<html>
<head>
<title>What Are the Different Ways to Clone an Object in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中克隆一个对象有哪些不同的方法？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-the-different-ways-to-clone-an-object-in-javascript-2e3e33527bd7?source=collection_archive---------23-----------------------#2021-08-12">https://javascript.plainenglish.io/what-are-the-different-ways-to-clone-an-object-in-javascript-2e3e33527bd7?source=collection_archive---------23-----------------------#2021-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce0693c275c923a0cd7bbebed5601eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*waX5EvAgvTT_zAfI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="46f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为开发人员，学无止境。我们总是需要与时俱进的技术，以及即将到来的或当前的市场趋势特征。</p><p id="a633" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些小文章不仅能帮助你编写更好的TypeScript或JavaScript代码，还能理清前端技术的概念。这不仅有助于你建立一个强大的基础，也有助于即将到来的前端面试。</p><p id="4060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何编程语言中最基本的主题之一就是摆弄对象。</p><p id="cd56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">当我们在组件中创建了一个对象时，我们可能需要在不止一个地方使用这个对象，为此，我们可能会一次又一次地更新同一个对象，这可能会破坏我们的逻辑。</strong></p><p id="e9b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">要解决这个问题，我们需要克隆一个对象来分配一个新的引用。让我们讨论一下克隆对象的有效方法。</em></p><p id="0f08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">我们先来了解一下</em> <strong class="kf ir"> <em class="lb">两个克隆中常见的</em> </strong> <em class="lb">术语。</em></p><blockquote class="lc ld le"><p id="63e0" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kf ir">浅抄</strong>抄收不准引用。</p><p id="8b71" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kf ir">深层拷贝</strong>拷贝一切。</p></blockquote><p id="3f6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了了解更多，在这个StackOverflow回答中，<a class="ae kc" href="https://stackoverflow.com/users/459/dlamblin" rel="noopener ugc nofollow" target="_blank"> dlamblin </a>很好地解释了这个问题。</p><p id="9bea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">浅显抄</strong>:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/1cb0ce85c22e25bd126e1f23d9999e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OePZ6fbda5lPENG_ZfFiQw.jpeg"/></div></div></figure><p id="8ee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变量a和B位于内存的两个不同部分。当我们把B赋值给A时，两者都指向同一个内存地址。现在，如果你对A或B做了任何改变，因为它们有相同的内存地址，默认情况下它们会被改变。</p><p id="eb88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">深度复制</strong>:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/d7ddb480e49aa60a67dbc9c647ef33a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vb1OasHzS2_fphish3mk0Q.jpeg"/></div></div></figure><p id="b93b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个副本中，你可以看到B被分配了一个新的内存地址。所以，如果我们改变A或B中的任何东西，都不会影响它们，它们的值是唯一的。</p><p id="680c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">亚历山大用更简单的方式解释道。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/87e2e519fc29473630320ae0c1e2d876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqM2H3EZh3afVTkmXbnmmg.jpeg"/></div></div></figure><h1 id="4133" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">1.本地方法(深层拷贝)</h1><p id="2459" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">最好也是最古老的克隆方式之一是使用JSON.stringify进行本地深度克隆。</p><p id="0f3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mv b">JSON.parse(JSON.stringify(object))</code></p><pre class="lj lk ll lm gt mw mv mx my aw mz bi"><span id="ed6b" class="na lq iq mv b gy nb nc l nd ne">const a = {<br/>  string: 'string',<br/>  number: 123,<br/>  bool: false,<br/>  nul: null,<br/>  date: new Date(),  // stringified<br/>  undef: undefined,  // lost<br/>  inf: Infinity,  // forced to 'null'<br/>  re: /.*/,  // lost<br/>}<br/>console.log(a);<br/>console.log(typeof a.date);  // Date object<br/>const clone = JSON.parse(JSON.stringify(a));<br/>console.log(clone);<br/>console.log(typeof clone.date);  // result of .toISOString()</span></pre><h1 id="1159" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.使用库的可靠克隆(深层拷贝)</h1><p id="f69f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们可以使用lodash库，例如:</p><ul class=""><li id="3d3a" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated">洛达什— <code class="fe ms mt mu mv b"><a class="ae kc" href="https://lodash.com/docs#cloneDeep" rel="noopener ugc nofollow" target="_blank">cloneDeep</a></code></li></ul><pre class="lj lk ll lm gt mw mv mx my aw mz bi"><span id="054a" class="na lq iq mv b gy nb nc l nd ne">var objects = [{ 'a': 1 }, { 'b': 2 }];</span><span id="bb77" class="na lq iq mv b gy no nc l nd ne">var deep = _.cloneDeep(objects);</span></pre><h1 id="8963" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">3.ES6(浅层拷贝)</h1><p id="e79f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">ES6提供了两种不同的克隆对象的方法，一种是Object.assign，另一种是spread操作符。</p><pre class="lj lk ll lm gt mw mv mx my aw mz bi"><span id="30b2" class="na lq iq mv b gy nb nc l nd ne">var data= {val: "string"};<br/>var newdata= Object.assign({}, data);<br/>var newdata3= {...data};  // Spread Operator</span></pre><p id="cc53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们检查一下性能矩阵。</p><p id="4c6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://jsben.ch/0HMc4" rel="noopener ugc nofollow" target="_blank">https://jsben.ch/0HMc4</a></p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/174f6a0d83300f0a843286dc3fa142ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*Xg22YShTjoX4kwa1o-SIhA.png"/></div></figure><p id="41da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">参考文献:</strong></p><div class="nq nr gp gr ns nt"><a href="https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">在JavaScript中深度克隆一个对象最有效的方法是什么？</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">HTML标准包括一个内部结构化克隆/序列化算法，可以创建…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">stackoverflow.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh jw nt"/></div></div></a></div><h1 id="f229" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">你可以在这里查看我以前的文章:</h1><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2faa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更多内容看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>