<html>
<head>
<title>The JavaScript Nobody Told You About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没人告诉你的JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-javascript-nobody-told-you-about-ac1bf4f56eb9?source=collection_archive---------1-----------------------#2021-10-25">https://javascript.plainenglish.io/the-javascript-nobody-told-you-about-ac1bf4f56eb9?source=collection_archive---------1-----------------------#2021-10-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/57d63a4124edfcb4962ec4fd2d37801f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VrsFi6WLoauCsGjagvpXuA.png"/></div></div></figure><p id="0f00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在大学生活的大部分时间里都在使用JVM语言，比如Java和Kotlin。具有讽刺意味的是，我大学毕业后的第一份工作是ReactJS开发人员。过去4年我害怕和逃避的语言现在就在我面前。我害怕JavaScript的原因主要是因为你也在这里。不容易理解为什么它会以这种方式工作。</p><p id="51c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">差不多一年半过去了，我现在感觉更自信了，希望你在读完这篇文章后也会如此。在这里，我指出了一些我敢肯定你从未想过JavaScript中存在的秘密。</p><h2 id="6740" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">虚伪的价值观</h2><p id="0e72" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><code class="fe lr ls lt lu b">undefined</code>、<code class="fe lr ls lt lu b">null</code>、<code class="fe lr ls lt lu b">0</code>、<code class="fe lr ls lt lu b">false</code>、<code class="fe lr ls lt lu b">NaN</code>、<code class="fe lr ls lt lu b">‘’</code>都是假值。你可能已经知道了，但是你知道空字符串也是假的吗？</p><p id="68ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">见下文。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="8dfa" class="kt ku in lu b gy md me l mf mg">console.log('' == false); // true<br/>console.log('' === false); // false</span></pre><h2 id="a496" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">滤波函数</h2><p id="ffa3" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">您一定在数组上经常使用<strong class="jx io"> filter </strong>函数。如果你想过滤数组中的虚假值，这里有一个提示。只需在过滤函数内部提供<strong class="jx io">布尔</strong>。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="ad3a" class="kt ku in lu b gy md me l mf mg">const arr = [1,4,undefined,null,9,NaN,10,''];<br/>console.log(arr.filter(<strong class="lu io">Boolean</strong>)); // [1,4,9,10]</span></pre><h2 id="9ef6" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">排序功能</h2><p id="923c" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">你对JavaScript中的<strong class="jx io">排序</strong>函数了解多少？它对数组进行排序，对吗？不完全是。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="92d2" class="kt ku in lu b gy md me l mf mg">const arr = [1,2,20,10,8];<br/>arr.sort(); // [1, 10, 2, 20, 8]<br/>arr.sort((a,b) =&gt; a-b); //[1,2,8,10,20]</span></pre><p id="41cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面第2行的输出看起来不像一个排序的数组。为什么？这是因为当我们调用不带参数的sort方法时，JavaScript <strong class="jx io">会将数组的元素转换成string </strong>然后按字母顺序排序。疯狂？我知道。</p><h2 id="49d9" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">交换</h2><p id="5c9c" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">很多时候，我有一个交换数组中两个元素或两个变量的用例。我曾经为此写过一个实用函数，但这里有一个JavaScript的方法。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="dce1" class="kt ku in lu b gy md me l mf mg"><strong class="lu io">Inside arrays<br/></strong>let arr = [1,2,3,4,5];<br/>[arr[4],arr[0]] = [arr[0],arr[4]];<br/>console.log(arr); //[5,2,3,4,1]</span><span id="98c0" class="kt ku in lu b gy mh me l mf mg"><strong class="lu io">Just two variables<br/></strong>let a = 10, b = 20;<br/>[a,b] = [b,a];<br/>console.log(a,b); // 20 10</span></pre><p id="b36d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是JavaScript中<strong class="jx io">析构</strong>的威力。虽然我使用析构很长时间了，但从来没有这样想过。</p><h2 id="52a3" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">微调功能</h2><p id="e52e" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">在许多编程语言中，我们在字符串上有一个<strong class="jx io"> trim </strong>方法来删除字符串中的任何空白。但是使用JavaScript trim并不能删除字符串中的所有空格。见下文。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="58f5" class="kt ku in lu b gy md me l mf mg">" shivam bhasin  ".trim(); // "shivam bhasin"<br/>"shivam bhasin".trim(); // "shivam bhasin"</span></pre><p id="512b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它<strong class="jx io">从你的字符串中移除所有的前导和尾随空格</strong>，但不是全部。这让我很困惑，因为我在Java中使用过字符串。</p><h2 id="a6cd" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">推送功能</h2><p id="a340" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我在代码中大量使用了push方法。虽然我最近才知道我们也可以使用push来合并数组。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="1bb2" class="kt ku in lu b gy md me l mf mg">const a = [1,2];<br/>const b = [3,4];<br/>a.push(b); // [1,2,[3,4]] <strong class="lu io">not merged</strong><br/>Array.prototype.push.apply(a,b); // [1,2,3,4] <strong class="lu io">merged</strong></span></pre><p id="db5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的第4行中，合并后的数组将在<strong class="jx io">变量a </strong>中。</p><h2 id="d520" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">isNaN函数</h2><p id="4d10" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><code class="fe lr ls lt lu b">isNaN</code>也是JavaScript中最常用的方法之一。它检查给定的参数是否是一个数字。但是对于空字符串和填充字符串，它的行为是不同的。见下文。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="0cab" class="kt ku in lu b gy md me l mf mg">isNaN(1); // false<br/>isNaN(""); // false<br/>isNaN("a"); // true<br/>isNaN("1"); // false</span></pre><p id="fd8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能很清楚第1行，1是一个数字，因此它返回false。但是在第2行，JavaScript将空字符串<strong class="jx io">视为0，</strong>是一个数字，因此没有通过NaN测试。第3行也应该清楚，因为“a”是一个字符串，因此不是一个数字。同样，在第4行“1”是一个字符串，但是JavaScript在内部<strong class="jx io">将其解析为数字1 </strong>，因此它没有通过NaN测试。很奇怪，对吧？了解这一点后，我开始在将参数传递给<code class="fe lr ls lt lu b">isNaN</code>函数之前对它们使用<code class="fe lr ls lt lu b">parseInt()</code>。</p><h2 id="de6f" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">对象的动态关键点</h2><p id="dbe0" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">有时我不得不根据API响应或某种计算给我的对象分配动态键。我们可以这样做。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="eff2" class="kt ku in lu b gy md me l mf mg">const a = "age";<br/>const b = {<br/>     name: 'shivam',<br/>     [a]: 22, // this will become <strong class="lu io">age: 22</strong> at runtime<br/>};</span></pre><h2 id="2608" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">拼接和切片</h2><p id="8f20" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">差不多3个月后，我意识到<code class="fe lr ls lt lu b">slice</code>和<code class="fe lr ls lt lu b">splice</code>是JavaScript中不同的方法。Lol我知道。以下是它们的不同表现。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="a882" class="kt ku in lu b gy md me l mf mg"><strong class="lu io">slice(s,e);<br/></strong>Here s is the starting index and end is the end index of the new array which will be a sub-array of the original array. <strong class="lu io">Note that the original array will not be changed when using slice.</strong></span><span id="dd3b" class="kt ku in lu b gy mh me l mf mg"><strong class="lu io">splice(i,n);<br/></strong>Here i denotes the starting index and n denotes the number of items to be removed starting from index i.<strong class="lu io"> Note that splice will alter the original array.</strong></span></pre><h2 id="e858" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">浮点数</h2><p id="1626" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">这几乎是难以置信的，但和我呆在一起。浮点数的加法在JavaScript中表现得非常怪异。见下文。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="2ee6" class="kt ku in lu b gy md me l mf mg">console.log(0.1+0.2 === 0.3); // false</span></pre><p id="c700" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为<code class="fe lr ls lt lu b">0.1+0.2</code>给出的<code class="fe lr ls lt lu b">0.30000000000000004</code>不等于<code class="fe lr ls lt lu b">0.3</code>。还有，</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="244a" class="kt ku in lu b gy md me l mf mg">console.log(9007199254740992 + 1); // 9007199254740992  <br/>console.log(9007199254740992 + 2); // 9007199254740994</span></pre><p id="1338" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这看起来很奇怪，直到我知道根据IEEE 754标准，所有的JavaScript数字都是用64位二进制内部表示的浮点数。你可以在这里阅读更多相关信息<a class="ae mi" href="https://2ality.com/2012/04/number-encoding.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="eb48" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">运算符的类型</h2><p id="c3fb" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><code class="fe lr ls lt lu b">typeOf</code>是一个一元运算符，返回一个表示变量原始类型的字符串。我们知道JavaScript大部分是对象，所以在大多数情况下，这会返回<code class="fe lr ls lt lu b">object</code>。这里有几个奇怪的例外。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="d8ce" class="kt ku in lu b gy md me l mf mg">typeOf NaN; // 'number'</span></pre><p id="59ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lu b">typeOf</code> NaN是一个看起来很奇怪的数字，但是<code class="fe lr ls lt lu b">NaN</code>在技术上是一个数字数据类型。但是，它是一种数值数据类型，其值不能用实际数字表示。见下文。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="6100" class="kt ku in lu b gy md me l mf mg">const nan1 = 2*'a'; // NaN<br/>const nan2 = 4*'b'; // NaN<br/>nan1 === nan2; // false</span></pre><p id="a846" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，<code class="fe lr ls lt lu b">nan1</code>和<code class="fe lr ls lt lu b">nan2</code>都不相等，这意味着它们拥有一些值。只是价值不能用数字来表示，所以它们是NaN。看到另一个异常，</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="e8f4" class="kt ku in lu b gy md me l mf mg">typeOf null; // 'object'</span></pre><p id="ad8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你在这里成功了，那就太棒了。大多数人在这之前就结束了。但是你对它了解得越多，你就越能意识到这个世界头号编程语言是如何工作的。</p><p id="cfb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是给你的临别赠言。</p><h2 id="ea37" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">原始操作&gt;方法</h2><p id="3ec1" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">如果你想让你的代码更快，那么试着使用原始操作而不是方法调用。尽可能使用VanillaJS，它会让你的代码在运行时更快。见下文。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="fc89" class="kt ku in lu b gy md me l mf mg">const min = Math.min(a,b); // slow<br/>const min = a&lt;b? a: b; // fast</span><span id="2396" class="kt ku in lu b gy mh me l mf mg">arr.push(x); // slow<br/>arr[arr.length] = x; // fast</span></pre><p id="59a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望你今天学到了新东西。在下面写下你已经知道了多少。此外，如果你认为有什么东西应该在这个列表上，请发表评论。</p><p id="903b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让你内心的极客赢吧！</p><p id="33d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mj">更多内容尽在</em><a class="ae mi" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>