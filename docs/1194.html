<html>
<head>
<title>How to Build a Real-Time Search Bar With RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用RxJS构建实时搜索栏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-real-time-search-bar-with-rxjs-4dd39f69f704?source=collection_archive---------5-----------------------#2021-03-13">https://javascript.plainenglish.io/how-to-build-a-real-time-search-bar-with-rxjs-4dd39f69f704?source=collection_archive---------5-----------------------#2021-03-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3118" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">简单而有效HTTP呼叫的搜索引擎。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fbdd79501ce32ecdc0af0f84aac682ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PVk34MALRt1SKP4-9Hjyg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@cgower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Christopher Gower</a> on <a class="ae ks" href="/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="da4b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将使用<a class="ae ks" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>构建一个功能丰富的搜索栏，返回实时结果。如果你以前从未使用过RxJS，这将是一个很好的介绍。您将看到RxJS库如何将一组相当复杂的需求转化为易于管理、易于阅读和理解的代码。</p><p id="e27d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在现代应用程序中很常见的一种情况是，您必须构建一个搜索栏，允许用户搜索数据库的一部分，如果不是全部的话。</p><p id="5133" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们所说的实时搜索栏或搜索引擎，每次搜索都需要向服务器发出请求并返回结果。众所周知，不断调用服务器对我们的应用程序性能不利。我们不知道用户会敲多少次键盘，向服务器发出不必要的请求。因此，像搜索栏这样常见的东西需要进行各种检查。</p><p id="3a58" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们开始吧。</p><h2 id="e76b" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">第一步:设置</h2><p id="c31a" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">对于这个例子，我只是使用了一个简单的JavaScript项目。</p><p id="5bdf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们有两个对主元素的引用，一个用于搜索输入，另一个用于我们将要加载结果的div元素。</p><p id="7b1f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了将我们的输入事件转化为可观察的序列，我们使用了<code class="fe mn mo mp mq b"><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/index/function/fromEvent" rel="noopener ugc nofollow" target="_blank">fromEvent()</a></code> <a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/index/function/fromEvent" rel="noopener ugc nofollow" target="_blank">操作符</a>，并将我们的搜索输入作为目标。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="72cf" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">第二步:最少搜索词</h2><p id="6199" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">RxJS的好处是我们可以将操作符链接在一起，就像我们可以将数组方法链接在一起一样。Observables有一个叫做<code class="fe mn mo mp mq b"><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/index/function/pipe" rel="noopener ugc nofollow" target="_blank">pipe()</a></code>的方法，它允许我们完成这个链，同时也易于阅读。</p><p id="80fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">咱们顺水推舟用<a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/pluck" rel="noopener ugc nofollow" target="_blank"/><code class="fe mn mo mp mq b"><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/pluck" rel="noopener ugc nofollow" target="_blank">pluck</a></code><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/pluck" rel="noopener ugc nofollow" target="_blank">符</a>。这允许我们映射源值(输入的返回对象)并挑选出我们感兴趣的嵌套属性。正如您在这里看到的，我们正在获取嵌套在输入返回对象中的<code class="fe mn mo mp mq b">target</code>对象中的<code class="fe mn mo mp mq b">value</code>属性。</p><p id="2f7a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果是一个需要搜索的大型数据库，那么下一个操作符非常重要，这一步是设置一个搜索项最小值。在这里，我将设置搜索词的最小值为3个字符，任何少于3个字符的内容都不会返回相关结果。我们将使用<code class="fe mn mo mp mq b"><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/filter" rel="noopener ugc nofollow" target="_blank">filter</a></code> <a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/filter" rel="noopener ugc nofollow" target="_blank">操作符</a>来设置最小值，并将长度条件设置为大于2。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="9c97" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">第三步:去抖时间</h2><p id="c30f" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">让我们开始减轻服务器上的一些负载。为了确保请求只在500 ms的间隔内发送，我们可以使用<code class="fe mn mo mp mq b"><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/debounceTime" rel="noopener ugc nofollow" target="_blank">debounceTime</a></code> <a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/debounceTime" rel="noopener ugc nofollow" target="_blank">操作符，</a>允许我们控制用户输入的速率。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="c705" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">第四步:区分时间变化</h2><p id="75eb" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们现在想要减少发送的API调用的数量。要做到这一点，我们希望应用程序忽略搜索词，如果自上次API调用以来没有任何变化。例如，用户可能键入“侏罗纪P”，然后键入“侏罗纪”，然后再次键入“侏罗纪P”。<code class="fe mn mo mp mq b"><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/distinctUntilChanged" rel="noopener ugc nofollow" target="_blank">distinctUntilChange()</a></code> <a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/distinctUntilChanged" rel="noopener ugc nofollow" target="_blank"> </a>将非常适合这种情况，它将记住之前通过流传递的数据，并且只有在不同的情况下才会继续流。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="812d" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">步骤5:查询API</h2><p id="9d35" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">现在我们需要添加查询API的代码。说到多个可观测流，<code class="fe mn mo mp mq b"><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/switchMap" rel="noopener ugc nofollow" target="_blank">switchMap</a></code>应该是你的首选。这被视为扁平化最安全的默认设置，它切换到一个新的可观察对象，同时取消之前的内部可观察对象，确保响应按顺序返回。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1373" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mn mo mp mq b"><a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/catchError" rel="noopener ugc nofollow" target="_blank">catchError()</a></code> <a class="ae ks" href="https://rxjs-dev.firebaseapp.com/api/operators/catchError" rel="noopener ugc nofollow" target="_blank">操作符</a>将接收错误和捕捉到错误的可观察值(如果您希望重试)。这里，我们在由我们的<code class="fe mn mo mp mq b">switchMap()</code>操作符返回的<code class="fe mn mo mp mq b">ajax</code>可观察值上捕捉错误，因为我们不希望整个<code class="fe mn mo mp mq b">input$</code>流在错误的情况下被完成。</p><p id="e8d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe mn mo mp mq b">catchError</code>中是你想要放置错误处理代码的地方。对于这个例子，我只是通过控制台记录错误，并返回一个空的可观察值，这允许流在不发出任何值的情况下完成。</p><h2 id="74bc" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">步骤6:激活并更新DOM</h2><p id="3177" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">最后一步是用订阅激活一切并更新DOM。为了做到这一点，我们使用了<code class="fe mn mo mp mq b">subscribe</code>操作符，使观察者能够看到被观察对象发出的数据事件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="530b" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">第7步:可选附加组件。</h2><p id="08b6" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">值得一提的是，你应该始终记住，更新DOM可能是一项资源密集型操作，因此减少更新DOM的次数将对你的应用程序的性能产生积极的影响。</p><p id="c479" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据用户的情况和服务器结果的响应，添加一个<code class="fe mn mo mp mq b">filter</code>或<code class="fe mn mo mp mq b">distinctUntilChanged</code>操作符有助于减少DOM更新的次数。</p><p id="3c7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">类似这样的东西👇</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="88f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一次，我们<strong class="kv io">而不是</strong>使用<code class="fe mn mo mp mq b">distinctUntilChanged</code>操作符来查看整个数据是否已经更改(就像我们对输入值所做的那样)。比较整个响应将等于糟糕的性能和次优的用户体验，这将是一个非常繁重的操作，所以相反，我们比较响应的<code class="fe mn mo mp mq b">key</code>属性。</p><p id="09bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这两个值匹配的情况下(先前的响应和新的响应),数据被过滤掉，并且不沿着可观察的流传递。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h2 id="4c14" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">结论</h2><p id="b2fa" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这就是了。有了这个解决方案，您就拥有了一个可靠的、功能丰富的实时搜索栏，旨在提供卓越的性能和卓越的用户体验。RxJS操作符的易用性和将操作符链接在一起的能力意味着您可以轻松地在上面的解决方案中删除或添加操作符，以满足您的应用程序需求。</p><p id="cf23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你是RxJS的新手，你可能会开始意识到这个库有多强大，它会给你的下一个项目带来多大的帮助。</p><h2 id="6edf" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">源代码</h2><p id="df12" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">💻<a class="ae ks" href="https://github.com/MeganRook18/real-time-search-engine" rel="noopener ugc nofollow" target="_blank">GitHub上的示例代码</a>。<br/>🏃‍♀️ <a class="ae ks" href="https://stackblitz.com/edit/real-time-search-bar-rxjs" rel="noopener ugc nofollow" target="_blank">在StackBlitz上运行代码。</a></p><p id="0392" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我用过的算子你都同意吗？您会添加更多还是使用不同的运算符？请随时留下你的想法。</p><p id="5220" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">快乐编码。</p></div></div>    
</body>
</html>