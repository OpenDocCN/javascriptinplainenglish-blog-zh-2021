<html>
<head>
<title>Getting Started with Socket.IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">套接字入门。超正析象管(Image Orthicon)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-socket-io-fe8c7d404b9b?source=collection_archive---------6-----------------------#2021-07-24">https://javascript.plainenglish.io/getting-started-with-socket-io-fe8c7d404b9b?source=collection_archive---------6-----------------------#2021-07-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/57880c1831cbf34de6f96b5a9e0202e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cArTHQEHnSOvK0uieO_trg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae jz" href="https://unsplash.com/s/photos/socket?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8b91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多年来，当我需要“实时”更新时，我让我的web应用程序轮询各种端点…老实说，这只是因为我不知道有什么更好的。</p><p id="a354" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你可能想象的那样，随着时间的推移，这产生了大量的问题。我的服务器收到了大量不必要的请求，这些轮询请求不时会超时或返回错误，破坏了用户体验(有时用户甚至不知道)。</p><p id="995d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个客户最近在重新设计管理面板时要求一堆实时数据，所以我决定寻找一个更好的解决方案，并找到了<a class="ae jz" href="https://socket.io" rel="noopener ugc nofollow" target="_blank"> Socket。IO </a>！</p><h1 id="22f4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是插座。木卫一？</h1><p id="4ce8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在我看来，最简单的方法就是将它视为一种广播和监听服务器和客户端之间事件的方式——例如，就像你监听web应用前端的按钮点击一样。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/31ea08046116ed5f2a8abad00a903d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oV8F-DAHI8UmA3-o-T_07A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image from <a class="ae jz" href="https://socket.io/docs/v4/index.html" rel="noopener ugc nofollow" target="_blank">socket.IO docs</a></figcaption></figure><p id="483c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">具体来说，从他们的网站:</p><blockquote class="mg mh mi"><p id="5ab3" class="ka kb mj kc b kd ke kf kg kh ki kj kk mk km kn ko ml kq kr ks mm ku kv kw kx ig bi translated">插座。IO支持实时、双向和基于事件的通信。<br/>它可以在任何平台、浏览器或设备上运行，同样注重可靠性和速度。</p></blockquote><h1 id="a897" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我为什么需要这个？</h1><p id="e891" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">关于实时客户端-服务器通信，有很多<em class="mj">吨</em>的用例，但这里是我使用它的一些方式，以及一些其他想法:</p><ul class=""><li id="3eee" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">当有新的文字信息进来时，立即更新聊天界面(另外利用<a class="ae jz" href="https://www.twilio.com/docs/usage/webhooks" rel="noopener ugc nofollow" target="_blank"> Twilio webhooks </a></li><li id="2a32" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">重要用户交互的通知，如联系人表单提交</li><li id="0937" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">实时分析图表</li><li id="a017" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">各种数据的报价器，如股票、追随者数量等。</li><li id="91fd" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">协作文档应用，如<a class="ae jz" href="https://docs.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌文档</a>或<a class="ae jz" href="https://codeshare.io" rel="noopener ugc nofollow" target="_blank">代码共享</a></li></ul><h1 id="1e3b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我确信。让我们开始建设吧！</h1><p id="7ce6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">太棒了。🙌</p><p id="bea4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程中，我们将创建一个简单的Node.js/Express.js应用程序，让用户提交包含用户名和消息的“评论”，并提供实时更新的“提要”。请随意复制下面的starter项目并直接跟随，或者跳过一点点进入使用socket.IO的内容。</p><p id="dcf1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您使用的是Node.js以外的框架:这里介绍的客户端代码和服务器端概念仍然完全适用。检查<a class="ae jz" href="https://socket.io/docs/v4/index.html" rel="noopener ugc nofollow" target="_blank">插座。IO docs </a>中的其他语言&amp;框架中社区维护的实现列表。</p><h1 id="ff90" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">这个计划</h1><p id="5259" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在我开始写代码之前，我总是喜欢画出(至少在心里)我的应用程序将会做什么。这个很简单:</p><ul class=""><li id="b37a" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">带有提交新评论的表单和显示所有评论的提要的用户界面</li><li id="edea" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">可以处理新评论提交并向客户端发送“新评论”事件的后端</li></ul><h1 id="f28c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">启动项目</h1><p id="3d50" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">起始项目位于GitHub 上的<a class="ae jz" href="https://github.com/adboio/socket-io-starter" rel="noopener ugc nofollow" target="_blank">处。您可以使用以下命令克隆它:</a></p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="21ab" class="ng kz in nc b gy nh ni l nj nk">git clone <a class="ae jz" href="https://github.com/adboio/socket-io-starter.git" rel="noopener ugc nofollow" target="_blank">https://github.com/adboio/socket-io-starter.git</a></span></pre><p id="3fe3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在您最喜欢的文本编辑器中打开它，您会注意到在<code class="fe nl nm nn nc b">routes/index.js</code>中设置了两条路线:</p><ol class=""><li id="c736" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx no mt mu mv bi translated"><code class="fe nl nm nn nc b">GET /</code>用于呈现带有评论流的简单用户界面</li><li id="5557" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx no mt mu mv bi translated"><code class="fe nl nm nn nc b">POST /</code>提交新评论</li></ol><p id="d749" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了确保正常工作，安装依赖项并启动节点服务器:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="8e0f" class="ng kz in nc b gy nh ni l nj nk">cd socket-io-starter<br/>npm install<br/>npm start</span></pre><p id="73a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…然后在浏览器中导航到localhost:3000。您应该会看到类似这样的内容:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/03042efac355af441a25ab6e7a2b8123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzmaJH_I21pfdSvYMjRCww.png"/></div></div></figure><p id="dff6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过填写表格并单击“提交”来测试意见提交。现在还不会发生什么，但是在终端中，您应该能够看到一个成功的200响应被发送回客户端，并且您的请求主体被记录下来(带有一个<code class="fe nl nm nn nc b">username</code>和<code class="fe nl nm nn nc b">comment</code>)。</p><p id="2725" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果有任何问题，退出节点服务器(<code class="fe nl nm nn nc b">ctrl+c</code>)，确保安装了所需的依赖项(<code class="fe nl nm nn nc b">npm install</code>)，然后重启服务器(<code class="fe nl nm nn nc b">npm start</code>)。如果这不起作用，请在下面留言，我会尽我所能帮助你！</p><h1 id="cece" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">安装插座。超正析象管(Image Orthicon)</h1><p id="9175" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">安装非常简单:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="ad57" class="ng kz in nc b gy nh ni l nj nk">npm install socket.io</span></pre><p id="6905" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们需要将它包含在我们的应用程序中，以便从所有潜在的路线轻松访问。一种简单的方法是定义套接字。IO客户机作为我们的<code class="fe nl nm nn nc b">app</code>对象的属性，然后将它附加到http服务器。我保证，这听起来比实际更复杂！注意下面<strong class="kc io">粗体</strong>中的新行。</p><p id="45a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nl nm nn nc b">app.js</code>:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="09a7" class="ng kz in nc b gy nh ni l nj nk">// initialize the express app<br/>var app = express();</span><span id="4169" class="ng kz in nc b gy nq ni l nj nk">// add this line to initialize the socket.IO client, and set it as our app's `io` property<br/><strong class="nc io">app.io = require('socket.io')();</strong></span></pre><p id="2886" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nl nm nn nc b">bin/www</code>:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="a2c5" class="ng kz in nc b gy nh ni l nj nk">// create the http server<br/>var server = http.createServer(app);</span><span id="71c5" class="ng kz in nc b gy nq ni l nj nk">// add this line to attach the server to our socket.IO client<br/><strong class="nc io">app.io.attach(server);</strong></span></pre><p id="220b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，在我们应用程序的任何地方，我们都可以访问套接字。通过简单引用<code class="fe nl nm nn nc b">req.app.io</code> ⚡️的IO客户端</p><h1 id="02c2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从服务器发出事件</h1><p id="a862" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">看一下<code class="fe nl nm nn nc b">index.js</code>里面的<code class="fe nl nm nn nc b">POST /</code>路线。现在，它所做的只是记录请求的主体，并向客户端发送200响应。相反，让它在请求进来时发出一个<code class="fe nl nm nn nc b">new comment</code>事件。</p><p id="d7ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">发出事件的语法如下所示:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="c4b4" class="ng kz in nc b gy nh ni l nj nk">req.app.io.emit('event name', eventData);</span></pre><p id="588f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用这个语法在发送回200响应之前发出一个包含评论的用户名和消息的<code class="fe nl nm nn nc b">new comment</code>事件。</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="ad41" class="ng kz in nc b gy nh ni l nj nk">router.post('/', (req, res, next) =&gt; {</span><span id="b29f" class="ng kz in nc b gy nq ni l nj nk">  console.log(req.body);</span><span id="d169" class="ng kz in nc b gy nq ni l nj nk"><strong class="nc io">  req.app.io.emit('new comment', {<br/>    username: req.body.username,<br/>    comment: req.body.comment<br/>  });</strong></span><span id="2ccd" class="ng kz in nc b gy nq ni l nj nk">  return res.sendStatus(200);</span><span id="f2a6" class="ng kz in nc b gy nq ni l nj nk">}</span></pre><p id="dda9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重新启动服务器，并尝试再次提交评论。从视觉上看，什么都没有改变，但是如果您仍然在终端中看到200响应，那么您就在正确的轨道上。</p><p id="5389" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">前进！🚀</p><h1 id="66cc" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">监听前端的事件</h1><p id="8ddc" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">这是真正有趣的地方，✨</p><p id="9491" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们将包括插座。在我们的视图(<code class="fe nl nm nn nc b">views/index.ejs</code>)中，就在结束的<code class="fe nl nm nn nc b">&lt;/body&gt;</code>标记之前，创建一个新的<code class="fe nl nm nn nc b">io</code>对象，在紧接着的新脚本标记中称为<code class="fe nl nm nn nc b">socket</code>。您可以<a class="ae jz" href="https://socket.io/docs/v4/client-installation/" rel="noopener ugc nofollow" target="_blank">下载这个库</a>并将其存储在您服务器上的某个地方，或者只是从CDN中包含它，如下所示:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="3aa6" class="ng kz in nc b gy nh ni l nj nk">  &lt;!-- start writing your socket code below! --&gt;</span><span id="03c5" class="ng kz in nc b gy nq ni l nj nk"><strong class="nc io">  &lt;script src="https://cdn.socket.io/4.1.2/socket.io.min.js" integrity="sha384-toS6mmwu70G0fw54EGlWWeA4z3dyJ+dlXBtSURSKN4vyRFOcxd3Bzjj/AoOwY+Rg" crossorigin="anonymous"&gt;&lt;/script&gt;</strong></span><span id="de2c" class="ng kz in nc b gy nq ni l nj nk"><strong class="nc io">  &lt;script&gt;<br/>    let socket = io();<br/>  &lt;/script&gt;</strong></span><span id="5919" class="ng kz in nc b gy nq ni l nj nk">&lt;/body&gt;</span></pre><p id="4b1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了监听来自服务器的事件，我们将使用一些熟悉的类似jQuery的事件监听器语法:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="f750" class="ng kz in nc b gy nh ni l nj nk">socket.on('event name', (data) =&gt; {/* do something */});</span></pre><p id="6531" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回想一下，我们的服务器发出一个名为<code class="fe nl nm nn nc b">new comment</code>的事件。出于测试目的，以及快速增加血清素，让我们编写一个快速事件侦听器，将事件数据记录到控制台:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="7e66" class="ng kz in nc b gy nh ni l nj nk">&lt;script&gt;<br/>  let socket = io();<br/>  <br/><strong class="nc io">  socket.on('new comment', (data) =&gt; {<br/>    console.log(data);<br/>  });<br/></strong>&lt;/script&gt;</span></pre><p id="3de3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">刷新页面，在浏览器中打开开发控制台(通常通过右键单击并选择“检查元素”，然后找到“控制台”选项卡)，然后提交新的评论。几乎在提交之后，您会立即看到控制台中记录的事件数据。大获成功！！🎊我们差不多完成了。</p><h1 id="43b6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更新新事件的评论源</h1><p id="52e0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">有很多方法可以做到这一点——请记住，下面介绍的方法并不是最容易维护的，可能不太适合您的项目的基础设施，但是对于演示来说，它非常有用😄</p><p id="30a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">starter项目在视图中有一些硬编码的注释，在<code class="fe nl nm nn nc b">#comments</code> div中。它们看起来像这样:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="0c63" class="ng kz in nc b gy nh ni l nj nk">&lt;div class="comment"&gt;<br/>  &lt;div class="message"&gt;bro, socket.IO is fire 🔥&lt;/div&gt;<br/>  &lt;div class="username"&gt;adboio&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="71b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当<code class="fe nl nm nn nc b">new comment</code>事件到来时，我们希望创建这些<code class="fe nl nm nn nc b">div.comment</code>元素中的另一个，用用户提交的内容填充，并将其添加到现有的评论列表中。</p><p id="d549" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以这样做:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="7031" class="ng kz in nc b gy nh ni l nj nk">&lt;script&gt;<br/>  let socket = io();<br/>  <br/>  socket.on('new comment', (data) =&gt; {<br/>    console.log(data);</span><span id="5ac2" class="ng kz in nc b gy nq ni l nj nk"><strong class="nc io">    let newComment = `<br/>      &lt;div class="comment"&gt;<br/>        &lt;div class="message"&gt;${data.message}&lt;/div&gt;<br/>        &lt;div class="username"&gt;${data.username}&lt;/div&gt;<br/>      &lt;/div&gt;`;<br/>    <br/>    $('#comments').prepend(newComment);<br/>  <br/>  </strong>});<strong class="nc io"><br/></strong>&lt;/script&gt;</span></pre><blockquote class="mg mh mi"><p id="2a2f" class="ka kb mj kc b kd ke kf kg kh ki kj kk mk km kn ko ml kq kr ks mm ku kv kw kx ig bi translated">如果你不熟悉JavaScript模板文字(上面反勾<code class="fe nl nm nn nc b">`</code>中的字符串)，MDN文档有一个很好的解释。基本上，它们允许我们编写包含变量的字符串，如下所示:</p></blockquote><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="d2a2" class="ng kz in nc b gy nh ni l nj nk">let message = `Welcome, ${userName}!`;</span></pre><blockquote class="mg mh mi"><p id="846f" class="ka kb mj kc b kd ke kf kg kh ki kj kk mk km kn ko ml kq kr ks mm ku kv kw kx ig bi translated">…而不是像这样连接字符串和变量:</p></blockquote><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="5808" class="ng kz in nc b gy nh ni l nj nk">let message = 'Welcome, ' + userName + '!';</span></pre><h1 id="15ed" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">现在，我们期待已久的时刻到了</h1><p id="20fd" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">刷新您的页面，在第二个窗口中打开应用程序，这样您就可以看到奇迹发生了。在一个窗口中，输入新的注释，然后检查它😍</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/cb37a75636d72b7503bdc5e4a0b74d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KB1vVGt9_CJ8bPYPVcu7Rg.gif"/></div></div></figure><h1 id="1a02" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">恭喜你！🎉</h1><p id="07b2" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">花一秒钟拍拍自己的背，承认这个配音👊</p><p id="ab95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，我意识到这个应用程序并不是最有用的……但是你已经成功地构建了一个全功能的web应用程序，它利用了通过Socket.IO实现的实时客户端-服务器通信。！</p><h2 id="df66" class="ng kz in bd la ns nt dn le nu nv dp li kl nw nx lm kp ny nz lq kt oa ob lu oc bi translated">解决纷争</h2><p id="9de9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果你在本教程中遇到了任何问题，请在下面留下你的评论，我会尽我所能帮助你。此外，如果您想参考，可以在GitHub上找到完整项目的源代码:</p><p id="00a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">https://github.com/adboio/socket-io-tutorial<a class="ae jz" href="https://github.com/adboio/socket-io-tutorial" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="d615" class="ng kz in bd la ns nt dn le nu nv dp li kl nw nx lm kp ny nz lq kt oa ob lu oc bi translated">后续步骤</h2><p id="bc88" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">接下来你要做什么完全取决于你，但是这里有一些关于我如何使用Socket的细节。生产应用中的IO:</p><ul class=""><li id="66e5" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">我设置了一个端点来接收传入SMS消息的Twilio webhooks，并将它们存储在数据库中。在这个端点中，在将成功的响应发送回Twilio之前，我发出一个<code class="fe nl nm nn nc b">new message</code>事件，其中包含关于发送者的一些信息，以及一些其他细节:</li></ul><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="d120" class="ng kz in nc b gy nh ni l nj nk">req.app.io.emit('new message', {<br/>  'user': {<br/>    'name': `${user.firstName} ${user.lastName},<br/>    'id': user.id<br/>  },<br/>  'body': body,<br/>  'prettyTime': moment.tz(new Date(), 'America/Los_Angeles').format('MMM D [at] h:mm a')<br/>});</span></pre><p id="b2cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…然后我在前端监听这个事件，构建一个新的消息元素，并使用<a class="ae jz" href="https://github.com/xrr2016/tata" rel="noopener ugc nofollow" target="_blank"> tata.js </a>为每个新消息显示一个通知:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="c9c0" class="ng kz in nc b gy nh ni l nj nk">socket.on('new message', function(msg) {<br/>  $('#unreads').prepend(createUnread(msg));<br/>  tata.success('New message!', `from ${msg.user.name}`);<br/>});</span></pre><ul class=""><li id="b38e" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">当管理员用户打开SMS对话线程时，会调用一个端点来将该线程中的所有消息标记为“已读”。在这个端点中，我触发了一个名为<code class="fe nl nm nn nc b">read messages</code>的事件:</li></ul><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="164e" class="ng kz in nc b gy nh ni l nj nk">req.app.io.emit('read messages', userId);</span></pre><p id="2010" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…在前端，我可以监听此事件，并从未读邮件列表中删除这些线索:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="3b88" class="ng kz in nc b gy nh ni l nj nk">socket.on('read messages', function(userId) {<br/>  $('#unreads').find(`tr[data-user-id="${userId}"]`).remove();<br/>});</span></pre><h2 id="e472" class="ng kz in bd la ns nt dn le nu nv dp li kl nw nx lm kp ny nz lq kt oa ob lu oc bi translated">你在建造什么？</h2><p id="422d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">最后，我喜欢听别人在做什么——请在评论中告诉我你打算如何使用socket。IO在你的下一个项目中！👋下次见！</p><h1 id="2d39" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a673" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">点击此处获取所有代码:</p><ul class=""><li id="a185" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">首发项目:<a class="ae jz" href="https://github.com/adboio/socket-io-starter" rel="noopener ugc nofollow" target="_blank">https://github.com/adboio/socket-io-starter</a></li><li id="37ba" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">最终项目:<a class="ae jz" href="https://github.com/adboio/socket-io-tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/adboio/socket-io-tutorial</a></li></ul><p id="922c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mj">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>