<html>
<head>
<title>React Rendering Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化反应渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-rendering-put-simply-c1d090df28ed?source=collection_archive---------13-----------------------#2021-10-15">https://javascript.plainenglish.io/react-rendering-put-simply-c1d090df28ed?source=collection_archive---------13-----------------------#2021-10-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4739c2d618bcd4945d57460165cf3b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgEtdEP59ISaExWLktIjtQ.png"/></div></div></figure><p id="9340" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将是对React渲染的一个生硬粗暴的浓缩，只剩下它的几个重要属性。</p><h2 id="3009" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">一切都不变。</h2><p id="ea64" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我暂时忽略裁判。它们是一个有用的窍门，但会妨碍基本的理解。从主函数开始到结束，没有任何变化。从上到下，属性和状态应该被视为不变的。如果您在当前运行中需要不同的值，请创建新的常量来导出您需要的值。</p><p id="3e2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设置状态不会改变这个事实。调用<code class="fe lr ls lt lu b">useState</code>的setter不会改变main函数当前运行的值。该函数会一直使用旧值。</p><p id="e28e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设置器<em class="lv">告诉</em>用新值从头到尾重新运行整个组件。这些值将再次保持不变…但会有更新的值。</p><h2 id="9937" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">组件不创建输出。</h2><p id="af29" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">他们创建关于输出应该是什么的指令。很容易将JSX误认为最终产品，因为它看起来像HTML。但是组件真正做的是输出指令来做出反应。它告诉React调用其他组件并最终创建HTML，但实际上并不是在组件内部创建HTML。您正在创建反应元素。</p><p id="c7ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么这很重要？至于为什么不能在主组件函数中访问DOM，这更有意义。主要的组件功能不是构建DOM，而是告诉React <em class="lv">如何</em>构建DOM。还没有DOM。这让我想到了下一个问题。</p><h2 id="e030" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">如果你需要用浏览器做一些事情，在一个效果或者一个事件处理器中做。</h2><p id="84bd" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">React从应用程序的顶部开始，一路向下，收集组件的所有输出。然后，它找出需要更改的内容，最后更新HTML以反映您的应用程序应该如何更新。</p><p id="9ba9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当React运行effects时，它基本上是在说，“好了，网页已经准备好让你操作了。”通过在效果中进行DOM访问和操作，您可以确保在浏览器中对最新的代码进行操作。如果你需要改变事件监听器中的一些东西，那也是完全合法的。事件侦听器直接绑定到DOM，当它们触发时，它们会针对网页触发。React在那些火的时候已经渲染好了。</p><p id="a8c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是最基本的。还有更多，与管理状态和效果依赖的方法有关，但希望这有助于思考React如何渲染和使用状态和道具。</p><p id="2153" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lv">更多内容请看</em><a class="ae lw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>