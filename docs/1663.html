<html>
<head>
<title>Grokking Closure in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的闭包</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/grokking-closure-in-javascript-7e8194924398?source=collection_archive---------19-----------------------#2021-04-09">https://javascript.plainenglish.io/grokking-closure-in-javascript-7e8194924398?source=collection_archive---------19-----------------------#2021-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c6d0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用简单的英语理解闭包</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/750dc2db475e1ecaafad55745c5469ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXh6TEwRX2Xe0Xgw_u-TEg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.twitter.com/tweetsbysoma" rel="noopener ugc nofollow" target="_blank">🎨</a></figcaption></figure><blockquote class="kw kx ky"><p id="a05a" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">本文是系列文章的第二部分，我们将探讨闭包的起源、幕后工作、现实生活中的用法以及与闭包相关的面试问题。</p></blockquote><p id="651a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">欢迎阅读本文的第二部分——我们将探究闭包以及它们如何工作的内在机制。许多人觉得闭包的概念很难理解。但是一旦你知道引擎盖下发生了什么，事情就不一样了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/dddc645ae1b601e30c6e743a197eefc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4ENPF03Ze2L71gryrRFWA.png"/></div></div></figure><p id="d399" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">理解闭包会对你编写和理解代码的方式产生重大影响。<em class="lb">在我们开始之前，请确保您对JavaScript如何工作有一些基本的了解。</em> </p><h1 id="3c44" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">让我们在JavaScript中寻找闭包，</h1><p id="d5c1" class="pw-post-body-paragraph kz la iq lc b ld ms jr lf lg mt ju li lw mu ll lm lx mv lp lq ly mw lt lu lv ij bi translated">为此，让我们创建一个<code class="fe mx my mz na b">greet</code>函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/d33bc26b92007b0e8780be9ec084a49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xT4PfGTMTNmrbb7bQVe50g.png"/></div></div></figure><p id="15f8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我将接受一个参数，我们把它命名为“<code class="fe mx my mz na b"><strong class="lc ir"><em class="lb">msg</em></strong></code>”。我将返回一个<strong class="lc ir"> <em class="lb">函数，而不是在<code class="fe mx my mz na b">greet</code>函数中工作。</em> </strong>我打算利用范围链来包含<code class="fe mx my mz na b">msg</code>，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/b49cfddd8c7692feccbea16cf757199f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q46U9HgKui5IPyQKgbaXHg.png"/></div></div></figure><p id="2f9e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">好好看看这个。我有一个返回函数 的<strong class="lc ir"> <em class="lb">函数。所以当我调用<code class="fe mx my mz na b">greet()</code>时，我将得到值，但不是一个字符串，或一个数字，或类似的东西，我将得到一个我可以再次调用的<strong class="lc ir"> <em class="lb">函数</em> </strong>！</em></strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/128f00ed60e56667bea874aade1738e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*p9VusIzW77PSI0f9B-k0Iw.gif"/></div></div></figure><p id="b434" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">因为函数是JavaScript中的对象，所以我可以把它作为一个值返回。现在，<code class="fe mx my mz na b">greet()</code>返回一个函数。那么，我如何调用这个函数呢？</p><p id="7694" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了调用它，我们需要再放一个<code class="fe mx my mz na b">()</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/f088a1fd79d73a9d8d31c84ca6c7d8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GAzZJAk-P9NEp3MeSdHCUg.gif"/></div></div></figure><p id="0895" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">看起来有点奇怪，对吧？但是我们调用一个函数(<code class="fe mx my mz na b">greet()</code>)，它返回一个匿名函数，然后我们调用这个匿名函数。</p><p id="6d4e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">有意义吗？仔细看，不寻常的事情已经发生了！为了理解这有多不寻常，让我们换一种方式来做这件事。让我们设置函数<code class="fe mx my mz na b">greet()</code>等于一个变量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/8840b29ffc5d2aeaf77cd7995445bd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ZlvcW6-GniV2zhGeu1JKQ.png"/></div></div></figure><p id="e352" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">所以现在<code class="fe mx my mz na b">say</code>，将是一个通过调用<code class="fe mx my mz na b">greet</code>返回的函数。当我调用<code class="fe mx my mz na b">say()</code>时，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/b9a69642599b1e1f57216e822137f3b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BOGqylj2-S9i7qy7mU-_Qg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Passing “Readers 🙏" as an argument</figcaption></figure><p id="e87b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">还能用！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/1e4754e9e32faf67e67cc1aee8784466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*RIIaoibZTdimEGrDpuDm7w.png"/></div></figure><p id="ed06" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们停下来想一想这个问题。<code class="fe mx my mz na b">say()</code>函数怎么还知道<code class="fe mx my mz na b">msg</code>变量？因为<code class="fe mx my mz na b">msg</code>变量是在第7行创建的，当<code class="fe mx my mz na b">greet()</code>被调用时，它完成了执行并从执行堆栈中弹出。</p><p id="f5e8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">然而，当我调用<code class="fe mx my mz na b">say(“Readers 🙏”)</code>时，它仍然有正确的值<code class="fe mx my mz na b">msg</code>，也就是<code class="fe mx my mz na b">Namaste</code>。</p><p id="b917" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这怎么可能呢？因为闭包所以有可能。</p><h1 id="f3f0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">让我们来看看引擎盖下发生了什么！</h1><p id="b78b" class="pw-post-body-paragraph kz la iq lc b ld ms jr lf lg mt ju li lw mu ll lm lx mv lp lq ly mw lt lu lv ij bi translated">当执行这段代码时，<code class="fe mx my mz na b">greet()</code>结束，当我调用由<code class="fe mx my mz na b">greet()</code>返回的函数时，看起来好像那个<code class="fe mx my mz na b">greet()</code>函数还在附近，因为<code class="fe mx my mz na b">msg</code>变量还在那里。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/3bf200d4854c971943405d3d2db6ab06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cIryK4amYtDud3ZpzusB0w.gif"/></div></div></figure><p id="42c1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">发生了什么事？当代码开始执行时，我们有了我们的全局执行上下文，即<code class="fe mx my mz na b"> greet()</code>和<code class="fe mx my mz na b"> anonymous()</code>的执行上下文。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/bebd4791f50485ae46671112850ab5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TR_SMOscmMHBiSKKFHlayg.jpeg"/></div></div></figure><p id="7f48" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">当我们到达这条线时</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/33e9f278624cce6dae291d2b1942926a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xskLnkK_AmN7VlBA3jQhrA.png"/></div></div></figure><p id="16d9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">它调用<code class="fe mx my mz na b">greet</code>函数，创建一个greet执行上下文，传递给的<code class="fe mx my mz na b">msg</code>变量存储在其变量环境中。它返回一个新的匿名函数。在返回之后，<code class="fe mx my mz na b">greet</code>执行上下文被弹出堆栈。</p><p id="ab6c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">但问题来了！</strong></p><p id="c1b4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们知道，每个执行上下文在内存中都有一个空间，其中存放着所创建的变量和函数。当<strong class="lc ir"> <em class="lb">执行上下文离开</em> </strong>时，<strong class="lc ir"> <em class="lb">那个内存空间</em> </strong>会发生什么变化？</p><p id="d223" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们的<code class="fe mx my mz na b">msg</code>变量会发生什么？</p><p id="de6f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在正常情况下，JavaScript引擎最终会通过一个叫做<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#garbage_collection" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="lb">垃圾收集的过程来清除它。</em></strong>T34】</a></p><p id="5de1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">然而，当垃圾收集器来了，看到我们的<code class="fe mx my mz na b">msg </code>变量，它说哦！这里有一个闭包，我无法清理它，因为有东西在引用<code class="fe mx my mz na b">msg</code>。JavaScript已经把它放到了特殊的闭包里！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/9b4b3f05e39f54c12c52d78ae5507570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7PE0YdT2_t3aAfljXY2-dg.gif"/></div></div></figure><p id="cd7a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在JavaScript中，任何东西只有在没有引用时才会被垃圾收集。 </p><p id="2df4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">还记得我们在<a class="ae kv" href="https://medium.com/p/5b139e1e170f/edit?source=your_stories_page-------------------------------------" rel="noopener">第一站</a>离开的地方吗？我们离开了为什么关闭要花这么长时间？<br/>一旦函数离开执行堆栈，我们就有丢失变量的问题？这就是那个问题的解决方案！</p><p id="9e0b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不要将变量或激活记录保存在执行堆栈中，而是将它们保存在<strong class="lc ir">内存堆中，</strong>像我们上面讨论的那样设计一个好的垃圾收集器！</p><p id="0080" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在上面的代码中，匿名执行上下文仍然有一个对其外部环境的内存空间的变量的引用。即使<code class="fe mx my mz na b">greet()</code>已经结束。在它内部创建的函数，当它们被调用时，仍然有一个对<code class="fe mx my mz na b">greet() </code>执行上下文和内存空间的引用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/b68211bd648d644237666454052e71da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ae5TIqKsPhp2xGs2QOpkcQ.png"/></div></div></figure><p id="d4e8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">JavaScript引擎确保我们的函数仍然可以沿着作用域链向下，在<strong class="lc ir">内存堆</strong>中找到<code class="fe mx my mz na b">msg</code>，即使它已经不在执行堆栈中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/439ccba98543b37dafa1ee0c627d7131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4oiVPhx2LMHREJLHAAVhug.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">🦅 eye view of whole picture</figcaption></figure><p id="5dad" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这样，我们说执行上下文在其外部变量中是封闭的，这些变量通常会被引用，即使那些执行上下文已经不存在了。<em class="lb">这种现象，在函数应该可以访问的所有变量中，被称为</em> <strong class="lc ir"> <em class="lb">闭包。</em>T15】</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/5cb89e6c5ca5b888edd497531732e868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwdV3mHdCL0MEt33jMwThQ.png"/></div></div></figure><p id="cc66" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">要记住的一件重要的事情是，结束不是你创造的。闭包只是JavaScript编程语言的一个特性。当你说，哦，我创建了一个闭包，那么，某种程度上，JavaScript引擎创建了闭包，我们只是在利用它！</p><p id="c559" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">既然我们已经学习了闭包的引擎盖机制，是时候看看它在现实生活中的威力了，在下一篇文章中我们将看到程序员如何使用闭包来解决各种问题。</p><h1 id="c71d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">如果你错过了这个系列，这里有链接。😊</h1><h2 id="5a69" class="nm mb iq bd mc nn no dn mg np nq dp mk lw nr ns mm lx nt nu mo ly nv nw mq nx bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/most-important-feature-ever-put-in-a-programming-language-5b139e1e170f?sk=baff3bd18de9be10a66bb27eb2d265d4"> 1。编程语言中最重要的特性</a></h2><h2 id="723c" class="nm mb iq bd mc nn no dn mg np nq dp mk lw nr ns mm lx nt nu mo ly nv nw mq nx bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/grokking-closure-in-javascript-7e8194924398?sk=0f6e01511d6400590608f10f0ea85017"> 2。在JavaScript中寻找闭包</a></h2><h2 id="05b3" class="nm mb iq bd mc nn no dn mg np nq dp mk lw nr ns mm lx nt nu mo ly nv nw mq nx bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/practical-usage-of-closures-in-javascript-b3203770ba2?sk=dc404a83106d791c943d16b6b389e26c"> 3。闭包的实际用法</a></h2><h2 id="d2dd" class="nm mb iq bd mc nn no dn mg np nq dp mk lw nr ns mm lx nt nu mo ly nv nw mq nx bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/ultimate-interview-questions-on-javascript-closures-8dd12a210677?sk=4d15f7e3756b76a9e2886b97515975b1"> 4。终极JavaScript面试问题—结束</a></h2></div></div>    
</body>
</html>