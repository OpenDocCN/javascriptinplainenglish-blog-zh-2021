<html>
<head>
<title>Handle CSS and links in dynamically injected HTML using Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular处理动态注入HTML中的CSS和链接</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handle-css-and-links-in-dynamically-injected-html-using-angular-74c074ca2fd7?source=collection_archive---------5-----------------------#2021-10-14">https://javascript.plainenglish.io/handle-css-and-links-in-dynamically-injected-html-using-angular-74c074ca2fd7?source=collection_archive---------5-----------------------#2021-10-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/168182f09250e226e46176135b2f0704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_80JakmVa3DazWzP"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jacksonsophat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jackson So</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="66d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用Angular在组件中注入HTML可以通过使用容器的“innerHTML”属性(通常是“div”或“p”)来完成。然而，这种方法有两个问题:</p><ul class=""><li id="e3e3" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">如果组件定义了一些CSS样式(并使用默认的视图封装)，它们将不会应用到插入的HTML中。</li><li id="9cda" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">如果HTML包含一些内部链接，这些链接将重新加载整个应用程序，而不是使用路由器导航。</li></ul><p id="2c96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我开发了<a class="ae jz" href="https://stackblitz.com/edit/angular-rxe6rp" rel="noopener ugc nofollow" target="_blank">这个角度应用</a>来演示这些问题。该应用程序的主要部分包括:</p><ul class=""><li id="621f" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">它包含通过路由器配置加载的三个组件("/home "，"/hello "和"/bye ")</li><li id="9aeb" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">“main”组件是为“/home”路径加载的，它只是在“div”中注入一些HTML。</li><li id="3013" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">“hello”和“bye”组件简单地显示他们的名字和返回“/home”路线的返回链接。</li></ul><p id="88ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，主组件使用的HTML使用了组件样式中声明的“bold”CSS类。此外，它包含三个环节:两个内部环节(一个相对和一个绝对)和一个外部环节。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="797a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在组件中显示该HTML的正常方式是StackBlitz中默认使用的方式:“innerHTML”属性。如果这样做，结果如下:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/cd886b0ab7d699d1faf623614ec42750.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*PjnLdne4cx0L85BlXUo9EA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Using “innerHTML”</figcaption></figure><p id="c1ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，第一个问题是“bold”类不适用于第一段。此外，如果您单击前两个链接，整个应用程序会重新加载，因为使用了浏览器导航而不是Angular router。</p><p id="ac9e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两个问题可以通过使用<a class="ae jz" href="https://stackblitz.com/edit/angular-rxe6rp?file=src%2Fapp%2Fhtml.directive.ts" rel="noopener ugc nofollow" target="_blank">的“html”指令</a>来解决。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="787e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以通过使用它而不是“innerHTML”来测试它，以查看以下结果:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/699c1047ef8abe856bbbec0fc3a2d027.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*Lj41D9RcrS2yQFvIIrx4vw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Using the “html” directive</figcaption></figure><p id="fdf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这次你可以看到，第一段现在是粗体的。此外，如果你点击链接，Angular路由器就会启动，应用程序不会重新加载(当然外部的除外)。</p><p id="60fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该指令的整个逻辑在“ngOnChanges”钩子中定义，以便在“html”输入的值改变时立即应用它。我们可以为“html”输入使用一个setter，但是因为只有一个输入，所以变化不大。</p><p id="137f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们做的第一件事是检索组件的惟一id。事实上，当使用默认的视图封装时，CSS样式实际上是用一个后缀来修改的，以便将它们的范围扩大到组件。例如，“bold”CSS类在页面的源代码中实际上是这样定义的:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/e62ec4b7caf82aa50a6446ca456f5b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*Yj95yaVUCR8CRNDtgQDpOQ.png"/></div></figure><p id="3240" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么使用“innerHTML”对CSS不起作用。事实上，插入的段落不会应用“_ngcontent-lnp-c5”属性，因此该类不会应用。这就是为什么我们在指令中做的第一件事是检索该指令所应用到的元素的这个属性的名称，并将其存储到“_uniqueId”变量中。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="a984" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们简单地更新元素的“innerHTML”属性来插入HTML。请注意，我们没有对其进行消毒，因此可能存在一些注射风险，这取决于您自己。我没有检查，但我猜想，它不应该是那么复杂，使用消毒剂的角度，以确保指令。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="bc49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了属性的名称，我们检索对元素的所有后代的引用，并将该属性添加到它们中。这样，段落现在将与“bold”类的CSS查询相匹配:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/db943a0c3473d748f8338be3068b108c.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*2OsBIkbGKoObqACXKl1jBw.png"/></div></figure><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7b16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这解决了CSS的问题，但是没有解决链接的问题。这部分由检查后代标签名是否为“A”的条件来处理。如果是这样，我们检索它的“href”属性的值。注意，我们不使用“getAttribute”函数，因为这将返回原始值。我的意思是“getAttribute”函数返回相对链接的相对URL，而“href”属性返回所有链接的绝对URL。因此，使用属性而不是属性可以确保URL始终是绝对的。</p><p id="f413" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们只想对内部链接使用角度路由器，所以我们检查“href”属性是从页面的原点开始的。如果是这样，我们在“a”元素上定义一个“click”事件来重定向使用路由器的用户，并防止默认行为，以确保浏览器不会在事后将用户重定向到该URL。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="cb0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，在将URL传递给路由器的“导航”功能之前，我们将它设为相对URL，因为它不支持绝对URL。</p><p id="de60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，您现在可以将HTML插入到组件中，这些组件:</p><ul class=""><li id="51b7" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">支持组件范围的样式</li><li id="508b" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">将角度路由器用于内部链路</li><li id="f3bc" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">绕过对HTML的净化(这可能是好事也可能是坏事，取决于你)。</li></ul><p id="864f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您看到了改进该指令的方法，请不要犹豫发表评论。</p><p id="209f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lw">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>