<html>
<head>
<title>A Detailed Guide to the ‘this’ Keyword in JavaScript — JS interview series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript — JS访谈系列中“this”关键字的详细指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-this-keyword-in-javascript-for-generic-and-arrow-functions-a-detailed-guide-5be2070184bf?source=collection_archive---------7-----------------------#2021-06-12">https://javascript.plainenglish.io/the-this-keyword-in-javascript-for-generic-and-arrow-functions-a-detailed-guide-5be2070184bf?source=collection_archive---------7-----------------------#2021-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/40b7737f77a1fdf856d7eb1633bd84f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXsNeCIjxingANs_EB72Cg.jpeg"/></div></div></figure><p id="e686" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JS中的“this”关键字经常是JS初学者的困惑来源。那么到底什么是“这个”,你如何回答与这个话题相关的面试问题。如果这些是你心中的问题，那么你就来对地方了。</p><p id="9a5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，这是一个DIY指南，请检查JS fiddle中的代码，以更好地理解所包含的代码。另外，试着自己解决最后的练习。</p><p id="3812" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开始吧！</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h2 id="3e8e" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated"><strong class="ak">定义‘这个’</strong></h2><p id="ef14" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">关键字“this”指出了当前正在执行的函数的上下文，或者换句话说，它指出了该函数所绑定的对象。这听起来可能很奇怪，但是JS中的函数和变量是绑定到(或属于)一个对象的。</p><p id="a288" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，泛型函数和arrow函数的绑定方式是不同的，这也是初学者容易混淆的地方。</p><h2 id="d34a" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated"><strong class="ak">通用函数中的‘这个’</strong></h2><p id="b94f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在总结通用函数的上下文(“this”值)时，有三个规则(没有明确说明):</p><ol class=""><li id="c1cd" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">在没有任何绑定(隐式或显式)的情况下,“this”关键字指出调用该函数的上下文。</li><li id="27d1" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">在隐式和显式绑定(见下文)中，函数的“this”关键字属于函数绑定到的对象。</li><li id="d6a4" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果没有隐式或显式绑定，函数将失去它们的上下文，并且“this”关键字遵循规则1。</li></ol><p id="a20b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑下面这段代码，猜测输出并在js fiddle中验证。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><p id="8e2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以看到foo()函数的上下文是窗口(或全局对象)参考规则1。现在尝试执行下面的代码</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><p id="f3d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里你可以看到函数foo()绑定到对象' a ',这从console.log(this)中可以明显看出。这是因为函数foo()在执行a.foo()时被<em class="mr">隐式绑定</em>到对象‘a’。因此，根据规则2,“this”关键字指向对象“a”。</p><p id="2e11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在您已经知道了上下文如何为隐式绑定工作，猜猜下面的JS代码的输出:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><p id="2ed3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们看到的,' this '关键字现在指向全局对象。这是因为函数newFoo()没有隐式或显式地绑定到任何对象——即使Foo()是有界的——因此函数现在丢失了它的上下文并指向全局对象。</p><p id="9d20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是考虑显式绑定的时候了(请在继续之前阅读关于<a class="ae mq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call#" rel="noopener ugc nofollow" target="_blank">调用、应用和绑定</a>的内容)。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><p id="f652" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的bind函数用于将函数foo()显式绑定到对象“a ”,并返回一个可以调用的有界函数。这里newFoo()充当有界函数，因此指向对象“a ”,而不是全局对象，即使它是在全局上下文中执行的。</p><p id="8a93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将在本文末尾的练习中再次讨论这些通用函数。</p><h2 id="f472" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated"><strong class="ak">箭头中的‘this’功能</strong></h2><p id="c30c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">箭头函数中“this”的工作方式不同于一般函数。箭头函数选择与封闭函数相同的上下文。因此“this”关键字指向封闭函数的上下文。考虑下面的例子</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><p id="6fe0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">箭头函数“a”的封闭函数是foo()，foo()函数的上下文是全局对象。因此“this”关键字指出了这里的全局对象。现在考虑下面的例子</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><p id="a0e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数doo()的“this”关键字指向对象“a ”,因为封闭函数foo()隐式绑定到对象“a ”,因此doo()函数拾取foo()的上下文。</p><p id="4f74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑下面的显式绑定示例，猜测输出应该很简单。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><p id="07a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，doo函数的“this”也指向对象“a ”,因为封闭函数foo被显式地绑定到对象“a”。</p><h2 id="7124" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated"><strong class="ak">勇敢者的练习</strong></h2><p id="4218" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><strong class="jx io">练习1: </strong></p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><h2 id="63c1" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated">说明</h2><p id="896c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，在第13行，函数func()被隐式绑定到myObject，因此“this”指的是myObject。在第4行，我们将myObject保存在变量self中。由于隐式绑定，第5行和第6行的console.log语句将如下所示</p><ul class=""><li id="7c7b" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks ms md me mf bi translated">" outer func: this.foo = bar "</li><li id="b229" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ms md me mf bi translated">" outer func: self.foo = bar "</li></ul><p id="7f05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第7行中，我们有一个立即调用的函数表达式(life ),由于这个函数没有绑定到任何对象(隐式或显式的),“this”将指向一个全局对象，因此this.foo是未定义的，因为foo不是全局对象上的变量。因此，第8行和第9行的输出如下</p><ul class=""><li id="1acb" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks ms md me mf bi translated">" inner func: this.foo = undefined "</li><li id="b279" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ms md me mf bi translated">" inner func: self.foo = bar "</li></ul><p id="450a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里self存储了我之前讨论过的对象，并且由于JS中的闭包，它可以被IIFE访问(这里有更多关于它的内容<a class="ae mq" href="https://www.youtube.com/watch?v=qikxEIxsXco" rel="noopener ugc nofollow" target="_blank"/>)。由此self.foo等于“bar”。</p><p id="7173" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">练习2: </strong></p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="ml ky l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Try this here: <a class="ae mq" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/</a></figcaption></figure><p id="75dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于箭头函数提取封闭函数(此处为func()的上下文),“this”和“self”都指向myObject，因此输出如下:</p><ul class=""><li id="0da1" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks ms md me mf bi translated">" outer func: this.foo = bar "</li><li id="d8be" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ms md me mf bi translated">" outer func: self.foo = bar "</li><li id="3ffc" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ms md me mf bi translated">" inner func: this.foo = bar "</li><li id="ab7f" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks ms md me mf bi translated">" inner func: self.foo = bar "</li></ul><h2 id="fdcd" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated">结论</h2><p id="905f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我希望下面的例子和解释是清楚的，并帮助你获得更好的理解。如果你有任何建议或想法，请在评论中告诉我们。</p><p id="f82d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mr">更多内容请看</em><a class="ae mq" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>