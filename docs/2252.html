<html>
<head>
<title>A Quick Guide to Call, Apply and Bind Methods in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中调用、应用和绑定方法的快速指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/quick-guide-to-call-apply-and-bind-methods-in-javascript-5c00cd856cfa?source=collection_archive---------5-----------------------#2021-05-11">https://javascript.plainenglish.io/quick-guide-to-call-apply-and-bind-methods-in-javascript-5c00cd856cfa?source=collection_archive---------5-----------------------#2021-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e7ca" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">调用、应用和绑定方法——结合实际应用和聚合来解释绑定方法。</h2></div><p id="c3ff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将讨论函数原型链的调用、应用和绑定方法。它们是JavaScript中最重要和最常用的概念，与<em class="ky"> this </em>关键字密切相关。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/ecd45a758b6c291aa4425e1230433f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HRqVf3HxHR4CvzwKnZTXNA.jpeg"/></div></div></figure><h1 id="9952" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">调用方法</h1><p id="9b0b" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated"><code class="fe mi mj mk ml b"><strong class="ke io">call()</strong></code>方法调用具有给定<code class="fe mi mj mk ml b">this</code>值和单独提供的参数的函数。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="b55e" class="mq lm in ml b gy mr ms l mt mu">func.call([thisArg[, arg1, arg2, ...argN]])</span></pre><p id="edf3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">参数:<br/></strong><code class="fe mi mj mk ml b">thisArg</code>——可选项。当调用<code class="fe mi mj mk ml b">func</code>时，使用<code class="fe mi mj mk ml b">this</code>是有价值的。<code class="fe mi mj mk ml b"><br/>arg1, arg2, ...argN</code>-函数的可选参数。</p><p id="a4cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">返回值:</strong>用指定的<code class="fe mi mj mk ml b"><strong class="ke io">this</strong></code>值和参数调用函数的结果。</p><h2 id="5a03" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">描述</h2><ul class=""><li id="7e08" class="ng nh in ke b kf md ki me kl ni kp nj kt nk kx nl nm nn no bi translated">使用调用方法我们可以进行<strong class="ke io">函数/方法借用</strong>，我们可以从其他对象中借用函数，并与其他一些对象的数据一起使用。</li><li id="3f17" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">有了<code class="fe mi mj mk ml b">call()</code>，您可以一次性编写一个方法，然后在另一个对象中继承它，而不必为新的对象重写方法。</li><li id="867a" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">在call方法中，第一个参数将是引用或我们希望“this”指向的内容。</li><li id="3069" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">后面的参数可以是该函数的参数。我们可以传递任意数量的逗号分隔的参数。</li></ul><h2 id="8eb3" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">实际应用</h2><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="8e62" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated"><strong class="ak"> 1)使用</strong> <code class="fe mi mj mk ml b"><strong class="ak">call</strong></code> <strong class="ak">为对象链接构造函数</strong></h2><p id="c9cf" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">使用<code class="fe mi mj mk ml b">call</code>为一个对象链接构造器(类似于Java)。</p><p id="d5ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在以下示例中，<code class="fe mi mj mk ml b">Person</code>对象的构造函数由两个参数定义:<code class="fe mi mj mk ml b">name</code>和<code class="fe mi mj mk ml b">age</code>。</p><p id="7d18" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外两个功能<code class="fe mi mj mk ml b">Engineer</code>、<code class="fe mi mj mk ml b">Doctor</code>调用<code class="fe mi mj mk ml b">Person</code>，通过<code class="fe mi mj mk ml b">this</code>、<code class="fe mi mj mk ml b">name</code>和<code class="fe mi mj mk ml b">age</code>。<code class="fe mi mj mk ml b">Person</code>初始化属性<code class="fe mi mj mk ml b">name</code>和<code class="fe mi mj mk ml b">age</code>，这两个专用函数定义了<code class="fe mi mj mk ml b">category</code>。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="c608" class="mq lm in ml b gy mr ms l mt mu">function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span><span id="f2e0" class="mq lm in ml b gy nw ms l mt mu">function Engineer(name, age) {<br/>  Person.call(this, name, age);<br/>  this.category = 'Engineer';<br/>}</span><span id="6031" class="mq lm in ml b gy nw ms l mt mu">function Doctor(name, age) {<br/>  Person.call(this, name, age);<br/>  this.category = 'Doctor';<br/>}</span><span id="efdf" class="mq lm in ml b gy nw ms l mt mu">const engineer = new Engineer('Ayush', 28);<br/>console.log(engineer);<br/>//Engineer {name: "Ayush", age: 28, category: "Engineer"}</span><span id="90b1" class="mq lm in ml b gy nw ms l mt mu">const doctor = new Doctor('Anu', 30);<br/>console.log(doctor);<br/>//Doctor {name: "Anu", age: 30, category: "Doctor"}</span></pre><h2 id="af89" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated"><strong class="ak"> 2)使用</strong> <code class="fe mi mj mk ml b"><strong class="ak">call</strong></code> <strong class="ak">调用一个函数并指定上下文为</strong><strong class="ak"/></h2><p id="561c" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在下面的例子中，当我们调用<code class="fe mi mj mk ml b">print</code>时，<code class="fe mi mj mk ml b">this</code>的值必然会反对<code class="fe mi mj mk ml b">person</code>。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="d7ca" class="mq lm in ml b gy mr ms l mt mu">const person = {<br/>    name: 'Ayush', <br/>    age: '28'<br/>};<br/>function print() {<br/>  const reply = [this.name, 'is', this.age, 'years old.'].join(' ');<br/>  console.log(reply);<br/>}</span><span id="61cf" class="mq lm in ml b gy nw ms l mt mu">print.call(person);<br/>//Ayush is 28 years old.</span></pre><h2 id="2543" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated"><strong class="ak"> 3)使用</strong> <code class="fe mi mj mk ml b"><strong class="ak">call</strong></code> <strong class="ak">调用函数而不指定第一个参数</strong></h2><p id="2a55" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在下面的例子中，我们调用<code class="fe mi mj mk ml b">display</code>函数而不传递第一个参数。如果第一个参数没有被传递，则<code class="fe mi mj mk ml b">this</code>的值被绑定到全局对象。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="024d" class="mq lm in ml b gy mr ms l mt mu">var name = 'Ayush';</span><span id="2316" class="mq lm in ml b gy nw ms l mt mu">function display() {<br/>  console.log('Your name: ', this.name);<br/>}</span><span id="4973" class="mq lm in ml b gy nw ms l mt mu">display.call();<br/>// Your name:  Ayush</span><span id="79fc" class="mq lm in ml b gy nw ms l mt mu"><strong class="ml io">Caution:</strong> In strict mode, the value of <!-- -->this<!-- --> will be <!-- -->undefined<!-- -->.</span><span id="0683" class="mq lm in ml b gy nw ms l mt mu">'use strict'</span><span id="b295" class="mq lm in ml b gy nw ms l mt mu">var name = 'Ayush';</span><span id="743b" class="mq lm in ml b gy nw ms l mt mu">function display() {<br/>  console.log('Your name: ', this.name);</span><span id="fe43" class="mq lm in ml b gy nw ms l mt mu">}</span><span id="cf8e" class="mq lm in ml b gy nw ms l mt mu">display.call();<br/>//Uncaught TypeError: Cannot read property 'name' of undefined</span></pre></div><div class="ab cl nx ny hr nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ig ih ii ij ik"><h1 id="1145" class="ll lm in bd ln lo oe lq lr ls of lu lv jt og ju lx jw oh jx lz jz oi ka mb mc bi translated">运用方法</h1><p id="7aca" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated"><code class="fe mi mj mk ml b"><strong class="ke io">apply()</strong></code>方法调用给定<code class="fe mi mj mk ml b">this</code>值的函数，并将<code class="fe mi mj mk ml b">arguments</code>作为数组(或<a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects" rel="noopener ugc nofollow" target="_blank">数组状对象</a>)提供。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="15f9" class="mq lm in ml b gy mr ms l mt mu">func.apply(thisArg, [ argsArray])</span></pre><p id="1a59" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">参数:<br/> </strong> <code class="fe mi mj mk ml b">thisArg </code>为调用<code class="fe mi mj mk ml b">func</code>提供的值。<br/>注意<code class="fe mi mj mk ml b">this</code>可能不是该方法看到的实际值:如果该方法是<a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener ugc nofollow" target="_blank">非严格模式</a>下的函数，则<code class="fe mi mj mk ml b"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">null</a></code>和<code class="fe mi mj mk ml b"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank">undefined</a></code>将被全局对象替换，基元值将被装箱。这个参数是必需的。</p><p id="2d4f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mi mj mk ml b">argsArray</code>可选。一个类似数组的对象，指定调用<code class="fe mi mj mk ml b">func</code>时应该使用的参数，如果没有参数提供给函数，则指定<code class="fe mi mj mk ml b"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">null</a></code>或<code class="fe mi mj mk ml b"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank">undefined</a></code>。</p><p id="f790" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">返回值:</strong>用指定的<code class="fe mi mj mk ml b"><strong class="ke io">this</strong></code>值和参数调用函数的结果。</p><h2 id="d3cf" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">描述</h2><ul class=""><li id="1dee" class="ng nh in ke b kf md ki me kl ni kp nj kt nk kx nl nm nn no bi translated">有了<code class="fe mi mj mk ml b">apply</code>，你可以写一次方法，然后在另一个对象中继承它，而不必为新对象重写方法。</li><li id="f08e" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated"><code class="fe mi mj mk ml b">apply</code>与<code class="fe mi mj mk ml b">call()</code>非常相似，除了它支持的参数类型。</li><li id="652c" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">使用<code class="fe mi mj mk ml b">apply</code>，还可以使用一个数组文字，例如<code class="fe mi mj mk ml b">func.apply(this, ['eat', 'bananas'])</code>，或者一个<code class="fe mi mj mk ml b">Array</code>对象，例如<code class="fe mi mj mk ml b">func.apply(this, new Array('eat', 'bananas'))</code>。</li><li id="1ee0" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">您也可以将<code class="fe mi mj mk ml b"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">arguments</a></code>用于<code class="fe mi mj mk ml b">argsArray</code>参数。<code class="fe mi mj mk ml b"><a class="ae oj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">arguments</a></code>是函数的局部变量。它可以用于被调用对象的所有未指定的参数。因此，当您使用<code class="fe mi mj mk ml b">apply</code>方法时，您不必知道被调用对象的参数。</li></ul><h2 id="5136" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">实际应用</h2><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="0c7e" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">1)使用apply将数组附加到另一个数组</h2><p id="8479" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">使用<code class="fe mi mj mk ml b">push</code>将一个元素添加到数组中。而且，因为<code class="fe mi mj mk ml b">push</code>接受可变数量的参数，所以您也可以一次推送多个元素。</p><p id="9cc8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，如果您将一个数组传递给<code class="fe mi mj mk ml b">push</code>，它实际上将该数组作为单个元素添加，而不是单独添加元素。所以你最终得到了一个数组中的数组。</p><p id="9e38" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这不是你想要的呢？在这种情况下,<code class="fe mi mj mk ml b">concat</code>确实具有期望的行为，但是它没有附加到现有的数组中——而是创建并返回一个新数组。</p><p id="98c7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是您想追加到现有的数组中…那么现在该怎么办呢？写循环？肯定不会吗？</p><p id="ab1e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mi mj mk ml b">apply</code>来救援了！</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="37e5" class="mq lm in ml b gy mr ms l mt mu">const arr = [1, 2, 3]; <br/>const numbers = [4, 5, 6];</span><span id="a47e" class="mq lm in ml b gy nw ms l mt mu">arr.push.apply(arr, numbers);  <br/>console.log(arr);<br/>//[1, 2, 3, 4, 5, 6]</span></pre><h2 id="b195" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">2)使用应用和内置函数</h2><p id="c8e6" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">巧妙使用<code class="fe mi mj mk ml b">apply</code>允许您使用内置函数来完成一些任务，否则这些任务可能会通过循环数组值来编写。</p><p id="08fe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有<code class="fe mi mj mk ml b">Math.max</code> / <code class="fe mi mj mk ml b">Math.min</code>作为例子，用来找出一个数组中的最大/最小值。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="867b" class="mq lm in ml b gy mr ms l mt mu">// Min/Max number in an array<br/>const numbers = [9, 8, 1, 2, 3, 5, 6, 7];</span><span id="60df" class="mq lm in ml b gy nw ms l mt mu">// Using Math.min/Math.max apply<br/>let max = Math.max.apply(null, numbers);<br/>console.log(max); //9</span><span id="e788" class="mq lm in ml b gy nw ms l mt mu">// This about equal to Math.max(numbers[0], ...)<br/>// or Math.max(5, 6, ...)</span><span id="ce29" class="mq lm in ml b gy nw ms l mt mu">let min = Math.min.apply(null, numbers);<br/>console.log(min); //1</span></pre></div><div class="ab cl nx ny hr nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ig ih ii ij ik"><h1 id="a174" class="ll lm in bd ln lo oe lq lr ls of lu lv jt og ju lx jw oh jx lz jz oi ka mb mc bi translated">绑定方法</h1><p id="eed1" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated"><code class="fe mi mj mk ml b"><strong class="ke io">bind()</strong></code>方法返回一个新函数，当被调用时，它的<code class="fe mi mj mk ml b">this</code>被设置为一个特定的值。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="7876" class="mq lm in ml b gy mr ms l mt mu">func<!-- -->.bind(thisArg[, arg1[, arg2[, ...]]])</span></pre><p id="ea12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">参数:<br/> </strong> <code class="fe mi mj mk ml b">thisArg</code>调用绑定函数时，作为<code class="fe mi mj mk ml b">this</code>参数传递给目标函数<code class="fe mi mj mk ml b">func</code>的值。如果没有向<code class="fe mi mj mk ml b">bind </code>提供参数，或者如果<code class="fe mi mj mk ml b">thisArg</code>是<code class="fe mi mj mk ml b">null</code>或<code class="fe mi mj mk ml b">undefined</code>，则执行范围的<code class="fe mi mj mk ml b">this</code>被视为新函数的<code class="fe mi mj mk ml b">thisArg</code>。</p><p id="0bb3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mi mj mk ml b">arg1, arg2, ...argN</code>可选。调用<code class="fe mi mj mk ml b">func</code>时提供给绑定函数的参数的前置参数。</p><p id="1ccc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">返回值:</strong>给定函数的副本，带有指定的<code class="fe mi mj mk ml b">this</code>值和初始参数(如果提供的话)。</p><h2 id="6da8" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">描述</h2><ul class=""><li id="6e5d" class="ng nh in ke b kf md ki me kl ni kp nj kt nk kx nl nm nn no bi translated"><code class="fe mi mj mk ml b">bind()</code>函数创建一个新的<strong class="ke io">绑定函数</strong>，它是一个<em class="ky">外来函数对象</em>(ECMAScript 2015中的一个术语)包装了原来的函数对象。调用绑定函数通常会导致执行其包装函数。</li><li id="b520" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">bind方法看起来与call方法完全相同，但唯一的区别是，bind方法将该方法与对象绑定，并返回该方法的副本，而不是在这里直接调用该方法。并将<strong class="ke io">返回一个函数。</strong></li><li id="6aa2" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">这里有一个问题，它不直接调用那个方法，而是返回一个以后可以调用的方法。这基本上只是用来绑定和保存那个方法的副本，以后再用。</li></ul><h2 id="edc8" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">实际应用</h2><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="d4e6" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">1)创建绑定函数</h2><p id="59b1" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated"><code class="fe mi mj mk ml b">bind()</code>最简单的用法是创建一个函数，不管它是如何被调用的，都是用一个特定的<code class="fe mi mj mk ml b">this</code>值来调用的。</p><p id="72ef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">新的JavaScript程序员的一个常见错误是从一个对象中提取一个方法，然后调用该函数并期望它使用原始对象作为它的<code class="fe mi mj mk ml b">this</code>(例如，通过在基于回调的代码中使用该方法)。</p><p id="5154" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，如果不特别小心，原始对象通常会丢失。使用原始对象从函数创建绑定函数，巧妙地解决了这个问题:</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="1239" class="mq lm in ml b gy mr ms l mt mu">this.x = 9;    // 'this' refers to global 'window' object here in a browser<br/>const module = {<br/>  x: 81,<br/>  getX: function() { return this.x; }<br/>};<br/><br/>module.getX();<br/>//  returns 81<br/><br/>const retrieveX = module.getX;<br/>retrieveX();<br/>//  returns 9; the function gets invoked at the global scope<br/><br/>//  Create a new function with 'this' bound to module<br/>//  New programmers might confuse the<br/>//  global variable 'x' with module's property 'x'</span><span id="cb09" class="mq lm in ml b gy nw ms l mt mu">const boundGetX = retrieveX.bind(module);<br/>boundGetX();<br/>//  returns 81</span></pre><h2 id="6cc0" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">2)部分应用的功能</h2><p id="3367" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">下一个最简单的使用<code class="fe mi mj mk ml b">bind()</code>的方法是使用预先指定的初始参数创建一个函数。</p><p id="6ca2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些参数(如果有的话)遵循提供的<code class="fe mi mj mk ml b">this</code>值，然后被插入到传递给目标函数的参数的开头，后面是调用时传递给绑定函数的任何参数。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="3c13" class="mq lm in ml b gy mr ms l mt mu">function addArguments(arg1, arg2) {<br/>  return arg1 + arg2<br/>}</span><span id="f5a3" class="mq lm in ml b gy nw ms l mt mu">const result1 = addArguments(1, 2);<br/>console.log(result1); //3</span><span id="4424" class="mq lm in ml b gy nw ms l mt mu">// Create a function with a preset first argument.<br/>const addThirtySeven = addArguments.bind(null, 37);<br/>const result2 = addThirtySeven(5);</span><span id="544d" class="mq lm in ml b gy nw ms l mt mu">console.log(result2); <br/>//  37 + 5 = 42</span><span id="7d42" class="mq lm in ml b gy nw ms l mt mu">const result3 = addThirtySeven(5, 10);<br/>console.log(result3);<br/>//  37 + 5 = 42<br/>//  (the second argument is ignored)</span></pre><h2 id="8520" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">3)使用JavaScript <code class="fe mi mj mk ml b">bind()</code>进行函数绑定(使用<code class="fe mi mj mk ml b">setTimeout()</code></h2><p id="f6d6" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">当你把一个方法对象作为回调传递给另一个函数时，<code class="fe mi mj mk ml b">this</code>就丢失了。例如:</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="3b68" class="mq lm in ml b gy mr ms l mt mu">let person = {<br/>    firstName: 'John Doe',<br/>    getName: function() {<br/>        console.log(this.firstName);<br/>    }<br/>};</span><span id="a8d2" class="mq lm in ml b gy nw ms l mt mu">setTimeout(person.getName, 1000); //undefined</span><span id="2026" class="mq lm in ml b gy nw ms l mt mu">let f = person.getName; <br/>setTimeout(f, 1000); //undefined</span></pre><p id="1308" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mi mj mk ml b">setTimeout()</code>函数内的<code class="fe mi mj mk ml b">this</code>在非严格模式下设置为全局对象，在严格模式下设置为<code class="fe mi mj mk ml b">undefined</code>。</p><p id="0a99" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，当回调<code class="fe mi mj mk ml b">person.getName</code>被调用时，全局对象中不存在<code class="fe mi mj mk ml b">name</code>，它被设置为<code class="fe mi mj mk ml b">undefined</code>。</p><p id="6b74" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要解决这个问题，您可以将对<code class="fe mi mj mk ml b">person.getName</code>方法的调用包装在一个匿名函数中，如下所示:</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="8bae" class="mq lm in ml b gy mr ms l mt mu">setTimeout(function () {<br/>    person.getName();<br/>}, 1000); <br/>// "John Doe"</span></pre><p id="c2cb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是可行的，因为它从外部范围获取<code class="fe mi mj mk ml b">person</code>，然后调用方法<code class="fe mi mj mk ml b">getName()</code>。</p><p id="695a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者您可以使用<code class="fe mi mj mk ml b">bind()</code>方法:</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="5941" class="mq lm in ml b gy mr ms l mt mu">let f = person.getName.bind(person); <br/>setTimeout(f, 1000); <br/>// "John Doe"</span></pre><h2 id="26fd" class="mq lm in bd ln mv mw dn lr mx my dp lv kl mz na lx kp nb nc lz kt nd ne mb nf bi translated">4)使用<code class="fe mi mj mk ml b">bind()</code>从不同的对象借用方法</h2><p id="e5f1" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在JavaScript中，借用对象的方法而不复制该方法并在两个不同的地方维护它的能力非常强大。</p><pre class="la lb lc ld gt mm ml mn mo aw mp bi"><span id="3686" class="mq lm in ml b gy mr ms l mt mu">let runner = {<br/>    name: 'Runner',<br/>    run: function(speed) {<br/>        console.log(this.name + ' runs at ' + speed + ' mph.');<br/>    }<br/>};</span><span id="f729" class="mq lm in ml b gy nw ms l mt mu">let flyer = {<br/>    name: 'Flyer',<br/>    fly: function(speed) {<br/>        console.log(this.name + ' flies at ' + speed + ' mph.');<br/>    }<br/>};</span><span id="8fa2" class="mq lm in ml b gy nw ms l mt mu">let run = runner.run.bind(flyer, 20);<br/>run();<br/>// Flyer runs at 20 mph.</span></pre><h1 id="9ab1" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">粘合剂法用聚合填料</h1><ul class=""><li id="42e4" class="ng nh in ke b kf md ki me kl ni kp nj kt nk kx nl nm nn no bi translated">首先，你需要让它对所有方法都可用，所以我们将从<code class="fe mi mj mk ml b">Function</code>的<code class="fe mi mj mk ml b">prototype</code>中获得帮助</li><li id="bcb4" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated"><code class="fe mi mj mk ml b">customBind</code>是一个用户定义的函数，你可以给它起任何你想要的名字，现在它可以用于你在代码中定义的任何函数，就像其他函数toString()、toLocaleString()等等。</li><li id="6776" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated"><code class="fe mi mj mk ml b">customBind</code>函数应返回一个函数，该函数在被调用时应调用应用了customBind的函数。</li><li id="e303" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">所有对象的范围都应该作为<strong class="ke io">上下文</strong>来传递。</li><li id="363b" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated">通过<strong class="ke io"> args1和args2 </strong>获取<code class="fe mi mj mk ml b">customBind</code>中传递的所有参数和返回的函数，创建一个包含两个数组元素的更大的数组，并将其作为参数传递给我们绑定的函数。</li></ul><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="9a63" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">结论</h1><p id="0bc1" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们已经讨论了JavaScript调用、应用和绑定方法。还学习了使用apply方法从头开始创建bind方法。</p><p id="e203" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你已经发现这是有用的。感谢您的阅读。</p><p id="3f8c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容尽在</em><a class="ae oj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ky">plain English . io</em></a></p></div></div>    
</body>
</html>