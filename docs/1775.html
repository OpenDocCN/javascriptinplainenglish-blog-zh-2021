<html>
<head>
<title>Bridging the Gap Between SSR and Client-State Persisted Data with next-persist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用next-persist弥合SSR和客户端状态持久化数据之间的差距</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-persist-bridging-the-gap-between-server-side-rendering-and-client-state-persisted-data-cb89d639f241?source=collection_archive---------1-----------------------#2021-04-15">https://javascript.plainenglish.io/next-persist-bridging-the-gap-between-server-side-rendering-and-client-state-persisted-data-cb89d639f241?source=collection_archive---------1-----------------------#2021-04-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ea0ab538c9559128c9297a820e2c2724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a27Y_O5AwGg7wJjm4bC8Lg.png"/></div></div></figure><p id="3c47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt"> next-persist </em> </strong> <em class="kt">是一个轻量级的</em> <strong class="jx io"> <em class="kt"> NPM包</em> </strong> <em class="kt">开发该包是为了简化存储和协调非关键、持久客户端数据的过程，同时保留Next.js提供的服务器端呈现和静态站点生成的好处。</em></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="65c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们深入了解<a class="ae lb" href="https://www.mostjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> next-persist </strong> </a>如何融入开发人员的生态系统之前，我们需要谈谈Next.js，这是一个由Vercel创建的前沿框架，它使开发人员能够轻松创建和部署应用程序，同时提供快速的加载时间。</p><p id="0a67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Next.js通过将服务器端(SSR)和客户端(CSR)呈现的最佳部分与静态站点生成(SSG)相结合，彻底改变了我们向客户端提供内容的方式。此外，通过抽象配置，如webpack和babel，并结合Vercel的CI/CD，启动并运行您的应用程序变得非常简单。</p><p id="9972" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，伴随这些好处而来的是挑战，特别是对持久客户端数据的处理。</p><p id="5ea9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么是服务器端渲染(SSR)？</strong></p><p id="7ea7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">服务器端呈现根据请求创建每个网页，能够存储和提供动态用户数据。这项技术意味着用户不会因为过多的客户端-服务器通信而体验到延迟。</p><p id="4697" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">SSR的一些好处是，由于浏览器通常能够快速呈现服务器生成的HTML，因此内容可以立即显示。除了要查看的HTML之外，浏览器不需要任何其他信息。搜索引擎优化(SEO)也没有问题，因为网络爬虫会直接查看来自服务器的HTML。</p><p id="a6b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">SSR的缺点是服务器为来自客户端的每个请求构建一个页面。服务器可能会做很多繁重的工作，因为它要加载每个页面，这可能很麻烦。另一个缺点是，虽然服务器总是为每个请求生成HTML，但在内容交付网络(CDN)级别没有缓存内容。</p><h2 id="d27d" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak">什么是客户端渲染(CSR)？</strong></h2><p id="b3c6" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">客户端呈现利用JavaScript on demand在浏览器中呈现每个HTML页面。CSR应用程序不是为每条路线创建一个HTML页面，而是在浏览器中动态生成单独的路线。</p><p id="44e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法的一些好处是，由create-react-app (CRA)等工具生成的Javascript包可以驻留在CDN中。这意味着HTML页面在全球的边缘位置等待，这样用户就可以方便快捷地访问它们。此外，最初没有web服务器与之交互，最初的工作流只是在浏览器和CDN之间。</p><p id="af59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CSR的一些缺点是，在完全处理完创建虚拟DOM的所有Javascript之前，您的浏览器将无法显示任何内容。此外，搜索引擎优化会有一些问题。网络爬虫只会看到一个包含Javascript包的空白HTML页面。</p><p id="5c09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">客户端呈现管理动态路由，无需在每次用户请求不同的路由时刷新页面。相比之下，SSR可以在网站的任何路由的初始负载上显示完全填充的页面。</p><h2 id="36f6" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak"> Next.js + SSR + SSG </strong></h2><p id="6a81" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">Next.js专注于预渲染，本质上是CSR和SSR的结合。预先呈现的页面是一个HTML框架，它正在等待AJAX/XHR用数据重新水合。当获取页面时，内部路由是动态完成的，以利用客户端呈现的网站的优势。</p><p id="4f8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">预渲染包括SSR和静态站点生成(SSG)。与SSR非常相似，SSG在构建时预渲染所有HTML页面，无需客户端渲染。</p><p id="05f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">预渲染应用程序的一个优点是构建时间与用户交互无关，因此即使需要一段时间，用户体验也不会受到影响。一旦SSG页面建成，就可以在CDNs上使用，这意味着用户可以立即使用该页面。最后，因为SSG页面是由CDN提供的，所以没有对web服务器的请求，也不需要web服务器。</p><h2 id="aeed" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak">客户端持久数据</strong></h2><p id="18b5" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">在客户端持久数据出现之前，服务器是存储和访问用户数据的唯一方式。这意味着，每当应用程序必须使用/更新/共享用户数据时，整个应用程序都必须重新呈现给客户端。Cookies是Lou Montulli在web早期创建的客户端持久数据的第一个实现。</p><p id="be43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次请求时，Cookies都会从服务器发送到浏览器。因为它们经常被来回发送，所以最好不要使用它们来存储大量数据，因为这会导致服务器和客户端之间的大量拥塞。</p><p id="febc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现代web浏览器利用Web存储API，允许数据在浏览器中保存为键值对。分配给localStorage的空间更多，具体数量取决于您的浏览器。与cookies非常相似，localStorage中的数据将跨会话保持不变。</p><p id="b8b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，localStorage不会在每个请求时都发送到服务器，web服务器也不能直接写入localStorage。</p><p id="317a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然Next.js非常适合SSR和SSG，但是没有直观的方法来持久化客户端数据。这就是<strong class="jx io"> next-persist </strong>前来救援的地方！</p><h2 id="aaa1" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak">进入下一个-持续</strong></h2><p id="ff0d" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">那么，<strong class="jx io"> next-persist </strong>到底是什么，它是如何绑定到Next.js和持久化客户端数据的呢？<strong class="jx io"> next-persist </strong>是一个轻量级NPM包，旨在简化存储和协调非关键、持久客户端数据的过程，同时保留Next.js提供的SSR和SSG的优势</p><p id="635e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以个人博客为例。在为用户提供某种动态持久化的同时获得Next.js的好处不是很好吗？所有这些都不需要担心额外的数据库管理系统的架构和成本？</p><p id="a024" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以了！<strong class="jx io"> next-persist </strong>为您的动态同构web应用程序提供了一个简单的解决方案。只需导入<strong class="jx io"> next-persist </strong>，设置一个快速配置并整合我们的功能。我们完成剩下的工作，为您提供SSR和客户端持久数据的好处。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="48ae" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak">如何在你的Next.js应用中使用next-persist</strong></h2><p id="1a0a" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">首先，您必须在您喜欢的文本编辑器或IDE中创建一个Next.js应用程序。</p><p id="de82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安装下一个-从终端持续。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="e929" class="lc ld in mf b gy mj mk l ml mm">npm install next-persist</span></pre><p id="7001" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Next.js应用的顶层将<code class="fe mn mo mp mf b">&lt;NextPersistWrapper /&gt;</code>导入到你的前端。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fee4" class="lc ld in mf b gy mj mk l ml mm">// _app.jsx<br/>import PersistWrapper from 'next-persist/lib/NextPersistWrapper';</span></pre><p id="7836" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果利用localStorage来持久化客户端状态:将<code class="fe mn mo mp mf b">{ getStorage }</code>导入到您计划持久化的reducer中。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f367" class="lc ld in mf b gy mj mk l ml mm">// yourReducer.jsx<br/>import { getStorage } from 'next-persist'</span></pre><p id="0ec8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果利用cookies来保存客户端状态:</p><p id="33d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Next.js应用程序的顶层将<code class="fe mn mo mp mf b">{ getCookieProps }</code>导入到你的前端，同时将<code class="fe mn mo mp mf b">{ getCookieStore }</code>导入到你计划保留的任何reducer中。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7082" class="lc ld in mf b gy mj mk l ml mm">// _app.js<br/>import { getCookieProps } from 'next-persist'<br/><br/>// yourReducer.js<br/>import { getCookieStore } from 'next-persist'</span></pre><h2 id="2796" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated">配置</h2><p id="048d" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">next-persist需要一个简单的配置对象，允许您对我们的包的行为进行更改。首先，一个<strong class="jx io">必需的</strong> <code class="fe mn mo mp mf b">method</code>键，指示你想要使用哪种存储方法。第二，一个可选的<code class="fe mn mo mp mf b">allowList</code>键按住一个对象。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0304" class="lc ld in mf b gy mj mk l ml mm">//_app.js<br/><br/>  const npConfig = {<br/>    method: 'localStorage' or 'cookies'<br/>    allowList: {<br/>      reducerOne: ['stateItemOne', 'stateItemTwo'],<br/>      reducerTwo: [],<br/>    },<br/>  };</span></pre><p id="f520" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以设置<code class="fe mn mo mp mf b">allowList</code>键，仅允许特定的减速器将特定的状态存储到所选的存储方法中。<code class="fe mn mo mp mf b">allowList</code>上的键必须与<code class="fe mn mo mp mf b">combineReducers()</code>中减速器的键相对应。要只存储reducer的某些状态，可以将值设置为一个数组，将状态项的名称保存为字符串。</p><p id="8c78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您希望存储reducer的所有状态，请将该值设置为空数组。如果没有提供allowList，next-persist会将所有reducers的所有状态存储到所选的存储方法中。</p><h2 id="3ed2" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated">包装材料</h2><p id="3e0b" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated"><code class="fe mn mo mp mf b">&lt;PersistWrapper /&gt;</code>需要一个标签为<code class="fe mn mo mp mf b">wrapperConfig</code>的道具，该道具将开发者在<code class="fe mn mo mp mf b">_app</code>组件中声明的配置对象作为参数。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9efa" class="lc ld in mf b gy mj mk l ml mm">Example:<br/><br/>  import { Provider } from "react-redux";<br/>  import store from "../client/store";<br/>  import PersistWrapper from 'next-persist/lib/NextPersistWrapper';<br/><br/>  const npConfig = {<br/>    method: 'localStorage'<br/>    allowList: {<br/>      reducerOne: ['stateItemOne', 'stateItemTwo'],<br/>    },<br/>  };<br/><br/>  const MyApp = ({ Component, pageProps }) =&gt; {<br/>    return (<br/>      &lt;Provider store={store}&gt;<br/>        &lt;PersistWrapper wrapperConfig={npConfig}&gt;<br/>          &lt;Component {...pageProps} /&gt;<br/>        &lt;/PersistWrapper&gt;<br/>      &lt;/Provider&gt;<br/>    );<br/>  };<br/><br/>  export default MyApp;</span></pre><h2 id="d01f" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated">还原剂</h2><p id="1698" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">在每个减速器文件中，我们需要从<code class="fe mn mo mp mf b">'next-persist'</code>导入<code class="fe mn mo mp mf b">getLocalStore</code>或<code class="fe mn mo mp mf b">getCookieStore</code>。</p><p id="85fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">声明一个常量，并将调用<code class="fe mn mo mp mf b">getLocalStore</code>或<code class="fe mn mo mp mf b">getCookieStore</code>方法的计算结果的值赋给它。</p><p id="347e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mn mo mp mf b">getLocalStore</code>或<code class="fe mn mo mp mf b">getCookieStore</code>有两个参数:</p><ul class=""><li id="caaf" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">字符串:保存在存储器中的缩减器密钥</li><li id="1916" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">一个对象:reducer文件中声明的初始状态</li></ul><p id="8ec5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将新声明的常量作为state的默认参数传递给reducer。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9d4d" class="lc ld in mf b gy mj mk l ml mm">Example:<br/><br/>  import * as types from '../constants/actionTypes';<br/>  import { getLocalStore } from 'next-persist';<br/>  // or<br/>  // import { getCookieStore } from 'next-persist'<br/><br/>  const initialState = {<br/>    // initialState goes here<br/>    stateItemOne: true,<br/>    stateItemTwo: 0,<br/>    stateItemThree: 'foo',<br/>  };<br/><br/>  const persistedState = getLocalStore('reducerOne', initialState);<br/>  // or<br/>  // const persistedState = getCookieStore('reducerOne', initialState);<br/><br/><br/>  const firstReducer = (state = persistedState, action) =&gt; {<br/>    // switch case logic in here<br/>    switch (action.type) {<br/>    default:<br/>      return state;<br/>    }<br/>  };<br/><br/>  export default firstReducer;</span></pre><h2 id="dc24" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated">饼干</h2><p id="6dc9" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">利用cookie存储方法提供了利用客户端状态和<code class="fe mn mo mp mf b">getInitialProps</code>的好处。但是，由于cookie大小的限制，它不能用于存储大量数据。</p><p id="8b51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我们调用<code class="fe mn mo mp mf b">getInitialProps</code>中的<code class="fe mn mo mp mf b">getCookieProps</code>，它将返回一个包含所有持久状态值的对象，保存在它们的reducer名称的键下。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c8b7" class="lc ld in mf b gy mj mk l ml mm">Example:<br/><br/>  MyApp.getInitialProps = async ({ ctx }) =&gt; {<br/>    const cookieState = getCookieProps(ctx);<br/>    return {<br/>      pageProps: cookieState,<br/>    };<br/>  }<br/><br/>  export default MyApp;</span></pre><h2 id="30bf" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated">结论</h2><p id="013b" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">感谢您的阅读。我们希望这对您有所帮助。如果你在应用中使用next-persist，请在评论中告诉我们你的想法。要了解更多关于<strong class="jx io"> next-persist </strong>的信息，请访问我们的<a class="ae lb" href="https://www.mostjs.org/" rel="noopener ugc nofollow" target="_blank">网站</a>。</p><h2 id="e0ba" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated">贡献的</h2><p id="9a5a" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">如果你愿意为next-persist做贡献，请<a class="ae lb" href="https://github.com/oslabs-beta/next-persist" rel="noopener ugc nofollow" target="_blank">叉本回购</a>。将您的更改提交到命名良好的功能分支，然后打开一个“拉”请求。我们感谢您对这个开源项目的贡献！</p><h2 id="d488" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated">保持器</h2><ul class=""><li id="1227" class="mq mr in jx b jy lv kc lw kg ne kk nf ko ng ks mv mw mx my bi translated">朱敏瀚:<a class="ae lb" href="https://github.com/darthchu" rel="noopener ugc nofollow" target="_blank">GitHub</a>/<a class="ae lb" href="https://www.linkedin.com/in/brianwilliamchu/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></li><li id="ee5c" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">克里斯托弗·博瑟曼:<a class="ae lb" href="https://github.com/christopherpbosserman" rel="noopener ugc nofollow" target="_blank">GitHub</a>/<a class="ae lb" href="https://www.linkedin.com/in/christopherpbosserman/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></li><li id="75ed" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">格雷格·莱文-罗泽万恩:<a class="ae lb" href="https://github.com/grishaLR" rel="noopener ugc nofollow" target="_blank">GitHub</a>/<a class="ae lb" href="https://www.linkedin.com/in/gregory-levine-rozenvayn/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></li><li id="0dce" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">马修·萨尔瓦多:<a class="ae lb" href="https://github.com/mjsalvador" rel="noopener ugc nofollow" target="_blank"> GitHub </a> / <a class="ae lb" href="https://www.linkedin.com/in/matthewsalvador/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></li></ul><p id="dae9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lb" href="https://www.mostjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> next-persist </strong> </a>是在<a class="ae lb" href="https://github.com/open-source-labs" rel="noopener ugc nofollow" target="_blank"> OSLabs </a>的支持下打造的</p><p id="c3b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">由</em> <a class="ae lb" href="http://medium.com/@darthchu" rel="noopener"> <strong class="jx io"> <em class="kt">【朱敏瀚】</em></strong></a><strong class="jx io"><em class="kt"/></strong><a class="ae lb" href="https://medium.com/@christopherpbosserman" rel="noopener"><strong class="jx io"><em class="kt">博瑟曼</em></strong></a><strong class="jx io"><em class="kt"/></strong><a class="ae lb" href="http://medium.com/@grisha617" rel="noopener"><strong class="jx io"><em class="kt">格雷戈里-莱文</em></strong></a><strong class="jx io"><em class="kt"/></strong><em class="kt"/></p><p id="1155" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容请看</em><a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>