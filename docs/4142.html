<html>
<head>
<title>Build a Quick, Simple, and Secure Local Web Server on Windows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Windows上构建快速、简单、安全的本地Web服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-quick-simple-and-secure-local-web-server-on-windows-ab7cee4ce6f4?source=collection_archive---------18-----------------------#2021-08-17">https://javascript.plainenglish.io/build-a-quick-simple-and-secure-local-web-server-on-windows-ab7cee4ce6f4?source=collection_archive---------18-----------------------#2021-08-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8468" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用Node.js、Chocolatey和mkcert的简单指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4d1675cf8775a1e7536e76156ae725b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rseyex9qE95D_-9ksecuQw.jpeg"/></div></div></figure><p id="1b40" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这篇文章是一个小练习，在不使用<a class="ae lk" href="https://expressjs.com/en/guide/routing.html" rel="noopener ugc nofollow" target="_blank"> express </a>的情况下创建一个简单的本地服务器，并通过添加一个通过<a class="ae lk" href="https://github.com/FiloSottile/mkcert" rel="noopener ugc nofollow" target="_blank"> mkcert </a>(和<a class="ae lk" href="https://chocolatey.org/" rel="noopener ugc nofollow" target="_blank"> chocolatey </a>)创建的证书使其在Windows上安全。我最近尝试了这一点，但在尝试设置一切时发现了一些棘手的问题。所以我想从一个地方收集的信息中提取精华，并潜在地帮助新的和/或刚刚开始的人。</p><h2 id="664e" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">目录</h2><ol class=""><li id="e5dc" class="me mf in kq b kr mg ku mh kx mi lb mj lf mk lj ml mm mn mo bi translated"><a class="ae lk" href="#293d" rel="noopener ugc nofollow">项目设置</a></li><li id="ab0c" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><a class="ae lk" href="#4f0c" rel="noopener ugc nofollow">构建服务器</a></li><li id="c8ed" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><a class="ae lk" href="#9d67" rel="noopener ugc nofollow">使用巧克力并设置mkcert </a></li></ol><h1 id="293d" class="mu lm in bd ln mv mw mx lq my mz na lt jt nb ju lw jw nc jx lz jz nd ka mc ne bi translated">项目设置</h1><p id="d913" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">假设您已经安装了node，创建一个项目文件夹(如果您还没有)并添加两个文件中的第一个，我们的<code class="fe ni nj nk nl b">package.json</code>。</p><p id="bf5b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">打开命令提示符并导航到该文件夹(或者如果您使用的是<a class="ae lk" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>，使用它的终端)，然后通过使用<code class="fe ni nj nk nl b">npm init</code>命令并回答几个问题来创建<code class="fe ni nj nk nl b">package.json</code>。如果不确定，<a class="ae lk" href="https://docs.npmjs.com/creating-a-package-json-file#creating-a-default-packagejson-file" rel="noopener ugc nofollow" target="_blank">查看文档</a>了解更多信息。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="9338" class="ll lm in nl b gy nq nr l ns nt">npm init</span></pre><p id="95f5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这应该会在项目文件夹中创建<code class="fe ni nj nk nl b">package.json</code>文件。接下来，运行下面的命令来安装节点包<code class="fe ni nj nk nl b">nodemon</code>。这个<a class="ae lk" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank">有用的包</a>在检测到项目文件中的变化时会自动重启服务器。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="5e40" class="ll lm in nl b gy nq nr l ns nt">npm install --save-dev nodemon</span></pre><p id="4b56" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将把它添加为开发依赖项，我们在npm脚本中使用它来启动/运行我们的服务器。在您的<code class="fe ni nj nk nl b">package.json</code>中，在测试脚本下面添加一个名为<code class="fe ni nj nk nl b">“start”</code>的脚本，带有以下选项:</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="ea6c" class="ll lm in nl b gy nq nr l ns nt">// in package.json</span><span id="ef9a" class="ll lm in nl b gy nu nr l ns nt">"scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "start": "nodemon -e js,html -- server.js"<br/>},</span></pre><p id="91ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里我们告诉nodemon，当它检测到扩展名为<code class="fe ni nj nk nl b">.js</code>和<code class="fe ni nj nk nl b">.html</code>的文件发生变化时，重新启动我们的<code class="fe ni nj nk nl b">server.js</code>。所以你可以随意定制你认为合适的。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="4f0c" class="mu lm in bd ln mv oc mx lq my od na lt jt oe ju lw jw of jx lz jz og ka mc ne bi translated">构建服务器</h1><p id="0c47" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">接下来，在与我们的<code class="fe ni nj nk nl b">package.json</code>相同的文件夹中，我们将添加第二个文件，命名为<code class="fe ni nj nk nl b">server.js</code>。首先从以下节点模块创建几个变量:</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="2b21" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="4232" class="ll lm in nl b gy nu nr l ns nt">const https = require(“https”);<br/>const fs = require(“fs”);<br/>const path = require(“path”);</span></pre><p id="19e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将使用这些模块来执行传输和读取项目中可能包含的各种类型文件的数据的功能。</p><p id="730c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ni nj nk nl b"><a class="ae lk" href="https://www.w3schools.com/nodejs/ref_https.asp" rel="noopener ugc nofollow" target="_blank">https</a></code>用于通过HTTP TLS/SSL协议(https://)进行数据传输。</p><p id="eee5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ni nj nk nl b"><a class="ae lk" href="https://www.w3schools.com/nodejs/nodejs_filesystem.asp" rel="noopener ugc nofollow" target="_blank">fs</a></code>用于与您计算机的文件系统进行交互。</p><p id="3b30" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ni nj nk nl b"><a class="ae lk" href="https://www.w3schools.com/nodejs/ref_path.asp" rel="noopener ugc nofollow" target="_blank">path</a></code>提供使用文件和目录路径的有用方法。</p><p id="f340" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，我们将在刚刚添加的变量下再添加几个变量:</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="70fc" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="9e2a" class="ll lm in nl b gy nu nr l ns nt">const https = require(“https”);<br/>const fs = require(“fs”);<br/>const path = require(“path”);</span><span id="2e43" class="ll lm in nl b gy nu nr l ns nt">const certPath = path.resolve("");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "")),<br/>};</span></pre><p id="22b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这几行代码只是设置让我们的HTTPS服务器获得正确的凭证和本地主机地址所需的内容。<code class="fe ni nj nk nl b">certpath</code>将是我们的<code class="fe ni nj nk nl b">key </code>和<code class="fe ni nj nk nl b">cert</code>(证书)文件的父文件夹，它们是我们的<code class="fe ni nj nk nl b">httpsConfig</code>对象的一部分。这些空字符串<code class="fe ni nj nk nl b">“”</code>将在稍后用文件名更新。</p><p id="cd17" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">继续添加一个存储服务器逻辑的服务器变量。在https模块的<code class="fe ni nj nk nl b">createServer</code>方法中，对于第一个参数，我们将传入<code class="fe ni nj nk nl b">httpsConf</code>对象，对于第二个参数，我们添加了一个<code class="fe ni nj nk nl b">requestListener</code>函数，其中有两个参数<code class="fe ni nj nk nl b">req</code>用于请求，<code class="fe ni nj nk nl b">res</code>用于响应。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="d018" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="b8fc" class="ll lm in nl b gy nu nr l ns nt">const https = require(“https”);<br/>const fs = require(“fs”);<br/>const path = require(“path”);</span><span id="4559" class="ll lm in nl b gy nu nr l ns nt">const certPath = path.resolve("");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "")),<br/>};<br/>const server = https.createServer(httpsConfig, (req, res) =&gt; {<br/>     <br/>});</span></pre><p id="f48a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们将添加几行。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="ad31" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="3299" class="ll lm in nl b gy nu nr l ns nt">const https = require(“https”);<br/>const fs = require(“fs”);<br/>const path = require(“path”);</span><span id="26e8" class="ll lm in nl b gy nu nr l ns nt">const certPath = path.resolve("");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "")),<br/>};<br/>const server = https.createServer(httpsConfig, (req, res) =&gt; {<br/>     let pathname = `/public/${req.url}`;<br/>     const ext = path.parse(pathname).ext == "" ? ".html" :   <br/>     path.parse(pathname).ext;<br/>     console.log(`${req.method} ${pathname}`);<br/>});</span></pre><p id="38d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ni nj nk nl b">pathname</code>是相对于我的客户端资产存储的位置，所以我想确保我的所有请求都指向我的项目中的那个位置。根据项目需要，随意更改或省略。</p><p id="0af5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ni nj nk nl b">ext</code>是将存储所请求的文件扩展名的变量(或默认为“.”。html”)用于稍后选择正确的MIME类型。</p><p id="2a58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ni nj nk nl b">console.log</code>只是在我们的命令窗口/终端中显示请求方法(<code class="fe ni nj nk nl b">req.method</code>)和<code class="fe ni nj nk nl b">pathname</code>，无论我们的服务器处理什么，如下所示。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/0773f0d254799ae40405bcc5fcdd35a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YxF5eHw4O0b73xvkGAJjQ.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">What the <code class="fe ni nj nk nl b">console.log</code> is for</figcaption></figure><p id="b032" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，我们为文件扩展名添加一个对象</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="617e" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="9bb8" class="ll lm in nl b gy nu nr l ns nt">const https = require(“https”);<br/>const fs = require(“fs”);<br/>const path = require(“path”);</span><span id="fd10" class="ll lm in nl b gy nu nr l ns nt">const certPath = path.resolve("");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "")),<br/>};<br/>const server = https.createServer(httpsConfig, (req, res) =&gt; {<br/>     let pathname = `/public/${req.url}`;<br/>     const ext = path.parse(pathname).ext == "" ? ".html" :   <br/>     path.parse(pathname).ext;<br/>     console.log(`${req.method} ${pathname}`);</span><span id="caab" class="ll lm in nl b gy nu nr l ns nt">     const map = {<br/>          ".ico": "image/x-icon",<br/>          ".html": "text/html",<br/>          ".js": "text/javascript",<br/>          ".json": "application/json",<br/>          ".css": "text/css",<br/>          ".png": "image/png",<br/>          ".jpg": "image/jpeg",<br/>          ".wav": "audio/wav",<br/>          ".mp3": "audio/mpeg",<br/>          ".svg": "image/svg+xml",<br/>          ".pdf": "application/pdf",<br/>          ".doc": "application/msword",<br/>     };<br/>});</span></pre><p id="f049" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ni nj nk nl b">map</code>用于根据文件扩展名确定<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types" rel="noopener ugc nofollow" target="_blank"> MIME类型</a>，它将被合并，让我们的服务器为每个响应动态设置<code class="fe ni nj nk nl b">Content-Type</code>头。</p><p id="5b76" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来的代码是可选的，也是唯一的，但我相信它会派上用场。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="fdac" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="6d85" class="ll lm in nl b gy nu nr l ns nt">const https = require(“https”);<br/>const fs = require(“fs”);<br/>const path = require(“path”);</span><span id="b9d8" class="ll lm in nl b gy nu nr l ns nt">const certPath = path.resolve("");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "")),<br/>};<br/>const server = https.createServer(httpsConfig, (req, res) =&gt; {<br/>     let pathname = `/public/${req.url}`;<br/>     const ext = path.parse(pathname).ext == "" ? ".html" :   <br/>     path.parse(pathname).ext;<br/>     console.log(`${req.method} ${pathname}`);</span><span id="a3e9" class="ll lm in nl b gy nu nr l ns nt">     const map = {<br/>          ".ico": "image/x-icon",<br/>          ".html": "text/html",<br/>          ".js": "text/javascript",<br/>          ".json": "application/json",<br/>          ".css": "text/css",<br/>          ".png": "image/png",<br/>          ".jpg": "image/jpeg",<br/>          ".wav": "audio/wav",<br/>          ".mp3": "audio/mpeg",<br/>          ".svg": "image/svg+xml",<br/>          ".pdf": "application/pdf",<br/>          ".doc": "application/msword",<br/>     };</span><span id="bb32" class="ll lm in nl b gy nu nr l ns nt">     if (fs.statSync(pathname).isDirectory()) {<br/>          pathname = pkgPaths.public + "/index.html";<br/>     } else if (<br/>          !pathname.match("^/images")<br/>          &amp;&amp; ext == ".html"<br/>          &amp;&amp; !pathname.match(".html$")<br/>     ) {<br/>       pathname = pathname + ext;<br/>     }<br/>});</span></pre><p id="5b19" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一个<code class="fe ni nj nk nl b">if/else</code>处理如果<code class="fe ni nj nk nl b">pathname</code>是一个目录或者一个不是HTML文件的文件会发生什么。对于前者，我们寻找根文件夹的<code class="fe ni nj nk nl b">index.html</code>文件。如果是后者，我们将文件扩展名添加到<code class="fe ni nj nk nl b">pathname</code>。(虽然这可能可以处理得更好，但我发现它满足了我的需求，所以我认为分享它不会有什么坏处。)</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="5cde" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="579b" class="ll lm in nl b gy nu nr l ns nt">const https = require("https");<br/>const fs = require("fs");<br/>const path = require("path");<br/>const certPath = path.resolve("");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "")),<br/>};<br/>const server = https.createServer(httpsConfig, (req, res) =&gt; {<br/>     let pathname = `/public/${req.url}`;<br/>     const ext = path.parse(pathname).ext == "" ? ".html" :   <br/>     path.parse(pathname).ext;<br/>     console.log(`${req.method} ${pathname}`);<br/>     const map = {<br/>          ".ico": "image/x-icon",<br/>          ".html": "text/html",<br/>          ".js": "text/javascript",<br/>          ".json": "application/json",<br/>          ".css": "text/css",<br/>          ".png": "image/png",<br/>          ".jpg": "image/jpeg",<br/>          ".wav": "audio/wav",<br/>          ".mp3": "audio/mpeg",<br/>          ".svg": "image/svg+xml",<br/>          ".pdf": "application/pdf",<br/>          ".doc": "application/msword",<br/>     };<br/>     if (fs.statSync(pathname).isDirectory()) {<br/>          pathname = pkgPaths.public + "/index.html";<br/>     } else if (<br/>          !pathname.match("^/images")<br/>          &amp;&amp; ext == ".html"<br/>          &amp;&amp; !pathname.match(".html$")<br/>     ) {<br/>       pathname = pathname + ext;<br/>     }</span><span id="c546" class="ll lm in nl b gy nu nr l ns nt">     fs.stat(pathname, function (err, stats) {<br/>          if (err) {<br/>               res.statusCode = 404;<br/>               res.end(`File ${pathname} not found!`);<br/>               return;<br/>          }</span><span id="8ba3" class="ll lm in nl b gy nu nr l ns nt">          fs.readFile(pathname, (err, data) =&gt; {<br/>               if (err) {<br/>                    console.log(err);<br/>                    res.writeHead(500);<br/>                    res.end(err);<br/>                    return;<br/>               }<br/>               res.setHeader("Content-Type", map[ext]<br/>               || "text/plain");<br/>               res.writeHead(200);<br/>               res.end(data);<br/>          });<br/>     });<br/>});</span></pre><p id="ecf6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的<code class="fe ni nj nk nl b">requestListener</code>的最后一部分试图使用<code class="fe ni nj nk nl b"><a class="ae lk" href="https://www.geeksforgeeks.org/node-js-fs-stat-method/https://www.geeksforgeeks.org/node-js-fs-stat-method/" rel="noopener ugc nofollow" target="_blank">fs.stat</a></code>方法获得由<code class="fe ni nj nk nl b">pathname</code>提供的文件的细节。我们通过返回一个404<code class="fe ni nj nk nl b">statusCode</code>和一个响应(找不到文件[路径名]！).如果没有错误发生，我们尝试使用<code class="fe ni nj nk nl b">fs.readFile</code>打开文件并相应地处理它。要么是一个<code class="fe ni nj nk nl b">500</code>错误，要么是使用<code class="fe ni nj nk nl b">res.setHeader</code>、我们的<code class="fe ni nj nk nl b">map</code>对象(或者默认为<code class="fe ni nj nk nl b">text/plain</code>)和之前的<code class="fe ni nj nk nl b">ext</code>应用正确的<em class="om"> MIME类型</em>，然后将文件提供给浏览器。</p><p id="b457" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们添加了将在服务器启动(重启)时运行的<code class="fe ni nj nk nl b">server.listen</code>方法。记录主机名和端口，所以可以随意定制。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="583e" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="dc58" class="ll lm in nl b gy nu nr l ns nt">const https = require("https");<br/>const fs = require("fs");<br/>const path = require("path");<br/>const certPath = path.resolve("");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "")),<br/>};<br/>const server = https.createServer(httpsConfig, (req, res) =&gt; {<br/>     let pathname = `/public/${req.url}`;<br/>     const ext = path.parse(pathname).ext == "" ? ".html" :   <br/>     path.parse(pathname).ext;<br/>     console.log(`${req.method} ${pathname}`);<br/>     const map = {<br/>          ".ico": "image/x-icon",<br/>          ".html": "text/html",<br/>          ".js": "text/javascript",<br/>          ".json": "application/json",<br/>          ".css": "text/css",<br/>          ".png": "image/png",<br/>          ".jpg": "image/jpeg",<br/>          ".wav": "audio/wav",<br/>          ".mp3": "audio/mpeg",<br/>          ".svg": "image/svg+xml",<br/>          ".pdf": "application/pdf",<br/>          ".doc": "application/msword",<br/>     };<br/>     if (fs.statSync(pathname).isDirectory()) {<br/>          pathname = pkgPaths.public + "/index.html";<br/>     } else if (<br/>          !pathname.match("^/images")<br/>          &amp;&amp; ext == ".html"<br/>          &amp;&amp; !pathname.match(".html$")<br/>     ) {<br/>       pathname = pathname + ext;<br/>     }<br/>     fs.stat(pathname, function (err, stats) {<br/>          if (err) {<br/>               res.statusCode = 404;<br/>               res.end(`File ${pathname} not found!`);<br/>               return;<br/>          }<br/>          fs.readFile(pathname, (err, data) =&gt; {<br/>               if (err) {<br/>                    console.log(err);<br/>                    res.writeHead(500);<br/>                    res.end(err);<br/>                    return;<br/>               }<br/>               res.setHeader("Content-Type", map[ext]<br/>               || "text/plain");<br/>               res.writeHead(200);<br/>               res.end(data);<br/>          });<br/>     });<br/>});</span><span id="7d5e" class="ll lm in nl b gy nu nr l ns nt">server.listen(port, hostname, () =&gt; {<br/>  console.log(`Server is listening at      <a class="ae lk" href="https://${hostname}:${port}/`" rel="noopener ugc nofollow" target="_blank">https://${hostname}:${port}/`</a>);<br/>});</span></pre><p id="908b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">恭喜你走到这一步，并完成了我们的服务器。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="9d67" class="mu lm in bd ln mv oc mx lq my od na lt jt oe ju lw jw of jx lz jz og ka mc ne bi translated">使用Chocolatey并设置mkcert</h1><p id="9167" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">有几种方法可以把mkcert添加到你的windows机器上，但是我选择了Chocolatey。<a class="ae lk" href="https://chocolatey.org/install#install-step2" rel="noopener ugc nofollow" target="_blank">按照这些说明</a>正确安装Chocolatey，然后从提升的/管理PowerShell窗口运行以下命令。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="879f" class="ll lm in nl b gy nq nr l ns nt">&gt; choco install mkcert</span></pre><p id="ed1c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦安装了mkcert，创建一个本地的<a class="ae lk" href="https://en.wikipedia.org/wiki/Certificate_authority" rel="noopener ugc nofollow" target="_blank">证书颁发机构</a>，它将对证书进行签名。现在运行下面的命令。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="183e" class="ll lm in nl b gy nq nr l ns nt">&gt; mkcert -install</span></pre><p id="9ab8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您应该会看到如下所示的内容</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="8102" class="ll lm in nl b gy nq nr l ns nt">Created a new local CA 💥<br/>The local CA is now installed in the system trust store! ⚡️<br/>The local CA is now installed in the Firefox trust store (requires browser restart)! 🦊</span></pre><p id="638b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，运行此命令为您的localhost项目创建证书。您可以根据需要添加<code class="fe ni nj nk nl b">localhost</code>、<code class="fe ni nj nk nl b">127.0.0.1</code>、域名(<code class="fe ni nj nk nl b">example.com</code>)或通配符子域(<code class="fe ni nj nk nl b">*.example.com</code>)，等等。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="cc92" class="ll lm in nl b gy nq nr l ns nt">&gt; mkcert localhost example.com *.example.com</span></pre><p id="749d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您应该会看到类似下面的内容</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="a4b5" class="ll lm in nl b gy nq nr l ns nt">Created a new certificate valid for the following names 📜 <br/>- "localhost"<br/>- "example.com" <br/>- "*.example.com"  </span><span id="6857" class="ll lm in nl b gy nu nr l ns nt">The certificate is at "./localhost+2.pem" and the key at "./localhost+2-key.pem" ✅</span></pre><p id="89c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们使用认证和认证文件的父文件夹来更新我们的<code class="fe ni nj nk nl b">server.js</code>文件。如果您需要帮助找到您的证书的根文件夹，您可以使用命令<code class="fe ni nj nk nl b">mkcert -CAROOT</code>。</p><p id="4d4e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">父文件夹的路径将分别用于<code class="fe ni nj nk nl b">certPath</code>和<code class="fe ni nj nk nl b">httpsConfig</code>对象的密钥和证书属性的文件名。</p><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="7ae1" class="ll lm in nl b gy nq nr l ns nt">const certPath = path.resolve("C:\\PathTo\\Certs");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "localhost+2-key.pem")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "localhost+2.pem")),<br/>};</span></pre></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h2 id="6214" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">最后看一下server.js</h2><pre class="kd ke kf kg gt nm nl nn no aw np bi"><span id="97d8" class="ll lm in nl b gy nq nr l ns nt">// in server.js</span><span id="f13b" class="ll lm in nl b gy nu nr l ns nt">const https = require("https");<br/>const fs = require("fs");<br/>const path = require("path");<br/>const certPath = path.resolve("C:\\PathTo\\Certs");<br/>const hostname = "localhost";<br/>const port = 5000;<br/>const httpsConfig = {<br/>     key: fs.readFileSync(path.resolve(certPath, "localhost+2-key.pem")),<br/>     cert: fs.readFileSync(path.resolve(certPath, "localhost+2.pem")),<br/>};<br/>const server = https.createServer(httpsConfig, (req, res) =&gt; {<br/>     let pathname = `/public/${req.url}`;<br/>     const ext = path.parse(pathname).ext == "" ? ".html" :   <br/>     path.parse(pathname).ext;<br/>     console.log(`${req.method} ${pathname}`);<br/>     const map = {<br/>          ".ico": "image/x-icon",<br/>          ".html": "text/html",<br/>          ".js": "text/javascript",<br/>          ".json": "application/json",<br/>          ".css": "text/css",<br/>          ".png": "image/png",<br/>          ".jpg": "image/jpeg",<br/>          ".wav": "audio/wav",<br/>          ".mp3": "audio/mpeg",<br/>          ".svg": "image/svg+xml",<br/>          ".pdf": "application/pdf",<br/>          ".doc": "application/msword",<br/>     };<br/>     if (fs.statSync(pathname).isDirectory()) {<br/>          pathname = pkgPaths.public + "/index.html";<br/>     } else if (<br/>          !pathname.match("^/images")<br/>          &amp;&amp; ext == ".html"<br/>          &amp;&amp; !pathname.match(".html$")<br/>     ) {<br/>       pathname = pathname + ext;<br/>     }<br/>     fs.stat(pathname, function (err, stats) {<br/>          if (err) {<br/>               res.statusCode = 404;<br/>               res.end(`File ${pathname} not found!`);<br/>               return;<br/>          }<br/>          fs.readFile(pathname, (err, data) =&gt; {<br/>               if (err) {<br/>                    console.log(err);<br/>                    res.writeHead(500);<br/>                    res.end(err);<br/>                    return;<br/>               }<br/>               res.setHeader("Content-Type", map[ext]<br/>               || "text/plain");<br/>               res.writeHead(200);<br/>               res.end(data);<br/>          });<br/>     });<br/>});</span><span id="b7f6" class="ll lm in nl b gy nu nr l ns nt">server.listen(port, hostname, () =&gt; {<br/>  console.log(`Server is listening at      <a class="ae lk" href="https://${hostname}:${port}/`" rel="noopener ugc nofollow" target="_blank">https://${hostname}:${port}/`</a>);<br/>});</span></pre><h2 id="d02b" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">大结局！</h2><p id="91a9" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">使用前面在<code class="fe ni nj nk nl b">package.json</code>中创建的脚本命令，运行<code class="fe ni nj nk nl b">start</code>命令，并在服务器监听的路径下访问您的项目。</p><p id="5b3b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">柯克·克拉克</p><p id="e507" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">图片来源:<a class="ae lk" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae lk" href="https://unsplash.com/s/photos/windows-secure-certificate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p><p id="f8d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="om">更多内容请看</em><a class="ae lk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="om">plain English . io</em></a></p></div></div>    
</body>
</html>