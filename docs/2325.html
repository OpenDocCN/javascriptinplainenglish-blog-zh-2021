<html>
<head>
<title>5 Advanced React Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5种高级反应模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-advanced-react-patterns-a6b7624267a6?source=collection_archive---------0-----------------------#2021-05-15">https://javascript.plainenglish.io/5-advanced-react-patterns-a6b7624267a6?source=collection_archive---------0-----------------------#2021-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7120" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">概述5种现代高级React模式，包括集成代码、优缺点以及在公共图书馆中的具体使用。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/be7d198d7a772e989d48fbdf41bc527d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDLXhIsh_ceBpN_MGCaotw.png"/></div></div></figure><p id="4693" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像每个React开发人员一样，您可能已经问过自己以下问题之一:</p><ul class=""><li id="6b67" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">我如何构建一个<strong class="jm io">可重用的</strong>组件来适应不同的用例？</li><li id="9e1f" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">我如何用一个简单的API来构建一个组件，使其易于使用？</li><li id="1618" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">就UI和功能而言，我如何构建一个可扩展的组件？</li></ul><p id="41d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些重复出现的问题导致了整个React社区中的一些高级模式。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><blockquote class="lq lr ls"><p id="fc69" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">在本文中，我们将考虑React开发人员(您)为其他开发人员构建组件的情况。</p></blockquote><p id="f3b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将看到5种模式的概述。为了便于比较，我们将对它们使用相同的结构:</p><p id="ffc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">a.模式介绍<br/> b .代码示例(基于一个简单的<code class="fe lw lx ly lz b">Counter</code>组件)</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/11a4cfdc51f705b765b8b868f29a4d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*_miRfZkNA8YkhIBSCywBdQ.png"/></div></figure><blockquote class="lq lr ls"><p id="3d9c" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">代码可以在github上获得:<a class="ae mb" href="https://github.com/alexis-regnaud/advanced-react-patterns" rel="noopener ugc nofollow" target="_blank">高级反应模式</a></p></blockquote><p id="02ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">c.利弊标准。基于两个因素:</p><ul class=""><li id="fafb" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><a class="ae mb" href="https://kentcdodds.com/blog/inversion-of-control" rel="noopener ugc nofollow" target="_blank">控制反转</a>:给予使用你的组件的开发者的灵活性和控制水平。</li><li id="2165" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">实现复杂性:您和开发人员实现模式的难度。</li></ul><p id="e6db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">e.公共图书馆在生产中使用该模式。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h2 id="6eaa" class="mc md in bd me mf mg dn mh mi mj dp mk jv ml mm mn jz mo mp mq kd mr ms mt mu bi translated">1.复合组件模式</h2><p id="6aee" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">这种模式使得创建表达性和声明性组件成为可能，同时避免了<a class="ae mb" href="https://kentcdodds.com/blog/prop-drilling" rel="noopener ugc nofollow" target="_blank">道具演练</a>。如果您想要一个可定制的组件，具有更好的关注点分离和可理解的API，可以考虑使用这种模式。</p><p id="b0f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例</strong></p><blockquote class="lq lr ls"><p id="e4f9" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">Github: <a class="ae mb" href="https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/compound-component" rel="noopener ugc nofollow" target="_blank">复合组件</a></p></blockquote><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="05ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">优点</strong></p><ul class=""><li id="ed5a" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">降低API的复杂性:避免将所有的道具都塞在一个巨大的父组件中，并向下钻取到子UI组件。相反，道具被附在最有意义的<code class="fe lw lx ly lz b">Counter</code>的孩子身上。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nc"><img src="../Images/03015b892dbe35f0cb32469e69543abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w85jLF0VEja0MAveEg4w1A.png"/></div></div></figure><ul class=""><li id="180f" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">灵活的标记结构:通过允许创建各种案例来提供很大的UI灵活性。例如，开发人员可以很容易地改变<code class="fe lw lx ly lz b">Counter</code>孩子的顺序，或者定义应该显示哪个孩子。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nd"><img src="../Images/3f73e586e5a75be69254e77c67be959d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jExoAFGc1T-EhZe1F-3TA.png"/></div></div></figure><ul class=""><li id="dfac" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">关注点分离:大部分逻辑集中在<code class="fe lw lx ly lz b">Counter</code>中。上下文(<code class="fe lw lx ly lz b">CounterProvider</code> + <code class="fe lw lx ly lz b">useCounterContext</code>)用于在<code class="fe lw lx ly lz b">Counter</code>的子节点间共享状态(<code class="fe lw lx ly lz b">counter</code>)和处理程序(<code class="fe lw lx ly lz b">handleIncrement()</code>、<code class="fe lw lx ly lz b">handleDecrement()</code>)。这给了我们明确的责任分配。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ne"><img src="../Images/e23842aefbc1e7b85ae15f9759b08d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMgnhqwbOb6jA_q0rt4kEA.png"/></div></div></figure><p id="ec5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">缺点</strong></p><ul class=""><li id="4cad" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">过多的UI灵活性:拥有这种级别的灵活性也会导致最初没有预料到的情况(例如:不需要的代码、错误的计数器子级顺序、缺少必需的子级)。<br/>根据您的使用情况，您可能不希望有太大的灵活性。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nf"><img src="../Images/b1cde42f895416ecb10e0534942966f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ax33uL1Vk8gWTbuVZpPwoQ.png"/></div></div></figure><ul class=""><li id="51bc" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">更重的JSX:这种模式将增加JSX行数，尤其是当您使用linter ( <code class="fe lw lx ly lz b">EsLint</code> <strong class="jm io"> ) </strong>或code formatted ( <code class="fe lw lx ly lz b">Prettier</code>)时。<br/>从单个组件的规模来看，这似乎没什么大不了的，但从全局来看，这肯定会产生巨大的影响。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ng"><img src="../Images/b0b1e1f1a9688513abf800c6748e653b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gl77TWP-Hnp0AmaLx5aS9Q.png"/></div></div></figure><p id="3fa6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">标准</strong></p><ul class=""><li id="3916" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">控制反转:1/4</li><li id="21f5" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">实施复杂性:1/4</li></ul><p id="038e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">使用这种模式的公共图书馆</strong></p><ul class=""><li id="8a20" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><a class="ae mb" href="https://react-bootstrap.github.io/components/dropdowns/" rel="noopener ugc nofollow" target="_blank">反应自举</a></li><li id="8b94" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><a class="ae mb" href="https://reach.tech/accordion" rel="noopener ugc nofollow" target="_blank"> Reach UI </a></li></ul></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h2 id="828e" class="mc md in bd me mf mg dn mh mi mj dp mk jv ml mm mn jz mo mp mq kd mr ms mt mu bi translated">2.控制道具模式</h2><p id="da35" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">这种模式将您的组件变成了一个<a class="ae mb" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">受控组件</a>。外部状态被作为“真实的单一来源”使用，允许开发人员插入他们自己的逻辑来修改默认的组件行为。</p><p id="2237" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例</strong></p><blockquote class="lq lr ls"><p id="391b" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">Github: <a class="ae mb" href="https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/control-props" rel="noopener ugc nofollow" target="_blank">控制道具</a></p></blockquote><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c81f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">优点</strong></p><ul class=""><li id="1f45" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">给予更多的控制:由于开发人员控制主状态，他们可以直接影响<code class="fe lw lx ly lz b">Counter</code>的行为。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nh"><img src="../Images/a34983ce11b91ca278361fb6108cfbe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luPxit07FeKtThFMAj3fVA.png"/></div></div></figure><p id="7e75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">缺点</strong></p><ul class=""><li id="e5fe" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">实现复杂性:以前，一次集成(<code class="fe lw lx ly lz b">JSX</code>)就足以让组件工作。现在它分布在三个不同的地方(<code class="fe lw lx ly lz b">JSX</code> / <code class="fe lw lx ly lz b">useState</code> / <code class="fe lw lx ly lz b">handleChange</code>)。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ng"><img src="../Images/73b93b436e5831420b1803d32a016dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjUOV3IsHwnICXTJQDyN8w.png"/></div></div></figure><p id="0389" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">标准</strong></p><ul class=""><li id="3353" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">控制反转:2/4</li><li id="887b" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">实施复杂性:1/4</li></ul><p id="995e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">使用这种模式的公共图书馆</strong></p><ul class=""><li id="8eb7" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><a class="ae mb" href="https://material-ui.com/components/rating/#rating" rel="noopener ugc nofollow" target="_blank">材料界面</a></li></ul></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h2 id="35ba" class="mc md in bd me mf mg dn mh mi mj dp mk jv ml mm mn jz mo mp mq kd mr ms mt mu bi translated">3.自定义挂钩模式</h2><p id="7631" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">让我们在“控制的倒置”中更进一步:主逻辑现在被移动到一个自定义钩子中。这个钩子暴露了几个内部逻辑(<code class="fe lw lx ly lz b">States</code>、<code class="fe lw lx ly lz b">Handlers</code>)，这给了开发人员很大的控制权。</p><p id="4870" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例</strong></p><blockquote class="lq lr ls"><p id="e66f" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">Github: <a class="ae mb" href="https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/custom-hooks" rel="noopener ugc nofollow" target="_blank">定制挂钩</a></p></blockquote><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cd80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">职业选手</strong></p><ul class=""><li id="e8f1" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">给予更多的控制:开发者可以在<code class="fe lw lx ly lz b">useCounter</code>和<code class="fe lw lx ly lz b">Counter</code>之间插入他们自己的逻辑，使得他们可以修改默认的<code class="fe lw lx ly lz b">Counter</code>行为。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ni"><img src="../Images/94fcdc6c486e9f0e771e4befd56a9a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CoCzzseCI0A5K-YwZOu3Ig.png"/></div></div></figure><p id="bedb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Cons </strong></p><ul class=""><li id="0828" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">实现的复杂性:因为逻辑部分与渲染部分是分开的，所以由开发人员来链接两者。因此，有必要很好地理解<code class="fe lw lx ly lz b">Counter</code>是如何工作的，以正确地实施它。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ni"><img src="../Images/2c969125e978ad62b37f5f845a9a5ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a75EVVp0p8u_puLd3aOOMQ.png"/></div></div></figure><p id="16de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">标准</strong></p><ul class=""><li id="cbec" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">控制反转:2/4</li><li id="411c" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">实施复杂性:2/4</li></ul><p id="0e37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">公共图书馆采用这种模式</strong></p><ul class=""><li id="548e" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><a class="ae mb" href="https://react-table.tanstack.com/docs/examples/basic" rel="noopener ugc nofollow" target="_blank">反应表</a></li><li id="4366" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><a class="ae mb" href="https://react-hook-form.com/api" rel="noopener ugc nofollow" target="_blank">反钩形</a></li></ul></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h2 id="3dc4" class="mc md in bd me mf mg dn mh mi mj dp mk jv ml mm mn jz mo mp mq kd mr ms mt mu bi translated">4.道具吸气剂模式</h2><p id="4745" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated"><code class="fe lw lx ly lz b">Custom Hook Pattern</code>提供了很好的控制，但是它也使得组件更难集成，因为开发人员不得不处理大量的本地钩子道具并重新创建他这边的逻辑。</p><p id="9cf8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lw lx ly lz b">Props Getters Pattern</code>模式试图掩盖这种复杂性。我们提供了一份<code class="fe lw lx ly lz b">props getters</code>的入围名单，而不是暴露本土道具。</p><blockquote class="lq lr ls"><p id="b6a0" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">一个<code class="fe lw lx ly lz b">getter</code>是一个返回很多道具的函数，它有一个有意义的名字，让开发者清楚哪个<code class="fe lw lx ly lz b">getter</code>对应哪个JSX元素。</p></blockquote><p id="cb7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例</strong></p><blockquote class="lq lr ls"><p id="ffa1" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">Github: <a class="ae mb" href="https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/props-getters" rel="noopener ugc nofollow" target="_blank">吸道具员</a></p></blockquote><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2e4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">优势:</strong></p><ul class=""><li id="8d8b" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">易用性:复杂性是隐藏的。开发者只需要将<code class="fe lw lx ly lz b">useCounter</code>给出的正确的<code class="fe lw lx ly lz b">getter</code>连接到正确的JSX元素。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ni"><img src="../Images/99ee2d871c1515662903ad00340ad458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EROrkxs2t83-X_UtFbxkgQ.png"/></div></div></figure><ul class=""><li id="522b" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">灵活性:过载<code class="fe lw lx ly lz b">getter</code>的道具可以适应特定情况。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nj"><img src="../Images/a5bf25fa63d16e4be08e5c618946fb64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gg5di6lFX4jH0PF0pKqXlQ.png"/></div></div></figure><p id="c1b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">缺点:</strong></p><ul class=""><li id="f431" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">缺乏可见性:<code class="fe lw lx ly lz b">getters</code>带来了抽象，这使得组件更容易集成，但也更加不透明和“神奇”。开发人员必须很好地理解暴露的getter属性以及受影响的内部逻辑，以便正确地覆盖它们(<code class="fe lw lx ly lz b">Typescript</code>应该有助于这一点)。</li></ul><p id="d4f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">标准</strong></p><ul class=""><li id="5ad7" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">控制反转:3/4</li><li id="5276" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">集成复杂度:3/4</li></ul><p id="7031" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">使用这种模式的公共图书馆</strong></p><ul class=""><li id="1a74" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><a class="ae mb" href="https://react-table.tanstack.com/docs/examples/basic" rel="noopener ugc nofollow" target="_blank">反应表</a></li><li id="bd29" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><a class="ae mb" href="https://github.com/downshift-js/downshift#usage" rel="noopener ugc nofollow" target="_blank">降档</a></li></ul></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h2 id="b1f9" class="mc md in bd me mf mg dn mh mi mj dp mk jv ml mm mn jz mo mp mq kd mr ms mt mu bi translated">5.状态缩减模式</h2><p id="42cd" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">控制反转方面最先进的模式。它为开发人员提供了一种改变组件内部操作方式的高级方法。代码类似于<code class="fe lw lx ly lz b">Custom Hook Pattern</code>，但是增加了一个<code class="fe lw lx ly lz b">reducer</code>传递给钩子。这个<code class="fe lw lx ly lz b">reducer</code>可以重载组件的任何内部动作。</p><p id="3e1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例子</strong></p><blockquote class="lq lr ls"><p id="7183" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">Github: <a class="ae mb" href="https://github.com/alexis-regnaud/advanced-react-patterns/tree/main/src/patterns/state-reducer" rel="noopener ugc nofollow" target="_blank">状态还原器</a></p></blockquote><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><blockquote class="lq lr ls"><p id="0b03" class="jk jl ki jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated"><code class="fe lw lx ly lz b">State reducer pattern</code>可以与其他图案(<code class="fe lw lx ly lz b">Compound components pattern</code>、<code class="fe lw lx ly lz b">Custom hook pattern</code>和<code class="fe lw lx ly lz b">Props Getters Pattern</code>)关联。在本例中，我们将它与<code class="fe lw lx ly lz b">Custom hook pattern</code>一起使用。</p></blockquote><p id="01a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">优点</strong></p><ul class=""><li id="0c71" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">给予更多的控制权:在最复杂的情况下，使用<code class="fe lw lx ly lz b">state reducers</code>是将控制权留给开发人员的最佳方式。所有内部<code class="fe lw lx ly lz b">useCounter</code>的动作现在都可以从外部访问，并且可以被覆盖。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ni"><img src="../Images/e6ee1e314ae9473de7e1465b0ce89299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQ6uhcFlebsimpDtUMVvbA.png"/></div></div></figure><p id="fa48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">缺点:</strong></p><ul class=""><li id="f9fd" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">实现的复杂性:对于您和开发人员来说，这种模式可能是实现起来最复杂的。</li><li id="afd1" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">缺乏可见性:因为任何减速器的动作都可以改变，所以需要很好地理解组件的内部逻辑。</li></ul><p id="c699" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">标准</strong></p><ul class=""><li id="0807" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">控制反转:4/4</li><li id="82cc" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">集成复杂度:4/4</li></ul><p id="6d44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">使用这种模式的公共图书馆</strong></p><ul class=""><li id="eb9b" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><a class="ae mb" href="https://github.com/downshift-js/downshift#statereducer" rel="noopener ugc nofollow" target="_blank">降档</a></li></ul></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h2 id="7e93" class="mc md in bd me mf mg dn mh mi mj dp mk jv ml mm mn jz mo mp mq kd mr ms mt mu bi translated">结论</h2><p id="330d" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">通过这5个高级反应模式，我们看到了利用“控制反转”概念的不同方式。它们为您提供了一种创建灵活且适应性强的组件的强大方法。</p><p id="81c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，我们都知道“强大的力量带来巨大的责任”。给开发人员越多的控制权，你的组件就会越远离“即插即用”的思维模式。这就是为什么你必须根据正确的需求选择正确的模式。</p><p id="5507" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下图可以帮助您完成这项任务。它根据“集成复杂性”和“控制反转”对所有这些模式进行分类:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nk"><img src="../Images/58de62605ea37f0d80028898311d81a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVq5PcC09q34j7FExkY5Zg.png"/></div></div></figure></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="7241" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章的灵感主要来自于React社区(【https://kentcdodds.com/】)的著名开发人员<a class="nl nm ep" href="https://medium.com/u/db72389e89d8?source=post_page-----a6b7624267a6--------------------------------" rel="noopener" target="_blank">肯特·c·多兹</a>的惊人工作。</p><p id="e73a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的阅读。</p><h2 id="c7e2" class="mc md in bd me mf mg dn mh mi mj dp mk jv ml mm mn jz mo mp mq kd mr ms mt mu bi translated">进一步阅读</h2><div class="nn no gp gr np nq"><a href="https://itnext.io/front-end-testing-strategy-5fddfd463feb" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">前端测试策略</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">定义测试的不同层次，并概述当前情况，以提出有效的…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">itnext.io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kt nq"/></div></div></a></div><p id="a4fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容看</em> <a class="ae mb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">说白了就是</em> </strong> </a> <em class="ki">。报名参加我们的</em> <a class="ae mb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">免费周报</em> </strong> </a> <em class="ki">。关注我们关于</em> <a class="ae mb" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">推特</em> </strong> </a>，<a class="ae mb" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">领英</em> </strong> </a> <strong class="jm io"> <em class="ki">，</em></strong><a class="ae mb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">YouTube</em></strong></a><strong class="jm io"><em class="ki">，以及</em></strong><em class="ki"/><a class="ae mb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">不和</em> </strong> </a>  <em class="ki">对成长黑客感兴趣？检查出</em> <a class="ae mb" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">电路</em> </strong> </a> <strong class="jm io"> <em class="ki">。</em>T71】</strong></p></div></div>    
</body>
</html>