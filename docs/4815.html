<html>
<head>
<title>Functional JavaScript — All the Important Concepts in One Article</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript——一篇文章中的所有重要概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-javascript-17032a113930?source=collection_archive---------1-----------------------#2021-09-27">https://javascript.plainenglish.io/functional-javascript-17032a113930?source=collection_archive---------1-----------------------#2021-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="78f2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解原因和方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/26aa43b3f90d4cb99ac87a054c8835d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RsEE5iXzD69OCDFSJq1uA.png"/></div></div></figure><p id="a0ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript给了我们很大的自由。</p><p id="5ef7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，改变初始化变量类型的自由。<br/>但也有尝试不同范例的自由。JavaScript没有固定的范例——我们可以编写面向对象的、命令式的、甚至是函数式的代码。</p><p id="310f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然我看到了很多面向对象的和命令式的JS代码，但后者似乎被低估了。函数式编程并不容易，而且容易被误解。</p><p id="d13a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是时候用JavaScript向初学者介绍这种范式了。以下是解释的主要概念。当然，你不会变成一个成熟的函数式程序员。但是希望这篇介绍能给你一个概述和为什么和如何的答案。</p><p id="cd5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于这是一篇很长的文章，这里有一个小目录:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="5ada" class="ls lt iq lo b gy lu lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#0175" rel="noopener ugc nofollow"><strong class="lo ir">Understanding the Philosophy of Functional Code</strong></a></span><span id="0c08" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#9515" rel="noopener ugc nofollow"><strong class="lo ir">Securing your Data — Understanding Immutability</strong></a></span><span id="77be" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#23f2" rel="noopener ugc nofollow"><strong class="lo ir">Focusing on What Matters — Pure Functions</strong></a></span><span id="c78d" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#d941" rel="noopener ugc nofollow"><strong class="lo ir">Transforming Data — Map, Reduce and Filter</strong></a></span><span id="f4ca" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#9a1b" rel="noopener ugc nofollow"><strong class="lo ir">Swallowing Functions — High Order Functions</strong></a></span><span id="4d8e" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#3ae2" rel="noopener ugc nofollow"><strong class="lo ir">Looping the Functional Way — Recursion</strong></a></span><span id="fd11" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#7a59" rel="noopener ugc nofollow"><strong class="lo ir">Functions That Aren’t Mutating</strong></a></span><span id="47a1" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#e857" rel="noopener ugc nofollow"><strong class="lo ir">Currying</strong></a></span><span id="a006" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#4493" rel="noopener ugc nofollow"><strong class="lo ir">Miscellaneous</strong></a></span><span id="8017" class="ls lt iq lo b gy lz lv l lw lx"><strong class="lo ir">· </strong><a class="ae ly" href="#4296" rel="noopener ugc nofollow"><strong class="lo ir">More Tools for Functional JavaScript</strong></a></span></pre><h1 id="0175" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">理解功能代码的哲学</h1><p id="1a36" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">理解是申请的基础。正确的动机对学习很有帮助。</p><p id="ba9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">许多人认为函数式编程意味着编写尽可能多的函数。我认为编写大量函数是函数式编程的结果。让我们揭开它的神秘面纱，了解这种编程范式的目标。</p><p id="5bdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">函数式编程主要解决表达式问题。由于函数调用是表达式，所以编写函数在函数式编程中是必不可少的。但是等等——表情？那是什么意思？</p><h2 id="fb5d" class="ls lt iq bd mb mw mx dn mf my mz dp mj la na nb ml le nc nd mn li ne nf mp ng bi translated">陈述和表达</h2><p id="5d0a" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">我们写的代码可以分为两组:语句和表达式。</p><p id="8965" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">表达式是可以被求值的语法实体。你可以把一个表达式想象成当它被执行时会返回一些东西。比如调用一个函数返回某个东西就是一个表达式。此外，调用变量是一个表达式，因为我们接收它的值。</p><p id="c8a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在chrome开发工具中，我们可以很好地看出区别:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c4b0ab0c41055f0781e6f4b0a2bcc4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*iVxJ0sCl3Jta1RvvXdAATQ.png"/></div></figure><p id="1966" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">初始化变量“a”是一个语句。因此，控制台不会为我们返回任何内容。如下图所示，在控制台中输入“12”是一个表达式。</p><p id="c1be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来是初始化函数“greet”——这是一个语句。语句大多是初始化或声明变量，也有像“for”或“while”这样的关键字。</p><p id="982a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">调用函数“greet”是一个表达式，就像将两个数字相加一样。</p><p id="1c51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">语句是典型的<em class="ni">命令式</em>编程范例。<br/>我们有下一个词要澄清。命令式风格围绕着编写指令(陈述)。另一方面，函数式编程是关于描述我们的数据。</p><p id="5b44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个简单的例子。</p><p id="2c0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目标是接收包含在<code class="fe nj nk nl lo b">numbers</code>中的所有偶数(2，4)的数组。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="190e" class="ls lt iq lo b gy lu lv l lw lx">let numbers = [1, 2, 3, 4]</span><span id="f38c" class="ls lt iq lo b gy lz lv l lw lx">let evenNumbers = []</span><span id="2acc" class="ls lt iq lo b gy lz lv l lw lx"><em class="ni">for</em> (let i = 0; i &lt; numbers.length; i++) {<br/>  let number = numbers[i]<br/>  <br/>  <em class="ni">if</em> (number % 2 === 0) {<br/>    evenNumbers.push(number)<br/>  }<br/>}</span><span id="eba0" class="ls lt iq lo b gy lz lv l lw lx">console.log(evenNumbers)</span></pre><p id="f5a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这段代码是必不可少的——它只由语句组成，并且依赖于变化的数据(甚至是一个全局变量)。</p><p id="4d2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，功能示例:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="c144" class="ls lt iq lo b gy lu lv l lw lx">let numbers = [1, 2, 3, 4]</span><span id="6cd1" class="ls lt iq lo b gy lz lv l lw lx">console.log(<br/>  numbers.filter((number) =&gt; {<br/>    <em class="ni">return</em> number % 2 === 0<br/>  })<br/>)</span></pre><p id="5b3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在神奇发生的地方，我们使用表情。filter函数被调用并返回一些东西——就像函数一样，我们传递给它。作为使用表达式的副作用，我们编写和调用函数——我们甚至将函数传递给其他函数。</p><p id="dc4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与命令式代码相比，这段代码不会改变任何数据。这是函数式编程背后的主要思想之一:尽量不要改变任何数据。如果你想知道为什么:改变其他函数依赖的全局数据可能会导致不必要的错误。</p><p id="e411" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想象一下，你不小心改变了一个很多函数在计算中使用的常数——这将导致很多地方出现错误。现在想象一下故意改变全球数据的风险<strong class="kt ir"/>。</p><p id="2e4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">说到不变性，这个概念经常被误解——尤其是在JavaScript中。我们来澄清一下。</p><h1 id="9515" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">保护您的数据—了解不变性</h1><p id="609b" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">如果一个对象的状态在初始化后不能改变，那么它就是不可变的。尽管听起来很简单，但这个概念对于函数式编程来说是必不可少的。而且有必要在JavaScript中理解它，因为它经常被误解。</p><p id="8d4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript对象不是不可变的。而const-keyword并没有改变这一点。const-关键字禁止重新分配变量，而不是改变它。<br/>另一方面，用“const”关键字初始化的原始类型(数字、布尔等)是不可变的。</p><p id="71b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可变性最糟糕的地方是它所允许的错误场景。<br/>让我们看一个例子。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="9679" class="ls lt iq lo b gy lu lv l lw lx">const person = { name: 'Max' }</span><span id="558e" class="ls lt iq lo b gy lz lv l lw lx">let copy = person<br/>copy.name = 'Carl'</span><span id="3612" class="ls lt iq lo b gy lz lv l lw lx">console.log(person)</span></pre><p id="a1c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，“Carl”将被记录在这里——改变对象的副本会改变原始对象本身。因此，即使我们不能重新分配人-对象，我们也可以改变它的状态。不变性是函数式编程中的一个基本主题，因此，理解JavaScript在这方面的问题和解决方案是必要的。</p><p id="7ae5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让JavaScript更加不可变的解决方案:</p><ul class=""><li id="2e46" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated"><a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/typescript-immutability-b52bece7b9ea">TypeScript中的不可变对象</a></li><li id="384a" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated"><a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/immutable-js-efe6b42e122f">不可变. js </a></li><li id="e81f" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">类似<code class="fe nj nk nl lo b">Object.freeze(obj)</code>的功能</li></ul><p id="3567" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们已经理解了不可变数据，我们可以把注意力放在函数上了。下面是如何用函数的方式编写函数。</p><h1 id="23f2" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">专注于重要的东西——纯粹的功能</h1><p id="8cd9" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">让我们直入主题吧。</p><p id="8bcf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果满足以下条件，则函数是纯函数:</p><ol class=""><li id="7bf1" class="nm nn iq kt b ku kv kx ky la no le np li nq lm oa ns nt nu bi translated">给定相同的输入，该函数每次都返回相同的输出</li><li id="6f63" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm oa ns nt nu bi translated">该函数不会产生副作用(改变任何全局状态)</li></ol><p id="a670" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你读到第一点时，你可能会提出一个问题:“那么，当我的函数依赖于一个全局状态时，它是纯的吗？”。</p><p id="6c8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你的纯函数依赖于一个全局变量，它的行为可能还是像纯函数一样。只要这个全局变量不变，函数将始终为相同的输入产生相同的结果。<br/>然而，这并不能保证。这里有一个小例子。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="bd54" class="ls lt iq lo b gy lu lv l lw lx">let globalNum = 10</span><span id="3290" class="ls lt iq lo b gy lz lv l lw lx">function add(num) {<br/>  return num + globalNum<br/>}</span></pre><p id="e7b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为<code class="fe nj nk nl lo b">globalNum</code>可能随时改变，所以不能保证函数<code class="fe nj nk nl lo b">add</code>总是为相同的输入产生相同的回报。<br/>函数<code class="fe nj nk nl lo b">add</code>不纯。</p><p id="2d04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当谈到作为全局状态<code class="fe nj nk nl lo b">globalNum</code>的不可变数据时，有人可能会说这个函数是纯函数。然而，避免依赖全局状态通常是一个好主意。</p><h1 id="d941" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">转换数据-映射、简化和过滤</h1><p id="c847" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">这三个属于JavaScript中最强大的函数。它们的共同点是:它们不会改变我们应用它们的数组。<br/>对，这三个都是数组函数。此外，它们是高阶函数(我们一会儿会阐明这一点)。</p><p id="9f04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们把它们分解开来。</p><h2 id="dcc8" class="ls lt iq bd mb mw mx dn mf my mz dp mj la na nb ml le nc nd mn li ne nf mp ng bi translated">地图——全方位</h2><p id="01fb" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">可以将<code class="fe nj nk nl lo b">array.map</code>功能想象为<code class="fe nj nk nl lo b">forEach</code>的替代功能。我们迭代一个数组，并提供一个函数来处理数组的值和索引。例如，我们可以使用映射将数组中的每个数字加倍:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="b69f" class="ls lt iq lo b gy lu lv l lw lx">let nums = [1, 2, 3]</span><span id="9931" class="ls lt iq lo b gy lz lv l lw lx">nums.map((num) =&gt; {<br/>  return num * 2<br/>})<br/>// [2, 4, 6]</span></pre><h2 id="ba2d" class="ls lt iq bd mb mw mx dn mf my mz dp mj la na nb ml le nc nd mn li ne nf mp ng bi translated">减少—将数组减少到一个值</h2><p id="f9b1" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">这可能是三个中最被误解的。Reduce将我们的数组缩减为一个值，这个值被返回。这是通过一个通常被称为“减速器”的功能来实现的。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="6fe9" class="ls lt iq lo b gy lu lv l lw lx">let nums = [1, 2, 3, 4]</span><span id="a812" class="ls lt iq lo b gy lz lv l lw lx">nums.reduce((prevVal, val) =&gt; {<br/>  return prevVal + val<br/>})</span></pre><p id="5bed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">reduce函数将返回“10”，因为1 + 2 + 3 + 4是10。</p><h2 id="6ced" class="ls lt iq bd mb mw mx dn mf my mz dp mj la na nb ml le nc nd mn li ne nf mp ng bi translated">Filter —返回经过筛选的数组</h2><p id="d057" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">对于过滤器，我们提供一个模式作为函数。对于应该包含在筛选数组中的每个元素，pattern函数应该返回“true”。</p><p id="fb05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个示例，返回[2，4]，因为它们是唯一的偶数:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="bc06" class="ls lt iq lo b gy lu lv l lw lx">let nums = [1, 2, 3, 4]</span><span id="b2f0" class="ls lt iq lo b gy lz lv l lw lx">nums.filter((val) =&gt; {<br/>  return val % 2 === 0<br/>})</span></pre><p id="2d9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这三个强大的功能就够了。通过数据转换和使用索引，您可以做更多的事情。然而，这应该只是一个介绍。</p><h1 id="9a1b" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">吞咽功能—高阶功能</h1><p id="b573" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">正如我在开始时所说的，函数式编程解决了很多关于函数的问题。如你所知，函数可以被调用，它们可以返回一些东西等等。我们没有做的是用它们改变全局数据——通常情况下，应该避免改变数据。</p><p id="0994" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，当遇到纯函数式编程时，许多人会问:“我能用这种语言做我能用(Python、Java、C++、JS)做的一切事情吗？”。</p><p id="88f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个相关的问题，通常被更具体地表述为:“这种语言是完整的吗？”。由于纯粹的函数式编程不允许我们做几件事情，许多人感到疑惑。</p><p id="4c31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好消息是，我们可以补偿许多我们在函数式编程中没有做的事情。在我们的例子中，函数帮助我们做到这一点。我们不仅可以调用它们并返回数据，我们甚至可以嵌套它们。</p><p id="ce68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">函数式编程中更复杂结构的一个例子是高阶函数。高阶函数是返回函数或接收函数作为参数(或两者兼有)的函数。</p><p id="c2b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，举个例子可能最有帮助。因为我们已经讨论了映射、过滤和减少，所以您应该理解这里发生了什么:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="47f4" class="ls lt iq lo b gy lu lv l lw lx">const nums = [1, 2, 3]</span><span id="a0d7" class="ls lt iq lo b gy lz lv l lw lx">function double(item) {<br/>  <em class="ni">return</em> item * 2<br/>}</span><span id="7d50" class="ls lt iq lo b gy lz lv l lw lx">console.log(nums.map(double))<br/><em class="ni">// [2, 4, 6]</em></span></pre><p id="f6e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是我们的地图，让价值再次翻倍。但这一次，我们用一个全局函数代替了匿名箭头函数，叫做“double”。由于<code class="fe nj nk nl lo b">map</code>是高阶函数，我们可以将函数传入其中。</p><p id="1df7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使得我们的代码可读性更好，并且“double”函数可以重用。</p><h1 id="3ae2" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">循环函数方式——递归</h1><p id="f7d4" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">任何编程语言都不应该缺少循环。大多数程序在某些时候依赖于for循环、while循环或for-each循环。然而，这些都是语句——而且语句在函数式编程中很少见。</p><p id="7247" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，这仅仅是风格的问题吗？这就是我们在函数式编程中不使用for-loops和co .的原因吗？不，这不仅仅是因为风格。</p><p id="d92c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个原因是，像for循环一样，循环依赖于一个变异的变量。除此之外，函数式编程不需要我们从大多数编程语言中了解到的那种循环。我们可以用递归代替一切。有时，我们可以使用内置的替代功能，比如我刚才展示的地图功能。</p><p id="394f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TL；DR:在函数式编程中，我们不需要for或forEach循环。</p><p id="caff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了充分装备自己，你需要理解递归。</p><p id="cea9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个想法并不难:一个在执行过程中调用自身的函数。正如您可能注意到的，这可能会导致无限循环。好吧，至少我们得到了我们的循环。玩笑归玩笑，这就是递归函数中条件发挥作用的地方。有条件的部分被称为<strong class="kt ir">基础案例</strong>。另一部分是<strong class="kt ir">递归案例</strong>。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="8720" class="ls lt iq lo b gy lu lv l lw lx">function coutdown(number) {<br/>  // base case <br/>  <em class="ni">if</em> (number === 0) {<br/>    console.log(0)<br/>    <em class="ni">return</em> 0<br/>  }</span><span id="4d8a" class="ls lt iq lo b gy lz lv l lw lx">  console.log(number)<br/>  // recursive case <br/>  coutdown(number — 1)<br/>}</span></pre><p id="9bb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，基本情况是终止我们的递归。递归的例子是为了重新调用我们的函数。</p><p id="3749" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有迭代函数都可以转换成递归。然而，这并不意味着你应该用它做任何事情。递归是有代价的。</p><p id="e3ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所谓的调用堆栈存储函数调用、它们的参数、局部变量和其他计算函数执行所需的数据。调用堆栈中不再需要的东西会被移除。问题:当使用递归时，在彼此之间建立调用。只有当整个递归完成后，调用堆栈才会被清理。因此，这个堆栈的负载是巨大的。</p><p id="2c0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面显示的递归在12000崩溃，传递到我的机器上。递归不如“for”或“while”这样的经典循环高效。</p><p id="6f33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，对于大多数计算来说，使用递归应该不成问题。</p><p id="d6ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实践这个概念，看一看它优雅地解决的问题是有意义的。有几件事，在本质上是递归的。层次结构，比如文件系统，就是一个很好的例子。其他领域的问题也可以用递归很好地解决——图形和一些数学问题，如斐波那契数列。</p><h1 id="7a59" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">没有变异的功能</h1><p id="4bb4" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">正如我之前所说，当试图编写函数式JavaScript时，目标是编写尽可能多的纯函数。当谈到变异数据时，你可能会问自己一个问题:“如果一个函数根据输入变异了一个局部变量，它还是纯的吗？”。这里有一个简单的例子:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="4148" class="ls lt iq lo b gy lu lv l lw lx">function add(a, b) {<br/>  let result = 0<br/>  result = a + b</span><span id="865d" class="ls lt iq lo b gy lz lv l lw lx"><em class="ni">  return</em> result<br/>}</span></pre><p id="c197" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管这是可怕的代码，但该函数在技术上是纯粹的。它确实变异了一个局部变量，但这并不违背纯函数的定义。<br/>尽管如此，函数式程序员完全避免变异变量——不管在什么地方，什么类型的变量。</p><p id="df8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，了解JavaScript中不可变函数的工具箱是一个好主意。例如，仅仅对于数组来说，就有大量的函数可以使用——有些是变异的，比如<code class="fe nj nk nl lo b">push</code>，有些不是，比如<code class="fe nj nk nl lo b">slice</code>。</p><p id="846e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你喜欢一个简单的例子吗？</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="df3a" class="ls lt iq lo b gy lu lv l lw lx">function addNum(arr, newNum) {<br/>  return […arr, newNum]<br/>}</span><span id="bdd1" class="ls lt iq lo b gy lz lv l lw lx">addNum([1, 2, 3], 4) <br/><em class="ni">// [1, 2, 3, 4]</em></span></pre><p id="9afd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于spread操作符，我们可以使用一个纯函数来返回数组的一个修改过的副本，而不是推送到数组并对其进行变异。</p><h1 id="e857" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Currying</h1><p id="0630" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">可化函数是一个接受多个参数的函数，但被转换成一系列接受每个参数的函数。<br/>一开始听起来很难吧？这里有一个例子。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="ca4e" class="ls lt iq lo b gy lu lv l lw lx">function add(a) {<br/>  return function(b) {<br/>    return a + b<br/>  }<br/>}</span><span id="84ee" class="ls lt iq lo b gy lz lv l lw lx">add(2)(3) // 5</span></pre><p id="82d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，我们有一个函数<code class="fe nj nk nl lo b">add</code>——但是这个函数没有调用它<code class="fe nj nk nl lo b">add(2, 3)</code>，而是返回一个函数，所以我们把两个函数调用放在一行中。</p><p id="4e31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是为什么呢？事实上，我不太喜欢奉承。然而，我想在这篇文章中讨论它。有好处。一个是您的函数现在逐步接收参数，以便您可以保存不同的函数调用:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="8b01" class="ls lt iq lo b gy lu lv l lw lx">const greet = (time) =&gt; (firstname) =&gt; (lastname) =&gt;<br/>  `Good ${time}, ${firstname} ${lastname}`</span><span id="0e4b" class="ls lt iq lo b gy lz lv l lw lx">const time = greet('Morning')</span><span id="a695" class="ls lt iq lo b gy lz lv l lw lx">const firstname = time('John')</span><span id="94ce" class="ls lt iq lo b gy lz lv l lw lx">console.log(firstname('Doe'))</span></pre><p id="e060" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有些人声称curried函数使测试更容易。</p><h1 id="4493" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">多方面的</h1><p id="6f03" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">是的，我知道你读过所有这些关于JavaScript中arrow与普通函数的文章。最后一次，当谈到函数式编程时，让我们来谈谈这两者。你能行的。</p><p id="6799" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里就不赘述了。除了关于<strong class="kt ir"> <em class="ni">这个</em> </strong>绑定的区别之外，箭头函数还有一个区别。</p><p id="61a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">箭头函数允许隐式返回。正如您在下面的示例中看到的，没有return关键字。然而，我们回报了一些东西。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="cf7c" class="ls lt iq lo b gy lu lv l lw lx">const addOne = x =&gt; x + 1;<br/>addOne(1); // -&gt; 2</span></pre><p id="36a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，使用这种语法返回某些内容，您以前不能编写任何语句。正如您在这里看到的,“普通”函数中的情况并非如此:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="f7b8" class="ls lt iq lo b gy lu lv l lw lx">function addOne(x) {<br/>  &lt;some-statement&gt;<br/>  return x + 1<br/>}</span></pre><p id="9999" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不想过多强调这一点，因为我发现这主要是视觉上的差异。然而，有些人称赞它是编写函数的一种更具功能性和声明性的方式。</p><h1 id="4296" class="ma lt iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">用于函数式JavaScript的更多工具</h1><p id="2841" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">现在我们谈了很多关于函数式编程的内容。然而，我们仍然使用JavaScript。我们曾经不使用库或框架做一些事情吗？绝对不行。说到函数式编程，有很多工具。</p><h2 id="2d49" class="ls lt iq bd mb mw mx dn mf my mz dp mj la na nb ml le nc nd mn li ne nf mp ng bi translated">不可变的. js</h2><p id="5e31" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">从本文开始，我们讨论了不变性。有一个著名的库叫做immutable.js，我在这里对它做了更扩展的介绍<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/immutable-js-efe6b42e122f">。<br/>该库有助于创建不可变的类型，如数组、映射和集合。不可变的. js还替换了默认函数，比如最初改变数据的<code class="fe nj nk nl lo b">Map.set</code>。不可变的. js改变了它们，所以函数返回改变的数据，但不改变原始数据。</a></p><h2 id="fd54" class="ls lt iq bd mb mw mx dn mf my mz dp mj la na nb ml le nc nd mn li ne nf mp ng bi translated">其他图书馆</h2><p id="5220" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">我不想过多地谈论函数式JavaScript的库。原因是我一个都没用。此外，库之间的差异正在变小，因为它们都集成了ask特性。除了Immutable.js之外，还有一场非常著名的Lodash和Underscore.js之战。两者都为JavaScript中的函数式编程提供了功能。由于两者都在不断变化，我建议你做你的研究。</p><p id="e942" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Ramda不如下划线、Lodash和Immutable.js出名。然而，许多函数式程序员喜欢它。</p><h2 id="d55f" class="ls lt iq bd mb mw mx dn mf my mz dp mj la na nb ml le nc nd mn li ne nf mp ng bi translated">纯脚本</h2><p id="8efa" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated"><a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/bringing-powerful-functional-programming-to-the-web-with-purescript-3ee759ce05aa"> PureScript </a>不是一个库，也不是一个框架。PureScript是一种完全不同的基于Haskell的编程语言。更有趣的是，PureScript是一种纯函数式编程语言。然而，最终，代码被编译成JavaScript。</p><p id="ece4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想写100%功能性的代码，试试PureScript。因为它以模块化的方式导出到JavaScript，所以现有的项目可以用它来扩展。</p><p id="7501" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读！</p><p id="209f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">万一你想同时加入Medium和支持我:<br/>你可以在这里</strong>  <strong class="kt ir"> *购买订阅</strong> <a class="ae ly" href="https://louispetrik.medium.com/membership" rel="noopener"> <strong class="kt ir">。</strong></a></p><p id="cf7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ni">*附属链接。如果你使用这些链接购买东西，我会赚取佣金，但没有额外的费用给你。非常感谢！</em></p><p id="f526" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想了解更多关于函数式编程的知识吗？我支持你:</p><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-functional-vs-oop-fb5fbf15a35d"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">JavaScript中的函数式编程与面向对象编程</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">对两者利弊的介绍</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/purescript-3ee759ce05aa"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">用PureScript为Web带来强大的函数式编程</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">就像JavaScript的Haskell</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="ot l op oq or on os kp oe"/></div></div></a></div><p id="461e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ni">更多内容看</em> <a class="ae ly" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ni">说白了。报名参加我们的</em> </a><a class="ae ly" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ni">免费每周简讯</em> </a> <em class="ni">。在我们的</em> <a class="ae ly" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="ni">社区</em> </a> <em class="ni">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>