<html>
<head>
<title>Introduction to Duck Typing in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的Duck类型介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-duck-typing-in-typescript-c537d2ff9b61?source=collection_archive---------0-----------------------#2021-11-30">https://javascript.plainenglish.io/what-is-duck-typing-in-typescript-c537d2ff9b61?source=collection_archive---------0-----------------------#2021-11-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/08dea14128775464f0e8df56ed77e22c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdukZdneKqM-5jPgapYYRQ.png"/></div></div></figure><p id="f3e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将讨论duck-typing，这是一种实践，也是TypeScript的一个很酷的特性，它带来了巨大的不同——<a class="ae kt" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" rel="noopener ugc nofollow" target="_blank">类型谓词</a>。</p><h2 id="8e4f" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">什么是“鸭子打字”？</h2><p id="08ec" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">Duck typing是许多OOP语言中的常见做法。它得名于所谓的“<a class="ae kt" href="https://en.wikipedia.org/wiki/Duck_test" rel="noopener ugc nofollow" target="_blank">鸭考</a>，即:</p><blockquote class="ls lt lu"><p id="770e" class="jv jw lv jx b jy jz ka kb kc kd ke kf lw kh ki kj lx kl km kn ly kp kq kr ks ig bi translated">如果它看起来像鸭子，游泳像鸭子，嘎嘎叫像鸭子，那么它很可能<em class="in">就是</em>鸭子</p></blockquote><p id="6350" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者用巨蟒小组的话说:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Monty Python and the Holy Grail (1975), Witch Trial Scene</figcaption></figure><p id="9b8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lv"> Duck Typing </em>通常用于需要处理一系列不同数据的代码中，通常不知道调用者将传递什么参数。在这里想一想您遇到的switch语句或复杂的if/else块的一些用法。这些是典型的地方，鸭子打字可能会派上用场，甚至提供一个替代方案。</p><h2 id="e6c5" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">为什么是鸭型？</h2><p id="486b" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">动态语言中鸭式输入的一个常见模式是，假设给定值符合我们的预期，尝试并执行一个动作，然后处理可能出现的任何异常。Python就是一个很好的例子:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mj me l"/></div></figure><p id="1218" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这显然是一个愚蠢的例子，但要点很简单——获取一个值，通过调用它的<code class="fe mk ml mm mn b">.quack()</code>方法检查它是否嘎嘎作响——如果它嘎嘎作响，返回true，如果出现属性或值错误，返回false。</p><p id="1412" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Python中,<code class="fe mk ml mm mn b">try-except</code>是一种被接受的模式，这种模式也被像<code class="fe mk ml mm mn b">hasattr</code>这样的内置软件内部使用，并在整个标准库中使用。相比之下，在JavaScript中，<code class="fe mk ml mm mn b">try-catch</code>更受限制——既不能根据抛出的错误的原型定义不同的catch块，也不能确定抛出的是不是错误的实例。</p><p id="8791" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在处理错误时，您必须更加详细和安全，这在某种程度上是JavaScript和TypeScript中的反模式。通常的做法是这样做:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mj me l"/></div></figure><p id="cbb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的谓词中，我们(1)检查参数<em class="lv">值</em>是否属于“object”类型，(2)它不为null，因为null的类型在JavaScript(🤦‍♂)，以及(3)使用Reflect.get方法，我们安全地检索“嘎嘎”的值，并检查它确实是一个函数。</p><p id="9aa8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种谓词对大多数读者来说可能是熟悉的——毕竟，JavaScript代码通常充满了布尔检查，无论它们是抽象成单独的函数还是简单地内联编写。</p><p id="439f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而这就是JavaScript和TypeScript的不同之处——参数<code class="fe mk ml mm mn b">value</code>可能是一只鸭子，但是IDE和JavaScript解释器都不知道鸭子是什么。另一方面，在TypeScript中，<code class="fe mk ml mm mn b">Duck</code>可以并且将会是一个类型:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mj me l"/></div></figure><p id="6919" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意<code class="fe mk ml mm mn b">isDuck</code>的返回值类型中使用的<code class="fe mk ml mm mn b"><strong class="jx io">is</strong></code>关键字，这就是TypeScript中所谓的<a class="ae kt" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" rel="noopener ugc nofollow" target="_blank"> a类型谓词</a>，这是该语言的一个更好的特性:类型谓词是一个函数，它返回一个布尔值，充当一个自定义类型保护；实际上是告诉TypeScript编译器给定值<em class="lv">属于给定类型</em>。也就是说，在上面的例子中，如果函数<code class="fe mk ml mm mn b">isDuck</code>返回true，编译器将知道该值的类型为<code class="fe mk ml mm mn b">Duck</code>。</p><p id="b615" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么这是一件大事？因为我们的函数现在有双重用途——它仍然是一个谓词，返回一个布尔值，这意味着我们可以像JavaScript中的谓词一样使用它，但同时，它也会影响TypeScript编译器，从而影响IDE和任何其他可能链接到编译器的工具(read ESLint)。</p><h2 id="271a" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">示例用例:recursiveResolve</h2><p id="b290" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">duck typing的一个便利用途是当您的代码可能接受承诺和非承诺时。处理这种情况的内置方法是使用<code class="fe mk ml mm mn b">Promise.resolve()</code>包装值，如果给定了一个Promise对象，这将解包Promise对象<em class="lv"/>——或者将值包装在Promise对象中，然后解包。这样做的问题是它有一点点开销——即使对于非承诺值，您也需要等待解决。</p><p id="af43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种方法是使用类型谓词“duck type”承诺，按照惯例，这将被称为<code class="fe mk ml mm mn b">isPromise</code>。</p><p id="3229" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们创建了一个自定义方法来递归遍历一个对象，解析可能嵌套在其中的任何承诺(下面的代码改编自我的一个库，您可以<a class="ae kt" href="https://github.com/Goldziher/interface-forge/blob/59ef8140eb1315578b57ba90de55c59e867179e3/src/utils/schema.ts#L27" rel="noopener ugc nofollow" target="_blank">在这里</a>查看原文)，这是这种类型谓词的一个很好的用例:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mj me l"/></div></figure><p id="7040" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您所看到的，我们在上面定义了两个谓词— <code class="fe mk ml mm mn b">isPromise</code>和<code class="fe mk ml mm mn b">isRecord</code>，它们都接受一个可选的泛型参数，这使得它们可以重用。然后，我们可以在<em class="lv"> recursiveResolve </em>函数中使用它们，开销很小，并且在整个函数中正确推断类型。</p><h2 id="c341" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">额外收获:谓词库</h2><p id="6a3c" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">给定这里的常见用例，您可以在许多不同的库中找到类型谓词。如果您在Node.js中工作，您可以使用现成的类型谓词，它们作为<a class="ae kt" href="https://nodejs.org/api/util.html#utiltypes" rel="noopener ugc nofollow" target="_blank"> node/util </a>包的一部分提供。还有一个<a class="ae kt" href="https://github.com/browserify/node-util" rel="noopener ugc nofollow" target="_blank">浏览器端口</a>可供选择。不过我会推荐另一个库，我自己制作的一个库，名为<a class="ae kt" href="https://github.com/tool-belt/type-predicates" rel="noopener ugc nofollow" target="_blank"><em class="lv">@ tool-belt/type-predicates</em></a>，它提供了一个更全面、类型更好的类型谓词和类型断言集合。无论哪种方式，您都可以不使用任何库——这取决于您的用例——只需根据需要编写谓词。</p><p id="7229" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lv">更多内容看</em> <a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lv">说白了。报名参加我们的</em><strong class="jx io"><em class="lv"/></strong><a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lv">免费每周简讯这里</em> </strong> </a> <strong class="jx io"> <em class="lv">。</em> </strong></strong></a></p></div></div>    
</body>
</html>