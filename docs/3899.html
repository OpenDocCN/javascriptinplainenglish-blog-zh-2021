<html>
<head>
<title>Increase performance of your Angular Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高角度应用的性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fix-memory-leaks-in-angular-b4f6bdc6e271?source=collection_archive---------2-----------------------#2021-08-05">https://javascript.plainenglish.io/fix-memory-leaks-in-angular-b4f6bdc6e271?source=collection_archive---------2-----------------------#2021-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="5ddd" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">如何减少内存泄漏？</h2><div class=""/><div class=""><h2 id="545b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">角度性能和优化清单</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/7a3424617241f7e459663e3f67de1658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*5mlXsr0wLxIysYty.jpg"/></div></figure><p id="821f" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Angular是功能强大、高性能的前端框架之一。随着应用程序的增长，它会变得越来越慢。如果你不知道如何优化应用程序，它会开始影响最终用户的体验。</p><p id="e868" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要预先了解并修复性能，最好了解优化技术。我们有很多方法可以优化你的角度应用，这里我想讨论一些对我的开发很有帮助的技术。</p><p id="f821" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们进入我们的主要讨论。</p><p id="cb64" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当“泄露”这个词出现在脑海中时，它意味着有些事情正在混乱地发生。有时很难找到问题所在，也很难解决问题。在软件开发中，写一个干净的代码，让你与众不同，是基本的事情之一。有时，当我们开发更大的应用程序时，随着时间的推移，它会随着代码的增长而变得缓慢。从一开始就知道让我们的应用程序更干净以减少包的大小并避免任何泄漏是非常重要的。</p><p id="de09" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如所讨论的，内存泄漏发生在每个应用程序中，让我们讨论如何影响Angular应用程序。在本文中，我们将在Angular应用程序中创建一个内存泄漏，并将解决和讨论解决它的不同方法。</p><p id="40c3" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当应用程序变慢时，我们通常会刷新或重新加载页面，从而释放内存，应用程序变得正常，但我们不知道后台实际发生了什么，直到我们深入了解它。</p><p id="2662" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一些原因有时会导致内存泄漏。</p><ol class=""><li id="4b73" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">长时间使用同一个应用程序。</li><li id="b386" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用ngIf多次渲染应用程序，这取决于可观测量。</li><li id="22d8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在应用程序中调用多个观察值，并且在使用后不取消订阅。</li><li id="f403" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">订阅诸如表单控件之类的侦听器，而不是在组件被破坏后取消订阅。</li><li id="63f8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">当我们使用shareReplay但没有添加unsubscribe逻辑来处理它时。</li></ol><p id="0fb8" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一些场景来讨论内存泄漏。</p><h1 id="3ba7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq kf mr kg ms ki mt kj mu kl mv km mw mx bi translated">1.订阅/取消订阅可观察值</h1><p id="e568" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">让我们看看与可观察到的问题相关的问题和解决方案。</p><p id="5353" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建<strong class="ky ja"> TestLeakChild </strong>和<strong class="ky ja">testleakpanarcomponent</strong>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3e9e" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ja"> TestLeakChild </strong>有一个计时器每秒运行一次，计时器的控制台以日期和时间启动。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a4bf" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ja"> ParentLeakComponent </strong>有两个启动观察和停止观察按钮，分别运行定时器和停止定时器。</p><p id="0e3f" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看演示。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="e386" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ja">观察:</strong></p><ol class=""><li id="5845" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我点击了<strong class="ky ja">开始观察按钮</strong></li><li id="adc6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我点击了<strong class="ky ja">开始观察</strong>按钮，控制台正在打印计时器值</li><li id="0a61" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我点击了<strong class="ky ja"> stop observable </strong>按钮，控制台仍在打印。点击<strong class="ky ja">停止可见</strong>按钮不是应该停止吗？</li><li id="2462" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">是的，你猜对了，我们已经成功地造成了内存泄漏。</li><li id="f6b0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们如何监控呢？</li></ol><p id="dba3" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看这个。</p><blockquote class="nh"><p id="b7d5" class="ni nj iq bd nk nl nm nn no np nq lr dk translated">首先，我们需要按照方法在浏览器中打开性能监视器。</p></blockquote><figure class="nr ns nt nu nv kt"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="202e" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们遵循相同的步骤，通过连续点击<strong class="ky ja">开始可见</strong>和<strong class="ky ja">停止可见</strong>按钮来检查Chrome性能监视器。</p><p id="73a1" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在GIF中注意到了(抱歉有点模糊),我们可以看到CPU使用率和堆大小开始增加。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="f9a3" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们应该如何解决这个问题呢？</p><h1 id="3aba" class="mg mh iq bd mi mj mk ml mm mn mo mp mq kf mr kg ms ki mt kj mu kl mv km mw mx bi translated">解决办法</h1><p id="0f06" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">常见的解决方案是使用unsubscribe方法，在可观察对象被使用后将其取消订阅。</p><p id="98fa" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过创建TestFixChildComponent和TestFixParentComponent来检查解决方案。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="97ce" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下使用unsubscribe方法后的行为。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="345a" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多种方法可以清理RXJS订阅。我们将在本文的后面讨论它们。</p><p id="1974" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里和stackblitz一起玩。</p><p id="1406" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae nw" href="https://stackblitz.com/edit/angular-meomry-leak?file=src%2Fapp%2Ftest-leak%2Ftest-leak-parent.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-meomry-leak?file = src % 2f app % 2f test-leak % 2f test-leak-parent . ts</a></p><h1 id="4bdc" class="mg mh iq bd mi mj mk ml mm mn mo mp mq kf mr kg ms ki mt kj mu kl mv km mw mx bi translated">2.共享重播</h1><p id="8872" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">首先，让我们了解什么是ShareReplay。它返回hot observable并重放N个通知，因此一旦源完成，它就向订阅者重放，而无需再次调用源。</p><p id="c468" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看这个例子。</p><p id="460a" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae nw" href="https://stackblitz.com/edit/rxjs-warning-sharereplay?file=app/app.component.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/rxjs-warning-sharereplay?file=app/app.component.ts </a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="dd87" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们看到上面的截图时，我们可以看到通过改变标签可以使堆的大小增加，并且计数器不会自己停止。</p><p id="2861" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里错过了一件事。</p><h1 id="1bb6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq kf mr kg ms ki mt kj mu kl mv km mw mx bi translated">解决方案:</h1><p id="0f91" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">共享重播的源代码</p><p id="c49b" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们错过了属性refCount: true，订阅将永远不会被取消订阅。</p><p id="6d09" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请查看下面的文章以了解更多信息。</p><blockquote class="nx ny nz"><p id="7e9b" class="kw kx nd ky b kz la ka lb lc ld kd le oa lg lh li ob lk ll lm oc lo lp lq lr ij bi translated"><a class="ae nw" href="https://blog.angularindepth.com/rxjs-whats-changed-with-sharereplay-65c098843e95" rel="noopener ugc nofollow" target="_blank"> <em class="iq">有角度有深度文章:ShareReplay有什么变化</em> </a> <em class="iq">。</em></p></blockquote><p id="366c" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，让我们添加以下内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nf l"/></div></figure><p id="9439" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们现在看到的，我们的内存泄漏已经消失了。</p><h1 id="7d52" class="mg mh iq bd mi mj mk ml mm mn mo mp mq kf mr kg ms ki mt kj mu kl mv km mw mx bi translated">3.事件监听器</h1><p id="8a2c" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">内存泄漏的另一个常见原因是DOM事件没有被注册，因此它将总是侦听一些事件。</p><p id="5a5d" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个常见的例子，在这个例子中，我们在主体上注册了一个事件，但从来没有取消注册。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cdb4" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在我们实例化ScrollComponent时造成内存泄漏。</p><h1 id="f9d6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq kf mr kg ms ki mt kj mu kl mv km mw mx bi translated">解决办法</h1><p id="2a76" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">一旦我们销毁了组件，基本上我们需要注销侦听器以避免内存泄漏。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f319" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经讨论了很多关于内存泄漏的问题，让我们检查一些常见的编码实践，以避免我们的Angular应用程序中的内存泄漏。</p><h1 id="bbfe" class="mg mh iq bd mi mj mk ml mm mn mo mp mq kf mr kg ms ki mt kj mu kl mv km mw mx bi translated">练习</h1><h2 id="281e" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">1.使用<code class="fe oo op oq or b">unsubscribe</code>方法</h2><p id="f9e3" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">所有订阅都需要<strong class="ky ja">取消订阅</strong>才能释放或取消可观察的执行。</p><p id="7f76" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止内存泄漏，一个常见的做法是捕获订阅中的可观察对象，并在ngOnDestroy钩子中取消订阅，一旦组件被销毁，这个钩子就会被调用。</p><p id="3321" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止这些内存泄漏，我们必须在完成订阅后取消订阅。我们这样做是通过调用<code class="fe oo op oq or b">unsubscribe</code>可观察的方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b16e" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，我们将ngOnDestroy添加到了TestComponent中，我们在订阅方法中捕获了可观察对象，并且取消了订阅。</p><p id="e599" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果组件中有多个订阅怎么办？让我们看看它是什么样子的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2764" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TestComponent中有两个订阅。它们都在ngOnDestroy钩子中被取消订阅，以防止内存泄漏。</p><p id="98ca" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在一个数组中收集它们的订阅，并在<code class="fe oo op oq or b">ngOnDestroy</code>中取消订阅:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b537" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Observables subscribe方法返回一个RXJS subscription对象，所以基本上，我们可以使用<strong class="ky ja"> add </strong>方法将它们分组，这样当我们取消订阅一个主订阅时，所有子订阅都将被自己取消订阅。</p><p id="aadf" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看这个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="79b2" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当组件被销毁时，这将取消<code class="fe oo op oq or b">this.subscripton1$</code>和<code class="fe oo op oq or b">this.subscripton2$</code>的订阅。</p><h2 id="794b" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">2.使用异步<code class="fe oo op oq or b">|</code>管道</h2><p id="8b40" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">异步管道订阅可观察对象，并返回最新发出的值。捕获新值后，异步管道标记组件会自行检查。异步管道自动取消订阅，以避免任何潜在的内存泄漏。</p><p id="4e58" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看异步管道的例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="67d2" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，异步管道的主要优点是我们不需要记住取消订阅ngOnDestroy方法中的可观察对象，因为它会自己处理。</p><h2 id="b53b" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">3.使用RxJS <code class="fe oo op oq or b">take*</code>运算符</h2><p id="d5ec" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">RXJS确实有一些take操作符，可以用来取消订阅Observables。</p><ul class=""><li id="448f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr os ly lz ma bi translated">拿走</li><li id="3306" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr os ly lz ma bi translated">takeUntil(通知程序)</li><li id="0037" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr os ly lz ma bi translated">takeWhile(谓语)</li></ul><h2 id="f931" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">拿走</h2><p id="8f3c" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">该操作符确保订阅发生一次，或者基于数量<strong class="ky ja"> n </strong>次(基于提到的数量)。</p><p id="23fa" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数情况下，它与take(1)一起使用，以确保我们只接收一次可观察值，并在此之后完成。</p><p id="0356" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们希望源Observable发出一次，然后直接从流中取消订阅时，这个操作符将是有效的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="76d7" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，data$在从服务中获得数据的第一个值后将取消订阅。</p><p id="a3da" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一的问题是，即使我们的组件被破坏，data$也不会退订，直到它获得价值。</p><p id="859b" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，最好确保取消ngOnDestroy挂钩中的所有内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="9cba" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">takeUntil(通知程序)</h2><p id="3aeb" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">该操作符发出由源可观察对象发出的值，直到通知者可观察对象发出一个值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="15a9" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">取消订阅可观察对象的一种常用方法是使用takeUntil操作符，它会一直等到我们从服务中获得数据。一旦我们得到数据，它将取消订阅数据美元。</p><p id="8c89" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们有多个订阅时，这种方法有助于只声明一次，并且只需要在ngOnDestroy钩子中编写一次代码来取消订阅。</p><h2 id="850a" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">4.使用RxJS <code class="fe oo op oq or b">first</code>运算符</h2><p id="0b86" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">该运算符类似于take(1)和takeWhile的组合</p><p id="69c0" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果它被调用时没有值，那么它将在第一个值时完成。如果用谓词函数调用它，它会发出源可观察对象的第一个值，该值通过了谓词函数的测试条件，并且是完整的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fdf3" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果间隔发出第一个值，数据$将完成。</p><h1 id="15c9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq kf mr kg ms ki mt kj mu kl mv km mw mx bi translated">5.使用Decorator自动退订</h1><p id="7f61" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们很有可能会忘记编写代码，或者有任何原因导致我们最终清理订阅。</p><p id="2d1b" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以创建自己的装饰器，这有助于避免一次又一次地编写代码。</p><p id="2a1b" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是npm包名称unsubscribe all的一个实现。</p><p id="3ae2" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【https://www.npmjs.com/package/unsubscribe-all T4】</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5555" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这样做，我们只需要在每个类中编写unsubscribe all()decorator，其他事情将由decorator负责。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="bbe8" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">6.使用<code class="fe oo op oq or b">tslint</code></h2><p id="61cb" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">有些可能需要<code class="fe oo op oq or b">tslint</code>的提醒，在控制台中提醒我们，我们的组件或指令应该有一个ngOnDestroy方法，当它检测不到时。</p><p id="3d51" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以向tslint添加一个自定义规则，以便在林挺和构建过程中，如果它在我们的组件中没有发现ngOnDestroy挂钩，就在控制台中向我们发出警告:</p><p id="ac44" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以按照本文来实现lint规则。</p><div class="ot ou gp gr ov ow"><a href="https://blog.bitsrc.io/6-ways-to-unsubscribe-from-observables-in-angular-ab912819a78f" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ja gy z fp pb fr fs pc fu fw iz bi translated">取消订阅Angular Observables的6种方法</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">回顾了在Angular中取消订阅Observables的不同方法</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">blog.bitsrc.io</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ku ow"/></div></div></a></div><p id="b945" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们有这样一个没有ngOnDestroy的组件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="44c5" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">林挺AppComponent将警告我们丢失的ngOnDestroy钩子:</p><pre class="kp kq kr ks gt pl or pm pn aw po bi"><span id="d5c1" class="od mh iq or b gy pp pq l pr ps">$ ng lint<br/>Error at app.component.ts 12: Class name must have the ngOnDestroy hook</span></pre></div><div class="ab cl pt pu hu pv" role="separator"><span class="pw bw bk px py pz"/><span class="pw bw bk px py pz"/><span class="pw bw bk px py"/></div><div class="ij ik il im in"><h2 id="c0a5" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">7.子链接</h2><p id="974c" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们可以使用第三方库来实现这些功能。</p><p id="7b52" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用setter使用<code class="fe oo op oq or b">sink</code>属性收集订阅的示例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7530" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ja">参考文献:</strong></p><div class="ot ou gp gr ov ow"><a href="https://trungk18.com/experience/angular-common-memory-leak-use-case-observable/" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ja gy z fp pb fr fs pc fu fw iz bi translated">了解并防止Angular应用程序中最常见的内存泄漏——订阅…</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">TL；DR —记得清理您的Rx订阅。以我的经验来看，这是目前记忆最常见的原因…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">trungk18.com</p></div></div><div class="pf l"><div class="qa l ph pi pj pf pk ku ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://itnext.io/angular-rxjs-detecting-memory-leaks-bdd312a070a0" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ja gy z fp pb fr fs pc fu fw iz bi translated">Angular &amp; RxJS:检测内存泄漏</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">我已经使用RxJS构建了一个示例Angular应用程序来模拟各种内存泄漏。这些技术中的大多数…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">itnext.io</p></div></div><div class="pf l"><div class="qb l ph pi pj pf pk ku ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://blog.bitsrc.io/6-ways-to-unsubscribe-from-observables-in-angular-ab912819a78f" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ja gy z fp pb fr fs pc fu fw iz bi translated">取消订阅Angular Observables的6种方法</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">回顾了在Angular中取消订阅Observables的不同方法</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">blog.bitsrc.io</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ku ow"/></div></div></a></div><h2 id="65f6" class="od mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw iw bi translated">如果你喜欢并想获得更多这样的内容，请做<a class="ae nw" href="https://medium.com/@patel_ap/membership" rel="noopener">订阅</a></h2><p id="a067" class="pw-post-body-paragraph kw kx iq ky b kz my ka lb lc mz kd le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><strong class="ky ja">你可以在这里查看我以前的文章:</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qc nf l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qc nf l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qc nf l"/></div></figure><p id="a265" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">更多内容尽在</em><a class="ae nw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ja"><em class="nd">plain English . io</em></strong></a></p></div></div>    
</body>
</html>