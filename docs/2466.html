<html>
<head>
<title>How the JavaScript Event Loop Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件循环如何工作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-the-javascript-event-loop-84d21ef276ee?source=collection_archive---------3-----------------------#2021-05-21">https://javascript.plainenglish.io/what-is-the-javascript-event-loop-84d21ef276ee?source=collection_archive---------3-----------------------#2021-05-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="54c8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">看看调用栈、Web APIs和回调队列是如何协同工作的</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5e27c77d1cebe960a63263c0b1069196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIloCYDemISWxD5Kt4D0FA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">Loupe</a> by Philip Roberts will be used for demonstrations</figcaption></figure><p id="9c87" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">事件循环</strong>是JavaScript在浏览器中用来处理多段代码执行的系统。它由调用栈、Web APIs和回调队列组成。它负责赋予JavaScript异步编程能力。</p><p id="21d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript是一种单线程的异步语言，具有基于“运行到完成”事件循环的并发模型…等等，什么？继续读下去，希望在你读完的时候，这句话会有意义。</p><p id="965a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">必备知识:基本的JS函数、console.logs和</em><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API" rel="noopener ugc nofollow" target="_blank"><em class="lp">Web API</em></a><em class="lp">如setTimeout和addEventListener。</em></p><h2 id="256c" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">我们来分解一下</h2><p id="191a" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated"><strong class="kv io">单线程:</strong>当我们说JavaScript是单线程语言时，这意味着它一次只能“处理”一个命令，从上到下。</p><p id="473d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">异步:</strong>等等，JavaScript怎么可能是异步单线程的？嗯，从技术上讲，浏览器及其Web APIs赋予了JavaScript异步能力；语言本身实际上没有这种能力。异步函数允许代码稍后运行(在我们的回调队列中),否则会降低web应用程序的加载速度。</p><p id="e913" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">“运行至完成”:</strong>这告诉我们，在下一个函数执行之前，每个JavaScript函数都将完整运行。如果一个函数需要很长时间运行，web应用程序基本上会暂停，等待它完成，然后继续下一个函数。这就是所谓的“阻塞堆栈”。浏览器及其异步Web APIs稍后将帮助我们解决这个问题。</p><p id="8b70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">调用堆栈:</strong>这是一个堆栈(是的，就像<a class="ae ks" href="https://www.studytonight.com/data-structures/stack-data-structure" rel="noopener ugc nofollow" target="_blank">堆栈</a>数据结构一样)，代码在这里一步一步执行。JavaScript函数以后进先出的顺序添加(push())和移除(pop())到堆栈中。JavaScript中只有一个调用栈，这就是为什么它是单线程的。像Java这样的多线程语言可以有很多栈同时运行代码。在调用堆栈运行完所有同步JavaScript之前，浏览器中呈现的页面不会是交互式的，理解这一点很重要。</p><p id="3324" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">Web API:</strong>这些异步调用(即addEventListener、setTimeout)由浏览器提供，为JavaScript引擎提供额外的功能。将Web API推送到调用堆栈后，它将被发送到一个单独的Web API容器，一旦触发了一个动作(即“点击”事件、计时器结束、HTTP请求)，回调函数将被添加到回调队列中。</p><p id="f6b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">回调队列:</strong>这是一个<a class="ae ks" href="https://www.geeksforgeeks.org/queue-data-structure/" rel="noopener ugc nofollow" target="_blank">队列</a>数据结构，它以FIFO(先进先出)的顺序添加来自Web APIs的回调函数。在调用栈运行完所有的同步JavaScript之后，回调队列一次一个函数地出队到调用栈上，然后执行。</p><h2 id="3519" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">同步调用堆栈示例</h2><p id="c26f" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">让我们看看正在运行的一些同步代码。本例中只使用了调用堆栈:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/bdbd2fc5170ff0afa678975f639cb120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*fqP9NZ6_T1dZYAS3io9Gvw.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">Loupe</a></figcaption></figure><p id="a599" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，我们从顶部开始，首先将console.log("START ")发送到调用堆栈。它在运行后被删除。然后我们向下移动到被调用的sayHi函数。将该函数添加到堆栈中，然后将其中的console.log添加到该函数的顶部并执行。每个都按FIFO顺序删除，并使用sayBye()重复相同的步骤。最后一次运行的代码是console.log("END ")，然后被删除，我们的堆栈再次为空，因为它已经完成了代码的运行。</p><p id="73e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们增加一些复杂性(但仍然没有异步Web APIs)来更好地理解调用栈如何运行代码。如果一个函数在另一个函数内部被调用，会发生什么？看一看:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/7660f34a03629edb7c3fbaed4939cc7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*P4cV1LlkHwSHlnMnLP78TA.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">Loupe</a></figcaption></figure><p id="12d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">答案是肯定的。在其他函数内部调用的函数将在堆栈中运行，然后在完成调用它们的函数中的代码之前运行完成。请注意sayWhatsUp函数在调用堆栈中是如何堆叠在sayHi函数之上的。</p><h2 id="08f3" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">异步Web API示例</h2><p id="4604" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">我们先来看看setTimeout Web API。如您所知，setTimeout有两个参数，一个回调函数和一个回调执行前的时间(毫秒)。让我们看看当我们将sayHi函数作为setTimeout的回调函数传入时会发生什么:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/df19d20bdd78f945b26a418077a8b4ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*1Pgg5uOrBZ8y6n8JMwNyYw.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">Loupe</a></figcaption></figure><p id="d60c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的setTimeout函数在调用堆栈中处理后被发送到Web APIs容器。3000毫秒(3秒)后，回调sayHi()被发送到回调队列，在那里等待同步代码结束运行，然后出队并在调用堆栈中运行。需要注意的是:我们设置的3000 ms时间是回调运行之前的最短时间。如果当3000毫秒结束时，我们的同步代码仍在调用堆栈中执行，则回调仍必须等到所有代码完成后，才能发送到调用堆栈。让我们将setTimeout时间设置为0，并查看实际情况:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/276fc29ccdf8b26d194809d27888dc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8iuG9ZrJicxS25J2-PLInQ.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">Loupe</a></figcaption></figure><p id="837d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这清楚地展示了回调队列是如何直到调用栈为空时才运行的，即使setTimeout函数已经超时。</p><p id="4735" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看一个例子，看看“阻塞”是如何在调用栈中发生的，以及Web APIs如何帮助解决这个问题。让我们的sayBye函数说三次“再见”。我们将添加一个带有click事件监听器的按钮，每当它被点击时，监听器记录“我被点击了”。在添加事件侦听器之前，我们将调用sayBye3Times函数:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/42d7d1aa8a63430cc8574a20fe9c262c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*1Jhs69OimplILHOt4sn7rw.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">Loupe</a></figcaption></figure><p id="fa8b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，调用堆栈被所有在say by 3次中调用的console.logs阻塞，因此我们的click侦听器没有被实例化，我们的单击被忽略。让我们看看如何使用异步Web API setTimeout来改进这一点:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1474e662ebc98910fbed7e59def9cdf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*X6tfbqNGPQc85glBRI_xtw.gif"/></div></figure><p id="334b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过将sayBye3Times函数放在setTimeout函数中并使其异步，我们的事件侦听器不再被阻止进入调用堆栈，并可以被发送到Web APIs容器进行实例化。现在，即使在执行sayBye3Times功能时，也可以记录我们的点击。</p><h2 id="5dcd" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">结论</h2><p id="2f7f" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">现在，这似乎更有意义了:<em class="lp"> JavaScript是一种单线程的异步语言，它的并发模型是基于“运行到完成”事件循环的。</em></p><p id="52eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢您的阅读，请随时在<a class="ae ks" href="https://www.linkedin.com/in/kylefarmer85/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系！</p><p id="d42c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lp">plain English . io</em></a></p></div></div>    
</body>
</html>