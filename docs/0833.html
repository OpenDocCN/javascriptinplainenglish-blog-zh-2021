<html>
<head>
<title>Writing a Node.js GraphQL backend that actually scales — A complete guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写一个实际可扩展的Node.js GraphQL后端——完整的指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-a-node-js-graphql-backend-that-actually-scales-a-complete-guide-part-1-setup-cddceae25bdc?source=collection_archive---------0-----------------------#2021-02-21">https://javascript.plainenglish.io/writing-a-node-js-graphql-backend-that-actually-scales-a-complete-guide-part-1-setup-cddceae25bdc?source=collection_archive---------0-----------------------#2021-02-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ccb1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><strong class="ak">第1部分:设置</strong></h2></div><p id="6e8d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在网络开发领域，无论何时你要构建一个现代化的应用程序，你都有很多工具和框架可以选择来构建你的堆栈，通常，人们会拿走他们觉得舒服的任何东西，或者最新/流行的技术。</p><p id="9c12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您以前经历过这种情况，您知道GraphQL是构建后端应用程序的一个流行的替代方案，您可能对它很感兴趣。</p><p id="4630" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，那时我很好奇，在用它进行了一些年和许多专业开发的项目之后，我可以向你保证，如果用正确的方法来做，GraphQL是很棒的，这是我非常努力才弄明白的。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/98e9aaf105b9dea8ec394e2626854328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENMJyVnsHHu9ksNkO1NkDg.jpeg"/></div></div></figure><p id="1b51" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可能你已经知道了。有很多教程和youtube视频教你如何用<a class="ae lk" href="https://www.apollographql.com/docs/apollo-server/getting-started/" rel="noopener ugc nofollow" target="_blank"> GraphQL Apollo Server </a>构建一个Node.js后端，也许你已经看过了。也可能不是。</p><p id="5189" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本系列文章的最终目标不仅是向您展示如何以适当的方式从头开始构建，而且还向您展示如何扩展到实际的大型代码库。</p><p id="2de2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管GraphQL已经证明自己是构建应用程序后端的成熟可靠的技术，但我认为它的流行程度并没有提高到应有的水平。人们仍然依赖旧的、但众所周知的RESTful模型API，因为它仍然可用，而且他们通常认为GraphQL是一个过度工程化的解决方案，尽管人们对它的共识是积极的。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ll"><img src="../Images/fecaa8f0a3e88fdc245700f1029c8c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vnW3LKksusXStAWZ9KX4w.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Source: <a class="ae lk" href="https://2020.stateofjs.com/en-US/technologies/" rel="noopener ugc nofollow" target="_blank">https://2020.stateofjs.com/en-US/technologies/</a></figcaption></figure><p id="856e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">似乎开发人员出于某种原因，并不真的喜欢构建GraphQL后端，但他们实际上喜欢使用它们。那么，我将在一系列文章中向您展示一种成功构建GraphQL后端的方法。</p><p id="ff7e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就拿这篇文章来说吧，当我开始使用graphql的时候，我可能就想拥有这篇文章。</p><h2 id="a6ae" class="lq lr in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated"><strong class="ak">你将学会如何……</strong></h2><ul class=""><li id="12db" class="mj mk in ke b kf ml ki mm kl mn kp mo kt mp kx mq mr ms mt bi translated">用Express从头开始使用Node.js来设置一个Apollo服务器(相信我，你会需要它)</li><li id="cd3a" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">构建查询结构，允许覆盖许多用例，同时仍然是可测试和可靠的</li><li id="aafc" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">写指令</li><li id="a0cb" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">结构化并拆分代码，这样它就不会成为单个文件上的大块</li><li id="7e03" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">以适当的方式对数据建模，并使用ORM/ODM将其连接到数据库</li><li id="e06f" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">优化操作以避免使用dataloaders对数据库进行重复查询</li><li id="8e2f" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">通过架构使用和配置动态计算字段时要充分利用这一点</li></ul><h2 id="cdca" class="lq lr in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated"><strong class="ak">你不会学到如何……</strong></h2><ul class=""><li id="1826" class="mj mk in ke b kf ml ki mm kl mn kp mo kt mp kx mq mr ms mt bi translated">基本了解GraphQL类型和解析器。我会假设你已经知道这一点，但你想知道如何改进你的项目。本教程将面向初学者，但还有其他更好的资源来了解基元类型。</li><li id="ef51" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">处理身份验证(这是针对另一篇完整的文章)</li><li id="0b88" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">处理文件上载(与前一个相同)</li><li id="7559" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">林挺和代码风格(另一篇文章)</li><li id="f081" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">向您的模式和解析器添加测试(您知道…另一篇文章)</li><li id="bb2b" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">构建您自己的数据类型</li><li id="6beb" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">部署</li></ul><p id="6868" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">注</strong>:这部分教程之前的东西都可以在我的<a class="ae lk" href="https://github.com/ernestognw/graphql-backend/tree/part-1" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">公开回购</strong> </a>上找到</p><h1 id="6970" class="mz lr in bd ls na nb nc lv nd ne nf ly jt ng ju mb jw nh jx me jz ni ka mh nj bi translated"><strong class="ak">我们开始吧</strong></h1><p id="59f1" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">你要做的第一件事是创建一个新的文件夹并启动一个新的npm项目，你可以通过运行以下命令来完成:</p><pre class="kz la lb lc gt nn no np nq aw nr bi"><span id="d544" class="lq lr in no b gy ns nt l nu nv">mkdir graphql-backend<br/>cd graphql-backend<br/>yarn init -y</span></pre><p id="cb7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用<code class="fe nw nx ny no b">-y</code>标志来避免配置设置，但是如果你想的话，你可以删除它。</p><p id="54d8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于本教程，我们目前将使用最新的Javascript语法，这将通过<a class="ae lk" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>来实现，这是一个transpiler，它获取我们的Node.js现代代码并将其转换为与基本节点语法兼容的内容。我们不会深入研究它，但知道它的用途是很好的。</p><p id="b25c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，要让热重载立即看到我们的应用程序中的变化，您可能需要添加<a class="ae lk" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank"> nodemon </a>，它将在每次更新时自动重启。</p><p id="ad20" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了添加提到的工具，只需运行:</p><pre class="kz la lb lc gt nn no np nq aw nr bi"><span id="642e" class="lq lr in no b gy ns nt l nu nv">yarn add <a class="ae lk" href="http://twitter.com/babel/core" rel="noopener ugc nofollow" target="_blank">@babel/core</a> <a class="ae lk" href="http://twitter.com/babel/node" rel="noopener ugc nofollow" target="_blank">@babel/node</a> <a class="ae lk" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a> nodemon -D</span></pre><ul class=""><li id="30c1" class="mj mk in ke b kf kg ki kj kl nz kp oa kt ob kx mq mr ms mt bi translated"><strong class="ke io"> @babel/core: </strong>这是核心库</li><li id="0d7b" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">这将允许我们使用<code class="fe nw nx ny no b">babel-node</code>命令而不是传统的<code class="fe nw nx ny no b">node</code>命令来运行我们的代码。</li><li id="a90d" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">最后，这是一个预置，包含了语言的最新添加，所以你不必担心手动添加新的语法</li></ul><p id="520c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">重要提示:</strong>如果您出于部署的原因计划创建一个生产构建(如前所述，我们没有涉及到这一点)，您应该添加<code class="fe nw nx ny no b">-D</code>标志，因此它们只是为开发环境添加的。</p><h1 id="5663" class="mz lr in bd ls na nb nc lv nd ne nf ly jt ng ju mb jw nh jx me jz ni ka mh nj bi translated"><strong class="ak">文件夹结构</strong></h1><p id="1847" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">一旦你完成了我们的基本设置，你的文件夹中就有了基本文件(比如yarn.lock或者package.json)。下一步是添加一个基本结构，我们将在未来对其进行扩展，但对于第1部分来说，这已经足够了:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/5d6a810bbf712a46b648b004cc4cabe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*A2Up9SMZNfABIrtadmnAkw.png"/></div></figure><p id="0ac1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我列出了将每个文件放在graphql文件夹之外的原因:</p><ul class=""><li id="4405" class="mj mk in ke b kf kg ki kj kl nz kp oa kt ob kx mq mr ms mt bi translated"><strong class="ke io"> index.js: </strong>我们正在根级别创建一个index.js，这样我们就可以使用它来启动项目，由于我们的项目规模，这在目前是没有意义的，但是当我们开始添加数据库内容时，它将是有用的，并且在将来当您可能需要将graphql之外的额外功能添加到您的应用程序时，它将是有用的。</li><li id="44c7" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io"> app.js: </strong>这将是express应用程序的配置文件，我们将在index.js上初始化它</li><li id="da1e" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io"> config: </strong>配置文件夹有助于集中应用程序的一般设置，我们稍后还会对此进行扩展，但此时我们将创建一个环境文件夹来使用其中的环境变量。</li><li id="cff6" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io"> .env.*: </strong>我们的env文件将指定环境变量，使我们的应用程序在每个环境中表现不同，这取决于我们希望它如何工作。的。env通过<strong class="ke io"> gitignore </strong>被忽略，而<code class="fe nw nx ny no b">.env.example</code>被保留以拥有所需环境变量的模板。如果你在团队中工作，这很有用</li><li id="12ee" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io">。Babel RC:</strong>Babel的配置文件</li></ul><p id="bb9f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在有趣的部分是:在graphql文件夹中，我们将把我们的模式和解析器分离到文件夹中，因为我们将看到如何根据我们将要建模的资源把我们的代码分割到不同的文件中。这将允许你以一种舒适的方式发展你的代码库。</p><h1 id="1179" class="mz lr in bd ls na nb nc lv nd ne nf ly jt ng ju mb jw nh jx me jz ni ka mh nj bi translated">基本依赖关系</h1><p id="7765" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">接下来，我们将添加我们的基本依赖项，以使我们的项目正常工作:</p><pre class="kz la lb lc gt nn no np nq aw nr bi"><span id="1a3b" class="lq lr in no b gy ns nt l nu nv">yarn add express apollo-server-express graphql <a class="ae lk" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/schema dotenv</span></pre><ul class=""><li id="ce03" class="mj mk in ke b kf kg ki kj kl nz kp oa kt ob kx mq mr ms mt bi translated"><strong class="ke io"> express: </strong>它是一个极简的HTTP服务器，但是你可能已经知道了。我们使用它是因为<strong class="ke io">相信我。</strong>在应用程序上实现不应由graphql处理的事情是有用的。通常，您需要为其他目的而不是数据访问公开端点，比如健康检查或身份验证。</li><li id="8438" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io"> apollo-server-express: </strong>因为我们使用的是express，所以需要使用apollo的express兼容版本。</li><li id="0e2a" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io"> graphql: </strong>即使它没有直接用在我们的应用程序上，但它是几个库的对等依赖，所以你必须添加它。</li><li id="b0d3" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io"> @graphql-tools/schema: </strong>我们将用它来构建和编译我们的模式</li><li id="6bdc" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io"> dotenv: </strong>为了使您的应用程序适合在不同的环境下工作，您可能需要添加环境变量。我们将使用这种依赖性来读取它们</li></ul><h1 id="c4ef" class="mz lr in bd ls na nb nc lv nd ne nf ly jt ng ju mb jw nh jx me jz ni ka mh nj bi translated">设置服务器</h1><p id="bd46" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">现在，在我们深入研究graphql文件夹配置之前，让我们只添加简单的代码来使我们的express应用程序工作。只需将下面的代码复制到相应的文件中，这样我们就可以有一个正常工作的HTTP服务器了。</p><p id="6500" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，在app.js文件中创建一个基本的快速应用程序:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="cc7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，用环境变量模板配置您的. env.example</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e776" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，在中创建它的副本。env(记住这是隐藏的)，并根据需要进行配置。我正在添加我正在使用的设置:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3701" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，在config/environment/index.js文件中，读取这些环境变量，并导出它们。这是集中您的配置，然后在应用程序的不同组件上使用它的好方法:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="87aa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，是时候配置您的。babelrc文件，以便使用我们之前讨论过的预置-env</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6f39" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成后，您只需在index.js上初始化您的应用程序</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e68b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，将一个npm脚本添加到您的<code class="fe nw nx ny no b">package.json</code>中，这样您就可以运行整个程序了:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi of"><img src="../Images/dfc4ad64d804fd8b80cccde1f6b08b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*Hri8tMuo3b6oCYZl06PzAg.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">nodemon ./index.js — exec babel-node</figcaption></figure><p id="b3d3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，只需运行您的服务器并检查一切是否正常:</p><pre class="kz la lb lc gt nn no np nq aw nr bi"><span id="d171" class="lq lr in no b gy ns nt l nu nv">yarn dev</span></pre><p id="d435" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该会看到类似这样的内容:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi og"><img src="../Images/2077bd6768ea5f356ec45f339b1547c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*w-m6CRXzsJxaxcqfyA8KAw.png"/></div></figure><h1 id="6031" class="mz lr in bd ls na nb nc lv nd ne nf ly jt ng ju mb jw nh jx me jz ni ka mh nj bi translated">设置我们的模式</h1><p id="dca5" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">至此，您已经有了运行express(还不是graphql)服务器的基本设置，您可以使用它来配置将来可能需要的主要内容。尽管看起来有很多文件夹和文件，但只要我们继续构建我们的应用程序，它就有意义。</p><p id="fc4e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从现在开始，我们将深入到在graphql文件夹中创建我们的graphql服务器的细节，但最终，我们将在未来添加一些额外的文件夹来连接我们的数据库，但现在，让我们解释我们将如何准备我们的graphql文件夹结构以正确伸缩。</p><p id="66bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要在graphql/index.js中准备好我们的Apollo服务器:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2f52" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您会注意到我们正在使用从集中式环境中导出的env变量。这就是它的好处。您希望根据未来的环境定义不同的行为。在这种情况下，我们锁定了操场，只让它在我们的开发环境中工作。</p><p id="1a3c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，根据<a class="ae lk" href="https://www.apollographql.com/docs/apollo-server/getting-started/#step-3-define-your-graphql-schema" rel="noopener ugc nofollow" target="_blank">官方apollo文档</a>，你会发现我们需要一个由两个主要事物定义的模式:</p><ul class=""><li id="5acb" class="mj mk in ke b kf kg ki kj kl nz kp oa kt ob kx mq mr ms mt bi translated"><strong class="ke io"> Typedefs </strong>:我们数据的形状</li><li id="99d9" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated"><strong class="ke io">解析器</strong>:数据计算和返回的方式</li></ul><p id="76dd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，通常教程会解释如何配置这两个家伙，但我们会更进一步，将他们分开，这样我们就可以从一开始就有一个组织良好的代码库。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e6ea711f910678d9e6ae46e1cc2d13de.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*HGp0aPDKEsmB138jfgG6PQ.png"/></div></figure><p id="9d70" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您之前看到的，我们在graphql主文件夹中定义了两个文件夹。这两个将帮助我们划分我们的代码。但是首先，让我们来看看我们要建模的数据:</p><h2 id="ca15" class="lq lr in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated">建模数据</h2><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi oh"><img src="../Images/b4c19ba790139aa9e65ba52a99063f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLgi7xBdptficIaVDdPJPg.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Entity-Relationship model</figcaption></figure><p id="1185" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是典型的图书作者示例的扩展版本，但是这里有一些额外的小东西，我们将在将来使用它们来涵盖更深层次的概念。</p><p id="9947" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看，总的来说，我们的主要实体是:</p><ul class=""><li id="e125" class="mj mk in ke b kf kg ki kj kl nz kp oa kt ob kx mq mr ms mt bi translated">出版者</li><li id="d517" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">作者</li><li id="6f89" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">书</li></ul><p id="65c5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nw nx ny no b">WorksAt</code>实体不会通过graphql公开，因为它只是一个弱实体，它的存在只是为了创建多对多的关系，所以我们不会将它视为模式中的可查询字段。</p><h2 id="d04e" class="lq lr in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated">Typedefs</h2><p id="a84e" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">现在我们对数据是如何形成的有了很好的理解，让我们开始在下面不同的文件中创建我们的typedefs:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f1435452acd620cb02a6bdc8202c865a.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*TCDxJ5e-ZhHHEuw4cMee9A.png"/></div></figure><p id="40c3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您将看到，我们为要建模的每个实体都准备了一个. graphql文件，以及一个<code class="fe nw nx ny no b">index.graphql</code>和一个<code class="fe nw nx ny no b">common.graphql</code>。我们将使用<code class="fe nw nx ny no b">index.graphql</code>来保存我们的根定义(理解为查询和变异)以及其他与特定实体相关的类型。<code class="fe nw nx ny no b">common.graphql</code>用于通用类型。</p><p id="dd84" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的<code class="fe nw nx ny no b">index.graphql</code>上，我们将填写以下内容:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="43da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你会注意到<code class="fe nw nx ny no b">Date</code>标量。这必须声明，因为它不是graphql的本机类型，但是它包含在@graphql-tools中，并且它将只使用这个声明。</p><p id="6d47" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">注意</strong>:我们不会处理删除操作，因为这会产生其他数据可靠性问题，我们可以用不属于本教程范围的技术来解决这些问题。</p><p id="2f0e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们用缺失的数据类型填充我们的实体graphql文件:</p><p id="d7ab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的<code class="fe nw nx ny no b">common.graphql</code>中，我们将定义一个应用于每个实体的接口，因为每个实体都有相应的时间戳。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e49f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们的作者，我们将定义数据库中指定的名称和id的类型，以及时间戳接口。此外，我们会将此事与出版商联系起来，但我们会看到如何在未来解决这种关系</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="780c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们的书来说，非常简单。与作者的关系要简单得多，所以我们可能会在以后处理这个问题。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="044c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，出版商和作者的情况差不多:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e76c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们将整个模式分成不同的文件。现在的问题是，<em class="oj">我们如何将所有这些放在一起？</em></p><p id="5e87" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将创建一个脚本来处理typedefs模式中的每个文件。这将允许我们创建我们所拥有的模式的最终版本，以构建单个模式。</p><p id="e19e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">转到您的项目，在<code class="fe nw nx ny no b">graphql/index.js</code>文件旁边创建一个<code class="fe nw nx ny no b">schema.js</code>，我们将在这里处理所有内容:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1b3719985de0b000cfb5677f047f7498.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*VJtD9Sr9GghsTdWOuU5knw.png"/></div></figure><p id="b285" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在其中，我们将使用节点文件系统实用程序来读取文件的名称，然后将它们转换为一个字符串，连接它们，最后使用@graphql-tools/schema将它们放在一起。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="5743" class="lq lr in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated">下决心者</h2><p id="cbc6" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">至此，我们已经完成了typedef，但是我们需要使用resolver函数用数据填充这些typedef。这些将被构建在<code class="fe nw nx ny no b">resolvers</code>文件夹中我们正在解析的实体名称的子文件夹中。因此，让我们创建以下结构，然后，我们将深入探究这样组织信息的原因:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/dcc94547335bfcf812508c5d94875085.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*qBJ_6Wo8u0Gz-ZG6hHAABw.png"/></div></figure><p id="a321" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您会看到每个文件夹都有相同的结构，这就是为什么:</p><ul class=""><li id="dbe7" class="mj mk in ke b kf kg ki kj kl nz kp oa kt ob kx mq mr ms mt bi translated"><strong class="ke io"> index.js: </strong>我们将在以后使用这个文件挂载代码来解析这个单独的实体。当我们优化查询时，您可能会发现这很有用。现在，它将只公开来自突变和查询文件的默认导出。</li><li id="c7f3" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">我们将把每个解析突变的函数放在这里</li><li id="d852" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">我们将把每个解析查询的函数放在这里</li></ul><p id="bb17" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于每个文件的内部外观，这里有一个作者文件夹的示例:</p><p id="eb39" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">queries.js:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0eaf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">mutations.js:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="659a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">索引. js</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3a3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，此时我们甚至没有解决任何问题。这是因为我们将在下一篇文章中用实际的数据库数据填充数据。</p><p id="9982" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从现在开始，我想如何填充剩余的文件会很清楚，所以我让你来做。</p><p id="e52d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将所有这些分割成文件的主要原因是因为我们的目标是拥有一个可伸缩的应用程序。所以，即使看起来一切都是分离的。我向您保证，这将使您的代码正确地组织到与主题相关的文件中，并为将来的扩展提供足够的空间。</p><p id="5309" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，让我们将这些解析器合并成您的<code class="fe nw nx ny no b">graphql/resolvers/index.js</code>文件中的一个对象。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a59c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们只需将解析器添加到我们的<code class="fe nw nx ny no b">graphql/schema.js</code>文件中，这样它们就可以一起工作了</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e2bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，使用这个全新的模式，并将其添加到您在<code class="fe nw nx ny no b">graphql/index.js</code>的Apollo服务器中</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3e0c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，只需将express服务器作为中间件添加到apollo服务器中:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6526" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果一切正常，您将在终端上看到和以前一样的消息，但是您实际上可以在<code class="fe nw nx ny no b">http://localhost:3000/graphql</code>检查您的模式:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi om"><img src="../Images/3e8d8a2c4116d1eedc58e780382e2fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LEG6fpNzqpUCe_jEEJz1A.png"/></div></div></figure><p id="1190" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，如果此时请求数据，将会出现错误，因为解析器无法解析并返回您请求的任何内容，但是我们将在下一篇文章中解决这个问题。</p><h1 id="ec98" class="mz lr in bd ls na nb nc lv nd ne nf ly jt ng ju mb jw nh jx me jz ni ka mh nj bi translated">包裹</h1><p id="c9a5" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">在本教程的第1部分中，我们将:</p><ul class=""><li id="3683" class="mj mk in ke b kf kg ki kj kl nz kp oa kt ob kx mq mr ms mt bi translated">为节点项目创建了一个基本设置</li><li id="6337" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">为了使用现代语法，增加了对巴别塔的支持</li><li id="0d84" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">创建了一个配置文件来读取环境变量，因此我们可以根据配置使用它们来管理不同的行为</li><li id="066e" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">设置基本express服务器</li><li id="88b5" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">使用我们的express server作为中间件，设置一个graphql服务器</li><li id="28f3" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">模型化数据</li><li id="b70a" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">定义了一个模式，为我们在一组组织良好的文件夹和文件中建模的数据提供服务</li><li id="8736" class="mj mk in ke b kf mu ki mv kl mw kp mx kt my kx mq mr ms mt bi translated">将每个文件合并到我们的主模式中</li></ul><p id="a0e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，在这一点上的一切都可以咨询和审查到我的整个系列的公开回购中，<a class="ae lk" href="https://github.com/ernestognw/graphql-backend/tree/part-1" rel="noopener ugc nofollow" target="_blank">你可以在这里找到</a>。</p><p id="1453" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae lk" href="https://js.plainenglish.io/writing-a-node-js-graphql-backend-that-actually-scales-bd5b3411b293" rel="noopener ugc nofollow" target="_blank">第二部分此处</a></p><ul class=""><li id="9c3c" class="mj mk in ke b kf kg ki kj kl nz kp oa kt ob kx mq mr ms mt bi translated">在社交媒体上关注我:<a class="ae lk" href="https://www.instagram.com/ernestognw/" rel="noopener ugc nofollow" target="_blank"> @ernestognw </a></li></ul></div><div class="ab cl on oo hr op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ig ih ii ij ik"><p id="ea36" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="oj">阅读更多尽在</em><a class="ae lk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="oj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>