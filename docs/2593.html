<html>
<head>
<title>Node.js Best practices: Performance and Reliability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践:性能和可靠性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-best-practices-performance-and-reliability-c737de2ef418?source=collection_archive---------8-----------------------#2021-05-28">https://javascript.plainenglish.io/node-js-best-practices-performance-and-reliability-c737de2ef418?source=collection_archive---------8-----------------------#2021-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/19d63760333ca28e6aeda1359a0f8d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZyIT05SEu6nO-c91IPU-g.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@markcjn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mark Chan</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="b9f8" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">Node.js应用程序的最佳实践</h2></div><p id="4183" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将是一个2篇文章的系列，我们将看到如何提高我们的应用程序的性能。在本文中，我们将讨论，我们可以在<strong class="kx jh">代码级别做些什么来提高性能</strong>。第二篇文章将介绍<strong class="kx jh"> OPs(环境/设置)部分</strong>。</p><p id="a95b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我正在研究与我从事的Express应用程序相关的东西。我们也可以在各种各样的web应用程序中使用这些方法，尽管有所改变。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lr"><img src="../Images/0b420027e9bc108e213ee4259af10fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nWjo3NEy8MmkJj_j.jpg"/></div></div></figure><h1 id="5717" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">使用gzip压缩</h1><p id="88e7" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">使用Gzip压缩可以大大减小响应体的大小，从而提高web应用程序的速度。在Express app中使用<a class="ae jd" href="https://www.npmjs.com/package/compression" rel="noopener ugc nofollow" target="_blank">压缩</a>中间件进行gzip压缩，如下所示:</p><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="9052" class="my lx jg mu b gy mz na l nb nc">var compression = require('compression')<br/>var express = require('express')<br/>var app = express()<br/>app.use(compression())</span></pre><h1 id="f805" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">对同步功能说不</h1><p id="8278" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">同步函数和方法在执行过程返回之前会一直占用执行过程。对同步函数的单个调用可能会在几微秒或几毫秒内返回，但是，在高流量的网站中，这些调用累积起来会降低应用程序的性能。避免在生产中使用它。</p><p id="ef79" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管Node和许多模块都提供了同步和异步版本的函数，但在生产中总是使用异步版本。同步功能唯一可以调整的时间是初始启动时。</p><p id="610a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们正在使用Node.js 4.0+或io.js 2.1.0+，我们可以在应用程序使用同步API时使用<code class="fe nd ne nf mu b">--trace-sync-io</code>命令行标志来打印警告和堆栈跟踪。当然，我们不希望在生产中使用它，而是希望确保我们的代码已经为生产做好了准备。</p><h1 id="6823" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">正确记录</h1><p id="1c88" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">一般来说，从我们的应用程序进行日志记录有两个原因:用于<strong class="kx jh">调试</strong>和用于<strong class="kx jh">日志记录应用程序</strong>活动(本质上，其他一切)。使用<code class="fe nd ne nf mu b">console.log()</code>或<code class="fe nd ne nf mu b">console.error()</code>将日志消息打印到终端是开发中的常见做法。但是<a class="ae jd" href="https://nodejs.org/api/console.html#console_console_1" rel="noopener ugc nofollow" target="_blank">当目的地是一个终端或一个文件时，这些函数是同步的</a>，所以它们不适合生产，除非我们通过管道将输出传递给另一个程序。</p><h2 id="066f" class="my lx jg bd ly ng nh dn mc ni nj dp mg le nk nl mi li nm nn mk lm no np mm nq bi translated">用于调试</h2><p id="4b57" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">如果我们记录日志是为了调试，那么不要使用<code class="fe nd ne nf mu b">console.log()</code>，而是使用一个特殊的调试模块，比如<a class="ae jd" href="https://www.npmjs.com/package/debug" rel="noopener ugc nofollow" target="_blank"> debug </a>。这个模块使我们能够使用DEBUG环境变量来控制发送给<code class="fe nd ne nf mu b">console.error()</code>的调试消息(如果有的话)。为了保持我们的应用程序完全异步，我们仍然希望将<code class="fe nd ne nf mu b">console.error()</code>通过管道传输到另一个程序。但是，我们不会真的在生产中调试，对吗？</p><h2 id="cd80" class="my lx jg bd ly ng nh dn mc ni nj dp mg le nk nl mi li nm nn mk lm no np mm nq bi translated">对于应用程序活动</h2><p id="de1e" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">如果我们正在记录应用程序活动(例如，跟踪流量或API调用)，我们可以使用像<a class="ae jd" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank"> Winston </a>或<a class="ae jd" href="https://www.npmjs.com/package/bunyan" rel="noopener ugc nofollow" target="_blank"> Bunyan </a>这样的日志库，而不是使用<code class="fe nd ne nf mu b">console.log()</code>。</p><h1 id="d1f2" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">使用验证参数</h1><p id="d2c9" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">用node.js编写的没有处理异常的应用程序可能会崩溃——在一些无效的输入参数的情况下，例如无效的类型转换、过长的字符串等。这意味着我们的应用程序动作的中断。</p><p id="b5ef" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很多时候，这些无效参数通过API函数传递给数据库，这可能会导致异常和错误消息。</p><blockquote class="nr ns nt"><p id="0654" class="kv kw nu kx b ky kz kh la lb lc kk ld nv lf lg lh nw lj lk ll nx ln lo lp lq ij bi translated"><strong class="kx jh">rest API中的任何函数在将输入参数发送到数据库或其他函数之前，必须在开始时检查输入参数的正确性。</strong></p></blockquote><p id="2a0f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有许多现成的软件包可以用于此目的。其中一个是<a class="ae jd" href="https://www.npmjs.com/package/express-validator" rel="noopener ugc nofollow" target="_blank"><strong class="kx jh">express-validator</strong></a>，非常适合生产。使用这个模块我们可以验证主体、查询和标题数据。</p><p id="152e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">如何使用— </strong>下面只是其中一种使用方法。我们可以根据我们的需要和要求来改变它。</p><p id="185f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.首先将模块放在server node.js的主文件中，例如index.js或server.js</p><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="08d8" class="my lx jg mu b gy mz na l nb nc">var util = require('util'),<br/>    bodyParser = require('body-parser'),<br/>    express = require('express'),<br/>    expressValidator = require('express-validator'),<br/>    app = express();</span><span id="c443" class="my lx jg mu b gy ny na l nb nc">app.use(bodyParser.json());</span><span id="8c71" class="my lx jg mu b gy ny na l nb nc">// this line must be immediately after any of the bodyParser middlewares!<br/>app.use(expressValidator({<br/>      errorFormatter: function(param, msg, value) {<br/>     var namespace = param.split('.')<br/>        ,root = namespace.shift()<br/>        ,formParam = root;<br/>    while(namespace.length) {<br/>           formParam += '[' + namespace.shift() + ']';<br/>    }<br/>    return {<br/>            param : formParam,<br/>            msg : msg,<br/>           value : value<br/>          };<br/> }<br/>}));</span><span id="01ff" class="my lx jg mu b gy ny na l nb nc">app.listen(8888);</span></pre><p id="5582" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.把下面这段代码放到一个新文件中，比如说validator.js。它将用于我们应用程序的许多文件的验证</p><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="a87a" class="my lx jg mu b gy mz na l nb nc">module.exports = function(request,response,schema)<br/>{<br/>   request.checkBody(schema);</span><span id="c23e" class="my lx jg mu b gy ny na l nb nc">  var errors = request.validationErrors();<br/>  if (errors) {<br/>       console.error({Error: errors});<br/>       response.status(422).send({Error: {Validator: errors}});<br/>       return true;<br/>   }<br/>   else return false;</span><span id="eb07" class="my lx jg mu b gy ny na l nb nc">}</span></pre><p id="c57b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.在单独的文件中声明用于输入参数验证的模式。</p><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="f811" class="my lx jg mu b gy mz na l nb nc">module.exports = {<br/>    'sensor_device_id': {</span><span id="ca88" class="my lx jg mu b gy ny na l nb nc">        isInt:{<br/>             errorMessage: 'sensor_device_id - Integer expected'<br/>        },<br/>        errorMessage: 'sensor_device_id is required'</span><span id="a1b9" class="my lx jg mu b gy ny na l nb nc">    },<br/>    'active': {</span><span id="3e8d" class="my lx jg mu b gy ny na l nb nc">        notEmpty: true,<br/>        errorMessage: 'Active Validation error'</span><span id="e081" class="my lx jg mu b gy ny na l nb nc">    },<br/>   'organisation': {</span><span id="0553" class="my lx jg mu b gy ny na l nb nc">        isInt:{<br/>            errorMessage: 'Organisation - Integer expected'<br/>        },<br/>        errorMessage: 'Organisation is required'</span><span id="81be" class="my lx jg mu b gy ny na l nb nc">    }<br/>}</span></pre><p id="e833" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.为模式的每个动作放置指令。我们需要用定义的模式放置正确的文件名。</p><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="f639" class="my lx jg mu b gy mz na l nb nc">if(validator(request,response,schema)) return next();</span></pre><p id="a0a9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">比如说-</p><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="6166" class="my lx jg mu b gy mz na l nb nc">const validator = require('../schema/validator.js');<br/>const schema_sensorActive = require('../schema/sensorActive.js');</span><span id="11ea" class="my lx jg mu b gy ny na l nb nc">app.post('/sensor', function (request, response, next) {</span><span id="24c9" class="my lx jg mu b gy ny na l nb nc">   if(validator(request,response,schema_sensorActive)) return next();</span><span id="05ba" class="my lx jg mu b gy ny na l nb nc"> const mssql = request.service.mssql; <br/> const params = request.body;<br/> const {<br/>        organisation=null,<br/>        sensor_device_id=null,<br/>        active=1<br/>    } = params;</span><span id="464e" class="my lx jg mu b gy ny na l nb nc">    const sqlQuery = 'EXEC [AppCenter].[Sensor_Active_UPDATE] ?, ?, ?, ?';<br/>    const sqlParams = [request.auth.UserID, organisation, sensor_device_id, active];<br/></span><span id="44a0" class="my lx jg mu b gy ny na l nb nc">    mssql.query(sqlQuery, sqlParams, {<br/>        success(res) {</span><span id="dcd1" class="my lx jg mu b gy ny na l nb nc">          try{<br/>                   return response.status(200).send(res);</span><span id="d998" class="my lx jg mu b gy ny na l nb nc">            } catch(err) {  return response.status(201).send({Error: res}); }<br/>        },<br/>        error: handleSqlError(response, sqlQuery, sqlParams)<br/>    });<br/>}</span></pre><p id="3524" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次，当验证器检测到一个错误，那么关于它的信息将被发送到前端客户端应用程序。同样，我们也可以对输出参数进行验证，比如从数据库、设备等执行数据之后。</p><h1 id="563f" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">正确的异常处理</h1><p id="4cd9" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">任何应用程序在遇到未捕获的异常时都会崩溃。不处理异常和采取适当的行动将使我们的应用程序崩溃和离线。有一种ops方法，我们可以在崩溃时自动启动应用程序(我将在第二部分讨论)，幸运的是，Express应用程序通常启动时间很短。</p><p id="a142" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，我们首先要避免崩溃，为此，我们需要正确处理异常。</p><p id="debe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了确保我们处理所有异常，请使用以下技巧:</p><ul class=""><li id="f2b5" class="nz oa jg kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated"><strong class="kx jh">使用试抓</strong></li><li id="9eed" class="nz oa jg kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><strong class="kx jh">使用承诺</strong></li></ul><p id="5213" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在深入这些主题之前，我们应该对节点/表达式错误处理有一个基本的了解:使用错误优先回调，以及在中间件中传播错误。Node使用“错误优先回调”约定从异步函数返回错误，其中回调函数的第一个参数是error对象，后面是后续参数中的结果数据。若要指示没有错误，请将null作为第一个参数传递。回调函数必须相应地遵循错误优先的回调惯例，以有意义地处理错误。在Express中，最佳实践是使用next()函数通过中间件链传播错误。</p><h2 id="cf30" class="my lx jg bd ly ng nh dn mc ni nj dp mg le nk nl mi li nm nn mk lm no np mm nq bi translated">不要做什么</h2><p id="8639" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们应该<strong class="kx jh"> <em class="nu">而不是</em> </strong>做的一件事是监听<code class="fe nd ne nf mu b">uncaughtException</code>事件，当一个异常一路冒泡回到事件循环时发出该事件。为<code class="fe nd ne nf mu b">uncaughtException</code>添加事件监听器将会改变遇到异常的流程的默认行为；尽管出现异常，该进程仍将继续运行。这听起来可能是防止我们的应用程序崩溃的好方法，但在未捕获到异常后继续运行应用程序是一种危险的做法，不推荐这样做，因为进程的状态变得不可靠和不可预测。</p><p id="2dc5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，使用<code class="fe nd ne nf mu b">uncaughtException</code>是官方认可的<a class="ae jd" href="https://nodejs.org/api/process.html#process_event_uncaughtexception" rel="noopener ugc nofollow" target="_blank">粗</a>。所以监听<code class="fe nd ne nf mu b">uncaughtException</code>只是个馊主意。我也不建议使用<a class="ae jd" href="https://nodejs.org/api/domain.html" rel="noopener ugc nofollow" target="_blank">域名</a>。它通常不能解决问题，并且是一个不推荐使用的模块。</p><h2 id="dfc5" class="my lx jg bd ly ng nh dn mc ni nj dp mg le nk nl mi li nm nn mk lm no np mm nq bi translated">使用试抓</h2><p id="a809" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">Try-catch是一种JavaScript语言结构，我们可以用它来捕获同步代码中的异常。例如，使用try-catch处理JSON解析错误，如下所示。</p><p id="8317" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用诸如<a class="ae jd" href="http://jshint.com/" rel="noopener ugc nofollow" target="_blank"> JSHint </a>或<a class="ae jd" href="http://www.jslint.com/" rel="noopener ugc nofollow" target="_blank"> JSLint </a>之类的工具来帮助我们找到隐式异常，比如未定义变量上的<a class="ae jd" href="http://www.jshint.com/docs/options/#undef" rel="noopener ugc nofollow" target="_blank">引用错误。</a></p><p id="5ab2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个使用try-catch处理潜在的进程崩溃异常的示例。这个中间件函数接受一个名为“params”的查询字段参数，它是一个JSON对象。</p><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="aa92" class="my lx jg mu b gy mz na l nb nc">app.get('/search', function (req, res) {<br/>  // Simulating async operation<br/>  setImmediate(function () {<br/>    var jsonStr = req.query.params<br/>    try {<br/>      var jsonObj = JSON.parse(jsonStr)<br/>      res.send('Success')<br/>    } catch (e) {<br/>      res.status(400).send('Invalid JSON string')<br/>    }<br/>  })<br/>})</span></pre><p id="1557" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，try-catch只适用于同步代码。因为节点平台主要是异步的(特别是在生产环境中)，所以try-catch不会捕获很多异常。</p><h2 id="626a" class="my lx jg bd ly ng nh dn mc ni nj dp mg le nk nl mi li nm nn mk lm no np mm nq bi translated">使用承诺</h2><p id="0085" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">Promises将处理使用<code class="fe nd ne nf mu b">then()</code>的异步代码块中的任何异常(显式和隐式)。只需将<code class="fe nd ne nf mu b">.catch(next)</code>添加到承诺链的末尾。例如:</p><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="1a50" class="my lx jg mu b gy mz na l nb nc">app.get('/', function (req, res, next) {<br/>  // do some sync stuff<br/>  queryDb()<br/>    .then(function (data) {<br/>      // handle data<br/>      return makeCsv(data)<br/>    })<br/>    .then(function (csv) {<br/>      // handle csv<br/>    })<br/>    .catch(next)<br/>})</span><span id="253c" class="my lx jg mu b gy ny na l nb nc">app.use(function (err, req, res, next) {<br/>  // handle error<br/>})</span></pre><p id="096f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，所有异步和同步错误都传播到了错误中间件。</p><p id="17ce" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">然而，有两个警告:</strong></p><ol class=""><li id="d219" class="nz oa jg kx b ky kz lb lc le ob li oc lm od lq on of og oh bi translated">我们所有的异步代码都必须返回承诺(发射器除外)。如果一个特定的库没有返回承诺，通过使用一个类似于<a class="ae jd" href="http://bluebirdjs.com/docs/api/promise.promisifyall.html" rel="noopener ugc nofollow" target="_blank">blue bird . promisifyall()</a>的帮助函数来转换基本对象。</li><li id="9186" class="nz oa jg kx b ky oi lb oj le ok li ol lm om lq on of og oh bi translated">事件发射器(如流)仍然会导致无法捕获的异常。因此，请确保我们正确处理了错误事件；例如:</li></ol><pre class="ls lt lu lv gt mt mu mv mw aw mx bi"><span id="f648" class="my lx jg mu b gy mz na l nb nc">const wrap = fn =&gt; (...args) =&gt; fn(...args).catch(args[2])</span><span id="fc3e" class="my lx jg mu b gy ny na l nb nc">app.get('/', wrap(async (req, res, next) =&gt; {<br/>  const company = await getCompanyById(req.query.id)<br/>  const stream = getLogoStreamById(company.id)<br/>  stream.on('error', next).pipe(res)<br/>}))</span></pre><p id="eea6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nd ne nf mu b">wrap()</code>函数是一个包装器，它捕捉被拒绝的承诺并以错误作为第一个参数调用<code class="fe nd ne nf mu b">next()</code>。</p><h1 id="3266" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">数据库查询优化</h1><p id="adcd" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">最后一个非常重要的问题:当来自DB服务器的响应需要几秒钟的时间(这转化为我们的Rest API的时间响应)时，即使node.js中的超级代码也会运行缓慢。</p><p id="b783" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第二件重要的事情是在DB的TSQL端使用更多的数据处理，而不是在node.js端。</p></div><div class="ab cl oo op hu oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ij ik il im in"><p id="daa7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nu">更多内容请看</em><a class="ae jd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nu">plain English . io</em></a></p></div></div>    
</body>
</html>