<html>
<head>
<title>Node.js Asynchronous and Concurrency Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js异步和并发模型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nodejs-asynchronous-concurrency-model-d4d18e17edf3?source=collection_archive---------3-----------------------#2021-05-27">https://javascript.plainenglish.io/nodejs-asynchronous-concurrency-model-d4d18e17edf3?source=collection_archive---------3-----------------------#2021-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/becbb54d8becfda09e7285f6f7e86a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*--6HnDdgXsvw1yvM"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="kb kc kd ke gt jo gh gi paragraph-image"><div class="gh gi ka"><img src="../Images/a5006a39b3c7d6c7ac51c275cc7880b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*NdruJQ6y4bNiGBCC7ysrrA.jpeg"/></div></figure><p id="0bd6" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">在本文中，我们将研究Node.js如何使用其非常流行的异步和并发模型来处理服务器端的操作。</p><p id="8346" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">I/O操作意味着计算机CPU中的单个进程与该CPU之外的任何事物之间的通信。它可以是内存、磁盘、网络，甚至是进程。信号在这种通信中被共享。计算机执行的大多数操作都是I/O操作。在服务器端环境中，I/O操作引用磁盘和网络资源访问，这与其他操作相比相对较慢。</p><p id="f47b" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">有许多方法可以处理这些I/O操作。我们可以同步执行，但这是低效的，因为一个操作依赖于另一个操作的执行。我们可以从操作系统派生一个新的进程来处理每个请求，但是在大量请求的场景中，很难执行。还有另一种方法，那就是<strong class="kh io">线程</strong>，这被认为是一种很好的方法，但当线程访问共享资源时，这就变得很令人头疼。</p><p id="674e" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">Node和JavaScript是单线程的。这意味着他们一次只能处理一项任务。但这并不会在运行缓慢的情况下带来更好的性能。Node使用三种技术:非阻塞I/O、事件和异步API来处理慢速I/O操作，而不会阻塞主执行运行时。</p><p id="2c91" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated"><strong class="kh io">非阻塞输入/输出</strong></p><p id="4695" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">这意味着程序可以在做其他事情的同时请求网络资源，然后，当网络操作完成时，将运行一个回调来处理结果。Node使用一个名为libuv的库来提供对非阻塞网络调用的访问。</p><blockquote class="ld le lf"><p id="e3bf" class="kf kg lg kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc ig bi translated">尽管节点应用程序是单线程的，但它有助于借助事件循环和异步API实现非阻塞I/O。</p></blockquote><p id="ede7" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">Node由谷歌Chrome V8 JavaScript引擎提供支持。它将javaScript代码编译成机器代码，并处理JavaScript代码的解释和运行。正如我已经说过的，处理I/O操作的节点libuv在C++绑定层的帮助下与V8引擎一起使用。</p><p id="1933" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated"><strong class="kh io">事件循环</strong></p><p id="f677" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">V8引擎有堆和堆栈内存。堆存储对象和函数。堆栈执行函数。堆和堆栈不属于节点。Node拥有定时器、包装器、操作系统操作发射器等API。节点还提供事件循环和事件队列(回调队列)。</p><p id="d55d" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">V8 JavaScript引擎回调栈通过跟踪当前运行的所有函数来跟踪程序的执行。我们知道堆栈是一种数据结构，后进先出(LIFO)操作在其中发生。Javascript是单线程的。它只有一个堆栈，一次只能做一件事。当堆栈执行一个函数时，在这个线程中不会发生任何事情。当多个函数相互调用时，它们将形成一个堆栈。那么功能将按照后进先出原则执行。这个回调栈的执行从一个匿名函数开始，这个函数首先被推入栈中。我们也可以把这个叫做main()。</p><p id="df53" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">事件循环是在事件队列(回调队列)和回调堆栈之间运行的循环。它从事件队列中提取事件，并将它们的回调推到调用堆栈中。但是当回调堆栈中至少有一个函数时，事件循环将不会执行它的操作。它将一直等待，直到V3引擎中的回调堆栈中不再有要执行的函数。由于队列数据结构是先进先出(FIFO)，在事件队列中，我们首先排队的事件将首先出队。当Node将事件出队时，与之相关的函数将被调用并将其推送到堆栈中。那么回调栈将执行它的操作。</p><p id="78a5" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated"><strong class="kh io">异步API </strong></p><p id="bb3a" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">那么，节点API在哪里发挥作用呢？当执行setTimeout、setInterval等异步函数时，V8引擎没有任何实现。相反，Node使用C++实现。因此，当这些函数被调用时，它们将被事件队列中的事件注册。当事件队列中的事件被执行时，回调将被推到V8引擎的堆栈中。</p><p id="869d" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">我们可以通过下面的例子来理解上面讨论的事情:</p><figure class="kb kc kd ke gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/7bc929710e0ebced4ac442391395bb4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EDSpuM6Uylmg2q7N1vvIQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example code snippet</figcaption></figure><p id="f00f" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">当我们查看这段代码时，输出将是:</p><figure class="kb kc kd ke gt jo gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/d25101395d469341aa6d435158b49c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*uK9YMOqD2Jwtq48SyigVFQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Output of the above example code snippet</figcaption></figure><p id="eb2a" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">从下图可以了解代码执行在Node中是如何工作的。</p><figure class="kb kc kd ke gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/d16579856a895cef7122b6a3b52fdd6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rw_122YeucqQwas9t6H6zw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Execution flow of code</figcaption></figure><p id="3bd9" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">当代码开始执行时，main()推入调用堆栈，控制台函数推入调用堆栈。“测试”登录到控制台。</p><p id="e4d3" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">在此之后，控制台功能将会弹出。然后，将getFits()推入堆栈，然后将控制台函数推入堆栈，并将“第一个进入队列”登录到控制台。</p><p id="da19" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">在此之后，控制台函数和getFirst()将从堆栈中弹出。</p><p id="bfed" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">调用getNext()并将其推入堆栈，然后调用setTimeout函数。这是一个不被Javascript处理的异步函数，它将被发送到节点API。节点API对此保持五秒钟，并将回调发送到消息队列。</p><p id="4ba1" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">在这发生的同时，最终的控制台函数将被执行，被推送到堆栈，然后“寻找下一个人”被登录到控制台并弹出。</p><p id="11fb" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">现在在调用堆栈中，只有main()会在那里，它也会弹出。现在调用堆栈是空的。因此，消息队列中的回调将被推入调用堆栈，并且“5秒钟后接收第二个人”将被记录到控制台。</p><p id="67f2" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">希望您对Node.js异步和并发模型有所了解。我的下一篇文章再见！</p><p id="15a6" class="pw-post-body-paragraph kf kg in kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated"><em class="lg">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lg">plain English . io</em></a></p></div></div>    
</body>
</html>