<html>
<head>
<title>Building a Range Slider with SVGs in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SVG以角度构建范围滑块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-range-slider-with-svgs-in-angular-f67fde71d161?source=collection_archive---------3-----------------------#2021-01-24">https://javascript.plainenglish.io/building-a-range-slider-with-svgs-in-angular-f67fde71d161?source=collection_archive---------3-----------------------#2021-01-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e74f364186251c1168955ecb9d4a78ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wo3UJdtdNZOoj1ScKXiYDA.jpeg"/></div></div></figure><p id="e9dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">又是在办公室的一天，我被困在一个任务上，我们的客户要求一个特定的功能(一个范围滑块)。</p><blockquote class="kt ku kv"><p id="4a0d" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">"它必须有过多的特定选项和定制."顾客问道。</p></blockquote><p id="d426" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在旧版本的应用程序中，这似乎是由古时候的开发人员使用的库来处理的，但是现在不再支持了。这也会带来更多的痛苦而不是快乐。所以我转向研究，花一些时间试图理解我们如何扩展一个通用的范围滑块。在花了几个小时翻阅不同的文章和书籍后，我偶然发现了一种方法，其中<strong class="jx io"> SVGs </strong>将在浏览器<strong class="jx io"> DOM </strong>中呈现，以创建<strong class="jx io">定制元素</strong>。增强我发现的带有浏览器事件的蓝图，你能够控制这些元素的每一个方面。</p><blockquote class="la"><p id="29f4" class="lb lc in bd ld le lf lg lh li lj ks dk translated">TLDR:你可以在这里找到最终解决方案<a class="ae lk" href="https://github.com/marrej/svg-slider" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><p id="09ad" class="pw-post-body-paragraph jv jw in jx b jy ll ka kb kc lm ke kf kg ln ki kj kk lo km kn ko lp kq kr ks ig bi translated">现在，让我通过构建我们自己的范围滑块来分享我收集的知识，在这里，我们将经历基本的SVG操作，然后使用浏览器事件处理创建的元素。</p><blockquote class="kt ku kv"><p id="4058" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">浏览器中的SVG是什么，我们如何渲染它们？</p></blockquote><p id="1ad5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看一下<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/SVG" rel="noopener ugc nofollow" target="_blank"> MDN </a> docs，你会发现有很多你可以渲染的元素。</p><p id="2534" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一切都从一个简单的<strong class="jx io"> &lt; SVG &gt; </strong>标签开始。我们应该定义一个高度和宽度(你可以像在示例代码中那样内联定义，或者你也可以把它放在你的CSS文件的类中，并用指定的类标记SVG。这会使溶液更干净；) )</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c762" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个SVG标签中，我们可以放入任何我们想要的元素，但是让我们从一个普通的元素开始，比如一个矩形。像前面一样，定义宽度、高度、填充<br/>(用于填充矩形的颜色)、rx(也称为border-radius)和y(垂直偏移，从顶部开始)。<br/>但是不要误以为所有这些属性都可以插入CSS中，因为有些是SVG属性，在文件中不会被识别。<strong class="jx io"> Chrome </strong>作为浏览器对它还是挺仁慈的，但是其他浏览器比如<strong class="jx io"> Mozzila </strong>就不喜欢；)</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0dec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在它上面添加了另一个矩形，这样它可以显示选择。这一个将有一个预定义的宽度200px，它将在稍后被绑定到组件中的一个变量。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="e8b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们添加我们的<strong class="jx io">拇指</strong> ( <strong class="jx io">指针</strong>、<strong class="jx io">选择器、</strong>或任何其他你想叫它的方式)，我们将<strong class="jx io">拖动</strong>来设置<strong class="jx io">范围滑块</strong>的值。<br/>为了填充这个角色，我们将选择<strong class="jx io">椭圆</strong>。<br/>我们可以使用<strong class="jx io"> cx </strong>和<strong class="jx io"> cy </strong>设置<strong class="jx io"> x </strong>和<strong class="jx io"> y </strong>位置，使用<strong class="jx io"> rx </strong>和<strong class="jx io"> ry </strong>属性设置<strong class="jx io">宽度</strong>和<strong class="jx io">高度</strong>。如果我想让拇指稳稳地坐在彩色线的末端，我会选择<strong class="jx io"> 200px </strong>作为我对<strong class="jx io"> cx </strong>的输入。对于<strong class="jx io"> cy </strong>，我会选择<strong class="jx io"> 7.5 </strong>。</p><p id="1065" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为什么？</strong>因为要在线的中间，我必须考虑y偏移的5个点，5px线的中心是2.5，<strong class="jx io">所以7.5就是</strong>:)</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="fc0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为最后的收尾工作，我们可以在滑块上添加百分比标签。为此，我们需要使用<strong class="jx io"> &lt;文本&gt; </strong>标记。</p><p id="36cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是在我接触<strong class="jx io"> HTML </strong>之前，让我给<strong class="jx io"> component.ts，</strong>添加一个标签的<strong class="jx io">数组，然后我可以在<strong class="jx io"> HTML模板</strong>中迭代它。</strong></p><p id="8de8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我可以使用Angular magic为使用<strong class="jx io">NGF生成文本标签。我将使用来自<strong class="jx io"> ngFor，</strong>的索引来获取文本元素的x位置。</strong></p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="65ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，我还在文本中添加了一些<strong class="jx io">样式</strong>。<br/>这些确保文本的<strong class="jx io">锚在<strong class="jx io">中心</strong>而不是在左边缘。</strong></p><blockquote class="kt ku kv"><p id="17fb" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">为了设置X位置，我使用了[]括号，但是我还需要将<strong class="jx io">属性</strong>作为前缀，以便能够操作<strong class="jx io"> SVG属性</strong>。</p></blockquote><p id="44a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我插入我的自定义函数，它将获得标签的位置。</p><blockquote class="kt ku kv"><p id="e8a8" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">(我用i + 1划分宽度，因为我想让宽度被<strong class="jx io">3</strong>3<strong class="jx io">标签</strong>分成<strong class="jx io"> 4段</strong>。然后我将它乘以i + 1，因为我希望第一个标签偏移段宽度)。</p></blockquote><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="745f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我现在不得不添加一个模拟宽度，因为我们没有真正的屏幕宽度，但我们将在一秒钟内到达。</p><p id="aac4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们得到组件的实际宽度，这样我们可以做一些适当的操作。我不太喜欢从组件内部查询元素的方法，但这确实符合它的目的，那就是为我们提供所请求的元素属性。</p><p id="e687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最好是利用<strong class="jx io">包装器的<strong class="jx io"> ID </strong>(不是<strong class="jx io">类</strong>)，或者SVG本身</strong>，因为它们在页面中必须是唯一的。您应该在初始化时为元素生成ID(ngOnInit)。<br/>可以利用<strong class="jx io"> this.constructor.name </strong>和<strong class="jx io"> lodash uniqueId() </strong>，生成唯一的<strong class="jx io">element id</strong>；).</p><p id="218a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦有了<strong class="jx io"> ID </strong>，就可以在函数中查询它，或者直接在<strong class="jx io"> ngOnInit </strong>中查询，然后将元素引用存储在本地属性中:)</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="1167" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以改变getLabelXPosition中的参数(<strong class="jx io"> width </strong>为<strong class="jx io"> getTotalWidth() </strong>)</p><p id="f73f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">瞧，我们应该看到标签在正确的位置。</p><p id="b805" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很好，我们已经建立了SVG的基础。<br/>现在尝试调整浏览器窗口的大小。你应该看到线条随着它的宽度而变化，但是拇指和填充的线条保持不变。如果你把窗口做得足够小，它们就会移出框架。</p><p id="41a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么我们能做些什么呢？</p><p id="ef78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所知，我们已经在填充线的<strong class="jx io">宽度和拇指</strong>的<strong class="jx io"> x位置中放置了一个<strong class="jx io">静态值</strong>，所以我们需要提供一个可以动态变化的值。所以让我们把现有的值换成函数<strong class="jx io">getline width()</strong>&amp;<strong class="jx io">getThumbPosition()</strong>。</strong></p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="eb49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于我们希望滑块从<strong class="jx io">0–100</strong>(因此标签为25、50、75)移动，我们可以只使用<strong class="jx io">0–1</strong>之间的值来确定拇指位置(滑块上的百分比位置)。之后，我们只需要将它乘以滑块的宽度，就可以得到实际的x位置。灌装线也是如此。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c705" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，我们有自我调整<strong class="jx io"> SVG </strong>似乎没有掉线，耶！:)</p><p id="0c42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以让我们增加一点互动性。</p><p id="7847" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用<strong class="jx io"> @HostListener </strong>注释来监听浏览器事件。特别是<strong class="jx io">鼠标按下</strong>，我们将用它作为<strong class="jx io">拖动</strong>以及<strong class="jx io">重新定位</strong>拇指的起点。<br/>我已经创建了一个公共函数<strong class="jx io"> updateThumbPosition() </strong>，我们稍后也可以将它用于触发运动的其他事件。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="9818" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，我们已经设置了一个布尔变量<strong class="jx io"> isDragStarted </strong>，稍后我们将使用它来确定用户是否在拖动。</p><blockquote class="kt ku kv"><p id="f2e6" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">你可能会问为什么？</p></blockquote><p id="793a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们将监听<strong class="jx io">鼠标移动</strong>，每当鼠标移动到<strong class="jx io"> SVG上时，该事件就会被触发。</strong> <br/>但是你可以想象，我们希望它只在用户点击<strong class="jx io">时被触发。</strong></p><p id="e2b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们将3个缺少的事件添加到<strong class="jx io">中，允许拇指可拖动</strong>，而不仅仅是<strong class="jx io">可点击</strong> ( <strong class="jx io"> mousemove、mouseup、mouseleave </strong>)。</p><p id="532a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Mousemove </strong>，将处理<strong class="jx io">拖动</strong>，但是就像我之前说的，它在任何鼠标在<strong class="jx io"> SVG </strong>上移动时被触发，所以它需要被修补。因此，只有当用户已经点击了鼠标(<strong class="jx io"> mousedown </strong>)时，我们才会触发拇指位置的更新。<br/>事件<strong class="jx io"> mouseup </strong>和<strong class="jx io"> mouseleave </strong>将<strong class="jx io">成为我们拖拽</strong>的结束者。所以每当用户释放鼠标按钮，或者简单地离开SVG区域，<strong class="jx io">我们将释放拖拽</strong>。</p><p id="da13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还需要<strong class="jx io">阻止<strong class="jx io"> mousemove事件</strong>的默认</strong>并停止传播，因为当你拖动滑块时，你可以选择标签，这将影响拖动。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="5fec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有一件事。</p><p id="ebd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像我一开始说的，你需要处理所有可能发生的行为和副作用。因此，在这里再添加一个事件侦听器可能是值得的，我们可以禁用它。<br/><strong class="jx io">拖动启动</strong>也可能<strong class="jx io">导致不必要的行为</strong>，通过阻止它，我们可以消除可能的问题(比如用拇指拖动标签……)</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><blockquote class="la"><p id="003a" class="lb lc in bd ld le lw lx ly lz ma ks dk translated">很好，所以我们有了一个全功能的SVG滑块。</p></blockquote><p id="b194" class="pw-post-body-paragraph jv jw in jx b jy ll ka kb kc lm ke kf kg ln ki kj kk lo km kn ko lp kq kr ks ig bi translated">我为我们感到骄傲！当然，我们遗漏了一个关键的东西。</p><p id="f718" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">移动支持！</strong></p><p id="8516" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">怎么了？怎么会？</p><p id="2fdc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，你可以想象<strong class="jx io">鼠标点击只支持台式机</strong>，<strong class="jx io">在手机上我们需要实现‘触摸’事件</strong> ( <strong class="jx io">触摸开始，触摸移动，触摸结束</strong>)；)对我们来说<strong class="jx io"> touchmove </strong>应该涵盖所有移动和触摸的情况，因此这是我们唯一需要做的添加。无论如何，我想在这里再做一件事，那就是，用另一个div包装我们现有的代码，这将有一个40px的边缘。</p><p id="dc21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为什么？嗯，因为我想让你观察一件事。<br/>那么让我们应用代码更改，看一看。</strong></p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><blockquote class="kt ku kv"><p id="73f7" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">当您在浏览器中单击并拖动滑块时，它的行为是正确的，对吗？</p></blockquote><p id="4eda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是让我们打开<strong class="jx io">开发者工具</strong>，如果在<strong class="jx io"> chrome </strong>上工作，默认情况下应该会把你的鼠标换成<strong class="jx io">点击模拟器</strong>。</p><p id="dca3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在尝试点击并拖动滑块。</p><p id="c0b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意到什么奇怪的事了吗？是吗？它与你的触摸指针不对齐？</p><p id="4d80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这正是我想给你看的。<br/>现在想象一个场景，你想在应用程序中的任何地方使用这个组件，你试着点击滑块，但是拇指在任何地方跳动，但是你的手指却落在那里。</p><blockquote class="kt ku kv"><p id="74ed" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">这不是我们想要的行为。那么我们可以用这个做什么呢？</p></blockquote><p id="3427" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上，触摸的位置被元素偏移量所抵消。我们能做的是得到SVG元素的<strong class="jx io">左界，然后<strong class="jx io">从touch clientX </strong>中减去它。<br/>这样我们就能得到实际的触摸位置。但是在我们这样做之前，让我们稍微重构一下代码。</strong></p><p id="cb4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以<strong class="jx io">移除包装器div </strong>，并且<strong class="jx io">将id直接添加到SVG </strong>(那里并不真正需要div)。然后我们可以<strong class="jx io">将svgElement变量</strong>添加到组件中，我们<strong class="jx io">将在Init </strong>上初始化它，然后我们应该能够在应用程序中访问它。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8acd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们也可以在getTotalWidth函数中替换它(不再需要在这里查询元素)。</p><p id="e2a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，让我们使用<strong class="jx io">this . SVG element . getboundingclientrect()减去元素的左边界。左侧</strong>。</p><p id="9ac4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仅此而已。现在，当您尝试移动滑块时，它应该牢牢地定位在您的指针上，即使是点击:)</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><blockquote class="la"><p id="5330" class="lb lc in bd ld le lw lx ly lz ma ks dk translated">本文到此结束:)</p></blockquote><p id="f864" class="pw-post-body-paragraph jv jw in jx b jy ll ka kb kc lm ke kf kg ln ki kj kk lo km kn ko lp kq kr ks ig bi translated">我们仍然可以实现一些东西，比如绑定thumb(这样它就不会移出屏幕)，在<strong class="jx io"> mousemove、mousedown、touchmove事件</strong>之后添加输出事件，这样它们就可以被父元素捕获，等等…</p><p id="537e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果你真的需要的话，我会把这些都留给你去玩:)</p><p id="9017" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下次见！:)</p></div></div>    
</body>
</html>