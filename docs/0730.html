<html>
<head>
<title>How to Request from an API (Fetch, Async/Await)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从API请求(获取、异步/等待)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-dev-coding-problem-request-from-an-api-fetch-async-await-cab222657a68?source=collection_archive---------11-----------------------#2021-02-14">https://javascript.plainenglish.io/web-dev-coding-problem-request-from-an-api-fetch-async-await-cab222657a68?source=collection_archive---------11-----------------------#2021-02-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2507" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">经典的Web开发人员面试问题:情人节版</h2></div><h1 id="b679" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">提示</h1><p id="63f2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">用一张随机的猫图片和5个随机的单词制作一张情人节卡片。一个警告:仅当两个API都成功返回数据时才呈现内容。</p><p id="e506" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">随机猫图片API <br/>端点:<a class="ae lv" href="https://api.thecatapi.com/v1/images/search" rel="noopener ugc nofollow" target="_blank">https://api.thecatapi.com/v1/images/search</a>T11】文档:<a class="ae lv" href="https://docs.thecatapi.com/" rel="noopener ugc nofollow" target="_blank">https://docs.thecatapi.com/</a></p><p id="0fac" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">随机词生成器API <br/>端点:<a class="ae lv" href="https://random-word-api.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://random-word-api.herokuapp.com/</a><br/>文档:<a class="ae lv" href="https://random-word-api.herokuapp.com/home" rel="noopener ugc nofollow" target="_blank">https://random-word-api.herokuapp.com/home</a></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/4d2f3287d9e1f1504c0eac7b89c6ef46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1svP_6Mg7ydLZ_9R3UqbSw.png"/></div></div></figure><h2 id="91aa" class="mi kd in bd ke mj mk dn ki ml mm dp km ld mn mo ko lh mp mq kq ll mr ms ks mt bi translated">基本HTML:</h2><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="c72f" class="mi kd in mv b gy mz na l nb nc">&lt;div id="card"&gt;<br/>  &lt;div id="image-wrapper"&gt;&lt;/div&gt;<br/>  &lt;div id="text-wrapper"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="362c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在你向下滚动看到我的解决方案之前，我建议你试一试！</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="066a" class="kc kd in bd ke kf nk kh ki kj nl kl km jt nm ju ko jw nn jx kq jz no ka ks kt bi translated">解决方案1。使用获取</h1><p id="db0e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">因为我们只想在两个API都返回数据的情况下呈现内容，所以我决定将两个GET请求一个接一个地链接起来，因为如果第一个承诺(从cat API获取)被拒绝(网络问题、无效的JSON等)，<code class="fe np nq nr mv b">.catch</code>将运行，而不会运行第二个GET请求或任何其他承诺<code class="fe np nq nr mv b">.then</code>处理程序。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="bb49" class="mi kd in bd ke mj mk dn ki ml mm dp km ld mn mo ko lh mp mq kq ll mr ms ks mt bi translated">解释:</h2><ul class=""><li id="4747" class="nu nv in kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">(第1-2行)将长端点字符串设置为易于阅读的常量变量。</li><li id="ed15" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">(第4–7行)<code class="fe np nq nr mv b">function checkStatus</code>检查请求的响应——如果不是则抛出一个错误<code class="fe np nq nr mv b">ok</code>(布尔值表示请求响应是否成功)并拒绝承诺。解析承诺，否则返回转换为JSON对象的响应。</li><li id="2170" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">(第9–14行和第16–21行)两个箭头函数，它们的唯一目的是呈现图像/文本。</li><li id="4552" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">(第23-35行)事情开始发生的地方。</li><li id="da30" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">(第23行)首先，向随机cat image API端点发出GET请求，或者用其他术语“获取”响应。接下来，每次给<code class="fe np nq nr mv b">.then</code>或<code class="fe np nq nr mv b">.catch</code>打电话都会产生一个新的承诺，这个新的承诺与之前的承诺联系在一起。<code class="fe np nq nr mv b">.then</code> promise处理程序在承诺被解析之前运行，并将前一个承诺的返回值作为参数。<code class="fe np nq nr mv b">.catch</code> promise处理程序仅在获取出错时运行，但不会检查网络错误。(见下一条如何处理该问题)。)</li><li id="f1b7" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">(第24行)如果一个解决的承诺从获取中返回，下一步是检查响应的状态是否成功(参见第4–7行)。还有，如果你不知道，这一行是写<code class="fe np nq nr mv b">.then(res =&gt; checkStatus(res))</code>的简写方式。</li><li id="3c49" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">(第25–34行)如果第24行的承诺得到了解析，那么下一个<code class="fe np nq nr mv b">.then</code>将猫图像url设置为一个常量变量，以便于阅读。然后，向随机单词API发出第二个GET请求。再次检查它的状态，如果请求状态显示成功，那么将图像文本追加到DOM。</li></ul><p id="39a5" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在下一节中，使用async/await的相同解决方案。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="93bf" class="kc kd in bd ke kf nk kh ki kj nl kl km jt nm ju ko jw nn jx kq jz no ka ks kt bi translated">解决方案2。使用异步/等待</h1><p id="8330" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们可以使用async/await重写它，而不是像前面的解决方案那样使用承诺链。这实现了相同的结果，但是格式更清晰，可读性更好(跳到第23–40行)。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">Only difference are lines 23–40.</figcaption></figure></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="e662" class="kc kd in bd ke kf nk kh ki kj nl kl km jt nm ju ko jw nn jx kq jz no ka ks kt bi translated">结论</h1><p id="8179" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">所以<code class="fe np nq nr mv b">fetch</code>和<code class="fe np nq nr mv b">.then</code> / <code class="fe np nq nr mv b">.catch</code>确实有用，但我个人认为利用<code class="fe np nq nr mv b">async</code> / <code class="fe np nq nr mv b">await</code>可以更清晰地阅读代码。检查运行中的代码:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="om nt l"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">Happy Valentine’s Day!</figcaption></figure></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h2 id="72b7" class="mi kd in bd ke mj mk dn ki ml mm dp km ld mn mo ko lh mp mq kq ll mr ms ks mt bi translated">资源</h2><div class="on oo gp gr op oq"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd io gy z fp ov fr fs ow fu fw im bi translated">使用获取</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">Fetch API提供了一个JavaScript接口，用于访问和操作HTTP管道的各个部分，例如…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">developer.mozilla.org</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe mg oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://www.digitalocean.com/community/tutorials/how-to-use-the-javascript-fetch-api-to-get-data" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd io gy z fp ov fr fs ow fu fw im bi translated">如何使用JavaScript Fetch API获取数据| DigitalOcean</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">曾经有一段时间，XMLHttpRequest用于发出API请求。它不包括承诺，也没有…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">www.digitalocean.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe mg oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://javascript.info/async-await" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd io gy z fp ov fr fs ow fu fw im bi translated">异步/等待</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">有一种特殊的语法以更舒适的方式处理承诺，称为“async/await”。令人惊讶的是…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">javascript.info</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe mg oq"/></div></div></a></div></div></div>    
</body>
</html>