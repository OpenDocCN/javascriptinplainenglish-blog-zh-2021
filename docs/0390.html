<html>
<head>
<title>Understanding Redux Concepts Through Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现理解Redux概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/redux-flux-the-bigger-picture-429410c0dbee?source=collection_archive---------6-----------------------#2021-01-23">https://javascript.plainenglish.io/redux-flux-the-bigger-picture-429410c0dbee?source=collection_archive---------6-----------------------#2021-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7214" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">还原/流动:更大的图景</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2fded4a10d2b0b9ff9a51ced0c9ff412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gZlRCgGqkGYT_86i"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@blizzard88?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Grant Durr</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e8a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近有点极端主义倾向。我的目标是:</p><ul class=""><li id="faa5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">不要使用外部图书馆。</li><li id="53c2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">不使用transpilation中间件(所以原生ES6，没有巴别塔，所有导入路径都是相对路径，放弃对旧浏览器的支持)</li><li id="f570" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">尽可能保持香草味。有了现代浏览器，你可以毫无障碍地编写现代JavaScript，所以新的“香草”是ES6+语法。</li></ul><p id="0530" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个过程让我找到了一些有趣的项目，包括<a class="ae kv" href="https://github.com/arlenner/olive" rel="noopener ugc nofollow" target="_blank"> Olive </a>，一个只有300多行代码的SPA框架，其中大部分是一个文件。该代码库的一部分是Redux的实现，我很高兴地说，它不仅功能不错，而且代码也很小。我想介绍一下创建这样一个组件以便在您自己的代码中使用的过程。我还将简要解释redux是什么，何时以及为什么使用它，以及如何使用中间件将您的代码分成纯代码和不纯代码。</p><h2 id="a4aa" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">Redux是什么？</h2><p id="168c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">Redux是一种叫做Flux的设计模式的实现。Flux是一种消息传递系统，最初是由脸书的人开发的，用于帮助管理他们复杂的应用程序状态。Redux本身是由一个叫丹·阿布拉莫夫的家伙建造的。它为他赢得了大量的曝光，成为国家管理的主要轻量级解决方案。通量设计模式是这样工作的:</p><ol class=""><li id="ffb8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ne ly lz ma bi translated">名为Store的组件保存应用程序的所有中央状态。它不能被修改，除了一个单独的特殊功能。您可以将状态视为通过另一个函数授予我们的副本。这样，如果不依靠一个叫做<em class="nf">减速器</em>的特殊逻辑，我们永远无法改变商店的状态。</li><li id="674e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">一个叫做Dispatcher的组件是可以改变存储状态的“特殊功能”。我们可以打电话<code class="fe ng nh ni nj b">dispatch</code>要求店家更改。因为存储的状态是完全不可变的，并且在每次成功修改时都会被替换，这将防止诸如陈旧数据和竞争条件之类的问题。</li><li id="ab78" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">我在第一节中提到的称为Reducer的组件处理应用程序状态更改的纯逻辑。当我说<em class="nf">纯</em>时，我指的是<em class="nf">功能纯</em>或<em class="nf">幂等</em>。这意味着你的减压器中的功能可能没有副作用。对于任何给定的输入，函数必须在每个场景中为该输入生成相同的输出。在我们的reducer的例子中，我们有一个称为Action的组件，我们接受它作为输入，这个Action给我们的reducer提供产生一个新状态所需的指令。reducer的产品是新状态本身，它将替换Store组件的旧状态。</li><li id="354e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">动作组件由两个关键部分组成:动作的<em class="nf">类型</em>和<em class="nf">有效载荷</em>。你的类型本质上是一个标识动作的键。有效载荷是与动作意图相关的一些数据或者没有数据。并非所有动作都需要有效负载。</li><li id="ce3e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">在Reducer产生一个新的状态(或者在无效的情况下不对状态做任何事情)之后，动作可以选择性地传递给一个单独的<em class="nf">中间件</em>函数。这个函数的目的是隔离代码的副作用部分，这样我们就可以将状态从副作用中分离出来。这个中间件可以可选地返回一个新的要被分派的动作。</li><li id="ef72" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">最后，我们依赖于某种前端接口，当与它交互时，它会将我们的动作发送到商店，启动整个连锁反应。</li></ol><p id="71af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这听起来可能很复杂，但是我将向您展示它是如何变得非常简单的。让我们从一段有点幼稚的代码开始，这段代码为我们提供了一个基本的存储工厂。</p><h2 id="e54b" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">建设商店</h2><p id="a60e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们定义商店的第一次尝试可能是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c7c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来不错。我们封装了一个默认状态<code class="fe ng nh ni nj b">model</code>，并把一个<code class="fe ng nh ni nj b">reducer</code>函数作为参数。我们通过不将内部的<code class="fe ng nh ni nj b">store</code>暴露在函数之外来使其成为‘私有的’。我们可以通过调用<code class="fe ng nh ni nj b">state</code>来获得进入商店的<em class="nf">视图</em>。<code class="fe ng nh ni nj b">state</code>只返回内部存储的副本。为了实际修改我们的内部函数<code class="fe ng nh ni nj b">store</code>，我们使用了<code class="fe ng nh ni nj b">dispatch</code>函数，我们在返回中公开了这个函数。我们将<code class="fe ng nh ni nj b">store</code>重新分配给<code class="fe ng nh ni nj b">reducer</code>的结果。我们只需要知道在这个时间点上，一个reducer接受我们的状态和动作的模型，并返回一个新的状态。有时，它有助于我看到写出的函数的签名，所以这里是Typescript符号中的缩减器:</p><pre class="kg kh ki kj gt nm nj nn no aw np bi"><span id="becb" class="mg mh iq nj b gy nq nr l ns nt">reducer: (state: State, action: [type: String, data?: any]) =&gt; State</span></pre><p id="7664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也暗示了我们将如何定义我们的行为。我们可以假设<code class="fe ng nh ni nj b">State</code>采用以下形式:</p><pre class="kg kh ki kj gt nm nj nn no aw np bi"><span id="84c4" class="mg mh iq nj b gy nq nr l ns nt">interface State {<br/> [k: string]: any<br/>}</span></pre><p id="dd4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以本质上任何普通的物体。如果您实际上使用的是Typescript，而我不是，那么您可以(也应该)利用编译器为您的应用程序定义您自己的状态类型。然而，这家商店有一些问题。</p><h2 id="fea1" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">传地址</h2><p id="ed93" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">目前，我们接受默认状态参数的对象。当我们将<code class="fe ng nh ni nj b">store</code>内部变量赋给<code class="fe ng nh ni nj b">model</code>参数时，我们实际上是通过引用将其赋给<em class="nf">。这意味着参数<code class="fe ng nh ni nj b">model</code>和私有变量<code class="fe ng nh ni nj b">store</code>实际上是内存中的同一个对象。那有什么问题呢？考虑这段虚构的代码:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用我们当前的实现，对<code class="fe ng nh ni nj b">DEFAULT_STATE</code>的引用实际上等于私有的<code class="fe ng nh ni nj b">store</code>变量。也就是说我们仍有机会从外面进入。另外，我们的代码很可能会出错，因为从技术上来说，我们试图在商店代码中重新分配一个<code class="fe ng nh ni nj b">const</code>。我们下一步可能会做这样的事情:</p><pre class="kg kh ki kj gt nm nj nn no aw np bi"><span id="7f9b" class="mg mh iq nj b gy nq nr l ns nt">let store = { ...model }</span></pre><p id="e6df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这似乎适用于简单的状态。但是，如果我们的状态中有嵌套对象，它将失败。对对象使用扩展语法只会产生浅层副本。为了真正获得我们的状态的副本，我们必须编写一个助手函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="93a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这个递归函数，现在我们可以处理任意数量的嵌套、数组、包含嵌套对象的数组等。它会全部复制。利用这一点，我们可以重构我们的<code class="fe ng nh ni nj b">tinyStore</code>,使其更加真实:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将拥有一个真正私有的内部<code class="fe ng nh ni nj b">store</code>变量，能够保存复杂的状态。我们的<code class="fe ng nh ni nj b">state</code>将返回一个定义了嵌套值的有意义的对象。</p><h2 id="6a61" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">一些基本用法</h2><p id="2f16" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在我上面虚构的代码片段中，敏锐的读者可能已经掌握了这种模式的一些使用细节。但是这里有一个从代码角度构建我们的商店的基本纲要:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="db14" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">更进一步</h2><p id="c26c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">flux/redux模式的要点是创建一个功能上纯粹的原子状态，或者一个<em class="nf">单一真实来源</em>。但是很大一部分应用依赖于副作用。副作用不纯。我们不知道他们做什么，他们可能什么也不返回，他们做了一些我们无法确定的事情或启动了一些我们无法确定的事情。副作用是所有bug的源头。但是副作用也是所有与我们的用户，外部服务器，随机数，任何返回承诺或任何返回未定义的交互的来源。副作用无处不在。我们能做的最好的事情就是给这混乱增加秩序。这就是中间件发挥作用的地方。让我们给我们的<code class="fe ng nh ni nj b">dispatch</code>函数添加几行代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8e38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在函数调用中添加了一个可选参数<code class="fe ng nh ni nj b">mw</code>。在dispatch中，在修改我们的状态之后，我们可以运行一个叫做中间件的功能。它的形式是:</p><pre class="kg kh ki kj gt nm nj nn no aw np bi"><span id="56a1" class="mg mh iq nj b gy nq nr l ns nt">mw: (model: State, action: Action) =&gt; Action | null</span></pre><p id="5b77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个动作被返回，我们递归地调度它。所以我们应该<em class="nf">永远不要返回动作本身</em>，否则我们将创建一个无限循环。这让我们可以做一些真正有趣的事情。我们有一套全新的模式可以利用。为了向您介绍副作用，让我们编写一个基本的拆分器。假设我们已经编写了在基本用法一节中编写的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="03ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们单击该按钮时，将会引发一系列新的事件:</p><ol class=""><li id="8585" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ne ly lz ma bi translated">事件将在调用我们商店的<code class="fe ng nh ni nj b">dispatch</code>函数的DOM中触发。</li><li id="a243" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">该动作将通过减速器传递。因为我们的减速器不处理<code class="fe ng nh ni nj b">TRY_MY_ACTION</code>类型的动作，所以模型不会改变。</li><li id="914d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">然后动作在效果循环中传递。我们的效果会将我们的“尝试”行为“分割”成两个结果行为之一——成功或失败。如果我的动作已经被调用，那么尝试将会失败，否则尝试将会成功。</li><li id="22a6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">效果返回的动作通过store的<code class="fe ng nh ni nj b">dispatch</code>函数放回。我们现在可以运行应用程序的纯结果部分—例如，登录失败将总是将状态设置为未登录。它可能还会显示一个登录页面。一次成功的登录会把你带到你的个人资料或者时间线或者你的应用程序的主视图</li></ol><p id="094d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到，像这样利用模式将允许您根据需要隔离应用程序的副作用部分。它将允许您控制混乱，允许有意义的调试消息、有组织的HTTP请求、数据库调用的隔离等等。</p><p id="6c67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来谈谈另一种效果模式，我称之为步进器。你采取了一系列复杂的行动，并隔离过程中的每一步:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="62ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，我们已经使用这种模式逐步完成了一个复杂的过程，在前端向用户提供了有意义的反馈。下面是一个可用的codepen示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nl l"/></div></figure><h2 id="00ec" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">好处</h2><p id="3273" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这就是我们如何用不到30行代码编写一个非常有特色的类似Redux的状态存储。我们可以应用这样的模式来组织任何应用程序。我们不需要用香草。我们可以使用React钩子来做同样的事情。如果您想使用React的减速器，请查看<code class="fe ng nh ni nj b">useReducer</code>挂钩。它几乎和我们在这里写的完全一样。Angular有一个名为<code class="fe ng nh ni nj b">ngrx</code>的包，它允许你使用redux类的存储和独立的副作用，就像我们的架构一样。知道如何有效地使用Redux将有助于您编写更有组织性和可重构的代码。我希望这能帮助我的读者理解状态管理的Flux/Redux模式背后的总体概念。</p><p id="baef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次见，FP上读者！</p></div></div>    
</body>
</html>