<html>
<head>
<title>How to Structure a Unit Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-structure-a-unit-test-9c87f287d1de?source=collection_archive---------4-----------------------#2021-09-04">https://javascript.plainenglish.io/how-to-structure-a-unit-test-9c87f287d1de?source=collection_archive---------4-----------------------#2021-09-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="205c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">编写单元测试的最佳实践</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/7f16597d8c2a421185519504494c5656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KyoS5q6zxy_9pbamjbn-A.jpeg"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk"><a class="ae ko" href="https://unsplash.com/photos/PP5nO5gcLdA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><h2 id="fa95" class="kp kq in bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">我不喜欢写测试。</h2><p id="676d" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt ky lu lv lw lc lx ly lz lg ma mb mc md ig bi translated">大部分开发人员也不喜欢，但是软件开发不是好恶的问题。它包括制造尽可能好的产品。这关系到很多东西——生意、金钱、名誉，在某些情况下，还有生命。</p><p id="0c86" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">据<a class="ae ko" href="https://fortegrp.com/the-importance-of-unit-testing/" rel="noopener ugc nofollow" target="_blank">复地集团</a>:</p><blockquote class="mj"><p id="7de1" class="mk ml in bd mm mn mo mp mq mr ms md dk translated">单元测试确保所有代码在部署之前都符合质量标准。这确保了质量至上的可靠工程环境。在产品开发生命周期的过程中，单元测试节省了时间和金钱，并帮助开发人员更高效地编写更好的代码。</p></blockquote><p id="ef4a" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt ky mv lv lw lc mw ly lz lg mx mb mc md ig bi translated">不可否认，一些开发人员做出了努力，但是他们最终写出了无结构的、难以辨认的和不可理解的测试。</p><p id="d975" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">在本文中，我们将看看使用<strong class="ln io"> Arrange-Act-Assert </strong>模式构建单元测试的适当方式。</p><p id="bcb1" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">语言和框架:JavaScript和Jest。</p><p id="2d9b" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated"><strong class="ln io"> <em class="my">什么是3A模式关于</em> : </strong></p><p id="8174" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">3A模式是一种常见的单元测试模式。它是一种安排和组织测试代码以使单元测试清晰易懂的方法，包括将每个单元测试功能分成三个部分:安排、动作和断言。</p><ul class=""><li id="5485" class="mz na in ln b lo me lr mf ky nb lc nc lg nd md ne nf ng nh bi translated"><strong class="ln io"> Arrange: </strong>这是初始化对象和设置要传递给被测函数的数据值的地方。如果我们打算使用模拟，这也是设置模拟的最佳位置。</li><li id="3411" class="mz na in ln b lo ni lr nj ky nk lc nl lg nm md ne nf ng nh bi translated"><strong class="ln io">Act:</strong>Act部分调用被测函数。</li><li id="b438" class="mz na in ln b lo ni lr nj ky nk lc nl lg nm md ne nf ng nh bi translated"><strong class="ln io">断言:</strong>这是验证被测函数的行为是否如预期的那样的地方。</li></ul><p id="4cd5" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated"><strong class="ln io"> <em class="my">空谈是廉价。给我看代码:</em> </strong></p><p id="2a27" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">让我们创建一个简单的函数，它接受两个参数—一个数字和一个数组，并根据数组中是否存在该数字返回一个布尔值:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8c81" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">我相信代码简单明了。在第一次函数调用时，<code class="fe np nq nr ns b">5</code>存在于数组中，因此，<code class="fe np nq nr ns b">true</code>被返回。在第二次调用时，<code class="fe np nq nr ns b">5</code>在数组中不存在，于是，<code class="fe np nq nr ns b">false</code>被返回。</p><p id="3dfa" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated"><strong class="ln io"> <em class="my">测试</em> </strong></p><p id="c4ba" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">请确保在运行测试命令之前从npm安装Jest。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="bc0c" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">使用<em class="my"> 3A </em>模式整齐地排列每个测试功能。在<em class="my">排列</em>部分，我创建了我需要的变量并给它们赋值。在<em class="my"> Act </em>部分，我调用了<code class="fe np nq nr ns b">isNumberInArray</code>，并将返回值赋给<code class="fe np nq nr ns b">value</code>。在<em class="my">断言</em>部分，我验证了<code class="fe np nq nr ns b">value</code>与我们分配给<code class="fe np nq nr ns b">expected</code>的值相同。当我们运行测试命令— <em class="my"> npm test </em>时，我们的测试通过。</p><h1 id="469b" class="nt kq in bd kr nu nv nw ku nx ny nz kx jt oa ju lb jw ob jx lf jz oc ka lj od bi translated">测试最佳实践</h1><p id="a0e5" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt ky lu lv lw lc lx ly lz lg ma mb mc md ig bi translated">Vasya Drobushkov 就这个话题写了一篇优秀的文章<strong class="ln io"> </strong>，所以我只是想指出一些我在他的文章中找不到的最佳实践。</p><ul class=""><li id="c7d1" class="mz na in ln b lo me lr mf ky nb lc nc lg nd md ne nf ng nh bi translated"><strong class="ln io">避免多个Arrange、Act和Assert部分:</strong>当一个测试函数包含多个由Assert分隔的Act部分，并且可能包含Arrange部分时，这样的测试就不能再称为单元测试了。</li></ul><p id="1cfd" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">例如:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="156a" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated">多个动作违背了单元测试的意图。重构包含多个动作和断言的测试。每一个动作都应该被提取出来进行测试。这样，您的测试将会快速、简单且易于理解。</p><ul class=""><li id="afdb" class="mz na in ln b lo me lr mf ky nb lc nc lg nd md ne nf ng nh bi translated"><strong class="ln io">避免if语句:</strong>一个单元测试应该简单易懂，但是当你使用<code class="fe np nq nr ns b">if</code>语句的时候，就表明你的测试一下子验证了很多东西。这样的测试应该分成几个测试。</li><li id="eef0" class="mz na in ln b lo ni lr nj ky nk lc nl lg nm md ne nf ng nh bi translated"><strong class="ln io"> Act部分不应该超过一行:</strong>如果Act部分超过一行，这表明您的代码或您可能调用的公共API的设计有问题。Act部分通常是单行代码。</li><li id="430f" class="mz na in ln b lo ni lr nj ky nk lc nl lg nm md ne nf ng nh bi translated">避免不可读的测试:人们不应该浪费时间试图弄清楚你的测试是做什么的。这就是3A模式派上用场的地方。3A模式使你的测试具有可读性和可理解性。</li><li id="30bd" class="mz na in ln b lo ni lr nj ky nk lc nl lg nm md ne nf ng nh bi translated">避免在测试中使用逻辑:在你的测试套件中使用逻辑会增加引入bug的机会，而你最不希望发现bug的地方就是你的测试套件。避免使用逻辑条件，如<code class="fe np nq nr ns b">for</code>、<code class="fe np nq nr ns b">if</code>、<code class="fe np nq nr ns b">while</code>和<code class="fe np nq nr ns b">switch</code>。</li><li id="2628" class="mz na in ln b lo ni lr nj ky nk lc nl lg nm md ne nf ng nh bi translated">避免魔术串:单元测试不应该包含魔术串。命名变量可以让测试的读者将注意力集中在测试上，而不是实现细节上。</li></ul></div><div class="ab cl og oh hr oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ig ih ii ij ik"><p id="5460" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated"><strong class="ln io">推荐内容</strong></p><div class="on oo gp gr op oq"><a href="https://betterprogramming.pub/unit-testing-best-practices-9bceeafe6edf" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd io gy z fp ov fr fs ow fu fw im bi translated">单元测试最佳实践</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">可以帮助您编写更好的测试的实用建议列表</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">better编程. pub</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ki oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://fortegrp.com/the-importance-of-unit-testing/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd io gy z fp ov fr fs ow fu fw im bi translated">更好的代码，更快:你应该使用单元测试的8个理由</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">一些开发人员低估了编写单元测试的重要性。以下是单元测试的五个好处…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">fortegrp.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe ki oq"/></div></div></a></div><p id="667d" class="pw-post-body-paragraph ll lm in ln b lo me jo lq lr mf jr lt ky mg lv lw lc mh ly lz lg mi mb mc md ig bi translated"><code class="fe np nq nr ns b">Chinedu Ikechi can be found on Twitter under the handle <a class="ae ko" href="https://twitter.com/Chinedu__Ikechi" rel="noopener ugc nofollow" target="_blank">@Chinedu__Ikechi</a>.</code></p></div></div>    
</body>
</html>