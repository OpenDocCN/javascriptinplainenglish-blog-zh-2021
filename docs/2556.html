<html>
<head>
<title>Migrating a 150K LOC codebase to Vite and ESBuild: is it worthwhile? (part 3/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将150K LOC代码库迁移到Vite和ESBuild:值得吗？(第三部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/migrating-a-150k-loc-codebase-to-vite-and-esbuild-is-it-worthwhile-part-3-3-5a12894bac96?source=collection_archive---------3-----------------------#2021-05-26">https://javascript.plainenglish.io/migrating-a-150k-loc-codebase-to-vite-and-esbuild-is-it-worthwhile-part-3-3-5a12894bac96?source=collection_archive---------3-----------------------#2021-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="473f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Webpack和Vite之间更公平的比较，一些Vite的警告，以及整体的开发者体验。</p><p id="fd38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是关于将React+TypeScript代码库从Webpack迁移到Vite的三篇文章系列的一部分。第1部分讲述了我们为什么决定迁移，<a class="ae ki" href="https://noriste.medium.com/migrating-a-150k-loc-codebase-to-vite-and-esbuild-how-part-2-3-91b0b873f388" rel="noopener">第2部分</a>讲述了我们是如何迁移的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/bcb10b44d9c861d20ffd53f0809f90b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1asz_EDOb6l3XN7Fux74BQ.png"/></div></div></figure><h1 id="5606" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">节食减肥</h1><p id="daf2" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">就像前面文章说的，Vite比Webpack快，但是做的事情少。在本系列的早些时候，我说过我们的定制Webpack配置利用了babel-loader、ts-loader和<a class="ae ki" href="https://github.com/TypeStrong/fork-ts-checker-webpack-plugin" rel="noopener ugc nofollow" target="_blank">fork-ts-checker-web pack-plugin</a>来编译TypeScript并同时运行ESLint。另一方面，ESBuild(Vite的核心)既不检查类型，也不运行ESLint。</p><p id="dc8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">不带TypeScript和ESLint的Webpack有多快？</strong>速度够快可以突出Vite吗？答案是否定的，但是越来越接近了。继续读下去。</p><h1 id="aaea" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Webpack ESBuild加载程序</h1><p id="7a3f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">现在我们的代码库已经可以进行ESBuild了，我们也可以通过Webpack来使用它。<a class="ae ki" href="https://github.com/privatenumber/esbuild-loader" rel="noopener ugc nofollow" target="_blank"> webpack-esbuild-loader </a>这就是解决方案(在Twitter 上的<a class="ae ki" href="https://twitter.com/VLecrubier/status/1375731336330248196?s=09" rel="noopener ugc nofollow" target="_blank">讨论中发现)。通过从Webpack中移除fork-ts-checker、TypeScript和ESLint负担，我们可以在Vite和Webpack之间进行更公平的比较。</a></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="7241" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这很有趣，结论是</p><ul class=""><li id="054a" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">我们可以通过ESBuild loader来提升Webpack。</li><li id="eff4" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">即使在这种情况下，Vite也更快。特别是，React快速刷新带来了巨大的不同。</li></ul><p id="44e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们对构建时间不太感兴趣(我们正在努力改进日常的DX)，但是为了完整起见，下面你可以找到构建的性能。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h1 id="2d31" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">维特的问题</h1><p id="d6fd" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我喜欢Vite，但我不妖魔化Webpack。我关心的是DX，而不是工具本身。这就是为什么我试图客观地报道我们在使用Vite时发现的问题:</p><ul class=""><li id="0ae7" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">保存后，Devtools的源代码面板会多次列出同一个文件。没什么大不了的，但是有时候选错了。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mo"><img src="../Images/76c6a61c40ff8ab12c408544a295a6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihPP0bN3AqShoDOG5qRWxA.jpeg"/></div></div></figure><ul class=""><li id="8e38" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">如果启用了缓存，在浏览器历史记录中来回移动会加载过时的文件。同时，禁用缓存会使Vite变慢。</li><li id="9543" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">Vite将工作负载从捆绑包转移到浏览器:与Webpack相比，Vite消耗一小部分RAM，但浏览器的工作将更加占用CPU。粉丝们作证。</li><li id="ec89" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">在很多热重装之后，你最好重装整个应用。</li><li id="3350" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">有一小部分文件我们不能通过Devtools断点，我们仍然需要理解为什么。</li><li id="2558" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">前端app的开发版明显比内置的慢。</li></ul><h1 id="b45d" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">到底:Vite还是Webpack？</h1><p id="6f5f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">答案来自使用最多的开发者:<strong class="jm io"> Vite </strong>！</p><p id="e660" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Vite的表现和流动性战胜了Webpack。整体DX好一个数量级，即使考虑以上问题。</p><p id="a471" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将在未来(或者，在最坏的情况下，当一个Webpack版本需要大量的前端操作工作时)删除每个Webpack依赖项、配置和所有脚本。</p><p id="390f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅此而已！我希望追踪我们的旅程对你也有帮助。欢迎发表评论，分享您的经验或提出更多改进建议。</p><h2 id="d48f" class="mp kw in bd kx mq mr dn lb ms mt dp lf jv mu mv lj jz mw mx ln kd my mz lr na bi translated">下一步是什么</h2><p id="d197" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我需要再次尝试<a class="ae ki" href="https://twitter.com/alexander_akait/status/1398031559723261952" rel="noopener ugc nofollow" target="_blank"> Webpack的文件系统缓存</a>。因为一个老问题，我们放弃了它，但是在此期间事情可能已经改变了。</p><p id="c5f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我还在我的<a class="ae ki" href="https://dev.to/noriste/speed-up-e2e-tests-for-vite-based-apps-3k4l" rel="noopener ugc nofollow" target="_blank">文章</a>中分享了如何通过启用Vite中的Rollup watch-mode来获得“旧”捆绑体验和新体验的最佳效果。</p><h1 id="86d9" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">后手稿</h1><p id="dd29" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">说到<strong class="jm io"> ESLint </strong>，我们在工作时不会再在手表模式下运行它了。这一决定背后的理由与Vite背后的动机相似:</p><ul class=""><li id="5f86" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">每次保存文件时，VSCode都会运行ESLint</li><li id="f7fe" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">通过lint暂存，暂存文件通过ESLint传递</li></ul><p id="bb09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">没有理由再让ESLint积极运行了。让我们也从Webpack中删除它。如果你在手表模式下运行ESLint，记得<a class="ae ki" href="https://twitter.com/NoriSte/status/1354445830523146248" rel="noopener ugc nofollow" target="_blank">打开它的缓存</a>。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="b5c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗨！我是斯特凡诺·马尼，我是一名充满激情的<strong class="jm io">前端工程师</strong>，一名<strong class="jm io">演讲者</strong>，一名<strong class="jm io">讲师</strong>。我作为高级前端工程师/团队领导为<a class="ae ki" href="https://www.workwave.com/" rel="noopener ugc nofollow" target="_blank">工作波</a>远程工作。</p><p id="7a12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢创造高质量的产品，测试和自动化一切，学习和分享我的知识，帮助别人，在会议上发言，面对新的挑战。</p><p id="017b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在<a class="ae ki" href="https://twitter.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ki" href="https://github.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae ki" href="https://www.linkedin.com/in/noriste/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。你可以找到我最近所有的投稿/演讲等。在<a class="ae ki" href="https://github.com/NoriSte/all-my-contributions" rel="noopener ugc nofollow" target="_blank">我的GitHub总结</a>。</p><p id="f815" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ni">更多内容请看</em><a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ni">plain English . io</em></a></p></div></div>    
</body>
</html>