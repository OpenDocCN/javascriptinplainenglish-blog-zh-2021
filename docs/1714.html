<html>
<head>
<title>How to build a GraphQL API backend with Express and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Express和MongoDB构建一个GraphQL API后端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/graphql-express-mongo-backend-d41625f728bf?source=collection_archive---------4-----------------------#2021-04-12">https://javascript.plainenglish.io/graphql-express-mongo-backend-d41625f728bf?source=collection_archive---------4-----------------------#2021-04-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cabd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快速设置、以客户端为中心的实时单一端点。听起来好得难以置信？在这个设置中，您将学习如何使用Node.js构建一个现代的可伸缩的GraphQL API后端，使用MongoDB作为数据库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0fed5d91092acb8bdc5b36902ed4644c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*miF1c7TflvGWQ95zpy8QLA.png"/></div></div></figure><h2 id="79dc" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">为什么选择GraphQL而不是Restful API？</h2><p id="5b1f" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated"><strong class="jm io"> 1。单一端点</strong></p><p id="4426" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有的数据查询和变异都是在单个端点上完成的，不像Restful APIs那样必须知道特定的端点才能获取数据。</p><p id="b9f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。修复了&amp;下的过度蚀刻</strong></p><p id="c51a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">GraphQL是一种查询语言，因此它针对检索指定的数据进行了优化，这与Rest APIss不同，Rest API检索的数据要么有额外的值(溢出)，要么没有所有的值，因此需要命中多个端点来检索全部数据(溢出)。</p><p id="1a26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。更快的开发(以客户端为中心的API) </strong></p><p id="9c92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">API是使用后端和前端开发人员共享的模式定义的，因此消除了API的模糊性。作为后端/前端开发人员，你会有相同的数据参考。</p><p id="90d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。汽车应用编程接口文档</strong></p><p id="0323" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦项目启动并运行，您就可以访问GraphQL Web界面——graph QL客户端(位于localhost:3000/graphql ),它包含了您可以对API执行的所有查询和变更的文档。</p><h2 id="4d3b" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">设置架构</h2><p id="fe63" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">在本文档中，我们将使用Express server作为后端服务器，使用MongoDB作为数据库来设置GraphQL后端。然后，我们将继续在产品实例上创建CRUD操作。</p><p id="f576" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是应用程序架构的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ls"><img src="../Images/1781c9d3d5fd130ca5543d62aebc15c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4wCVFlyCTYeI0LN42RTsw.png"/></div></div></figure><h2 id="2bca" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">步骤1-设置Express.js服务器</h2><p id="12fc" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们将使用<a class="ae lt" href="https://expressjs.com/en/starter/installing.html" rel="noopener ugc nofollow" target="_blank"> Express.js </a>作为后端服务器，使我们能够托管<a class="ae lt" href="https://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务器，并将其与<a class="ae lt" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>数据库集成。</p><p id="e3a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 1。初始化项目</strong></p><p id="557f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建一个项目文件夹，并将cd放入该文件夹以初始化节点包管理器(npm)。</p><p id="4eb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">先决条件:</strong></p><ul class=""><li id="5df5" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated">安装<a class="ae lt" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。</li></ul><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="5920" class="ku kv in me b gy mi mj l mk ml">npm init</span></pre><p id="135e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。安装Express.js </strong></p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="0fe2" class="ku kv in me b gy mi mj l mk ml">npm install express --save</span></pre><p id="e50b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。安装快速依赖关系:</strong></p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="bc4f" class="ku kv in me b gy mi mj l mk ml">npm install cors body-parser --save</span></pre><p id="d4ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。安装nodemon </strong></p><p id="abb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将有助于我们服务于快速应用程序并进行热重装。我们将把它安装为一个开发依赖项:</p><p id="788b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mm mn mo me b">npm install --save-dev nodemon</code></p><p id="91fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要添加<strong class="jm io">服务器运行</strong>脚本，通过添加以下行来更新您的<strong class="jm io"> package.json </strong>文件:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="b6e4" class="ku kv in me b gy mi mj l mk ml">"scripts": {<br/>    "serve": "nodemon ./app.js localhost 8080"<br/>},</span></pre><p id="d7d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 5。创建Hello world API测试应用程序</strong></p><p id="6e34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建您的应用程序入口文件<strong class="jm io"> app.js </strong>(在根文件夹中)，并粘贴以下内容:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="eb5e" class="ku kv in me b gy mi mj l mk ml">const express = require('express')<br/>const app = express()<br/>const port = 3000<br/><br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World!')<br/>})<br/><br/>app.listen(port, () =&gt; {<br/>  console.log(`Example app listening at http://localhost:${port}`)<br/>})</span></pre><p id="1fd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码是一个简单的hello world脚本，用于确保应用程序正在运行。您可以通过运行以下命令在<a class="ae lt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>访问响应:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="c697" class="ku kv in me b gy mi mj l mk ml">npm run serve</span></pre><h2 id="c1b5" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">步骤2 —设置MongoDB</h2><p id="f9c5" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">为了让数据库快速启动和运行，我们将使用一个docker容器映像，在您的本地磁盘上进行持久存储。</p><p id="9a79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">先决条件:</strong></p><ul class=""><li id="8016" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated"><a class="ae lt" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">已安装docker</a>。</li><li id="65f4" class="lu lv in jm b jn mp jr mq jv mr jz ms kd mt kh lz ma mb mc bi translated"><a class="ae lt" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">安装docker-compose</a>。这用于编排docker映像的构建和运行。</li></ul><p id="16ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 1。环境设置</strong></p><p id="1d04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了创建express和MongoDB都使用的环境设置，您将创建一个<strong class="jm io">。env </strong>文件并粘贴下面的细节(根据你的喜好编辑值):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="9a27" class="ku kv in me b gy mi mj l mk ml">MONGO_INITDB_ROOT_USERNAME=backend_admin</span><span id="0807" class="ku kv in me b gy mu mj l mk ml">MONGO_INITDB_ROOT_PASSWORD=password</span><span id="a86f" class="ku kv in me b gy mu mj l mk ml">MONGO_INITDB_DATABASE=ecommerce</span><span id="f3ef" class="ku kv in me b gy mu mj l mk ml">MONGO_DATABASE_HOST=localhost</span><span id="c03d" class="ku kv in me b gy mu mj l mk ml">MONGO_DATABASE_PORT=27017</span></pre><p id="a042" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装<strong class="jm io"> DotEnv </strong>以访问Node.js运行时中的环境变量(这将在express应用程序中用于访问环境变量)。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="a7b5" class="ku kv in me b gy mi mj l mk ml">npm install dotenv</span></pre><p id="2303" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。创建Mongo_init文件</strong></p><p id="0dde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一步中，我们将为Mongo Docker映像创建初始化脚本。创建一个<strong class="jm io"> mongo/docker </strong>文件夹，并在其中创建一个<strong class="jm io"> mongo_init.js </strong>文件；粘贴以下内容(<strong class="jm io">/mongo/docker/mongo _ init . js</strong>):</p><blockquote class="mv mw mx"><p id="b8ae" class="jk jl my jm b jn jo jp jq jr js jt ju mz jw jx jy na ka kb kc nb ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong> Mongo Docker映像提供了初始化脚本的规范，我们可以在其中指定为容器映像创建的数据库/用户/测试。</p></blockquote><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="8161" class="ku kv in me b gy mi mj l mk ml">db.createUser({<br/>    user: "backend_admin",<br/>    pwd: "password",<br/>    roles: [{<br/>        role: "root",<br/>        db: "admin"<br/>    }]<br/>});</span></pre><p id="92ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。创建docker-compose文件</strong></p><p id="7d5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们将在项目文件夹的根目录下创建一个<strong class="jm io"> docker-compose.yml </strong>(描述映像的规格并编排映像生命周期)文件，并将内容放在下面:</p><blockquote class="mv mw mx"><p id="507e" class="jk jl my jm b jn jo jp jq jr js jt ju mz jw jx jy na ka kb kc nb ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>我们使用先前在<strong class="jm io">中指定的环境变量。env </strong>文件。我们使用<strong class="jm io">/mongo/docker/mongo _ init . js</strong>文件中提供的初始化脚本为要创建的用户提供规范。</p></blockquote><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="3e1d" class="ku kv in me b gy mi mj l mk ml">version: "3.3" # specify docker-compose version</span><span id="bb17" class="ku kv in me b gy mu mj l mk ml"># Define the services/containers to be run</span><span id="8072" class="ku kv in me b gy mu mj l mk ml">services:<br/>  database: # name of service: database<br/>  image: mongo:4.0.3 # specify image to build container from<br/>  container_name: mean_mongo<br/>  restart: always<br/>  environment:<br/>    MONGO_INITDB_ROOT_USERNAME: ${MONGO_INITDB_ROOT_USERNAME}<br/>    MONGO_INITDB_ROOT_PASSWORD: ${MONGO_INITDB_ROOT_PASSWORD}<br/>    MONGO_INITDB_DATABASE: ${MONGO_INITDB_DATABASE}<br/>  volumes:<br/>    - ./mongo:/home/mongodb<br/>  # Copies the files from /docker folder containing cong to /docker-entrypoint-initdb.d/ where init scrips for conainer run.<br/>    - ./mongo.docker/:/docker-entrypoint-initdb.d/<br/>    - ./mongo/db:/data/db<br/>  ports:<br/>    - "${MONGO_DATABASE_PORT}:27017" # specify port forewarding</span></pre><p id="63ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。构建并运行MongoDB映像</strong></p><p id="7c1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要构建并运行容器映像，请运行下面的脚本:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="7b7f" class="ku kv in me b gy mi mj l mk ml">docker-compose -f "./docker-compose.yml" up -d --build</span></pre><p id="464f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要检查容器映像是否正在运行:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="9163" class="ku kv in me b gy mi mj l mk ml">docker ps</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/c572bcebec296ef77a969ee4bb22bdf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIE9QyWYT4UITfEvzq9hMA.jpeg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">You should see the docker image running</figcaption></figure><p id="0d6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要连接和可视化数据库，您可以使用免费的开源工具<a class="ae lt" href="https://www.mongodb.com/try/download/compass" rel="noopener ugc nofollow" target="_blank"> Mongo Compass </a>(使用您的。env文件)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/6927f3bea46229472bbf4041631e0a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gs6oCoTwK4AhTIPxyu_Epw.jpeg"/></div></div></figure><h2 id="c89f" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">步骤3 —设置GraphQL API服务</strong></h2><p id="b1ae" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们将在一个产品实例上实现<strong class="jm io"> CRUD </strong>。我们的API将能够使用GraphQL API使用Mongoose作为ODM(对象文档映射)从MongoDB创建、读取、更新和删除产品。</p><p id="8d8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 1。装猫鼬。<br/> </strong>首先，我们需要安装<a class="ae lt" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>，它将帮助我们定义数据库的<strong class="jm io"> chema </strong>，轻松地交互和操作数据库实例，并轻松地连接到MongoDB。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="b621" class="ku kv in me b gy mi mj l mk ml">npm i mongoose</span></pre><p id="b003" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。创建模式文件</strong></p><p id="268a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将创建一个模式文件。首先，在项目的根目录下创建一个<strong class="jm io"> models </strong>文件夹，然后创建一个<strong class="jm io">product . js</strong>(/models/product . js)文件。粘贴以下内容:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="994a" class="ku kv in me b gy mi mj l mk ml">const mongoose = require('mongoose');</span><span id="08bc" class="ku kv in me b gy mu mj l mk ml">const Schema = mongoose.Schema;</span><span id="73cd" class="ku kv in me b gy mu mj l mk ml">const productSchema = new Schema ({</span><span id="83ef" class="ku kv in me b gy mu mj l mk ml">name: {<br/>        type: String,<br/>        required: true,<br/>    },<br/>    description: {<br/>        type: String,<br/>        required: true,<br/>    },<br/>    price: {<br/>        type: Number,<br/>        min: [1],<br/>        required: true,<br/>    },<br/>    discount: {<br/>        type: Number,<br/>        min: [1],<br/>        required: false,<br/>    },<br/>    created_at: {type: Date, default: Date.now},<br/>     updated_at: {type: Date, default: Date.now()}</span><span id="64bf" class="ku kv in me b gy mu mj l mk ml">});</span><span id="1df6" class="ku kv in me b gy mu mj l mk ml">module.exports = mongoose.model('Product', productSchema);</span></pre><p id="dae8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。</strong> <a class="ae lt" href="https://graphql.org/graphql-js/running-an-express-graphql-server/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">安装GraphQL </strong> </a> <strong class="jm io">及其依赖:</strong></p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="1076" class="ku kv in me b gy mi mj l mk ml">npm install express-graphql graphql --save</span></pre><p id="e0d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。创建GrapQL解析器</strong></p><p id="ebea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">GraphQL使用解析器为应用程序定义<strong class="jm io">业务逻辑/ API逻辑</strong>。</p><p id="6457" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将首先创建一个产品解析器<strong class="jm io"> : </strong></p><p id="4e19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在项目的根文件夹中，创建一个<strong class="jm io"> GraphQL文件夹，</strong>并在其中创建一个<strong class="jm io"> resolvers.js </strong>文件(/graphql/resolvers.js)。在其中，粘贴以下代码:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="1e90" class="ku kv in me b gy mi mj l mk ml">const Product = require('../models/product');</span><span id="b025" class="ku kv in me b gy mu mj l mk ml">module.exports = {<br/>  createProduct: async function ({ productInput }) {<br/>    const product = new Product({<br/>      name: productInput.name,<br/>      description: productInput.description,<br/>      price: productInput.price,<br/>      discount: productInput.discount,<br/>    });</span><span id="7554" class="ku kv in me b gy mu mj l mk ml">    const createdProduct = await product.save();<br/>    return {<br/>      ...createdProduct._doc,<br/>      _id: createdProduct._id.toString(),<br/>    };<br/>  },<br/>}</span></pre><p id="6f02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。创建GrapQL模式</strong></p><p id="6436" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">GraphQL使用模式来定义API的数据格式和解析器的类型，以便在客户端请求查询/变异时运行。</p><p id="ce1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">创建:</strong>我们将继续为已创建的产品<strong class="jm io">创建一个<strong class="jm io"> </strong>模式。</strong></p><p id="fc5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在项目的根目录下创建一个GraphQL文件夹，添加一个<strong class="jm io"> schema.js </strong>文件(/graphql/schema.js)并粘贴以下内容:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="f67a" class="ku kv in me b gy mi mj l mk ml">const { buildSchema } = require('graphql');</span><span id="b5c4" class="ku kv in me b gy mu mj l mk ml">export default buildSchema(`<br/>    type Product{<br/>        _id:ID!<br/>        name: String!<br/>        description: StriWng!<br/>        price: Float!<br/>        discount: Int<br/>        created_at: String!<br/>        updated_at: String!<br/>    }</span><span id="65cf" class="ku kv in me b gy mu mj l mk ml">   input ProductInputData { <br/>       name: String!<br/>       description: String!<br/>       price: Float!<br/>       discount: Int<br/>    }</span><span id="d001" class="ku kv in me b gy mu mj l mk ml">    type RootMutation {<br/>       createProduct(productInput:ProductInputData): Product!<br/>    }</span><span id="5b15" class="ku kv in me b gy mu mj l mk ml">   schema {<br/>       mutation: RootMutation<br/>   }</span><span id="0ab2" class="ku kv in me b gy mu mj l mk ml">`);</span></pre><p id="6ac2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要阅读更多关于GraphQL模式定义的内容，请点击这个<a class="ae lt" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="bb5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 5。GraphQL CRUD操作</strong></p><p id="f328" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经完成了创建操作，我们将继续创建其他操作。</p><p id="8747" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">读取/查询:</strong>获取所有产品API。</p><p id="92c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了读取创建的所有产品，我们将首先创建查询解析器(在解析器文件中将其作为模块导出的一部分添加):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="20f9" class="ku kv in me b gy mi mj l mk ml">products: async function () {<br/>  const products = await Product.find();<br/>  return {<br/>    products: products.map((q) =&gt; {<br/>      return {<br/>        ...q._doc,<br/>        _id: q._id.toString(),<br/>      };<br/>    })<br/>  };<br/>},</span></pre><p id="fd66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在<strong class="jm io"> schema.js </strong>文件中，添加产品查询逻辑(作为buildSchema导出的一部分):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="0e36" class="ku kv in me b gy mi mj l mk ml">type ProductData {<br/>    products: [Product!]!<br/>}<br/>type RootQuery {<br/>    products: ProductData!<br/>}<br/>schema {<br/>    query: RootQuery<br/>    mutation: RootMutation<br/>}</span></pre><p id="04f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">更新:</strong>更新产品的实例。</p><p id="be99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将首先创建一个<strong class="jm io"> updateProduct </strong>解析器，然后在模式中注册它。在<strong class="jm io"> resolvers.js </strong>文件中添加以下代码(作为模块导出的一部分):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="e8e0" class="ku kv in me b gy mi mj l mk ml">updateProduct: async function ({ id, productInput }) {<br/>  const product = await Product.findById(id);<br/>  if (!product) {<br/>    throw new Error('Product Not found!');<br/>  }<br/>  <br/>  product.name = productInput.name;<br/>  product.description = productInput.description;<br/>  product.price = productInput.price;<br/>  product.discount = productInput.discount;</span><span id="a04b" class="ku kv in me b gy mu mj l mk ml">  const updatedProduct = await product.save();<br/>  return {<br/>    ...updatedProduct._doc,<br/>    _id: updatedProduct._id.toString(),<br/>  };<br/>},</span></pre><p id="f903" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> schema.js </strong>文件中，添加<strong class="jm io"> updateProduct </strong> resolver(它获取产品的ID，并使用请求中提供的值改变数据库中的值):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="47c9" class="ku kv in me b gy mi mj l mk ml">type RootMutation {<br/>    createProduct(productInput:ProductInputData): Product!<br/>    updateProduct(id: ID!, productInput:ProductInputData): Product!<br/>}</span></pre><p id="d770" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">删除:</strong>删除一个产品的实例。</p><p id="1dc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将创建一个<strong class="jm io"> deleteProduct </strong>解析器，然后在模式中注册它。在resolvers.js文件中添加以下代码(作为模块导出的一部分):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="1f08" class="ku kv in me b gy mi mj l mk ml">deleteProduct: async function ({ id, productInput }) {<br/>  const product = await Product.findById(id);<br/>  if (!product) {<br/>    throw new Error('Product Not found!');<br/>  }</span><span id="3358" class="ku kv in me b gy mu mj l mk ml">  await Product.findByIdAndRemove(id);<br/>  return {<br/>    ...product._doc,<br/>    id: product._id.toString(),<br/>  };<br/>},</span></pre><p id="1eb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> schema.js </strong>文件中，添加<strong class="jm io"> deleteProduct </strong> resolver(这将获取产品的ID并从MongoDB中删除实例):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="76a2" class="ku kv in me b gy mi mj l mk ml">type RootMutation {<br/>    createProduct(productInput:ProductInputData): Product!<br/>    updateProduct(id: ID!, productInput:ProductInputData): Product!<br/>    deleteProduct(id: ID!): Product!<br/>}</span></pre><p id="102f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终的<strong class="jm io"> resolvers.js文件</strong>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4729" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终的<strong class="jm io"> schema.js </strong>文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="cbc6" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">步骤4-设置Express服务器</h2><p id="e37c" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">最初，我们有一个简单的hello world应用程序。但是我们需要配置Express应用程序入口文件<strong class="jm io"> (app.js) </strong>，以便连接到MongoDB并服务于GraphQL服务器。</p><p id="c3de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将<strong class="jm io"> app.js </strong>文件更新为以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="e4e0" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">步骤5 —运行GraphQL API</h2><p id="a5cd" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">这是您现在可以运行GraphQL服务器的最后一步。</p><blockquote class="mv mw mx"><p id="9770" class="jk jl my jm b jn jo jp jq jr js jt ju mz jw jx jy na ka kb kc nb ke kf kg kh ig bi translated">注意:确保docker容器正在运行。</p></blockquote><p id="7a7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要运行服务器，请执行以下操作:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="e9c4" class="ku kv in me b gy mi mj l mk ml">npm run serve</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/4b012675ced0c9deace6483756de549e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VD51GUA82WkW3_GJhi7l6A.jpeg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">You should see the application serving at localhost:3000</figcaption></figure><p id="49a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您现在可以在<a class="ae lt" href="http://HTTP://localhost:3000/graphql" rel="noopener ugc nofollow" target="_blank">HTTP://localhost:3000/GraphQL</a>访问graph QL客户端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/34173e2f0fe4af8f7ed8b6f4f5320e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfXW_E-lIqdkYBEOy5TvOQ.jpeg"/></div></div></figure><h2 id="d9f4" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">第6步—运行查询和突变。</h2><p id="8ba8" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">在GraphQL控制台中，您可以运行这些查询和变异:</p><p id="1fac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 1。创建产品变异</strong>(在GraphQL客户端控制台中):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="5ba7" class="ku kv in me b gy mi mj l mk ml">mutation {<br/>  createProduct(productInput: { name: "Test Product 1",description: "Test Product",price: 7000.50,discount: 10}){<br/>    _id,<br/>    name,<br/>    description,<br/>    price,<br/>    discount,<br/>    created_at,<br/>    updated_at<br/>  }<br/>}</span></pre><p id="10fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。读取所有产品查询(在GraphQL客户端控制台中):</strong></p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="4860" class="ku kv in me b gy mi mj l mk ml">{<br/>  products{products{_id, description, price, discount,created_at,updated_at}}<br/>}</span></pre><p id="33bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。更新产品突变</strong>(在GraphQL客户端控制台中):</p><blockquote class="mv mw mx"><p id="4c3d" class="jk jl my jm b jn jo jp jq jr js jt ju mz jw jx jy na ka kb kc nb ke kf kg kh ig bi translated"><strong class="jm io">注</strong>:用自己创建的ID替换ID。</p></blockquote><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="eef7" class="ku kv in me b gy mi mj l mk ml">mutation {<br/>  updateProduct(id:"6054a67820f5c5716e99b657",productInput: { name: "Test Product 2",description: "Test Product",price: 7500.50,discount: 8}){<br/>      _id,<br/>      name,<br/>      description,<br/>      price,<br/>      discount,<br/>      created_at,<br/>      updated_at<br/>  }<br/>}</span></pre><p id="1a7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。删除产品突变</strong>(在GraphQL客户端控制台中):</p><blockquote class="mv mw mx"><p id="2c54" class="jk jl my jm b jn jo jp jq jr js jt ju mz jw jx jy na ka kb kc nb ke kf kg kh ig bi translated"><strong class="jm io">注意</strong> : —用你创建的ID替换它。</p></blockquote><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="81b9" class="ku kv in me b gy mi mj l mk ml">mutation {<br/>  deleteProduct(id:"6054a67820f5c5716e99b657"){<br/>      _id,<br/>      name,<br/>      description,<br/>      price,<br/>      discount,<br/>      created_at,<br/>      updated_at<br/>  }<br/>}</span></pre><p id="1a41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你喜欢并学到了新的东西！</p><p id="74e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> </strong>完整的项目可以在这里找到:</p><div class="nm nn gp gr no np"><a href="https://github.com/GeoffMahugu/apollo-backend" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">GeoffMahugu/阿波罗-后端</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">该文档将包含使用graphql服务设置简单NodeJS后端的设置指南。我们将会…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><p id="40a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="my">可以在</em><a class="ae lt" href="https://twitter.com/GeoffreyMahugu" rel="noopener ugc nofollow" target="_blank"><em class="my">@ GeoffreyMahugu</em></a><em class="my">关注我的推特。如果你有兴趣一起工作，给我发邮件到geoffreymahugu@gmail.com。</em></p><p id="573b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="my">更多内容请看</em><a class="ae lt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="my">plain English . io</em></a></p></div></div>    
</body>
</html>