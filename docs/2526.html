<html>
<head>
<title>WebSockets Tutorial: Creating a real-time WebSocket Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSockets教程:创建实时WebSocket服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/websockets-tutorial-creating-a-real-time-websocket-server-86508661b104?source=collection_archive---------13-----------------------#2021-05-24">https://javascript.plainenglish.io/websockets-tutorial-creating-a-real-time-websocket-server-86508661b104?source=collection_archive---------13-----------------------#2021-05-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d97ec4dc9e7e179b7227bdef65f6af1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mu_l23GsPIil3n0XJqw4g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://www.pexels.com/@skylar-kang?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Skylar Kang</a> from <a class="ae jz" href="https://www.pexels.com/photo/armchair-near-floor-lamp-in-empty-house-6044969/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="ce5f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们用JavaScript做的很多工作都涉及到从服务器来回发送信息。你可能熟悉API的<strong class="kc io">概念，</strong>以特定的格式向服务器或网站发送数据，以获得特定的响应。</p><p id="4e22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些被称为REST APIs。虽然有用，但它们不太擅长持续的数据流。如果你试图用REST APIs做一些实时的事情，你会有一段不好的时间。幸运的是，<strong class="kc io">如果我们想要与用户</strong>实时连接，我们有一个替代方案，称为<strong class="kc io"> WebSockets </strong>。</p><h1 id="c31d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">WebSockets如何工作</h1><p id="c57f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Websockets本质上是服务器和计算机之间的持续连接。当你访问一个网站时，它可以向服务器发送一个<code class="fe mb mc md me b">GET</code>请求，启动用户和服务器之间的WebSocket连接。</p><h1 id="7427" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">WebSockets vs REST API</h1><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/afddec3b28a1cdf78ac604b6807b873a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DymIWN0Y7Uf_-MHQ17ZaiA.png"/></div></div></figure><p id="ff15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果用户离开网站，连接就会被切断，因此只要用户继续使用网站，他们就只能访问WebSocket。</p><h1 id="a957" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">WebSocket可以保持开放多长时间？</h1><p id="bd51" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">一旦WebSocket被创建，理论上它可以永远保持开放。对此有一些例外:</p><ul class=""><li id="04f3" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated">服务器关闭——这将中断WebSocket，但是我们可以尝试重新连接它。</li><li id="f553" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">停电或互联网连接问题—如果用户的互联网中断，连接将会中断。</li><li id="7280" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">不活动—如果用户不通过WebSocket进行交互或发送数据，连接不可避免地会超时。</li></ul><p id="eac5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，当我们设计WebSockets时，我们需要考虑如果用户的连接由于某种原因停止，我们如何重新连接到它们，以便不中断用户的体验。</p><h1 id="dced" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">制作WebSocket</h1><p id="4cf0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">因此，WebSocket由两部分组成——服务器和用户使用的本地机器。对于我们正在做的事情，我们将使用Node.js作为我们的服务器，但是其他语言也支持WebSockets。</p><p id="cfa0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用户访问我们的网站时，我们加载一个带有JavaScript的文件，该文件包含一个到WebSocket的连接字符串。同时，在我们的后端，我们将设置用户将连接到的WebSocket。如下图所示:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0a5fd7d0be067d8173335d88466fb39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uIDFAexTUQ2uBIxT.png"/></div></div></figure><h1 id="14d3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤1:创建我们的服务器<a class="ae jz" href="https://fjolt.com/article/javascript-websockets#step-1:-creating-our-server" rel="noopener ugc nofollow" target="_blank"> # </a></h1><p id="ad20" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们首先为WebSocket连接创建Node.js web服务器。为此，我们将使用一个带有名为<code class="fe mb mc md me b">express-ws</code>的附加包的express服务器。这个额外的包将允许我们像使用<code class="fe mb mc md me b">get</code>一样使用<code class="fe mb mc md me b">ws</code>。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="10ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一个子句<code class="fe mb mc md me b">app.ws</code>，指的是WebSocket，这是我们将尝试在前端连接到的。目前，WebSocket only控制台记录一条消息，只要它从前端接收到一条消息。让我们改变它，让它发送一些东西回来:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7d2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，每当这个WebSocket连接接收到数据时，它都会发送回一个对象，我们已经在上面定义过了。然后，我们可以在前端操作这个对象，为用户显示或更改视图。</p><h1 id="6aa3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤2:在前端连接</h1><p id="eb96" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">正如我们之前提到的，当用户访问我们的网站时，我们在HTML文档中为他们提供一些本地JavaScript。我在index.html文件中为我们的演示添加了一些其他元素:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9e7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们需要在我们的<code class="fe mb mc md me b">local.js</code>文件中放入一些连接细节。我已经创建了一个连接文件，我们在文档加载后运行它。看起来是这样的:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8ce7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要连接到WebSocket，我们必须使用ws://，而不是HTTP，以及wss://，而不是HTTPS。我们将它放入我们的<code class="fe mb mc md me b">new WebSocket()</code>函数中来生成我们的连接。在我们的连接函数中，我们有三个事件监听器:</p><ul class=""><li id="e0b3" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated"><code class="fe mb mc md me b">socket.onopen</code> -如果连接成功并打开，将触发此操作。</li><li id="394f" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated"><code class="fe mb mc md me b">socket.onmessage</code> -每当服务器向我们发送信息时，就会触发。在我们的例子中，如果用户接收到将<code class="fe mb mc md me b">append</code>设置为<code class="fe mb mc md me b">true</code>的数据，我们将在用户的HTML中添加一个新元素。</li><li id="7098" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated"><code class="fe mb mc md me b">socket.onerror</code> -如果连接失败，或者发生错误，这将触发。</li></ul><p id="a2e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们把它们联系在一起——因为我们将套接字变量存储在全局范围内，所以我们可以在连接成功后发送数据。下面的事件监听器连接到WebSocket，然后在用户单击我们的HTML按钮时向服务器发送数据。</p><p id="a9c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当服务器接收到这些数据时，它会在服务器的message事件触发时发送回自己的数据。这返回给用户，然后用户向他们的文档添加一个新元素。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="c8ee" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="a981" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">就是这样！现在我们有了一个正常工作的WebSocket，它允许你向服务器发送数据，然后返回给用户。如果您想了解更多或下载源代码，这里有一些有用的链接:</p><ul class=""><li id="5cd6" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated"><a class="ae jz" href="https://github.com/smpnjn/express-websocket" rel="noopener ugc nofollow" target="_blank">通过Github下载代码</a></li><li id="a260" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated"><a class="ae jz" href="https://html.spec.whatwg.org/multipage/web-sockets.html" rel="noopener ugc nofollow" target="_blank">web socket规范</a></li></ul><p id="73a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="na">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="na">plain English . io</em></a></p></div></div>    
</body>
</html>