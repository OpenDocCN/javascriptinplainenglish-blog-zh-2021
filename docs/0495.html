<html>
<head>
<title>What is Cache Busting?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是缓存破坏？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-cache-busting-55366b3ac022?source=collection_archive---------3-----------------------#2021-01-30">https://javascript.plainenglish.io/what-is-cache-busting-55366b3ac022?source=collection_archive---------3-----------------------#2021-01-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7b73" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">缓存破坏是一种技术，使浏览器可以在文件上有长时间的缓存，同时在文件改变时重新加载文件</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1a5571574f9e98848e1449b96f07a87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEWzRXuH1KaPAgOVfegeug.png"/></div></div></figure><p id="674c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">缓存破坏是一种技术，使浏览器可以在文件上有长时间的缓存，同时在文件改变时重新加载文件。在你理解这一点之前，你必须理解网站的缓存是如何工作的。</p><h2 id="f5aa" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">缓存您的网站</h2><p id="b371" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">当你想让浏览器缓存文件，这样用户就不必每次访问你的网站时都重新加载，你就使用<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank"> HTTP缓存</a>。HTTP缓存允许您指定文件名的缓存时间，这样加载页面就非常快。现在让我们来研究一下这个问题。</p><h2 id="3d5c" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">缓存的问题是</h2><p id="5bf4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">假设您有一个包含3个文件的网站，<code class="fe mj mk ml mm b">index.html</code>、<code class="fe mj mk ml mm b">index.js</code>和<code class="fe mj mk ml mm b">index.css</code>，并且您将缓存生存期设置为1年，这样网站的加载速度会非常快。现在你可以改变<code class="fe mj mk ml mm b">index.css</code>，在你的应用程序中使用不同的配色方案。您的老用户不会注意到，因为他们必须等待一年才能刷新缓存。</p><p id="83da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就成了一个问题，尤其是在部署错误修复和安全补丁的时候。人们通常使用缓存破坏来解决这个问题，他们使用各种方法来更改每个版本加载的文件的名称，以便浏览器加载它们并将其添加到缓存中。</p><h2 id="c052" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">缓存破坏</h2><p id="00a1" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">有几种不同的方法可以改变文件名，这样当文件名改变时就可以加载了。一种方法是使用版本号，并在加载时将它们放在文件名中。每个版本都可以有一个子目录，<code class="fe mj mk ml mm b">v1/index.js</code> <code class="fe mj mk ml mm b">v2/index.css</code>。您也可以在URL、<code class="fe mj mk ml mm b">index.js?v1</code>、<code class="fe mj mk ml mm b">index.css?v2</code>中查询版本。</p><p id="ddf0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一种方法是改变文件名，<code class="fe mj mk ml mm b">index.v1.js</code>，<code class="fe mj mk ml mm b">index.v2.css</code>。这些方法并不容易管理，因为一旦有大量文件被更改，这将变得非常困难。</p><p id="56c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一种更受欢迎和更易于管理的方法是将散列保存在文件名中。如果你不知道，散列是任何内容的固定长度字符表示，并且它们是不可逆的，这意味着你可以从文件中获得散列，但是你不能从散列中获得文件。哈希对于这个来说是完美的，因为当文件改变时，它的哈希也会改变，所以如果我们将哈希保存在文件名<code class="fe mj mk ml mm b">index.[someHashHere].js</code>中，浏览器会检测到它并加载它，而不是一个旧文件。</p><p id="5260" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这甚至更好，因为它非常容易适应您的工作流程，您可以使用捆绑器对资源进行其他优化。</p><h2 id="4007" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">结论</h2><p id="a333" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在这篇文章中，我谈到了长时间缓存而不破坏缓存的问题，以及缓存破坏应用程序的不同方法。</p><p id="974b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">📚延伸阅读:<br/><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank">MDN上的HTTP缓存</a> <br/> <a class="ae mi" href="https://webpack.js.org/guides/caching/" rel="noopener ugc nofollow" target="_blank">用Webpack散列文件</a></p><p id="1d2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mn">如果你喜欢这篇文章，我建议你去我的博客</em>  <em class="mn">看看我的其他文章。</em></p></div></div>    
</body>
</html>