<html>
<head>
<title>5 Frontend Interview Questions To Help You Master Asynchronous JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助你掌握异步JavaScript的5个前端面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-frontend-interview-questions-to-help-you-master-asynchronous-javascript-3339d0f89fdc?source=collection_archive---------4-----------------------#2021-01-20">https://javascript.plainenglish.io/5-frontend-interview-questions-to-help-you-master-asynchronous-javascript-3339d0f89fdc?source=collection_archive---------4-----------------------#2021-01-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="10ab" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">问答，从初级到高级</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5e407ce4f49e6c4e5459125d565f1e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuABwsaULIX7bLh-_M12OQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">src: <a class="ae ks" href="https://ivanjov.com/do-you-promise/" rel="noopener ugc nofollow" target="_blank">https://ivanjov.com/do-you-promise/</a></figcaption></figure><p id="7c91" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">学习JavaScript时，最难理解的事情之一是<strong class="kv io">承诺</strong>。它们不容易理解，需要一些教程和大量的练习才能掌握。</p><p id="7b33" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天我们将为您准备<strong class="kv io">编码面试</strong>和<strong class="kv io">主承诺</strong>。</p><p id="b7c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在看到完整答案之前，请尝试回答以下问题:)</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="afef" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated"><em class="mo"> 1。这个回报是什么？</em></h1><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="24f4" class="mu lx in mq b gy mv mw l mx my">const <strong class="mq io">firstPromise</strong> = new Promise((res, rej) =&gt; {<br/>      setTimeout(res, 500, 'one');<br/>});<br/><br/>const <strong class="mq io">secondPromise</strong> = new Promise((res, rej) =&gt; {<br/>      setTimeout(res, 100, 'two');<br/>});<br/><br/><strong class="mq io">Promise.race</strong>([firstPromise, secondPromise]).then(res =&gt; console.log(res));</span></pre><ul class=""><li id="e9f7" class="mz na in kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated">答:<code class="fe ni nj nk mq b">"one"</code></li><li id="543f" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">乙:<code class="fe ni nj nk mq b">"two"</code></li><li id="6648" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">丙:<code class="fe ni nj nk mq b">"two" "one"</code></li><li id="6bfd" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">丁:<code class="fe ni nj nk mq b">"one" "two"</code></li></ul><h2 id="2e8a" class="mu lx in bd ly nq nr dn mc ns nt dp mg lc nu nv mi lg nw nx mk lk ny nz mm oa bi translated"><strong class="ak">回答</strong></h2><p id="29d9" class="pw-post-body-paragraph kt ku in kv b kw ob jo ky kz oc jr lb lc od le lf lg oe li lj lk of lm ln lo ig bi translated">当我们将多个承诺传递给<strong class="kv io"> Promise.race </strong>方法时，它解析/拒绝第一个解析/拒绝的承诺。对于<strong class="kv io"> setTimeout </strong>方法，我们传递一个定时器:第一个承诺(<strong class="kv io">first promise</strong>)500毫秒，第二个承诺(<strong class="kv io">second promise</strong>)100毫秒。这意味着<strong class="kv io">第二个承诺</strong>首先解析为<strong class="kv io">‘二’</strong>的值。<strong class="kv io"> res </strong>现在保存<strong class="kv io">‘two’</strong>的值，该值被记录。正确答案是<strong class="kv io"> B </strong>。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="9204" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">2.产量是多少？</h1><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="ace1" class="mu lx in mq b gy mv mw l mx my"><strong class="mq io">async</strong> function <strong class="mq io">getData</strong>() {<br/>      return await Promise.resolve('I made it!');<br/>}<br/><br/>const <strong class="mq io">data</strong> = getData();<br/>console.log(data);</span></pre><ul class=""><li id="c607" class="mz na in kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated">答:<code class="fe ni nj nk mq b">"I made it!"</code></li><li id="8a53" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">乙:<code class="fe ni nj nk mq b">Promise {&lt;resolved&gt;: "I made it!"}</code></li><li id="af78" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">丙:<code class="fe ni nj nk mq b">Promise {&lt;pending&gt;}</code></li><li id="ad3f" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">丁:<code class="fe ni nj nk mq b">undefined</code></li></ul><h2 id="e6cf" class="mu lx in bd ly nq nr dn mc ns nt dp mg lc nu nv mi lg nw nx mk lk ny nz mm oa bi translated"><strong class="ak">回答</strong></h2><p id="471c" class="pw-post-body-paragraph kt ku in kv b kw ob jo ky kz oc jr lb lc od le lf lg oe li lj lk of lm ln lo ig bi translated">异步函数总是返回一个承诺。<code class="fe ni nj nk mq b">await</code>仍然需要等待承诺的解析:当我们调用<code class="fe ni nj nk mq b">getData()</code>来设置<code class="fe ni nj nk mq b">data</code>等于它时，一个未决的承诺被返回。</p><p id="d8e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们想访问解析后的值<code class="fe ni nj nk mq b">"I made it"</code>，我们可以在<code class="fe ni nj nk mq b">data</code>上使用<code class="fe ni nj nk mq b">.then()</code>方法:</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="53e7" class="mu lx in mq b gy mv mw l mx my">data.then(res =&gt; console.log(res))</span></pre><p id="b349" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将被记录<code class="fe ni nj nk mq b">"I made it!"</code>。正确答案是<strong class="kv io"> C </strong>。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="7655" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">3.<em class="mo">输出值是多少？</em></h1><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="2475" class="mu lx in mq b gy mv mw l mx my">const <strong class="mq io">myPromise</strong> = () =&gt; Promise.resolve('I have resolved!');<br/><br/>function <strong class="mq io">firstFunction</strong>() {<br/>    myPromise().then(res =&gt; console.log(res));<br/>    console.log('second');<br/>}<br/><br/><strong class="mq io">async</strong> function <strong class="mq io">secondFunction</strong>() {<br/>    console.log(await myPromise());<br/>    console.log('second');<br/>}<br/><br/>firstFunction();<br/>secondFunction();</span></pre><ul class=""><li id="332f" class="mz na in kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated">答:<code class="fe ni nj nk mq b">I have resolved!</code>、<code class="fe ni nj nk mq b">second</code>、<em class="og">和</em>、<code class="fe ni nj nk mq b">I have resolved!</code>、<code class="fe ni nj nk mq b">second</code></li><li id="fbe0" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">b:<code class="fe ni nj nk mq b">second</code><code class="fe ni nj nk mq b">I have resolved!</code><em class="og"/><code class="fe ni nj nk mq b">second</code><code class="fe ni nj nk mq b">I have resolved!</code></li><li id="c355" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">C: <code class="fe ni nj nk mq b">I have resolved!</code>、<code class="fe ni nj nk mq b">second</code>、<em class="og">、</em>、<code class="fe ni nj nk mq b">second</code>、<code class="fe ni nj nk mq b">I have resolved!</code></li><li id="2c3f" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">D: <code class="fe ni nj nk mq b">second</code>、<code class="fe ni nj nk mq b">I have resolved!</code>、<code class="fe ni nj nk mq b">I have resolved!</code>、<code class="fe ni nj nk mq b">second</code></li></ul><h2 id="fd7d" class="mu lx in bd ly nq nr dn mc ns nt dp mg lc nu nv mi lg nw nx mk lk ny nz mm oa bi translated"><strong class="ak">答案</strong></h2><p id="d208" class="pw-post-body-paragraph kt ku in kv b kw ob jo ky kz oc jr lb lc od le lf lg oe li lj lk of lm ln lo ig bi translated">有了承诺，我们基本上会说<em class="og">我想执行这个函数，但它运行时我会暂时把它放在一边，因为这可能需要一段时间。只有当某个值被解析(或拒绝)并且调用堆栈为空时，我才希望使用该值。</em></p><p id="1181" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以通过<code class="fe ni nj nk mq b">.then</code>和<code class="fe ni nj nk mq b">async</code>函数中的<code class="fe ni nj nk mq b">await</code>关键字获得该值。虽然<code class="fe ni nj nk mq b">.then</code>和<code class="fe ni nj nk mq b">await</code>都能体现出承诺的价值，但二者的作用原理略有不同。</p><p id="294c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe ni nj nk mq b">firstFunction</code>中，我们(有点)把myPromise函数放在一边，同时它还在运行，但我们继续运行另一个代码，在这个例子中就是<code class="fe ni nj nk mq b">console.log('second')</code>。然后，该函数用字符串<code class="fe ni nj nk mq b">I have resolved</code>解析，当它看到调用堆栈为空时，就会记录该字符串。</p><p id="8d9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">利用<code class="fe ni nj nk mq b">secondFunction</code>中的wait关键字，我们实际上暂停异步函数的执行，直到该值被解析后再移动到下一行。</p><p id="09fb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着它等待<code class="fe ni nj nk mq b">myPromise</code>用值<code class="fe ni nj nk mq b">I have resolved</code>解析，只有发生一次，我们移动到下一行:<code class="fe ni nj nk mq b">second</code>被记录。正确答案为<strong class="kv io"> D </strong>。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="9659" class="mu lx in bd ly nq nr dn mc ns nt dp mg lc nu nv mi lg nw nx mk lk ny nz mm oa bi translated">4.<em class="mo">这会带来什么回报？</em></h2><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="8b89" class="mu lx in mq b gy mv mw l mx my">Promise.resolve(5);</span></pre><ul class=""><li id="9cca" class="mz na in kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated">答:<code class="fe ni nj nk mq b">5</code></li><li id="09e8" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">B: <code class="fe ni nj nk mq b">Promise {&lt;pending&gt;: 5}</code></li><li id="7f90" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">C: <code class="fe ni nj nk mq b">Promse {&lt;fulfilled&gt;: 5}</code></li><li id="4971" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">D: <code class="fe ni nj nk mq b">Error</code></li></ul><h2 id="3afc" class="mu lx in bd ly nq nr dn mc ns nt dp mg lc nu nv mi lg nw nx mk lk ny nz mm oa bi translated"><strong class="ak">回答</strong></h2><p id="7e76" class="pw-post-body-paragraph kt ku in kv b kw ob jo ky kz oc jr lb lc od le lf lg oe li lj lk of lm ln lo ig bi translated">我们可以向<code class="fe ni nj nk mq b">Promise.resolve</code>传递任何类型的值，可以是承诺值，也可以是非承诺值。该方法本身返回一个带有解析值的承诺(<code class="fe ni nj nk mq b">&lt;fulfilled&gt;</code>)。如果你传递一个正则函数，它将是一个有正则值的解析承诺。如果你传递了一个承诺，它将是一个解决了的承诺，并具有解决了的价值。</p><p id="c5f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，我们只是传递了数值<code class="fe ni nj nk mq b">5</code>。它返回一个解析的承诺，值为<code class="fe ni nj nk mq b">5</code>。正确答案是<strong class="kv io"> C </strong>。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="f009" class="mu lx in bd ly nq nr dn mc ns nt dp mg lc nu nv mi lg nw nx mk lk ny nz mm oa bi translated">5.产量是多少？</h2><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="3081" class="mu lx in mq b gy mv mw l mx my"><strong class="mq io">async</strong> function* <strong class="mq io">range</strong>(start, end) {<br/>      for (let i = start; i &lt;= end; i++) {<br/>            yield Promise.resolve(i);<br/>      }<br/>}<br/><br/>(<strong class="mq io">async</strong> () =&gt; {<br/>      const <strong class="mq io">gen</strong> = range(1, 3);<br/>      for <strong class="mq io">await</strong> (const item of gen) {<br/>            console.log(item);<br/>      }<br/>})();</span></pre><ul class=""><li id="9de3" class="mz na in kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated">答:<code class="fe ni nj nk mq b">Promise {1}</code> <code class="fe ni nj nk mq b">Promise {2}</code> <code class="fe ni nj nk mq b">Promise {3}</code></li><li id="df1c" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">B: <code class="fe ni nj nk mq b">Promise {&lt;pending&gt;}</code> <code class="fe ni nj nk mq b">Promise {&lt;pending&gt;}</code> <code class="fe ni nj nk mq b">Promise {&lt;pending&gt;}</code></li><li id="9c48" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">C: <code class="fe ni nj nk mq b">1</code> <code class="fe ni nj nk mq b">2</code> <code class="fe ni nj nk mq b">3</code></li><li id="1100" class="mz na in kv b kw nl kz nm lc nn lg no lk np lo ne nf ng nh bi translated">D: <code class="fe ni nj nk mq b">undefined</code> <code class="fe ni nj nk mq b">undefined</code> <code class="fe ni nj nk mq b">undefined</code></li></ul><h2 id="c9bd" class="mu lx in bd ly nq nr dn mc ns nt dp mg lc nu nv mi lg nw nx mk lk ny nz mm oa bi translated"><strong class="ak">回答</strong></h2><p id="b1f1" class="pw-post-body-paragraph kt ku in kv b kw ob jo ky kz oc jr lb lc od le lf lg oe li lj lk of lm ln lo ig bi translated">生成器函数<code class="fe ni nj nk mq b">range</code>为我们传递的范围内的每一项返回一个带有承诺的异步对象:<code class="fe ni nj nk mq b">Promise{1}</code>、<code class="fe ni nj nk mq b">Promise{2}</code>、<code class="fe ni nj nk mq b">Promise{3}</code>。我们设置变量<code class="fe ni nj nk mq b">gen</code>等于异步对象，之后我们使用<code class="fe ni nj nk mq b">for await ... of</code>循环遍历它。我们将变量<code class="fe ni nj nk mq b">item</code>设置为等于返回的承诺值:首先是<code class="fe ni nj nk mq b">Promise{1}</code>，然后是<code class="fe ni nj nk mq b">Promise{2}</code>，然后是<code class="fe ni nj nk mq b">Promise{3}</code>。由于<em class="og">在等待</em>的<code class="fe ni nj nk mq b">item</code>值，解析后的promsie，承诺的解析后的<em class="og">值</em>得到返回:<code class="fe ni nj nk mq b">1</code>，<code class="fe ni nj nk mq b">2</code>，然后<code class="fe ni nj nk mq b">3</code>。正确答案是<strong class="kv io"> C </strong>。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="30cc" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">结论</h1><p id="ab0d" class="pw-post-body-paragraph kt ku in kv b kw ob jo ky kz oc jr lb lc od le lf lg oe li lj lk of lm ln lo ig bi translated">希望你喜欢破解承诺任务并更新你的知识。我祝你在JavaScript学习上好运！</p></div></div>    
</body>
</html>