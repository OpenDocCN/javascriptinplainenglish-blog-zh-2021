<html>
<head>
<title>Understanding SOLID: Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解固体:依赖倒置原则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-solid-dependency-inversion-principle-ea271d5a53cd?source=collection_archive---------8-----------------------#2021-06-20">https://javascript.plainenglish.io/understanding-solid-dependency-inversion-principle-ea271d5a53cd?source=collection_archive---------8-----------------------#2021-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fed4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><strong class="ak">依赖倒置原则是软件设计和开发的标准指导规则之一，以确保松耦合组件和组件可扩展性</strong></h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5d1fa55f277942c85e1643c927402fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yyAL4I2quhPsYWJxpkM3w.png"/></div></div></figure><h1 id="e75b" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">依赖倒置原理是什么？</h1><p id="2576" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">依赖倒置原则声明我们需要依赖抽象而不是具体的实现。</p><h1 id="4652" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">什么是系统耦合？</strong></h1><p id="a531" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">系统耦合被定义为系统中一个项目对另一个项目的约束状态。耦合发生在上下文信息上。例如，在空调中，压缩机被称为耦合到内部冷却制冷剂和冷却机构，因为这些部件一起构成冷却系统的整体。</p><h1 id="148a" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">紧耦合和松耦合的组件？</strong></h1><p id="e936" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">联轴器有两种类型:<strong class="li io">紧联轴器</strong>和<strong class="li io">松联轴器</strong>。这些指的是在存在某个组件/模块的替代品的情况下，系统将如何反应。</p><p id="1e2f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在我们之前的例子中，如果空调的冷却机制与压缩机“紧密耦合”，那么其他公司制造的压缩机替代品<strong class="li io">极有可能完全破坏冷却机制</strong>。这是紧耦合组件系统的一个例子。紧密耦合的组件有具体的硬编码实现。</p><p id="0d03" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">松耦合与上述示例中的<em class="mh">正好相反</em>，用一个功能相似但<em class="mh">构造</em> / <em class="mh">实现</em>不同的系统进行替换，将确保系统按照上述方式工作。</p><h1 id="ddee" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">现在让我们看一个代码示例</strong></h1><p id="b901" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">根据我们之前的类比，我们定义一个简单的<strong class="li io">空调</strong>类:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="37fe" class="mn kp in mj b gy mo mp l mq mr">class CompressorV1 {</span><span id="95ec" class="mn kp in mj b gy ms mp l mq mr">  constructor() {</span><span id="0670" class="mn kp in mj b gy ms mp l mq mr">    console.log(“Compressor V1”);</span><span id="8a63" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="e135" class="mn kp in mj b gy ms mp l mq mr">  setup() {</span><span id="c9e6" class="mn kp in mj b gy ms mp l mq mr">    // perform some necessary setup task</span><span id="c7f4" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="9b3a" class="mn kp in mj b gy ms mp l mq mr">  turnOn() {</span><span id="251d" class="mn kp in mj b gy ms mp l mq mr">    this.setup();</span><span id="415a" class="mn kp in mj b gy ms mp l mq mr">    // function code</span><span id="732f" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="ed20" class="mn kp in mj b gy ms mp l mq mr">}<br/></span><span id="7542" class="mn kp in mj b gy ms mp l mq mr">class AirConditioner {</span><span id="ff3f" class="mn kp in mj b gy ms mp l mq mr">  private compressor: Compressor = new CompressorV1();</span><span id="64bf" class="mn kp in mj b gy ms mp l mq mr">  constructor() {}</span><span id="f676" class="mn kp in mj b gy ms mp l mq mr">  public powerOn() {</span><span id="98d4" class="mn kp in mj b gy ms mp l mq mr">    this.compressor.turnOn();</span><span id="959b" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="91c2" class="mn kp in mj b gy ms mp l mq mr">}</span></pre><p id="f6eb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io"> CompressorV1 </strong>对象是该<strong class="li io">空调</strong>类中的<strong class="li io">直接依赖</strong>。如果根据我们的类比进行新的修改，这将破坏<strong class="li io">空调</strong>类，因为它没有办法扩展功能以与新的压缩机类型一起运行。在没有实现依赖性反转原则的情况下，如果新的压缩机<strong class="li io"> CompressorV2 </strong>被引入空调，这将是代码的未来快照:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="9fe5" class="mn kp in mj b gy mo mp l mq mr">class CompressorV2 {</span><span id="19ae" class="mn kp in mj b gy ms mp l mq mr">  constructor() {</span><span id="48c6" class="mn kp in mj b gy ms mp l mq mr">    console.log(“Compressor V2”);</span><span id="7882" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="7e23" class="mn kp in mj b gy ms mp l mq mr">  setup() {</span><span id="85b6" class="mn kp in mj b gy ms mp l mq mr">    // perform some necessary setup task</span><span id="4814" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="e2fd" class="mn kp in mj b gy ms mp l mq mr">  turnOn() {</span><span id="a500" class="mn kp in mj b gy ms mp l mq mr">    this.setup();</span><span id="6c5f" class="mn kp in mj b gy ms mp l mq mr">    // function code</span><span id="c53f" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="75a0" class="mn kp in mj b gy ms mp l mq mr">}</span><span id="4475" class="mn kp in mj b gy ms mp l mq mr"><br/>class AirConditioner {</span><span id="0bca" class="mn kp in mj b gy ms mp l mq mr">  private compressor: Compressor = new CompressorV1();</span><span id="60b8" class="mn kp in mj b gy ms mp l mq mr">  private compressor2: CompressorV2 = new CompressorV2();</span><span id="d740" class="mn kp in mj b gy ms mp l mq mr">  constructor(private activeCompressor = 1) {}</span><span id="b29c" class="mn kp in mj b gy ms mp l mq mr">  public powerOn() {</span><span id="5ebe" class="mn kp in mj b gy ms mp l mq mr">    if (activeCompressor == 1) {</span><span id="4da8" class="mn kp in mj b gy ms mp l mq mr">      this.compressor.turnOn();</span><span id="4d31" class="mn kp in mj b gy ms mp l mq mr">    } else {</span><span id="98ed" class="mn kp in mj b gy ms mp l mq mr">      this.compressor2.turnOn();</span><span id="7f23" class="mn kp in mj b gy ms mp l mq mr">    }</span><span id="ccec" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="af04" class="mn kp in mj b gy ms mp l mq mr">}</span></pre><h2 id="abe9" class="mn kp in bd kq mt mu dn ku mv mw dp ky lp mx my la lt mz na lc lx nb nc le nd bi translated">问题突然变得很明显。</h2><p id="5e81" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">代码<strong class="li io">在添加大量不同的组件后将无法很好地扩展</strong>，这些组件是<strong class="li io">空调</strong>级中的核心依赖项，将来可能需要被替换。而且即使组件不需要替换，以这种方式使用<strong class="li io"> if-else </strong>块对生产代码也不好。众所周知，代码执行过程中遇到的决策分支越多，执行速度就越慢。</p><h1 id="a773" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">控制反转(IoC) </strong></h1><p id="d637" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">从上面的例子中，我们看到<strong class="li io"> AirConditioner </strong>类负责实例化和管理compressor对象。这导致了一种乏味的代码模式，每次引入新的<strong class="li io">压缩机</strong>时，都需要有人修改<strong class="li io">空调</strong>类来支持新的<strong class="li io">压缩机</strong>类型。</p><p id="4b3d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然而，让我们换个角度来看。我们没有让<strong class="li io">空调</strong>类来处理压缩机对象的生命周期，而是定义了一个<em class="mh">抽象</em>压缩机接口来为<strong class="li io">空调</strong>处理生命周期。我们将这个接口命名为<strong class="li io"> ICompressor </strong>(在前面加一个<strong class="li io"> I </strong>只是接口的命名约定)。</p><p id="22fc" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">你会问，为什么要有一个<strong class="li io">接口</strong>？接口允许我们<em class="mh">定义</em>一个特定类型的函数<em class="mh">，而不需要实际实现它</em>。因此，我们定义了一个压缩器的接口，它具有“设置”和“打开”的声明，但没有它的定义。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="c2a5" class="mn kp in mj b gy mo mp l mq mr">interface ICompressor {</span><span id="401e" class="mn kp in mj b gy ms mp l mq mr">  setup(config?: any): any;</span><span id="41b0" class="mn kp in mj b gy ms mp l mq mr">  turnOn(): any;</span><span id="062b" class="mn kp in mj b gy ms mp l mq mr">}</span></pre><p id="37f2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">每个compressor类现在都会实现这个接口。产生的代码:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="ef49" class="mn kp in mj b gy mo mp l mq mr">class CompressorV1 implements ICompressor {</span><span id="d15c" class="mn kp in mj b gy ms mp l mq mr">  constructor() {</span><span id="9405" class="mn kp in mj b gy ms mp l mq mr">    console.log(“CompressorV1 is in system”);</span><span id="2d77" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="3080" class="mn kp in mj b gy ms mp l mq mr">  setup(config?: any): any {</span><span id="c738" class="mn kp in mj b gy ms mp l mq mr">    // perform the very same setup tasks in this interface function</span><span id="e829" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="e69b" class="mn kp in mj b gy ms mp l mq mr">  turnOn(): void {</span><span id="2f54" class="mn kp in mj b gy ms mp l mq mr">    // same function code</span><span id="ebc0" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="fed3" class="mn kp in mj b gy ms mp l mq mr">}</span><span id="6045" class="mn kp in mj b gy ms mp l mq mr">class CompressorV2 implements ICompressor {</span><span id="ae7e" class="mn kp in mj b gy ms mp l mq mr">  constructor() {</span><span id="8246" class="mn kp in mj b gy ms mp l mq mr">    console.log(“Compressor V2 is in system”);</span><span id="b17e" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="2456" class="mn kp in mj b gy ms mp l mq mr">  setup(config?: any): any {</span><span id="05b1" class="mn kp in mj b gy ms mp l mq mr">    // perform the same necessary setup task</span><span id="d05c" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="e670" class="mn kp in mj b gy ms mp l mq mr">  turnOn(): void {</span><span id="22d7" class="mn kp in mj b gy ms mp l mq mr">    // same function code as before</span><span id="ba92" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="dc0f" class="mn kp in mj b gy ms mp l mq mr">}</span></pre><p id="c4ef" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">此外，<strong class="li io">空调</strong>级采用这种优雅的界面设计，看起来干净多了:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="657c" class="mn kp in mj b gy mo mp l mq mr">class AirConditioner {</span><span id="db9b" class="mn kp in mj b gy ms mp l mq mr">  constructor(private compressor: ICompressor) {}</span><span id="404c" class="mn kp in mj b gy ms mp l mq mr">  public powerOn() {</span><span id="d3d3" class="mn kp in mj b gy ms mp l mq mr">    this.compressor.turnOn();</span><span id="e977" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="1e9a" class="mn kp in mj b gy ms mp l mq mr">}</span></pre><p id="d50f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果我们现在运行我们的程序，它看起来是这样的:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="e149" class="mn kp in mj b gy mo mp l mq mr">class Main {</span><span id="17df" class="mn kp in mj b gy ms mp l mq mr">    static main(args: string[]): Number {</span><span id="e1a8" class="mn kp in mj b gy ms mp l mq mr">    const ac: AirConditioner = new AirConditioner(new CompressorV1());</span><span id="69e4" class="mn kp in mj b gy ms mp l mq mr">    ac.powerOn();</span><span id="eb63" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="4154" class="mn kp in mj b gy ms mp l mq mr">}</span></pre><p id="8489" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们刚才所做的被称为<strong class="li io">控制反转</strong>。这个过程消除了<strong class="li io">空调</strong>对<strong class="li io">压缩机</strong>类的依赖性。因此，概括地说，我们通过引入一个<em class="mh">甚至更高层次的抽象</em> ( <strong class="li io"> ICompressor </strong>)，使<strong class="li io">反转了<strong class="li io">依赖控制流</strong>，其中更高层次的模块(<strong class="li io">空调</strong>类)依赖于更低层次的模块(<strong class="li io">压缩机V1 </strong> / <strong class="li io">压缩机V2 </strong>类)。</strong></p><h1 id="23a3" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">再举一个例子</strong></h1><p id="425c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在我们上面的空调案例中，引入复杂行为并不罕见。假设出现了第三种类型的压缩器，我们也需要在我们的ACs中提供对这种压缩器的支持。但是这个压缩器的设置过程有点不同。与前两种类型完全离线设置过程不同，这种类型有一个远程连接模块，需要在压缩机启动之前配置该模块，以便进行压缩机系统资源监控。</p><p id="7cc0" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，第三个压缩器具有不同的内部设置行为，因为它依赖异步请求来完成其设置任务。</p><p id="02f0" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">由于现在采用了更高层次的实现方式，这种新型压缩机可以非常容易地集成到我们的空调中。我们简单地以下面的方式实现了另外一个<strong class="li io"> Compressor </strong>类，但是这次<strong class="li io"> turnOn </strong>函数被实现为<strong class="li io"> async </strong>函数。这是一个完全有效的修改，因为接口只关心函数的签名，从不关心函数是如何实现的。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="efbb" class="mn kp in mj b gy mo mp l mq mr">class SmartCompressor implements ICompressor {</span><span id="9682" class="mn kp in mj b gy ms mp l mq mr">  constructor() {</span><span id="fc8f" class="mn kp in mj b gy ms mp l mq mr">    console.log(“Smart Compressor is in system”);</span><span id="1156" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="ccb1" class="mn kp in mj b gy ms mp l mq mr">  loadConfiguration(): any {</span><span id="fe7c" class="mn kp in mj b gy ms mp l mq mr">    //function to load connection configuration</span><span id="5cbd" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="725e" class="mn kp in mj b gy ms mp l mq mr">  setup(config?: any): Promise&lt;any&gt; {</span><span id="01de" class="mn kp in mj b gy ms mp l mq mr">    // perform the same necessary setup task</span><span id="5d64" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="10ae" class="mn kp in mj b gy ms mp l mq mr">  async turnOn(): void {</span><span id="d7da" class="mn kp in mj b gy ms mp l mq mr">    const configObject = loadConfiguration();</span><span id="a3c0" class="mn kp in mj b gy ms mp l mq mr">    try {</span><span id="7856" class="mn kp in mj b gy ms mp l mq mr">      await this.setup(configObject);</span><span id="96a0" class="mn kp in mj b gy ms mp l mq mr">      // function code to turn on compressor</span><span id="e7d4" class="mn kp in mj b gy ms mp l mq mr">    } catch (err) {</span><span id="a148" class="mn kp in mj b gy ms mp l mq mr">      // catch error if connection fails</span><span id="3ca0" class="mn kp in mj b gy ms mp l mq mr">      console.log(err.message);</span><span id="4fac" class="mn kp in mj b gy ms mp l mq mr">    }</span><span id="dfe8" class="mn kp in mj b gy ms mp l mq mr">  }</span><span id="dab9" class="mn kp in mj b gy ms mp l mq mr">}</span></pre><p id="6698" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">尽管这次设置压缩器的过程非常不同，但是依赖反转确保了这个新添加的组件不需要对我们的系统进行完全的重新迭代(注意，这次我们甚至不需要使用我们的<strong class="li io">空调</strong>类)，从而节省了我们的时间和精力。借助于依赖倒置原则，这个系统现在已经被转换成一个松散耦合的系统。</p><h1 id="1467" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">结论</strong></h1><p id="3bd2" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">总之，这就是<strong class="li io">依赖倒置原则</strong>陈述并打算实现的内容。显而易见，松耦合架构是如何以及为什么支持这一原则，以及为什么它会出现在<strong class="li io"> S.O.L.I.D </strong>软件设计原则的列表中。</p><p id="8560" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><em class="mh">更多内容请看</em><a class="ae nf" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="mh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>