<html>
<head>
<title>Improve Your React Application with Code Splitting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过代码分割改进React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improve-your-react-application-with-code-splitting-4fc1597940fc?source=collection_archive---------5-----------------------#2021-12-06">https://javascript.plainenglish.io/improve-your-react-application-with-code-splitting-4fc1597940fc?source=collection_archive---------5-----------------------#2021-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3044" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">只在你需要的时候加载你需要的JavaScript文件。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/27759d2abe4acd964814b09cbe69c4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIZ1TjGmim5zw-xn3pSUPA.jpeg"/></div></div></figure><h2 id="c9ab" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">什么是代码拆分？</strong></h2><p id="9095" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><em class="mg">代码拆分是将代码拆分成不同的包或组件，然后按需或并行加载。~ MDN </em></p><h2 id="95ed" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">代码拆分的主要好处</strong></h2><p id="7a40" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">由于需要处理的JavaScript更少，您的应用程序将运行得更快。你的应用程序运行得越快，用户就越不可能认为你的应用程序质量差。漫长的加载时间<a class="ae mh" href="https://www.dotcom-tools.com/blog/how-fast-should-my-website-load/#:~:text=Ideal%20Website%20Load%20Time%20%E2%80%93%202,in%202%20seconds%20or%20less." rel="noopener ugc nofollow" target="_blank">会影响</a>应用程序的跳出率。此外，在比较单页面应用程序和多页面应用程序时，按需加载文件一直是主要的优势之一。</p><h2 id="1b17" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">你需要什么</strong></h2><p id="ba22" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">我的例子将使用React + Webpack配置。我不会深入讨论如何设置React或Webpack。本文假设您已经完成了这些工作，并且正在寻找进一步的优化。</p><h2 id="a2a2" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">入门</strong></h2><p id="7783" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">代码拆分相对容易实现。我们只需要更新我们的路由器。首先，我将展示一个没有启用代码分割的应用程序。焦点将集中在最高级路由器上。您使用的路由库应该无关紧要。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b618" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">在我构建我的应用程序之后，我的dist文件夹有一个包含我的整个应用程序的JavaScript文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/0e226a353e2a86c5bcd5f2cef0e38f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kq4Fi61SwJSgW_tc1a_AWQ.png"/></div></div></figure><p id="edb4" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">到本文结束时，我们的每条路线都将有一个单独的文件。</p><h2 id="217b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">启用web pack asynchunknames</strong></h2><p id="549c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><em class="mg">该步骤是可选的，但有助于调试</em></p><p id="6a31" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">一旦创建了新文件，有一种方法来识别它们是很好的。<code class="fe mq mr ms mt b">webpack-async-chunk-names-plugin</code>允许您配置文件的名称。</p><p id="82c7" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">要安装:</p><p id="68c2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated"><code class="fe mq mr ms mt b">yarn add webpack-async-chunk-names-plugin -D</code></p><p id="fbe8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">在webpack.config.js中:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="7d59" class="kr ks iq mt b gy my mz l na nb">// require the package</span><span id="1e3e" class="kr ks iq mt b gy nc mz l na nb">const AsyncChunkNames = require("webpack-async-chunk-names-plugin")</span><span id="7fc7" class="kr ks iq mt b gy nc mz l na nb"><br/>// add to your plugin array</span><span id="c4b5" class="kr ks iq mt b gy nc mz l na nb">plugins: [</span><span id="4ab1" class="kr ks iq mt b gy nc mz l na nb">  new AsyncChunkNames(),</span><span id="7715" class="kr ks iq mt b gy nc mz l na nb">]</span><span id="6185" class="kr ks iq mt b gy nc mz l na nb">// include a chunchunkFilename option inside output. This will get convered later.</span><span id="2175" class="kr ks iq mt b gy nc mz l na nb">output: {</span><span id="4acf" class="kr ks iq mt b gy nc mz l na nb">  filename: "[name].[hash].js",</span><span id="380f" class="kr ks iq mt b gy nc mz l na nb">  chunkFilename: "[name].[hash].js", &lt;--</span><span id="0cf1" class="kr ks iq mt b gy nc mz l na nb">  publicPath: "/",</span><span id="3591" class="kr ks iq mt b gy nc mz l na nb">}</span></pre><h2 id="0313" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">更新路由器</strong></h2><p id="da49" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">接下来，我们需要使用两个React函数来更新路由器，<code class="fe mq mr ms mt b">Lazy</code>和<code class="fe mq mr ms mt b">Suspense</code>。</p><p id="5e92" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">Lazy允许您将动态导入作为常规组件呈现。Lazy函数为您的组件获取一个导入语句并返回一个承诺。以这种方式导入的组件必须命名为exports。</p><p id="0320" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated"><code class="fe mq mr ms mt b">export default MyComponent</code></p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="2133" class="kr ks iq mt b gy my mz l na nb">const Component = React.lazy(() =&gt; import(./path-to-component))</span></pre><p id="e81c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">因为我们的惰性组件现在是异步加载的，所以我们需要使用悬念来等待它们的呈现。您可以提供您想要的任何组件作为后备选项。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="13cb" class="kr ks iq mt b gy my mz l na nb">&lt;Suspense fallback={&lt;LinearProgress /&gt;}&gt;<br/>  &lt;Component /&gt;<br/>&lt;/Suspense&gt;</span></pre><p id="bdb8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">这两个特性结合起来就是我们实现代码拆分的方式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="45d2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">回到我们添加到Webpack配置中的可选的<code class="fe mq mr ms mt b">chunkFilename</code>选项。您可以在lazy import语句中添加<code class="fe mq mr ms mt b">/* webpackChunkName: “name” */</code>,给文件一个您可以识别的名称。这是一个很好的特性，有助于解决您以后可能遇到的任何问题。</p><p id="fee0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">当Webpack看到这个配置时，它会为您处理一切。</p><p id="e865" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">重新构建您的应用程序，您应该看到在您的dist文件夹中为每个延迟加载的组件生成了单独的文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/3b62132e440046f4a4ed9ad8b7eb34a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkGu3ElRzmvk583k1aB5LQ.png"/></div></div></figure><p id="2093" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated">当您运行您的应用程序并访问每条路由时，您应该看到您的命名文件被加载到您的network选项卡中。</p><p id="59ef" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mm lx ly le mn ma mb li mo md me mf ij bi translated"><em class="mg">更多内容看</em> <a class="ae mh" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="mg">说白了. io </em> </strong> </a> <strong class="lp ir"> <em class="mg">。</em> </strong> <em class="mg">报名参加我们的</em> <a class="ae mh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="mg">免费每周简讯这里</em> </strong> </a> <strong class="lp ir"> <em class="mg">。</em>T25】</strong></p></div></div>    
</body>
</html>