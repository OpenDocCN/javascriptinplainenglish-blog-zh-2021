<html>
<head>
<title>The Squandered Potential of TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿被浪费的潜力</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-in-2021-and-beyond-not-worth-your-time-979e2b6e97d9?source=collection_archive---------0-----------------------#2021-05-31">https://javascript.plainenglish.io/typescript-in-2021-and-beyond-not-worth-your-time-979e2b6e97d9?source=collection_archive---------0-----------------------#2021-05-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4809" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">帮助您从TypeScript项目中获得最大类型安全性的一些模式</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/393931a1ecc9acec927498fe9551f671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_WQPoUg-fNVIP44t"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo of someone covered in TypeScript runtime errors, by <a class="ae ks" href="https://unsplash.com/@jessedo81?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">jesse orrico</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="03a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">免责声明:</strong>本文经过大量编辑，语气有所变化。请注意，标题不再是“TypeScript不值得您花费时间”，而是“以下是从TS项目中提取更多价值的方法。”</p><p id="aa3f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TypeScript不是免费的。它带来了严重的开发时损失和最低限度的安全保证，同时保留了JavaScript最糟糕的方面。</p><p id="575b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TypeScript使得JavaScript更难编写，开发时间更长，测试难度更大*，并让您产生一种错误的类型安全感。太多的时候人们忘记了写打字稿是<strong class="kv io"> <em class="lp">打假装</em> </strong> <em class="lp">。</em>您正在参与一个类型<strong class="kv io"> <em class="lp">提示</em> </strong>系统，而不是一个类型系统。您得不到运行时好处或安全保证，以及最少的类型推断。TypeScript增加的任何价值都基于这样一个假设，即您用准确的类型来修饰您编写的所有内容。<br/></p><p id="a1ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TypeScript的许多缺点可以被看作是脱离了它们的目标，即TypeScript是一种“非二进制”语言选择；首先是JavaScript互操作和逐步采用TypeScript，这种语言对您编写的代码类型不做任何假设。</p><p id="fdb1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种缺乏远见的做法使得JavaScript(现在是TypeScript)社区陷入了一些相当严重的反模式，比如使用类进行依赖注入、使用继承进行代码重用以及基于异常的错误处理。</p><p id="2bd8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TypeScript已经明确表明他们愿意添加修改运行时行为的构造，即在decorators和constructor属性中——为什么不进一步考虑类型安全呢？为什么不劝阻<a class="ae ks" href="https://medium.com/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf" rel="noopener">类&amp;继承</a>？为什么不强制<a class="ae ks" href="https://www.nickknowlson.com/blog/2013/04/16/why-maybe-is-better-than-null/" rel="noopener ugc nofollow" target="_blank">空值声明和处理</a>？为什么<a class="ae ks" href="https://softwareengineering.stackexchange.com/questions/150837/maybe-monad-vs-exceptions" rel="noopener ugc nofollow" target="_blank">不阻止异常</a>？为什么不鼓励使用类型来封装行为？</p><h1 id="eebd" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">我希望包括什么</h1><h2 id="535e" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">用结果类型进行优雅的错误处理</h2><p id="bbd6" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">大多数语言，包括Javascript和Typescript，都使用基于<strong class="kv io">控制流</strong>的错误处理。例外情况。</p><p id="eeb5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着当一个函数到达不能继续的状态时，它<strong class="kv io">抛出</strong>一个错误，这个错误由调用它的函数和调用那个函数的函数再次抛出，直到希望有人捕捉到它。</p><p id="b635" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这对JS来说可以，但对TypeScript就不行了。最大的问题是<strong class="kv io">你不能从它的类型签名</strong>判断一个函数是否可能失败。这意味着您看到的任何TypeScript函数签名都有可能是谎言。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="22dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个函数<strong class="kv io"> <em class="lp">说</em> </strong>它返回一个数字，但是如果你传递一个分母为0的值，它会抛出一个错误。</p><h2 id="0a05" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">输入<code class="fe nb nc nd ne b">Result&lt;T, E&gt;</code></h2><p id="939d" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">Result(有时也称为要么)是一种特殊的类型，它表示“<strong class="kv io">要么</strong>运行正常，您得到一个T，要么有一个错误，您得到一个e。”</p><p id="bab5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最小的定义可能是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b5db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，这并不完美，更健壮的实现可以使用<code class="fe nb nc nd ne b"><a class="ae ks" href="https://gigobyte.github.io/purify/adts/Either" rel="noopener ugc nofollow" target="_blank">purify-ts/Either</a></code>或<code class="fe nb nc nd ne b"><a class="ae ks" href="https://gcanti.github.io/fp-ts/modules/Either.ts.html" rel="noopener ugc nofollow" target="_blank">fp-ts/Either</a></code>。</p><p id="b6f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着上面的<code class="fe nb nc nd ne b">divide</code>函数可以重写为:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3d28" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这有一些很大的好处:</p><ul class=""><li id="b8bd" class="nf ng in kv b kw kx kz la lc nh lg ni lk nj lo nk nl nm nn bi translated">我们可以流畅地处理错误(就像我们与数组交互一样；一般有<code class="fe nb nc nd ne b">Result.map</code>、<code class="fe nb nc nd ne b">Result.bind</code>、<code class="fe nb nc nd ne b">Result.isOk</code> / <code class="fe nb nc nd ne b">isErr</code>)</li><li id="a103" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">类型签名表示“我可以失败！”</li><li id="edd6" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated"><code class="fe nb nc nd ne b">divide</code> <strong class="kv io">的调用者必须</strong>检查结果是否正确，以便提取值，从而编译类型脚本</li><li id="2ef2" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">这个错误不会在调用栈中冒泡，直到有人发现它</li></ul><h2 id="b68f" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">使用选项进行优雅的空值处理</h2><p id="5233" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">如果您启用了严格模式并使用了null-coalesce操作符，那么这就没什么价值了，但仍然很有价值。</p><p id="2644" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">与Result类似，我们可以使用类型来封装值是否存在:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d7cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，这并不完美，更健壮的实现可用作<code class="fe nb nc nd ne b"><a class="ae ks" href="https://gigobyte.github.io/purify/adts/Maybe" rel="noopener ugc nofollow" target="_blank">purify-ts/Maybe</a></code>或<code class="fe nb nc nd ne b"><a class="ae ks" href="https://gcanti.github.io/fp-ts/modules/Option.ts.html" rel="noopener ugc nofollow" target="_blank">fp-ts/Option</a></code>。</p><ul class=""><li id="693f" class="nf ng in kv b kw kx kz la lc nh lg ni lk nj lo nk nl nm nn bi translated">我们可以流畅地处理空值(就像我们处理数组一样；一般有<code class="fe nb nc nd ne b">Option.map</code>、<code class="fe nb nc nd ne b">Option.bind</code>、<code class="fe nb nc nd ne b">Option.isSome</code> / <code class="fe nb nc nd ne b">isNone</code>)</li><li id="eec3" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">类型签名说“我可能什么也不返回！”(你已经可以用<code class="fe nb nc nd ne b">Nullable</code>做到这一点)</li><li id="df31" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated"><code class="fe nb nc nd ne b">Option</code> s <strong class="kv io">的接收者有</strong>来确保该值是某个值，以便从选项中获取它</li></ul><h2 id="c243" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">合成而非继承</h2><p id="38bf" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">在一种致力于成为另一种语言的超集的语言中，这种情况有点难以想象。在TS中有3种声明类型的方法；<code class="fe nb nc nd ne b">type</code>、<code class="fe nb nc nd ne b">interface</code>和<code class="fe nb nc nd ne b">class</code>。<code class="fe nb nc nd ne b">type</code>和<code class="fe nb nc nd ne b">interface</code>类似，允许你声明一个函数类型但不实现它。<code class="fe nb nc nd ne b">class</code>允许你混合类型定义和实现。</p><p id="f932" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将数据建模为类的一个常见示例是形状；如<code class="fe nb nc nd ne b">Triangle</code>、<code class="fe nb nc nd ne b">Quadrilateral</code>。这个例子通常是因为每个形状都是从一个叫做<code class="fe nb nc nd ne b">Shape</code>的基类中派生出来的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8880" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个模型的问题是，如果你使用一个基类来共享接口和实现，你已经把<code class="fe nb nc nd ne b">Shape</code>和子类耦合得非常紧密了。</p><p id="b11d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更好的模式是使用复合——将脚本从“<code class="fe nb nc nd ne b">Triangle</code>是一个<code class="fe nb nc nd ne b">Shape</code>”翻转为“<code class="fe nb nc nd ne b">Triangle</code>有<code class="fe nb nc nd ne b">Area</code>”和“<code class="fe nb nc nd ne b">Triangle</code>有<code class="fe nb nc nd ne b">Sides</code>”</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="443c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过用多个单一用途的接口替换基类，我们已经根据每个形状所具有的品质组合了各个形状。这意味着每一个都可以在不影响其他的情况下被扩展或改变。</p><p id="4aff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Rust和Haskell等语言中，复合模式发挥到了极限，它们用复合(如上)和代数数据类型完全取代了类和继承。</p><p id="99c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lp">plain English . io</em></a></p></div></div>    
</body>
</html>