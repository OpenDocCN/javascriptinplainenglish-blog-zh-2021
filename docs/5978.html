<html>
<head>
<title>An Introduction to State Management in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的状态管理介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/state-management-in-react-48d16d162442?source=collection_archive---------7-----------------------#2021-12-22">https://javascript.plainenglish.io/state-management-in-react-48d16d162442?source=collection_archive---------7-----------------------#2021-12-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5516" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React中的状态管理概述，并确定状态管理是否完全必要。</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/f829194b304081c9413861f049ddda73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jJQ0I1VEdOKOCBdb"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk"><a class="ae kt" href="https://unsplash.com/photos/gNMVpAPe3PE" rel="noopener ugc nofollow" target="_blank">Photo</a> by Mourizal Zativa</figcaption></figure><p id="9ae6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">这篇文章是关于React中的状态管理。它由三章组成，回答了以下问题:什么是状态管理？国家管理解决哪些问题？解决方案和最佳实践是什么？本文不仅概述了React中的状态管理，还提供了是否需要状态管理的决策基础。</em></p><p id="82ff" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">🇩🇪版本你可以在这篇<a class="ae kt" href="https://blog.codecentric.de/2021/12/state-management-in-react/" rel="noopener ugc nofollow" target="_blank">博文</a>中找到。</p><p id="237a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">状态管理是一个非常复杂的话题。所有前端开发人员都知道这一点。他们问自己，在组件之间共享和管理状态的最佳方法是什么。</p><p id="a9e5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">不仅有许多外部状态管理库(比如最流行的Redux和Mobx ),而且React已经内置了状态管理。这使得做决定更加困难。</p><p id="b694" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在决定哪种状态管理方法最适合您之前，您应该问自己以下几个问题:</p><ol class=""><li id="ddbb" class="lr ls in kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">我甚至需要状态管理吗？</li><li id="f4bf" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><em class="lq">哪种解决方案最适合我的使用案例？</em></li><li id="bcdb" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><em class="lq">当我的应用程序变得更大更复杂时，我如何扩展和维护已实现的解决方案？</em></li><li id="3bd4" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><em class="lq">如何测试状态管理？* </em></li></ol><p id="3753" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">本文回答问题1-3。我将回答问题4 " <em class="lq">如何测试状态管理？"</em>下一篇。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="3ab5" class="mm mn in bd mo mp mq mr ms mt mu mv mw jt mx ju my jw mz jx na jz nb ka nc nd bi translated">1.我需要国家管理吗？</h1><p id="6288" class="pw-post-body-paragraph ku kv in kw b kx ne jo kz la nf jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">不幸的是，这个问题没有简单的答案。这取决于您的应用程序的规模和复杂程度，以及您使用React的经验。</p><p id="e457" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">“伟大的埃瓦，现在我更加困惑，仍然不知道我是否甚至需要一个国家管理”。</p><p id="dd03" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果你的应用程序不是太大太复杂，而是很小很简单，你不必让它变得不必要的复杂。对于许多用例，您根本不需要任何状态管理库。</p><p id="454b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">此外，如果你是一个初学者，开始学习React，你不应该在开始时使用任何复杂的库。</p><p id="b41e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">重要的是，你从一开始就已经知道如何反应。</p><ul class=""><li id="3935" class="lr ls in kw b kx ky la lb ld lt lh lu ll lv lp nj lx ly lz bi translated">您的组件应该一次只负责一项任务。它们越大，测试起来就越复杂和困难。你可以把它们想象成乐高积木。</li><li id="3af6" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">你应该知道<em class="lq">状态</em>和<em class="lq">道具的区别。</em></li></ul><p id="eb56" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这里我简单给大家解释一下<em class="lq">状态</em>和<em class="lq">道具的区别和相同之处。</em></p><h2 id="b698" class="nk mn in bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated"><strong class="ak">状态和道具</strong></h2><p id="2a99" class="pw-post-body-paragraph ku kv in kw b kx ne jo kz la nf jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated"><em class="lq">状态</em>和<em class="lq">道具</em>有什么共同点？它们是<strong class="kw io">确定性的</strong>并且<strong class="kw io">一旦改变<strong class="kw io">就触发渲染更新</strong>。<em class="lq">确定性</em> </strong> <em class="lq"> </em>意思是如果你的组件对相同的状态和道具组合产生不同的输出，说明你做错了。</p><p id="f822" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">什么是<strong class="kw io">状态</strong>？我们以复选框为例。复选框有两种状态- <em class="lq">真</em>和<em class="lq">假。</em>如果用户选中复选框，其状态将会改变。这种状态被称为<em class="lq">状态</em>。</p><p id="676f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">以下是与<strong class="kw io">状态</strong>相关的最重要的亮点:</p><ul class=""><li id="36a6" class="lr ls in kw b kx ky la lb ld lt lh lu ll lv lp nj lx ly lz bi translated">用户事件经常会改变状态</li><li id="ca4b" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">国家是私有的。只有具有状态的组件才能改变它</li><li id="007a" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">状态有一个初始默认值</li></ul><p id="7b8d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">什么是<strong class="kw io">道具</strong>？你可以把道具想象成一种配置。道具由父组件提供。让我们以前面的例子，一个复选框:它可以是可配置的，例如，它可以有一个名称或颜色。这些是道具。道具有<strong class="kw io"> <em class="lq">不可变</em> </strong>。这意味着组件不能改变它。</p><p id="6e42" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在这个<a class="ae kt" href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md#changing-props-and-state" rel="noopener ugc nofollow" target="_blank"> React指南</a>里，你可以找到一个非常好甚至更详细的总结。</p><p id="1a3c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们分析下面的例子，在这里你可以看到s <em class="lq">状态</em>和<em class="lq">道具</em>之间的区别:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="18b3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您可以使用如下属性定义复选框的不同变体:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="192c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是它呈现的样子:</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/478d9e862e541242d82cd29729c39b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*dFDaJ7z7O2RBQ4FWESv3EA.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Different configurations of a checkbox</figcaption></figure><p id="7d54" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你可能想知道为什么我解释并提到了道具和状态。在一些用例中，你只能使用道具和状态来代替状态管理。如果父子关系中有两个组件，这是有意义的。因此，这些组成部分非常相互依赖。所以你可以很好地封装一切。</p><p id="0713" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果直接子组件不需要数据，而只需要孙组件，就不应该使用props。否则，组件只需转发道具，即使它们不需要也不应该知道任何关于它们的信息。这可能导致正确钻井。我将在下一章解释什么是道具训练。</p><p id="b522" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">也没有必要全局保存内部组件状态。如果父组件需要子组件状态已经改变的信息，你可以传递一个回调函数(例如<em class="lq"> TabIndexChange </em>)给父组件作为道具。</p><h1 id="7b2e" class="mm mn in bd mo mp nz mr ms mt oa mv mw jt ob ju my jw oc jx na jz od ka nc nd bi translated">2.<em class="kc">哪个解决方案最适合我的用例</em>？</h1><p id="98cc" class="pw-post-body-paragraph ku kv in kw b kx ne jo kz la nf jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">在这一章中，我解释了两种状态管理解决方案:Redux和useContext。我描述了每个解决方案解决了哪些问题，以及在每种情况下如何处理异步操作。我还解释了什么是道具钻井的意思。我们从Redux开始。</p><h2 id="e511" class="nk mn in bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated"><strong class="ak"> Redux </strong></h2><p id="704b" class="pw-post-body-paragraph ku kv in kw b kx ne jo kz la nf jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">我假设您熟悉Redux的概念。如果没有，你应该先了解一下它的<a class="ae kt" href="https://redux.js.org/understanding/thinking-in-redux/three-principles" rel="noopener ugc nofollow" target="_blank">基本原理</a>和<a class="ae kt" href="https://redux.js.org/introduction/core-concepts" rel="noopener ugc nofollow" target="_blank">概念</a>。</p><p id="45bd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Redux有助于减少<strong class="kw io">支柱钻孔。</strong></p><p id="0fd2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> Prop drilling </strong>发生在几个但不是所有组件(在组件树中)需要相同的信息时，例如UI主题、用户名或响应状态(加载/错误/成功)。问题是大的props对象被传递到组件树的其他部分。结果很多组件只是转发道具，根本不需要数据。它使得:</p><ul class=""><li id="5991" class="lr ls in kw b kx ky la lb ld lt lh lu ll lv lp nj lx ly lz bi translated"><strong class="kw io">代码更难理解</strong> -最迟在应用程序变大时</li><li id="9430" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated"><strong class="kw io">应用程序的扩展、重构和测试</strong>更加困难。假设您有一个对象，您将它传递给许多组件:<em class="lq">{ username:string；名字:字符串；lastName:字符串；}.</em>现在有一个新的领域<em class="lq">年龄。</em>在这种情况下，您必须调整所有受影响的组件和测试。</li></ul><p id="320a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">React文档建议将共享状态提升到下一个公共父组件:</p><blockquote class="oe of og"><p id="1e80" class="ku kv lq kw b kx ky jo kz la lb jr lc oh le lf lg oi li lj lk oj lm ln lo lp ig bi translated">通常，几个组件需要反映相同的变化数据。我们建议将共享状态提升到它们最近的共同祖先[1]。</p></blockquote><p id="7371" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">“嗯，Ewa，我已经知道什么是道具钻探，这也是我们决定为我们的项目选择Redux的原因。Redux需要大量样板代码。那有什么好处呢？”</p><p id="a922" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是正确的。因此，在下文中，我将描述React概念<strong class="kw io">use context</strong>&amp;<strong class="kw io">useReducer</strong>作为状态管理解决方案。但是在我们进入那个部分之前，先说几句关于<strong class="kw io">Redux</strong>T26】Toolkit的话。也许这对你来说是个不错的选择。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="11a0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Redux团队意识到了所有这些问题，比如样板代码和Redux的复杂使用。这就是他们试图简化Redux概念的原因。这个新概念叫做<strong class="kw io"> Redux Toolkit </strong>，根据Redux文档，这是编写Redux逻辑的新的推荐方法。</p><h2 id="1c17" class="nk mn in bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated"><strong class="ak"> Redux工具包:</strong></h2><ul class=""><li id="f97a" class="lr ls in kw b kx ne la nf ld ok lh ol ll om lp nj lx ly lz bi translated">非常灵活</li><li id="9413" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">有助于避免最常见的错误</li><li id="9673" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">包含最佳实践</li><li id="ad6c" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">加速开发并简化Redux的使用</li><li id="7fc2" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">很容易测试</li></ul><p id="f904" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们看看下面的例子，你可以看到，你如何使用redux工具包从Redux状态定义一个分数:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="93ee" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果你了解Redux，你可能已经注意到代码更简单，更容易理解。现在只有Redux状态的一小部分，称为<em class="lq">片</em>，而不是动作和reducers的两个文件。reducers的实现不太复杂，因为在幕后<em class="lq"> Immer库</em>负责不可变的状态更新。</p><p id="1cd3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在<a class="ae kt" href="https://redux-toolkit.js.org/usage/immer-reducers" rel="noopener ugc nofollow" target="_blank"> Redux Toolkit文档</a>中，你可以读到更多关于<em class="lq"> Immer库</em>的内容。</p><p id="8d37" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">发送动作和使用选择器也非常简单:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="2b28" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您一定想知道当发送一个像上面例子中的<em class="lq"> fetchUser </em>这样的异步动作时会发生什么。如何发送请求、等待响应并最终相应地更新存储呢？理想情况下:处理错误，记录一些东西，向用户显示一个加载微调器，等等。您肯定不希望在每个组件中重复相同的事情(加载微调器、成功通知、错误处理……)。</p><p id="d59a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你如何解决这个问题？答案是:“中间件来拯救！”</p><p id="e16f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">有了中间件，你可以拦截每一个发送的动作，进行修改，甚至取消动作。中间件有助于:</p><ul class=""><li id="f060" class="lr ls in kw b kx ky la lb ld lt lh lu ll lv lp nj lx ly lz bi translated">记录</li><li id="3290" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">错误处理</li><li id="4baa" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">异步请求</li><li id="357e" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">还有更多…</li></ul><p id="2330" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">最喜欢<a class="ae kt" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> redux saga </a>。下面是一个如何发送异步请求和更新状态的例子。在Saga中，你可以做更多的事情，例如，将用户重定向到另一个页面。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="3216" class="nk mn in bd mo nl nm dn ms nn no dp mw ld np nq my lh nr ns na ll nt nu nc nv bi translated">使用上下文&amp; useReducer</h2><p id="3c4e" class="pw-post-body-paragraph ku kv in kw b kx ne jo kz la nf jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">不过Redux说够了！如上所述，React还提供了自己的实现状态管理的解决方案——不需要任何外部库，比如Redux (Toolkit)。这个解决方案被称为<em class="lq">上下文</em>。</p><p id="8f74" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">上下文在一组需要相同数据的组件之间共享数据。这意味着不需要手动将道具传递到每个树级。可以分组的数据例如是UI主题或登录用户。</p><p id="2622" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">使用上下文&amp;用户删除模式:</strong></p><ul class=""><li id="41e9" class="lr ls in kw b kx ky la lb ld lt lh lu ll lv lp nj lx ly lz bi translated">没有额外的库，一切都基于React</li><li id="36b2" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">非常灵活，但是您必须自己实现一些模式(参见下面的例子)</li></ul><p id="7b9d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们来看看这个例子:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6a47" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是定义上下文的方式。它非常类似于Redux:您定义状态、reducers和动作。</p><p id="ac24" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">下面是一个非常简单的例子，说明如何使用<em class="lq">分派</em>和<em class="lq">状态</em>:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="7d26" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果您按下“保存用户”按钮，会发送一个操作，然后用户名会被更新。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b1f3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你必须记住只在提供者内部使用<em class="lq"> useUserDetails </em>。正如你在这里看到的，子组件<em class="lq">用户表单</em>和<em class="lq">用户头像</em>不再需要道具。</p><p id="b11a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">“好吧，我明白这个模式了。我如何发送异步动作？有没有类似Redux-Saga的东西？”</p><p id="e6f2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">可惜没有。但是你可以使用所谓的帮助函数。Kent C. Dodds提出了一个解决此类问题的好模式，并在他的文章<a class="ae kt" href="https://kentcdodds.com/blog/how-to-use-react-context-effectively#what-about-async-actions" rel="noopener ugc nofollow" target="_blank">中进行了解释。</a></p><h1 id="7b6b" class="mm mn in bd mo mp nz mr ms mt oa mv mw jt ob ju my jw oc jx na jz od ka nc nd bi translated">3.当我的应用程序变得更大更复杂时，我如何扩展和维护实现的解决方案？</h1><p id="a585" class="pw-post-body-paragraph ku kv in kw b kx ne jo kz la nf jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">有了这三个基本规则，您可以灵活地扩展和维护您的应用程序:</p><p id="8d1c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">不要保存店内所有物品！</strong></p><p id="60e6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果只在父代和子代之间分发数据，则不应将它们保存在存储中。在这种情况下，如果只使用道具和内部组件状态就足够了。</p><p id="ba8b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">定义状态更通用！</strong></p><p id="520e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设您的应用程序中有不同类型的模态或通知，例如<em class="lq"> ConfirmationModal </em>、<em class="lq"> ReportProblemModal、</em>或<em class="lq"> UserFormModal </em>。这些情态动词属于不同的特征。但是，您可以将所有必要的模态字段存储在一个通用的<em class="lq">模态</em>特征(切片)中，而不是重复并保存每个特征的模态状态。那会节省你很多时间。</p><p id="bb80" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这里您可以看到一个反模式。对于每个特性，模态的代码不必重复。这同样适用于测试:在这种情况下，您需要多次测试相同的功能(modalOpen)。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="4662" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">相反，您可以简化代码，使其更加通用。这同样适用于通知、错误和其他对话框。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1c62" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">完善组件树的结构！</strong></p><p id="0343" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在使用Context或Redux之前，你应该首先考虑<strong class="kw io">复合组件</strong>是否能解决你的问题。</p><p id="82a6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果有两个高度依赖的组件(父组件和子组件)，可以使用<strong class="kw io">复合组件</strong>。例如，这可以是下拉菜单或菜单列表:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="52d8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">菜单列表</em>是<em class="lq">菜单项</em>的容器。这两个组件高度依赖于彼此。使用<em class="lq">菜单列表</em>而没有<em class="lq">菜单项目</em>是没有意义的，反之亦然。<em class="lq">菜单列表</em>有一个内部状态(<em class="lq"> isOpen </em>)，也知道选择了哪个选项(<em class="lq">菜单项目</em> ) <em class="lq"> </em>)。</p><p id="cfd8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果您想了解更多关于复合组件的知识，您可以阅读Kent C. Dodds的这篇非常好的文章。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="420a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在这篇文章中，我提出并回答了三个关于国家管理的问题。在选择状态管理解决方案之前，您应该首先问自己是否需要状态管理。这取决于您的应用程序的规模和复杂程度，以及您使用React的经验。有时候只有道具和状态就够了。</p><p id="0a55" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果您决定支持状态管理，您可以使用内置的React解决方案(上下文)或者选择一个外部库(例如Redux Toolkit)。</p><p id="20f2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">尽管如此，您也应该遵循最佳实践:</p><ul class=""><li id="aab1" class="lr ls in kw b kx ky la lb ld lt lh lu ll lv lp nj lx ly lz bi translated">如果可能，不要保存商店中的所有内容并定义状态generic！</li><li id="d146" class="lr ls in kw b kx ma la mb ld mc lh md ll me lp nj lx ly lz bi translated">尝试改进组件树的结构，例如，如果可能的话，使用复合组件！</li></ul><p id="450d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">希望我的文章对你有帮助，回答了你的问题。我会很高兴你的反馈。</p><h1 id="eb1a" class="mm mn in bd mo mp nz mr ms mt oa mv mw jt ob ju my jw oc jx na jz od ka nc nd bi translated">来源</h1><ol class=""><li id="1b39" class="lr ls in kw b kx ne la nf ld ok lh ol ll om lp lw lx ly lz bi translated"><a class="ae kt" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank"> React文档</a></li></ol><p id="744e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">更多内容看</em> <a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">说白了。报名参加我们的</em> </a><a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">免费周报</em> </a> <em class="lq">。在我们的</em> <a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="lq">社区</em> </a> <em class="lq">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>