<html>
<head>
<title>Write Your Own Promise in JavaScript — JavaScript Interview Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript — JavaScript面试系列中写下你自己的承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-your-own-promise-in-js-javascript-interview-series-b95c88bc1456?source=collection_archive---------9-----------------------#2021-07-23">https://javascript.plainenglish.io/writing-your-own-promise-in-js-javascript-interview-series-b95c88bc1456?source=collection_archive---------9-----------------------#2021-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/160281ac131363713ef45f51fdb2293a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pa4_wg7eU8YMUZxD"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@andrewwwpetrov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Petrov</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5fa1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Promises是ES6最大的新增功能之一，它构成了许多基于异步方法的Javascript库的基础。事实上，这是所有Javascript访谈中经常遇到的话题。有时候，求职者需要用Javascript写下自己的承诺(也称为polyfill ),尤其是当你为亚马逊、脸书等大公司面试时。对于公司来说，这是衡量候选人对JS核心概念理解的一个很好的方式。</p><p id="1216" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们开始之前，我想请你读一下下面的文章，对承诺有一个清楚的了解。</p><div class="ky kz gp gr la lb"><a href="https://wasefs.medium.com/promises-in-javascript-javascript-interview-series-fd65be7cb0b2" rel="noopener follow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">Javascript中的承诺——Javascript访谈系列</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">承诺是Javascript中最重要的主题之一，是作为ES6的一部分引入的。它经常被问到…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">wasefs.medium.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jt lb"/></div></div></a></div><p id="2367" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设你知道关于承诺的一切，现在是开始的时候了</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><h1 id="7c29" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak">多填承诺</strong></h1><p id="c2a3" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">考虑一个异步方法，用2秒的延迟将两个数(a，b)相除。我们尝试使用Promise polyfill (myPromise)来执行这个操作。请仔细阅读下面的代码</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/81ae8855ee3ba5094600a4e14177ec57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qz4M8O1jSA6BvKR9YhGu8A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 1. Asynchronous event executed with custom promise</figcaption></figure><p id="90be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们一步一步地检查这段代码。</p><ol class=""><li id="f574" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">在第36行执行异步函数<em class="nj"> division(a，b) </em>，其中a = 5，b = 2。</li><li id="9168" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated">该函数返回一个承诺(myPromise)。因为myPromise是一个构造函数，所以用“new”关键字创建并返回myPromise的一个实例。</li><li id="323d" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated">myPromise函数接受一个<em class="nj">执行器</em>函数作为参数(定义在第3行。第12行)由于setTimeout函数而异步。</li><li id="f381" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated">当使用“new”关键字创建实例时，还会调用并执行myPromise函数，并返回“this”。点击阅读更多关于‘new’关键字和构造函数<a class="ae jz" href="https://docs.microsoft.com/en-us/previous-versions/msdn10/ff852808(v=msdn.10)" rel="noopener ugc nofollow" target="_blank">的内容。返回的this用于调用必要的函数，如<em class="nj"> then() </em>和<em class="nj"> catch() </em>。</a></li><li id="1452" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated">由于<em class="nj">执行器</em>函数是异步的，因此<em class="nj">执行器</em>函数虽然在第32行因“new”关键字而被执行，但由于其异步特性(由于setTimeout ),不会立即被执行。</li><li id="da9a" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated"><em class="nj">执行器</em>函数接受两个参数<em class="nj">解决</em>和<em class="nj">拒绝</em>，这在第26行中描述。和第29行。分别是。<em class="nj">解析</em>功能执行<em class="nj"> onResolve </em>功能。然而，这个函数还没有被定义，因为<em class="nj"> then() </em>方法(第18行。)分配给它某个功能(第19行。)尚未调用。因此，我们处于一个不安全的区域。然而，由于executor函数的异步特性，我们有足够的时间通过调用<em class="nj"> division(5，2)中的then()方法，将<em class="nj"> onResolve </em>的状态从未定义更改为<em class="nj"> then() </em>方法中描述的函数。然后()</em>。</li><li id="3bc4" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated">当在函数divide(5，2)上调用<em class="nj"> then() </em>方法时，执行<em class="nj"> then() </em>方法(在第18行之间描述。和第20行)。无论<em class="nj">括号中描述的是什么函数，then() </em>方法都会附加到之前描述的<em class="nj"> onResolve </em>变量上。因此现在<em class="nj"> resolve </em>不再有未定义的<em class="nj"> onResolve </em>变量。</li><li id="ec10" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated">当setTimeout到期后<em class="nj">执行器</em>函数准备就绪时，在第6行调用<em class="nj">执行器</em>函数中的<em class="nj"> resolve() </em>函数(因为b不等于零)。</li><li id="4ba3" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated">就这样，我的承诺被解决了。</li></ol><p id="ec0f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">唷！！！这太过分了。现在，如果executor函数没有setTimeout方法会怎样。</p><p id="7905" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个还能用吗？</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="np lv l"/></div></figure><p id="91a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可悲的🥲 🥲 🥲 <strong class="kc io">不！！！！！因为我们没有足够的时间走出不安全的区域。</strong></p><p id="b982" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在浏览器中得到以下错误</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/c3a88b430b2b457a9308f93946a6e5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnVD5hVfM8zWnL0jlu-2rQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 2. Errors for promise without setTimeout</figcaption></figure><p id="4c5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了处理这种情况，我们需要如下修改myPromise函数。(我只对已解决的承诺进行了修改，但对于拒绝也可以考虑类似的方法)。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/3c0fab9ff923bdcf5143dae2fcc2bf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EeJFu1q8RyRW7rfV2xParw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Figure 3. Synchronous event executed by custom promise.</figcaption></figure><p id="39a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的执行顺序与前面描述的一样。然而，这里我们有三个额外的变量(值、调用和实现)。</p><ol class=""><li id="a0b6" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">如果<em class="nj"> then() </em>函数在<em class="nj"> resolve </em>函数之前执行，那么我们将在<em class="nj"> then() </em>方法中描述的函数存储在onResolve函数中，并将名为的<em class="nj">变量设置为true(第19行),表明调用了<em class="nj"> then() </em>函数。然而，如果在执行<em class="nj"> then() </em>函数之前实现了承诺，那么我们会立即调用<em class="nj"> onResolve </em>函数，其中包含<em class="nj"> then() </em>函数中描述的函数以及存储在变量<em class="nj"> value </em>中的值(第24行)。</em></li><li id="9173" class="na nb in kc b kd nk kh nl kl nm kp nn kt no kx nf ng nh ni bi translated">如果<em class="nj"> resolve </em>函数在<em class="nj"> then() </em>函数之前执行，则<em class="nj"> fulfilled </em>变量被设置为true，表示承诺已履行，解析值(<em class="nj"> val </em>)存储在<em class="nj"> value </em>变量中。此外，检查是否使用名为的变量<em class="nj">调用了<em class="nj"> then() </em>函数。如果是，则将执行<em class="nj"> onResolve </em>功能，因为该功能现在已经可用。</em></li></ol><p id="c722" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图3中描述的代码。是Promise polyfill的完整而充分的版本。</p><p id="5f1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在开始自己尝试这段代码之前，请花些时间再次阅读这篇文章。</p><p id="de36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你喜欢这篇文章。请在下面的评论区分享你的意见和疑问。</p><p id="3c92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nj">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>