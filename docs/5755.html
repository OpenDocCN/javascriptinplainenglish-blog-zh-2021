<html>
<head>
<title>The Architectural Pattern in Software Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件架构中的架构模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/architectural-pattern-in-software-architecture-f77bd8cb0601?source=collection_archive---------8-----------------------#2021-12-06">https://javascript.plainenglish.io/architectural-pattern-in-software-architecture-f77bd8cb0601?source=collection_archive---------8-----------------------#2021-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3d585d3baa11e4071b843c818c8491c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aFS50NwVyLmweR7F"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@lukepeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luke Peters</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ebfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据维基百科，</p><p id="805f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“一个架构模式是一个通用的、可重用的解决方案，用于解决给定环境下软件架构中经常出现的问题。架构模式类似于软件设计模式，但范围更广。”</p><p id="7145" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看一些常见的架构模式，</p><h1 id="b4f0" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">单体建筑:</strong></h1><p id="0f4d" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">在单片架构中，<strong class="kc io">整个程序是一个大的可执行单元</strong>。有时会指定成千上万行源代码。一个结构良好的整体可以给你需要的效率，代价是非常缓慢和痛苦的部署。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/a3cbd00cbaf24701bac782cc8f0181be.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*_oTArSrBA6ln9V5qhV5eDQ.png"/></div></figure><p id="43d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是整块石头有一个缺点，那就是每个人都不敢碰它，甚至一个小小的变化都会在意想不到的地方引起问题。应该花几个小时的工作可能要花几个星期。</p><h1 id="6ba5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">微内核(插件)架构:</strong></h1><p id="b475" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">微内核(插件)架构<strong class="kc io">背后的主要思想是将系统的基本功能放入一个独立的可执行文件</strong>。例如，在操作系统中，内核处理虚拟内存和文件系统。其他功能是作为独立的执行单元实现的，它们有效地插入内核来完成它们的工作。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/6226457d78bbdc06f562351f0dc44fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6t_G44PztGfD8k0qgJh5Cw.png"/></div></div></figure><p id="ac1b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从几个方面来看，微内核体系结构比单片系统更上一层楼。最主要的一点是这些插件在很大程度上是相互独立的。通常，插件不知道其他插件是如何工作的，或者其他插件是否存在。</p><p id="1e14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">插件也相对较小，易于编写、调试和维护，所以你不会有找不到东西的问题，也不会有系统复杂到你无法理解的问题。不利的一面是，内核本身，或者更准确地说，内核的API非常脆弱。<strong class="kc io">如果你需要对这些API进行必要的修改，所有的插件可能需要重新编写以使用新的API</strong>。</p><h1 id="c2ee" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">基于消息的架构:</h1><p id="312f" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">这种架构通过<strong class="kc io"> <em class="ky">形式化元素之间的通信路径并进一步隔离它们</em> </strong>将微内核的概念向前推进了一步。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/ff3bdb701ad6a0a159c558cfe71fa41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdKqp-UuYI3ixUl_k0KH4g.png"/></div></div></figure><p id="5e49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在基于消息的体系结构中，公共消息总线控制着通信流。每个应用程序都配备了一个所谓的适配器，它在一端与消息总线对话，在另一端与应用程序对话。</p><p id="dfda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在称为发布/订阅模型的另一种基于消息的体系结构模型中，</p><p id="3dc6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ky">发布者发布与特定主题相关的消息</em> </strong>。<strong class="kc io"> <em class="ky">订阅者可以订阅某个主题，并接收来自该主题任意发布者</em> </strong>的消息。</p><p id="2c30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于消息的架构允许系统的组件以极端的方式<strong class="kc io"><em class="ky"/></strong>隔离。每个组件实际上都是一个独立的小程序，可以独立于其他程序进行维护。那个<strong class="kc io"> <em class="ky">解耦使得你的系统比一个整体</em> </strong>更容易维护，并且它解决了微内核系统的依赖性问题。</p><p id="2db8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不利的一面是，消息传递系统很快变得高度复杂，管理这种复杂性非常困难。</p><h1 id="16a5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">微服务和微服务</h1><p id="91ac" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">在微服务架构中,<strong class="kc io">更大的系统由一群非常小的独立服务组成，这些服务以对等的方式合作完成更大的工作</strong>。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/c41e6eb5dc44b0d2fd8ba128358ed0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STXsgzJWzdIlvTfowLcdPA.png"/></div></div></figure><p id="344c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在讨论防御风暴的前一章中，您将把从该练习中出现的代理或实体实现为单独的微服务。这些服务可以分布在一个网络上，甚至是整个互联网上，冗余是内置的。例如，同一服务的许多实例可以并行运行。把这些东西放在一起，你会得到一个非常有弹性的系统，可以轻松处理你施加给它的任何压力。微服务不仅仅是微小的整体。它们必须以一种<strong class="kc io"> <em class="ky">支持分布式部署和复杂实时交互的方式来设计。</em> </strong></p><p id="8c93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">微服务应该是</p><ul class=""><li id="46ce" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated">可独立部署</li><li id="3c13" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">翻译成几百行源代码</li><li id="3723" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">以隐藏所有实现细节的方式编写</li><li id="9526" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">设计用于不可靠的网络环境</li><li id="a5e2" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">非常明显，他们记录他们做的每一件事。您可以实时监控它们的运行情况。所以如果服务失败了，你知道他们失败的原因。</li></ul><p id="9101" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您实现微服务时，主要的问题通常与服务如何相互通信有关。人们采取两种主要的方法。</p><p id="547e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一种方法是让每个服务成为一个小型的基于HTTP的web服务，您可以使用类似REST的协议与之对话。基于post的API的主要缺点是，它本质上是同步的，相当笨重，并且有几种难以解决的错误模式。</p><p id="c3d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二种方法是消息传递，而不是HTTP。</p><p id="f531" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">微服务有许多优势，特别是在敏捷环境中，您需要不断地对少量服务进行小的更改，并快速部署它们。</p><p id="729f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">微服务的主要缺点是设计和运行时都很复杂 。让多步操作在整个网络中可靠地工作是一件非常困难的工作。<strong class="kc io">微服还自带速度命中</strong>。与其他替代方案相比，网络只是速度较慢。</p><h1 id="043f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">反应式和精心设计的系统</h1><p id="23cd" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">在一个反应式的编排系统中，系统是发布事件而不是发出请求。它向全世界广播该事件，任何对该事件感兴趣的下游服务都可以做任何需要做的事情来处理该事件。</p><p id="b093" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">反应式和精心设计的系统比微服务架构更快。所有下游处理很容易并行完成，因此最坏情况下的延迟通常是最慢的下游处理的处理时间。</p><p id="136a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在这里讨论了一些架构模式，如果你想了解更多，你可以看看Grady Booch、Mark Richards、Simon Brown和Neal Ford的作品。</p><p id="9b56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a><em class="ky">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">免费周报</em> </strong> </a> <em class="ky">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">Twitter</em></strong></a><em class="ky">和</em><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">LinkedIn</em></strong></a><em class="ky">。加入我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">社区不和谐</em> </strong> </a> <em class="ky">。</em></p></div></div>    
</body>
</html>