<html>
<head>
<title>Understanding var, let, and const</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解var、let和const</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-var-let-and-const-67bcd6343fdc?source=collection_archive---------12-----------------------#2021-01-12">https://javascript.plainenglish.io/understanding-var-let-and-const-67bcd6343fdc?source=collection_archive---------12-----------------------#2021-01-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="66d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当你访问一个变量时，JavaScript使用一个叫做<em class="ki">范围</em> <strong class="jm io"> <em class="ki"> </em> </strong> <em class="ki">链</em>的东西来确定你引用的是哪个变量。</p><p id="00ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">作用域</em> <strong class="jm io"> <em class="ki"> </em> </strong> <em class="ki">链</em> <strong class="jm io"> <em class="ki"> </em> </strong>的工作方式是这样的，JavaScript开始在调用它的作用域中寻找变量，如果在那个作用域中找不到它，它就向上移动到下一级并在那里寻找，它一直这样做，直到找到全局空间，如果在全局作用域中找不到它，它就抛出一个错误。</p><p id="e8c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我认为ODB抓住了这一点，当他说<em class="ki">“你看，我的名字是你不会知道的，除非你在布鲁克林动物园”</em>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/d1c5abc81050d41f071a944206fdb7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*tdDh9mTE3mwoeDXK3JMZVg.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">R.I.P. Dirt McGirt</figcaption></figure><p id="c13b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你看，如果你是一个吴唐门迷(又名打倒布鲁克林动物园)你知道ODB，但如果你不听吴，你不会知道他的存在。这听起来很简单，对吗？它可能比听起来要复杂一点，让我们来看看一些代码。在下一节中，我将给出一些示例代码，解释代码中发生了什么，然后询问您代码将返回什么。我把单词<em class="ki">结果</em>放在答案前面，这样你就不会在猜测之前滚动太远看到答案。</p><p id="87fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们在全局空间中有一个变量叫做<strong class="jm io"><em class="ki">hiphop artists</em></strong>，它的值是一个hipHopArtists的数组。我们还有一个函数叫做<strong class="jm io"><em class="ki">getdownthezoo</em></strong>，在这个函数里面我们声明了另一个变量叫做<strong class="jm io"><em class="ki">hipHopArtists</em></strong>，它的值是一个Wu成员的数组。<strong class="jm io"><em class="ki">getdownthezoo</em></strong>也将<strong class="jm io"><em class="ki">hipHopArtists</em></strong>记录到控制台。在我们调用<strong class="jm io"><em class="ki">getdownthezoo</em></strong>的代码中，我们登录<strong class="jm io"><em class="ki">hipHopArtists</em></strong>，你认为这段代码会返回什么？让我们来看看。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="1bbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码是否返回了您所期望的结果？这里发生的事情是，我们在第8行<strong class="jm io"> <em class="ki"> </em> </strong>记录<strong class="jm io"> <em class="ki"> hipHopArtists </em> </strong>，因为有一个全局范围的变量叫做<strong class="jm io"><em class="ki">【hiphop artists</em></strong>我们得到下面的数组<em class="ki"> ["Snoop Dogg "、" Liff先生"、" Bus Driver "、" Devin the Dude"] </em>。然后，我们调用<strong class="jm io"><em class="ki">getDownWithTheZoo</em></strong>函数，该函数还记录了<strong class="jm io"><em class="ki">hipHopArtists</em></strong>，因为有一个名为<strong class="jm io"><em class="ki">hipHopArtists</em></strong>的函数作用域变量，我们得到下面的数组<em class="ki"> ["RZA "、" GZA "、" ODB "、" Inspectah Deck】]</em>。现在，让我们做一些改变，看看会发生什么。您希望下面的代码返回什么？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="27cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码是否返回了您所期望的结果？这里发生的事情是，我们记录了<strong class="jm io"><em class="ki">hipHopArtists</em></strong>，由于有一个名为<strong class="jm io"><em class="ki">hipHopArtists</em></strong>的全局变量，我们得到了下面的数组<em class="ki"> ["Snoop Dogg "、" Liff先生"、" Bus Driver "、" Devin the Dude"] </em>。然后，我们调用<strong class="jm io"><em class="ki">get down with thezoo</em></strong>函数，该函数记录了<strong class="jm io"><em class="ki">brooklynzoartists</em></strong>和<strong class="jm io"><em class="ki">hipHopArtists</em></strong>，由于有一个名为<strong class="jm io"><em class="ki">brooklynzoartists</em></strong>的函数作用域变量，我们得到下面的数组<em class="ki"> ["RZA】，" GZA "，" ODB "，" inspecthak Deck "]</em>。接下来，我们记录<strong class="jm io"><em class="ki">hiphop artists</em></strong>并且由于在函数作用域中没有名为<strong class="jm io"><em class="ki">hiphop artists</em></strong>的变量，JavaScript沿着<strong class="jm io"> <em class="ki">作用域链</em> </strong>向上移动到全局空间，并且在那里找到一个名为<strong class="jm io"><em class="ki">hiphop artists</em></strong>的变量，并且记录<em class="ki"> ["Snoop Dogg "，"让我们再做一些改变，看看会发生什么。您希望下面的代码返回什么？</em></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="e2ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码是否返回了您所期望的结果？所以这里发生的是我们console . log<strong class="jm io"><em class="ki">hiphop artists</em></strong>并且因为有一个全局范围的变量叫做<strong class="jm io"> <em class="ki"> hipHopArtists </em> </strong>我们得到下面的数组<em class="ki"> ["Snoop Dogg "，" Liff先生"，" Bus Driver "，" Devin the Dude"] </em>。然后，我们调用<strong class="jm io"><em class="ki">get down with thezoo</em></strong>函数，该函数记录<strong class="jm io"><em class="ki">brooklynzoartists</em></strong>和<strong class="jm io"><em class="ki">hipHopArtists</em></strong>，由于有一个函数作用域变量叫做<strong class="jm io"><em class="ki">brooklynzoartists</em></strong>，我们得到下面的数组<em class="ki"> ["RZA】、" GZA "、" ODB "、" inspecthak Deck "]</em>。接下来，我们记录下<strong class="jm io"><em class="ki">hiphop artists</em></strong>，由于在函数作用域中没有名为<strong class="jm io"><em class="ki">hiphop artists</em></strong>的变量，JavaScript沿着“作用域链”向上移动到全局空间，在那里找到名为<strong class="jm io"><em class="ki">hiphop artists</em></strong>的变量，并记录下<em class="ki"> ["Snoop Dogg "、" Liff先生"、" Bus Driver "、" Devin the Dude"] </em>。然后我们调用<strong class="jm io"> <em class="ki"> getHorror </em> </strong>函数，该函数有一个变量<strong class="jm io"><em class="ki">horrorcorealtors</em></strong>，该变量记录了<strong class="jm io"><em class="ki">hipHopArtists</em></strong>。由于在<strong class="jm io"><em class="ki">get horror<strong class="jm io"><em class="ki">作用域链</em> </strong>中没有名为<em class="ki"> hipHopArtists </em> </em></strong>的变量，并且由于没有名为<strong class="jm io"><em class="ki">hipHopArtists</em></strong>的变量●不料在全局空间中有一个名为<strong class="jm io"> <em class="ki">的变量hipHopArtist </em> </strong>和<em class="ki"> ["Snoop Dogg "、" Mr. Liff "、" Bus Driver "、" Devin the Dude"] </em>被登录到控制台。好了，现在我们知道了<strong class="jm io"> <em class="ki">作用域链</em> </strong>是如何工作的，让我们来看看<em class="ki"> var </em>、<em class="ki"> let和const </em>之间的区别。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/8de6769c1a9e870814f4dafafd8f158a.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*xM7epGxwpUqisCE7b1KwrA.jpeg"/></div></figure><p id="c613" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在谈论<em class="ki"> var </em>、<em class="ki"> let </em>、<em class="ki"> const </em>时，我们首先需要覆盖的是<em class="ki">block</em><strong class="jm io"><em class="ki"/></strong><em class="ki">范围</em>。所以你可能听说过全局作用域和函数作用域，但是什么是块作用域呢？块作用域是当你在一个<em class="ki">代码</em> <strong class="jm io"> <em class="ki"> </em> </strong> <em class="ki">块</em>中包含一个变量时，就像一个for循环或者一个条件语句(if语句)。如果你看一下下面的代码，你会看到一个变量<strong class="jm io"> <em class="ki"> i </em> </strong>那就是for循环里面的<em class="ki">块</em> <strong class="jm io"> <em class="ki"> </em> </strong> <em class="ki">作用域</em> <strong class="jm io"> <em class="ki"> </em> </strong>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="409c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们知道了什么是block scope，下面就来说说<em class="ki"> var </em>、<em class="ki"> let </em>和<em class="ki"> const </em>的区别。关于<em class="ki"> var </em>要记住的最重要的事情是它不能是块范围的。看看下面的代码片段，你认为控制台会记录什么？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="cbc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码记录了您所期望的吗？发生了什么事？所以当我们运行第一个日志时，我们得到<strong class="jm io"> <em class="ki"> 11 </em> </strong>，因为<strong class="jm io"> <em class="ki"> i </em> </strong>在全局空间中被定义为<strong class="jm io"> <em class="ki"> 11 </em> </strong>。接下来，我们将<strong class="jm io"> <em class="ki"> i </em> </strong>定义为for循环内部的<strong class="jm io"><em class="ki">【0】</em></strong>，但是由于<em class="ki"> var </em>不能被<em class="ki"> block作用域</em> <strong class="jm io"> <em class="ki"> i </em> </strong>泄漏到全局空间中，所以现在<strong class="jm io"> <em class="ki"> i </em> </strong>在全局空间中的值为<strong class="jm io"> <em class="ki"> 0 </em> </strong>。当我们运行for循环中的第二个日志时，在名为<strong class="jm io"><em class="ki"/></strong>的<em class="ki">块作用域</em>中没有<em class="ki">变量</em>，因为它泄漏到了全局空间中，所以JavaScript将作用域链向上移动到全局空间并返回<strong class="jm io"> <em class="ki"> i </em> </strong>，它现在的值为<strong class="jm io"> <em class="ki"> 0 </em> </strong>。每当<strong class="jm io"> <em class="ki"> i </em> </strong>递增，直到<strong class="jm io"> <em class="ki"> i </em> </strong>的值为<strong class="jm io"> <em class="ki"> 10 </em> </strong>并且for循环停止时，都会发生这种情况。然后我们移动到第三个日志，它记录了全局空间中的<strong class="jm io"> <em class="ki"> i </em> </strong>，其值为<strong class="jm io"> <em class="ki"> 10 </em> </strong>，因为这是for循环停止的地方。让我们来看看当我们将for循环中的<strong class="jm io"> <em class="ki"> var </em> </strong>改为<strong class="jm io"> <em class="ki"> let </em> </strong>时会发生什么。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="e3ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，结果非常不同。那是因为let可以是<em class="ki">块范围的</em>，意味着有一个变量<strong class="jm io"> <em class="ki"> i </em> </strong>存在于<em class="ki">全局范围</em>中，还有一个存在于for循环内部。因此，第一个日志引用全局范围中定义的<strong class="jm io"> <em class="ki"> i </em> </strong>，第二个日志引用<em class="ki">块范围</em>中的<strong class="jm io"> <em class="ki"> i </em> </strong>，递增到<strong class="jm io"> <em class="ki"> 10 </em> </strong>，第三个日志引用回<em class="ki">全局空间</em>中存在的<strong class="jm io"> <em class="ki"> i </em> </strong>。这里重要的一点是<em class="ki"> let </em>关键字可以是<em class="ki">全局</em>、<em class="ki">功能</em>或块范围的，而<em class="ki"> var </em>只能是<em class="ki">功能</em>或<em class="ki">全局</em>范围的。好了，现在我们明白了<em class="ki"> var </em>和<em class="ki"> let </em>的区别，让我们来讨论一下<em class="ki"> const </em>。看看下面的代码，你认为在这个实例中控制台会记录什么？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="da0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">啊哦，我们有一个错误。你认为这是为什么？<em class="ki"> const </em>关键字和<em class="ki"> let </em>关键字很像，都可以是<em class="ki">全局</em>功能和<em class="ki"> block </em>作用域<em class="ki"/>。但是有一个非常重要的区别，用<em class="ki"> const </em>声明的变量的值不能被重新赋值，所以当我们试图在for循环中增加<strong class="jm io"> <em class="ki"> i </em> </strong>的值时，我们会得到一个错误，因为我们不能将<strong class="jm io"> <em class="ki"> i </em> </strong>的值从<strong class="jm io"> <em class="ki"> 0 </em> </strong>更改为<strong class="jm io"> <em class="ki"> 1这可能有点令人困惑，因为用<em class="ki"> const </em>声明的变量不能被重新赋值，但其值可能会发生变异。看一下下面的代码来看一个例子。</em></strong></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="00a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，当我们将100加到<strong class="jm io"> <em class="ki"> i </em> </strong>然后记录它时，<strong class="jm io"> <em class="ki"> i </em> </strong>的值仍然是<strong class="jm io"> <em class="ki"> 11。</em> </strong>那是因为<strong class="jm io"> <em class="ki"> i </em> </strong>的值不能被重新赋值。但是，我们将<strong class="jm io"> <em class="ki">独眼巨人</em> </strong>赋给一个空数组的值，然后我们推送<em class="ki">我是变种人</em>的字符串，当我们登录<strong class="jm io"> <em class="ki">独眼巨人</em> </strong>我们得到下面的值<em class="ki"> ['我是变种人'] </em>。那是因为<strong class="jm io"> <em class="ki">独眼巨人</em> </strong>还是同一个数组，所以我们没有重新分配<strong class="jm io"> <em class="ki">独眼巨人</em> </strong>的值，我们只是通过添加“<em class="ki">我是</em> <em class="ki">变异体</em>”的字符串对数组进行了变异。我喜欢这样想，如果你从你最喜欢的当地披萨店订购了一份黑橄榄披萨，但他们忘记在你的披萨上放橄榄，你可以把你的披萨拿回去，他们可以添加黑橄榄，然后把它放回烤箱几分钟，然后还给你。</p><p id="9daf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以基本上他们只是变异了你的披萨，但是如果你点了一份黑橄榄披萨，他们却意外地给了你鸡翅，那就没办法把你的鸡翅变异成披萨了。所以他们必须做一个全新的披萨。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/234a1d268a5c192f2df1b1e54b1b7662.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*TlEBzrdmrpXDUHDtpoFpiQ.jpeg"/></div></figure><p id="9fb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，现在我们知道了<em class="ki"> var </em>、<em class="ki"> let </em>和<em class="ki"> const </em>之间的区别，我们还有一个令人困惑的话题要在本文中讨论。还记得我们谈论JavaScript解释器时，我说过在创建阶段解释器会检查代码，找到所有的函数和变量，并为它们节省空间吗？该过程被解释人员称为<strong class="jm io"> <em class="ki">提升</em> </strong>，井<em class="ki">让</em>和<em class="ki">保持</em>不被<em class="ki">提升</em>。这意味着在执行阶段，直到解释器到达它们，它们才被定义。看看下面的例子，你认为控制台会记录什么？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="9858" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是起重发挥作用的地方。当JavaScript解释器进入创建阶段时，它会看到<em class="ki"> var </em>关键字，并在内存中为变量<em class="ki"> thing1 </em>节省空间，它还没有定义，但已经为它留出了空间。然后当它进入执行阶段时，<em class="ki"> thing1 </em>被记录到控制台，因为它直到被调用后才被赋值，未定义的被记录到控制台。由于<em class="ki"> let </em>和<em class="ki"> const </em>关键字没有<em class="ki">提升</em>，JavaScript解释器在创建阶段忽略它们。</p><p id="f2aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，当我们进入执行阶段并尝试将<em class="ki"> thing2 </em>记录到控制台时，我们会得到以下错误:<strong class="jm io"> <em class="ki"> ReferenceError:无法在初始化</em> </strong>之前访问thing2，因为JavaScript解释器不知道<em class="ki"> thing2 </em>的存在。吊装有点像去唱片店购买最新的吴唐专辑，唱片店还没有收到他们的货物，他们知道它的存在，他们只是没有库存。</p><p id="bcf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">让</em>和c <em class="ki"> onst </em>不要被吊起来，这样就像去唱片店买一张还没有创作出来的武堂专辑，他们会告诉你，你要找的东西不存在。</p><h2 id="f348" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">结论</h2><p id="790c" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">我希望这篇文章有助于阐明作用域、作用域链以及<em class="ki"> var </em>、<em class="ki"> let </em>和<em class="ki"> const </em>之间的区别。这些可能是非常令人困惑的话题，事实上，在写这篇文章的时候，我发现我并没有像我想象的那样理解这些概念。我发现花些时间修补你自己的代码将有助于巩固这些概念。我希望这篇文章对您有所帮助；如果你有任何你希望我在未来涉及的话题，请在评论中提出。</p></div></div>    
</body>
</html>