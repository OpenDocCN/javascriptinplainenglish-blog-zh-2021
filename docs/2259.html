<html>
<head>
<title>Learn to use React Query for Server-State Data Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习使用React Query进行服务器状态数据管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learn-to-use-react-query-for-server-state-data-management-abb4acf0694e?source=collection_archive---------12-----------------------#2021-05-11">https://javascript.plainenglish.io/learn-to-use-react-query-for-server-state-data-management-abb4acf0694e?source=collection_archive---------12-----------------------#2021-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="202e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React的下一件大事。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/da153db43f7ebf813faaa65edc849b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L9R6b0SXtTdE3PDN"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8e63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用预配置的React查询库恢复您对服务器状态数据同步的信心。看看如何使用本教程中介绍的简单自动化挂钩将获取、缓存和更新逻辑变成几行容易理解的代码。</p><h1 id="9372" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">为什么它是下一个大事件？</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/cf6b56df1dec7ffb17c3dce52a0aab57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*51ZVq3gbsJWxVq4i"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@karsten116?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Karsten Winegeart</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1528" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是React缺少的部分，有助于服务器状态数据管理。忘记把一切都保持在一个标准的全局状态，因为大多数库只是为了处理客户机状态而创建的，而服务器状态是完全不同的。</p><p id="1a59" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">服务器数据是异步的。由于它没有存储在你的应用程序中，它可能会在一瞬间过时。所以你应该想出一个建立缓存的方法。坏消息是，这是编程中最难的事情之一。但是好消息是React Query可以处理您的获取、缓存、同步和更新服务器状态。</p><h1 id="d0ae" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">为什么用React Query开始一个项目很酷？</h1><p id="1361" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">一行程序时间——它将把你的应用程序带到一个新的水平。但是真的，考虑下面的例子。</p><h1 id="1c0b" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">React查询的主要优势</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/42f47a210a6ff0586359e7be14ad02d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KXR4ez6ulQnerEfg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@mattartz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Artz</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><ul class=""><li id="47a1" class="mo mp in kv b kw kx kz la lc mq lg mr lk ms lo mt mu mv mw bi translated">窗口焦点重新提取——当用户离开你的应用选项卡时，React Query会将数据标记为“陈旧”,并在用户返回时重新提取。</li><li id="a377" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">请求重试-您可以为任何请求设置重试次数，以防止随机错误。</li><li id="f873" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">预取-如果您的应用程序在更新请求后需要新数据，您可以使用特定的键预取查询，React Query将在后台更新它。</li><li id="2ebe" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">乐观更新——当您编辑或删除列表中的项目时，您可以发布列表的乐观更新。</li></ul><h1 id="4094" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">启动React查询引擎</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/5f491a70ca6783534169689df7f95b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2HtLdF8EbECodaC8"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@kasparseglitis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kaspars Eglitis</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3266" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是基本配置。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="949f" class="ni lq in ne b gy nj nk l nl nm">import { QueryClient, QueryClientProvider } from 'react-query' const queryClient = new QueryClient() &lt;QueryClientProvider client={queryClient}&gt;  &lt;App /&gt;&lt;/QueryClientProvider&gt;</span></pre><p id="fd12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我们有一个基本的<code class="fe nn no np ne b">axios</code>函数，它为我们的文章返回数据。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="1203" class="ni lq in ne b gy nj nk l nl nm">async function createFetchArticles() {  <br/> const { data } = await axios.get('/api/articles')  <br/> return data<br/>}</span><span id="1fb3" class="ni lq in ne b gy nq nk l nl nm">import React from 'react'<br/>import { useQuery } from 'react-query' <br/>export const Articles = () =&gt; {  <br/>const { data, error, isError, isLoading } = useQuery(['articles'], createFetchArticles)   <br/>if (isLoading) {    <br/> return &lt;span&gt;Loading...&lt;/span&gt;  <br/>}   <br/>if (isError) {    <br/> return &lt;span&gt;Error: {error.message}&lt;/span&gt;  <br/>}   <br/>return (    &lt;ul&gt;      {data.map(article =&gt; (        &lt;li key={article.id}&gt;{article.title}&lt;/li&gt;      ))}    &lt;/ul&gt;  )<br/>}</span></pre><h1 id="834b" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">抓取现在更好了</h1><p id="26ae" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">为什么它比使用<code class="fe nn no np ne b">useEffect</code>模式的普通抓取要好？当您使用带有相同的<code class="fe nn no np ne b">projects</code>键的查询时，React Query首先返回以前获取的数据，然后再次获取它。</p><p id="797e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当第二个数据集与第一个数据集相同时，React Query将两个数据集都作为引用，而不强制重载。这是UX工作的巨大进步。</p><h1 id="072c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">更新挂钩如何工作</h1><p id="3319" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">因此您知道如何更容易地获取数据。我们来看看怎么更新吧。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="85b2" class="ni lq in ne b gy nj nk l nl nm">async function createPostArticle(id) {  <br/>await axios.post(`/api/article/${id}`)<br/>} <br/>export const AddArticle = () =&gt; {  <br/>const [title, setTitle] = React.useState('')  <br/>const {isLoading, isError, error, mutate} = useMutation(createPostArticle)   <br/>return (    &lt;div&gt;      &lt;input        value={title}        onChange={(e) =&gt; setTitle(e.target.value)}        disabled={isLoading}      /&gt;      &lt;button        onClick={() =&gt; {          mutate({ title })        }}        disabled={isLoading || !title}      &gt;        Add Article      &lt;/button&gt;      &lt;div&gt;        {isLoading          ? "Saving..."          : isError          ? error.message          : "Saved!"}      &lt;/div&gt;    &lt;/div&gt;  )<br/>}</span></pre><p id="82dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React Query有一个<code class="fe nn no np ne b">useMutation</code>钩子，可以用来更新/创建/删除数据。<code class="fe nn no np ne b">useMutation</code>让你可以访问mutate函数，我们可以向它传递必要的参数。然后，它返回关于API调用状态的信息。状态可以是:</p><ul class=""><li id="c320" class="mo mp in kv b kw kx kz la lc mq lg mr lk ms lo mt mu mv mw bi translated"><code class="fe nn no np ne b">idle</code>为空闲或刷新/复位状态</li><li id="dce2" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated"><code class="fe nn no np ne b">loading</code>对于当前正在运行的突变</li><li id="6879" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated"><code class="fe nn no np ne b">error</code>当我们遇到一个</li><li id="0b7f" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">当一切正常且我们的数据可用时</li></ul></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="2c8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以从status变量中访问状态信息，或者对于那些喜欢布尔状态的人来说，可以通过以下变量访问它们。</p><ul class=""><li id="2863" class="mo mp in kv b kw kx kz la lc mq lg mr lk ms lo mt mu mv mw bi translated"><code class="fe nn no np ne b">isIdle</code></li><li id="a07a" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated"><code class="fe nn no np ne b">isLoading</code></li><li id="2adf" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated"><code class="fe nn no np ne b">isError</code></li><li id="063f" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated"><code class="fe nn no np ne b">isSuccess</code></li></ul><p id="7efb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如你所见，超级好用。由于有更多的选项可以传递给<code class="fe nn no np ne b">useMutation</code>，React Query可以成为您最强大的开发工具之一。</p><h1 id="3551" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">这才是真正的力量</h1><p id="9459" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">当设备在发送数据时离线一会儿会发生什么？React Query有一个解决方案！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/c6547c341cd7befdc49d4655a405d4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mCz6t-9p3fuMND9b"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@courtniebt13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Courtnie Tosana</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="90ed" class="ni lq in bd lr nz oa dn lv ob oc dp lz lc od oe mb lg of og md lk oh oi mf oj bi translated">使用请求重试</h2><p id="e6e4" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">您可以通过<code class="fe nn no np ne b">retry</code>选项传递重新连接后查询应该重试变异的次数。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="87f6" class="ni lq in ne b gy nj nk l nl nm">const mutation = useMutation(addArticle, { retry: 3 })</span></pre><h1 id="d947" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">摘要</h1><p id="e94c" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">React Query确实帮助我们解决了异步数据处理的问题。生活曾经更艰难。开发人员需要一堆其他库，他们最终会将服务器数据放入一个全局存储中。不是个好主意。为什么？正如我前面提到的，将异步服务器数据保存在全局存储中给我们的代码增加了不必要的复杂性。</p><p id="d664" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有更多。该查询还有助于减少样板代码的数量(比如将每次提取保存在<code class="fe nn no np ne b">useEffect</code>钩子中)。如果使用得当，它会改善用户体验，但也会破坏用户体验。所以要小心，先试着去了解这个库。</p><p id="3291" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ok">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ok">plain English . io</em></a></p></div></div>    
</body>
</html>