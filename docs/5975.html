<html>
<head>
<title>React Hooks: The Ultimate Guide (useCallback/useMemo)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks:终极指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hooks-the-ultimate-guide-usecallback-usememo-d68516b0767c?source=collection_archive---------4-----------------------#2021-12-22">https://javascript.plainenglish.io/react-hooks-the-ultimate-guide-usecallback-usememo-d68516b0767c?source=collection_archive---------4-----------------------#2021-12-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="36ca" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">反应钩的最终指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ca594765c6375bde3e6cc2591d404121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gh6tINpRzXFcrHM0"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a630" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大多数人在使用React.js时都担心性能问题。React是惊人的，如果使用得当，当状态改变时，你应该不会有重新渲染的问题。但是正如我们在本系列的第一部分开始所说的，我们不仅需要使用<code class="fe lp lq lr ls b">useState</code>和<code class="fe lp lq lr ls b">useEffect</code>来管理状态，还需要使用我们将在这里看到的其他钩子。</p><p id="de17" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，让我们了解记忆化的概念以及我们为什么需要记忆化。</p><h2 id="f80e" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">记忆化</h2><blockquote class="mm mn mo"><p id="4831" class="kt ku mp kv b kw kx jo ky kz la jr lb mq ld le lf mr lh li lj ms ll lm ln lo ig bi translated">在计算中，记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。</p></blockquote><p id="8cbf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">记忆化的思想是保存函数的返回值或函数本身，如果发送给它的值没有改变，就不要重新运行它。</p><h2 id="2855" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">了解JavaScript相等检查</h2><p id="5d0d" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">JavaScript中的函数是一等公民，这意味着函数是常规对象。函数对象可以像对象一样被其他函数返回，进行比较等。</p><p id="3daf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是如果我们有一个函数，运行它两次，设置它为两个不同的变量并比较它(如下)，这将返回<code class="fe lp lq lr ls b">false</code>，我们将相同的逻辑应用于对象</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="44df" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">使用回调</h2><p id="dd10" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">所以<code class="fe lp lq lr ls b">useCallback</code>的目标是避免不必要的重新渲染，它接收两个值:一个将被记忆的函数和一个每次任何值改变时都将更新该函数的依赖数组。因此，要解决上一篇文章中的小问题，我们可以这样做:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="bfb8" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated"><strong class="ak">使用备忘录</strong></h2><p id="bd8b" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">钩子<code class="fe lp lq lr ls b">useMemo</code>接收两个参数:一个计算并返回一个值的函数和一个依赖数组(比如<code class="fe lp lq lr ls b">useCallback</code>)。当我们有一些基于道具的计算时(比如下面的例子)，或者当我们想用发送的道具记忆一个组件时，通常使用这个钩子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="bc6b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很简单，对吧？</p><h2 id="b7b1" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">useMemo vs useCallback</h2><p id="2ccd" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">这两个钩子在react组件中有相同的目标，那就是记忆值，最大的区别是要记忆的值的类型。<code class="fe lp lq lr ls b">useCallback</code>返回一个内存化的回调，<code class="fe lp lq lr ls b">useMemo</code>返回一个内存化的值，但是这是什么意思呢？</p><p id="9309" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe lp lq lr ls b">useMemo</code>中，将运行函数(第一个参数), React将记忆从该函数返回的值(每次依赖关系数组改变时),在<code class="fe lp lq lr ls b">useCallback</code>中，每次依赖关系数组改变时返回其函数uncalled，因此您可以稍后调用它(或不调用)。</p><p id="61db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你有一些大的计算或者一些需要花费一些时间在函数中计算的东西，你应该使用<code class="fe lp lq lr ls b">useMemo</code>,这样这个计算只有在依赖关系改变的时候才会发生。</p><p id="f434" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">将道具向下传递到子组件</strong></p><p id="440a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">useCallback</code>和<code class="fe lp lq lr ls b">useMemo</code>真正有用的一点是在传递值给子组件的时候。假设你想传递一个函数和一个值给你的子组件，你想避免不必要的重新渲染。如果您传递函数和值本身，而没有将它包装在一个<code class="fe lp lq lr ls b">useCallback</code>和<code class="fe lp lq lr ls b">useMemo</code>中，它将重新呈现，即使函数本身没有改变(还记得JavaScript等式检查吗？).</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="e3e7" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated"><strong class="ak">什么时候不用它</strong></h2><p id="0c0a" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">在现实生活中，没有什么是防弹的，所以即使是那些在某些情况下提高性能的挂钩也会降低你的应用程序的速度。</p><blockquote class="mm mn mo"><p id="fd9b" class="kt ku mp kv b kw kx jo ky kz la jr lb mq ld le lf mr lh li lj ms ll lm ln lo ig bi translated">性能优化不是免费的。它们总是伴随着成本，但并不总是伴随着抵消成本的收益。</p></blockquote><p id="f2b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要使内存化工作，需要处理这些数据，计算并保存它们(处理垃圾收集器等)。我的观点是，只有在以下情况下才应该使用这些挂钩:</p><ul class=""><li id="9147" class="na nb in kv b kw kx kz la lc nc lg nd lk ne lo nf ng nh ni bi translated">你有一些计算将是计算昂贵的</li><li id="32cc" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">当你需要比较它的时候(比如把一个函数传递给一个子组件)</li></ul><h2 id="c2a6" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated"><strong class="ak">结论</strong></h2><p id="d97f" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">当谈到React应用程序时，性能非常重要，当处理复杂情况或计算或真正的大数据时，这些钩子将会给你很大帮助。</p><p id="ea11" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望有帮助。如果我遗漏了什么或者有什么要补充的，请留下评论，我会编辑帖子！</p><p id="98d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">干杯！</p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><div class="kd ke kf kg gt nv"><a href="https://en.wikipedia.org/wiki/Memoization" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">记忆化-维基百科</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在计算中，优化或记忆是一种优化技术，主要用于通过…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">en.wikipedia.org</p></div></div><div class="oe l"><div class="of l og oh oi oe oj km nv"/></div></div></a></div><p id="9012" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://reactjs.org/docs/hooks-faq.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-faq.html</a></p><p id="636f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://kentcdodds.com/blog/usememo-and-usecallback" rel="noopener ugc nofollow" target="_blank">https://kentcdodds.com/blog/usememo-and-usecallback</a></p><p id="b68d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://pt-br.reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usecallback</a></p><p id="65a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mp">更多内容看</em> <a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">说白了. io </em> </a> <em class="mp">。在这里注册我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">免费周报</em> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>