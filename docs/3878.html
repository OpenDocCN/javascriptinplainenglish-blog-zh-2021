<html>
<head>
<title>Features of Node.js Clean Code Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js干净代码架构的特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/features-of-node-js-clean-code-architecture-569cc396479f?source=collection_archive---------2-----------------------#2021-08-04">https://javascript.plainenglish.io/features-of-node-js-clean-code-architecture-569cc396479f?source=collection_archive---------2-----------------------#2021-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6e0f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使我们的代码能够适应时间的变化</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ed9c69497885b035c98d7c30052d5bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddura25okCbtOt9PsKfv9Q.jpeg"/></div></div></figure><h1 id="f588" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">建筑简介</h1><p id="d4e7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">软件体系结构主要是在一个有目的和有效的系统中安排的软件组件的结构。软件架构的目标是最小化构建和维护软件系统所需的人力。软件开发周期中最耗费精力的过程之一是适应变化。在软件开发中，处理系统变更的主要方法是在软件的各层之间创建关注点的分离。这就是罗伯特·塞西尔·马丁创造的干净代码架构大放异彩的地方。</p><p id="9b5f" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">以下是使用来自节点应用程序的代码片段实现干净的代码架构的好处。</p><h1 id="ed6c" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">框架独立性</h1><p id="1925" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">使用框架进行大量操作很容易使我们的代码严重依赖我们正在使用的框架。在我们的代码和底层框架之间创建一个紧密的耦合会导致将来改变框架的困难。例如，如果你想从“快递”移动到“风帆”</p><p id="0c1d" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">要解决这个问题:</p><ol class=""><li id="adbc" class="mi mj in li b lj md lm me lp mk lt ml lx mm mb mn mo mp mq bi translated">我们尽可能地限制我们在框架上的可靠性。</li><li id="d233" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">我们通过在框架和项目代码之间使用一个<em class="mw">适配器设计模式</em>来做到这一点。</li><li id="eb7e" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">同样的方法也用于修改响应对象。</li></ol><p id="82ce" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">在MERN堆栈应用中，我们创建了一个adaptRequest()函数，作为express框架和应用代码(即{内层代码})之间的<em class="mw">中间适配器</em>。请查看我下面的示例片段。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Parsing framework’s req/res object to a common req/res object</figcaption></figure><h1 id="1915" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">独立于数据库</h1><p id="52a5" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">我们使用类似的适配器设计模式使您的代码{在内层}独立于我们正在使用的数据库。</p><p id="0ade" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">基本上，我们可以创建一个包含所有通用数据库操作的DB服务接口。然后为我们希望在您的项目中使用的每种类型的数据库实现一个DB服务。举个例子，假设我们需要在一个项目中使用多个异构数据库(比如DynamoDB和MongoDB ),我们将为我们正在使用的每个数据库创建Db服务，并简单地将Db服务(DynamoDbService.js)作为依赖注入传递给需要在该数据库(DynamoDB)上执行操作的服务(比如FileUploadService.js)。</p><p id="fe5f" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">您可以通过将dbConnectionInstance作为DB服务的依赖项来传递，从而更进一步。从而使您能够通过简单地更改dbConnectionInstance，在项目中建立/切换DB连接。<br/> <em class="mw">(我们建议只有当您必须从一个应用程序连接到多个数据库实例时才这样做。)</em></p><h1 id="370d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">避免因第三方库而导致的重大变更</h1><ol class=""><li id="a238" class="mi mj in li b lj lk lm ln lp nd lt ne lx nf mb mn mo mp mq bi translated">第三方库通常是开发周期较长的项目中变更的原因。</li><li id="508c" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">从找到一个更好的替代库到升级现有库的所有过程都可能导致代码被更改，并经常破坏代码。</li><li id="f8b9" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">同样，我们的适配器设计模式可以在这里实现，以解决这个问题。</li><li id="387c" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">我们只需创建一个服务(比如ThirdPartyLib.js ),并在其中导入第三方库，用您自己的函数包装第三方函数，并在必要时添加任何额外的逻辑。然后在任何我们需要使用第三方方法的地方使用这个库。</li></ol><h1 id="5a2f" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">依赖注入</h1><p id="b5cc" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">依赖注入，依赖注入，依赖注入——您可能已经听过这个词很多次了。但是什么是依赖注射呢？</p><p id="69c1" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">“依赖注入”是一个25美元的术语，表示一个5美分的概念……依赖注入意味着给一个对象它的实例变量。真的。就这样。— <a class="ae mc" href="http://jamesshore.com/v2/blog/2006/dependency-injection-demystified" rel="noopener ugc nofollow" target="_blank"> [3] </a></p><p id="e7c8" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">为什么我们首先要使用依赖注入？</p><ol class=""><li id="cbbc" class="mi mj in li b lj md lm me lp mk lt ml lx mm mb mn mo mp mq bi translated">创建可测试性<br/>依赖注入是一种非常有用的测试技术，因为它允许依赖被嘲笑或剔除。<a class="ae mc" href="https://stackoverflow.com/questions/130794/what-is-dependency-injection" rel="noopener ugc nofollow" target="_blank">【4】</a></li><li id="d7f5" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">实现松散耦合<br/>松散耦合的明显好处在于，它提供了在不修改底层业务逻辑的情况下改变依赖关系的灵活性。这为我们提供了更大的能力，在开发和测试过程中尝试新的替代方法，而不用冒内层代码改变的风险。</li></ol><h1 id="4ee9" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">创建干净的代码样板</h1><p id="3ef5" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">尽管使用干净的代码架构创建项目有很多好处，但是创建样板代码一直是一项艰巨的任务。您在网上获取的示例代码对学习非常有用；然而，创建一个真实的应用程序与它有很大的不同。一个简单的方法是使用一个新的在线代码生成平台<a class="ae mc" href="https://hubs.la/H0TFtyP0" rel="noopener ugc nofollow" target="_blank"> DhiWise </a>。</p><p id="d987" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">您可以使用表格视图添加模型，单击构建应用程序，从组合框中选择干净的代码架构，然后嘣！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/530ecbef01e792d56c7bf0875f021ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbI2hH15ZNZIE9mCPBMwiw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">You can view the generated application’s code online or dl the source code.</figcaption></figure><h1 id="2809" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">文献学</h1><ol class=""><li id="8486" class="mi mj in li b lj lk lm ln lp nd lt ne lx nf mb mn mo mp mq bi translated"><a class="ae mc" href="https://www.youtube.com/watch?v=7EmboKQH8lM" rel="noopener ugc nofollow" target="_blank">清洁代码-鲍勃叔叔系列讲座</a></li><li id="e169" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><a class="ae mc" href="https://github.com/dev-mastery/comments-api" rel="noopener ugc nofollow" target="_blank">开发人员掌握的干净代码架构演示</a></li><li id="55e1" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><a class="ae mc" href="https://github.com/howardmann/clean-node" rel="noopener ugc nofollow" target="_blank"> Howardamann的干净代码演示应用程序</a></li><li id="d7c2" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><a class="ae mc" href="https://www.jamesshore.com/v2/blog/2006/dependency-injection-demystified" rel="noopener ugc nofollow" target="_blank">依赖性注射液去神秘化</a></li><li id="5f85" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">罗伯特·马丁(鲍勃大叔)的干净代码博客</li><li id="f940" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><a class="ae mc" href="https://stackoverflow.com/questions/130794/what-is-dependency-injection" rel="noopener ugc nofollow" target="_blank">关于DI溢出栈溢出的讨论</a></li><li id="3def" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><a class="ae mc" href="https://hubs.la/H0T7djs0" rel="noopener ugc nofollow" target="_blank"> Dhiwise-pro代码平台</a></li></ol></div></div>    
</body>
</html>