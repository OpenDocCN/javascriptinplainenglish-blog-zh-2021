<html>
<head>
<title>JavaScript: Equal !== Equality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:相等！==平等</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-equal-equality-54d2d8dc70bc?source=collection_archive---------16-----------------------#2021-03-15">https://javascript.plainenglish.io/javascript-equal-equality-54d2d8dc70bc?source=collection_archive---------16-----------------------#2021-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fc157887d98ebe40269b5f39f646ab6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64FUlr93FoDiUsWmzSazRA.png"/></div></div></figure><p id="1217" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天的意识流博客将我带进了JavaScript兔子洞，这是我在最近几篇博客中陷入的主题。毫不奇怪，JavaScript包含多种等式。根据MDN关于<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" rel="noopener ugc nofollow" target="_blank">平等性比较和相同性</a>的文件:</p><blockquote class="ku kv kw"><p id="0ad7" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">ES2015中有四种等式算法:</p><p id="1842" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">-抽象相等比较(<code class="fe lb lc ld le b">==</code> ) <br/> -严格相等比较(<code class="fe lb lc ld le b">===</code>):由<code class="fe lb lc ld le b">Array.prototype.indexOf</code>、<code class="fe lb lc ld le b">Array.prototype.lastIndexOf</code>、<code class="fe lb lc ld le b">case</code>使用-匹配<br/> - SameValueZero:由<code class="fe lb lc ld le b">%TypedArray%</code>和<code class="fe lb lc ld le b">ArrayBuffer</code>构造函数使用，以及<code class="fe lb lc ld le b">Map</code>和<code class="fe lb lc ld le b">Set</code>操作，以及从ES2016 <br/>开始的<code class="fe lb lc ld le b">String.prototype.includes </code>和<code class="fe lb lc ld le b">Array.prototype.includes</code>-same value:在所有其他地方使用</p></blockquote><p id="d75c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这很好，但我真正想说的是我们调用这些等式算法的不同方式。更具体地说，我想谈谈三种不同的值比较操作<code class="fe lb lc ld le b">===</code>、<code class="fe lb lc ld le b">==</code>和<code class="fe lb lc ld le b">Object.is()</code>。下面我们来探讨一下这三种操作的异同。</p><h2 id="fdcd" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated"><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank"> Object.is() </a></h2><p id="d677" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">这对我来说是一个新的操作，所以我想我应该先投入进去。事实上，在我开始写这个主题之前，我从来没有听说过它，而且我发现我看过的大多数教程都没有深入这个主题。此方法比较括号内的两个值，并确定两个值是否相同。</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="13be" class="lf lg in le b gy ml mm l mn mo">Object.is(7, 7); <em class="kx">//</em><strong class="le io"><em class="kx"> true</em></strong><br/>Object.is('foo', 'foo'); <em class="kx">//</em><strong class="le io"><em class="kx"> true<br/></em></strong>Object.is('foo', 'bar'); <em class="kx">// </em><strong class="le io"><em class="kx">false<br/></em></strong>Object.is({}, {}); <em class="kx">//</em><strong class="le io"><em class="kx"> false</em></strong></span></pre><p id="42a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你明白了。记住<code class="fe lb lc ld le b">Object.is()</code>如何工作的关键在于记住你正在比较的价值观。例如，看看上面的第一行代码，用变量重写它，看起来像:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="57ba" class="lf lg in le b gy ml mm l mn mo">let a = 7;<br/>let b = a;</span><span id="5764" class="lf lg in le b gy mp mm l mn mo">Object.is(a, b); <em class="kx">// </em><strong class="le io"><em class="kx">true</em></strong></span></pre><p id="3b81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述两个变量指向同一个值，<code class="fe lb lc ld le b">7</code>，并且它们具有相同的原始数据类型，<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="noopener ugc nofollow" target="_blank">编号</a>。在<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/javascript-everything-is-an-object-or-is-it-2f1092403dc3">之前的博客</a>中，我简单地提到了原始数据类型的主题，也就是原始值，以及<em class="kx">类型的</em>对<code class="fe lb lc ld le b">Object.is()</code>而不是<code class="fe lb lc ld le b">==</code>操作符很重要。<code class="fe lb lc ld le b"><strong class="jx io">Object.is()</strong></code> <strong class="jx io">不执行</strong> <a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">式强制</strong> </a>。下面是当<code class="fe lb lc ld le b">Object.is()</code>返回true时的MDN分解:</p><blockquote class="ku kv kw"><p id="67f7" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">如果下列条件之一成立，则两个值相同:</p><p id="4973" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">-两个<code class="fe lb lc ld le b"><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank">undefined</a><br/></code> -两个<code class="fe lb lc ld le b"><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">null</a><br/></code> -两个<code class="fe lb lc ld le b">true</code>或两个<code class="fe lb lc ld le b">false<br/></code> -两个字符串长度相同，字符顺序相同<br/> -两个对象相同(意味着两个值都引用内存中的同一个对象)<br/> -两个数字<strong class="jx io">和<br/>—</strong>—两个<code class="fe lb lc ld le b">+0<em class="in"><br/></em></code> —两个<code class="fe lb lc ld le b">-0<br/></code> —两个<code class="fe lb lc ld le b"><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN" rel="noopener ugc nofollow" target="_blank">NaN</a><br/></code> —或者两个都不为零且都不为<code class="fe lb lc ld le b"><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN" rel="noopener ugc nofollow" target="_blank">NaN</a></code>，并且两个值相同</p></blockquote><p id="ad5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与<code class="fe lb lc ld le b">===</code>和<code class="fe lb lc ld le b">==</code>相比，它们有相似之处，但更重要的是，它们有一些关键的区别。让我们来看看。</p><h2 id="21f5" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated"><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#strict_equality_using" rel="noopener ugc nofollow" target="_blank">严格相等比较(“严格相等”、“相同”、“三重相等”)——= = =</a></h2><p id="da36" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">我们已经简要地看了一下<code class="fe lb lc ld le b">Object.is()</code>，但是让我们看看同值比较……如何与严格相等比较进行比较(<em class="kx">这是很多比较……</em>)。要使用严格的相等比较，您可以使用三重等于运算符，<code class="fe lb lc ld le b">===</code>。事实上，这是您应该比任何其他比较操作更多使用的比较运算符。事实上，MDN认为'<em class="kx">严格相等几乎总是正确的比较操作。</em></p><p id="ace5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与<code class="fe lb lc ld le b">Object.is()</code>一样，<code class="fe lb lc ld le b">===</code>在比较值时不执行类型强制。<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#strict_equality_using" rel="noopener ugc nofollow" target="_blank"> ' <em class="kx">如果值有不同类型，则认为值不相等。</em>’</a>基本上，上面的虚线列表几乎完全适用于严格的等式比较。差不多了。在两种特殊情况下，triple equals的行为可能与您预期的不同。那两个特例涉及<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/javascript-special-numbers-404dd5bf5f20">特殊号</a>、<code class="fe lb lc ld le b">NaN</code>和<code class="fe lb lc ld le b">-0</code>。</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="70d5" class="lf lg in le b gy ml mm l mn mo">NaN === NaN; <em class="kx">// </em><strong class="le io"><em class="kx">false</em></strong><br/>Object.is(NaN, NaN); <em class="kx">// </em><strong class="le io"><em class="kx">true</em></strong></span><span id="1632" class="lf lg in le b gy mp mm l mn mo">-0 === 0; <em class="kx">// </em><strong class="le io"><em class="kx">true</em></strong><br/>0 === -0; <em class="kx">// </em><strong class="le io"><em class="kx">true</em></strong><br/>Object.is(-0, 0); <em class="kx">// </em><strong class="le io"><em class="kx">false</em></strong><br/>Object.is(0, -0); <em class="kx">// </em><strong class="le io"><em class="kx">false</em></strong></span></pre><p id="7fe7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lb lc ld le b">NaN</code>与<code class="fe lb lc ld le b">NaN</code>的值相同，这也是<code class="fe lb lc ld le b">Object.is(NaN, NaN)</code>返回<code class="fe lb lc ld le b">true</code>的原因。<code class="fe lb lc ld le b">-0</code>与<code class="fe lb lc ld le b">+0</code>或<code class="fe lb lc ld le b">0</code>不是同一个值，这就是<code class="fe lb lc ld le b">Object.is(-0, 0)</code>返回<code class="fe lb lc ld le b">false</code>的原因。如果这对你来说没有意义，我明白了，但还是用在JavaScript还是一个东西<em class="kx">之前制定的<a class="ae kt" href="https://en.wikipedia.org/wiki/IEEE_754#Comparison_predicates" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">IEEE 754</strong></a><em class="kx"/>标准吧。如果你正在使用<code class="fe lb lc ld le b">===</code>操作符，这两个特殊的数字可能会让你头疼，既然你应该头疼，只要记住上面的代码行是仅有的两个特例，你就会没事。</em></p><p id="93d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">边注</em> </strong> <em class="kx">:如果你曾经想使用严格的相等比较来检查一个值是否为</em> <code class="fe lb lc ld le b"><em class="kx">NaN</em></code> <em class="kx">我建议使用</em> <code class="fe lb lc ld le b"><em class="kx">!==</em></code> <em class="kx">。</em> <code class="fe lb lc ld le b"><em class="kx">NaN</em></code> <em class="kx">总是不等于其他每一个值，包括</em> <code class="fe lb lc ld le b"><em class="kx">NaN</em></code> <em class="kx">。唯一能让</em> <code class="fe lb lc ld le b"><em class="kx">NaN</em></code> <em class="kx">返回真的方法是比较</em> <code class="fe lb lc ld le b"><em class="kx">NaN !== NaN</em></code> <em class="kx">。还有，可以用</em><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN" rel="noopener ugc nofollow" target="_blank"><em class="kx">number . isnan()</em></a><em class="kx">。</em></p><h2 id="6089" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated"><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#loose_equality_using" rel="noopener ugc nofollow" target="_blank">抽象相等比较(“宽松相等”、“双重相等”)——= =</a></h2><p id="eaa3" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">现在，我已经在前面的章节中提到了<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion" rel="noopener ugc nofollow" target="_blank">类型强制</a>以及之前的比较是如何执行类型强制的。这就是它发挥作用的地方。Double equals就像是JS中比较的狂野西部。很难预测，这是因为类型强制。我不会在这种类型的比较上花太多时间，因为使用宽松的等式通常是“不鼓励的”。但是，它是有效的JS，所以你应该知道它。MDN将其细分如下:</p><blockquote class="ku kv kw"><p id="bd21" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">相等运算符(<code class="fe lb lc ld le b">==</code>和<code class="fe lb lc ld le b">!=</code>)使用<a class="ae kt" href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" rel="noopener ugc nofollow" target="_blank">抽象相等比较算法</a>来比较两个操作数。这可以大致概括如下:</p><p id="e83c" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">-如果操作数都是对象，仅当两个操作数引用同一个对象时才返回<code class="fe lb lc ld le b">true</code>。<br/>——如果一个操作数是<code class="fe lb lc ld le b">null</code>，另一个是<code class="fe lb lc ld le b">undefined</code>，则返回<code class="fe lb lc ld le b">true</code>。<br/> -如果操作数是不同的类型，在比较之前尽量把它们转换成相同的类型:<br/>-在比较一个数字和一个字符串时，尽量把字符串转换成数值。<br/> —如果操作数之一是<code class="fe lb lc ld le b">Boolean</code>，如果是<code class="fe lb lc ld le b">true</code>，则将布尔操作数转换为1，如果是<code class="fe lb lc ld le b">false</code>，则转换为+0。<br/> —如果一个操作数是对象，另一个是数字或字符串，尝试使用对象的<code class="fe lb lc ld le b">valueOf()</code>和<code class="fe lb lc ld le b">toString()</code>方法将对象转换为原语。</p><p id="6c38" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">-如果操作数具有相同的类型，则进行如下比较:<br/> — <code class="fe lb lc ld le b">String</code>:仅当两个操作数具有相同顺序的相同字符时，返回<code class="fe lb lc ld le b">true</code>。<br/> — <code class="fe lb lc ld le b">Number</code>:仅当两个操作数的值相同时，返回<code class="fe lb lc ld le b">true</code>。<code class="fe lb lc ld le b">+0</code>和<code class="fe lb lc ld le b">-0</code>被视为相同的值。如果任一操作数为<code class="fe lb lc ld le b">NaN</code>，则返回<code class="fe lb lc ld le b">false</code>。<br/> — <code class="fe lb lc ld le b">Boolean</code>:仅当操作数都是<code class="fe lb lc ld le b">true</code>或都是<code class="fe lb lc ld le b">false</code>时，返回<code class="fe lb lc ld le b">true</code>。</p></blockquote><p id="fbde" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像我说的，小心使用这个。最好的做法总是坚持严格的平等而不是宽松的平等。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="f9e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你知道了！总之，在确定两个值是否相等时，使用严格比较。它将永远是你最安全的赌注，只要你记住这两个特例，它的表现将是最可预测的。这里还有一个<a class="ae kt" href="https://dorey.github.io/JavaScript-Equality-Table/" rel="noopener ugc nofollow" target="_blank">有用的github演示</a>JS比较！</p><p id="6a11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快乐编码🤓</p></div></div>    
</body>
</html>