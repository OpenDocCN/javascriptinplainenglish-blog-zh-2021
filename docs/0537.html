<html>
<head>
<title>How Recursion Works: The Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归如何工作:简单的方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-recursion-works-the-easy-way-d45dcb4d98e2?source=collection_archive---------14-----------------------#2021-02-01">https://javascript.plainenglish.io/how-recursion-works-the-easy-way-d45dcb4d98e2?source=collection_archive---------14-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5244" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript示例，不需要fibonacci</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5fdb20134cd2ffbb2111d2f0b6fe4a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYI61j1tVfjgO5ds51G4eA.jpeg"/></div></div></figure><p id="bc79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你已经通过使用<em class="ln"> </em> <a class="ae lo" href="https://medium.com/quick-code/fibonacci-sequence-javascript-interview-question-iterative-and-recursive-solutions-6a0346d24053" rel="noopener">斐波那契</a>或<a class="ae lo" href="https://medium.com/@julianjohannesen/banging-my-head-against-recursive-functions-a79f53fbab0f" rel="noopener">指数</a> JavaScript函数努力学习<strong class="kt ir">递归</strong> <em class="ln"> </em>，那么这篇文章是给你的。起初，我遇到了递归的麻烦，因为基于“数学”的递归有两个方面:实际的递归和不断变化的返回值。幸运的是，如果我们从等式中去掉返回值，事情就简单多了。我们可以通过专注于迭代数组来实现这一点。</p><h2 id="80f9" class="lp lq iq bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">什么是递归？</h2><p id="f4ef" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">对于一个递归的函数，它只需要做两件事:1) <strong class="kt ir">调用自己</strong>和<strong class="kt ir"> 2)知道什么时候<em class="ln">停止</em>调用自己</strong>。就这样，就这样。严格来说，你甚至不需要第二个。当然，没有它，你的函数会爆炸，但是它会递归地爆炸<em class="ln">。</em></p><h1 id="ec98" class="mn lq iq bd lr mo mp mq lu mr ms mt lx jw mu jx ma jz mv ka md kc mw kd mg mx bi translated">让我们构建一个简单的函数</h1><p id="04be" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">首先，让我们做一个基本函数。它所做的只是在数组中记录一个值:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="4027" class="lp lq iq mz b gy nd ne l nf ng">const <strong class="mz ir">recursiveFunc</strong> = (<strong class="mz ir">arr</strong>, <strong class="mz ir">idx</strong>) =&gt; {<br/>  <strong class="mz ir">console.log</strong>(`- ${<strong class="mz ir">arr</strong>[<strong class="mz ir">idx</strong>]}`);<br/>};</span><span id="788f" class="lp lq iq mz b gy nh ne l nf ng">const <strong class="mz ir">arr</strong>= ['<em class="ln">a</em>', '<em class="ln">b</em>', '<em class="ln">c</em>'];</span><span id="9e11" class="lp lq iq mz b gy nh ne l nf ng">// this would log each value<strong class="mz ir"><br/>recursiveFunc(arr, </strong>0<strong class="mz ir">);<br/>recursiveFunc(arr</strong>, 1<strong class="mz ir">);<br/>recursiveFunc(arr</strong>, 2<strong class="mz ir">);</strong></span></pre><p id="28de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能注意到记录每个值的方法是用一个更大的索引来调用它。现在<strong class="kt ir">我们</strong>调用函数并增加索引，但是如果函数本身调用了呢？</p><h1 id="bab8" class="mn lq iq bd lr mo mp mq lu mr ms mt lx jw mu jx ma jz mv ka md kc mw kd mg mx bi translated">使函数递归</h1><p id="94f8" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">让我们在函数中添加递增和调用<em class="ln">。</em></p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2772" class="lp lq iq mz b gy nd ne l nf ng">const <strong class="mz ir">recursiveFunc</strong> = (<strong class="mz ir">arr</strong>, <strong class="mz ir">idx </strong>= 0) =&gt; {<br/>  <strong class="mz ir">console.log</strong>(`- ${<strong class="mz ir">arr</strong>[<strong class="mz ir">idx</strong>]}`);<br/>  <strong class="mz ir">recursiveFunc</strong>(<strong class="mz ir">arr</strong>, <strong class="mz ir">idx</strong> + 1);<br/>};</span></pre><p id="687e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样:一个<strong class="kt ir">递归函数</strong>。看到函数调用本身看起来很奇怪，但是所有的编程语言都能够做到这一点。然而，如果我们照原样运行，它就会爆炸。那是因为我们从来没有告诉它在任何时候停止<em class="ln">。我们仍然需要要求2，一个停止条件:</em></p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="e627" class="lp lq iq mz b gy nd ne l nf ng"><em class="ln">const</em> <strong class="mz ir">recursiveFunc</strong> = (<strong class="mz ir">arr</strong>, <strong class="mz ir">idx</strong> = 0) =&gt; {<br/>  if (<strong class="mz ir">arr</strong>[<strong class="mz ir">idx</strong>]) {<br/>    <strong class="mz ir">console</strong>.log(`- ${<strong class="mz ir">arr</strong>[<strong class="mz ir">idx</strong>]}`);<br/>    <strong class="mz ir">recursiveFunc</strong>(<strong class="mz ir">arr</strong>, <strong class="mz ir">idx</strong> + 1);<br/>  }<br/>};</span></pre><p id="86fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，一旦我们找到一个不在数组中的索引，它就什么也做不了，整个递归函数链也就结束了。</p><h1 id="f998" class="mn lq iq bd lr mo mp mq lu mr ms mt lx jw mu jx ma jz mv ka md kc mw kd mg mx bi translated">到底发生了什么</h1><p id="6bfc" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">如果您运行这个函数，您会得到:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="c435" class="lp lq iq mz b gy nd ne l nf ng"><strong class="mz ir">recursiveFunc(</strong>[<em class="ln">'a'</em>, <em class="ln">'b'</em>, <em class="ln">'c'</em>])<strong class="mz ir">;</strong></span><span id="7ec7" class="lp lq iq mz b gy nh ne l nf ng">// Logs out:<br/>- a <br/>- b <br/>- c</span></pre><p id="90f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但在内部，这是正在发生的事情</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/36ddc53e8c262a5f0569cd42d3d97458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yC49mdBV0ErFOqPTVvLWLQ.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">How each new function works with the new arguments</figcaption></figure><p id="0002" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们每次都会将索引值增加一，因此我们会遍历整个数组。当索引值改变时，数组不改变。一旦索引处没有值，该函数就没有什么可做的了，所以我们退出该函数，然后它就完成了链上所有的函数。花一分钟时间真正地内在化这里发生的事情的逻辑，因为这是递归如何工作的焦点。</p><h1 id="0788" class="mn lq iq bd lr mo mp mq lu mr ms mt lx jw mu jx ma jz mv ka md kc mw kd mg mx bi translated">我们必须走得更远</h1><p id="10fa" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">我们的函数符合我们对递归的定义，但是它不能递归地遍历<em class="ln">嵌套的</em>数组。这不好，因为这实际上是递归的一个实际应用。看，循环处理迭代更好，但是它们不容易处理未知深度的嵌套。这是因为如果递归函数发现了另一个嵌套数组，它可以在那个数组上再次调用自己的<em class="ln"/>。</p><p id="c330" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了说明嵌套，我们需要做的就是添加一个步骤，在这里我们检查值是否是一个数组。如果是，我们从索引0开始，如果不是，我们像往常一样继续:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b2ac" class="lp lq iq mz b gy nd ne l nf ng">const recursiveFunc = (arr, idx = 0) =&gt; {<br/>  if (arr[idx]) {</span><span id="2d74" class="lp lq iq mz b gy nh ne l nf ng"><strong class="mz ir">    if (Array.isArray(arr[idx])) {<br/>      recursiveFunc(arr[idx]);<br/>    } else {</strong><br/>  <strong class="mz ir">    console.log(`- ${arr[idx]}`);<br/>    }</strong></span><span id="fddf" class="lp lq iq mz b gy nh ne l nf ng">    recursiveFunc(arr, idx + 1);<br/>  }<br/>};</span><span id="970c" class="lp lq iq mz b gy nh ne l nf ng">recursiveFunc([<em class="ln">'a'</em>, [<em class="ln">'x', 'y'</em>], <em class="ln">'d'</em>]);</span><span id="71ec" class="lp lq iq mz b gy nh ne l nf ng">// logs <br/>- a <br/>- x<br/>- y<br/>- d</span></pre><p id="a429" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们之前图表的新版本</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/3ba81223c60871fdee8dc72173337484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCo9IjuK9ZZl7ymQHakq1w.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Our new recursive function showing the separate array step in another box</figcaption></figure><p id="de80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是在新数组上开始另一个递归调用链。看看我们如何传入新数组并默认返回到<code class="fe no np nq mz b">0</code>来开始新序列。一旦这个序列完成，我们回到我们的主链。另外，注意最后的<code class="fe no np nq mz b">recursiveFunc</code>调用是在之后的<em class="ln">调用，并且在数组检查之外。这是因为当我们进入一个数组后，当我们返回时，我们总是想继续下去。为了简单起见，我们只嵌套一次，但是这可以用于更多的层次。</em></p><h1 id="c996" class="mn lq iq bd lr mo mp mq lu mr ms mt lx jw mu jx ma jz mv ka md kc mw kd mg mx bi translated">通过想象来仔细检查</h1><p id="183e" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">为了确保您理解主要概念，为什么不尝试添加另一个参数呢？让我们为更好的打印添加一个<code class="fe no np nq mz b">level</code>参数:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6672" class="lp lq iq mz b gy nd ne l nf ng"><em class="ln">const</em> <strong class="mz ir">recursiveFancy</strong> = (<strong class="mz ir">arr</strong>, <strong class="mz ir">idx = 0</strong>, <strong class="mz ir">level = 1</strong>) =&gt; {<br/>  if (arr[idx]) {<br/>    if (<strong class="mz ir">Array.</strong>isArray(<strong class="mz ir">arr</strong>[<strong class="mz ir">idx</strong>])) {<br/>      <strong class="mz ir">recursiveFancy</strong>(<strong class="mz ir">arr</strong>[<strong class="mz ir">idx</strong>], 0, <strong class="mz ir">level</strong> + 1);<br/>    } else {<br/>      <strong class="mz ir">console</strong>.log(`${'- '.repeat(<strong class="mz ir">level</strong>)}${<strong class="mz ir">arr</strong>[<strong class="mz ir">idx</strong>]}`);<br/>    }<br/>    <strong class="mz ir">recursiveFancy</strong>(<strong class="mz ir">arr</strong>, <strong class="mz ir">idx</strong> + 1, <strong class="mz ir">level</strong>);<br/>  }<br/>};</span><span id="6293" class="lp lq iq mz b gy nh ne l nf ng"><strong class="mz ir">recursiveFancy</strong>(['<em class="ln">a</em>', '<em class="ln">b</em>', ['<em class="ln">q</em>', ['<em class="ln">x</em>',]], '<em class="ln">c</em>']);<br/><em class="ln"># returns </em><br/>- a<br/>- b<br/>- - q<br/>- - - x<br/>- c</span></pre><p id="7703" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意我们这里的<code class="fe no np nq mz b">+1</code> <code class="fe no np nq mz b">idx </code>和<code class="fe no np nq mz b">level</code>，并不完全相同。我们只在处理嵌套数组时增加<code class="fe no np nq mz b">level</code>,只在数组中向前移动时增加<code class="fe no np nq mz b">idx</code>。既然基础知识已经完成，学习递归返回值应该会容易得多。看看他们如何处理<a class="ae lo" href="https://medium.com/quick-code/fibonacci-sequence-javascript-interview-question-iterative-and-recursive-solutions-6a0346d24053" rel="noopener">斐波纳契面试问题</a>。</p><h1 id="4600" class="mn lq iq bd lr mo mp mq lu mr ms mt lx jw mu jx ma jz mv ka md kc mw kd mg mx bi translated">递归的缺点</h1><p id="b84c" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">如果递归如此简单，为什么我们不到处使用它呢？为什么循环对于纯迭代更好？原因与<a class="ae lo" href="https://www.javascripttutorial.net/javascript-call-stack/" rel="noopener ugc nofollow" target="_blank"> JavaScript调用栈</a>有关。我建议检查一下，这是编程的基础部分。但是最重要的是:当你调用一个函数时，它被放在调用栈中。一旦完成，它就被移除。但是，递归的问题是，第一次调用直到所有的<em class="ln">子函数</em>完成后才能完成。这意味着调用栈越来越高。如果太高，它会全部坏掉。</p><p id="6f07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是递归的问题，有一个最大深度。你希望一个函数有一个<code class="fe no np nq mz b">for</code>循环，可以重复一百万次？太棒了。但是递归函数可以更快地发现问题。这并不意味着循环更好。这意味着我们必须使用递归来解决更具体的问题，比如未知的深度或递归数据结构(<a class="ae lo" href="https://www.youtube.com/watch?v=t2CEgPsws3U" rel="noopener ugc nofollow" target="_blank">二分搜索法树</a>)。这只是为问题找到合适的工具。</p><p id="c2ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大家编码快乐，</p><p id="6021" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">迈克</p></div></div>    
</body>
</html>