<html>
<head>
<title>How To Authenticate and Authorize Using JWT with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过Node.js使用JWT进行身份验证和授权</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-authenticate-and-authorize-using-jwt-with-node-js-a324437dedb1?source=collection_archive---------16-----------------------#2021-04-09">https://javascript.plainenglish.io/how-to-authenticate-and-authorize-using-jwt-with-node-js-a324437dedb1?source=collection_archive---------16-----------------------#2021-04-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d1ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我敢打赌，如果你每次都被要求在你最喜欢的应用程序上登录，那会很令人沮丧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/813afa1c27e1141b03a7fb3d56cacc7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yMtnFwIjq8T8zKqH"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aa34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将探索jwt(JSON Web令牌)。JWTs为发布和验证认证令牌提供了一个很好的系统。身份验证令牌将确保客户端不需要每次在服务器上执行操作时都登录。</p><p id="b52d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦用户登录，每个后续请求都将包含JSON Web令牌，这将允许用户访问可以用该令牌访问的路由和服务。</p><p id="31ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的路线图包括创建一个express服务器、一个用户、一个身份验证中间件和一个任务服务——如果我们未经身份验证，就无法访问它们。</p><p id="b1a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将使用的工具和框架包括NodeJS、Express、MongoDB和Postman。</p><p id="7a7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，初始化Node.js项目:</p><p id="54d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">npm init -y</code></p><p id="e085" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，安装express framework:</p><p id="7383" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">npm install express</code></p><p id="2f74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装express后，创建一个文件(我叫我的<code class="fe kz la lb lc b">app.js</code>)并设置一个express服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="fca8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行这个文件会将文本<code class="fe kz la lb lc b">listening to server at port:5000</code> <strong class="jm io"> </strong>打印到终端。这表明我们的服务器已经启动并正在运行。</p><p id="0d36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是安装mongoose并设置MongoDB数据库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="7871" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个mongoose文件驻留在一个<code class="fe kz la lb lc b">db</code>文件夹中，这个文件夹必须导入到<code class="fe kz la lb lc b">app.js</code>文件中。这将在服务器启动后启用MongoDB连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Add this line to the top of the app.js file.</figcaption></figure><p id="7675" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦服务器启动，我们就可以连接到任何MongoDB客户端。</p><p id="0738" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，让我们创建一个用户模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="44fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的用户模型包含四个字段:名称、密码、电子邮件和令牌字段，每当用户注册或登录时，这些字段将用于存储生成的令牌。</p><h2 id="21d8" class="lf lg in bd lh li lj dn lk ll lm dp ln jv lo lp lq jz lr ls lt kd lu lv lw lx bi translated"><strong class="ak">用户路线</strong></h2><p id="e61e" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">下一步是为注册和登录用户创建端点。每当用户注册或登录时，都会生成一个新令牌。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="9a50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第一个端点中，<strong class="jm io"> </strong> <code class="fe kz la lb lc b">user.save()</code> <strong class="jm io"> </strong>在数据库中存储一个新用户，而<code class="fe kz la lb lc b">user.GenerateAuthToken()</code> <strong class="jm io"> </strong>为该用户生成一个新的auth令牌。我们将很快定义<code class="fe kz la lb lc b">GenerateAuthToken()</code> <strong class="jm io"> </strong>函数。如果这些操作成功，我们会将用户详细信息和生成的令牌作为响应发送回去。</p><p id="16a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第二个端点中，我们使用<code class="fe kz la lb lc b">FindByCredentials()</code> <strong class="jm io"> </strong>函数(我们尚未定义)来登录已经拥有帐户的用户——也就是说，如果他们提供的电子邮件和密码与数据库中的电子邮件和密码相匹配。一旦他们登录，就会使用<code class="fe kz la lb lc b">GenerateAuthToken()</code> <strong class="jm io"> </strong>功能为他们生成一个新令牌。如果这些操作成功，我们将用户详细信息和生成的令牌作为响应发送回去。</p><p id="da5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看我们的用户创建端点是否通过Postman工作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/0c0acbfbdcde6bc0a40e1582d1a23d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJlsARhTCbqk7SOaZtbpdQ.png"/></div></div></figure><p id="76a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在请求体中提供了一个<code class="fe kz la lb lc b">name</code>、<code class="fe kz la lb lc b">password</code>和<code class="fe kz la lb lc b">email </code>，当我们发送请求时，为创建的用户生成了一个<code class="fe kz la lb lc b">token </code>。</p><h2 id="86c3" class="lf lg in bd lh li lj dn lk ll lm dp ln jv lo lp lq jz lr ls lt kd lu lv lw lx bi translated"><strong class="ak">生成和存储认证令牌</strong></h2><p id="69d2" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">每当用户注册或登录时，JWT都会生成一个新的身份验证令牌。该认证令牌可以存储在数据库中。所有生成的令牌都将存储为用户配置文件。这样，它们可以用于注销用户。每当用户注销时，当前令牌将从用户配置文件中删除。删除存储在用户配置文件中的所有生成的令牌将导致用户从所有会话中注销。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Define this function in user.js</figcaption></figure><p id="3354" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的实例方法负责生成新的认证令牌。在函数中，我们调用了生成令牌的<code class="fe kz la lb lc b">jwt.sign()</code> <strong class="jm io"> </strong>函数。<strong class="jm io"> </strong> <code class="fe kz la lb lc b">sign()</code>取三个参数:<code class="fe kz la lb lc b">payload</code>、<strong class="jm io"> </strong> <code class="fe kz la lb lc b">secretOrPrivatekey</code>、<code class="fe kz la lb lc b">options</code>。<code class="fe kz la lb lc b">payload </code>可以是字符串也可以是对象；我们的是一个对象—用户id <code class="fe kz la lb lc b">id</code>。<code class="fe kz la lb lc b">secretOrPrivateKey </code>顾名思义——一个秘密的或私有的密钥，它不应该被暴露(尽管为了可见性，我们确实暴露了我们的密钥)。第三个参数是可选的。</p><p id="7706" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">生成令牌后，我们通过将它添加到用户模型中的令牌字段来将其存储在数据库中。存储后，令牌从函数返回。</p><p id="8f13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建了一个生成身份验证令牌的系统之后，让我们继续创建一个任务服务。该服务中的主要操作——创建任务——将放在身份验证之后。这将确保只有经过身份验证的用户才有权创建任务。</p><h2 id="ca2d" class="lf lg in bd lh li lj dn lk ll lm dp ln jv lo lp lq jz lr ls lt kd lu lv lw lx bi translated"><strong class="ak">任务服务</strong></h2><p id="8f4c" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">让我们首先创建一个任务模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="302e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的任务模型包含三个字段:<code class="fe kz la lb lc b">description</code> <strong class="jm io"> </strong> —基本上是一个任务的描述；<code class="fe kz la lb lc b">completed </code> —一个布尔值，表示任务是否完成；<code class="fe kz la lb lc b">owner </code> —与用户模型的关系，表明谁创建了任务。</p><p id="0578" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是创建一个用于创建任务的端点，但是我们需要创建一个认证中间件，它可以被添加到端点来锁定它。这意味着只有拥有帐户或已登录的用户才能创建任务。</p><h2 id="faf8" class="lf lg in bd lh li lj dn lk ll lm dp ln jv lo lp lq jz lr ls lt kd lu lv lw lx bi translated"><strong class="ak">认证中间件(接受和验证令牌)</strong></h2><p id="42aa" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">这个中间件的目标是验证身份验证令牌，然后获取该用户的配置文件。下面的代码展示了如何做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="3ab0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法<code class="fe kz la lb lc b">verify()</code> <strong class="jm io"> </strong>使用我们的私钥<code class="fe kz la lb lc b">yourprivatekey</code>验证来自<code class="fe kz la lb lc b">req.header</code> <strong class="jm io"> </strong>的认证令牌。返回一个解码后的令牌，其中包含我们用来创建令牌(id)的有效负载。然后，这个解码后的令牌可用于获取用户配置文件，该文件随后可被传递给<code class="fe kz la lb lc b">req.user</code>。这允许路由处理器函数访问用户配置文件，而不必再次获取它。</p><h2 id="5704" class="lf lg in bd lh li lj dn lk ll lm dp ln jv lo lp lq jz lr ls lt kd lu lv lw lx bi translated"><strong class="ak">任务路线</strong></h2><p id="f7bb" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">现在我们已经定义了身份验证中间件，让我们为创建任务创建一个端点。认证中间件将作为第二个参数添加到<code class="fe kz la lb lc b">router.post()</code>，这意味着它将在路由处理程序运行之前运行。这将确保用户得到验证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="4d8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦用户被认证，他们可以继续创建任务，但是在用户未被认证的情况下，认证中间件<code class="fe kz la lb lc b">auth</code>、<strong class="jm io">、</strong>将抛出<code class="fe kz la lb lc b"><strong class="jm io">401 </strong></code>(未授权错误)，这将阻止路由处理器执行任务创建操作。如果任务创建成功，它将存储在数据库中。</p><p id="b51b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看我们的任务创建端点是否通过Postman工作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/6bdc8c1280005a8f0630c182a83bdb53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pKHt9lLlx3BoB3MSSQWSQg.png"/></div></div></figure><p id="8ff5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们收到了一个<code class="fe kz la lb lc b">201 </code>状态代码，这意味着我们能够成功地创建一个任务，这是因为我们通过了身份验证——也就是说，我们已经登录。未登录的用户将无法创建任务。</p><p id="d722" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经看到了jwt在我们的API和服务中的作用和重要性。一旦我们通过了身份验证，我们就可以在不提示我们进行身份验证的情况下执行许多操作。JWTs还使我们能够通过将端点置于身份验证之后来保护我们的服务。这将防止未经身份验证的用户访问和使用我们的端点和服务。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="bbe2" class="mm lg in bd lh mn mo mp lk mq mr ms ln mt mu mv lq mw mx my lt mz na nb lw nc bi translated">结论</h1><p id="0f47" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">仅此而已。</p><p id="b64c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，我们已经了解了如何:</p><ul class=""><li id="413d" class="nd ne in jm b jn jo jr js jv nf jz ng kd nh kh ni nj nk nl bi translated">使用JWT生成身份验证令牌。</li><li id="3754" class="nd ne in jm b jn nm jr nn jv no jz np kd nq kh ni nj nk nl bi translated">验证身份验证令牌。</li><li id="9542" class="nd ne in jm b jn nm jr nn jv no jz np kd nq kh ni nj nk nl bi translated">通过将终端置于身份验证之后来保护终端。</li></ul><p id="dd17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">写这篇文章的时候我学到了很多，我希望你在阅读的时候也能学到一些东西。</p><p id="a06f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nr">更多内容看</em><a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="nr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>