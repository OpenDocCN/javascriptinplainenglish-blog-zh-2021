<html>
<head>
<title>9 Data Structures &amp; Algorithms you Should Know as a Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为开发人员，你应该知道的9种数据结构和算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/9-data-structures-algorithms-you-should-know-as-a-developer-5e10946c95a0?source=collection_archive---------1-----------------------#2021-03-07">https://javascript.plainenglish.io/9-data-structures-algorithms-you-should-know-as-a-developer-5e10946c95a0?source=collection_archive---------1-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2e53" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让你成为更好的开发者的数据结构和算法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b601fbc00287156ea8f448fba687c134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9WlZAhEbvK-8gkGN_hE8A.png"/></div></div></figure><h1 id="4ef1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">1.链表</h1><p id="435b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你已经有一些编程经验，那么你可能听说过链表，这被认为是比数组更好的在内存中存储列表的选择，因为使用数组有很多缺点和限制。</p><blockquote class="mf"><p id="fdf2" class="mg mh iq bd mi mj mk ml mm mn mo me dk translated">什么是节点？</p><p id="4529" class="mg mh iq bd mi mj mk ml mm mn mo me dk translated">比方说，在一家餐馆里，你点了一些食物，当服务员来到你的桌前并记下你点的食物时，他必须随身携带两样东西，那显然是你的食物和你在餐馆的位置。类似地，在一个链表中，我们有包含两个东西的节点，<strong class="ak">数据</strong> &amp; <strong class="ak">链接</strong>。<strong class="ak"> <em class="mp">数据</em> </strong>是您实际存储的数据，而<strong class="ak"> <em class="mp">链接</em> </strong>包含列表中下一个节点的地址。</p></blockquote><p id="c58a" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated"><strong class="ll ir">有3种类型的链表需要查看。</strong></p><ul class=""><li id="235d" class="mv mw iq ll b lm mx lp my ls mz lw na ma nb me nc nd ne nf bi translated"><strong class="ll ir">单链表:</strong>简单的由多个节点组成，每个节点都包含数据和链接。<strong class="ll ir"> <em class="ng">例如，</em> </strong>如果我们在单个链表中存储3个数字<strong class="ll ir"> (10，20，30) </strong>，现在每个节点都包含该节点的地址及其相关数据，除了第一个节点没有链接，为了访问第一个节点，我们有一个<strong class="ll ir"> <em class="ng">指针</em> </strong>，它包含自己的地址。注意，最后一个节点在一个链表中也没有地址。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/5576dbad608ad3e5611d19bc69dd9187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGBdE6kdR0zMhNsjhRs4ZQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Single Linked List</strong></figcaption></figure><blockquote class="mf"><p id="1c2b" class="mg mh iq bd mi mj nn no np nq nr me dk translated">导航仅向前</p></blockquote><p id="3ac1" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated"><strong class="ll ir">双向链表:</strong>由于我们在单向链表中有前向导航，双向链表和单向链表有点不同，每个节点都有一个额外的指针指向前一个节点，类似于单向链表。这些额外的指针提供了向前和向后移动的能力。</p><blockquote class="ns nt nu"><p id="0588" class="lj lk ng ll b lm mx jr lo lp my ju lr nv nw lu lv nx ny ly lz nz oa mc md me ij bi translated">注意，我们必须在双向链表中的两个位置提供空指针。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/a7c4b92797d20d4fde201d6132599a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dC05E_RyBA70oCMhUqslkQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Doubly Linked List</strong></figcaption></figure><blockquote class="mf"><p id="c6f2" class="mg mh iq bd mi mj nn no np nq nr me dk translated">向前和向后导航是可能的</p></blockquote><ul class=""><li id="1b51" class="mv mw iq ll b lm mq lp mr ls oc lw od ma oe me nc nd ne nf bi translated"><strong class="ll ir">循环链表:</strong>在这种情况下，如果你对单链表&amp;双链表有很好的了解就很容易理解了。现在循环链表有两个子类型<strong class="ll ir">(循环单链表</strong> &amp; <strong class="ll ir">循环双链表)。</strong>在<strong class="ll ir"> <em class="ng">循环单链表</em> </strong>的情况下，除了循环单链表的最后一个节点指向第一个节点之外，我们拥有与单链表相似的一切。</li></ul><blockquote class="ns nt nu"><p id="1f4a" class="lj lk ng ll b lm mx jr lo lp my ju lr nv nw lu lv nx ny ly lz nz oa mc md me ij bi translated">另一方面，循环双向链表类似于双向链表，除了<strong class="ll ir"> <em class="iq">循环双向链表</em> </strong>的最后一个节点指向第一个节点&amp;第一个节点指向最后一个节点。下图你会有更好的理解。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/52a9d4d435d7ddffeee417e136dd9961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQEF9OnOgMAGbunQ_ZnJqg.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Circular Linked List</strong></figcaption></figure><blockquote class="mf"><p id="fe91" class="mg mh iq bd mi mj nn no np nq nr me dk translated">最后一个元素链接到第一个元素</p></blockquote></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="8417" class="om ks iq bd kt on oo dn kx op oq dp lb ls or os ld lw ot ou lf ma ov ow lh ox bi translated">2.堆栈和队列</h2><ul class=""><li id="3ace" class="mv mw iq ll b lm ln lp lq ls oy lw oz ma pa me nc nd ne nf bi translated"><strong class="ll ir">栈:</strong>它们是遵循特定操作顺序的线性数据结构。现实生活中有很多关于书库的例子，例如:我们说图书馆里的书库，里面的书一本书一本书地叠在一起。</li><li id="b2f0" class="mv mw iq ll b lm pb lp pc ls pd lw pe ma pf me nc nd ne nf bi translated"><strong class="ll ir">队列:</strong>队列的一个很好的例子是任何资源的任何客户队列，队列中排在第一位的客户将首先得到服务，当第一个客户离开队列时，更多的客户可以从队列的后面排队。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/698b7613ecc583e1ec65f0d015497f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ex-syq-BAiDQDLbOp3KUMg.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Stack &amp; Queue</strong></figcaption></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="7e0f" class="om ks iq bd kt on oo dn kx op oq dp lb ls or os ld lw ot ou lf ma ov ow lh ox bi translated">3.合并排序</h2><p id="d6ab" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是一个<strong class="ll ir"> <em class="ng">分治算法</em> </strong>，我们将输入数组分成两半，它为这两半调用自己，然后合并排序后的两半。为了更好地理解，请看一下我在下面展示的例子。</p><ul class=""><li id="f99e" class="mv mw iq ll b lm mx lp my ls mz lw na ma nb me nc nd ne nf bi translated">我们有一个输入数组，如示例中所述，在merge-sort中，当我们将输入数组分成两半时，我们需要计算该数组中元素的索引，以便我们可以将数组分成两半。</li><li id="005b" class="mv mw iq ll b lm pb lp pc ls pd lw pe ma pf me nc nd ne nf bi translated">在这里，我们可以看到数组中有5个元素，所以我们将5除以2，结果，我们得到了数组中需要划分的元素的索引。</li><li id="5911" class="mv mw iq ll b lm pb lp pc ls pd lw pe ma pf me nc nd ne nf bi translated">当我们得到索引2时，我们简单地从第2个索引开始划分数组，之后，左边的数组<strong class="ll ir"> (8，2) </strong>不能再划分，所以我们根据顺序&amp;对其排序。转换后的数组现在是<strong class="ll ir"> 2，8 </strong>。</li><li id="11b2" class="mv mw iq ll b lm pb lp pc ls pd lw pe ma pf me nc nd ne nf bi translated">现在我们在处理右边的数组，用同样的除法术语来获得索引，我们在数组不能再分的地方继续分，之后，我们按照它们的顺序排序。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/f058e5a9171994aebf10baa0ce8c9860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_UcpP5LlXmODBvHYWNFFQg.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Merge Sort</strong></figcaption></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="783f" class="om ks iq bd kt on oo dn kx op oq dp lb ls or os ld lw ot ou lf ma ov ow lh ox bi translated">4.二叉树</h2><p id="0c2d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">二叉树中有很多东西需要学习，所以我将只关注入门前你必须知道的基础知识。</p><p id="d365" class="pw-post-body-paragraph lj lk iq ll b lm mx jr lo lp my ju lr ls nw lu lv lw ny ly lz ma oa mc md me ij bi translated"><em class="ng">二叉树是一种每个节点最多有两个子节点的树。</em></p><ul class=""><li id="37db" class="mv mw iq ll b lm mx lp my ls mz lw na ma nb me nc nd ne nf bi translated">二叉查找树:树在计算机科学中有大量的应用，因为它们被用于数据库、自动完成、压缩算法等。二叉查找树是一种二叉树，其中每个节点遵循对它们排序的属性。例如所有后代&lt; = n &lt;所有正确的后代&amp;子树也是如此。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/2dbd721e6bcc7d7345b59b0bf1edeff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHn_5COi0jNTkxQ6NHlalA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Binary Search Tree</strong></figcaption></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="d6ae" class="om ks iq bd kt on oo dn kx op oq dp lb ls or os ld lw ot ou lf ma ov ow lh ox bi translated">5.图表</h2><p id="c8ff" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这种数据结构由一组有限的节点和一组连接它们的边组成。<strong class="ll ir"> <em class="ng">例如</em> </strong>，一对<strong class="ll ir"> (x，y) </strong>被称为边，它传达了<strong class="ll ir"> <em class="ng"> x节点</em> </strong>连接到<strong class="ll ir"> <em class="ng"> y节点</em> </strong>。</p><p id="28fe" class="pw-post-body-paragraph lj lk iq ll b lm mx jr lo lp my ju lr ls nw lu lv lw ny ly lz ma oa mc md me ij bi translated">图被大量用于解决包含网络复杂性的现实生活问题，例如社交网站数据库中的用户可以被表示为节点，而与另一个用户的连接可以被表示为节点之间的边。<strong class="ll ir"> <em class="ng">每个节点可以存储用户的信息。</em> </strong></p><blockquote class="mf"><p id="c813" class="mg mh iq bd mi mj mk ml mm mn mo me dk translated">图形的类型</p></blockquote><ul class=""><li id="5f20" class="mv mw iq ll b lm mq lp mr ls oc lw od ma oe me nc nd ne nf bi translated"><strong class="ll ir">无向图:</strong>节点通过边以双向方式连接，因此如果一条边连接两个节点，那么我们可以从节点1横向到节点2，反之亦然。</li><li id="8876" class="mv mw iq ll b lm pb lp pc ls pd lw pe ma pf me nc nd ne nf bi translated"><strong class="ll ir">有向图:</strong>节点仅通过有向边以有向方式连接，因此如果一条边连接两个节点，我们只能从节点1和节点2横向穿过，而不能在相反方向穿过。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/f23cba0abc2da110330563a2b08c88d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42WIX_dHLenhgYeF9H1nPQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Graphs</strong></figcaption></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="62f5" class="om ks iq bd kt on oo dn kx op oq dp lb ls or os ld lw ot ou lf ma ov ow lh ox bi translated">6.哈希表</h2><p id="8323" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你是学习数据结构和算法的新手，那么哈希表在实际情况下很难理解，因为它们比基本数据结构更复杂。哈希表用于构建<strong class="ll ir">拼写检查器</strong>、<strong class="ll ir">编译器、字典</strong>、&amp;代码编辑器。</p><p id="b12d" class="pw-post-body-paragraph lj lk iq ll b lm mx jr lo lp my ju lr ls nw lu lv lw ny ly lz ma oa mc md me ij bi translated">在哈希表中，数据存储在键-值对中，键被发送给哈希函数，哈希函数对其执行算术运算&amp;结果称为<strong class="ll ir"> <em class="ng">哈希值</em> </strong>，它是哈希表中键-值对的索引。</p><p id="07c2" class="pw-post-body-paragraph lj lk iq ll b lm mx jr lo lp my ju lr ls nw lu lv lw ny ly lz ma oa mc md me ij bi translated"><strong class="ll ir"> <em class="ng">一个基本哈希表由两部分组成:</em> </strong></p><ul class=""><li id="57af" class="mv mw iq ll b lm mx lp my ls mz lw na ma nb me nc nd ne nf bi translated"><strong class="ll ir">哈希函数:</strong>它决定了我们的键值对的索引。</li><li id="11ea" class="mv mw iq ll b lm pb lp pc ls pd lw pe ma pf me nc nd ne nf bi translated"><strong class="ll ir"> Array: </strong>它保存表中所有的键值条目，数组的大小根据我们期望的数据量来设置。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/ea83a75d6e73e49cc3ee3ab451058402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rqz1bgqudZmo4sKCTj9OtQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Hash Tables</strong></figcaption></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="125d" class="om ks iq bd kt on oo dn kx op oq dp lb ls or os ld lw ot ou lf ma ov ow lh ox bi translated">7.大O符号</h2><p id="da7c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">简而言之，<em class="ng">大O符号</em>描述了一个算法的性能，它让我们了解当提供大量输入数据时，该算法将如何执行。</p><p id="9bca" class="pw-post-body-paragraph lj lk iq ll b lm mx jr lo lp my ju lr ls nw lu lv lw ny ly lz ma oa mc md me ij bi translated"><strong class="ll ir"> <em class="ng">例如，</em> </strong> <em class="ng">我们可以很容易地通过一个数组元素的索引来访问它，这样就够快了，但是如果我们不得不</em> <strong class="ll ir"> <em class="ng">添加</em> </strong> <em class="ng">或</em> <strong class="ll ir"> <em class="ng">删除数组中的</em> </strong> <em class="ng">项，如果输入的数据太大，代价就会很大。同样，如果我们需要添加或删除项目，我们有</em> <strong class="ll ir"> <em class="ng">链表</em> </strong> <em class="ng">，它可以快速增长或收缩，但通过索引访问项目的</em> <strong class="ll ir"> <em class="ng">速度很慢</em> </strong> <em class="ng">。当我们必须根据所需的性能选择算法时，这就是大O符号发挥作用的地方。</em></p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="c4b6" class="om ks iq bd kt on oo dn kx op oq dp lb ls or os ld lw ot ou lf ma ov ow lh ox bi translated">8.线性搜索</h2><p id="7081" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">它在时间复杂度为<strong class="ll ir"> O(n) </strong>的元素列表中查找给定元素，其中<strong class="ll ir"> n </strong>表示列表中元素的总数。这被认为是最简单的搜索算法，因为该过程从比较搜索元素和列表中的第一个元素开始，如果两者都匹配，则我们获得结果，否则它继续与列表中的下一个元素进行比较。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/4b01eb8915f4e6c7ccbd07d19cb418c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0wLsZreLODCFgqIOB55-w.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Linear Search</strong></figcaption></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="7bb2" class="om ks iq bd kt on oo dn kx op oq dp lb ls or os ld lw ot ou lf ma ov ow lh ox bi translated">9.冒泡排序</h2><p id="b2d3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一种简单的排序算法，如果相邻元素的顺序不正确，则交换相邻元素，然后多次迭代数组，直到元素的顺序正确为止。</p><p id="5bbf" class="pw-post-body-paragraph lj lk iq ll b lm mx jr lo lp my ju lr ls nw lu lv lw ny ly lz ma oa mc md me ij bi translated"><strong class="ll ir"> <em class="ng">例如:</em> </strong></p><ul class=""><li id="9980" class="mv mw iq ll b lm mx lp my ls mz lw na ma nb me nc nd ne nf bi translated">我们有一个包含4个元素的数组，它们的相关索引为<strong class="ll ir"> (0，1，2，3) </strong>，使用冒泡排序，我们通过交换相邻的元素来对最高值进行排序。</li><li id="165d" class="mv mw iq ll b lm pb lp pc ls pd lw pe ma pf me nc nd ne nf bi translated">我们比较索引<strong class="ll ir"> 0 </strong> &amp; <strong class="ll ir"> 1 </strong>，按顺序排列它们并继续下一个交换操作，等等，直到我们找到正确顺序中的最高值，我们必须继续迭代数组。</li></ul><blockquote class="mf"><p id="e65b" class="mg mh iq bd mi mj nn no np nq nr me dk translated">之所以称之为冒泡排序，是因为在每次迭代之后，具有最高值的元素被移动到最正确的位置，这被称为冒泡。</p></blockquote><figure class="pj pk pl pm pn kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/56d22bcc178e1732a4cbd935f57eab3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JWBwFS5I8l6XvRzk58t2A.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">Bubble Sort</strong></figcaption></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt po"><a rel="noopener  ugc nofollow" target="_blank" href="/10-must-have-tools-for-react-developers-in-2021-b063426b43fd"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd ir gy z fp pt fr fs pu fu fw ip bi translated">2021年React开发者的10个重要工具</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">使用React工具的正确生态系统来制作出色的React应用程序。</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="px l"><div class="py l pz qa qb px qc kp po"/></div></div></a></div><div class="qd qe gp gr qf po"><a rel="noopener  ugc nofollow" target="_blank" href="/design-patterns-in-react-native-component-patterns-785d585ac3f"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd ir gy z fp pt fr fs pu fu fw ip bi translated">React Native中的设计模式:组件模式</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">学习在React Native中创建可重用的表示组件</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="px l"><div class="qg l pz qa qb px qc kp po"/></div></div></a></div></div></div>    
</body>
</html>