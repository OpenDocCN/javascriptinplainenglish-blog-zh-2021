<html>
<head>
<title>Understand JavaScript Array Methods Like A Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专家一样理解JavaScript数组方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-javascript-array-methods-like-a-pro-part-2-6222e7642ce3?source=collection_archive---------20-----------------------#2021-08-06">https://javascript.plainenglish.io/understand-javascript-array-methods-like-a-pro-part-2-6222e7642ce3?source=collection_archive---------20-----------------------#2021-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="21f1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript数组方法的全面概述—第2部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/733882a12f5f523f6ae9a9053bb29495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlSpQkFDTMOCMKP3B2yKwQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.pexels.com/@divinetechygirl?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Christina Morillo</a> from <a class="ae kv" href="https://www.pexels.com/photo/two-women-looking-at-the-code-at-laptop-1181263/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="f1c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎回到我的系列<strong class="ky ir">像专家一样理解JavaScript数组方法！</strong>如果你错过了第一部分，我建议你在深入第二部分之前先检查一下。👇</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt lz"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-javascript-array-methods-like-a-pro-72be6153320f"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">像专家一样理解JavaScript数组方法</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">如果你真的想成为JavaScript专家，那么你必须能够完全理解数组方法是如何工作的…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kp lz"/></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="d3a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上次我们看了JavaScript提供的一些初学者数组方法，以及何时应该使用它们。在本系列的这一部分中，我们将深入探讨更高级的数组方法，如<strong class="ky ir"> map()、some()和reduce() </strong>。我倾向于使用这些方法，仅仅是因为它们在我的应用程序中使用时非常强大。读完这个系列，你也应该对这些方法的工作原理有一个专业的理解。</p><p id="87dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说够了，让我们开始吧…</p><h1 id="b6bf" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">map()方法</h1><p id="32f5" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">欢迎使用地图方法！我非常兴奋地谈论这个方法，因为它是我的应用程序中最常用的方法。地图方法超级强大，非常容易理解。让我们来看看这个方法到底有多强大:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="f4a6" class="nq mp iq nm b gy nr ns l nt nu">const galaxy = ['rick','morty','kate','jerry','summer','snowball'];</span><span id="23c4" class="nq mp iq nm b gy nv ns l nt nu">let sub_world = [];</span><span id="52cf" class="nq mp iq nm b gy nv ns l nt nu">for(let i = 0; i &lt; galaxy.length; i++){<br/> sub_world.push({index: i, name: galaxy[i]})<br/>}</span><span id="a0e8" class="nq mp iq nm b gy nv ns l nt nu">console.log({sub_world});</span><span id="9c2b" class="nq mp iq nm b gy nv ns l nt nu">//output<br/>//[{index: 0, name: 'rick'},{index: 1, name: 'morty'},{index: 2,   name: 'jerry'},{index: 3, name: 'summer'},{index: 4, name: 'snowball'}]</span></pre><p id="bacd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们循环遍历数组，并将一个新对象推送到我们的<strong class="ky ir"> sub_world </strong>数组中，该数组包含元素的索引和元素的名称。在我们完成对数组的迭代后，我们记录新数组，以查看它返回了一个全新的对象数组。这看起来很简单，不是吗？</p><p id="b402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，但是如果你还记得这个系列的第一部分，因为循环很快就要灭绝了，仅仅是因为现在有了更简单的方法。</p><p id="f056" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何使用map方法实现相同的代码</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="9985" class="nq mp iq nm b gy nr ns l nt nu">const galaxy = ['rick','morty','kate','jerry','summer','snowball'];</span><span id="edd3" class="nq mp iq nm b gy nv ns l nt nu">const sub_world = galaxy.map((name,index) =&gt; ({index, name}))</span><span id="4687" class="nq mp iq nm b gy nv ns l nt nu">console.log({sub_world});</span><span id="333a" class="nq mp iq nm b gy nv ns l nt nu">//output<br/>//[{index: 0, name: 'rick'},{index: 1, name: 'morty'},{index: 2,   name: 'jerry'},{index: 3, name: 'summer'},{index: 4, name: 'snowball'}]</span></pre><p id="3485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一下上面的代码。请注意map方法与我们在之前的故事中看到的<strong class="ky ir"> forEach </strong>方法是多么的相似。这里的区别是map方法返回一个数组，而forEach不返回任何东西。</p><p id="f11f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">map函数实际上是用来将一个数组映射到一个新的数组，我们可以做的事情是无限的。现在让我们看一个更复杂的例子。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="6003" class="nq mp iq nm b gy nr ns l nt nu">const galaxy = ['rick','morty','kate','jerry','summer','snowball'];</span><span id="210e" class="nq mp iq nm b gy nv ns l nt nu">const friends = [<br/> {id: 0, name: 'bird man'},{id: 0, name: 'noob noob'},<br/> {id: 1, name: 'jessica'},{id: 1, name: 'morty jr.'},<br/> {id: 0, name: 'morty'},{id: 2, name: 'jerry'},<br/> {id: 4, name: 'morty'},{id: 4, name: 'rick'},<br/> {id: 4, name: 'ethan'},{id: 5, name: 'morty'},<br/> {id: 5, name: 'jerry'},{id: 3, name: 'snowball'}<br/>]</span><span id="21b0" class="nq mp iq nm b gy nv ns l nt nu">const sub_world = galaxy.map((name,index) =&gt; {<br/> const my_friends = friends.filter(friend =&gt; friend.id === index).map(friend =&gt; friend.name);<br/>  return {<br/>   name: name,<br/>    friends: my_friends<br/>  }<br/>})</span><span id="88a2" class="nq mp iq nm b gy nv ns l nt nu">console.log({sub_world});</span><span id="22ef" class="nq mp iq nm b gy nv ns l nt nu">//output<br/>//[{name: 'rick', friends:['bird man','noob noob','morty']},<br/>// {name: 'morty', friends:['jessica','morty jr.']},<br/>// {name: 'kate', friends:['jerry']},<br/>// {name: 'jerry', friends:['snowball']},<br/>// {name: 'summer', friends:['morty','rick','ethan']},<br/>// {name: 'snowball', friends:['morty','jerry']}]</span></pre><p id="2dd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能看起来很难理解，但是相信我，当我们开始分解它时，它是相当简单的。在上面的例子中，我们迭代了星系数组中的每个元素。对于数组中的每个元素，我们过滤掉<strong class="ky ir"> friends </strong>数组，并找到与当前元素的索引相匹配的元素。然后，我们将结果映射回一个名为<strong class="ky ir"> my_friends </strong>的新数组。一旦完成，我们返回当前元素名称的对象，以及我们在<strong class="ky ir"> friends </strong>数组中找到的它们的朋友。</p><p id="716f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是地图方法如此强大的原因💪。</p><h1 id="cb4d" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">何时使用map()方法</h1><p id="1c4a" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">map方法是我最常用和最喜欢的JavaScript数组方法之一。这种方法在我发现自己处于的任何情况下都很方便。如上所述，我们可以使用map方法将一个旧数组转换成一个新的对象数组，或者基本上是任何与此相关的东西。当我们需要将两个数组合并成一个数组时，我们也可以使用这种方法(只有当两个数组的大小都相当小时，我才会推荐这种方法)。</p><p id="927e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以map方法处理数组，但是对象呢？</p><p id="0174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很高兴你问了。map方法不直接处理对象，但是我们总是可以使用<strong class="ky ir"> Object.entries() </strong>方法将对象转换成数组(在本系列中我们不会讨论这个方法)，然后像以前一样使用它。</p><h1 id="8f4d" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">reduce()方法</h1><p id="ba78" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">说到整合，reduce方法就是为此而构建的。</p><p id="e794" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我在编写应用程序时经常使用的另一个数组方法。这是最复杂的数组方法之一，但如果使用正确，它绝对是强大的。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="e0ba" class="nq mp iq nm b gy nr ns l nt nu">const numbers = [1,10,44,21,19,2,3];</span><span id="38b9" class="nq mp iq nm b gy nv ns l nt nu">let total = 0;</span><span id="da3f" class="nq mp iq nm b gy nv ns l nt nu">for(let i = 0; i &lt; numbers.length; i++){<br/> total += numbers[i];<br/>}</span><span id="b72d" class="nq mp iq nm b gy nv ns l nt nu">console.log({total});</span><span id="6ae4" class="nq mp iq nm b gy nv ns l nt nu">//output: 100</span></pre><p id="8a31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看上面的例子，我们可以看到一个简单的for循环，它取数组中所有数字的和。让我们继续用reduce方法替换for循环:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="ef74" class="nq mp iq nm b gy nr ns l nt nu">const numbers = [1,10,44,21,19,2,3];</span><span id="3232" class="nq mp iq nm b gy nv ns l nt nu">const total = numbers.reduce((sum,number) =&gt; sum + number,0)</span><span id="4635" class="nq mp iq nm b gy nv ns l nt nu">console.log({total});</span><span id="7130" class="nq mp iq nm b gy nv ns l nt nu">//output: 100</span></pre><p id="9252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意reduce方法如何产生与之前相同的输出。好吧，我知道你在想什么，这看起来很混乱。相信我，我花了一段时间才明白这种方法是如何运作的。我会尽力解释，但事情是这样的:</p><p id="d4a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">reduce方法的第一个参数叫做<em class="nw">累加器</em>，它的目的是……嗯，累加东西。在这种情况下，它将保存数组中数字的总和，我们可以初始化我们的总和，从我们喜欢的任何值开始，因此在reduce方法的末尾是“0”。第二个参数是我们的数组元素。这就像forEach和map一样，给我们当前所在的元素。最后，我们将当前总和与当前元素相加，并返回结果，直到访问完数组中的所有元素。</p><p id="1e55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子有点简单，所以让我们来看看reduce方法的一个更实际的用例。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="2d7d" class="nq mp iq nm b gy nr ns l nt nu">const galaxy = ['rick','morty','rick','jerry','summer','summer','kate','noob noob','morty','rick','rick','summer','morty'];</span><span id="1fd4" class="nq mp iq nm b gy nv ns l nt nu">const character_count = galaxy.reduce((obj,name) =&gt; {<br/> obj[name] ? obj[name]++ : obj[name] = 1<br/>  return obj;<br/>},{})</span><span id="94c1" class="nq mp iq nm b gy nv ns l nt nu">console.log({character_count});</span><span id="d03b" class="nq mp iq nm b gy nv ns l nt nu">//output<br/>//{jerry: 1, kate: 1, morty: 3, noob noob: 1, rick: 4, summer: 3}</span></pre><p id="ddf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们试图计算一个特定的字符在数组中出现的次数。这里我们的累加器是一个对象而不是一个数字，我们的第二个参数和之前一样。我们在数组的第一次迭代中初始化一个空对象。如果一个字符已经存在于我们的对象中，那么我们增加该字符的计数，否则，我们用该字符的名称创建一个新的属性，并将其计数设置为1。</p><p id="511b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，似乎我们有一个额外的瑞克在我们的星系中翻找…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/034850730de34a6b0010a977892cfa54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*QubFvi5EoxwMMGkm_gF5IQ.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">rick and morty evil morty theme song — soundcloud.com</figcaption></figure><h1 id="72aa" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">何时使用reduce()方法</h1><p id="2afa" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">reduce方法几乎在所有情况下都有用。如果我们需要得到一个快速的总数，如果我们需要创建一个具有唯一值的对象，或者像map方法一样产生另一个数组，我们可以使用它。我通常不使用reduce方法来生成另一个数组，原因很简单，因为map方法已经这样做了，使用reduce只会让它更难理解。</p><h1 id="dca9" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">some()方法</h1><p id="8985" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这种方法不像其他两种方法那么复杂，但我认为这是一种容易被大多数开发人员遗忘的方法。作为一个被遗忘的方法，它仍然在我的应用程序中有一些用处…</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="434b" class="nq mp iq nm b gy nr ns l nt nu">const products = ['potato','banana','strawberry','beans','coffee','cake']</span><span id="0213" class="nq mp iq nm b gy nv ns l nt nu">const check_avail = 'beans'<br/>let available = false;</span><span id="6c34" class="nq mp iq nm b gy nv ns l nt nu">for(let i = 0; i &lt; products.length; i++){<br/> if(products[i] === check_avail){<br/>   available = true;<br/>  }<br/>}</span><span id="29da" class="nq mp iq nm b gy nv ns l nt nu">console.log(`The product: ${check_avail} is ${available ? '' : 'not '}available`)</span><span id="45bf" class="nq mp iq nm b gy nv ns l nt nu">//output: The product: beans is available</span></pre><p id="c27a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子演示了我们如何检查一系列产品的可用性。如果我们正在寻找的产品可用，那么我们将变量设置为true并记录输出。老实说，对于这种问题使用for循环有点大材小用，但是我们可以通过使用some方法来减少代码量。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="1ce0" class="nq mp iq nm b gy nr ns l nt nu">const products = ['potato','banana','strawberry','beans','coffee','cake']</span><span id="11e5" class="nq mp iq nm b gy nv ns l nt nu">const check_avail = 'beans'<br/>const available = products.some(product =&gt; product === check_avail)</span><span id="7553" class="nq mp iq nm b gy nv ns l nt nu">console.log(`The product: ${check_avail} is ${available ? '' : 'not '}available`)</span><span id="3fec" class="nq mp iq nm b gy nv ns l nt nu">//output: The product: beans is available</span></pre><p id="c7ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码片段演示了我们如何通过使用some方法获得相同的输出。与其他方法一样，这种方法的工作方式完全相同，只是它返回被检查的条件是真还是假。我们也可以用<strong class="ky ir"> find() </strong>方法来做这个检查，但是这将导致我们进行额外的检查来确认是否找到了结果。</p><h1 id="b82a" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">何时使用some()方法</h1><p id="3363" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">当我们需要检查数组中的条件是否满足时，some方法变得非常有用，例如检查产品当前是否可用，或者我们是否需要检查某个数量是否存在。我经常使用这种方法，希望这能让其他人也用上它。</p><h1 id="07a0" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="10aa" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">好了，你知道了。理解这些方法是如何工作的确实有助于练习。你用得越多，你就越能理解如何以及何时正确使用它们。</p><p id="805e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，这是这个系列的结尾，但我希望在不久的将来能做更多这样的事情。</p><p id="0436" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一如既往，感谢再次阅读，不要忘记鼓掌，我会很快再见到你。👋</p><p id="a5ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nw">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>