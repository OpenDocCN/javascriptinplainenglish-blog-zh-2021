<html>
<head>
<title>How to Traverse a Matrix: Largest Elements in their Rows &amp; Columns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何遍历矩阵:行和列中的最大元素</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-traverse-a-matrix-largest-elements-in-their-rows-columns-e48621ce1f6e?source=collection_archive---------4-----------------------#2021-04-24">https://javascript.plainenglish.io/how-to-traverse-a-matrix-largest-elements-in-their-rows-columns-e48621ce1f6e?source=collection_archive---------4-----------------------#2021-04-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ce1e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">演示如何处理包含0和1的二维整数列表，并使用JavaScript中的频率计数器查找最大的元素</h2></div><p id="dca0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎来到矩阵。不，<em class="ky">不是那个矩阵</em>，很遗憾。</p><p id="6023" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我在Leetcode，或者在这种情况下，binarysearch.com的页面上徘徊时，我倾向于回避我不熟悉的输入。我很容易被吓到(这不是骗人的！)</p><p id="8d8e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">矩阵也不例外。到目前为止，如果我看到一个矩阵作为输入，我会立即转向另一个问题。然而，今天我不得不勇敢地面对我的恐惧，因为我和我的朋友在一次结对编程中遇到了这个问题。不出所料，我很难想象如何处理这样的输入，更不用说尝试解决问题了。</p><p id="4897" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的朋友，以典型的方式，开始不停地编码&amp;在我理解问题之前就找到了解决方案。然而，当我开始一步一步地解决问题&amp;开始以一种不同的方式可视化矩阵时，事情开始变得明朗起来&amp;突然间，问题和解决方案变得有意义了。</p><p id="3dbb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章能帮助你实现那个时刻。事不宜迟，让我们跳进自己的矩阵世界，解决这个问题。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/397d81c4959fb22fb85012948b88ecde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tVoPY5tOqdNTqqXu"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Which will it be?</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="7607" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">什么是矩阵？</h1><p id="b266" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">这是我们的第一个障碍。让我们来看一个简单的矩阵:</p><pre class="la lb lc ld gt mt mu mv mw aw mx bi"><span id="37e0" class="my lx in mu b gy mz na l nb nc">matrix = [<br/>    [0, 0, 1],<br/>    [1, 0, 0],<br/>    [0, 1, 0]<br/>]</span></pre><p id="d5f9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">乍一看，它可能看起来令人望而生畏。我花了几分钟对自己思考，<em class="ky">我到底该怎么做？</em></p><p id="7c90" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但如果你仔细观察，我们的矩阵只是一个数组的数组。让我们把矩阵改写成不那么可怕的东西:</p><pre class="la lb lc ld gt mt mu mv mw aw mx bi"><span id="2cca" class="my lx in mu b gy mz na l nb nc">matrix = [ [0, 0, 1], [1, 0, 0], [0, 1, 0] ]</span></pre><p id="337e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，这个小小的调整让事情变得稍微好了一点(这可能也是我反应迟钝的原因)。但是矩阵到底是什么？</p><p id="1327" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，矩阵是数字的平方，或者是数字的2D矩阵。换句话说，子数组在数组中必须包含相同数量的元素。在上面的例子中，我们的每个数组都有三个整数。如果其中一个有4或2个元素，它就不再是一个矩阵。</p><p id="b819" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们对矩阵有了更好的理解，让我们引入一个问题来学习如何遍历矩阵。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="d2f2" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">问题是</h1><p id="49a0" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">问题陈述:</p><p id="7014" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">给你一个二维的整数列表</em> <code class="fe nd ne nf mu b"><em class="ky">matrix</em></code> <em class="ky">，包含</em> <code class="fe nd ne nf mu b"><em class="ky">1</em></code> <em class="ky"> s和</em> <code class="fe nd ne nf mu b"><em class="ky">0</em></code> <em class="ky"> s，返回</em> <code class="fe nd ne nf mu b"><em class="ky">matrix</em></code> <em class="ky">中元素的个数如下:</em></p><ul class=""><li id="a415" class="ng nh in ke b kf kg ki kj kl ni kp nj kt nk kx nl nm nn no bi translated"><code class="fe nd ne nf mu b"><em class="ky">matrix[r][c] = 1</em></code></li><li id="d349" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nl nm nn no bi translated"><code class="fe nd ne nf mu b"><em class="ky">matrix[r][j] = 0</em></code> <em class="ky">为每</em> <code class="fe nd ne nf mu b"><em class="ky">j ≠ c</em></code> <em class="ky">和</em> <code class="fe nd ne nf mu b"><em class="ky">matrix[i][c] = 0</em></code> <em class="ky">为每</em> <code class="fe nd ne nf mu b"><em class="ky">i ≠ r</em></code></li></ul><p id="56b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哇哦。好吧——我从哪里开始理解这一点呢？</p><p id="2fcf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们再看看上面的例子:</p><pre class="la lb lc ld gt mt mu mv mw aw mx bi"><span id="c174" class="my lx in mu b gy mz na l nb nc">matrix = [<br/>    [0, 0, 1],<br/>    [1, 0, 0],<br/>    [0, 1, 0]<br/>]</span></pre><p id="1e33" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看我们的第一个要点，我们想找到<code class="fe nd ne nf mu b"><em class="ky">matrix[r][c] = 1.</em></code></p><p id="3501" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住，我们的矩阵是数组的数组。因此，r表示行，即矩阵中的三个子数组，c表示列，即每个子数组中的三个整数。</p><p id="5526" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在寻找1的值。然而，在我们的第二个要点中，我们有几个额外的事情要考虑。</p><ul class=""><li id="acfc" class="ng nh in ke b kf kg ki kj kl ni kp nj kt nk kx nl nm nn no bi translated"><code class="fe nd ne nf mu b"><em class="ky">matrix[r][j] = 0</em></code> <em class="ky">为每一个</em> <code class="fe nd ne nf mu b"><em class="ky">j ≠ c</em></code></li></ul><p id="0907" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着在我们找到1的那一行中，所有其他值都必须等于0。</p><ul class=""><li id="813a" class="ng nh in ke b kf kg ki kj kl ni kp nj kt nk kx nl nm nn no bi translated"><code class="fe nd ne nf mu b"><em class="ky">matrix[i][c] = 0</em></code> <em class="ky">为每一个</em> <code class="fe nd ne nf mu b"><em class="ky">i ≠ r</em></code></li></ul><p id="687e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着，在我们找到1的列(或索引)中，该索引中的所有其他子数组都必须是0。</p><p id="69bd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们再来看看我们的样本矩阵:</p><pre class="la lb lc ld gt mt mu mv mw aw mx bi"><span id="1811" class="my lx in mu b gy mz na l nb nc">matrix = [<br/>    [0, 0, 1],<br/>    [1, 0, 0],<br/>    [0, 1, 0]<br/>]</span></pre><p id="f27e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以看到，在我们的第一排，我们有一个<em class="ky">一个</em> 1(与第二个&amp;第三排相同)。然后我们检查它们各自的列中是否有1，在这种情况下没有。因此，本例的预期输出是3。我们有<code class="fe nd ne nf mu b">matrix[0][2]</code>、<code class="fe nd ne nf mu b">matrix[1][0]</code>和<code class="fe nd ne nf mu b">matrix[2][1]</code>符合标准。</p><p id="092b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看另一个例子:</p><pre class="la lb lc ld gt mt mu mv mw aw mx bi"><span id="cbae" class="my lx in mu b gy mz na l nb nc">matrix = [<br/>    [0, 0, 1],<br/>    [1, 0, 0],<br/>    [1, 0, 0]<br/>]</span></pre><p id="14c7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以看到每排有<em class="ky">一个</em> 1。然而，当我们检查它们各自的列中是否有1时，我们看到第2个&amp;第3行在第0个索引中都包含1。只有<code class="fe nd ne nf mu b">matrix[0][2]</code>符合标准。其他两个<code class="fe nd ne nf mu b">1</code>共享同一列，因此我们的预期输出是1。</p><p id="ebcf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一点上，我们应该感觉很好。我们终于很好地理解了这个问题&amp;我们想要的输出应该是什么。我们已经通过对矩阵的理解取得了重大进展——也许我们应该稍微变通一下？</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nu"><img src="../Images/b2c090f7d137de642ea210e8624665da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tUShFtXFrO4BlG04"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Maybe my back isn’t ready for this after all…</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="f3a1" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">方法</h1><p id="1c36" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">让我们谈谈我们将如何处理这个问题。记住，我们的矩阵本质上是一个数组的数组。我们不仅需要迭代我们的矩阵数组，还需要迭代每个子数组的单个元素，以计算其行和列中1的数量。</p><p id="4188" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，我认为我们可以建立一个外部for循环来迭代我们的三个数组。然后，我们可以设置一个内部for循环来迭代子数组的每个元素。</p><p id="7756" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我们使用频率计数器发挥作用的地方。当我们找到一个1时，我们可以计算这一行中1的数量。如果不止一个，那么我们知道这不算数&amp;我们继续迭代。然而，如果1的频率计数仅仅是1，那么我们可以进行第二个频率计数器来计数其他数组中该索引中1的数量。如果1的频率计数在这种情况下也是1，我们可以得出结论，矩阵[r][c]满足我们所有的标准，我们可以将计数增加1。</p><p id="3995" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">咻——我知道这很复杂&amp;用一种混乱的方式来解决这个问题，但是和我在一起吧！</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="2f8d" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">伪代码</h1><p id="0088" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">在我们开始之前，让我们先做一点伪代码&amp;用简单的英语看看我们的代码会是什么样子:</p><ol class=""><li id="0274" class="ng nh in ke b kf kg ki kj kl ni kp nj kt nk kx nv nm nn no bi translated">实例化一个名为count的变量。这将是我们函数结束时的输出</li><li id="892f" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nv nm nn no bi translated">建立一个外部for循环，它将迭代矩阵的长度，换句话说，就是数组中子数组的数量</li><li id="870d" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nv nm nn no bi translated">建立一个内部for循环，它将迭代一个子数组的长度(记住，我们所有的子数组都有相同的长度)</li><li id="bb67" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nv nm nn no bi translated">如果矩阵[i][j]等于1，我们将需要计算该子数组中1的总数。我们将把频率计数器存储在一个名为rowFreq的散列中。</li><li id="8f9d" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nv nm nn no bi translated">如果rowFreq[1](即该行中1的总频率)等于1，我们将需要计算每个子数组的索引中1的总数。我们将把频率计数器存储在一个名为columnFreq的散列中。</li><li id="3728" class="ng nh in ke b kf np ki nq kl nr kp ns kt nt kx nv nm nn no bi translated">如果我们的columnFreq[1]等于1，我们可以得出结论，它是该行&amp;该列中唯一的1，并将我们的计数增加1</li></ol></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="756d" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">解决方案</h1><p id="d609" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">太好了——让我们开始写代码吧。在上面的伪代码中，我们已经有了路线图，所以让我们一步步来:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nw"><img src="../Images/85eb1df1e2c29b1555b87054db1d62d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SHlj2LzwITpJH3ruxuxqg.png"/></div></div></figure><p id="8fc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，我们实例化了count变量，并设置了每个子数组的长度。我们设置了两个for循环，外部的for循环迭代矩阵数组的长度，内部的for循环迭代子数组的长度。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nx"><img src="../Images/7b6f1db6a121bf3f054a2096c7dc71dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raTUTlwNO3jRXhaOszMiMQ.png"/></div></div></figure><p id="504e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，我们检查子数组中是否有1。如果我们找到1，我们为该行设置一个频率计数器，以确定该子数组中0和1的数量。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ny"><img src="../Images/0f133c355d2e7926ba6240046c3775be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-RiLXiRQDIjJnUgwr9k5mw.png"/></div></div></figure><p id="f7d8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，如果rowFreq[1]的频率是1，那么我们必须计算所有其他子数组的相同索引中1和0的频率。如果columnFreq[1]的值是1，那么我们将计数增加1。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="9e7a" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">结论</h1><p id="4d32" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">我希望这个演练能让你更好地理解什么是矩阵，以及我们如何使用外部和内部for循环遍历它。在我们的具体练习中，我们需要遍历矩阵来检查矩阵的行和列中1的频率。</p><p id="079a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然我承认这肯定不是解决这个问题的最干净的方法，但对于我们这些刚刚接触这些新概念的新手来说，这是一个很好的入门。我欢迎您的意见——如果您对矩阵有其他方法或问题，请随时联系我们，并在下面留下您的评论。</p><p id="19c2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下次见！</p><p id="1bc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em><a class="ae nz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>