<html>
<head>
<title>What Are Primitive Types in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原语类型是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-primitive-types-in-javascript-671909def6ca?source=collection_archive---------4-----------------------#2021-01-06">https://javascript.plainenglish.io/what-are-primitive-types-in-javascript-671909def6ca?source=collection_archive---------4-----------------------#2021-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f5c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中有6种原始类型(或“原始数据类型”):数字、字符串、布尔、bigints、符号和<code class="fe kf kg kh ki b">undefined</code>。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/6a95201d8f95b486cbd90c258f3c9279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIfAJP8ZCy5CIJQF73GAtg.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@ellenauer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ellen Auer</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0588" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">基本类型不是JavaScript对象。</h1><p id="5e49" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">JavaScript中的一个基本概念是对象(属性集合)和基本类型之间有区别。</p><blockquote class="mo mp mq"><p id="15f0" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated">“在<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>中，<strong class="lu ir">原语</strong>(原语值，原语数据类型)是不是<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/object" rel="noopener ugc nofollow" target="_blank">对象</a>并且没有<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/method" rel="noopener ugc nofollow" target="_blank">方法</a>的数据。”— <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="d02b" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">JavaScript中有6种基本类型:</p><ol class=""><li id="99a0" class="na nb iq lu b lv ms ly mt mb nc mf nd mj ne mn nf ng nh ni bi translated"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-string-in-javascript-a16b196915ff" rel="noopener">琴弦</a></li><li id="fd34" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-boolean-in-javascript-98fdc8aec2a7" rel="noopener">布尔型</a></li><li id="0d99" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-number-in-javascript-8d9024708153" rel="noopener">数字</a>包括<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/coding-in-simple-english/how-to-check-for-nan-in-javascript-4294e555b447" rel="noopener">NaN</a></code>(“非数字”)</li><li id="b8fb" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">比根茨</li><li id="38d7" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated"><a class="ae kz" href="https://medium.com/p/30c3f294ea65" rel="noopener">符号</a></li><li id="020e" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/coding-at-dawn/how-to-check-for-undefined-in-javascript-bcedd62c8ad" rel="noopener">undefined</a></code></li></ol><p id="54b8" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">值<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">null</a></code>基本上也是一个原语，但是由于技术原因(我将在后面解释),它不被认为是原语。</p><p id="db9c" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">基本类型的概念可能会令人困惑，因为我们实际上可以像访问对象一样，在JavaScript中直接访问基本数据类型的属性和方法。</p><p id="8a2f" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">例如，字符串有一个<code class="fe kf kg kh ki b">.length</code> ( <code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length" rel="noopener ugc nofollow" target="_blank">String.prototype.length</a></code>)属性。然而，字符串不是对象——它们是原语。</p><p id="5a1c" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">JavaScript提供了某些助手(在本例中，在<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener ugc nofollow" target="_blank">的</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener ugc nofollow" target="_blank">String</a></code> <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener ugc nofollow" target="_blank"> </a>原型上)，但是字符串本身是<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/Immutable" rel="noopener ugc nofollow" target="_blank">不可变的</a>。</p><blockquote class="mo mp mq"><p id="34db" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated">所有原语都是<strong class="lu ir">不可变的</strong>，即它们不能被改变。重要的是不要把原语本身与被赋予原语值的变量混淆。可以给变量重新分配一个新值，但不能像改变对象、数组和函数那样改变现有值— <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="56e0" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">您通常会听到与原语一起使用的单词“突变”(意味着变化)或“可变性”(被改变的能力)。</p><p id="01ea" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">与您可以<code class="fe kf kg kh ki b">.push()</code> ( <code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="noopener ugc nofollow" target="_blank">Array.prototype.push()</a></code>)向其添加新项目的数组或可以使用<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors" rel="noopener ugc nofollow" target="_blank"/><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors" rel="noopener ugc nofollow" target="_blank">.</a></code><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors" rel="noopener ugc nofollow" target="_blank">属性访问器</a>添加新对象键的对象不同，您不能改变基本类型。</p><p id="45f0" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">换句话说，没有像数组那样的基元的“赋值方法”，数组有像<code class="fe kf kg kh ki b">.sort()</code> ( <code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank">Array.prototype.sort()</a></code>)这样的方法来改变数组。</p><p id="50e0" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">当我们在一个字符串上调用<code class="fe kf kg kh ki b">.toUpperCase()</code> ( <code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase" rel="noopener ugc nofollow" target="_blank">String.prototype.toUpperCase()</a></code>)时，我们得到一个新的字符串——但是现有的字符串永远不会改变。这就是基本类型的定义。</p><p id="432b" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">赋给变量名的内容(使用<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-use-let-var-and-const-in-javascript-cdf42b48d70" rel="noopener">let</a></code> <a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-use-let-var-and-const-in-javascript-cdf42b48d70" rel="noopener">、</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-use-let-var-and-const-in-javascript-cdf42b48d70" rel="noopener">var</a></code> <a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-use-let-var-and-const-in-javascript-cdf42b48d70" rel="noopener">或</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-use-let-var-and-const-in-javascript-cdf42b48d70" rel="noopener">const</a></code>关键字定义)是否可以改变，与是否可以改变一个基本类型是不同的问题。</p><p id="cbe6" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">例如，如果您定义了<code class="fe kf kg kh ki b">const x = 2</code>，那么<code class="fe kf kg kh ki b">x</code>不能被赋予新的值，因为它是用<code class="fe kf kg kh ki b">const</code>定义的。</p><p id="730c" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">然而，如果你定义一个对象<code class="fe kf kg kh ki b">y</code>为<code class="fe kf kg kh ki b">const y = {}</code>，那么<code class="fe kf kg kh ki b">y</code>不能被赋予一个新值，但是它的内容可以被改变。</p><p id="b162" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">对象是<strong class="lu ir">可变的</strong>，而原语是<strong class="lu ir">不可变的</strong>。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="7043" class="la lb iq bd lc ld nv lf lg lh nw lj lk jw nx jx lm jz ny ka lo kc nz kd lq lr bi translated">基本类型有基本包装对象。</h1><p id="0b22" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们获得这些助手属性的原因是因为在JavaScript中“包装”原始类型的<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">原型对象</a>。</p><blockquote class="mo mp mq"><p id="26a8" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated">“除了<code class="fe kf kg kh ki b">null</code>和<code class="fe kf kg kh ki b">undefined</code>之外，所有的原始值都有环绕原始值的对象等价物:</p><p id="5a2d" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener ugc nofollow" target="_blank">String</a></code>为字符串原语。</p><p id="9f5a" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="noopener ugc nofollow" target="_blank">Number</a></code>为数本原。</p><p id="022f" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="noopener ugc nofollow" target="_blank">BigInt</a></code>为bigint原始人。</p><p id="9476" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean" rel="noopener ugc nofollow" target="_blank">Boolean</a></code>为布尔原语。</p><p id="b89a" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated"><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">Symbol</a></code>为象征原始人。”— <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive#Primitive_wrapper_objects_in_JavaScript" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="6950" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">这里要记住的重要一点是，你永远不需要自己引用那些对象包装器。</p><p id="4cff" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">JavaScript在幕后自动将任何原语包装在对象包装器中，让您可以访问原型。</p><p id="77c3" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">如果您需要取回原始值本身，有一个名为<code class="fe kf kg kh ki b">valueOf()</code> ( <code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" rel="noopener ugc nofollow" target="_blank">Object.prototype.valueOf()</a></code>)的helper方法。</p><blockquote class="mo mp mq"><p id="73fc" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated">"包装器的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" rel="noopener ugc nofollow" target="_blank">valueOf()</a></code>方法返回原始值."— <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive#Primitive_wrapper_objects_in_JavaScript" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="c21c" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">你可以想象在一个原语上调用<code class="fe kf kg kh ki b">valueOf()</code>总是会返回原语本身。在实践中，它没有太多用处，但是如果你能理解<code class="fe kf kg kh ki b">valueOf()</code>发生了什么，那么你就会理解基本类型的对象包装概念。</p><p id="658e" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">每当您访问基元值的任何属性或方法时，这些相同的步骤都会在幕后发生:</p><ol class=""><li id="5719" class="na nb iq lu b lv ms ly mt mb nc mf nd mj ne mn nf ng nh ni bi translated">您有一个原始数据类型，例如<code class="fe kf kg kh ki b">"string"</code></li><li id="f759" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">您可以在原语上使用<code class="fe kf kg kh ki b">.</code>属性访问器</li><li id="c9b0" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">JavaScript自动包装原语</li><li id="ab7f" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">您现在可以访问原型方法了</li><li id="3a52" class="na nb iq lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated"><code class="fe kf kg kh ki b">"string".valueOf()</code>永远是<code class="fe kf kg kh ki b">"string"</code></li></ol><p id="79bf" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">除了<code class="fe kf kg kh ki b">undefined</code>之外，其他任何基元类型的过程都相同。现在让我们回到<code class="fe kf kg kh ki b">null</code>，它一点也不原始。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="30c9" class="la lb iq bd lc ld nv lf lg lh nw lj lk jw nx jx lm jz ny ka lo kc nz kd lq lr bi translated">为什么<code class="fe kf kg kh ki b">null</code>不是一个原始数据类型？</h1><p id="551d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">鉴于<code class="fe kf kg kh ki b">undefined</code>是一个原始类型，值<code class="fe kf kg kh ki b">null</code>似乎是一个原始类型。</p><blockquote class="mo mp mq"><p id="1301" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated">“还有<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/null" rel="noopener ugc nofollow" target="_blank">空</a>，看似原始，其实对于每一个<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">Object</a></code>都是一个特例:任何结构类型都是通过<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" rel="noopener ugc nofollow" target="_blank">原型链</a>从<code class="fe kf kg kh ki b">null</code>派生出来的。”— <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="775a" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">我们通常使用<code class="fe kf kg kh ki b">null</code>来表示<em class="mr">故意的</em>无值。相比之下，<code class="fe kf kg kh ki b">undefined</code>用于表示<em class="mr">无意的</em>无值(或尚未定义的值，如未知的对象属性)。</p><p id="73ab" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">然而<code class="fe kf kg kh ki b">null</code>实际上是所有物体的起源，想起来有点奇怪。我不会太担心，如果你把<code class="fe kf kg kh ki b">null</code>归为原始生物，就不会有坏事发生。</p><p id="9d4f" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">如果你关心为什么<code class="fe kf kg kh ki b">null</code>不是一个原语，当你<a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">检查</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">null</a></code>时，它实际上与整个<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">typeof</a></code> bug相关。</p><blockquote class="mo mp mq"><p id="308a" class="ls lt mr lu b lv ms jr lx ly mt ju ma mu mv md me mw mx mh mi my mz ml mm mn ij bi translated">"每个对象都是从<code class="fe kf kg kh ki b">null</code>值派生的，因此<code class="fe kf kg kh ki b">typeof</code>操作符为它返回<code class="fe kf kg kh ki b">object</code>"— <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/null" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="043b" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated"><code class="fe kf kg kh ki b">typeof null</code>是<code class="fe kf kg kh ki b">"object"</code>，因为对于JavaScript中的每个对象，每个<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank">原型链</a>实际上都从<code class="fe kf kg kh ki b">null</code>开始。很困惑吧。</p><p id="b3a2" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">您可以在控制台中通过使用<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="noopener ugc nofollow" target="_blank">Object.create()</a></code>制作一个“真正空的”对象来证明这一点，它将一个原型对象作为其参数。调用<code class="fe kf kg kh ki b">Object.create(null)</code>使用<code class="fe kf kg kh ki b">null</code>作为原型，产生一个没有从原型继承任何东西的对象。</p><p id="a457" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">实际上并没有一个很好的理由来创建一个真正的空对象，但是它解释了为什么<code class="fe kf kg kh ki b">null</code>实际上不是一个基本类型。</p><p id="7e33" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">JavaScript中不能调用<code class="fe kf kg kh ki b">Object.create(undefined)</code>，只能调用<code class="fe kf kg kh ki b">Object.create(null)</code>。</p><p id="2254" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">相比之下，<code class="fe kf kg kh ki b">Object.create(Object.prototype)</code>使用<code class="fe kf kg kh ki b">Object.prototype</code>作为原型对象:正常行为。</p><p id="2d8d" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated"><code class="fe kf kg kh ki b">Object.prototype</code>对象是所有标准JavaScript对象的标准原型。它存在于全局<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">Object</a></code>对象中，当我们用对象字面语法(<code class="fe kf kg kh ki b">{}</code>花括号)创建一个对象时，它在幕后使用。当我们用<code class="fe kf kg kh ki b">new</code>关键字:<code class="fe kf kg kh ki b">new Object()</code>调用<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/Object" rel="noopener ugc nofollow" target="_blank">Object()</a></code>构造函数时，也会用到对象原型。</p><p id="cec5" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">真的，把<code class="fe kf kg kh ki b">null</code>当成原始人没问题。但是一些技术访谈可能想让你知道，<code class="fe kf kg kh ki b">null</code>在技术上是JavaScript中所有原型的起源，<em class="mr">不是</em>原语。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="b2fb" class="la lb iq bd lc ld nv lf lg lh nw lj lk jw nx jx lm jz ny ka lo kc nz kd lq lr bi translated">不要对象包装原始类型</h1><p id="2094" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">总结一下，幕后的对象包装器解释了为什么不在内置基本类型的构造函数中使用<code class="fe kf kg kh ki b">new</code>关键字。</p><p id="0ae4" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">与<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date" rel="noopener ugc nofollow" target="_blank">Date()</a></code>构造函数一样，JavaScript <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" rel="noopener ugc nofollow" target="_blank">构造函数</a>与<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank"/><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">new</a></code><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">关键字</a>一起用于创建该类型的对象。</p><p id="a8e1" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">当您编写<code class="fe kf kg kh ki b">new</code>时，您明确地要求JavaScript创建和存储一个对象。因为原始数据类型与对象完全相反，所以永远不要对它们使用<code class="fe kf kg kh ki b">new</code>。</p><p id="e64c" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">然而，您仍然可以使用构造函数在JavaScript中执行<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion" rel="noopener ugc nofollow" target="_blank">类型强制</a>。在没有 <code class="fe kf kg kh ki b"><strong class="lu ir">new</strong></code> <strong class="lu ir">关键字的情况下调用<code class="fe kf kg kh ki b">String(value)</code>—<strong class="lu ir">—</strong>将把那个<code class="fe kf kg kh ki b">value</code>作为字符串原语返回。</strong></p><p id="5d2a" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">原始数据类型(<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/String" rel="noopener ugc nofollow" target="_blank">String()</a></code>、<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/Number" rel="noopener ugc nofollow" target="_blank">Number()</a></code>等)的对象包装器的构造函数。)是您在JavaScript <strong class="lu ir">中调用的唯一的<strong class="lu ir">构造函数，而没有使用</strong>关键字<code class="fe kf kg kh ki b">new</code>。</strong></p><p id="dff2" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">这是一个常见的混淆来源:如果你从来不使用<code class="fe kf kg kh ki b">new</code>调用构造函数，为什么原始类型——不是对象——有一个带有构造函数的“对象原型”？</p><p id="2f6c" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">原因还是为了转换类型——就像我举的例子，使用<code class="fe kf kg kh ki b">String(value)</code>强制一些<code class="fe kf kg kh ki b">value</code>变成一个字符串。</p><p id="dbf6" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">另一个原因是JavaScript自动使用这些构造函数来“对象包装”原始类型。但是您永远不需要使用<code class="fe kf kg kh ki b">new</code>关键字手动完成这项工作。</p><p id="f432" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">这些概念看起来很高级，但是一旦你理解了它们，你就会对JavaScript中原始数据类型和对象的区别有深刻的理解。</p><p id="a151" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated"><strong class="lu ir">编码快乐！</strong>👨‍🔬🥽🧪🔬💥</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="23d4" class="pw-post-body-paragraph ls lt iq lu b lv ms jr lx ly mt ju ma mb mv md me mf mx mh mi mj mz ml mm mn ij bi translated">德里克·奥斯汀博士是《职业编程:如何在6个月内成为一名成功的6位数程序员》一书的作者，该书现已在亚马逊上出售。</p></div></div>    
</body>
</html>