<html>
<head>
<title>JavaScript Currying: A Comprehensive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Currying:综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-currying-comprehensive-guide-e69c47497309?source=collection_archive---------0-----------------------#2021-07-27">https://javascript.plainenglish.io/javascript-currying-comprehensive-guide-e69c47497309?source=collection_archive---------0-----------------------#2021-07-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4df1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Curry &amp;局部应用，高级Curry实现，无限Curry和Curry的优点</h2></div><p id="17db" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Currying是一种使用函数的高级技术。它不仅在JavaScript中使用，也在其他语言中使用。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/f1819bd87e2735206d0bc44030e388fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*aTHu_4UDNiKH-0S_fu-Ddg.png"/></div></figure><blockquote class="lg"><p id="ea66" class="lh li in bd lj lk ll lm ln lo lp kx dk translated">Currying是函数式编程中的一个过程，在这个过程中，我们可以将一个具有多个参数的函数转换成一系列嵌套函数。它返回一个新函数，该函数需要内联的下一个参数。</p></blockquote><ul class=""><li id="3005" class="lq lr in ke b kf ls ki lt kl lu kp lv kt lw kx lx ly lz ma bi translated">换句话说，当一个函数不是一次接受所有参数，而是接受第一个参数并返回一个接受第二个参数的新函数，然后返回一个接受第三个参数的新函数，以此类推，直到满足所有参数。</li><li id="6c27" class="lq lr in ke b kf mb ki mc kl md kp me kt mf kx lx ly lz ma bi translated">Currying是一种函数转换，它将一个函数从可调用的as <code class="fe mg mh mi mj b">f(a, b, c)</code>转换成可调用的as <code class="fe mg mh mi mj b">f(a)(b)(c)</code>。Currying不调用函数。它只是改变了它。</li><li id="64a4" class="lq lr in ke b kf mb ki mc kl md kp me kt mf kx lx ly lz ma bi translated">函数接受的参数数量也称为<code class="fe mg mh mi mj b"><strong class="ke io">arity</strong></code>。</li></ul><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="88fe" class="mo mp in mj b gy mq mr l ms mt">function sum(a, b) {<br/>    // do something<br/>}<br/>function _sum(a, b, c) {<br/>    // do something<br/>}</span></pre><p id="65da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数<code class="fe mg mh mi mj b">sum</code>有两个参数(2-arity函数)，而<code class="fe mg mh mi mj b">_sum</code>有三个参数(3-arity函数)。</p><p id="3407" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Curried函数是通过同时定义和立即返回它们的内部函数来链接闭包而构造的。示例:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="d279" class="mo mp in mj b gy mq mr l ms mt">function sum(a, b, c) {<br/>    return a + b + c;<br/>}</span><span id="d79c" class="mo mp in mj b gy mu mr l ms mt">sum(1,2,3); // 6</span></pre><p id="457f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所见，函数带有完整的参数。让我们创建一个函数的简化版本，看看我们如何在一系列调用中调用同一个函数(并获得相同的结果):</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="a0aa" class="mo mp in mj b gy mq mr l ms mt">function sum(a) {<br/>    return (b) =&gt; {<br/>        return (c) =&gt; {<br/>            return a + b + c<br/>        }<br/>    }<br/>}<br/><br/>console.log(sum(1)(2)(3)) // 6</span></pre><p id="1a4e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以把这个和(1)(2)(3)分开来更好地理解它:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="4947" class="mo mp in mj b gy mq mr l ms mt">const sum1 = sum(1);<br/>const sum2 = sum1(2);<br/>const result = sum2(3);<br/>console.log(result); // 6</span></pre><p id="e1e7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来了解一下它是如何工作的:<br/>我们将1传递给了<code class="fe mg mh mi mj b">sum</code>函数:<code class="fe mg mh mi mj b">let sum1 = sum(1);</code></p><p id="3025" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mg mh mi mj b">sum</code>返回函数:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="2edf" class="mo mp in mj b gy mq mr l ms mt">return (b) =&gt; {<br/>   return (c) =&gt; {<br/>       return a + b + c<br/>   }<br/>}</span></pre><p id="23f3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，<code class="fe mg mh mi mj b">sum1</code>保存了上面的函数定义，它带有一个参数<code class="fe mg mh mi mj b">b</code>。我们调用了<code class="fe mg mh mi mj b">sum1</code>函数，传入了<code class="fe mg mh mi mj b">2</code> : <code class="fe mg mh mi mj b">let sum2 = sum1(2);</code></p><p id="83ba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mg mh mi mj b">sum1</code>将返回第三个函数:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="250a" class="mo mp in mj b gy mq mr l ms mt">return (c) =&gt; {<br/>   return a + b + c<br/>}</span></pre><p id="1029" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回的函数现在存储在<code class="fe mg mh mi mj b">sum2</code>变量中。<code class="fe mg mh mi mj b">sum2</code>将:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="4d8f" class="mo mp in mj b gy mq mr l ms mt">sum2 = (c) =&gt; {<br/>     return a + b + c<br/>}</span></pre><p id="428a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用3作为参数调用<code class="fe mg mh mi mj b">sum2</code>时，<code class="fe mg mh mi mj b">const result = sum2(3); </code>用之前传入的参数进行计算:a = 1，b = 2，返回6。</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="14e8" class="mo mp in mj b gy mq mr l ms mt">console.log(result); // 6</span></pre><p id="c50f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为嵌套函数，<code class="fe mg mh mi mj b">sum2</code>可以访问外部函数<code class="fe mg mh mi mj b">sum</code>和<code class="fe mg mh mi mj b">sum1</code>的变量范围。这就是<code class="fe mg mh mi mj b">sum2</code>如何用已经定义好的<code class="fe mg mh mi mj b">exit</code>函数中的变量执行求和运算。虽然函数早已从内存中返回<code class="fe mg mh mi mj b">garbage collected</code>，但它的变量却不知何故还保留着<code class="fe mg mh mi mj b">"alive"</code>。</p><p id="b261" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以看到，这三个数字一次一个地应用于该函数，并且每次都返回一个新的函数，直到用完所有的数字。最后一个函数只接受<code class="fe mg mh mi mj b">c</code>变量，但会对其封闭函数范围早已返回的其他变量执行操作。因为有了<code class="fe mg mh mi mj b">Closure.</code>，它仍然可以工作</p><h1 id="78cb" class="mv mp in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">固化和部分应用</h1><p id="afd6" class="pw-post-body-paragraph kc kd in ke b kf nm jo kh ki nn jr kk kl no kn ko kp np kr ks kt nq kv kw kx ig bi translated">有些人可能会认为一个curried函数拥有的嵌套函数的数量取决于它接收的参数的数量。是的，那使它成为一道咖喱菜。让我们举同一个<code class="fe mg mh mi mj b">sum</code>例子:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="f85d" class="mo mp in mj b gy mq mr l ms mt">function sum(a) {<br/>    return (b, c) =&gt; {<br/>        return a + b + c;<br/>    }<br/>}</span></pre><p id="82b1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以这样称呼:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="a3f5" class="mo mp in mj b gy mq mr l ms mt">let x = sum(10);<br/>x(3,12);<br/>x(20,12);<br/>x(20,13);</span><span id="fd6a" class="mo mp in mj b gy mu mr l ms mt">// OR</span><span id="d516" class="mo mp in mj b gy mu mr l ms mt">sum(10)(3,12);<br/>sum(10)(20,12);<br/>sum(10)(20,13);</span></pre><p id="f03b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的函数需要3个参数，有2个嵌套函数，不像我们以前的版本需要3个参数，有3个嵌套函数。这个版本不是咖喱。我们只是做了<code class="fe mg mh mi mj b">sum</code>函数的部分应用。</p><p id="ec51" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Currying和Partial Application是有联系的(因为闭包)，但它们是不同的概念。<strong class="ke io">部分应用</strong>将一个函数转换成另一个arity更小的函数。</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="f281" class="mo mp in mj b gy mq mr l ms mt">function sum1(x, y, z) {<br/>    return sum2(x,y,z)<br/>}</span><span id="93ce" class="mo mp in mj b gy mu mr l ms mt">// to</span><span id="f9c2" class="mo mp in mj b gy mu mr l ms mt">function sum1(x) {<br/>    return (y,z) =&gt; {<br/>        return sum2(x,y,z)<br/>    }<br/>}</span></pre><p id="1582" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于阿谀奉承，应该是这样的:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="caef" class="mo mp in mj b gy mq mr l ms mt">function sum1(x) {<br/>    return (y) = &gt; {<br/>        return (z) = &gt; {<br/>            return sum2(x,y,z)<br/>        }<br/>    }<br/>}</span></pre><p id="029a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> Currying </strong>根据函数的参数个数创建嵌套函数。每个函数都接收一个参数。如果没有争论，就没有奉承。</p><p id="b7a0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更高级的currying实现，比如<a class="ae nr" href="https://lodash.com/docs#curry" rel="noopener ugc nofollow" target="_blank"> _。curry </a>从lodash库中，返回一个允许函数被正常和部分调用的包装器:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="0072" class="mo mp in mj b gy mq mr l ms mt">function sum(a, b) {<br/>  return a + b;<br/>}</span><span id="82a3" class="mo mp in mj b gy mu mr l ms mt">let curriedSum = _.curry(sum); // using _.curry from lodash library</span><span id="7a3f" class="mo mp in mj b gy mu mr l ms mt">alert( curriedSum(1, 2) ); // 3, still callable normally<br/>alert( curriedSum(1)(2) ); // 3, called partially</span></pre><blockquote class="ns nt nu"><p id="ee2c" class="kc kd nv ke b kf kg jo kh ki kj jr kk nw km kn ko nx kq kr ks ny ku kv kw kx ig bi translated">注意:我们可以使用bind实现同样的行为。这里的问题是我们必须修改 <code class="fe mg mh mi mj b"><em class="in">this</em></code> <em class="in">绑定。</em></p></blockquote><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="0be7" class="mo mp in mj b gy mq mr l ms mt">function sum(a, b) {<br/>  return a + b;<br/>}</span><span id="acb5" class="mo mp in mj b gy mu mr l ms mt">var addBy4 = sum.bind(this,2);<br/>console.log(addBy4(4));<br/>// =&gt; 6</span></pre><h1 id="7ed1" class="mv mp in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">高级Curry实现</h1><p id="21fb" class="pw-post-body-paragraph kc kd in ke b kf nm jo kh ki nn jr kk kl no kn ko kp np kr ks kt nq kv kw kx ig bi translated">让我们开发一个函数，它接受任何函数并返回该函数的一个简化版本。这是我们可以在上面使用的多参数函数的“高级”curry实现。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="89b7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">新的<code class="fe mg mh mi mj b">curry</code>可能看起来很复杂，但实际上很容易理解。调用<code class="fe mg mh mi mj b">curry(func)</code>的结果是包装器<code class="fe mg mh mi mj b">curried</code>,如下所示:</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="8d3f" class="mo mp in mj b gy mq mr l ms mt">// func is the function to transform<br/>function curried(...args) {<br/>  if (args.length &gt;= func.length) { // (1)<br/>    return func.apply(this, args);<br/>  } else {<br/>    return function(...args2) { // (2)<br/>      return curried.apply(this, args.concat(args2));<br/>    }<br/>  }<br/>};</span></pre><p id="caa1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们运行它时，有两个<code class="fe mg mh mi mj b">if</code>执行分支:</p><ol class=""><li id="22ea" class="lq lr in ke b kf kg ki kj kl ob kp oc kt od kx oe ly lz ma bi translated">如果传递的<code class="fe mg mh mi mj b">args</code>计数等于或大于原始函数定义中的计数(<code class="fe mg mh mi mj b">func.length</code>，那么就使用<code class="fe mg mh mi mj b">func.apply</code>将调用传递给它。</li><li id="101f" class="lq lr in ke b kf mb ki mc kl md kp me kt mf kx oe ly lz ma bi translated">否则，得到一个部分:我们还没有调用<code class="fe mg mh mi mj b">func</code>。相反，返回另一个包装器，它将重新应用<code class="fe mg mh mi mj b">curried</code>，提供以前的参数和新的参数。</li></ol><p id="45dc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，如果我们再次调用它，我们将得到一个新的部分(如果没有足够的参数)，或者，最后，结果。</p><h1 id="5c87" class="mv mp in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">无限咖喱</h1><p id="0b94" class="pw-post-body-paragraph kc kd in ke b kf nm jo kh ki nn jr kk kl no kn ko kp np kr ks kt nq kv kw kx ig bi translated">现在，我们将建立一个无限的curring函数，即curring一个函数，而不知道它的arity。你可以通过无限返回一个接受一个参数并累加结果直到你说够了的函数来实现上面的库里技术。类似于，</p><pre class="kz la lb lc gt mk mj ml mm aw mn bi"><span id="f0c6" class="mo mp in mj b gy mq mr l ms mt">sum(a)(b)(c)...(n)()<br/>//Output sum of n numbers -&gt; sum of a + b + c...+ n;</span><span id="1a35" class="mo mp in mj b gy mu mr l ms mt">Example: sum(1)(2)(3)(4)(); //10</span></pre><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="facd" class="mv mp in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">Currying的优点</h1><ul class=""><li id="9af2" class="lq lr in ke b kf nm ki nn kl of kp og kt oh kx lx ly lz ma bi translated">currying的主要好处是当你需要用一些相同的参数大量使用同一个调用时，也就是说，它有助于避免一次又一次地传递相同的变量。在这种情况下，奉承成为一种很好的技巧。</li><li id="3b79" class="lq lr in ke b kf mb ki mc kl md kp me kt mf kx lx ly lz ma bi translated">Currying会让你的代码更容易重构。Currying还创建了一个更具声明性的代码库，例如，更容易阅读代码和理解它在做什么。</li><li id="6fd0" class="lq lr in ke b kf mb ki mc kl md kp me kt mf kx lx ly lz ma bi translated">它有助于创建高阶函数。</li></ul><h1 id="6c1b" class="mv mp in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">结论</h1><p id="c14f" class="pw-post-body-paragraph kc kd in ke b kf nm jo kh ki nn jr kk kl no kn ko kp np kr ks kt nq kv kw kx ig bi translated">Currying是一种非常方便的技术，它允许我们通过传递较少的参数来创建有用的函数。闭包使得JavaScript中的currying成为可能。它保留已经执行的函数状态的能力使我们能够创建工厂函数——可以为参数添加特定值的函数。</p><p id="581e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望现在你知道currying是如何工作的，或者至少对它有了更好的理解。</p><p id="4e3a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nv">更多内容请看</em><a class="ae nr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>