<html>
<head>
<title>Git Merging Strategies: A Simple Explanation and Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git合并策略:简单的解释和指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/git-merging-strategies-a-simple-explanation-and-guide-9e7e508b369c?source=collection_archive---------9-----------------------#2021-11-01">https://javascript.plainenglish.io/git-merging-strategies-a-simple-explanation-and-guide-9e7e508b369c?source=collection_archive---------9-----------------------#2021-11-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/49f71b9855a0cb2f7e3c2d4fb12084e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OhOmOqMLFyM1OY5Q"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kingimaging?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Loren King</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2908" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们这些做过git版本控制系统的人一定都遇到过这两种合并策略:<strong class="kc io">快进合并和递归策略做的合并</strong>。</p><p id="5473" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是很多时候，由于大部分事情都是由git自己处理的，我们并不确切地知道git历史上会发生什么，或者至少这就是我的情况。每次我看到类似“快进”或“递归策略合并”的消息，我都想知道这是什么意思。在这篇文章中，我将试着解释这些合并策略的含义，我希望它也能给你们一些启发。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="dd6c" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们正在研究的例子</h1><p id="a5dd" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这是我们将在本文中使用的git树。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bc58" class="mr lg in mn b gy ms mt l mu mv">master       m1  m2</span><span id="caf8" class="mr lg in mn b gy mw mt l mu mv">feature      m1  m2  f1  f2</span></pre><p id="c827" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将master作为我们的主分支，我们将从中分支并作为master的新分支。</p><p id="76f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">master中的初始提交是m1和m2，之后检查新的分支特性，该特性进一步具有f1和f2提交。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="ff4a" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">快进合并</h1><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/c03288d05c7b143fec91759c8bcd20f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*44He7mhmqKp7fl8U"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kydroon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kurt Cotoaga</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b57d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在快进合并中，如果<strong class="kc io">主</strong>在分支<strong class="kc io">特征</strong>后没有任何变化，则在合并到主时，不会创建合并提交，而是所有特征提交都放在主提交之上。</p><p id="3733" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果在上面的例子中，我们在主服务器上运行“git merge特性”,下一个状态应该是这样的:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ef86" class="mr lg in mn b gy ms mt l mu mv">master       m1  m2  f1  f2</span></pre><blockquote class="my mz na"><p id="94de" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>如果您在特性分支中有多个提交，并且您想在合并到主特性之前将它们合并成一个，您可以运行:<br/> <strong class="kc io"> "git merge - squash feature "，</strong>这将提示您提交消息，状态如下:</p></blockquote><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8e52" class="mr lg in mn b gy ms mt l mu mv">master        m1  m2  “single commit”</span></pre><blockquote class="my mz na"><p id="086c" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated">这里的“单次提交”是我们在运行squash命令时提供的消息(f1和f2都是该提交的一部分)。</p></blockquote></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="c936" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">非快进合并(递归策略)</h1><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/788037efbd8c1994fc3f091e96b74765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T6kmIc9A3DKvXinR"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@seimesa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mario Mesaglio</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d40c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自从从<strong class="kc io">主模块</strong>创建<strong class="kc io">特征</strong>以来，当<strong class="kc io">主模块</strong>已经发展并具有更新的提交(可能是由于一些其他分支被合并)时，git采用该策略。在这种情况下，初始树应该是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d4a1" class="mr lg in mn b gy ms mt l mu mv">master       m1  m2  m3</span><span id="c1c7" class="mr lg in mn b gy mw mt l mu mv">feature      m1  m2  f1  f2</span></pre><p id="8b52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，m3是主模块中的新提交，如果我们现在在<strong class="kc io">主模块</strong>上运行“git合并功能”，那么<strong class="kc io">功能</strong>分支的所有提交都会在<strong class="kc io">主模块</strong>上执行，并且还会创建一个合并提交。这不同于在附加提交创建中的快速前进合并。</p><p id="dc10" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是合并后的新状态:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="35aa" class="mr lg in mn b gy ms mt l mu mv">master       m1  m2  f1  f2  m3  "merge commit of feature branch"</span></pre><p id="355d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="nb">虽然git会自动执行这种类型的合并策略，但如果我们明确地想要这样做，我们可以运行“git merge - no-ff feature”。</em> </strong></p><blockquote class="my mz na"><p id="951e" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>如果您在特性分支中有多个提交，并且您想在合并到主特性之前将它们合并成一个，您可以运行:<br/> " <strong class="kc io"> git merge - squash特性</strong>，这将提示您一个提交消息，其状态如下:</p></blockquote><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bf48" class="mr lg in mn b gy ms mt l mu mv">master        m1  m2  m3  “single commit”</span></pre><blockquote class="my mz na"><p id="420e" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated">这里的“单次提交”是我们在运行squash命令时提供的消息(f1和f2都是该提交的一部分)。</p></blockquote></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="3da9" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">资源</h1><div class="ng nh gp gr ni nj"><a href="https://www.tutorialspoint.com/what-is-a-fast-forward-merge-in-git" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">什么是Git中的快进合并？</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">当存在从源分支到目标分支的直接线性路径时，可以执行快进合并。在…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jt nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://www.atlassian.com/git/tutorials/using-branches/git-merge" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">Git合并| Atlassian Git教程</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">合并是Git将分叉的历史重新组合在一起的方式。git merge命令允许您将…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.atlassian.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx jt nj"/></div></div></a></div><p id="dae5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nb">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>