# 用打字稿写一个苗条的商店

> 原文：<https://javascript.plainenglish.io/writing-a-svelte-store-with-typescript-22fa1c901a4?source=collection_archive---------1----------------------->

本文不是对 Svelte 或 TypeScript 的介绍。如果您对这些技术中的任何一种都不熟悉，我建议您在深入研究这些主题之前做一些单独的研究。说完了，让我们开始吧！

![](img/d85654a68f1db8ec0e36363b477622c1.png)

# 为什么是苗条商店

作为一名从事大型 React 应用程序开发的 React 开发人员，随着时间的推移，我对 React 应用程序的可伸缩性越来越失望。大型嵌套组件中的提升状态总是令人困惑和重复的，尤其是当组件有 3 层以上的深度时。将状态从一个更小的嵌套组件(如 textfield)提升到页面的根级组件以便在组件之间共享数据是没有意义的

找替代品，找了 Redux，看了“为什么要用 Redux”和“为什么不用 Redux”的文章，最后都没用过。关于过多的样板代码和混乱的工作流的评论赶走了我，而且我从未从事过大到需要那种级别的状态管理的项目。

然后 React 发布了 Context API，我以为会修复一切。在很短的一段时间里，前景似乎是光明的，但是上下文也开始让我失望，即使是在 Hooks API 集成的情况下。没完没了的组件包装器让我的组件变得冗长而不可读，并且强制子级重新渲染对性能的影响开始显现出来。

在很短的时间内，我研究了 Vue3 和 Composition API，虽然它解决了一些问题，但它似乎也有一些 React 面临的潜在问题。我仍然认为组合 API 背后有一些潜在的力量，但 Vue3 还没有被广泛采用，因为从 Vue2 手动迁移，我不相信它会修复我所希望的一切。

我决定是时候全身心投入到 Svelte 上了，这是一个新的闪亮的框架，有些人对此赞不绝口(它实际上是一个编译器，但我们不需要在这里深入研究)。几乎没有人支持，社区也很小，这似乎是一个风险，但我必须尝试。

经过几周的教程和代码沙盒，我的赌博似乎有了回报。到目前为止，Svelte 给我印象最深的是它的商店，以至于我正在写我的第一篇媒体文章来赞美它。

# 示例商店

这个苗条的商店完全是对国家管理的重新想象，我喜欢它。让值“可反应”而不是必须将它们存储在“状态对象”中是一种范式转变，而且是一种受欢迎的转变。下面是我为一个简单应用程序创建的存储示例，它管理两个输入的值，firstname 和 lastname。

如果你在这一点上被吓倒了，**不要做**。我们将讨论一个秘密语法，它使得使用这个商店*变得如此简单*。

**可写的**函数使这些值“可反应”，允许组件订阅(读取)和更新这些值。如果你来自一个反动的背景，这有点像国家，但这是不同的。

您也可以使用**派生的**函数，它类似于 Vue 中的计算值。这将把你的“存储”对象(可写的)，并拉当前值，然后在一个可读的对象返回它。Derived 还监视传递给它的任何可写对象的变化，只有当它们发生变化时才更新，所以您将总是获得最新的值，并且具有出色的性能。

最后，在我的存储文件中，我在底部附近导出了一个**单例**，这个**只被创建一次**，并且可以全局访问。这与 React 不同，React 会在每次重新渲染时重新运行所有的状态代码。React 有一个设置，使这成为一个非常有效的过程，但它仍然是不同的。如果您想要创建多个存储，这对于使用苗条的上下文(另一篇文章的主题)可能是有效的，您可以使用存储文件最底部的注释代码。

# 行动中的苗条商店

现在我们已经创建了这个商店，让我们使用它。这是一个从我们的存储中访问值的瘦组件。

当我们从 myFormStore 中析构属性以获取 firstname 和 lastname 时，我们接收到了两个可写的**对象。本质上，你不能从 writable 中访问值，但是通过一些特殊的语法，我们可以。通过在我们的变量前加前缀' $ '，Svelte 为该值创建了一个自动订阅，甚至会在组件卸载时取消订阅(太神奇了！).如果你想了解更多关于订阅的信息，我推荐你跟随他们网站上的苗条教程，它很直观也很容易跟随。**

您可以在第 12 行和第 16 行看到使用' $ '快捷方式的示例，这里我们将可写值绑定到输入的值属性。这个绑定类似于 Vue 的 v-model，它去掉了添加 onChange 和 value prop 的模板。现在，如果我们在输入字段中输入值，那么存储中的 firstname 和 lastname 值将会自动更新，还有我们派生的 fullname 属性。

我还在上面创建了另一个组件，它利用商店并使用全名值。它与第一个组件(无嵌套)在同一层级上。在这里，我们再次使用了' $ '语法，因为 fullname 是一个**可读的**对象，现在每当任何一个**可写的**存储值(firstname 或 lastname)发生变化时，我们都会自动更新该值。该存储可以被 10 到 15 个组件使用，而不会引入混乱和冗长的嵌套。

# 结论

到目前为止，我对 Svelte 的体验非常棒，我想分享我所学到的东西，这样社区就会发展壮大，并开始被大规模采用。如果你喜欢这篇文章，请让我知道，我很乐意提供更多的概念，如上下文或使用' $:'语法燃料反应性苗条教程。编码快乐！

这里有一个 Github 回购和代码的链接
[https://github.com/doughill1000/store-svelte-typescript](https://github.com/doughill1000/store-svelte-typescript)

 [## 苗条的应用

### 编辑描述

doughill1000.github.io](https://doughill1000.github.io/store-svelte-typescript/)