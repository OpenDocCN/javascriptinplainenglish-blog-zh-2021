<html>
<head>
<title>Immutability in JavaScript — Objects and Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的不变性——对象和数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/immutability-in-javascript-objects-and-arrays-34d6a85f29b7?source=collection_archive---------18-----------------------#2021-09-22">https://javascript.plainenglish.io/immutability-in-javascript-objects-and-arrays-34d6a85f29b7?source=collection_archive---------18-----------------------#2021-09-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7ad37ea6e272e162e80ad592577ae38c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aRnLN8Kjuig3sraV"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@matthewhenry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matthew Henry</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="06b4" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是不可变对象？</h1><blockquote class="ky kz la"><p id="d9a0" class="lb lc ld le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">在<a class="ae jz" href="https://en.wikipedia.org/wiki/Object-oriented_computer_programming" rel="noopener ugc nofollow" target="_blank">面向对象</a>和<a class="ae jz" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式</a>编程中，一个<strong class="le io">不可变对象</strong>(不可变对象)是一个<a class="ae jz" href="https://en.wikipedia.org/wiki/Object_(computer_science)" rel="noopener ugc nofollow" target="_blank">对象</a>，它的状态在创建后不能被修改。</p><p id="e4f4" class="lb lc ld le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">-维基百科</p></blockquote><p id="de91" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">上面的定义相当简单，但我会详细说明。一旦创建了对象，就不能更改该对象的任何属性。这实际上是创建了一个不能更新的只读对象。</p><h1 id="ad9a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">为什么我需要使用不变性？</h1><p id="eec1" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">利用不可变的设计可以提供许多好处，例如</p><ul class=""><li id="3a9d" class="mi mj in le b lf lg lj lk ma mk mb ml mc mm lz mn mo mp mq bi translated">线程安全</li><li id="e295" class="mi mj in le b lf mr lj ms ma mt mb mu mc mv lz mn mo mp mq bi translated">更容易调试</li><li id="716f" class="mi mj in le b lf mr lj ms ma mt mb mu mc mv lz mn mo mp mq bi translated">更易维护的代码</li></ul><p id="3e06" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">关于线程安全，对被多个线程访问的对象进行突变可能会导致意外和不正确的结果。如果您有一个计数器来计算有多少人访问了您的网站，您希望确保每个计数都记录正确。如果您直接更新计数器，由于并发错误，可能会遗漏一个视图，并且您将得到一个不正确的计数。如果你有一个不可变的计数器，每次都会创建一个新的版本来确保你有正确的值。</p><p id="2270" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">对于调试来说，能够及时查看某个位置的对象状态(带有值的属性)确实可以减少混乱。如果您有一个人的姓氏需要更新，在没有不变性的情况下，您可能会在更新后丢失以前的姓氏。使用不变性，您将拥有更新前对象的记录，以及替换它的具有更新名称的新对象。</p><p id="c515" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">不变性是一种常见的编码实践，在各行各业都有使用。通过应用不可变的设计模式，其他开发人员应该更容易理解您的代码和您试图完成的任务。</p><h1 id="e5c6" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">JavaScript中的示例—对象</h1><p id="9f61" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">既然我们已经介绍了什么是不可变对象以及我们为什么使用它们，那么让我们介绍一些使用突变和不可变设计模式的代码示例。</p><p id="6898" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">假设我们有一个人对象。person对象有两个属性，名字和姓氏</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="c345" class="nf kb in nb b gy ng nh l ni nj">const person = {<br/>   firstName: 'Jane',<br/>   lastName: 'Smith'<br/>}</span></pre><p id="22f9" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">让我们想象一下，简刚刚结婚，想把她的姓改成她丈夫的姓。所以她现在的姓将不再是“史密斯”，而是“多伊”。首先，我们将介绍如何通过改变person对象来实现，然后我将介绍如何使用不可变的设计模式</p><h2 id="fd32" class="nf kb in bd kc nk nl dn kg nm nn dp kk ma no np ko mb nq nr ks mc ns nt kw nu bi translated">使对象变异</h2><p id="3670" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">使用简单的JavaScript，很容易更新这个人的姓氏。我们只需给person.lastName赋一个新值，然后就可以记录结果了</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="bc91" class="nf kb in nb b gy ng nh l ni nj">person.lastName = 'Doe' // Mutation</span><span id="96bb" class="nf kb in nb b gy nv nh l ni nj">// Logging her new last name<br/>console.log(person.lastName) // 'Doe'</span></pre><p id="db28" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">太好了！但是她之前的姓呢？因为我们直接变异了对象，所以该值不再可访问。如果我们需要更新具有她旧姓氏的其他记录，这可能是一场噩梦。</p><h2 id="2e84" class="nf kb in bd kc nk nl dn kg nm nn dp kk ma no np ko mb nq nr ks mc ns nt kw nu bi translated">使用不可变模式和ES6扩展语法</h2><p id="eec0" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">让我们创建一个具有更新后的姓氏的副本，而不是直接改变person对象。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d925" class="nf kb in nb b gy ng nh l ni nj">// Create a copy of the original object with the updated last name<br/>const updatedPerson = {<br/>   ...person, // Copy values from original object<br/>   lastName: 'Doe'<br/>}</span></pre><p id="70aa" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">如果你不熟悉这个语法，让我解释一下。在ES6中，我们可以使用spread操作符从一个对象中提取属性，并将它们复制到一个新对象中。在这种情况下，我们基本上是说将person的所有属性复制到这个新的updatedPerson对象中。现在，在跨页下面，我们用新值包含lastName，这样从person ('Smith ')复制的值将被' Doe '覆盖。</p><p id="4ba9" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">我知道这有点令人困惑，但是相信我，一旦你练习了，就会明白很多道理。现在，有了这个不可变的结构，让我们再次尝试调试</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="4a6b" class="nf kb in nb b gy ng nh l ni nj">console.log(person.lastName); // 'Smith'<br/>console.log(updatedPerson.lastName); // 'Doe'</span></pre><p id="ce6a" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">厉害！现在我们有了Jane的审计历史和对她姓氏的更新。如果我们需要检索或访问那个值，我们仍然可以在内存中找到旧的对象</p><h1 id="2e4e" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">JavaScript中的示例—数组</h1><p id="5c25" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">由于我们在前一节中已经介绍了很多对象，所以这一节会稍微简短一些。假设我们有一个姓氏数组，我们需要在Jane结婚后更新她的姓氏</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="4802" class="nf kb in nb b gy ng nh l ni nj">const lastNames = ['Johnson', 'Smith', 'Kennedy']</span></pre><h2 id="8529" class="nf kb in bd kc nk nl dn kg nm nn dp kk ma no np ko mb nq nr ks mc ns nt kw nu bi translated">变异一个数组</h2><p id="7adb" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">如果我们想将数组的第二项更新为“Doe ”,这就是我们通过数组变异来完成的方式。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6a49" class="nf kb in nb b gy ng nh l ni nj">lastNames[1] = 'Doe' // Mutation<br/>console.log(lastNames) // ['Johnson', 'Doe', 'Kennedy']</span></pre><p id="e3dc" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">数组现在更新了，但是像以前一样，我们丢失了姓氏列表的记录。</p><h2 id="d666" class="nf kb in bd kc nk nl dn kg nm nn dp kk ma no np ko mb nq nr ks mc ns nt kw nu bi translated">使用不可变模式和ES6扩展语法</h2><p id="782b" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">这一次，我们不直接改变数组，而是创建数组的副本，然后更新对象。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="1b02" class="nf kb in nb b gy ng nh l ni nj">const newLastNames = [...lastNames] // Create a copy of the array<br/>newLastNames[1] = 'Doe'</span><span id="51ba" class="nf kb in nb b gy nv nh l ni nj">console.log(lastNames) // ['Johnson', 'Smith', 'Kennedy']<br/>console.log(newLastNames) // ['Johnson', 'Doe', 'Kennedy']</span></pre><p id="5d64" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">在本例中，我们再次使用spread语法创建一个新数组，以创建所有数组元素的副本，并将它们放在一个新数组中。一旦完成，我们就可以更新新对象中的值，而不改变原始数组。正如我们再次看到的，我们可以保留对象的更新历史，并且不会遇到任何并发问题。</p><h1 id="00be" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">ES6扩展语法的注意事项</h1><p id="ea81" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">我必须提到，虽然ES6的spread语法很棒，但它也有一个缺点，那就是它只会执行<em class="ld">浅层复制</em>。我的意思是它只会向下克隆一层对象。因此，如果您的对象具有其他对象的属性，您将需要对这些嵌套属性使用spread语法，以确保它们保持不变。对象数组也是如此。</p><p id="d27e" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated"><a class="ae jz" href="https://www.geeksforgeeks.org/what-is-shallow-copy-and-deep-copy-in-javascript/" rel="noopener ugc nofollow" target="_blank">这里有一篇很棒的文章，解释了浅复制和深复制</a></p><h1 id="5865" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结束语</h1><p id="4e95" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">虽然实现不可变的设计模式是强大的，但它并不总是完美的解决方案。正如技术中的一切一样，您必须权衡利弊，选择适合您的解决方案。不变性确实增加了一些额外的代码行，但是作为一个经验丰富的程序员，我可以向您保证，从长远来看，它是值得使用的。我并不总是一个信徒，但我已经接受了这种模式，并将其整合到我的代码中适合的地方:</p><p id="23a7" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">React和Redux是利用不变性的主要支持者，所以本文将介绍如果您开始用React编码，您可能会看到什么以及为什么会这样。</p><p id="eddb" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">一如既往，如果你喜欢这篇文章，请鼓掌并跟随，快乐编码！</p><p id="350f" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated"><em class="ld">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="le io"><em class="ld">plain English . io</em></strong></a></p></div></div>    
</body>
</html>