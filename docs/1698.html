<html>
<head>
<title>How to Re-Render a Functional React Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何重新渲染功能性React组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/re-render-a-functional-react-component-1d64fa9a0c60?source=collection_archive---------6-----------------------#2021-04-11">https://javascript.plainenglish.io/re-render-a-functional-react-component-1d64fa9a0c60?source=collection_archive---------6-----------------------#2021-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/367b2635c350ad15d9a58d2683ad6f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8ACA47HFhBjoqO5QTUxBA.png"/></div></div></figure><p id="63e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有很多原因你可能希望一个组件被重新渲染，但是没有多少方法可以实现这一点。React在触发重新渲染时非常严格。我已经提到了为什么直接改变状态在React世界里是一个大禁忌，这是其中很大的一部分。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/55463b45746a06b0d152c8f259cd6ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*XVBpspYenADKn66yojvERg.png"/></div></figure><p id="74b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在React组件中，每当状态改变时，它都会运行<code class="fe ky kz la lb b">render()</code>方法。如果您要直接改变状态，React将不会识别该更改，因此不会重新渲染。记住，我们谈论的是功能组件。所以，为了使用状态，你必须使用钩子(use state和/或useReducer)。如果你不熟悉钩子，看看这里的React文档<a class="ae lc" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6171" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，假设您有一个好友列表，并且刚刚编写完允许用户接受好友请求的所有逻辑。现在，您需要重新呈现该列表，向用户显示包含他们的新朋友的更新版本。在这个例子中，我将使用useState、useDispatch和useReducer钩子。同样，如果你对这些不熟悉，请点击查看React文档<a class="ae lc" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="49d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从哪里开始？让我们在好友列表组件中创建一个名为refreshFriendsList的回调函数。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/0eaa007e4eaf598a5d06997f7462cac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*lciT273C1zjrGehqtmkeDQ.png"/></div></figure><p id="bb61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，现在让我们把它传到我们需要的地方，当我们准备好重新渲染的时候调用它。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi le"><img src="../Images/461a5fe7810c2b579399ec8002125494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLnDvSK7o1QZTDXqJhhn9Q.png"/></div></div></figure><p id="3f73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">acceptFriendRequest操作返回一个承诺，因此我们能够使用。然后在storeDispatch (useDispatch hook)上确保在我们的数据库用新信息更新之前，我们没有调用refreshFriendsList。回到朋友列表。</p><p id="1b80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了重新渲染，我们需要更新状态。所以，我们暂时只做一个计数器，在调用refreshFriendsList时递增值。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/b75fc8473832c61060c727d1fd6b0457.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*Z1ieG9sq1TntMp4qV0xw6Q.png"/></div></figure><p id="f009" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太棒了。现在，当后端完成数据库更新后，将调用refreshFriendsList，count (useState hook)加1，并重新呈现朋友列表组件。但是，什么都没有改变。那么，为了向用户呈现更新后的朋友列表，需要做些什么呢？</p><p id="71b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，我认为我们首先需要向后端发出另一个调用来检索更新的朋友列表。然后，我们需要向用户提供更新的信息。</p><p id="e9f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，让我们调用fetchAllFriends方法。这将从数据库中获取更新的信息，进而更新friends和friendRequests变量。这里，我使用useSelector钩子来订阅我的Redux store，所有来自后端的信息都存储在这里。欲了解更多关于Redux的信息，请点击这里查看文档<a class="ae lc" href="https://react-redux.js.org/introduction/getting-started" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lg"><img src="../Images/e1486f46489f17c4196d7affbe87d964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQD8kbRsGzBd1DxYHGkNDw.png"/></div></div></figure><p id="651e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好东西，现在我们在我们的朋友列表组件中有了所有更新的信息。只有一个问题——它不能用更新的信息重新呈现。我们不再更新状态，因此不再重新呈现组件。让我们修理它！</p><p id="2eb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，为了触发重新渲染，我们需要更新状态。我们可以使用我们之前构建的计数器，但是我认为不那么武断的东西会更合适。让我们创建一个组合了friends和friendRequests的状态变量，因为当Redux存储更新时，它们会自动更新。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/6d12e1a9812c1bbea7d0f04687fcd5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*yJnFLZxLklXYVdbzWXmgxA.png"/></div></figure><p id="32ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后要做的就是更新allFriends。但是哪里是发生这种事情的好地方呢？我们可以把它放在refreshFriendsList函数中，但是在执行之前，我们必须等待fetchAllFriends返回它的有效载荷。而且一点都不能重复使用。我认为这非常适合使用效果挂钩。让我们放置一个useEffect钩子，将allFriends设置为一个数组，该数组包含Friends和friendRequest变量中的所有朋友。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi li"><img src="../Images/809c74bf840599ea2b69d5c1dc8141e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*lrWdEd3Le7eGf-qu256osg.png"/></div></figure><p id="8002" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，我将一个数组作为第二个参数传递。这确保了它只在friends和/或friendRequests发生变化时运行。让我们放置另一个useEffect钩子，它在初始化时调用fetchAllFrieds，并传递一个空数组作为第二个参数，这样它将只运行一次。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/e3f9553f3da76f51c8c516764f3619c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*swkABLwLLhsabwuj19d06Q.png"/></div></figure><p id="c882" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">厉害！现在，当用户接受好友请求时，数据库被更新，我们获取更新的信息并更新Redux存储。当Redux存储被更新时，变量friends和friendRequests也被更新。这触发了我们的useEffect钩子，并通过setAllFriends更新状态，setall friends触发了所有更新信息的重新呈现。</p><p id="dcc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是重新呈现功能性react组件的真实示例。编码快乐！</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/5c698a5a255df363927533db86403864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hlAFfkSBTkjFHFJRpZaSnA.gif"/></div></div></figure><h2 id="3dae" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated"><em class="me">延伸阅读</em></h2><div class="mf mg gp gr mh mi"><a href="https://bit.cloud/blog/introducing-component-compare-easily-review-component-changes-l4qyxtoo" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd io gy z fp mn fr fs mo fu fw im bi translated">比特博客</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">组件驱动软件的官方博客。围绕现代组件驱动的web开发的文章…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">比特云</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw jt mi"/></div></div></a></div><p id="7f7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mx">更多内容请看</em><a class="ae lc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">plain English . io</em></strong></a><em class="mx">。报名参加我们的</em> <a class="ae lc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mx">免费周报</em> </strong> </a> <em class="mx">。关注我们关于</em><a class="ae lc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">Twitter</em></strong></a><a class="ae lc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">LinkedIn</em></strong></a><strong class="jx io"><em class="mx"/></strong><a class="ae lc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">YouTube</em></strong></a><strong class="jx io"><em class="mx">，以及</em></strong><em class="mx"/><a class="ae lc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">不和</em> </strong> </a>  <em class="mx">对成长黑客感兴趣？检查</em> <a class="ae lc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mx">电路</em> </strong> </a> <strong class="jx io"> <em class="mx">。</em> </strong></p></div></div>    
</body>
</html>