<html>
<head>
<title>Hooks &amp; Context in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的挂钩和上下文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hooks-context-in-react-1da111da280e?source=collection_archive---------9-----------------------#2021-02-01">https://javascript.plainenglish.io/hooks-context-in-react-1da111da280e?source=collection_archive---------9-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="944e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用钩子和上下文构建轻量级组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/df93eb15c5dfbee227457c4c2efaaf06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGdXRJwHyU-u5pu6exyQ3g.png"/></div></div></figure><p id="e9f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React挂钩和上下文是React中的一些基本概念，使用React挂钩，我们可以开发更快且易于维护的应用程序。在<strong class="kt ir"> <em class="ln"> React 16.8 </em>但是在React Hooks的帮助下，我们可以用几行代码轻松地维护我们组件的状态，因为我们可以制作大规模的React应用程序，无论是React.js还是React Native，它都需要使用钩子，因为它以一种漂亮的方式避免了状态管理的复杂性。</strong></p><h2 id="f328" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak">为什么要对上下文做出反应？</strong></h2><p id="d935" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">如果我们谈论<strong class="kt ir"> React Context </strong>，它在从多个组件获取数据时开始起作用，并简化React组件中的这些获取任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/0bafd481810feba057ae2dd8c8b9185e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYwJJYnvvICqI89Sb1GIiQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">React Context</figcaption></figure><p id="2726" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">例如，</em> </strong> <em class="ln">假设我们有3个组件:</em></p><ul class=""><li id="db27" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated"><strong class="kt ir"> App: </strong>每个React应用程序中都有的普通App.js文件(包含用户的电子邮件)。</li><li id="79cc" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated"><strong class="kt ir">用户:</strong>位于App &amp;档案页面组件之间的组件。</li><li id="3374" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated"><strong class="kt ir">个人资料页面:</strong>在这里我们需要访问用户的电子邮件。</li></ul><p id="e826" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，我们需要在<strong class="kt ir">个人资料页面</strong>组件&amp;中访问用户的电子邮件，为此，我们需要将电子邮件对象传递给用户组件，然后只有我们可以在个人资料页面组件中访问它。这种方法也被称为<strong class="kt ir">道具钻取</strong>，因为我们必须在组件中传递多个道具。但是这种方法会使您的React应用程序变慢，并且在不同的情况下会花费更多的时间。</p><blockquote class="nf ng nh"><p id="3f03" class="kr ks ln kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated">为了避免这种性质，我们也有<strong class="kt ir"> Redux </strong>，但这是我们不打算谈论的东西，因为它需要自己的概念。</p></blockquote></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="6143" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak">使用状态挂钩</strong></h2><p id="dc10" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">在类组件中，我们使用正常的状态管理术语，但是当涉及到功能组件来处理状态时，我们使用React <strong class="kt ir">钩子。</strong></p><p id="7eb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<strong class="kt ir"> useState </strong>钩子中，有两件事情需要考虑，我们想要为特定动作改变的状态值和负责改变该状态值的函数。</p><p id="0971" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/29968315f66ca45672311baa910ec134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pm_ub1BOCVwReskYj6Zt7A.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk"><strong class="bd nt">useState</strong></figcaption></figure><ul class=""><li id="1c91" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated">我们有一个函数组件&amp;使用useState钩子我们定义了一个const数组(<strong class="kt ir"> [count，setCount] </strong>)，我们在<strong class="kt ir"> useState() </strong>中分配的值与数组中的第一项相关联，这意味着现在count的值为0，因为我们已经定义了<strong class="kt ir"> useState(0) </strong>。</li><li id="5abb" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">数组中的第二项是负责改变计数值的函数，无论我们在哪里使用<strong class="kt ir"> setCount </strong>函数，它都可以在每次渲染时改变count的值。</li><li id="d517" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">为了清晰的演示，我在一个<strong class="kt ir"> div </strong>中添加了<strong class="kt ir">计数</strong>，这样当我们按下使用<strong class="kt ir"> setCount </strong>函数的按钮时，我们可以看到动态变化。</li><li id="f92c" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">当我们按下按钮时，我们可以很容易地看到计数随着时间的推移而变化，增量为1。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/9ef2e3dd20bc2de4936f459e6989b1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1d97ywaEfxMKrF-nF9fwg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk"><strong class="bd nt">useState Result</strong></figcaption></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="3805" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">useEffect挂钩</h2><p id="0376" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">在类组件中，我们有3个生命周期方法<strong class="kt ir">componentidmount()</strong>，<strong class="kt ir">componentiddupdate()</strong>&amp;<strong class="kt ir">componentWillMount()</strong>，当我们使用这些生命周期方法时，我们的逻辑遍布在我们的代码中，我们必须来回管理状态，但是在功能组件中，我们可以使用<strong class="kt ir"> useEffect </strong>钩子，在那里我们有更干净和最少的实现。</p><p id="f678" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/faddd18187827cf7e425034fdb0079c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJGAApA82314p3-bYx2KOw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk"><strong class="bd nt">useEffect</strong></figcaption></figure><ul class=""><li id="60f2" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated">假设我们想在一个特定的动作上改变页面的<strong class="kt ir"> document.title </strong>，在我们的例子中，每次当我们按下<strong class="kt ir">按钮</strong>时，标题都会改变，并在默认标题中添加count。</li><li id="40c3" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">为了实现这个特性，我们导入了<strong class="kt ir"> <em class="ln"> useEffect </em> </strong>钩子，之后我们必须传递一个由useEffect钩子要求的lambda表达式，在这个表达式中，我们添加了所有我们想要在每次渲染时在网页上实现的更改。</li><li id="5bd9" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">现在每次我们按下增加按钮来改变计数值，标题也会在每次渲染时更新。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/ecbdaceb68437dc9465893449ef8f0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVpqf4uIMHnTKJYHbtkQww.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk"><strong class="bd nt">useEffect Result</strong></figcaption></figure><blockquote class="nf ng nh"><p id="a120" class="kr ks ln kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><em class="iq">在</em><strong class="kt ir"><em class="iq">useEffect</em></strong><em class="iq">钩子中还有一点我们需要注意，那就是</em> <strong class="kt ir">依赖关系数组</strong> <em class="iq">，依赖关系数组控制着我们的use effect钩子中的更新，如果我们没有在</em> <strong class="kt ir"> <em class="iq"> useEffect函数中传递依赖关系，</em> </strong> <em class="iq">，那么它就会被跳过，或者我们可以说它就是不会渲染。因此，如果我们需要在redner中设置一些条件，我们可以在useEffect函数中提供一组依赖项。</em></p></blockquote><p id="cc1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">注意:</em> </strong> <em class="ln">高亮显示的空数组是我们添加所有依赖项的地方，用于在渲染中设置条件。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/957d24d5554c8f222946b686b0c5c413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9EjuhJSru6P5uVcF1okGkQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk"><strong class="bd nt">Array Of Dependencies In useEffect</strong></figcaption></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="c11a" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">语境</h2><p id="c91f" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">在功能组件中使用上下文相当容易，但是在类组件中需要一点理解。</p><h2 id="b072" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak"> 1。类组件中的上下文:</strong></h2><p id="d781" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们有一个与上面的例子相似的演示，其中我们解释了对<strong class="kt ir"> useEffect的需求。</strong>我们有两个类组件<strong class="kt ir">用户</strong> &amp; <strong class="kt ir"> ProfilePage </strong>和<strong class="kt ir"> App.js </strong>中的一个对象，我们希望将它们传递给<strong class="kt ir"> ProfilePage </strong>组件。</p><blockquote class="nf ng nh"><p id="da71" class="kr ks ln kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><em class="iq">在</em><strong class="kt ir"><em class="iq">app . js</em></strong><em class="iq">中我们定义了一个对象为</em><strong class="kt ir"><em class="iq">user email</em></strong><em class="iq">，其中包含了一个我们需要向下传递的对象。</em></p><p id="3b4a" class="kr ks ln kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><em class="iq">内</em><strong class="kt ir"><em class="iq">User . js</em></strong><em class="iq">我们有</em><strong class="kt ir"><em class="iq">User</em></strong><em class="iq">组件，我们必须在</em><strong class="kt ir"><em class="iq">profile page</em></strong><em class="iq">组件&amp;</em><strong class="kt ir"><em class="iq">profile page</em></strong><em class="iq">组件中包含从访问电子邮件对象的所有代码</em></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/6d05e985f6871f9f6c0d28fa0a271826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhFKVT2lgNCIdYU9ecsF7g.png"/></div></div></figure><ul class=""><li id="ac90" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated">为了在React中使用上下文，我们必须创建一个包含我们上下文的所有方法的上下文文件，在这个演示中，我们有一个名为<strong class="kt ir"> emailContext.js </strong>(注意，我们可以将我们的上下文命名为任何东西)&amp;使用<strong class="kt ir"> React.createContext </strong>我们创建了一个新的上下文，并将其存储在一个const中，并将其导出为默认值。同样为了清楚地理解组件树，我们可以命名我们的上下文。(在演示中命名为<strong class="kt ir"> EmailContext </strong>)。</li></ul><blockquote class="nf ng nh"><p id="030a" class="kr ks ln kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated">注意，根据我们的组件树，我们正在传递<strong class="kt ir">用户</strong>组件中的<strong class="kt ir"> ProfilePage </strong>组件。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/3de1cecf5236bce976f535764bfc1ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vg679LiKV1xD25DdP7bWQ.png"/></div></div></figure><ul class=""><li id="1b7d" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated">之后，我们需要查看两件事情，我们上下文中的<strong class="kt ir">提供者</strong>和<strong class="kt ir">消费者</strong>，在我们的例子中，App组件将是提供者，ProfilePage将是消费者，因为我们将对象从<em class="ln"> App </em>传递到<em class="ln"> ProfilePage </em>。</li><li id="a146" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">为了实现这个提供者和消费者术语，我们可以使用<strong class="kt ir"> EmailContext </strong>组件，它有两个方法作为提供者和消费者。</li><li id="20a5" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">在我们的例子中，App组件作为提供者工作，我们使用了<strong class="kt ir"> EmailContext。Provider </strong>方法，并将我们所有的代码包装在这个组件中。此外，我们有一个<strong class="kt ir"> value </strong> prop，它接受我们想要传递的值(在我们的例子中，我们传递的是<strong class="kt ir"> userEmail </strong>对象)。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/5db5dd8268c033763aa192594615f086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azJq73U9CDL0PHncsyvtGQ.png"/></div></div></figure><ul class=""><li id="a44d" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated">类似地，在<strong class="kt ir"> ProfilePage </strong>组件内部，我们必须使用一个<strong class="kt ir"> EmailContext。消费者</strong>组件。但是在这个组件内部，我们必须使用lambda表达式将所有组件作为一个函数传递。</li><li id="e232" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated">现在，使用我们在lambda表达式中添加的<strong class="kt ir"> emailContext </strong>对象(它可以被命名为任何东西),我们只需要渲染email对象，因为我们将它添加在了<strong class="kt ir"> div </strong>元素内的花括号中。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/f29367222aeed3badc53ac08e687a75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nQem31dM38V2jP42H1RFQ.png"/></div></div></figure><p id="6814" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现之后，我们可以在结果中观察到电子邮件的呈现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f4d52fd312f876633f278a56e31a0b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Cwq26nCE_XFpDnpWiqIgjA.png"/></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="5c24" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">2.功能组件中的上下文:</h2><p id="ece6" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">在功能组件的情况下，我们可以很容易地使用上下文，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/1e41bc784ae7bcd31c0db30a03a08c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-T4xhh3kaLzEhcfn_PniHQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk"><strong class="bd nt">NewUser.js</strong></figcaption></figure><p id="71c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我们创建了一个名为<strong class="kt ir"> NewUser、</strong>的新组件，要访问这个组件中的email对象，我们可以使用<strong class="kt ir"> useContext </strong>钩子。在这里，我们可以添加先前的上下文，并将该上下文存储在一个<strong class="kt ir"> const </strong>中，并将其命名为<strong class="kt ir"> newContext。</strong>现在使用<strong class="kt ir"> newContext </strong>变量，我们可以访问之前上下文中的所有值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/bff1d3855a42e1df4283bcd7a787770d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRBUU_v-FxNw6va-FtoAHA.png"/></div></div></figure><p id="3312" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">稍后，如果我们在<strong class="kt ir"> ProfilePage </strong>组件中呈现<strong class="kt ir"> NewUser </strong>组件，我们可以获得与上面相同的结果。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt ob"><a href="https://medium.com/javascript-in-plain-english/building-forms-in-react-native-with-formik-474be9d54a62" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">在React Native与Formik中构建表单</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">React Native中带有验证的更好的表单</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op kp ob"/></div></div></a></div></div></div>    
</body>
</html>