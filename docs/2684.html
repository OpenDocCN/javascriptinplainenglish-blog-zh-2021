<html>
<head>
<title>What are Linear Data Structures?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是线性数据结构？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-linear-data-structures-9afb3e05edc9?source=collection_archive---------14-----------------------#2021-06-02">https://javascript.plainenglish.io/what-are-linear-data-structures-9afb3e05edc9?source=collection_archive---------14-----------------------#2021-06-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4a70d5baae8386bacf9e43ce2770c686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AE0_hA1-YTsRCmX4.png"/></div></div></figure><p id="cf79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们说一个数据结构是“线性的”,如果其中的项目是按顺序存储的。</p><p id="544e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数组、链表和栈都是线性数据结构。</p><h1 id="3c60" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我为什么要在乎？</h1><p id="5467" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们每天都在编程中使用这些数据结构。</p><p id="4d28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使你已经很熟悉了，偶尔重温一下也是有帮助的。</p><h1 id="8975" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在5分钟或更短时间内</h1><p id="7262" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">正如我们在引言中所说的，如果元素形成一个序列，那么数据结构就是“线性”的。</p><p id="b150" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着数据结构有第一个和最后一个元素，每个元素都连接到它的前一个和下一个元素。</p><ul class=""><li id="195b" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">一个‘数组’<em class="mf">是</em>一个线性数据结构；项目是按顺序存储的。</li><li id="dec4" class="lw lx in jx b jy mg kc mh kg mi kk mj ko mk ks mb mc md me bi translated">“图形”是<em class="mf">而不是</em>线性数据结构；图中的任何节点都可以链接到任何其他节点，没有固定的“顺序”。</li></ul><p id="c273" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(如果你对图表不熟悉，不要担心——有一份时事通讯将详细探讨它们)。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/c9286f70eddf66dcb9b0e0fa5206695a.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*utXaR0UprB9kiAiDLbsxWQ.png"/></div></figure><p id="7f29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看一些常见的线性数据结构…</p><h1 id="9e15" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">数组</h1><p id="eb77" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果你做过任何编程，你几乎肯定熟悉数组的概念。</p><p id="a10c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个数组就像一个书架；这些条目存储在一起，但是我们可以跳到任何我们喜欢的条目来阅读。</p><p id="7393" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数组中的项目有一个“索引”,允许我们直接引用它们。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e65d8848bb4382de8cc0cdbcfc8622b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*8vBxLiVF2t-gaXvdP3rnEQ.png"/></div></figure><p id="c63b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">跳转到我们喜欢的任何项目来读取其值的能力被称为“随机访问”，这是数组的一个巨大优势。</p><p id="83ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们认为这是理所当然的，但这不是许多其他“线性数据结构”所具有的属性，正如您将在下面看到的。</p><p id="1d67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们分配阵列时，我们必须预先确定我们需要多少空间。</p><p id="4de5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们填满了数组，我们必须停下来分配更多的空间。这意味着，虽然正常的数组插入速度非常快，但偶尔我们不得不暂停一会儿，让数组变大——这需要一些时间。</p><h1 id="0bfd" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">链接列表</h1><p id="9155" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">链表是一种数据结构，其中每一项指向下一项。我们不能像数组那样直接跳到任何元素。相反，我们必须依次访问它们:</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/0be862ce479d3543cbf20a70d44da6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*ZiF6NE8nhiE0mDjXYNiTmQ.png"/></div></figure><p id="7b3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链表是有用的，因为不像数组，我们不需要预先决定我们需要多少空间。如果我们需要添加一个新项目，我们只需将它添加到末尾。</p><p id="fe0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着添加第200个项目与添加第2个项目的成本相同。这种可预测的性能是链表的一个优点。</p><p id="d868" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过简单地改变一些“下一个”指针，在链表的中间添加或删除一个条目也很容易。</p><p id="76de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我们如何从链表中移除一个条目:</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/f78372e179e40ef96f94f8c33413efe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*NtpE2mRlCShJeT8UhJ56kg.png"/></div></div></figure><p id="9ecf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这在一个数组中更难做到，因为我们必须移动所有剩余的项来说明新的或被删除的项。</p><p id="9964" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链表的一种变体是“双向链表”，其中每个元素不仅指向下一个元素的<em class="mf">，还指向前一个</em>元素的<em class="mf">。</em></p><p id="f643" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着我们可以以任意顺序遍历数据结构，但仍然具有链表的优点。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/464f2ca59e2905900dd3cfa693ad363f.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*I1t-16JROGGcaKUWpbF_kw.png"/></div></figure><h1 id="ee32" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">行列</h1><p id="89de" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">队列是一种“先进先出”(FIFO)的数据结构。这意味着项目的读取顺序与插入顺序相同。</p><p id="2399" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就好比在商店排队，第一个加入排队的人就是第一个被服务的人。</p><p id="b8ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打印机队列是使用这种数据结构的一个很好的例子。打印机将按照项目排队的顺序打印项目。如果您最后将文档发送到打印机，它将是最后打印的内容。</p><p id="1c17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">队列也可以用作“缓冲器”。</p><p id="4878" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有两个独立的系统，一个读取消息，一个处理消息。我们不希望<em class="mf">读取</em>消息的系统必须等待每条消息被<em class="mf">处理</em>后才能侦听另一条消息。</p><p id="8b64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在它们之间放置一个队列可以让我们“解耦”这些系统。<em class="mf">读取</em>进程可以继续将项目添加到队列中，安全地知道<em class="mf">处理</em>端将从队列中取出项目并最终处理它们——不需要等待。</p><h1 id="ebe0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">大量</h1><p id="f660" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">堆栈是一种“后进先出”的数据结构；要添加的最后一个<em class="mf">项目是要读取的第一个<em class="mf">项目。</em></em></p><p id="3307" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以把它想象成一堆盘子，最后一个加入的盘子是我们要拿走的第一个盘子:</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0c45517ade7ab3012541803b4ac2cf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*wDyw0qOOatsg4OXiJIOZPQ.png"/></div></figure><p id="dabc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，你可以使用堆栈来实现“撤销”功能。用户执行的最后一个<em class="mf">任务是用户点击“撤销”按钮时要撤销的第一个<em class="mf">任务。</em></em></p><p id="76ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们每天在运行代码时看到的“调用堆栈”也是堆栈的一个很好的例子，但这是未来通讯的主题！</p><p id="a496" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mf">我的</em> <a class="ae mv" href="https://www.baseclass.io/newsletter" rel="noopener ugc nofollow" target="_blank"> <em class="mf">通迅订阅者</em> </a> <em class="mf">先收到这个。</em></p><p id="51d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mf">更多内容请看</em><a class="ae mv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mf">plain English . io</em></strong></a></p></div></div>    
</body>
</html>