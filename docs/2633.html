<html>
<head>
<title>React’s Diffing Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React差分算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reacts-diffing-algorithm-1a64cfefa4e0?source=collection_archive---------2-----------------------#2021-05-31">https://javascript.plainenglish.io/reacts-diffing-algorithm-1a64cfefa4e0?source=collection_archive---------2-----------------------#2021-05-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ee7c0886838d324a0945a275dc0362f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nstnjGu7uPJ7tal4"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d248" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">抛弃香草JavaScript和它对React的颓废的沉重认真就像把自己从流沙般的关系中释放出来。生活不必再如此艰难。但是当你在与令人窒息的垃圾抗争时，约会的场景发生了变化。现在DOM更新速度更快，您的健身机构有机会使用新的应用程序。</p><p id="fd6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目前，在2021年夏天，React是用于创建交互式ui的最广泛使用的JavaScript库之一。它的组件模型为开发者提供了一个直观、干净的脚手架，从中可以弹出大胆、诱人的应用程序，吸引潜在的新客户走出他们在互联网地下墓穴中的藏身之处。这些新的应用程序对用户的欲望如此敏感，对他们的特性如此顺从，对潜意识的欲望如此接受，以至于它们创造了一种比普通的旧感觉更温暖的幻觉:注意力。</p><p id="056d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">怎么反应这么快？如此顺从？这么容易接受？答案就在diffing算法中，这是一个斯芬克斯，它的迷惑性谜语迷惑了许多卑微的开发者。</p><p id="2608" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React的速度是其虚拟DOM的结果。在后台，每次对React应用程序进行更改时(比如调用setState()，触发事件处理程序，或者发送API请求)，React都会从头开始呈现一个全新的虚拟DOM。与JavaScript的本体论保持一致，虚拟DOM本身——就像JavaScript世界中的其他事物一样——是一个JavaScript对象！</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/cb1a4b9b69db2a83412a5c616dd7510a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FI6U2tDTxDoLll5crRvU2Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Chrome’s developer tools offer us a peek at the virtual DOM</figcaption></figure><p id="599a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当您修改DOM树上的一个节点时，React都会扫描实际DOM上的树和它自己的相应副本——虚拟DOM——直到找到一个不同的节点。当React“看到”所讨论的更新节点与实际节点不匹配时，React会转到实际DOM并更新在虚拟DOM中更新的节点。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ld"><img src="../Images/47a9c1f15d8a278f34eed91627f73e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hO-Cn6XHEft1jCF6Idc3DA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">illustrations by Annie Bishai @AnnieBishai</figcaption></figure><p id="cde7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据其公开的<a class="ae jz" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">文档</a>，React使用一种叫做diffing算法的方法来比较新旧DOM。区分是一种基于两个假设的启发式算法:</p><ol class=""><li id="68ac" class="le lf in kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">两种不同类型的元素会产生不同的树。</li><li id="e843" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">开发人员可以使用关键道具提示哪些元素在渲染中保持稳定。(这就是为什么React总是警告我们在道具中包含关键点)。</li></ol><p id="a848" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">普通JavaScript要慢得多，因为对实际DOM进行每次更新都需要很多计算。浏览器将需要重新渲染CSS、布局和边距，这可能很麻烦，尤其是在应用程序很大的情况下。虚拟DOM只更新需要更新的节点。</p><p id="2b59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在比较DOM树的过程中，React尽可能地保留相同类型的元素，只更新它们的属性。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/e25aaca73f707326243b32536d4b35f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*636CLpQDx3PJHkS9Lcjizg.png"/></div></div></figure><p id="b6a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果发现一个更新的节点与实际DOM上的类型不同，React将停止搜索，忽略下面较低分支上可能发生的任何事情，并重新呈现整个子树。这个过程比检查每个子树分支的差异要快得多。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lt"><img src="../Images/84ae81ca3864abbfb1aa4af3fb58767b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ct0e3DBaeVwuGLEuRTk-g.jpeg"/></div></div></figure><p id="d19b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React使用广度优先而不是深度优先的逻辑在节点树中前进。在回溯之前，深度优先搜索从根节点沿着每个分支尽可能向下推进:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lt"><img src="../Images/87d50c0a166cf1296fb73e9be651c49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTZWHhmPWvCdkOnseus0iw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Depth-First Search</figcaption></figure><p id="2ea8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有React，节点树中的差异可以通过O(n)来计算，这意味着1，000次操作将需要1，000，000次计算。由于diffing算法，React可以以O(n)的速度计算差异。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lt"><img src="../Images/b50ccf163e13a8e99db5fd38b9793f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*py7-3qMXfYwmFJxK9e7MOw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Breadth-First Search</figcaption></figure><p id="98d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React的名字很贴切，因为这个库拥有对用户做出反应的不可思议的能力。这种令人着迷的迅捷给人的感觉是敏感。想象一下，一个响应如此迅速的应用程序感觉就像爱一样。</p><p id="ec48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lu">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lu">plain English . io</em></a></p></div></div>    
</body>
</html>