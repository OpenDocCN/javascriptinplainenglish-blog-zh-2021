<html>
<head>
<title>Did Someone say Composition?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有人说作文了吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/did-someone-say-composition-c7843d898b2?source=collection_archive---------9-----------------------#2021-06-02">https://javascript.plainenglish.io/did-someone-say-composition-c7843d898b2?source=collection_archive---------9-----------------------#2021-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c73" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何组成React组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cfaaf3c28a465ab7e8bc868beaa0a331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7HinrC6tcxPmIgiZ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dayne Topkin</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9bfc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">一点背景知识</h1><p id="bc81" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在过去的几个月里，我在一个致力于<strong class="lq ir">性能改进</strong>的团队中，对抗React代码库中的<a class="ae kv" href="https://atlassian.design/components" rel="noopener ugc nofollow" target="_blank">设计系统</a>。</p><p id="9950" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从表面上看，优化有两个部分:性能增强和代码重构/重新设计。然而，在几个月处理了几十个组件重构后，我们发现它们基本上是一个问题的两个方面:好的设计通常会带来更好的性能，反之亦然。</p><p id="d565" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是一个有趣的发现，当我们讨论增强性能的方法时，一个最容易被忽视的因素是软件本身的<strong class="lq ir">设计</strong>。我们关心包的大小和不必要的重新渲染，甚至CSS选择器的优先级。但是我们通常不会仅仅为了提高组件的性能而审查设计。另一方面，如果一个组件没有完全遵循<code class="fe mq mr ms mt b">S.O.L.I.D</code>原则，我们会说它缺乏可扩展性，或者太大而难以维护，但通常不会认为糟糕的设计会影响<em class="mp">性能</em>(也许性能问题只有在开发生命周期的后期才会被注意到)。</p><p id="c179" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了更详细地说明这个问题，以及我们如何改变我们的设计以使代码更有性能，让我们看一些具体的和典型的例子。</p><h1 id="86f6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">头像组件</h1><p id="37e8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们设计系统中的一个早期实现的<a class="ae kv" href="https://atlassian.design/components/avatar/examples" rel="noopener ugc nofollow" target="_blank">头像</a>组件上，它有一个便利的特性:如果用户将<code class="fe mq mr ms mt b">name</code>道具传入组件，那么当鼠标悬停在上面时，工具提示将显示在头像底部，并以<code class="fe mq mr ms mt b">name</code>为值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/24732b781b1457093df2fe67066222e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9_NEMQE-NIOb7eROR9LwQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Avatar component with Tooltip</figcaption></figure><p id="7168" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在内部，<code class="fe mq mr ms mt b">Avatar</code>正在利用另一个组件<code class="fe mq mr ms mt b">Tooltip</code>来实现这一目标:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="370c" class="mz kx iq mt b gy na nb l nc nd">import Tooltip from "@atlaskit/tooltip";</span><span id="8f38" class="mz kx iq mt b gy ne nb l nc nd">const Avatar = (props) =&gt; {<br/>  if (props.name) {<br/>    return (<br/>      &lt;Tooltip content={props.name}&gt;<br/>        &lt;Circle&gt;<br/>          &lt;img src={props.url} /&gt;<br/>        &lt;/Circle&gt;<br/>      &lt;/Tooltip&gt;<br/>    );<br/>  }</span><span id="f8e1" class="mz kx iq mt b gy ne nb l nc nd">  return (<br/>    &lt;Circle&gt;<br/>      &lt;img src={props.url} /&gt;<br/>    &lt;/Circle&gt;<br/>  );<br/>};</span></pre><p id="e629" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的代码是好的，当消费者要求定制工具提示时，我们才开始失去对组件的控制。例如，用户A可能希望工具提示显示在头像的顶部，而用户B希望能够定制工具提示的背景颜色/字体大小，等等。</p><p id="adda" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当然，我们也可以简单地给<code class="fe mq mr ms mt b">Avatar</code>添加一些道具，比如:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="184b" class="mz kx iq mt b gy na nb l nc nd">&lt;Avatar<br/>  tooltipPosition="top"<br/>  tooltipBackgroundColor="blue"<br/>  tooltipColor="whitesmoke"<br/>/&gt;;</span></pre><p id="12b3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">或者我们公开一个更灵活的<em class="mp">选项</em>对象，比如:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="4b8b" class="mz kx iq mt b gy na nb l nc nd">&lt;Avatar<br/>  tooltipProps={{<br/>    position: "top",<br/>    backgroundColor: "blue",<br/>    color: "whitesmoke",<br/>  }}<br/>/&gt;;</span></pre><p id="cf2f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后将它发送给底层的<code class="fe mq mr ms mt b">Tooltip</code>组件。但是很快，我们会看到这种方法的一些问题:</p><ul class=""><li id="f104" class="nf ng iq lq b lr mk lu ml lx nh mb ni mf nj mj nk nl nm nn bi translated">头像包包括工具提示包，是一个比较大的包</li><li id="9d77" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">每当用户想以某种方式定制<code class="fe mq mr ms mt b">Tooltip</code>时，<code class="fe mq mr ms mt b">Avatar</code>也需要采用这种改变</li><li id="fa49" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">来自<code class="fe mq mr ms mt b">Tooltip</code>的任何API变更可能需要在<code class="fe mq mr ms mt b">Avatar</code>重新打包</li></ul><p id="298d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是如果我们仔细观察头像组件，我们会注意到<code class="fe mq mr ms mt b">Tooltip</code>更像是一个补充功能，而不是一个基本功能(为用户显示图像)，更像是一个可选功能。因此，我们可以简化<code class="fe mq mr ms mt b">Avatar</code>，如下面没有<code class="fe mq mr ms mt b">Tooltip</code>的代码:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="741c" class="mz kx iq mt b gy na nb l nc nd">const Avatar = (props) =&gt; (<br/>  &lt;Circle&gt;<br/>    &lt;img src={props.url} title={props.name || ""} /&gt;<br/>  &lt;/Circle&gt;<br/>);</span></pre><p id="6a87" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它不会打破一个头像的定义，但它会打破现有的用户体验(例如，在这种情况下不一致)一点。这是我们考虑是否可以/应该将这两个组件分开并将Tooltip移出软件包的时候了。然后由消费者决定他们是否需要工具提示。换句话说，我们可以使代码更具有<em class="mp">可组合性</em>。</p><p id="bf6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，从依赖项中删除工具提示，代码变成:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="87aa" class="mz kx iq mt b gy na nb l nc nd">import Avatar from "@atlaskit/avatar";<br/>import Tooltip from "@atlaskit/tooltip";</span><span id="fe70" class="mz kx iq mt b gy ne nb l nc nd">const MyAvatar = (props) =&gt; (<br/>  &lt;Tooltip<br/>    content="Juntao Qiu"<br/>    position="top"<br/>    css={{ color: "whitesmoke", backgroundColor: "blue" }}<br/>  &gt;<br/>    &lt;Avatar<br/>      name="Juntao Qiu"<br/>      url="https://avatars.githubusercontent.com/u/122324"<br/>    /&gt;<br/>  &lt;/Tooltip&gt;<br/>);</span></pre><p id="863a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">乍一看，它可能与上一个没有太大区别，但注意这里上面的片段来自阿凡达的<em class="mp">消费者</em>。这意味着头像组件不知道(也不应该知道)工具提示的存在。例如，我们可以从另一个包<code class="fe mq mr ms mt b">@material-ui/core/Tooltip</code>中引入<code class="fe mq mr ms mt b">tooltip</code>，功能应该是相同的(当然，除了用户界面有一点改变):</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="d3d7" class="mz kx iq mt b gy na nb l nc nd">import Avatar from "@atlaskit/avatar";<br/>import Tooltip from "@material-ui/core/Tooltip";</span><span id="e7e3" class="mz kx iq mt b gy ne nb l nc nd">const MyAvatar = (props) =&gt; (<br/>  &lt;Tooltip title="Juntao Qiu" placement="top" classes={...}&gt;<br/>    &lt;Avatar<br/>      name="Juntao Qiu"<br/>      url="https://avatars.githubusercontent.com/u/122324"<br/>    /&gt;<br/>  &lt;/Tooltip&gt;<br/>);</span></pre><p id="562b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着什么呢？现在对于头像的消费者来说，工具提示不再是一个与头像绑定的黑匣子。此外，这种多<strong class="lq ir"> <em class="mp">可组合</em> </strong>的方法也有以下好处:</p><ul class=""><li id="1d78" class="nf ng iq lq b lr mk lu ml lx nh mb ni mf nj mj nk nl nm nn bi translated">对于头像本身来说，包的大小要小得多</li><li id="2079" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">消费者只为他们需要的东西付费</li><li id="6016" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">avatar不再绑定到任何特定的工具提示实现，所以用户可以选择他们喜欢的其他工具提示</li></ul><p id="8fa7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">事实上，在这些转换过程中，我们已经做了许多类似的更改。例如，在下一个例子中，我们将讨论——我们如何设法将<em class="mp">无效对话框</em>移出内嵌编辑组件。</p><h1 id="4b0e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">InlineEdit组件</h1><p id="29ae" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://atlassian.design/patterns/inline-edit" rel="noopener ugc nofollow" target="_blank">内联编辑</a>是代码库中另一个广泛使用的通用组件。它允许用户在不改变上下文的情况下编辑和保存页面上的内容。所以本质上，它是一个只有一个输入字段的表单。</p><p id="1b2b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在早期版本中，它提供了这样一个特性:当提供了<code class="fe mq mr ms mt b">validate</code> function prop时，如果在用户击键后返回false，那么在输入的右边会出现一个带有错误消息的弹出窗口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/09d026b6c83cf2ad7e205f18832c8d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eB9HYaJbq4EhKYWfm83cYQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Invalid status of an inline edit</figcaption></figure><p id="9887" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个特性的逻辑是这样的:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="1b8c" class="mz kx iq mt b gy na nb l nc nd">import InlineDialog from "@atlaskit/inline-dialog";</span><span id="491f" class="mz kx iq mt b gy ne nb l nc nd">const InlineEdit = (props) =&gt; {<br/>  const { validate, editView } = props;<br/>  return (<br/>    &lt;Field&gt;<br/>      {({ fieldProps, error }) =&gt; (<br/>        &lt;div&gt;<br/>          {editView(fieldProps)}<br/>          {validate &amp;&amp; (<br/>            &lt;InlineDialog<br/>              isOpen={fieldProps.isInvalid}<br/>              placement="right"<br/>              content={&lt;span&gt;{error}&lt;/span&gt;}<br/>            /&gt;<br/>          )}<br/>        &lt;/div&gt;<br/>      )}<br/>    &lt;/Field&gt;<br/>  );<br/>};</span></pre><p id="b1b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意这里的<code class="fe mq mr ms mt b">editView</code>是一个返回<code class="fe mq mr ms mt b">ReactNode</code>的函数，用户可以将自己的<code class="fe mq mr ms mt b">editView</code>定义为真实项目中的<code class="fe mq mr ms mt b">Textfield</code>或<code class="fe mq mr ms mt b">Select</code>。同样，通过隐式使用<code class="fe mq mr ms mt b">InlineDialog</code>，它可以防止用户使用其他对应的包。而<code class="fe mq mr ms mt b">validate</code>是用户传入检查内容是否有效的函数。</p><p id="c24b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，<code class="fe mq mr ms mt b">validate</code>可以是如下函数:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="3bf8" class="mz kx iq mt b gy na nb l nc nd">validate={(value) =&gt; {<br/>    if(value &amp;&amp; value.length &lt; 8) return false;<br/>}}</span></pre><p id="5d8c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，如果我们想应用与在<code class="fe mq mr ms mt b">Avatar</code>中相同的方法，那也不行:与头像和工具提示之间的松散耦合不同，这里的<code class="fe mq mr ms mt b">InlineEdit</code>和<code class="fe mq mr ms mt b">InlineDialog</code>是紧密耦合的:只有当<code class="fe mq mr ms mt b">InlineEdit</code>处于<code class="fe mq mr ms mt b">invalid</code>状态时，<code class="fe mq mr ms mt b">InlineDialog</code>才会出现。</p><p id="e0b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着我们可以<em class="mp">而不是</em>简单地将其重构为:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="59d7" class="mz kx iq mt b gy na nb l nc nd">import InlineDialog from "@atlaskit/inline-dialog";</span><span id="a558" class="mz kx iq mt b gy ne nb l nc nd">const MyEdit = () =&gt; {<br/>  return (<br/>      &lt;InlineDialog content={} isOpen={} placement="top"&gt;<br/>      &lt;InlineEdit<br/>        editView={(fieldProps) =&gt; &lt;Textfield {...fieldProps} /&gt;}<br/>        validate={(value) =&gt; {<br/>          return false;<br/>        }}<br/>      /&gt;<br/>    &lt;/InlineDialog&gt;<br/>  );<br/>};</span></pre><p id="5696" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为作为父节点，<code class="fe mq mr ms mt b">InlineDialog</code>无法知道其子节点的状态是什么(您可以使用上下文API来传递状态，但这会使组件不那么通用/独立)。所以我们需要做的是摆脱<strong class="lq ir">具体的</strong> <code class="fe mq mr ms mt b">InlineDialog</code>用法，转而依靠一些抽象:一种允许我们在输入内容出错时处理错误的抽象。</p><h2 id="75d0" class="mz kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">选项1</h2><p id="a101" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这里我们关心的是，当出现问题时，需要触发一个<em class="mp">动作</em>。动作是什么并不重要:它可能是在控制台上打印一条错误消息，或者从浏览器API使用本机<code class="fe mq mr ms mt b">alert</code>或者呈现一些其他定制组件。</p><p id="fbf6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们称这个动作为名为<code class="fe mq mr ms mt b">invalidView</code>的函数，它接受两个参数:<code class="fe mq mr ms mt b">isInvalid</code>表示验证状态，<code class="fe mq mr ms mt b">error</code>表示真正的错误消息。并且函数的签名可以是:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="5a6a" class="mz kx iq mt b gy na nb l nc nd">invalidView: (isInvalid: boolean, error: string) =&gt; React.ReactNode;</span></pre><p id="505a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后我们可以使用<code class="fe mq mr ms mt b">InlineEdit</code>中的功能来拆除<code class="fe mq mr ms mt b">InlineDialog</code>:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="5603" class="mz kx iq mt b gy na nb l nc nd">const InlineEdit = (props) =&gt; {<br/>  const { validate, editView, invalidView } = props;</span><span id="b6f2" class="mz kx iq mt b gy ne nb l nc nd">  return (<br/>    &lt;Field&gt;<br/>      {({ fieldProps, error }) =&gt; (<br/>        &lt;div&gt;<br/>          {editView(fieldProps)}<br/>          {validate &amp;&amp; invalidView(isInvalid, error)}<br/>        &lt;/div&gt;<br/>      )}<br/>    &lt;/Field&gt;<br/>  );<br/>};</span></pre><p id="90bc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于消费者来说，他们可以选择使用哪个包来进行错误提示:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="a1a0" class="mz kx iq mt b gy na nb l nc nd">import InlineDialog from "@atlaskit/inline-dialog"; //Note here how a consumer introduce InlineDialog for rendering error message</span><span id="bf40" class="mz kx iq mt b gy ne nb l nc nd">const MyEdit = () =&gt; {<br/>  return (<br/>    &lt;InlineEdit<br/>        editView={(fieldProps) =&gt; &lt;Textfield {...fieldProps} /&gt;}<br/>      validate={(value) =&gt; {<br/>        return false;<br/>      }}<br/>      invalidView={(isInvalid, error) =&gt; (<br/>        &lt;InlineDialog isOpen={isInvalid} content={error} placement="top" /&gt;<br/>      )}<br/>    /&gt;<br/>  );<br/>};</span></pre><p id="29a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从理论上来说，<code class="fe mq mr ms mt b">invalidView</code>可以做任何事情，因此存在无限的无效对话框的机会。</p><h2 id="eeda" class="mz kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">选项2</h2><p id="7450" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">或者，我们可以用另一种方式去掉<code class="fe mq mr ms mt b">InlineDialog</code>的直接/隐式用法。我们在内联编辑开始时谈到的<code class="fe mq mr ms mt b">editView</code>也是一个相对通用的函数，如果你查看它的签名的话:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="8a69" class="mz kx iq mt b gy na nb l nc nd">editView: (fieldProps: FieldProps) =&gt; React.ReactNode;</span></pre><p id="0ad8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以我们可以用另外两个参数扩展这个函数:<code class="fe mq mr ms mt b">isInvalid</code>和<code class="fe mq mr ms mt b">error</code>，就像这样:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="1746" class="mz kx iq mt b gy na nb l nc nd">const InlineEdit = (props) =&gt; {<br/>  const { validate, editView } = props;</span><span id="d4f9" class="mz kx iq mt b gy ne nb l nc nd">  return (<br/>    &lt;Field&gt;<br/>      {({ fieldProps, isInvalid, error }) =&gt; (<br/>        &lt;div&gt;<br/>          {editView(fieldProps, isInvalid, error)}<br/>        &lt;/div&gt;<br/>      )}<br/>    &lt;/Field&gt;<br/>  );<br/>};</span></pre><p id="d7c0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后当用户定义他们自己的<code class="fe mq mr ms mt b">editView</code>时，他们可以简单地用一个<code class="fe mq mr ms mt b">InlineDialog</code>或另一个UI包来包装它:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="6b5b" class="mz kx iq mt b gy na nb l nc nd">import InlineDialog from "@atlaskit/inline-dialog";</span><span id="f666" class="mz kx iq mt b gy ne nb l nc nd">const MyEdit = () =&gt; {<br/>  return (<br/>    &lt;InlineEdit<br/>      editView={(fieldProps, isInvalid, error) =&gt; (<br/>        &lt;InlineDialog isOpen={isInvalid} content={error} placement="top"&gt;<br/>          &lt;Textfield {...fieldProps} /&gt;<br/>        &lt;/InlineDialog&gt;<br/>      )}<br/>      validate={(value) =&gt; {<br/>        return false;<br/>      }}<br/>    /&gt;<br/>  );<br/>};</span></pre><p id="7fe2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样，我们就可以解耦<code class="fe mq mr ms mt b">InlineEdit</code>和<code class="fe mq mr ms mt b">InlineDialog</code>，注意这里editView的内容来自消费者，而不是我们的设计系统。</p><p id="f632" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，消费者现在可以在相同的场景中使用Material-UI中的<code class="fe mq mr ms mt b">popover</code>:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="b0b8" class="mz kx iq mt b gy na nb l nc nd">import InlineDialog from "@atlaskit/inline-dialog";<br/>import Popover from "@material-ui/core/Popover";<br/>import Typography from "@material-ui/core/Typography";</span><span id="57e1" class="mz kx iq mt b gy ne nb l nc nd">const MyEdit = () =&gt; {<br/>  return (<br/>    &lt;InlineEdit<br/>      editView={(fieldProps, isInvalid, error) =&gt; (<br/>        &lt;Popover open={isInvalid}&gt;<br/>          &lt;Typography&gt;{error}&lt;/Typography&gt;<br/>          &lt;Textfield {...fieldProps} /&gt;<br/>        &lt;/Popover&gt;<br/>      )}<br/>      validate={(value) =&gt; {<br/>        return false;<br/>      }}<br/>    /&gt;<br/>  );<br/>};</span></pre><p id="e816" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">或者默默咽下错误:</p><pre class="kg kh ki kj gt mv mt mw mx aw my bi"><span id="8618" class="mz kx iq mt b gy na nb l nc nd">const MyEdit = () =&gt; {<br/>  return (<br/>    &lt;InlineEdit<br/>      editView={(fieldProps, isInvalid, error) =&gt; {<br/>        if (isInvalid) {<br/>          console.log(error);<br/>        }</span><span id="683c" class="mz kx iq mt b gy ne nb l nc nd">        return (&lt;Textfield {...fieldProps} /&gt;);<br/>      }}<br/>      validate={(value) =&gt; {<br/>        return false;<br/>      }}<br/>    /&gt;<br/>  );<br/>};</span></pre><p id="83ae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我们所看到的，选项1和选项2非常相似:我们试图让组件不知道真实的错误响应，并将这个决定推迟到组件的消费者。这种方法的优点是组件对于处理无效内容更加开放(而不是引入一个具体的包来关闭所有其他可能性)。我们通过减少额外的封装实现了这一点，这意味着更小的包尺寸。此外，有了简化的逻辑，我们的设计系统组件就不太可能出现错误。</p><h1 id="9d4b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="920c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通过上面的例子，我想我们可以得出这样的结论:一旦我们决定在我们的代码中使用一个特定的库/包，我们就不可避免地关闭了所有其他的替代方案。例如，我们在《阿凡达》中使用了<code class="fe mq mr ms mt b">@atlaskit/tooltip</code>，那么最终消费者无论如何都必须使用它(他们可能必须使用其他类似的包)，就像我们在<code class="fe mq mr ms mt b">InlineEdit</code>中使用<code class="fe mq mr ms mt b">@atlaskit/inline-dialog</code>来关闭消费者使用<code class="fe mq mr ms mt b">Popover</code>的可能性一样。</p><p id="8315" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好消息是，一旦我们发现了问题，解决方案就相当简单了。对于那些可以完全分离的部分(比如工具提示和头像场景)，我们可以从我们的包中移除该组件，并要求消费者进行一些迁移(我有另一篇文章<a class="ae kv" href="https://itnext.io/automatic-refactoring-with-jscodeshift-codemods-45c219eaf992" rel="noopener ugc nofollow" target="_blank"/>)来覆盖它。对于那些有相互关系的，我们需要让我们的代码依赖于抽象(而不是具体的实现)，并且确保我们的代码只访问这些抽象的层，让消费者完成其余的工作。这样，我们可以最大限度地减少依赖性，最大限度地提高灵活性。</p><h1 id="1e5b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">其他参考文献</h1><ul class=""><li id="26b0" class="nf ng iq lq b lr ls lu lv lx of mb og mf oh mj nk nl nm nn bi translated">如果你对<code class="fe mq mr ms mt b">editView</code>函数不熟悉，这里有一些关于Final Form(我们在内嵌编辑中使用的底层API)的类似例子</li><li id="2416" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">肯特·多德有一篇非常棒的帖子《T4》，详细描述了这里使用的模式背后的理论。强烈建议。</li></ul><p id="5944" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">更多内容请参见</em> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">简明英语. io </em> </a></p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="02f3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">如果您喜欢阅读，请</strong> <a class="ae kv" href="https://icodeit.com.au/#subscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">在我的邮件列表</strong> </a> <strong class="lq ir">上签名。我每周都通过</strong> <a class="ae kv" href="https://juntao-qiu.medium.com/" rel="noopener"> <strong class="lq ir">博客</strong></a><strong class="lq ir"/><a class="ae kv" href="https://leanpub.com/u/juntao" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">书籍</strong> </a> <strong class="lq ir">和</strong> <a class="ae kv" href="https://www.youtube.com/@icodeit.juntao" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">视频</strong> </a> <strong class="lq ir">分享清洁代码和重构技术。</strong></p></div></div>    
</body>
</html>