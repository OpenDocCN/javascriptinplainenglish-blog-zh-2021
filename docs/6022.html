<html>
<head>
<title>Difference Between let and var in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中字母和变量的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/difference-between-let-var-in-javascript-2497ec45641b?source=collection_archive---------3-----------------------#2021-12-25">https://javascript.plainenglish.io/difference-between-let-var-in-javascript-2497ec45641b?source=collection_archive---------3-----------------------#2021-12-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="61be" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">让我们了解一下为什么在JavaScript中有两种声明变量的方式，提升和闭包概念。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1cea62a3572e5b9ee87e666a399348b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VGxvcpxOuytn6rNM"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="29f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在ECMAScript6 (2015)之前，JavaScript只有全局作用域和函数作用域。现在我们又有了一个:块范围。ES6引入了两个重要的新JavaScript关键字:<strong class="kv io"> let </strong>和<strong class="kv io"> const </strong>。</p><p id="8ab7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们所说的范围是什么意思？</p><p id="c45b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">范围决定了变量可见或可访问的区域。</p><p id="03b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以谈论两个不同的范围，即<strong class="kv io">全局</strong>和<strong class="kv io">局部</strong>。其中，局部有两个子类型，即<strong class="kv io">功能</strong>和<strong class="kv io">块</strong>。</p><p id="03c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了更好地理解什么是作用域，我们可以看下面的例子:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="8614" class="lu lv in lq b gy lw lx l ly lz">const message = 'Hello';</span><span id="ab4c" class="lu lv in lq b gy ma lx l ly lz">console.log(message);     // 'Hello'</span></pre><p id="62b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好了，正如所料，我们将消息常量打印为“Hello”。让我们看看当我们把声明移到if语句中时会发生什么:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="485a" class="lu lv in lq b gy lw lx l ly lz">if (true) {</span><span id="eba2" class="lu lv in lq b gy ma lx l ly lz">const message = 'Hello';</span><span id="61cd" class="lu lv in lq b gy ma lx l ly lz">}</span><span id="f050" class="lu lv in lq b gy ma lx l ly lz">console.log(message); // Uncaught ReferenceError: message is not defined"</span></pre><p id="6f8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们无法打印，因为我们试图在我们定义的范围之外打印。它是不可访问的。</p><p id="f0c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">作用域是一条规则，规定你不能访问这个区域之外的变量。</p><p id="a6be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当一个变量<em class="mb">是全局作用域</em>时，这意味着它在你程序的任何地方都是可用的。全局范围是最外层的范围。它可以从任何内部(又名<em class="mb">局部</em>)作用域访问。</p><p id="d5ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们深入本地范围。</p><p id="00c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">封锁范围:</strong></p><p id="fed2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们所说的块是由花括号分隔的代码片段。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="59df" class="lu lv in lq b gy lw lx l ly lz">{</span><span id="1062" class="lu lv in lq b gy ma lx l ly lz">StatementList</span><span id="3651" class="lu lv in lq b gy ma lx l ly lz">}</span></pre><p id="da58" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果需要，可以标记块。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="6f2c" class="lu lv in lq b gy lw lx l ly lz">LabelIdentifier: {</span><span id="46b2" class="lu lv in lq b gy ma lx l ly lz">StatementList</span><span id="f41a" class="lu lv in lq b gy ma lx l ly lz">}</span></pre><p id="1b4a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们在上面给出了块范围的第一个例子。当我们试图在if语句中声明constant时，我们遇到了块范围的变量。</p><p id="b178" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">功能范围:</strong></p><p id="5c86" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">顾名思义，它被认为是可以在函数中访问的。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="aae3" class="lu lv in lq b gy lw lx l ly lz">function ring() {</span><span id="3950" class="lu lv in lq b gy ma lx l ly lz">// "ring" function scope</span><span id="dd64" class="lu lv in lq b gy ma lx l ly lz">var message = '<strong class="lq io">One Ring to rule them all, One Ring to find them,</strong> <strong class="lq io">One Ring to bring them all and in the darkness bind them</strong>.';</span><span id="26c3" class="lu lv in lq b gy ma lx l ly lz">console.log(message); // '<strong class="lq io">One Ring to rule them all, One Ring to find them,</strong> <strong class="lq io">One Ring to bring them all and in the darkness bind them</strong>.'</span><span id="2273" class="lu lv in lq b gy ma lx l ly lz">}<br/></span><span id="3128" class="lu lv in lq b gy ma lx l ly lz">ring();</span><span id="544b" class="lu lv in lq b gy ma lx l ly lz">console.log(message); // Uncaught ReferenceError: message is not defined"</span></pre><p id="8a51" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">就是这样！因为它是函数范围的。同样，我们不能打印消息变量</p><p id="8b7d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于作用域的一个关键点是<em class="mb">内部作用域</em>可以访问其<em class="mb">外部作用域</em>的变量。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="3dd6" class="lu lv in lq b gy lw lx l ly lz">function ring() {</span><span id="d6cd" class="lu lv in lq b gy ma lx l ly lz">// "ring" function scope</span><span id="9696" class="lu lv in lq b gy ma lx l ly lz">const message = '<strong class="lq io">One Ring to rule them all, One Ring to find them,</strong> <strong class="lq io">One Ring to bring them all and in the darkness bind them</strong>.';</span><span id="83d6" class="lu lv in lq b gy ma lx l ly lz">if (true) {</span><span id="d89f" class="lu lv in lq b gy ma lx l ly lz">// "if" code block scope</span><span id="0831" class="lu lv in lq b gy ma lx l ly lz">const carrier = 'Frodo';</span><span id="ff39" class="lu lv in lq b gy ma lx l ly lz">console.log(message); // '<strong class="lq io">One Ring to rule them all, One Ring to find them,</strong> <strong class="lq io">One Ring to bring them all and in the darkness bind them</strong>.'<br/></span><span id="4881" class="lu lv in lq b gy ma lx l ly lz">}</span><span id="8113" class="lu lv in lq b gy ma lx l ly lz">console.log(carrier); // throws ReferenceError</span><span id="6f2e" class="lu lv in lq b gy ma lx l ly lz">}<br/></span><span id="140c" class="lu lv in lq b gy ma lx l ly lz">ring();</span></pre><p id="166e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以在内部作用域(if语句)打印<em class="mb">消息</em>变量，但是我们不能在外部作用域打印<em class="mb">载体</em>变量。</p><p id="7eb2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我假设您已经了解了什么是作用域，现在是时候看看两个变量声明之间的区别了。</p><h2 id="112b" class="lu lv in bd mc md me dn mf mg mh dp mi lc mj mk ml lg mm mn mo lk mp mq mr ms bi translated">let和var的差异:</h2><p id="b29e" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated"><strong class="kv io"> var </strong>是声明变量的老办法，也是最弱的关键字。为什么？因为:</p><ul class=""><li id="b35d" class="my mz in kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated"><strong class="kv io">变量</strong>是函数作用域</li><li id="38b1" class="my mz in kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated"><strong class="kv io">设</strong>是块范围的</li><li id="cb58" class="my mz in kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated"><strong class="kv io"> var </strong>可以更新，也可以重新申报</li><li id="a7d3" class="my mz in kv b kw nh kz ni lc nj lg nk lk nl lo nd ne nf ng bi translated"><strong class="kv io">让</strong>可以更新但不能重新声明</li></ul><p id="95e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在一个例子中检查关于<strong class="kv io">变量</strong>的问题:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="f7c1" class="lu lv in lq b gy lw lx l ly lz">var offer = "<!-- -->The story ends<!-- -->";</span><span id="72e5" class="lu lv in lq b gy ma lx l ly lz">var pill = blue;<br/><br/>if (pill == red ) {<br/> var offer = "<!-- -->Stay In Wonderland<!-- -->"; <br/>}<br/>    <br/>console.log(offer); // "<!-- -->Stay In Wonderland<!-- -->"</span></pre><p id="fa3b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们在全球范围内接受了蓝色药丸，但当我们打印报价时，我们不得不呆在仙境中:(</p><p id="4917" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为<strong class="kv io">变量</strong>不是块范围的。我们可以在if语句中访问<em class="mb"> offer </em>变量。并且它改变分配给<em class="mb">报价</em>的字符串值。</p><p id="402f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于作用域的不同，我们也从具有闭包的循环中获得不同的值，如下所示:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="ed30" class="lu lv in lq b gy lw lx l ly lz">// Logs 3 thrice, not what we meant.<br/>for (var i = 0; i &lt; 3; i++) {<br/>  setTimeout(() =&gt; console.log(i), 0);<br/>}</span><span id="c1b2" class="lu lv in lq b gy ma lx l ly lz">// Logs 0, 1 and 2, as expected.<br/>for (let j = 0; j &lt; 3; j++) {<br/>  setTimeout(() =&gt; console.log(j), 0);<br/>}</span></pre><p id="24bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果对你来说这还不够，还有一个问题:</p><p id="b9b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">我们可以更新两种变量类型，而不会出现错误:</strong></p><p id="12da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用<strong class="kv io">让</strong></p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="5d32" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">let offer = "The story ends";<br/>offer = "Stay in Wonderland";</strong></span></pre><p id="d559" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用<strong class="kv io"> var </strong></p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="3abf" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">var offer = "The story ends";<br/>offer = "Stay in Wonderland";</strong></span></pre><p id="7f86" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">但是当我们试图重新声明它们的时候:</strong></p><p id="d061" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用<strong class="kv io">让</strong></p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="8ea2" class="lu lv in lq b gy lw lx l ly lz">let offer = "<strong class="lq io">The story ends</strong>";<br/>let offer = "<strong class="lq io">Stay in Wonderland</strong>"; // <!-- -->Uncaught SyntaxError: Identifier 'offer' has already been declared"</span></pre><p id="e3cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用<strong class="kv io"> var </strong></p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="ef9a" class="lu lv in lq b gy lw lx l ly lz">var offer = "<strong class="lq io">The story ends</strong>";<br/>var offer = "<strong class="lq io">Stay in Wonderland</strong>";</span></pre><p id="330c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们不想无意中声明一个变量两次，对吗？</p><p id="738c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<strong class="kv io"> let </strong>减少了处理大量变量时可能发生的潜在命名冲突。当你想让一个全局变量显式地出现在窗口<strong class="kv io"> </strong>对象上时，可以使用<strong class="kv io">变量</strong>(如果有必要，一定要仔细考虑)。</p><h1 id="98b3" class="nm lv in bd mc nn no np mf nq nr ns mi jt nt ju ml jw nu jx mo jz nv ka mr nw bi translated">提升</h1><p id="4e39" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">在编译阶段，就在代码执行前的几微秒内，它会被扫描函数和变量声明。所有这些函数和变量声明都被添加到名为<strong class="kv io">词法环境</strong>的JavaScript数据结构的内存中。以便在源代码中声明它们之前就可以使用它们。</p><p id="c082" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这个概念的帮助，我们可以在我们定义它们的线之上使用函数:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="d7d5" class="lu lv in lq b gy lw lx l ly lz">mithrandir();  // "A wizard is never late"<br/>mithrandir(){<br/>  console.log('A wizard is never late');<br/>}</span></pre><p id="73c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有的变量都被提升了。然而，虽然<strong class="kv io">变量</strong>声明用<em class="mb">未定义</em>初始化，但是<strong class="kv io">让</strong>和<strong class="kv io">常量</strong>声明保持<em class="mb">未初始化。</em></p><p id="3983" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看一个例子:</p><p id="5c2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用<strong class="kv io"> var </strong></p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="e780" class="lu lv in lq b gy lw lx l ly lz">console.log(password); // undefined<br/>var password = 'Speak, friend, and enter.';</span></pre><p id="4d70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用<strong class="kv io">让</strong></p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="d657" class="lu lv in lq b gy lw lx l ly lz">console.log(password); // undefined<br/>let password = 'Speak, friend, and enter.'; // Uncaught ReferenceError: Cannot access 'password' before initialization"</span></pre><h1 id="5999" class="nm lv in bd mc nn no np mf nq nr ns mi jt nt ju ml jw nu jx mo jz nv ka mr nw bi translated"><strong class="ak">关闭</strong></h1><p id="edf9" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">有一个访问内部作用域的提示，那就是使用闭包！</p><p id="9a3a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mb">闭包</em>是一个访问其内部作用域的函数，即使在其词法作用域之外执行。</p><p id="f678" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过一个基本示例学习闭包概念:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="f134" class="lu lv in lq b gy lw lx l ly lz">function ring() {</span><span id="5c10" class="lu lv in lq b gy ma lx l ly lz"> let carrier = 'Frodo';</span><span id="a385" class="lu lv in lq b gy ma lx l ly lz"> function gollum() {</span><span id="4c50" class="lu lv in lq b gy ma lx l ly lz">  console.log(carrier); // "Frodo"</span><span id="6a91" class="lu lv in lq b gy ma lx l ly lz"> }</span><span id="11d0" class="lu lv in lq b gy ma lx l ly lz"> gollum();</span><span id="912a" class="lu lv in lq b gy ma lx l ly lz">}<br/></span><span id="9222" class="lu lv in lq b gy ma lx l ly lz">ring(); </span></pre><p id="8eab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们有一个名为<em class="mb">载体</em>的变量,“Frodo”被分配给这个变量。正如所料，它甚至可以从内部函数<em class="mb">咕鲁</em>中访问:)</p><p id="b644" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当执行函数ring()时，它正在执行gollum()函数，我们可以在ring()函数范围之外访问<em class="mb">载体</em>变量。</p><p id="5807" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">咕鲁是这里的终结。</p><p id="f715" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个题目到此为止。感谢您的阅读。</p><p id="8227" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mb">更多内容看</em> <a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mb">说白了. io </em> </a> <em class="mb">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mb">免费每周简讯</em> </a> <em class="mb">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="mb">社区</em> </a> <em class="mb">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>