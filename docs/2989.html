<html>
<head>
<title>The Operator of the Day: The concatMap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">今日操作符:连接图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-operator-of-the-day-the-concatmap-f7a416945663?source=collection_archive---------9-----------------------#2021-06-17">https://javascript.plainenglish.io/the-operator-of-the-day-the-concatmap-f7a416945663?source=collection_archive---------9-----------------------#2021-06-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="952d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它会把虫子赶走的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0caca080298ff9cd6ec5ce611f45acbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-V-lV54v9GEGozhp-BsiQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@lunarts?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Volodymyr Hryshchenko</a> on <a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3bb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经开始了这一系列的文章来研究RxJS中的每一个操作符、creational和其他操作符。虽然我以前和认识很多，但我不知道他们中的每一个。很多时候，我意识到如果我只知道一个操作者，会有一个更干净或更短的做事方法。我想让这些文章简短，但有几个例子有意义，所以我决定每篇文章用一个操作符。</p><h1 id="2b46" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">基础知识</h1><p id="61a8" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">让我们看看医生们对今天的操作符<strong class="jm io"> concatMap </strong>是怎么说的。</p><blockquote class="mc md me"><p id="5543" class="jk jl mf jm b jn jo jp jq jr js jt ju mg jw jx jy mh ka kb kc mi ke kf kg kh ig bi translated">将每个源值投影到一个可观察对象中，该可观察对象合并到输出可观察对象中，以序列化的方式等待每个对象完成，然后再合并下一个对象。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/a2ae4be920ab4d02592035babc811033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHmPOKIxuNGyGc6WSQlLKg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image from <a class="ae ky" href="https://rxjs-dev.firebaseapp.com/api/operators/concatMap" rel="noopener ugc nofollow" target="_blank">RxJS’s documentation</a></figcaption></figure><p id="b80d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从marble图和文档中可以看到，也可能从名字中猜到，这个操作符用于将其他所谓的内部可观察对象连接到源。这里的关键字是concat。你一定不要忘记<strong class="jm io">这个操作符会在开始新的观察之前，等待每一个内部观察完成。这种行为有时是可取的，但有时不是。让我们看一些例子:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">RxJS’s docs example</figcaption></figure><p id="d2fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们来看一个和RxJS网站上marbles写的一样的例子。我使用marble testing来创建代码样本，我发现这是一种很好的可视化方式来表现操作员是如何工作的。</p><p id="5afc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能注意到的第一件事是，内部可观察的模式(大理石)可以在预期的输出可观察到。这应该是您所期望的，因为文档还说concatMap将在处理下一个发出的值之前等待内部可观察对象完成。这也意味着它将等待它完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">concatMap with non-emitting inner observable</figcaption></figure><p id="f9e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的例子表明，如果我把内部可观察对象变成一个热可观察对象，它根本没有完成，我们的输出可观察对象会更长，或者它甚至不会完成或发出值。这可能会引起混乱。例如，您可能将一系列事件连接到您的源可观察对象中，而该事件恰好根本没有被引发，那么您的输出可观察对象将永远不会发出任何值，也不会完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">concatMap to a hot Observable that completes before the source emits</figcaption></figure><p id="9f52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您将一个映射连接到一个内部可观察对象，这个内部可观察对象是热的，虽然是完整的，但是在任何值到达您的源可观察对象之前，它就已经完成并发出了值。这将导致一个空流，无论有多少值来自源，它都不会发出任何值。</p><h1 id="daff" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="af8d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><strong class="jm io">使用concatMap运算符，当:</strong></p><ul class=""><li id="cc16" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">你想映射到一个内在的可观察对象，它是冷的，你确信它会完成。</li><li id="62ac" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">您希望将您的可观察对象映射到一个不重复出现的HTTP请求。(“不重复”部分在这里很重要，因为concatMap将等待每个内部可观察对象完成)</li></ul><p id="e287" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">使用concatMap运算符时，请小心</strong>，如果:</p><ul class=""><li id="6ae7" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">您将映射连接到一个内部可观察对象，它表示一个重复的HTTP请求。通常，当新值到达时，您希望取消旧的HTTP请求。因此，在这种情况下，要确保通过HTTP处理由源observable发出的每个值。</li></ul><p id="d305" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">避免</strong>，使用concatMap运算符，当:</p><ul class=""><li id="2421" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">你必须映射到一个你无法控制的热可观察点。就像一连串你无法完成的事件或主题，或者你不知道它何时完成。</li><li id="9a4c" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">你必须映射到一个内部可观察对象，它比你的源可观察对象发出值要慢。因为它在等待每个内部可观察对象完成，这可能会导致内存/性能问题。</li></ul><p id="0427" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mf">更多内容尽在</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>