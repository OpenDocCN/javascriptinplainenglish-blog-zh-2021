<html>
<head>
<title>Code Splitting in React — All You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的代码拆分—您需要知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/code-splitting-in-react-all-you-need-to-know-392b0dfeb1fa?source=collection_archive---------1-----------------------#2021-12-29">https://javascript.plainenglish.io/code-splitting-in-react-all-you-need-to-know-392b0dfeb1fa?source=collection_archive---------1-----------------------#2021-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b491" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中代码拆分的深入探讨。</h2></div><p id="bd0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多JavaScript框架将所有依赖项捆绑到一个大文件中。这使得将JavaScript添加到HTML页面变得很容易。这个包只需要一个链接标签，而且设置页面所需的调用也更少，因为所有的JavaScript都在一个地方。</p><p id="580c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在某一点上，一个包变得太大，在这一点上解释和执行代码的开销降低了页面的加载速度，而不是加速。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/794a1528cf80a63194616c90e98411bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/0*0_lW1Bi7X52KP2cy.jpg"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae ln" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fdev.to%2Fben%2Fcomment%2F1a1p4&amp;psig=AOvVaw0ajNg7EccWTU6bWFp1Nxb0&amp;ust=1640890207155000&amp;source=images&amp;cd=vfe&amp;ved=0CAsQjRxqFwoTCIiH6tbWifUCFQAAAAAdAAAAABAm" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><p id="d995" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是代码分割可以帮助你的地方。代码分割允许您有策略地从包中省略某些依赖项，然后只在需要的地方插入它们。这意味着它们只有在需要的时候才会被加载——只有在需要的时候才加载JavaScript，这加快了页面的加载时间。</p><h1 id="7cc8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">如何在React中进行代码拆分</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/9328e2a0fcabd7a3874e974faccabcd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*yLajQE41IOyx5TRm.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae ln" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Ftwitter.com%2Fswyx%2Fstatus%2F1158369440326721537&amp;psig=AOvVaw1Svbs9nvfv6QgDU0_MaKql&amp;ust=1640890216832000&amp;source=images&amp;cd=vfe&amp;ved=2ahUKEwiB_ZfF1on1AhVwrWoFHcrAAqUQjRx6BAgAEAk" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><h2 id="0a02" class="mh lp iq bd lq mi mj dn lu mk ml dp ly ko mm mn ma ks mo mp mc kw mq mr me ms bi translated"><strong class="ak">动态导入</strong></h2><p id="3582" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">在React中分割代码的最简单方法是使用动态导入语法。有些绑定器可以本地解析动态导入语句，而有些则需要一些配置。动态导入语法适用于静态站点生成和服务器端呈现。</p><p id="d49f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">之前:</strong></p><pre class="lc ld le lf gt my mz na nb aw nc bi"><span id="d2e4" class="mh lp iq mz b gy nd ne l nf ng">import { add } from './math';<br/>console.log(add(16, 26));</span></pre><p id="0652" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">之后:</strong></p><pre class="lc ld le lf gt my mz na nb aw nc bi"><span id="7aa2" class="mh lp iq mz b gy nd ne l nf ng">import("./math").then(math =&gt; {<br/>  console.log(math.add(16, 26));<br/>});</span></pre><p id="b895" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这确保了只有在真正需要的时候才加载这个包。</p><h2 id="0d76" class="mh lp iq bd lq mi mj dn lu mk ml dp ly ko mm mn ma ks mo mp mc kw mq mr me ms bi translated"><strong class="ak">使用React.lazy </strong></h2><p id="8893" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated"><code class="fe nh ni nj mz b">React.lazy</code>函数让你把一个动态导入渲染成一个常规组件。</p><p id="e1bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">之前:</strong></p><pre class="lc ld le lf gt my mz na nb aw nc bi"><span id="ecbd" class="mh lp iq mz b gy nd ne l nf ng">import MyComponent from './MyComponent';</span></pre><p id="759d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">之后:</strong></p><pre class="lc ld le lf gt my mz na nb aw nc bi"><span id="6aff" class="mh lp iq mz b gy nd ne l nf ng">const MyComponent = React.lazy(() =&gt; import('./MyComponent'));</span></pre><p id="f185" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nh ni nj mz b">React.lazy</code>接受一个必须调用动态<code class="fe nh ni nj mz b">import()</code>的函数。这必须返回一个<code class="fe nh ni nj mz b">Promise</code>，它解析为一个带有包含React组件的<code class="fe nh ni nj mz b">default</code>导出的模块。</p><p id="db23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="nk">注意</em> </strong> <em class="nk"> —组件必须呈现在</em> <strong class="kh ir"> <em class="nk">悬念</em> </strong> <em class="nk">组件内，在加载时显示回退内容。</em></p><pre class="lc ld le lf gt my mz na nb aw nc bi"><span id="1113" class="mh lp iq mz b gy nd ne l nf ng">import React, { Suspense } from 'react';<br/><br/>const MyComponent = React.lazy(() =&gt; import('./MyComponent'));<br/><br/>function MainComponent() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>        &lt;MyComponent /&gt;<br/>      &lt;/Suspense&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="73f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在等待组件加载时，<code class="fe nh ni nj mz b">fallback</code> prop接受您想要呈现的任何React元素。您可以将<code class="fe nh ni nj mz b">Suspense</code>组件放在惰性组件之上的任何地方。您甚至可以用一个<code class="fe nh ni nj mz b">Suspense</code>组件包装多个惰性组件。[ <a class="ae ln" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">链接</a> ]</p><p id="ef08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果<strong class="kh ir"> <em class="nk">网络调用</em> </strong>失败，您可以在代码中使用<strong class="kh ir">错误边界</strong>来显示错误。一旦创建了错误边界，当出现网络错误时，可以在惰性组件上方的任何地方使用它来显示错误状态。</p><pre class="lc ld le lf gt my mz na nb aw nc bi"><span id="0063" class="mh lp iq mz b gy nd ne l nf ng">import React, { Suspense } from 'react';<br/>import MyErrorBoundary from './MyErrorBoundary';</span><span id="1b02" class="mh lp iq mz b gy nl ne l nf ng">const MyComponent = React.lazy(() =&gt; import('./MyComponent'));<br/><br/>function MainComponent() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;MyErrorBoundary&gt;<br/>        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>          &lt;MyComponent /&gt;<br/>        &lt;/Suspense&gt;<br/>      &lt;/MyErrorBoundary&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="c334" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><strong class="ak">在哪里引入代码拆分</strong></h1><p id="53b9" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">决定在应用程序的什么地方引入代码分割可能有点棘手。你需要确保你选择的位置可以平均分割包，但不会破坏用户体验。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e30785f38ed93373cb4eb66979bd9184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*izIr78hNJlZbj5dy.jpg"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae ln" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fmedium.com%2F%40mattdlockyer%2Fyoure-using-materialize-css-wrong-470b593e78e9&amp;psig=AOvVaw1-64Xr4pI69_nropyL60i8&amp;ust=1640890370803000&amp;source=images&amp;cd=vfe&amp;ved=0CAsQjRxqFwoTCMjyhpzXifUCFQAAAAAdAAAAABAJ" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><h2 id="3f01" class="mh lp iq bd lq mi mj dn lu mk ml dp ly ko mm mn ma ks mo mp mc kw mq mr me ms bi translated"><strong class="ak">基于路由的代码拆分</strong></h2><p id="15cd" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">一个好的起点是路线。网络上的大多数人都习惯于页面转换，这需要花费一些时间来加载。您还倾向于一次重新呈现整个页面，因此您的用户不太可能同时与页面上的其他元素进行交互。</p><pre class="lc ld le lf gt my mz na nb aw nc bi"><span id="377f" class="mh lp iq mz b gy nd ne l nf ng">import React, { Suspense, lazy } from 'react';<br/>import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';<br/><br/>const Home = lazy(() =&gt; import('./routes/Home'));<br/>const About = lazy(() =&gt; import('./routes/About'));<br/><br/>const App = () =&gt; (<br/>  &lt;Router&gt;<br/>    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>      &lt;Switch&gt;<br/>        &lt;Route exact path="/" component={Home}/&gt;<br/>        &lt;Route path="/about" component={About}/&gt;<br/>      &lt;/Switch&gt;<br/>    &lt;/Suspense&gt;<br/>  &lt;/Router&gt;<br/>);</span></pre><h2 id="72be" class="mh lp iq bd lq mi mj dn lu mk ml dp ly ko mm mn ma ks mo mp mc kw mq mr me ms bi translated"><strong class="ak">基于组件的代码拆分</strong></h2><p id="f443" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">React还允许您基于组件而不是原始功能来拆分代码。React-loadable函数使您能够创建一个定制的加载器，该加载器只需动态导入一次所需的代码块。将动态导入包装在加载器中可以防止它们被包含在页面加载包中。</p><pre class="lc ld le lf gt my mz na nb aw nc bi"><span id="f05a" class="mh lp iq mz b gy nd ne l nf ng">import Loadable from 'react-loadable';<br/><br/>function ProgressIndicator() {<br/>  return &lt;div&gt;In Progress...&lt;/div&gt;;<br/>}<br/><br/>const LoaderContainerComponent = Loadable({<br/>  loader: () =&gt; import('./loadable-another-component'),<br/>  LoadingComponent: ProgressIndicator<br/>});<br/><br/>class MyComponent extends React.Component {<br/>  render() {<br/>    return &lt;LoaderContainerComponent/&gt;;<br/>  }<br/>}</span></pre><p id="22df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">现在去享受拆分代码的乐趣吧</strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/03d09cf04a943c1f64dd751452af14f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XARxG-uLbFdlAUHz.jpg"/></div></div></figure><p id="2555" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">延伸阅读:</strong></p><div class="ns nt gp gr nu nv"><a href="https://reactjs.org/docs/code-splitting.html#route-based-code-splitting" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">代码分解-反应</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">大多数React应用程序会使用Webpack、Rollup或Browserify等工具“捆绑”文件。捆绑是一个过程…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">reactjs.org</p></div></div><div class="oe l"><div class="of l og oh oi oe oj lh nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://blog.logrocket.com/code-splitting-in-react-an-overview/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">React中的代码拆分:概述</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">尽管JavaScript是一种简单的语言，但它可以生成复杂得惊人的代码库。部分原因是…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">blog.logrocket.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj lh nv"/></div></div></a></div><p id="3a47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nk">更多内容看</em> <a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="nk">说白了。报名参加我们的</em><strong class="kh ir"><em class="nk"/></strong><a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nk">免费周报</em> </strong> </a> <em class="nk">。在我们的</em><strong class="kh ir"><em class="nk"/></strong><a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nk">社区不和谐</em> </strong> </a> <strong class="kh ir"> <em class="nk">获得独家获取写作机会和建议。</em>T45】</strong></strong></a></p></div></div>    
</body>
</html>