<html>
<head>
<title>3 Utility Types In TypeScript You Can’t Live Without</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的3个实用程序类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/usefull-utility-types-in-typescript-5187eb3398e6?source=collection_archive---------12-----------------------#2021-03-14">https://javascript.plainenglish.io/usefull-utility-types-in-typescript-5187eb3398e6?source=collection_archive---------12-----------------------#2021-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="517a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">利用使用类型和静态分析的能力</h2></div><p id="5d60" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">TypeScript就像服用了类固醇的JavaScript。这主要归功于使用类型和静态分析的能力。所以我们来谈谈TypeScript中一些有用的实用工具类型。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/6505966f7b144d937c616dbb676e6c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1VTfGIx5hZ0PJXn3"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@nubelsondev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nubelson Fernandes</a> on <a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="1d17" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">1.部分<t/></h1><p id="e6cb" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated"><strong class="ke io"><em class="mt">Partial&lt;T&gt;</em></strong>是一个实用程序类型，它接受一个给定的类型并返回一个新类型，其中所有属性都是可选的。如果您需要在几个地方使用同一个接口，有些地方需要所有属性都是可选的，而有些地方不需要，那么这是非常有用的。例如，如果您有一个表示表单数据模型的界面，并且您在两个地方使用该表单，在一个地方它有必填字段，而在另一个地方所有字段都是可选的。为了便于阅读，我将使用简化的示例。</p><pre class="kz la lb lc gt mu mv mw mx aw my bi"><span id="59a3" class="mz lx in mv b gy na nb l nc nd">interface FormModel {<br/>  email: string;<br/>  name: string;<br/>  surname: string;<br/>}</span><span id="0a2b" class="mz lx in mv b gy ne nb l nc nd"><br/>class FormWithRequiredFields {<br/>  ...</span><span id="b9b1" class="mz lx in mv b gy ne nb l nc nd">  setFormValue(value: FormModel): void {<br/>    ...<br/>  }</span><span id="01bb" class="mz lx in mv b gy ne nb l nc nd">  ...<br/>}</span><span id="514c" class="mz lx in mv b gy ne nb l nc nd">class FormWithOptionalField {<br/>  ...</span><span id="2569" class="mz lx in mv b gy ne nb l nc nd">  setFormValue(value: Partial&lt;FormModel&gt;): void {<br/>    ...<br/>  }</span><span id="5cf0" class="mz lx in mv b gy ne nb l nc nd">  ...<br/>}</span></pre><p id="98a8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以在第一个类<strong class="ke io"><em class="mt">FormWithRequiredFields</em></strong>方法<strong class="ke io"><em class="mt">【set form value】</em></strong>中我们使用原来的<strong class="ke io"> <em class="mt"> FormModel </em> </strong>接口，其中有<strong class="ke io"><em class="mt"/></strong><strong class="ke io"><em class="mt">姓氏</em> </strong>作为可选属性，<strong class="ke io"> <em class="mt"> email </em> </strong>作为必需属性。对于第二类<strong class="ke io"><em class="mt">FormWithOptionalFields</em></strong>方法<strong class="ke io"> <em class="mt"> setFormValue、</em> </strong>我们使用<strong class="ke io"> <em class="mt"> FormModel </em> </strong>接口连同<strong class="ke io"><em class="mt">Partial&lt;T&gt;</em></strong>实用程序类型使其成为<strong class="ke io"><em class="mt">Partial&lt;form model&gt;</em></strong>。这使得接口<strong class="ke io"> <em class="mt">表单模型</em> </strong>的所有属性都是可选的。</p><p id="538d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="mt">局部&lt; T &gt; </em> </strong>在制作<em class="mt">补丁</em>请求时也非常有用。在这种情况下，我们可以采用原始接口，用于<em class="mt"> GET </em>或<em class="mt"> POST </em>请求，并使其所有属性可选。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="df20" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">2.选择<t/></h1><p id="fb2c" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated"><strong class="ke io"><em class="mt">Pick&lt;T&gt;</em></strong>使我们能够指定给定类型的属性子集，通过声明我们想要的父类型的键。当我们知道我们需要来自父类型的一些键，而不需要其他键时，这可能是有用的。让我们回到我们的表单示例，如果我们有一个包含更多字段的更大的表单和另一个包含来自更大表单的字段子集的更小的表单，我们可以使用<strong class="ke io"><em class="mt">Pick&lt;T&gt;</em></strong>来只将该字段子集放入我们的表单数据模型。</p><pre class="kz la lb lc gt mu mv mw mx aw my bi"><span id="8e01" class="mz lx in mv b gy na nb l nc nd">interface FormModel {<br/>  email: string;<br/>  name: string;<br/>  surname: string;<br/>}</span><span id="b878" class="mz lx in mv b gy ne nb l nc nd">class FormWithAllFields {<br/>  ...</span><span id="0831" class="mz lx in mv b gy ne nb l nc nd">setFormValue(value: FormModel): void {<br/>    ...<br/>  }</span><span id="1fe8" class="mz lx in mv b gy ne nb l nc nd">...<br/>}</span><span id="b9a3" class="mz lx in mv b gy ne nb l nc nd">class FormWithNameAndSurnameFields {<br/>  ...</span><span id="509e" class="mz lx in mv b gy ne nb l nc nd">setFormValue(value: Pick&lt;FormModel, 'name' | 'surname'&gt;): void {<br/>    ...<br/>  }</span><span id="7945" class="mz lx in mv b gy ne nb l nc nd">...<br/>}</span></pre><p id="c663" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以在第一个类<strong class="ke io"><em class="mt">form with all fields</em></strong>method<strong class="ke io"><em class="mt">【set form value】</em></strong>中我们使用了原来的<strong class="ke io"> <em class="mt"> FormMode </em> </strong>接口，其中有一个<strong class="ke io"> <em class="mt">【姓名】</em> </strong>和<strong class="ke io"> <em class="mt"> email </em> </strong>属性。对于第二类<strong class="ke io"><em class="mt">formwithnameandsunamefields</em></strong>方法<strong class="ke io"> <em class="mt"> setFormValue </em> </strong>我们使用<strong class="ke io"> <em class="mt"> FormModel </em> </strong>接口连同<strong class="ke io"><em class="mt">Pick&lt;T&gt;</em></strong>实用程序类型将其制作成<strong class="ke io"> <em class="mt"> Pick &lt; FormModel、【姓名】|&gt;</em></strong>。这使得一个新类型只带有<strong class="ke io"> <em class="mt">名</em> </strong>和<strong class="ke io"> <em class="mt">姓</em> </strong>属性的接口<strong class="ke io"> <em class="mt"> FormModel </em> </strong>。</p><p id="306e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以通过编写<strong class="ke io"> <em class="mt"> Pick &lt; T、&gt; </em> </strong>来获取一个属性，或者通过使用union <strong class="ke io"> <em class="mt"> Pick &lt; T、【prop 1】|【prop 2】|【prop 3】'&gt;</em></strong>来获取多个属性，就像我们在上面的示例中所做的那样。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="113e" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">3.省略<t/></h1><p id="f5dc" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated"><strong class="ke io"> <em class="mt">省略&lt; T &gt; </em> </strong>行为方式与<strong class="ke io"> <em class="mt">挑&lt; T &gt; </em> </strong>相似，但相反。我们提供了不想在新类型中出现的父类型的键。这样，我们可以从示例表单类型中删除一些键。</p><pre class="kz la lb lc gt mu mv mw mx aw my bi"><span id="3193" class="mz lx in mv b gy na nb l nc nd">interface FormModel {<br/>  email: string;<br/>  name: string;<br/>  surname: string;<br/>}</span><span id="c7c4" class="mz lx in mv b gy ne nb l nc nd">class FormWithAllFields {<br/>  ...</span><span id="49cf" class="mz lx in mv b gy ne nb l nc nd">setFormValue(value: FormModel): void {<br/>    ...<br/>  }</span><span id="fda9" class="mz lx in mv b gy ne nb l nc nd">...<br/>}</span><span id="79ef" class="mz lx in mv b gy ne nb l nc nd">class FormWithNameAndSurnameFields {<br/>  ...</span><span id="2cbe" class="mz lx in mv b gy ne nb l nc nd">setFormValue(value: Omit&lt;FormModel, 'email'&gt;): void {<br/>    ...<br/>  }</span><span id="14b4" class="mz lx in mv b gy ne nb l nc nd">...<br/>}</span></pre><p id="e66e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以在第一个类<strong class="ke io"><em class="mt">form with all fields</em></strong>method<strong class="ke io"><em class="mt">set form value、</em> </strong>中我们使用了原来的<strong class="ke io"> <em class="mt"> FormMode </em> </strong>接口，其中有<strong class="ke io"> <em class="mt"> name、</em> </strong>和<strong class="ke io"> <em class="mt"> email </em> </strong>属性。对于第二类<strong class="ke io"><em class="mt">formwithnameandsunamefields</em></strong>方法<strong class="ke io"> <em class="mt"> setFormValue </em> </strong>我们使用<strong class="ke io"> <em class="mt"> FormModel </em> </strong>接口连同<strong class="ke io"> <em class="mt">省略&lt; T &gt; </em> </strong>实用程序类型使其成为<strong class="ke io"> <em class="mt">省略&lt; FormModel、&gt; </em>这使得一个新的类型只有<strong class="ke io"> <em class="mt">名</em> </strong>和<strong class="ke io"> <em class="mt">姓</em> </strong>属性的接口<strong class="ke io"><em class="mt">form model</em></strong>。</strong></p><p id="6da4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义属性名称与使用<strong class="ke io"> <em class="mt"> Pick &lt; T &gt; </em> </strong>相同，您可以通过编写<strong class="ke io"> <em class="mt">省略&lt; T、【prop’&gt;</em></strong>或使用union <strong class="ke io"> <em class="mt"> Pick &lt; T、【prop 1】|【prop 2】|【prop 3】&gt;</em></strong>来获取一个属性或多个属性。</p><p id="b3a0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你只需要从更大的集合中提取几个属性，你应该使用<strong class="ke io"> <em class="mt">选择&lt; T &gt; </em> </strong>，或者如果你需要保留其中的大部分，只移除一部分，你可以反过来省略&lt; T &gt;  。</p><h1 id="1dd4" class="lw lx in bd ly lz nf mb mc md ng mf mg jt nh ju mi jw ni jx mk jz nj ka mm mn bi translated">摘要</h1><p id="6448" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">通过在代码中使用TypeScript实用工具类型，您可以获得更干净、更易于维护的类型。此外，对一个父类型所做的更改将反映在所有继承的父类型中，这些父类型使用实用程序类型。</p><p id="6994" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae lo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">订阅我们的YouTube频道</strong> </a> <strong class="ke io">获取更多类似内容！</strong></p><p id="6b03" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mt">更多内容请看</em><a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>