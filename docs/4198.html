<html>
<head>
<title>Rendering Huge Lists of Data — A Good Case for Client-Side-Rendering?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">呈现巨大的数据列表——客户端呈现的好例子？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/client-side-rendering-list-3b79e596668f?source=collection_archive---------10-----------------------#2021-08-20">https://javascript.plainenglish.io/client-side-rendering-list-3b79e596668f?source=collection_archive---------10-----------------------#2021-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ef3c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">JavaScript实验</h2><div class=""/><div class=""><h2 id="aaad" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">南车能比SSR有优势吗？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a4c5a74c2f34dd8c160bb487ec52b149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbTEF3yDYopRPXa6ta0CDA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Source: the author</figcaption></figure><p id="81c2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">昨天的淋浴想:也许客户端渲染并不是那么糟糕，可以降低我们发送给客户端的千字节数？</p><p id="afc9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> <em class="ma">提示</em> </strong> <em class="ma">，在我们进入之前:这篇文章一般是针对网络渲染的。我会使用React.js，但是你不需要任何使用它的经验，也不需要学习React。</em></p><p id="b9a4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">以下是我的假设背后的理论:</p><p id="1d23" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">客户端渲染意味着我们将JavaScript组件发送到客户端浏览器。在浏览器中，它们被渲染并转化为DOM元素。但最终，浏览器收到的是这样的内容:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="f570" class="mg mh iq mc b gy mi mj l mk ml">function App() {<br/>  return React.createElement("div", { className: "App" }, [<br/>    React.createElement("h1", null, "Hello World!")<br/>  ]);<br/>}</span></pre><p id="9d9a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">而对于服务器端呈现，我们在服务器上执行JavaScript组件，并只传送结果HTML结构。上面的代码会像这样发送到浏览器:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="0330" class="mg mh iq mc b gy mi mj l mk ml">&lt;div class='App'&gt;<br/>  &lt;h1&gt;Hello World!&lt;/h1&gt;<br/>&lt;/div&gt;</span></pre><p id="d04b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这很好。这甚至比发布JavaScript组件更好，因为客户端呈现意味着在呈现DOM之前，需要执行JS。</p><p id="36bc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们进入重点。</p><p id="2786" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">单个JavaScript组件，无论是在Vue、React还是Angular中，都可以生成很多DOM元素。事实上，我们希望/需要多少DOM元素就有多少。这里有一个例子可以更清楚地说明这一点:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="89bb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这个React组件生成<code class="fe mo mp mq mc b">&lt;li&gt;Element&lt;/li&gt;</code> 100次。将这个组件作为JavaScript发布并不重要。然而，在服务器上呈现它并将其转换成100个DOM元素的文字列表肯定会导致巨大的HTTP响应，因为它包含所有元素，而不仅仅是blueprint JS代码。</p><p id="e006" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">理论到此为止。我想测试在这种情况下客户端渲染是否比服务器端渲染有优势。通过发布小的JS蓝图，而不是大量的DOM元素，也许我们的页面会更小。</p><p id="cfbc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了测试这一点，我呈现了相同的React组件，创建了一个巨大的列表——一次在客户端，但也在服务器端。让我们看看会发生什么。</p><h1 id="492a" class="mr mh iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">付诸实践——CSR与SSR的巨大清单</h1><p id="bb76" class="pw-post-body-paragraph le lf iq lg b lh ni ka lj lk nj kd lm ln nk lp lq lr nl lt lu lv nm lx ly lz ij bi translated">这是我实现的组件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9f4a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">它产生的是完全相同的列表元素，但是重复了500次:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/10ab055793d278d5f6cd1e7375599794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXG7d3vRtFrtJ9-f8BRQQQ.png"/></div></div></figure><p id="cc80" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">那么，SSR和CSR实际上在规模上如何比较，渲染这个列表？</p><p id="2ad8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">结果证明我的论文是正确的——嗯，部分是正确的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi no"><img src="../Images/34829e62252afdcc01e94ceb357cafb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*kgVKArrxKCyYUmoXs1dSYg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Server-side-rendering</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d961b223f78420d08ec5bc1514978ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*h6KcaneTLb-8bR98LaZRWA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Client-side-rendering</figcaption></figure><p id="c8e6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们所看到的非常迷人。</p><p id="7e88" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">页面本身的大小差异很大，实际上超过60千字节。这对我来说并不意外。在CSR案例中，我们只发布了组件蓝图，而在SSR案例中，我们发布了500个元素的列表。<br/>那么，客户端大小渲染的要点是什么？不，没那么容易。</p><p id="4de3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们应该把重点放在上面图片中的“转让”价值上。</p><p id="cceb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该值表示通过网络实际传输的千字节数。正如我们所见，两页几乎相同。</p><h2 id="f08a" class="mg mh iq bd ms np nq dn mw nr ns dp na ln nt nu nc lr nv nw ne lv nx ny ng iw bi translated">压力支撑着我们。</h2><p id="635d" class="pw-post-body-paragraph le lf iq lg b lh ni ka lj lk nj kd lm ln nk lp lq lr nl lt lu lv nm lx ly lz ij bi translated">我们可以在SSR案例中最好地看到这一点，network选项卡中的<em class="ma"> localhost </em>元素表示我们收到的HTML结构:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/259eaac5f96f1de399524c2386f3f3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIZ8rNEmY9cSpVVc3SIlMw.png"/></div></div></figure><p id="cd2e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Next.js默认使用gzip压缩接收到的代码。只有2.1千字节通过网络传输。但事实上，由于我们得到了500个列表元素，所以未压缩文件的大小为67.7千字节。</p><p id="b4a7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如您所见，压缩在这里做得很好。一会儿我们会努力让它更难压缩。</p><p id="0c41" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">但是渲染性能呢？</strong></p><p id="516b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">下面是服务器端渲染的灯塔报告:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/00e7ce65e9fba00795b79eef90aed6ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIdNCL4pgncliNl2s0iLvQ.png"/></div></div></figure><p id="14dc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">以下是客户端渲染的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/ec94cefafe4898a0233774fb6967a71a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDTuI1N6FQrKppsjMHCVWQ.png"/></div></div></figure><p id="ee8a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">正如你所看到的，当使用客户端渲染时，第一次内容丰富的绘制实际上更好。</p><p id="3424" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这并不奇怪，因为<code class="fe mo mp mq mc b">&lt;h1&gt;Huge list:&lt;/h1&gt;</code>是一个独立的组件，在计算大列表之前呈现。因此在CSR版本中，它安装在前面，构成了我们的FCP。</p><p id="c2d3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">另一方面，我们看到浏览器中巨大的渲染工作量，使得最大的内容丰富的绘画花费更多的时间。</p><p id="5723" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">CSR的结果没有那么令人信服，因为这是一个相当不现实的例子，生成了2500多个DOM元素。在我看来，这不是CSR的一个要点。</p><h2 id="bc7b" class="mg mh iq bd ms np nq dn mw nr ns dp na ln nt nu nc lr nv nw ne lv nx ny ng iw bi translated">但是如果这个例子太容易压缩了呢？</h2><p id="ed72" class="pw-post-body-paragraph le lf iq lg b lh ni ka lj lk nj kd lm ln nk lp lq lr nl lt lu lv nm lx ly lz ij bi translated">如果你已经考虑过这个问题，你说得很有道理！在我们看到压缩之前的几行代码做了一件不可思议的工作，使我们庞大的服务器端渲染列表保持较小的大小。</p><p id="34a6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是因为我们生成的列表非常易于压缩。压缩引擎只能压缩相似的内容—我们创建的元素列表有80%是相同的。只有随机生成的数字不同。</p><p id="71a7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有时候，对于一个庞大的列表来说，这可能是一个现实的例子。有时，在现实中，我们会遇到一些更随机的情况，因此，我也创造了以下场景:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/3e2eb382e655a9c6285f6dc3170d50e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mvhJZEHUdO2MkEDKL01qw.png"/></div></div></figure><p id="6003" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我加入了更多随机生成的数字——是的，在这种情况下，压缩工作，事实上，没那么好。</p><p id="eaef" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">突然之间，包含该结构的页面压缩后的大小为27.8千字节。这是以前的10倍多。然而，绝对来说，在一个已经不切实际的应用程序中增加25千字节并不算多——这也体现在灯塔的结果中。</p><p id="d166" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">对于第一次内容丰富的绘制，服务器端渲染的结果增长了0.2秒——这也不算多。客户端渲染版本的结果保持不变。遗憾的是，对于客户端渲染来说，这仍然不是一个真正的好处。</p><h2 id="6449" class="mg mh iq bd ms np nq dn mw nr ns dp na ln nt nu nc lr nv nw ne lv nx ny ng iw bi translated">为什么要进行服务器端渲染？</h2><p id="bfa2" class="pw-post-body-paragraph le lf iq lg b lh ni ka lj lk nj kd lm ln nk lp lq lr nl lt lu lv nm lx ly lz ij bi translated">到目前为止，我们在服务器端和客户端渲染之间进行了一场艰苦的战斗。目前，我想这是一个相当大的平局。即使我的减小尺寸的论点是正确的，当使用CSR时，这并没有表现为真正的好处。压缩完成了它的任务。</p><p id="9454" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，这种比较甚至没有那么复杂。</p><p id="c51c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因为客户端呈现的版本不会从某个地方获取列表数据，它会随机生成列表数据。这是一个奇怪的用例。如果包含动态数据，我们通常从数据源获取它。在客户端渲染中，这需要一些代码来获取数据，并且明显增加了渲染时间。然而，我们把这些额外的负担留给了客户端渲染版本。</p><p id="393c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因为数据是随机生成的，所以不需要通过每个请求在服务器上运行计算。另一方面，在这种情况下，使用活动的服务器端呈现是多余的。更好的情况是将页面呈现一次，然后将其作为静态站点托管。</p><p id="9e65" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了公平起见，我还将这个巨大的随机列表作为静态页面运行。令我惊讶的是，它提供了与服务器端渲染完全相同的性能——这并不是真正的优势。</p><p id="8226" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">好了，我们终于告一段落，稍微总结一下。</p><h1 id="fc81" class="mr mh iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">在这种情况下，我们可以做得更好</h1><p id="47b6" class="pw-post-body-paragraph le lf iq lg b lh ni ka lj lk nj kd lm ln nk lp lq lr nl lt lu lv nm lx ly lz ij bi translated">我们刚刚了解到，客户端渲染并不比服务器端渲染有真正的优势，即使是在处理不切实际的大量数据时也是如此。</p><p id="20eb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">原因是压缩，CSR需要在客户端进行大量渲染。尤其是在低端设备上，这可能会导致问题。</p><p id="fc5c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我默默地希望中国南车在这方面有优势。然而，事实并非如此——即使如此，也有更好的方法来正确处理庞大的列表。</p><p id="39e0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了避免大量的初始加载和渲染，虚拟化列表和延迟加载可能是更好的方法。虚拟化列表可以帮助我们，只呈现对用户可见的内容。延迟加载会有所帮助，在必要时加载数据/列表组件。</p><p id="f2a9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">总的来说，有更好的方法来应对这一点，甚至可以与服务器端渲染相结合。然而，我发现这个实验非常令人兴奋。</p><p id="2a23" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我希望你也喜欢它——谢谢你的阅读！</p><p id="e77f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">下面是我如何在客户端和服务器端渲染同一个组件:</p><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/next-js-client-side-rendering-56a3cae65148"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ja gy z fp ok fr fs ol fu fw iz bi translated">如何在Next.js中客户端呈现组件</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">以及为什么这真的有用</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oo l"><div class="op l oq or os oo ot ky of"/></div></div></a></div><p id="cd51" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">更多内容看</em><a class="ae ou" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja"><em class="ma">plain English . io</em></strong></a></p></div></div>    
</body>
</html>