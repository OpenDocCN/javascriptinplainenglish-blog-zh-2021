<html>
<head>
<title>LeetCode Algorithm Challenge: Symmetric Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法挑战:对称树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-challenge-symmetric-tree-b5b5183ed1d8?source=collection_archive---------5-----------------------#2021-07-03">https://javascript.plainenglish.io/leetcode-algorithm-challenge-symmetric-tree-b5b5183ed1d8?source=collection_archive---------5-----------------------#2021-07-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="74b5" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题</h1><p id="8a78" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">给定一棵二叉树的<code class="fe lg lh li lj b">root</code>，<em class="lk">检查它是否是自身</em>的镜像(即围绕其中心对称)。</p><p id="2668" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><strong class="kk io">例1: </strong></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/4aae900c20840ce4811885e8b8406d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*YQhy378gS4fE6VBy.jpg"/></div></figure><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="2e2f" class="mc jl in lj b gy md me l mf mg"><strong class="lj io">Input:</strong> root = [1,2,2,3,4,4,3]<br/><strong class="lj io">Output:</strong> true</span></pre><p id="b243" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><strong class="kk io">例2: </strong></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/5e6238bcd46ed82e7414ef98fcee4310.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*cd20bgfxlemGnRiI.jpg"/></div></figure><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="c351" class="mc jl in lj b gy md me l mf mg"><strong class="lj io">Input:</strong> root = [1,2,2,null,3,null,3]<br/><strong class="lj io">Output:</strong> false</span></pre></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h2 id="f23e" class="mc jl in bd jm mp mq dn jq mr ms dp ju kt mt mu jy kx mv mw kc lb mx my kg mz bi translated">什么是对称树？</h2><p id="365b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果左右子树是彼此相同的镜像，则认为树是对称的。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/2ce40ef5f205a41f35820188ec333701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0-ezMqdb7bPhTcFYHgmGg.png"/></div></div></figure><p id="ec8f" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">正如你从上图中看到的，镜像并不等同于你原本认为的相等，因为在这种情况下是<code class="fe lg lh li lj b">root.val===root.val</code>而是<code class="fe lg lh li lj b">root.left===root.right</code>，反之亦然。这是我们编写代码时的主要支点。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h2 id="b6cf" class="mc jl in bd jm mp mq dn jq mr ms dp ju kt mt mu jy kx mv mw kc lb mx my kg mz bi translated">方法</h2><p id="8175" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在这种情况下，我们将使用递归函数遍历树，检查每个子树。姑且称之为对称。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="c841" class="mc jl in lj b gy md me l mf mg">function symmetric(treeLeft, treeRight) {</span><span id="2eb9" class="mc jl in lj b gy nf me l mf mg">....</span><span id="2fd9" class="mc jl in lj b gy nf me l mf mg">}</span></pre><p id="94d9" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">首先，当一个或两个子树都为空时，检查边缘情况会很好。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="9d0e" class="mc jl in lj b gy md me l mf mg">if(treeLeft===null &amp;&amp; treeRight===null) {return true};</span></pre><p id="512a" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">如果两个子树相等，我们将返回true。但如果只有一个等于null，结果将为false。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="3d9c" class="mc jl in lj b gy md me l mf mg">if(treeLeft===null || treeRight===null) {return false};</span></pre><p id="84b7" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">现在我们到了需要评估子树的步骤，子树由<code class="fe lg lh li lj b">tree.val</code>、<code class="fe lg lh li lj b">tree.left</code>和<code class="fe lg lh li lj b">tree.right</code>组成。所以我们将检查每一个条件并返回结果。</p><p id="baae" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">对于<code class="fe lg lh li lj b">.val</code>,我们将检查两个值是否相同，然后我们将需要使用<code class="fe lg lh li lj b">.left</code>和<code class="fe lg lh li lj b">.right</code>作为我们对称函数的参数，记住<code class="fe lg lh li lj b">treeLeft.right</code>将与<code class="fe lg lh li lj b">treeRight.left</code>进行比较，反之亦然。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="3c80" class="mc jl in lj b gy md me l mf mg">return (treeLeft.val===treeRight.val) &amp;&amp; symmetric(treeLeft.right,treeRight.left) &amp;&amp; symmetric(treeLeft.left,treeRight.right)</span></pre><p id="6978" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">一旦我们完成了递归函数，我们现在可以两次都使用参数根调用它，让函数完成它的工作。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="31a4" class="mc jl in lj b gy md me l mf mg">return symmetric(root,root)</span></pre></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h2 id="0315" class="mc jl in bd jm mp mq dn jq mr ms dp ju kt mt mu jy kx mv mw kc lb mx my kg mz bi translated">密码</h2><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="2d5a" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><em class="lk">请在以下社交网络上查看我，我希望收到您的来信！——</em><a class="ae ni" href="https://www.linkedin.com/in/nick-solonyy/" rel="noopener ugc nofollow" target="_blank"><em class="lk">LinkedIn</em></a><em class="lk">，</em> <a class="ae ni" href="https://github.com/nicksolony" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> GitHub </em> </a>，<a class="ae ni" href="https://www.facebook.com/nick.solony" rel="noopener ugc nofollow" target="_blank"> <em class="lk">脸书</em> </a> <em class="lk">。</em></p><p id="44f0" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><em class="lk">更多内容请看</em><a class="ae ni" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="lk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>