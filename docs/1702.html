<html>
<head>
<title>What’s New in ES2021?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2021有什么新功能？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-new-in-es2021-350c80a74723?source=collection_archive---------10-----------------------#2021-04-11">https://javascript.plainenglish.io/whats-new-in-es2021-350c80a74723?source=collection_archive---------10-----------------------#2021-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d387b9e112854b4e4493a308db6f5d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pp6HolIf5MxS4c9w"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@judebeck?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jude Beck</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="60fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES2021是截至2021年的EcmaScript规范的最新版本。</p><p id="c21d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它拥有JavaScript的最新特性，这些特性被添加到各种运行时环境中，如浏览器和Node.js。</p><p id="4bb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2021的新特性。</p><h1 id="79c5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">字符串.原型. replaceAll</h1><p id="b985" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">string实例的<code class="fe me mf mg mh b">replaceAll</code>方法是一个新方法，它允许我们替换字符串中子串的所有实例。</p><p id="b009" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2ddb" class="mq lc iq mh b gy mr ms l mt mu">const newStr = 'foo bar foo bar'.replaceAll('foo', 'baz')<br/>console.log(newStr)</span></pre><p id="49c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">newStr</code>就是<code class="fe me mf mg mh b">'baz bar baz bar’</code>。</p><p id="c077" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用第二个参数中的字符串替换作为第一个参数传入的字符串的所有实例。</p><h1 id="a790" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">WeakRef</h1><p id="2de2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakRef</code>是一个构造函数，它让我们创建对象，让我们手动清理传递给它的任何东西。</p><p id="f9e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a8aa" class="mq lc iq mh b gy mr ms l mt mu">const obj = new WeakRef({<br/>   foo: "bar"<br/> });<br/> console.log(obj.deref().foo);</span></pre><p id="e7f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过传递一个对象来创建一个<code class="fe me mf mg mh b">WeakRef</code>实例。</p><p id="ab40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数返回一个与我们传入的内容相同的对象。</p><p id="0eaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但它也继承了让我们手动从内存中移除引用<code class="fe me mf mg mh b">obj</code>的<code class="fe me mf mg mh b">deref</code>方法。</p><p id="c72b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">deref</code>返回<code class="fe me mf mg mh b">obj</code>的原始内容。</p><p id="fcc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe me mf mg mh b">console.log</code>会记录<code class="fe me mf mg mh b">'bar'</code>。</p><h1 id="431a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">终结器</h1><p id="d13c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">终结器让我们注册在对象被垃圾回收后运行的回调。</p><p id="15d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a622" class="mq lc iq mh b gy mr ms l mt mu">const registry = new FinalizationRegistry((value) =&gt; {<br/>  console.log(value);<br/>});</span><span id="e99a" class="mq lc iq mh b gy mv ms l mt mu">(() =&gt; {<br/>  const obj = {}<br/>  registry.register(obj, "bar");<br/>})()</span></pre><p id="e1dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用带有回调的<code class="fe me mf mg mh b">FinalizationRegistry</code>创建了<code class="fe me mf mg mh b">registry</code>，当传入<code class="fe me mf mg mh b">registry.register</code>的对象被垃圾回收时调用该回调。</p><p id="4860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们运行创建<code class="fe me mf mg mh b">obj</code>的函数，并通过第二个参数中的值将其传递给<code class="fe me mf mg mh b">registry.register</code>。</p><p id="1782" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该值将是回调中<code class="fe me mf mg mh b">value</code>的值。</p><p id="b9ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该看到在<code class="fe me mf mg mh b">obj</code>上完成垃圾收集后记录的<code class="fe me mf mg mh b">'bar'</code>。</p><h1 id="cdbe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Promise.any()</h1><p id="47f7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.any</code>返回一个承诺，如果任何提供的承诺得到解决，则该承诺得到解决。</p><p id="0736" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0091" class="mq lc iq mh b gy mr ms l mt mu">(async () =&gt; {<br/>  const result = await Promise.any([<br/>    Promise.resolve(1),<br/>    Promise.reject('error'),<br/>    Promise.resolve(2)<br/>  ]);<br/>  console.log(result);<br/>})();</span></pre><p id="f12d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将一系列承诺传递给<code class="fe me mf mg mh b">Promise.any</code>。</p><p id="bee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于第一个承诺解析为一个值，<code class="fe me mf mg mh b">Promise.any</code>将返回一个解析为1的承诺。</p><p id="6062" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe me mf mg mh b">result</code>将因此为1。</p><p id="2227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有一个承诺被解决，则产生一个<code class="fe me mf mg mh b">AggregateError</code>。</p><p id="67d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有这样的东西:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b64f" class="mq lc iq mh b gy mr ms l mt mu">(async () =&gt; {<br/>  try {<br/>    const result = await Promise.any([<br/>      Promise.reject('error1'),<br/>      Promise.reject('error2'),<br/>      Promise.reject('error3'),<br/>    ]);<br/>    console.log(result);<br/>  } catch (error) {<br/>    console.log(error)<br/>  }<br/>})();</span></pre><p id="5417" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">error</code>就是<code class="fe me mf mg mh b">'AggregateError: All promises were rejected’</code>。</p><h1 id="9854" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">逻辑赋值运算符</h1><p id="25a2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">借助ES2021，我们可以将布尔运算符<code class="fe me mf mg mh b">&amp;&amp;</code>、<code class="fe me mf mg mh b">||</code>与<code class="fe me mf mg mh b">=</code>运算符结合起来，用新变量对现有变量进行布尔运算，并将其分配给现有变量。</p><p id="3caa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ba57" class="mq lc iq mh b gy mr ms l mt mu">let x = true;<br/>const y = false;<br/>x &amp;&amp;= y;<br/>console.log(x)</span></pre><p id="52a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">x</code>就是<code class="fe me mf mg mh b">false</code>，因为<code class="fe me mf mg mh b">x &amp;&amp;= y</code>与<code class="fe me mf mg mh b">x = x &amp;&amp; y</code>相同。</p><p id="e57a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">||=</code>操作符对<code class="fe me mf mg mh b">||</code>做同样的事情。</p><h1 id="acc1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数字分隔符</h1><p id="9304" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">_</code>数字分隔符现在是ES2021中的标准。</p><p id="c601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">_</code>来分隔长数字的数字组。</p><p id="58e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写<code class="fe me mf mg mh b">1_000_000</code>来写一百万。</p><h1 id="aa4a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4ac7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES2021附带了许多有用的新功能。</p><p id="9ffa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>