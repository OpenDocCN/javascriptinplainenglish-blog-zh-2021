<html>
<head>
<title>Referential Transparency in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的引用透明性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/referential-transparency-in-javascript-48d056eb89b0?source=collection_archive---------8-----------------------#2021-10-07">https://javascript.plainenglish.io/referential-transparency-in-javascript-48d056eb89b0?source=collection_archive---------8-----------------------#2021-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e61059fe11f99e6d4e9e334698493e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kOxoySpL-j0tHdeq"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8f8c" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="c6b3" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在JavaScript中，函数式编程是一种我们创建函数的模型。也就是说，仅仅依靠它输入来完成它的逻辑。这证实了一个函数在被多次调用时，能够成功地返回相似的结果。该函数同样不会改变外部世界的任何数据，这对可缓存和可测试的代码库很重要。</p><p id="60a6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">由于所有函数都为相同的输入返回相似的值，因此函数的这一属性被称为引用透明性。在本帖中，我们将详细讨论引用透明性。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/9465afd8554aef9fb3c20d706da8e42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/0*Es79Hq3YsR_N_bU_.jpg"/></div></figure><h1 id="1586" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">描述</h1><p id="67e7" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">引用透明性用于许多领域，例如数学、逻辑、语言学、哲学和编程。在这些领域中，它的含义都发生了很大的变化。</p><p id="7fef" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在数学中，指称透明是表达式的内容。可以用其他的表达来代替。那些有着相似价值观的人无法以任何方式改变结果。</p><p id="3755" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">编程中的引用透明性与程序有关。程序是由子程序组成的，而子程序本身就是程序。它也与那些子程序相关。子程序可以用方法来表示。</p><p id="ffcc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">为了更好地理解，参照透明度见下面的例子。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1bfd" class="ml kb in mh b gy mm mn l mo mp">var identity = (i) =&gt; { return i }</span></pre><ul class=""><li id="1e0b" class="mq mr in la b lb lw lf lx lj ms ln mt lr mu lv mv mw mx my bi translated">我们在上面的代码片段中定义了一个名为identity的简单函数。</li><li id="8baa" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">这个函数返回我们作为它输入传递的任何东西。</li><li id="c161" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">也就是说，如果我们传递10，它将返回值10。</li><li id="9911" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">因为功能仅仅是充当镜子和身份。</li><li id="39bb" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">我们的函数只对传入的参数“I”起作用。</li><li id="47a7" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">我们的函数中没有全局引用。</li></ul><h1 id="88cf" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">替代模型</h1><ul class=""><li id="82da" class="mq mr in la b lb lc lf lg lj ne ln nf lr ng lv mv mw mx my bi translated">目前，该函数用于其他函数调用之间，如下所示:</li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8335" class="ml kb in mh b gy mm mn l mo mp">sum(4,5) + identity(1)</span></pre><ul class=""><li id="f110" class="mq mr in la b lb lw lf lx lj ms ln mt lr mu lv mv mw mx my bi translated">通过我们的参照透明性定义，我们可以把上面的陈述变成这样:</li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="715b" class="ml kb in mh b gy mm mn l mo mp">sum(4,5) + 1</span></pre><ul class=""><li id="44ff" class="mq mr in la b lb lw lf lx lj ms ln mt lr mu lv mv mw mx my bi translated">这时这个过程叫做替代模型。</li><li id="2c6a" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">通过，我们可以直接用它的值代替函数的结果。</li><li id="e15a" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">一般来说，由于函数的逻辑不依赖于其他全局变量。</li><li id="bfe2" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">这导致了等同的代码和缓存。</li><li id="599b" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">我们可以轻松地运行上面的函数，几个线程甚至不需要同步。</li><li id="d757" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">同步的动机来自于线程在等价运行时不应该处理全局数据的细节。</li><li id="a80c" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated"><a class="ae jz" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank">遵循参照透明性的函数</a>只依赖于其参数的输入。</li><li id="3716" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">因此，线程可以在没有任何锁定机制的情况下运行。</li><li id="e9e1" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">同时，对于给定的输入，该函数返回相同的值。</li><li id="3292" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">我们实际上可能会缓存它。例如，有一个叫做阶乘的函数。</li><li id="cc3f" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">计算给定数字的阶乘。</li><li id="56a0" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">Factorial将输入作为需要计算阶乘的参数。</li><li id="8e78" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">我们都知道5的阶乘是120。</li><li id="84e3" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">如果用户第二次调用5的阶乘会怎样？</li><li id="beb2" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">我们看到，如果阶乘函数像以前一样遵循引用透明性，结果将是120。</li><li id="0847" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">它只取决于输入参数。</li><li id="8a6d" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">我们可以通过记住这些字符来缓存阶乘函数的值。</li><li id="3acd" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">因此，如果第二次调用阶乘，输入为“5”，我们可以返回缓存的值，而不是再次计算。</li></ul><p id="2c9d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="nh">欲了解更多详情，请访问:</em></p><p id="8568" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><a class="ae jz" href="https://www.technologiesinindustry4.com/2021/10/referential-transparency-in-javascript.html" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://www . technologiesinindustry 4 . com/2021/10/referential-transparency-in-JavaScript . html</em></a></p><p id="8048" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="nh">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>