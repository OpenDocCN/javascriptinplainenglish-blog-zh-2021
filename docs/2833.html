<html>
<head>
<title>A Guide to Setting Up Unit Tests in Jasmine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jasmine中设置单元测试的指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-guide-to-setting-up-unit-tests-in-jasmine-8a5e2896a09e?source=collection_archive---------11-----------------------#2021-06-09">https://javascript.plainenglish.io/a-guide-to-setting-up-unit-tests-in-jasmine-8a5e2896a09e?source=collection_archive---------11-----------------------#2021-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="08f6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解在Jasmine中为Angular应用程序编写单元测试时，如何设置和创建一个可重用的测试平台。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a00b3cc91c9cea219889bf29f9a6f6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*op9jtLc9wm4oMX4gi8DNDg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">cottonbro</strong></a> from <a class="ae ks" href="https://www.pexels.com/photo/person-using-macbook-pro-beside-white-ceramic-mug-5052875/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">Pexels</strong></a></figcaption></figure><p id="41ee" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在本文中，我将向您展示如何创建一个可重用的测试床来设置您的单元测试，并在您的spec文件中重用它们。</p><p id="e866" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们将讨论以下内容:</p><blockquote class="lq lr ls"><p id="9afb" class="ku kv lt kw b kx ky jo kz la lb jr lc lu le lf lg lv li lj lk lw lm ln lo lp ig bi translated">什么是测试平台，什么是模拟？我们如何建立一个可重用的测试平台？如何创建模拟组件？如何创建模拟服务？你如何在单元测试中设置你的应用程序路径？如何建立一个测试组件的规格文件？如何为测试服务建立一个规范文件？在编写单元测试之前，我必须模仿所有的东西吗？</p></blockquote><h2 id="36a3" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">内容</h2><ol class=""><li id="8849" class="mq mr in kw b kx ms la mt ld mu lh mv ll mw lp mx my mz na bi translated"><a class="ae ks" href="#887a" rel="noopener ugc nofollow"> <strong class="kw io">创建可重用的测试床</strong> </a></li><li id="13ca" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae ks" href="#3f4d" rel="noopener ugc nofollow"> <strong class="kw io">声明:嘲讽成分</strong> </a></li><li id="0bcf" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae ks" href="#9105" rel="noopener ugc nofollow"> <strong class="kw io">提供者:嘲讽服务</strong> </a></li><li id="402a" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae ks" href="#7a3a" rel="noopener ugc nofollow"> <strong class="kw io">导入:模仿内置服务</strong> </a></li><li id="a3c2" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae ks" href="#766b" rel="noopener ugc nofollow"> <strong class="kw io">设置您的单元测试路线</strong> </a></li><li id="862c" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae ks" href="#0deb" rel="noopener ugc nofollow"> <strong class="kw io">为组件单元测试建立你的规格文件</strong> </a></li><li id="90f7" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae ks" href="#7f77" rel="noopener ugc nofollow"> <strong class="kw io">为服务单元测试设置您的规格文件</strong> </a></li><li id="023d" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated">在编写单元测试之前，我必须嘲笑一切吗？ </li></ol><h2 id="887a" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">1.创建可重用的测试床</h2><p id="af12" class="pw-post-body-paragraph ku kv in kw b kx ms jo kz la mt jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">我们首先需要创建和设置我们的测试床，这是我们设置和定义测试环境的地方，包括我们单元测试需要的一切。我们定义了我们当前正在测试的组件或服务，我们希望在测试中使用的其他组件和服务，以及运行测试可能需要的任何其他东西。</p><p id="0077" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">默认情况下，你的应用程序的所有组件都被自动添加到测试床上，这对于集成测试来说是可以的，但是我们不希望在编写单元测试时这样做。我们只想要我们目前正在进行单元测试的组件，并希望用不做任何事情的空版本替换所有其他组件。我们称这些空组件为模拟组件。</p><p id="fa13" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这确保了我们的组件是隔离的，没有其他东西会影响我们正在测试的组件，唯一的变量是我们的组件。我们必须模仿我们的组件和服务。</p><p id="02f1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">测试平台有三个主要部分。声明部分、提供者部分和导入部分。</p><ul class=""><li id="b8a0" class="mq mr in kw b kx ky la lb ld nj lh nk ll nl lp nm my mz na bi translated">在声明部分，我们定义正在测试的组件，并用模拟组件替换应用程序中的所有其他组件。</li><li id="8438" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp nm my mz na bi translated">在Providers部分，我们定义了正在测试的服务，并用模拟服务替换应用程序中的所有其他服务。</li><li id="e5fc" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp nm my mz na bi translated">在Imports部分，我们用正式的测试版本替换了内置的服务，还包含了运行测试所需的任何其他angular模块。</li></ul><p id="e9fe" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在接下来的小节中，我们将更详细地讨论如何创建这些模拟组件和服务。</p><p id="6e23" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">由于每个单元测试之间唯一不同的是我们当前正在测试的组件或服务，我们可以创建一个可重用的测试床，在那里模拟一切，然后将其导入并复制到我们的spec文件中。然后，我们可以用真实的版本替换当前测试组件的模拟版本。这使我们不必每次都重新创建测试平台。</p><p id="cc4b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">下面是一个测试床的例子，所有的东西都被模拟了，可以导入到每个规格文件中并重复使用。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0677" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">要使用它，我们可以将<code class="fe np nq nr ns b"><strong class="kw io">configureTestingModule()</strong></code>导入到我们的spec文件中，然后我们可以将正在进行单元测试的当前组件添加到声明部分，它将覆盖并替换模拟版本。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8fe8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在这个例子中，我们在测试床中覆盖了<code class="fe np nq nr ns b"><strong class="kw io">AppComponent</strong></code>模拟，并用真正的<code class="fe np nq nr ns b"><strong class="kw io">AppComponent</strong></code> <strong class="kw io">替换它。</strong></p><h2 id="3f4d" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated"><strong class="ak"> 2。声明:模仿组件</strong></h2><p id="b307" class="pw-post-body-paragraph ku kv in kw b kx ms jo kz la mt jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">为了创建一个模拟组件，我们可以删除所有的类型脚本代码和HTML模板代码，除了输入和输出的定义以及任何HTML模板占位符，如<router-outlet>和<ng-content>。通过保留输入、输出和占位符，它仍然可以在我们测试的其他组件中用作子组件，而不会导致错误。它对这些数据没有任何作用。</ng-content></router-outlet></p><p id="9154" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">下面是一个<code class="fe np nq nr ns b"><strong class="kw io">FirstComponent</strong></code>的示例模拟版本。我们创建一个新组件，它必须具有与原始组件完全相同的选择器和名称，以便测试床知道替换这个组件。我们定义输入和输出，但不调用任何函数或对它们做任何其他事情。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5d15" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果它没有任何输入或输出，那么我们让组件完全为空。然后，我们只需将这个模拟<code class="fe np nq nr ns b"><strong class="kw io">FirstComponent</strong></code> <strong class="kw io"> </strong>添加到测试平台的声明部分。</p><h2 id="9105" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated"><strong class="ak"> 3。提供商:模仿服务</strong></h2><p id="1ee1" class="pw-post-body-paragraph ku kv in kw b kx ms jo kz la mt jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">我们还需要用简单的模拟版本替换我们的服务。但是我们不能在这里使用空的服务，我们需要定义服务中的函数，这样当我们运行单元测试时，组件仍然可以调用这些函数。</p><p id="bcf3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是，我们没有使用真正的函数，而是确保每个函数总是返回相同的值，以确保服务是恒定的，并且不会影响单元测试。如果我们确实想改变服务函数返回的内容，那么我们可以使用<code class="fe np nq nr ns b"><strong class="kw io">returnValue()</strong></code>在单元测试本身中暂时这样做。</p><p id="cb9c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">下面是一个名为<code class="fe np nq nr ns b"><strong class="kw io">FirstService</strong></code>的服务的模拟服务示例。我们创建一个新的服务，它的名称与我们想要替换的服务不同，并修复这些函数返回的值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="88d5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">然后在测试平台的Providers部分，我们声明我们想要用<code class="fe np nq nr ns b"><strong class="kw io">FirstServiceMock</strong></code> <strong class="kw io">替换<code class="fe np nq nr ns b"><strong class="kw io">FirstService</strong></code> <strong class="kw io"> </strong>。</strong></p><h2 id="7a3a" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated"><strong class="ak"> 4。导入:模仿内置服务</strong></h2><p id="c88a" class="pw-post-body-paragraph ku kv in kw b kx ms jo kz la mt jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">我们的应用程序中还使用了其他重要的服务，我们也需要用简单的测试版本来模拟和替换它们。幸运的是，这些服务中的大多数都有官方测试版本，包含在同一个库中。</p><p id="1669" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在测试平台的Imports部分，我们用正式的测试版本替换了其中的一些关键服务。</p><ul class=""><li id="a479" class="mq mr in kw b kx ky la lb ld nj lh nk ll nl lp nm my mz na bi translated"><strong class="kw io">HTTPClientTestingModule:</strong>这将使用测试版本替换HTTPClient服务。</li><li id="3dc7" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp nm my mz na bi translated"><strong class="kw io"> RouterTestingModule: </strong>这用测试版本替换了路由，并允许我们为我们的单元测试设置路由。在这里，我们可以只包括我们的正常应用程序路线，以便我们可以测试它们是否正常工作。</li><li id="9d3e" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp nm my mz na bi translated"><strong class="kw io">BrowserAnimationsModule:</strong>这是您的应用程序正常运行所必需的。当你的HTML模板的样式改变时，它会给你的应用添加漂亮的动画。</li><li id="e887" class="mq mr in kw b kx nb la nc ld nd lh ne ll nf lp nm my mz na bi translated"><strong class="kw io"> SharedModule: </strong>您还应该添加应用程序中使用的所有第三方模块。在这里，我们将它们全部放入一个名为SharedModule的模块中，并将其导入到我们的测试床中。</li></ul><h2 id="766b" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">5.设置您的单元测试路线</h2><p id="556b" class="pw-post-body-paragraph ku kv in kw b kx ms jo kz la mt jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">您还需要将应用程序中使用的所有相同路线添加到测试平台中，以便测试应用程序的导航功能是否正常。当您将<code class="fe np nq nr ns b"><strong class="kw io">RouterTestingModule </strong></code>添加到测试平台的导入部分时，您可以添加它们。假设您有一些名为<code class="fe np nq nr ns b"><strong class="kw io">routes</strong></code>的路线，那么您可以像这样添加它们</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="0deb" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">6.为组件单元测试设置规格文件</h2><p id="30eb" class="pw-post-body-paragraph ku kv in kw b kx ms jo kz la mt jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">在这一节中，我将向您展示如何设置您的spec文件，以便您可以为名为<code class="fe np nq nr ns b"><strong class="kw io">FirstComponent</strong></code>的组件编写单元测试。我们要做的第一件事是将模拟的<code class="fe np nq nr ns b"><strong class="kw io">FirstComponent</strong></code>添加到测试平台的声明部分，用真实版本的<code class="fe np nq nr ns b"><strong class="kw io">FirstComponent </strong></code>替换它。在每个单元测试运行之前，我们通过将它放在一个<code class="fe np nq nr ns b"><strong class="kw io">beforeEach()</strong></code>块中来实现这一点。</p><p id="94dc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">然后，我们使用测试床创建组件，并将其保存到一个名为<code class="fe np nq nr ns b"><strong class="kw io">component</strong></code>的变量中，然后使用<code class="fe np nq nr ns b"><strong class="kw io">fixture.detectChanges()</strong></code>更新UI。然后，您可以访问该组件上的任何公共字段和方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="7f77" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">7.为服务单元测试设置规格文件</h2><p id="cec7" class="pw-post-body-paragraph ku kv in kw b kx ms jo kz la mt jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">在这一节中，我将向您展示如何设置您的spec文件，以便您可以为名为<code class="fe np nq nr ns b"><strong class="kw io">FirstService</strong></code>的服务编写单元测试。我们设置它的方式与我们为一个组件编写单元测试时略有不同。我们首先必须将我们的模拟<code class="fe np nq nr ns b"><strong class="kw io">FirstService</strong></code>添加到测试平台的providers部分，用我们的真实<code class="fe np nq nr ns b"><strong class="kw io">FirstService</strong></code>替换它。我们确保在每个单元测试运行之前这样做，将它放在一个<code class="fe np nq nr ns b"><strong class="kw io">beforeEach()</strong></code>块中。</p><p id="2aaf" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们使用<code class="fe np nq nr ns b"><strong class="kw io">TestBed.inject()</strong></code>在测试床中获取对服务的引用，然后我们可以访问这个服务的公共字段和方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="7e94" class="lx ly in bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">8.在编写单元测试之前，我必须模仿所有的东西吗？</h2><p id="3a91" class="pw-post-body-paragraph ku kv in kw b kx ms jo kz la mt jr lc ld ng lf lg lh nh lj lk ll ni ln lo lp ig bi translated">不，在编写单元测试之前，您不必马上模拟所有的东西，您只需要模拟您想要进行单元测试的组件中使用的子组件和服务。</p><p id="9588" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">事实上，在为每个组件编写单元测试并最终模拟它们时，您可以随着时间的推移构建您的测试床。如果您向模拟服务添加新的函数，您将需要保持模拟服务是最新的，否则当您运行单元测试时，会出现函数未定义的错误。</p><p id="3f4a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果您忘记模拟子组件或服务，那么您可能会在其他组件或服务中出现错误，而这些错误甚至不会被您正在进行单元测试的组件所使用。</p><p id="c2af" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lt">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lt">plain English . io</em></a></p></div></div>    
</body>
</html>