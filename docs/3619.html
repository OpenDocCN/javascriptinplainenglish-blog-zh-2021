<html>
<head>
<title>Write a LiveReload Plugin for Hapi: Enable Automatic Page Reloads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为哈比神写一个LiveReload插件:启用自动页面重载</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/write-a-livereload-plugin-for-hapi-enable-automatic-page-reloads-7cec2d0c6cdb?source=collection_archive---------23-----------------------#2021-07-20">https://javascript.plainenglish.io/write-a-livereload-plugin-for-hapi-enable-automatic-page-reloads-7cec2d0c6cdb?source=collection_archive---------23-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e08f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何为哈比神写一个LiveReload插件？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b6eb983a8d3489538b6bf0129978d175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jvaJxtpHQzA3gr41g-GWQ.png"/></div></div></figure><p id="935e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一段时间以来，我一直想解决的一个问题是缺少一个<a class="ae kx" href="https://github.com/livereload/livereload-js" rel="noopener ugc nofollow" target="_blank">的LiveReload </a>插件来支持<a class="ae kx" href="https://hapi.dev/" rel="noopener ugc nofollow" target="_blank">的哈比神</a>。如果关闭缓存，在手动重新加载时可以看到模板的变化，但是我已经习惯了用<a class="ae kx" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>开发时自动重新加载。</p><h2 id="1f24" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">肝叶建筑</h2><p id="6941" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">完整的肝脏加载协议<a class="ae kx" href="http://livereload.com/api/protocol/" rel="noopener ugc nofollow" target="_blank">可供所有人查看</a>。简言之，它需要两个部分。</p><h2 id="51bf" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">计算机网络服务器</h2><p id="294d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">LiveReload服务器接受HTTP和WebSocket连接(在同一端口上)。它负责为LiveReload客户端代码提供服务，并监控文件系统的变化。它还监听来自客户端的指示URL更改的消息。</p><p id="eed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当发生更改时，它会向客户端发送一条消息(通过WebSocket ),指出哪个文件发生了更改，以便在需要时可以重新加载。</p><h2 id="8fdf" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">客户</h2><p id="24f1" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">客户端在浏览器中运行，它连接到服务器并等待消息。当它收到要求重新加载的消息时，它就会这样做。</p><p id="fcb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(这是一个相当简略的解释……)</p><p id="5c28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我并不打算实际上重新实现客户端——我只是想自动插入导致客户端代码被加载并开始监听的片段。</p><h2 id="b197" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">插件结构</h2><p id="6852" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">哈比神插件似乎是最好的起点。我从以前的工作中了解到，哈比神服务器在<a class="ae kx" href="https://hapi.dev/api/?v=20.1.4#request-lifecycle" rel="noopener ugc nofollow" target="_blank">请求/响应生命周期</a>中有“扩展点”,可以连接到这些扩展点并用于监控或修改请求或响应。</p><p id="9695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哈比神插件的基本结构很简单——它是一个导出名为<code class="fe lw lx ly lz b">plugin</code>的结构的对象，该结构包含名为<code class="fe lw lx ly lz b">register()</code>的函数(和一些元数据)。注册函数接收一个<code class="fe lw lx ly lz b">server</code>对象和一个(可选)<code class="fe lw lx ly lz b">options</code>对象。它做它需要做的事情，然后返回或者抛出一个异常。</p><p id="714d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个非常基础的插件。它导出了哈比神在插件中寻找的结构。register函数创建一个向用户问好的路由，或者如果用户没有指定要问候谁，则创建一个向全世界问好的路由。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="fe0e" class="ky kz iq lz b gy me mf l mg mh">'use strict';<br/><br/>async function register(server, options = {}) {<br/>  server.route({<br/>    path: "/hello",<br/>    method: "GET",<br/>    handler: function () {<br/>      const name = options.name || "world";<br/>      return `Hello ${name}\n`;<br/>    }<br/>  });<br/>}<br/><br/>module.exports = {<br/>  name: 'hapi-reload',<br/>  version: '0.1.0',<br/>  register: register<br/>};</span></pre><p id="fa8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有多种方法来声明你的插件——哈比神的文档很好地涵盖了这一切。现在我们保持简单，把插件代码放在一个名为<code class="fe lw lx ly lz b">plugin.js</code>的文件中。</p><p id="ddee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要启动并运行一台服务器，这样我们就有东西可以插入了。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="64a3" class="ky kz iq lz b gy me mf l mg mh">const Hapi = require("@hapi/hapi");<br/>const hapiLivereload = require("./plugin");<br/><br/>async function run() {<br/>  const serverOpts = {<br/>    port: process.env.PORT || 4000,<br/>    host: '0.0.0.0'<br/>  };<br/>  const server = Hapi.server(serverOpts);<br/><br/>  await server.register({<br/>    plugin: hapiLivereload<br/>  });<br/>  return server.start();<br/>}<br/><br/>run()<br/>  .then(() =&gt; console.log("Server up"))<br/>  .catch(err =&gt; console.error("Couldn't run", err));</span></pre><p id="a4ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且——这很有效。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="aff2" class="ky kz iq lz b gy me mf l mg mh">$ node dev/server.js<br/>Server up</span><span id="8a9e" class="ky kz iq lz b gy mi mf l mg mh">$ curl http://localhost:4000/hello<br/>Hello world</span></pre><p id="3049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以添加<code class="fe lw lx ly lz b">name</code>选项来定制响应。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="81e8" class="ky kz iq lz b gy me mf l mg mh">await server.register({<br/>    plugin: hapiLivereload,<br/>    options: {<br/>      name: "Paul"<br/>    }<br/>  });</span></pre><p id="e783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在它认识我了！</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="1578" class="ky kz iq lz b gy me mf l mg mh">$ curl http://localhost:4000/hello<br/>Hello Paul</span></pre><h2 id="388b" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">用哪个挂钩？</h2><p id="8c00" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">所以这是一个基本的插件，但它没有做任何特别有用的事情——你可能会想到更简单的方式来说“你好，世界”。</p><p id="ca61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次开始查看请求生命周期。浏览步骤列表，<code class="fe lw lx ly lz b">onPreResponse</code>看起来不错——响应已经生成，但尚未传输，更好的是:</p><blockquote class="mj mk ml"><p id="5fd7" class="jn jo mm jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">request.response中包含的响应可能会被修改(但不会被赋予新值)。若要返回不同的响应类型(例如，用HTML响应替换错误)，请返回新的响应值。</p></blockquote><p id="1024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们尝试一种新的方法——而不是特定的路线来问候用户，让所有的<em class="mm">响应都这样做。友好多了。</em></p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="e8d0" class="ky kz iq lz b gy me mf l mg mh">async function register(server, options = {}) {<br/>  server.ext({<br/>    type: 'onPreResponse',<br/>    method: function(request, h) {<br/>      const name = options.name || "world";<br/>      console.log(`Replacing "${request.response.source}"`);<br/>      return `Hello ${name}\n`;<br/>    }<br/>  });<br/>}</span></pre><p id="3741" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lw lx ly lz b">console.log</code>向我们展示了我们正在替换什么(对调试有用)；我们只需返回我们想要的新回复文本，医生说这应该可以。</p><p id="f704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试它，我们需要一条<em class="mm">不返回<code class="fe lw lx ly lz b">Hello world</code>的路线。我们可以将它添加到我们的服务器代码中的<code class="fe lw lx ly lz b">run()</code>。</em></p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="e3fb" class="ky kz iq lz b gy me mf l mg mh">server.route({<br/>    path: "/",<br/>    method: "GET",<br/>    handler: () =&gt; "I should be an index page\n"<br/>  })</span></pre><p id="7387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们尝试一下呢？</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="e684" class="ky kz iq lz b gy me mf l mg mh">Server up<br/>Replacing "I should be an index page<br/>"</span><span id="1e40" class="ky kz iq lz b gy mi mf l mg mh">$ curl http://localhost:4000/<br/>Hello Paul</span></pre><p id="f390" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太棒了。</p><h2 id="d671" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">肝负荷寄存器</h2><p id="f22b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">livereload插件的<code class="fe lw lx ly lz b">register</code>功能基本上是一样的。差异是特定于插件的，计算出客户端代码的位置。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="0f86" class="ky kz iq lz b gy me mf l mg mh">const logger = require("util").debuglog("hapi-livereload");<br/><br/>let host, port, src;<br/><br/>async function register(server, options = {}) {<br/>  host = options.host || "localhost";<br/>  port = options.port || 35729;<br/>  src = options.src || '//' + host + ':' + port + '/livereload.js?snipver=1';<br/><br/>  server.ext({<br/>    type: 'onPreResponse',<br/>    method: addSnippet<br/>  });<br/>}</span></pre><p id="a4a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还没有涉及到的是<code class="fe lw lx ly lz b">addSnippet</code>函数，这是事情变得更复杂的地方——实际上是修改返回的网页。</p><p id="bd20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用Node的标准<code class="fe lw lx ly lz b"><a class="ae kx" href="https://nodejs.org/api/util.html#util_util_debuglog_section_callback" rel="noopener ugc nofollow" target="_blank">util.debuglog</a></code>功能添加了一个<code class="fe lw lx ly lz b">logger</code>功能，因此如果用户需要，我们可以向他们报告。</p><h2 id="b184" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">修改HTML</h2><p id="4496" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我花了一些时间寻找一个HTML解析器。事实上，插件不仅需要解析输出的HTML页面，而且我们还必须能够修改它并将其作为文本发送出去，这使得事情变得复杂。</p><p id="bb6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，我最终偶然发现了喜马拉雅山，这非常适合我的工作。它将HTML文档转换成JSON对象，因此这个文档:</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="5c2b" class="ky kz iq lz b gy me mf l mg mh">&lt;div class='post post-featured'&gt;<br/>  &lt;p&gt;Himalaya parsed me...&lt;/p&gt;<br/>  &lt;!-- ...and I liked it. --&gt;<br/>&lt;/div&gt;</span></pre><p id="7965" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变成了这个JSON:</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="c033" class="ky kz iq lz b gy me mf l mg mh">[{<br/>  type: 'element',<br/>  tagName: 'div',<br/>  attributes: [{<br/>    key: 'class',<br/>    value: 'post post-featured'<br/>  }],<br/>  children: [{<br/>    type: 'element',<br/>    tagName: 'p',<br/>    attributes: [],<br/>    children: [{<br/>      type: 'text',<br/>      content: 'Himalaya parsed me...'<br/>    }]<br/>  }, {<br/>    type: 'comment',<br/>    content: ' ...and I liked it. '<br/>  }]<br/>}]</span></pre><p id="ceed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(示例摘自Github页面。)</p><p id="307e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了<code class="fe lw lx ly lz b">parse</code>之外，还有一个<code class="fe lw lx ly lz b">stringify</code>方法，它将JSON <em class="mm">转换回</em>为HTML。完美。</p><p id="6d3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个比我开始时意识到的更大的问题。对于大问题，我发现最好的办法是分解它们，如下图所示。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="3098" class="ky kz iq lz b gy me mf l mg mh">function addSnippet(request, h) {<br/>  // Is it HTML? If not, we can't work with it.<br/>  // Can we parse it?<br/>  // If we can parse it, does it have a HTML tag as it should?<br/>  // And is there a 'head' element we can attach our script to?<br/>  // Did someone already add a livereload script to it?<br/>  // Add the script to the 'head' element<br/>  // Convert back to HTML and return it<br/>}</span></pre><p id="bdf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来是一个可管理的分解，所有的单个部分看起来并不具有挑战性。让我们来解决它们。</p><h2 id="4582" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">我们能处理回复吗？</h2><p id="f9dd" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这里我们采用简单的方法——我们假设<a class="ae kx" href="https://webplatform.github.io/docs/concepts/Internet_and_Web/mime_types/" rel="noopener ugc nofollow" target="_blank">的哑剧类型</a>是正确的，并检查<code class="fe lw lx ly lz b">text/html</code>。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="2bd1" class="ky kz iq lz b gy me mf l mg mh">function isHtml(response) {<br/>  return response.contentType?.indexOf("text/html") &gt;= 0;<br/>}</span></pre><h2 id="59d9" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">我们能解析它吗，它有正确的节点吗？</h2><p id="162c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们最终要搜索相当多的节点，所以让我们有一个方便的函数。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="5196" class="ky kz iq lz b gy me mf l mg mh">function findNode(nodes, name) {<br/>  return nodes.find(node =&gt; node.tagName === name);<br/>}</span></pre><p id="7d4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们的解析/检查代码可以写成如下。我们试图解析它；如果我们可以解析它，我们就寻找<code class="fe lw lx ly lz b">html</code>元素。如果存在，我们就寻找<em class="mm">的子元素</em>，它是<code class="fe lw lx ly lz b">head</code>元素。</p><p id="2fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意——我们在这里使用<code class="fe lw lx ly lz b">h.continue</code>。这向哈比神表明，我们对这个回应没什么可说的，继续下一个话题。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="1018" class="ky kz iq lz b gy me mf l mg mh">const doc = parse(response.source);<br/>  if (!doc || doc.length == 0) {<br/>    logger("Couldn't parse", response.source);<br/>    return h.continue;<br/>  }<br/><br/>  const htmlNode = findNode(doc, "html")<br/>  if (!htmlNode) {<br/>    logger("Couldn't find HTML tag", response.source);<br/>    return h.continue;<br/>  }<br/><br/>  const headNode = findNode(htmlNode.children, "head");<br/>  if (!headNode) {<br/>    logger("Couldn't find HEAD tag", response.source);<br/>    return h.continue;<br/>  }</span></pre><h2 id="4a44" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">已经有剧本了吗？</h2><p id="9f08" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">从技术上讲，脚本可以在页面的任何地方。我们不希望只搜索整个网页——其中可能有大量的节点。所以我们将简化我们的问题，只检查<code class="fe lw lx ly lz b">head</code>中的脚本，这是它最有可能出现的地方。</p><p id="b338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要:</p><ol class=""><li id="17df" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">找到<code class="fe lw lx ly lz b">head</code>节点的所有子节点，</li><li id="5e66" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">它们是脚本节点，</li><li id="35b6" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">带有<code class="fe lw lx ly lz b">src</code>属性</li><li id="44df" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">并检查<code class="fe lw lx ly lz b">livereload.js</code>的<code class="fe lw lx ly lz b">src</code>值</li></ol><p id="decf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤1很简单— <code class="fe lw lx ly lz b">head.children</code>。剩下的3个步骤可以重写为——对于每个节点，如果它是一个<code class="fe lw lx ly lz b">script</code>节点，检查<code class="fe lw lx ly lz b">src</code>属性和<code class="fe lw lx ly lz b">src</code>值。如果<code class="fe lw lx ly lz b">src</code>值包含<code class="fe lw lx ly lz b">livereload.js</code>，那么脚本已经被添加。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="bf9e" class="ky kz iq lz b gy me mf l mg mh">function reloadExists(nodes) {<br/>  let found = false;<br/><br/>  nodes.forEach(node =&gt; {<br/>    if ((node.type === 'element') &amp;&amp; (node.tagName === 'script')) {<br/>      const reloadAttribs =<br/>        node.attributes<br/>            .filter(node =&gt; node.key === 'src')<br/>            .filter(attr =&gt; attr.value?.indexOf('/livereload.js') &gt;= 0);<br/>      found = reloadAttribs.length &gt; 0;<br/>    }<br/>  })<br/><br/>  return found;<br/>}</span></pre><h2 id="a36c" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">添加脚本</h2><p id="d0e4" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们需要添加一个<code class="fe lw lx ly lz b">script</code>节点来加载客户端脚本。我们将把它设为<code class="fe lw lx ly lz b"><a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attributes" rel="noopener ugc nofollow" target="_blank">async</a></code>，这样它就不会减慢网站的其他加载速度。</p><p id="6e6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们使用的是JSON，这现在相对容易了——我们将一个新节点推到现有的<code class="fe lw lx ly lz b">head</code>子节点上。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="5651" class="ky kz iq lz b gy me mf l mg mh">headNode.children.push({<br/>    type: 'element',<br/>    tagName: 'script',<br/>    attributes: [{ key: 'src', value: src }, { key: "async", value: null }, { key: "defer", value: null }],<br/>    children: []<br/>  })</span></pre><h2 id="d3b3" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">转换回HTML</h2><p id="5e55" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最后一步，我们从钩子返回新的HTML，这样哈比神将使用它作为响应。喜玛拉雅让这变得简单:</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="5136" class="ky kz iq lz b gy me mf l mg mh">return stringify(doc);</span></pre><h2 id="44d0" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">把它们放在一起</h2><p id="90d3" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们现在可以从上面充实我们的<code class="fe lw lx ly lz b">addSnippet</code>框架，用实际代码替换注释。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="57f5" class="ky kz iq lz b gy me mf l mg mh">function addSnippet(request, h) {<br/>  logger("Processing response for", request.info.id);<br/><br/>  // Less typing.<br/>  const response = request.response;<br/><br/>  if (!isHtml(response)) {<br/>    logger("Response isn't HTML, skip it.");<br/>    return h.continue;<br/>  }<br/><br/>  const doc = parse(response.source);<br/>  if (!doc || doc.length == 0) {<br/>    logger("Couldn't parse", response.source);<br/>    return h.continue;<br/>  }<br/><br/>  const htmlNode = findNode(doc, "html")<br/>  if (!htmlNode) {<br/>    logger("Couldn't find HTML tag", response.source);<br/>    return h.continue;<br/>  }<br/><br/>  const headNode = findNode(htmlNode.children, "head");<br/>  if (!headNode) {<br/>    logger("Couldn't find HEAD tag", response.source);<br/>    return h.continue;<br/>  }<br/><br/>  if (reloadExists(headNode.children)) {<br/>    logger("Snippet already exists, skip.");<br/>    return h.continue;<br/>  }<br/><br/>  headNode.children.push({<br/>    type: 'element',<br/>    tagName: 'script',<br/>    attributes: [{ key: 'src', value: src }, { key: "async", value: null }, { key: "defer", value: null }],<br/>    children: []<br/>  })<br/><br/>  logger("Processing done for", request.info.id);<br/>  return stringify(doc);<br/>}</span></pre><h2 id="e8ce" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">尝试一下</h2><p id="8c82" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">为了测试它，我们需要一个实际服务于HTML文件的路由——没有什么特别的，所以我们可以很容易地看到代码是否被添加了。</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="4b38" class="ky kz iq lz b gy me mf l mg mh">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;title&gt;Home Page&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;header&gt;&lt;h1&gt;Hello from Hapi!&lt;/h1&gt;&lt;/header&gt;<br/>&lt;main&gt;<br/>    &lt;p&gt;This is a paragraph&lt;/p&gt;<br/>    &lt;p&gt;This is still also a paragraph.&lt;/p&gt;&lt;/main&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="4376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将改变我们的<code class="fe lw lx ly lz b">/</code>路线来提供服务。假设<code class="fe lw lx ly lz b">html</code>变量包含HTML页面:</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="5884" class="ky kz iq lz b gy me mf l mg mh">server.route({<br/>    path: "/",<br/>    method: "GET",<br/>    handler: (request, h) =&gt; h.response(html)<br/>  })</span></pre><p id="4cb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试一下:</p><pre class="km kn ko kp gt ma lz mb mc aw md bi"><span id="91db" class="ky kz iq lz b gy me mf l mg mh">&lt;!doctype html&gt;<br/>&lt;html lang='en'&gt;<br/>&lt;head&gt;<br/>    &lt;title&gt;Home Page&lt;/title&gt;<br/>&lt;script src='//localhost:35729/livereload.js?snipver=1' async defer&gt;&lt;/script&gt;&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;header&gt;&lt;h1&gt;Hello from Hapi!&lt;/h1&gt;&lt;/header&gt;<br/>&lt;main&gt;<br/>    &lt;p&gt;This is a paragraph&lt;/p&gt;<br/>    &lt;p&gt;This is still also a paragraph.&lt;/p&gt;&lt;/main&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="4d29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就在那里！你可以看到HTML看起来和以前完全不一样——例如,<code class="fe lw lx ly lz b">doctype</code>的大小写被改变了——但是它有相同的语义。</p><h2 id="cbe4" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">结论</h2><h2 id="a096" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">好的…</h2><p id="fd88" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我还没有对它进行过大量的测试，但是这种方法似乎适用于普通的HTML文件。</p><p id="db77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现起来并不难——哈比神提供了我们融入请求/响应生命周期所需要的一切，喜马拉雅库正好提供了我们处理HTML所需要的东西(如果没有它，事情会变得困难得多)。</p><h2 id="fae2" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">…还有“哎呀”</h2><p id="05e1" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">然而……当我把它和我正在做的项目整合在一起时，我发现它不能和Vision一起工作。<code class="fe lw lx ly lz b">source</code>元素不是一个呈现的页面，它是一个数据结构，大概对Vision有意义。</p><p id="9ba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我做了之前应该想到的事情——我将JavaScript放在由Vision呈现的头部分中。一旦我做到了这一点，我就不需要插件就可以运行livereload了。</p><p id="5522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，从“让肝脏加载工作”的角度来看，这实际上是一个相当无意义的工作。不过，这仍然是一次有用的经历，我从中吸取了教训。所以它并没有被浪费掉，只是有点“doh！”瞬间。</p><p id="e109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mm">更多内容请看</em><a class="ae kx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>