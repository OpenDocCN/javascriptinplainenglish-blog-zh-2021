<html>
<head>
<title>An Introduction to Recoil: A State Management Library for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反冲介绍:React的状态管理库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recoil-e422476011a?source=collection_archive---------6-----------------------#2021-08-14">https://javascript.plainenglish.io/recoil-e422476011a?source=collection_archive---------6-----------------------#2021-08-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/0852ab5e57d5da75ca7303a98b7ba141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSjm1beN40ZhqSD85xMWdw.png"/></div></div></figure><div class=""/><div class=""><h2 id="3123" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated"><em class="kn">状态管理哪个更像React </em></h2></div><p id="72d9" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">状态管理</em>已经成为任何应用程序开发的核心部分。容器模式帮助我们为所有应用程序的数据创建一个单一的真实来源。<em class="lk"> Redux </em>和<em class="lk"> MobX </em>是在反应方面的首选状态管理库。他们固执己见(这是一个优点),需要你学习他们特有的新模式，这给整个应用程序构建过程又增加了一步。</p><p id="a120" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了解决状态管理的外部依赖性，React提出了它的<em class="lk">上下文API </em>和<em class="lk"> useReducer钩子</em>。但是对于更大的应用程序来说，它仍然不是开发者可以依赖的东西。甚至脸书的React团队也意识到了局限性，例如:</p><ul class=""><li id="d6f0" class="ll lm iy kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated">组件状态只能通过将其推至公共祖先来共享，但这可能包括一个巨大的树，然后需要重新呈现。</li><li id="33be" class="ll lm iy kq b kr lu ku lv kx lw lb lx lf ly lj lq lr ls lt bi translated">上下文只能存储单个值，而不能存储一组不确定的值，每个值都有其使用者。</li></ul><p id="8c54" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了克服这些限制，并仍然保持一种类似React的模式，他们提出了一种新的状态管理库<a class="ae lz" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iz">反冲</strong> </a>。此时是0.4.0版本，所以和4.1.1的Redux还是不在一个级别。</p><h2 id="2fe2" class="ma mb iy bd mc md me dn mf mg mh dp mi kx mj mk ml lb mm mn mo lf mp mq mr ms bi translated">核心概念/API:</h2><p id="6b51" class="pw-post-body-paragraph ko kp iy kq b kr mt jz kt ku mu kc kw kx mv kz la lb mw ld le lf mx lh li lj ig bi translated"><strong class="kq iz">原子</strong>:每个原子都是一个状态单位。它们是可更新和可订阅的:当一个atom被更新时，每个订阅的组件都用新值重新呈现。最棒的是它们可以在运行时创建。原子在技术上可以取代组件状态，可以直接注入到依赖于状态的组件中，而不是作为道具传递。</p><p id="5674" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">原子需要一个惟一的键/标识符(如果存在两个具有相同值的标识符，将会导致错误)，它用于调试、持久性，以及某些高级API，允许您查看所有原子的映射。像<em class="lk"> useState </em>一样，你也需要提供一个默认状态。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="0c54" class="ma mb iy nd b gy nh ni l nj nk">import { atom } from 'recoil';</span><span id="2cb1" class="ma mb iy nd b gy nl ni l nj nk">const <strong class="nd iz">textState</strong> = atom({<br/>key: 'textState', //identifier<br/>default: '', // initial state});</span></pre><p id="1a26" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq iz"> useRecoilState: </strong>为了从组件中读写原子，我们使用了一个名为<em class="lk"> useRecoilState的钩子。</em></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="eea5" class="ma mb iy nd b gy nh ni l nj nk">import { useRecoilState } from 'recoil';<br/>import { textState } from '../counter/Counter';</span><span id="15fb" class="ma mb iy nd b gy nl ni l nj nk">function TextInput() {<br/>const [counter, setCounter] = <strong class="nd iz">useRecoilState</strong>(<em class="lk">textState</em>);<br/>const onChange = (event) =&gt; {setCounter(event.target.value);};<br/>return (<br/>  &lt;div&gt;<br/>   &lt;input type='text' value={counter} onChange={onChange}  placeholder='Enter text'/&gt;<br/>   &lt;h5&gt;Input text: {counter}&lt;/h5&gt;<br/> &lt;/div&gt;<br/>);}</span></pre><p id="04cc" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq iz">选择器:</strong>一个<em class="lk">选择器</em>是一个纯函数，接受原子或其他选择器作为输入。当原子或选择器的状态被更新时，选择器函数将被重新评估。像Redux一样，组件可以像原子一样订阅选择器，然后在选择器改变时重新呈现。它们主要用于计算基于独立状态值的派生数据。</p><p id="b513" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">像原子一样，选择器也需要唯一的标识符。使用<em class="lk"> get </em>属性，我们可以访问<em class="lk"> get函数</em>，我们可以使用这个函数访问作为参数传递的原子的状态。如果原子(被传递)或选择器的状态更新，那么<em class="lk"> get </em>函数将被重新计算。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="17fc" class="ma mb iy nd b gy nh ni l nj nk">import { selector } from 'recoil';</span><span id="d7bf" class="ma mb iy nd b gy nl ni l nj nk">const <strong class="nd iz">charCountState</strong> = selector({<br/> key: 'charCountState', // identifier<br/> get: ({ get }) =&gt; {<br/>  const text = get(textState);<br/>  return text.length;<br/> },<br/>});</span></pre><p id="6649" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq iz"> useRecoilValue </strong>:为了读取选择器的值，我们使用了一个名为<em class="lk"> useRecoilValue的钩子。</em></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="a2a1" class="ma mb iy nd b gy nh ni l nj nk">import { useRecoilValue } from 'recoil';</span><span id="1efc" class="ma mb iy nd b gy nl ni l nj nk">const DisplayCount = () =&gt; {<br/> const <em class="lk">count</em> = useRecoilValue(<strong class="nd iz">charCountState</strong>);<br/> return &lt;h5&gt;Character Count: {count}&lt;/h5&gt;;<br/>};</span></pre></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><figure class="my mz na nb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nt"><img src="../Images/979459066a7e502480cf042624f4492e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBBNp1thaYLxF_SoMmr2qA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">Recoil core features example</figcaption></figure><p id="d3de" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我使用反冲文档中的<a class="ae lz" href="https://recoiljs.org/docs/introduction/getting-started" rel="noopener ugc nofollow" target="_blank"> <em class="lk">入门示例</em> </a>创建了上述示例。我对结构做了一些小的改动来测试一些东西，你可以在这里找到回购<a class="ae lz" href="https://github.com/devAbhimanyu/react-x-recoil/tree/counter-app" rel="noopener ugc nofollow" target="_blank">的链接</a>。</p><p id="5531" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容请看</em> <a class="ae lz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iz"> <em class="lk">说白了就是</em> </strong> </a> <strong class="kq iz"> <em class="lk">。</em> </strong> <em class="lk">报名参加我们的</em><strong class="kq iz"><em class="lk"/></strong><a class="ae lz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq iz"><em class="lk">免费每周简讯这里</em> </strong> </a> <strong class="kq iz"> <em class="lk">。</em> </strong></p></div></div>    
</body>
</html>