<html>
<head>
<title>Let’s Demystify Garbage Collection in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们揭开JavaScript中垃圾收集的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-garbage-collection-in-javascript-3d5c94dea99f?source=collection_archive---------20-----------------------#2021-10-18">https://javascript.plainenglish.io/demystifying-garbage-collection-in-javascript-3d5c94dea99f?source=collection_archive---------20-----------------------#2021-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="324b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">垃圾收集是Java和C++等一些高级语言中非常基本的功能。但是当涉及到JavaScript中的垃圾收集和内存管理时，混乱就开始了，因为没有显式的方法来销毁对象，也没有定义每次销毁对象时的流程。我将试着对这个难以捉摸的过程进行更多的阐释。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b61f4c6fbd339b7038e82c4ff45d5969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ibKw9uePvo9ixqBH"/></div></div></figure><h1 id="8932" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">内存管理</strong></h1><p id="af82" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">内存管理有3个非常简单的阶段:</p><ol class=""><li id="5636" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">分配您需要的内存</li><li id="9711" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">使用分配的内存(读、写)</li><li id="e4ac" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">当不再需要分配的内存时，释放它</li></ol><h2 id="84e2" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated"><strong class="ak"> 1。分配内存</strong></h2><p id="5e28" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这在JavaScript中非常简单。</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="a6c7" class="mo ky iq nb b gy nf ng l nh ni">var num= 123; // allocates memory for a number<br/>var str = 'sumeet'; // allocates memory for a string<br/><br/>var obj = {<br/>  fName: "Sumeet",<br/>  lName: "Bhalla"<br/>}; // allocates memory for an object and contained values<br/><br/><br/>var arr = [123, null, 'sumeet',"bhalla]; // allocates memory for the array and contained values<br/><br/>function myFunc(val1,val2) {<br/>  return val1+ val2;<br/>} // allocates a function (which is a callable object)</span></pre><h2 id="f91f" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated"><strong class="ak"> 3。释放分配的内存</strong></h2><p id="f12e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">JavaScript用来决定何时释放内存的算法称为<strong class="jp ir"> <em class="nj">标记和清除</em> </strong>算法。</p><p id="6eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nj">该算法假设了一组称为根的对象的知识。在JavaScript中，根是全局对象。周期性地，垃圾收集器将从这些根开始，找到从这些根引用的所有对象，然后是从这些根引用的所有对象，等等。从根开始，垃圾收集器将找到所有可到达的对象并收集所有不可到达的对象。</em></p><p id="fb95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定期执行以下“垃圾收集”步骤:</p><ul class=""><li id="e822" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk nk mg mh mi bi translated">垃圾收集器提取根并“标记”(记住)它们。</li><li id="2f4b" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk nk mg mh mi bi translated">然后，它访问并“标记”来自它们的所有引用。</li><li id="f163" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk nk mg mh mi bi translated">然后它访问被标记的对象并标记它们的引用。所有访问过的对象都记住了，以免以后两次访问同一个对象。</li><li id="4ca2" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk nk mg mh mi bi translated">…依此类推，直到每个可到达的(从根)引用都被访问过。</li><li id="0327" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk nk mg mh mi bi translated">除标记的对象外，所有对象都将被删除。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/46a83361c56eafc01c7050fa0a13f09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*I5w3sMOEqUt8ljk15bTvuw.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><a class="ae nq" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><blockquote class="nr ns nt"><p id="6307" class="jn jo nj jp b jq jr js jt ju jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj kk ij bi translated"><strong class="jp ir">例题</strong></p></blockquote><p id="44ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的箭头描述了一个对象引用。全局变量<code class="fe nx ny nz nb b">"user"</code>引用了对象<code class="fe nx ny nz nb b">{name: "John"}</code>。约翰的<code class="fe nx ny nz nb b">"name"</code>属性存储了一个原语，所以它被绘制在对象内部。来源</p><p id="ee9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个<strong class="jp ir">的简单例子</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/bbd436c9cd168af9c05539697c64fa18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vK0guvr-qHPSQmJG0tqI2Q.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><a class="ae nq" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="63a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果<code class="fe nx ny nz nb b">user</code>的值被覆盖，参考丢失:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/b4fe57f29ee777b04c82748d1039fdef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7q7pgFtDWXA6VClbn_f0g.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><a class="ae nq" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="c354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在约翰变得遥不可及。没有办法访问它，也没有引用它。垃圾收集器将丢弃数据并释放内存。[ <a class="ae nq" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="e53d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果有<strong class="jp ir">多个引用</strong>指向该用户对象，</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="1577" class="mo ky iq nb b gy nf ng l nh ni">// user has a reference to the object <br/>let user = {   <br/>  name: "John" <br/>};  <br/>let admin = user;</span></pre><p id="04cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在如果我们设定</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/467c6caba5499c779d7fa456df56dc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*CiNST3VasRCGbAIjvHNi_A.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><a class="ae nq" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="8376" class="mo ky iq nb b gy nf ng l nh ni">user = null</span></pre><p id="611e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该对象仍然可以通过admin访问，因此只有当admin也将其设置为null时，它才会被标记为由垃圾收集器清理。</p><p id="535a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你也有下面的<strong class="jp ir">互连参考的例子。</strong></p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="b135" class="mo ky iq nb b gy nf ng l nh ni">function marry(man, woman) {   <br/>  woman.husband = man;   <br/>  man.wife = woman;    <br/>  return {     <br/>    father: man,     <br/>    mother: woman   <br/>  } <br/>}  <br/>let family = marry(<br/>  {   name: "John" }, <br/>  {   name: "Ann" }<br/>);</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi od"><img src="../Images/24a6479583540b122a3a2ab93fd9ad0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*j6uaX9fJ61vOAbzrNir1Zw.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><a class="ae nq" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="76cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在所有的对象都是可到达的，所以它们被标记为从根可到达。</p><p id="28db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设现在我们移除一些对象引用</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="4718" class="mo ky iq nb b gy nf ng l nh ni">delete family.father; <br/>delete family.mother.husband;</span></pre><div class="km kn ko kp gt ab cb"><figure class="oe kq of og oh oi oj paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/bf5d05d36fb2d9e1a06d330396cff3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*VgagDBDAOCTYhJdUPxXrbg.png"/></div></figure><figure class="oe kq ok og oh oi oj paragraph-image"><img src="../Images/5c340c80ce13ad03ef5f51bcd7b71ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*jJQfbzBuMy3JonEYBByfvg.png"/><figcaption class="nm nn gj gh gi no np bd b be z dk ol di om on"><a class="ae nq" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure></div><p id="2696" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向外引用并不重要。只有传入的可以使对象可达。因此，John现在是不可访问的，并且将从存储器中移除，其所有数据也变得不可访问。</p><p id="00d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，如果您设置</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="b320" class="mo ky iq nb b gy nf ng l nh ni">family = null;</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d9cc10762f9b31234dcb15a18aeef1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*1LsxsARbyREKddGeLqhdcw.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk"><a class="ae nq" href="https://javascript.info/garbage-collection" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="40e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这被称为<strong class="jp ir">无法到达的岛屿。</strong></p><p id="d64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nj">*截至2012年</em><strong class="jp ir"><em class="nj"/></strong><em class="nj">，所有现代浏览器都配备了标记-清除垃圾收集器。<br/>*截至</em><strong class="jp ir"><em class="nj">2019</em></strong><em class="nj">，无法在JavaScript中显式或编程触发垃圾回收。</em></p><h2 id="56cb" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated"><strong class="ak">总结</strong></h2><p id="4c0e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">需要了解的主要事项:</p><ul class=""><li id="2691" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk nk mg mh mi bi translated">垃圾收集是自动执行的。我们不能强迫或阻止它。</li><li id="e203" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk nk mg mh mi bi translated">对象在可访问时保留在内存中。</li><li id="6695" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk nk mg mh mi bi translated">被引用与可到达(从根)是不同的:一组相互链接的对象可以作为一个整体变得不可到达。[ <a class="ae nq" href="https://javascript.info/garbage-collection#interlinked-objects" rel="noopener ugc nofollow" target="_blank">来源</a></li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi op"><img src="../Images/109074938deacc3c06a85b6bac90cfd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*rdCx3QtdDo1pBLAB"/></div></figure><h2 id="eba7" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated"><strong class="ak">好的读数</strong></h2><ul class=""><li id="5a53" class="ma mb iq jp b jq lv ju lw jy oq kc or kg os kk nk mg mh mi bi translated"><a class="ae nq" href="https://javascript.info/garbage-collection#interlinked-objects" rel="noopener ugc nofollow" target="_blank">https://JavaScript . info/garbage-collection # interlinked-objects</a></li><li id="ca2e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk nk mg mh mi bi translated"><a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Memory _ Management</a></li></ul><p id="91c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nj">更多内容请看</em><a class="ae nq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>