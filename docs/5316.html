<html>
<head>
<title>‘==’ vs. ‘===’ in JavaScript: An In-Depth Guide to Abstract vs. Strict Equality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的==' vs. '=== ':抽象与严格相等的深入指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vs-in-javascript-2977631d00db?source=collection_archive---------17-----------------------#2021-11-01">https://javascript.plainenglish.io/vs-in-javascript-2977631d00db?source=collection_archive---------17-----------------------#2021-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b710" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你用过JSLint吗？如果是，当您使用<code class="fe kl km kn ko b">==</code>而不是<code class="fe kl km kn ko b">===</code>时，您可能会遇到多个警告。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/e4633bb15bbfe012c8fa52a1f2479e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ih8prBrA7VyrcMHlb4OcFw.jpeg"/></div></div></figure><p id="aea3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从技术上讲，JSLint是一个静态代码分析工具。它被精心设计来分析用JavaScript编写的代码，以一种更技术性的方式，而不是固执己见的方式。随着时间的推移，图书馆演变成了ESLint。ESLint允许开发者添加自定义规则。今天，ESLint是一个工业标准。全球的开发人员都使用它来了解他们代码的质量——以及如何使他们的解决方案变得更好。</p><p id="eedb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ESLint最常抛出的建议之一是用<code class="fe kl km kn ko b">===</code>代替<code class="fe kl km kn ko b">==</code>。</p><p id="f50f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是为什么呢？</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="d3d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">你可以把==看作是平等的一种抽象形式。</strong></p><p id="d364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以把===看作是等式的一种严格形式。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c092" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">抽象版本(==)</h1><p id="bd23" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">对于我们的讨论，让我们把“==”当作抽象的等式。</p><p id="1545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在比较变量之前，JavaScript中的抽象等式对变量做了大量的运算。首先，它参与类型转换。让我们用一个简单的问题来理解这个。</p><p id="99a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“<strong class="jp ir"> null </strong>是否等于“<strong class="jp ir"> undefined </strong>”？</p><p id="c907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Null被赋给没有任何值的变量。另一方面，undefined用于标识编译时不存在的变量。无论是空的还是未定义的，在整个JavaScript架构中都有一个非常独特的用途。尽管开发人员不理解它们之间的区别，但他们经常互换使用。如果你以一种肤浅的方式来看，null可以等于undefined。因为在这两种情况下，您都在尝试识别一个不存在或没有值的变量——这间接意味着它不存在。如果你的目的是做一个简单的检查，看看变量中值的存在——使用抽象比较就足够了。</p><p id="b4a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么？<strong class="jp ir"> Null == undefined返回true！</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ml"><img src="../Images/bd5ba2fc6ba856098c5234cb6add33d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VrBiLu3xeENMMfr6NPcHGw.png"/></div></div></figure><p id="91fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的矩阵中可以看出，使用我们的抽象等式运算符进行比较是非线性的。事实上，这是一个复杂的故事，有太多的如果和但是需要考虑。这就像在JavaScript中比较两个变量的主观方式。你需要理解变量的最终推论是什么。它会以“真”或“假”结束，而在这两者之间没有什么被认为是抽象的平等。这就是为什么<strong class="jp ir"> true == 1返回true </strong>和<strong class="jp ir"> "" == []也返回true </strong>！</p><p id="bce7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于JavaScript初学者来说，抽象等式的规则是不可记忆的，而且相当复杂。所以，千万不要试图去记忆上面的图表。相反，要理解为什么抽象的等式操作符会有这样的行为。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mm"><img src="../Images/b335187ae18f28fdd13d9460269d75cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9FEV2lIDUDo7WqJ9x1FPA.png"/></div></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="68ad" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">严格相等(===)</h1><p id="d6ad" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">现在，让我们学习JavaScript中的严格相等。</p><p id="09e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">严格的平等并不意味着“同值同型”。相反，它检查两个操作数是否引用同一个对象，如果是value，两者应该具有相同的值。</p><pre class="kq kr ks kt gt mn ko mo mp aw mq bi"><span id="ec0b" class="mr lj iq ko b gy ms mt l mu mv">var a = [1,2,3];<br/>var b = [1,2,3];<br/>var c = a;<br/><br/>var ab_eq = (a === b); This will return false. Even though both the objects are off the same type and value<br/>var ac_eq = (a === c); This will return true, because both the objects refer to the same memory</span></pre><p id="8a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个相等运算符不参与任何附加运算。它不执行任何类型转换。而且，它不会将值简化为一种常见的形式。相反，它接受显示的值，并对它们进行检查。这意味着<strong class="jp ir"> null === undefined永远不会返回true，</strong>当你使用严格等式时。</p><p id="2e87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果两个值完全不同，特别是在它们的类型上，那么响应将会非常快。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ml"><img src="../Images/692709fc67d1d861b22942a980b5b645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9Xu6LLUEQmgEmR-j-wthA.png"/></div></div></figure><p id="a0ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用严格相等的比较是相当线性的。如果你在你的代码中使用它，总是严格到严格相等。特别是，如果您知道正在处理的响应的数据类型。当然，如果你已经掌握了抽象等式中的时髦转换——你可以选择！</p><h2 id="db1d" class="mr lj iq bd lk mw mx dn lo my mz dp ls jy na nb lw kc nc nd ma kg ne nf me ng bi translated">例外</h2><p id="7980" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">现在，JavaScript中的字符串有一个小小的例外。如果每个内存索引中的长度和字符都相同，您会期望严格相等运算符返回true。嗯，并不总是这样。</p><pre class="kq kr ks kt gt mn ko mo mp aw mq bi"><span id="17c9" class="mr lj iq ko b gy ms mt l mu mv"><strong class="ko ir">Case 1:</strong><br/>var a = "12" + "3";<br/>var b = "123";<br/><br/>console.log(a === b); <br/>The above will return true, because both a and b are equal in terms of value and type</span><span id="f649" class="mr lj iq ko b gy nh mt l mu mv"><strong class="ko ir">Case 2:</strong><br/>var a = new String("123");<br/>var b = "123";<br/>console.log(a === b);<br/>The above will return false, even though it appears to be equal in value. <strong class="ko ir">Why</strong>?</span></pre><p id="a9bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二种情况下，创建了一个新的字符串，这反过来又创建了一个对象，其行为类似于一个字符串。如果你试图用一个字符串对象来比较一个原始字符串，在严格相等的情况下，你一定会看到“假”。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/dff58c5cb83424977b07884d1d4f8554.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*X_vAQ9PgjzZkMNQw6aNDGQ.png"/></div></figure><h2 id="7d4a" class="mr lj iq bd lk mw mx dn lo my mz dp ls jy na nb lw kc nc nd ma kg ne nf me ng bi translated">严格相等的摘要</h2><p id="04d1" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">这里有一个简单的备忘单，可以帮助您理解严格的等式运算符。</p><blockquote class="nj nk nl"><p id="9fd5" class="jn jo nm jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">对于值类型(数字):</em> </strong> <br/> <code class="fe kl km kn ko b">a === b</code>如果<code class="fe kl km kn ko b">a</code>和<code class="fe kl km kn ko b">b</code>具有相同的值并且属于同一类型，则返回true</p><p id="cc1c" class="jn jo nm jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">对于引用类型:</em> </strong> <br/> <code class="fe kl km kn ko b">a === b</code>如果<code class="fe kl km kn ko b">a</code>和<code class="fe kl km kn ko b">b</code>引用完全相同的对象，则返回true</p><p id="60c7" class="jn jo nm jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">对于字符串:</em> </strong> <br/> <code class="fe kl km kn ko b">a === b</code>如果<code class="fe kl km kn ko b">a</code>和<code class="fe kl km kn ko b">b</code>都是字符串并且包含完全相同的字符，则返回true</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="b10b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="ec05" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">在JavaScript中比较两个值时，我总是使用===。它更加清晰，并且代码随着时间的推移变得不那么模糊。</p><p id="f02a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，这里有一个矩阵，为您比较了抽象和严格的等式运算符。希望这能帮助你想象这两者之间的区别。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ml"><img src="../Images/c82a8a40ee916c3cb88c710de7b05815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kX5TbFQ5tEh4wDNY7OcUw.png"/></div></div></figure><p id="2346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nm">更多内容请看</em><a class="ae nq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>