<html>
<head>
<title>Controlled and Uncontrolled Components in React — The Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的受控和非受控组件—简单的方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/controlled-and-uncontrolled-components-in-react-the-easy-way-60c44597a55f?source=collection_archive---------6-----------------------#2021-05-30">https://javascript.plainenglish.io/controlled-and-uncontrolled-components-in-react-the-easy-way-60c44597a55f?source=collection_archive---------6-----------------------#2021-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi jr"><img src="../Images/ce86edb9c33ef0b4512070fa34308557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*28jMYPzjSq9xd6OS"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Photo by <a class="ae kh" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0e35" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当开始使用React时，您可能经常从您的团队成员或一些网络文章中听到这两个术语。我知道当你不好意思问，不得不点头时，这变得很尴尬。不过，你现在不必担心。我会尽力向你解释它们是什么。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><blockquote class="lg lh li"><p id="c2c5" class="ki kj lj kk b kl km kn ko kp kq kr ks lk ku kv kw ll ky kz la lm lc ld le lf ig bi translated"><em class="in">根据React文档—</em>在受控组件中，表单数据由React组件处理。另一种方法是不受控制的组件，表单数据由DOM本身处理。<em class="in"/></p></blockquote><p id="79af" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当您编写React组件时，组件可以从两个来源获取要显示的数据</p><ol class=""><li id="739b" class="ln lo in kk b kl km kp kq kt lp kx lq lb lr lf ls lt lu lv bi translated">来自DOM</li><li id="a2de" class="ln lo in kk b kl lw kp lx kt ly kx lz lb ma lf ls lt lu lv bi translated">从道具</li></ol><blockquote class="lg lh li"><p id="c04e" class="ki kj lj kk b kl km kn ko kp kq kr ks lk ku kv kw ll ky kz la lm lc ld le lf ig bi translated">DOM是浏览器为显示网页而创建的符号。DOM由节点和对象组成。</p></blockquote><p id="eb58" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">DOM如何向组件发送数据？</strong></p><p id="f400" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您现在可能想知道DOM如何成为组件的数据源。为了更好的理解，我们来举个例子。</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Uncontrolled Component</figcaption></figure><p id="a08e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在上面的代码中，有一个<code class="fe md me mf mg b">input</code>元素，其上附加了一个<code class="fe md me mf mg b">ref</code>。对于那些不知道的人来说，可以把它看作是可以访问附加了<code class="fe md me mf mg b">ref</code>的DOM节点的属性的人。现在当<code class="fe md me mf mg b">App</code>第一次渲染时，你会看到一个空的<code class="fe md me mf mg b">input</code>框和一个<code class="fe md me mf mg b">Submit</code>按钮。当你向它输入一些东西时，它会记住这个值并显示出来。但是在代码中，你不会有任何关于值类型的信息。为了获得类型化的值，我们必须从DOM中"<strong class="kk io">提取"</strong>数据。参见<code class="fe md me mf mg b">Submit</code>按钮的<code class="fe md me mf mg b">onClick</code>。它显示一个报警，其值存储在<code class="fe md me mf mg b">input</code>框中。这里的<code class="fe md me mf mg b">inputRef</code>用于从DOM中提取数据。</p><p id="a42a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">这里发生了什么？</strong></p><p id="5afc" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">DOM维护自己的内部状态，当您在输入框中键入一些值时，它会得到更新。然后,<code class="fe md me mf mg b">input</code>组件读取更新后的状态并显示值。所以这种类型的组件是<strong class="kk io">不受控制的</strong>，因为DOM正在为组件管理数据。要访问这些数据，我们只需单击Submit按钮就可以从DOM中读取。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="4f9a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">不受控制的组件允许您创建元素，而无需立即管理它们的状态。然而，这限制了你使你的UI成为所谓的“<strong class="kk io">反应式</strong>”的能力</p><p id="7ba2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">考虑这个场景:<em class="lj">您想要构建一个表单，让您的用户订阅您的博客，这样当您发布一些有趣的博客时，他们可以收到电子邮件。该表单将有一个输入框，让用户填写他们的电子邮件，并提交按钮，以确认提交。您有一个特殊的请求——只有当用户在输入框中填写了有效的电子邮件时，您才会启用提交按钮。这可以让用户在你的网站上有一个没有错误的体验。</em></p><p id="ffda" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们想想如何解决这个问题。我们必须时刻关注用户输入的电子邮件值，验证电子邮件，并动态启用按钮。所以你会写这样的东西:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Controlling button state with Uncontrolled Component</figcaption></figure><p id="8b90" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您会注意到，这还不完整。因为在<code class="fe md me mf mg b">button</code>组件中，我们不知道如何根据邮件值动态启用按钮。另外，<code class="fe md me mf mg b">refs</code>不触发组件的重新渲染(这就是<code class="fe md me mf mg b">refs</code>的意思)😐 ).我们只能通过点击提交按钮来访问电子邮件值，但是如果它被禁用了，我们怎么能点击呢(哦，上帝，我们都做了些什么😅).</p><p id="c1b9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这就是我正在谈论的问题。对于不受控制的组件，您可以访问状态中的组件值，这样您就无法知道它们是何时更改的。因此，您不能让您的UI<strong class="kk io"/>与不受控制的组件“反应”。这就是<strong class="kk io">控制的</strong>部件来救援的地方。</p><h1 id="d579" class="mh mi in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">受控组件</h1><p id="3a49" class="pw-post-body-paragraph ki kj in kk b kl nf kn ko kp ng kr ks kt nh kv kw kx ni kz la lb nj ld le lf ig bi translated">受控组件接受两个道具-</p><ul class=""><li id="c6de" class="ln lo in kk b kl km kp kq kt lp kx lq lb lr lf nk lt lu lv bi translated">prop1 —告知组件的当前值</li><li id="d1f8" class="ln lo in kk b kl lw kp lx kt ly kx lz lb ma lf nk lt lu lv bi translated">prop2 —更改该值的回调</li></ul><p id="7186" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">值受控部件触发回调更新值… </strong></p><p id="ca8f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这些组件遵循上述周期来反映数据变化。下面是<strong class="kk io">受控组件的例子:</strong></p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Controlled Component</figcaption></figure><p id="b93d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在上面的例子中，<code class="fe md me mf mg b">input</code>框的值是通过<code class="fe md me mf mg b">value</code>属性传递的。<code class="fe md me mf mg b">onChange</code>回调用于更新<code class="fe md me mf mg b">input</code>中的变化，更新<code class="fe md me mf mg b">value</code>道具。现在<code class="fe md me mf mg b">App</code>组件知道了电子邮件的值，并且可以验证和执行<strong class="kk io">“反应式”</strong>想要做的任何事情。</p><p id="a3f0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">这里发生了什么？</strong></p><p id="aae6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我知道看着它可能听起来让人不知所措。但是不要担心，我会告诉你更新是如何发生的。</p><ol class=""><li id="e01e" class="ln lo in kk b kl km kp kq kt lp kx lq lb lr lf ls lt lu lv bi translated"><strong class="kk io">第一次呈现</strong> —当组件第一次加载时，它会将状态中存储的初始值传递给盒子。对于<code class="fe md me mf mg b">input</code>，<code class="fe md me mf mg b">value</code>道具永远是真理的源泉。如果你仔细注意，我们已经传递了一些初始值给<code class="fe md me mf mg b">useState()</code>。所以首先，当我们经过它时，它会显示<code class="fe md me mf mg b">Initial Value</code>字符串。</li><li id="3d4b" class="ln lo in kk b kl lw kp lx kt ly kx lz lb ma lf ls lt lu lv bi translated"><strong class="kk io">你把整个单词</strong>删掉——当<code class="fe md me mf mg b">input</code>有任何变化的时候，回调总是被调用。所以当我们把整个世界删除后，<code class="fe md me mf mg b">onChange</code>就会被调用。在<code class="fe md me mf mg b">onChange</code>我们会收到<code class="fe md me mf mg b">event</code>道具。当我们删除<code class="fe md me mf mg b">input</code>框中的单词时，它触发了一个事件来调用<code class="fe md me mf mg b">onChange</code>回调。这个<code class="fe md me mf mg b">event</code>对象存储由<code class="fe md me mf mg b">input</code>在删除时触发的事件(你可以在MDN <a class="ae kh" href="https://developer.mozilla.org/en-US/docs/Web/API/Event" rel="noopener ugc nofollow" target="_blank"> docs </a>中读到事件)。为了在事件被触发时访问值<code class="fe md me mf mg b">input</code>，我们通过<code class="fe md me mf mg b">event.target.value</code>来访问它。现在，这个值由<code class="fe md me mf mg b">setValue</code>函数在我们的状态中更新。当我们的状态改变时，它触发<code class="fe md me mf mg b">App</code>重新渲染。由于这种重新渲染，传递给<code class="fe md me mf mg b">input</code>框的<code class="fe md me mf mg b">value</code>属性得到更新，因此我们看到了更新后的值。这发生得非常快；它看起来是实时的。</li><li id="5fba" class="ln lo in kk b kl lw kp lx kt ly kx lz lb ma lf ls lt lu lv bi translated"><strong class="kk io">你输入‘a’</strong>—如步骤2所述，同样的循环再次进行。<code class="fe md me mf mg b">onChange </code>回调将被触发并更新状态。状态改变将导致<code class="fe md me mf mg b">App</code>重新渲染并更新<code class="fe md me mf mg b">value</code>道具收件箱。</li></ol><p id="8908" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们回到我们面对<strong class="kk io">不受控组件的问题。</strong>我们无法动态切换按钮的“开”或“关”。通过控制输入状态并将其作为用户类型进行验证，我们可以很容易地做到这一点。请参见下面的代码:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Controlling button’s state with email value</figcaption></figure><p id="aa39" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">简而言之，<strong class="kk io">受控组件</strong>让您能够控制传递给某个组件的数据，最终让您能够以<strong class="kk io">“反应式”</strong>方式执行操作。</p><h1 id="5f53" class="mh mi in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">结论</h1><p id="38b1" class="pw-post-body-paragraph ki kj in kk b kl nf kn ko kp ng kr ks kt nh kv kw kx ni kz la lb nj ld le lf ig bi translated">现在，您应该已经了解了这两种类型组件的要点。现在，您可以应用这些知识来确定您想要使用哪个组件。我总是建议你知道你的组件的用途，并相应地使用它们。</p><p id="f704" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这是我第一次尝试写博客。希望你喜欢它。请在评论中分享你的反馈。如果你喜欢它的内容，请关注更多这样有趣的博客帖子。</p><p id="1d7e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lj">更多内容尽在</em><a class="ae kh" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lj">plain English . io</em></a></p></div></div>    
</body>
</html>