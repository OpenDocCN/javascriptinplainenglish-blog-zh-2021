<html>
<head>
<title>Create an AutoFocus/AutoSelect Hook with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React创建自动对焦/自动选择挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-an-autofocus-autoselect-hook-with-react-856ca260b2f5?source=collection_archive---------2-----------------------#2021-09-30">https://javascript.plainenglish.io/create-an-autofocus-autoselect-hook-with-react-856ca260b2f5?source=collection_archive---------2-----------------------#2021-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5e91898ce29c656dc8803126a1fe846f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LkQgs6sjo3LnQnR4"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@japhethmast?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Japheth Mast</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a586" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不熟悉钩子，或者想看一个有趣的例子，本文将演示如何将一些通用代码抽象成钩子，以便在您的代码中反复使用。</p><h2 id="3261" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">使用自动聚焦挂钩</h2><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="95ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们解开这段代码，因为有很多事情要做。首先，一个钩子只是一个需要在函数的每一次渲染中在<a class="ae jz" href="https://reactjs.org/docs/hooks-rules.html#only-call-hooks-from-react-functions" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">上运行的函数。</strong></a>当我们看到下面的组件代码时，我们将看到如何运行它。现在，只要理解这个钩子是一个函数，它接受一个参数，这个参数将决定当我们选择它时，我们是否想要选择和高亮显示输入中的文本。</p><p id="319b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第5行和第7行，我们创建refs来保存值。T <strong class="kc io">第5行的ref确保一旦isSelectText的初始值被传入，它就不会被更改。我们需要这样做，以便useEffect在</strong> <a class="ae jz" href="https://github.com/facebook/react/issues/14920" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">下面，这样linter就不会抛出关于缺少依赖项的警告</strong> </a> <strong class="kc io">。</strong></p><p id="87c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第10行是一个检查，以确保我们不会得到一个空引用(这是不应该发生的)。<strong class="kc io">之后，我们聚焦文本框，然后根据传入钩子的内容选择或不选择文本(isSelectText)。</strong></p><p id="7edb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">最后，我返回一个具有属性‘ref’的对象，它包含我们关注的输入元素ref。有些人可能不同意我返回一个对象而不是一个数组的决定，但是我认为这严重限制了使用对象析构所能达到的代码的整洁。</strong></p><h2 id="8c1c" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">使用useAutoFocus挂钩</h2><p id="70c1" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">现在我们有了钩子，让我们把它用在一个简单的输入上，看看它的神奇之处。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d363" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">在第14行，我调用了钩子并析构了返回值。这允许我将从钩子返回的对象的“ref”属性传递给子元素/组件。</strong>如果您不喜欢全部放在一行中，您可以很容易地调用return语句上面的钩子，并将ref={ &lt; ref &gt; }赋给input元素。</p><h2 id="23d5" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">包扎</h2><p id="ae08" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">我希望你喜欢阅读这篇文章和我的钩子。请在您的代码中自由使用此代码，并根据您的需要进行修改。另外，如果你想看到更多类似的内容，请留下一些掌声并关注我。编码快乐！</p><p id="9350" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回购:<a class="ae jz" href="https://github.com/doughill1000/auto-focus-hook" rel="noopener ugc nofollow" target="_blank">https://doughill1000.github.io/auto-focus-hook/</a></p><p id="3445" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">工作实例:<a class="ae jz" href="https://doughill1000.github.io/auto-focus-hook/" rel="noopener ugc nofollow" target="_blank">https://doughill1000.github.io/auto-focus-hook/</a></p><p id="b246" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>