# 用 Jasmine 编写单元测试时要注意的 15 件事

> 原文：<https://javascript.plainenglish.io/15-things-to-cover-when-writing-unit-tests-in-jasmine-b309e0c27115?source=collection_archive---------3----------------------->

## 了解一些我认为每个开发人员在用 Jasmine 编写单元测试时应该涉及的内容。

![](img/e13cfbdae35e1dfc1b9099bb35c257db.png)

Photo by [**Markus Spiske**](https://www.pexels.com/@markusspiske?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) from [**Pexels**](https://www.pexels.com/photo/text-2004161/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

在这篇文章中，我将分享你在 Jasmine 中为 Angular 应用程序编写单元测试时可以做的 15 件事。

## **内容**

1.  [**测试功能被称为**](#848a)
2.  [**检测字段被更新**](#1ea9)
3.  [**测试功能结果**](#e308)
4.  [**测试 Getters 和 setter**](#e5ec)
5.  [**测试订阅量和可观察量**](#cbb1)
6.  [**测试自己的异步函数**](#c8d2)
7.  [**测试导航**](#7816)
8.  [**测试模态**](#5104)
9.  [**测试本地存储**](#12cd)
10.  [**测试上推组件**](#9c1d)
11.  [**测试变化检测器**](#e407)
12.  [**测试构造函数中的**](#0436)
13.  [**测试构造函数中的变化检测器**](#f943)
14.  [**测试*不可变. js* 数据**](#d213)
15.  [**用测试线束测试第三方组件**](#c6f0)

## **1。测试功能被称为**

可能最常见的单元测试是测试一个函数在另一个函数中被调用。它可以是组件或服务上的功能。为此，我们在我们期望被调用的函数上创建一个 spy，并使用`**toHaveBeenCalledWith()**`监听和检查它是否被调用

您也可以使用`**not.toHaveBeenCalledWith()**`检查函数是否被调用

你也不必把间谍的结果赋给一个变量。你可以用这种方式来检查间谍

您也可以通过将间谍的返回类型设置为`**any**`并使用对象键符号而不是点符号来获取对函数的引用来监视私有函数，如下所示

## 2.测试字段已更新

可能第二个最常见的测试是测试组件字段的值在某个函数被调用后是否被更新。

首先，我们初始化该字段的值，然后执行函数并检查新值。

## 3.测试功能结果

您还需要检查您的函数是否为不同的输入产生了正确的结果。您只想检查键值，但要由您来决定尝试什么和多少输入，尝试所有不同的可能组合是浪费时间。

您的单元测试可能如下所示。

## 4.测试吸气剂和沉降剂

您也可以测试组件中的吸气剂和沉降剂。假设我们有下面的 getter 函数。

您可以像调用任何其他函数一样在您的单元测试中调用 getter，但是不要像这样在末尾添加括号

您也可以测试 setter 函数。假设您有以下设置程序。

您可以通过给单元测试赋值来调用设置器。

## 5.测试订阅和可观察项

当可观测值发出新值时，您可以测试调用了正确的函数并且更新了正确的字段。

当测试异步代码时，您需要等待一个可观察的完成并完成发射值，或者等待某个时间`**x**`它发射下一个值，然后您需要在`**fakeAsync()**`中包装您的单元测试并使用`**tick().**`这模拟时间的流逝并跳到所有异步代码完成的时候，或者某个时间以后的`**x**` 。然后，您可以直接测试结果，实际上不必等待观察到的结果。您的单元测试将如下所示

处理异步代码的旧方法是将测试包装在`**async()**` 中，并使用`**fixture.whenStable().then(() => {})**` 实际上等待所有当前活动的订阅完成。新的方法使这些可观察到的东西立即发出它们的值，并加速你的单元测试。

假设我们有下面的例子，当用户在最后半秒钟没有在搜索输入中键入任何内容时，我们使用`**debounceTime(500)**`调用函数`**getFirstPage()**` 。

我们需要在`**fakeAsync()**`中包装我们的测试，发出一个新值，然后使用`**tick(500)**` **等待半秒钟。然后我们可以检查是否已经调用了`**getFirstPage()**`。使用`**tick()**` 而不指定一个值是行不通的，因为管道`**debounceTime()**`永远不会完成它自己，并将继续发出新的值，所以我们需要跳过一段时间。**

你用完全相同的方式测试`**setTimeout(() => {},x)**`。你需要通过使用`**tick(x)**` **在单元测试中等待函数被调用。**

## 6.测试您自己的异步函数

您还可以测试自己的异步函数，这些函数返回一个可观察的。这最常用于测试当您进行 API 调用时会发生正确的事情。假设在组件`**ngOnInit()**`初始化期间订阅了一个异步函数，如下所示。

我们需要检查函数`**handleData()**`是否被调用，字段`**data**`是否被设置。

我们首先需要确保订阅是通过调用`**ngOnInit()**`创建的。在这种情况下，当您创建组件时，这已经在组件初始化期间被调用，这应该已经在`**beforeEach()**`块中完成。

现在我们需要释放一个新的价值。有两种方法可以做到这一点，通过在我们的测试中创建一个主题，并使用一个 spy 来临时使`**getData()**` 返回这个主题或它的可观察对象。然后我们可以用这个主题来产生一个新的价值。我们也可以编辑我们模仿的`**apiService**` 并在其中创建一个新的私有主题，然后更改`**getData()**` 使其返回该主题的可观察值。

然后在单元测试中，我们只需抓取我们刚刚创建的主题`**getDataSubject**` 并发出一个新值。检查`**handleData()**`函数是否被调用的单元测试可能如下所示

## 7.测试导航

为了测试 Angular 应用程序中的导航路线是否正确，您首先需要设置您的测试环境，以使用与生产应用程序相同的导航路线，这可以在您的测试床上使用`**RouterTestingModule**`来完成。

假设我们有以下路由，并想测试我们是否可以导航到/home 路径。

在单元测试中，我们将认证服务的`**canActivate()**`方法设置为返回 true，这样用户就可以导航到这个路径。然后我们尝试使用`**router.navigate()**` 进行导航，以检查/home 是否是有效路线。然后使用 tick 等待导航完成。单元测试看起来会像这样

## 8.测试模型

当我们处理一个使用模态的组件时，我们需要确保模态首先被显示，否则当我们试图使用`**querySelector()**`获取它时，我们什么也找不到。

在包含模态的组件的单元测试文件中，在`**beforeEach()**` 块中，您可以确保`**display**` CSS 属性设置正确，并应用您需要的任何类来使模态出现。然后再次调用`**detectChanges()**`更新 UI。现在你可以使用`**querySelector()**` 从 UI 中抓取模态。

## 9.测试本地存储

您也可以在单元测试中测试本地存储。我们实际上并不测试本地存储是否返回并保存正确的值，而是测试函数本身是否被调用。

为了测试一个函数是否保存了一些东西到本地存储器，你可以检查是否用正确的键和值调用了`**setItem()**`函数。

为了测试一个函数从本地存储中加载了什么，你可以检查是否用正确的键调用了`**getItem()**`函数。

## 10.测试推送组件

推式组件是那些将变更检测策略设置为`**OnPush**`的组件。这意味着只有当字段被分配了新的引用时，UI 才会自动更新，并且如果字段的值被更改，UI 不会总是更新。

因此，如果像字符串这样的不可变字段被更新，它就会更新，但如果像数组这样的可变字段被更新，它就不会更新。这有助于防止 UI 随着每一个微小的变化而不断更新，最终使它变得更加反应迟钝。

目前，有一个长期悬而未决的问题，能够测试推组件在角度。当你使用`**componentFixture.detectChanges()**`时，它只在你第一次使用时更新用户界面，之后就不再工作了。

[https://github.com/angular/angular/issues/12313](https://github.com/angular/angular/issues/12313)

这意味着目前不可能测试按下行为。目前我们唯一能做的就是完全禁用单元测试中的推送功能，并在设置测试平台时，将单元测试中的变更检测策略设置回默认值。至少这样您可以继续其他单元测试，因为`**componentFixture.detectChanges()**` 将再次正确工作。

## 11.测试变化检测器

当组件字段更新时，更改检测器自动更新 UI，但是您可以通过分离更改检测器并调用`**detectChanges()**`手动更新 UI 来更改它，以便它仅在您想要时更新。这有助于保持应用程序的响应性，因为在每次小的更改后都不会重新加载数据。

例如，我们可能有下面的代码，其中我们加载一些数据，最后，我们更新用户界面。

但是如果我们在组件中分离变更检测器，那么在单元测试中使用`**componentFixture.detectChanges()**`将不再有效。

相反，我们需要获取对组件中使用的变化检测器的引用，并在其上调用`**detectChanges()**` ，如下所示。

```
**component['_cdr'].detectChanges();**
```

另外，如果您想测试在您的组件中调用了`**detectChanges()**`方法，您可以像这样在您的单元测试中监视变更检测器。

## 12.在构造函数中测试函数

您可能希望在组件的构造函数期间调用测试函数，但是构造函数只在您创建组件时调用一次，这通常在单元测试运行之前在`**beforeEach()**`块中完成。

这使得在构造函数中测试任何东西变得不可能，但是我们能做的就是在单元测试中使用测试床创建另一个组件。这将至少允许我们测试任何正在使用的服务。

假设我们有下面这个名为`**MyComponent**`的组件的构造函数。

我们首先监视测试中使用的服务的功能`**getData()**`，然后使用测试床创建一个使用相同服务的新组件。

## 13.测试构造函数中的变化检测器

我们已经看到了如何编写单元测试来检查 UI 是否更新。但是假设我们在构造过程中更新 UI 或者分离变更检测器，我们之前做的就不行了。

相反，我们需要使用组件的服务注入器获取对变更检测器服务的引用，然后我们可以窥探变更检测器的功能。假设我们有下面这个名为`**MyComponent**`的组件的构造函数。

检查变更检测器是否被分离的单元测试将是

## 14.测试*不可变. js* 数据

当您使用 immutable.js 库时，您可能会遇到试图使值相等的问题。这是因为使用的数据结构不同。假设我们有下面的单元测试，其中我们试图使用`**toEqual()**`使一些数据相等。以下测试不起作用。

为了解决这个问题，我们需要使用不可变. js 库中的等式操作符`**is()**`，如下所示。

## 15.使用测试工具测试第三方组件

Angular 9 中引入了组件工具，它为用户提供了一种简单的方法来测试他们的应用程序在使用你创建的组件时是否工作正常。

组件线束需要由组件库(如 Angular Material)的作者创建，因此可能不适用于所有库。

之前，您需要知道组件的具体实现和结构，以便找到并获取它显示的标签，并通过使用大量查询来检查它的设置是否正确。例如`**fixture.debugElement.query()**`

组件装具现在允许您通过使用装具上的一个属性轻松地获取这个标签，并且您不再需要担心您的测试在它们对组件进行任何更改时会中断。

您使用 HarnessLoader 来获取组件的线束，然后您可以轻松地获取不同的属性并轻松地模拟用户交互，例如用户通过简单地调用一个方法来单击和选择下拉列表中的选项。

*更多内容看*[*plain English . io*](http://plainenglish.io/)