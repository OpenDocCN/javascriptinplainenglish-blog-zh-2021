<html>
<head>
<title>Learn to Build a Web Scraper in an Evening</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学会在一个晚上建立一个网络刮刀</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learn-to-build-a-web-scraper-in-an-evening-6a9d2c3862c?source=collection_archive---------9-----------------------#2021-04-14">https://javascript.plainenglish.io/learn-to-build-a-web-scraper-in-an-evening-6a9d2c3862c?source=collection_archive---------9-----------------------#2021-04-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi jr"><img src="../Images/43ebff2da3c26c63fc3e4c23ee19dca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vxcenjrK3BGEyxRi"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Photo by <a class="ae kh" href="https://unsplash.com/@jefflssantos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jefferson Santos</a> on <a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3069" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果你一直想建立一个网页抓取器，或者只是好奇它是如何完成的，我已经创建了这个简单的教程来帮助你开始。在本教程中，你将学习网络抓取的基础知识。尽管本教程使用了JavaScript/Node.js，但是这里使用的概念对于所有编程语言都是一样的。所以，如果你想要一个不做任何假设的教程，你就来对地方了。</p><h2 id="760f" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">项目设置</strong></h2><p id="4ec5" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">首先，让我们安装Node.js. Node.js是一个JavaScript运行时，使我们能够在浏览器之外运行JavaScript。每个浏览器都有一个JavaScript引擎，这样它就可以执行网站上的JavaScript代码。一个叫<a class="ae kh" href="https://en.wikipedia.org/wiki/Ryan_Dahl" rel="noopener ugc nofollow" target="_blank"> Ryan Dhal </a>的家伙拿出chrome浏览器中的JavaScript引擎，并在其上构建了所谓的Node.js。因此，我们可以像本地计算机一样在非浏览器环境中运行JavaScript代码。为了能够在你的计算机上运行JavaScript，你只需要安装Node.js</p><p id="1148" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，不同的操作系统遵循稍微不同的方法来安装JavaScript运行时。要为您的操作系统安装，请访问<a class="ae kh" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">官方Node.js网站</a>，并按照您的操作系统的说明进行操作。</p><p id="da1b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一旦解决了这个问题，您应该验证安装是否顺利进行。一种方法是检查安装的Node.js的版本。卷起您的终端或命令提示符并运行命令:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="90c6" class="lh li in mg b gy mk ml l mm mn">node --v</span></pre><p id="a331" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您应该看到安装的Node.js版本与我的版本一样，如下所示:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi mo"><img src="../Images/b1e3570202f987b104e7940ab3fa634e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dQ8QyShGVBzQqG85TmLDQ.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Terminal showing node version</figcaption></figure><p id="94b7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">你的版本可能与我的不同，但对我们来说这不是问题。</p><p id="25ad" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">好吧，我们只安装了Node.js，但是npm是和它一起安装的。如果您尝试命令<code class="fe mp mq mr mg b">npm -v</code>，您将看到安装的npm版本。</p><h2 id="79bf" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">那么什么是npm呢？</strong></h2><p id="1ea7" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">NPM是Node.js的包经理，包是由其他程序员编写并提供给我们的代码，以帮助我们做事情，所以我们不必从头开始编写一切。我们将使用这些包来创建我们的web scraper。因此，npm将帮助我们安装和管理这些软件包。</p><h2 id="813f" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">初始化项目</strong></h2><p id="4fa8" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">让我们初始化项目。</p><p id="2310" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">创建一个您选择的文件夹并导航到其中。对我来说，我在我的文档目录中创建了这个文件夹，并将其命名为<strong class="kk io"> web-scraper。</strong></p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi mo"><img src="../Images/913addf34d544abd6bb82dbb9ea2f19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3F3-0c-YvgiTKIvnFCPgnQ.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Empty web-scraper folder</figcaption></figure><p id="1c93" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在启动终端/命令提示符并导航到文件夹。然后运行命令:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="526d" class="lh li in mg b gy mk ml l mm mn">npm init</span></pre><p id="52ed" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">按照说明进行操作，并通过一直按下<strong class="kk io">回车</strong>来接受。如果您确定在项目初始化期间不会对npm提供的默认选项进行任何更改，您可以使用<code class="fe mp mq mr mg b">--y</code>标志来初始化项目。那就是:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="44ba" class="lh li in mg b gy mk ml l mm mn">npm init --y</span></pre><p id="9edd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这告诉npm简单地使用缺省值，不要等待我们继续按回车键。</p><p id="0983" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">运行该命令后，您将看到npm已经为您创建了一个<strong class="kk io"> package.json </strong>文件。这个文件保存了关于项目的信息，比如项目的名称、作者和版本。请参见下面的文件视图:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="dba2" class="lh li in mg b gy mk ml l mm mn">{<br/>  "name": "web-scraper",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC"<br/>}</span></pre><p id="f5f0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">该文件还记录了我们安装的要在项目中使用的所有包。我们无法在文件中找到包列表，因为我们还没有安装任何包。为了创建我们的web scraper，我们需要两个包来使用:<strong class="kk io"> axios </strong>和<strong class="kk io"> cheerio。</strong>让我们通过运行以下命令来安装它们:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="d698" class="lh li in mg b gy mk ml l mm mn">npm i axios cheerio</span></pre><p id="8602" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这将为我们安装这两个包。再次查看<code class="fe mp mq mr mg b">package.json</code>文件，我们可以看到这些包已经列在文件的<strong class="kk io">依赖项</strong>部分:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="e543" class="lh li in mg b gy mk ml l mm mn">{<br/>  "name": "web-scraper",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  <strong class="mg io">"dependencies": {<br/>    "axios": "^0.21.1",<br/>    "cheerio": "^1.0.0-rc.6"<br/>  }</strong><br/>}</span></pre><p id="a64e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您还会注意到已经生成了其他文件和一个额外的文件夹。对我们来说重要的是<strong class="kk io"> node_modules </strong>文件夹。这是我们安装的所有软件包将被保存的地方。当我们运行代码时，Node将在文件夹中查找我们的包。如果您怀疑node_modules文件夹已经被篡改，您总是可以使用命令:<code class="fe mp mq mr mg b">npm install</code>重新安装您的所有软件包</p><h2 id="7df4" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">接下来呢？</strong></h2><p id="f910" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">在我们继续之前，我想做一个愚蠢的假设。我假设你对HTML和CSS有所了解。如果你不知道这些是什么，别担心，我会试着给你介绍一下。</p><p id="4e0c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">网页只不过是一个文本文件，包含代表页面结构的元素。HTML是我们用来定义这种结构语言(不是编程语言，lol)。例如，如果我想在浏览器中显示一段文本，HTML为我提供了一个<strong class="kk io">标签</strong>来实现。我的段落看起来会像这样:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="4a34" class="lh li in mg b gy mk ml l mm mn">&lt;p&gt; This is my paragraph text &lt;/p&gt;</span></pre><p id="9b30" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">HTML中的大标题如下所示:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="7a6c" class="lh li in mg b gy mk ml l mm mn">&lt;h1&gt;This is a big heading&lt;/h1&gt;</span></pre><p id="9246" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一个网页可以有几个段落和其他元素。这使得仅仅通过显示数据的标签来识别数据变得非常困难。除了标签之外，HTML还提供了其他属性来唯一地标识元素。可以给一个元素一个id，以将其与其他元素区分开来。例如:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="a649" class="lh li in mg b gy mk ml l mm mn">&lt;p id="p1"&gt; this is a paragraph&lt;/p&gt;</span></pre><p id="0170" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">该段落的id为<code class="fe mp mq mr mg b">p1</code>。这将把它与页面上的其他段落或元素分开。另一个有助于分隔元素的东西是<strong class="kk io">类。</strong>类决定了元素的样式。假设一页上有两个段落:<strong class="kk io"> ParagraphA </strong>和<strong class="kk io"> ParagraphB </strong>。段落可以是绿色的，段落b可以是黄色的。课程帮助我们实现这个目标。人们创建CSS类，定义HTML元素的样式规则，然后将这些类分配给目标元素。在真实的HTML文档中，我们的示例段落看起来会像这样:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="ffdd" class="lh li in mg b gy mk ml l mm mn">&lt;p id="paragraph1" class="green-text"&gt; ParagraphA &lt;/p&gt;<br/>&lt;p class="yellow-text"&gt; ParagraphB &lt;/p&gt;</span></pre><p id="0e71" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您可以看到，ParagraphA有一个id<code class="fe mp mq mr mg b">paragraph1</code>和一个类<code class="fe mp mq mr mg b">green-text</code>，而ParagraphB没有id，但有一个类<code class="fe mp mq mr mg b">yellow-text</code>。关于这两段的信息如下表所示:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/8428b308f2cc6332ded277262d6c2ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*cstUU97NLahPGvsZQ9ApeQ.png"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Showing attributes of the two paragraphs</figcaption></figure><blockquote class="mt mu mv"><p id="c12b" class="ki kj lg kk b kl km kn ko kp kq kr ks mw ku kv kw mx ky kz la my lc ld le lf ig bi translated">重要的是要记住，HTML不是一种会迫使编码人员遵守规则的严格语言。这可以在我们的示例段落中看到。即使ParagraphB没有给定的id，浏览器仍然会显示它。</p></blockquote><p id="c2fe" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">HTML也遵循层次结构。所有元素都包含在<code class="fe mp mq mr mg b">&lt;html&gt;</code>标签中。有些元素通常是容器。它们意味着包含其他元素。例子有:<code class="fe mp mq mr mg b">div</code>、<code class="fe mp mq mr mg b">span</code>、<code class="fe mp mq mr mg b">template</code>、<code class="fe mp mq mr mg b">section</code>等。当你浏览网站时，你会看到这些元素在起作用。</p><p id="986e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，这看起来和你来这里的主要原因有很大的偏离。但是相信我，这很重要。知道如何识别与我们想要的数据相关的所有必要属性是非常重要的。事实上，你制作铲运机的大部分时间都花在了计算这些信息上。</p><p id="a8cb" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这就引出了一个问题:什么是网络抓取？</p><p id="1b9e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Web抓取只是一个复杂的术语，用于简单地识别和提取HTML元素的内容，如我们前面提到的<code class="fe mp mq mr mg b">p</code>和<code class="fe mp mq mr mg b">h1</code>。本质上，web抓取涉及的主要工作是收集更多关于我们想要抓取的数据的信息。</p><h2 id="cbc6" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">刮网在行动</strong></h2><p id="152c" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">我创建了一个简单的<a class="ae kh" href="http://web-scraper-tutorial.netlify.app" rel="noopener ugc nofollow" target="_blank">网页</a>，这样我们就可以一起工作了。我们将在此网页上浏览提取所需数据的过程:<a class="ae kh" href="https://web-scraper-tutorial.netlify.app/" rel="noopener ugc nofollow" target="_blank">web-刮板-tutorial.netlify.app </a>:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi mz"><img src="../Images/a7e18b33cc20d970990279d8815d61f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0D9-J6-q8eqp53PTHWUNg.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Example website created by the author</figcaption></figure><p id="99a3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果您单击链接，您将在浏览器中看到显示的页面。但是我们如何看待HTML标记呢？要查看标记，请按组合键:<strong class="kk io">CTRL+SHIFT+I。</strong>这将在您的浏览器中打开一个新的部分，简称为开发工具或DevTools:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi mz"><img src="../Images/8943a2657e77a81a49d5c6ae00ca79fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUNJQHHlKHH2EO4-80t7Hg.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">The chrome dev tools</figcaption></figure><p id="439b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">DevTools附带了不同的选项卡，要查看HTML标记，请单击元素选项卡(在大多数情况下，元素选项卡可能是默认选项卡)。开发工具窗口中的另一个重要部分是控制台。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi na"><img src="../Images/f961ddad425f6307bb8fc019605aca99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lf5iSmNYD8OS93zZ5W4Jww.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">The Elements and the Console tabs</figcaption></figure><p id="c3d0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">本部分允许我们使用JavaScript与网页交互。如果您不知道JavaScript，请不要担心，我们将在此过程中收集我们需要了解的内容。</p><p id="8f4b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了在页面上看到元素的HTML表示，chrome开发工具附带了一个检查工具。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nb"><img src="../Images/aa6af7e70530b3c4b64cb5cbe8721cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DXa_Ze0FBO7m5x3AFtmhw.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">The inspector</figcaption></figure><p id="7cea" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">单击此工具，转到“新闻标题”文本并单击它。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi mo"><img src="../Images/719e9c7d22d614a22fa9c1705d95948e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Skp7rZmODjxhIACPJH9iwQ.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Headline highlighted</figcaption></figure><p id="1d1c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您会注意到HTML标记在元素部分很快被突出显示。除此之外，您还会注意到，将光标放在页面上的元素上会显示关于这些元素的更多信息:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f077fa6f71e65c09f17e145fde4b960c.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*ToSseBq6JPdWCH1YYHKiwA.png"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Highlighter information</figcaption></figure><p id="bc10" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对我们来说，重要的是:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="bffe" class="lh li in mg b gy mk ml l mm mn">h1.display-4.text-white.mt-5.mb-2</span></pre><p id="b47b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这告诉我们，这个“新闻标题”被包装在h1元素中，并且有4个相关的类。这些类别是:</p><p id="97bf" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">显示-4 </strong>、<strong class="kk io">文字-白色</strong>、<strong class="kk io"> mt-5 </strong>、<strong class="kk io"> mb-2 </strong></p><p id="2c27" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">每节课都以一个点开始。所以如果我们看到一个点，在我们遇到另一个点之前，后面的所有东西都是类名。这就是为什么我们知道h1元素有4个类。我们得到的关于“新闻标题”的所有细节都被称为它的选择器。这很有意义，因为这些项唯一地标识了元素。</p><p id="fa58" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">好吧，让我们试着检查一下网页上我最喜欢的文字，上面写着:“作者已被{ {在此插入您最喜欢的FANG公司}}录用”；</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nd"><img src="../Images/f95867897210f8b3afb89b18aca59c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeGSjH2PClASfGhU_9H91w.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Highlights h2</figcaption></figure><p id="e6f4" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这里，选择器是<code class="fe mp mq mr mg b">h2#favourite</code>。由此我们可以得出，包含文本的元素是<code class="fe mp mq mr mg b">h2</code>但是什么是<code class="fe mp mq mr mg b">#favourite</code>？由于课程以<code class="fe mp mq mr mg b">.</code>开头，所以<code class="fe mp mq mr mg b">favourite</code>不是课程。当<code class="fe mp mq mr mg b">#</code>在前面时，这告诉我们选择器是一个id。因此，本质上，这个突出显示的文本被包装在h2元素中，id为<code class="fe mp mq mr mg b">favourite</code>。您可以使用检查工具继续突出显示页面上的元素，以查看它们的HTML组成。</p><h2 id="7151" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">使用控制台选择元素。</strong></h2><p id="12a3" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">您已经看到了如何使用检查工具来选择和查看页面上每个元素的更多信息。现在，我们将使用控制台来选择这些元素。转到控制台部分，单击进入编辑器并键入代码</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="a7dd" class="lh li in mg b gy mk ml l mm mn">document.querySelector('h2')</span></pre><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ne"><img src="../Images/3b856dac9648ab82e4888858407db158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8_MzaAIQI78wB4_I91lvQ.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">writing Javascript in console</figcaption></figure><p id="8a8a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">代码是JavaScript在页面上选择元素的方式。<code class="fe mp mq mr mg b"><strong class="kk io">document</strong></code> <strong class="kk io"> </strong>是一个保存网页中所有东西(包括元素)的对象，所以要获取任何元素，我们只需使用<code class="fe mp mq mr mg b">querySelector</code>函数向<code class="fe mp mq mr mg b">document</code>请求即可。querySelector函数希望我们提供与相关元素相关联的选择器。我们总是可以使用检查工具，通过突出显示元素来了解元素的选择器。</p><p id="e68c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">该页面有4个段落元素(即包装在<p>标签中的文本)，让我们在控制台中选择这些段落:</p></p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="4102" class="lh li in mg b gy mk ml l mm mn">document.querySelector('p')</span></pre><p id="2ded" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">运行代码后，我们得到以下结果:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/56d2a014c098a24120fe496ccedd6418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*Wx1tMjvLiVkWbxmyepFN6Q.png"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Query all paragraphs</figcaption></figure><p id="b593" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">不幸的是，该命令只返回一个段落。这就是<code class="fe mp mq mr mg b">querySelector</code>功能的工作原理。即使有许多元素具有相同的选择器，它也会返回遇到的第一个。</p><p id="0e5e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果您想返回所有匹配选择器的元素，您应该使用元素查询的不同变体，<code class="fe mp mq mr mg b">querySelectorAll()</code>。</p><p id="4c12" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们试试这个:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="5d8f" class="lh li in mg b gy mk ml l mm mn">document.querySelectorAll('p')</span></pre><p id="2b46" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在控制台中运行该命令将返回一个数组，其中包含与选择器<code class="fe mp mq mr mg b">p</code>匹配的元素。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ng"><img src="../Images/9b05b2a243645790ee520a047495245c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywOjLY1kLFY5_-ZpAclGZw.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Querying all paragraphs</figcaption></figure><p id="f2c8" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">尽管所有的元素都被返回，但是它们伴随着我们不需要的其他数据。那么我们如何得到我们所需要的，比如这些元素的文本属性呢？</p><p id="a377" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一种方法是遍历这些元素并提取文本内容。这可以使用下面的代码来完成:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="efb7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">首先，我们得到一个数组中的所有段落。</p><p id="8a90" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">然后，我们遍历该数组，并使用<strong class="kk io"> innerText </strong>属性提取每个段落的文本内容，并将其保存在变量<strong class="kk io"> text </strong>中。然后，我们将文本打印到控制台。</p><p id="9d3b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这很酷，但大多数网站不会这么容易刮。真正的网站有着复杂的标记和约定，使用普通的JavaScript来处理事情会变得令人不知所措。这就是jQuery发挥作用的地方。jQuery是一个JavaScript库，可以帮助开发人员轻松执行任务。</p><p id="b09d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以使用jQuery轻松找到示例网页的元素。但是有一个问题。除非网页上安装了jQuery，否则不能在网页上使用jQuery。解决这个问题的一个方法是将jQuery注入到您想要抓取的页面中。有几个浏览器扩展可以帮助你做到这一点。</p><p id="cd60" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">转到您的浏览器商店并搜索jQuery injector。对于Chrome商店，我找到了这个:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nj"><img src="../Images/a4531ef8978341c90f57f0faf00bc104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tY33wCF-VabNtMOZzoYJ-w.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">jQuery Injector in the Chrome Store</figcaption></figure><p id="b4e6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">安装它，加载你要刮的页面后注入:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/746f33017f582786627529133b1c5eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*2o1BEdpXfdg2UvtsZc1PVA.png"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Inject jQuery</figcaption></figure><p id="0345" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一旦注入了这些内容，您就可以在控制台中运行下面的代码:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1e4b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这使得它非常简洁。我们不必直接处理文档对象及其方法。此外，jQuery为我们提供了提取数据的便捷方法，比如<code class="fe mp mq mr mg b">.text()</code>函数。如果我们要使用普通的JavaScript，这可以帮助我们减少代码行。如果我们想在一个元素上使用jQuery，我们需要将它包装在<code class="fe mp mq mr mg b">$()</code>函数中。</p><p id="12af" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在让我们获取页面上按钮的文本属性。但是我们需要知道它的选择器，对吗？我将使用检查工具来获取信息。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b3d965cc6599d8876195865042f8072a.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*ckp8i_IDEXUbl_3EENIeLQ.png"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Button highlighted</figcaption></figure><p id="257b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">按钮是一个<strong class="kk io">一个</strong>元素，有3个类，<strong class="kk io"> btn </strong>，<strong class="kk io"> btn-primary </strong>，<strong class="kk io"> btn-lg </strong></p><p id="5753" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在让我们在控制台中查询:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8959" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">而<code class="fe mp mq mr mg b">button</code>的文字已经印在了控制台上。不错吧。</p><p id="f9e3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在按钮的标记中，我们可以看到按钮有一个href属性:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nm"><img src="../Images/ece93b02772371838801fe930ed664c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whspHe-cDONgmSZKPLr2VQ.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">The button markup</figcaption></figure><p id="6c87" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因此，如果我们单击按钮，它会将我们带到<code class="fe mp mq mr mg b">google.com</code>。如果我们想提取那条信息呢？</p><p id="f62e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以用<code class="fe mp mq mr mg b">attr()</code>函数来实现:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8ab3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果您在控制台中运行它，您会看到它打印了属性<code class="fe mp mq mr mg b"><strong class="kk io">href</strong></code>，即<code class="fe mp mq mr mg b"><a class="ae kh" href="https://google.com" rel="noopener ugc nofollow" target="_blank">https://google.com</a></code></p><p id="0197" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们首先找到带有代码的按钮:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="f421" class="lh li in mg b gy mk ml l mm mn">let button = $('a.btn.btn-primary.btn-lg')</span></pre><p id="1130" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">然后我们提取href属性:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="0846" class="lh li in mg b gy mk ml l mm mn">let result = $(button).attr('href')</span></pre><h2 id="0086" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">用Node.js刮取</strong></h2><p id="8358" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">我们可以看到用jQuery抓取网站是多么容易。但这并不实际。这意味着我们每天都要不停地访问这些我们想要抓取的网站，给这些网站注入jQuery，卷起我们的控制台，执行抓取。在现实世界中，人们会创建自动为他们执行这些步骤的服务器。我们将学习如何设置Node.js来为我们执行这个任务。</p><p id="3651" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，回到我们在本教程第一部分创建的文件夹:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi mo"><img src="../Images/4387dbc13e55aff01f4c059d110a231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOV-mPvkYAvxcbe3_MQYVA.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">web-scraper folder</figcaption></figure><p id="352f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">接下来，在文件夹中创建一个文件<code class="fe mp mq mr mg b">index.js</code>:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi mo"><img src="../Images/38f596138471d268b68ce5205a7c8557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fJTlLVNtPw6kWuv7NwLDQ.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Creates index.js</figcaption></figure><p id="054d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">从现在开始，我们将要编写的代码将在这个文件中。</p><p id="2214" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在您最喜欢的文本编辑器中打开index.js，并编写以下代码:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="7992" class="lh li in mg b gy mk ml l mm mn">const cheerio = require('cheerio')<br/>const axios = require('axios')</span></pre><p id="256e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果你还记得，在开始的时候，我们安装了这两个包。我们现在做的是将这两个包导入到我们的项目中。</p><h2 id="3913" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">那么这两个包是干什么用的呢？</strong></h2><p id="8582" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">网络搜集包括两个基本步骤:</p><ul class=""><li id="be58" class="nn no in kk b kl km kp kq kt np kx nq lb nr lf ns nt nu nv bi translated"><em class="lg">获取我们想要抓取的网页</em></li><li id="ef7d" class="nn no in kk b kl nw kp nx kt ny kx nz lb oa lf ns nt nu nv bi translated"><em class="lg">从网页中选择并提取数据</em></li></ul><p id="ab4c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">之前，我们使用浏览器来获取网页，并使用jQuery来选择和提取数据。Axios和Cheerio在Node.js环境中的工作方式相同。Axios将帮助你获得一个无标题的网页，Cheerio的工作方式与jQuery相同。事实上，Cheerio是一个面向服务器的jQuery实现。</p><p id="f059" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们使用axios加载我们的网页:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="acb1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们创建了一个名为<strong class="kk io"> main </strong>的函数，并在其中使用<code class="fe mp mq mr mg b">axios.get()</code>函数来获取网页的内容。实际上，axios返回一个响应对象，但是我们只需要数据属性，所以我们用这个<code class="fe mp mq mr mg b">{data}</code>析构该对象并检索数据，然后我们在函数的最后一行将它打印到控制台。</p><p id="338d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您会注意到代码中完成的<strong class="kk io">异步/等待</strong>仪式。因为axios获取我们的网页需要一些时间，所以我们不得不告诉node js等待资源。必须等待异步工作的方法必须用async关键字标记。</p><p id="7888" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">要运行我们的代码，请在您的终端/命令提示符下运行命令:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="561a" class="lh li in mg b gy mk ml l mm mn">node index.js</span></pre><p id="5a65" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">确保您位于自己创建的文件夹中。它应该打印页面的HTML表示。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi mo"><img src="../Images/93076d8e500116089949f49f36dccc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hkxHnsokDp97_DYMTx6Kg.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">printing the contents of the page</figcaption></figure><p id="dbe8" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如上所示，我们可以成功地检索我们的网站资源。让我们使用Cheerio与这个HTML进行交互，并提取我们需要的数据:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f9c8" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">由于页面的HTML存储在<code class="fe mp mq mr mg b">data</code>中，我们可以使用<code class="fe mp mq mr mg b">cheerio.load()</code>函数将这些数据加载到Cheerio中。该函数返回普通的jQuery函数<code class="fe mp mq mr mg b">$</code>。然后，您可以像我们在浏览器中那样使用该功能。在上面的代码中，我们选择了<code class="fe mp mq mr mg b">a</code>元素并提取了代码为<code class="fe mp mq mr mg b">$('a').text()</code>的文本属性，然后打印出来。</p><h2 id="2300" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">当元素的直接选择器不够用时</strong></h2><p id="8654" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">有时候，仅仅使用元素的选择器是不够的。您经常会遇到具有相同类和标签的不同元素。检查我们的页面，我们可以看到两个段落证明这种情况:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ob"><img src="../Images/866de7d4882075f4ac493a3671373db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfUhzENl5-hN4G_S7-B3-A.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Identical paragraphs</figcaption></figure><p id="f897" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这两段是一样的。它们之间唯一的区别是文本内容。所以查询<code class="fe mp mq mr mg b">$('p.text-primary')</code>将返回这两个段落。</p><p id="a4df" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">假设我们想返回页面上的最后一段。上面写着“这是第三段”的那个。有时，我们可以通过指定数据的父元素来为数据提供更多的上下文。我们可以选择父元素，然后选择目标元素。</p><p id="e4a1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">通过仔细检查元素，我们会注意到这个段落包含在一个具有两个类<code class="fe mp mq mr mg b">container</code>和<code class="fe mp mq mr mg b">bg-secondary</code>的div中:</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b260ea069486170b255dfc65e004cfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*Neg7lHE7_CWfrbi7S2ny3g.png"/></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">paragraph contained in a div</figcaption></figure><p id="3ce1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因此，我们可以告诉Cheerio，我们关心的是这个选定div中包含的段落，而不是可能共享相同选择器的其他许多段落。这很简单，因为:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="77bc" class="lh li in mg b gy mk ml l mm mn">$('div.container.bg-secondary &gt; p.text-warning')</span></pre><p id="81bf" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们用更大的符号<code class="fe mp mq mr mg b">&gt;</code>将两者分开。它告诉Cheerio右边的元素在左边的元素中。</p><p id="1fea" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您可以在NodeJs代码中实现这一点:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="0df5" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">我们可能想就此打住。</h2><p id="c852" class="pw-post-body-paragraph ki kj in kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">但是这就是网络抓取的全部吗？肯定不是！想象一下，你想刮掉脸书墙上的前十个帖子。你不能就这样做:</p><pre class="js jt ju jv gt mf mg mh mi aw mj bi"><span id="edab" class="lh li in mg b gy mk ml l mm mn">let {data} = await axios('https://facebook.com')</span></pre><p id="fb79" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Axios无法知道它将获得谁的帐户。有些资源需要经过身份验证才能获得。这个还没讲。</p><p id="0d70" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">另一件事，一些网站可以检测到它不是一个真正的人在试图访问资源，并有效地阻止访问。一些网站使用验证码来防止僵尸程序。</p><p id="6697" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">网络抓取的主要挑战之一是获取网页。但是一旦你把网页放在地上，选择和提取数据的过程是一样的。开发人员有很多方法可以避开这些措施。一种是使用浏览器自动化工具，如Selenium和Puppeteer。然而，这个概念已经超出了本教程的范围。</p><p id="48bb" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">本教程旨在向您介绍网络抓取的基础知识。你可以随时接受挑战，更加深入。正如所有事情一样，最大的障碍是如何开始。现在你有了开始构建的基本工具。</p><p id="fe46" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">教程的Github repo:</p><div class="od oe gp gr of og"><a href="https://github.com/kastona/web-scraper-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">卡斯托纳/网络刮刀-教程</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">这是我的中型Web Scraper教程- kastona/web-scraper-tutorial的存储库</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kb og"/></div></div></a></div><p id="0d39" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在<a class="ae kh" href="https://twitter.com/stephenkastona" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kh" href="https://linkedin.com/in/kastona" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系。</p><h2 id="199d" class="lh li in bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">进一步阅读</h2><div class="od oe gp gr of og"><a rel="noopener  ugc nofollow" target="_blank" href="/automate-web-scraping-with-an-easy-to-use-browser-extension-cb6073f1e61d"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">使用易于使用的浏览器扩展自动抓取网页</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">如何使用Listly，一个初学者友好的无代码工具，轻松实现web抓取过程的自动化。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="op l"><div class="ov l or os ot op ou kb og"/></div></div></a></div><p id="cb1b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg">更多内容请看</em><a class="ae kh" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="lg">plain English . io</em></strong></a><em class="lg">。报名参加我们的</em> <a class="ae kh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io"> <em class="lg">免费周报</em> </strong> </a> <em class="lg">。关注我们关于</em><a class="ae kh" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="lg">Twitter</em></strong></a><a class="ae kh" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="lg">LinkedIn</em></strong></a><em class="lg"/><a class="ae kh" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="lg">YouTube</em></strong></a><em class="lg"/><a class="ae kh" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="lg">不和</em> </strong> </a> <em class="lg">。</em></p></div></div>    
</body>
</html>