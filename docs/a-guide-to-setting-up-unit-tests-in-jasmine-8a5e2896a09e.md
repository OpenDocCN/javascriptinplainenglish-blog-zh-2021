# 在 Jasmine 中设置单元测试的指南

> 原文：<https://javascript.plainenglish.io/a-guide-to-setting-up-unit-tests-in-jasmine-8a5e2896a09e?source=collection_archive---------11----------------------->

## 了解在 Jasmine 中为 Angular 应用程序编写单元测试时，如何设置和创建一个可重用的测试平台。

![](img/a00b3cc91c9cea219889bf29f9a6f6c2.png)

Photo by [**cottonbro**](https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) from [**Pexels**](https://www.pexels.com/photo/person-using-macbook-pro-beside-white-ceramic-mug-5052875/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

在本文中，我将向您展示如何创建一个可重用的测试床来设置您的单元测试，并在您的 spec 文件中重用它们。

我们将讨论以下内容:

> 什么是测试平台，什么是模拟？我们如何建立一个可重用的测试平台？如何创建模拟组件？如何创建模拟服务？你如何在单元测试中设置你的应用程序路径？如何建立一个测试组件的规格文件？如何为测试服务建立一个规范文件？在编写单元测试之前，我必须模仿所有的东西吗？

## 内容

1.  [**创建可重用的测试床**](#887a)
2.  [**声明:嘲讽成分**](#3f4d)
3.  [**提供者:嘲讽服务**](#9105)
4.  [**导入:模仿内置服务**](#7a3a)
5.  [**设置您的单元测试路线**](#766b)
6.  [**为组件单元测试建立你的规格文件**](#0deb)
7.  [**为服务单元测试设置您的规格文件**](#7f77)
8.  在编写单元测试之前，我必须嘲笑一切吗？

## 1.创建可重用的测试床

我们首先需要创建和设置我们的测试床，这是我们设置和定义测试环境的地方，包括我们单元测试需要的一切。我们定义了我们当前正在测试的组件或服务，我们希望在测试中使用的其他组件和服务，以及运行测试可能需要的任何其他东西。

默认情况下，你的应用程序的所有组件都被自动添加到测试床上，这对于集成测试来说是可以的，但是我们不希望在编写单元测试时这样做。我们只想要我们目前正在进行单元测试的组件，并希望用不做任何事情的空版本替换所有其他组件。我们称这些空组件为模拟组件。

这确保了我们的组件是隔离的，没有其他东西会影响我们正在测试的组件，唯一的变量是我们的组件。我们必须模仿我们的组件和服务。

测试平台有三个主要部分。声明部分、提供者部分和导入部分。

*   在声明部分，我们定义正在测试的组件，并用模拟组件替换应用程序中的所有其他组件。
*   在 Providers 部分，我们定义了正在测试的服务，并用模拟服务替换应用程序中的所有其他服务。
*   在 Imports 部分，我们用正式的测试版本替换了内置的服务，还包含了运行测试所需的任何其他 angular 模块。

在接下来的小节中，我们将更详细地讨论如何创建这些模拟组件和服务。

由于每个单元测试之间唯一不同的是我们当前正在测试的组件或服务，我们可以创建一个可重用的测试床，在那里模拟一切，然后将其导入并复制到我们的 spec 文件中。然后，我们可以用真实的版本替换当前测试组件的模拟版本。这使我们不必每次都重新创建测试平台。

下面是一个测试床的例子，所有的东西都被模拟了，可以导入到每个规格文件中并重复使用。

要使用它，我们可以将`**configureTestingModule()**`导入到我们的 spec 文件中，然后我们可以将正在进行单元测试的当前组件添加到声明部分，它将覆盖并替换模拟版本。

在这个例子中，我们在测试床中覆盖了`**AppComponent**`模拟，并用真正的`**AppComponent**` **替换它。**

## **2。声明:模仿组件**

为了创建一个模拟组件，我们可以删除所有的类型脚本代码和 HTML 模板代码，除了输入和输出的定义以及任何 HTML 模板占位符，如<router-outlet>和<ng-content>。通过保留输入、输出和占位符，它仍然可以在我们测试的其他组件中用作子组件，而不会导致错误。它对这些数据没有任何作用。</ng-content></router-outlet>

下面是一个`**FirstComponent**`的示例模拟版本。我们创建一个新组件，它必须具有与原始组件完全相同的选择器和名称，以便测试床知道替换这个组件。我们定义输入和输出，但不调用任何函数或对它们做任何其他事情。

如果它没有任何输入或输出，那么我们让组件完全为空。然后，我们只需将这个模拟`**FirstComponent**` 添加到测试平台的声明部分。

## **3。提供商:模仿服务**

我们还需要用简单的模拟版本替换我们的服务。但是我们不能在这里使用空的服务，我们需要定义服务中的函数，这样当我们运行单元测试时，组件仍然可以调用这些函数。

但是，我们没有使用真正的函数，而是确保每个函数总是返回相同的值，以确保服务是恒定的，并且不会影响单元测试。如果我们确实想改变服务函数返回的内容，那么我们可以使用`**returnValue()**`在单元测试本身中暂时这样做。

下面是一个名为`**FirstService**`的服务的模拟服务示例。我们创建一个新的服务，它的名称与我们想要替换的服务不同，并修复这些函数返回的值。

然后在测试平台的 Providers 部分，我们声明我们想要用`**FirstServiceMock**` **替换`**FirstService**` 。**

## **4。导入:模仿内置服务**

我们的应用程序中还使用了其他重要的服务，我们也需要用简单的测试版本来模拟和替换它们。幸运的是，这些服务中的大多数都有官方测试版本，包含在同一个库中。

在测试平台的 Imports 部分，我们用正式的测试版本替换了其中的一些关键服务。

*   **HTTPClientTestingModule:**这将使用测试版本替换 HTTPClient 服务。
*   **RouterTestingModule:** 这用测试版本替换了路由，并允许我们为我们的单元测试设置路由。在这里，我们可以只包括我们的正常应用程序路线，以便我们可以测试它们是否正常工作。
*   **BrowserAnimationsModule:**这是您的应用程序正常运行所必需的。当你的 HTML 模板的样式改变时，它会给你的应用添加漂亮的动画。
*   **SharedModule:** 您还应该添加应用程序中使用的所有第三方模块。在这里，我们将它们全部放入一个名为 SharedModule 的模块中，并将其导入到我们的测试床中。

## 5.设置您的单元测试路线

您还需要将应用程序中使用的所有相同路线添加到测试平台中，以便测试应用程序的导航功能是否正常。当您将`**RouterTestingModule**` 添加到测试平台的导入部分时，您可以添加它们。假设您有一些名为`**routes**`的路线，那么您可以像这样添加它们

## 6.为组件单元测试设置规格文件

在这一节中，我将向您展示如何设置您的 spec 文件，以便您可以为名为`**FirstComponent**`的组件编写单元测试。我们要做的第一件事是将模拟的`**FirstComponent**`添加到测试平台的声明部分，用真实版本的`**FirstComponent**` 替换它。在每个单元测试运行之前，我们通过将它放在一个`**beforeEach()**`块中来实现这一点。

然后，我们使用测试床创建组件，并将其保存到一个名为`**component**`的变量中，然后使用`**fixture.detectChanges()**`更新 UI。然后，您可以访问该组件上的任何公共字段和方法。

## 7.为服务单元测试设置规格文件

在这一节中，我将向您展示如何设置您的 spec 文件，以便您可以为名为`**FirstService**`的服务编写单元测试。我们设置它的方式与我们为一个组件编写单元测试时略有不同。我们首先必须将我们的模拟`**FirstService**`添加到测试平台的 providers 部分，用我们的真实`**FirstService**`替换它。我们确保在每个单元测试运行之前这样做，将它放在一个`**beforeEach()**`块中。

我们使用`**TestBed.inject()**`在测试床中获取对服务的引用，然后我们可以访问这个服务的公共字段和方法。

## 8.在编写单元测试之前，我必须模仿所有的东西吗？

不，在编写单元测试之前，您不必马上模拟所有的东西，您只需要模拟您想要进行单元测试的组件中使用的子组件和服务。

事实上，在为每个组件编写单元测试并最终模拟它们时，您可以随着时间的推移构建您的测试床。如果您向模拟服务添加新的函数，您将需要保持模拟服务是最新的，否则当您运行单元测试时，会出现函数未定义的错误。

如果您忘记模拟子组件或服务，那么您可能会在其他组件或服务中出现错误，而这些错误甚至不会被您正在进行单元测试的组件所使用。

*更多内容请看*[*plain English . io*](http://plainenglish.io/)