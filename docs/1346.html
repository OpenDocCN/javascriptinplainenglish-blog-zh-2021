<html>
<head>
<title>Real World Use Cases for Heaps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆的真实用例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/real-world-uses-cases-for-heaps-e57edbeb7da3?source=collection_archive---------12-----------------------#2021-03-21">https://javascript.plainenglish.io/real-world-uses-cases-for-heaps-e57edbeb7da3?source=collection_archive---------12-----------------------#2021-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7022" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">以及如何用JavaScript实现它们</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7128c5df9f5d514f75b91b9c5e4766ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLuOzweqg8rrz6NKdkjqmQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A heap is a specialized version of a Binary Tree</figcaption></figure><h1 id="1a80" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">介绍</h1><p id="9f7a" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">那么什么是堆呢？堆只是二叉树数据结构的一个非常特殊的版本。记住，二叉树的主要特征是每个节点最多有两个子节点。因此，每向下移动一级，节点数就会翻倍。</p><p id="2a5c" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">堆将这个定义向前推进了一步，除了每个节点只有两个子节点之外，每个父节点还必须大于(最大堆)或小于(最小堆)它的两个子节点。最大或最小堆的目的是，当数据添加到结构中时，它允许我们实时跟踪一组数据中的最大值或最小值。</p><h1 id="445d" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">我会在哪里使用堆呢？</h1><p id="70c5" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">堆在“现实世界”中最常用于一种叫做优先级队列的东西中。如果你熟悉标准的队列数据结构(如果不熟悉，我在这里写了通过链表实现一个<a class="ae ml" href="https://medium.com/swlh/real-life-example-of-a-linked-list-8f787b660b3f" rel="noopener"/>)你会发现添加到队列中的数据遵循先进先出(FIFO)模式，即按照添加的顺序移除数据。</p><p id="1a74" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在优先级队列中，情况并非总是如此，因为队列中的一些项目比其他项目具有更高的优先级。这实际上是现实世界中比简单的FIFO列表更常见的做法。假设你在工作中有一堆任务要完成。你有一个待办事项列表，当任务分配给你时，你可以在上面添加任务。如果你能一次只做一件事，随着任务的增加把每一件都划掉，直到你完成清单，那会很好，然而这很少发生。</p><p id="d806" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">你经常在工作中开始做一件事情，突然你的老板把你叫进来，说“放下你正在做的事情，我们有紧急情况需要你所有的注意力。”</p><p id="6227" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">这实际上就是优先级队列。即使你的待办事项清单上还有7件其他的事情，你的老板给你的新任务会突然优先于所有其他的事情，并且直接跳到清单的最前面。</p><h1 id="9e0a" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">用JavaScript构建优先级队列</h1><p id="dfd3" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">让我们继续这个待办事项列表的例子，我们可以给列表中的每一项分配一个优先级，这样它就可以在我们的队列中正确排序。为此，我们将利用一个将在JavasScript中构建的MinHeap类。我选择了一个MinHeap，因为我们将为项目分配最高优先级a 1，最低优先级a 5。你可以很容易地使用一个最大堆，只需翻转优先级，使数字越大，优先级越高。</p><h2 id="40f2" class="mm kt in bd ku mn mo dn ky mp mq dp lc lt mr ms le lx mt mu lg mb mv mw li mx bi translated">创建MinHeap类</h2><p id="bfaf" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们将从在一个文件中定义一个MinHeap类开始，我将这个文件恰当地命名为MinHeap.js。</p><p id="03e2" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们需要创建一个构造函数，它将在每次调用“new MinHeap()”时初始化我们的类。构造函数不接受任何参数，但需要创建堆和大小属性，我们将把它们初始化为一个数组，数组的第一项分别为null和0。它看起来会像这样:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="6ad4" class="mm kt in mz b gy nd ne l nf ng">class MinHeap {<br/>  constructor() {<br/>    this.heap = [null];<br/>    this.size = 0;<br/>  }<br/>}</span></pre><p id="728f" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们可以把我们的堆想象成一棵二叉树，这就是它的样子，但是在这个场景中，我们将只使用一个JavaScript数组来存储实际的数据。我将在本文后面解释这是如何工作的。</p><p id="4cff" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们将数组中的第一项初始化为null的原因是为了利用数组索引的工作方式。这样，我们数组中的最小项将始终是this.heap[1]而不是0，最后一项将始终是this.heap[this.size]而不是this.size-1。这样工作起来更容易。</p><h2 id="8897" class="mm kt in bd ku mn mo dn ky mp mq dp lc lt mr ms le lx mt mu lg mb mv mw li mx bi translated">添加到堆中</h2><p id="8c82" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">接下来，我们需要一种向堆中添加数据的方法。我们将通过创建一个。像这样添加函数:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="889f" class="mm kt in mz b gy nd ne l nf ng">class MinHeap {<br/>  constructor() {<br/>    this.heap = [null];<br/>    this.size = 0;<br/>  }</span><span id="d114" class="mm kt in mz b gy nh ne l nf ng">  add(value) {<br/>    this.heap.push(value);<br/>    this.size++;<br/>  }</span><span id="4452" class="mm kt in mz b gy nh ne l nf ng">}</span></pre><p id="28e4" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">该函数将接受一个“值”参数，并利用内置的。JavaScript数组对象上的push方法将该值添加到堆的末尾。我们还会将堆的大小增加1。</p><h2 id="4305" class="mm kt in bd ku mn mo dn ky mp mq dp lc lt mr ms le lx mt mu lg mb mv mw li mx bi translated">变胖</h2><p id="3ef7" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">现在，我们敏锐的读者可能会说“等一下，如果您总是将数据添加到数组的末尾，您将如何保持顺序？”这是一个很好的观点。</p><p id="f015" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">每次向堆中添加数据(或从堆中移除数据)时，我们都需要检查以确保仍然满足堆条件(每个父级最多有2个子级，并且每个父级的值小于每个子级的值)。</p><p id="6b6e" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">让我们用一个例子来思考这个问题。我们将创建以下堆:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="991c" class="mm kt in mz b gy nd ne l nf ng">let heap = [null, 2, 4, 6]</span></pre><p id="6108" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">画出一棵树，看起来像这样:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/89250d90c5e11a3a25eb20c2b18fc7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2scSqATnsAruXWVpYY8vg.png"/></div></div></figure><p id="a96c" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在，假设我们使用add方法将3添加到堆中。</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="69be" class="mm kt in mz b gy nd ne l nf ng">heap.add(3)</span></pre><p id="48c0" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">当我们添加到堆中时，我们将推到堆数组的末尾，它看起来像这样:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="a9e0" class="mm kt in mz b gy nd ne l nf ng">heap = [null, 2, 4, 6, <strong class="mz io">3</strong>]</span></pre><p id="68fd" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">或者像这样的树:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/5af4d76d413248e3bb063557e56329fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeuofQV7g-gaDDv8nXvTtw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Our child node of 3 is smaller than our parent node of 4. This violates our heap condition</figcaption></figure><p id="6f02" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">为了解决这个问题，我们需要交换父节点4和子节点3的位置。这个恢复堆状态的过程叫做堆化，当你在树中向上移动一个节点直到它在正确的位置时，这个过程叫做堆化。</p><p id="adae" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">让我们添加一个对名为。heapifyUp到我们的add函数</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="d89c" class="mm kt in mz b gy nd ne l nf ng">class MinHeap {<br/>  constructor() {<br/>    this.heap = [null];<br/>    this.size = 0;<br/>  }</span><span id="20d8" class="mm kt in mz b gy nh ne l nf ng">add(value) {<br/>    this.heap.push(value);<br/>    this.size++;<br/>    <strong class="mz io">this.heapifyUp();</strong><br/>  }</span><span id="7e8f" class="mm kt in mz b gy nh ne l nf ng">}</span></pre><p id="ad44" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">不，我们需要定义肥胖。记住，这个函数的目标是检查新添加的节点是否小于其父节点的值。如果是，请执行交换。然后我们重复这个过程，直到节点不再比它的父节点小。</p><p id="afb4" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们可以使用以下函数重现这种行为:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="ef76" class="mm kt in mz b gy nd ne l nf ng">heapifyUp() {</span><span id="1fd9" class="mm kt in mz b gy nh ne l nf ng">  let current = this.size;</span><span id="5de9" class="mm kt in mz b gy nh ne l nf ng">  while (current &gt; 1 &amp;&amp; this.heap[getParent(current)] &gt;      this.heap[current]) {</span><span id="e738" class="mm kt in mz b gy nh ne l nf ng">    this.swap(current, getParent(current));<br/>    current = getParent(current);</span><span id="d21f" class="mm kt in mz b gy nh ne l nf ng">  }</span><span id="4e44" class="mm kt in mz b gy nh ne l nf ng">}</span></pre><p id="3971" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在，这是一个很大的摘要，并使用了更多的帮助函数，我们将一个一个地分解。</p><h2 id="76d7" class="mm kt in bd ku mn mo dn ky mp mq dp lc lt mr ms le lx mt mu lg mb mv mw li mx bi translated">二叉树的左右子模式</h2><p id="5b75" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们将利用二叉树中存在的一个很好的模式，以便总是能够获取一个节点的左子节点、右子节点或父节点。</p><p id="9ed5" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">起初这可能并不直观，但是由于二叉树的性质，每个子节点的索引位置很容易根据父节点的引入位置来计算。让我们来看看:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/cbbd689f6ee142d83a092e68969ca42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIdDACucvSBIy5eUdTi6ZA.png"/></div></div></figure><p id="63ff" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">这里，值为3的节点位于2的索引位置(红色)。你会注意到它的左右两个子节点的索引分别是4和5。</p><p id="fea1" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">另一种纠正方法是，它的子节点位于左侧的(parent_index * 2)位置和右侧的(parent_index * 2 + 1)位置。也为6节点进行检查。这种模式是正确的。</p><p id="feb4" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在反过来，如果你想找到一个节点的父节点的索引，它总是节点的索引除以2，然后四舍五入。例如，值为9的节点的索引为6。因此，它的父代将位于向下舍入为3的6 /2的索引中。对于13节点，它将是7/2，即3.5向下舍入到3。因此，我们可以编写以下函数来查找任何节点的子节点或父节点:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="e823" class="mm kt in mz b gy nd ne l nf ng">const getParent = current =&gt; Math.floor((current / 2));</span><span id="3bd0" class="mm kt in mz b gy nh ne l nf ng">const getLeft = current =&gt; current * 2;</span><span id="e2f9" class="mm kt in mz b gy nh ne l nf ng">const getRight = current =&gt; current * 2 + 1;</span></pre><h2 id="7e88" class="mm kt in bd ku mn mo dn ky mp mq dp lc lt mr ms le lx mt mu lg mb mv mw li mx bi translated">互换</h2><p id="9aa9" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们需要的另一个辅助函数是实际执行我们前面提到的交换的函数。</p><p id="a162" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们称之为。交换，并可以如下实现它:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="7b56" class="mm kt in mz b gy nd ne l nf ng">swap(a, b) {</span><span id="b6e5" class="mm kt in mz b gy nh ne l nf ng">  [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];</span><span id="b25a" class="mm kt in mz b gy nh ne l nf ng">}</span></pre><h2 id="01c8" class="mm kt in bd ku mn mo dn ky mp mq dp lc lt mr ms le lx mt mu lg mb mv mw li mx bi translated">重温Heapify Up</h2><p id="b2d4" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">现在，如果我们重温一下前面的heapify函数，并加入我们对新函数的定义，就会更清楚地看到发生了什么。</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="c3e8" class="mm kt in mz b gy nd ne l nf ng">class MinHeap {</span><span id="5323" class="mm kt in mz b gy nh ne l nf ng">constructor() {<br/>  this.heap = [null];<br/>  this.size = 0;<br/>}</span><span id="577b" class="mm kt in mz b gy nh ne l nf ng">add(value) {<br/>  this.heap.push(value);<br/>  this.size++;<br/>  this.bubbleUp();<br/>}</span><span id="69e1" class="mm kt in mz b gy nh ne l nf ng">heapifyUp() {</span><span id="d06e" class="mm kt in mz b gy nh ne l nf ng">  let current = this.size;</span><span id="3abf" class="mm kt in mz b gy nh ne l nf ng">  while (current &gt; 1 &amp;&amp; this.heap[getParent(current)] &gt;  this.heap[current]) {</span><span id="6008" class="mm kt in mz b gy nh ne l nf ng">    this.<strong class="mz io">swap</strong>(current, <strong class="mz io">getParent</strong>(current));<br/>    current = <strong class="mz io">getParent</strong>(current);<br/>  }<br/>}</span><span id="9819" class="mm kt in mz b gy nh ne l nf ng"><strong class="mz io">swap(a, b) {</strong></span><span id="62a2" class="mm kt in mz b gy nh ne l nf ng"><strong class="mz io">  [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];</strong></span><span id="f7ab" class="mm kt in mz b gy nh ne l nf ng"><strong class="mz io">}</strong></span><span id="1cfe" class="mm kt in mz b gy nh ne l nf ng"><strong class="mz io">const getParent = current =&gt; Math.floor((current / 2));</strong></span><span id="8020" class="mm kt in mz b gy nh ne l nf ng"><strong class="mz io">const getLeft = current =&gt; current * 2;</strong></span><span id="610c" class="mm kt in mz b gy nh ne l nf ng"><strong class="mz io">const getRight = current =&gt; current * 2 + 1;</strong></span></pre><p id="5c59" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们使用getParent在堆中向上移动，然后在子节点小于父节点时交换节点。</p><h2 id="4d97" class="mm kt in bd ku mn mo dn ky mp mq dp lc lt mr ms le lx mt mu lg mb mv mw li mx bi translated">删除最小值</h2><p id="4919" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">到目前为止，这一切都很好，但是min堆的要点是能够在它的顶部返回根值，有效地返回最小值。</p><p id="f8e2" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">让我们创建另一个函数来完成这项工作:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="c881" class="mm kt in mz b gy nd ne l nf ng">popMin() {</span><span id="3f9d" class="mm kt in mz b gy nh ne l nf ng">  if (this.size === 0) {<br/>    return null<br/>  }</span><span id="0650" class="mm kt in mz b gy nh ne l nf ng">  const min = this.heap[1];<br/>  this.heap[1] = this.heap[this.size];<br/>  this.size--;<br/>  this.heap.pop();<br/>  return min;<br/>}</span></pre><p id="1bfa" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">如果你看看这个函数，你会注意到它在移除最小值之前交换了堆数组的第一项和最后一项，最小值现在是我们的最后一个值。这是因为如果您直接删除根节点，您将得到一个包含两个无父节点的破碎树。因为最后一个节点总是没有子节点，所以通过在移除之前交换这两个节点，可以避免这个问题。</p><p id="89c4" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">然而，现在你有一个不同的问题。根节点不再是最小节点。我们需要编写另一个类似于HeapifyUp的函数，将这个根节点在树中向下移动，直到它位于正确的位置。</p><h2 id="ba1e" class="mm kt in bd ku mn mo dn ky mp mq dp lc lt mr ms le lx mt mu lg mb mv mw li mx bi translated">HeapifyDown</h2><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="0a46" class="mm kt in mz b gy nd ne l nf ng">heapifyDown() {</span><span id="a78c" class="mm kt in mz b gy nh ne l nf ng">let current = 1;<br/>  let leftChild = getLeft(current);<br/>  let rightChild = getRight(current);</span><span id="e60e" class="mm kt in mz b gy nh ne l nf ng">// Check that there is something to swap (only need to check the left if both exist)</span><span id="3f90" class="mm kt in mz b gy nh ne l nf ng">while (this.canSwap(current, leftChild, rightChild)){</span><span id="fac8" class="mm kt in mz b gy nh ne l nf ng">// Only compare left &amp; right if they both exist</span><span id="752c" class="mm kt in mz b gy nh ne l nf ng">if (this.exists(leftChild) &amp;&amp; this.exists(rightChild)) {</span><span id="9d8b" class="mm kt in mz b gy nh ne l nf ng">// Make sure to swap with the smaller of the two children</span><span id="5f3d" class="mm kt in mz b gy nh ne l nf ng">if (this.heap[leftChild] &lt; this.heap[rightChild]) {<br/>    this.swap(current, leftChild);<br/>    current = leftChild;<br/>  } else {<br/>    this.swap(current, rightChild);<br/>    current = rightChild;<br/>    }<br/>  } else {</span><span id="00f5" class="mm kt in mz b gy nh ne l nf ng">// If only one child exist, always swap with the left</span><span id="b3a3" class="mm kt in mz b gy nh ne l nf ng">this.swap(current, leftChild);<br/>    current = leftChild;<br/>  }</span><span id="70e9" class="mm kt in mz b gy nh ne l nf ng">leftChild = getLeft(current);<br/>    rightChild = getRight(current);<br/>  }<br/>}</span></pre><p id="3143" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">这个函数依赖于另一个辅助函数来检查交换是否发生，方法是确保左右子代都存在，然后选择子代中较小的值并执行交换。</p><p id="f4b3" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">通过总是选择两个值中较小的一个，可以保证最小值是二叉树的父树。</p><p id="787f" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">以下是您需要的两个助手功能:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="0907" class="mm kt in mz b gy nd ne l nf ng">exists(index) {<br/>  return index &lt;= this.size;<br/>}</span><span id="87b6" class="mm kt in mz b gy nh ne l nf ng">canSwap(current, leftChild, rightChild) {</span><span id="3b6e" class="mm kt in mz b gy nh ne l nf ng">// Check that one of the possible swap conditions exists</span><span id="9102" class="mm kt in mz b gy nh ne l nf ng">  return (<br/>    this.exists(leftChild) &amp;&amp; this.heap[current] &gt;  this.heap[leftChild]<br/>    || this.exists(rightChild) &amp;&amp; this.heap[current] &gt; this.heap[rightChild]<br/>  );<br/>}</span></pre><p id="0865" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在让我们将heapifyDown添加到popMin函数中:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="7d2e" class="mm kt in mz b gy nd ne l nf ng">popMin() {</span><span id="1695" class="mm kt in mz b gy nh ne l nf ng">if (this.size === 0) {<br/>    return null<br/>  }</span><span id="6116" class="mm kt in mz b gy nh ne l nf ng">const min = this.heap[1];<br/>  this.heap[1] = this.heap[this.size];<br/>  this.size--;<br/>  this.heap.pop();<br/>  <strong class="mz io">this.heapifyDown();</strong><br/>  return min;<br/>}</span></pre><p id="5a3e" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">就是这样！我们最后的MinHeap类如下:</p><pre class="kd ke kf kg gt my mz na nb aw nc bi"><span id="3514" class="mm kt in mz b gy nd ne l nf ng">class MinHeap {</span><span id="4105" class="mm kt in mz b gy nh ne l nf ng">  constructor() {<br/>    this.heap = [null];<br/>    this.size = 0;<br/>  }</span><span id="36da" class="mm kt in mz b gy nh ne l nf ng">  add(value) {<br/>    this.heap.push(value);<br/>    this.size++;<br/>    this.bubbleUp(); <br/>  }</span><span id="98fb" class="mm kt in mz b gy nh ne l nf ng">  popMin() {<br/>   if (this.size === 0) {<br/>    return null<br/>   }<br/>   const min = this.heap[1];<br/>   this.heap[1] = this.heap[this.size];<br/>   this.size--;<br/>   this.heap.pop();<br/>   this.heapify();<br/>   return min;<br/>  }</span><span id="e694" class="mm kt in mz b gy nh ne l nf ng">heapifyUp() {<br/>   let current = this.size;<br/>   while (current &gt; 1 &amp;&amp; this.heap[getParent(current)] &gt;     this.heap[current]) {<br/>   this.swap(current, getParent(current));<br/>   current = getParent(current);<br/>  }<br/>}</span><span id="cf0d" class="mm kt in mz b gy nh ne l nf ng">heapifyDown() {<br/>  let current = 1;<br/>  let leftChild = getLeft(current);<br/>  let rightChild = getRight(current);</span><span id="14aa" class="mm kt in mz b gy nh ne l nf ng">while (this.canSwap(current, leftChild, rightChild)){<br/>  if (this.exists(leftChild) &amp;&amp; this.exists(rightChild)) {<br/>    if (this.heap[leftChild] &lt; this.heap[rightChild]) {<br/>      this.swap(current, leftChild);<br/>      current = leftChild;<br/>    } else {<br/>      this.swap(current, rightChild);<br/>      current = rightChild;<br/>    }<br/>  } else {<br/>    this.swap(current, leftChild);<br/>    current = leftChild;<br/>  }</span><span id="d662" class="mm kt in mz b gy nh ne l nf ng">  leftChild = getLeft(current);<br/>  rightChild = getRight(current);<br/>  }<br/>}</span><span id="ec88" class="mm kt in mz b gy nh ne l nf ng">swap(a, b) {</span><span id="4056" class="mm kt in mz b gy nh ne l nf ng">[this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];</span><span id="e141" class="mm kt in mz b gy nh ne l nf ng">}</span><span id="d9c7" class="mm kt in mz b gy nh ne l nf ng">exists(index) {<br/>  return index &lt;= this.size;<br/>}</span><span id="bdd1" class="mm kt in mz b gy nh ne l nf ng">  canSwap(current, leftChild, rightChild) {<br/>    return (<br/>      this.exists(leftChild) &amp;&amp; this.heap[current] &gt;  this.heap[leftChild]</span><span id="26c3" class="mm kt in mz b gy nh ne l nf ng">      || this.exists(rightChild) &amp;&amp; this.heap[current] &gt; this.heap[rightChild]<br/>    );<br/>  }<br/>}</span><span id="14e4" class="mm kt in mz b gy nh ne l nf ng">const getParent = current =&gt; Math.floor((current / 2));</span><span id="5749" class="mm kt in mz b gy nh ne l nf ng">const getLeft = current =&gt; current * 2;</span><span id="b060" class="mm kt in mz b gy nh ne l nf ng">const getRight = current =&gt; current * 2 + 1;</span></pre></div></div>    
</body>
</html>