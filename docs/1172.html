<html>
<head>
<title>Using Firestore with more TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Firestore和更多类型脚本</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-firestore-with-more-typescript-8058b6a88674?source=collection_archive---------1-----------------------#2021-03-12">https://javascript.plainenglish.io/using-firestore-with-more-typescript-8058b6a88674?source=collection_archive---------1-----------------------#2021-03-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="10bb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用这个验证点符号对象键的TS 4魔术来升级你的Firestore/TypeScript游戏。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c6a5510a8978557384ebf8c04948f87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N8vHZsgk-scumy7u"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@peterconlan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Peter Conlan</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7e6d" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">如果您想理解代码，请注意:</h1><p id="3c18" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">这篇文章是我上一篇关于Firestore和TS的文章的延续</p><div class="mh mi gp gr mj mk"><a href="https://medium.com/swlh/using-firestore-with-typescript-65bd2a602945" rel="noopener follow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">将Firestore与Typescript一起使用</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">用几行干净的代码提升你的Firestore和TS技能。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my km mk"/></div></div></a></div><p id="86ef" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">我写<code class="fe ne nf ng nh b">db</code>的时候，假设你知道我在说什么。以下是提醒代码:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="a53b" class="nm ku in nh b gy nn no l np nq">// import firstore (obviously)<br/>import { firestore } from "firebase-admin"</span><span id="b8aa" class="nm ku in nh b gy nr no l np nq">// Import or define your types<br/>// import { User } from '~/@types'</span><span id="7aca" class="nm ku in nh b gy nr no l np nq">const converter = &lt;T&gt;() =&gt; ({<br/>  toFirestore: (data: Partial&lt;T&gt;) =&gt; data,<br/>  fromFirestore: (snap: FirebaseFirestore.QueryDocumentSnapshot) =&gt; snap.data() as T<br/>})</span><span id="0d43" class="nm ku in nh b gy nr no l np nq">const dataPoint = &lt;T&gt;(collectionPath: string) =&gt; firestore().collection(collectionPath).withConverter(converter&lt;T&gt;())</span><span id="eff2" class="nm ku in nh b gy nr no l np nq">const db = {<br/>  // list your collections here<br/>  // users: dataPoint&lt;User&gt;('users')<br/>}</span><span id="af9f" class="nm ku in nh b gy nr no l np nq">export { db }</span></pre><p id="7ba8" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated"><strong class="ln io">TLDR</strong>；<br/>TS游乐场的类型安全Firestore更新:<br/><a class="ae ks" href="https://bit.ly/2OhV1y4" rel="noopener ugc nofollow" target="_blank">https://bit.ly/2OhV1y4</a><br/>代码完整要旨:<br/><a class="ae ks" href="https://gist.github.com/JamieCurnow/650ea759c277757ae5665ea52400713b" rel="noopener ugc nofollow" target="_blank">https://GIST . github . com/Jamie curnow/650 ea 759 c 277757 AE 5665 ea 52400713 b</a></p><h1 id="7bbc" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">问题是:</h1><p id="b114" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">几个月来，我一直在使用我的另一篇文章中的代码(上面有链接),它在我读写Firestore时为我提供了可爱的类型安全和建议。然而，它有一个缺点:T1方法。</p><p id="6ff3" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">Firestore的<code class="fe ne nf ng nh b">documentRef.update()</code>方法在不覆盖整个文档的情况下更新文档的一些字段，类似于做<code class="fe ne nf ng nh b">set({}, { merge: true })</code>，但是有一个巧妙的技巧——使用点符号来更新嵌套属性。</p><p id="da2f" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">以这个数据结构为例:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="db18" class="nm ku in nh b gy nn no l np nq">interface User {<br/>  name: string<br/>  email: string<br/>  address: {<br/>    line1: string<br/>    line2: string<br/>    postcode: string<br/>    verified: false<br/>    timeAtAddress: {<br/>      days: string<br/>      months: string<br/>      hours: string<br/>    }<br/>  }<br/>}</span></pre><p id="8945" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">如果我们只想更新<code class="fe ne nf ng nh b">user.adress.verified</code>，但保持地址对象的所有其他值不变，该怎么办？</p><p id="4f74" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated"><strong class="ln io">这将删除地址中的所有其他关键字:</strong></p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="a85e" class="nm ku in nh b gy nn no l np nq">db.users.doc('1234').set({<br/>  address: {<br/>    verified: true<br/>  }<br/>})<br/>// it would also throw a TS error because it's not a complete User</span></pre><p id="c12a" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">即使使用<strong class="ln io"> </strong> <code class="fe ne nf ng nh b">merge: true</code>，地址中的所有<strong class="ln io">其他键也会被删除</strong>:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="7f42" class="nm ku in nh b gy nn no l np nq">db.users.doc('1234').set({<br/>  address: {<br/>    verified: true<br/>  }<br/>}, { merge: true })</span></pre><p id="76ed" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">这是因为<code class="fe ne nf ng nh b">merge</code>选项没有深入执行合并。</p><p id="dec4" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">这就是方便的<code class="fe ne nf ng nh b">update</code>函数的用武之地。当您调用<code class="fe ne nf ng nh b">update()</code>时，您可以使用“点符号”来引用文档中的嵌套字段:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="6dd4" class="nm ku in nh b gy nn no l np nq">db.users.doc('1234').update({<br/>  ['address.verified']: true<br/>})</span></pre><p id="0f64" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">使用TypeScript时只有一个问题…传递给<code class="fe ne nf ng nh b">@google-cloud/firestore</code>中的update函数的单个参数的签名是这样的:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="b2a3" class="nm ku in nh b gy nn no l np nq">export type UpdateData = {[fieldPath: string]: any};</span></pre><p id="8ded" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">所以在实践中，我们可以将任何对象传递给<code class="fe ne nf ng nh b">update()</code>函数，TypeScript会很高兴。然后，我们有坏的数据挂在周围，没有类型安全时，我们写的对象！检查一下:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="4bc1" class="nm ku in nh b gy nn no l np nq">db.users.doc('1234').update({<br/>  ['address.unkownKey']: true<br/>  notName: 'Jamie'<br/>})<br/>// No Type errors at all!</span></pre><p id="881f" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">所以我首先创建了一个<code class="fe ne nf ng nh b">updates</code>对象，它被类型化以存储我的更新，但是这不适用于点符号键:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="627f" class="nm ku in nh b gy nn no l np nq">const updates: Partial&lt;User&gt; = {<br/>  name: 'Jamie',<br/>  notName: 'Jamie' // Type Error - Great!<br/>  ['address.verified']: true // Type Error - Oh no!<br/>}<br/>db.users.doc('1234').update(updates)</span></pre><h1 id="59a7" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">解决方案是:</h1><p id="4950" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我考虑这个问题已经有一段时间了，并尝试过几次编写一些神奇的类型脚本，这些脚本将只强制已知的键，并为点符号键更正值。然后我在推特上找到了@diegohaz的这个小片段:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="2dcc" class="nm ku in nh b gy nn no l np nq">type PathImpl&lt;T, Key extends keyof T&gt; =<br/>  Key extends string<br/>  ? T[Key] extends Record&lt;string, any&gt;<br/>    ? | `${Key}.${PathImpl&lt;T[Key], Exclude&lt;keyof T[Key], keyof any[]&gt;&gt; &amp; string}`<br/>      | `${Key}.${Exclude&lt;keyof T[Key], keyof any[]&gt; &amp; string}`<br/>    : never<br/>  : never;</span><span id="855f" class="nm ku in nh b gy nr no l np nq">type PathImpl2&lt;T&gt; = PathImpl&lt;T, keyof T&gt; | keyof T;</span><span id="6830" class="nm ku in nh b gy nr no l np nq">type Path&lt;T&gt; = PathImpl2&lt;T&gt; extends string | keyof T ? PathImpl2&lt;T&gt; : keyof T;</span><span id="8045" class="nm ku in nh b gy nr no l np nq">type PathValue&lt;T, P extends Path&lt;T&gt;&gt; =<br/>  P extends `${infer Key}.${infer Rest}`<br/>  ? Key extends keyof T<br/>    ? Rest extends Path&lt;T[Key]&gt;<br/>      ? PathValue&lt;T[Key], Rest&gt;<br/>      : never<br/>    : never<br/>  : P extends keyof T<br/>    ? T[P]<br/>    : never;</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="8800" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">多传奇啊！</h1><p id="0b09" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我很快将它扩展到firebase更新中，效果非常好:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="67e8" class="nm ku in nh b gy nn no l np nq">type PathImpl&lt;T, K extends keyof T&gt; =<br/>  K extends string<br/>  ? T[K] extends Record&lt;string, any&gt;<br/>  ? T[K] extends ArrayLike&lt;any&gt;<br/>  ? K | `${K}.${PathImpl&lt;T[K], Exclude&lt;keyof T[K], keyof any[]&gt;&gt;}`<br/>  : K | `${K}.${PathImpl&lt;T[K], keyof T[K]&gt;}`<br/>  : K<br/>  : never</span><span id="5bd4" class="nm ku in nh b gy nr no l np nq">type Path&lt;T&gt; = PathImpl&lt;T, keyof T&gt; | keyof T</span><span id="a223" class="nm ku in nh b gy nr no l np nq">type PathValue&lt;T, P extends Path&lt;T&gt;&gt; =<br/>  P extends `${infer K}.${infer Rest}`<br/>  ? K extends keyof T<br/>  ? Rest extends Path&lt;T[K]&gt;<br/>  ? PathValue&lt;T[K], Rest&gt;<br/>  : never<br/>  : never<br/>  : P extends keyof T<br/>  ? T[P]<br/>  : never</span><span id="3492" class="nm ku in nh b gy nr no l np nq">type UpdateData&lt;T extends object&gt; = Partial&lt;{<br/>  [TKey in Path&lt;T&gt;]: PathValue&lt;T, TKey&gt;<br/>}&gt;</span><span id="aefc" class="nm ku in nh b gy nr no l np nq">const updates: UpdateData&lt;User&gt; = {<br/>  name: 'Jamie',<br/>  'address.verified': true,<br/>  notName: 'Jamie' // TS Error. Great!<br/>  'address.unkownKey': false // TS Error. Fantastic :)<br/>}</span><span id="3edc" class="nm ku in nh b gy nr no l np nq">db.users.doc('1234').update(updates)</span></pre><p id="e8d7" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">我把这些类型保存在我的助手中，这样当我在应用程序中使用它们的时候，它会变得很好很干净。下面是一些完整的代码:</p><pre class="kd ke kf kg gt ni nh nj nk aw nl bi"><span id="62f8" class="nm ku in nh b gy nn no l np nq">// utils/firestore-helpers.ts</span><span id="fc05" class="nm ku in nh b gy nr no l np nq">// import firstore (obviously)<br/>import { firestore } from "firebase-admin"</span><span id="7829" class="nm ku in nh b gy nr no l np nq">// Make the helper types for updates:<br/>type PathImpl&lt;T, K extends keyof T&gt; =<br/>  K extends string<br/>  ? T[K] extends Record&lt;string, any&gt;<br/>  ? T[K] extends ArrayLike&lt;any&gt;<br/>  ? K | `${K}.${PathImpl&lt;T[K], Exclude&lt;keyof T[K], keyof any[]&gt;&gt;}`<br/>  : K | `${K}.${PathImpl&lt;T[K], keyof T[K]&gt;}`<br/>  : K<br/>  : never</span><span id="ca80" class="nm ku in nh b gy nr no l np nq">type Path&lt;T&gt; = PathImpl&lt;T, keyof T&gt; | keyof T</span><span id="4d78" class="nm ku in nh b gy nr no l np nq">type PathValue&lt;T, P extends Path&lt;T&gt;&gt; =<br/>  P extends `${infer K}.${infer Rest}`<br/>  ? K extends keyof T<br/>  ? Rest extends Path&lt;T[K]&gt;<br/>  ? PathValue&lt;T[K], Rest&gt;<br/>  : never<br/>  : never<br/>  : P extends keyof T<br/>  ? T[P]<br/>  : never</span><span id="cdc3" class="nm ku in nh b gy nr no l np nq">export type UpdateData&lt;T extends object&gt; = Partial&lt;{<br/>  [TKey in Path&lt;T&gt;]: PathValue&lt;T, TKey&gt;<br/>}&gt;</span><span id="0ecf" class="nm ku in nh b gy nr no l np nq">// Import or define your types<br/>import { User } from '~/@types'</span><span id="aafe" class="nm ku in nh b gy nr no l np nq">const converter = &lt;T&gt;() =&gt; ({<br/>  toFirestore: (data: Partial&lt;T&gt;) =&gt; data,<br/>  fromFirestore: (snap: FirebaseFirestore.QueryDocumentSnapshot) =&gt; snap.data() as T<br/>})</span><span id="2766" class="nm ku in nh b gy nr no l np nq">const dataPoint = &lt;T&gt;(collectionPath: string) =&gt; firestore().collection(collectionPath).withConverter(converter&lt;T&gt;())</span><span id="3215" class="nm ku in nh b gy nr no l np nq">const db = {<br/>  // list your collections here<br/>  // users: dataPoint&lt;YourType&gt;('users')<br/>}</span><span id="8311" class="nm ku in nh b gy nr no l np nq">export { db }</span><span id="474c" class="nm ku in nh b gy nr no l np nq">// some-other-file.ts<br/>import { db, UpdateData } from '~/utils/firestore-helpers.ts'<br/>import { User } from '~/@types'</span><span id="9fd8" class="nm ku in nh b gy nr no l np nq">export const verifyUserAddress = async (userId: string) =&gt; {<br/>  // Make the updates object<br/>  const updates: UpdateData&lt;User&gt; = {<br/>    'address.verified': true<br/>  }<br/>  <br/>  // do the update!<br/>  await db.users.doc(userId).update(updates)<br/>}</span></pre><p id="c08c" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">如果Firestore团队能够将这种新类型集成到SDK中，以便在使用<code class="fe ne nf ng nh b">withConverter</code>技巧时自动进行更新，那就太好了。我已经查看了源代码，这很容易实现，但是需要他们从3.8.3更新到TS ≥4.1，这可能会非常麻烦，需要大量的工作…我已经向他们提出了一个问题，请关注这个空间！https://github.com/googleapis/nodejs-firestore/issues/1448<br/>T3</p><p id="e8b3" class="pw-post-body-paragraph ll lm in ln b lo mz jo lq lr na jr lt lu nb lw lx ly nc ma mb mc nd me mf mg ig bi translated">感谢阅读！</p><h1 id="a12d" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">支持你的创作者！</h1><p id="3086" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">如果你觉得这个故事有用，并希望我继续写有用的内容，请考虑在<a class="ae ks" href="https://www.patreon.com/jamiecurnow" rel="noopener ugc nofollow" target="_blank"> Patreon </a>上支持我🤗</p><div class="mh mi gp gr mj mk"><a href="https://www.patreon.com/jamiecurnow" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">Jamie Curnow正在开发软件| Patreon</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">今天就成为Jamie Curnow的赞助人:在世界上最大的…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.patreon.com</p></div></div><div class="mt l"><div class="nu l mv mw mx mt my km mk"/></div></div></a></div></div></div>    
</body>
</html>