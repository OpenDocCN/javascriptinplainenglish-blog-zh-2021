<html>
<head>
<title>How Node.js Microservices Interact with Each Other Using gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js微服务如何使用gRPC相互交互</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/grpc-in-node-js-microservices-34ccd2f86134?source=collection_archive---------0-----------------------#2021-02-06">https://javascript.plainenglish.io/grpc-in-node-js-microservices-34ccd2f86134?source=collection_archive---------0-----------------------#2021-02-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d17abc1e5af287be96cc22ce78c266fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRP9RNcKE-kgdbzG0nT50A.jpeg"/></div></div></figure><p id="cc8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将了解微服务如何使用gRPC框架相互交互。gRPC是一种现代的RPC，它使微服务能够相互交互。</p><h2 id="52e1" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">什么是微服务？</h2><p id="f63d" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">微服务是一种架构，它将服务器应用程序分成松散耦合的服务。例如:</p><ol class=""><li id="f158" class="lr ls in jx b jy jz kc kd kg lt kk lu ko lv ks lw lx ly lz bi translated">专用于用户认证和授权的微服务。</li><li id="341c" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">用于处理客户详细信息(获取、更新、插入等)的微服务。)</li><li id="c732" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">处理产品的微服务。</li><li id="8237" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">处理订单的微服务。</li><li id="a1e5" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">这样的例子不胜枚举。</li></ol><p id="8098" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于微服务更详细的解释可以在<a class="ae mf" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Microservices</a>找到</p><p id="e1e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些微服务经常需要相互交互。例如，orders微服务经常需要产品细节和一些客户细节。</p><p id="f130" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">产品和订单微服务通常需要与用户的微服务进行交互，以了解用户是否被授权执行某些操作，如添加产品或确认订单。</p><p id="6316" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有几种方法可以定义微服务之间的交互方式。最常用的有:</p><ol class=""><li id="aec9" class="lr ls in jx b jy jz kc kd kg lt kk lu ko lv ks lw lx ly lz bi translated">肥皂</li><li id="38e3" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">HTTP REST架构</li><li id="f9ab" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">GraphQL</li></ol><p id="7223" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将重点介绍一种新的协议，称为gRPC。与旧协议不同，此协议基于HTTP 2.0协议。</p><h2 id="f09a" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">这种新协议的一些优点是:</h2><ol class=""><li id="07cc" class="lr ls in jx b jy lm kc ln kg mg kk mh ko mi ks lw lx ly lz bi translated">二进制数据而不是文本数据。因为二进制数据比文本数据压缩程度更高，所以确保了更低的延迟和更高的速度。</li><li id="ad3c" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">HTTP 2.0是完全复用的。HTTP 1.1传输一个资源(比如图像、JavaScript文件等等)，所以如果一个资源由于某种原因被阻塞，那么这个被阻塞的资源之后的所有资源也被阻塞。这在HTTP 2.0中不是问题，因为它可以在单个TCP连接中发送多个数据流，这样任何资源都不能阻塞其他资源。</li><li id="fe76" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">服务器推送:服务器推送多个资源以响应一个请求。</li><li id="f6a9" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">标题压缩确保了更快的加载时间。</li></ol><h2 id="e3af" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">设置Node.js环境</h2><p id="443e" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">为了演示如何在Node.js应用程序中实现gRPC，我们将构建两个应用程序。</p><ol class=""><li id="5f36" class="lr ls in jx b jy jz kc kd kg lt kk lu ko lv ks lw lx ly lz bi translated">用户_服务器</li><li id="47d8" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">用户_客户端</li></ol><p id="78ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是定义计划传输的数据和要使用的功能。定义这些功能的文件是一个原型定义文件(<code class="fe mj mk ml mm b">.proto</code>)，我们将使用的语言是协议缓冲语言。</p><p id="9ab8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以让我们开始写一个. proto文件。第一行是原型版本声明:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4be2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还必须定义一个包:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d536" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将协议缓冲语言版本定义为版本3。现在我们可以为我们应该接收的数据定义一个数据结构。</p><p id="eb39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们定义的第一个对象是OrderItemObject。每个order item对象将包括3个属性:<code class="fe mj mk ml mm b">orderId</code>作为一个数字，<code class="fe mj mk ml mm b">orderDescription</code>作为一个字符串，quantity作为一个数字。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7bfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们必须接收特定客户的订单项目列表。为此，我们将创建第二个对象来汇总返回给客户端的数据。它将包括两个属性:<code class="fe mj mk ml mm b">customerID</code>作为一个数字和一个之前定义的订单项数组。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2940" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们定义函数的参数:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="13a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，现在我们可以定义方法本身了:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="783c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完整的文件将如下所示:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="61c7" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">构建服务器端组件</h2><p id="dfcb" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">首先，我们必须导入外部库来加载<code class="fe mj mk ml mm b">.proto</code>文件并创建gRPC服务器:</p><pre class="mn mo mp mq gt mt mm mu mv aw mw bi"><span id="b2e6" class="kt ku in mm b gy mx my l mz na">npm i @grpc/grpc-js</span><span id="ae8e" class="kt ku in mm b gy nb my l mz na">npm i @grpc/proto-loader</span></pre><p id="8f74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个新文件中，让我们定义原型文件路径:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="922a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们将导入在使用NPM之前下载的外部组件:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0ba8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们将导入在使用NPM之前下载的外部组件:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b29f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在将定义包装定义:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f10e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mj mk ml mm b">PROTO_PATH</code>代表原型文件的路径。第二个对象定义了包定义的不同参数。此处的不同参数可在<a class="ae mf" href="https://www.npmjs.com/package/@grpc/proto-loader" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/@grpc/proto-loader</a>上详细解释</p><p id="5508" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们将刚刚创建的包定义加载到<code class="fe mj mk ml mm b">gRPC</code>对象中。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="aefa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">OnlineShop是我们创建的原型文件的包名。</p><p id="3ae2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，仅仅为了演示gRPC，我们将创建一个硬编码的对象来表示来自服务器的数据。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9827" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们终于可以实现以下内容了:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f1f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe mj mk ml mm b">.proto</code>文件中，我们定义了一个名为<code class="fe mj mk ml mm b">GetOrdersForCustomerID</code>的服务，其中一个参数表示<code class="fe mj mk ml mm b">customerID</code>。在函数中，我们通过调用<code class="fe mj mk ml mm b">call.request.id</code>来获取这个参数值。输出由回调函数发出。</p><p id="5287" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">剩下的工作就是将所有东西都绑定到一个工作模块中:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8c1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是完整的服务器文件:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4cf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们的服务器已经完成，我们可以通过以下命令来执行它:</p><pre class="mn mo mp mq gt mt mm mu mv aw mw bi"><span id="7423" class="kt ku in mm b gy mx my l mz na">node users_server.js</span></pre><h2 id="9aa2" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">构建客户端组件</h2><p id="dc73" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">在本演示中，我们将构建一个简单的命令行实用程序，其执行方式如下所示:</p><pre class="mn mo mp mq gt mt mm mu mv aw mw bi"><span id="6565" class="kt ku in mm b gy mx my l mz na">node users_client.js —baseaddress localhost —customerID 1</span></pre><p id="4f5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其中<code class="fe mj mk ml mm b">baseaddress </code>和<code class="fe mj mk ml mm b">customerID </code>是客户端组件的参数。我们期望获得ID为1的客户的所有订单。</p><p id="9b27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，像在服务器组件中一样，我们必须导入我们在服务器组件中使用的相同的proto文件，导入<code class="fe mj mk ml mm b">@grpc/grpc-js</code>和<code class="fe mj mk ml mm b"> @grpc/proto-loader</code>，并创建包定义:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2203" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们创建我们的主函数，它叫做main:</p><pre class="mn mo mp mq gt mt mm mu mv aw mw bi"><span id="40a2" class="kt ku in mm b gy mx my l mz na">function main() {}</span></pre><p id="bb2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个函数中，我们必须解析参数(<code class="fe mj mk ml mm b">baseaddress </code>和customerID)。为此，我们必须导入另一个名为<code class="fe mj mk ml mm b">minimist</code>的外部库</p><pre class="mn mo mp mq gt mt mm mu mv aw mw bi"><span id="4fce" class="kt ku in mm b gy mx my l mz na">npm i minimist</span></pre><p id="fdad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在将参数，解析它们，并将它们存储到两个变量中:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e2de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果参数中没有定义<code class="fe mj mk ml mm b">baseaddress</code>，那么我们将把它设置为“localhost”。</p><p id="a027" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是创建一个连接到服务器的客户机对象:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3062" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步是执行我们在服务器中定义的方法:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a998" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终文件将如下所示:</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="4e54" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">总结:</h2><p id="a136" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们看到了一个组件如何执行另一个组件的方法，就好像它是在本地执行的一样。</p><p id="c6bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完整的源代码可以在:<a class="ae mf" href="https://github.com/krasnoff/gRPC_nodeJS_microservices" rel="noopener ugc nofollow" target="_blank">https://github.com/krasnoff/gRPC_nodeJS_microservices</a>找到</p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h2 id="2fd8" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">进一步阅读</h2><div class="nj nk gp gr nl nm"><a href="https://bit.cloud/blog/component-driven-microservices-with-nodejs-and-bit-l64shurc" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd io gy z fp nr fr fs ns fu fw im bi translated">具有NodeJS和Bit的组件驱动的微服务</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">大多数人认为组件是前端的一部分。然而，CBSE(基于组件的软件工程)是…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">比特云</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jt nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://plainenglish.io/blog/how-to-compose-and-integrate-apis-together-as-if-you-were-using-npm-for-apis" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd io gy z fp nr fr fs ns fu fw im bi translated">如何将API组合和集成在一起，就像您正在使用API的NPM一样</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">将两个API整合到一个应用程序中，该应用程序显示了历史上最大的音乐会，按国家首都排列。与……</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">简明英语. io</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa jt nm"/></div></div></a></div></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><p id="956f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="oc">更多内容请看</em><a class="ae mf" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">plain English . io</em></strong></a><em class="oc">。报名参加我们的</em> <a class="ae mf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="oc">免费周报</em> </strong> </a> <em class="oc">。关注我们关于</em><a class="ae mf" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">Twitter</em></strong></a><a class="ae mf" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">LinkedIn</em></strong></a><em class="oc"/><a class="ae mf" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">YouTube</em></strong></a><em class="oc"/><a class="ae mf" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">不和</em> </strong> </a> <em class="oc">。对增长黑客感兴趣？检查</em> <a class="ae mf" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="oc">电路</em> </strong> </a> <em class="oc">。</em></p></div></div>    
</body>
</html>