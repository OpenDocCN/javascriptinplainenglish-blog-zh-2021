<html>
<head>
<title>Optimize Your Algorithms Tail Call Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化您的算法尾部调用优化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-tail-call-optimization-how-to-optimize-your-algorithms-ce45dce80035?source=collection_archive---------10-----------------------#2021-02-08">https://javascript.plainenglish.io/the-tail-call-optimization-how-to-optimize-your-algorithms-ce45dce80035?source=collection_archive---------10-----------------------#2021-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b68b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何优化调用栈？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e9a14a263fc81943b6f96ff4560f58f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-pA6ufcli8mEhAOXYW4Lg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Library representing the call stack</figcaption></figure><p id="b1cd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在编写代码和算法时，您应该考虑尾部调用优化(TCO)。</p><h2 id="d62f" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">什么是尾调用优化？</h2><p id="b78e" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">尾部调用优化是优化递归函数的事实，以避免建立一个高的<strong class="ku io">调用栈</strong>。你也应该知道一些编程语言正在进行尾部调用优化。</p><p id="ba3d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">比如Python和Java决定不使用TCO。而JavaScript从ES2015-ES6开始允许使用TCO。</p><p id="7704" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">即使你知道你最喜欢的语言是否支持本地TCO，我还是建议你假设你的编译器/解释器不会为你做这些工作。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h2 id="f3e1" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">如何做一个尾调用优化？</h2><p id="dfee" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">有两个著名的方法来进行尾部调用优化和避免高调用栈。</p><h2 id="397e" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">1.自下而上</h2><p id="dc1d" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">如你所知，递归正在构建调用栈，所以如果我们在算法中避免这样的递归，将允许我们节省<strong class="ku io">内存使用</strong>。这种策略被称为<strong class="ku io">自底向上</strong>(我们从头开始，而递归算法是在建立堆栈后从末尾开始，逆向工作。)</p><p id="0d53" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们以下面的代码为例(自顶向下—递归代码):</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="88e7" class="lo lp in mu b gy my mz l na nb">function product1ToN(n) {<br/>  return (n &gt; 1) ? (n * product1ToN(n-1)) : 1;<br/>}</span></pre><p id="efba" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如你所看到的，这段代码有一个问题:它建立了一个大小为O(n)的<strong class="ku io">调用栈</strong>，这使得我们的总内存开销为O(n)。这段代码使我们容易受到<strong class="ku io">堆栈溢出错误</strong>的影响，调用堆栈变得太大，耗尽了空间。</p><p id="9c6d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了优化我们的例子，我们需要自下而上，消除递归:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="8b7c" class="lo lp in mu b gy my mz l na nb">function product1ToN(n) {<br/>  let result = 1;<br/>  for (let num = 1; num &lt;= n; num++) {<br/>    result *= num;<br/>  }<br/>  return result;<br/>}</span></pre><p id="25f4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这次我们没有在<strong class="ku io">调用栈</strong>中堆积我们的调用，我们使用了O(1)空间复杂度(O(n)时间复杂度)。</p><h2 id="b318" class="lo lp in bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">2.记忆化</h2><p id="94a9" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated"><strong class="ku io">记忆</strong>通过记录函数的结果(通常在一个对象中),确保函数在不需要的时候不会运行超过一次。</p><p id="f3fc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们从一个经典的例子开始，斐波那契数列:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="b165" class="lo lp in mu b gy my mz l na nb">function fib(n) {<br/>  if (n &lt; 0) {<br/>    throw new Error('You cannot start with a negative number!');<br/>  }<br/>  // Obvious cases<br/>  if (n === 0 || n === 1) {<br/>    return n;<br/>  }<br/>  return fib(n - 1) + fib(n - 2);<br/>}</span></pre><p id="3e38" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果我们将<strong class="ku io">调用栈</strong>表示为一个图形，我们将得到下图:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/55b16eb6e66575c76a8bfeaef7309c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*5ttKT57F_O3TqG5Jph7oVA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Fibonacci recursive</figcaption></figure><p id="8de5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本例中，我们将4作为参数传递给Fibbonaci序列，正如您所看到的，我们计算了两次fib(0)和fib(2)以及三次fib(1)。如你所料，这是对计算资源的浪费。</p><p id="76f9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了避免这种计算资源的浪费，我们可以使用<strong class="ku io">记忆化</strong>。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="1ef9" class="lo lp in mu b gy my mz l na nb">class Fibber {<br/>  constructor() {<br/>    this.memo = {};<br/>  }<br/><br/>  fib(n) {<br/>    if (n &lt; 0) {<br/>      throw new Error('You cannot start with a negative number!');<br/>    }<br/>    // Obvious cases<br/>    if (n === 0 || n === 1) {<br/>      return n;<br/>    }<br/>    // Check if we have already calculated this<br/>    if (this.memo.hasOwnProperty(n)) {<br/>      return this.memo[n];<br/>    }<br/>    const result = this.fib(n - 1) + this.fib(n - 2);<br/>    // Memoize for the next possible calculation<br/>    this.memo[n] = result;<br/>    return result;<br/>  }<br/>}</span></pre><p id="604b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果函数已经被处理过，这次我们就不计算它了。</p><p id="60e0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下面是我们的调用堆栈图:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/a266fa8f1c026f0c6d13463af5096007.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*OOeC8_y5I8lbJL5PZpST_g.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Fibonacci memoization</figcaption></figure><p id="44ac" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如您在这里看到的，我们只执行了一次函数，这使我们节省了调用堆栈。</p><p id="13ee" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="ne">更多内容请看</em><a class="ae nf" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="ne">plain English . io</em></strong></a></p></div></div>    
</body>
</html>