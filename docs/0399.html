<html>
<head>
<title>An Introduction to Webpack 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack 5简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/webpack-5-9256d45f7b83?source=collection_archive---------1-----------------------#2021-01-24">https://javascript.plainenglish.io/webpack-5-9256d45f7b83?source=collection_archive---------1-----------------------#2021-01-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/1cc4f5b8fd82d320e0f7e2b20d3e1729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*Zzm6q8wMaT6_UqG1J2NqQw.png"/></div></figure><div class=""/><div class=""><h2 id="1a67" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated"><em class="kj">一步步介绍捆绑JavaScript应用的世界。</em></h2></div><p id="9a37" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km iv"> Webpack </strong>是最著名的捆扎机之一，拥有<em class="lg"> rollup </em>。你可能会在不知不觉中使用它，例如，create-react-app使用webpack来捆绑它所有的依赖项。它帮助开发人员专注于开发，并将所有资产、模块和依赖项捆绑成一个包。现在有了webpack 5，我认为向每个人介绍这个令人敬畏的工具是个好主意。</p><p id="0c20" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">使用<em class="lg"> webpack </em>，你可以创建自己的定制解决方案/样板，这完全取决于你在网上找到的东西。</p><h2 id="f411" class="lh li iu bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">那么为什么是webpack呢？</h2><p id="4d88" class="pw-post-body-paragraph kk kl iu km b kn ma jv kp kq mb jy ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">Webpack是一个用于现代JavaScript应用的静态模块捆绑器。当<em class="lg"> webpack </em>处理你的应用程序时，它会递归地构建一个包含应用程序中每个模块的依赖图。没有隐藏的依赖关系。最好的部分是，我们只需要包含一个JS文件，所有其他的依赖项，内部的和外部的，都打包在这个打包文件中。</p><p id="4546" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">简而言之，<strong class="km iv"> webpack </strong>是一个单一的工具，用于在一个地方管理你所有的代码和资产。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="1a71" class="lh li iu bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">我们开始吧</h2><p id="ed67" class="pw-post-body-paragraph kk kl iu km b kn ma jv kp kq mb jy ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">打开一个新文件夹，首先使用“<em class="lg"> npm init </em>”启动一个新的npm项目。</p><p id="c509" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一旦完成，就该添加<strong class="km iv">网络包了。由于它是一个开发依赖项，我们在安装时使用-D选项。</strong></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e623" class="lh li iu mr b gy mv mw l mx my">npm i -D webpack webpack-cli</span></pre></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="5abf" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我创建了两个单独的JS文件hw.js和button.js，index.js充当应用程序的入口点。你可以在这里找到回购<a class="ae mz" href="https://github.com/devAbhimanyu/webpack-configs" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1971a8602acf6f54425660ce643b5bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*DhQB0uMI7msuVBRi4dzaMQ.png"/></div></figure><p id="306a" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">第二个任务是创建我们的<em class="lg">配置文件</em>，它将用于构建和捆绑应用程序。文件命名约定为<strong class="km iv"> webpack.config.js </strong>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="507a" class="lh li iu mr b gy mv mw l mx my">const path = require('path');</span><span id="0670" class="lh li iu mr b gy nb mw l mx my">module.exports={<br/> entry:'./src/index.js', the entry point to the application<br/> //this is where the bundled files will be placed<br/> output:{<br/>  filename:'bundle.js',<br/>  path:path.resolve(__dirname,'./dist'),<br/> },<br/> mode:'none'<br/>}</span></pre><p id="61cf" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在在<em class="lg"> package.json </em>中添加构建脚本，告诉webpack构建我们的应用程序。这将生成包含bundle.js文件的dist文件夹</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="1437" class="lh li iu mr b gy mv mw l mx my">"build": "webpack",</span></pre><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c12b28288f4625f792487334ea965969.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*fKwTq0o8QlaSodMAxcl5aQ.png"/></div></figure><p id="53c7" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在我们需要将这个bundle.js导入到我们的HTML文件中来使用它。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="3ec4" class="lh li iu bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">装载机</h2><p id="d268" class="pw-post-body-paragraph kk kl iu km b kn ma jv kp kq mb jy ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">在构建任何前端应用程序时，都有多个依赖项，如HTML、JS、样式文件(CSS、SASS或更少)和其他可选资产(图像)。默认情况下，<em class="lg"> webpack </em>理解JS，如果我们试图导入默认情况下webpack不知道的依赖项，必然会发生构建错误。所以我们需要告诉webpack如何导入不同的模块。这就是<strong class="km iv">装载机</strong>发挥作用的地方。</p><p id="c9a1" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了定义<em class="lg">加载器</em>，需要在webpack.config中添加一个新的属性<strong class="km iv">模块</strong>，在模块对象内部，需要添加<strong class="km iv">规则</strong>。正是<em class="lg">规则</em>映射了文件扩展名和加载器。</p><p id="b082" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一个基本规则有一个<strong class="km iv">测试</strong>属性，它是<em class="lg">正则表达式</em>(使用文件的扩展名)，而<strong class="km iv">使用</strong>属性，它是一个数组，您可以在其中定义不同的<em class="lg">加载器</em>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2436" class="lh li iu mr b gy mv mw l mx my">module:{<br/> rules:[{<br/> test:/\.ext$/,<br/> use:[loader]<br/> }]<br/>}</span></pre><p id="74bd" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们看一些场景:</p><p id="a600" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km iv"> 1)加载图像</strong>:由于图像是文件，我们需要安装“<em class="lg">文件加载器</em></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4c96" class="lh li iu mr b gy mv mw l mx my">module:{<br/> rules:[ {<br/> test:/\.(png|jpg)$/,<br/> use:['file-loader']<br/>}]}</span></pre><p id="85c5" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">使用<em class="lg"> webpack 5 </em>时，<strong class="km iv"> publicPath </strong>属性默认设置为“<strong class="km iv"> auto </strong>”但是如果你把图片放在某个CDN里会怎么样呢？您可以将公共路径指向该地址。Webpack会通过将publicPath附加到图像上来自动构建src路径。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2417" class="lh li iu mr b gy mv mw l mx my">module.exports={<br/> entry:'./src/index.js', the entry point to the application<br/> //this is where the bundled files will be placed<br/> output:{<br/>  filename:'bundle.js',<br/>  path:path.resolve(__dirname,'./dist'),<br/>  <strong class="mr iv">publicPath:'https://www.someCdn.com/'</strong><br/> },<br/> mode:'none'<br/>}</span></pre><p id="3bc0" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">2) <strong class="km iv">加载样式</strong>:使用css或sass/scss添加样式，需要安装所需的加载器。“<em class="lg"> style-loader </em>”和“<em class="lg"> css-loader </em>”是sass和css都需要的加载器。对于sass/scss文件，需要“<em class="lg"> sass-loader </em>”和“<em class="lg"> node-sass </em>”(处理sass到CSS的依赖关系)。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3af2" class="lh li iu mr b gy mv mw l mx my">{<br/>  test:/\.css$/,<br/>  use:[style-loader', 'css-loader']<br/>},<br/>{<br/>  test:/\.(scss|sass)$/,<br/>  use:[style-loader', 'css-loader','sass-loader']<br/>}</span></pre><p id="3fbd" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">加载器是从右向左解析的，所以scss-&gt;css-&gt;然后style-loader使用style标签将它们添加到html中。</p><p id="c66e" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">3) <strong class="km iv">加载现代javascript特性:</strong>JS遵循的ECMA标准，每年更新。但是并不是所有的浏览器都可以更新和支持这些功能。为此，我们需要使用一个叫做<strong class="km iv"> transpiler </strong>的东西。transpiler将最新的代码从例如从<em class="lg"> ES7 </em>转换成标准JavaScript。<strong class="km iv"> Babel </strong>是JS transpilers中最著名的，它提供了一个“<em class="lg"> babel-loader </em>”添加到webpack配置中。</p><p id="6d2f" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">所需的devDependencies是:“@babel/core”、“babel/plugin-proposal-class-properties”、“babel/preset-env”和“babel-loader”，</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e5dd" class="lh li iu mr b gy mv mw l mx my">{<br/> test:/\.js$/,<br/> exclude:/node_modules/,<br/> use:{ <br/>  loader:'babel-loader', <br/>  options:{<br/>   presets:['@babel/preset-env'],<br/>   plugins:['@babel/plugin-proposal-class-properties']<br/>  }<br/> }<br/>}</span></pre><p id="4509" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km iv">@ babel/plugin-proposal-class-properties:</strong>是一个插件，用来支持JS类特性。在Babel中，<strong class="km iv">预置</strong>是一组用于支持特定语言特性的插件。</p><p id="3212" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">定义加载器后，模块对象应该看起来像这样:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7cfa" class="lh li iu mr b gy mv mw l mx my">module:{<br/> rules:[<br/> {<br/>  test:/\.(png|jpg)$/,<br/>  use:['file-loader']<br/> },<br/> {<br/>  test:/\.css$/,<br/>  use:[style-loader', 'css-loader']<br/> },<br/> {<br/>  test:/\.(scss|sass)$/,<br/>  use:[style-loader', 'css-loader','sass-loader']<br/> },<br/> {<br/>  test:/\.js$/,<br/>  exclude:/node_modules/,<br/>  use:{ <br/>   loader:'babel-loader', <br/>   options:{<br/>    presets:['@babel/preset-env'],<br/>    plugins:['@babel/plugin-proposal-class-properties']<br/>   }<br/>  }<br/> },<br/>{<br/> test:/\.hbs$/,<br/> use:['handlebars-loader']<br/> }<br/>]}</span></pre><p id="b8a0" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg">*注意:在下面的html模板示例中，我将使用</em> <strong class="km iv"> <em class="lg">手柄</em> </strong> <em class="lg">。你需要安装"</em><strong class="km iv"><em class="lg"/></strong><em class="lg">"作为开发依赖，安装"</em> <strong class="km iv"> <em class="lg">车把</em> </strong> <em class="lg">"作为普通依赖。</em></p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="e3b8" class="lh li iu bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">插件</h2><p id="5965" class="pw-post-body-paragraph kk kl iu km b kn ma jv kp kq mb jy ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">使用加载器，你告诉webpack如何加载不同的依赖模块和文件。但是，如果您需要在应用程序的捆绑方式中添加某些行为，该怎么办呢？这就是<strong class="km iv">插件</strong>发挥作用的地方。</p><p id="4db3" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">插件可以帮助修改包本身的创建方式。例如<a class="ae mz" href="https://www.npmjs.com/package/uglifyjs-webpack-plugin" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> uglifyJSPlugin </em> </a>获取bundle.js并缩小内容以减小包的大小。</p><p id="29ef" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">插件可以在配置中通过添加<strong class="km iv">插件</strong>属性来定义，这是一个数组:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7f18" class="lh li iu mr b gy mv mw l mx my">module.exports={<br/> entry:'./src/index.js',<br/> output:{<br/>  filename:'bundle.[contenthash].js',<br/>  path:path.resolve(__dirname,'./dist'),<br/>  publicPath:'/dist/'<br/> },<br/> mode:'none',<br/> module:{},<br/> plugins:[]<br/>}</span></pre><p id="cb23" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们看一些场景:</p><p id="3246" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">1) <strong class="km iv">缩小:</strong>通过缩小应用，应用的包大小减小，并且消耗更少的互联网流量。为了简化，我们需要使用webpack 5中内置的“<em class="lg"> terser-webpack-plugin </em>”。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8f68" class="lh li iu mr b gy mv mw l mx my">const <strong class="mr iv">TerserPlugin</strong> =  require('terser-webpack-plugin')</span><span id="d056" class="lh li iu mr b gy nb mw l mx my">plugins:[new TerserPlugin()]</span></pre><p id="88c5" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">2) <strong class="km iv">将CSS提取到单独的包中:</strong>通过将CSS提取到单独的包中，可以进一步减小JS包的大小。“<em class="lg">mini-CSS-extract-plugin</em>”是一个webpack插件，可以帮助我们实现这个目标。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d9eb" class="lh li iu mr b gy mv mw l mx my">const <strong class="mr iv">MiniCSSPlugin</strong> = require('mini-css-extract-plugin');</span><span id="7fb1" class="lh li iu mr b gy nb mw l mx my">plugins:[<br/> new MiniCSSExtractPlugin({<br/>      filename:'style.css'<br/> })<br/>]</span></pre><p id="5a8f" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">使用extract插件时，我们需要将规则中的style-loader替换为，<em class="lg">minicssplugin . loader</em><strong class="km iv">。</strong></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e947" class="lh li iu mr b gy mv mw l mx my">{<br/> test:/\.css$/,<br/> use:[MiniCSSPlugin.loader, 'css-loader']<br/>}</span></pre><p id="5719" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km iv"> 3)在构建之前清理输出文件夹:</strong>可以观察到，每次创建一个新的构建，输出文件夹都会变得更加拥挤。这里唯一的解决方案是在运行构建脚本之前清空文件夹。最好的方法是自动化这个过程，我们有一个插件来帮助做到这一点"<em class="lg"> clean-webpack-plugin </em>"</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="fa3f" class="lh li iu mr b gy mv mw l mx my">const { CleanWebpackPlugin } = require('clean-webpack-plugin');</span><span id="d94c" class="lh li iu mr b gy nb mw l mx my">plugins:[<br/> new CleanWebpackPlugin({<br/>  cleanOnceBeforeBuildPatterns:['**/*',path.join(process.cwd(),<br/>  'extra/**/*')]<br/> })<br/>]</span></pre><p id="322e" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg">*注意:</em><strong class="km iv"><em class="lg">* */*</em></strong><em class="lg">"指的是dist文件夹(输出路径)，如果想清除不同的文件夹与输出路径之外的文件夹，可以使用" path.join(process.cwd()，' extra/* */*)"</em></p><p id="971d" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km iv"> 4)自动化HTML模板:</strong>到目前为止，index.html必须手动生成和更新。Webpack有一个插件来自动完成这个过程，我们可以使用我们自己的模板或者它生成一个默认的模板。插件是“<strong class="km iv"> html-webpack-plugin </strong>”。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a03f" class="lh li iu mr b gy mv mw l mx my">const HtmlWebpackPlugin = require('html-webpack-plugin')</span><span id="0761" class="lh li iu mr b gy nb mw l mx my">plugins:[new HtmlWebpackPlugin(<br/>{<br/> title:"Test App",<br/> template:"src/index.hbs", //handlebar file<br/> filename:'index.html'<br/>})]</span></pre><p id="861b" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">使用<em class="lg">htmlwebpackplugin . options</em>变量可以访问选项中定义的属性。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f402f25a29dbf4fe9f4a451cf177e1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*Y72Rj_QrHUS99kVIqH_D4A.png"/></div></figure><p id="aa46" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">生成的模板:</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/4ac1e7d36b68223262d2adeb17956ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*iR4gRDwnN-xK2BhDv0HEhg.png"/></div></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="cffa" class="lh li iu bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">使用浏览器缓存</h2><p id="d218" class="pw-post-body-paragraph kk kl iu km b kn ma jv kp kq mb jy ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">浏览器缓存帮助浏览器缓存应用程序的一部分，使第二次加载更容易、更快。这可以通过为文件名提供一个散列键来实现，使浏览器更容易索引文件。如果一个新的散列被识别，应用程序从开始加载。</p><p id="b464" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">要添加缓存，可以在定义文件名时使用“<em class="lg">【content hash】</em>”关键字:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="06af" class="lh li iu mr b gy mv mw l mx my">output:{<br/> filename:'<strong class="mr iv">bundle.[contenthash].js</strong>',<br/> path:path.resolve(__dirname,'./dist'),<br/> publicPath:'/dist/'<br/>},<br/>plugins:[<br/> new MiniCSSExtractPlugin({<br/>      filename:'<strong class="mr iv">style.[contenthash].css</strong>'<br/> })<br/>]</span></pre></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="169c" class="lh li iu bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">为生产和开发环境定义单独的配置</strong></h2><p id="abf2" class="pw-post-body-paragraph kk kl iu km b kn ma jv kp kq mb jy ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">根据环境类型(开发或生产)有不同的配置是一个标准，因为需求是不同的。在生产中，我们希望所有的东西都缩小以加快加载速度，但是这样调试就变得很困难。所以<em class="lg"> TerserPlugin </em>可以在dev模式下从插件列表中删除。</p><p id="842d" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg">*注:默认情况下</em><strong class="km iv"><em class="lg">TerserPlugin</em></strong><em class="lg">用于</em> <strong class="km iv"> <em class="lg">生产模式</em> </strong> <em class="lg">中，一般情况下可以从两个配置中删除。</em></p><p id="60be" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">要定义构建类型，可以使用“<strong class="km iv">模式”</strong>:模式:<em class="lg">开发</em>或模式:<em class="lg">生产</em>，</p><p id="faac" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对于单独的配置，我们需要在包中定义新的脚本。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e48d" class="lh li iu mr b gy mv mw l mx my"><strong class="mr iv">“dev</strong>”: “webpack — config webpack.dev.config.js”,<br/><strong class="mr iv">“build</strong>”: “webpack — config webpack.prod.config.js”</span></pre></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="1d9d" class="lh li iu bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated"><strong class="ak">添加开发服务器</strong></h2><p id="14b0" class="pw-post-body-paragraph kk kl iu km b kn ma jv kp kq mb jy ks kt mc kv kw kx md kz la lb me ld le lf ig bi translated">在构建任何应用程序时，都会进行多项更改。但是，在每次小的改动之后手动构建应用程序会变得令人头疼。这可以通过添加“<em class="lg">web pack-dev-server</em>”(-D)来实现。</p><p id="26f0" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一旦安装了webpack-dev-server，我们就可以更新配置了。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="bfb7" class="lh li iu mr b gy mv mw l mx my">devServer:{<br/> contentBase:path.resolve(__dirname,'./dist'),<br/> index:'index.html',<br/> port:8081,<br/> writeToDisk:true<br/>},</span></pre><p id="d468" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">随着devServer的配置，应用程序也提供了一个端口，它将在那里托管，删除需要单独托管它。该脚本也需要为开发更新:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d61d" class="lh li iu mr b gy mv mw l mx my"><strong class="mr iv">“dev</strong>”: “webpack serve — config webpack.dev.config.js —-hot”</span><span id="3eb8" class="lh li iu mr b gy nb mw l mx my">-- hot: is for hot reloading, so that every time a changes is made it would update the application build</span></pre><figure class="mm mn mo mp gt ip"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">webpack config for dev</figcaption></figure></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="3d34" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果您到达这里，感谢您的阅读。我花了一些时间准备这个。您可以在此处找到最终配置和回购<a class="ae mz" href="https://github.com/devAbhimanyu/webpack-configs" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="bcc9" class="pw-post-body-paragraph kk kl iu km b kn ko jv kp kq kr jy ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg">更多内容请看</em><a class="ae mz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="km iv"><em class="lg">plain English . io</em></strong></a><strong class="km iv"><em class="lg">。</em> </strong> <em class="lg">报名参加我们的</em> <a class="ae mz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="km iv"> <em class="lg">免费每周简讯这里</em> </strong> </a> <strong class="km iv"> <em class="lg">。</em>T53】</strong></p></div></div>    
</body>
</html>