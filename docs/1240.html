<html>
<head>
<title>The Easiest Way to Manage Tokens and Create Protected Pages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理令牌和创建受保护页面的最简单方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-easiest-way-to-manage-token-and-created-protected-pages-in-frontend-c60db33f1921?source=collection_archive---------19-----------------------#2021-03-15">https://javascript.plainenglish.io/the-easiest-way-to-manage-token-and-created-protected-pages-in-frontend-c60db33f1921?source=collection_archive---------19-----------------------#2021-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="963a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">避免在Redux或LocalStorage中存储身份验证令牌，而是使用Cookies。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5f9874e785c24b24f4d80cba972348d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WudZtikgfFL0Leh4h35How.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Storing authentication token in Cookie(<a class="ae kv" href="http://ihatereading.in/creativity" rel="noopener ugc nofollow" target="_blank">Website</a>)</figcaption></figure><p id="9105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要令牌来使API在将来免受任何攻击，并判断请求的真实性。在所有敏感API的头部或主体部分添加令牌总是一个好方法。最好使用的令牌之一是JWT——JSON Web令牌是一种向服务器发出API请求的新的安全方式。JWT有3个部分有效载荷，签名和报头。</p><ol class=""><li id="9e6d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir"> Header </strong> —定义用户的令牌和算法类型。</li><li id="2bbf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">有效负载</strong> —有效负载由发出API请求时传输的数据组成。</li><li id="d3fe" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">签名</strong>——JWT的签名部分，用于解码/检测令牌的真实性。</li></ol><p id="7c06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的主要目的是避免将这些令牌存储在redux store或本地存储中，下面是我们不应该这样做的原因:<br/> 1。当用户重新加载应用程序时，redux中存储的令牌会被删除(尽管redux中有一种方法可以避免这个问题)。用户可以轻松清除/删除冗余存储。<br/> 3。Redux store不能在服务器端访问(稍后将涉及这一点)。<br/> 4。LocalStorage存储令牌的时间比预期的长。<br/> 5。本地存储容易受到攻击，因此存储的数据也不安全。</p><p id="1d1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">存储令牌和管理用户会话的最佳方式是什么？<br/> </strong>我总是喜欢将令牌存储在cookie中，并设置令牌的到期时间。以下是在cookie中保存令牌的好处<strong class="ky ir"> : </strong> <br/> 1。Cookie令牌可以在服务器端和客户端轻松访问。<br/> 2。Cookie令牌将在最多14天后自动过期。<br/> 3。即使用户重新加载应用程序，Cookie数据也会保持一致(无需添加额外的层来使数据在重新加载后保持不变)。<br/> 4。Cookie数据在浏览器的所有选项卡中保持持久，这使得同时管理多个选项卡中的会话变得容易。</p><h1 id="b356" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">在饼干里放一个代币</strong></h1><p id="2a8c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Cookie有自己的方法，Browser为我们提供了添加、删除和编辑cookie的方法。添加一个cookie方法需要3个参数<strong class="ky ir"> cookie名称</strong>、<strong class="ky ir"> cookie值</strong>和<strong class="ky ir"> cookie到期时间</strong>(以天为单位)。第三个参数有助于在每隔“<strong class="ky ir">x”</strong>天后使令牌过期(x =您设置为方法的第三个参数的过期天数)，一旦令牌过期，它将从浏览器内存中删除。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/6312b83afe5fe1e270214213d19cf97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAfPzhFhM1gnHukmOboHng.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Cookie methods in utils</figcaption></figure><p id="dc07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经在名为“<strong class="ky ir"> utils”的文件夹中创建了设置cookie、获取cookie和删除cookie的函数。</strong>这样，我们可以在多个组件上重用这些方法来检索cookie、设置cookie和删除cookie。</p><p id="0fce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">管理用户会话</strong> <br/>我们总是将认证令牌保存在名为“<strong class="ky ir"> authToken”的cookie中。</strong>我们将在安装firebase认证时使用代码库。</p><p id="55c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是代码:<a class="ae kv" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/FirebaseAuthentication" rel="noopener ugc nofollow" target="_blank">https://github . com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/firebase authentic ation</a>。</p><h1 id="d986" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">接近</strong></h1><ol class=""><li id="27a6" class="ls lt iq ky b kz my lc mz lf ne lj nf ln ng lr lx ly lz ma bi translated">添加API的认证方法，我们正在使用firebase，我已经添加了一个电子邮件和谷歌Firebase方法登录。</li><li id="f9e0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">成功添加登录和注册方法后，firebase方法将用户"<strong class="ky ir"> uid" </strong>作为<strong class="ky ir"> "authToken "，</strong>我们将把它作为一个身份验证令牌，并将该令牌存储在一个cookie中。</li><li id="f478" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">现在在客户端或服务器端取决于您的需要，我们将从cookie中获取authToken。</li><li id="0fde" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">检查"<strong class="ky ir"> authToken </strong>的真实性，可以使用firebase方法本身来检查用户"<strong class="ky ir"> uid" </strong>值是否正确。</li><li id="bd37" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">因为我们设置了14天的过期时间，所以每隔14天令牌就会被擦除。</li><li id="7662" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果令牌不存在，则将用户从您网站上所有安全或受保护的页面中注销。例如，只有当令牌存在于cookie中并且令牌是正确的令牌时，用户才能使用仪表板。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/eec7a3af42ad132084b20797e790ee7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7ED1gjEHQvOB8Krl8og0Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Login with Email and Password methods above and Login with Google method below.</figcaption></figure><p id="dc49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用firebase登录API中的“<strong class="ky ir">set cookie”</strong>方法，将用户“<strong class="ky ir">uid”</strong>和“<strong class="ky ir">email”</strong>添加到cookie中。在用户登录后，我们将把用户抛到一个受保护的页面，就像我们例子中的仪表板页面。此外，我们还需要在仪表板页面上添加一些检查，看看cookie中是否存在“<strong class="ky ir"> authToken </strong>”以及该令牌是否正确。</p><p id="37c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，我们的主要目标是在服务器端为仪表板页面获取这个cookie。在我们的例子中，我们将检查“<strong class="ky ir">authToken”</strong>是否存在于cookie中，如果不存在，那么在重定向到仪表板页面之前，我们将把用户扔到登录页面。我们将在登录页面中添加同样的检查。一旦用户登录，他/她就不能访问登录页面，如果他/她试图这样做，我们会将他们重定向到控制面板页面。</p><p id="68fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<strong class="ky ir"> next-cookie </strong> npm包来访问cookie，并将此功能添加到登录和仪表板页面的“<strong class="ky ir"> getServerSideProps </strong>中。</p><blockquote class="ni nj nk"><p id="b245" class="kw kx nl ky b kz la jr lb lc ld ju le nm lg lh li nn lk ll lm no lo lp lq lr ij bi translated">“<strong class="ky ir">getServerSideProps”</strong>只能在“<strong class="ky ir">pages”</strong>目录的路由页面内使用。更多阅读请点击这里=&gt;<a class="ae kv" href="https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering" rel="noopener ugc nofollow" target="_blank">https://nextjs . org/docs/basic-features/data-features # getserversideprops-server-side-rendering</a></p></blockquote><div class="kg kh ki kj gt ab cb"><figure class="np kk nq nr ns nt nu paragraph-image"><img src="../Images/4055a28316004d650e38a09d1a8e3ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*QmdMKOKNfqemxnuyhZavkw.png"/></figure><figure class="np kk nv nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/e454d3a81c13805f03eec2581da40449.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*4AASU_OOi7UFOu74Z-K0KA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk nw di nx ny">“<strong class="bd nz">getServerSideProps</strong>” method inside the login page and the dashboard page in the left image and the right image respectively.</figcaption></figure></div><h1 id="7035" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">结论</strong></h1><p id="893a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们必须编写最多30/40行代码，并为这个设置安装一个npm包。我发现，与在redux store或LocalStorage中存储令牌相比，这种方法是最简单、最强大的。此外，您可以在getServerSideProps中添加更强大的功能。例如，在API头中使用相同的“<strong class="ky ir"> authToken </strong>”从API获取数据，然后将数据传递给仪表板组件以在页面上显示数据，这被称为预取页面数据。</p><p id="b0e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你从这篇文章中学到了一些东西，下次再见，祝大家有美好的一天。</p><p id="8795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是代码仓库= &gt;<a class="ae kv" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/TokenInFrontend" rel="noopener ugc nofollow" target="_blank">https://github . com/shreyvijayvargiya/iHateReadingLogs/tree/main/tech logs/token infrontend</a></p><p id="acfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nl">代表</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nl">plain English . io</em></strong></a><em class="nl">，感谢阅读！</em></p></div></div>    
</body>
</html>