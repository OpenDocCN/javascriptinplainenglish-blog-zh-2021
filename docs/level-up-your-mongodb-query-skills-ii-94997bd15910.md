# 提升您的 MongoDB 查询技能 II

> 原文：<https://javascript.plainenglish.io/level-up-your-mongodb-query-skills-ii-94997bd15910?source=collection_archive---------19----------------------->

## **主 MongoDB 聚合**

![](img/8a0732d9f3963fcc8c733c0127b22278.png)

Photo by [John T](https://unsplash.com/@john_thng?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

本文是*提高您的 MongoDB 查询技能(掌握 MongoDB 查询)的第二部分。*

[](/level-up-your-mongodb-query-skills-db059432f5f9) [## 提升您的 MongoDB 查询技能

### 主 MongoDB 查询

javascript.plainenglish.io](/level-up-your-mongodb-query-skills-db059432f5f9) 

因此，为了避免重复，我将重用那篇文章中的一些程序，包括如何创建 MongoDB 连接、创建用户集合和文档，以及如何执行 CRUD 操作。

聚合是 MongoDB 的高级查询语言。它使我们能够组合来自多个文档的数据来生成单个文档，这是我们无法从单个文档生成的。

Aggregation 相当于 MongoDB 的 SQL GROUP BY 子句。

# **聚合框架概述**

在聚合管道中，管道操作中每个步骤的输出为下一个步骤提供了输入。在每个步骤中，对输入文档执行单个操作来转换它们并生成输出文档。

在本文中，我们将研究以下聚合管道操作:

*   `$project` —指定要放置在输出文档中的字段。
*   `$group` —按指定的关键字对文档进行分组。
*   `$match` —选择要处理的文档，类似于`find()`
*   `$limit` —限制要传递给下一步的文档数量。
*   `$skip` —跳过指定数量的文档。
*   `$unwind` —为每个输入文档数组生成一个输出文档。
*   `$sort` —对文档进行分类。
*   `$out` —将管道的结果写入集合。

在*提高您的 MongoDB 查询技能*(第 1 部分)中，我只创建了一个集合—`User`，但是为了更好地理解聚合，我们需要更多的集合，所以我将创建更多的集合来使它成为一个电子商务数据库。我将创建的集合有:`Products`、`Categories`、`Orders`和`Reviews`。

## **产品数据**

首先，让我们创建一个文件— `product.js`，它将包含产品数据。这个文件将被导入到`connect.js`(我们在上一篇文章中创建的文件)中。

## **产品集合**

在`connect.js`中，添加下面的代码，该代码将导入产品数据，创建产品集合，并将产品数据插入产品集合。

## **类别数据**

让我们创建包含类别数据的`category.js`。

## **类别集合**

将类别数据导入`connect.js` 创建类别集合。

这里，我们对产品数据做了同样的事情。我们将包含类别数据的文件导入到`connect.js`中，创建一个类别集合，并将类别数据插入到类别集合中。

## **订单数据**

一个电商店铺没有订单是没有意义的，所以我们创建一个文件— `orders.js`，里面会包含我们的订单数据。

## **订单收款**

将`orders.js`导入`connect.js`获取订单数据，创建订单集合，并将订单数据插入订单集合。

## **审查数据**

用户通常会在网站上留下对商品的评论，所以让我们创建一个包含评论数据的`review.js`。

## **回顾收藏**

就像我们对其他集合所做的一样，要创建一个评审集合，将`reviews.js`导入到`connect.js`中以获取评审数据，创建一个评审集合，并将评审数据插入到评审集合中。

让我们看看如何将不同的聚合管道操作符应用到我们创建的集合和文档中。

# **$项目**

`$project` 操作符检索或传递只包含指定字段的文档到管道的下一阶段。

使用`$project` 运算符时需要注意的几点:

*   默认情况下，`_id` 字段包含在输出文档中。这意味着，除非您显式排除`_id` 字段，否则它将在返回或传递到管道中下一个阶段的文档字段中。
*   您可以指定要返回或传递到下一阶段的字段的包含和排除。
*   如果您指定包含文档中不存在的字段，`$project` 会忽略该字段。

示例:

假设我们想要返回所有用户的`_id`、`firstname`和`age`，我们的查询应该是这样的:

如果用户集合中有用户，将返回包含用户的字段`_id`、`firstname`和`age`的文档。
在我们的查询中，我们指定应该检索`firstname` 和`age` 字段，但是我们没有指定应该排除`_id` 字段，但是请记住，如果我们没有显式排除`_id` 字段，它将默认包含在内。

我们已经看到了如何指定要返回或传递到管道下一阶段的字段，但是我们如何显式地排除字段呢？

如果我们不关心文档的`_id`并希望它被排除，我们的查询应该是这样的:

如果您想要排除的字段存在，为其分配零将使其从返回的文档中排除。
以上查询将返回除`_id`之外的所有其他现有字段的用户文档。

# **$组**

`$group` 聚合多个文档的数据。

使用`$group`运算符时，必须指定`_id`字段。通过指定`_id` 字段，您可以让`$group` 操作员知道您希望文档如何分组。
`$group` 根据指定的`_id`表达式对输入文档进行分组，并返回每个不同组的汇总输出。

如果你熟悉 SQL，那么`$group` 函数相当于 SQL `GROUP BY` 子句。

那么它是如何工作的呢？

假设我们想从`Review` 集合中检索不同的评分值，我们的查询应该是这样的:

这将对评论集合中的每个不同的评级进行分组，并为每个评级返回一个文档。

例如，如果 5 个客户提交评分 1，15 个客户提交评分 3，20 个客户提交评分 4，上面的代码将返回代表每个评分(1，3，4)的三个文档，如下所示:

```
{ "_id": "1" }
{ "_id": "3" }
{ "_id": "4" }
```

# **$match**

就像`find()` 方法只检索符合指定条件的文档一样，`$match` 操作符过滤文档，只将符合指定条件的文档传递到管道中的下一个阶段。

您可能希望将这个操作符尽可能早地放在聚合管道中，因为`$match` 减少了聚合管道中的文档总数，这将最小化管道中的处理量。

示例:

从产品集合中，`$match` 只检索`name` 字段等于`Sony WH-1000XM4.`的文档

# **$限额**

`$limit` 操作符限制将传递到聚合管道中下一个阶段的文档数量。

要传递给`$limit` 的值应该是一个正整数，它指定了要检索或传递给下一阶段的最大文档数。

示例:

假设我们的`Product`集合中有成百上千的产品，上面的操作将只返回管道传递给它的前五个文档。

# **$跳过**

`$skip`操作符跳过指定数量的文档，将剩余的文档传递到管道中的下一个阶段。

一个正整数作为值传递给`$skip` 以指定要跳过的最大文档数。

示例:

该操作跳过管道传递给它的前五个产品，并将剩余的文档传递给管道中的下一个阶段。

# **$排序**

如果希望查询结果按特定顺序返回，可以使用`$sort` 操作符，该操作符对所有输入文档进行排序，并按排序后的顺序将它们返回到管道。`$sort` 需要一个指定排序依据字段和排序顺序的文档。

文档通常按升序或降序排序。按升序排序时，指定的排序依据字段被赋值为`1`，而按降序排序时，指定的排序依据字段被赋值为`-1`。

MongoDB 集合中的文档没有按照特定的顺序存储，因此，在对包含重复值的文档进行排序时，这些值可以按照任何顺序返回。为了避免这种情况，也就是说，如果您希望排序顺序一致，那么在排序文档中至少要包含一个包含唯一值的字段，最常见的是`_id` 字段。

示例:

在上面的例子中，产品根据它们的名称以升序排序，但是排序顺序可能不一致。如果`name` 字段包含重复值，则返回的单据不一致。

如前所述，确保排序顺序一致的一种方法是在排序文档中包含一个具有唯一值的字段:

`_id` 字段包含唯一值，将其包含在排序操作中可以确保排序操作返回的文档一致。

要按产品名称降序排列产品:

该操作将从`Product` 集合中返回文档，产品名称按降序排列。

# **$平仓**

如果将一个数组字段传递给`$unwind` 操作符，将为数组中的每个条目生成一个输出文档。

理想情况下，您应该为`$unwind` 提供一个数组字段，但是如果您提供的字段没有解析为数组，并且它不是 missing、null 或空数组，`$unwind` 会将非数组操作数视为单元素数组。

示例:

我们的聚合管道包含两个阶段:`$project`和`$unwind`。第一阶段— `$project`将确保返回的文档只包含`tag`字段。在第二阶段— `$unwind`，如果 tag 字段的值是一个数组，那么将为数组中的每一项生成一个文档。

我们的`Product`系列中有一款产品——索尼耳机，它包含以下标签:

```
tags: [ "Headphone", "Sony", "Technology" ]
```

在`$unwind`操作结束时，将返回以下内容:

```
{ "tags": "Headphone" }
{ "tags": "Sony" }
{ "tags": "Technology" }
```

# Out

`$out`操作符获取聚合管道生成或返回的文档，并将它们写入指定的集合。如果指定的集合不存在，`$out`操作符将创建一个新的集合。如果指定的集合存在，则在聚合操作结束时，现有集合的内容将自动替换为聚合操作的结果。

关于 out 操作符，需要注意一些事情:

*   $out 运算符必须是管道中的最后一个运算符。
*   在聚合完成之前，新创建的集合不可见。
*   如果聚合失败，MongoDB 不会创建集合。

例如:

该操作计算每个主要类别的产品数量。如果一个`mainCategorySummary`集合不存在，操作的结果将创建一个新的`mainCategorySummary`集合，但是如果它已经存在，现有的内容将被操作的结果完全替换。

在本文中，我们查看了各种 MongoDB 聚合管道，包括:`$project`、`$group`、`$match`、`$limit`、`$skip`、`$sort`、`$unwind`和`$out`。
正如我们从各种操作中看到的，这些聚合操作符使我们能够组合来自多个文档的数据，以生成不可能从单个文档生成的信息。

注意这篇文章中的错误或任何不妥之处，或有任何贡献要补充吗？请在评论区指出来。我很乐意纠正和改进它。

感谢您的阅读。

*更多内容请看*[*plain English . io*](http://plainenglish.io/)*。报名参加我们的* [*免费周报在这里*](http://newsletter.plainenglish.io/) *。*