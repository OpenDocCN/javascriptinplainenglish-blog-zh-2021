<html>
<head>
<title>The Best JavaScript Interview Question I’ve Ever Come Across</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我遇到过的最好的JavaScript面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-best-javascript-question-for-an-interview-f24435471d9c?source=collection_archive---------1-----------------------#2021-09-05">https://javascript.plainenglish.io/the-best-javascript-question-for-an-interview-f24435471d9c?source=collection_archive---------1-----------------------#2021-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d181ba7ec12b7a9db597c10e3452cd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMjuoIMeLadcy3DDXTn19A.jpeg"/></div></div></figure><p id="4dc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">面试可能会让人精疲力尽。我们倾向于认为，只有被面试者日子不好过:坐在椅子上，汗流浃背，想尽办法给面试官留下好印象。</p><p id="36b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但实际上，面试对面试官来说也是一个令人厌倦的过程。他不仅要面试几十个甚至几百个候选人，而且面试本身有时也会很艰难，因为很难真正评估候选人的技能。</p><p id="b4bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论你是面试官还是被面试者，我都想向你介绍一个我遇到过的最棒的面试问题。</p><p id="a19f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么这么伟大？因为它在一个代码块中涵盖了大量的JavaScript核心概念。</p><p id="3ca2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看这个问题:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7c46" class="lc ld in ky b gy le lf l lg lh">for(var i = 0; i&lt;5; i++) {</span><span id="3318" class="lc ld in ky b gy li lf l lg lh">    setTimeout(()=&gt; console.log("i = ", i), i*10); </span><span id="8554" class="lc ld in ky b gy li lf l lg lh">}</span></pre><p id="9de4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 1。产量是多少？</strong></p><p id="40e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。怎么修？</strong></p><p id="c8b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">花几分钟时间考虑一下。</p><p id="1628" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在回答第一个问题之前，我们先来分析一下代码。我们有一个for循环，只要“I”小于5，它就一直运行，并且每循环增加“I”。</p><p id="8e82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在for循环中，我们有一个超时，它在回调函数中记录“I”的值(并将其倒计时时间设置为“I”乘以10)。</p><p id="a881" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们期望在控制台中看到什么？i=0，i=1，i=2，i=3，i=4。</p><h1 id="a088" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">JavaScript调用堆栈和事件循环</h1><p id="169a" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">你可能已经猜到这不是正确的答案。控制台将打印i=5五次。现在是有趣的部分——为什么？</p><p id="6449" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们必须了解JavaScript如何处理超时功能，或者更准确地说，JavaScript如何处理异步任务。</p><p id="f207" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript中，我们有调用栈。顾名思义，调用栈是一堆调用——函数调用。</p><p id="6db4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript是单线程的，这意味着它一次只能处理一个任务。当它到达你的代码块中的一个函数时，它会把它堆在调用栈中并执行它。</p><p id="30e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果该函数有更多的回调，它们将在其上堆叠，并且当它们完成执行时，它们将按照它们进来时的顺序退出调用堆栈。这被称为FILO数据结构:先入—后出。</p><p id="eb70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看下面的代码片段在调用堆栈中会是什么样子:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="fa7a" class="lc ld in ky b gy le lf l lg lh">const sayHi = () =&gt; {</span><span id="e608" class="lc ld in ky b gy li lf l lg lh">sayBye();</span><span id="a745" class="lc ld in ky b gy li lf l lg lh">console.log('Hi');</span><span id="b694" class="lc ld in ky b gy li lf l lg lh">};</span><span id="2d69" class="lc ld in ky b gy li lf l lg lh">const sayBye = () =&gt; {</span><span id="ae49" class="lc ld in ky b gy li lf l lg lh">console.log('Bye');</span><span id="57d2" class="lc ld in ky b gy li lf l lg lh">};</span><span id="ff9a" class="lc ld in ky b gy li lf l lg lh">sayHi();</span></pre><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8eee4db41204ac95726b44b3db08d75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-pBgdOKkEV73yQIZo653fw.gif"/></div></div></figure></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><p id="a9b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们调用<code class="fe ms mt mu ky b">SayHi()</code>函数，在函数体中调用<code class="fe ms mt mu ky b">sayBye()</code>函数。<code class="fe ms mt mu ky b">sayHi()</code>函数进入堆栈，紧接着，<code class="fe ms mt mu ky b">sayBye()</code>函数被堆叠在它上面。当<code class="fe ms mt mu ky b">sayBye()</code>执行完毕，它将退出调用栈，之后<code class="fe ms mt mu ky b">sayHi()</code>也存在。</p><p id="9181" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是在处理异步操作时，JavaScript的行为有点不同。例如，如果我们有一个超时，我们不希望JavaScript引擎等待所有的倒计时时间，直到它继续下一行代码(记住JavaScript是<strong class="jx io">单线程</strong>)，对吗？</p><p id="5f84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有什么解决办法？JavaScript会将该任务(处理超时或任何其他异步操作)交给浏览器API，该API运行在与JavaScript单线程引擎不同的环境中。</p><p id="bf37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当计时器的倒计时结束时，浏览器API会将超时函数“推”到事件循环中。</p><p id="edd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就事件循环使用的数据结构而言，它与调用堆栈略有不同。事件循环使用队列数据结构，这意味着它是FIFO:先进先出。当JavaScript引擎清除调用堆栈时(因此当它完成运行代码时)，事件循环将采取行动，并开始将队列中的任务推送到调用堆栈。</p><p id="c89b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们再看看上面的面试问题，那么我们可以这样解释:</p><p id="225f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一轮中，JavaScript将检测超时功能，并让浏览器API处理倒计时。浏览器API会立即将回调函数推送到事件循环中(因为时间设置为0)。事件循环现在正在等待代码的剩余部分(在本例中是for循环)完成。</p><p id="9251" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同时，另一个超时被发送到浏览器API，10毫秒后，它也将被推送到事件循环。现在，事件循环中有两个任务等待进入堆栈。诸如此类。</p><p id="e7e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当for循环结束时，事件循环会将队列中的任务一个接一个地抛出到调用堆栈中。如前所述，第一个进入事件循环的任务是第一个退出的任务(并进入调用堆栈)。</p><h1 id="ed5b" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">函数范围和块范围</h1><p id="c7c6" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">但是为什么它会打印i=5五次呢？答案在于我们使用了var关键字。</p><p id="f68e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经知道，每个变量都有自己的“范围”。范围意味着变量将被“锁定”在特定的区域中。在JS中，我们有3个主要作用域——全局作用域、函数作用域和块作用域。</p><p id="ee87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们在函数之外声明一个变量，它将被认为是全局变量。像这样:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="2e2c" class="lc ld in ky b gy le lf l lg lh">const globalScope = 'global';<br/>var alsoGlobalScope = 'global';</span><span id="a3be" class="lc ld in ky b gy li lf l lg lh">function functionScope() {<br/>const insideFunctionScope = 'function scope';<br/>var alsoInsideFunctionScope = 'function scope';</span><span id="388d" class="lc ld in ky b gy li lf l lg lh">}</span></pre><p id="00dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是对于块范围，我们有一个不同的行为来比较let和const与var。</p><p id="6069" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然const和let在if/for语句中声明时会“接受”block作用域，但var不会将其视为单独的作用域。就好像我们在那个范围之外(全局地)声明了它。</p><p id="941b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个简短的片段，可以帮助我们形象化它:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="d29a" class="lc ld in ky b gy le lf l lg lh">if(someValue) {<br/>const insideBlock = 'inside';<br/>}<br/>console.log(insideBlock) // Uncaught ReferenceError: insideBlock is not defined<br/> <br/>if(someValue) {<br/>var insideBlock = 'inside';</span><span id="e95d" class="lc ld in ky b gy li lf l lg lh">}</span><span id="fbf5" class="lc ld in ky b gy li lf l lg lh">console.log(insideBlock); // output: inside</span></pre><h1 id="883d" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">关闭</h1><p id="a55b" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">让我们看看<a class="ae mv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> MDN对闭包有什么看法</a>:</p><blockquote class="mw mx my"><p id="acb6" class="jv jw mz jx b jy jz ka kb kc kd ke kf na kh ki kj nb kl km kn nc kp kq kr ks ig bi translated"><em class="in">闭包是对其周围状态(词法环境)的引用捆绑在一起(封闭)的函数的组合。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。</em></p></blockquote><p id="6d0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，这是官方的定义。听起来有点吓人？让我们简化一下:</p><p id="e22b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">闭包意味着在JavaScript运行代码之前，它会寻找函数中的所有变量。</p><p id="4f2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果它在一个内部没有声明(let、const或var)的函数中看到一个变量，但是在一个外部作用域(函数嵌套在其中)中，它会将该变量的值“锁定”在给定的函数中。</p><p id="8808" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你还困惑吗？考虑下面的片段:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="37c1" class="lc ld in ky b gy le lf l lg lh">const myOuterFunction = () =&gt; {<br/>  let variableInOuterFunction = 'Hello World';<br/></span><span id="2b1a" class="lc ld in ky b gy li lf l lg lh">  const myNestedFunction = () =&gt; {<br/>    console.log(variableInOuterFunction);<br/>  };<br/></span><span id="e30f" class="lc ld in ky b gy li lf l lg lh">  myNestedFunction();<br/>};<br/></span><span id="842c" class="lc ld in ky b gy li lf l lg lh">myOuterFunction();</span></pre><p id="4cd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意我们如何在<code class="fe ms mt mu ky b">myNestedFunction</code>中使用<code class="fe ms mt mu ky b">variableInOuterFunction</code>(在<code class="fe ms mt mu ky b">myOuterFunction</code>中声明)？这就结束了。值“Hello World”现在在嵌套函数中被“关闭”(锁定)。听起来很简单，对吧？</p><p id="f8cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以理解为什么使用var声明会产生五次“i=5”了。</p><p id="cba8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们试图在脑海中画出它的样子，我们可以这样想:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="42d3" class="lc ld in ky b gy le lf l lg lh">//First round in the for loop<br/>var i = 0;<br/>setTimeout(() =&gt; console.log('i = ', i), i * 10); // sent to browser API and then to the event loop queue</span><span id="bd89" class="lc ld in ky b gy li lf l lg lh">//Second round</span><span id="cc6c" class="lc ld in ky b gy li lf l lg lh">var i = 1; // same variable being override since it's the same scope.</span><span id="4069" class="lc ld in ky b gy li lf l lg lh">setTimeout(() =&gt; console.log('i = ', i), i * 10); //sent to browser API</span><span id="7896" class="lc ld in ky b gy li lf l lg lh">output: i=1 X 2</span></pre><p id="2db0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者像这样，如果你喜欢:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="5b45" class="lc ld in ky b gy le lf l lg lh">var i = 0;</span><span id="5c6f" class="lc ld in ky b gy li lf l lg lh">while (i &lt; 5) {</span><span id="1542" class="lc ld in ky b gy li lf l lg lh">setTimeout(() =&gt; console.log('i = ', i), i * 10);</span><span id="4522" class="lc ld in ky b gy li lf l lg lh">i++;</span><span id="96af" class="lc ld in ky b gy li lf l lg lh">}</span></pre><p id="9e03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关键是，即使我们在每一轮中都有一个闭包(我们在超时函数中使用“I”变量)，环境的上下文总是相同的。因为我们只有一个“I”变量，所以当所有超时函数调用从事件循环返回时，除了最终值之外，什么都不会传递给它们。</p><p id="7061" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于let或const声明，它看起来完全不同。每次循环运行时，都会创建一个新的作用域，在嵌套的超时函数中锁定“I”的值。</p><p id="f89e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以这样想象(用函数作用域来形象化):</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1ad4" class="lc ld in ky b gy le lf l lg lh"><em class="mz">//First round in the for loop</em></span><span id="bccc" class="lc ld in ky b gy li lf l lg lh">const firstRound = (() =&gt; {</span><span id="d532" class="lc ld in ky b gy li lf l lg lh">let i = 0;</span><span id="539e" class="lc ld in ky b gy li lf l lg lh">setTimeout(() =&gt; console.log('i = ', i), i * 10); <em class="mz">// sent to browser API and then to the event loop queue</em></span><span id="a9ff" class="lc ld in ky b gy li lf l lg lh">})()</span><span id="9d6a" class="lc ld in ky b gy li lf l lg lh"><em class="mz">//Second round</em></span><span id="9368" class="lc ld in ky b gy li lf l lg lh">const secondRound = (() =&gt; {</span><span id="958a" class="lc ld in ky b gy li lf l lg lh">let i = 1;</span><span id="bfe9" class="lc ld in ky b gy li lf l lg lh">setTimeout(() =&gt; console.log('i = ', i), i * 10); <em class="mz">// sent to browser API and then to the event loop queue</em></span><span id="387f" class="lc ld in ky b gy li lf l lg lh">})()</span><span id="9aa9" class="lc ld in ky b gy li lf l lg lh"><em class="mz">//yields i =  0  i =  1</em></span></pre><p id="1f6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">再次强调，这里的关键点是<code class="fe ms mt mu ky b">setTimout</code>函数将记住它被触发的范围，当从事件循环中返回时，它将在记住的范围内使用变量。</p><p id="af49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一个场景中，当我们使用var声明时，<code class="fe ms mt mu ky b">setTimout</code>记忆的范围是全局范围，由于我们在这个范围内只有一个变量，它将使用最终值(5)。</p><p id="64f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第二个场景中，我们每一轮都有不同的范围，因此有一个新的“I”变量。</p><h1 id="20b8" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">提升</h1><p id="9e13" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">人们经常错误地认为提升意味着将变量(使用var关键字)和函数的声明移到代码的顶部。</p><p id="dc04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，实际上没人会碰你的代码，不用担心。</p><p id="1b73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，提升到底是怎么一回事呢？</p><p id="8865" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript引擎继续逐行执行我们的代码之前，它将对代码进行一次介绍性的会话。这就是所谓的解析时间。</p><p id="0372" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它遍历代码，寻找变量和函数的声明。</p><p id="bf47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦找到，它将把它们存储在内存中，或者更确切地说，在内存中保留一个特殊的位置(对于变量，它将在内存中保留一个未定义的位置作为值，对于函数，整个函数将保留在内存中)。</p><p id="6723" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当JS引擎运行代码时，如果它发现一个函数调用或变量在被声明之前就被使用了(在代码的底部),它将不会被“吓倒”,因为正如我们所说的，它将它们存储在内存中。</p><p id="cd3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么在我们的面试问题中，提升在哪里呢？</p><p id="b90a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上，非常简单。所有的var声明都被提升到代码的顶部。由于它们都声明同一个变量(I)，结果我们只有一个变量声明。像这样:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a5db" class="lc ld in ky b gy le lf l lg lh">var i;<br/>for(i=0; i&lt;5; i++) {</span><span id="2ec5" class="lc ld in ky b gy li lf l lg lh">setTimeout(()=&gt; console.log("i = ", i), i*10);</span><span id="0b07" class="lc ld in ky b gy li lf l lg lh">}</span></pre><h1 id="6661" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">如何解决</h1><p id="81b4" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们已经看到了如何使用var关键字解决这个问题。但是有另一种方法可以解决这个问题。有其他解决方案的想法吗？你应该能够用你到目前为止学到的知识解决这个问题。花点时间考虑一下。</p><p id="cda1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">明白了吗？</p><p id="1f38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们创建一个新的函数来保存我们的超时逻辑，我们将在每次迭代中创建一个新的闭包。让我们看看它是什么样子的:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1271" class="lc ld in ky b gy le lf l lg lh">const doSetTimeout = (i) =&gt; {<br/>  setTimeout(() =&gt; { console.log(i) },i*10);<br/>}</span><span id="b533" class="lc ld in ky b gy li lf l lg lh">for (var i = 0; i &lt; 5; i++)<br/>  doSetTimeout(i);</span></pre><p id="a470" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们将“I”的值传递给我们的<code class="fe ms mt mu ky b">doSetTimeout</code>函数。由于每次迭代都会创建一个带有参数值“I”的新闭包，所以我们会像预期的那样在控制台上打印0，1，2，3，4。</p><h1 id="34c0" class="lj ld in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="936f" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我相信这篇文章的关键在于，为了在面试中取得成功，你必须非常了解JavaScript的核心概念。</p><p id="3384" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使你没有说出正确的答案——继续向面试官解释JavaScript是如何在幕后工作的。一旦你表现出你对这个问题很了解，我相信你会给面试官留下一个好印象。</p><p id="b9e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">面试官也是一样——不要期望你的面试者把所有事情都做对。面试可能是一件令人紧张的事情，他的精神可能不在最佳状态。相反，鼓励他展示他的知识，并以此来评估他。</p><p id="5892" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mz">更多内容尽在</em> <a class="ae mv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mz">说白了. io </em> </strong> </a> <em class="mz">。报名参加我们的</em> <a class="ae mv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mz">免费周报</em> </strong> </a> <em class="mz">。在我们的</em> <a class="ae mv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mz">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="mz">。</em></p></div></div>    
</body>
</html>