<html>
<head>
<title>Explained: All You Need to Know About JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释:所有你需要知道的关于JavaScript的承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/explained-all-you-need-to-know-about-javascript-promises-5d35df9d9919?source=collection_archive---------8-----------------------#2021-04-27">https://javascript.plainenglish.io/explained-all-you-need-to-know-about-javascript-promises-5d35df9d9919?source=collection_archive---------8-----------------------#2021-04-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0c2f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">你的父母答应过给你买你想要的东西吗？</h2></div><p id="6b1a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在您开始阅读本文之前，您需要了解以下先决条件:</p><ul class=""><li id="fc26" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><a class="ae lh" href="https://medium.com/dev-genius/master-javascript-basics-in-8-minutes-97b3c679eade" rel="noopener">JavaScript基础知识</a></li><li id="3606" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">JavaScript中的类</li><li id="f2db" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">JavaScript中的模块</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/7ed2ac307ad8a116bea9e6910e41a473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CLzJucPYped3sEW4"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@andrewwwpetrov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Petrov</a> on <a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="6855" class="md me in bd mf mg mh dn mi mj mk dp ml kl mm mn mo kp mp mq mr kt ms mt mu mv bi translated">JavaScript中的异步操作是什么？</h2><p id="9198" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">异步操作是指允许计算机在等待异步操作完成的同时继续执行其他代码的操作。也就是说，我们可以通过使用异步方法来节省时间，并防止程序暂停。</p><p id="8ff4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">异步操作</strong>的一个真实例子是当你的机器人帮你做家务时；在此期间你可以做任何你想做的事情。</p><p id="cf3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">计算机也是如此。我们在编程中也使用异步方法。例如，像向数据库发出网络请求这样的操作可能会很乏味并且非常耗时，但是JavaScript有能力在等待其完成的同时执行其他任务。</p><p id="0db0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们深入研究使用<code class="fe nb nc nd ne b">Promise</code>处理异步操作的现代<strong class="ke io"> JavaScript </strong>。</p><h1 id="2c33" class="nf me in bd mf ng nh ni mi nj nk nl ml jt nm ju mo jw nn jx mr jz no ka mu np bi translated">JavaScript中的宏任务</h1><p id="4e50" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">在理解JavaScript中的Promise之前，应该先理解macrotasks。宏任务使开发人员能够以同步方式异步执行任务。JavaScript中有一些宏任务。比如<code class="fe nb nc nd ne b"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" rel="noopener ugc nofollow" target="_blank"><strong class="ke io">setInterval</strong></a></code>、<code class="fe nb nc nd ne b"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate" rel="noopener ugc nofollow" target="_blank"><strong class="ke io">setImmediate</strong></a></code>、<code class="fe nb nc nd ne b"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank"><strong class="ke io">setTimeout</strong></a></code>、T14。</p><p id="fd97" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是为了这篇文章，我将只通过<code class="fe nb nc nd ne b">setTimeout</code>。那么，<code class="fe nb nc nd ne b">setTimeout</code>到底是做什么的呢？<code class="fe nb nc nd ne b">setTimeout</code>是一个<strong class="ke io">节点API </strong> <strong class="ke io">(也称为web API) </strong>，它对延迟后要执行的任务进行排序。<code class="fe nb nc nd ne b">setTimeout</code>接收一个回调函数和你希望它延迟多少毫秒。</p><p id="9907" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nq"><img src="../Images/9f98572c1c00e120b65c11b7a62d2e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4twrmSDnSqQlCHcN4urSCA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of <strong class="bd nr">setTimeout( )</strong></figcaption></figure><ul class=""><li id="ce2b" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">从上面的例子中，我们将首先完成同步操作，即<code class="fe nb nc nd ne b">console.log(“I am first”);</code>,它将压入堆栈并打印到控制台。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/f0c23a68029d36ed8dcd805ec5a3f8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AK5vi8_3iSgXhWQinVffmA.gif"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of <strong class="bd nr">console.log(“I am first”);</strong></figcaption></figure><ul class=""><li id="9072" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">接下来是<code class="fe nb nc nd ne b">console.log(“I am second”);</code>。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/d1b6d00999b3292a64a54e21b522cf64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ThcB-EX4-mprCUBSKEIfIQ.gif"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of <strong class="bd nr">console.log(“I am second”);</strong></figcaption></figure><ul class=""><li id="3182" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">然后到了<code class="fe nb nc nd ne b">useMacro</code>回合，<code class="fe nb nc nd ne b">useMacro</code>只会在1秒后执行。这种延迟是异步执行的。这意味着我们的程序不会在延迟期间突然停止。它仍在运行，但现在在一个队列中。我将在下面的图片中解释更多关于队列的内容。以防你需要一些数学帮助:</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/5b354b02d252c281cb369b21e3920e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*LnB0MAlDy2_jKtjtXb3igg.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">millisecond to second</figcaption></figure><ul class=""><li id="1d51" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><code class="fe nb nc nd ne b">setTimeout( )</code>将在栈为空时被推入栈中，回调函数将被推入Web API进行处理。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/4550173b3c1368b1dde4b8edb160a63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JzK-h-Js3sQ2gfbiE5wEdw.gif"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of <strong class="bd nr">setTimeout( )</strong></figcaption></figure><ul class=""><li id="8961" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">Web API会将回调发送到队列中，并等待完成。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/dafe23b9db5812fb4e2d4acd75b5d0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*C3GHcvNM2YO8Org7FErIRw.gif"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of <strong class="bd nr">setTimeout( )</strong></figcaption></figure><ul class=""><li id="01be" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">1秒钟后，队列中的回调函数将被推入堆栈，并记录到控制台的<code class="fe nb nc nd ne b">I am third</code>。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/b0a54a3c55a8a2f3e08fa82bf085c60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-EF9dpEp5Mf8K_UUhFT57g.gif"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of <strong class="bd nr">console.log(“I am third”)</strong></figcaption></figure><ul class=""><li id="2b20" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">在异步JavaScript中，有一个东西叫做<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">事件循环</strong> </a>。Event-loop的工作是充当<strong class="ke io">队列</strong>和<strong class="ke io">堆栈之间的中间人；如果堆栈中什么都没有，那么队列中的代码将被推入堆栈并开始执行。</strong></li><li id="e4f7" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">在<code class="fe nb nc nd ne b">useMacro</code>可以运行之前，同步代码将首先运行。最后，在所有的同步代码之后，<code class="fe nb nc nd ne b">useMacro</code>将运行并返回<code class="fe nb nc nd ne b">I am third</code>到控制台。</li><li id="c12d" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">这就是我们最终会得到的结果:</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/6396e66d92976f3bb1e2b547b668938d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mM-omr7Z8EaAPT6tUFyrQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of the final result</figcaption></figure><h1 id="0cd6" class="nf me in bd mf ng nh ni mi nj nk nl ml jt nm ju mo jw nn jx mr jz no ka mu np bi translated">那么，什么是承诺呢？</h1><p id="d267" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">承诺是表示异步操作的未来结果(<em class="nu">成功</em>或<em class="nu">失败</em>)的对象。</p><p id="bbbc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">承诺由三种状态组成:</p><ul class=""><li id="d87c" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="ke io">待定</strong>:尚未完成操作的初始状态。</li><li id="a901" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="ke io">已履行</strong>:操作已成功完成，承诺具有已解析的值。</li><li id="6430" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="ke io">拒绝</strong>:操作失败，承诺有失败原因。通常会导致一个<code class="fe nb nc nd ne b">Error</code>。</li></ul><p id="4300" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个现实生活中的承诺的例子:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nv"><img src="../Images/540973641354a2d08656c741b8a2b443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6aABwgM5AcjPS5novQchQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">An example of a <strong class="bd nr">promise</strong></figcaption></figure><p id="28f8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上图可以看出，承诺初始状态将一直处于<strong class="ke io"> <em class="nu">等待</em> </strong>模式。如果它被解析，那么它将有一个解析值，否则如果它被拒绝，它将有一个<code class="fe nb nc nd ne b">Error</code>来说明失败的原因。</p><h1 id="8718" class="nf me in bd mf ng nh ni mi nj nk nl ml jt nm ju mo jw nn jx mr jz no ka mu np bi translated">承诺对象长什么样？</h1><p id="f443" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">我们使用<code class="fe nb nc nd ne b">new</code>关键字和<code class="fe nb nc nd ne b">Promise</code>构造函数方法来创建一个新的<code class="fe nb nc nd ne b">Promise</code>对象。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nq"><img src="../Images/011692eba4e7b4562987e9cc3c1bf8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHfjU195e-UT_Aqde_uo3g.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">An example of a <strong class="bd nr">promise object</strong></figcaption></figure><ul class=""><li id="da75" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">首先，我们将制作一个函数，该函数也被称为<strong class="ke io"> <em class="nu">执行函数。</em> </strong>从上面的例子来看，<strong class="ke io"> <em class="nu"> </em> </strong> <code class="fe nb nc nd ne b">anyFunction</code>就是我们的<strong class="ke io"> <em class="nu">执行程序功能</em> </strong>。</li><li id="b4c9" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><strong class="ke io"> <em class="nu">执行器函数</em> </strong>将接收两个函数作为参数，它们将决定未来的结果。</li><li id="5e54" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><code class="fe nb nc nd ne b">resolve</code>和<code class="fe nb nc nd ne b">reject</code>是作为参数的两个函数。</li><li id="13b4" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">如果<code class="fe nb nc nd ne b">specifyYourConditionHere</code>为<strong class="ke io">真</strong>，那么<code class="fe nb nc nd ne b">resolve( )</code>代码将运行并返回<code class="fe nb nc nd ne b">‘I resolved!’</code>。然后将<em class="nu">承诺的状态</em>从<strong class="ke io">待决</strong>变为<strong class="ke io">已履行</strong>。</li><li id="aaa9" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">否则<code class="fe nb nc nd ne b">reject( )</code>代码将运行并返回<code class="fe nb nc nd ne b">‘I rejected!’</code>。然后将<em class="nu">承诺的状态</em>从<strong class="ke io">待决</strong>变为<strong class="ke io">拒绝</strong>。</li><li id="3e5d" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><code class="fe nb nc nd ne b">Promise</code>构造函数接受一个函数参数，即<strong class="ke io"> <em class="nu">执行器函数</em> </strong>，开始异步运行代码。结果将是<strong class="ke io">解决</strong>或<strong class="ke io">拒绝</strong>。</li></ul><h1 id="0591" class="nf me in bd mf ng nh ni mi nj nk nl ml jt nm ju mo jw nn jx mr jz no ka mu np bi translated">如何使用承诺？</h1><p id="9e2f" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">由于<code class="fe nb nc nd ne b">Promise</code>的初始状态将始终处于<strong class="ke io">待定</strong>模式，承诺将始终有一个未来结果，要么<strong class="ke io">履行</strong>要么<strong class="ke io">拒绝</strong>。</p><p id="6618" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是你有没有问过自己，在它运行完<code class="fe nb nc nd ne b">Promise</code>之后，我能做什么？</p><p id="ab35" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用<code class="fe nb nc nd ne b">.then( )</code>来跟进另一个动作。这个方法总是返回一个<code class="fe nb nc nd ne b">Promise</code>。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nw"><img src="../Images/586a9e04aa53c4ddc549c698373f1545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUwxhNBTev1Ddk-0U9tsJA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">An example of using<code class="fe nb nc nd ne b"> <strong class="bd nr">promise</strong></code></figcaption></figure><p id="f2fc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的例子来看，</p><ul class=""><li id="fd57" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">如果<code class="fe nb nc nd ne b">pending promise</code>得到<code class="fe nb nc nd ne b">resolve</code>的结果，这意味着<strong class="ke io">满足</strong>，那么项目完成。</li><li id="489f" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">如果一个<code class="fe nb nc nd ne b">pending promise</code>得到一个<code class="fe nb nc nd ne b">reject</code>的结果，这意味着<strong class="ke io">被拒绝</strong>，那么它将开始偷懒。</li></ul><p id="7db3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">供您参考，<code class="fe nb nc nd ne b">.then( )</code>是一个高阶函数，它使用<strong class="ke io">两个参数</strong>来表示<strong class="ke io">回调函数</strong>。两个参数的<strong class="ke io">称为<strong class="ke io">处理程序</strong>。</strong></p><p id="09ff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有哪些<strong class="ke io">两个经手人</strong>？</p><ol class=""><li id="a72d" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx nx le lf lg bi translated">第一个处理程序称为<strong class="ke io">成功处理程序</strong>、<code class="fe nb nc nd ne b">onFulfilled</code>。它应该包含表明承诺已解决的逻辑。</li><li id="80a7" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx nx le lf lg bi translated">第二个处理程序被称为<strong class="ke io">故障处理程序</strong>、<code class="fe nb nc nd ne b">onRejected</code>。它应该包含表明承诺被拒绝的逻辑。</li></ol><h1 id="420f" class="nf me in bd mf ng nh ni mi nj nk nl ml jt nm ju mo jw nn jx mr jz no ka mu np bi translated">如何使用成功/失败处理程序作为回调函数？</h1><p id="6356" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">当<strong class="ke io">被解决</strong>或<strong class="ke io">被拒绝</strong>时，为了处理一个成功或失败的承诺，我们可以将成功和失败处理程序传递到一个<strong class="ke io">回调函数</strong>，然后用<code class="fe nb nc nd ne b">.then( )</code>调用它，如下所示:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nq"><img src="../Images/e33d0008afbd5b18b46681496ef53192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODnADPqY3WlsMwgn5OmkRQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">An example of <strong class="bd nr">success/failure handlers</strong> using <strong class="bd nr">callback functions</strong></figcaption></figure><p id="926d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的例子来看:</p><ul class=""><li id="43d6" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><code class="fe nb nc nd ne b">work</code>是一个承诺，用一个条件语句检查它是否被解析，然后它将返回一个被解析的值<code class="fe nb nc nd ne b">Working on side projects</code>，否则返回一个被拒绝的值<code class="fe nb nc nd ne b">Unclear what to do</code>。</li><li id="f465" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">然后我们将定义一个函数<code class="fe nb nc nd ne b">success( )</code>和<code class="fe nb nc nd ne b">failure( )</code>。然后我们将打印传递给它的参数。</li><li id="ed84" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">接下来，我们用<code class="fe nb nc nd ne b">.then( )</code>调用<code class="fe nb nc nd ne b">work</code>，传入<code class="fe nb nc nd ne b">success( )</code>和<code class="fe nb nc nd ne b">failure( )</code>函数。</li><li id="76db" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">您可能已经知道，它将被解析并返回一个值，然后记录到控制台<code class="fe nb nc nd ne b">Working on side projects</code>。</li></ul><h2 id="a5ec" class="md me in bd mf mg mh dn mi mj mk dp ml kl mm mn mo kp mp mq mr kt ms mt mu mv bi translated">为什么不遵循关注点分离(SoC)规则？</h2><p id="94df" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">以上只是开始，遵循<a class="ae lh" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"><strong class="ke io">【SoC】</strong></a><strong class="ke io"/>的规则，这就是<strong class="ke io"> </strong> <code class="fe nb nc nd ne b">.catch( )</code>功能发挥作用的地方。</p><p id="3e72" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数将只接受一个参数<code class="fe nb nc nd ne b">onRejected</code>，并返回拒绝的原因。<code class="fe nb nc nd ne b">.catch( )</code>实现与<code class="fe nb nc nd ne b">.then( )</code>相同的功能，但仅用于抓住<code class="fe nb nc nd ne b">Error</code>。</p><p id="9a21" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nq"><img src="../Images/862c9081f9c8387354e595f12942ccb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f388i8n1NEVNNn09U1X60Q.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of <strong class="bd nr">SoC</strong></figcaption></figure><p id="bac0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图中有一个使用<code class="fe nb nc nd ne b">.catch( )</code>的代码片段。由于<code class="fe nb nc nd ne b">reject</code>为真，因此我们将返回<code class="fe nb nc nd ne b">Unclear what to do</code>作为拒绝的理由。</p><p id="0a26" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过实现<strong class="ke io"> SoC，</strong>我们能够提高代码的可读性，并在代码的某个特定部分出错时更容易调试。</p><h2 id="cde4" class="md me in bd mf mg mh dn mi mj mk dp ml kl mm mn mo kp mp mq mr kt ms mt mu mv bi translated">如何使用承诺。所有()？</h2><p id="57ca" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">如果您有一大堆承诺呢？你会等到所有的承诺都一一解决吗？这就是<code class="fe nb nc nd ne b">Promise.all( )</code>发挥作用的地方。</p><p id="6415" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">Promise.all( )</code>接受一系列承诺，但只回报一个承诺。</p><ul class=""><li id="81f3" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">如果数组中的每个承诺都被解析，那么<code class="fe nb nc nd ne b">Promise.all( )</code>将返回一个包含解析值的承诺。</li><li id="fa12" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">如果数组中的单个承诺被拒绝，则后续等待解析的承诺也将被拒绝，也称<strong class="ke io"> <em class="nu">快速失败</em> </strong>，则<code class="fe nb nc nd ne b">Promise.all( )</code>返回包含拒绝原因的承诺。</li></ul><p id="55b2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nq"><img src="../Images/bb42b6a8596b3f82310f1583c05ac619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ij6ZFwupnqFWCYaVhvEHeA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of <strong class="bd nr">Promise.all( )</strong></figcaption></figure><ul class=""><li id="5c0e" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">综上所述，我们有<strong class="ke io">三个</strong> <strong class="ke io">承诺</strong>等待完成。</li><li id="74c9" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">其次，我们使用<strong class="ke io">成功</strong>和<strong class="ke io">失败处理程序</strong>作为<strong class="ke io">回调函数</strong>。</li><li id="9f95" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">然后我们创建一个变量，存储<code class="fe nb nc nd ne b">Promise.all( )</code>。</li><li id="9004" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><code class="fe nb nc nd ne b">Promise.all( )</code>将决定<strong class="ke io">三个承诺</strong>是<strong class="ke io">拒绝</strong>还是<strong class="ke io">决议</strong>。</li><li id="bc6f" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">最后，我们调用变量<code class="fe nb nc nd ne b">myPromises</code>和<code class="fe nb nc nd ne b">.then( )</code>返回解析值和<code class="fe nb nc nd ne b">.catch( )</code>拒绝原因。</li><li id="07ba" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">由于<strong class="ke io">一个承诺</strong>被拒绝即<code class="fe nb nc nd ne b">example3</code>，那么<code class="fe nb nc nd ne b">.catch( )</code>将会尽力找出被拒绝的原因即<code class="fe nb nc nd ne b">Failed: I rejected!</code>。</li></ul><h1 id="a3dd" class="nf me in bd mf ng nh ni mi nj nk nl ml jt nm ju mo jw nn jx mr jz no ka mu np bi translated"><strong class="ak">结论</strong></h1><p id="6781" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">这就是JavaScript中的承诺。请记住，承诺是能够解决或<strong class="ke io">拒绝的东西——它将永远处于<strong class="ke io">等待模式</strong>。你从这篇文章中学到了什么吗？我希望你觉得这篇文章有用，谢谢你的阅读。</strong></p><p id="652e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nu">通过</em><a class="ae lh" href="https://www.linkedin.com/in/eugene-goh-5236241a9/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nu">LinkedIn</em></strong></a><em class="nu">和</em><a class="ae lh" href="https://twitter.com/EugeneGohHere" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nu">Twitter</em></strong></a><strong class="ke io"><em class="nu">与我联系。</em>T19】</strong></p><p id="955b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nu">更多内容请看</em><a class="ae lh" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nu">plain English . io</em></a></p></div></div>    
</body>
</html>