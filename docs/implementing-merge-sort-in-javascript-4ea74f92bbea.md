# 在 JavaScript 中实现合并排序

> 原文：<https://javascript.plainenglish.io/implementing-merge-sort-in-javascript-4ea74f92bbea?source=collection_archive---------19----------------------->

![](img/f2a78f7c97c52bdc94ac8c42d6a657e4.png)

Photo by [Tomas Sobek](https://unsplash.com/@tomas_nz?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

合并排序是一种采用分治法的排序算法。这是迄今为止我所涉及的最快的排序算法，但代价是它占用了更多的空间。当您使用 JavaScript 的`.sort()`时，它实际上可能在幕后调用合并排序。因此，如果您不熟悉递归，您可能希望先了解一下。

# 逐步示例

# 预期结果

按升序排序
输入:[4，2，5，1，3，6]
输出:[1，2，3，4，5，6]

# 拆分数组

合并排序的方法与我们已经研究过的许多算法大不相同。它要做的第一件事是将数组分解成 1 元素数组。这是*分而治之*的一部分。

## 第一步

[4, 2, 5, 1, 3, 6] → [4, 2, 5] [1, 3, 6]

## 第二步

[4，2，5]→4[2，5]
[1，3，6]→1[3，6]

## 第三步

[4]
[2，5] → [2] [5]
[1]
[3，6] → [3] [6]

## 结果

[4] [2] [5] [3] [6]

# 合并数组

现在，我们已经将阵列分成了 1 个元素子阵列，我们的下一步是将它们放在一起，边走边排序。

## 第一步

我们需要遍历我们的每个 1 元素数组，并将它们组合成 2 个已排序的元素数组。在下一步，当我们在每个数组中有更多的元素要处理时，我将更深入地讨论排序过程。
[4] [2] [5] [1] [3] [6] → [2，4] [1，5] [3，6]

## 第二步

现在我们有了 2 个元素数组，让我们更仔细地看看对它们进行排序的过程。

为了合并，我们将采用两个排序的数组，并将它们合并成一个排序的数组。我们需要一个空数组，我们称之为合并数组。首先，我们有两个已经排序的数组和一个空数组。
arr1 = [2，4]
arr2 = [1，5]
合并= []

现在，我们需要比较两个数组的第一个元素。
2 > 1，因此需要将 1 复制到已合并的
[ **2** ，4] [ **1** ，5]
已合并= [1]

由于我们已经将 arr2 中的第一个元素添加到合并后的数组中，我们需要检查 arr2 的第二个元素。
2 < 5
[ **2** ，4【1】， **5** ]
合并= [1，2]

现在我们将检查 arr1 的第二个元素，因为我们已经复制了它的第一个元素。
[2、 **4** ] [1、 **5** ]
合并= [1、2、4]

arr1 中没有更多要检查的元素，所以我们只需要看看 arr2 中是否还有剩余的元素，然后将它们添加到 merged 中。
合并= [1，2，4，5]

结果:
[2，4] [1，5] [3，6] → [1，2，4，5] [3，6]

因此，合并时的排序过程如下所示:

*   首先检查两个数组的第一个元素
*   将最小的元素复制到合并的数组中
*   检查数组中具有较小元素的下一个元素
*   重复，直到检查完其中一个数组中的每个元素
*   将另一个数组的剩余元素添加到我们的合并数组中

## 最后一档

现在我们只剩下两个数组，剩下要做的就是将它们合并在一起

让我们按照上面的步骤进行。

arr1 = [1，2，4，5]
arr2 = [3，6]
合并= []

[ **1** ，2，4，5] [ **3** ，6]
1 < 3
合并= [1]

[1， **2** ，4，5] [ **3** ，6】
2<3
合并= [1，2]

[1，2， **4 【T22，】5] [ **3 【T24，6】
4>3
合并= [1，2，3]****

[1，2， **4** ，5] [3，**6**
4<6
合并= [1，2，3，4]

[1，2，4， **5** ] [3， **6** ]
5 < 6
合并= [1，2，3，4，5]

现在我们已经检查了 arr1 中的所有元素，所以我们将检查是否有元素要添加到 arr2 中的 merged，并添加它们。
合并= [1，2，3，4，5，6]

我们只剩下一个排序后的数组。

# 密码

让我们从合并两个有序数组的函数开始。

```
function merge(arr1, arr2) {
    let merged = []; // index for arr1
    let index1 = 0; // index for arr2
    let index2 = 0; while (index1 < arr1.length && index2 < arr2.length) {
        if (arr1[index1] < arr2[index2]) {
            merged.push(arr1[index1]);
            index1++;
        } else {
            merged.push(arr2[index2]);
            index2++;
        }
    } while (index1 < arr1.length) {
        merged.push(arr1[index1]);
        index1++;
    } while (index2 < arr2.length) {
        merged.push(arr2[index2]);
        index2++;
    } return merged;
}
```

所以我们开始了一个`while`循环，它将一直运行，直到其中一个索引等于其各自数组的长度(这模拟了运行的行为，直到我们检查完一个数组中的所有元素)。在`while`循环中，我们将检查哪个元素更小，然后将该元素放入合并后的数组中。只有在推入数组的一个元素后，我们才增加它的索引。

一旦我们跳出循环，我们将添加另一个数组的剩余元素。我们不知道这将是哪个数组，所以我们设置了另外两个`while`循环。它们只有在数组中有未检查的元素时才会运行，并且会一直运行到该数组的所有元素都被添加到`merged`中。

现在我们有了一个函数来合并两个排序后的数组，我们准备好创建我们的`mergeSort`函数了。

```
function mergeSort(arr) {
    // base case
    if (arr.length < 2) return arr; let mid = Math.floor(arr.length / 2);
    let firstHalf = arr.slice(0, mid);
    let secondHalf = arr.slice(mid); return merge(mergeSort(firstHalf), mergeSort(secondHalf));
}
```

首先，我们设置我们的基本情况，即如果数组中只有一个元素，我们需要返回该数组。如果不是，我们找到数组的中点。我们使用中点将数组分成两个独立的部分。然后，我们在每一半上递归调用`mergeSort`，最后将这两个一起调用`merge`并返回。

## 理解递归

如果你觉得很难思考/推理递归，这段代码可能会令人困惑。如果没有，请随意跳过这一部分。

关于递归需要理解的是，它是从基本情况开始的。它不断地将自己的函数调用添加到堆栈中，直到其中一个函数调用可以解决为止(我们的基本情况)，然后它开始向后处理之前的函数调用。

这意味着只有当它达到了我们返回 1 个元素数组的基本情况时，它才会开始合并过程。让我们通过一个非常小的例子来更好地理解它。

如果我们称之为`mergeSort([3, 2, 1])`，它会将数组分成两半，然后称之为`merge(mergeSort([3]), mergeSort([2, 1]))`。

`mergeSort([3])`将返回`[3]`因为它到达了我们的基地箱所以现在我们有:`merge([3], mergeSort([2, 1]))`。

`mergeSort([2, 1])`将再次将我们的阵势一分为二，然后召唤`merge(mergeSort([2]), mergeSort([1])`。

因此，现在作为一个整体，我们有:`merge([3], merge(mergeSort[2], mergeSort([1])))`。

我们对`mergeSort([2])`的调用将到达我们的基本案例，因此现在我们有:`merge([3], merge([2], mergeSort([1])))`

我们对`mergeSort([1])`的调用将到达我们的基本案例，所以现在是:
`merge([3], merge([2], [1]))`

然后，我们对`merge([2], [1])`的调用将解析为给我们[1，2]。现在我们有:`merge([3], [2, 1])`。

最后，我们得到了[1，2，3]的排序数组。

# 时间复杂性、空间复杂性和稳定性

## 时间复杂性

合并排序的时间复杂度为*线性*或 **O(n log n)** 。这是它的最佳、最差和平均时间复杂度。为了更充分地理解为什么，我建议阅读这篇关于汗学院的文章，因为理解线性时间本身是一个足够困难的话题。理解线性时间很重要，因为它是任何比较排序类型算法产生的最佳时间复杂度。比较排序是将元素相互比较，以找到数组的顺序。因此，到目前为止，我们所做的每一个算法都是一种比较排序。

## 空间复杂性

我们的合并排序的实现并没有在适当的位置进行*排序，这意味着它不仅仅是在输入数组中的元素之间移动，而是必须创建自己的数组来存储排序后的元素。**需要 O(n)个空间**。这是因为对于每个递归调用，它将创建两个数组，每个数组的大小等于输入大小的一半。然而，这些子阵列不会同时存在于内存中(随着对`mergeSort()`的递归调用的解决，这些阵列中的每一个都将终止)。*

## 稳定性

合并排序是一种稳定的排序算法。简而言之，这意味着相同的值将保持它们在原始数组中的顺序。

# 总之…

值得注意的是，有些合并排序的实现可能需要恒定的时间。因为它的线性时间复杂度是合并排序的一个较大的缺点，所以它可能值得研究。现在你知道了合并排序，你知道了一个更广泛使用的排序算法，祝贺你！如果你想看这篇博客中使用的代码，我已经把它放在 GitHub 仓库[这里](https://github.com/ReginaF2012/JavaScript_MergeSort)。