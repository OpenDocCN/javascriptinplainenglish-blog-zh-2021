<html>
<head>
<title>9 Programming Principles Every Software Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个软件开发人员都应该知道的9条编程原则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/9-programming-principles-every-software-developer-should-know-9fffe3c5258?source=collection_archive---------9-----------------------#2021-03-22">https://javascript.plainenglish.io/9-programming-principles-every-software-developer-should-know-9fffe3c5258?source=collection_archive---------9-----------------------#2021-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4f79" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">很好地了解干净代码的编程原则</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/690d8689c2125fafabf497097b545650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6X-IocFIb49W8w6p.jpg"/></div></div></figure><h1 id="3cc1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">1.YAGNI</h1><blockquote class="lj"><p id="5f4b" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">你不需要它</p></blockquote><p id="8a62" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo lt ij bi translated">这是<strong class="lw ir">极限编程</strong>的一个原理，一般用在<em class="mp">敏捷软件开发</em>过程中。根据这个原则，我们不应该添加任何功能，直到它被认为是必要的，或者更简单地说，你的代码应该总是与当前的情况相关。不要添加任何你将来需要的东西，你的代码应该呈现当前情况的逻辑，而不是需要在过程的后期解决的东西。</p><p id="291a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="cca9" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">避免软件在开发的早期变得更大更复杂。</li></ul><h1 id="5c96" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">2.吻</h1><blockquote class="lj"><p id="392d" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">简单点，笨蛋</p></blockquote><p id="f3ac" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo lt ij bi translated">这个原则的重点是保持代码库的简单，并且对其他开发人员来说是描述性的。不仅仅是开发人员，在遵循这个原则的同时，你的代码必须是人类可以理解的。保持方法简单和整洁，避免在每个方法中添加超过50-60行。</p><p id="b648" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated">每种方法一次只能解决一个小问题，如果方法中有很多条件，那么就把它们分解成更小的方法。</p><p id="3382" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="30b2" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">使得与其他开发人员一起工作变得更加容易，因为他们不必花费大量的时间阅读任何杂乱的代码。</li></ul><h1 id="0bc8" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">3.美国汽车协会</h1><blockquote class="lj"><p id="f5db" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">安排，行动，断言</p></blockquote><figure class="nf ng nh ni nj kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/6da565c3e6b64d54c7c0e50b3830e78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5r4js5xmtjWy0mjqIHA3ow.png"/></div></div></figure><p id="4fe0" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated">软件开发行业的一个标准原则，这个原则建议你应该把你的<em class="mp">测试</em>方法分成三个部分&amp;，每个部分只负责它们被命名的那部分。</p><ul class=""><li id="5493" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated"><strong class="lw ir">安排:</strong>设置特定测试所需的代码</li><li id="6fe7" class="mv mw iq lw b lx nk ma nl md nm mh nn ml no lt na nb nc nd bi translated"><strong class="lw ir">动作:</strong>调用被测试的方法</li><li id="3537" class="mv mw iq lw b lx nk ma nl md nm mh nn ml no lt na nb nc nd bi translated"><strong class="lw ir">断言:</strong>检查测试是否符合预期</li></ul><p id="6b30" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="91c3" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">使执行多个单元测试变得更加容易</li></ul><h1 id="3615" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">4.干燥的</h1><blockquote class="lj"><p id="a746" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">不要重复你自己</p></blockquote><p id="6c64" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo lt ij bi translated">您一定听说过这一条，这是最著名的编程原则之一，在编写代码时应用它，以减少相同方法的重复。程序中的每一个重要功能都应该在代码中的一个地方实现&amp;类似的功能由其他一些不同的代码段执行。</p><p id="8a06" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="4ba9" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">避免代码库中的重复，因为这会导致重大的维护问题。同样，如果没有这个原则，就更有可能构建出糟糕的重构代码库。</li></ul><h1 id="248c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">5.童子军规则</h1><blockquote class="lj"><p id="008d" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">让代码比你发现时更干净</p></blockquote><p id="56e1" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo lt ij bi translated">我个人认为这个原则非常有用，因为它有助于保持我离开工作时的环境。根据这个原则，你应该总是保持你的代码库像开始时一样干净。比方说，当我们在应用程序中处理一个特性时，我们在顶部添加了更多的功能，最终它变得不可读，现在我们没有清理这些代码，过了一段时间，我们意识到没有什么是有意义的。</p><p id="6f3a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="e077" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">您将始终拥有一个可维护且可读的代码库</li></ul><h1 id="8024" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">6.第一</h1><blockquote class="lj"><p id="1f8a" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">快速、独立、可重复、自我验证和彻底</p></blockquote><p id="d9c9" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo lt ij bi translated">在编写健壮的单元测试时应用这个原则，并结合如下多个原则:</p><ul class=""><li id="712e" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated"><strong class="lw ir">快:</strong>单元测试必须更快，当运行<em class="mp">单元测试</em>时，它们不应该与任何<strong class="lw ir">远程服务器</strong>或<strong class="lw ir">数据库</strong>通信，由于这个原因，当你实现新的应用程序特性时，你可以经常运行<em class="mp">单元测试</em>。</li><li id="2976" class="mv mw iq lw b lx nk ma nl md nm mh nn ml no lt na nb nc nd bi translated"><strong class="lw ir">独立:</strong>单元测试应该是独立的，一个单元测试不应该依赖于另一个单元测试产生的结果。此外，您正在测试的代码应该与它的<strong class="lw ir">依赖关系</strong>隔离开来，这可以确保一些随机的bug不会破坏整个单元测试<strong class="lw ir"> <em class="mp">(依赖关系通常会被嘲笑或者被提供一些预定义的数据)。</em> </strong></li><li id="1693" class="mv mw iq lw b lx nk ma nl md nm mh nn ml no lt na nb nc nd bi translated">可重复:如果在不同的机器上执行，单元测试应该能够产生相同的结果。</li><li id="8f31" class="mv mw iq lw b lx nk ma nl md nm mh nn ml no lt na nb nc nd bi translated"><strong class="lw ir">自验证:</strong>单元测试应该是自验证的，这意味着，无论测试是否通过，开发人员都不必在<em class="mp">单元测试结束后执行任何手动检查。</em></li><li id="3d22" class="mv mw iq lw b lx nk ma nl md nm mh nn ml no lt na nb nc nd bi translated"><strong class="lw ir">彻底:</strong>考虑到单元测试中的负面结果，我们应该在<em class="mp">正面</em>和<em class="mp">负面</em>场景下运行我们的测试，以获得更可靠的结果。一个单元测试将在有效的输入参数下测试函数，另一个单元测试将在无效的输入参数下测试函数。</li></ul><p id="0fc3" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="7b67" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">最小化单元测试中的错误，并导致更快的单元测试</li></ul><h1 id="abf5" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">7.控制反转</h1><blockquote class="lj"><p id="6011" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">请勿来电；我们会通知你</p></blockquote><p id="8d73" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo lt ij bi translated">它意味着你如何控制组件(<strong class="lw ir">类</strong>)。之所以称之为反转，是因为在这种模式之前，这些类对它们将做什么的定义是固定的。控制反转改变方法签名的耦合方向&amp;方法签名的定义由方法实现而不是方法调用方决定。</p><p id="ce53" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="86b4" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">它用于增加程序的模块化，使其更具可扩展性。</li></ul><h1 id="5a2f" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">8.鲁棒性原则</h1><blockquote class="lj"><p id="f4ad" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">在你做的事情上要保守，在你接受别人的事情上要开明</p></blockquote><p id="7929" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo lt ij bi translated">这个原则反映了计算机界面应该能够接受许多不同形式的信息，但总是返回相同的信息。由于这个原因，你总是知道你的软件会有什么样的结果。</p><p id="3e13" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="ab5a" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">你可以在不破坏现有产品的情况下，用新的特性来改进当前的软件。</li></ul><h1 id="02e1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">9.命令查询分离</h1><blockquote class="lj"><p id="0ef4" class="lk ll iq bd lm ln lo lp lq lr ls lt dk translated">提问不应该修改答案</p></blockquote><p id="d19e" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo lt ij bi translated">每个方法应该要么处理<strong class="lw ir">查询</strong>，要么<strong class="lw ir">执行</strong>一个将数据返回给调用者的动作，但不能同时处理两者。使用这个原则，开发人员可以建立更多的信心，因为查询方法可以在任何地方以任何顺序使用。</p><p id="f7ac" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo lt ij bi translated"><strong class="lw ir"> <em class="mp">优点:</em> </strong></p><ul class=""><li id="bf83" class="mv mw iq lw b lx mq ma mr md mx mh my ml mz lt na nb nc nd bi translated">开发人员无需了解每个方法的实现细节，就可以更加自信地进行编码。</li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt nw"><a rel="noopener  ugc nofollow" target="_blank" href="/7-concepts-you-should-know-as-a-javascript-developer-f406597319ab"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">JavaScript开发人员应该知道的7个概念</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">在下一个JavaScript项目中使用的基本概念</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="of l"><div class="og l oh oi oj of ok kp nw"/></div></div></a></div><div class="ol om gp gr on nw"><a rel="noopener  ugc nofollow" target="_blank" href="/9-data-structures-algorithms-you-should-know-as-a-developer-5e10946c95a0"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">作为开发人员，你应该知道的9种数据结构和算法</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">让你成为更好的开发者的数据结构和算法</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="of l"><div class="oo l oh oi oj of ok kp nw"/></div></div></a></div><div class="ol om gp gr on nw"><a rel="noopener  ugc nofollow" target="_blank" href="/ultimate-web-developer-roadmap-for-2021-6758edd0bd3f"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">2021年终极网络开发者路线图</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">从基础到部署可伸缩的Web应用程序</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="of l"><div class="op l oh oi oj of ok kp nw"/></div></div></a></div></div></div>    
</body>
</html>