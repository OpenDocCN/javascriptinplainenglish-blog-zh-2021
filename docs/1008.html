<html>
<head>
<title>Extending HTTP Interceptors Hierarchically in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular中分层扩展HTTP拦截器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/extending-http-interceptors-hierarchically-in-angular-4ca4d25af475?source=collection_archive---------6-----------------------#2021-03-03">https://javascript.plainenglish.io/extending-http-interceptors-hierarchically-in-angular-4ca4d25af475?source=collection_archive---------6-----------------------#2021-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3f0b586f0a9e245a7dd2c64a4e4bed27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezSAyJrhljzgxL3sCpvUrA.png"/></div></div></figure><p id="1c0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您是否曾经希望将您的应用程序分割成业务模块(特性模块),以便它们每个都有自己的特性逻辑http拦截器集，然而它们是如此的分离，以至于它们仍然可以使用公共的逻辑拦截器，而无需了解或参考它。</p><p id="3274" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也许不同的团队从事不同的功能，有不同的角度项目<em class="kt">(我希望他们不是在构建一个巨大的不可维护的整体)</em>，这些项目输出独立测试的模块，这些模块被延迟加载到主应用程序中。也许是其他类似的用例🤔…</p><p id="f47c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在每个http请求上只需要对特性模块做一些特别的事情，但是仍然需要应用通用的拦截器，那些完成REST api端点的URL的拦截器，以及添加定制头的拦截器。如果有拦截器的话🤨特性模块开发团队不应该真的需要知道核心模块的工作方式。这类似于<a class="ae ku" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">控制的反转</a>。</p><p id="cc53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Angular的工作方式(从Angular v11开始)是，惰性加载模块的拦截器要么被忽略，要么被单独应用。</p><p id="76ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更深入地了解原因，我们来解释一下:因为一个<a class="ae ku" href="https://angular.io/guide/providers#limiting-provider-scope-by-lazy-loading-modules" rel="noopener ugc nofollow" target="_blank">惰性加载模块创建了一个子注入器</a>，所以提供的拦截器是这个子注入器包含的一个集合。因此，如果<code class="fe kv kw kx ky b">HttpClientModule</code>的导入只保留给父模块，它们会被<em class="kt">忽略</em>，因为当从父注入器注入服务<code class="fe kv kw kx ky b">HttpClient</code>时，它看不到子注入器中的拦截器集。另一方面，如果<code class="fe kv kw kx ky b">HttpClientModule</code>在子模块中被重新导入，那么它们就会被<em class="kt">隔离</em>，这样就创建了一个新的服务实例，它只能看到同一个注入器中的一组拦截器，而看不到父模块中的拦截器。</p><p id="5a0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦制定了用例并解释了为什么不能开箱即用，仍然有一种方法可以避免这种行为，那就是告诉Angular的<code class="fe kv kw kx ky b">HttpClient</code>服务如何看到两组拦截器。</p><p id="9842" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们借助一个简单的，即使不一定真实或有效的例子，只是为了描绘一个实现。</p><p id="3cbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以Angular CLI样板代码为例，让我们建立我们需要的东西，并在此基础上继续构建。</p><p id="2832" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显示在<code class="fe kv kw kx ky b">AppComponent</code>中的<code class="fe kv kw kx ky b">title</code>需要通过http请求获取，我们将使用一个<em class="kt">角度服务</em>来实现:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="4e3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个懒惰加载的<code class="fe kv kw kx ky b">FeatureComponent</code>，它显示一个标题，这个标题也被获取。它将和<code class="fe kv kw kx ky b">AppComponent</code>一样:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="2a71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两个标题在不同路径的同名文本文件<code class="fe kv kw kx ky b">title.txt</code>中，所以我们将使用一个<em class="kt">服务</em>来完成这个任务，并通过<em class="kt">拦截器</em>来调整所述路径:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="8958" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了简单起见，<em class="kt">应用标题</em>文件驻留在<code class="fe kv kw kx ky b">assets/</code>文件夹中，我们将在<em class="kt">拦截器</em>中预先放置路径:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="3ad9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">特性标题</em>文件在路径<code class="fe kv kw kx ky b">assets/feature/</code>中，但是由于我们计划“继承”<em class="kt">拦截器</em>应用程序，我们将只在<em class="kt">特性拦截器</em>中添加<code class="fe kv kw kx ky b">feature/</code>部分:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="d9ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">两个<em class="kt">拦截器</em>都在它们各自的<em class="kt">模块</em>中提供，但是我们只在根<code class="fe kv kw kx ky b">AppModule</code>中导入<code class="fe kv kw kx ky b">HttpClientModule</code>:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="e72a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的<code class="fe kv kw kx ky b">FeatureModule</code>中，我们将导入一个特殊的<code class="fe kv kw kx ky b">InterceptorInheritanceModule</code>来代替。不过还有另一个区别，接下来提供的<code class="fe kv kw kx ky b">HTTP_INTERCEPTORS</code>与<code class="fe kv kw kx ky b">@angular/common/http</code>中的<em class="kt">注入令牌</em>不同。它的必要性在于“子”和“父”<em class="kt">拦截器</em>之间的依赖关系，因此我们需要为两个集合使用不同的令牌。为了保持一致，它们的名称是相同的。它的宣言随后出现:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="d925" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，这整个概念只适用于多个<em class="kt">注入器</em>，也就是延迟加载模块，因此在导入<code class="fe kv kw kx ky b">RouterModule</code>时，会有<code class="fe kv kw kx ky b">FeatureModule</code>的延迟加载:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="eea4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，所有的部分都准备好了，我们的特殊<code class="fe kv kw kx ky b">InterceptorInheritanceModule</code>，整个问题解决方案的本质。我们将提供应用<em class="kt">拦截器</em>和“真实的”<code class="fe kv kw kx ky b">HTTP_INTERCEPTORS</code>令牌所需的内置<em class="kt">服务</em>，以及合并两组<em class="kt">拦截器</em>的策略:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="3fe0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的例子完成了🎉。完整代码可在<a class="ae ku" href="https://github.com/miguel-leon/extend-interceptors" rel="noopener ugc nofollow" target="_blank"> github </a>获得。我们可以运行它，并在浏览器中看到对<code class="fe kv kw kx ky b">/assets/title.txt</code>和<code class="fe kv kw kx ky b">/assets/feature/title.txt</code>的两个正确请求。</p><p id="dce9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，记住解决方案中使用的一些api是angular的“私有”API，即<code class="fe kv kw kx ky b">ɵHttpInterceptingHandler</code>和<code class="fe kv kw kx ky b">injector.parent</code>。它们在版本11中工作，但将来可能会改变。</p><p id="9dfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，Angular的github 中还有一个<a class="ae ku" href="https://github.com/angular/angular/issues/36974" rel="noopener ugc nofollow" target="_blank">未解决的问题，这篇文章的存在是为了让我们更深入地了解为什么我们想要以这种方式设计<em class="kt">拦截器</em>，所以也许在未来我们可以只使用内置的“公共”api。</a></p></div></div>    
</body>
</html>