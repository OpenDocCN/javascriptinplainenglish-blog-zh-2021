<html>
<head>
<title>Let’s Create a React Native TypeScript App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们创建一个React本机类型脚本应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-create-a-react-native-typescript-app-35eee21e162d?source=collection_archive---------4-----------------------#2021-03-15">https://javascript.plainenglish.io/lets-create-a-react-native-typescript-app-35eee21e162d?source=collection_archive---------4-----------------------#2021-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="fade" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">作为学习练习和参考实施，现在就将这一架构完善、可重复的基础设施添加到您的武器库中</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14bcc156b0a1c638fe498ec62850fe6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0L2WrKEeyprS1Bf8WSjuqg.png"/></div></div></figure><p id="374d" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">用<em class="ls">编写的应用React Native </em>原生运行在iOS和Android设备上。无需编写一行Java或Swift代码，您就可以控制整个堆栈——前端、中间和后端。你可以很容易地用纯粹的<em class="ls">打字稿</em>来完成。用一种语言来统治他们。</p><p id="cae4" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这个故事是为有兴趣学习或过渡到React原生生态系统的TypeScript开发人员编写的。它也适用于任何对坚实的React Native / TypeScript基础感兴趣的多平台应用程序开发人员，作为未来应用程序的起点。</p><p id="d3a5" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们将使用TypeScript作为源语言，为任何非正式或专业的React Native工作创建一个参考实现和起点。我们的实现将涵盖一系列不同的主题，包括项目结构、一些基本的React本地语言语义、代码库可重用性、设备管理、命令行快捷方式和产品命名规则。</p><p id="f127" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们将生产一个功能最少但架构良好的核心应用程序，用于绿地产品开发。让这个项目保持最新，并使用它来自信地引导任何需要这个堆栈的新应用程序。</p><h1 id="96e0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">React本机CLI项目</h1><p id="3249" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">我们的项目将<em class="ls">而不是</em>基于Expo tooling或任何其他先进的锅炉板系统；也不会以这种方式开始。相反，我们将使用标准的<a class="ae ly" href="https://www.npmjs.com/package/react-native-cli" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> React Native CLI </em> </a>以及一个优秀的、社区驱动的、现成的React Native TypeScript <a class="ae ly" href="https://github.com/react-native-community/react-native-template-typescript" rel="noopener ugc nofollow" target="_blank">模板</a>。我们将利用各种命令行实用程序以及与设备相关的本地开发平台——用于iOS的Xcode IDE和用于其他平台的Android Studio。</p><h1 id="f5f0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">你需要什么</h1><h2 id="3a79" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">技术技能</h2><p id="9c65" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">没有必要了解任何关于打字稿的知识。我们的主要目标是创建一个由强大的Typescript编码环境支持的应用程序基础架构。该设置将准备扩展到下一个功能级别，并将作为对TypeScript和React Native感兴趣的人的学习平台。</p><p id="0fe4" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">对于这些目标，唯一的语言先决条件是JavaScript的工作知识和熟悉一种<a class="ae ly" href="https://pubs.opengroup.org/onlinepubs/007904975/utilities/xcu_chap02.html" rel="noopener ugc nofollow" target="_blank"> POSIX shell命令语言</a>(这里我们将使用<a class="ae ly" href="https://www.theverge.com/2019/6/4/18651872/apple-macos-catalina-zsh-bash-shell-replacement-features" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> zsh </strong> </a> <em class="ls"> </em>)。你也要对<a class="ae ly" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> Node.js </strong> </a>，<a class="ae ly" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io">NPM</strong>/<strong class="kw io">npx</strong></a>，<a class="ae ly" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">纱</strong> </a>和<a class="ae ly" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> git </strong> </a>驾轻就熟。</p><h2 id="5251" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">系统设置</h2><p id="08ea" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">你需要:</p><ul class=""><li id="19ca" class="ml mm in kw b kx ky lb lc lf mn lj mo ln mp lr mq mr ms mt bi translated">运行Catalina或更好的基于macOS的电脑(<em class="ls"/><em class="ls">macbox</em>)</li><li id="86b4" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr mq mr ms mt bi translated">您最喜欢的IDE或代码编辑器</li><li id="bce6" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr mq mr ms mt bi translated">可选地，通过USB连接到macbox和macbox WIFI网络的iOS和/或Android移动设备</li></ul><p id="f31c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们的故事发生在一台基于macOS的电脑上。虽然没有它也可以编写iOS解决方案，但那是另一回事了。</p><h2 id="a847" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">Xcode和Android Studio</h2><p id="50c0" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">Xcode和Android Studio的设置和一般使用超出了本文的范围。在完成我们的项目(不包括它们的安装)的过程中，将会提供关于它们的使用的明确说明，并且它们在这里的使用都是非常直接的。如果macbox上没有安装这些产品，请安装它们。如果已经安装，请继续更新以获得最新版本。</p><h2 id="f76f" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">目标平台</h2><p id="2f11" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">我们将在Android模拟器(可通过Android Studio获得)、iOS模拟器(来自Xcode)上运行我们的软件，并可选地在任一平台的<em class="ls">物理</em>设备上运行。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="16d7" class="jk jl in bd jm jn ng jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd nk kf kg kh bi translated">让我们摇滚吧！</h1><h2 id="4cfd" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">确保Node.js的l <em class="nl">测试LTS </em>已安装，并且是macbox的默认设置</h2><p id="1139" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">既然我们是从零开始构建一个项目，我们不妨从最新的完全支持版本的<strong class="kw io"> Node.js </strong> (node)开始，因为从这一点开始我们所做的几乎所有事情都将依赖于它。</p><p id="8ea5" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">让我们用<strong class="kw io"> nvm </strong>(节点版本管理器)来抓取<em class="ls">最新的LTS </em>(长期支持)版本的节点。你可能会被诱惑使用他们所谓的<em class="ls">当前版本</em>，这看起来很合理，甚至是可取的，但不要这样做。当前版本用于内部系统开发和生产包管理，仅支持6个月，而LTS版本支持30个月。选择最新的LTS可以节省几年升级应用程序的麻烦。</p><p id="2aca" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">如果macbox上没有安装<strong class="kw io"> nvm </strong>，请遵循此处的说明。</p><p id="dce0" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">下面的片段说明了我们在终端会话中关于交互式命令处理器对话框的约定。<code class="fe nm nn no np b"><strong class="kw io">bold</strong></code>字符是在<code class="fe nm nn no np b"><em class="ls">italics</em></code>中响应输入的命令——常规的终端内容。空白行上的省略号代替了不感兴趣的输出。</p><p id="9f53" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">从任何目录:</p><ol class=""><li id="badb" class="ml mm in kw b kx ky lb lc lf mn lj mo ln mp lr nq mr ms mt bi translated">运行命令<code class="fe nm nn no np b"><strong class="kw io">node --version</strong></code>，在我的系统上，它返回<code class="fe nm nn no np b"><em class="ls">v15.8.0</em></code>；注意到node的所有奇数版本都是非LTS的，我决定不这样做</li><li id="c134" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr nq mr ms mt bi translated">最新的grep，我们看到的是<code class="fe nm nn no np b"><em class="ls">v14.15.5 (Latest LTS: Fermium)</em></code></li><li id="bed5" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr nq mr ms mt bi translated">如果你还没有最新的LTS，用<code class="fe nm nn no np b"><strong class="kw io">nvm install --lts</strong></code>安装它，其中<code class="fe nm nn no np b"><strong class="kw io">nvm</strong></code>显示我们新的<code class="fe nm nn no np b"><em class="ls">default alias</em></code>指向<code class="fe nm nn no np b"><em class="ls">v14.16.0</em></code></li><li id="fcd7" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr nq mr ms mt bi translated">用<code class="fe nm nn no np b"><strong class="kw io">node --version</strong></code>命令验证这一点，知道我们已经设置好了。</li></ol><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="8edc" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">node --version</strong><br/><em class="ls">v15.8.0</em></span><span id="e57f" class="lz jl in np b gy nz nw l nx ny"><strong class="np io">nvm ls-remote | grep 'Latest LTS' | tail -1</strong><br/><em class="ls">v18.14.0   (Latest LTS: Hydrogen)</em></span><span id="fc7d" class="lz jl in np b gy nz nw l nx ny"><strong class="np io">nvm install --lts</strong><br/><em class="ls">Installing latest LTS version.<br/></em>Downloading and installing node v18.14.0...<br/>Downloading <a class="ae ly" href="https://nodejs.org/dist/v18.14.0/node-v18.14.0-linux-x64.tar.xz" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/dist/v18.14.0/node-v18.14.0-linux-x64.tar.xz</a>...<em class="ls"><br/>...<br/></em>Now using node v18.14.0 (npm v9.3.1)</span><span id="0b3d" class="lz jl in np b gy nz nw l nx ny"><strong class="np io">node --version</strong><br/><em class="ls">v18.14.0<br/></em><strong class="np io">~ &gt;</strong></span></pre><p id="e249" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">安装节点的同时也安装了可执行文件<strong class="kw io">NPM</strong>T21和<strong class="kw io">npx</strong>(<a class="ae ly" href="https://nodejs.dev/learn/the-npx-nodejs-package-runner" rel="noopener ugc nofollow" target="_blank">节点包管理器<em class="ls">和节点包运行器</em>T28】)。我们将使用<strong class="kw io"> npx </strong>专门运行<code class="fe nm nn no np b"><strong class="kw io">react-native</strong></code>实用程序。</a></p><h2 id="3991" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">创建参考模型</h2><p id="c988" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">接下来，使用<code class="fe nm nn no np b"><a class="ae ly" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io">npx react-native init</strong></a></code>创建一个框架应用程序，传入我们的项目名称(<code class="fe nm nn no np b"><strong class="kw io">rctnts</strong></code>，这里)和<code class="fe nm nn no np b"><strong class="kw io">--template</strong></code>开关以引入社区模板<code class="fe nm nn no np b"><a class="ae ly" href="https://github.com/react-native-community/react-native-template-typescript" rel="noopener ugc nofollow" target="_blank"><strong class="kw io">react-native-template-typescript</strong></a></code>。该模板基于标准的React本机模板，同时添加了一些经过深思熟虑的、提供TypeScript支持的最小扩展。</p><p id="907c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">完成后，导航到<code class="fe nm nn no np b"><strong class="kw io">./rctnts</strong></code>目录并列出其一级结构。我们将很快仔细看看这些文件和目录，但让我们先运行应用程序。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="be5b" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">cd ~<br/>mkdir apps</strong><br/><strong class="np io">cd apps<br/>npx react-native init rctnts --template react-native-template-typescript</strong><em class="ls"><br/>...<br/>✔ Downloading template<br/>✔ Copying template<br/>✔ Processing template<br/>✔ Installing CocoaPods dependencies (this may take a few minutes)</em></span><span id="0026" class="lz jl in np b gy nz nw l nx ny"><em class="ls">Run instructions for iOS:<br/>    • cd "</em>/Users/fred<em class="ls">/</em>apps<em class="ls">/rctnts" &amp;&amp; npx react-native run-ios<br/>    - or -<br/>    • Open </em>/Users/fred/<em class="ls">rctnts/ios/rctnts.xcworkspace in Xcode or run "xed -b ios"<br/>    • Hit the Run button</em></span><span id="ecdf" class="lz jl in np b gy nz nw l nx ny"><em class="ls">Run instructions for Android:<br/>    • Have an Android emulator running (quickest way to get started), or a device connected.<br/>    • cd "</em>/Users/fred<em class="ls">/apps/rctnts" &amp;&amp; npx react-native run-android<br/>...</em><br/><strong class="np io">cd rctnts<br/>ls -1</strong><br/><em class="ls">App.tsx<br/>__tests__<br/>android<br/>app.json<br/>babel.config.js<br/>index.js<br/>ios<br/>metro.config.js<br/>node_modules<br/>package.json<br/>tsconfig.json<br/>yarn.lock</em></span></pre><h2 id="b1dc" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">在模拟器上运行iOS应用程序</h2><p id="e9ac" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">我们现在准备在Xcode iPhone模拟器上运行该应用程序。按照上面片段中打印的说明，在<code class="fe nm nn no np b"><em class="ls">Run instructions for iOS:</em></code>下面。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="fc84" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">cd rctnts<br/>npx react-native run-ios<br/></strong><em class="ls">info Found Xcode workspace "rctnts.xcworkspace"<br/>info Launching iPhone 11 (iOS 14.4)<br/>info Building (using "xcodebuild -workspace rctnts.xcworkspace -<br/>...<br/>info Launching "org.reactjs.native.example.rctnts"<br/>success Successfully launched the app on the simulator</em></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/641b4b83577f208a29c75719e515b2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*XQvCc0r9i6UbPovbrO3gzA.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">default iOS app from <strong class="bd of">react-native-template-typescript</strong></figcaption></figure><p id="a77f" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">我们刚刚创建的app</em></strong><br/>这个单页app显示了几个基本的交互指令。它还滚动显示官方<a class="ae ly" href="https://reactnative.dev/docs/tutorial" rel="noopener ugc nofollow" target="_blank"> React原生教程</a>的各种链接。如果你点击其中一个链接，结果页面将显示在macbox的默认浏览器中(而不是模拟器的浏览器中)。有趣的是，当我们在物理设备上运行这款应用程序时，我们会得到相同的行为——使该应用程序成为macbox浏览器的遥控器。干净利落。</p><p id="922c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">跟随链接<br/> </em> </strong>如果这是你第一次接触React Native，那就继续跟随应用程序的链接了解情况吧。这些链接中的材料质量超高，是网站综合处理的一小部分，将成为你的首选参考。</p><p id="8ceb" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">在这里，应用程序出现在iOS模拟器中，默认为iPhone 11设备。要在另一个iOS设备模拟器上运行应用程序，请使用模拟器开关，就像在<code class="fe nm nn no np b">npx react-native run-ios --simulator="iPhone 8"</code>中一样。</p><h2 id="f541" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">选择性地在设备上运行iOS应用程序</h2><p id="1cef" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">在您的项目上启动Xcode运行<code class="fe nm nn no np b"><strong class="kw io">xed ./ios.</strong></code>命令。这会对你的<code class="fe nm nn no np b"><strong class="kw io">rctnts.xcworkspace</strong></code>运行Xcode。</p><p id="b3fa" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">然后，在Xcode中，做这些事情。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f6c1f0f2a8d4cb052f60a46617350365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TeSBsBUik-7A9MsBJNDqAQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">Select a signing Team associated with your Apple ID</figcaption></figure><ol class=""><li id="ca70" class="ml mm in kw b kx ky lb lc lf mn lj mo ln mp lr nq mr ms mt bi translated">选择左上角的文件夹图标以查看项目视图，然后选择项目<code class="fe nm nn no np b">rctnts</code></li><li id="5b45" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr nq mr ms mt bi translated">将您的iOS设备连接到macbox USB端口，选择左侧的<code class="fe nm nn no np b">rctnts</code>并点击右侧的设备列表，滚动到顶部并按名称选择您的设备</li><li id="9a62" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr nq mr ms mt bi translated">点击<em class="ls">签名&amp;功能</em>标签</li><li id="7ca0" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr nq mr ms mt bi translated">在团队选择列表中，点击<em class="ls">添加账号… </em>并用你的Apple ID进行认证，此时你就被赋予了一个用户角色叫做<em class="ls">你的名字</em>(个人团队)的团队；关闭对话框，现在您可以从Xcode <em class="ls">团队</em>选择列表中选择该团队</li></ol><p id="1c02" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">请注意<a class="ae ly" href="https://developer.apple.com/library/archive/qa/qa1915/_index.html" rel="noopener ugc nofollow" target="_blank">您的(个人团队)不能用于对您的应用进行代码签名以提交至应用商店</a>。要进入App Store，你必须有一个99美元/年的苹果开发者账户，在那里你可以创建真正的开发者和发行凭证来签署和销售你的应用。请参见应用程序分发指南的<a class="ae ly" href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/ManagingAccounts/ManagingAccounts.html" rel="noopener ugc nofollow" target="_blank">管理帐户部分。</a></p><p id="58d1" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">您现在可以在设备上运行应用程序了。确保您的设备<strong class="kw io">未被锁定</strong>且<strong class="kw io">未被您的防火墙</strong>阻止，并按下Xcode面板顶部的▶️。</p><p id="7065" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">如果您从未使用上一步中选择的团队在iOS设备上运行应用程序，则会出现一个Xcode错误对话框，标题为<em class="ls">无法运行“RCT nts”</em>，并包含指示应用程序的<em class="ls">配置文件未被用户</em>明确信任的措辞。完美！</p><p id="e020" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">走到这一步并收到这个错误，iOS设备现在有了一个新的<code class="fe nm nn no np b">Settings</code>菜单元素。在设备上，您现在可以导航到<code class="fe nm nn no np b">Settings</code>&gt;<code class="fe nm nn no np b">General</code>&gt;<code class="fe nm nn no np b">Device Management… </code>&gt;<code class="fe nm nn no np b">Apple Development: …</code>&gt;<code class="fe nm nn no np b">Trust “Apple Development…</code>，然后按<code class="fe nm nn no np b">Trust</code>。好了，我们进去了。</p><p id="b752" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">返回Xcode并再次按下▶️，应用程序将在设备上旋转。只有第一次，应用程序会问:<em class="ls">“RCT nts</em>想要找到并连接到您的本地网络上的设备。”单击确定。</p><p id="fe48" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">如果应用程序在设备上只显示为不运行的图标，只需按下它。如果应用程序无法加载，用力摇晃设备(严重)，在出现的开发者菜单中，选择<em class="ls">配置捆绑器</em>，<em class="ls"> </em>输入macbox IP地址，点击<em class="ls">应用更改</em>。您可能需要在设备进入睡眠模式时重复摇动程序(要控制睡眠模式，请调整<code class="fe nm nn no np b">Settings</code> &gt; <code class="fe nm nn no np b">Display &amp; Brightness</code>下的自动锁定)。在同一个菜单中，您也可以通过简单地选择<em class="ls">重新加载</em>来启动它。</p><p id="b02f" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">你现在可以杀死Xcode并回到你信任的编辑器和终端，在那里你可以运行<code class="fe nm nn no np b"><strong class="kw io">npx react-native run-ios --device</strong></code>(这次是用<code class="fe nm nn no np b"><strong class="kw io">--device</strong></code>选项)并继续。如果您连接了多个iOS设备，请将设备名称指定为参数(<code class="fe nm nn no np b"><strong class="kw io">--device <em class="ls">iosDeviceName</em></strong></code>)。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/320e2ea0e78c89945b44994766bdd75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfHFkO40wQV6o5O7Ewjz2w.png"/></div></div></figure><p id="1d74" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls"> Metro —自动驾驶</em> </strong> <br/>当你运行app时，一个终端弹出来，周围一堆胡言乱语<em class="ls">欢迎反应原生！</em></p><p id="c3b2" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这是<em class="ls">Metro</em>—<a class="ae ly" href="https://github.com/facebook/metro" rel="noopener ugc nofollow" target="_blank">JavaScript bundler</a>和服务器，在macbox和设备之间建立了一座桥梁。它将我们复杂的代码集捆绑到一个JavaScript文件中，在设备上安装和管理它，并监听源代码的变化。</p><p id="9397" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">Metro用我们的<code class="fe nm nn no np b"><strong class="kw io">npx react-native run-ios</strong></code>命令自动跑<em class="ls">自动跑</em>，很棒但是有点太方便了。不能这样。</p><p id="fb1b" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls"> Metro —驾驶杆<br/> </em> </strong>为了进入下一个级别的控制，我们需要手动运行Metro<em class="ls"/>—在一个单独的终端窗口中执行<code class="fe nm nn no np b"><strong class="kw io">npx react-native start</strong></code> <strong class="kw io"> </strong>，让它一直运行。这将使Metro服务器守护进程保持活动并监听。</p><p id="c013" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">要停止Metro，在它的终端窗口中执行一个<code class="fe nm nn no np b"><strong class="kw io"><em class="ls">CTRL-c</em></strong></code>或者向它发送一个kill信号——对于它的默认端口(8081 ),使用:</p><p id="6b62" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">kill $(sudo lsof -iTCP:8081 -sTCP:LISTEN | awk '{ print $2 }')</strong></code></p><p id="fd75" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">像这样手动运行Metro给了我们额外的控制权来管理它的资源，包括端口细节和缓存，并且通常给了我们一个很好的关注点分离，这在我们遇到冲突或需要更多控制时很有用。另外，驾驶手动挡只是更有趣而已。</p><p id="df5f" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">地铁——开快车<br/> </em> </strong>我们的app构建、安装、运行花了几分钟。但是有了Metro，一旦它<em class="ls">在</em>运行，对其源代码的任何改变都会立即反映在应用程序及其显示上。</p><p id="3047" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">所以，让我们改变一个应用程序，并观察它的运行。当应用程序运行时，在编辑器中打开<code class="fe nm nn no np b"><strong class="kw io">App.tsx</strong></code>，这样你就可以同时查看运行的应用程序和编辑器。</p><p id="dbb3" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">对<code class="fe nm nn no np b"><strong class="kw io">App.tsx</strong></code>做任何明显的改变，比如说，将文字文本<code class="fe nm nn no np b">&gt;Step One&lt;</code>改为<code class="fe nm nn no np b">&gt;Step Uno&lt;</code>，然后观察当你点击Command-S时，屏幕会多快地反映出你的改变</p><p id="78b0" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">是的——亚秒！不再有冗长的构建过程。仅此一点就让React Native值回票价。</p><p id="55e5" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">试试这个。使用我们的新应用程序导航到其中一个<em class="ls">了解更多</em>页面，复制源代码并替换<code class="fe nm nn no np b"><strong class="kw io">App.tsx</strong></code>的全部内容，然后点击Command-S。瞧！你自己的实验室用这些反应本地的例子和那些世界和以太的例子进行实验。</p><p id="4cf9" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">在非8081端口上运行iOS应用<br/> </em> </strong>使用普通<code class="fe nm nn no np b"><strong class="kw io">npx react-native run-ios</strong></code>命令运行应用的默认端口是8081。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">if you need to use a non-8081 port for Metro iOS apps</figcaption></figure><p id="45a7" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">偶尔，这个端口已经被分配给另一个进程。您可以停止该进程或使用另一个端口。如果您需要使用另一个端口(因为公司的McAfee应用程序不会放弃8081)，您将需要修改几个文件，并在npx命令中添加<code class="fe nm nn no np b"><strong class="kw io">--port</strong></code>选项。</p><p id="85b7" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">您可以按照这里的注释手动编辑<code class="fe nm nn no np b"><strong class="kw io">RCTDefines.h</strong></code>和<code class="fe nm nn no np b"><strong class="kw io">project.pbxproj</strong></code>,或者将这些命令合并到您的shell操作中，如果这不仅仅是一个临时场景，或者如果您只是想方便地使用它，或者如果您是个坏蛋，那么这是一个不错的选择。</p><p id="8efb" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">不管怎样，事情就是这样的。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="e7d9" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls"> App.tsx <br/> </em> </strong>在运行这个应用程序时，精明的观察者可能已经注意到，我们的应用程序屏幕的指令中的<strong class="kw io">步骤一</strong>建议编辑<code class="fe nm nn no np b"><strong class="kw io">App.tsx</strong></code>文件以<em class="ls">改变这个屏幕，然后回来查看您的编辑</em>。</p><p id="9cc2" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们将很快接受应用程序的建议。现在，好肉汁——另一个扩展？这是什么<strong class="kw io">。tsx </strong>的事情？</p><h2 id="1928" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated"><strong class="ak"> <em class="nl"> JSX语法:</em>。jsx <em class="nl">和。tsx文件</em> </strong></h2><p id="33a5" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">具有这些扩展名的文件支持JavaScript JSX语言语法，这正是React编程的优势所在。扩展名为<code class="fe nm nn no np b"><strong class="kw io">.jsx</strong></code>和<code class="fe nm nn no np b">.<strong class="kw io">tsx</strong></code>的文件分别用JavaScript和TypeScript编写，并且都支持相同的JSX语法。如果这是您第一次接触JSX语法，在继续阅读之前，请到这里<a class="ae ly" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank">快速了解一下。并且知道这些事情。</a></p><p id="a73f" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><em class="ls"> TypeScript是JavaScript的超集，因此有效的JavaScript就是有效的TypeScript。</em></p><p id="8861" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><em class="ls"> JSX是JavaScript的扩展，因此也是TypeScript的扩展。</em></p><p id="5c29" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><em class="ls">所有的TypeScript语法在</em> <strong class="kw io"> <em class="ls">中都有效。tsx </em> </strong> <em class="ls">文件，有以下例外:</em></p><p id="95a2" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">在TypeScript中，尖括号用于类型断言。但是JSX文件中的尖括号总是定义JSX元素。这给需要使用JSX语法的TypeScript程序造成了解析歧义。为此， <strong class="kw io"> <em class="ls">。tsx </em> </strong> <em class="ls">文件不允许通过尖括号进行类型断言。替换</em> <strong class="kw io"> <em class="ls">中的此类断言。tsx </em> </strong> <em class="ls">文件带有</em> <code class="fe nm nn no np b"><em class="ls">as</em></code> <em class="ls">运算符，以便… </em></p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="0a14" class="lz jl in np b gy nv nw l nx ny">const myPet = &lt;Dog&gt; createBestFriend("fido");</span></pre><p id="01f5" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><em class="ls">……变成了……</em></p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="af86" class="lz jl in np b gy nv nw l nx ny">const myPet = createBestFriend("fido") as Dog;</span></pre><h2 id="8d02" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated"><strong class="ak"> <em class="nl">有趣的文件</em> </strong></h2><p id="006f" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">下面是我们的<code class="fe nm nn no np b"><strong class="kw io">npx react-native init rctnts react-native-template-typescript</strong></code>命令在应用程序根目录下创建的一些有趣的文件和目录。</p><p id="3a52" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io"><em class="ls">Asp.tsx</em></strong></code> <br/>我们app的主要入口点，也是我们开始编程的地方。</p><p id="73a2" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io"><em class="ls">ios</em></strong></code><strong class="kw io"><em class="ls"/></strong><code class="fe nm nn no np b"><strong class="kw io"><em class="ls">android</em></strong></code><strong class="kw io"><em class="ls">目录</em> </strong> <br/>平台特定目录主要由我们的React原生构建系统维护。</p><p id="1e66" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io"><em class="ls">app.json</em></strong></code> <br/>包含我们app的名称——实际上是它的<em class="ls">简称</em>和<em class="ls">显示名称</em>。这个简称将在我们的构建上下文中以各种方式使用，您将在下面的脚本中看到它的引用。</p><p id="e564" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><a class="ae ly" href="https://babeljs.io/docs/en/configuration" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="ls">babel.config.js</em></strong></a><br/></code>控制着通天塔transpiler的行为。React Native依赖于从该文件导出的Babel预设(参见<a class="ae ly" href="https://www.npmjs.com/package/metro-react-native-babel-preset" rel="noopener ugc nofollow" target="_blank">metro-react-Native-Babel-preset</a>)来获取Metro和构建过程的正确插件。</p><p id="6029" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io"><em class="ls">index.js</em></strong></code> <br/>用于引导我们的应用:<strong class="kw io"> App.tsx </strong>。</p><p id="e658" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io"><em class="ls">tsconfig.json</em></strong></code> <br/>告诉TypeScript这是项目的根目录，并为<code class="fe nm nn no np b"><strong class="kw io">tsc</strong></code>(<em class="ls">TypeScript编译器</em>)提供默认选项，包括<code class="fe nm nn no np b"><strong class="kw io">tsc</strong></code> <strong class="kw io"> </strong>命令行上没有直接提供的任何编译器选项和文件包含。这个文件也被你的IDE和linter使用。</p><h2 id="a7e9" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">看看这个应用程序</h2><p id="5fbc" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io"><em class="ls">index.js</em></strong></code> <br/> React原生应用需要注册自己，以便它们的生命周期可以由它们的目标原生系统管理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk"><strong class="ak">index.js</strong> file generated with the <strong class="ak">react-native-template-typescript </strong>template</figcaption></figure><p id="2616" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这是使用根级别的<code class="fe nm nn no np b"><strong class="kw io">index.js</strong></code>文件完成的，在这个清单中，它导入了<code class="fe nm nn no np b"><strong class="kw io">App.tsx</strong></code>，其唯一目的是返回我们应用程序的顶级JavaScript入口点。它还从<code class="fe nm nn no np b"><strong class="kw io">app.json</strong></code>抓取应用名称。</p><p id="bde2" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">现在，AppRegistry为Metro提供了一个入口点，供本机系统用来加载应用程序和管理其运行时生命周期。</p><p id="a9a0" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这是我们应用程序的主要源文件，可能是你在任何新应用程序中替换的第一个文件。让我们仔细看看这里发生了什么。当你明白这一点，你就成功了。</p><p id="6147" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">第31行开始了<code class="fe nm nn no np b">App</code>函数，这是我们应用程序的入口点，必须返回一个JSX。元素对象(一个<em class="ls"> React元素</em>)并且必须是文件的默认导出。按照惯例，但技术上无关，这里的函数名<code class="fe nm nn no np b">App</code>与我们的<code class="fe nm nn no np b"><strong class="kw io">index.js</strong></code>文件中的名称相匹配。名字不重要。只要是默认导出(第118行)，就可以称之为<code class="fe nm nn no np b">Fred</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk"><strong class="ak">App.tsx</strong> file generated with <strong class="ak">react-native-template-typescript </strong>template</figcaption></figure><p id="af40" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls"> JSX元素是组件</em></strong><br/>【JSX】元素标签(如第34行的<code class="fe nm nn no np b">&lt;StatusBar&gt;</code>)指明了React元素的类型(<em class="ls">元素类型</em>)。元素类型是指React中的组件类型—元素<em class="ls">是</em>组件。</p><p id="f5c4" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">让我们看看这里使用的一些组件种类。</p><p id="b505" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">小写的React元素指的是内置组件——读HTML标签，像<code class="fe nm nn no np b">&lt;div&gt;</code>。大写的元素被假定为范围内组件，例如从<code class="fe nm nn no np b">‘react-native’</code>导入的<code class="fe nm nn no np b">View</code>(第12–19行)。</p><p id="119f" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">部分React元素指React <a class="ae ly" href="https://reactnative.dev/docs/intro-react-native-components" rel="noopener ugc nofollow" target="_blank"> <em class="ls">核心组件</em> </a> ( <code class="fe nm nn no np b">View</code>、<code class="fe nm nn no np b">Text</code>、<code class="fe nm nn no np b">ScrollView</code>)。有些是在各种标准库中实现的，还有一些是用户定义的。</p><p id="be45" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这里可以看到<code class="fe nm nn no np b">ReloadInstructions</code>(第56行)在范围内，因为它是从<code class="fe nm nn no np b">NewAppScreen</code>系统库导入的(第21–27行)。为什么他们在这里使用一个组件，而不仅仅是一些文本文字？这是因为这个应用程序必须支持平台特定的措辞，因为在iOS和Android之间重新加载应用程序的指令是不同的。有趣的是，这里有一个<a class="ae ly" href="https://github.com/facebook/react-native/pull/25353/files" rel="noopener ugc nofollow" target="_blank">拉请求</a>调整该组件显示的特定于平台的指令。</p><p id="f8ca" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b">SafeAreaView</code>(第35行)，虽然是真正的核心组件，但只适用于iOS设备。它用于管理UI元素周围的填充，以避免物理屏幕限制，如相机凹口和圆角。</p><p id="fd58" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">像<code class="fe nm nn no np b">style={styles.body}</code>这样看起来像属性的东西是组件道具。这里，<code class="fe nm nn no np b">style</code>是属性名，它的值<code class="fe nm nn no np b">styles.body</code>是一个JavaScript表达式。</p><p id="b419" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">是的，在JSX，任何出现在大括号(<code class="fe nm nn no np b">{}</code>)中的东西都是有效的JavaScript表达式。记住，尽管<code class="fe nm nn no np b">if</code>语句和<code class="fe nm nn no np b">for</code>循环不是JavaScript表达式。如果一个组件需要使用这些，将逻辑和循环放入它们自己的函数中，然后这些函数可以被当作表达式并在大括号中引用。此外，有时用三元表达式代替<code class="fe nm nn no np b">if</code> / <code class="fe nm nn no np b">else</code>构造是有意义的。</p><p id="ea63" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">更多详细内容、说明和示例，请参见<a class="ae ly" href="https://reactjs.org/docs/jsx-in-depth.html" rel="noopener ugc nofollow" target="_blank"> JSX深度</a>。</p><p id="a146" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">包含整个JSX文档树的空的<code class="fe nm nn no np b">&lt;&gt;</code>和<code class="fe nm nn no np b">&lt;/&gt;</code>元素(第33和75行)被称为<em class="ls">片段</em>，分别是<code class="fe nm nn no np b">&lt;React.Fragment&gt;</code>和<code class="fe nm nn no np b">&lt;/React.Fragment&gt;</code>的简写。</p><p id="e3af" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">碎片的存在是为了<em class="ls">防止</em>不得不将兄弟元素封装在像<code class="fe nm nn no np b">&lt;View&gt;</code>或<code class="fe nm nn no np b">&lt;div&gt;</code>这样的“普通”容器中。</p><p id="b1ff" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们正在通过组合创造复杂的成分(原谅辅音)。不可能允许兄弟(例如，一行中的三个<code class="fe nm nn no np b">&lt;Text&gt;</code>元素)在容器元素之外单独呈现，所以我们把它们放在比如<code class="fe nm nn no np b">&lt;div&gt;</code>中。当我们把这个结构嵌入到另一个不支持<code class="fe nm nn no np b">&lt;div&gt;</code>的元素中时，问题就出现了。</p><p id="e4ce" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">在JSX，当需要兄弟元素，但是常规容器不可行或不理想时，我们可以改为在片段中包含这些兄弟元素，这些片段不在文档模型中创建节点，但是提供了包含兄弟元素所需的语法。更完整的举例说明见<a class="ae ly" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">片段</a>。</p><p id="7f24" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">好了，这已经很多了，但是<strong class="kw io"> App.tsx </strong>文件到此为止。值得研究和参考冲浪，因为这些都不会消失。一切都从这里开始，变得更加有趣，所以思考这个例子，直到它熟悉为止。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="5fb4" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">在模拟器上运行安卓应用程序</h2><p id="aed9" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">启动AVD <br/> </em> </strong>转到Android模拟器，运行Android Studio并执行这些操作。</p><div class="kj kk kl km gt ab cb"><figure class="ok kn ol om on oo op paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c67fc3aade0e4b5df2e781f2a99a01f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*a7ruOUk8hT5eO_63BIvssw.png"/></div></figure><figure class="ok kn oq om on oo op paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/6d3bddb03ac8cd5c16a258f82dabebc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*3JjbduYe_UUDP_zwl1wYLQ.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk or di os ot">Run a virtual device on the Android Studio emulator</figcaption></figure></div><ol class=""><li id="6e69" class="ml mm in kw b kx ky lb lc lf mn lj mo ln mp lr nq mr ms mt bi translated">单击AVD (Android虚拟设备)管理器图标</li><li id="48b9" class="ml mm in kw b kx mu lb mv lf mw lj mx ln my lr nq mr ms mt bi translated">在AVD管理器中，单击[启动]按钮(绿色箭头)在仿真器中运行其中一个AVD，或者首先使用[创建虚拟设备]按钮创建一个AVD，然后返回此处并单击[启动]按钮</li></ol><p id="2945" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">启动Android应用<br/> </em> </strong>现在Android虚拟设备正在运行，我们可以启动我们的Android应用了。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="f77a" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">npx react-native run-android<br/></strong><em class="ls">info Running jetifier to migrate libraries to AndroidX. You can disable it using "--no-jetifier" flag.<br/>Jetifier found 967 file(s) to forward-jetify. Using 4 workers...<br/>info Starting JS server...<br/>info Installing the app...<br/>Starting a Gradle Daemon (subsequent builds will be faster)<br/>...<br/>BUILD SUCCESSFUL in 1m 18s<br/>27 actionable tasks: 27 executed<br/>info Connecting to the development server...<br/>8081<br/>info Starting the app on "emulator-5554"...<br/>Starting: Intent { cmp=com.rctnts/.MainActivity }</em></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/e467417b595179a5e371fda950eabbf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*Z1LiRSC0CaZmW2OuFUzfQw.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">Android app from <strong class="bd of">react-native-template-typescript</strong></figcaption></figure><p id="f4e1" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们被当作一个形式和功能与iOS应用程序完全相同的安卓应用程序。嗯……除了基于我们的<code class="fe nm nn no np b">ReloadInstructions</code>和<code class="fe nm nn no np b">DebugInstructions</code>组件中平台特定逻辑的屏幕指令中的细微差别之外。</p><h2 id="897a" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">可选地在设备上运行安卓应用程序</h2><p id="c878" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">首先，找到Android的</em> * &amp; ^$% <em class="ls"> build号<br/> </em> </strong>不同的Android设备类型和操作系统变体有不同的菜单结构，但对于定位<code class="fe nm nn no np b">Build number</code>来说，它们遵循下面的<em class="ls">通用导航模式。现在就使用它。</em></p><p id="a8ba" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">(<code class="fe nm nn no np b">Settings</code>-或-<code class="fe nm nn no np b">Settings</code>&gt;<code class="fe nm nn no np b">System</code>)<strong class="kw io">&gt;</strong><br/>(<code class="fe nm nn no np b">About phone</code>-或-<code class="fe nm nn no np b">About</code>)<strong class="kw io">&gt;</strong><br/>(<code class="fe nm nn no np b">Software info</code>-或-<br/><code class="fe nm nn no np b">Software information</code>-或-<br/><code class="fe nm nn no np b">Software information</code>&gt;<code class="fe nm nn no np b">More</code>-或- <br/> <em class="ls">什么都没有，好像你已经在那里了</em>)</p><p id="c429" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">到了那里，轻敲<code class="fe nm nn no np b">Build number</code>七次<em class="ls">召唤隐形剑客</em>。我是认真的(无论如何，关于七拍)。这将带你进入双秘密开发模式。现在才可以在<code class="fe nm nn no np b">Settings</code> &gt; <code class="fe nm nn no np b">Developer</code>下启用<em class="ls"> USB调试</em>。是的，这正在发生。</p><p id="5cf1" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">回到macbox，将<code class="fe nm nn no np b"><strong class="kw io">Android/sdk/platform-tools</strong></code>添加到您的路径中。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="b701" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">echo 'export PATH=$PATH:~/Library/Android/sdk/platform-tools/' &gt;&gt; ~/.bashrc<br/>. ~/.bashrc</strong></span></pre><p id="d0e1" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">将设备插入macbox上的USB端口，并运行<em class="ls"> Android调试桥</em>命令<code class="fe nm nn no np b"><strong class="kw io">adb devices</strong></code> <strong class="kw io"> </strong>以确保设备被识别。单词<em class="ls"> device </em>左边的字母数字字符串是您的设备标识符。如果Android模拟器还在运行，它也会出现在列表中，就像这里一样。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="b4e3" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">adb devices<br/></strong><em class="ls">List of devices attached</em><strong class="np io"><em class="ls"><br/></em></strong><em class="ls">emulator-5554 device<br/>15efadeb device</em></span></pre><p id="844e" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">adb</strong></code>命令是它自己的故事，有无数选项，运行它自己的Unix系统，在设备上运行一个守护进程，并促进与macbox dev服务器Metro的通信。对于我们的直接目的，我们将“仅仅”使用它来做<em class="ls">反向端口转发</em>，以便当设备试图与其自己的8081端口通信时，它将改为与macbox 8081端口对话。</p><p id="9fb5" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给我们的<code class="fe nm nn no np b"><strong class="kw io">run-android</strong></code>命令加上一个<code class="fe nm nn no np b"><strong class="kw io">--device</strong></code>开关，比赛就开始了。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="5d0f" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">adb reverse tcp:8081 tcp:8081<br/>npx react-native run-android --device</strong></span></pre><p id="1344" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">在非8081端口上运行Android应用程序<br/> </em> </strong>参见<strong class="kw io"> <em class="ls">在非8081端口上运行iOS应用程序</em> </strong>一节，了解关于这个一般主题的讨论和基本原理。以下是Android的细节。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">if you need to use a non-8081 port for Metro apps</figcaption></figure></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="2af5" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">完善模型——添加一点sumpin</h2><p id="9804" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">从技术上来说，我们已经实现了我们的目标，即创建一个应用程序，作为未来应用程序的可重用核心。但是目的是什么呢？使用上述说明创建一个新的应用程序就像从我们的新模型中“克隆”一个一样简单。但这没有抓住重点。</p><p id="423a" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">毕竟，这个练习的目的是创建一个可克隆的参考实现。是的，为了节省时间，但更重要的是为了促进我们的标准，提供一致性和可重复性，以及在我们的开发环境中代表我们对未来应用的最低期望。</p><p id="857b" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">另一方面，在这里猜测一个给定的开发努力或组织可能需要或甚至想要什么是愚蠢的。取而代之的是，让我们补充一点每个人都需要的假设，以表明我们在这里。一些<em class="ls">常用目录</em>怎么样？总之，他们通常是第一个上来的。</p><p id="15a9" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io">此外，围绕媒体、字体、服务、语言、可访问性和其他任意特性的各种资产需要共同的生存空间。下面是一些你会在野外看到的目录。还有其他的，你可能不需要所有这些。您将根据您的应用、组织和客户的要求找到自己的组合，但这些是几个事实上的选择，让这一切成为现实。</strong></p><p id="a4ca" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">在应用程序的根目录(<code class="fe nm nn no np b"><strong class="kw io">./rctnts</strong></code>，运行这些<code class="fe nm nn no np b"><strong class="kw io">mkdir</strong></code>命令。我们创建了<code class="fe nm nn no np b"><strong class="kw io">.keep</strong></code>文件，所以最深的目录被git选中(git不存储空目录)。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="f00b" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">mkdir -p src/assets/fonts; touch src/assets/fonts/.keep<br/>mkdir -p src/components; touch src/components/.keep<br/>mkdir -p src/i18n; touch src/i18n/.keep<br/>mkdir -p src/modules; touch src/modules/.keep<br/>mkdir -p src/services; touch src/services/.keep</strong></span></pre><p id="32a8" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">src/assets/fonts</strong></code> <strong class="kw io"> </strong>标准放置各种系统检查字体</p><p id="eb06" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">src/components</strong></code> <strong class="kw io"> </strong>我们组件的专用根目录</p><p id="8711" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">src/i18n</strong></code> <strong class="kw io"> </strong>国际化资产包括翻译映射</p><p id="6abd" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">src/modules</strong></code><strong class="kw io"/>React特定组件之外的代码和算法</p><p id="0656" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">src/services</strong></code> <strong class="kw io"> </strong>访问和管理任意功能的抽象</p><p id="43b1" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">将参考模型提交给git <br/> </em> </strong>让我们将我们的参考模型提交给<code class="fe nm nn no np b"><strong class="kw io">git</strong></code>，以便为C <em class="ls"> lone和重命名</em>流程做好准备。在<code class="fe nm nn no np b"><strong class="kw io">./rctnts</strong></code>中，运行以下命令，我们称之为参考实现。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="ceee" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">git init</strong><strong class="np io"><br/></strong><strong class="np io">git add -A</strong><strong class="np io"><br/></strong><strong class="np io">git commit -m 'initial commit'</strong></span></pre><p id="ce5c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们的模板已经给了我们一个完美的<code class="fe nm nn no np b"><strong class="kw io">.gitignore</strong></code>文件，所以我们现在有了一个好的、可发布的工作库(减去一个<code class="fe nm nn no np b"><strong class="kw io">README.md</strong></code>文件)。</p><h2 id="94dc" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">克隆并重命名我们的参考应用</h2><p id="a1e4" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">克隆参考应用<br/> </em> </strong>我们已经为将来会有自己名字的应用创建了一个参考模型。所以我们才花了无数个小时来到这里。因此，让我们克隆我们的模型应用程序，并对其进行重命名。让我们把这个新的应用程序叫做<em class="ls">目录应用程序</em>，就像我们知道自己在做什么一样。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="6ece" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">cd ~/apps<br/>git clone rctnts catalogapp<br/>cd catalogapp</strong></span></pre><p id="6794" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io">此外，iOS和Android平台的命名惯例完全不同，这使得重命名React原生应用看起来更像是一项职业，而不是一个偶然的问题。</strong></p><p id="d7bc" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">幸运的是，开源社区又一次提供了我们所需要的东西。我们将使用一个社区贡献的包来帮助我们高效地克隆/重命名应用程序本身，并帮助更改其绑定和应用程序标识符。还有一个琐碎但必要的手动步骤。</p><p id="8323" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">重命名我们的参考app <br/> </em> </strong>全局安装精彩的<code class="fe nm nn no np b"><a class="ae ly" href="https://www.npmjs.com/package/react-native-rename" rel="noopener ugc nofollow" target="_blank"><strong class="kw io">react-native-rename</strong></a></code> <strong class="kw io"> </strong>包和二进制文件并运行，如下所示(全部来自我们新的<code class="fe nm nn no np b">./<strong class="kw io">catalogapp</strong></code>目录内)。然后按照完整的<code class="fe nm nn no np b"><strong class="kw io">react-native-rename</strong></code>输出(此处未显示)中的指示运行此处显示的清理命令。结尾用一个<code class="fe nm nn no np b"><strong class="kw io">CTRL-c</strong></code>爆发。</p><pre class="kj kk kl km gt nr np ns nt aw nu bi"><span id="3d42" class="lz jl in np b gy nv nw l nx ny"><strong class="np io">yarn global add react-native-rename<br/>npx react-native-rename 'Catalog App' -b com.acme.catalogapp</strong><strong class="np io"><br/></strong>/ios/CatalogApp RENAMED<br/>/ios/CatalogApp-tvOS RENAMED<br/>...<br/>/app.json MODIFIED<br/>/android/app/build.gradle MODIFIED<br/>...<br/><strong class="np io">yarn install<br/>...<br/>cd ios; pod install; cd ..</strong><em class="ls"><br/>...<br/>Pod installation complete! There are 47 dependencies from the Podfile and 38 total pods installed.</em><br/><strong class="np io">watchman watch-del-all<br/></strong><em class="ls">{<br/>    "version": "4.9.0",<br/>    "roots": [<br/>        "/Users/fred/apps/rctnts"<br/>    ]<br/>}</em><br/><strong class="np io">npx react-native start --reset-cache<br/><em class="ls">...<br/></em></strong>To reload the app press "r"<br/>To open developer menu press "d"<br/><strong class="np io">CTRL-c</strong></span></pre><p id="96bb" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">传递给<code class="fe nm nn no np b"><strong class="kw io">react-native-rename</strong></code> ( <code class="fe nm nn no np b">'Catalog App'</code>)的app名称和bundle id <br/> </em> </strong>主值将成为<code class="fe nm nn no np b"><strong class="kw io">app.json</strong></code>中<code class="fe nm nn no np b">displayName</code>参数的值。它的语法是混合大小写的字母数字加空格。该值也将被分配给<code class="fe nm nn no np b">name</code>参数(没有空格)。</p><p id="1197" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">-b</strong></code>选项指定了<em class="ls"> Bundle ID </em>，它将在Android端控制大量的Java类型(反向域)目录命名，但在iOS端则没有。捆绑包id的长度必须至少为两段(由句点分隔)，并且不能以句点结尾。每个段都是大小写混合的字母数字加连字符，并且必须以字母开头。</p><p id="02c2" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">要指定iOS端的捆绑ID，请参见上面标题为<em class="ls">选择与您的Apple ID关联的签名团队</em>的截图。我们使用该屏幕选择了我们的<em class="ls">签约团队</em>，但是团队字段的正下方是<em class="ls">捆绑包标识符</em>字段。在Xcode中打开我们的新应用程序(<code class="fe nm nn no np b"><strong class="kw io">xed ./ios</strong></code>)，返回到该屏幕并输入您在上面输入的确切的捆绑包ID。从那里保存应用程序，它将被编码到我们项目的iOS端。</p><p id="0ca0" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">注意，包id很重要。它们在苹果的应用商店和谷歌的Play商店中唯一地识别你的应用。在您的应用程序被接受之前，您可以更改它们。之后，在应用程序的整个生命周期中，你都要使用这个标识符。慎重选择。</p><p id="cbee" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">为了测试新系统<br/> </em> </strong>使用<code class="fe nm nn no np b"><strong class="kw io">npx react-native start</strong></code>在自己的终端会话中启动Metro，在另一个终端中，使用<code class="fe nm nn no np b"><strong class="kw io">npx react-native run-</strong><em class="ls">platform</em></code>(其中<code class="fe nm nn no np b"><em class="ls">platform </em></code>是<code class="fe nm nn no np b">ios </code>或<code class="fe nm nn no np b">android</code>)启动iOS或Android应用程序(确保首先运行Android模拟器)。</p><p id="183b" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">如果使用连接的设备，请按照<em class="ls"> O </em> <strong class="kw io"> <em class="ls">下的说明在设备</em> </strong>上运行iOS/Android应用程序。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="761e" class="lz jl in bd jm ma mb dn jq mc md dp ju lf me mf jy lj mg mh kc ln mi mj kg mk bi translated">货物</h2><p id="c2f7" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">已经走了这么远，你现在有权得到货物。以下两个脚本结合了整个故事中的操作命令、技术和假设。我称他们为<code class="fe nm nn no np b"><strong class="kw io">rctntsclone</strong></code>和<code class="fe nm nn no np b"><strong class="kw io">rctntsrun</strong></code>，但是你喜欢怎么称呼他们都行。将这些列表的内容粘贴到您选择的文件中，并使它们可执行(<code class="fe nm nn no np b"><strong class="kw io">chmod 755 rctntsclone rctntsrun</strong></code>)。</p><p id="4e57" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">在使用这些脚本之前，请确保您已经按照上面的说明创建了我们的<code class="fe nm nn no np b"><strong class="kw io">rctnts</strong></code>参考模型(按照上面的说明从<strong class="kw io"> <em class="ls">创建参考模型</em> </strong>到<strong class="kw io"> <em class="ls">将参考模型提交给git </em> </strong>，包括在内)，这些脚本应该可以正常工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk"><code class="fe nm nn no np b">the<strong class="ak"> rctntsclone </strong>script</code></figcaption></figure><p id="ad89" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"><em class="ls">rctntsclone脚本<br/> </em> </strong>该脚本一举完成克隆和重命名过程。</p><p id="03f8" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">正在运行命令…</p><p id="4ec3" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">rctntsclone \<br/>--app 'Catalog App' \<br/>--bundle com.acme.CatalogApp</strong></code></p><p id="e5e3" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">…在<code class="fe nm nn no np b"><strong class="kw io">./rctnts</strong></code>目录中，将验证您的捆绑包ID，克隆<code class="fe nm nn no np b"><strong class="kw io">rctnts</strong></code>应用程序，重命名并在之后清理，创建一个包含该应用程序的新的并行目录(<code class="fe nm nn no np b"><strong class="kw io">../CatalogApp</strong></code>)。</p><p id="92bc" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们在这里使用<code class="fe nm nn no np b"><strong class="kw io">zsh</strong></code> shell(并继续使用),因为它现在是macOS的默认设置。另外，它能够解析“长”命令选项(<code class="fe nm nn no np b">--app</code>)。</p><p id="896b" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">如果用户误用选项或通过<code class="fe nm nn no np b">--help</code>选项，将打印用法。</p><p id="103c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这个脚本和我们之前收集的shell命令的主要区别在于，这个脚本执行了许多健全性检查和验证。</p><p id="7842" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">例如，它验证包ID的语法，并确保脚本在一个合理的位置启动——目录<code class="fe nm nn no np b"><strong class="kw io">./rctnts</strong></code>。</p><p id="655e" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这里的捆绑ID验证是一种混合的东西，旨在保护与苹果应用商店和谷歌Play商店兼容的值。虽然这两个商店之间的Bundle ID规范非常类似于Java风格的反向域名，但是我们必须坚持一些细微的差异，而且我们确实这样做了。</p><p id="eaa8" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">最后，该脚本启动Metro服务器，只是将<code class="fe nm nn no np b"><strong class="kw io">--reset-cache</strong></code>选项传递给它，作为其清理过程的一部分，在此之后，它等待几秒钟并终止剩余的进程。</p><p id="e11c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">如上所述，不要忘记通过Xcode复制新的包ID。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk">the<strong class="ak"> rctntsrun </strong>script</figcaption></figure><p id="2cb2" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"><em class="ls">rctntsrun脚本<br/> </em> </strong>接下来，您可以<code class="fe nm nn no np b"><strong class="kw io">cd</strong> <strong class="kw io">../CatalogApp</strong></code>并运行命令<code class="fe nm nn no np b"><strong class="kw io">rctntsrun</strong></code>的一些变体，比如…</p><p id="091d" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">rctntsrun --ios --port 8042 \<br/>--device 'Rons iPhone'</strong></code></p><p id="0f8c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">…有或没有设备(和可选的设备名称)，在Android或iOS平台上，针对任何有效的可用端口(或重用工作的Metro端口)。</p><p id="0983" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">该脚本将编辑文件并执行启动应用程序所需的命令。根据您的测试场景，它可以针对相同或不同的端口同时运行多次。例如，你可以在iOS上运行一次，在Android的同一个端口上再运行一次，在两个设备上同时测试同一个应用。你可以启动多个应用程序(在不同的端口上)以及模拟器/设备/端口/平台的任何其他逻辑排列。</p><p id="90e1" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这里值得评论的一些代码包括第37行…</p><p id="180f" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><code class="fe nm nn no np b"><strong class="kw io">if [[ “$v_port” != &lt;-&gt; ]] {</strong></code></p><p id="4448" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">…这确保了<code class="fe nm nn no np b"><strong class="kw io">$v_port</strong></code>变量只包含数字字符。很好奇是因为这种模式只有<code class="fe nm nn no np b"><strong class="kw io">zsh</strong></code>才有。</p><p id="7fc6" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这里真正繁重的工作是由第70–77行的<code class="fe nm nn no np b"><strong class="kw io">ed</strong></code>命令完成的。这里，脚本将文件的<code class="fe nm nn no np b"><strong class="kw io">RCT_METRO_PORT</strong></code>条目更新为我们的命令的<code class="fe nm nn no np b"><strong class="kw io">--port</strong></code>值，或者如果没有指定，则更新为默认值(<code class="fe nm nn no np b"><strong class="kw io">8081</strong></code>)。</p><p id="9569" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">从第82行开始，脚本评估用户输入的端口当前是否在使用，这是一个很有意思的步骤。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="bfb4" class="jk jl in bd jm jn ng jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd nk kf kg kh bi translated">结论</h1><p id="dad6" class="pw-post-body-paragraph ku kv in kw b kx lt kz la lb lu ld le lf lv lh li lj lw ll lm ln lx lp lq lr ig bi translated">咻。您已经创建了一个React Native TypeScript参考应用程序，用于支持您的产品计划。你已经用它召唤出了邪恶的同卵双胞胎。现在，您拥有了几个独特而强大的脚本，它们可以与您不断发展的体系结构进行插件兼容。</p><p id="2db3" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">感谢您在此投入时间。我相信这会为你节省几个小时的时间。感谢你远道而来——很明显你在坏蛋的北面。快乐编码，愿源代码与你同在！</p><p id="cae8" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">罗恩·霍沃斯<br/>北美粘度</p><p id="1890" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="kw io"> <em class="ls">许可:</em> </strong> <em class="ls">以上脚本为</em>原创<em class="ls">且完全免费，可用于任何您认为有趣的用途、商业用途或其他用途。这里的想法、方法和代码样本都是从最好的朋友、工程师、网络空间潜水酒吧和目前可用的行星地狱洞中剽窃来的。积极地分享它们。</em></p></div></div>    
</body>
</html>