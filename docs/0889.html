<html>
<head>
<title>Leetcode Problem: Partition Labels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode问题:分区标签</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-problem-partition-labels-f7eb1182f55f?source=collection_archive---------7-----------------------#2021-02-24">https://javascript.plainenglish.io/leetcode-problem-partition-labels-f7eb1182f55f?source=collection_archive---------7-----------------------#2021-02-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ff0c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">双指针JavaScript解决方案演练</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/16d47657d00aea12f053c618a98f35b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QP1e7aaiL-4v0WHno41TA.jpeg"/></div></div></figure><p id="a407" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我对自己的算法解决技巧越来越有信心。以至于我已经升级到中等难度的Leetcode问题。耶！我能毫不费力地解决我看到的每一个问题吗？绝对不会。我现在所处的阶段是，对于给定的问题，我通常可以提出一个可行的强力解决方案。然而，在寻找最优答案时，我通常会寻找一些提示。不过没关系！只要我在继续下一步之前花时间充分理解解决方案，我就会学到一两个新技巧，并可以将它们应用到下一个问题中。</p><p id="9461" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面就是这样一个问题:</p><h1 id="1474" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">分区标签问题</h1><p id="bdc4" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">给出一串小写英文字母<code class="fe mh mi mj mk b">S</code>。我们希望将这个字符串分割成尽可能多的部分，以便每个字母最多出现在一个部分中，并返回一个表示这些部分大小的整数列表。</p><h2 id="a3f6" class="ml ll in bd lm mm mn dn lq mo mp dp lu kx mq mr lw lb ms mt ly lf mu mv ma mw bi translated"><strong class="ak">注:</strong></h2><ul class=""><li id="391d" class="mx my in kq b kr mc ku md kx mz lb na lf nb lj nc nd ne nf bi translated"><code class="fe mh mi mj mk b">S</code>将具有在<code class="fe mh mi mj mk b">[1, 500]</code>范围内的长度。</li><li id="7644" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated"><code class="fe mh mi mj mk b">S</code>将只包含小写英文字母(<code class="fe mh mi mj mk b">'a'</code>到<code class="fe mh mi mj mk b">'z'</code>)。</li></ul><h2 id="adc6" class="ml ll in bd lm mm mn dn lq mo mp dp lu kx mq mr lw lb ms mt ly lf mu mv ma mw bi translated">示例:</h2><pre class="kd ke kf kg gt nl mk nm nn aw no bi"><span id="6f16" class="ml ll in mk b gy np nq l nr ns"><strong class="mk io">Input:</strong> S = "ababcbacadefegdehijhklij"<br/><strong class="mk io">Output:</strong> [9,7,8]<br/><strong class="mk io">Explanation: </strong>The partition is "ababcbaca", "defegde", "hijhklij".</span></pre><h1 id="f8c7" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">算法</h1><p id="32d7" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">为了解决这个问题，我们将使用两点解决方案。请参见以下步骤:</p><h2 id="6482" class="ml ll in bd lm mm mn dn lq mo mp dp lu kx mq mr lw lb ms mt ly lf mu mv ma mw bi translated"><strong class="ak">步骤</strong>:</h2><ol class=""><li id="d03f" class="mx my in kq b kr mc ku md kx mz lb na lf nb lj nt nd ne nf bi translated">首先，我们为字符串中每个唯一字符的最后一个索引创建一个hashmap。这是通过遍历字符串并存储每个字母出现的索引来实现的。如果一个字母重复出现，哈希将使用更大的索引进行更新，并且只保存最后出现的字母。</li><li id="37d8" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nt nd ne nf bi translated">接下来是两个指针部分。首先，我们将初始化我们的分区数组(这就是我们将要返回的内容)，并且初始化指向字符串开头的两个指针(将end和start设置为0)。</li><li id="d2c4" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nt nd ne nf bi translated">然后我们遍历字符串，设置结束指针。结束指针是我们所在的索引和我们所在字符的最后一个索引之间的较大值(使用hashmap！).</li><li id="01ad" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nt nd ne nf bi translated">接下来，我们比较结束指针的位置和我们在字符串上迭代的位置。如果当前索引与结束索引不同，我们就必须继续移动，什么也不做。</li><li id="9ce5" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nt nd ne nf bi translated">但是，如果end和current索引相同，那么我们一定是在一个分区的末尾。基本上，这个字符不会再出现，所以你应该在字符串中做一个剪切，以确保我们得到最大数量的分区。</li><li id="0163" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nt nd ne nf bi translated">要进行切割，请将段的长度推入分区数组。然后，在最后一个分区结束后，我们将开始指针更新为1。</li><li id="b4b0" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nt nd ne nf bi translated">循环结束后，我们简单地返回分区数组。</li></ol><h1 id="ebde" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">解决方案代码</h1><pre class="kd ke kf kg gt nl mk nm nn aw no bi"><span id="3d48" class="ml ll in mk b gy np nq l nr ns">var partitionLabels = function(S) {</span><span id="c4ef" class="ml ll in mk b gy nu nq l nr ns">  let lastIndex = {}</span><span id="d7ef" class="ml ll in mk b gy nu nq l nr ns">  for (let i = 0; i &lt; S.length; i++){<br/>    lastIndex[S[i]]= i<br/>  }</span><span id="3d78" class="ml ll in mk b gy nu nq l nr ns">  let partitions = []<br/>  let start = 0<br/>  let end = 0</span><span id="d20b" class="ml ll in mk b gy nu nq l nr ns">  for (let i = 0; i &lt; S.length; i++) {<br/>    end = Math.max(end, lastIndex[S[i]])<br/>    if (i === end) {<br/>      partitions.push(i — start + 1)<br/>      start = i + 1<br/>    }<br/>  }</span><span id="0c52" class="ml ll in mk b gy nu nq l nr ns">  return partitions<br/>}</span></pre><h1 id="b613" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">时空复杂性</h1><p id="71ab" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">在完成时空复杂性分析之前，永远不要离开一个问题。它可以帮助触发一个信号到一个可能存在更优化方法的强力解决方案。</p><p id="bc16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于上面的解决方案代码:</p><p id="4313" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">空间复杂度:O(n) </strong>这与我们存储每个字符的最后一个索引的步骤有关。理论上，您可以让每个字符都是唯一的，从而产生该哈希所需的O(n)个空间。</p><p id="048e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">时间复杂度:O(n) </strong>循环遍历数组两次。一次是创建最后一个索引的散列，另一次是创建分区。这导致最坏情况下的时间复杂度为2*O(n)。但是我们不关心系数，所以我们在开始时去掉了2。</p><h1 id="8d88" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated"><strong class="ak">更多(中)问题</strong></h1><p id="ba27" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">在完成一个算法后，特别是一个我需要一些额外帮助的算法，我喜欢解决另一个类似的问题。寻找解决方案没有错，但是为了确保你正在学习，试着将这些技能应用到一个新的问题上。</p><p id="785e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有一个相关的Leetcode提示的问题:<a class="ae nv" href="https://leetcode.com/problems/merge-intervals/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">合并间隔时间</strong> </a>。试试吧！</p><h1 id="c827" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">参考</h1><ul class=""><li id="ac6a" class="mx my in kq b kr mc ku md kx mz lb na lf nb lj nc nd ne nf bi translated"><a class="ae nv" href="https://leetcode.com/problems/partition-labels/" rel="noopener ugc nofollow" target="_blank">分区标签-leet code</a></li><li id="707e" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated"><a class="ae nv" href="https://algorithmexplorer.medium.com/leetcode-763-partition-labels-33350a163019" rel="noopener"> Leetcode #763分区标签</a></li><li id="0623" class="mx my in kq b kr ng ku nh kx ni lb nj lf nk lj nc nd ne nf bi translated"><a class="ae nv" href="https://dev.to/mzakzook/leetcode-partition-labels-3dma" rel="noopener ugc nofollow" target="_blank">leet code-分区标签</a></li></ul></div></div>    
</body>
</html>