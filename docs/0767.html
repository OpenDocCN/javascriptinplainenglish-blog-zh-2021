<html>
<head>
<title>JavaScript: How To Intercept Function and Method Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:如何拦截函数和方法调用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-how-to-intercept-function-and-method-calls-b9fd6507ff02?source=collection_archive---------2-----------------------#2021-02-17">https://javascript.plainenglish.io/javascript-how-to-intercept-function-and-method-calls-b9fd6507ff02?source=collection_archive---------2-----------------------#2021-02-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="e71b" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">JavaScript Alpha指南</h2><div class=""/><div class=""><h2 id="cb09" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">拦截JavaScript中的函数或方法调用。猴子补丁或代理。让我们谈谈那个。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c302360be81f17d32a5403defbab644e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnH0shEKgBEACEkEtbTQsw.jpeg"/></div></div></figure><p id="ba3d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">前几天，我有一个对象，需要知道它的任何方法何时被调用。这个对象有许多方法，这些方法在许多文件中被调用。因此，在每次调用后添加一行额外的代码来获得调用通知似乎是不切实际的。</p><h1 id="7466" class="lt lu in bd lv lw lx ly lz ma mb mc md kc me kd mf kf mg kg mh ki mi kj mj mk bi translated">问题是</h1><p id="4be6" class="pw-post-body-paragraph kx ky in kz b la ml jx lc ld mm ka lf lg mn li lj lk mo lm ln lo mp lq lr ls ig bi translated">让我们考虑以下对象:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="ddc3" class="mv lu in mr b gy mw mx l my mz">let myObj = {<br/>  multiply(x, y) {<br/>    return x * y;<br/>  },<br/>  squared(x) {<br/>    return x ** x;<br/>  }<br/>};</span></pre><p id="ceea" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在，每次你调用<code class="fe na nb nc mr b">myObj.multiply(x, y)</code>或<code class="fe na nb nc mr b">myObj.squared(x)</code>时，你都想知道在<code class="fe na nb nc mr b">myObj</code>对象上调用了一个方法。在理想的情况下，你会想知道它是哪种方法，它是用什么参数调用的。类似这样的。</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="2d96" class="mv lu in mr b gy mw mx l my mz">interceptMethodCalls(myObj, (fnName, fnArgs) =&gt; { ... });</span></pre><h1 id="eb50" class="lt lu in bd lv lw lx ly lz ma mb mc md kc me kd mf kf mg kg mh ki mi kj mj mk bi translated">猴子补丁</h1><blockquote class="nd ne nf"><p id="8ee0" class="kx ky ng kz b la lb jx lc ld le ka lf nh lh li lj ni ll lm ln nj lp lq lr ls ig bi translated">Monkey patching是一种在运行时添加、修改或取消一段代码的默认行为而不改变其原始源代码的技术<br/>https://www . au dero . it/blog/2016/12/05/monkey-patching-JavaScript</p></blockquote><p id="7b62" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">所以<strong class="kz ix">猴子补丁</strong>基本上是运行时属性的动态替换。我们如何着手解决猴子补丁的问题？</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="8831" class="mv lu in mr b gy mw mx l my mz">function interceptMethodCalls(obj, fn) {<br/>  Object.keys(obj).forEach(key =&gt; { // <strong class="mr ix">(A)</strong><br/>    const prop = obj[key];<br/>    if (typeof prop === 'function') { // <strong class="mr ix">(B)</strong><br/>      const origProp = prop;<br/>      obj[key] = (...args) =&gt; { // <strong class="mr ix">(C)</strong><br/>        fn(key, args); // <strong class="mr ix">(D)</strong><br/>        return Reflect.apply(origProp, obj, args); // <strong class="mr ix">(E)</strong><br/>      }<br/>    }<br/>  });<br/>}</span></pre><p id="f8f4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在第<code class="fe na nb nc mr b">(A)</code>行，我们遍历给定对象的属性名。在第<code class="fe na nb nc mr b">(B)</code>行，我们检查对象的属性是否是一个函数。神奇的事情发生在第<code class="fe na nb nc mr b">(C)</code>行，我们用一个匿名函数替换了原来的函数——这就是<strong class="kz ix">猴子补丁</strong>部分。这个匿名函数用两个参数调用给定的<code class="fe na nb nc mr b">fn</code>函数<code class="fe na nb nc mr b">(D)</code>: 1。被调用函数的名称，2。调用函数时使用的参数(作为数组)。最后，我们使用<code class="fe na nb nc mr b">Reflect</code> API调用原始函数。</p><p id="c678" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这太棒了👍。</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="c170" class="mv lu in mr b gy mw mx l my mz">const handleMethodCall = (fnName, fnArgs) =&gt;<br/>  console.log(`${fnName} called with `, fnArgs);</span><span id="5759" class="mv lu in mr b gy nk mx l my mz">interceptMethodCalls(myObj, handleMethodCall);</span><span id="24ff" class="mv lu in mr b gy nk mx l my mz">myObj.multiply(2, 7); // "multiply called with [ 2, 7 ]"<br/>myObj.squared(2); // "squared called with [ 2 ]"</span></pre><p id="8e8b" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">酪总有一个but️.</p><p id="9c56" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">猴子补丁的作用是改变对象的位置。</strong>在我们的例子中是<code class="fe na nb nc mr b">myObj</code>。在调用<code class="fe na nb nc mr b">interceptMethodCalls(myObj, handleMethodCall);</code>之后，所有的对象方法都被替换成不同的方法——行<code class="fe na nb nc mr b">(C)</code>。</p><p id="2fa3" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们不希望这样。有更好的解决办法。</p><h1 id="7bb3" class="lt lu in bd lv lw lx ly lz ma mb mc md kc me kd mf kf mg kg mh ki mi kj mj mk bi translated">代理人</h1><blockquote class="nd ne nf"><p id="5f5b" class="kx ky ng kz b la lb jx lc ld le ka lf nh lh li lj ni ll lm ln nj lp lq lr ls ig bi translated"><code class="fe na nb nc mr b">Proxy</code>对象使您能够为另一个对象创建一个代理，它可以截取并重新定义该对象的基本操作<br/><a class="ae nl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Proxy</a></p></blockquote><p id="9efd" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">JavaScript <strong class="kz ix">代理</strong>包装另一个对象(目标)并允许您拦截目标对象上的基本操作。像获取一个值、设置一个值、调用一个函数这样的操作。这些操作被称为<strong class="kz ix">陷阱</strong>。这听起来正是我们想要实现的目标。</p><h2 id="14a6" class="mv lu in bd lv nm nn dn lz no np dp md lg nq nr mf lk ns nt mh lo nu nv mj it bi translated">应用陷阱</h2><blockquote class="nd ne nf"><p id="3dcf" class="kx ky ng kz b la lb jx lc ld le ka lf nh lh li lj ni ll lm ln nj lp lq lr ls ig bi translated">"<code class="fe na nb nc mr b"><strong class="kz ix">handler.apply()</strong></code>方法是一个函数调用的陷阱."~<a class="ae nl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/apply" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Proxy/Proxy/apply</a></p></blockquote><p id="9777" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这个<code class="fe na nb nc mr b">apply</code>陷阱看起来很合适。不过，有个问题。在对象上调用方法实际上是两个操作。</p><ol class=""><li id="d7e2" class="nw nx in kz b la lb ld le lg ny lk nz lo oa ls ob oc od oe bi translated">检索功能- <code class="fe na nb nc mr b">get</code>陷阱</li><li id="a6da" class="nw nx in kz b la of ld og lg oh lk oi lo oj ls ob oc od oe bi translated">调用函数- <code class="fe na nb nc mr b">apply</code>陷阱</li></ol><p id="9cf1" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">方法调用没有<strong class="kz ix">陷阱</strong>，所以我们将结合<code class="fe na nb nc mr b">get</code>和<code class="fe na nb nc mr b">apply</code>陷阱。</p><p id="7cd5" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">工作解决方案如下:</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="5264" class="mv lu in mr b gy mw mx l my mz">function interceptMethodCalls(obj, fn) {<br/>  return new Proxy(obj, {<br/>    get(target, prop) { // <strong class="mr ix">(A)</strong><br/>      if (typeof target[prop] === 'function') {<br/>        return new Proxy(target[prop], {<br/>          apply: (target, thisArg, argumentsList) =&gt; { // <strong class="mr ix">(B)</strong><br/>            fn(prop, argumentsList);<br/>            return Reflect.apply(target, thisArg, argumentsList);<br/>          }<br/>        });<br/>      } else {<br/>        return Reflect.get(target, prop);<br/>      }<br/>    }<br/>  });<br/>}</span></pre><p id="e580" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">比猴子打补丁的方案长一点，但是更干净。在任何时候，我们都没有修改原始对象或它的方法。我们只是把它们包装在一个代理中。</p><p id="a377" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在第<code class="fe na nb nc mr b">(A)</code>行，我们在<code class="fe na nb nc mr b">obj</code>参数上设置<code class="fe na nb nc mr b">get</code>陷阱。所以当我们访问某个方法时(例如前面例子中的<code class="fe na nb nc mr b">myObj.multiply</code>),这个陷阱就会被触发。它只是对象上的一个属性。属性的值只是一个函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/4f85b78d30c942ffd126a3391ccdee9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*4pI93lh_hF0tSBYw8kMUiA.png"/></div><figcaption class="ol om gj gh gi on oo bd b be z dk">JavaScript Proxies When Intercepting Method Calls</figcaption></figure><p id="dc87" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在我们准备创建一个被检索函数的代理版本，我们可以通过<code class="fe na nb nc mr b">target[prop]</code>访问它。所以我们制作一个新的<strong class="kz ix">代理</strong>，设置<code class="fe na nb nc mr b">apply</code>陷阱，并返回那个<strong class="kz ix">代理</strong>而不是原来的方法。</p><p id="682f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">所以这基本上是一个两步的过程，但这是值得的，因为你既不改变对象也不改变它的方法。</p><h1 id="981a" class="lt lu in bd lv lw lx ly lz ma mb mc md kc me kd mf kf mg kg mh ki mi kj mj mk bi translated">操场</h1><p id="b896" class="pw-post-body-paragraph kx ky in kz b la ml jx lc ld mm ka lf lg mn li lj lk mo lm ln lo mp lq lr ls ig bi translated">你可以在<a class="ae nl" href="https://repl.it/@MelkorNemesis/Intercept-Method-Calls" rel="noopener ugc nofollow" target="_blank">https://repl.it/@MelkorNemesis/Intercept-Method-Calls</a>玩一玩上面的代码。</p></div></div>    
</body>
</html>