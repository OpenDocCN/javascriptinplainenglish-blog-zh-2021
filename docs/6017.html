<html>
<head>
<title>Pros and Cons of the Different Types of Test Doubles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不同类型测试双打的利与弊</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dealing-with-test-doubles-2e475ba6eb54?source=collection_archive---------6-----------------------#2021-12-24">https://javascript.plainenglish.io/dealing-with-test-doubles-2e475ba6eb54?source=collection_archive---------6-----------------------#2021-12-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b3df" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">比较不同类型的测试双打，并找到最适合测试您的实现。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/e3ec4b1bff589a0d58497f20cbf7fbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*9oFLT5LLdgctEg6h.jpg"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Photo by <a class="ae ko" href="https://www.pexels.com/@nicollazzi-xiong-208366?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kp">nicollazzi xiong</strong></a> from <a class="ae ko" href="https://www.pexels.com/photo/four-rock-formation-668353/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kp">Pexels</strong></a></figcaption></figure><p id="7dde" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">毫无疑问，测试是软件开发中最重要的部分之一。已经开发了许多工具来简化测试过程。但是时间工程师通常不愿意写测试，因为两个原因，脆弱和缓慢的测试。</p><p id="e816" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">如果一个测试由于没有在产品代码中引入任何bug的无关变更而失败，那么这个测试就被认为是脆弱的。如果测试验证的是实现细节而不是公共API，就会发生这种情况。</p><p id="34b7" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">另一方面，缓慢的测试可能是由多种原因造成的。也许测试正在执行一个增加延迟的HTTP请求，也许测试必须模拟延迟以满足某些条件，等等。其中很少是好的，但是想象一下数百个测试用例，每个都增加了几秒钟的运行时间，测试可能需要几个小时才能完成。</p><p id="40b7" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">在这种情况下，<strong class="ks io">测试替身</strong>会很方便。</p><h1 id="fd35" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">测试双打</h1><p id="af76" class="pw-post-body-paragraph kq kr in ks b kt me jo kv kw mf jr ky kz mg lb lc ld mh lf lg lh mi lj lk ll ig bi translated">如果术语test double对您来说感觉很奇怪，那是因为我们通常使用“mock”这个词来指代测试中使用的所有对象。</p><p id="19a5" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">就像替身演员代替演员表演身体要求高的东西一样，替身演员被用来代替真实的表演。test double是一个简单的替代对象或函数，其行为类似于真实实现的行为。当使用真正的生产服务不可行时，这是一个理想的选择。</p><blockquote class="mj mk ml"><p id="8da9" class="kq kr mm ks b kt ku jo kv kw kx jr ky mn la lb lc mo le lf lg mp li lj lk ll ig bi translated">你能想象每次我们运行一个测试案例时，必须实际处理信用卡支付服务的费用吗？</p></blockquote><p id="df52" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">罗伯特·马丁(也被称为鲍勃叔叔)写了一篇名为<a class="ae ko" href="https://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html" rel="noopener ugc nofollow" target="_blank">小嘲笑者</a>的简短博文，有趣地解释了各种测试替身之间的关系。</p><p id="7bbd" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">简而言之，测试替身由假人、假货、树桩、间谍和模仿品组成。每一种都支持不同风格的测试。</p><p id="d78d" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">在这些对象中，虚拟对象没有真正的行为，它们只是被传递来满足参数列表，而其余的工作方式略有不同。对于工程师来说，理解每种技术的工作原理及其缺点是非常有帮助的。</p><h1 id="1083" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">赝品</h1><p id="b35d" class="pw-post-body-paragraph kq kr in ks b kt me jo kv kw mf jr ky kz mg lb lc ld mh lf lg lh mi lj lk ll ig bi translated">首先，我们有fakes，一个API、对象或函数的轻量级版本。假货的行为与真货类似，它们有商业行为，但通常采取一些捷径来简化。</p><p id="8abc" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">这方面的一个例子是代表真实数据库的内存数据库。</p><p id="8627" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">假货可以在没有嘲讽框架的帮助下构建，如<a class="ae ko" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>或<a class="ae ko" href="https://sinonjs.org/" rel="noopener ugc nofollow" target="_blank"> Sinon </a>。Typescript中的伪对象示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b63c" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">有了假货，真正的实现可以换成假的。在上面的例子中，我们创建了一个假的身份验证类，它严格遵循身份验证API契约，只要接口匹配，这个类以后可以用来替代真正的身份验证。</p><p id="4a51" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">围绕创建测试替身的一个相当重要的概念是<em class="mm">保真度</em>，这是一个假的行为与真实实现的行为有多接近。保真度越高越好，这意味着假货越接近生产代码，反过来，我们可以依靠它们在出现漏洞时捕捉漏洞。</p><p id="7610" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">然而，赝品的一个缺点是它们很难制作，维护起来也很麻烦。</p><h1 id="5017" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">存根和间谍</h1><p id="6077" class="pw-post-body-paragraph kq kr in ks b kt me jo kv kw mf jr ky kz mg lb lc ld mh lf lg lh mi lj lk ll ig bi translated">其他技术有存根和间谍。根据定义，存根化是一个将行为添加到一个原本不存在的函数中的过程。但是，也可以用来替换现有的行为，以避免处理依赖关系。</p><p id="635a" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">另一方面，间谍只是存根，但是它们跟踪调用，这样你就可以验证它们被调用了多少次。</p><p id="7dc0" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">开玩笑的说，树桩和间谍是一样的东西，它们可以用<code class="fe ms mt mu mv b">jest.spyOn()</code>创建:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="62a7" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">在上面的例子中，我们在<code class="fe ms mt mu mv b">getCount</code>方法上添加了一个行为，这样无论如何它都会返回一个值<code class="fe ms mt mu mv b">20</code>。</p><p id="b509" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">当需要模拟各种各样的返回值时，存根是合适的，如果我们使用真实的实现或假的，这可能是不可能的。</p><p id="f29b" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">此外，由于Jest将stub和spy对象视为同一事物，这意味着我们可以验证该对象确实被调用了。</p><pre class="kd ke kf kg gt mw mv mx my aw mz bi"><span id="e282" class="na ln in mv b gy nb nc l nd ne">expect(mockCounter.getCount).toHaveBeenCalled(); // ✅</span></pre><p id="7b93" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">因为stubbing很容易应用，所以很容易把它当作一个简单的补丁来处理其他重要的行为。如果我们过度依赖存根来定制实现，那么与实际实现的偏差就是一个真正的问题。</p><h1 id="3a5f" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">嘲弄</h1><p id="a2c6" class="pw-post-body-paragraph kq kr in ks b kt me jo kv kw mf jr ky kz mg lb lc ld mh lf lg lh mi lj lk ll ig bi translated">您可能会注意到，到目前为止，我们所做的只是验证“状态”在给定条件下是否正确。换句话说，我们正在做一个状态验证，一个通过验证被测试系统的状态来验证被运用的方法是否正确工作的测试。</p><p id="b41b" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">问题是，被测试的系统可能是有状态的，也可能不是，在这种情况下，我们需要使用行为验证测试，一种验证某个方法的调用的测试。这就是模仿发挥作用的地方。</p><p id="2100" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">模拟是预编程的对象，具有观察调用的能力。在测试过程中，用模拟的物体代替真实的物体，这是确保副作用不会发生的好方法。此外，我们还可以设置断言，如果一个函数根本没有被调用、用错误的参数调用或者调用次数过多，测试就会失败。</p><p id="2688" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">假设我们有一个名为<code class="fe ms mt mu mv b">analytics</code>的对象，它包含几个如下所示的方法:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="92d0" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">我们可能不想在测试期间向分析仪表板发送实际事件，但是我们确实需要确保它们被调用。</p><p id="3b89" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">为了解决这个问题，我们可以模仿<code class="fe ms mt mu mv b">analytics</code>模块:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="eda9" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><code class="fe ms mt mu mv b">jest.mock('./analytics')</code>在这种情况下，相当于:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1581" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><code class="fe ms mt mu mv b">jest.fn()</code>是一个方便的函数，它将删除一个方法的当前行为，并用一个模仿对象来替换它。这样，我们可以安全地调用<code class="fe ms mt mu mv b">analytics.sendEvent()</code>进行测试，而不必担心副作用。</p><p id="9347" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">然后，我们可以像这样执行彻底的断言:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="537e" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">这种测试的一个缺点是它利用了被测系统的实现细节。我们已经接触到被测系统调用这个函数的测试。</p><p id="4598" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><a class="ae ko" href="https://kentcdodds.com/blog/testing-implementation-details" rel="noopener ugc nofollow" target="_blank">在本文</a>中，Kent C. Dodds说得很好，测试实现细节糟糕是因为两个原因:</p><ol class=""><li id="e486" class="nf ng in ks b kt ku kw kx kz nh ld ni lh nj ll nk nl nm nn bi translated">如果我们重构应用程序代码，测试可能会中断。<strong class="ks io">假阴性</strong></li><li id="549b" class="nf ng in ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">如果我们破坏了应用程序代码，测试可能不会失败。<strong class="ks io">假阳性</strong></li></ol><p id="fd4f" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">这两种情况都表明测试人员对被测系统的内部细节了解太多。</p><h1 id="14a2" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">状态验证与行为验证</h1><p id="0d93" class="pw-post-body-paragraph kq kr in ks b kt me jo kv kw mf jr ky kz mg lb lc ld mh lf lg lh mi lj lk ll ig bi translated">在测试过程中，我经常问自己的一个问题是，我应该使用模拟还是存根？</p><p id="883a" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">事实证明，这个问题的答案取决于执行状态验证是否比行为验证更合适。</p><p id="d696" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">在Martin Fowler的文章<a class="ae ko" href="https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs" rel="noopener ugc nofollow" target="_blank">中，这个决定几乎总是取决于上下文。我们谈论的是简单的合作还是相当尴尬的合作？</a></p><p id="6941" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">如果协作很容易，例如在<code class="fe ms mt mu mv b">Order</code>类和<code class="fe ms mt mu mv b">Warehouse</code>类之间，我们更有可能能够使用真实的对象或存根并执行状态验证。如果是尴尬的协作，比如<code class="fe ms mt mu mv b">Order</code>类和<code class="fe ms mt mu mv b">MailService</code>类之间的协作，我们很可能会使用mock并执行行为验证。</p><p id="4455" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">另一个要考虑的因素是这两种测试方法与实际工作代码的相似程度。行为验证的主要问题是，我们不能确定被测系统是否正常工作，我们只能验证某个函数是否如预期的那样被调用。举个例子，如果调用了<code class="fe ms mt mu mv b">database.save(payload)</code>函数，我们只能假设该项会被保存到数据库中。而使用状态验证，我们可以对数据库执行查询，以验证该项确实存在。</p><p id="ab62" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">当然，最终，我们需要衡量两个决策之间的权衡。</p><h1 id="7d57" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">结论</h1><p id="b8b8" class="pw-post-body-paragraph kq kr in ks b kt me jo kv kw mf jr ky kz mg lb lc ld mh lf lg lh mi lj lk ll ig bi translated">我从软件测试中学到的一件事是，不同的测试框架对测试副本的创建有不同的看法。在<code class="fe ms mt mu mv b">jest</code>中，测试双创仅限于<code class="fe ms mt mu mv b">jest.mock()</code>和<code class="fe ms mt mu mv b">jest.spyOn()</code>，stub和spy被视为同一事物，可以互换使用mock和stub。而在<code class="fe ms mt mu mv b">sinon</code>，则有<code class="fe ms mt mu mv b">sinon.stub()</code>、<code class="fe ms mt mu mv b">sinon.fake()</code>、<code class="fe ms mt mu mv b">sinon.mock()</code>、<code class="fe ms mt mu mv b">sinon.spy()</code>。</p><p id="8e97" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">测试替身在帮助工程师编写运行快速的综合测试套件方面非常有价值。然而，误用它们会导致一场维护噩梦。这就是为什么工程师需要了解每一种测试double的起伏。工程师经常需要权衡使用哪种技术。</p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="8eaa" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><em class="mm">原发布于</em><a class="ae ko" href="https://frendyguo.me/dealing-with-test-doubles/" rel="noopener ugc nofollow" target="_blank"><em class="mm">https://frendy Guo . me</em></a><em class="mm">。</em></p><p id="9005" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><em class="mm">更多内容看</em> <a class="ae ko" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mm">说白了就是</em> </a> <em class="mm">。报名参加我们的</em> <a class="ae ko" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mm">免费每周简讯</em> </a> <em class="mm">。在我们的</em> <a class="ae ko" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="mm">社区不和谐</em> </a> <em class="mm">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>