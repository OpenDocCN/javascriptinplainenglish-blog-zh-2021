<html>
<head>
<title>Master React With Ease: Understand Event Bubbling Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大师轻松应对:像专家一样理解事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/master-react-with-ease-understand-event-bubbling-like-a-pro-part-1-8389644dca34?source=collection_archive---------6-----------------------#2021-08-13">https://javascript.plainenglish.io/master-react-with-ease-understand-event-bubbling-like-a-pro-part-1-8389644dca34?source=collection_archive---------6-----------------------#2021-08-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="178a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解什么是事件冒泡以及如何在React应用中防止它——第1部分</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/51fd918758a1416af434ddde286f53ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crqiCvbiv8dyMFpd5WGYBg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://www.pexels.com/@inspiredimages?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Anthony</a> from <a class="ae ks" href="https://www.pexels.com/photo/clear-water-drops-132477/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="0396" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">欢迎来到《轻松应对大师》，这是一个<strong class="kv io"> </strong>系列节目，旨在帮助你以一种超级清晰易懂的方式理解《❤》</p><p id="3523" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我会教你<strong class="kv io">所有你需要知道的</strong>关于<strong class="kv io">事件冒泡</strong>的事情，这样你就可以开始在你的项目中应用你在这里学到的东西了！</p><p id="2169" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天您将学到的内容:</p><ul class=""><li id="3d99" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io"> ✨ </strong> <a class="ae ks" href="#549c" rel="noopener ugc nofollow"> <strong class="kv io">什么是事件委派？(+它与事件冒泡的关系)</strong> </a></li><li id="3335" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">✨</strong>t20<strong class="kv io">什么是事件冒泡？</strong> </li><li id="0b05" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">✨</strong><a class="ae ks" href="#2602" rel="noopener ugc nofollow"><strong class="kv io">JavaScript中事件冒泡是如何发生的</strong> </a></li><li id="88fc" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io"> ✨ </strong> <a class="ae ks" href="#b4b2" rel="noopener ugc nofollow"> <strong class="kv io">事件冒泡是如何在反应中发生的</strong> </a></li><li id="c8fd" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io"> ✨ </strong> <a class="ae ks" href="#ab13" rel="noopener ugc nofollow"> <strong class="kv io">如何阻止事件在你的组件中冒泡(附实例)</strong> </a></li></ul></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="549c" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">什么是事件委托？</h1><p id="dd8a" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">长话短说，事件委托就是<strong class="kv io">一种强大的JavaScript技术，允许更有效的事件处理。</strong></p><p id="4bf8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">👍优点(将进一步详细解释):</strong></p><ul class=""><li id="485d" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">这种技术通常被认为是高性能的，因为在顶级父元素上只使用了一个事件侦听器函数，而不是每个子元素都使用一个。</li></ul><p id="58f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">👎缺点(将进一步详细解释):</strong></p><ul class=""><li id="86a1" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">一旦内部子元素的事件被调用，它上面/下面的所有元素也将被调用(冒泡/捕获)。为了阻止这种情况发生，必须调用<code class="fe nh ni nj nk b">event</code>对象上的方法。</li><li id="37fd" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">本主题的第2部分将进一步详细解释其他问题。</li></ul><p id="486e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">冒泡</strong>和<strong class="kv io">捕获</strong>(稍后解释)允许我们实现事件委托模式。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="1dd4" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">什么是事件冒泡？</strong></h1><p id="6ce3" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">假设我们认识一个叫<code class="fe nh ni nj nk b">Molly</code>的女孩，她也不是一个真实的人，而是——🥁drum·罗尔——<strong class="kv io">一个React组件！哇！如此方便！</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/f870f91086f07ec37a333ed13a2bf888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fo9xuSf8Tt4Hl2Cd.jpg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">generated via <a class="ae ks" href="https://memegenerator.net/" rel="noopener ugc nofollow" target="_blank">https://memegenerator.net/</a></figcaption></figure><p id="fe32" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">她有一个单亲家长<code class="fe nh ni nj nk b">div</code>，有一个<code class="fe nh ni nj nk b">onClick</code>事件处理程序，当点击它时——把每个人叫到桌子旁吃她的食物。</p><p id="4d9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后在这个父元素<code class="fe nh ni nj nk b">div</code>中有几个子元素<code class="fe nh ni nj nk b">button</code>——当被点击时创建一个虚拟的食物项目(即。【T2氏】。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0120" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是当你点击每一个时发生的事情:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://media.giphy.com/media/eEVi5aB0WIv7rCTlhV/giphy.gif" rel="noopener ugc nofollow" target="_blank">Mariya Diminsky</a></figcaption></figure><p id="858d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你所看到的，这种情况发生在每个孩子身上:</p><ol class=""><li id="8b83" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo np lv lw lx bi translated">首先，按钮的事件处理程序被触发。</li><li id="aa91" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo np lv lw lx bi translated"><strong class="kv io">其次，父div的事件处理程序被触发</strong>。</li></ol><p id="99c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在大多数情况下，您可能只想在单击按钮时调用按钮的事件处理程序。然而，正如您所看到的，父事件也被触发了！？</p><p id="8268" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这叫做<strong class="kv io"> ✨Event Bubbling✨ </strong>。</p><p id="bb4d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在接下来的几节中，我将讨论到底发生了什么以及我们如何解决它！</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="2602" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">JavaScript中事件冒泡是如何发生的</strong></h1><h2 id="f0d3" class="nq ml in bd mm nr ns dn mq nt nu dp mu lc nv nw mw lg nx ny my lk nz oa na ob bi translated">ℹ️为什么会存在？</h2><p id="c61f" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">JavaScript创建<strong class="kv io">事件传播</strong>模式的目的之一是让从一个源(父元素)捕获事件变得更容易，而不是在每个内部子元素上设置一个事件处理程序。</p><h2 id="9350" class="nq ml in bd mm nr ns dn mq nt nu dp mu lc nv nw mw lg nx ny my lk nz oa na ob bi translated">ℹ️事件传播触发顺序</h2><p id="3dab" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">事件传播经历了<strong class="kv io">三个阶段</strong>:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2467bbc910054c10ad492496e9ff28e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*k9jAK0q6AHmY2GZB.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image from <a class="ae ks" href="https://ehsankorhani.com/" rel="noopener ugc nofollow" target="_blank">https://ehsankorhani.com/</a></figcaption></figure><ol class=""><li id="5365" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo np lv lw lx bi translated"><strong class="kv io"> 🟢捕获阶段</strong> —当事件被实际触发时，这是<strong class="kv io">第一阶段</strong>。这个事件首先通过最顶层的事件“捕获”或传播，即。<code class="fe nh ni nj nk b">window</code>对象，然后是<code class="fe nh ni nj nk b">document</code>，在<code class="fe nh ni nj nk b">html</code>元素之后，然后是最里面的元素。<strong class="kv io">一直往下，直到到达</strong> <code class="fe nh ni nj nk b">event.target</code> <strong class="kv io">(你点击的/事件触发的)。</strong></li><li id="0346" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo np lv lw lx bi translated"><strong class="kv io"> 🟢目标阶段</strong>—<strong class="kv io">第二阶段</strong>是我们到达<code class="fe nh ni nj nk b">event.target</code>的时候。例如，当用户点击一个按钮时，<strong class="kv io">这是实际的按钮元素。</strong></li><li id="ed19" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo np lv lw lx bi translated"><strong class="kv io"> 🟢鼓泡阶段</strong>—<strong class="kv io">第三阶段</strong>。这个事件从<code class="fe nh ni nj nk b">event.target</code>开始，<strong class="kv io">向上传播，直到它再次到达顶层父节点</strong>(尽管顶层父节点的事件不再被调用)。</li></ol><p id="c8c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="od">请注意:虽然有3个主要阶段，但目标阶段实际上没有单独处理。捕获和冒泡阶段的事件处理程序都在这里触发。</em></p><p id="222e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="od">从技术上讲，还有另一个阶段叫做“无阶段”,即没有事件发生的阶段。您可以通过</em> <code class="fe nh ni nj nk b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase" rel="noopener ugc nofollow" target="_blank"><em class="od">event.eventPhase</em></a></code> <em class="od">访问元素处于哪个阶段。</em></p><p id="e4dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">考虑你刚刚学到的内容，看看下面的例子。</strong></p><p id="3c9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设用户点击了<code class="fe nh ni nj nk b">table</code>中的<code class="fe nh ni nj nk b">td</code>元素。<strong class="kv io">这里事件传播是如何发生的？🤔花点时间想一想。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a85c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这是实际发生的事情，按照刚才提到的顺序:</strong></p><p id="a7d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="od">请注意:</em> <code class="fe nh ni nj nk b"><em class="od">DefaultView</em></code> <em class="od">这里的</em> <code class="fe nh ni nj nk b"><em class="od">Window</em></code> <em class="od">会是对象。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/0c45f1744d2ec21c21baff490ad3df27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gP4N9Wb_6sGTfcFW2RVQew.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image by <a class="ae ks" href="https://www.w3.org/" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/</a></figcaption></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="b4b2" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">React中事件冒泡是如何发生的</h1><p id="7953" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">另一方面React创造了一个叫做<a class="ae ks" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">的东西</strong> </a>。</p><p id="0e70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些只是浏览器事件对象的包装器。基本的用例是相似的，包括像<code class="fe nh ni nj nk b">stopPropagation</code>和<code class="fe nh ni nj nk b">preventDefault</code>这样的方法(我将在后面讨论)——最大的好处是它们在不同的浏览器上工作是一样的。</p><p id="c2e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React不将事件处理程序附加到节点，而是附加到文档的根。当事件被触发时，React首先调用适当的元素(即。目标阶段(您单击的元素)，然后它开始冒泡)。</p><p id="3093" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为什么React会这样做，而不是像原生DOM那样简单地处理事件？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://giphy.com/gifs/hayley-mills-the-trouble-with-angels-AqlX1TY49hTS8/links" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><h2 id="eec2" class="nq ml in bd mm nr ns dn mq nt nu dp mu lc nv nw mw lg nx ny my lk nz oa na ob bi translated"><strong class="ak"> ℹ️ </strong>浏览器一致性</h2><p id="582a" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">重要的是，事件在所有浏览器中的工作是相同的。React创建的合成事件，以确保属性在不同的浏览器和平台之间保持一致。</p><p id="e6c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">当一个事件在一个浏览器中运行，但另一个浏览器中的用户使用你的应用程序时，你不会想创建一个应用程序，它将不再运行</strong> —这是一个糟糕的用户体验<strong class="kv io">。</strong></p><h2 id="e2af" class="nq ml in bd mm nr ns dn mq nt nu dp mu lc nv nw mw lg nx ny my lk nz oa na ob bi translated"><strong class="ak"> ℹ️从你实际想要从</strong>触发的元素触发</h2><p id="0953" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">设置事件处理程序的地方就是打算调用它的地方——在那个特定的元素上，而不是在其他地方(当然，为了首先理解基本概念，我在这里暂时忽略一些边缘情况)。</p><p id="e701" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">那个事件最了解它所设置的元素，所以它应该是第一个触发的。之后，随着事件传播越来越高，上面的每个元素知道的越来越少。</strong></p><p id="0dcc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以我们之前的<code class="fe nh ni nj nk b">Molly</code>组件为例。我知道你很想她，所以她又来了:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://media.giphy.com/media/eEVi5aB0WIv7rCTlhV/giphy.gif" rel="noopener ugc nofollow" target="_blank">Mariya Diminsky</a></figcaption></figure><p id="8ca8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">🤔你有没有注意到当一个按钮被点击时，按钮上的事件处理程序首先被调用，然后父事件处理程序才被调用？</p><p id="034e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它从来没有发生在相反的(即。捕获阶段永远不会被触发)。</p><p id="a52c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这是因为React的合成事件只使用冒泡阶段(此处包含目标阶段)。</strong>如果目的是关注首先触发事件的<code class="fe nh ni nj nk b">event.target</code>(本例中的按钮)，这是有意义的。</p><p id="1f21" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请记住，React只是用这些<strong class="kv io">合成事件</strong>模拟 JavaScript的本机冒泡和捕获阶段，这就是为什么随着时间的推移，您可能会注意到一些差异(在本主题的第2部分中会进一步解释)。</p><p id="17d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> ⚠️合成事件</strong>本身并不关注捕捉阶段，除非您专门将其设置为。要触发捕获阶段，只需将父<code class="fe nh ni nj nk b">div</code>的事件处理程序<code class="fe nh ni nj nk b">onClick</code>设置为<code class="fe nh ni nj nk b">onClickCapture</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c408" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意，下面触发的不是冒泡阶段，而是捕获阶段:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://giphy.com/gifs/BETT2abn9nJdSjenq4" rel="noopener ugc nofollow" target="_blank">Mariya Diminsky</a></figcaption></figure><p id="4169" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> ⚠️ </strong></p><p id="ac25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，在React版本17+中，事件处理程序只能到达<code class="fe nh ni nj nk b">root</code>元素。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/13253716fbf4f2ae750538384096e3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xRfy8jiTxvbVTDdjhCytQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image by <a class="ae ks" href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html" rel="noopener ugc nofollow" target="_blank">React</a></figcaption></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="ab13" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">如何停止组件中的事件冒泡</strong></h1><p id="11d6" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">现在你已经理解了<strong class="kv io">事件传播</strong>、<strong class="kv io">事件冒泡</strong>和<strong class="kv io">事件捕获</strong>的核心概念，让我们讨论一下如何修复我们最初的问题。</p><p id="a630" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您有一个按钮(或其他元素),并且您只想触发按钮的事件处理程序——不应该触发其他父级！</p><p id="fd10" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">🤔那么，我们如何才能阻止这种情况发生呢？您有几个选择:</p><h2 id="c105" class="nq ml in bd mm nr ns dn mq nt nu dp mu lc nv nw mw lg nx ny my lk nz oa na ob bi translated"><em class="oh"> ℹ️事件</em>。停止传播()</h2><p id="c280" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">这将阻止任何父组件的事件触发。要使用它:</p><ol class=""><li id="a27e" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo np lv lw lx bi translated">确保将<code class="fe nh ni nj nk b">event</code>对象作为参数传递。</li><li id="fb1d" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo np lv lw lx bi translated">在事件处理函数中，对代码上方的事件对象使用<code class="fe nh ni nj nk b">stopPropagation</code>方法。</li></ol><p id="5a10" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意:请注意，我将父代的<code class="fe nh ni nj nk b">div</code>从<code class="fe nh ni nj nk b">onClickCapture</code>改回了<code class="fe nh ni nj nk b">onClick</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6f01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面我只给<code class="fe nh ni nj nk b">handleCookEggs</code>函数添加了<code class="fe nh ni nj nk b">stopPropagation</code>。所以当点击<code class="fe nh ni nj nk b">Cook Eggs</code>按钮时，注意它只为那个元素触发那个事件！</p><h2 id="22e6" class="nq ml in bd mm nr ns dn mq nt nu dp mu lc nv nw mw lg nx ny my lk nz oa na ob bi translated">ℹ️事件. stop immediate传播()</h2><p id="570b" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">假设在同一个元素上有多个事件。如果你使用<code class="fe nh ni nj nk b">event.stopPropagation()</code>，肯定会阻止任何父事件触发，但是如果你在同一个元素上有多个事件，它们仍然会被触发。</p><p id="690e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了防止同一元素上的其他事件触发，请使用<code class="fe nh ni nj nk b">event.stopImmediatePropagation()</code>来代替。它将阻止父事件和相同元素事件触发。</p><p id="8b81" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你处于<code class="fe nh ni nj nk b">event.stopPropagation()</code>对你不起作用的情况，试试<code class="fe nh ni nj nk b">event.stopImmediatePropagation()</code>吧。</p><p id="c678" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="od">注意:有时你的应用程序中可能会有第三方库，导致前者无法工作。当然，看看是什么导致后者工作而不是前者，这仍然是一个好主意，可能会给你另一个解决问题的线索。</em></p><h2 id="fbbf" class="nq ml in bd mm nr ns dn mq nt nu dp mu lc nv nw mw lg nx ny my lk nz oa na ob bi translated">ℹ️事件.预防默认()</h2><p id="d8ab" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">根据事件处理程序和元素，您可能希望使用此。</p><p id="067d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如:</p><ul class=""><li id="8238" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">如果您有一个表单，并且不想在提交时刷新页面。</li><li id="70e6" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">您正在设置自己的路线功能，并且不想刷新页面。</li></ul></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="ebd6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你已经完成了<strong class="kv io">的第1部分，像<strong class="kv io">大师轻松应对</strong>系列中的专家</strong>一样理解事件冒泡！耶！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oi nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif from <a class="ae ks" href="https://media.giphy.com/media/SVs0cQ0nLRsLNUadmn/giphy.gif" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="cd87" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在你知道了:</p><ul class=""><li id="bacf" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io">事件委托意味着什么，事件冒泡和事件捕获是如何工作的。</strong></li><li id="3cf1" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">事件传播在JavaScript和React中的不同工作方式。</strong></li><li id="adba" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">你对React中事件处理的好处和注意事项有了更好的理解。</li><li id="c422" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">有几种方法可以用来解决你特殊情况下可能出现的问题。</li></ul><p id="dba1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">的第2部分像专家一样理解事件冒泡</strong>深入探讨了事件传播的更多注意事项，包括一个重要的边缘案例。第1部分应该足以开始在您的应用程序中实现它，但如果您想了解更多细节，请务必查看第2部分！</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="063a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> ✨🥰如果你喜欢这篇文章，并且想了解更多关于各种React主题的信息，请关注以下内容以获取最新更新🎉</strong></p><p id="b4b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="od">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="od">plain English . io</em></strong></a></p></div></div>    
</body>
</html>