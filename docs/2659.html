<html>
<head>
<title>A Case for Compile to JavaScript Interface Frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个编译成JavaScript接口框架的例子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-case-for-compile-to-javascript-interface-frameworks-a684b361884f?source=collection_archive---------6-----------------------#2021-06-01">https://javascript.plainenglish.io/a-case-for-compile-to-javascript-interface-frameworks-a684b361884f?source=collection_archive---------6-----------------------#2021-06-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1a55" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">为什么将声明性UI编译成JavaScript既有用又快速</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/292536bdccae8c36092b14f3387a7099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LUP7NJrirKlw-voh"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a9eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天，像React和Vue这样的web框架在创建现代web应用程序时非常流行，这是有充分理由的。它们有助于将代码片段变成可重用的组件，并使使用声明性标记基于数据进行更新变得容易。</p><p id="d3db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，几乎所有这些都有性能成本，因为它们需要大型运行时库。此外，这种接口语言功能更弱，也更冗长，因为它受限于原生JavaScript的约束。</p><p id="103a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，这个问题的解决方案可以让您在使用较少冗长代码的同时获得更好的性能。</p><p id="a4bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些框架将针对声明式用户界面设计优化的语言编译成本地JavaScript。因为它们是编译的，不需要庞大的运行时库，所以要小得多。</p><p id="3ebe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有两种主要类型的编译JavaScript用户界面框架。有些使用JavaScript实现实际逻辑，如<a class="ae ks" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">苗条的</a>和<a class="ae ks" href="https://github.com/solidjs/solid" rel="noopener ugc nofollow" target="_blank">坚实的</a> *，还有一些使用完全不同的语言，通常不仅仅做声明性标记，如<a class="ae ks" href="https://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>和<a class="ae ks" href="https://www.mint-lang.com/" rel="noopener ugc nofollow" target="_blank"> Mint </a>。在本文中，我们将主要关注像Svelte这样的框架。现在让我们看看为什么要使用这些框架。</p><p id="d9a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">*Solid可以被认为是一个运行时框架，但是因为它大量使用编译来优化代码，所以对于本文，我认为它是一个编译成JS的框架。</p><h2 id="55b2" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">编译的JavaScript很快</h2><p id="595e" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">许多被编译的框架，尤其是较新的框架，比运行时框架要快得多，也轻得多。</p><p id="3c67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为他们可以在代码运行之前进行大量的优化，并且他们可以将代码转换成普通的DOM操作JavaScript，从而避免了对大型包的需求。</p><p id="a1f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，比较Svelte和Solid这两个大量使用编译的框架，以及React*和Vue这两个设计用于运行时的框架。</p><p id="954a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">* React确实使用了编译过的JSX，但那只是对<code class="fe mn mo mp mq b">createElement</code>调用的基本语法修饰。</p><p id="8613" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React的和Vue的捆绑包大小，根据BundlePhobia，分别是39.4kb GZip和22.9kb GZip。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/966ed884057d949d69feafed2c54aa98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWAVUnOXKsrwrRzTSb6kzw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React’s bundle size</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/7f83dbb99d943de258eadd8dd23b029b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTVWVuDuNORYhxf1g5bF_w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Vue’s bundle size</figcaption></figure><p id="b4f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">相比之下，Svelte实际上没有基本的包大小，因为除了原生DOM操作之外，它使用的东西很少，而Solid只有一些小函数来帮助更新元素。</p><p id="5929" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为大部分的包权重是编译器，不包含在生成的web app中，所以不能从Bundlephobia量化权重，但是下面的startup times benchmark对权重有一个合理的估计。</p><p id="3a03" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，Solid和Svelte在运行时都要快得多。根据<a class="ae ks" href="https://krausest.github.io/js-framework-benchmark/2021/table_chrome_90.0.4430.72.html" rel="noopener ugc nofollow" target="_blank">krausset Framework benchmark</a>，Solid和Svelte在启动时间、DOM操作速度和内存使用方面都更快。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/f979a01964e65c596a3b4fcc2013c249.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*cyKBaU7O35rKAPZJ4jsO2A.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Framework speed benchmark</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/b3aa1d25b1e99495cde069665d4fb1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*m5e36L44ph12wCOhCq576Q.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Framework startup benchmark</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/77bc1eb86efc4979051e7b678b200143.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*EuwkvRIURVuvKk7XqphdYQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Framework memory benchmark</figcaption></figure><p id="cf18" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，在大型DOM操作、启动(受脚本大小和解释时间的影响)和内存使用方面，Solid和Svelte比React和Vue更优化。</p><p id="d178" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，您必须记住，大多数时候，这没什么大不了的。但是，如果您需要更高的性能，那么利用编译UI代码来优化性能的框架可能是一个不错的选择。</p><p id="5063" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，如果您正在为速度慢的2G或3G网络上的人开发，使用Svelte带来的体重减轻可能是一件非常有益的事情。</p><p id="c5a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，请记住，虽然优化的编译框架可能比非优化的框架更快，但是普通的JavaScript几乎总是更快。但是普通的JavaScript可能更冗长乏味，这就引出了我们的第二点。</p><h2 id="0edd" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">编译后的框架经过优化，可以编写更少的代码</h2><p id="6b69" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">JavaScript最初并不是为了像React这样的声明性标记而设计的，正因为如此，React中的许多特性迫使您使用像<code class="fe mn mo mp mq b">useState()</code>这样的函数和方法来代替使用普通变量，这不是坏事，但也不尽如人意。</p><p id="50af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，由于大多数功能都需要在运行时提供，因此功能少得多。编译对此有所帮助。Svelte内置了对反应变量的支持，您可以使用普通的<code class="fe mn mo mp mq b">let variable = value</code>语法来声明它们。</p><p id="76df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，你只用<code class="fe mn mo mp mq b">$:</code>来做被动的陈述。这可能看起来令人困惑，所以这里有一些例子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A click counter example in React</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The equivalent click counter in Svelte</figcaption></figure><p id="4de1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如您在上面看到的，语法风格非常不同。Svelte更具本土感，代码比reactor少1/3。</p><p id="1014" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，最终，您可以选择使用什么语法，但是编译器只是增加了语法的灵活性。您可能会认为编译和设置编译器所花的时间比语法优势更重要，这将引导我们进入最后一点。</p><h2 id="bc06" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">您可能已经在编译您的JavaScript了</h2><p id="3c6e" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">虽然您可能不会使用本机JavaScript以外的任何东西，但您可能仍然在编译它，即使它只是将ES6转换为旧浏览器支持的代码，或者只是为了缩小代码。<a class="ae ks" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank">创建反应应用程序</a>在引擎盖下使用Webpack对您的代码执行许多不同的操作。事实上，由React团队推荐的React JSX需要编译为创建实际元素的函数调用。</p><p id="747f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不幸的是，React没有充分利用这一点并对其进行优化，尽管他们最近通过新的JSX变换在这方面取得了一些进展。此外，<a class="ae ks" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue Cli </a>也在引擎盖下使用Webpack。这意味着，虽然您不需要使用编译器，但无论如何您很可能会使用，而且它很容易设置。</p><h2 id="990a" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">结论</h2><p id="0ba0" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">使用编译成JavaScript的框架并不总是答案。一些不编译成JavaScript的框架比使用编译器的要快，使用编译器并不自动意味着它是更好的框架。</p><p id="4087" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，有一个很大的范围是多少编制。有些框架，比如Alpine.js，完全是为不需要任何构建步骤而设计的。</p><p id="50d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其他的，比如React，只对代码的一小部分可选部分进行编译。Solid也有点像React，因为它使用JSX，只是在编译时会进一步优化。</p><p id="f4c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编译的最后一层是编译所有东西的东西，比如Svelte。想编多少是你自己的选择，各有利弊。</p><p id="9f0b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望你从中有所收获，感谢你的阅读。</p><p id="4fa4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mx">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>