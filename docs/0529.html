<html>
<head>
<title>React Tesseract OCR Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React宇宙魔方OCR教程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tesseract-ocr-tutorial-d72bb04b5094?source=collection_archive---------6-----------------------#2021-02-01">https://javascript.plainenglish.io/react-tesseract-ocr-tutorial-d72bb04b5094?source=collection_archive---------6-----------------------#2021-02-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b647" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">鉴于web技术的当前状态和web应用程序的整体能力，许多以前具有挑战性和计算密集型的任务现在可以比以往任何时候都更容易地在浏览器上运行。OCR(光学字符识别)是我们可以考虑的任务之一。当涉及到计算能力时，这是非常苛刻的，需要花费大量的时间才能得到好的结果，并且现有的解决方案大多提供超过1个人的终身工作。幸运的是，提到的解决方案的一些非常强大的例子现在非常容易获得，并且非常容易使用。</p><p id="54bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们为什么要在浏览器上使用OCR呢？这种需求的产生可能有很多原因，例如，当您想要使用浏览器从扫描的文档中提取文本时，OCR是一个完美的选择，这非常有益；或者当我们想要自动检测隐藏在文本中的不需要的行为时，OCR又是一个goto选择，或者可能是因为更简单的原因，我们在看到IBAN号码的截图时感到沮丧，这可能是出于多种原因发送的，以帮助我们自己。在这种情况下，OCR可以是一个非常实用的助手。正如你所看到的，用例可能会有所不同，可以一次添加一页又一页的想法。</p><p id="3148" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在今天的教程中，我将带您浏览一个React应用程序，您可以上传各种格式的图像，并可以应用OCR轻松提取文本内容。所以，如果你准备好了，让我们马上进入应用程序。</p><p id="f808" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们期望的结果将如下，该应用程序应该有功能，使图像上传和OCR启动可用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4b19874890da9a8dd3afe10920c6a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XiSBhUC70hroRzg_.png"/></div></div></figure><p id="ca31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该项目有两个选项，您可以继续创建自己的“create-react-app”项目，或者您可以直接从<a class="ae ku" href="https://github.com/eren23/react-tesseract-ocr-starter" rel="noopener ugc nofollow" target="_blank">这里</a>下载项目的最终版本，然后使用它一步一步地跟随教程。还提供了如何使用“创建-反应-应用程序”的指南。</p><p id="e440" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你选择第二个选项，你可以删除不必要的文件，最终得到一个这样的文件夹结构，它仍然可以被简化，但它似乎没有默认版本那么麻烦。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/b2e35f7cd46a74134cbbb16162b31672.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/0*W4O607U3Xb821qRb.png"/></div></figure><p id="0103" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你下载了我提供的版本，你需要做的就是在根文件夹中打开你的终端，运行下面的命令“yarn &amp;&amp; yarn start”。“yarn”命令它会自动下载依赖项，并为您创建一个node_modules文件夹，因为您的应用程序现在已准备就绪，您可以简单地使用下面的“yarn start”命令来启动项目。</p><p id="c828" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，如果你正在使用“创建-反应-应用程序”,你将需要做一些我们将在教程中使用的部分。我们将使用3个第三方库用于不同的目的。第一个是“tesseract.js”，它让我们只需几行代码就能轻松运行OCR。第二个是“反应-图片-上传”，它将允许我们上传图片到浏览器，并轻松访问它们的位置。第三个是“react-spinners”，它允许我们用很少的代码创建看起来很酷的spinners，这显然不是实现教程目的所必需的，但是在加载东西时使用这样的技术通常被认为是一个好的实践。因此，如果你使用“创建-反应-应用程序”，你可以简单地通过运行命令“纱线添加反应-图像-上传反应-spinners tesseract.js”获得这3个，下载完成后，你应该可以开始了。</p><p id="88f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们要做的第一件事是清理我们的App.js文件，并将我们的代码分离到其他地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/e76a6179c87d7e7ca9d160fa752c6ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q9h1Nvqyn574tBIM.png"/></div></div></figure><p id="d573" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了App.js集，我们可以看看我们在这里带来了什么。我们正在添加一个带有h1标签的分隔线和另一个分隔线。因此，由于默认样式不包含这样的CSS类，我们也在这里改变了我们的CSS。让我们一步一步来看看它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/d16fab7860dbb3ccf32c2dae0313bad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wdV9ct-01rA2Aujx.png"/></div></div></figure><p id="05e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们添加了两个CSS类来创建一个平衡的外观。在第一个类中，我们创建了一个flex布局，我们将它的方向设置为一列，我们将项目居中，然后我们在顶部添加了一点边距，我们使用第二个类将我们的标题转换为一个block元素，这样它就不会与div的相同元素并排。</p><p id="31ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了不从App.js文件中获得任何错误，我们应该创建我们的ImageLoader组件，现在继续创建一个scripts文件夹，并在scripts文件夹中创建一个名为imageLoader的文件夹，其中包含imageLoader.js和imageLoader.css文件。</p><p id="a950" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一步之后，将代码片段放入imageLoader.js文件中，组件就准备好了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/fd02e628f8a6c17c26051bb15092864f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6WShuqPUw3XZ53lj.png"/></div></div></figure><p id="7359" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于只有两个文件需要进一步编码，分别是imageLoadar.js和imageLoader.css，我将在这里复制并粘贴代码片段的图片，然后一步一步地向您解释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/f762c525c5dfa444c4e061dc963b2441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QXx11TsibleDsdhN.png"/></div></div></figure><p id="4e91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们导入前面提到的所需库，我们还需要导入useState，因为我们将使用State钩子和CSS文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/7abe8a3d42992d8889794c761c678b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4Iu9XaAGraf1xOAZ.png"/></div></div></figure><p id="1813" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们做了一些新的事情，你可能想仔细遵循它们。我们应该把代码片段放在返回上面，我们在这里创建3个状态来实现不同的目标。这里的第一个状态是从我们的ImageUploader组件获取图像URL，并保存它以供进一步处理，第二个状态是我们保存OCR应用文本的状态，第三个状态是用于加载逻辑的状态。</p><p id="5f93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当我们的ImageUploader组件发生变化时，就会调用onDrop函数，您很快就会在下面看到该组件。所以每当发生变化，比如在我们的组件中添加或删除照片，这个功能就会被激活。onChange事件触发后，它会将我们需要的参数放在第二个位置，所以我们可以通过放“_”来绕过第一个参数，并获取第二个参数。它有链接/链接我们的图像在它，它会带来完整的最新的链接列表，所以每当我们从我们的函数得到一个列表，我们可以安全地把它放在我们的数组。</p><p id="9c3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">runOcr功能看起来很棘手，但实际上，它非常简单，我们获取URL状态，并为每个元素运行下面的识别脚本。函数至少接受2个参数，第一个是URL，第二个是目标语言，支持100多种语言。在请求解决后，我们获取输出文本并将其添加到当前数组中。在我们启动runOcr命令后，我们可以将Loading设置为true，以便显示微调器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kx"><img src="../Images/ebd5af56684edc3d7b65c4df1652601d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jRj5uV_BCBxgpHTd.png"/></div></div></figure><p id="e741" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以把我们的JSX还给这里了。因为我们想保持一切都在控制之下，并得到一个体面的外观，我们应用一些CSS到我们的父母div像这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/951f716e24c10ce2572b8c17e416bad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TTSA4a-1TE-V-XKd.png"/></div></div></figure><p id="9ccd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以开始将子元素添加到div中。在我们的ImageUploader组件上，我们有许多选项，比如设置最大图像大小或限制文件类型。也可以选择显示或不显示预览。</p><p id="1f6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们调用我们的ImageUploader之后，我们可以创建另一个按钮来启动OCR过程，因为我想创建一个普通的div元素并对其进行样式化，而不是直接使用按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/c75430e9a3a81139fc2d5ae912a29c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g9UG-h4aMfVI7go-.png"/></div></div></figure><p id="3a42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们用一个特殊的伪类设置了一些样式，以使它在悬停时有不同的行为。我们从ImageUploader中复制了相同的颜色和设计方法，以与设计保持一致。</p><p id="2abd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的按钮之后，我们有了我们的主要逻辑，它也非常直接。我们首先检查我们的ocrText状态中是否有任何项目，如果有，我们可以简单地创建一个无序列表，每当一个新的项目被添加到ocrText状态时就显示出来。我们使用项目的索引为每个项目提供一个键，并枚举每个输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/a8552fb13866f88ea7c7b2fb5a5313c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EFn3sTwMYcQ1KA6D.png"/></div></div></figure><p id="34af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那个部分的造型不包含任何东西，只包含一些边缘的着色和雕刻。</p><p id="f656" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你看，当我们的ocrText状态没有任何东西时，我们会自动检查微调器，因为微调器也依赖于runOcr函数的触发，它不会在停留时显示任何副作用。</p><p id="f796" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，各位，今天就到这里，希望你们喜欢。将来我会做更多像那样的教育内容。在此之前，请注意安全，保重身体。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="8b63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lf">原为发表于</em><a class="ae ku" href="https://blog.akbuluteren.com/blog/react-tesseract-ocr-tutorial" rel="noopener ugc nofollow" target="_blank"><em class="lf"/></a><em class="lf">。</em></p></div></div>    
</body>
</html>