<html>
<head>
<title>Exploring the JavaScript ‘this’ Keyword in Different Execution Contexts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索不同执行上下文中的JavaScript“this”关键字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/exploring-this-in-different-contexts-af10e2248ddd?source=collection_archive---------12-----------------------#2021-04-25">https://javascript.plainenglish.io/exploring-this-in-different-contexts-af10e2248ddd?source=collection_archive---------12-----------------------#2021-04-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/76fa2c8b4f90e36e90eaa3d53d55777d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fjrkPgih9xbMQN-e"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Prateek Katyal</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0ae6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript中的“this”关键字指的是执行当前函数的对象。“this”关键字在不同的上下文中有不同的作用，可能很难理解，尤其是对新人来说，这可能会令人望而生畏。在这篇文章中，我解释了“这个”在不同上下文中的行为。</p><h2 id="bf55" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">全球背景</strong></h2><p id="ba8d" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在全局上下文中，即在任何函数或对象之外，“this”关键字指的是窗口对象。</p><p id="5eae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="08d8" class="ky kz in mb b gy mf mg l mh mi">this.num1 = 3<br/>console.log(window.num1) // 3<br/>console.log(this) //window object</span></pre><p id="c0d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/ad2f0e8f081124403cd0cf8b2fdead2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XeGmBDN0_-gF1zW4LtBykQ.png"/></div></div></figure><p id="9519" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“this”的工作方式也随着它执行的模式(严格模式或默认模式)而变化。在全局上下文中，在任一模式下，this的用法总是指窗口对象。</p><h2 id="66f3" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">常规功能</strong></h2><p id="0a68" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在函数内部,“this”关键字仍然引用全局对象。尽管在严格模式下，“this”只会返回“undefined”。</p><p id="1cbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="93b3" class="ky kz in mb b gy mf mg l mh mi">function foo(){<br/>    return this;<br/>}<br/>console.log(foo()); //window object</span></pre><p id="8a21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在函数内部和外部声明一个同名的变量，并尝试在函数内部引用带有' this '的变量。输出会是什么？它会指向局部变量还是全局变量？</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="60a0" class="ky kz in mb b gy mf mg l mh mi">var n1 =1;<br/>function foo(){<br/>    var n1 = 6;<br/>    console.log(n1);   // 6<br/>    console.log(this.n1);   //1<br/>}<br/>foo();</span></pre><p id="76e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/2fac24b84973b297c47ce6830f1162b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMn1E-utjvIHtBdE44dzeg.png"/></div></div></figure><p id="0f9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们在上面的输出中看到的，用这个调用函数内部的变量会引用全局变量，而没有这个，它会引用局部变量。</p><p id="6c31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在严格模式下的函数中使用“this ”:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fb1b" class="ky kz in mb b gy mf mg l mh mi">function f2() {<br/>   ‘use strict’; // strict mode<br/>    console.log(this);<br/> }<br/>f2();</span></pre><p id="6ffd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/a1f48c9ed361731527acf5225685edcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gNAEh6OLlRjVlMewc8H2oQ.png"/></div></div></figure><h2 id="ab39" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">对象方法</strong></h2><p id="e5ec" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">当一个函数被定义为一个对象的属性时，它就被称为方法。方法中的“this”与函数中的“this”不同。理解这里的工作原理是很重要的，因为两者返回不同的值。这里的“this”指的是该方法所属的对象。</p><p id="07c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="bef5" class="ky kz in mb b gy mf mg l mh mi">OBJ1:{<br/>   num1 : 3,<br/>   num2 : 1,<br/>   sum: function(){<br/>   console.log(this);<br/>   console.log(`Sum : ${this.num1 + this.num2}`);<br/>   }<br/>}<br/>OBJ1.sum()</span></pre><p id="da27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/f29b8ec8e88c059c4fb4664f7875f1c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NpVLAGbZrz03N6sLtVIPA.png"/></div></div></figure><p id="fa0b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，“this”被设置为对象“obj1 ”,并且可以访问它的所有属性，正如我们从<strong class="kc io"> console.log(this)的输出中看到的。</strong></p><h2 id="984c" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">构造函数</strong></h2><p id="dd2d" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">构造函数是通过在函数名前面加上“new”关键字来定义的。</p><p id="1639" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">语法:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7a81" class="ky kz in mb b gy mf mg l mh mi">let dog1 = new Dogs(‘Bubbles’, ‘mutt’); //By convention constructors should start with capital letter.</span></pre><p id="7435" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里dog1是新创建的构造函数Dogs的对象。构造函数用于初始化对象。构造函数中的“this”关键字类似于它在方法中的工作方式。它引用构造函数的对象。</p><p id="3259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8600" class="ky kz in mb b gy mf mg l mh mi">function Dogs(name, breed){<br/>    this.name = name;<br/>    this.breed = breed;<br/>    this.display = function(){<br/>      console.log(`I have a dog named ${name} who is a ${breed} `);<br/>    }<br/>}<br/>let dog1 = new Dogs("Bubbles", "mutt");<br/>let dog2 = new Dogs("Marley", "Labrador");<br/>dog1.display();<br/>dog2.display();</span></pre><p id="a2ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，“this”指向调用它的相应对象，即dog1或dog2。</p><p id="3866" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在执行过程中，“this”被转换为dog1，因此它本质上与dog 1 . name = name；相同。dog1.breed =品种；</p><p id="9958" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/03e8a8763e159a02cdbd0c7224db08ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rjn2yjiw9RMAXNnTcpPFQ.png"/></div></div></figure><h2 id="d80f" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">箭头功能</strong></h2><p id="84c2" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">箭头函数实际上没有自己的上下文。如果在arrow函数中使用“this ”,它将引用其外部函数。</p><p id="d0b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ea98" class="ky kz in mb b gy mf mg l mh mi">var window = this;<br/>var get = (() =&gt;this)<br/>console.log(get() === window); //True</span></pre><p id="cd3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，“this”指的是窗口对象。因此我们不应该使用箭头函数作为方法，因为它们会引用窗口对象。</p><p id="6b4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f536" class="ky kz in mb b gy mf mg l mh mi">let OBJ1 = {<br/>   firstName : “John”,<br/>   age : 23,<br/>   introduce: () =&gt; console.log(`I am ${this.firstName}.I am      ${this.age} years old `)<br/>}<br/>OBJ1.introduce();</span></pre><p id="c777" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/621672530f511f8c48c7b6cd906379bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvKVbKuy6wRuhUojVtToRQ.png"/></div></div></figure><p id="a1f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您从上面的输出中所看到的，arrow函数“import”指向全局对象，因此返回undefined。</p><p id="aaeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，箭头函数确实有一个特殊的功能。让我们看看下面的例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d4c2" class="ky kz in mb b gy mf mg l mh mi">let user = {<br/>   firstName: “John”,<br/>   sayHi: function() {<br/>      function display(){<br/>          console.log(this.firstName);<br/>      }<br/>      return display();<br/>   }<br/>};<br/>user.sayHi();</span></pre><p id="cfc9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/5b8a7b94526db194e45ad704c7f82310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vY72RlKB2PPfs9mwcdc8vQ.png"/></div></div></figure><p id="c54a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所看到的，函数显示在对象内部，并且“这”仍然指向全局对象。这是因为display()是使用一个简单的函数调用来调用的，正如我们之前看到的，函数中定义的“这个”将总是引用全局对象。</p><p id="0463" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是箭头功能出现的地方。当我们实际上不想有一个单独的“这个”，而是从外部上下文中获取名字的值时，这是很有用的。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="13bb" class="ky kz in mb b gy mf mg l mh mi">let user = {<br/>   firstName: “John”,<br/>   sayHi() {<br/>      let display= () =&gt; console.log(this.firstName);<br/>      display();<br/>   }<br/>};<br/>user.sayHi();</span></pre><p id="1b20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/e636cc04eeee89703aafafadaace6bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXzp-Qh830GMuW4ZxLxdzg.png"/></div></div></figure><p id="2fd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们得到了输出John，因为箭头函数中的“这个”指向它的外部函数。</p><h2 id="6bc8" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">类</strong></h2><p id="22e2" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">类中的“this”关键字的工作方式类似于它在函数中的工作方式，因为在JavaScript中，类是通过函数实现的。除了这里的“this”指的是一个对象，类的所有方法都被添加到它的原型中。</p><p id="c7e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7e8f" class="ky kz in mb b gy mf mg l mh mi">class Example {<br/>    constructor() {<br/>       console.log(this);<br/>    }<br/>    first(){}<br/>    second(){}<br/>    static third(){}<br/>}<br/>new Example();</span></pre><p id="741b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/f8414526d00137c4b4d64d6c8ed1a43d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZrqLGyStgCgf5ELk5zdbCg.png"/></div></div></figure><p id="6cb1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ms">注:</em> </strong> <em class="ms">这里，静态方法不是对象的一部分，它们是类的属性。只有非静态方法被添加到对象的原型中。</em></p><p id="b42e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有关如何使用“this”的更多信息，请点击此处的<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"/>链接。</p><p id="4ed8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ms">多内容于</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">中</em></a></p></div></div>    
</body>
</html>