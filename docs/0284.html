<html>
<head>
<title>Advanced React Optimization Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级反应优化技术</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-react-optimization-techniques-66614412efdc?source=collection_archive---------0-----------------------#2021-01-17">https://javascript.plainenglish.io/advanced-react-optimization-techniques-66614412efdc?source=collection_archive---------0-----------------------#2021-01-17</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="678d" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">以及如何避免常见的陷阱</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/032514fe6799bf37418572028161647d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGc_6Vs0gAEs4BKQUtmKlQ.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@thefredyjacob?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Fredy Jacob</a> on <a class="ae kw" href="https://unsplash.com/s/photos/memory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="63c0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">反应非常快。我是说非常非常快。这就是React的伟大之处。</p><p id="b390" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是如果你想进一步优化你的应用程序，有一些方法可以做到。</p><p id="3abf" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">今天，我们将研究React本身提供的解决一些性能问题的最有用的两种技术。</p><h2 id="ad32" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">1.让我们从简单的开始</h2><p id="c53f" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">举一个例子，我们有一个名为<code class="fe mr ms mt mu b">Display</code>的组件，它除了显示一行文本之外什么也不做。</p><p id="1c8f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个组件是<code class="fe mr ms mt mu b">Controller</code>的子组件，它有一个按钮增加一个名为<code class="fe mr ms mt mu b">count</code>的状态变量，并保存我们的<code class="fe mr ms mt mu b">Display</code>组件。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">The component where unnecessary rendering happens</figcaption></figure><p id="6fd2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">注意，我们已经在我们的<code class="fe mr ms mt mu b">Display</code>组件中添加了一个<code class="fe mr ms mt mu b">console.log()</code>，以确定我们的组件是否正在重新呈现。</p><p id="7f6a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在，当我们点击<code class="fe mr ms mt mu b">Controller</code>组件的按钮并打开控制台时。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mx"><img src="../Images/31d95bd05e49ddaa11f5f8d70b663aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nclw2ZLIyP1lBm9DLjH8sQ.png"/></div></div></figure><p id="5886" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">虽然它与组件的视图无关，但是我们的组件<code class="fe mr ms mt mu b">Display</code>是<code class="fe mr ms mt mu b">Controller</code>的子组件，每次我们按下按钮，它都会被重新渲染。</p><p id="9609" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这可不酷。如果我们在整个项目中使用这个<code class="fe mr ms mt mu b">Display</code>组件会怎么样？</p><p id="4fbd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">表演会受到影响。</p><h2 id="3930" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">2.你问什么是记忆？</h2><p id="b8fe" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">记忆化是一种非常常见的技术，在很多地方都有使用。无非就是缓存。</p><p id="511d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">维基百科的定义是</p><blockquote class="my mz na"><p id="bd93" class="kx ky nb kz b la lb js lc ld le jv lf nc lh li lj nd ll lm ln ne lp lq lr ls ik bi translated"><em class="ir">在计算中，</em> <strong class="kz is"> <em class="ir">记忆化</em> </strong> <em class="ir">或</em> <strong class="kz is"> <em class="ir">记忆化</em> </strong> <em class="ir">是一种优化技术，主要用于通过存储昂贵的</em> <a class="ae kw" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank"> <em class="ir"> f </em> </a> <em class="ir">函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。</em></p></blockquote><p id="fdb4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">那么……如果记忆化是一种提高功能性能的技术，我们能为我们的功能组件做同样的事情吗？</p><p id="3f43" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">是的，我们能做到。事实上，React已经为我们提供了一个很好的特性，叫做<code class="fe mr ms mt mu b">React.memo()</code></p><p id="0c33" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们将看看如何用它来解决我们当前的问题。</p><h2 id="fc14" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">3.使用React.memo()防止重新呈现</h2><p id="66c2" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated"><code class="fe mr ms mt mu b">React.memo()</code>需要两个参数。</p><ul class=""><li id="db97" class="nf ng ir kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">第一个是我们要记忆的函数。</li><li id="fc80" class="nf ng ir kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">第二个是可选的比较功能，就像<code class="fe mr ms mt mu b">shouldComponentUpdate()</code>一样。我们稍后会打电话给你。</li></ul><p id="a5ed" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">所以现在如果我们把我们的<code class="fe mr ms mt mu b">Display</code>组件传递到<code class="fe mr ms mt mu b">memo()</code>中，这应该被记住。</p><p id="1f35" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们看看会发生什么，如果我们像下面这样重写我们的组件…</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Display component with memoization</figcaption></figure><p id="3fb4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">瞧啊。我们的组件现在不会在我们每次点击按钮时重新呈现。</p><h2 id="f0c5" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">4.让我们更进一步</h2><p id="e003" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">好了，现在你有了一个有效的组件。但问题是component绝对是哑的。你想根据传递给它的一些道具来改变<code class="fe mr ms mt mu b">Display</code>的内容。</p><p id="15ac" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们现在将重写我们的组件以显示名称列表。</p><p id="0bd1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，当我们单击按钮时，它会为我们的状态添加一个新名称。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Updated Display Component to Show List of Names</figcaption></figure><p id="b3eb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">所以每当我们点击<code class="fe mr ms mt mu b">Add Name</code>按钮时，我们应该会看到<code class="fe mr ms mt mu b">another name</code>被追加到名字列表中。</p><p id="222b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是当我们这样做的时候，什么也没有发生。这是为什么呢？</p><h2 id="87a3" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">5.可变与不可变</h2><p id="1bff" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">要解决这个问题，我们必须理解<code class="fe mr ms mt mu b">Immutable</code>的概念。</p><p id="7dfa" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在<code class="fe mr ms mt mu b">newNames = names</code>一行中，我们认为我们将<code class="fe mr ms mt mu b">names</code>赋给了一个新变量<code class="fe mr ms mt mu b">newNames</code>，但实际上javascript中的<code class="fe mr ms mt mu b">arrays</code>并不是这样工作的！</p><p id="0807" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在后台，这一行所做的就是将<code class="fe mr ms mt mu b">names</code>数组的引用分配给<code class="fe mr ms mt mu b">newNames</code>。因此，尽管names数组的内容在变化，但引用却没有变化。</p><p id="217e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">React在这里做的是一个<code class="fe mr ms mt mu b">shallow</code>检查。它只将names数组的前一个引用与新的引用进行比较。因为它没有改变，所以react认为没有必要重新渲染。</p><p id="9e5d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们可以这样重写我们的<code class="fe mr ms mt mu b">addNewName</code>函数来解决这个问题…</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">updated addName function</figcaption></figure><p id="a0d4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个spread操作符返回一个全新的数组，该数组现在被指定为<code class="fe mr ms mt mu b">newNames</code>。</p><p id="f19f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在，如果我们单击按钮，我们会看到我们的组件将重新呈现。</p></div><div class="ab cl nt nu hv nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ik il im in io"><h2 id="5b4f" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">6.在memo()失败的地方，useCallback()来拯救</h2><p id="694d" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">我们再举一个例子。我们将创建一个类似于上一个组件的组件，每次单击按钮时，它都会添加一个新名称。</p><p id="00f4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们将有另一个组件来清除该列表。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="61f1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在，每当我们点击<code class="fe mr ms mt mu b">Add Name</code>按钮时，我们的<code class="fe mr ms mt mu b">ClearButton</code>就会一次又一次地重复渲染！</p><p id="7c72" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这意味着尽管我们记住了我们的<code class="fe mr ms mt mu b">ClearButton</code>并且<code class="fe mr ms mt mu b">clearNames</code>没有改变，但是我们的组件正在不必要地重新渲染。</p><p id="ea95" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了解决这个问题，我们可以使用一个名为<code class="fe mr ms mt mu b">useCallback()</code>的钩子。这个useCallBack()钩子帮助我们避免重新计算<code class="fe mr ms mt mu b">clearNames</code>。它是由React本身提供的，所以我们可以像…</p><pre class="kh ki kj kk gu oa mu ob oc aw od bi"><span id="dea2" class="lt lu ir mu b gz oe of l og oh">import <strong class="mu is"><em class="nb">React</em></strong>,{ useCallback} from 'react';</span></pre><p id="c8e7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们可以如下重写<code class="fe mr ms mt mu b">clearNames</code>函数来解决我们的问题。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">re-written clear name function with useCallback()</figcaption></figure><p id="474b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们的问题解决了！</p><p id="94ff" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，这些是您可以用来提高应用程序性能的一些方法。但是每件好事都有它自己的陷阱。所以试着明智地使用这些技术来避免任何不必要的错误。</p><p id="3e00" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">今天到此为止。编码快乐！</p><p id="b7a8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is">通过</strong> <a class="ae kw" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz is"> LinkedIn </strong> </a> <strong class="kz is">或我的</strong> <a class="ae kw" href="https://www.mohammadfaisal.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz is">个人网站</strong> </a> <strong class="kz is">与我取得联系。</strong></p><div class="oi oj gq gs ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/20-essential-parts-of-any-large-scale-react-app-ee4bd35436a0"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd is gz z fq oq fs ft or fv fx iq bi translated">任何大型React应用程序的20个基本部分</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">如果您正在编写企业级代码，您需要了解这一点</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kq ol"/></div></div></a></div><div class="oi oj gq gs ok ol"><a href="https://betterprogramming.pub/the-7-traits-of-a-rock-star-react-developer-747fbb001c05" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd is gz z fq oq fs ft or fv fx iq bi translated">摇滚明星React开发者的7个特质</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">造成差异的习惯</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">better编程. pub</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz kq ol"/></div></div></a></div></div></div>    
</body>
</html>