<html>
<head>
<title>‘let’ Keyword in JavaScript for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者用JavaScript中的let关键字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/let-keyword-in-javascript-for-beginners-93ee6aa343fe?source=collection_archive---------13-----------------------#2021-07-27">https://javascript.plainenglish.io/let-keyword-in-javascript-for-beginners-93ee6aa343fe?source=collection_archive---------13-----------------------#2021-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3320" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解“让”这个关键词在面试的JavaScript中是如何工作的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5319c4c16767ecb38f08acbdd54db3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*316nQEhTUpmKVa1bql4q3Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Let keyword in JavaScript</figcaption></figure><p id="df14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://www.youtube.com/channel/UCo-h1M-5M6Y5D4Lgut8ge4w" rel="noopener ugc nofollow" target="_blank">技术漏斗</a>展示了另一篇文章，这次是关于JavaScript中的“let”关键字。<strong class="kx ir">在ES6中引入了</strong><strong class="kx ir">“let”这个关键词，在JavaScript访谈</strong>中常见相关问题。我们将讨论JavaScript中<strong class="kx ir"> let关键字的要求和用法。</strong></p><h1 id="bbe7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">“让”关键字是什么？</h1><ul class=""><li id="2686" class="mk ml iq kx b ky mm lb mn le mo li mp lm mq lq mr ms mt mu bi translated"><strong class="kx ir"> <em class="mv">让</em> </strong> <em class="mv"> </em>让用户在JavaScript中<strong class="kx ir">声明变量</strong></li><li id="aa6e" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated"><strong class="kx ir"> <em class="mv">让</em> </strong>关键字声明<strong class="kx ir">块范围变量</strong></li><li id="2c8a" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated"><strong class="kx ir"> <em class="mv">让</em> </strong>帮我们<strong class="kx ir">减少记忆足迹</strong></li><li id="aba2" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated"><strong class="kx ir"> <em class="mv">让</em> </strong>关键词是<strong class="kx ir">不吊</strong></li><li id="4e2d" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated">用<strong class="kx ir"> <em class="mv">定义的变量让</em> </strong>关键字<strong class="kx ir">不能重新声明</strong></li></ul><h1 id="5f57" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">功能范围与块范围</h1><p id="0241" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">为了理解“let”关键字的影响，我们首先需要理解<strong class="kx ir">函数作用域和块作用域变量</strong>，然后再继续讨论“let”和“var”之间的区别。</p><h2 id="5bb0" class="ne lt iq bd lu nf ng dn ly nh ni dp mc le nj nk me li nl nm mg lm nn no mi np bi translated">函数作用域变量</h2><p id="e3ad" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">函数作用域变量的作用域是它所属的最近的函数。变量的生命周期和作用域将绑定到最近的函数。让我借助一个简单的例子来解释一下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lr" href="https://gist.github.com/Mayankgupta688/cfb3bf5e3225779c24aa3f1fc0721194" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/cfb3bf5e3225779c24aa3f1fc0721194</a></figcaption></figure><p id="8f18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，即使变量是在“if”块中声明的，这个变量的范围也是绑定到声明它的函数的。这意味着，即使在“if”块被执行之后，变量“username”仍然可以在“if”块之外被访问，因为该变量是函数范围的。我们可以使用“var”关键字声明函数范围的变量</p><h2 id="b6d7" class="ne lt iq bd lu nf ng dn ly nh ni dp mc le nj nk me li nl nm mg lm nn no mi np bi translated">块作用域变量</h2><p id="0406" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">块作用域变量是只能在定义它们的块中访问的变量。我们可以把一个块想象成“for”、“do-while”、“while”、“if”、“switch”等。如果一个变量被定义为块范围的，它将不能在块外被访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lr" href="https://gist.github.com/Mayankgupta688/b385efa8ecd7e99729c79321521e1bf9" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/b385efa8ecd7e99729c79321521e1bf9</a></figcaption></figure><p id="7ce2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面给出的例子中，使用“let”关键字在块内定义变量名。因为我们使用“let”关键字，所以它是一个块范围的变量，不能在该块范围之外访问。任何试图在外部访问它的行为都将导致错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/5007c69b5e25a77f922eed67898212e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dewJBCBctoElOUAZrxq_Ug.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Block Scoped Variable in JavaScript</figcaption></figure><h1 id="735f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">“让”关键字未被悬挂</h1><p id="3b4b" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">提升的概念定义了变量的作用域，并使变量可用于最近的函数作用域。将变量所属的最近的函数设置为变量的作用域。所以变量可以在函数中使用。下面声明的函数使用“let”关键字创建一个变量。如果变量被提升，它应该在函数范围内可用，我们应该能够在第2行访问该变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lr" href="https://gist.github.com/Mayankgupta688/45c273c28f6cbf85a8cd386e41a83415" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/45c273c28f6cbf85a8cd386e41a83415</a></figcaption></figure><p id="0736" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，用“let”关键字声明的变量不会被提升，并且在函数范围内不可用。我们只能在声明后使用let定义的变量，因为它只能在第3行后使用。</p><p id="90db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我们可以看到，在第3行用“let”声明变量之前，任何访问该变量的尝试都会导致错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/e623b7182d8bc8183a0ba214873c5328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyZULSbywIT0ZGdypFwXCQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">No Hoisting for variable declared with “let”</figcaption></figure><p id="71d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该错误指出在初始化之前不能访问该变量。该变量在第3行初始化，因此只有在第3行执行后才能使用。</p><h1 id="31c6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">减少内存占用</strong></h1><p id="01ba" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">使用“let”关键字声明的变量的作用域在定义它们的块内。一旦块完成执行，使用“let”关键字声明的变量将可供垃圾收集器销毁。我们只在需要变量的地方限制变量的范围，并在块执行后立即处理它们，因此提供了更好的内存管理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lr" href="https://gist.github.com/Mayankgupta688/b385efa8ecd7e99729c79321521e1bf9" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/b385efa8ecd7e99729c79321521e1bf9</a></figcaption></figure><p id="68f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，变量“userName”将在第5行之后对垃圾收集器可用，因为该变量是在“if”块中声明的。所以变量“userName”的存在范围仅限于“if”块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lr" href="https://gist.github.com/Mayankgupta688/7617280887e8e31d93933fdc3062485b" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/7617280887e8e31d93933fdc3062485b</a></figcaption></figure><p id="e952" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在“if”块完成后，任何访问变量的尝试都将导致错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/ea307a62683039b9296690862f943de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiyGLd7a_ESqLklVNIUGgg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Reduce Memory Footprint with let keyword</figcaption></figure><h1 id="303c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak"> <em class="nv">【让】</em> </strong>关键字不能重申报</h1><p id="2cb7" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">同名变量不能在一个块中声明两次。在一个块中多次声明一个变量会导致错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lr" href="https://gist.github.com/Mayankgupta688/8beb594505456d55d227d6063238b3b7" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/8beb594505456d55d227d6063238b3b7</a></figcaption></figure><p id="a792" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码会因为“重新声明”而抛出一个错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c980d80e0252dbe4bfa7ab6db6e4799d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*melQVYc9QtYRibyGpJWZlQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">let keyword cannot be redeclared.</figcaption></figure><p id="0f81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:同名变量可以在同一个函数的另一个块中重新声明。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lr" href="https://gist.github.com/Mayankgupta688/ddfbb04b6f4834125a3ca204df0b8542" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/ddfbb04b6f4834125a3ca204df0b8542</a></figcaption></figure><p id="2464" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述程序的输出如下图所示。这两个变量都是在不同的代码块中使用“let”关键字声明的。由于这些变量的范围仅限于声明它们的“if/else”块，因此代码不会给用户任何错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f6873e2b723e6a06c8394f1b08b83ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*jM6sQD9MyCeZItjsAvCuMA.png"/></div></figure><h1 id="accd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">var和let之间的差异</h1><p id="0686" class="pw-post-body-paragraph kv kw iq kx b ky mm jr la lb mn ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">“let”和“var”之间的区别可以总结如下:</p><ul class=""><li id="e9ef" class="mk ml iq kx b ky kz lb lc le ny li nz lm oa lq mr ms mt mu bi translated">let是块范围的，而var是函数范围的变量</li><li id="d988" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated">let关键字不能在同一个块中重新声明，而var可以</li><li id="5f9d" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated">let可以减少内存占用并有效地管理内存</li><li id="a062" class="mk ml iq kx b ky mw lb mx le my li mz lm na lq mr ms mt mu bi translated">let变量不能被提升，而var可以被提升</li></ul><p id="3cd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mv">更多内容看</em><a class="ae lr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="mv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>