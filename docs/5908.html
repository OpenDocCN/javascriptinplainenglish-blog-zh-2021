<html>
<head>
<title>Boost Your React App Performance with React Profiler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Profiler提升React应用程序的性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/boosting-your-react-app-performance-with-react-profiler-be049146bdd3?source=collection_archive---------5-----------------------#2021-12-18">https://javascript.plainenglish.io/boosting-your-react-app-performance-with-react-profiler-be049146bdd3?source=collection_archive---------5-----------------------#2021-12-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="32c8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用React Profiler分析和提高React应用程序性能的指南。伴随着一个网络应用程序，使它很容易关注。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a063083813422b9f821cdbe4c30cff3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--6s-su5Oxvb9Vs_6g33vw.jpeg"/></div></div></figure><p id="2c03" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">编写React应用程序很容易。编写一个好的React应用程序更加复杂。编写一个好的React应用程序，并且快速运行，这需要的不仅仅是编程技巧。</p><p id="e6c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">即使你是一个伟大的程序员，像大头针一样锋利，像鞭子一样聪明，像丹·阿布拉莫夫一样反应敏捷——你也会错过一些东西；它发生了。有时候，发现自己错过了什么并不是一件小事。</p><p id="4296" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天我们将讨论解决React性能问题的终极工具——React Profiler。</p><h1 id="4952" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">背景</h1><p id="9dfc" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">首先<a class="ae mh" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" rel="noopener ugc nofollow" target="_blank">在2018年推出【React Profiler已经成为</a><a class="ae mh" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"> React Dev Tools Chrome扩展</a>的一部分有一段时间了。你可能会认为这样一个强大的工具会在这些年里越来越受欢迎，但是我一直看到专业社区的人们使用<strong class="kq io"> console.log </strong>来计算渲染次数和测量渲染时间。</p><p id="ac43" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不管是因为人们不熟悉分析器，还是因为它对他们来说太复杂——我们都要解决；你将学习它是什么以及如何使用它，你会发现它一点也不复杂。</p><p id="6186" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以让我们直接开始吧。</p><h1 id="77a7" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">实验室老鼠</h1><p id="9a24" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">为了展示React Profiler，我们将有一个非常简单的应用程序，它有一个自动生成的数字列表，可以通过我们在文本框中输入的搜索词进行过滤。</p><p id="5204" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们开始吧:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6a15" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">他们说这里没什么复杂的，他们说的是不言自明的代码。</p><p id="d2a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了更容易理解，我把这个应用放到了网上<a class="ae mh" href="https://react-profiler-lab-rat.netlify.app/" rel="noopener ugc nofollow" target="_blank">这里</a>。您可以进入该站点，打开调试工具，按照本文进行操作。</p><p id="20c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该应用的完整代码可以在<a class="ae mh" href="https://github.com/just-jeb/react-profiler-lab-rat-app/tree/not-optimized" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><h1 id="67df" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">反应分析器</h1><p id="18cb" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">现在我们已经启动并运行了我们的应用程序，我们可以认识一下React Profiler了。我假设现在你已经安装了React Dev工具扩展，但如果没有，请去Chrome商店帮自己一个忙。</p><p id="43f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">安装后，React开发工具将在任何使用React构建的网站上启用。</p><p id="c128" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">转到我们的web应用程序，打开Chrome开发工具。您会注意到其中一个选项卡是<strong class="kq io"> Profiler </strong>:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mk"><img src="../Images/20d72b21f4bb5400751f0ba60a340a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nARMAPE25Cwrt9OipD41Ag.jpeg"/></div></div></figure><p id="e85d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">概要分析并不是即时进行的——首先，您必须记录一个概要分析会话，然后才能对其进行分析。</p><p id="5386" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们开始记录之前，我们需要在React Dev工具设置中启用一个重要设置:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mk"><img src="../Images/9f10876fe1ac538634dacf42a2a03401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHnkYi7Q9JTwGpqUKtFqQg.jpeg"/></div></div></figure><p id="3a87" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">点击齿轮图标并检查<strong class="kq io">记录为什么每个组件在分析时渲染</strong>复选框:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ml"><img src="../Images/383749c24e0ac384370ebe43900fe372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQOkowzLWnNRWPasPRnyPw.jpeg"/></div></div></figure><p id="3cc7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二个选项(<strong class="kq io">隐藏</strong>以下的提交)也很有用，特别是当您有很多<a class="ae mh" href="#6bef" rel="noopener ugc nofollow">提交</a>并且想要过滤那些无关紧要的提交(那些低于特定阈值的提交)时。</p><h1 id="fd8d" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">记录个人资料</h1><p id="4c0b" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">要开始记录个人资料，请点击蓝色的<strong class="kq io">记录</strong>按钮:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mk"><img src="../Images/77409d013d7bdd7f6ba58ed60d6ab899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHwXNMJ04WAKioWCmdb-RQ.jpeg"/></div></div></figure><p id="7774" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者，您可以重新加载页面并立即开始录制:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mk"><img src="../Images/9bc589e8c900d52dbd791204c024968e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mP939hp5l3_kIpI-BeztMA.jpeg"/></div></div></figure><p id="2c16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">录制开始后，播放一会儿您的应用程序，或者重现一个特别有问题的场景，然后停止录制:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mm"><img src="../Images/102df6068faeeeae873a72aab8467fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOHS-b-40XLXbfEvzguBVQ.jpeg"/></div></div></figure><p id="b267" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于我们的测试应用程序，我只需在文本字段中输入<strong class="kq io"> 111 </strong>，然后逐个删除数字(<strong class="kq io">111-&gt;11-&gt;1-&gt;' '</strong>)。</p><p id="5fae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">停止记录后，我们得到的是:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/33cabcac2fbd415732cbbbb87816aa5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AY0v9SlZC7W0Idyd6CAJ5g.jpeg"/></div></div></figure><p id="c324" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们看看这是什么意思。</p><h1 id="e3e1" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">探查器用户界面</h1><p id="f4af" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">Profiler UI在逻辑上可以分为4个主要部分:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/e66499683e9ace349cc805a406482aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dU5ImKgJ4ndZaGwQBZj6zQ.jpeg"/></div></div></figure><ol class=""><li id="c036" class="mo mp in kq b kr ks ku kv kx mq lb mr lf ms lj mt mu mv mw bi translated"><strong class="kq io">图表选择</strong> —允许在您的应用档案的两种不同表示形式之间进行选择— <em class="mx">火焰图表</em>和<em class="mx">排名图表</em>。我们将详细讨论这两个问题。</li><li id="4056" class="mo mp in kq b kr my ku mz kx na lb nb lf nc lj mt mu mv mw bi translated"><strong class="kq io">图表区</strong> —您的应用程序概要文件中的<em class="mx">单次提交</em>的图形表示。</li><li id="716e" class="mo mp in kq b kr my ku mz kx na lb nb lf nc lj mt mu mv mw bi translated"><strong class="kq io">提交</strong> —每个条形代表应用程序生命周期中<a class="ae mh" href="https://wavez.github.io/react-hooks-lifecycle/" rel="noopener ugc nofollow" target="_blank">提交阶段</a>的一次出现。无论何时通过单击选择提交，图表区和提交信息都会相应地更新。</li><li id="d2c6" class="mo mp in kq b kr my ku mz kx na lb nb lf nc lj mt mu mv mw bi translated"><strong class="kq io">信息面板</strong> —关于单个选定提交阶段或单个选定组件的详细信息。</li></ol><p id="3bd6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在来详细说说。</p><h1 id="6bef" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">承诺</h1><p id="e146" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">React协调算法分为两个阶段:<strong class="kq io">渲染</strong>和<strong class="kq io">提交</strong>。</p><ul class=""><li id="8337" class="mo mp in kq b kr ks ku kv kx mq lb mr lf ms lj nd mu mv mw bi translated"><strong class="kq io">渲染</strong>阶段确定需要对例如DOM做出什么改变。在此阶段，React调用render，然后将结果与之前的渲染进行比较(<a class="ae mh" href="https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm" rel="noopener ugc nofollow" target="_blank">差异算法</a>)。</li><li id="c5b6" class="mo mp in kq b kr my ku mz kx na lb nb lf nc lj nd mu mv mw bi translated"><strong class="kq io">提交</strong>阶段是React应用任何更改的时候。(对于React DOM，这是React插入、更新和删除DOM节点的时候。)</li></ul><p id="7e0c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae mh" href="https://pbs.twimg.com/media/DZ-97vzW4AAbcZj?format=jpg&amp;name=large" rel="noopener ugc nofollow" target="_blank">这里的</a>是经典React组件的相图(作者丹·阿布拉莫夫)，这里的<a class="ae mh" href="https://wavez.github.io/react-hooks-lifecycle/" rel="noopener ugc nofollow" target="_blank"/>是hooks的类似图(作者盖伊·马格利特)。</p><p id="f001" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如前所述，提交部分中的每个条形代表一次提交—条形越高，提交花费的时间越长。提交还可以通过从绿色到黄色的颜色渐变来区分——黄色的性能较低，绿色的性能较高。</p><p id="5499" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，<em class="mx">较高的黄色条代表比较短的绿色条</em>花费更长时间的提交。</p><p id="c340" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当前选择的提交是蓝色的。</p><h1 id="38a1" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">图表:火焰图图表</h1><p id="92c9" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">flamegraph图表视图表示针对特定提交的应用程序的呈现树。图表中的每个条形代表一个React组件。组件从渲染根到叶子进行组织(根是最上面的组件，叶子是最下面的)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/246729a6d32e5d161b2522c0fa74ed89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IG_Rg4jjobbgA9IIvUhymA.jpeg"/></div></div></figure><p id="0c03" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如您所见，<strong class="kq io"> Header </strong>和<strong class="kq io"> FilterableList </strong>是<strong class="kq io"> App </strong>的子组件，因此它们紧挨着出现在<strong class="kq io"> App </strong>组件的下方。</p><p id="b50f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">条形的宽度代表组件<em class="mx">及其子组件</em>渲染<em class="mx">所花费的时间。</em>条形的颜色代表组件本身渲染花了多长时间(绿色表示快，黄色表示慢)。</p><p id="d68e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，在上面的例子中，<strong class="kq io">可过滤列表</strong>的宽度表示<strong class="kq io">可过滤列表</strong>渲染<em class="mx">所花费的时间，包括</em>渲染<strong class="kq io">列表</strong>所花费的时间。</p><p id="1374" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一方面，您可以看到<strong class="kq io">可过滤列表</strong>是绿色的，而<strong class="kq io">列表</strong>是黄色的，并且它与数字相关——渲染<strong class="kq io">可过滤列表</strong>只花了<strong class="kq io">0.5毫秒</strong>，渲染<strong class="kq io">列表</strong>花了<strong class="kq io">1.6毫秒。</strong></p><p id="27c3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，如果一个组件在特定的提交过程中根本没有被呈现，会发生什么呢？</p><p id="88ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看第四次提交:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/b99b939860e03d157442c2197e3dc53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALT6dHqqxg0cnUJcSSWSPg.jpeg"/></div></div></figure><p id="988f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> App </strong>和<strong class="kq io"> Header </strong>组件在过滤时不会改变，所以它们只被渲染一次——在第一次提交期间。在接下来的提交中，这两个组件都是灰色的，但是，它们看起来还是有点不同。那么有什么区别呢？</p><p id="879f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">灰色填充</strong>——一个在提交过程中没有渲染的组件，但它是渲染路径的一部分(例如<strong class="kq io"> App </strong>没有渲染，但它是<strong class="kq io"> FilterableList </strong>的父级，后者进行了渲染)。</p><p id="dee7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">灰色渐变条纹</strong>——一个在提交过程中没有渲染的组件，也不是渲染路径的一部分(例如，<strong class="kq io">头</strong>没有渲染，但是它也没有任何渲染过的子组件)</p><p id="3308" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另外，你可能已经注意到<strong class="kq io">应用</strong>组件栏仍然有宽度，尽管它没有渲染。</p><p id="2666" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，让我们稍微细化一下定义。</p><p id="3c06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">条形的宽度代表组件最后一次渲染花费了多少时间<em class="mx">，颜色代表作为当前提交</em>的一部分花费了多少时间<em class="mx">。</em></strong></p><p id="a600" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后但同样重要的是，您可以通过单击组件来放大或缩小图表。</p><p id="8ba0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">缩小:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/866776838a3a7de8a524c5864dfa6019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wbvvIzwIn9nz3CnDVBcmw.jpeg"/></div></div></figure><p id="79f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">放大:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/a50ee2814751ae2bf003a2c658979f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdBR7kRpFZt04LGOsnMmJg.jpeg"/></div></div></figure><p id="d315" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">缩小:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/b99b939860e03d157442c2197e3dc53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALT6dHqqxg0cnUJcSSWSPg.jpeg"/></div></div></figure><h1 id="35aa" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">图表:排名图表</h1><p id="bd76" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">与flamegraph图表类似，分级图表表示单个提交。但是，与flamegraph图表不同，组件是按渲染时间而不是渲染顺序排序的。</p><p id="0fee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着花费最长时间渲染的<em class="mx">组件位于顶部。</em></p><p id="1fc0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一个区别是组件的条宽代表组件渲染<em class="mx">所花费的时间，不包括其子组件。</em>这意味着颜色和宽度之间存在直接关联。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/151701af737420780e95c915f0ca319d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXckfgc36LE37H3GUrvEOg.jpeg"/></div></div></figure><p id="7e32" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如你所看到的，<strong class="kq io"> List </strong>花费了最长的时间来渲染，所以它位于顶部，它是条形中最宽的，也是条形中最黄的。</p><p id="30a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在提交<em class="mx">期间没有呈现的组件不会出现在分级图表</em>中。</p><p id="516f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与flamegraph图表类似，通过单击组件可以进行放大和缩小。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/768cc1084b11fed6e5b9e5f1d032cafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AuwTUkiIdnxnRzxNMEwDQ.jpeg"/></div></div></figure><h1 id="e8b4" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">信息面板</h1><p id="70ea" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">信息面板有两种不同的应用。</p><p id="44f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 1。选定提交</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/27cd3aa6a00f57b33fa299bd0ab37942.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*vuKRYT6xldboYLfPtYKvCA.jpeg"/></div></figure><p id="8a6a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当未选择(放大)任何组件时，它会显示当前在提交部分选择的提交的概述。数据包括提交时间(自应用程序启动以来)、渲染时间和优先级。</p><p id="6e92" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2。所选组件</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/e4ae7939bcac145f3288ffe26bdf2f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*VZAOtWWyQX5_onsXcKL3Jw.jpeg"/></div></div></figure><p id="43a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当您在其中一个图表视图中单击某个组件(放大它)时，信息面板将显示有关该组件的详细信息。这包括组件在此特定提交期间呈现的原因(如果您在设置中启用了此选项)以及带有时间戳的提交列表。该列表是交互式的，允许您轻松地在涉及该特定组件的不同提交之间导航。</p><h1 id="b58a" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">让实验室老鼠更上一层楼</h1><p id="3813" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">现在我们已经熟悉了React Profiler，让我们看看如何将这些知识应用到实际场景中。</p><p id="8f2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">再来看看我们的<a class="ae mh" href="https://github.com/just-jeb/react-profiler-lab-rat-app/tree/not-optimized" rel="noopener ugc nofollow" target="_blank"> app </a>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d9a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">组件内部的逻辑非常简单，因此很难改进。</p><p id="8a30" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相反，我们将重点关注渲染性能，以尝试减少渲染的数量。因为我们在提交之间所做的只是过滤，所以我们假设这些项目被渲染一次，然后在应用过滤器时从DOM中删除。这意味着当我们过滤时，列表项不应该被渲染两次。然而，这种情况并没有发生。如果您查看<a class="ae mh" href="https://react-profiler-lab-rat.netlify.app/" rel="noopener ugc nofollow" target="_blank"> lab rat </a>配置文件，并在提交面板中的提交之间切换，您会注意到每次提交时都会呈现列表项。为什么会这样？</p><p id="1977" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们放大第二次提交中的一个项目，并尝试找出它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/e1b3da41d050b1a0c52801fb1202ed9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eag36RY82-CEXH0aByr5KA.jpeg"/></div></div></figure><p id="0e86" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">放大为我们提供了有用的信息——自从其<strong class="kq io">值</strong>属性改变后，该项目已被重新渲染(参见<strong class="kq io">信息面板</strong>)。</p><p id="f22e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为什么价值会改变？每次我们过滤列表时，都会创建一个新的数组。由于我们使用item index作为<strong class="kq io"> ListItem </strong>组件的<strong class="kq io">键</strong>，因此每次我们更改过滤器值时，组件间列表值的分布都会不同。</p><p id="e590" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，在第一次渲染时，数组中的第一个条目是使用一个<strong class="kq io"> key=1 </strong>的组件渲染的。然而，在第二次渲染时，当我们从数组中过滤出一些值时，第一个条目可能会有所不同。React将重用第一次渲染中<strong class="kq io"> key=1 </strong>的组件，但由于第一个条目已更改，值已更改，因此重新渲染。</p><p id="0205" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了解决这个问题，我们将在第一次创建数组时给数组中的每个条目分配一个<strong class="kq io"> ID </strong>,并使用它作为条目的键，而不是使用条目索引。</p><p id="0895" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们应用修复程序，看看发生了什么变化(更新的应用程序在此处<a class="ae mh" href="https://react-profiler-lab-rat-semi-optimized.netlify.app/" rel="noopener ugc nofollow" target="_blank">可用</a>):</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9248" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">令人惊讶的是，它什么也没有改变——数字是相同的，并且每次提交时项目组件仍然被重新呈现。让我们仔细看看:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/cc5a68f4ce2977943eb850290bc1f3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbZu7sInAPKs7CVbww_Zhg.jpeg"/></div></div></figure><p id="e636" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如你所看到的，有一件事发生了变化——重新渲染的原因。现在<strong class="kq io">列表项</strong>被重新呈现，因为它们的父组件(<strong class="kq io">列表</strong>)被重新呈现，即使这些组件没有任何变化——无论是ID还是值。</p><p id="7866" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">幸运的是，我们知道如何解决这类问题。让我们把备忘录放在清单项目上，看看它有多少改进:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a087" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae mh" href="https://react-profiler-lab-rat-optimized.netlify.app/" rel="noopener ugc nofollow" target="_blank">到了</a>我们走吧！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/b1a2e015c46f2a30880b5b7cb5caf7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMYkFPJGKdW2OUC3njDQSQ.jpeg"/></div></div></figure><p id="aafa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在以下提交中，以前呈现的项目都不会重新呈现。看看渲染持续时间——我们把它缩短了2倍！</p><h1 id="0b1e" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">完成单词</h1><p id="b9dc" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这个性能问题的最终解决方案是使用一个带有虚拟滚动的列表，它可以为不同的数据重用相同的项目，从而节省重新安装组件的时间。然而，本文的目标是学习如何使用profiler，而不是为Lab Rat应用程序提供最佳解决方案。所以我希望这个目标能够实现，并且你能够理解它是如何工作的，以及它能够做什么。</p><p id="1d54" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">随意使用Lab Rat live应用程序或Github repo并在本地使用它:</p><ul class=""><li id="9f1a" class="mo mp in kq b kr ks ku kv kx mq lb mr lf ms lj nd mu mv mw bi translated"><strong class="kq io">非优化</strong> : <a class="ae mh" href="https://github.com/just-jeb/react-profiler-lab-rat-app/tree/not-optimized" rel="noopener ugc nofollow" target="_blank"> Github </a>，<a class="ae mh" href="https://react-profiler-lab-rat.netlify.app/" rel="noopener ugc nofollow" target="_blank"> Live </a></li><li id="9b2a" class="mo mp in kq b kr my ku mz kx na lb nb lf nc lj nd mu mv mw bi translated"><strong class="kq io">半优化</strong> : <a class="ae mh" href="https://github.com/just-jeb/react-profiler-lab-rat-app/tree/semi-optimized" rel="noopener ugc nofollow" target="_blank"> Github </a>，<a class="ae mh" href="https://react-profiler-lab-rat-semi-optimized.netlify.app/" rel="noopener ugc nofollow" target="_blank"> Live </a></li><li id="5799" class="mo mp in kq b kr my ku mz kx na lb nb lf nc lj nd mu mv mw bi translated"><strong class="kq io">优化</strong> : <a class="ae mh" href="https://github.com/just-jeb/react-profiler-lab-rat-app" rel="noopener ugc nofollow" target="_blank"> Github </a>，<a class="ae mh" href="https://react-profiler-lab-rat-optimized.netlify.app/" rel="noopener ugc nofollow" target="_blank"> Live </a></li></ul><p id="027e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">重要提示:</strong> React DOM在v16.5 &gt;的开发模式下自动支持概要分析，但是由于概要分析会增加一些额外的开销，因此它在生产模式下是可选的。<a class="ae mh" href="https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977" rel="noopener ugc nofollow" target="_blank">这个要点解释了如何选择加入。</a></p><p id="6dd8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天就到这里，如果你喜欢这篇文章，请关注我，在这里发表评论，或者如果你有任何问题，请在Twitter上给我发消息。</p><p id="fc11" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">干杯！</p><p id="81fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mx">这篇和其他文章都可以在我的</em> <a class="ae mh" href="https://www.justjeb.com/blog" rel="noopener ugc nofollow" target="_blank"> <em class="mx">个人博客</em> </a> <em class="mx">上免费获得。请务必注册以获得最新最棒的！</em></p><p id="bfda" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mx">更多内容看</em> <a class="ae mh" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">说白了。报名参加我们的</em> </a><a class="ae mh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">免费每周简讯</em> </a> <em class="mx">。在我们的</em> <a class="ae mh" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="mx">社区</em> </a> <em class="mx">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>