<html>
<head>
<title>GraphQL for Beginners: Setting Up GraphQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL初学者:设置GraphQL服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/graphql-for-beginners-setting-up-graphql-server-ba48a3cbc184?source=collection_archive---------13-----------------------#2021-09-04">https://javascript.plainenglish.io/graphql-for-beginners-setting-up-graphql-server-ba48a3cbc184?source=collection_archive---------13-----------------------#2021-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a889" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">GraphQL初学者友好系列🔰让我们开始构建我们的应用程序吧！第3部分:设置GraphQL服务器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eee741799f84d153997d040622824359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xWxCrrf8PeVRGc0Z"/></div></div></figure><p id="6749" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎回到<a class="ae ln" href="https://lo-victoria.com/series/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL初学者</a>！这是一个对初学者友好的系列，介绍了GraphQL的基本概念，以及如何将其连接到前端框架，如使用Apollo的React。</p><p id="b2c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一部分中，我们将开始使用React和Apollo客户端为一个简单的聊天应用程序构建一个GraphQL服务器。</p><p id="45a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lo">先睹为快:</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lp"><img src="../Images/061e683657d2b31966b20c383d7e69ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujPM8_U8oHvvABs0Lr1gzg.png"/></div></div></figure><blockquote class="lq lr ls"><p id="a6f4" class="kr ks lo kt b ku kv jr kw kx ky ju kz lt lb lc ld lu lf lg lh lv lj lk ll lm ij bi translated">如果你没有看过前面的部分，请在这里看一下<a class="ae ln" href="https://victoria2666.medium.com/graphql-for-beginners-subscriptions-schemas-and-servers-c4b440e3b2aa?sk=0141fe163f173af76e407e8688c3fa8f" rel="noopener">。</a></p></blockquote><h1 id="37a2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">设置GraphQL服务器</h1><p id="417b" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">首先，我们需要一个GraphQL服务器来接收和发送查询给我们的客户机。</p><p id="8b24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要回顾GraphQL服务器，请随意阅读本系列的第2部分。</p><h1 id="b5ec" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">步骤1:初始化项目</h1><p id="75fb" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">确保您的计算机上安装了Node.js。如果没有，在这里安装<a class="ae ln" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="30c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，在终端中使用以下命令创建一个新项目:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="8f6c" class="my lx iq mu b gy mz na l nb nc">mkdir project   // create project folder<br/>mkdir project/server    // create server folder<br/>cd project/server    // move to server folder<br/>npm init    // create package.json in the server folder</span></pre><p id="0b1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您当前的项目文件夹应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/557174e42ff14a3f280f3138eb6933da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q6eW-kTEb-w0ZcPq"/></div></div></figure><p id="de11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如截图所示，我继续在<code class="fe ne nf ng mu b">scripts</code>下添加了<code class="fe ne nf ng mu b">"start": nodemon index.js</code>命令。这样我就可以通过运行<code class="fe ne nf ng mu b">npm start</code>来运行带有nodemon的服务器。</p><h1 id="ae7a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">步骤2:安装软件包</h1><p id="76e4" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在本教程中，我们将使用graphql-yoga设置一个GraphQL服务器。</p><p id="e75d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它很容易设置，并包括内置的Websockets订阅支持，我们将需要我们的聊天应用程序。</p><p id="6da2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确保我们当前的目录是<code class="fe ne nf ng mu b">server</code>文件夹。让我们用以下命令安装它:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="f12d" class="my lx iq mu b gy mz na l nb nc">npm install graphql-yoga</span></pre><h1 id="f0d6" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">步骤3: index.js和Schema</h1><p id="3914" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">然后，在<code class="fe ne nf ng mu b">server</code>文件夹中创建一个<code class="fe ne nf ng mu b">index.js</code>文件。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="b93c" class="my lx iq mu b gy mz na l nb nc">touch index.js</span></pre><p id="016a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们将在中设置GraphQL服务器的入口点。在顶部的<code class="fe ne nf ng mu b">index.js</code>上，让我们导入之前安装的<code class="fe ne nf ng mu b">graphql-yoga</code>包。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="9db2" class="my lx iq mu b gy mz na l nb nc">const { GraphQLServer } = require("graphql-yoga");</span></pre><p id="d272" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们可以通过创建类型定义来定义我们的GraphQL模式:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="d365" class="my lx iq mu b gy mz na l nb nc">const typeDefs = `<br/>  type Message {<br/>    id: ID!<br/>    user: String!<br/>    text: String!<br/>  }<br/>  type Query {<br/>    messages: [Message!]<br/>  }<br/>  type Mutation {<br/>    postMessage(user: String!, text: String!): ID!<br/>  }<br/>  type Subscription {<br/>    messages: [Message!]<br/>  }<br/>`;</span></pre><blockquote class="lq lr ls"><p id="d91d" class="kr ks lo kt b ku kv jr kw kx ky ju kz lt lb lc ld lu lf lg lh lv lj lk ll lm ij bi translated">如果您需要对模式进行回顾，请随意阅读本系列的第2部分。</p></blockquote><p id="afa5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的模式中，我们有一个名为Message的对象类型，带有<code class="fe ne nf ng mu b">id</code>、<code class="fe ne nf ng mu b">user</code>和<code class="fe ne nf ng mu b">text</code>字段。这个对象类型将是我们在这个应用程序上发送和接收的消息。<code class="fe ne nf ng mu b">id</code>是每条消息的唯一标识符。<code class="fe ne nf ng mu b">user</code>只是发送者的名字，而<code class="fe ne nf ng mu b">text</code>是消息的内容。</p><p id="6b34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们有一个查询类型来获取所有消息。查询<code class="fe ne nf ng mu b">messages</code>将返回消息类型的数组，如方括号所示。</p><p id="27cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的查询类型下面，我们有一个突变类型，允许用户在应用程序中发送消息。<code class="fe ne nf ng mu b">postMessage</code>变异接受两个必需的参数:<code class="fe ne nf ng mu b">user</code>和<code class="fe ne nf ng mu b">text</code>，然后返回新发布消息的<code class="fe ne nf ng mu b">id</code>。</p><p id="f85b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们有一个订阅类型，它监听<code class="fe ne nf ng mu b">messages</code>中的变化，并在发生变化时返回所有消息类型的数组。这让我们可以在新消息发送后实时更新UI。</p><h1 id="c3f8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">第四步:发布订阅</h1><p id="0121" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated"><code class="fe ne nf ng mu b">graphql-yoga</code>包含PubSub，一个公开简单发布和订阅API的类。这是实现我们的订阅类型所必需的。</p><p id="4e8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们将它包含在<code class="fe ne nf ng mu b">index.js</code>的顶部，然后创建一个新的PubSub实例。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="f9e1" class="my lx iq mu b gy mz na l nb nc">const { GraphQLServer, PubSub /*add this*/ } = require("graphql-yoga");</span><span id="b950" class="my lx iq mu b gy nh na l nb nc">//create new instance<br/>const pubsub = new PubSub();</span></pre><h1 id="7906" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">步骤5:解析函数</h1><p id="5611" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">正如在本系列的<a class="ae ln" href="https://lo-victoria.com/graphql-for-beginners-subscriptions-schemas-and-servers" rel="noopener ugc nofollow" target="_blank">前一部分</a>中提到的，解析器函数是决定模式如何检索和返回数据的逻辑。您可以将模式视为GraphQL API的结构，而解析器函数实现API的行为。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/0b3d240bf23f75a2e43855d04db77364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KVZ5hKWDNfub4rOO"/></div></div></figure><p id="1424" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要为每个查询、变异和订阅类型编写一个解析器函数，以便指示服务器如何获取、发布和侦听数据中的更改。</p><p id="3d58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们创建一些变量来存储我们的<code class="fe ne nf ng mu b">messages</code>和<code class="fe ne nf ng mu b">subscribers</code>数据。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="ff89" class="my lx iq mu b gy mz na l nb nc">const messages = []; //stores all the messages sent<br/>const subscribers = []; //stores any new messages sent upon listening</span><span id="81d9" class="my lx iq mu b gy nh na l nb nc">//to push new users to the subscribers array<br/>const onMessagesUpdates = (fn) =&gt; subscribers.push(fn);</span></pre><p id="9468" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们创建包含所有解析器函数的<code class="fe ne nf ng mu b">resolver</code>对象。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="13d8" class="my lx iq mu b gy mz na l nb nc">const resolvers = {<br/>  //add all the resolver functions here<br/>}</span></pre><h1 id="01ea" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">解析旋变函数</h1><p id="514e" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">让我们写我们的第一个解析器函数！在我们继续之前，让我们来谈谈解析器函数的结构。它可以接受4个参数:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="4e3e" class="my lx iq mu b gy mz na l nb nc">resolver_name: (parent, args, context, info) =&gt; {<br/>          return something;<br/>        },</span></pre><h2 id="5757" class="my lx iq bd ly nj nk dn mc nl nm dp mg la nn no mi le np nq mk li nr ns mm nt bi translated">1.<code class="fe ne nf ng mu b">parent</code></h2><p id="d5e1" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">解析器函数中的第一个参数是<code class="fe ne nf ng mu b">parent</code>(有时称为<code class="fe ne nf ng mu b">root</code>)。这个<code class="fe ne nf ng mu b">parent</code>指的是操作的根或前一个解析器执行。这是什么意思？</p><blockquote class="lq lr ls"><p id="23cb" class="kr ks lo kt b ku kv jr kw kx ky ju kz lt lb lc ld lu lf lg lh lv lj lk ll lm ij bi translated">如果您需要对GraphQL查询的语法进行回顾，请阅读本系列的第1部分。</p></blockquote><p id="77dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您可能注意到的，GraphQL查询是嵌套的。解析函数是在每个嵌套级别从上到下执行的。<code class="fe ne nf ng mu b">parent</code>返回上一次执行函数的结果。如果查询只有一个级别，它将返回null。</p><h2 id="2d8f" class="my lx iq bd ly nj nk dn mc nl nm dp mg la nn no mi le np nq mk li nr ns mm nt bi translated">2.<code class="fe ne nf ng mu b">args</code></h2><p id="05f9" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated"><code class="fe ne nf ng mu b">args</code>指的是为执行我们的查询而传入的参数。例如，我们的<code class="fe ne nf ng mu b">postMessage</code>变异接受<code class="fe ne nf ng mu b">user</code>和<code class="fe ne nf ng mu b">text</code>作为参数。我们将把这些传递到解析器函数中，稍后我们会写这个函数。</p><h2 id="a823" class="my lx iq bd ly nj nk dn mc nl nm dp mg la nn no mi le np nq mk li nr ns mm nt bi translated">3.<code class="fe ne nf ng mu b">context</code></h2><p id="7f20" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">它允许每一级的解析器能够共享它们可以读取和写入的信息。</p><h2 id="9fd1" class="my lx iq bd ly nj nk dn mc nl nm dp mg la nn no mi le np nq mk li nr ns mm nt bi translated">4.<code class="fe ne nf ng mu b">info</code></h2><p id="7cc4" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">包含所有查询信息的抽象语法树(AST)对象。它不在本系列的讨论范围之内。点击阅读更多详细信息<a class="ae ln" href="https://www.prisma.io/blog/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6d80" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">编写我们的第一个解析器</h1><p id="71d2" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">现在让我们开始为我们的查询<code class="fe ne nf ng mu b">messages</code>编写一个解析器函数。确保解析器返回的类型与步骤3中模式中定义的类型相同是很重要的。</p><p id="bb7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我们的查询类型<code class="fe ne nf ng mu b">messages</code>返回一个消息对象数组。因此，它的解析器功能应该如下:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="bf27" class="my lx iq mu b gy mz na l nb nc">//add inside the resolvers object<br/>  Query: { //gets all messages<br/>    messages: () =&gt; messages, //returns the messages array<br/>  },</span></pre><p id="0f5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个解析器函数非常简单。我们不需要传递任何参数。我们只需要返回包含所有消息对象的消息数组。让我们用我们的突变类型尝试一个更难的。</p><h1 id="9dc8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">突变分解器</h1><p id="6bbf" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们的突变被定义为:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="e825" class="my lx iq mu b gy mz na l nb nc">//in our schema<br/>  type Mutation {<br/>    postMessage(user: String!, text: String!): ID!<br/>  }</span></pre><p id="198c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">变异<code class="fe ne nf ng mu b">postMessage</code>接受两个必需的字符串(即用户和文本)作为参数，并返回一个ID类型。因此，它的解析器函数如下所示:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="e8f0" class="my lx iq mu b gy mz na l nb nc">//add this below the Query resolver</span><span id="95d5" class="my lx iq mu b gy nh na l nb nc"> Mutation: { //post new message and returns id<br/>    postMessage: (parent, { user, text }) =&gt; {<br/>      const id = messages.length; //create the id for new message<br/>      messages.push({id, user, text}); //push Message object to messages array<br/>      return id; //return the id<br/>    },<br/>  }</span></pre><p id="6e04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们将<code class="fe ne nf ng mu b">user</code>和<code class="fe ne nf ng mu b">text</code>作为解析器函数的<code class="fe ne nf ng mu b">args</code>传入。然后，我们为新消息创建一个新的<code class="fe ne nf ng mu b">id</code>，它将是消息数组的长度。我们将一个新的消息对象及其所有相关字段:id、用户和文本推送到消息数组中。最后，如我们的模式中所定义的，我们只返回id。</p><p id="8919" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止还好吗？让我们在这个项目中编写最后也是最复杂的解析器函数。</p><h1 id="87ac" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">订阅:最终解析功能</h1><p id="e424" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们名为<code class="fe ne nf ng mu b">messages</code>的订阅类型监听我们的消息数组中的变化(也就是说，当一个新消息被推入数组时)并返回更新后的消息数组。</p><p id="8159" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">订阅的解析器在3个方面与查询和变异略有不同:</p><ol class=""><li id="a170" class="nu nv iq kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated">它返回一个<code class="fe ne nf ng mu b">AsyncIterator</code>，服务器用它将新的事件数据推送到客户端。</li><li id="71a8" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">它是一个带有<code class="fe ne nf ng mu b">subscribe</code>方法的对象(即<code class="fe ne nf ng mu b">messages</code>)。</li><li id="1f2b" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">它使用<code class="fe ne nf ng mu b">pubsub</code>实例作为<code class="fe ne nf ng mu b">context</code>(解析器函数的第三个参数)来访问处理订阅所需的方法(即pubsub.publish()和pubsub.asyncIterator())</li></ol><blockquote class="lq lr ls"><p id="5440" class="kr ks lo kt b ku kv jr kw kx ky ju kz lt lb lc ld lu lf lg lh lv lj lk ll lm ij bi translated">简而言之，订阅解析器不是一个函数，而是一个具有subscribe方法的对象，它返回AsyncIterable。</p></blockquote><p id="da35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总而言之，我们的订阅解析器功能将是:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="9e81" class="my lx iq mu b gy mz na l nb nc">Subscription: {<br/>    messages: {<br/>      subscribe: (parent, args, { pubsub }) =&gt; {<br/>        //create random number as the channel to publish messages to<br/>        const channel = Math.random().toString(36).slice(2, 15);</span><span id="9b43" class="my lx iq mu b gy nh na l nb nc">        //push the user to the subscriber array with onMessagesUpdates function and <br/>        //publish updated messages array to the channel as the callback<br/>        onMessagesUpdates(() =&gt; pubsub.publish(channel, { messages }));</span><span id="1fce" class="my lx iq mu b gy nh na l nb nc">        //publish all messages immediately once a user subscribed<br/>        setTimeout(() =&gt; pubsub.publish(channel, { messages }), 0);</span><span id="c249" class="my lx iq mu b gy nh na l nb nc">        //returns the asyncIterator<br/>        return pubsub.asyncIterator(channel);<br/>      },<br/>    },<br/>  },<br/>};</span></pre><p id="918a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们只需要在突变解析器函数中添加一行代码。这提醒我们的订阅在每次新消息被推送到变异下时调用回调函数。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="2624" class="my lx iq mu b gy mz na l nb nc">Mutation: { <br/>    postMessage: (parent, { user, text }) =&gt; {<br/>      const id = messages.length;<br/>      messages.push({ id, user, text });<br/>      subscribers.forEach((fn) =&gt; fn()); //add this line<br/>      return id;<br/>    },<br/>  },</span></pre><h1 id="ad4c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">步骤6:创建服务器</h1><p id="7b25" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在这个脚本的底部，我们用我们的typeDefs(即模式)、解析器函数和pubsub作为上下文来初始化<code class="fe ne nf ng mu b">server</code>。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="11c0" class="my lx iq mu b gy mz na l nb nc">const server = new GraphQLServer({ typeDefs, resolvers, context: { pubsub } });<br/>server.start(({ port }) =&gt; {<br/>  console.log(`Server on http://localhost:${port}/`);<br/>});</span></pre><h1 id="3723" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结果</h1><p id="bb4b" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">如果一切正常，我们应该能够使用以下命令运行我们的服务器:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="7124" class="my lx iq mu b gy mz na l nb nc">node index.js</span></pre><p id="1e44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，GraphQL playground将在<code class="fe ne nf ng mu b">http://localhost:4000</code>加载。我们可以尝试一个简单的查询，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/30c94e3f3cd10dda7ffe3c36561c35fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*R2mRZe8gHDs1BWnz"/></div></figure><h1 id="00aa" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">试验</h1><p id="68db" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们可以进行测试查询来获取、发布和订阅消息！让我们在订阅消息的同时发布一个简单的消息。</p><p id="dd87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，创建一个订阅查询，如下图所示。当我们运行查询时，它最初应该返回一个空数组。现在，它正在监听新消息的到来。</p><p id="5807" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，让我们发布一个带有突变查询的新消息。在操场上打开一个新标签，运行变异。</p><p id="3afc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太好了，新消息已经发布。如果我们返回到我们的subscription选项卡，我们会看到它已经成功地返回了新数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/96c0fa159a9b65ca2076cf770012e5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZghHEzzpY1eiHruEdu9GHg.png"/></div></div></figure><p id="ab2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如上图所示，每次发送新消息时，订阅都将返回新的消息数组。这将是我们如何使用订阅来实现我们的实时聊天应用程序的最后一部分。是不是很酷？</p><h1 id="81aa" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">敬请关注</h1><p id="9015" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">非常感谢你阅读这篇长文。希望到目前为止已经很有见地了。请随时查看下面的“阅读更多”部分，以了解更多有关今天用于构建我们的服务器的概念。</p><p id="c4a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">剩下的就是让客户端去做这些查询，而不是在操场上做。这将出现在下一个也是最后一部分，所以请保持关注！干杯！</p><p id="1b43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击这里阅读<a class="ae ln" href="https://victoria2666.medium.com/graphql-for-beginners-build-real-time-chat-app-with-apollo-client-and-react-278d22e1d135?sk=73e5b7107a3ae303284936b3c194a470" rel="noopener">第4部分:用GraphQL和Apollo React构建实时聊天应用</a>！</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h1 id="20f5" class="lw lx iq bd ly lz or mb mc md os mf mg jw ot jx mi jz ou ka mk kc ov kd mm mn bi translated">阅读更多</h1><ul class=""><li id="ef94" class="nu nv iq kt b ku mo kx mp la ow le ox li oy lm oz oa ob oc bi translated"><a class="ae ln" href="https://victoria2666.medium.com/graphql-for-beginners-introduction-90c78a56a96e?sk=ee4885321344329d8af3096f9074427b" rel="noopener">第1部分:GraphQL简介</a></li><li id="526f" class="nu nv iq kt b ku od kx oe la of le og li oh lm oz oa ob oc bi translated"><a class="ae ln" href="https://victoria2666.medium.com/graphql-for-beginners-subscriptions-schemas-and-servers-c4b440e3b2aa?sk=0141fe163f173af76e407e8688c3fa8f" rel="noopener">第2部分:模式、订阅和服务器</a></li><li id="f962" class="nu nv iq kt b ku od kx oe la of le og li oh lm oz oa ob oc bi translated">GitHub回购项目:<a class="ae ln" href="https://github.com/victoria-lo/devthoughts" rel="noopener ugc nofollow" target="_blank">https://github.com/victoria-lo/devthoughts</a></li></ul><h1 id="7ff6" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">参考</h1><ul class=""><li id="9d4e" class="nu nv iq kt b ku mo kx mp la ow le ox li oy lm oz oa ob oc bi translated"><a class="ae ln" href="https://github.com/prisma-labs/graphql-yoga" rel="noopener ugc nofollow" target="_blank"> graphql-yoga GitHub </a></li><li id="625d" class="nu nv iq kt b ku od kx oe la of le og li oh lm oz oa ob oc bi translated"><a class="ae ln" href="https://www.apollographql.com/docs/graphql-subscriptions/setup/" rel="noopener ugc nofollow" target="_blank">发布订阅</a></li><li id="bbef" class="nu nv iq kt b ku od kx oe la of le og li oh lm oz oa ob oc bi translated"><a class="ae ln" href="https://www.howtographql.com/graphql-js/2-a-simple-query/" rel="noopener ugc nofollow" target="_blank">解析器功能</a></li><li id="2719" class="nu nv iq kt b ku od kx oe la of le og li oh lm oz oa ob oc bi translated"><a class="ae ln" href="https://www.prisma.io/blog/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a" rel="noopener ugc nofollow" target="_blank">关于解析器的信息参数</a></li><li id="a0f3" class="nu nv iq kt b ku od kx oe la of le og li oh lm oz oa ob oc bi translated"><a class="ae ln" href="https://github.com/apollographql/graphql-subscriptions" rel="noopener ugc nofollow" target="_blank">关于订阅</a></li></ul></div></div>    
</body>
</html>