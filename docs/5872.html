<html>
<head>
<title>Pick by Values in TypeScript— A Widely Used Trick in Many Famous Projects That You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过TypeScript中的值进行选择——这是许多著名项目中广泛使用的技巧，您应该知道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/pick-by-values-in-typescript-a-widely-used-trick-in-many-famous-projects-that-you-should-know-38801eaac1aa?source=collection_archive---------2-----------------------#2021-12-16">https://javascript.plainenglish.io/pick-by-values-in-typescript-a-widely-used-trick-in-many-famous-projects-that-you-should-know-38801eaac1aa?source=collection_archive---------2-----------------------#2021-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9c75732ba2be3e9e07ac64289b37cf15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJXD31t--_B5uWhg4U6ztw.png"/></div></div></figure><p id="f2f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你读过一些用TypeScript编写的开源项目的源代码，你会发现有很多令人惊叹的技巧。它们可以帮助我们真正享受TypeScript的优势，而不是将其退化为任何脚本。</p><p id="5109" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们从一个简单的例子开始。下面是一个对象类型<code class="fe kw kx ky kz b">User</code>:</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="6a7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想基于<code class="fe kw kx ky kz b">User</code>创建一个新类型，保留<code class="fe kw kx ky kz b">name</code>和<code class="fe kw kx ky kz b">age</code>属性，放弃<code class="fe kw kx ky kz b">level</code>和<code class="fe kw kx ky kz b">isMember</code>，我们该怎么做？</p><p id="1bf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最直接的方法是复制和粘贴:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="0cfb" class="lk ll iq kz b gy lm ln l lo lp">type UserInfo = {<br/>    name: string,<br/>    age: number<br/>}</span></pre><p id="3aa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这种编码方式并不是通用的。更常见的方法是使用<code class="fe kw kx ky kz b">Pick</code>生成新类型。</p><p id="cb8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Pick&lt;Type, Keys&gt;</code>是<a class="ae lq" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">在TypeScript </a>中内置的实用程序类型，它通过从<code class="fe kw kx ky kz b">Type</code>中挑选属性集<code class="fe kw kx ky kz b">Keys</code>(字符串文字或字符串文字的并集)来构造类型。</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="725b" class="lk ll iq kz b gy lm ln l lo lp">type UserInfo = Pick&lt;User, 'name' | 'age'&gt;</span></pre><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/7ce3bdf6063f6673339709243c04b663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IV50K7P6zP4IxpewB8l2eA.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Now, the user is UserInfo type, which doesn’t have a level property.</figcaption></figure><p id="15ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个知识很简单，相信很多读者已经掌握了。如果还不熟悉，可以看看<a class="ae lq" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>中的相关介绍。</p><p id="dd11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是让我们更深入地思考一下:</p><ol class=""><li id="cf26" class="lw lx iq ka b kb kc kf kg kj ly kn lz kr ma kv mb mc md me bi translated"><code class="fe kw kx ky kz b">Pick</code>是如何工作的？我们能自己实现<code class="fe kw kx ky kz b">Pick</code>吗？</li></ol><p id="f02d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你读过官方文档中的实用程序类型一节，你会发现有很多内置的实用程序类型。这些实用程序类型的基本原理是什么？</p><p id="2521" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.如果我们需要通过值来选择，而不是通过属性名来选择，例如，从<code class="fe kw kx ky kz b">User</code>中选择所有字符串类型的属性，我们应该怎么做？</p><p id="6cfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个著名的开源项目的代码片段，<a class="ae lq" href="https://github.com/piotrwitek/utility-types" rel="noopener ugc nofollow" target="_blank"> utility-types </a>，你明白吗？</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="3d36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不知道这两个问题的答案，你就很难理解别人写的TypeScript代码。在本文中，我将围绕这两个问题，和大家一步步学习相关知识点。</p><h1 id="9039" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">基础知识</h1><p id="d3e7" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">在我们进入这两个问题之前，我们首先需要理解一些基本的TypeScript概念。如果你对这些有信心，你可以跳过它。</p><h2 id="90b6" class="lk ll iq bd mg nh ni dn mk nj nk dp mo kj nl nm ms kn nn no mw kr np nq na nr bi translated">keyof</h2><p id="6bdf" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">在<a class="ae lq" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html" rel="noopener ugc nofollow" target="_blank">正式文件</a>中，<code class="fe kw kx ky kz b">keyof</code>的定义是:</p><blockquote class="ns nt nu"><p id="6cab" class="jy jz nv ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated">keyof操作符接受一个对象类型，并生成其键的字符串或数字文字并集。</p></blockquote><p id="9002" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比如keyof <code class="fe kw kx ky kz b">User</code>返回<code class="fe kw kx ky kz b">'name' | 'age' | 'level' | 'isMember'</code>。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/5fd84fa5ab265f27b5a45295822016da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpKMzCpVeNFKgLmqLRVhuw.png"/></div></div></figure><h2 id="9e8a" class="lk ll iq bd mg nh ni dn mk nj nk dp mo kj nl nm ms kn nn no mw kr np nq na nr bi translated">条件类型</h2><p id="d177" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">TypeScript中的条件类型的形式看起来有点像JavaScript中的条件表达式。</p><blockquote class="oa"><p id="9ca2" class="ob oc iq bd od oe of og oh oi oj kv dk translated">某种类型扩展另一种类型？TrueType:false type；</p></blockquote><p id="efe9" class="pw-post-body-paragraph jy jz iq ka b kb ok kd ke kf ol kh ki kj om kl km kn on kp kq kr oo kt ku kv ij bi translated">在JavaScript中，我们可以使用条件表达式:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="6448" class="lk ll iq kz b gy lm ln l lo lp">let num = 30;<br/>let isOdd =  num / 2 == 0 ? false : true;</span></pre><p id="44c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这相当于:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="e20e" class="lk ll iq kz b gy lm ln l lo lp">let num = 30;<br/>let isOdd;</span><span id="305f" class="lk ll iq kz b gy op ln l lo lp">if (num / 2 == 1){<br/>  isOdd = false<br/>} else {<br/>  isOdd = true<br/>}</span></pre><p id="4810" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在TypeScript中，条件类型的工作方式类似:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="205b" class="lk ll iq kz b gy lm ln l lo lp">interface A {}<br/><br/>interface B extends A {} <br/><br/>type C = B extends A ? number : string</span></pre><p id="f185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码意思是:如果<code class="fe kw kx ky kz b">B</code>扩展了<code class="fe kw kx ky kz b">A</code>，那么<code class="fe kw kx ky kz b">C</code>应该是数字类型，否则<code class="fe kw kx ky kz b">C</code>应该是字符串类型。</p><p id="5615" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于条件类型的更多细节，可以参考<a class="ae lq" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p><h2 id="66fe" class="lk ll iq bd mg nh ni dn mk nj nk dp mo kj nl nm ms kn nn no mw kr np nq na nr bi translated">访问对象类型的属性</h2><p id="2663" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">上面的用户类型非常类似于JavaScript中的对象文字。事实上，在TypeScript中，这种类型也被称为对象类型，我们可以像访问JavaScript对象一样访问它们的属性。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/df74e84794427d697b7af296f3990a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USobZRzu57jEgM8g1O4KOw.png"/></div></div></figure><p id="f6de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上例中，<code class="fe kw kx ky kz b">department</code>被赋予了<code class="fe kw kx ky kz b">User['department']</code>，也就是<code class="fe kw kx ky kz b">'coding' | 'marketing'</code>。所以<code class="fe kw kx ky kz b">dep</code>可以分配<code class="fe kw kx ky kz b">'marketing'</code>而不能分配<code class="fe kw kx ky kz b">'22'</code>。</p><p id="7107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们还可以访问多个属性:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/abb8dae010808757a7e7cbc73bfa970e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvBiobZsQEEHHgc4S5EceA.png"/></div></div></figure><p id="5e62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们使用<code class="fe kw kx ky kz b">'department' | 'age'</code>来访问<code class="fe kw kx ky kz b">User</code>，因此<code class="fe kw kx ky kz b">departmentAndAge</code>等于<code class="fe kw kx ky kz b">User['department']</code>和<code class="fe kw kx ky kz b">User['age']</code>的并集，即<code class="fe kw kx ky kz b">'coding' | 'marketing' | number</code>。所以<code class="fe kw kx ky kz b">value</code>可以分配<code class="fe kw kx ky kz b">'marketing'</code>或<code class="fe kw kx ky kz b">1</code>而不能分配<code class="fe kw kx ky kz b">'hi'</code>。</p></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="112c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，这些是你应该知道的基本知识。</p><h1 id="6f2b" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">映射类型</h1><p id="3e06" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">映射类型是本文的重点，也是解决以上两个问题的关键。</p><p id="c48b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript中的映射类型是什么？先说个例子。</p><p id="d786" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有一个界面<code class="fe kw kx ky kz b">Point</code>:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="d5d2" class="lk ll iq kz b gy lm ln l lo lp">interface Point {<br/>  x: number;<br/>  y: number;<br/>}</span></pre><p id="4870" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想创建一个新的类型<code class="fe kw kx ky kz b">PointString</code>，其中也有<code class="fe kw kx ky kz b">x</code>和<code class="fe kw kx ky kz b">y</code>作为属性，但是将它们设置为字符串类型，我们应该怎么做？</p><p id="3c06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你甚至可以复制粘贴:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="2878" class="lk ll iq kz b gy lm ln l lo lp">interface PointString {<br/>  x: string;<br/>  y: string;<br/>}</span></pre><p id="f606" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们之前提到的，这种编码方式有很多缺陷:</p><ul class=""><li id="5b41" class="lw lx iq ka b kb kc kf kg kj ly kn lz kr ma kv oz mc md me bi translated">很多重复的代码，不好看</li><li id="73d4" class="lw lx iq ka b kb pa kf pb kj pc kn pd kr pe kv oz mc md me bi translated">代码不能重复使用</li></ul><p id="7059" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们可以使用映射类型:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/553bd1e008c281541656a20efcb8bf8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBPky99WvB_UGYaKR7cO6Q.png"/></div></div></figure><p id="da69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个语法乍一看可能令人望而生畏，所以让我们一点一点地分解它:</p><ul class=""><li id="4e1b" class="lw lx iq ka b kb kc kf kg kj ly kn lz kr ma kv oz mc md me bi translated">我们正在定义一个类型，<code class="fe kw kx ky kz b">PointString</code>。</li><li id="c216" class="lw lx iq ka b kb pa kf pb kj pc kn pd kr pe kv oz mc md me bi translated">在方括号中，我们使用的是<code class="fe kw kx ky kz b">keyof</code>操作符。<code class="fe kw kx ky kz b">keyof Point</code>表示类型为<code class="fe kw kx ky kz b">Point</code>的所有属性名，等于<code class="fe kw kx ky kz b">'x' | 'y'</code></li><li id="dddb" class="lw lx iq ka b kb pa kf pb kj pc kn pd kr pe kv oz mc md me bi translated">方括号中的关键字<code class="fe kw kx ky kz b">in</code>表示我们正在处理一个映射类型。<code class="fe kw kx ky kz b">[key in keyof Point]: string</code>表示类型<code class="fe kw kx ky kz b">Point</code>的每个属性<code class="fe kw kx ky kz b">key</code>的类型应该转换为<code class="fe kw kx ky kz b">string</code>。</li></ul><p id="81ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">[key in keyof Point]: string</code>是一种类似于JavaScript中的<code class="fe kw kx ky kz b">for ... in</code>语法的语法。它遍历<code class="fe kw kx ky kz b">Point</code>的键来创建一个新类型:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/0c1624e6338a340d9d5af6f2ec436103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s36ylqXPsZply5H4qWIkdQ.png"/></div></div></figure><p id="2681" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是上面的代码好像还是没用，因为<code class="fe kw kx ky kz b">PointString</code>只能处理Point。改进的想法很简单，我们只是用一个<strong class="ka ir">泛型类型</strong>替换了类型点。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ph"><img src="../Images/c36045a83a103c440022e4e515e7a6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bzj35IT_bldfsz22wEsCQ.png"/></div></div></figure><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="90e1" class="lk ll iq kz b gy lm ln l lo lp">type Stringify&lt;Type&gt; = {<br/>    [key in keyof Type]: string<br/>}</span></pre><p id="8b08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码与前面的代码做同样的事情。唯一不同的是，我们使用的是泛型而不是<code class="fe kw kx ky kz b">Point</code>，所以这个<code class="fe kw kx ky kz b">Stringify</code>可以是通用的。</p><p id="eb60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是映射类型的用法。它可以映射现有类型的所有属性，然后我们可以在这个过程中对它们进行一定的修改，最终创建一个我们想要的新类型。这是一个非常强大的技术，我们可以用它做很多事情。</p><h1 id="6e4c" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">内置实用程序类型</h1><p id="3d50" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">在TypeScript中，有许多内置的实用程序类型，包括Readonly、Partial和本文开头提到的Pick。它们都是使用底层的映射类型实现的。我们自己试试吧。</p><p id="8549" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不熟悉这些公用事业类型，你可以自己阅读<a class="ae lq" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">的官方文件</a>，我在这里重复介绍它们是没有用的。</p><h2 id="88d8" class="lk ll iq bd mg nh ni dn mk nj nk dp mo kj nl nm ms kn nn no mw kr np nq na nr bi translated">只读</h2><blockquote class="ns nt nu"><p id="516d" class="jy jz nv ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated">Readonly <type>构造一个类型，其中<code class="fe kw kx ky kz b">Type</code>的所有属性都设置为<code class="fe kw kx ky kz b">readonly</code>，这意味着构造的类型的属性不能被重新分配。</type></p></blockquote><p id="3e98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要实现Readonly，我们可以这样写:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pi"><img src="../Images/b2939d3c1ad4fa731ceb4f8d32fa7a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnMOoApXvIBWvS7ZcpQkaA.png"/></div></div></figure><p id="0f88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，我们只需要在表达式前添加一个<code class="fe kw kx ky kz b">readonly</code>修饰符，然后它会使所有的属性都变成只读的。</p><p id="c9bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">MyReadonly</code>的用法与内置型<code class="fe kw kx ky kz b">Readonly</code>完全相同。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pj"><img src="../Images/1348e2b5e29f8e10e5e2b745feffd9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5tW47fUB6JOXQbUdrwgGQ.png"/></div></div></figure><h2 id="23bf" class="lk ll iq bd mg nh ni dn mk nj nk dp mo kj nl nm ms kn nn no mw kr np nq na nr bi translated">部分的</h2><blockquote class="ns nt nu"><p id="59b5" class="jy jz nv ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated">Partial <type>构造一个类型，其中<code class="fe kw kx ky kz b">Type</code>的所有属性都设置为可选。该实用程序将返回一个表示给定类型的所有子集的类型。</type></p></blockquote><p id="10c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要实现分部，我们可以这样写:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pk"><img src="../Images/19e8cd2b8bd70453c0f4f3b10c6747c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSSX4U0mBlYXtqiy_Q5PIA.png"/></div></div></figure><p id="2507" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">?</code>是一个修饰符，表示该属性是可选的。</p><p id="4f12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">MyPartial</code>的用法与内置类型<code class="fe kw kx ky kz b">Partial</code>完全相同。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pl"><img src="../Images/4625aac7064f4ace0108ffb1c6b2ce38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7D1qUWLr4LHNJ5PMInKfQ.png"/></div></div></figure><h2 id="f631" class="lk ll iq bd mg nh ni dn mk nj nk dp mo kj nl nm ms kn nn no mw kr np nq na nr bi translated">需要</h2><blockquote class="ns nt nu"><p id="54ad" class="jy jz nv ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Required&lt;Type&gt;</code>构造一个由设置为required的<code class="fe kw kx ky kz b">Type</code>的所有属性组成的类型。<code class="fe kw kx ky kz b">Partial</code>的反义词。</p></blockquote><p id="ac90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要实现分部，我们可以这样写:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pm"><img src="../Images/7cd0a4cfea4cd439e8169c03ab5472c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6q4dd26lMD99n_KGs78g6w.png"/></div></div></figure><p id="5012" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">-</code>是表示除去某物的特殊修饰语，<code class="fe kw kx ky kz b">-?</code>的意思是使不可选择。</p><p id="47b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">MyRequired</code>的用法与内置实用程序类型<code class="fe kw kx ky kz b">Required</code>完全相同。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pn"><img src="../Images/8e79707fd3031d013725528e9a52b9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRf2cOXDwLxkBcZEq3hwsA.png"/></div></div></figure><p id="c44d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，<code class="fe kw kx ky kz b">user2</code>的所有属性都不是可选的。</p><h2 id="a5ca" class="lk ll iq bd mg nh ni dn mk nj nk dp mo kj nl nm ms kn nn no mw kr np nq na nr bi translated">挑选</h2><p id="d61b" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">好了，在练习了几次映射类型之后，现在让我们回到开始的问题:如何实现<code class="fe kw kx ky kz b">Pick</code>。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi po"><img src="../Images/3407ed59bf9a4fcbd51c5834efcc4ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TSzLxIbKvOzBQxo46DViA.png"/></div></div></figure><p id="8ca2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们不会遍历<code class="fe kw kx ky kz b">T</code>的所有属性，相反，我们只遍历扩展<code class="fe kw kx ky kz b">K</code>的属性，因此其他属性将被删除。然后它生成一个新的类型。</p><p id="2b66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是<code class="fe kw kx ky kz b">MyPick</code>的用法，和内置实用类型<code class="fe kw kx ky kz b">Pick</code>完全一样。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pp"><img src="../Images/c2176d787a2d021b5454ee0451fe6ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hptujeqtHMOMLXxwaVEntw.png"/></div></div></figure><p id="71a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们用图表来表示这个过程，它看起来像这样:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/36adf71e6076f758a6e4aa950aa1f86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNTn1AnRKY--o1vZHQTlPg.png"/></div></div></figure></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="b07e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们在开头完成了第一个问题:理解<code class="fe kw kx ky kz b">Pick</code>的底层，然后自己实现。</p><p id="2d49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们还实现了许多其他内置的实用程序类型，我希望这将提高您对这些类型的理解。</p><h1 id="8959" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">按值选取</h1><p id="ef11" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">然后我们可以发现，<code class="fe kw kx ky kz b">Pick</code>的核心思想是通过属性名挑选一组属性。但是，如果我们想通过值来选择，例如，选择数字类型的用户的所有属性，我们应该写什么？</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/1f25567683b06636fe74b34a19753482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CurFDDG5uv1zWrpOdbXoA.png"/></div></div></figure><p id="4066" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文开头已经给出了实现:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pq"><img src="../Images/83a858e84b5cb6ff2f2c9cae479cd984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ek6wiA6hOaxQae_WMtZ3fw.png"/></div></div></figure><p id="f75c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用法:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="ab gu cl pr"><img src="../Images/513f77c5d1aa0c58086dc0f2c0e7dbe4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hchx4n5RAcP0Sl7LHSF6YQ.png"/></div></figure><p id="2bd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，字符串类型属性<code class="fe kw kx ky kz b">name</code>和布尔类型属性<code class="fe kw kx ky kz b">isMember</code>已经被删除，只剩下两个数字类型属性。</p><p id="7a87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如何理解这个代码呢？</p><p id="2585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以先分解一下问题。如果我们为此定义一个类型:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="b5b4" class="lk ll iq kz b gy lm ln l lo lp">type SetUnwantedTypeToNever&lt;T, ValueType&gt; = {<br/>    [Key in keyof T] -?: T[Key] extends ValueType ? Key : never<br/>}</span></pre><p id="a8bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着如果<code class="fe kw kx ky kz b">T</code>的一个属性是一个<code class="fe kw kx ky kz b">ValueType</code>，那么把它的值改成它的名字文本；否则将属性设置为<code class="fe kw kx ky kz b">never</code>。下面是一个例子:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ps"><img src="../Images/fa552233bd5867a5d0c238643e9349d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exscZRnCQPwIp75IUOvVKg.png"/></div></div></figure><p id="b5e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们选择<code class="fe kw kx ky kz b">User</code>的所有字符串类型属性，然后将它们的值改为name literal。<code class="fe kw kx ky kz b">User</code>的其他属性被设置为从不。</p><p id="079f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，我们可以用一个图表来表示<code class="fe kw kx ky kz b">PickByValue&lt;User, number&gt;</code>的过程:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/06291a3c8c190114bfcdce0b8383ac0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s456dgUsxTQoH7D8MuNiqg.png"/></div></div></figure><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/a3124243db9b6a474f2f4a2ffb6e0550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrdXlekFIQj_7GC-pgXOtA.png"/></div></div></figure><p id="0169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们通过值选择类型的诀窍。好了，我们从一开始就解决了第二个问题。</p></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><h1 id="e4ac" class="mf ll iq bd mg mh pt mj mk ml pu mn mo mp pv mr ms mt pw mv mw mx px mz na nb bi translated">结论</h1><p id="066f" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">我们从两个问题开始:内置类型<code class="fe kw kx ky kz b">Pick</code>是如何实现的，以及如何实现通过值类型选择属性的实用程序类型。</p><p id="c20c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们简单介绍一些基本概念，比如<code class="fe kw kx ky kz b">keyof</code>，条件类型，以及其他实用类型的用法。</p><p id="c1f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们学习了映射类型，并用它来实现这些内置的实用程序类型。希望通过这个手动实现的过程，让你对内置的实用工具类型和映射类型有更深入的了解。</p><p id="1cd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们使用一个复杂的技巧来实现按值选取，然后用一个图表来解释。</p><p id="9158" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这篇文章对你有用，能让你更流利的阅读TypeScript代码。</p></div></div>    
</body>
</html>