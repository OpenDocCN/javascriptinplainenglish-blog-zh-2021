<html>
<head>
<title>Coding Interviews: Sorting Characters by Frequency in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码采访:在JavaScript中按频率对字符排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/coding-interviews-sorting-characters-by-frequency-in-javascript-f18c85a357d1?source=collection_archive---------8-----------------------#2021-11-15">https://javascript.plainenglish.io/coding-interviews-sorting-characters-by-frequency-in-javascript-f18c85a357d1?source=collection_archive---------8-----------------------#2021-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b0483b3414dcf84f27cabfd19e315588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*auiLFm20EL1ISRUi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@shs521?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Susan Holt Simpson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d12b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="ee05" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">计算频率的问题通常很适合使用地图数据结构。</li><li id="4d36" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">我们需要计算字符频率，推断字符，对推断出的字符串进行排序，然后将这些字符串重新连接在一起。</li><li id="fd3b" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">该算法具有<code class="fe ly lz ma mb b">O(n*log(n)</code>时间复杂度和<code class="fe ly lz ma mb b">O(n)</code>空间复杂度。</li></ul><h1 id="e09c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">问题描述</h1><blockquote class="mc"><p id="08ca" class="md me iq bd mf mg mh mi mj mk ml lo dk translated"><em class="mm">给定一个字符串</em> <code class="fe ly lz ma mb b"><em class="mm">s</em></code> <em class="mm">，根据字符出现的频率按降序排序。字符的频率是它在字符串中出现的次数。</em></p><p id="7ddb" class="md me iq bd mf mg mh mi mj mk ml lo dk translated"><em class="mm">返回排序后的字符串。如果有多个答案，请返回其中任何一个。</em></p></blockquote><p id="f030" class="pw-post-body-paragraph mn mo iq ld b le mp mq mr lg ms mt mu li mv mw mx lk my mz na lm nb nc nd lo ij bi translated">这个问题来自<a class="ae kc" href="https://leetcode.com/problems/sort-characters-by-frequency/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>。那里不缺少实践问题，但是LeetCode是磨练你的算法设计技能的最受欢迎的平台之一。LeetCode提供了实践问题、解决方案和讨论问题的健康用户群，是一个很好的资源。</p><h1 id="bd78" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">问题解决方案</h1><p id="1b2e" class="pw-post-body-paragraph mn mo iq ld b le lf mq mr lg lh mt mu li ne mw mx lk nf mz na lm ng nc nd lo ij bi translated">这个问题的关键是将字符映射到它们在字符串中出现的频率。每当你遇到一个使用“频率”这个词的问题时，地图很有可能是这项工作的合适工具。</p><p id="ce76" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">一旦所有的字符都被映射，我们需要将单个的字符外推到包含重复适当次数的字符的字符串中。然后，我们可以对这些字符串进行排序，并将它们连接成一个最终的字符串。</p><p id="a54c" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">让我们将逻辑分解成更小、更容易理解的部分。</p><h1 id="120c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">计数字符</h1><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/496b5d18ae36d8022b0b73327bb07baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EghbO5YRP1I4PMsAPUpKg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A flowchart illustrating the logic of counting characters.</figcaption></figure><p id="781a" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">与其试图对这些字符进行低效的分组和排序，不如简单地计算字符频率，然后创建我们稍后想要看到的字符分组。地图数据结构在这里特别有用，因为它是以一种允许我们进行常量时间查找的方式实现的(即<code class="fe ly lz ma mb b">O(1)</code>)。所以通过使用一个地图，当我们想要添加一个角色的时候，它是一个快速的查找来检查我们是否已经在地图中有那个角色。</p><p id="aeb9" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">因此，我们可以遍历我们的角色，检查它们是否已经存在于我们的地图中。如果是这样，我们会将该角色的计数值增加1，如果不是，我们会将该角色添加到地图中，初始计数值为1。</p><h1 id="add1" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">外推和排序</h1><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/27722d9d72d9e7a5d27652f129d86dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*urHw-spLctPMUaI8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A flowchart illustrating the logic of extrapolating and sorting characters.</figcaption></figure><p id="f637" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">将字符外推至由按其频率重复的字符组成的字符串可能是该算法中自己的部分，但大多数成熟的编程语言都有一种内置的声明性方式来完成这一任务。在JavaScript中，我们可以使用<code class="fe ly lz ma mb b">String.prototype.repeat</code>来完成这个任务。</p><p id="8104" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">考虑到外推逻辑，我们的逻辑如下:遍历映射，外推字符，将外推的字符串推入可排序的数据结构，然后排序。这里的关键是使用易于排序的数据结构。在JavaScript中，数组有一个原生的<code class="fe ly lz ma mb b">Array.prototype.sort</code>方法，可以用来声明性地对项目进行排序，所以我们将使用一个方法来存储我们推断出的字符串。</p><h1 id="d9a8" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">连接</h1><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/0e9e61840b0272719393ad68079f4994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QZErv_zuSh7yer7W"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A flowchart illustrating the logic of joining extrapolated characters.</figcaption></figure><p id="577b" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">在我们对字符串进行排序之后，我们只需要将它们连接成最终的结果字符串。同样，JavaScript有一个名为<code class="fe ly lz ma mb b">Array.prototype.join</code>的声明性原型方法，它将为我们完成这项工作。如果您想自己实现连接逻辑，只需遍历数组并将每个字符串连接成一个结果字符串。</p><h1 id="18e7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">JavaScript实现</h1><p id="1148" class="pw-post-body-paragraph mn mo iq ld b le lf mq mr lg lh mt mu li ne mw mx lk nf mz na lm ng nc nd lo ij bi translated">既然我们已经有了心智模型和算法，将其翻译成代码就相当简单了。让我们来看一个JavaScript实现。</p><figure class="nn no np nq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/416c142898c855c84c83d4ee48a035d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aWM8MD37WuX-H2xt"/></div></div></figure><p id="ac5a" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">如您所见，映射逻辑在第2行到第7行实现。我们创建一个空对象作为我们的映射，使用一个<code class="fe ly lz ma mb b">for</code>循环来遍历我们的字符串，在每次迭代中，我们使用基本的对象属性赋值来更新我们的字符频率。</p><p id="32c6" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">字符外推发生在第9行到第14行。你会注意到我们使用了一个<code class="fe ly lz ma mb b">for...in</code>循环来遍历我们的对象，在每次迭代中，我们使用<code class="fe ly lz ma mb b">String.prototype.repeat</code>方法外推我们的字符串，并将其推到数组的末尾。之后，我们使用<code class="fe ly lz ma mb b">Array.prototype.sort</code>按长度对字符串进行排序。</p><p id="5eda" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">最后，我们使用<code class="fe ly lz ma mb b">Array.prototype.join</code>将我们的字符串数组合并成第17行的最终字符串。</p><p id="603d" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">如果你想运行这段代码，你可以从<a class="ae kc" href="https://gist.github.com/mjstromberg/8f4edd906abfb737b30d62cebceaba63" rel="noopener ugc nofollow" target="_blank">这里</a>复制它。</p><h1 id="68d7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">效率</h1><p id="d452" class="pw-post-body-paragraph mn mo iq ld b le lf mq mr lg lh mt mu li ne mw mx lk nf mz na lm ng nc nd lo ij bi translated">一个算法的好坏取决于它的效率。在面试中，一个低效的算法当然比什么都没有好，但通常“蛮力”方法是不会成功的。因此，了解如何计算算法的效率以及如何向他人传达这些信息非常重要。</p><p id="b586" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">算法的效率通常使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大O符号</a>来描述，并用于定义时间复杂度和空间复杂度。</p><h2 id="9014" class="nt ke iq bd kf nu nv dn kj nw nx dp kn li ny nz kr lk oa ob kv lm oc od kz oe bi translated">时间复杂度</h2><p id="1b5b" class="pw-post-body-paragraph mn mo iq ld b le lf mq mr lg lh mt mu li ne mw mx lk nf mz na lm ng nc nd lo ij bi translated">对于我们的问题，映射是线性的(即<code class="fe ly lz ma mb b">O(n)</code>)，连接也是线性的，但是这里的瓶颈是排序。排序效率取决于JavaScript运行时的实现。Chrome使用V8引擎，该引擎本身使用<a class="ae kc" href="https://v8.dev/blog/array-sort" rel="noopener ugc nofollow" target="_blank"> Timsort </a>算法实现<code class="fe ly lz ma mb b">Array.prototype.sort</code>，平均产生一个<code class="fe ly lz ma mb b">O(n*log(n)</code>的时间复杂度。因为这些操作是顺序的，没有嵌套，所以最大的复杂性使其他操作相形见绌，因为<code class="fe ly lz ma mb b">n</code>(数据结构中的项数)接近无穷大。</p><h2 id="1138" class="nt ke iq bd kf nu nv dn kj nw nx dp kn li ny nz kr lk oa ob kv lm oc od kz oe bi translated">空间复杂性</h2><p id="d214" class="pw-post-body-paragraph mn mo iq ld b le lf mq mr lg lh mt mu li ne mw mx lk nf mz na lm ng nc nd lo ij bi translated">本质上，映射操作占用线性空间(即<code class="fe ly lz ma mb b">O(n)</code>)，因为对于字符串中的每个字符，我们在映射中分配了一块内存。平均来说，映射中使用的内存会更少<code class="fe ly lz ma mb b">n</code>，因为我们经常会有重复的字符，但是我们通常只关心算法问题中最坏的情况。外推部分也是线性的，因为我们为地图中的每个条目向数组中添加了一个条目。这是消耗额外存储器的操作的仅有的两个部分，并且因为它们都是线性的，所以算法作为一个整体被认为具有线性(即<code class="fe ly lz ma mb b">O(n)</code>)空间复杂度。</p><h1 id="7d14" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="4582" class="pw-post-body-paragraph mn mo iq ld b le lf mq mr lg lh mt mu li ne mw mx lk nf mz na lm ng nc nd lo ij bi translated">算法问题是关于识别何时使用特定的逻辑模式。为此，您需要熟悉各种模式和模式组合。</p><p id="dc11" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated">将字符映射到它们出现的频率是一种常见的模式，您应该对此非常熟悉。一旦你完全理解了这个策略和它背后的效率，你将开始认识到它可以被正确使用的其他领域。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="2d32" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated"><em class="om">最初发表于</em><a class="ae kc" href="https://codingbootcampguides.com/coding-interviews-sorting-characters-by-frequency-in-javascript" rel="noopener ugc nofollow" target="_blank"><em class="om">https://codingbootcampguides.com</em></a><em class="om">。</em></p><p id="732b" class="pw-post-body-paragraph mn mo iq ld b le nh mq mr lg ni mt mu li nj mw mx lk nk mz na lm nl nc nd lo ij bi translated"><em class="om">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="om">plain English . io</em></strong></a></p></div></div>    
</body>
</html>