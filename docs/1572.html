<html>
<head>
<title>Create Your Own Blockchain with JavaScript and Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript和Express创建自己的区块链</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-your-own-blockchain-in-express-4b81b50277b1?source=collection_archive---------7-----------------------#2021-04-04">https://javascript.plainenglish.io/create-your-own-blockchain-in-express-4b81b50277b1?source=collection_archive---------7-----------------------#2021-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7b21f8d47991e7721c81b5def72788e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wSzW7xAN_hcO7K2U"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@silverhousehd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">André François McKenzie</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="32c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很少有人问我，我们是否可以用JavaScript来构建一个区块链应用程序，当然，有很多资源可以用来构建这样一个应用程序。现在人们在听到有人在区块链工作后变得疯狂，让我告诉你这并没有那么复杂。这就像一个普通的项目，但有更多的规则要遵循，如果你没有犯任何错误，那么瞧，你领先于区块链。</p><h2 id="07d5" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">什么是区块链？</h2><p id="a7e4" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">当组合生成关于某些交易或一系列步骤的信息时，区块链是一组链接在一起的块。例如，无论何时您进行任何银行交易，无论是存钱还是取钱，您都是在根据您在银行中的最后存款金额执行操作，当任何人将它放到网上时，它需要与之前的块有一些关系。</p><p id="8cd8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哦，说得太多了，但是对于任何像你我这样的开发人员来说，我们如何理解这种情况并基于此创建一个应用程序。这是一个块将如何连接的演示。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/ebdd3011c062df70211030c2a7a03f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDWBmbB9stdZjg-ODTxGgg.png"/></div></div></figure><p id="24b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与流程图类似，我们将创建一个应用程序来演示相同的内容。</p><h2 id="809b" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">让我们搭一个积木吧</h2><p id="5d0e" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们将使用与前几篇文章相同的回购协议，<a class="ae jz" href="https://github.com/Piyush-Use-Personal/Role-Based-Access" rel="noopener ugc nofollow" target="_blank">这里的</a>是回购协议的链接。你可以在分支<a class="ae jz" href="https://github.com/Piyush-Use-Personal/Role-Based-Access/tree/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>中找到完整的代码。可以通过运行<strong class="kc io"><em class="mb">NPM run dev/node index</em></strong>打开服务器。</p><p id="52c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，创建一个区块链，但是要创建一个区块链，我们需要先有块，所以让我们创建一个名为<em class="mb">块的类。</em></p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/e7872503c1e9752fb8c8c99d68ab42c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3KfJSF_jkUzLDsFPQ89bg.png"/></div></div></figure><p id="2ccf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一行，我们导入一个包来为我们处理加密。下面的命令将为我们完成安装包的工作。</p><p id="5903" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">npm i crypto-js</code></p><p id="9975" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来谈谈我们创建的类，</p><p id="3cb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们在构建对象时有几个参数，即索引、时间戳、事务和precedingHash。</p><p id="18c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">index</code>是给一个块一个唯一的标识符，并通过索引提取我们需要的任何数据结构的块。</p><p id="c782" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">timestamp</code>是给一个特定的块一个创建时间，因为这个块不能被更新，我们不关心更新的时间和时间戳。</p><p id="33bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">transaction</code>是需要阻止的实际数据。例如，雇员总数或总金额或发送者详细信息等</p><p id="b1a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">precedingHash</code>是负责前一个块和当前块之间连接的字段，如图所示。</p><p id="6e71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">hash</code>是将与<code class="fe md me mf mg b">precedingHash</code>一起工作的领域，以确保我们处于正确的连接轨道上。</p><p id="9c0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，有一个函数<code class="fe md me mf mg b">computeHash</code>将使用SHA256算法为我们计算散列值。该算法将获取所有数据，以确保我们将生成的哈希代码的唯一性。</p><p id="49a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们已经创建了我们的块，让我们移动到链。</p><h2 id="b934" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">创建一个链</h2><p id="ee0c" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">同样，我们将创建一个链类，用更多的方法激活其中的块。下面是整个类的代码。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/76dd7931d259eda124ddd93cb821c23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxoAkr6MfCVYT6g2InceGQ.png"/></div></div></figure><p id="e61a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个更大的问题，但我会指引你一路走来。</p><p id="97b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们创建了一个空的构造函数来初始化几个字段，包括id[给出一个标识符]，name[给块起一个酷名字]，区块链[处理所有块的实际字段]，以及last difference[得到工作证明]。</p><p id="6944" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们进入代码的另一部分之前，我们先来看看<strong class="kc io">创世纪。</strong>对于任何区块链项目，我们需要用第一块来初始化链，因为第一块将表现得像一个构建块，并包含第一个散列，以便块的其余部分用作先前的散列。这里我们从前面的类中创建了一个block对象，并给它一个初始值作为参考。</p><p id="1c86" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们创建了一个带几个参数的<code class="fe md me mf mg b">create()</code></p><p id="de52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">name</code>是从API中给一个名字</p><p id="71aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">id</code>是从API中给出Id</p><p id="61aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和<code class="fe md me mf mg b">genesis</code>给初始genesis一个值</p><p id="6fc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们有<code class="fe md me mf mg b">obtainLatestBlock()</code>给我们进入链的最后一个块，这将帮助我们获得最后一个块的散列，我们将把它分配给链中的新元素。</p><p id="617e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而最重要的方法是<code class="fe md me mf mg b">addNewBlock()</code>向我们的链中添加一个新的block，该方法将block项作为参数。首先，我们将获得区块链的最新散列，并将其添加到它的<code class="fe md me mf mg b">precedingHash</code>中，然后我们将创建一个新散列并将其分配给hash，我们可以跳过这一步，因为我们已经将它添加到了block对象的构造函数中。但是，一旦这个方法运行，它将继续推动项目进入我们的块生态系统。</p><p id="e44f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们有<code class="fe md me mf mg b">checkChainValidity()</code>，我们不打算使用它，但它有助于块的验证。</p><h2 id="faff" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">添加控制器和路由</h2><p id="adb6" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们将增加3条路线，</p><p id="dc76" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了创造一个区块链，</p><pre class="lx ly lz ma gt mi mg mj mk aw ml bi"><span id="a95d" class="ky kz in mg b gy mm mn l mo mp">POST - /api/blockchain</span></pre><p id="460a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了得到区块链，</p><pre class="lx ly lz ma gt mi mg mj mk aw ml bi"><span id="a7b5" class="ky kz in mg b gy mm mn l mo mp">GET - /api/blockchain</span></pre><p id="e97f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要将新的子元素添加到链中，</p><pre class="lx ly lz ma gt mi mg mj mk aw ml bi"><span id="5055" class="ky kz in mg b gy mm mn l mo mp">POST - /api/blockchain/append</span></pre><p id="9e93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们为此创建一个控制器文件，</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/1704224f9367b050cf3d8468625d1a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34vy3pu18nsp6-vOfYhZxg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">controller file for the blockchain</figcaption></figure><p id="712e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们将导入我们创建的两个类，Block和区块链。之后，我们创建了一个名为FlippingCoin的控制器，您可以随意命名。但问题是我们需要关注3种方法:</p><ol class=""><li id="6ad5" class="mr ms in kc b kd ke kh ki kl mt kp mu kt mv kx mw mx my mz bi translated">创建新链</li><li id="d1eb" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx mw mx my mz bi translated">appendNewChild</li><li id="499f" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx mw mx my mz bi translated">获取链</li></ol><p id="2a2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在此之前，我们已经创建了一个引用链的全局对象，您也可以附加一个数据库或某种数据处理程序来存储数据。现在，为了简单起见，我跳过了数据存储部分。除了这三点，我们还必须验证方法，以验证链是否有正确的数据格式来创建。</p><p id="5d6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们正在调用相应的方法来使事情起作用。</p><p id="5ceb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们添加如下所示的路线</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/4fef01f9187e7d9c0f84755ba7a8f752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0yxhB-o0P1jiyRr_o9RDQ.png"/></div></div></figure><p id="1962" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们确保将方法映射到正确的路线。</p><h2 id="5cd6" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">让我们测试一下</h2><p id="5e03" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">让我们去路线哨所—/API/区块链</p><p id="cbd0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将为我们创造一个新的区块链，基于我们在创世纪的交易中传递的任何数据</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/bc360f9aab7515a761f564f12888b042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHsQbsbRzk0OZ74mU6vAdg.png"/></div></div></figure><p id="c92e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们去路由POST—/API/区块链/append</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/63ca5d20121ab78e26c97d4ae1eca846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fn15f9OA3BH82LXcvMCytg.png"/></div></div></figure><p id="2f76" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将在传递事务数据时将块添加到链中。</p><p id="1e5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，让我们转到路径GET—/API/区块链/来检查数据是否得到更新。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/d79a37fdd6a3dd74bf2e116b74cad998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9pvhtsBnTPVsCf0v-PM0Q.png"/></div></div></figure><p id="76da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们看到前一个块的散列连接到下一个块的前一个散列，这最终证明了我们的第一个图位于第一个位置。</p><h2 id="0bc7" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">结论</h2><p id="f450" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在这里，我要结束这篇文章。我们已经讨论了基本的用法和hash的基本原理。您可以在这里通过添加数据库、权限角色等等来构建东西。</p><p id="8b12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你一直支持我读到这里。祝你今天过得愉快。</p><p id="362c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mb">更多内容看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>