<html>
<head>
<title>Fauna and FQL for Firestore users</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firestore用户的动物群和FQL</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fauna-and-fql-for-firestore-users-dff6f8404eb8?source=collection_archive---------0-----------------------#2021-10-30">https://javascript.plainenglish.io/fauna-and-fql-for-firestore-users-dff6f8404eb8?source=collection_archive---------0-----------------------#2021-10-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/172f28c47bff399e062d7e4d454b9754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhVAe0H3tzqJSc2LYvNz-Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="bde5" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">了解动物群和Firestore之间的差异，以及如何从Firestore迁移到动物群</h2></div><p id="f22f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">Fauna和Firestore是非常相似的数据库，都提供即时可伸缩性和相当简单的查询方式，但仍有一些关键的区别。在这篇文章中，我们将看看这些差异，以及如何从Firestore迁移到动物群和动物群的查询语言(FQL)。您可能希望迁移，因为Fauna的查询语言、灵活性或多区域功能。即使您还不知道是否要迁移，本文也会提供一些关于差异的信息。</p><h1 id="879d" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">背景</h1><p id="23bb" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated"><a class="ae mg" href="https://cloud.google.com/firestore" rel="noopener ugc nofollow" target="_blank"> Firestore </a>是谷歌在2017年创建的数据库。它是前两个数据库Firebase Realtime DB和Cloud Datastore的继承者。它被归入Firebase类别组，提供与不同Firebase服务的集成，尽管它也通过Google Cloud提供。Firestore的主要卖点是它易于使用，即使没有服务器，并且具有实时功能。它还提供基于读取、数据存储和写入的简单定价。</p><figure class="mh mi mj mk gt ip gh gi paragraph-image"><div class="ab gu cl ml"><img src="../Images/f5b58c179941bccca0b8b79275bf6690.png" data-original-src="https://miro.medium.com/v2/format:webp/1*a2Da_CQHUsSKTCTRI2tYhQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Firestore logo</figcaption></figure><p id="d7c0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><a class="ae mg" href="https://fauna.com/" rel="noopener ugc nofollow" target="_blank">动物群</a>是由几位前Twitter工程师在2012年开发的数据库，用于解决现有NoSQL数据库的可扩展性问题。如果你不想学习另一种查询语言，那么Fauna提供了一种简单的查询语言FQL和GraphQL服务。在没有后端的情况下，也可以很容易地使用动物群，并专注于在尽可能保持可扩展性的同时做到这一点。</p><p id="82a0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">凡世通和动物群有许多相似的特征和一些关键的区别。它们都在云机器上抽象，以提供使用它们的简单方式，甚至在跨区域复制上抽象。它们都提供客户端SDK和实时功能。他们的查询语言有点不同，因为Fauna有一个更全面的设置，允许您通过他们的查询语言在数据库上进行某些计算。这可以通过减少往返查询的需求来提高速度。Firestore的查询语言主要由CRUD函数组成。另一个关键区别是，在查询能力和可伸缩性方面，Fauna更加灵活。现在您已经了解了每个数据库的背景以及它们之间的区别，让我们更深入地了解一下。</p><h1 id="6b86" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">比较</h1><h2 id="f8e8" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">查询语言</h2><p id="272e" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">既然我们已经强调了查询语言中的一些差异，让我们更仔细地看看这些差异。Firestore有两种不同的数据查询方式，函数链接和通过参数传递数据。在V9更新之前，Firestore的SDK主要使用函数链。例如，一个基本的读取查询可能如下所示:</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="688d" class="mq lk iy nd b gy nh ni l nj nk">const data = (await db.collection("cities").doc("SF").get()).data()</span></pre><p id="b63d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上面的例子通过链接方法函数来访问主数据库对象，然后是集合和文档。如果您使用服务器端SDK，它仍然是这样工作的。然而，在客户端web SDK的更新版本中，有一种通过将选项作为参数传递来进行查询的方法。</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="8250" class="mq lk iy nd b gy nh ni l nj nk">const data = (await getDoc(doc(db, "collectionName", "documentName"))).data()</span></pre><p id="7224" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">Fauna只有一个通用SDK和一个查询风格，类似于Firestore V9 SDK的一个更强大的版本。要执行操作，需要在其他函数中嵌套不同的函数。例如，要阅读文档，您可以这样做:</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="be70" class="mq lk iy nd b gy nh ni l nj nk">const data = (await db.query(<br/>    q.Get(q.Ref(q.Collection('collectionName'), 'documentName'))<br/>)).data</span></pre><p id="4f70" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">每个函数的命名空间都在q下面。这个例子中使用的函数不止这些。想要完整的列表，你可以看看《动物群》的备忘单。如前所述，Fauna还提供了一个GraphQL API，但为了简洁起见，我就不赘述了。</p><p id="e762" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这两种查询语言都很容易使用，并且您可以使用这两种语言做您需要的大多数事情，尽管Fauna的提供了更多在数据库上运行事情的方法来防止往返。</p><h2 id="d596" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">指数</h2><p id="b415" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">索引是Firestore和动物群有很大不同的地方。Firestore选择的方法是自动为文档中的所有字段创建索引，并允许使用这些索引进行查询，而不必担心它们。对于包含多个字段的索引，您必须手动创建一个复合查询。这种方法使查询变得容易，但最终会增加用户的成本，因为Firestore即使在不需要索引时也会创建索引，这会占用更多的存储空间。</p><p id="37c7" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">相比之下，虽然它提供了一个易于使用的仪表板和FQL函数来创建索引，但它让您手动创建索引。动物群还为索引提供了更多的功能，比如交叉集合索引。</p><h2 id="d56c" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">交易和一致性</h2><p id="9cc0" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">Firestore和Fauna都提供非常一致的数据库操作。动物群使用<a class="ae mg" href="https://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf" rel="noopener ugc nofollow" target="_blank">卡尔文</a>，这使它能够在全球复制数据，具有很强的一致性。Firestore不使用高级复制系统，尽管它仍然提供强大的一致性。一致事务的最大区别是，如前所述，Fauna允许您直接在数据库上做更多的事情。这使得您可以在服务器响应数据的过程中减少数据变化的时间。因此，在这种情况下，就可靠地运行开箱即用的一致事务而言，动物群无疑更好，但在这种情况下，两者都相当好。</p><h2 id="a80d" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">定价</h2><p id="f1c4" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">Firestore和Fauna的定价在某些方面相似，但在其他方面却有很大不同。它们都按读取、写入和存储进行定价，尽管Fauna也对计算操作进行定价，计算操作是在它们的服务器上完成的操作。两者都提供免费层，所以你可以尝试任何一个，不需要支付任何费用。</p><p id="f331" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">Firestore costs定价因您所在的地区而异。对于典型的单区域配置，Firestore的读取成本为每百万文档0.36美元，写入成本为每百万文档1.08美元，存储成本为每千兆字节0.108美元。对于多区域配置，Firestore的读取成本为每百万文档0.6美元，写入成本为每百万文档1.8美元，存储成本为每千兆字节0.18美元。</p><p id="9d9f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">因为默认情况下，动物群是全球性的，所以它有更一致的定价，尽管如果您将所有数据存储在欧洲，动物群的所有成本会乘以1.2倍，如果您将一些数据存储在欧洲，则会乘以1.1倍。每百万个文档读取成本为0.45美元，每百万个文档写入成本为2.25美元，每百万次计算操作成本为2.03美元，每千兆字节存储成本为0.23美元。</p><p id="aaf6" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">从上面可以看出，它们的成本相当接近。动物在表面上可能更贵，但只是有时更贵。这是因为Fauna提供了内置压缩和更便宜的查询等功能。最终，你需要根据自己的需求做更多的研究，找出哪种更便宜。</p><h2 id="6515" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">限制</h2><p id="631b" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">这两个数据库在吞吐量和大小上都有一些限制。对于Firestore，文档有多种限制。一个是文档必须是1mb或更小，并且每秒钟不能改变超过一次。另一个问题是，每秒钟对数据库执行的写操作不能超过10，000次，这些写操作总共包含的数据不能超过10兆字节。此外，文档结构图中的嵌套数据最大深度为20，尽管您可以通过将它转换为JSON字符串来解决这个问题。在他们的<a class="ae mg" href="https://firebase.google.com/docs/firestore/quotas#limits" rel="noopener ugc nofollow" target="_blank">限制</a>页面上显示了许多其他限制，但这些限制与大多数人最相关。动物群也有限制，尽管更少。文档大小上限为8兆字节，事务大小上限为16兆字节，索引条目必须保持在64，000字节以下。更多信息，你可以看看他们的<a class="ae mg" href="https://docs.fauna.com/fauna/current/api/limits" rel="noopener ugc nofollow" target="_blank">限制</a>页面。</p><h2 id="2178" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">结论</h2><p id="fe6d" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">动物群和Firestore在许多方面非常相似，但在其他方面有着重要的不同。两者都很容易使用，虽然动物群可能更强大。如果你以前使用过Firestore并且对动物群感兴趣，请继续阅读为以前的Firestore用户设计的FQL(动物群查询语言)介绍。</p><h1 id="16e3" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">来自Firestore的FQL介绍</h1><p id="8b44" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">正如您在比较的查询语言部分所看到的，这两个数据库的查询方式之间可能有相当多的差异，尤其是如果您习惯于使用函数链Firestore SDK的话。幸运的是，FQL是相当直观的，所以你应该不会有太多的学习困难。一个基本的FQL查询只是<code class="fe nl nm nn nd b">db.query()</code>，没有传递任何东西给它。为了处理查询，你将不同的函数传递给查询函数，比如<code class="fe nl nm nn nd b">q.Get</code>或<code class="fe nl nm nn nd b">q.Create</code>，为了将正确的信息传递给那些操作，比如什么文档，你嵌套了像<code class="fe nl nm nn nd b">q.Ref</code>和<code class="fe nl nm nn nd b">q.Collection</code>这样的函数。对于习惯Firestore只在文档上运行<code class="fe nl nm nn nd b">.get()</code>的人来说，这听起来可能有些冗长，但它可以更优雅，并且您可以做更多。</p><h2 id="5a7f" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">创建文档</h2><p id="f163" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">Fauna提供了一个功能<code class="fe nl nm nn nd b">q.Create</code>，可以像Firestore的<code class="fe nl nm nn nd b">add</code>功能一样创建文档。您只需传递一个集合和数据，它将返回对新文档的引用以及新文档的数据。</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="db1b" class="mq lk iy nd b gy nh ni l nj nk">const result = await db.query(<br/>    q.Create(<br/>        q.Collection("collectionName"),<br/>        {       <br/>            data: {<br/>                field: "fieldValue",<br/>                fruit: "bananas"<br/>            },     <br/>        },<br/>    )<br/>)<br/>// Get reference to result<br/>console.log(result.ref)<br/>// Get new result data<br/>console.log(result.data)</span></pre><p id="570b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">Firestore的对等物是</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="a538" class="mq lk iy nd b gy nh ni l nj nk">const result = await addDoc(collection(db, "collectionName"), {<br/>    field: "fieldValue",<br/>    fruit: "bananas"<br/>});</span><span id="5278" class="mq lk iy nd b gy no ni l nj nk">// Get reference to result<br/>console.log(result);</span></pre><p id="7959" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这适用于在不指定id的情况下创建文档，但是您也可以通过使用带有集合和ID的<code class="fe nl nm nn nd b">q.Ref</code>而不是<code class="fe nl nm nn nd b">q.Collection</code>来更新现有文档。</p><h2 id="e64f" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">获取文档</h2><p id="ac87" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">如果您只是通过ID和集合名称获取文档，那么实现起来非常简单。</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="2a2c" class="mq lk iy nd b gy nh ni l nj nk">const data = (await db.query(<br/>    q.Get(q.Ref(q.Collection("collectionName"), "documentName"))<br/>)).data</span></pre><p id="b169" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">正如您所看到的，有一个查询函数包含一个get查询，并向其传递了一个ref。这相当于</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="8ad4" class="mq lk iy nd b gy nh ni l nj nk">const data = (await db.collection("collectionName").doc("documentName").get()).data()</span></pre><p id="bb5b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">或者</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="85c3" class="mq lk iy nd b gy nh ni l nj nk">const data = (await getDoc(doc(db, "collectionName", "documentName"))).data()</span></pre><h2 id="93b2" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">设置/更新文档</h2><p id="2044" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">为此，Fauna提供了两种内置方法，<code class="fe nl nm nn nd b">q.Replace</code>用于破坏性替换，而<code class="fe nl nm nn nd b">q.Update</code>用于在不改变整个文档的情况下更新特定字段。这等同于Firestore <code class="fe nl nm nn nd b">set</code>和<code class="fe nl nm nn nd b">update</code>功能。</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="49aa" class="mq lk iy nd b gy nh ni l nj nk">await db.query(<br/>    q.Replace(<br/>        q.Ref(q.Collection("collectionName"), "documentName"),<br/>        {        <br/>            data: {<br/>                field: "fieldValue", fruit: "still bananas"<br/>            }<br/>        }<br/>    )<br/>)<br/>await db.query(<br/>    q.Update(<br/>        q.Ref(q.Collection("collectionName"), "documentName"),<br/>        {        <br/>            data: {<br/>                fruit: "still bananas"<br/>            }<br/>        }<br/>    )<br/>)</span></pre><p id="2185" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这相当于</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="3bd2" class="mq lk iy nd b gy nh ni l nj nk">// v8 web or Node</span><span id="7a2e" class="mq lk iy nd b gy no ni l nj nk">await db.collection("collectionName").doc("documentName").set({<br/>    field: "fieldValue",<br/>    fruit: "still bananas"<br/>});</span><span id="949d" class="mq lk iy nd b gy no ni l nj nk">await db.collection("collectionName").doc("documentName").update({<br/>    fruit: "still bananas"<br/>});</span><span id="f65d" class="mq lk iy nd b gy no ni l nj nk">// v9 web</span><span id="3486" class="mq lk iy nd b gy no ni l nj nk">await setDoc(doc(db, "collectionName", "documentName"), {<br/>    field: "fieldValue",<br/>    fruit: "still bananas"</span><span id="494b" class="mq lk iy nd b gy no ni l nj nk">});</span><span id="0a7b" class="mq lk iy nd b gy no ni l nj nk">await updateDoc(doc(db, "collectionName", "documentName"), {<br/>    fruit: "still bananas"<br/>});</span></pre><p id="520b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">目前，如果您想用<code class="fe nl nm nn nd b">merge: true</code>模拟<code class="fe nl nm nn nd b">set</code>的行为，如果文档不存在，则创建一个文档，您可以使用运行查询来检查文档是否存在，如果不存在，则使用<code class="fe nl nm nn nd b">q.If</code>创建文档。</p><h2 id="246b" class="mq lk iy bd ll mr ms dn lp mt mu dp lt kw mv mw lv la mx my lx le mz na lz nb bi translated">删除文档</h2><p id="07ae" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">删除一个有动物群的文档就像获取一个文档一样，但是用<code class="fe nl nm nn nd b">q.Delete</code>代替<code class="fe nl nm nn nd b">q.Get</code>。</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="05f6" class="mq lk iy nd b gy nh ni l nj nk">await client.query(<br/>    q.Delete(q.Ref(q.Collection("collectionName"), "documentName"))<br/>);</span></pre><p id="6828" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这相当于</p><pre class="mh mi mj mk gt nc nd ne nf aw ng bi"><span id="6e94" class="mq lk iy nd b gy nh ni l nj nk">// v8 web or node</span><span id="7401" class="mq lk iy nd b gy no ni l nj nk">await db.collection("collectionName").doc("documentName").delete()</span><span id="a7c2" class="mq lk iy nd b gy no ni l nj nk">// v9 web</span><span id="1df9" class="mq lk iy nd b gy no ni l nj nk">await updateDoc(doc(db, "collectionName", "documentName"))</span></pre><h1 id="86a9" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">结论</h1><p id="22c3" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">动物群是Firestore的一个很好的替代品，具有更强大的查询API和其他优势。它们是非常相似的数据库，很容易从Firestore迁移到动物群。我希望这篇文章已经启发了你动物群和Firestore之间的区别，以及FQL代码如何转化为Firestore代码，感谢您的阅读。</p><p id="9536" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><em class="np">更多内容看</em><a class="ae mg" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kp iz"><em class="np">plain English . io</em></strong></a></p></div></div>    
</body>
</html>