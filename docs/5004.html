<html>
<head>
<title>JavaScript Currying: A Practical Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Currying:一个实际例子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-currying-practical-example-512cf1099e81?source=collection_archive---------2-----------------------#2021-10-10">https://javascript.plainenglish.io/javascript-currying-practical-example-512cf1099e81?source=collection_archive---------2-----------------------#2021-10-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8afc88db20fafad4bcfe9c5d558c088d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q_VkUwAWg3piIEvG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Emile Perron</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="116c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在数学和计算机科学中，currying是一种将带有多个参数的函数转换成一系列带有单个参数的函数的技术。</p><p id="3886" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的add函数接受三个参数并返回它们的和。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5c9a" class="lh li in ld b gy lj lk l ll lm">const add = (a,b,c) =&gt; {<br/>   return a+b+c<br/>}</span><span id="0bf9" class="lh li in ld b gy ln lk l ll lm">add(1,2,3) // 6</span></pre><p id="d25c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果三个参数不在同一个范围内呢？如果我们可以像在校车上挑选孩子一样挑选他们呢？</p><p id="4a4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，<strong class="kc io"> <em class="lo">让我们咖喱一下</em> </strong>上面的功能。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="efaa" class="lh li in ld b gy lj lk l ll lm">const add = a =&gt; b =&gt; c =&gt; a+b+c<br/>add(1)(2)(3) // 6</span></pre><h2 id="d84a" class="lh li in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">切线:箭头函数速记</h2><p id="f2be" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">以上，如果你想知道，有<strong class="kc io">隐含返回语句</strong>。例如，我们可以像这样编写前面的add函数。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0166" class="lh li in ld b gy lj lk l ll lm">// const add = (a,b,c) =&gt; {<br/>//    return a+b+c<br/>// }</span><span id="2911" class="lh li in ld b gy ln lk l ll lm">const add = (a,b,c) =&gt; a+b+c</span><span id="b16f" class="lh li in ld b gy ln lk l ll lm">add(1,2,3) // 6</span></pre><p id="6651" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们不需要主体括号和return关键字。</p><p id="20fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们不能使用大括号，如何返回一个<strong class="kc io">对象文字</strong>？我们可以用括号来括起来。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1c61" class="lh li in ld b gy lj lk l ll lm">const obj = (a,b,c) =&gt; ({a:a, b:b, c:c})<br/>obj(1,2,3) // { a: 1, b: 2, c: 3 }</span></pre><p id="7833" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在以下两个版本的curried function中，你更喜欢哪一个？</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="af48" class="lh li in ld b gy lj lk l ll lm">const addNew = a =&gt; b =&gt; c =&gt; a+b+c</span><span id="8a6b" class="lh li in ld b gy ln lk l ll lm">// vs</span><span id="77f7" class="lh li in ld b gy ln lk l ll lm">const addOld = (a) =&gt; {<br/>  <strong class="ld io">return</strong> (b)=&gt; {<br/>    <strong class="ld io">return</strong> (c)=&gt; {<br/>      <strong class="ld io">return</strong> a+b+c<br/>    }<br/>  }<br/>}</span></pre><p id="b3ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一种可能最初看起来可读性较差，但是一旦我们习惯了，我们的代码会看起来更优雅。</p><h2 id="bdf9" class="lh li in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">一流的功能</h2><p id="06a6" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">回到currying之前还有一个话题。</p><blockquote class="ml mm mn"><p id="71b1" class="ka kb lo kc b kd ke kf kg kh ki kj kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated">当一种编程语言中的<strong class="kc io">函数</strong>被视为任何其他变量时，该语言被称为具有<strong class="kc io">一级函数</strong>。— MDN网络文档</p></blockquote><p id="5307" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我第一次遇到回调时，这个概念产生了对编程的不同理解。我认为一级函数的概念是OOP人们抱怨JavaScript怪异的主要原因。我们可以像传递其他变量或对象一样传递函数。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="dfed" class="lh li in ld b gy lj lk l ll lm">const add = (a,b) =&gt; a+b<br/>const sub = (a,b) =&gt; a-b</span><span id="4d17" class="lh li in ld b gy ln lk l ll lm">const calc = (a, b, cb) =&gt; cb(a,b)</span><span id="c547" class="lh li in ld b gy ln lk l ll lm">calc(3,4, add) // 7<br/>calc(3,4, sub) // -1</span></pre><p id="fce9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太解放了！</p><h2 id="2f34" class="lh li in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated"><strong class="ak">高阶</strong> - <strong class="ak">阶函数</strong></h2><p id="e491" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">顺便说一下，上面例子中的calc函数是一个高阶函数。</p><blockquote class="ml mm mn"><p id="8009" class="ka kb lo kc b kd ke kf kg kh ki kj kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated">对其他<strong class="kc io">函数</strong>进行操作的<strong class="kc io">函数</strong>，无论是将其作为自变量还是将其返回，都被称为<strong class="kc io">高阶</strong> - <strong class="kc io">函数</strong>。<strong class="kc io">——</strong>雄辩的JavaScript。</p></blockquote><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="df94" class="lh li in ld b gy lj lk l ll lm">function getName(name) {<br/>  return function greet(){<br/>    console.log('Hello, ', name)<br/>  }<br/>}</span><span id="ed48" class="lh li in ld b gy ln lk l ll lm">const <strong class="ld io">greet</strong> = getName('Karthick')<br/>greet() // Hello,  Karthick</span></pre><p id="4f98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们从getName得到的问候是我们在下一行调用的函数。我们显然可以用arrow函数速记来转换上面的内容。试试看。</p><h2 id="fa3e" class="lh li in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">部分应用</h2><p id="15be" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">回到问题上来。如果参数不在同一个范围内会怎样？我们也明白我们可以像传递变量一样传递函数。</p><p id="cb67" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有一种解决方案叫做局部应用。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7f83" class="lh li in ld b gy lj lk l ll lm">function add(x, y, z){<br/>  return x + y + z;<br/>}</span><span id="cb4f" class="lh li in ld b gy ln lk l ll lm">const plus5 = add.bind(this, 5)<br/>console.log(plus5(3,9)) // 17</span><span id="eedd" class="lh li in ld b gy ln lk l ll lm">const plus12 = plus5.bind(this,7)<br/>plus12(9) // 21</span></pre><p id="5210" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们通过将5绑定到第一个参数来构建一个名为plus5的函数。现在,<strong class="kc io"> plus5 </strong>函数可以为结果多带两个参数。</p><p id="085a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过绑定7作为plus5的第一个参数，从组合的<strong class="kc io"> plus5 </strong>中选择组合另一个函数。这给了我们<strong class="kc io">加12 </strong>。</p><p id="3429" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是使用bind的部分应用程序。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="025e" class="lh li in ld b gy lj lk l ll lm">bind(thisArg, arg1, ... , argN)</span></pre><h2 id="9b3f" class="lh li in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">Currying:构造函数的更简单方法</h2><p id="24cb" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">我们看到了一个使用<strong class="kc io"> <em class="lo">绑定</em> </strong>函数部分应用参数的例子。</p><p id="7bcf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于改变<strong class="kc io"> <em class="lo">上下文</em> </strong>的方法call、apply、bind与Arrow函数无关。</p><p id="1cdd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用curry来试试上面的例子。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e156" class="lh li in ld b gy lj lk l ll lm">const add = x =&gt; y =&gt; z =&gt; {<br/>  return x + y + z;<br/>}</span><span id="9a5a" class="lh li in ld b gy ln lk l ll lm">const add5 = add(5)<br/>const add12 = add5(7)<br/>add12(7) // 19</span></pre><p id="6966" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这要简单得多，根本不用担心上下文。</p><p id="cce5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，看看上面例子中的<strong class="kc io"> <em class="lo">闭包</em> </strong>是如何工作的。当我们调用add5(7)时，在前面的执行中传递的值5在作用域链中被记住了！</p><p id="e3ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更多关于闭包<a class="ae jz" href="https://karthickragavendran.medium.com/javascript-understanding-closures-with-the-dragon-warrior-f5ed13b7df94" rel="noopener">的信息，请点击</a>。</p><h1 id="0343" class="mr li in bd lp ms mt mu ls mv mw mx lv my mz na ly nb nc nd mb ne nf ng me nh bi translated">Currying:实际例子</h1><p id="e14c" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">编造的例子够多了。让我们把这个<strong class="kc io"> <em class="lo">功能组合</em> </strong>技术好好利用起来。</p><p id="f4be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码是从redux切片中提取的。extraReducers中的属性将在解析thunks时被调用。</p><p id="a48a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">[sign up . pending . tostring()]</strong>只是我们从redux操作中获得的动态属性键。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0965" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常多余。</p><p id="11a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以创建一个函数，使fulfilled、loading和error可选，默认值为false。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="3d79" class="lh li in ld b gy lj lk l ll lm">const setStatus = ({fulfilled = false,loading = false,error = false}) =&gt; {<br/>  console.log(fulfilled, loading, error)<br/>}</span><span id="e61d" class="lh li in ld b gy ln lk l ll lm">setStatus({fulfilled:true}) // true, false, false</span></pre><p id="0a4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很好。但是状态对象在哪里更新呢？让<strong class="kc io"> <em class="lo">柯里</em> </strong>这个函数带着状态和动作对象。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a391" class="lh li in ld b gy lj lk l ll lm">const setStatus = <strong class="ld io">(</strong>state, action<strong class="ld io">) =&gt;</strong> <strong class="ld io">(</strong>{fulfilled = false,loading = false,error = false}<strong class="ld io">)</strong> <strong class="ld io">=&gt;</strong> {<br/>  state.fulfilled = fulfilled<br/>  state.loading = loading<br/>  state.error = error}</span><span id="01c9" class="lh li in ld b gy ln lk l ll lm">setStatus(state)({fulfilled:true}) <br/>// This will set state.fulfilled to true and remaining to false</span></pre><p id="166d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，早期的extraReducer将如下所示。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="380d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能认为,{fullfilled: true}对象可以作为第二个参数传递给setStatus函数。为什么要奉承呢？</p><p id="9bfa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">魔法还没有完成。</p><h2 id="0d65" class="lh li in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">复试</h2><p id="7cfe" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">让我们看看回调在JavaScript中是如何工作的。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9f93" class="lh li in ld b gy lj lk l ll lm">onClick(<strong class="ld io">updateState</strong>) // updateState is a function/callback</span><span id="e7dc" class="lh li in ld b gy ln lk l ll lm">// We can pass arguments too right? JavaScript should not complain.</span><span id="4af5" class="lh li in ld b gy ln lk l ll lm">onClick(<strong class="ld io">updateState('Hello!')</strong>)  // Wrong. JavaScript will immediately execute updateState and won't wait for the click.</span><span id="cec6" class="lh li in ld b gy ln lk l ll lm">onClick(<strong class="ld io">()=&gt;</strong> <strong class="ld io">updateState('Hello!')</strong>)  // Good.</span></pre><p id="1029" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果onClick提供的参数与updateState传递的参数相同怎么办？</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="756c" class="lh li in ld b gy lj lk l ll lm">onClick(<strong class="ld io">(state)=&gt;</strong> <strong class="ld io">updateState(state)</strong>)  // Okay...</span></pre><p id="5c02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，这看起来非常类似于</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4156" class="lh li in ld b gy lj lk l ll lm">onClick(<strong class="ld io">()=&gt;</strong> <strong class="ld io">updateState()</strong>)  // Yes...</span></pre><p id="dcf0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有一个简写。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f0d1" class="lh li in ld b gy lj lk l ll lm">onClick(<strong class="ld io">()=&gt;</strong> <strong class="ld io">updateState()</strong>)  </span><span id="4d27" class="lh li in ld b gy ln lk l ll lm">// can be written as <br/>onClick(<strong class="ld io">updateState</strong>)</span><span id="90ca" class="lh li in ld b gy ln lk l ll lm">// because they share the same arguments (which is nothing)!</span><span id="48de" class="lh li in ld b gy ln lk l ll lm">// So,<br/>onClick(<strong class="ld io">(state)=&gt;</strong> <strong class="ld io">updateState(state)</strong>)</span><span id="86da" class="lh li in ld b gy ln lk l ll lm">// can be written as<br/>onClick(<strong class="ld io">updateState</strong>)</span></pre><p id="988c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没错。那是一件事。</p><p id="a502" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我切换一下setStatus上函数的顺序。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="dd28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在可以简化extraReducer中的属性。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0d86" class="lh li in ld b gy lj lk l ll lm">fulfilled: <strong class="ld io">(state,action) =&gt; </strong>setStatus({ fulfilled: true })<strong class="ld io">(state,action)</strong></span></pre><p id="a803" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可以写成</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a829" class="lh li in ld b gy lj lk l ll lm">fulfilled: setStatus({ fulfilled: true })</span></pre><p id="fdcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多酷啊。</p><p id="6f40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看extraReducers属性的区别。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="59f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来很干净。这表明了意图。我们可以走得更远，但是抽象是有代价的。过一段时间后，我们应该能够理解自己的代码。</p><p id="9002" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，使用这些函数式编程技术来寻找抽象中的最佳点有助于我们编写优雅且可读的代码。</p><p id="3334" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你。下次见。</p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/5c22cc1879a352912ee448111192a692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0K6OJ1XwGVMiln2479gtng.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">currying example</figcaption></figure><p id="10fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lo">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lo">plain English . io</em></strong></a></p></div></div>    
</body>
</html>