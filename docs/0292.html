<html>
<head>
<title>Understanding The Bind Method in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的绑定方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-the-bind-method-in-javascript-3e51d2b9c35a?source=collection_archive---------8-----------------------#2021-01-17">https://javascript.plainenglish.io/understanding-the-bind-method-in-javascript-3e51d2b9c35a?source=collection_archive---------8-----------------------#2021-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="64f6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过示例了解JavaScript中的bind方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a6e61faba701177cadba927aa768ef18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlHus32W34rI1w9sAEjuIw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image created with ❤️️ By <a class="ae kv" href="https://mehdiouss315.medium.com/" rel="noopener">author</a>.</figcaption></figure><h1 id="56c6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="fa2d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在JavaScript中，函数有自己的原型对象<code class="fe mk ml mm mn b">Function</code>。这个原型有很多我们可以使用的方法和属性，而<strong class="lq ir"> bind </strong>方法就是其中之一。它返回新的函数，将它们自己的关键字<code class="fe mk ml mm mn b">this</code>设置为提供的值。我们将在下面用一些例子来解释。</p><p id="b44d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在本文中，我们将通过一些实例来学习JavaScript中的bind方法。让我们开始吧。</p><h1 id="945d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">该绑定方法</h1><p id="fe29" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript中的方法<code class="fe mk ml mm mn b">bind()</code>返回一个新函数，当调用这个函数时，它的<code class="fe mk ml mm mn b">this</code>关键字被设置为一个特定的值。新返回的函数带有一个给定的参数序列，该序列位于调用它时提供的任何参数之前。</p><p id="e2e5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">下面的例子说明了<code class="fe mk ml mm mn b">bind()</code>方法的语法:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="3ef3" class="mx kx iq mn b gy my mz l na nb"><strong class="mn ir">fn.bind(thisArg[, arg1[, arg2[, ...]]])</strong></span></pre><p id="9bb5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在这个语法中，方法<code class="fe mk ml mm mn b">bind()</code>返回函数<code class="fe mk ml mm mn b">fn</code>的副本，带有特定的<code class="fe mk ml mm mn b">this</code>值(<code class="fe mk ml mm mn b">thisArg</code>)和参数(<code class="fe mk ml mm mn b">arg1</code>、<code class="fe mk ml mm mn b">arg2</code>、…)。</p><h1 id="618b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用bind方法进行绑定</h1><p id="c13d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">方法<code class="fe mk ml mm mn b">bind()</code>创建一个新的<em class="nc">绑定函数</em>，它是一个<em class="nc">外来函数对象</em>，包装了原来的函数对象。</p><p id="306e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">让我们看看下面的例子:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="4c36" class="mx kx iq mn b gy my mz l na nb">const user = {<br/> name: "Mehdi",<br/> getName: function() {<br/>  return this.name;<br/>}<br/>};</span><span id="8330" class="mx kx iq mn b gy nd mz l na nb">const unboundFunc = user.getName;<br/>console.log(unboundFunc()); <br/>// The function gets invoked at the global scope<br/>// expected output: undefined</span></pre><p id="2797" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">如您所见，<code class="fe mk ml mm mn b">unboundFunc</code>返回的是<code class="fe mk ml mm mn b">undefined</code>而不是<code class="fe mk ml mm mn b">Mehdi</code>。这是因为<code class="fe mk ml mm mn b">unboundFunc</code>是与用户对象(在全局范围内)分开调用和执行的，其中<code class="fe mk ml mm mn b">this</code>的值与用户对象内<code class="fe mk ml mm mn b">this</code>的值不同。</p><p id="3851" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">为了解决这个问题，我们需要使用方法<code class="fe mk ml mm mn b">bind()</code>绑定函数<code class="fe mk ml mm mn b">getName</code>。</p><p id="d134" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">下面的例子可以做到这一点:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="461c" class="mx kx iq mn b gy my mz l na nb">const user = {<br/> name: "Mehdi",<br/> getName: function() {<br/> return this.name;<br/>}<br/>};</span><span id="dbb2" class="mx kx iq mn b gy nd mz l na nb">const unboundFunc = user.getName;<br/>console.log(unboundFunc()); <br/>// The function gets invoked at the global scope<br/>// expected output: undefined</span><span id="5bac" class="mx kx iq mn b gy nd mz l na nb">const boundFunc = <strong class="mn ir">unboundFunc.bind(user)</strong>;<br/>console.log(boundFunc());<br/>// expected output: Mehdi</span></pre><p id="da8b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在这种情况下，方法<code class="fe mk ml mm mn b">bind</code>创建了一个新函数，当这个函数被调用时，它的<code class="fe mk ml mm mn b">this</code>关键字被设置为对象<code class="fe mk ml mm mn b">user</code>中<code class="fe mk ml mm mn b">this</code>的值。这就是为什么我们得到名称<code class="fe mk ml mm mn b">Mehdi</code>作为输出。</p><h1 id="a900" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">从不同的对象借用方法</h1><p id="b4f8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设我们有一个名为Mehdi的用户的对象<code class="fe mk ml mm mn b">user1</code>,还有一个名为John的用户的对象<code class="fe mk ml mm mn b">user2</code>。两个对象都有一个方法<code class="fe mk ml mm mn b">getAge</code>。</p><p id="b003" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">看看下面的例子:</p><p id="a67a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><em class="nc">用户1: </em></p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="015a" class="mx kx iq mn b gy my mz l na nb">const user1 = {<br/>  name: "Mehdi",<br/>  getAge: function(age){<br/>    return this.name + " is " + age + " years old."<br/>  }<br/>}</span></pre><p id="4339" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><em class="nc">用户2: </em></p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="322c" class="mx kx iq mn b gy my mz l na nb">const user2 = {<br/>  name: "John",<br/>  getAge: function(age){<br/>    return this.name + " is " + age + " years old."<br/>  }<br/>}</span></pre><p id="0934" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">现在我们可以使用方法<code class="fe mk ml mm mn b">bind()</code>将<code class="fe mk ml mm mn b">getAge</code>从用户2借用到用户1。这里有一个例子:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="f480" class="mx kx iq mn b gy my mz l na nb">let user = <strong class="mn ir">user1.getAge.bind(user2, 22)</strong>;<br/>console.log(<strong class="mn ir">user()</strong>);</span><span id="50c7" class="mx kx iq mn b gy nd mz l na nb">// output: <strong class="mn ir">John</strong> is 22 years old.</span></pre><p id="880c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">如您所见，方法<code class="fe mk ml mm mn b">bind()</code>让我们能够借用一个对象的方法，而无需复制该方法并在两个不同的地方维护它。</p><h1 id="0d6c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="c715" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">bind方法是JavaScript的一个强大而有用的特性。它创建一个新函数，该函数将特定的<code class="fe mk ml mm mn b">this</code>设置为所提供的值。除此之外，它还允许一个对象从另一个对象借用一个方法，而不用复制那个方法。</p><h1 id="258c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">更多阅读</h1><p id="ed31" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="nc">如果你对JavaScript和web开发相关的更有用的内容感兴趣，也可以</em> <a class="ae kv" href="https://mehdiouss.ck.page/" rel="noopener ugc nofollow" target="_blank"> <em class="nc">订阅</em> </a> <em class="nc">我的快讯。</em></p><p id="aa3b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><em class="nc">下面的链接是另一篇有用的文章:</em></p><div class="ne nf gp gr ng nh"><a href="https://medium.com/javascript-in-plain-english/5-useful-css-tips-every-web-developer-should-know-5c19a088620e" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">每个Web开发人员都应该知道的5个有用的CSS技巧</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">作为一名web开发人员，你应该知道的一些CSS技巧。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div></div></div>    
</body>
</html>