<html>
<head>
<title>How to Track Changes in ngDoCheck with KeyValueDiffer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用KeyValueDiffer跟踪ngDoCheck中的更改</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-track-changes-in-ngdocheck-with-keyvaluediffer-6667ed7a1dad?source=collection_archive---------5-----------------------#2021-11-10">https://javascript.plainenglish.io/how-to-track-changes-in-ngdocheck-with-keyvaluediffer-6667ed7a1dad?source=collection_archive---------5-----------------------#2021-11-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b0c3dfcd14e59f6cd9753b873f843335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_avw-l6hr5sZqBRm7zK5w.jpeg"/></div></div></figure><p id="e84c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们使用<code class="fe kt ku kv kw b">ngDoCheck</code>来检测变化时，我们需要确保我们的实现是极其轻量级和快速的，以便它不会影响用户体验。在本教程中，我们将学习如何使用<code class="fe kt ku kv kw b">KeyValueDiffer</code>有效地跟踪和处理这些变更。</p><h1 id="55d7" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe kt ku kv kw b">ngDoCheck</code>生命周期挂钩</h1><p id="4772" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">这个生命周期挂钩的官方定义是这样的:</p><p id="b68e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ma">“检测Angular自身无法或不愿检测到的变化并采取相应措施。每次运行更改检测时，在ngOnChanges()之后立即调用，第一次运行时，在ngOnInit()之后立即调用。</em></p><p id="d198" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单地说，角度跟踪通过对象引用绑定输入。这意味着如果一个对象引用没有改变，绑定改变不会被检测到，改变检测也不会被执行。这就是我们需要<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/DoCheck" rel="noopener ugc nofollow" target="_blank">ngDoCheck</a></code>的地方。</p><h1 id="59f5" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实际用法</h1><p id="0956" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">理解在处理代码时何时使用<code class="fe kt ku kv kw b">ngDoCheck</code>生命周期钩子以及它与<code class="fe kt ku kv kw b">ngOnChanges</code>有何不同是非常重要的。</p><p id="ba1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，我们将考虑两个组件:</p><ol class=""><li id="b9a7" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated"><code class="fe kt ku kv kw b">my-app</code> -具有基本布局和<code class="fe kt ku kv kw b">rates</code>属性，表示一段时间内1美元的印度卢比汇率。</li><li id="8cc4" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated"><code class="fe kt ku kv kw b">app-rates</code> -接受<code class="fe kt ku kv kw b">rates</code>的单个<code class="fe kt ku kv kw b">@Input</code></li></ol><p id="6216" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的目标是跟踪<code class="fe kt ku kv kw b">rates.inr</code>的变化并在<code class="fe kt ku kv kw b">app-rates</code>中显示。让我们从编码开始:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0c3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">my-app</code>的代码是基本的。它只显示<code class="fe kt ku kv kw b">rates</code>，我们也给出了一个<code class="fe kt ku kv kw b">button</code>，它将通过调用<code class="fe kt ku kv kw b">updateRates</code>来更新<code class="fe kt ku kv kw b">rates</code>。</p><p id="f079" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看<code class="fe kt ku kv kw b">app-rates</code>的代码:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1d74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">app-rates</code>的模板只显示<code class="fe kt ku kv kw b">diff</code>，代表<code class="fe kt ku kv kw b">rates.inr</code>从上次开始变化了多少。而如果没有变化，就会显示“没有区别”的文字。</p><p id="5a8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，为了简单地得到<code class="fe kt ku kv kw b">diff</code>，我们需要计算新值和旧值之间的差值。</p><p id="e5d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可能会想到用<code class="fe kt ku kv kw b">ngOnChanges</code>来做这件事。让我们先来看看在生命周期挂钩中我们得到了什么变化:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2b14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们留意控制台，并单击“更新率”按钮:</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5b1e01bf1c907c50319a20258d6642f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*T3kAAnVFx4sWqzYM"/></div></figure><p id="c62b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，<code class="fe kt ku kv kw b">ngOnChanges</code>只有在第一次分配<code class="fe kt ku kv kw b">rates</code>时才会被调用。这是因为我们没有通过从<code class="fe kt ku kv kw b">my-app</code>引用来改变<code class="fe kt ku kv kw b">rates</code>对象。如果我们在<code class="fe kt ku kv kw b">my-app</code>中写下如下内容，那么<code class="fe kt ku kv kw b">ngOnChanges</code>将捕捉到这些变化:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="86a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与<code class="fe kt ku kv kw b">ngOnChanges</code>不同的是，<code class="fe kt ku kv kw b">ngDoCheck</code>跟踪所有的变化，无论它们是否被引用，甚至更多。让我们在例子中利用它:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b529" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，我们引入了一个名为<code class="fe kt ku kv kw b">oldRate</code>的新属性。在<code class="fe kt ku kv kw b">ngDoCheck</code>中，我们检查新的<code class="fe kt ku kv kw b">rates.inr</code>是否与<code class="fe kt ku kv kw b">oldRate</code>不同，然后它应该更新<code class="fe kt ku kv kw b">diff</code>。现在让我们看看输出:</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/191f6393f3a463e0dc76d1fc04078b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*JJU7yL4zB_arBTju"/></div></figure><p id="c06c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ma">要了解更多关于</em> <code class="fe kt ku kv kw b"><em class="ma">ngDoCheck</em></code> <em class="ma">的内容，我推荐您阅读文章:</em> <a class="ae mb" href="https://indepth.dev/posts/1131/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article" rel="noopener ugc nofollow" target="_blank"> <em class="ma">如果您认为</em> </a> <code class="fe kt ku kv kw b"><a class="ae mb" href="https://indepth.dev/posts/1131/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article" rel="noopener ugc nofollow" target="_blank"><em class="ma">ngDoCheck</em></a></code> <a class="ae mb" href="https://indepth.dev/posts/1131/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article" rel="noopener ugc nofollow" target="_blank"> <em class="ma">意味着您的组件正在被检查——阅读这篇文章——Angular depth</em></a><em class="ma">。</em></p><p id="2254" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该示例可在<a class="ae mb" href="https://stackblitz.com/edit/angular-ivy-tcrchs?file=src/app/rates/rates.component.ts" rel="noopener ugc nofollow" target="_blank"> stackblitz </a>上找到。这段代码给出了预期的结果。但是Angular很少提供有效跟踪对象随时间变化的工具。让我们调查一下。</p><h1 id="1310" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">键值差异和实用程序</h1><p id="e369" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">当我们想使用<code class="fe kt ku kv kw b">KeyValueDiffer</code>时，会涉及到一些接口和一个服务。下面的插图涵盖了所有这些内容:</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/72ee00efd3e9310e6a1bbbc614335324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/0*BDGv8-LkRfqlhl0T"/></div></figure><p id="e335" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是摘要:</p><ol class=""><li id="3a95" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated">我们将注入服务<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueDiffers" rel="noopener ugc nofollow" target="_blank">KeyValueDiffers</a></code>并使用它的方法获得一个<code class="fe kt ku kv kw b">KeyValueDifferFactory</code></li><li id="3bbb" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">接下来，我们将使用<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueDifferFactory" rel="noopener ugc nofollow" target="_blank">KeyValueDifferFactory</a></code>的方法创建<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueDiffer" rel="noopener ugc nofollow" target="_blank">KeyValueDiffer</a></code></li><li id="97df" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">我们将通过<code class="fe kt ku kv kw b">KeyValueDiffer</code>的方法跟踪变化。它返回<code class="fe kt ku kv kw b">KeyValueChanges</code></li><li id="7299" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">最后，我们将使用<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueChanges" rel="noopener ugc nofollow" target="_blank">KeyValueChanges</a></code>的<a class="ae mb" href="https://angular.io/api/core/KeyValueChanges#methods" rel="noopener ugc nofollow" target="_blank">方法之一</a>来分析【】的变化，例如<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueChanges#foreachchangeditem" rel="noopener ugc nofollow" target="_blank">forEachChangedItem</a></code></li><li id="abc2" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">所有方法都提供对变更记录的访问<code class="fe kt ku kv kw b">KeyValueChangeRecord</code></li><li id="6210" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated"><code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueChangeRecord" rel="noopener ugc nofollow" target="_blank">KeyValueChangeRecord</a></code>界面是表示项目变更信息的记录</li></ol><h1 id="ba12" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实际用法</h1><p id="daae" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">我们将在之前创建的<code class="fe kt ku kv kw b">app-rates</code>中使用上述实用程序。我们将从空白<code class="fe kt ku kv kw b">ngDoCheck</code>开始:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2a0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的目标是用<code class="fe kt ku kv kw b">KeyValueDiffer</code>工具跟踪对<code class="fe kt ku kv kw b">rates</code>属性所做的更改。</p><p id="fd45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们首先创建一个<code class="fe kt ku kv kw b">differ</code>:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b878" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<code class="fe kt ku kv kw b">rates</code>对象有类型<code class="fe kt ku kv kw b">string</code>的键和类型<code class="fe kt ku kv kw b">number</code>的值，我们用<code class="fe kt ku kv kw b">KeyValueDiffer</code>分别传递两种类型<code class="fe kt ku kv kw b">string</code>和<code class="fe kt ku kv kw b">number</code>。您可以根据自己的需要进行更改。</p><p id="7f1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，让我们注入<code class="fe kt ku kv kw b">KeyValueDiffers</code>服务:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="cb2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是时候从服务中初始化<code class="fe kt ku kv kw b">differ</code>了。我们将在<code class="fe kt ku kv kw b">ngOnInit</code>做生命周期挂钩:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5741" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，首先，我们调用了<code class="fe kt ku kv kw b">find()</code>方法。这个方法首先在内部检查作为参数传递的对象是不是一个<code class="fe kt ku kv kw b">Map</code>或者JSON，如果检查成功，那么它返回<code class="fe kt ku kv kw b">KeyValueDiffersFactory</code>。你可以在<a class="ae mb" href="https://github.com/angular/angular/blob/b1c028677f45e704342e81d7957d024c137340ce/packages/core/src/change_detection/differs/keyvalue_differs.ts#L179" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看它的源代码，但总的来说，下面是它的样子:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4920" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">find()</code>之后，我们正在调用<code class="fe kt ku kv kw b">KeyValueDiffersFactory</code>的<code class="fe kt ku kv kw b">create()</code>方法，它创建了一个<code class="fe kt ku kv kw b">KeyValueDiffer</code>对象。</p><p id="9b4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将使用<code class="fe kt ku kv kw b">differ</code>并在<code class="fe kt ku kv kw b">ngDoCheck</code>中调用它的<code class="fe kt ku kv kw b">diff()</code>方法:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="59c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">diff()</code>方法返回<code class="fe kt ku kv kw b">KeyValueChanges</code>或<code class="fe kt ku kv kw b">null</code>。如前所述，<code class="fe kt ku kv kw b">KeyValueChanges</code>提供了跟踪所有变更、添加和删除的方法。</p><p id="827f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，我们需要跟踪对<code class="fe kt ku kv kw b">rates</code>所做的更改，所以我们将使用<code class="fe kt ku kv kw b">forEachChangedItem()</code>并计算<code class="fe kt ku kv kw b">diff</code>:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d2a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">app-rates</code>的最终代码如下所示:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="785b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个例子在<a class="ae mb" href="https://stackblitz.com/edit/angular-ivy-nwzydo?file=src/app/rates/rates.component.ts" rel="noopener ugc nofollow" target="_blank"> stackblitz </a>上也有。</p><h1 id="cb68" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="30e9" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">我们首先从一个简短的介绍开始。然后我们学习了跟踪变更所需的实用程序，即接口<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueDiffer" rel="noopener ugc nofollow" target="_blank">KeyValueDiffer</a></code>、<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueChanges" rel="noopener ugc nofollow" target="_blank">KeyValueChanges</a></code>、<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueChangeRecord" rel="noopener ugc nofollow" target="_blank">KeyValueChangeRecord</a></code>和<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueDifferFactory" rel="noopener ugc nofollow" target="_blank">KeyValueDifferFactory</a></code>以及<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueDiffers" rel="noopener ugc nofollow" target="_blank">KeyValueDiffers</a></code>服务。</p><p id="4181" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们在代码中实现了这一切，并使用<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/KeyValueChanges#forEachChangedItem" rel="noopener ugc nofollow" target="_blank">KeyValueChanges.forEachChangedItem</a></code>跟踪了对<code class="fe kt ku kv kw b">rates</code>对象的更改。</p><p id="66e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Angular的内置指令也使用了这种策略，你可以在<a class="ae mb" href="https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_style.ts" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看它的代码。</p><p id="3659" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们学习了跟踪对对象所做的更改。还可以跟踪对数组所做的更改。为此，您将需要以同样的方式使用<code class="fe kt ku kv kw b"><a class="ae mb" href="https://angular.io/api/core/IterableDiffers" rel="noopener ugc nofollow" target="_blank">IterableDiffers</a></code>服务和相关接口。关于它的更多信息，请查看GitHub上的代码，Angular团队已经在那里使用了T3。</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="daeb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ma">最初发表于</em><a class="ae mb" href="https://indepth.dev/tutorials/angular/track-changes-in-ngdocheck-with-keyvaluediffers" rel="noopener ugc nofollow" target="_blank"><em class="ma">depth . dev</em></a><em class="ma">。</em></p><p id="7532" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ma">更多内容请看</em><a class="ae mb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ma">plain English . io</em></strong></a></p></div></div>    
</body>
</html>