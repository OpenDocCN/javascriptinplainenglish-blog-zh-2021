<html>
<head>
<title>What is Zone.js in 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5分钟后Zone.js是什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-zone-why-zone-8534350480dd?source=collection_archive---------1-----------------------#2021-01-29">https://javascript.plainenglish.io/what-is-zone-why-zone-8534350480dd?source=collection_archive---------1-----------------------#2021-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="43ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解Zone.js的概念并开始使用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c7a952b7305d0db93794020a5cfa00dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-VMRArvVf-waFToeiy6_Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Working with Zone.js</figcaption></figure><h1 id="a248" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">什么是Zone.js</h1><p id="a0bf" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们执行的每个JavaScript代码都是在执行上下文中执行的。<strong class="lp ir"> Zone.js </strong>是一种创建新上下文并让代码在那个<strong class="lp ir">上下文/Zone </strong>中执行的方法。包含在区域中的任何代码，无论是同步的还是异步的，都在同一个上下文中执行。<strong class="lp ir"> Zone.js主要用于创建新的上下文</strong>并在其中执行代码。</p><h1 id="4253" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">我们为什么使用Zone.js</h1><p id="3210" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在本节中，我们将分析一个需要解决的问题陈述。在下面的代码中，我们有一些需要执行的同步函数，我们希望评估这些函数的总执行时间。让我们寻找代码来评估相同的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae ml" href="https://gist.github.com/Mayankgupta688/11f71441090c492e034daeeada891629" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/11f71441090c492e034daeeada891629</a></figcaption></figure><p id="c851" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">在上面的代码中，整个执行是同步的，因此计算这段代码的总执行时间非常容易。执行这三个函数的总时间约为311毫秒。因为函数2有很多迭代，所以它花费了最多的时间。总执行时间如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/dcb5f9301a3782dd1e4bf4269ac66378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DcHpMMVgClKB8XogW-p5w.png"/></div></div></figure><p id="fa9c" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">现在让我们将异步函数添加到同一个执行中，看看效果如何。我们将在“<strong class="lp ir"> executeTaskTwo </strong>”中添加setTimeout，以便在一些延迟之后异步执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae ml" href="https://gist.github.com/Mayankgupta688/171d4f70ca29d521b2c0fa18d0a743a2" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/171d4f70ca29d521b2c0fa18d0a743a2</a></figcaption></figure><p id="bc80" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">上述代码的执行会产生以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/156c2cc3014a516df4585cc005f911f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-tCQK7hafCthZ7VOmoSSzw.png"/></div></div></figure><p id="7388" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">现在这个任务的执行时间减少到“<strong class="lp ir"> .465秒</strong>”。由于没有考虑<strong class="lp ir">异步执行时间</strong>，因此这段代码的执行时间发生了巨大的变化。对于<strong class="lp ir">只考虑同步部分</strong>的时间，不考虑异步执行，给我们错误的结果。</p><p id="b4af" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">为了迎合这种情况，我们需要部署一些机制，在这些机制中，所有异步和同步代码执行都可以被考虑到，这是由块内的任何函数触发的。对于这些场景，我们需要创建一个区域，任何异步或同步执行都将被视为同一区域/上下文下执行的一部分。然后，我们可以通过找出该区域的总执行时间来计算总时间。我们将很快看到使用Zone的钩子实现指定的代码</p><h1 id="cd61" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">不同的Zone.js挂钩/事件</h1><p id="bdc9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Zone.js为正在创建的新上下文提供了一些特性/挂钩。这些挂钩连接到创建的每个区域。我们可以在同一区域下的代码执行时跟踪不同的阶段。以下是该区域可用的挂钩/事件:</p><ol class=""><li id="7132" class="mt mu iq lp b lq mm lt mn lw mv ma mw me mx mi my mz na nb bi translated"><strong class="lp ir"> onZoneCreated </strong>:最初创建区域时执行</li><li id="6c47" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated"><strong class="lp ir"> beforeTask </strong>:在<strong class="lp ir">“zone . run”</strong>中的任务执行之前运行</li><li id="4c36" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated"><strong class="lp ir">任务后</strong>:一旦“<strong class="lp ir">区.运行</strong>内的任务被执行</li><li id="6aa9" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated"><strong class="lp ir"> onError </strong>:当“<strong class="lp ir"> zone.run </strong>内的函数抛出错误时运行</li></ol><h1 id="85d4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">向应用程序添加区域</h1><p id="7600" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">一旦我们将Zone.js添加到应用程序中，我们就向窗口中添加了一个全局“Zone”对象。我们可以派生一个继承自“父”区域的新区域。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/fb0635de37d2e3542e068c742856535e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rF2CCTkJ6Rl9uj6kmgzH-Q.png"/></div></div></figure><p id="c800" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">一旦Zone.js被添加到应用程序中，我们可以看到一个新的对象"<strong class="lp ir"> window.zone </strong>"在全局级别上可用。由于创建的区域位于最顶层，因此父区域被标记为<strong class="lp ir">“null”</strong>。我们现在可以通过派生父区域来创建更多的区域。让我们在下一节中寻找相同的内容。</p><h1 id="d3d0" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">创建和分叉区域</h1><p id="ff95" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们在前面的例子中看到，只要将“zone.js”添加到应用程序中，就会创建一个父区域<strong class="lp ir"> window.zone </strong>。从这个父区域创建更多的区域非常容易。下面的代码指定了从父区域派生区域的简单代码。可以使用“分叉”功能创建新区域。我们可以从现有区域派生出新区域。一旦新区域分叉，父区域将由区域对象的“父”属性指向。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a24a" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">在上面的代码中，我们从父区域派生出新区域，并在创建的新区域(myZone)中执行函数“createNewContext”。“myZone.run”表示我们正在“myZone”上下文中运行该函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/3e92fde8369cdce7c0c7c73a73c9c872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBwDCgkih-NPP3oT28vAUQ.png"/></div></div></figure><p id="106e" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">我们可以在上图中看到，创建了一个新区域，这个新区域有一个特定的Id，父区域用关键字“parent”映射。这些区域以指定的方式链接在一起。</p><h1 id="e0a3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">使用Zone.js的优势</h1><p id="196e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们可以将这个库用于不同的用途:</p><ol class=""><li id="1b53" class="mt mu iq lp b lq mm lt mn lw mv ma mw me mx mi my mz na nb bi translated">应用程序中的错误处理</li><li id="70c6" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">跟踪应用程序性能</li><li id="70af" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">在区域级别维护变量</li><li id="7e3c" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">跟踪应用程序执行和事件</li><li id="3f36" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">以角度表示变化检测机制</li><li id="731d" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">在父区域级别创建全局数据</li></ol><p id="818d" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">这些优势可以通过在Zone.js中使用不同的钩子来获得</p><h1 id="59a6" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">添加区域规范</h1><p id="92db" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当使用“<strong class="lp ir"> fork </strong>”创建一个区域时，我们可以向该区域添加挂钩。可以使用钩子来跟踪指定区域内的执行和失败场景。使用这些钩子，您可以维护一些可用于执行区域的全局变量，并提供错误处理能力。让我们寻找可用的挂钩来进一步了解优势。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae ml" href="https://gist.github.com/Mayankgupta688/254e732acd1b5db834ccd16f21235fab" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/254e732acd1b5db834ccd16f21235fab</a></figcaption></figure><p id="2287" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">在上面的代码中，我们可以看到区域中有多个可用的钩子。它可以帮助我们跟踪事件，例如:</p><ol class=""><li id="78a4" class="mt mu iq lp b lq mm lt mn lw mv ma mw me mx mi my mz na nb bi translated">在当前指定区域下执行代码</li><li id="96a8" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">在区域内执行代码期间发生的任何错误</li><li id="da5c" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">创建区域时要执行的代码</li><li id="574b" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">每次执行退出当前区域执行时</li></ol><p id="6139" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">我们可以通过一些包含异步执行的示例代码来理解给定的钩子。由于我们将拥有异步代码，JavaScript的执行将多次进入和退出该区域。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae ml" href="https://gist.github.com/Mayankgupta688/0635cb4d5aeec5c25cb11a4529ae9189" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/0635cb4d5aeec5c25cb11a4529ae9189</a></figcaption></figure><p id="09be" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">上述执行的输出给出了以下结果。在上面的代码中，我们在一个单独的区域内执行函数“executeUnderNewContext”。一旦执行了函数的同步部分，执行就移出了新创建的区域。该函数包含异步执行。在执行异步代码之前，代码进入创建的同一个“区域”,并在指定的区域内执行这个异步函数。</p><p id="6e6d" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">因此，通过分叉区域，我们可以在同一个上下文中执行一组同步和异步功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/237c9436b4f26775a5320c96b14b7386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*BUkCUQB29YXNAHFmS4PEAw.png"/></div></figure><p id="365b" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">每次执行分叉区域中指定的函数调用时，都会调用这些钩子。甚至异步执行和事件执行都是在创建的区域内执行的。</p><p id="0d43" class="pw-post-body-paragraph ln lo iq lp b lq mm jr ls lt mn ju lv lw mo ly lz ma mp mc md me mq mg mh mi ij bi translated">在下一篇文章中，我们将讨论在您的应用程序中使用Zone.js的实时示例。</p></div></div>    
</body>
</html>