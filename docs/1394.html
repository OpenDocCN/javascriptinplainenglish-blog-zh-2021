<html>
<head>
<title>Creating a Chrome extension with Vue.js and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Vue.js和Node.js创建Chrome扩展</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-chrome-extension-with-vue-js-and-node-13ddafcf0d84?source=collection_archive---------3-----------------------#2021-03-24">https://javascript.plainenglish.io/creating-a-chrome-extension-with-vue-js-and-node-13ddafcf0d84?source=collection_archive---------3-----------------------#2021-03-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4f56596048efdf5110c81247d3b8a866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cU5qrgkS3_dDo1gYlm02yw.png"/></div></div></figure><p id="fd96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">半影是chrome的一个新标签，以扩展的形式出现。它覆盖了现有的新标签，提供了一些非常小的附加组件或功能。</p><p id="5f9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我对默认新标签的主要问题是它太简单了。它限制用户只能使用八个快捷方式，并使用这些网站的收藏夹图标进行预览。收藏夹图标通常很小(16×16px ),当它们被用在除了标签以外的任何地方时，它们看起来很模糊。这个恼人的问题迫使我创建了自己的Chrome扩展，带有我喜欢的微妙特征。</p><p id="435e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有太多新的替换标签了。但是它们要么试图拥有多产的特性，以至于用起来很讨厌，要么太少，以至于我开始怀疑这有什么意义。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/54725135fc8c8f05530185314955161e.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*lpW-wLZrQ_K3XqcytkV1Cg.gif"/></div></figure><h1 id="76fb" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">项目结构</h1><p id="70d6" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">现在我们来谈谈这个扩展是如何工作的。像大多数网络应用一样，半影有两个部分——前端和后端。前端是用户可以与扩展和后端发送高质量的网站图标互动。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/a8a177022f7a27fd53a7d99f8dc069a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXPMzch8mwkabc4rXiJa2g.png"/></div></div></figure><p id="29d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在客户端，我使用VueJs创建UI。VueJs是一个JavaScript框架，用于为web创建反应式和模块化的ui。</p><p id="1279" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">半影的用户界面很小，类似于默认界面，很少有例外。它可以让你添加网站(超过8个)，它显示天气和每个请求的随机报价。如果你愿意，你也可以改变背景颜色。</p><p id="1f38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在后端，我使用Node with express创建API端点和一个抓取徽标的NPM包来获取网站的图标。Node是一个JavaScript运行时，允许您在系统上执行JavaScript，而不是在浏览器中执行。ExpressJs让您可以轻松地创建API端点。您也可以用vanilla Node创建API端点，但是它的HTTP模块使用起来有点难看。使用快递可以节省很多时间。</p><h1 id="6b43" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">后端</h1><p id="67f4" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">半影的后端非常简单。我正在创建一个API端点，用户可以发送他/她想要添加的网站的URL。然后有一个NPM包<a class="ae mc" href="https://www.npmjs.com/package/logo-scrape" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">的图标抓取</strong> </a>，它抓取该网站的图标，并返回包含图像地址的对象数组。我还创建了一个JSON文件，其中包含一些流行网站的图片地址。然后我合并两个数组——一个来自JSON文件，另一个使用logo-scrape包获取，并发送回客户端。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/9faf4b6da9f0c3359b4eb5e85bfa1e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eeu-J9wrt7FCtWwscjDqcw.png"/></div></div></figure><p id="2b64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在导入必要的包之后，我创建了一个端口常量，它存储了系统中可用的端口值，如果没有，则为3000。在大多数情况下，主机提供商系统为我们的应用程序提供了一个存储在端口环境变量中的端口，我们可以使用该端口连接到互联网。</p><p id="c838" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我将创建一个新的express实例，并将其存储在app constant中。紧接着是三个app.use()函数。这些函数允许我们在接收每个请求之后和发送每个响应之前运行一些函数。这些在每个请求后运行的功能被称为中间件。所以有三个中间件功能在每个请求后执行。第一个是cors()。这是一个处理CORS政策的NPM方案。它基本上允许与REST进行跨域信息交换。有关CORS的更多信息，请访问<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> MDN docs </a>。第二个和第三个中间件处理REST请求的解析体。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/75d0a2b965254471a2a5a282f1143de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7ba_VDoaxvuStG0mloEug.png"/></div></div></figure><p id="d132" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">app.get()接受两个参数，第一个是路径，第二个是回调函数，它将在每个get请求命中所提供的路径时执行。</p><p id="9645" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，第一个参数是一个“/”，表示根域。因此，如果这个网站是托管在www.example.com，那么我们作为第二个参数提供的回调函数将在用户每次访问这个页面时运行。</p><p id="637e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的回调函数有两个参数——req和res。第一个参数是一个对象，它包含关于特定请求的所有信息。标题细节，如果是post请求的话还有正文等等。第二个参数也是一个对象，它包含处理向用户发送响应的方法。在这里，我们使用res.send()方法，并在其中发送一个HTML元素。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/3bbc754ec9e78e0860da6a5d6fda6895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6e9LgQsBSOtvB7Jy-iJ-g.png"/></div></div></figure><p id="eb84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">app.post()是我们获取图像的主要目标被执行的地方。像app.get()方法一样，它有两个参数，一个是路径，另一个是回调函数。在这种情况下，路径是“/url”，所以它将产生www.example.com/url.，回调函数将在此路径上的每个post请求上执行。在我们的回调函数中有一个异步生命(立即调用的函数表达式)。生命只是一个被立即调用/执行的函数的花哨名字。你只需将整个函数声明放在括号内，后面跟着另一组括号。在我们的异步函数中，我们存储从客户端发送的url。然后我们使用LogoScrape.getLogos()函数并传递URL，之后我们得到一个包含图像地址的对象数组，我们将它存储在Logos中。</p><p id="8989" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个if块将JSON文件(hdLogo)中的图像地址添加到logos数组的第一个索引中。最后，我们发送包含图像地址的徽标数组，从最相关到最不相关。为了将数组发送回用户，我们使用res.send()方法。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/2c200fbc9aa9322f18ab31a31c79833a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CohmSLpCNt12DI0u2H1NA.png"/></div></div></figure><p id="8803" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">app.listen()是我们正在使用的最后一个方法。这个函数是不言自明的。这里我们监听端口并执行一个回调函数。这个函数基本上启动了我们的服务器。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fe96101292024421f368e4c466be950b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDxe6SLQUDAAffQkzI_gzQ.png"/></div></div></figure><h1 id="800b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">前端</h1><p id="8792" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">客户端UI非常简单。我们在左上角有一个天气通知。中间有一个随机引用，下面是你的网站快捷方式。右下角有一个锁定按钮，可以锁定/解锁所有设置，如悬停在卡片上时提示使用网站删除，将温度单位从摄氏温度改为华氏温度，反之亦然，还可以改变背景颜色。底部还有一个容器，当你悬停在它附近时会出现，它包含几个主题，你可以从中选择。</p><p id="9e03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们将每个UI特性分散到单独的组件中。</p><h2 id="2c27" class="mh kz in bd la mi mj dn le mk ml dp li kg mm mn lm kk mo mp lq ko mq mr lu ms bi translated">成分</h2><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/5d346ac63efc089c42e2d84c58769bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYyakVjHA-eYq1IlsH55Ig.png"/></div></div></figure><p id="df2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">天气</strong> —在我们的主App.vue中，我们有一个天气组件。我在这里使用一个IP地址API来获取用户的位置。我本可以使用内置在地理定位web API中的JavaScript来获取用户的位置，这样会更准确、更快速，但这会打开一个提示，要求用户必须给出使用地理定位的权限。这将增加另一层用户交互。所以我选择用IP地址API获取用户地址，并使用该位置从天气API获取天气数据。这稍微慢了一点，因为我们背靠背地使用了两个API，但是好的一面是用户不需要做任何事情。天气将会显示，用户不必点击任何地方。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/92a5546732c65c1dfb21af476e1d7dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2S3VjfC8XYgzS34h9CnMMg.png"/></div></div></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/c6f83db39e6dd7d4ad9c7564730dfa04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EK-BQXJ-3GYmlHMFivWPKg.png"/></div></div></figure><p id="18ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个组件中，我们有一个适当的<strong class="jx io">类型</strong>，它决定用户是否能够改变温度单位。那么我们在这个局域态中有两个变量。<strong class="jx io"> weatherData </strong>和<strong class="jx io"> showMetric </strong>，weatherData将用于存储天气数据，showMetric将确定单元的类型。</p><p id="6685" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们没有使用任何数据库来存储用户的偏好，而是使用了<strong class="jx io"> localStorage </strong>。因此，在创建的钩子中，我们检查是否有用户偏好存储在localStorage中，如果有，则使用公制单位。</p><p id="675b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，当我们的组件被安装时，我们正在执行<strong class="jx io"> fetchWeather </strong>函数。这个函数首先从IP地址API中获取用户的位置，然后我使用这些数据来获取天气信息，并存储在weatherData变量中。</p><p id="f717" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还有一个<strong class="jx io"> changeMetric </strong>函数，每次用户单击天气组件时都会执行这个函数。它更改showMetric变量并将新变量存储在localStorage中。</p><p id="2b0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">信息— </strong>这是另一个简单的组件，显示每个请求的新报价。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/9105da1fef23d1d55efe228bb75ad8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8F_VUFX99UHrD9804nVSw.png"/></div></div></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/0383e86498e83ef1d2102ec4e7b001a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KOjWrXBB21PrxMY7mOYCw.png"/></div></div></figure><p id="16b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们在本地状态中有三个变量— <strong class="jx io"> qod，author </strong>和<strong class="jx io"> showAuthor </strong>。qod是我存储随机引用的地方，author存储作者姓名，showAuthor是决定是否显示作者的布尔值。</p><p id="222a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在内部安装的钩子中，我们获取最大长度为80的随机报价。</p><p id="3412" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> WebsiteModule — </strong>该组件负责向用户显示网站，并允许用户删除、更改图标、刷新等。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/a9b5cb405b902e781331f31517b7acff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jyH-4OGNB2BJRkjke44FQ.png"/></div></div></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/8b8b000cd09e1192dba7505c8163a270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIuCyenRHZawsISL1TxiMQ.png"/></div></div></figure><p id="813d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该组件接收<strong class="jx io">网站对象</strong>作为道具，包括网站名称和用户可以切换的图标数组。如果锁的属性为真，它将阻止任何改变，否则它将发出删除，改变图标等事件。然后在<strong class="jx io">app . vue</strong>中处理这些事件</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="05b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有一些其他组件，如BackgroundColor、Lock等。还有一个组件<strong class="jx io">input mode</strong>，我在其中创建POST请求，以从我们创建的后端获取高清图标。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/6934972a6c1730847d2ab1d60c9589f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVJyBoBWidqhbsKByfQqog.png"/></div></div></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/8aecd243ade4d4fa9eee0305a380cfcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cfnoe-rez2RhXxYNeqRANQ.png"/></div></div></figure><p id="a4bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> fetchIconsFromAPI </strong>创建一个post请求，其中包含用户输入的URL(经过验证)。然后，当收到新图标时，我会发出一个事件。</p><p id="368f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后在App.vue中，我捕捉到了那个发射器，并执行了一个函数<strong class="jx io">addmoreonicons</strong>，将从post请求中收到的图标作为参数。在执行过程中，它将新图标存储在<strong class="jx io">初始网站</strong>数组中。这个数组包含了用户添加的网站对象，如果在里面做了任何改变，就把它们存储在localStorage中。</p><h1 id="0dd1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在Chrome网络商店上发布</h1><p id="d59a" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">为了在chrome的网络商店上发布它，首先我们需要在我们的新标签中做一些改变。目前，它只是一个网站，而不是扩展。要使成为扩展，我们需要在构建的根目录中有一个<strong class="jx io"> manifest.json </strong>文件。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/01242dfd0e21b64a236d816fe5238083.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*p1EknCz16p2UrdGSIyFHJw.png"/></div></figure><p id="97aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要构建我们的vue应用程序，为此我们需要运行<strong class="jx io"> <em class="nf"> npm run build。</em> </strong>它会构建我们的app，给我们一个dist文件夹。</p><p id="dac5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个dist文件夹中，我们将创建我们的清单文件。这个清单文件将告诉chrome我们的扩展。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/958d194f0a50733abc58c669e0117c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mM-khVIQSrKphX-r_lSB8g.png"/></div></div></figure><p id="4681" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们将给出我们的扩展名，版本，描述等。对于我们的扩展来说，两个重要的东西是<strong class="jx io"> chrome_url_overrides </strong>和<strong class="jx io">图标。chrome_url_overrides是一个覆盖现有url的对象，在我们的例子中，它是一个新标签，应该指向我们的主索引文件。</strong></p><p id="5a04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">icons也是一个对象，这里我们声明了我们扩展的不同大小的图标。</p><p id="00c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不同类型的扩展要求清单中有不同的参数。你可以在这里看官方<a class="ae mc" href="https://developer.chrome.com/docs/extensions/mv3/manifest/" rel="noopener ugc nofollow" target="_blank">文档。</a></p><p id="cb2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，要进行托管，你必须去<a class="ae mc" href="https://chrome.google.com/webstore/devconsole/" rel="noopener ugc nofollow" target="_blank"> Chrome开发者控制台</a>并支付5美元的一次性费用。完成后，点击添加项目，并在此处附加dist文件夹的zip文件。然后你需要提交一些关于你的扩展和发布的细节。审查需要一些时间，一段时间后你的扩展将被部署给其他人使用。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/fdae5debdeed85cda5add3b592a23ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bXhxHXyEOEBe6KWlART5rA.gif"/></div></div></figure><h1 id="36b5" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="bc7f" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">半影是一个小项目，我创建了一个新的标签为我工作。构建这个新选项卡的整个过程非常简单，我没有尝试做任何极端的事情。但这并不意味着我没有学到新的东西。我知道了如何创建API端点，以及在创建时会出现什么问题。在前端，我试图保持整个结构干燥和简单。最后，学习了chrome扩展如何真正工作，并使用manifest利用chrome特性。将来我会构建一些更复杂的扩展。你可以在<a class="ae mc" href="https://chrome.google.com/webstore/detail/penumbra-newtab-minified/gfcknafpdhcijijjbkekflmpfagdcdgd?utm_source=chrome-ntp-icon" rel="noopener ugc nofollow" target="_blank">这里</a>亲自尝试这个扩展，或者在<a class="ae mc" href="https://github.com/ayushman-git/newtab" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中查看代码。</p><p id="cf86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nf">更多内容请看</em><a class="ae mc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nf">plain English . io</em></strong></a></p></div></div>    
</body>
</html>