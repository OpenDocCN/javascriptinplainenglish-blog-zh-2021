<html>
<head>
<title>Token Based Security in Angular Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度应用中基于令牌的安全性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/token-based-security-angular-applications-9378791a3762?source=collection_archive---------9-----------------------#2021-06-12">https://javascript.plainenglish.io/token-based-security-angular-applications-9378791a3762?source=collection_archive---------9-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="b891" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="10e9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我写过几篇关于基于令牌的安全、其重要性、OAUTH、OIDC和身份服务器的文章。如果你不熟悉这些话题，你可以查看之前的<a class="ae lj" href="https://medium.com/codex/token-based-security-setting-up-identityserver-ui-part-6-36173700857f" rel="noopener">帖子</a>。</p><p id="7cc9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">今天，我将讲述如何利用这些技术保护角度应用。我们将了解如何将角度应用程序与IdentityServer关联。</p><p id="b684" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Angular应用程序是一个<strong class="kn ir">公共客户端</strong>类型的应用程序，这些应用程序不像<strong class="kn ir">服务器端</strong>客户端应用程序如ASP。NET MVC，Nodejs等。</p><p id="f5ee" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">过去<strong class="kn ir">隐式</strong>流用于角流，但不再推荐。正如我们在以前的帖子中了解到的那样，授权码<strong class="kn ir">+<strong class="kn ir">PKCE</strong>是当今的标准。</strong></p><p id="2388" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个流程涉及从angular应用程序重定向到IdentityServer，用户在IDP上输入登录/密码，在那里进行验证，然后重定向回angular应用程序。</p><p id="fc50" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我见过许多带有<strong class="kn ir">应用内</strong>登录屏幕的应用程序(例如，在Angular应用程序内)，虽然这可以做到(通常使用资源所有者密码流)，但如果可能的话，请避免这种做法。它制造的问题比解决的问题还多。如果您对IDP默认的登录/注销视图不满意，您可以设计/更改IDP屏幕，而不是构建登录/注销等。角度应用中的屏幕。</p><p id="4fb9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在本文中，我们将介绍推荐的流程，但是，首先，我们需要一些API端点(在资源服务器上)来返回一些数据。接下来让我们创建一个简单的端点:</p><h1 id="5680" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">API端点</h1><p id="4a17" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我有一个API，只是一个. NET核心的web应用。首先，我为产品创建了一个API，如下所示，它使用<strong class="kn ir"> dapper </strong>和<strong class="kn ir"> postgreSQL </strong>从数据库中读取数据，并以JSON格式返回给调用者:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/70ddb581cfb3cb40fe96838e1232db61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/0*GXuu98gJQJ95CCta"/></div></figure><p id="8a8e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">(我在dapper ORM上使用postgres db，如果你愿意，你可以直接返回内存数据，完全跳过db部分)。</p><p id="58a0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">接下来，我们将创建一个angular应用程序和一个产品组件。Angular应用程序将对ProductsController上的Get端点进行HTTP调用，并接收JSON数据，然后使用HTML显示这些数据。</p><h1 id="77ca" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">角度应用</h1><p id="abe8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我已经使用angular-cli创建了一个非常基本的角度应用程序。应用程序包含一个在表格中显示产品数据的<strong class="kn ir">产品组件</strong>。您可以使用自己现有的或新的角度应用程序，其机制是相同的。</p><p id="e2b5" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我还创建了一个角度服务<strong class="kn ir"> api.service.ts </strong>，它对后端api端点(ProductsController)进行HTTP调用:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/b7d677b2e697b4e74e3b982a52ad2087.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/0*v9s50bqL-xPZL8Sg"/></div></figure><p id="7492" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在，如果我们运行angular应用程序并访问产品页面，产品会显示在页面上:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/615f133836acdf99995d5d5f5652ced7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K4dppaxay6n2hfF1"/></div></div></figure><p id="44ae" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，我们的angular应用程序能够调用API端点并获取数据。接下来，让我们保护这个API端点:</p><h1 id="a9d8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">保护API</h1><p id="5c7c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们通过应用Authorize属性来保护API:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi md"><img src="../Images/ae8c92c42786fa19b510f9bf2b1809a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/0*OCM4dqIITXxnkhtu"/></div></figure><p id="8d95" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">重新启动web应用程序，并尝试再次打开产品页面，但不会显示任何数据。打开控制台窗口，我们会看到401错误:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/1afc46d1a08cea43191aae68e1728538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M0UGnqdgeCI_dU20"/></div></div></figure><p id="9f30" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，API受到保护，只有授权的客户才能访问它。</p><p id="7603" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在，在这一点上，我们在<strong class="kn ir">资源服务器</strong>中有一个产品API端点，它使用<strong class="kn ir">授权</strong>属性进行保护。我们的<strong class="kn ir">身份服务器</strong>正在保护资源服务器。我们还有一个<strong class="kn ir"> Angular </strong>应用程序，它对产品API端点进行HTTP调用。接下来，让我们做一些必要的步骤来授权这个HTTP调用获取数据。</p><h1 id="d2d2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">OIDC客户</h1><p id="fdbb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了将我们的angular应用程序连接到授权服务器并处理各种流，我们可以使用<strong class="kn ir"> oidc </strong>客户端库来管理重定向和协议级细节。</p><p id="8cca" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">您可以使用npm命令安装软件包:</p><pre class="lq lr ls lt gt me mf mg mh aw mi bi"><span id="dc74" class="mj jo iq mf b gy mk ml l mm mn">npm install oidc-client</span></pre><p id="2a7f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">接下来，我们将创建一个服务(AuthService ),它将作为我们的angular应用程序的安全上下文。该服务将根据需要在内部使用<strong class="kn ir"> oidc </strong>库。</p><h1 id="c219" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">授权服务</h1><p id="3d81" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将从创建这个服务开始。Auth service将使用oidc库，并为我们完成向oidc认证的艰苦工作。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/22fad5d863a7bb9e67e4f3b8a4edb39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CMaaIMcJh-zoAkKX"/></div></div></figure><p id="6f1b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">首先，我们将从oidc库中导入<strong class="kn ir"> UserManager </strong>和<strong class="kn ir"> User </strong>类型。这些是您将从oidc客户端处理的主要类型。</p><p id="19b7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">接下来，我们包含了用于<strong class="kn ir">用户管理器</strong>和<strong class="kn ir">用户</strong>类型的私有字段。用户管理器将在登录过程完成时生成用户。接下来，我们在AuthService的<strong class="kn ir">构造函数</strong>中初始化<strong class="kn ir"> UserManager </strong>。</p><p id="a1b4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们很快就会看到<strong class="kn ir">用户</strong>变量。</p><ul class=""><li id="d6a4" class="mo mp iq kn b ko lk ks ll kw mq la mr le ms li mt mu mv mw bi translated">对象为我们管理OIDC流的所有底层协议细节。因此，我们不必担心我们的应用程序和身份提供商之间的网络连接。</li><li id="4351" class="mo mp iq kn b ko mx ks my kw mz la na le nb li mt mu mv mw bi translated"><strong class="kn ir"> User </strong> type封装了一个<strong class="kn ir">登录的</strong>用户的客户端信息，例如</li><li id="bfc6" class="mo mp iq kn b ko mx ks my kw mz la na le nb li mt mu mv mw bi translated">从<strong class="kn ir"> IDP </strong>返回的ID和访问<strong class="kn ir">令牌</strong></li><li id="cccd" class="mo mp iq kn b ko mx ks my kw mz la na le nb li mt mu mv mw bi translated">作为<strong class="kn ir">声明</strong>从IDP返回的任何用户<strong class="kn ir">资料</strong>信息。</li><li id="3ae4" class="mo mp iq kn b ko mx ks my kw mz la na le nb li mt mu mv mw bi translated">并且能够在用户的令牌过期时使用。</li></ul><p id="56b6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在服务的构造函数中，我们用<strong class="kn ir"> stsSettings </strong>初始化UserManager。如果你还记得我们的邮差演示，你可能已经认出了其中的一些。</p><ul class=""><li id="3223" class="mo mp iq kn b ko lk ks ll kw mq la mr le ms li mt mu mv mw bi translated"><strong class="kn ir"> redirect_ur </strong> i:这是IdentityServer在登录过程后重定向回来时的uri。我们将为此创建一个角度组件。</li><li id="c1c7" class="mo mp iq kn b ko mx ks my kw mz la na le nb li mt mu mv mw bi translated"><strong class="kn ir"> post_logout_redirect_uri </strong>:与上面类似，我们将创建一个angular组件来处理用户在STS上注销并重定向回angular应用程序的情况。</li></ul><p id="7422" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这两个组件将非常简单，大多只有一个<strong class="kn ir">空div </strong>和一些JavaScript。我们将在后面的文章中看到这两个组件。</p><h1 id="531a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">登录过程</h1><p id="2077" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我在AuthService中添加了一个<strong class="kn ir"> login </strong>方法，该方法在<strong class="kn ir"> userManager </strong>对象上调用<strong class="kn ir"> singinRedirect </strong>:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2f8bb65876432eb72391702b972622f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*gli33LbiRmu1PzTq"/></div></figure><p id="fe81" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">成功登录后，UserManager将它创建的结果用户对象存储在<strong class="kn ir">会话存储器</strong>中，以便在需要时可以随时检索，例如获取<strong class="kn ir"> AccessToken </strong>以将其发送给<strong class="kn ir"> API </strong>调用。</p><p id="ef82" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">用户对象包含<strong class="kn ir">访问</strong>和<strong class="kn ir"> ID令牌</strong>，以及一个<strong class="kn ir">过期</strong>标志，我们可以检查该标志以确保访问令牌没有过期。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nd"><img src="../Images/4a032b6f44152f1441bbb7ee1fb7e8aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ue-f6U25d-tJVT1a"/></div></div></figure><h1 id="5c04" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">isLoggedIn Helper方法</h1><p id="41fa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的代码图中，我创建了<strong class="kn ir">is loggin</strong>方法。该方法将帮助我们从任何组件中找出“<strong class="kn ir">检查用户是否已经登录</strong>”。</p><h1 id="0591" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">加载用户时引发事件</h1><p id="9988" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当重定向从STS返回angular app时，获得<strong class="kn ir"> ID </strong>和<strong class="kn ir">访问令牌</strong>的进程与根视图的加载异步<strong class="kn ir">。因此，我们还需要<strong class="kn ir">在用户加载时引发一个事件</strong>(见下图)，这样依赖于它的UI就可以更新了。我们将使用一个<strong class="kn ir"> RxJs可观察值</strong>来实现这一点:</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d12cc06602abebf98508f12c6dbc3a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/0*kvkY5DTtYH_UqMuW"/></div></figure><p id="7ec7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，为了实现这一点，我们将在AuthService上声明一个作为RxJs主题的<strong class="kn ir">私有属性</strong> <code class="fe nf ng nh mf b">_loginChangedSubject</code>，然后声明一个由<strong class="kn ir">主题</strong>产生的<strong class="kn ir">公共可观察对象</strong> <code class="fe nf ng nh mf b"> _loginChanged</code>。然后我们在<strong class="kn ir"> isLoggedIn </strong>方法中添加代码以<strong class="kn ir">触发可观察的</strong>。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a3e4446bb95cd102a5439bc45a156121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*EbNZxyFRBU7Vmck9"/></div></figure><p id="2fa8" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当<strong class="kn ir">登录过程</strong> <strong class="kn ir">完成</strong>时，我们也会触发这个可观察事件，但是我们稍后会回到那个部分。</p><h1 id="441f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">从会话存储中加载用户</h1><p id="b0b2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，用<strong class="kn ir"> IsLoggedIn </strong> check更新根<strong class="kn ir"> AppComponent </strong>，这样，如果会话存储中已经有一个来自上一次登录的文件，用户就可以在启动时加载。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/45d7a1620dfdb28943827bc22cbf4b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/0*XL9CSqmqcR8wYKcE"/></div></figure><p id="bc3c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我还添加了一个事件处理程序，当登录状态改变时更新<strong class="kn ir"> isLoggedIn </strong>属性<strong class="kn ir">。</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/b7abe28838c9600efbc84817bc6b864c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/0*-7XgqkiwrYJ3YslR"/></div></figure><p id="8278" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，现在每当用户状态改变时，应用程序组件都会得到通知，并且应用程序将能够对该改变做出反应。</p><h1 id="25d8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">登录/注销按钮和方法</h1><p id="2274" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我在<strong class="kn ir"> AppComponent </strong>中添加了登录/注销按钮(HTML)和方法:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/73347dfa03da8be1ec63432b40caa3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/0*111uzY1P6utn15KD"/></div></figure><p id="aacf" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">下面是登录/注销方法代码:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/cb1e7a4ff2a000c2018451cd2a57295b.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/0*xseOTvGBMq4ZTgnD"/></div></figure><p id="d8a2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们仍然必须设置登录和挑选出<strong class="kn ir">回调组件</strong>和一些更多的角度代码。我们还需要<strong class="kn ir">用angular客户端设置来配置STS </strong>。然而，为了控制帖子的长度，我们现在暂停，将在下一篇帖子中继续余下的设置。您可以从这个git存储库下载源代码。我们将在下一篇文章中继续这个设置，如果你有什么意见或问题，请告诉我。下次再见，快乐编码。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="b78e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="nu">原载于2021年6月12日https://hexquote.com</em><a class="ae lj" href="https://hexquote.com/token-based-security-angular-applications/" rel="noopener ugc nofollow" target="_blank"><em class="nu"/></a><em class="nu">。</em></p></div></div>    
</body>
</html>