<html>
<head>
<title>Most Frequently Used RxJS Operators (with Use Cases)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最常用的RxJS运算符(有用例)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/most-frequently-used-rxjs-operators-with-use-cases-7645639317fc?source=collection_archive---------2-----------------------#2021-05-16">https://javascript.plainenglish.io/most-frequently-used-rxjs-operators-with-use-cases-7645639317fc?source=collection_archive---------2-----------------------#2021-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5407" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">反应式编程的须知操作符</h2></div><p id="e49e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">习惯于AJAX调用承诺的开发人员总是会问同一个问题:承诺工作正常，为什么我们需要RxJS？</p><p id="6dcd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我就反过来问，你知道如何用<strong class="ke io"> <em class="ky">大数据</em></strong><strong class="ke io"><em class="ky">高复杂度</em> </strong>来<strong class="ke io"> <em class="ky">管理和扩展</em> </strong>应用吗？您在处理复杂的<strong class="ke io"> <em class="ky">并行或顺序异步调用</em> </strong>时遇到过麻烦吗？</p><p id="d0e6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这些问题，我想分享以下Angular/React项目中最常用的RxJS操作符:<strong class="ke io"> <em class="ky"> pipe，of，map，first，combineLatest，switchMap/mergeMap，以及takeUntil </em> </strong>。除了解释之外，我将包括真实用例的示例代码。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/710d46da5608343b6a5679f65a36d7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fSaUSkR7MFL_YBeT"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Photo by <a class="ae lp" href="https://unsplash.com/@mattj_bowden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Bowden</a> on <a class="ae lp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2b35" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">先决条件</h1><p id="2216" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">RxJS(Reactive Extensions for JavaScript)是微软开发的一组库，用于在反应式编程的基础上编写异步和基于事件的程序[1]。</p><p id="3f5e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它是一种声明式编程范式，关注数据流和变化的传播[2]。</p><p id="1efa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如今，反应式编程对于管理和扩展具有大数据量和高复杂性的应用程序至关重要。</p><p id="6e18" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了JS，它还支持其他语言，如Java。Net、Scala、Clojure和Swift。</p><p id="8a50" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在阅读本文之前，您必须了解以下要素:</p><h2 id="474d" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated"><strong class="ak"> <em class="mz">可观察的</em> </strong></h2><p id="8e32" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">可观察值是返回一系列值的函数。默认情况下，一个可观察对象是冷的，当第一个订阅者到达时，它会变热，这意味着在第一个订阅完成之前，它不会发出值。如果想了解更多，请在<a class="ae lp" href="https://v6.rxjs.dev/guide/observable" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ky">详解</em> </strong> </a>中阅读。</p><h2 id="244e" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated"><strong class="ak"> <em class="mz">订阅</em> </strong></h2><p id="45ba" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">订阅代表一个可观察的执行。如前所述，它通过调用方法”将可观察对象变成热对象。订阅”。然后，将为每个发出的值执行该方法中的回调函数。如果想了解更多，请在<a class="ae lp" href="https://v6.rxjs.dev/guide/subscription" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ky">详细</em> </strong> </a>中阅读。</p><p id="d920" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与通常只运行一次的承诺代码不同，Observables可以不断发出值，订阅将接收并处理它们。</p><p id="5902" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的例子是一个非常简单的用例:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="162d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们有一个由数字1、2、3、4、5和6组成的可观测序列。然后我们订阅打印每个发出的数字。</p><p id="3a7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么我们如何查询那些由可观察对象表示的异步数据流呢？答案是运营商。算子通过变换改变原来的可观测值，返回一个新的可观测值。你可以在这里  找到运营商<a class="ae lp" href="https://v6.rxjs.dev/guide/operators" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ky">的完整列表。</em></strong></a></p><p id="a851" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">强烈推荐你在名为<a class="ae lp" href="https://rxmarbles.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ky">rx marbles</em></strong></a>的网站上用交互图玩不同的运营商。</p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h1 id="225a" class="lq lr in bd ls lt nj lv lw lx nk lz ma jt nl ju mc jw nm jx me jz nn ka mg mh bi translated">最常用的运算符</h1><p id="fe00" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">在这一部分，我将逐一介绍我以前的Angular / React项目中最常用的操作符:</p><h2 id="d55e" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated">👉管</h2><p id="955d" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">从<strong class="ke io"> <em class="ky"> RxJS 5.5 </em> </strong>开始，管道运算符就成了运算符的正确使用方式。您可以将它视为一个函数，它将一个可观察对象作为输入，用不同的操作符将所有转换聚集在一起，然后返回另一个可观察对象。正如您在下面的示例中看到的，它提高了代码的可读性，并且更适合于树抖动。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="c8a5" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated">👉的和映射</h2><p id="d6fe" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">的运算符用于在序列中发出值。并且算子映射用于将项目的可观察值转换成不同项目的另一可观察值。以下示例显示了如何将源可观测值的每个值转换为其平方值:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="3bd4" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated">👉过滤器</h2><p id="32c2" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">filter操作符将根据给定的谓词函数过滤来自源可观察值的值。下面的例子允许从源可观测值中过滤偶数。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="4142" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated">👉第一</h2><p id="1220" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">如果我们只对满足可观察对象发出的谓词条件的第一项或第一个值感兴趣，我们可以使用这个操作符。</p><h2 id="6435" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated"><strong class="ak">用例:</strong> <strong class="ak">某app的sing up页面</strong></h2><p id="8a55" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">当用户填写完所有信息后，他将点击“验证”按钮提交。因此，我们需要通过名为“userService”的HttpClient服务将对象“user”发送到我们的后端API。但是我们只需要获得第一个HTTP结果，以显示一次“成功”消息。第一个操作符是这种情况的完美候选。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="539a" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated">👉组合测试</h2><p id="37d6" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">该运算符组合多个可观察值来创建一个可观察值，其值通过每个输入可观察值的最新值来计算。每当任何输入可观测值发出一个值时，它使用所有输入的最新值计算一个公式，然后发出该公式的输出[3]。</p><p id="6fba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下图中，有两个源可观测量，运算符将结合每个可观测量的最新元素生成一个新值。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi no"><img src="../Images/faeb114c1bcf0317737858c74a686840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DV42bLi6_9-3YDjJhqKrqw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">from <a class="ae lp" href="https://rxmarbles.com" rel="noopener ugc nofollow" target="_blank">https://rxmarbles.com</a></figcaption></figure><h2 id="a6a0" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated"><strong class="ak">用例:实时文本过滤器</strong></h2><p id="92ee" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我们得到一个产品页面，其中列出了所有产品，并允许用户通过输入文本按类别和颜色进行筛选。以下带有combienLatest operate的代码允许<strong class="ke io"> <em class="ky">在过滤器中实时显示输入类别和国家的产品</em> </strong>。为了实现，我们需要两个BehaviorSubject来获取类别过滤器和国家过滤器的最后值。每次用户更改这些过滤器输入的值时，产品都将被过滤。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="841c" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated">👉切换映射/合并映射</h2><p id="9132" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">运算符switchMap将每个源值投影到一个可观测值，该可观测值合并到输出可观测值中，仅从最近投影的可观测值中发出值[4]。换句话说，它<strong class="ke io"> <em class="ky">将每个值映射到一个可观测值</em> </strong>，然后<strong class="ke io"> <em class="ky">展平</em> </strong>所有这些可观测值中唯一输出的可观测值。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi np"><img src="../Images/b231bbc973d93ec4fc486fd73d287199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIkatJK4T-JldeDKLmCEkg.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">from <a class="ae lp" href="https://rxmarbles.com" rel="noopener ugc nofollow" target="_blank">https://rxmarbles.com</a></figcaption></figure><h2 id="5127" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated"><strong class="ak">用例:产品详情页面</strong></h2><p id="0a2c" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我们需要使用ParamMap从当前路线(例如“/product/123”)获取产品id，然后通过调用后端API获取所获取id的产品详细信息:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b56f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有就是<strong class="ke io"> <em class="ky"> mergeMap </em> </strong>运算符，两者还是挺像的。不同之处在于，switchMap取消仍在进行中的先前的HTTP请求，而mergeMap让它们完成。所以你可以根据你的需要选择其中之一。</p><h2 id="d011" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated">👉直到</h2><p id="2424" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">takeUntil订阅并开始镜像源可观察对象。它还监视您提供的第二个可观察的通知程序。如果通知程序发出一个值，输出可观察对象停止镜像源可观察对象并完成。如果通知程序没有发出任何值并完成，那么takeUntil将传递所有值[5]。</p><p id="b8bf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下图中，第一个彩色的可观察对象是源可观察对象，bleu中的第二个是通知者可观察对象。当通知程序发出第一个值时，源可观察对象的镜像停止。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nq"><img src="../Images/5448ee3edd4378c536acf872492d2f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w67_Ff8yT_HoywWN_ED7aA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">from <a class="ae lp" href="https://rxmarbles.com" rel="noopener ugc nofollow" target="_blank">https://rxmarbles.com</a></figcaption></figure><h2 id="b540" class="mn lr in bd ls mo mp dn lw mq mr dp ma kl ms mt mc kp mu mv me kt mw mx mg my bi translated"><strong class="ak">用例:管理角度组件的取消订阅</strong></h2><p id="9fa0" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">假设当我们的组件被销毁时，我们有两个订阅要取消订阅。我们可以手动取消订阅:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0b4a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，我们可以用takeUntil操作符以更好的方式来实现它。为此，我们应该使用一个名为destroy$的<a class="ae lp" href="https://v6.rxjs.dev/guide/subject" rel="noopener ugc nofollow" target="_blank"> RxJS主题</a>(一种特殊类型的多播可观察对象)。时，它会发出一个值。调用next()方法。当我们在ngOnDestroy生命周期挂钩中这样做时，组件中的所有订阅都将终止。</p><p id="ea10" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个巨大的好处是，我们不再需要保存对我们的订阅的引用。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6887" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您有任何问题或对任何相关话题感兴趣，请随时在下面写下您的评论或通过<a class="ae lp" href="https://www.linkedin.com/in/zhichuan-jin-baa0168a/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae lp" href="https://twitter.com/Zhichuan_JIN" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我！</p><h1 id="6282" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">参考</h1><p id="7ab5" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">[1]:【https://github.com/Reactive-Extensions/RxJS T4】</p><p id="d3f2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">【2】:<a class="ae lp" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Reactive_programming</a></p><p id="a480" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">【3】:<a class="ae lp" href="https://v6.rxjs.dev/api/index/function/combineLatest" rel="noopener ugc nofollow" target="_blank">https://v6.rxjs.dev/api/index/function/combineLatest</a></p><p id="c265" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[4]:<a class="ae lp" href="https://v6.rxjs.dev/api/operators/switchMap" rel="noopener ugc nofollow" target="_blank">https://v6.rxjs.dev/api/operators/switchMap</a></p><p id="6614" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[5]:<a class="ae lp" href="https://v6.rxjs.dev/api/operators/takeUntil" rel="noopener ugc nofollow" target="_blank">https://v6.rxjs.dev/api/operators/takeUntil</a></p><p id="8ca7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em> <a class="ae lp" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ky">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>