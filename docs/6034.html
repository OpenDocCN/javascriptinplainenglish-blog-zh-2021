<html>
<head>
<title>JavaScript Hoisting in Depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度提升JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hoisting-in-javascript-a0320bb42921?source=collection_archive---------7-----------------------#2021-12-27">https://javascript.plainenglish.io/hoisting-in-javascript-a0320bb42921?source=collection_archive---------7-----------------------#2021-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7b2a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入探究JavaScript中的提升。</h2></div><p id="9960" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在JavaScript中是一个典型的棘手概念。提升是一种JavaScript机制，在代码执行之前，变量和函数声明被移动到它们作用域的顶部。这意味着无论在哪里声明函数和变量，无论它们的作用域是全局的还是局部的，它们都被移动到作用域的顶部。但是，这种机制只移动声明。作业留在原处。</p><p id="6a34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在下面更详细地讨论这些。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/383cb8011c0416cecbbb2aea47b270c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NtVo0RFvLEJuHif8.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk"><a class="ae lr" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fjavascript.plainenglish.io%2Funderstanding-hoisting-in-javascript-11cb313f2a20&amp;psig=AOvVaw27qohq2XBWy2IwZl4fi7Wj&amp;ust=1640707722863000&amp;source=images&amp;cd=vfe&amp;ved=0CAsQjRxqFwoTCLCBiuGuhPUCFQAAAAAdAAAAABAm" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><h1 id="88e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可变提升</h1><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="8497" class="mp lt iq ml b gy mq mr l ms mt">x = 5;<br/>console.log(x) // 5<br/>var x;</span></pre><blockquote class="mu mv mw"><p id="d1bd" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><strong class="kh ir">初始化未被提升</strong></p></blockquote><p id="bd65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提升也不会将初始化上移。它们被留在原地。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="a8fa" class="mp lt iq ml b gy mq mr l ms mt">console.log(x) // undefined<br/>x = 5;<br/>console.log(x) // 5<br/>var x;<br/>console.log(x) // 5</span></pre><p id="6a3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果试图在变量初始化之前访问它(定义为<code class="fe nb nc nd ml b">var</code>的变量)，它将返回undefined作为值。</p><p id="3b37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是<code class="fe nb nc nd ml b">var</code>和<code class="fe nb nc nd ml b">let</code>的主要区别，因为<code class="fe nb nc nd ml b">let</code>定义的变量没有被提升，如果你试图在声明和初始化它们之前访问它，它将返回<code class="fe nb nc nd ml b">ReferenceError</code>。</p><p id="ff39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里了解更多信息:</p><div class="ne nf gp gr ng nh"><a rel="noopener  ugc nofollow" target="_blank" href="/let-vs-var-what-is-the-actual-difference-5acdb1f1c83"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">let' vs 'var ':实际区别是什么？</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">这里有一个关于JavaScript中let和var之间的区别的快速阅读，可能会派上用场。很高兴…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ll nh"/></div></div></a></div><p id="8776" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="mx">注意</em></strong><em class="mx">—JavaScript</em><code class="fe nb nc nd ml b">strict mode</code><em class="mx">不允许使用未声明的变量。</em></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/aae0b09bbe71f41cf110024da61bd80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*KCykVHmKEC88Yt60.jpeg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk"><a class="ae lr" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fmedium.com%2F%40victoreloy%2Flearn-once-for-all-how-js-hoisting-works-bd69f1579d56&amp;psig=AOvVaw1Kii5Syjv3F6hGBXfkyLqE&amp;ust=1640710339662000&amp;source=images&amp;cd=vfe&amp;ved=0CAsQjRxqFwoTCJj1_rq4hPUCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><h1 id="04d0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">功能提升</h1><p id="2721" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">像变量一样，JavaScript引擎也提升函数声明。它将函数声明移到脚本的顶部。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="b74c" class="mp lt iq ml b gy mq mr l ms mt">let x = 20,     <br/>let y = 10;  <br/>let result = add(x,y); </span><span id="c865" class="mp lt iq ml b gy oc mr l ms mt">console.log(result);  //30</span><span id="30d6" class="mp lt iq ml b gy oc mr l ms mt">function add(a, b)<br/>{ <br/>  return a + b; <br/>}</span></pre><p id="f8a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行上下文的创建阶段，JavaScript引擎将<code class="fe nb nc nd ml b">add()</code>函数声明放在堆内存中。准确地说，JavaScript引擎创建了一个<code class="fe nb nc nd ml b"><a class="ae lr" href="https://www.javascripttutorial.net/javascript-function-type/" rel="noopener ugc nofollow" target="_blank">Function</a></code>类型的对象和一个引用function对象的函数引用<code class="fe nb nc nd ml b">add</code>。[ <a class="ae lr" href="https://www.javascripttutorial.net/javascript-hoisting/" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="a890" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意</strong>——你要记住箭头函数和函数表达式是不吊的。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="a020" class="mp lt iq ml b gy mq mr l ms mt">//OUTPUT - "TypeError: add is not a function</span><span id="bde6" class="mp lt iq ml b gy oc mr l ms mt">let x = 20,     <br/>let y = 10;  <br/>let result = add(x,y);</span><span id="0546" class="mp lt iq ml b gy oc mr l ms mt">console.log(result);</span><span id="54a8" class="mp lt iq ml b gy oc mr l ms mt">var add = function (a, b)<br/>{ <br/>  return a + b; <br/>}</span></pre><p id="749d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在全局执行上下文的创建阶段，JavaScript引擎在内存中创建<code class="fe nb nc nd ml b">add</code>变量，并将其值初始化为<code class="fe nb nc nd ml b">undefined</code>(就像变量一样)。这个<code class="fe nb nc nd ml b">add</code>变量只在全局执行上下文的执行阶段被分配给一个匿名函数。如下所示，箭头方法也会发生同样的行为。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="3b7a" class="mp lt iq ml b gy mq mr l ms mt">//OUTPUT - "TypeError: add is not a function</span><span id="bac5" class="mp lt iq ml b gy oc mr l ms mt">let x = 20,     <br/>let y = 10;  <br/>let result = add(x,y);</span><span id="fb9e" class="mp lt iq ml b gy oc mr l ms mt">console.log(result);</span><span id="5826" class="mp lt iq ml b gy oc mr l ms mt">var add = (x, y) =&gt; x + y;</span></pre><h1 id="f372" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">优先顺序</h1><ol class=""><li id="20eb" class="od oe iq kh b ki nx kl ny ko of ks og kw oh la oi oj ok ol bi translated">变量赋值优先于函数声明</li><li id="fc36" class="od oe iq kh b ki om kl on ko oo ks op kw oq la oi oj ok ol bi translated">函数声明优先于变量声明</li></ol><p id="ab06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">函数声明挂在变量声明之上，但不挂在变量赋值之上。</em></p><p id="117d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看这意味着什么。</p><blockquote class="mu mv mw"><p id="6c89" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><strong class="kh ir">函数声明上的变量赋值</strong></p></blockquote><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="ec22" class="mp lt iq ml b gy mq mr l ms mt">var square = 10;</span><span id="7ec6" class="mp lt iq ml b gy oc mr l ms mt">function square(num) {<br/>  return (num*num);<br/>}</span><span id="128a" class="mp lt iq ml b gy oc mr l ms mt">console.log(typeof square); // Output: number</span></pre><blockquote class="mu mv mw"><p id="8456" class="kf kg mx kh b ki kj jr kk kl km ju kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><strong class="kh ir">函数声明优先于变量声明</strong></p></blockquote><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="971b" class="mp lt iq ml b gy mq mr l ms mt">var square;</span><span id="4787" class="mp lt iq ml b gy oc mr l ms mt">function square(num) {<br/>  return (num*num);<br/>}</span><span id="c405" class="mp lt iq ml b gy oc mr l ms mt">console.log(typeof square); // Output: function</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi or"><img src="../Images/556cedc3be7ea9008959d9e25e725826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*xYtM_vNYSLtkOLQe.jpg"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk"><a class="ae lr" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fdev.to%2Fnaveenchandar%2Fjavascript-hoisting-2pde&amp;psig=AOvVaw27qohq2XBWy2IwZl4fi7Wj&amp;ust=1640707722863000&amp;source=images&amp;cd=vfe&amp;ved=0CAsQjRxqFwoTCLCBiuGuhPUCFQAAAAAdAAAAABAa" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><h1 id="bc7b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分级提升</h1><p id="61fb" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">这和函数提升很像。类声明被提升，但它们在求值之前保持未初始化状态。这实际上意味着，在使用一个类之前，必须先声明它。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="b08c" class="mp lt iq ml b gy mq mr l ms mt">var james= new User();<br/>james.name = "James Bond";<br/>james.age = 35;<br/>console.log(james); // Output: ReferenceError: User is not defined<br/><br/>class User {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>}</span></pre><p id="f3db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，就类声明而言，要访问类声明，必须先声明。</p><p id="f9aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="mx">注意</em></strong><em class="mx">——很像它们的函数对应，类表达式不吊。</em></p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="d557" class="mp lt iq ml b gy mq mr l ms mt">var james= new BasicUserInfo();<br/>james.name = "James Bond";<br/>james.age = 35;<br/>console.log(james); // Output: ReferenceError: BasicUserInfo is not defined<br/><br/>var BasicUserInfo = class User {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>}</span><span id="ee29" class="mp lt iq ml b gy oc mr l ms mt">OR</span><span id="3437" class="mp lt iq ml b gy oc mr l ms mt">var BasicUserInfo = class {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>}</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi os"><img src="../Images/f16a0e7814e3c3cf05bfe000fe359a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yn_ZNnEZmrSz7h-0.jpg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk"><a class="ae lr" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fifunny.co%2Ftags%2Fhoisting&amp;psig=AOvVaw27qohq2XBWy2IwZl4fi7Wj&amp;ust=1640707722863000&amp;source=images&amp;cd=vfe&amp;ved=0CAsQjRxqFwoTCLCBiuGuhPUCFQAAAAAdAAAAABAV" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><h1 id="8b17" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="db52" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">在JavaScript中进行提升时有很多注意事项，所以总是建议在文件开头声明所有变量，以避免混淆或使用严格模式。</p><p id="bbe4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mx">更多内容看</em> <a class="ae lr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">说白了就是</em> </a> <em class="mx">。报名参加我们的</em> <a class="ae lr" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">免费每周简讯</em> </a> <em class="mx">。在我们的</em> <a class="ae lr" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="mx">社区不和谐</em> </a> <em class="mx">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>