<html>
<head>
<title>Should I Use Vue 3 or Vue 2 In 2022?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年应该用Vue 3还是Vue 2？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/should-i-use-vue-3-or-vue-2-in-2022-ba09c8059233?source=collection_archive---------2-----------------------#2021-07-23">https://javascript.plainenglish.io/should-i-use-vue-3-or-vue-2-in-2022-ba09c8059233?source=collection_archive---------2-----------------------#2021-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d2d711ceb62274d9c15465bfd325cb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZRVxe3SsWW851UoZ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Already installed Vue CLI? Don’t worry! The same CLI offers both Vue 2 as well as Vue 3 support :)</figcaption></figure><p id="ea2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">长话短说，这里有一个快速检查。</p><h1 id="c93c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">何时使用Vue 3，何时不使用</h1><ol class=""><li id="6b79" class="ly lz iq ke b kf ma kj mb kn mc kr md kv me kz mf mg mh mi bi translated">如果需要IE11支持:<strong class="ke ir">不要用Vue 3，支持还没到| </strong>开个玩笑——微软终于扔掉了Internet Explorer，所以除非你有一些遗留客户端，否则不需要支持。</li><li id="eed9" class="ly lz iq ke b kf mj kj mk kn ml kr mm kv mn kz mf mg mh mi bi translated">如果您正在使用Vue 2: <strong class="ke ir">进行一个非常大且复杂的现有项目，您可能不希望迁移到Vue 3 </strong>，这取决于您的代码，迁移时间和性能收益可能不值得</li><li id="3fa0" class="ly lz iq ke b kf mj kj mk kn ml kr mm kv mn kz mf mg mh mi bi translated">如果你有一些优化后的性能问题:<strong class="ke ir"> Vue 3是从头开始写的，比Vue 2提供更好的性能</strong></li><li id="57dd" class="ly lz iq ke b kf mj kj mk kn ml kr mm kv mn kz mf mg mh mi bi translated">如果你需要更好的TypeScript支持:<strong class="ke ir">用Vue 3，比以前好多了！</strong></li><li id="a786" class="ly lz iq ke b kf mj kj mk kn ml kr mm kv mn kz mf mg mh mi bi translated">如果你的依赖支持Vue 3: <strong class="ke ir">使用Vue 3 </strong> | Vue 3是新的，并不是所有的库都支持它。</li></ol><p id="03d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">最后，我鼓励任何不需要IE11支持(也见上面第1点的笑话)和不需要使用不支持Vue 3的依赖项的新项目使用Vue 3。</strong></p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/998aa0df85fbfaf342515b9e323c6e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*eaeLago4DiHkv16k.gif"/></div></figure><p id="104f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你认为你得到了你想要的，<strong class="ke ir">祝贺你！</strong>但是你难道不想知道更多关于Vue 3的信息吗？</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><blockquote class="na nb nc"><p id="bea1" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">如果你有兴趣学习Vue JS或者在Vue JS中磨砺自己的技能，可以看看我新推出的课程<a class="ae nh" href="https://www.udemy.com/course/vue-3-essentials/?referralCode=E6D2FDE2B8B06C1991F1" rel="noopener ugc nofollow" target="_blank"> Vue 3要领</a>和<a class="ae nh" href="https://www.udemy.com/course/vuejs-complete-course-plus-guide/?referralCode=93BDA4A1FE3F73C37CD2" rel="noopener ugc nofollow" target="_blank"> Vue JS完整课程+指南</a>。</p></blockquote></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="e5f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代号为“海贼王”的Vue 3.0于2年前公布，2020年9月正式发布。Vue 3完全重写了框架。它带来了更好的性能、更好的树抖动、更小的尺寸、改进的TypeScript支持，以及一些用于开发大型企业软件的革命性新特性。</p><h1 id="b98f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2022年该学Vue 2还是Vue 3？</h1><p id="43c7" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">Vue 2中的大部分语法和做法在Vue 3中保持不变，所以<strong class="ke ir">如果你学习Vue 2或Vue 3 </strong>应该不会有太大的区别。大多数图书馆现在支持Vue 3，我们也期待Vue 3的兼容版本很快推出。然而，并不是所有的库都与Vue 3兼容，所以<strong class="ke ir">如果你想安全一点，并且能够承受没有Vue 3的性能和API改进，那么你最好学习并使用Vue 2 </strong>。</p><p id="9a3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Vue 3基本上是Vue 2的增压版本。Vue 3甚至更快更轻，带有改进的TypeScript支持，并且有一些很棒的新功能。框架本身已经从头开始重新编写，但是API(开发人员如何使用它)几乎保持不变。这有多棒？！</p><p id="b401" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">把升级到Vue 3想象成换成一部稍新的相同品牌的手机，比如从iPhone X换成iPhone 11 Pro。感觉棒极了，你得到了很大的改进，但是用户界面保持不变。在这两种情况下，您都有一部出色的手机！同样的<strong class="ke ir">在Vue.js中，当你转到Vue 3时，你将能够用你的新框架做更多的事情，但是你以前能做的一切都将继续发挥作用</strong>。</p><p id="65cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了实现这一转变，Vue团队发布了深入的指南，并将发布一个迁移工具来解析您的应用程序并指导您完成升级。</p><p id="7fc6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以不要害怕Vue 3，不要犹豫学习和使用Vue 2。事实上，Vue 3与Vue 2共享大多数概念。</p><h1 id="6f2a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Vue 3中激动人心的新功能</h1><p id="8af4" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">正如您所料，除了出色的性能改进和更好的摇树功能外，Vue 3还带来了许多令人兴奋的新功能。谢天谢地，Vue团队主要引入了对当前API的补充和改进，而不是重大的改变，所以已经知道Vue 2的人应该很快对新语法感到满意。</p><p id="438a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是新功能的列表:</p><blockquote class="na nb nc"><p id="61bf" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">成分原料药</p><p id="d942" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">全局安装/配置API更改</p><p id="1ce3" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">碎片</p><p id="37dd" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">焦虑</p><p id="ad23" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">多个v型</p><p id="f7d7" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">门户|传送</p><p id="d35b" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">新的自定义指令应用编程接口</p></blockquote><p id="1ad1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们从大多数人可能听说过的API开始…</p><h1 id="093e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">成分原料药</h1><p id="32fb" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">Composition API是Vue下一个主要版本中最常讨论和使用的语法。这是一种完全<strong class="ke ir">可选的</strong>逻辑重用和代码组织方法。值得注意的是，您仍然可以使用所有可选的Vue 2 Options APIs。</p><p id="120f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">目前，我们使用所谓的选项API构建组件。为了给Vue组件添加逻辑，我们填充了(选项)属性，如<code class="fe nl nm nn no b">data</code>、<code class="fe nl nm nn no b">methods</code>、<code class="fe nl nm nn no b">computed</code>等。这种方法最大的缺点是它本身不是一个工作的JavaScript代码。您需要确切了解模板中哪些属性是可访问的，以及<code class="fe nl nm nn no b">this</code>关键字的行为。在幕后，Vue编译器需要将这些属性转换成工作代码。</p><p id="4939" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Composition API旨在通过将当前可通过组件属性获得的机制公开为JavaScript函数来解决这个问题。Vue核心团队将Composition API描述为<em class="nd">“一组允许灵活组合组件逻辑的基于函数的附加API”。</em>用Composition API编写的代码可读性更强，幕后没有魔法，更容易阅读和学习。</p><p id="96e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看一个非常简单的组件示例，它使用新的Composition API来理解它是如何工作的。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="9f55" class="nt lb iq no b gy nu nv l nw nx">&lt;template&gt;<br/>  &lt;button @click="increment"&gt;<br/>    Count is: {{ count }}, double is {{ double }}, click to increment.<br/>  &lt;/button&gt;<br/>&lt;/template&gt;</span><span id="96b4" class="nt lb iq no b gy ny nv l nw nx">&lt;script&gt;<br/>import { ref, computed, onMounted } from 'vue'</span><span id="c69b" class="nt lb iq no b gy ny nv l nw nx">export default {<br/>  setup() {<br/>    const count = ref(0)<br/>    const double = computed(() =&gt; count.value * 2)</span><span id="54a0" class="nt lb iq no b gy ny nv l nw nx">    function increment() {<br/>      count.value++<br/>    }</span><span id="ec02" class="nt lb iq no b gy ny nv l nw nx">    onMounted(() =&gt; console.log('component mounted!'))</span><span id="16cb" class="nt lb iq no b gy ny nv l nw nx">    return {<br/>      count,<br/>      double,<br/>      increment<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="354c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们把这段代码分解成几部分，以了解发生了什么</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="9035" class="nt lb iq no b gy nu nv l nw nx">import { ref, computed, onMounted } from 'vue'</span></pre><p id="14c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我之前提到的，Composition API将组件属性公开为函数，所以第一步是导入我们需要的函数。在我们的例子中，我们需要用<code class="fe nl nm nn no b">ref</code>创建反应性引用，用<code class="fe nl nm nn no b">computed</code>计算属性，用<code class="fe nl nm nn no b">onMounted</code>访问安装的生命周期钩子。</p><p id="7070" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在你大概在想这个神秘的<code class="fe nl nm nn no b">setup</code>方法是什么吧？</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="495f" class="nt lb iq no b gy nu nv l nw nx">export default {<br/>  setup() {</span></pre><p id="9f17" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简言之，它只是一个向模板返回属性和函数的函数。就这样。我们在这里声明所有的反应属性、计算属性、观察器和生命周期钩子，然后返回它们，以便它们可以在模板中使用。</p><p id="16cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们没有从<code class="fe nl nm nn no b">setup</code>功能中返回的内容在模板中将不可用。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="12ad" class="nt lb iq no b gy nu nv l nw nx">const count = ref(0)</span></pre><p id="69d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据以上所述，我们用<code class="fe nl nm nn no b">ref</code>功能来声明一个叫做<code class="fe nl nm nn no b">count</code>的反应性属性。它可以包装任何图元或对象，并返回其被动引用。传递的元素的值将保留在创建的引用的<code class="fe nl nm nn no b">value</code>属性中。例如，如果您想访问<code class="fe nl nm nn no b">count</code>引用的值，您需要显式地请求<code class="fe nl nm nn no b">count.value</code>。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="c62a" class="nt lb iq no b gy nu nv l nw nx">const double = computed(() =&gt; count.value * 2)</span><span id="024c" class="nt lb iq no b gy ny nv l nw nx">function increment() {<br/>  count.value++<br/>}</span></pre><p id="3f50" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">……这正是我们在声明计算属性<code class="fe nl nm nn no b">double</code>和<code class="fe nl nm nn no b">increment</code>函数时所做的。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="b0e2" class="nt lb iq no b gy nu nv l nw nx">onMounted(() =&gt; console.log('component mounted!'))</span></pre><p id="ccc2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了<code class="fe nl nm nn no b">onMounted</code>钩子，当组件被安装时，我们会记录一些消息，只是为了告诉你你可以。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="5abb" class="nt lb iq no b gy nu nv l nw nx">return {<br/>  count,<br/>  double,<br/>  increment<br/>}</span></pre><p id="6945" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们用<code class="fe nl nm nn no b">increment</code>方法返回<code class="fe nl nm nn no b">count</code>和<code class="fe nl nm nn no b">double</code>属性，使它们在模板中可用。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="d3ac" class="nt lb iq no b gy nu nv l nw nx">&lt;template&gt;<br/>  &lt;button @click="increment"&gt;<br/>    Count is: {{ count }}, double is {{ double }}. Click to increment.<br/>  &lt;/button&gt;<br/>&lt;/template&gt;</span></pre><p id="8509" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">瞧。现在我们可以像通过旧的Options API声明属性和函数一样，在模板中访问<code class="fe nl nm nn no b">setup</code>方法返回的属性和函数。</p><p id="a991" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个简单的例子，用Options API也很容易实现。新的组合API的真正好处不仅仅是以不同的方式编码，当涉及到重用我们的代码/逻辑时，这些好处就会显现出来。</p><p id="0e7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">代码复用与组合API </strong></p><p id="bc73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">新的组合API有更多的优点。考虑代码重用。目前，如果我们想在其他组件之间共享一些代码，有两种选择——混合和作用域插槽。两者都有缺点。</p><p id="bba2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们想要提取<code class="fe nl nm nn no b">counter</code>功能并在其他组件中重用它。下面您可以看到它如何与可用的API和新的组合API一起使用:</p><p id="41e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们从mixins开始:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="0183" class="nt lb iq no b gy nu nv l nw nx">import CounterMixin from './mixins/counter'</span><span id="978e" class="nt lb iq no b gy ny nv l nw nx">export default {<br/>  mixins: [CounterMixin]<br/>}</span></pre><p id="90d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">mixins最大的缺点是我们不知道它实际上给我们的组件添加了什么。这不仅使推理变得困难，还会导致与现有属性和函数的名称冲突。</p><p id="603e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是时候使用作用域插槽了。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="4f76" class="nt lb iq no b gy nu nv l nw nx">&lt;template&gt;<br/>  &lt;Counter v-slot="{ count, increment }"&gt;<br/>     {{ count }}<br/>    &lt;button @click="increment"&gt;Increment&lt;/button&gt; <br/>  &lt;/Counter&gt; <br/>&lt;/template&gt;</span></pre><p id="a2ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了作用域插槽，我们确切地知道我们可以通过<code class="fe nl nm nn no b">v-slot</code>属性访问什么属性，所以理解代码要容易得多。这种方法的缺点是我们只能在模板中访问它，并且它只能在<code class="fe nl nm nn no b">Counter</code>组件范围内使用。</p><p id="e922" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在是组合API的时候了:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="3e5f" class="nt lb iq no b gy nu nv l nw nx">function useCounter() {<br/>  const count = ref(0)<br/>  function increment () { count.value++ }</span><span id="cb68" class="nt lb iq no b gy ny nv l nw nx">return {<br/>    count,<br/>    incrememt<br/>  }<br/>}</span><span id="f9f8" class="nt lb iq no b gy ny nv l nw nx">export default {<br/>  setup () {<br/>    const { count, increment } = useCounter()<br/>    return {<br/>      count,<br/>      increment<br/>    }<br/>  }<br/>}</span></pre><p id="2e9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">优雅多了，不是吗？我们不受模板或组件范围的限制，并且确切地知道我们可以访问计数器中的哪些属性。此外，我们可以从编辑器中可用的代码完成中受益，因为<code class="fe nl nm nn no b">useCounter</code>只是一个返回一些属性的函数。幕后没有魔法，所以编辑器可以帮助我们进行类型检查和建议。</p><p id="131d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这也是使用第三方库的一种更优雅的方式。比如我们要用Vuex，可以显式使用<code class="fe nl nm nn no b">useStore</code>函数，而不是污染Vue原型(<code class="fe nl nm nn no b">this.$store</code>)。这种方法也消除了Vue插件的幕后魔力。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="0a6d" class="nt lb iq no b gy nu nv l nw nx">const { commit, dispatch } = useStore()</span></pre><p id="158e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想了解更多关于Composition API及其用例的知识，我强烈推荐你阅读来自Vue团队的文档<a class="ae nh" href="https://vue-composition-api-rfc.netlify.com/" rel="noopener ugc nofollow" target="_blank">,它解释了新API背后的原因并推荐了它的最佳用例。还有一个</a><a class="ae nh" href="https://github.com/LinusBorg/composition-api-demos" rel="noopener ugc nofollow" target="_blank">很棒的资源库</a>，里面有Vue核心团队的Thorsten Lünborg使用组合API的例子。</p><h1 id="9f80" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">全球安装/配置API变更</h1><p id="9657" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">我们可以在实例化和配置应用程序的方式中找到另一个主要变化。让我们看看它现在是如何工作的:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="149e" class="nt lb iq no b gy nu nv l nw nx">import Vue from 'vue'<br/>import App from './App.vue'</span><span id="8060" class="nt lb iq no b gy ny nv l nw nx">Vue.config.ignoredElements = [/^app-/]<br/>Vue.use(/* ... */)<br/>Vue.mixin(/* ... */)<br/>Vue.component(/* ... */)<br/>Vue.directive(/* ... */)</span><span id="88e5" class="nt lb iq no b gy ny nv l nw nx">new Vue({<br/>  render: h =&gt; h(App)<br/>}).$mount('#app')</span></pre><p id="c850" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">目前，我们使用全局<code class="fe nl nm nn no b">Vue</code>对象来提供任何配置和创建新的Vue实例。对<code class="fe nl nm nn no b">Vue</code>对象的任何更改都会影响到每个Vue实例和组件。</p><p id="04e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们看看它在Vue 3中是如何工作的:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="a717" class="nt lb iq no b gy nu nv l nw nx">import { createApp } from 'vue'<br/>import App from './App.vue'</span><span id="c0e3" class="nt lb iq no b gy ny nv l nw nx">const app = createApp(App)</span><span id="e231" class="nt lb iq no b gy ny nv l nw nx">app.config.ignoredElements = [/^app-/]<br/>app.use(/* ... */)<br/>app.mixin(/* ... */)<br/>app.component(/* ... */)<br/>app.directive(/* ... */)</span><span id="0d42" class="nt lb iq no b gy ny nv l nw nx">app.mount('#app')</span></pre><p id="410a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你可能注意到的，现在每个配置的范围都是用<code class="fe nl nm nn no b">createApp</code>定义的某个Vue应用。</p><p id="0ceb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它可以使您的代码更容易理解，并且不容易出现由第三方附加组件引起的意外问题。目前，如果某个第三方解决方案正在修改Vue对象，它会以意想不到的方式影响你的应用程序(特别是使用全局混合),这在Vue 3中是不可能的。</p><p id="1771" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这一API变化目前正在<a class="ae nh" href="https://github.com/vuejs/rfcs/pull/29" rel="noopener ugc nofollow" target="_blank"> this </a> RFC中讨论，这意味着它可能会在未来发生变化。</p><h1 id="cdc3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">碎片</h1><p id="2661" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">在Vue 3中，我们可以期待的另一个令人兴奋的增加是片段。</p><p id="a1c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能会问什么是片段？如果你创建一个Vue组件，它只能有一个根节点。</p><p id="78ca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这意味着无法创建这样的组件:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="0f47" class="nt lb iq no b gy nu nv l nw nx">&lt;template&gt;<br/>  &lt;div&gt;Hello&lt;/div&gt;<br/>  &lt;div&gt;World&lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="4ebf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">原因是代表任何Vue组件的Vue实例都需要绑定到单个DOM元素中。创建具有多个DOM节点的组件的唯一方法是创建一个没有底层Vue实例的功能组件。</p><p id="c7d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">原来React社区也有同样的问题。他们提出的解决方案是一个名为Fragment的虚拟元素。看起来或多或少是这样的；</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="ca4f" class="nt lb iq no b gy nu nv l nw nx">class Columns extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;td&gt;Hello&lt;/td&gt;<br/>        &lt;td&gt;World&lt;/td&gt;<br/>      &lt;/React.Fragment&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="d5a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管Fragment看起来像普通的DOM元素，但它是虚拟的，根本不会在DOM树中呈现。这样，我们可以将组件功能绑定到单个元素中，而无需创建冗余的DOM节点。</p><p id="2508" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">目前，你可以通过<a class="ae nh" href="https://vuejsdevelopers.com/2018/09/11/vue-multiple-root-fragments/" rel="noopener ugc nofollow" target="_blank"> vue-fragments </a>库在Vue 2中使用片段，而在Vue 3中，你可以开箱即用！</p><h1 id="2bb4" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">焦虑</h1><p id="ed89" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">另一个将在Vue 3中采用的来自React生态系统的伟大想法是悬念组件。</p><p id="c39b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">暂停挂起组件呈现，并呈现回退组件，直到满足某个条件。在伦敦Vue期间，尤雨溪简要地谈到了这个话题，并展示了我们或多或少可以期待的API。事实证明，悬念只是一个带槽的组件:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="ea26" class="nt lb iq no b gy nu nv l nw nx">&lt;Suspense&gt;<br/>  &lt;template &gt;<br/>    &lt;Suspended-component /&gt;<br/>  &lt;/template&gt;<br/>  &lt;template #fallback&gt;<br/>    Loading...<br/>  &lt;/template&gt;<br/>&lt;/Suspense&gt;</span></pre><p id="4afd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">回退内容将一直显示，直到<code class="fe nl nm nn no b">Suspended-component</code>完全呈现。如果是异步组件，暂停可以等到组件被下载，或者在<code class="fe nl nm nn no b">setup</code>函数中执行一些异步操作。</p><h1 id="fc4c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">多个虚拟模型</h1><p id="7082" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">V-model是一个指令，我们可以用它来实现给定组件的双向绑定。我们可以传递一个反应性属性，并从组件内部修改它。</p><p id="3368" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们从形式元素中很好地了解<code class="fe nl nm nn no b">v-model</code>:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="c593" class="nt lb iq no b gy nu nv l nw nx">&lt;input v-model="property" /&gt;</span></pre><p id="b5c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是您知道您可以对每个组件使用<code class="fe nl nm nn no b">v-model</code>吗？在引擎盖下<code class="fe nl nm nn no b">v-model</code>只是路过<code class="fe nl nm nn no b">value</code>酒店和聆听<code class="fe nl nm nn no b">input</code>事件的捷径。将上面的示例重写为下面的语法将会产生完全相同的效果:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="c348" class="nt lb iq no b gy nu nv l nw nx">&lt;input <br/>  v-bind:value="property"<br/>  v-on:input="property = $event.target.value"<br/>/&gt;</span></pre><p id="9b47" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们甚至可以用组件<code class="fe nl nm nn no b">model</code>属性更改默认属性和事件的名称:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="5d16" class="nt lb iq no b gy nu nv l nw nx">model: {<br/>  prop: 'checked',<br/>  event: 'change'<br/>}</span></pre><p id="88c8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如您所看到的，如果我们想要在我们的组件中有双向绑定，那么<code class="fe nl nm nn no b">v-model</code>指令可以是一个非常有用的语法糖。不幸的是，每个组件只能有一个<code class="fe nl nm nn no b">v-model</code>。</p><p id="79fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">幸运的是，这在Vue 3中不会成为问题！您可以给<code class="fe nl nm nn no b">v-model</code>房产命名，并且可以有任意多个。下面，您可以找到表单组件中两个<code class="fe nl nm nn no b">v-model</code>的示例:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="1075" class="nt lb iq no b gy nu nv l nw nx">&lt;InviteeForm<br/>  v-model:name="inviteeName"<br/>  v-model:email="inviteeEmail"<br/>/&gt;</span></pre><p id="badd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本 RFC的<a class="ae nh" href="https://github.com/vuejs/rfcs/pull/31" rel="noopener ugc nofollow" target="_blank">部分目前正在讨论API的这种变化，这意味着将来可能会发生变化。</a></p><h1 id="942f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">门户网站</h1><p id="5d6d" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">门户是用于呈现当前组件之外的某些内容的特殊组件。这也是React 中本机实现的特性<a class="ae nh" href="https://pl.reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">之一。以下是React文档对门户网站的描述:</a></p><p id="ec7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nd">门户提供了一种一流的方式来将子节点呈现到存在于父组件的DOM层次结构之外的DOM节点中。</em>”</p><p id="913b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是处理模态、弹出窗口和通常出现在页面顶部的组件的一种非常好的方式。通过使用门户，您可以确定没有任何宿主组件CSS规则会影响您想要显示的组件，并减轻您对<code class="fe nl nm nn no b">z-index</code>的恶意攻击。</p><p id="b5ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于每个门户，我们需要指定它的目标目的地，在那里门户内容将被呈现。下面您可以看到<a class="ae nh" href="https://github.com/LinusBorg/portal-vue" rel="noopener ugc nofollow" target="_blank">门户-vue </a>库的实现，它为Vue 2增加了这个功能:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="38ce" class="nt lb iq no b gy nu nv l nw nx">&lt;portal to="destination"&gt;<br/>  &lt;p&gt;This slot content will be rendered wherever thportal-target with name 'destination'<br/>    is  located.&lt;/p&gt;<br/>&lt;/portal&gt;</span><span id="8e7b" class="nt lb iq no b gy ny nv l nw nx">&lt;portal-target name="destination"&gt;<br/>  &lt;!--<br/>  This component can be located anywhere in your App.<br/>  The slot content of the above portal component wilbe rendered here.<br/>  --&gt;<br/>&lt;/portal-target&gt;</span></pre><p id="23a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Vue 3将附带对门户的现成支持！</p><h1 id="08b8" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">新的自定义指令应用编程接口</h1><p id="96f5" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">定制指令API将在Vue 3中稍微改变，以便更好地与组件生命周期保持一致。这种变化应该会让新来的人更容易理解和学习应用编程接口，因为它现在更直观了。</p><p id="7034" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个当前的自定义指令API:</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="2679" class="nt lb iq no b gy nu nv l nw nx">const MyDirective = {<br/>  bind(el, binding, vnode, prevVnode) {},<br/>  inserted() {},<br/>  update() {},<br/>  componentUpdated() {},<br/>  unbind() {}<br/>}</span></pre><p id="0944" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">…这就是它在Vue 3中的样子。</p><pre class="mp mq mr ms gt np no nq nr aw ns bi"><span id="ab1c" class="nt lb iq no b gy nu nv l nw nx">const MyDirective = {<br/>  beforeMount(el, binding, vnode, prevVnode) {},<br/>  mounted() {},<br/>  beforeUpdate() {},<br/>  updated() {},<br/>  beforeUnmount() {}, // new<br/>  unmounted() {}<br/>}</span></pre><p id="bb27" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管这是一个突破性的变化，但它应该很容易被Vue兼容性构建所覆盖。</p><p id="7886" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这一API变化目前正在<a class="ae nh" href="https://github.com/vuejs/rfcs/pull/32/files" rel="noopener ugc nofollow" target="_blank"> this </a> RFC中讨论，这意味着它可能会在未来发生变化。</p><p id="dc1e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嘶！你可以在我们的课程中学习如何掌握自定义指令<a class="ae nh" href="https://vueschool.io/courses/custom-vuejs-directives" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="3ebb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="eae4" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn ni kp kq kr nj kt ku kv nk kx ky kz ij bi translated">除了Vue 3中最大的新API Composition API，我们还可以找到很多小的改进。我们可以看到Vue正在向更好的开发者体验和更简单、更直观的API发展。很高兴看到Vue团队决定采用许多目前只能通过第三方库获得的想法作为框架的核心。</p><p id="96d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2022年用Vue 3肯定是可取的。唯一的例外是当你已经有一个大的代码库或者你的依赖项还不支持Vue 3的时候。然而，在大多数情况下，即使是为了让您的大型代码库与Vue 3兼容，您也需要做最小的改动。如果你需要任何帮助或者通过<a class="ae nh" href="https://www.upwork.com/workwith/mayankkumarchaudhari" rel="noopener ugc nofollow" target="_blank"> Upwork </a>联系我，请在评论区告诉我。</p><p id="ed13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nd">更多内容请看</em><a class="ae nh" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="nd">plain English . io</em></strong></a></p></div></div>    
</body>
</html>