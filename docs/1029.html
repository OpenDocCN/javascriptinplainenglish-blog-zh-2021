<html>
<head>
<title>How to Build a ClubHouse clone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何建立一个克隆的俱乐部会所</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-an-app-like-clubhouse-eeb2382da03e?source=collection_archive---------3-----------------------#2021-03-04">https://javascript.plainenglish.io/how-to-create-an-app-like-clubhouse-eeb2382da03e?source=collection_archive---------3-----------------------#2021-03-04</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="32d6" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">用Angular + Agora + Firebase创建一个类似ClubHouse的应用程序</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/1a6a9c9bec7124d5bf868f0f0c4b58f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XMuBFw-6UyJCqAQY"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@williamk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">William Krause</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e977" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最近几周，网络上出现了越来越多关于俱乐部会所应用的技术信息。一些爱好者创建了带有会所API库的存储库，甚至发布了非官方的Android应用。</p><p id="3f05" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">公众的兴趣和可用的信息使得建立你的语音网络或者至少知道如何实现它变得很有趣。</p><p id="1445" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在本文中，我将讨论如何使用Agora.io、Angular和Firebase实现基本功能。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><p id="6017" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Firebase只是一个例子，您可以使用任何后端来处理身份验证和存储空间</p><h1 id="2b7f" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">先决条件</h1><ul class=""><li id="0b43" class="ms mt ir kz b la mu ld mv lg mw lk mx lo my ls mz na nb nc bi translated">创建了firebase项目</li><li id="1984" class="ms mt ir kz b la nd ld ne lg nf lk ng lo nh ls mz na nb nc bi translated">已经在您的机器上安装了Node.js</li><li id="539f" class="ms mt ir kz b la nd ld ne lg nf lk ng lo nh ls mz na nb nc bi translated">已在全球安装<code class="fe ni nj nk nl b">@angular/cli</code></li><li id="4c4e" class="ms mt ir kz b la nd ld ne lg nf lk ng lo nh ls mz na nb nc bi translated">您对如何使用Firebase有所了解</li></ul><h1 id="84cf" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">议程</h1><ul class=""><li id="9c7d" class="ms mt ir kz b la mu ld mv lg mw lk mx lo my ls mz na nb nc bi translated">项目初始化</li><li id="e8ce" class="ms mt ir kz b la nd ld ne lg nf lk ng lo nh ls mz na nb nc bi translated">证明</li><li id="9747" class="ms mt ir kz b la nd ld ne lg nf lk ng lo nh ls mz na nb nc bi translated">客房大堂和客房创建</li><li id="7376" class="ms mt ir kz b la nd ld ne lg nf lk ng lo nh ls mz na nb nc bi translated">语音直播流一对多(最多100万听众)</li></ul><p id="6cb8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是首先，我们需要初始化项目。</p><p id="c548" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">打开终端，导航到所需的文件夹并运行:</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="1b98" class="nq mb ir nl b gz nr ns l nt nu">ng new clubhouse</span></pre><p id="5a76" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后，让我们创建两个带路线的功能模块:</p><ol class=""><li id="626e" class="ms mt ir kz b la lb ld le lg nv lk nw lo nx ls ny na nb nc bi translated"><code class="fe ni nj nk nl b">ng generate module profile — route profile — module app.module</code></li><li id="6bb7" class="ms mt ir kz b la nd ld ne lg nf lk ng lo nh ls ny na nb nc bi translated"><code class="fe ni nj nk nl b">ng generate module rooms — route rooms — module app.module</code></li></ol><p id="dd52" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">清除app.component.html，只留下一个标记:</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="a029" class="nq mb ir nl b gz nr ns l nt nu">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre><p id="3c54" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">出发前剩下的最后一件重要的事——@ angular/fire库。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="d941" class="nq mb ir nl b gz nr ns l nt nu">ng add <a class="ae kw" href="http://twitter.com/angular/fire" rel="noopener ugc nofollow" target="_blank">@angular/fire</a></span></pre><p id="3d6f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">将Firebase配置添加到环境变量中</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="324e" class="nq mb ir nl b gz nr ns l nt nu">export const environment = {<br/>  production: false,<br/>  <strong class="nl is">firebase: {<br/>    apiKey: ‘&lt;your-key&gt;’,<br/>    authDomain: ‘&lt;your-project-authdomain&gt;’,<br/>    databaseURL: ‘&lt;your-database-URL&gt;’,<br/>    projectId: ‘&lt;your-project-id&gt;’,<br/>    storageBucket: ‘&lt;your-storage-bucket&gt;’,<br/>    messagingSenderId: ‘&lt;your-messaging-sender-id&gt;’,<br/>    appId: ‘&lt;your-app-id&gt;’,<br/>    measurementId: ‘&lt;your-measurement-id&gt;’<br/>  }</strong><br/>};</span></pre><p id="f944" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">并在<code class="fe ni nj nk nl b">app.module.ts</code>中使用</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="3495" class="nq mb ir nl b gz nr ns l nt nu">imports: [<br/>  BrowserModule,<br/>  AppRoutingModule,<br/>  <strong class="nl is">AngularFireModule.initializeApp(environment.firebase)</strong><br/>]</span></pre><p id="b9f1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们准备好使用我们未来的应用程序了=)</p><h1 id="e82a" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">证明</h1><p id="d93e" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">Firebase应用程序有许多不同的认证提供者。为了使本教程简单，让我们使用一个匿名提供者。不需要任何不必要的动作。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oc"><img src="../Images/8070862ded974b90116d5a6d2013632f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhYkUFDELKpasMaxJEy1Gg.png"/></div></div></figure><p id="924c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是在您的项目中，您可以使用任何类型的身份验证。</p><p id="1bb3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在<code class="fe ni nj nk nl b">app-routing.module.ts</code>中设置房间模块为默认路线，并启用授权守卫。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="c2b2" class="nq mb ir nl b gz nr ns l nt nu">...<br/>import { AngularFireAuthGuard, redirectUnauthorizedTo } from '@angular/fire/auth-guard';</span><span id="7616" class="nq mb ir nl b gz od ns l nt nu"><strong class="nl is">const redirectUnauthorizedToLogin = () =&gt; redirectUnauthorizedTo(['profile']);</strong></span><span id="89f5" class="nq mb ir nl b gz od ns l nt nu">const routes: Routes = [<br/>  ...<br/>  {<br/>    path: 'rooms',<br/>    loadChildren: () =&gt;<br/>    import('./rooms/rooms.module').then((<em class="oe">m</em>) =&gt; <em class="oe">m</em>.RoomsModule),<br/>    <strong class="nl is">canActivate: [AngularFireAuthGuard],<br/>    data: { authGuardPipe: redirectUnauthorizedToLogin }</strong><br/>  },<br/>  <strong class="nl is">{<br/>    path: '**',<br/>    redirectTo: 'rooms'<br/>  }</strong><br/>];</span></pre><p id="5c94" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在，我们将在个人资料页面上添加一个简单的登录按钮。如果您愿意，您可以创建单独的登录/注册/个人资料页面。但是在我们的例子中，用一个登录按钮就足够了。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj of"><img src="../Images/fa15a1df4c5cf0981556b5932efad2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*GIuADMQU28yy01FJ8Owr_Q.png"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Profile component view</figcaption></figure><p id="35a6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">profile.component.html</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="30af" class="nq mb ir nl b gz nr ns l nt nu">&lt;p&gt;Hello 👋&lt;/p&gt;<br/>&lt;button (click)="login()"&gt;<br/>Login to Clubhouse<br/>&lt;/button&gt;</span></pre><p id="df67" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">配置文件.组件. scss</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="eae9" class="nq mb ir nl b gz nr ns l nt nu">:host {<br/>  display: block;<br/>  text-align: center;<br/>  padding: 50px 0;<br/>}</span></pre><p id="4994" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">实现成功时重定向到房间页面的登录方法。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="7969" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">单击浏览器中的登录按钮，如果一切正常，您将被重定向到房间页面。这一次auth guard将允许我们打开这个页面。</p><h1 id="abf0" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">客房大堂和客房创建</h1><p id="92b7" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">在这一页，让我们展示带有可用房间和按钮“开始一个房间”的卡片。我们将使用Firebase实时数据库来存储房间列表。</p><p id="1383" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">首先，我们需要允许用户读写数据库。在浏览器搜索控制台中打开并转到:<code class="fe ni nj nk nl b">Realtime database =&gt; Rules</code>。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="dc8c" class="nq mb ir nl b gz nr ns l nt nu">{<br/>  "rules": {<br/>    ".read": "auth != null",<br/>    ".write": "auth != null"<br/>  }<br/>}</span></pre><p id="c4a5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">打开<code class="fe ni nj nk nl b">rooms.component.ts</code>。我们将在这里使用一些依赖项，所以让我们在构造函数中提供它们:</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="23fe" class="nq mb ir nl b gz nr ns l nt nu">...<br/><strong class="nl is">import { AngularFireAuth } from '@angular/fire/auth';<br/>import { AngularFireDatabase } from '@angular/fire/database';<br/>import { Router } from '@angular/router';<br/>import { Observable } from 'rxjs';<br/>import { map, take, takeUntil } from 'rxjs/operators';</strong></span><span id="d967" class="nq mb ir nl b gz od ns l nt nu">...<br/>constructor(<br/>  <strong class="nl is">private <em class="oe">auth</em>: AngularFireAuth,<br/>  private <em class="oe">db</em>: AngularFireDatabase,<br/>  private <em class="oe">router</em>: Router</strong><br/>) {}</span><span id="1f98" class="nq mb ir nl b gz od ns l nt nu">...</span></pre><p id="9ac4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们需要一些变量来存储<code class="fe ni nj nk nl b">rooms</code>、<code class="fe ni nj nk nl b">subscriptions</code>和<code class="fe ni nj nk nl b">userId</code>。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="485b" class="nq mb ir nl b gz nr ns l nt nu"><strong class="nl is">export interface Irooms {<br/>  key?: string;<br/>  name: string;<br/>  host?: string;<br/>}</strong><br/>...</span><span id="4bc9" class="nq mb ir nl b gz od ns l nt nu">export class RoomsComponent implements OnInit {<br/>  <strong class="nl is">public $rooms: Observable&lt;Irooms[]&gt; | undefined;<br/>  public isRoomCreationShown = false;<br/>  private user: string | undefined;<br/>  private roomList = this.db.list&lt;Irooms&gt;('rooms');<br/>  private $destroy: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;();</strong></span><span id="ac13" class="nq mb ir nl b gz od ns l nt nu">  constructor(<br/>    private <em class="oe">auth</em>: AngularFireAuth,<br/>    private <em class="oe">db</em>: AngularFireDatabase,<br/>    private <em class="oe">router</em>: Router<br/>  ) {}</span></pre><p id="c30a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在组件初始化上，我们应该建立一个对数据库列表的订阅- <code class="fe ni nj nk nl b">rooms</code>。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="1f5a" class="nq mb ir nl b gz nr ns l nt nu">ngOnInit(): void {<br/>  <strong class="nl is">this.$rooms = this.roomList.snapshotChanges().pipe(<br/>    map((action) =&gt;<br/>      action.map((c) =&gt; {<br/>        return {<br/>          ...(c.payload.val() as any),<br/>          key: c.payload.key<br/>        };<br/>      })<br/>    )<br/>  );</strong><br/>}</span></pre><p id="bc06" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当用户创建一个新房间时，我们需要将他定义为主人。当然，在生产中，最好是在云功能端进行，但是在我们的例子中，让我们保持简单。我们将在创建房间时为当前用户提供详细的UID。为了提供它，我们需要从firebase用户身份验证状态中获取它。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="8a34" class="nq mb ir nl b gz nr ns l nt nu">ngOnInit(): void {<br/>  ...<br/>  <strong class="nl is">this.auth.authState.pipe(take(1)).subscribe({<br/>    next: (user) =&gt; {<br/>      this.user = user?.uid;<br/>    }<br/>  });</strong><br/>}</span></pre><p id="a6d2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">房间部分快完成了。我们需要创建一个新房间的方法，我们需要一个导航用户到所需房间的能力。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="9117" class="nq mb ir nl b gz nr ns l nt nu">public addRoom(nameInput: HTMLInputElement): void {<br/>  if (nameInput.value.length) {<br/>    this.roomList<br/>    .push({<br/>      name: nameInput.value,<br/>      host: this.user<br/>    })<br/>    .then((resp) =&gt; {<br/>       this.navigate(resp.key);<br/>    });<br/>  }<br/>  nameInput.value = '';<br/>  this.isRoomCreationShown = false;<br/>}</span><span id="1124" class="nq mb ir nl b gz od ns l nt nu">public navigate(roomId?: string | null): void {<br/>  this.router.navigate([`rooms/${roomId}`]);<br/>}</span></pre><p id="eef5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">用于显示房间列表和创建房间的简单输入的模板。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="c7bb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">带有显示房间创建形式的小过渡的样式。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="og oh l"/></div></figure></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/fa7be5765251109c8e000290ba87eb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*fqS8Or_XxN_mTRhoxWFWug.gif"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">I have no idea why typing is so slow on the gif 🐌</figcaption></figure><p id="98d2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">“房间”组件已经完成，下面是它应该看起来的样子。</p><p id="b4c5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">很简化，但这是教程，不是真实项目。我不喜欢使用被动形式。对于生产来说，还是用它们比较好。</p><p id="b07b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如您所见，当我们创建新房间时，我们打开了另一个页面，该页面当前是空的。这个组件此刻对你来说是不存在的，我们来补充一下。</p><p id="75a4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在终端中运行:</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="de96" class="nq mb ir nl b gz nr ns l nt nu">ng g component rooms/room</span></pre><p id="6b35" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">别忘了将它添加到客房路线中:</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="e962" class="nq mb ir nl b gz nr ns l nt nu">const routes: Routes = [<br/>  { path: '', component: RoomsComponent },<br/>  <strong class="nl is">{ path: ':id', component: RoomComponent }</strong><br/>];</span></pre><h1 id="ab0d" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">语音直播一对多</h1><p id="03e9" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">首先在<a class="ae kw" href="https://www.agora.io/" rel="noopener ugc nofollow" target="_blank"> agora.io </a>注册。这是一个SaaS后端，它位于俱乐部应用程序的后面。学习用的不用提供任何银行卡。</p><p id="bb70" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">接下来，用npm安装Agora SDK:</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="44f2" class="nq mb ir nl b gz nr ns l nt nu">npm i agora-rtc-sdk</span></pre><p id="50e2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在转到Agora控制台= &gt;找到您的项目= &gt;点击编辑= &gt;复制您的应用程序id。将它作为firebase config旁边的agoraAppId插入到environment.ts中。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="369b" class="nq mb ir nl b gz nr ns l nt nu">export const environment = {<br/>  production: false,<br/>  firebase: {<br/>    apiKey: ‘&lt;your-key&gt;’,<br/>    authDomain: ‘&lt;your-project-authdomain&gt;’,<br/>    databaseURL: ‘&lt;your-database-URL&gt;’,<br/>    projectId: ‘&lt;your-project-id&gt;’,<br/>    storageBucket: ‘&lt;your-storage-bucket&gt;’,<br/>    messagingSenderId: ‘&lt;your-messaging-sender-id&gt;’,<br/>    appId: ‘&lt;your-app-id&gt;’,<br/>    measurementId: ‘&lt;your-measurement-id&gt;’<br/>  },<br/>  <strong class="nl is">agoraAppId: '&lt;your-agora-app-id&gt;'</strong><br/>};</span></pre><p id="07b4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们已经准备好构建最后一个组件——一个有实时流的房间。</p><p id="f0ee" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这次我们将从模板开始，因为我们需要一个媒体播放器的容器。通过这个播放器，用户将听到声音。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="60ab" class="nq mb ir nl b gz nr ns l nt nu">&lt;section class="room-content"&gt;<br/>    &lt;div #streamContainer&gt;&lt;/div&gt;<br/>    &lt;div class="users"&gt;<br/>        &lt;div class="user-card"<br/>             *ngFor="let user of $onlineList | async"&gt;<br/>            &lt;img [ngClass]="{'host': user.key === room?.host}"<br/>                 [src]="'<a class="ae kw" href="https://i.pravatar.cc/150?u='+user.key" rel="noopener ugc nofollow" target="_blank">https://i.pravatar.cc/150?u='+user.key</a>"<br/>                 alt=""&gt;<br/>            &lt;h4&gt;{{user?.displayName}}&lt;/h4&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/section&gt;<br/>&lt;section class="room-footer"&gt;<br/>    &lt;button class="btn leave-btn"<br/>            (click)="leaveRoom()"&gt;✌️ Leave quietly&lt;/button&gt;<br/>&lt;/section&gt;</span></pre><p id="3a46" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在这个模板中，您可以看到两个部分。第一个是加入房间的用户列表。第二部分有一个离开房间的按钮。</p><p id="fcbe" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们使用匿名认证，没有用户名和头像，这就是为什么我们会产生随机的用户数据。</p><p id="5e2f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们添加样式，它们很简单:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="d32a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们将用绿色边框突出显示房间的主持人(演讲者)。</p><p id="7b70" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们的下一步是组件逻辑。首先，我们需要导入<code class="fe ni nj nk nl b">activatedRoute</code>并从路由中获取房间id。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="0a7d" class="nq mb ir nl b gz nr ns l nt nu"><strong class="nl is">import { Router, ActivatedRoute } from '@angular/router';</strong></span><span id="e2ef" class="nq mb ir nl b gz od ns l nt nu">...<br/>constructor(<br/>  <strong class="nl is">private <em class="oe">activatedRoute</em>: ActivatedRoute,<br/>  private <em class="oe">route</em>: Router</strong><br/>) {}</span><span id="01b9" class="nq mb ir nl b gz od ns l nt nu">ngOnInit(): void {<br/>  <strong class="nl is">this.roomId = this.activatedRoute.snapshot.paramMap.get('id');</strong><br/>}</span></pre><p id="018e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在让我们进入最有趣的部分——实时流实现。下面是在主持人和观众之间启动直播流的主要步骤的序列图。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oj"><img src="../Images/bf51531203979667029766e5ae32fc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2tdx9h2nqGWSSwsZ"/></div></div></figure><h2 id="0898" class="nq mb ir bd mc ok ol dn mg om on dp mk lg oo op mm lk oq or mo lo os ot mq ou bi translated">创建本地客户端</h2><p id="2ad5" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">然后我们需要初始化Agora客户端，所以让我们创建这个私有方法并在组件初始化时调用它。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="6042" class="nq mb ir nl b gz nr ns l nt nu">...<br/><strong class="nl is">import AgoraRTC from 'agora-rtc-sdk';<br/>import { environment } from 'src/environments/environment';</strong><br/>...</span><span id="b03a" class="nq mb ir nl b gz od ns l nt nu">ngOnInit(): void {<br/>    this.roomId = this.activatedRoute.snapshot.paramMap.get('id');<br/>    <strong class="nl is">this.initClient();</strong><br/>}</span><span id="4dcf" class="nq mb ir nl b gz od ns l nt nu"><strong class="nl is">private initClient(): void {<br/>  this.client = AgoraRTC.createClient({<br/>    mode: 'live',<br/>    codec: 'vp8'<br/>  });</strong></span><span id="6e9d" class="nq mb ir nl b gz od ns l nt nu"><strong class="nl is">  this.client.init(environment.agoraAppId);<br/>}</strong></span></pre><p id="aa78" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们将创建一对多的流，这就是为什么我们需要使用<code class="fe ni nj nk nl b">mode: 'live'</code>的原因，因为我们将只支持现代浏览器，所以我们使用<code class="fe ni nj nk nl b">codec: vp8</code>。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ov"><img src="../Images/a26e9d3bb7b2582eb56f41ff1b20c441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-Pl3Gxbo-6JAsfeQJBXZg.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Codec VP8 and H.264 browser support</figcaption></figure><h2 id="b185" class="nq mb ir bd mc ok ol dn mg om on dp mk lg oo op mm lk oq or mo lo os ot mq ou bi translated">设置用户角色并加入频道</h2><p id="c022" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">在加入渠道之前，我们需要检测用户角色。正如您所记得的，在上一步中，我们在房间细节中保存了作为主机的用户ID。现在我们需要从Firebase auth状态中获取当前用户ID，并将其与房间主机进行比较。我们可以同时做。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="07fe" class="nq mb ir nl b gz nr ns l nt nu">private joinRoom(): void {<br/>  combineLatest([<br/>    this.auth.authState,<br/>    this.db.object&lt;Iroom&gt;(`rooms/${this.roomId}`).valueChanges()<br/>  ])<br/>    .pipe(take(1))<br/>    .subscribe({<br/>      next: ([user, room]) =&gt; {<br/>        this.user = user;<br/>        this.room = room;<br/>        this.isHost = this.user.uid === this.room.host;<br/>        this.client.setClientRole(this.isHost ? 'host' : 'audience');<br/>      }<br/>    });<br/>}</span></pre><p id="9e60" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可能会用自己的解决方案来取消订阅observables，而不是<code class="fe ni nj nk nl b">take(1)</code>。</p><p id="894d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在ngOnInit钩子中调用<code class="fe ni nj nk nl b">joinRoom()</code>。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="3e30" class="nq mb ir nl b gz nr ns l nt nu">ngOnInit(): void {<br/>    this.roomId = this.activatedRoute.snapshot.paramMap.get('id');<br/>    <!-- -->this.initClient();<br/>    <strong class="nl is">this.joinRoom();</strong><br/>}</span></pre><p id="db19" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，对于我们的俱乐部应用程序，我们需要显示加入的人的列表。让我们为它创建一个角度服务，并通过地址将加入的用户存储在实时数据库中:<code class="fe ni nj nk nl b">online/${roomID}</code>。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="cb4a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">将此服务导入组件，并在设置用户角色后立即使用它:</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="e163" class="nq mb ir nl b gz nr ns l nt nu">private joinRoom(): void {<br/>...</span><span id="c419" class="nq mb ir nl b gz od ns l nt nu">  next: ([user, room]) =&gt; {<br/>     ...<br/>     this.client.setClientRole(this.isHost ? 'host' : 'audience');</span><span id="630e" class="nq mb ir nl b gz od ns l nt nu">     <strong class="nl is">this.presenceService<br/>       .setPresenceOnline(<br/>         {<br/>           displayName: randomNames[Math.floor(Math.random() * randomNames.length)],<br/>           key: this.user.uid<br/>         },<br/>         this.roomId<br/>       )<br/>      .pipe(take(1))<br/>      .subscribe();</strong><br/>  }<br/>}</span></pre><p id="1cc3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我用了随机的名字。根据需要在某处定义一个数组😊。当然，在真正的应用程序中，你应该从注册用户档案中取名字。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="6269" class="nq mb ir nl b gz nr ns l nt nu">const randomNames = [<br/>  'Sheryl Edie',<br/>  'Dalton Kincade',<br/>  'Nathan Laber',<br/>  'Carola Wilmot'<br/>];</span></pre><p id="ed83" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">理论上，目前，我们应该可以在UI上看到在线列表，但是我们看不到，因为模板仍然有一些未实现的方法。我们将很快实施所有这些措施。</p><p id="853d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">加入这个流非常简单，但是需要额外的动作。我们需要在后端生成令牌。这个令牌取决于Agora发给你的证书。为了验证概念，可以在<a class="ae kw" href="https://console.agora.io/" rel="noopener ugc nofollow" target="_blank"> agora管理面板</a>中直接生成临时令牌。点击编辑您的项目并找到按钮<code class="fe ni nj nk nl b">generate temp token</code>。键入通道名“demo”(或任何其他名称，但将其作为第二个参数传递给<code class="fe ni nj nk nl b">client.join()</code>函数)并复制生成的令牌。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="450a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">设置用户角色后调用<code class="fe ni nj nk nl b">joinStream</code>函数。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="ac37" class="nq mb ir nl b gz nr ns l nt nu">private joinRoom(): void {<br/>...</span><span id="5381" class="nq mb ir nl b gz od ns l nt nu">next: ([user, room]) =&gt; {<br/>    ...<br/>    this.presenceService<br/>     .setPresenceOnline(...)<br/>     .pipe(take(1))<br/>     .subscribe();</span><span id="2946" class="nq mb ir nl b gz od ns l nt nu">    <strong class="nl is">this.</strong><strong class="nl is">joinStream();</strong><br/>  }<br/>}</span></pre><h2 id="9ea4" class="nq mb ir bd mc ok ol dn mg om on dp mk lg oo op mm lk oq or mo lo os ot mq ou bi translated">创建和发布本地流</h2><p id="a6fc" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">此时，我们需要在房间组件中定义一些变量。我们将在接下来的步骤中使用它们。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="92a9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">之前我们使用了<code class="fe ni nj nk nl b">this.createLocalStream();</code>功能。我们需要实施它。该函数只能由主机调用。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="b347" class="nq mb ir nl b gz nr ns l nt nu">private createLocalStream(): void {<br/>  this.localStream = AgoraRTC.createStream(this.streamOptions);<br/>  // Initialize the local stream<br/>  this.localStream.init(() =&gt; {<br/>    this.client.publish(this.localStream, this.handleError);<br/>  }, this.handleError);<br/>}</span></pre><p id="98ea" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于错误处理，让我们做一些简单的事情:</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="d8a7" class="nq mb ir nl b gz nr ns l nt nu">private handleError(<em class="oe">err</em>: any): void {<br/>  console.error(<em class="oe">err</em>);<br/>}</span></pre><p id="08f3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">哇哦，我们创建了一个本地流，现在我们开始为加入者广播它。但是细木工怎么听得进去呢？只剩几步了。</p><h2 id="077e" class="nq mb ir bd mc ok ol dn mg om on dp mk lg oo op mm lk oq or mo lo os ot mq ou bi translated">订阅远程流</h2><p id="3b9a" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">我们需要收听来自Agora SDK的事件。当流开始时，我们需要创建一个标签，SDK将在那里播放流。当流结束时——我们需要移除那个标签。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="0150" class="nq mb ir nl b gz nr ns l nt nu">private addStream(elementId): void {<br/> // Creates a new div for every stream<br/> const streamDiv = document.createElement('div');<br/> streamDiv.id = elementId;<br/> this.streamContainer.nativeElement.appendChild(streamDiv);<br/>}</span><span id="4809" class="nq mb ir nl b gz od ns l nt nu">private removeStream(elementId: string): void {<br/> const remoteDiv = document.getElementById(elementId);<br/> if (remoteDiv) {<br/>  remoteDiv?.parentNode?.removeChild(remoteDiv);<br/> }<br/>}</span></pre><p id="ae0b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们能够监听事件。</p><p id="9ffe" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">添加流时—为用户订阅以收听它。<br/>订阅建立时—在UI上播放。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="a68a" class="nq mb ir nl b gz nr ns l nt nu">private subscribeToStreamStart(): void {<br/> this.client.on('stream-added', (evt) =&gt; {<br/>   if (!this.localStreams.includes(evt.stream.getId())) {<br/>     this.client.subscribe(evt.stream, null, this.handleError);<br/>   }<br/> });</span><span id="5222" class="nq mb ir nl b gz od ns l nt nu"> // Play the remote stream when it is subsribed<br/> this.client.on('stream-subscribed', (evt) =&gt; {<br/>  const stream = evt.stream;<br/>  const streamId = String(stream.getId());<br/>  this.addStream(streamId);<br/>  stream.play(streamId);<br/> });<br/>}</span></pre><p id="2d81" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在ngOnInit中调用subscribeToStreamStart()函数。</p><h2 id="be77" class="nq mb ir bd mc ok ol dn mg om on dp mk lg oo op mm lk oq or mo lo os ot mq ou bi translated">离开频道</h2><p id="4e73" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">为了取消订阅流，我们需要做几乎相同的事情。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="2d49" class="nq mb ir nl b gz nr ns l nt nu">private subscribeToStreamStop(): void {<br/>    // Remove the corresponding view when a remote user unpublishes.<br/>    this.client.on('stream-removed', (evt) =&gt; {<br/>      const stream = evt.stream;<br/>      const streamId = String(stream.getId());<br/>      stream.close();<br/>      this.removeStream(streamId);<br/>    });<br/>    // Remove the corresponding view when a remote user leaves the channel.<br/>    this.client.on('peer-leave', (evt) =&gt; {<br/>      const stream = (evt as any).stream;<br/>      const streamId = String(stream.getId());<br/>      stream.close();<br/>      this.removeStream(streamId);<br/>    });<br/>  }</span></pre><p id="4e63" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们需要做的最后一件事是添加离开空间功能，并在组件销毁时清除所有内容。</p><pre class="kh ki kj kk gu nm nl nn no aw np bi"><span id="4203" class="nq mb ir nl b gz nr ns l nt nu">ngOnDestroy(): void {<br/>  this.presenceService.setPresenceOffline(<br/>  { key: this.user.uid },<br/>    this.roomId<br/>  );<br/>  this.client.leave();<br/>}</span><span id="849d" class="nq mb ir nl b gz od ns l nt nu">public leaveRoom(): void {<br/>  if (this.localStream) {<br/>    this.localStream.stop();<br/>    this.localStream.close();<br/>  }<br/>  this.route.navigate(['/rooms']);<br/>}</span></pre><p id="6c4c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">恭喜你！我们完了！</p><p id="deb0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">完整的应用示例可在<a class="ae kw" href="https://github.com/Golosay/clubhouse-tutorial" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><h1 id="c74e" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">结论</h1><p id="90a5" class="pw-post-body-paragraph kx ky ir kz b la mu js lc ld mv jv lf lg nz li lj lk oa lm ln lo ob lq lr ls ik bi translated">本文中的代码仅用于教程目的，并不适合生产，但足以了解如何实现一对多流媒体应用程序。</p><p id="c7c6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可以在Medium上关注我的更多科技文章，也可以在<a class="ae kw" href="https://twitter.com/golosay" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上找到我。</p></div></div>    
</body>
</html>