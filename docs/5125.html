<html>
<head>
<title>How to Create Custom Headers with Express and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Express和TypeScript创建自定义标题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-custom-headers-with-express-and-typescript-b964d3f0be89?source=collection_archive---------4-----------------------#2021-10-18">https://javascript.plainenglish.io/how-to-create-custom-headers-with-express-and-typescript-b964d3f0be89?source=collection_archive---------4-----------------------#2021-10-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5c19c7c982469f67c21f09de05ce909b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onOQ8hrfZ1aGS0ppzpDN2w.png"/></div></div></figure><p id="3803" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我不得不创建一个将一些数据存储在PostgreSQL数据库中的云函数。一旦我完成了所有的工作，或者至少完成了最小的功能，我必须为我的端点添加某种基本的认证。没什么新的，我们只是在这里使用了一个定制的标准头，“企业密钥”，它将告诉我哪个客户端正在执行请求。</p><p id="ac36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能会认为这很简单，但是我花了将近5个小时的研究才弄明白如何实现它。因为我想帮助任何可能有同样问题的人，所以我决定写这篇文章。我们开始吧！</p><p id="8baa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我假设您对Node.js、Express、TypeScript等有所了解。您需要做的第一件事是创建一个<strong class="jx io"> CustomRequest </strong>接口，该接口将从Express的<strong class="jx io"> Request </strong>接口扩展而来，如下所示:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="9302" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，一切顺利。此时，我们可以添加任意多的属性，但是它们必须是可选的(使用<strong class="jx io">？</strong>运算符)，例如:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="778c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这样做，您将能够将<code class="fe kz la lb lc b">myAwesomeProperty</code>作为<code class="fe kz la lb lc b">request</code>对象的一个属性来访问。现在你可能认为下一步是创建一个名为<em class="ld"> headers </em>的属性，并将其定义为一个对象，然后在那里添加我们的新属性，例如<code class="fe kz la lb lc b">customHeader</code>:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="a76d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您使用上面的代码并试图从<code class="fe kz la lb lc b">headers</code>中访问<code class="fe kz la lb lc b">customHeader</code>属性，您的编译器将会出现一个巨大的错误，类似于:</p><pre class="kt ku kv kw gt le lc lf lg aw lh bi"><span id="0570" class="li lj in lc b gy lk ll l lm ln">No overload matches this call. (...)</span><span id="5e93" class="li lj in lc b gy lo ll l lm ln">Types of property 'headers' are incompatible.</span><span id="5c82" class="li lj in lc b gy lo ll l lm ln">Property 'customHeader' is missing in type 'IncomingHttpHeaders' but required in type '{ customHeader: string; }'.ts(2769)</span></pre><p id="9ef8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们到了，一切开始的地方。像往常一样，这是一个非常复杂和难以理解的错误，但我们可以解决它。您可能会注意到，这里重要的是<code class="fe kz la lb lc b">IncomingHttpHeaders</code>类型和我们的<code class="fe kz la lb lc b">customHeader</code>属性。如果你检查一下<code class="fe kz la lb lc b">Request</code>的定义，你会注意到它从<code class="fe kz la lb lc b">core.Request</code>接口扩展而来，而接口又从<code class="fe kz la lb lc b">http.IncomingMessage</code>类扩展而来，这个类有一个名为<code class="fe kz la lb lc b">headers</code>的属性，你猜怎么着，它的类型是<code class="fe kz la lb lc b">IncomingHttpHeaders</code>(来自<code class="fe kz la lb lc b">http</code>模块)。我们找到了！</p><p id="d793" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在我们知道<code class="fe kz la lb lc b">headers</code>来自某个类型，但是我们不能在TypeScript中扩展一个类型，对吗？嗯，从严格意义上来说，这可能是真的，但是有一种方法可以在TypeScript中“扩展”类型(更多信息请查看<a class="ae lp" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces" rel="noopener ugc nofollow" target="_blank"> this </a>)。这样做的方法是通过使用<strong class="jx io">交集</strong>，当我们交集两个或更多类型时，我们通过使用<strong class="jx io"> &amp; </strong>操作符从它们创建一个新类型。因此，我们的下一步将是从<code class="fe kz la lb lc b">http</code>导入<code class="fe kz la lb lc b">IncomingHttpHeaders</code>，并将其与我们的自定义标题相交。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="d6d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完事了吗？不完全是。如果你把这篇文章留在这里，你可能会面临和我一样的错误——每当我试图访问我的<code class="fe kz la lb lc b">customHeader</code>时，我都得到了未定义，没有任何明显的原因。在没有任何解释的情况下，您可能无法访问新的自定义页眉。但是有解决的办法！只需将<code class="fe kz la lb lc b">customHeader</code>属性更改为snake case就可以了:<code class="fe kz la lb lc b">custom-header</code>或<code class="fe kz la lb lc b">Custom-Header</code>就可以了，现在通过使用方括号(<code class="fe kz la lb lc b">req.headers['custom-header']</code>)你就可以访问自己的标题了。</p><p id="fee4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们为什么要这么做？为什么Express在使用camel case时似乎无法访问我们的自定义头？我不知道，但是如果你知道，请在这里随意评论为什么，我们都可以从你的回答中受益。</p><p id="be2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，有空的话，看看我的npm CLI工具，<a class="ae lp" href="https://www.npmjs.com/package/@anthonylzq/simba.js" rel="noopener ugc nofollow" target="_blank"> simba.js </a>。它有点像<a class="ae lp" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> cra </a>，但用于后端开发。它使用MongoDB、Express和TypeScript。只需一个简单的命令，您就可以让服务器运行一些您可能会觉得有用的端点。</p><p id="f331" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编码快乐！</p><p id="f5fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ld">更多内容请看</em><a class="ae lp" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ld">plain English . io</em></strong></a></p></div></div>    
</body>
</html>