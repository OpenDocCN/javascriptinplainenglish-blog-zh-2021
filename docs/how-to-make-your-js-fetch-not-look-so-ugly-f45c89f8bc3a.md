# 停止编写难看的 JavaScript 获取函数

> 原文：<https://javascript.plainenglish.io/how-to-make-your-js-fetch-not-look-so-ugly-f45c89f8bc3a?source=collection_archive---------0----------------------->

这是典型的 JavaScript `fetch()`函数调用的样子:

在我们大幅改进它之前，让我们先来分析一下是什么让它变得如此丑陋。

也许最令人震惊的是第一个`.then()`声明。我们有一个匿名的内部函数，它只执行一个动作，从初始的`fetch()`调用中获取响应，并转换成一个更容易使用的 JSON 对象。

您可以立即看到可读性方面的所有问题。第一，没干。每当从服务器获取数据时，您几乎总是需要执行这个操作，那么为什么我们在这个`fetch()`块的中间编写代码，而不是用一个可重用的方法呢？

虽然匿名内部函数在 JavaScript 和其他语言中很常见，但确实应该谨慎使用。“匿名”或“内部”这两个词没有任何可读性。匿名？为什么不想告诉我这是什么功能？内心？你为什么要隐藏功能？另外，我们已经在代码中加入了这个动作的核心部分。

下面的`.then()`通常是你实际想要对从数据库中获取的数据做的事情。也就是说，这是您想要对数据执行的*操作*。等等，函数不就是我们要对数据执行的操作吗？是的。

好了，关于`fetch()`电话通常是如何写的已经说得够多了，让我们开始用更好的方式来写吧。

我们可以做的第一个改进是将第一个`then()`的样板动作放入一个可重用的函数中:

这个函数需要知道的主要事情是一个`fetch()`调用总是会从某种类型的服务器返回一个响应。您可以将这个响应作为参数传递给函数(这就是我们代码中的“response”变量)。

从那里，我们简单地在响应上调用`.json()`函数，并返回该函数调用的结果，以 JSON 格式给出我们可以根据需要使用的服务器响应。

**注意:**我们没有在`.then()`中包含`()`，因为我们没有*调用* `getResponse()`，我们仅仅是*告诉* JavaScript 当它准备好的时候要去哪个函数。

现在我们有了数据，我们可以根据需要在另一个函数中处理它。

该函数应该通过它的名字清楚地表明它在做什么。出于举例的目的，我们称之为`processJSON()`。

当我们在`getResponse()`之后的`.then()`中调用这个函数时，我们将被传递这个函数返回的 JSON 对象。所以我将`processJSON()`的参数变量命名为“json ”,以提醒我们所拥有的数据。当然，您可以随意命名所有参数，并且可能希望将其命名为与您的应用程序或您正在处理的数据更相关的名称。

哇，我们的`fetch()`现在看起来好多了！我们不仅没有在代码中间展开函数，而且更加枯燥，因为我们可以在任何需要的时候调用`fetch()`块中的`getResponse()`和`processJSON()`。我们还对可读性做了很大的改进。我们现在拥有的实际上是伪代码；它读起来和实际发生的事情非常相似。"获取数据，然后得到响应，然后处理 JSON . "

有人可以确切地知道我们的程序是如何工作的，而根本不需要看到实现细节。这才是真正的可读性。

虽然我们的`fetch()`语句看起来确实更好，但是我们仍然传递了硬编码的 URL。它不仅看起来很糟糕，而且如果我们对后端进行更改，它可能会崩溃，我们必须找到它的每个实例来修复它。我想你知道这是怎么回事。

我们将获取路径保存在一个名为 following RESTful conventions 的常量中。我们使代码更新变得更加容易，并使我们的获取更加干净:

谈谈从零到英雄！我们最初的代码是杂乱的，不干燥的，可读性不是很好。我们在这三个方面都有了很大的改进。那，就是你怎么写一个`fetch()`。

## 但是发帖打补丁呢？

你说得对，用`fetch()`调用写入数据库会变得相当混乱，主要是因为需要用`fetch()`请求传递一个 http 对象(下面代码片段中的第 3–8 行)。

让我们一扫而光。

我们将编写一个名为`writeServer()`的可重用函数，它将为 fetch 调用生成并返回 http 请求。

`writeServer()`的两个参数 action 和 data 允许我们对 POST、PATCH 和 DELETE 请求使用相同的函数。当我们调用函数(动作)时，我们简单地指定 http 动词，并包括我们正在发布或修补的数据。

如果没有，例如删除请求，“数据”默认设置为空对象。作为一个重要的提醒，您需要在 fetch 调用中包含括号()(下面的第 2 行)。

我们*调用*的`writeServer()`函数来获取它的返回值，并将其作为参数传递给我们的`fetch()`调用。如果你将变量传递给`writeServer()`，这就更容易记住了。

在数据库中创建新电影的 fetch 调用可能如下所示:

Yeeeaah.

它是枯燥的，可读的，灵活的。比我们开始的地方有了巨大的进步。

*更多内容请看*[***plain English . io***](http://plainenglish.io)