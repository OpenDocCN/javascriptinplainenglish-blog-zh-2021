<html>
<head>
<title>HTTP Interceptors in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的HTTP拦截器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/http-interceptors-in-react-4dd7a35ba297?source=collection_archive---------1-----------------------#2021-05-11">https://javascript.plainenglish.io/http-interceptors-in-react-4dd7a35ba297?source=collection_archive---------1-----------------------#2021-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8310" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为你的React应用编写超级拦截器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/351e31f68451759b40f436f276441175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6xgNi2UxJUNn6A27lD7Bg.png"/></div></div></figure><p id="7682" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React的核心只是一个视图库，让您的DOM更新和状态管理变得更加容易。它消除了许多管理和担心漂亮UI的视图部分的负担。</p><p id="c3ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我是一名全栈工程师，经常使用JavaScript的三个主要UI框架——Angular、React和Vue.js。当我从一个框架转换到另一个框架时，我可以感受到另一个框架中我喜欢的和不喜欢的东西。但是，根据您的使用情况，或者有时是因为业务需要，这是由许多因素造成的，您必须仔细选择您的武器库。</p><p id="d32f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular是一个完全电池加载的框架，其次是Vue.js，然后是React，这在很大程度上依赖于许多第三方库。但就其受欢迎程度或招聘信息而言，React仍然是一个主要的赢家，这取决于你属于世界的哪个部分。</p><p id="d016" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一名开发人员，我在心里对所有这些框架有一个很好的位置，这些是我们正在见证的一些令人惊叹的技术。由于互联网上充斥着这类文章，我不会深入比较这三者的本质。但是，我将根据您的经验和使用案例来比较这三者，以帮助您选择最佳方案。</p><p id="4006" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题空间</strong></p><p id="fbfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个动态UI都需要与后端交互，最流行的方式是使用HTTP调用。大多数情况下，代码的某个部分可能是一个头或特定的操作，您需要在分派请求之前或接收响应之后对HTTP调用执行这些操作。</p><p id="e4ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解决方案</strong></p><p id="b541" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于angular来说，这很简单，并作为一个特性添加到Angular提供的<a class="ae ku" href="https://angular.io/api/common/http" rel="noopener ugc nofollow" target="_blank"> @angular/common/http </a>模块中。</p><p id="cbd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果对此感兴趣，您可以继续关注:</p><div class="kv kw gp gr kx ky"><a href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab fo"><div class="la ab lb cl cj lc"><h2 class="bd io gy z fp ld fr fs le fu fw im bi translated">有角的</h2><div class="lf l"><h3 class="bd b gy z fp ld fr fs le fu fw dk translated">Angular是一个构建移动和桌面web应用程序的平台。加入数百万开发者的社区…</h3></div><div class="lg l"><p class="bd b dl z fp ld fr fs le fu fw dk translated">angular.io</p></div></div></div></a></div><p id="8dbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们的目标不同。我们希望在React中有类似的功能。在发送请求和接收响应之前做一些事情的拦截器。</p><p id="297a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用的工具集:</p><pre class="kj kk kl km gt lh li lj lk aw ll bi"><span id="8d06" class="lm ln in li b gy lo lp l lq lr">"axios": "^0.21.1",</span></pre><p id="8027" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Axios是一个使用非常广泛的库，你会在很多在线项目中发现它的集成。</p><p id="b29c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其余的都将与create-react-app提供的所有基本内容相同。</p><p id="3d3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个初学者教程中，我们将做2个拦截器。</p><h2 id="979d" class="lm ln in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">基本设置:</h2><pre class="kj kk kl km gt lh li lj lk aw ll bi"><span id="124e" class="lm ln in li b gy lo lp l lq lr">import axios from "axios";</span><span id="02ec" class="lm ln in li b gy mj lp l lq lr">import errorInterceptor from "./interceptors/error";</span><span id="57d6" class="lm ln in li b gy mj lp l lq lr">import updateHeaderInterceptor from "./interceptors/updateHeader";</span><span id="63d0" class="lm ln in li b gy mj lp l lq lr">const httpClient = axios.create({</span><span id="b937" class="lm ln in li b gy mj lp l lq lr">baseURL: process.env.REACT_APP_API_URL,</span><span id="62b4" class="lm ln in li b gy mj lp l lq lr">});</span><span id="0054" class="lm ln in li b gy mj lp l lq lr">errorInterceptor(httpClient);</span><span id="cf15" class="lm ln in li b gy mj lp l lq lr">updateHeaderInterceptor(httpClient);</span><span id="46fb" class="lm ln in li b gy mj lp l lq lr">export default httpClient;</span></pre><p id="e02b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">调用调用:</p><pre class="kj kk kl km gt lh li lj lk aw ll bi"><span id="aaa7" class="lm ln in li b gy lo lp l lq lr">React.useEffect(() =&gt; {</span><span id="e4c8" class="lm ln in li b gy mj lp l lq lr">httpClient.get("/");</span><span id="4a7c" class="lm ln in li b gy mj lp l lq lr">}, []);</span></pre><h2 id="b499" class="lm ln in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">请求拦截器:</h2><p id="543b" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">这是一个拦截器，位于您的所有请求之间，并将一个JWT令牌附加到我们客户端的所有身份验证请求上。JWT就是一个例子。在请求发出之前，您可以对其进行各种各样的处理。</p><pre class="kj kk kl km gt lh li lj lk aw ll bi"><span id="ba2d" class="lm ln in li b gy lo lp l lq lr">const updateHeaderInterceptor = (<em class="mp">axiosInstance</em>) =&gt; {</span><span id="c3ec" class="lm ln in li b gy mj lp l lq lr"><em class="mp">axiosInstance</em>.interceptors.request.use((<em class="mp">config</em>) =&gt; {</span><span id="3422" class="lm ln in li b gy mj lp l lq lr">   const jwtToken = "Bearer Token from Localstorage";</span><span id="e6e3" class="lm ln in li b gy mj lp l lq lr"><em class="mp">   config</em>.headers["Authorization"] = jwtToken;</span><span id="e447" class="lm ln in li b gy mj lp l lq lr">   return <em class="mp">config</em>;<br/>},(<em class="mp">error</em>) =&gt; {<br/>   <br/>});</span><span id="f731" class="lm ln in li b gy mj lp l lq lr">};</span><span id="8b75" class="lm ln in li b gy mj lp l lq lr">export default updateHeaderInterceptor;<br/></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/1d1c9e121630d3484734d9a4e4ac22bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7MYC5Uyv4PQ_HYMst67ow.png"/></div></div></figure><p id="85a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到拦截器使用这种模式附加的授权。我们可以用几行代码将我们的JWT令牌添加到所有的请求中。</p><h2 id="d56c" class="lm ln in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">响应拦截器:</h2><pre class="kj kk kl km gt lh li lj lk aw ll bi"><span id="dd3b" class="lm ln in li b gy lo lp l lq lr">const DEBUG = process.env.REACT_APP_NODE_ENV !== "production";</span><span id="c7d7" class="lm ln in li b gy mj lp l lq lr">const errorInterceptor = (<em class="mp">axiosInstance</em>) =&gt; {</span><span id="52fa" class="lm ln in li b gy mj lp l lq lr"><em class="mp">axiosInstance</em>.interceptors.response.use((<em class="mp">response</em>) =&gt; {</span><span id="0729" class="lm ln in li b gy mj lp l lq lr">  //Response Successful</span><span id="deb1" class="lm ln in li b gy mj lp l lq lr">},(<em class="mp">error</em>) =&gt; {</span><span id="75cf" class="lm ln in li b gy mj lp l lq lr">   if (<em class="mp">error</em>?.status?.code === 401) {</span><span id="8fef" class="lm ln in li b gy mj lp l lq lr">     //Unauthorized</span><span id="97ac" class="lm ln in li b gy mj lp l lq lr"><em class="mp">     //redirect to Login</em></span><span id="a0d4" class="lm ln in li b gy mj lp l lq lr">   } else {</span><span id="85ed" class="lm ln in li b gy mj lp l lq lr"><em class="mp">    //dispatch your error in a more user friendly manner</em></span><span id="af79" class="lm ln in li b gy mj lp l lq lr">      if (DEBUG) {<br/>      //easier debugging</span><span id="81f7" class="lm ln in li b gy mj lp l lq lr">      console.group("Error");</span><span id="3714" class="lm ln in li b gy mj lp l lq lr">      console.log(<em class="mp">error</em>);</span><span id="359b" class="lm ln in li b gy mj lp l lq lr">      console.groupEnd();</span><span id="d389" class="lm ln in li b gy mj lp l lq lr">     }</span><span id="6538" class="lm ln in li b gy mj lp l lq lr">  }</span><span id="1e04" class="lm ln in li b gy mj lp l lq lr">});</span><span id="e8e8" class="lm ln in li b gy mj lp l lq lr">};</span><span id="98a3" class="lm ln in li b gy mj lp l lq lr">export default errorInterceptor;</span></pre><p id="906b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们可以看到我们的控制台组错误，因为我们没有任何后端连接到我们的用户界面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/f3d63f1ba5fb974748b999cc59d96fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DC2Tlz_JghADdMpjro0Hg.png"/></div></div></figure></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><p id="b2d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接近尾声时，这是一个非常基本的教程，我们可以看到用很少的代码行使用这种模式可以做多少事情。我们可以在一个地方管理我们所有的错误处理，除此之外，在他们自己的拦截器中有共同的模式，使得他们非常容易理解并在日常工作中使用。</p><p id="facf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一名完整的工程师和架构师，请继续关注我提出的更多现实问题及其解决方案。和平！</p><p id="9883" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mp">更内容于</em> <a class="ae ku" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">通俗易懂</em> </a></p></div></div>    
</body>
</html>