<html>
<head>
<title>How to Improve Your Express Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高你的快递申请</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-things-you-can-do-to-make-an-express-application-become-better-4a357e0f7d9?source=collection_archive---------8-----------------------#2021-04-04">https://javascript.plainenglish.io/5-things-you-can-do-to-make-an-express-application-become-better-4a357e0f7d9?source=collection_archive---------8-----------------------#2021-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d0d83b55cd3d413dde71a0d2f158063f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAewNEIXS4NbR8-ps2ltGw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@codestorm" rel="noopener ugc nofollow" target="_blank">Safar Safarov</a> on <a class="ae jz" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>.</figcaption></figure><h2 id="bebc" class="ka kb in bd kc kd ke dn kf kg kh dp ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.使用TypeScript</h2><p id="4fdd" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">这只是我的推荐。我在2017年开始与TypeScript合作，然后我成为Typescript爱好者。我的团队成员也很喜欢它。</p><p id="06f2" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">使用TypeScript的主要好处是在错误进入生产之前捕捉更多的错误，并使您更容易使用代码库。</p><p id="1c97" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated"><strong class="ky io">打字优惠:</strong></p><ul class=""><li id="23ec" class="lw lx in ky b kz lr ld ls kj ly kn lz kr ma lq mb mc md me bi translated">静态类型——如果您来自强类型语言，如Java的C#，那么很容易开始。</li><li id="b9b5" class="lw lx in ky b kz mf ld mg kj mh kn mi kr mj lq mb mc md me bi translated">大型编码项目的更好选择——当您在团队中工作时，您的团队应该保持代码库的整洁和可维护性。当大型编码项目有许多开发人员时，就有可能出现混乱的编码。并且错误的数量增加，这使得处理它们变得困难。因此，类型安全具有在编码时检测错误的特性。这使得代码更加高效，我们也可以轻松地调试它。</li><li id="b5c7" class="lw lx in ky b kz mf ld mg kj mh kn mi kr mj lq mb mc md me bi translated">更高的工作效率ECMAScript 6代码、动态类型、IDE或具有自动完成功能的编辑器等特性有助于开发人员提高工作效率。</li></ul><p id="6b03" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated"><strong class="ky io"> JavaScript的好处:</strong></p><ul class=""><li id="0c26" class="lw lx in ky b kz lr ld ls kj ly kn lz kr ma lq mb mc md me bi translated">它有一个巨大的活跃的开发者社区，这使它成为一种流行的语言。</li><li id="79ab" class="lw lx in ky b kz mf ld mg kj mh kn mi kr mj lq mb mc md me bi translated">它支持原生浏览器。而TypeScript将首先被编译，然后被转换成JavaScript。这就产生了一个额外的步骤。</li><li id="5afe" class="lw lx in ky b kz mf ld mg kj mh kn mi kr mj lq mb mc md me bi translated">更加灵活。</li></ul><h2 id="df8d" class="ka kb in bd kc kd ke dn kf kg kh dp ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.导出快速实例</h2><p id="64b8" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">对于Express，我编写了这样一个Express服务器:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="790e" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">我在Express定义文件中启动HTTP服务器。如果您只导出<code class="fe mq mr ms mt b">app</code>对象并使用这个<code class="fe mq mr ms mt b">app</code>在另一个逻辑文件中启动HTTP服务器，效果会更好。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1735" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">这样，你可以将你的<code class="fe mq mr ms mt b">app</code>用于各种目的。尤其是你不想“启动”你的<code class="fe mq mr ms mt b">app</code>的时候。例如，用<code class="fe mq mr ms mt b">supertest</code>为您的<code class="fe mq mr ms mt b">app</code>编写测试:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="982b" class="ka kb in mt b gy my mz l na nb">import app import '../app';</span><span id="7a80" class="ka kb in mt b gy nc mz l na nb">request(app)<br/>  .get('/user')<br/>  .expect('Content-Type', /json/)<br/>  .expect(200)<br/>  .end(function(err, res) {<br/>    if (err) throw err;<br/>  });</span></pre><p id="332a" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">或者，将您的Express服务器与另一个框架集成，如<code class="fe mq mr ms mt b">firebase-functions</code>:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="2237" class="ka kb in mt b gy my mz l na nb">import app import '../app';<br/>import functions from 'firebase-functions';</span><span id="6356" class="ka kb in mt b gy nc mz l na nb">// ...</span><span id="0341" class="ka kb in mt b gy nc mz l na nb">exports.app = functions.https.onRequest(app);</span></pre><p id="1ce3" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated"><code class="fe mq mr ms mt b">Aws-lambda-function</code>同<code class="fe mq mr ms mt b"><a class="ae jz" href="https://github.com/dougmoscrop/serverless-http" rel="noopener ugc nofollow" target="_blank">serverless-http</a></code>:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="acdb" class="ka kb in mt b gy my mz l na nb">import app import '../app';<br/>import serverless from 'serverless-http';</span><span id="39a0" class="ka kb in mt b gy nc mz l na nb">// ...<br/>exports.handler = serverless(app);</span></pre><h2 id="8470" class="ka kb in bd kc kd ke dn kf kg kh dp ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.异步处理程序</h2><p id="f888" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">一个普通的快速错误处理程序如下所示:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="f72c" class="ka kb in mt b gy my mz l na nb">app.use(function(error: Error, req: Request, res: Response, next: NextFunction) {<br/>  if (error instanceof AppError) {<br/>    res.status(error.status);<br/>  } else {<br/>    res.status(500);<br/>  }<br/>  res.json({ message: error.message });<br/>});</span></pre><p id="6d0f" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">用<code class="fe mq mr ms mt b">AppError</code>:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="0da0" class="ka kb in mt b gy my mz l na nb">export default class AppError extends Error {<br/>  constructor(<br/>    public status = 400,<br/>    public message = '',<br/>  ) {<br/>    super(message);<br/>    Object.setPrototypeOf(this, new.target.prototype);<br/>  }<br/>}</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="6ae0" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">当前的Express稳定版本不能处理处理函数中抛出的错误，你必须用错误中的第一个参数调用<code class="fe mq mr ms mt b">next</code>函数。</p><p id="837a" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">例如，您有一条使用<code class="fe mq mr ms mt b">async/await</code>的路线:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="6c93" class="ka kb in mt b gy my mz l na nb">app.get('/users/:userId', async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>  const { userId } = req.params<br/>  const user = await userService.getUserById(userId);<br/>  res.status(200).json(user);<br/>});</span></pre><p id="5e98" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">如果<code class="fe mq mr ms mt b">.getUserById</code>抛出一个错误(比如:<code class="fe mq mr ms mt b">throw new AppError(404, 'User not found!');</code>，你的服务器会崩溃，错误无法处理。为了避免这种情况，我对许多人(包括我自己，第一次)说，使用<code class="fe mq mr ms mt b">try/catch</code>块来处理它:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="f202" class="ka kb in mt b gy my mz l na nb">app.get('/users', async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>  try {<br/>    const { userId } = req.params<br/>    const user = await userService.getUserById(userId);<br/>    res.status(200).json(user);<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span></pre><p id="d4d9" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">现在它工作得很好！</p><p id="1a09" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">但是在每个请求处理程序中有一个<code class="fe mq mr ms mt b">try/catch</code>语句是很糟糕的。它们使得请求处理程序看起来比实际更复杂。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="2869" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">我们有一个更好的方法来处理路由器中的错误——使用wrap异步句柄。</p><p id="1581" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">众所周知，异步函数总是返回一个承诺。这意味着我们可以使用<code class="fe mq mr ms mt b">async/await</code>或仅仅通过<code class="fe mq mr ms mt b">catch</code>链函数来处理<code class="fe mq mr ms mt b">try/catch</code>的错误。</p><p id="5141" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">让我们创建一个函数，它使用请求句柄作为参数，调用处理函数，并在抛出错误时捕获错误。该函数还返回一个函数作为新的请求处理函数。</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="1e1d" class="ka kb in mt b gy my mz l na nb">export const asyncHandlerWrap = (<br/>  handler: (req: Request, res: Response, next?: NextFunction) =&gt; Promise&lt;any&gt;,<br/>) =&gt; {<br/>  return (req: Request, res: Response, next: NextFunction) =&gt; {<br/>    handler(req, res, next)<br/>      .catch(next);<br/>  }<br/>}</span></pre><p id="497d" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">更新到<code class="fe mq mr ms mt b">GET /users</code>路由器。</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="8299" class="ka kb in mt b gy my mz l na nb">app.get('/users', asyncHandlerWrap(async (req: Request, res: Response) =&gt; {<br/>  const { userId } = req.params<br/>  const user = await userService.getUserById(userId);<br/>  res.status(200).json(user);<br/>}));</span></pre><p id="e622" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">包装功能可以应用于请求处理器或中间件。我们仍然可以像平常一样调用<code class="fe mq mr ms mt b">next</code>函数。但是抛出一个错误，而不是调用下一个有错误的函数。这样会让我们的逻辑容易理解。</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="7e43" class="ka kb in mt b gy my mz l na nb">// User token middleware<br/>app.use(asyncHandlerWrap(async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>  const userToken = req.get('authorization');<br/>  const user = await userService.findByToken(userToken);</span><span id="cb14" class="ka kb in mt b gy nc mz l na nb">  if (!user) {<br/>    throw AppError(401, "access denied");<br/>  }</span><span id="02f0" class="ka kb in mt b gy nc mz l na nb">  req.user = user;<br/>  next();<br/>}));</span></pre><h2 id="7105" class="ka kb in bd kc kd ke dn kf kg kh dp ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.自定义请求对象的类型定义</h2><p id="80e4" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">如果您的项目不使用Typescript，可以跳过这一部分。</p><p id="ec7d" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">自定义对象是具有一个或多个额外属性的快速请求对象。最常见的例子是“add”，它是用户认证中间件中请求对象的用户信息对象。</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="7051" class="ka kb in mt b gy my mz l na nb">// User token middleware<br/>app.use(asyncHandlerWrap(async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>  const userToken = req.get('authorization');<br/>  const user = await userService.findByToken(userToken);</span><span id="0b70" class="ka kb in mt b gy nc mz l na nb">  if (!user) {<br/>    throw AppError(401, "access denied");<br/>  }</span><span id="ca3e" class="ka kb in mt b gy nc mz l na nb">  (req as any).user = user; // This line<br/>  next();<br/>}));</span></pre><p id="9896" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">然后，我们可以在“下一个”中间件或处理程序中获得<code class="fe mq mr ms mt b">user</code>数据:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="4c1b" class="ka kb in mt b gy my mz l na nb">app.get('/users/friends', async (req: Request, res: Response) =&gt; {<br/>  const { user } = (req as any); // const user: IUser = (req as any).user;<br/>  const friends = await userService.getFriendsOfUserId(user.id);<br/>  res.json(friends);<br/>});</span></pre><p id="d797" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">我们可以看到，<code class="fe mq mr ms mt b">req.user</code>会抛出一个TypeScript错误— <code class="fe mq mr ms mt b">Property ‘user’ does not exist on type ‘Request…</code>。然后，我们必须将req对象或包含<code class="fe mq mr ms mt b">user</code>属性的类型转换为用户对象类型- <code class="fe mq mr ms mt b">IUser</code>。</p><p id="db34" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">让我们定义一个自定义请求对象，如下所示:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="eb05" class="ka kb in mt b gy my mz l na nb">import { Request } from "express";<br/>interface AuthenticatedRequest extends Request {<br/>  user?: IUser;<br/>}</span></pre><p id="c1d2" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">我们扩展<code class="fe mq mr ms mt b">express.Request</code>类型，<code class="fe mq mr ms mt b">user</code>是一条附加信息。<code class="fe mq mr ms mt b">user</code>应该是可选的，那么新建的类型可以赋给<code class="fe mq mr ms mt b">Request</code>类型。</p><p id="8e0d" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">中间件和请求处理器的<code class="fe mq mr ms mt b">req</code>参数的更新类型:</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="42bb" class="ka kb in mt b gy my mz l na nb">// User token middleware<br/>app.use(async (req: AuthenticatedRequest, res: Response, next: NextFunction) =&gt; {<br/>  const userToken = req.get('authorization');<br/>  const user = await userService.findByToken(userToken);<br/>  if (!user) {<br/>    throw AppError(401, "access denied");<br/>  }<br/>  req.user = user; // This line<br/>  next();<br/>});</span><span id="5d93" class="ka kb in mt b gy nc mz l na nb">// Request handler<br/>app.get('/users/friends', async (req: AuthenticatedRequest, res: Response) =&gt; {<br/>  const { user } = req; // const user: IUser = (req as any).user;<br/>  const friends = await userService.getFriendsOfUserId(user.id);<br/>  res.json(friends);<br/>});</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="babb" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">我们可以对像<code class="fe mq mr ms mt b">params, body...</code>这样的请求对象的现有数据做同样的事情</p><p id="d701" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">示例:<code class="fe mq mr ms mt b">POST /users/friends/:friendId/messages</code>的请求对象</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="5ee8" class="ka kb in mt b gy my mz l na nb">interface SendMessageRequest extends AuthenticatedRequest {<br/>  params: {<br/>    friendId: string,<br/>  };<br/>  body: SendMessageDTO,<br/>}</span></pre><figure class="mk ml mm mn gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/d3218974e669faa5393612360a6e6c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00V8bg5qgwDDnWiyTylHLA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Autocomplete for property name</figcaption></figure><h2 id="d32f" class="ka kb in bd kc kd ke dn kf kg kh dp ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.继承路由器</h2><p id="4d36" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">这只是我们使用Express时的一个小技巧。在普通的Express应用程序中，我们通常在将路由器注册到应用程序之前注册一个中间件。</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="9538" class="ka kb in mt b gy my mz l na nb">// "Public" routers<br/>app.use('/auth', authRouter);</span><span id="f29b" class="ka kb in mt b gy nc mz l na nb">// Register authenticate middleware<br/>app.user(jwtAuthMiddleware);</span><span id="c42c" class="ka kb in mt b gy nc mz l na nb">// Requires authentication routers<br/>app.user('/users', userRouter);<br/>app.user('/documents', documentRouter);</span><span id="bb8b" class="ka kb in mt b gy nc mz l na nb">// Register admin authorization<br/>app.user(adminAuthMiddleware);</span><span id="0607" class="ka kb in mt b gy nc mz l na nb">// Admin routers<br/>app.use('/admin/users', adminUserRouter);</span><span id="8f60" class="ka kb in mt b gy nc mz l na nb">// ...</span></pre><p id="53f0" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">秩序如此重要。我们必须记住在哪里注册中间件，在哪里注册新的路由器。</p><p id="6f33" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">这个提示将帮助我们更好地控制这种情况。</p><p id="c3a0" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">我们创建一个路由器“工厂”来生成一个基础路由器，然后使用这个路由器来创建一个新的路由器。基本路由将在返回之前注册“公共”中间件。</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="64ce" class="ka kb in mt b gy my mz l na nb">// base router<br/>class AuthenticatedRouter {<br/>  protected router: Router;</span><span id="c418" class="ka kb in mt b gy nc mz l na nb">  constructor() {<br/>    this.router = Router();<br/>    this.router.use(jwtAuthMiddleware);<br/>  }</span><span id="a32b" class="ka kb in mt b gy nc mz l na nb">  getRouter() {<br/>    return this.router;<br/>  }<br/>}</span><span id="120c" class="ka kb in mt b gy nc mz l na nb">class BaseAdminRouter extends AuthenticatedRouter {<br/>  constructor() {<br/>    super();<br/>    this.router.use(adminAuthMiddleware);<br/>  }<br/>}</span><span id="2f0b" class="ka kb in mt b gy nc mz l na nb">// child routers<br/>class UserRouter extends AuthenticatedRouter {<br/>  constructor() {<br/>    super();<br/>    this.router.get('/', userController.getUsers);<br/>    // ...<br/>  }<br/>}</span><span id="b89c" class="ka kb in mt b gy nc mz l na nb">class AdminUserRouter extends BaseAdminRouter {<br/>  constructor() {<br/>    super();<br/>    this.router.post('/', adminController.createUser);<br/>    // ...<br/>  }<br/>}</span></pre><p id="59d4" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">现在，在应用程序中，不需要注册“公共”中间件，顺序也无关紧要。</p><pre class="mk ml mm mn gt mu mt mv mw aw mx bi"><span id="a2ae" class="ka kb in mt b gy my mz l na nb">// "Public" routers<br/>app.use('/auth', authRouter);</span><span id="5828" class="ka kb in mt b gy nc mz l na nb">// Admin routers<br/>app.use('/admin/users', adminUserRouter);</span><span id="114a" class="ka kb in mt b gy nc mz l na nb">// Requires authentication routers<br/>app.user('/users', userRouter);<br/>app.user('/documents', documentRouter);</span></pre><h2 id="81bb" class="ka kb in bd kc kd ke dn kf kg kh dp ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h2><p id="661a" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">我们有太多的东西可以帮助改进我们的应用程序。但是每当我用Express开始一个新项目时，这是我经常做的5件事。</p><p id="208f" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated">感谢您的阅读！</p><p id="aa59" class="pw-post-body-paragraph kw kx in ky b kz lr lb lc ld ls lf lg kj lt li lj kn lu ll lm kr lv lo lp lq ig bi translated"><em class="nl">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nl">plain English . io</em></a></p></div></div>    
</body>
</html>