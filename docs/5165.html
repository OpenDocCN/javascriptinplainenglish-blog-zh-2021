<html>
<head>
<title>How to Pass Commit Hash to an Environment Variable Using Webpack Plugin in Vue 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vue 3中使用Webpack插件将提交散列传递给环境变量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/passing-commit-hash-to-an-environmental-variable-using-webpack-plugin-in-vue-3-a1d5fcae22e?source=collection_archive---------5-----------------------#2021-10-20">https://javascript.plainenglish.io/passing-commit-hash-to-an-environmental-variable-using-webpack-plugin-in-vue-3-a1d5fcae22e?source=collection_archive---------5-----------------------#2021-10-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5e93f5f4826e7ff1c95802dbaf08ef0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G5RtJyVLd4EZ5Z8f"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@nublson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nubelson Fernandes</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="81cd" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">如何确定应用程序是从哪个提交构建的？</h1><p id="4de7" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">将应用程序部署到多个实例(例如，许多客户端)可能会导致问题。当有人报告一个错误时，您可能想知道如何确定特定客户端使用的应用程序的版本。在evonica中，我们有这样的需求，因为我们的应用程序正在被许多航空公司使用。</p><p id="b9f8" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">当然，有许多不同的方法可以做到这一点。您可以只检查最新的部署，但这需要一些时间。为什么客户端不在错误报告中提供应用版本呢？如果你还没有任何自动化的错误报告工具，找出它的确切版本可能会有点棘手。</p><p id="01d5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">当然，你可以在里面的某个地方打印应用程序版本。但是您需要记住在两次发布之间更新它。让我们直截了当地说吧——当你可以自动化的时候，你没有成为一个程序员去执行手工的可重复的任务。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/02e767f3cc1325173292c9025b2b9432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ZGu-NUvTNGv1p9-7PBj5Q.png"/></div></div></figure><h1 id="d4fb" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">我们大多数人使用git</h1><p id="490f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">可能你的应用程序存储在某个版本控制系统中的某个地方(如果你不使用这样的解决方案——你是一个非常勇敢的人😉).让我们假设您在项目中使用git。有没有比commit hash更好的版本标识符？您可以使用以下方式在“终端”中打印它:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9b46" class="ml kb in mh b gy mm mn l mo mp">git rev-parse HEAD</span></pre><p id="37d7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这将打印当前提交的SHA散列—例如<code class="fe mq mr ms mh b">1dfc6da771f3642c5c75g933bc05ca0d5fff6736</code>。如果您给这个命令添加标志<code class="fe mq mr ms mh b">--short</code>，您将得到这个散列的简短版本—例如<code class="fe mq mr ms mh b">1dfc6da7</code>:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="eb74" class="ml kb in mh b gy mm mn l mo mp">git rev-parse --short HEAD</span></pre><h1 id="78d2" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">但是如何在构建过程中将变量传递给应用程序呢？</h1><p id="21ce" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">您可以使用环境变量来实现它。让我们为此创建一个简单的组件。<code class="fe mq mr ms mh b">process.env</code>不能在模板中直接访问，所以我们可以将它包装在组件数据中。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8bdb" class="ml kb in mh b gy mm mn l mo mp">&lt;template&gt;<br/>    &lt;div class="version-info"&gt;<br/>        {{ version }}<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="ebb1" class="ml kb in mh b gy mt mn l mo mp">&lt;script lang="ts"&gt;<br/>import { defineComponent } from 'vue';</span><span id="3022" class="ml kb in mh b gy mt mn l mo mp">export default defineComponent({<br/>    data: () =&gt; ({<br/>        version: process.env.VUE_APP_VERSION,<br/>    }),<br/>});<br/>&lt;/script&gt;</span></pre><p id="5b8f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">好了，我们已经得到了带有打印环境变量的提交散列和模板，但是如何将提交散列传递给环境变量呢？我们可以扩展我们的<code class="fe mq mr ms mh b">vue.config.js</code>。您需要创建一个Webpack插件，并将其添加到<code class="fe mq mr ms mh b">configureWebpack</code>部分的插件列表中:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0c86" class="ml kb in mh b gy mm mn l mo mp">module.exports = {<br/>    ...<br/>    configureWebpack: {<br/>        plugins: [<br/>            /*** HERE :) ***/<br/>        ],<br/>    },<br/>};</span></pre><p id="8b1b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">要创建一个Webpack插件，您需要创建一个<code class="fe mq mr ms mh b">webpack.DefinePlugin</code>类的实例，并在构造函数中定义您希望在运行时访问的值</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7319" class="ml kb in mh b gy mm mn l mo mp">new webpack.DefinePlugin(runtimeValue)</span></pre><p id="1518" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">您可以使用这样的<code class="fe mq mr ms mh b">runtimeValue</code>来定义<code class="fe mq mr ms mh b">process.env</code>变量</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3498" class="ml kb in mh b gy mm mn l mo mp">{<br/>  'process.env': {<br/>    /*** ENVIRONMENT VARIABLES ***/<br/>  },<br/>}</span></pre><p id="caf6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">因此，要定义我们的<code class="fe mq mr ms mh b">VUE_APP_VERSION</code>,我们只需使用:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="2c76" class="ml kb in mh b gy mm mn l mo mp">{<br/>  'process.env': {<br/>    VUE_APP_COMMIT_HASH: gitLastCommitHash,<br/>  },<br/>}</span></pre><p id="cbf6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">总的来说，我们有这样的结构:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a64b" class="ml kb in mh b gy mm mn l mo mp">module.exports = {<br/>    ...<br/>    configureWebpack: {<br/>        plugins: [<br/>           new webpack.DefinePlugin({<br/>                'process.env': {<br/>                    VUE_APP_COMMIT_HASH: lastCommitHash,<br/>                },<br/>            }),<br/>        ],<br/>    },<br/>};</span></pre><h1 id="3361" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">前端app中的Git命令？</h1><p id="3af5" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">但是现在—如何将终端命令结果传递给<code class="fe mq mr ms mh b">vue.config.js</code>？文件是在编译过程中加载的，我们可以在这里执行一些节点命令。有一个允许在js文件中执行终端命令:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ede6" class="ml kb in mh b gy mm mn l mo mp">const childProcess = require('child_process');</span><span id="8dc7" class="ml kb in mh b gy mt mn l mo mp">childProcess.execSync('/*** COMMAND ***/')</span></pre><p id="2db6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">作为命令，我们将使用我们的<code class="fe mq mr ms mh b">git rev-parse --short HEAD</code>。<code class="fe mq mr ms mh b">execSync()</code>可能会抛出一个错误，所以把它封装在<code class="fe mq mr ms mh b">try-catch</code>块中并把一个可能的错误输出到控制台是一个很好的做法。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="d12d" class="ml kb in mh b gy mm mn l mo mp">const childProcess = require('child_process');</span><span id="51dd" class="ml kb in mh b gy mt mn l mo mp">try {<br/>  childProcess.execSync('git rev-parse --short HEAD')<br/>} catch (e) {<br/>  console.error(e);<br/>}</span></pre><p id="ba40" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在让我们将结果存储到一个变量中。因为我们得到了<code class="fe mq mr ms mh b">try-catch</code>，我们可能永远得不到结果，所以首先—让我们用空字符串值用<code class="fe mq mr ms mh b">let</code>初始化变量。然后我们需要将<code class="fe mq mr ms mh b">execSync()</code>的结果转换成带有<code class="fe mq mr ms mh b">.toString()</code>的字符串。为了避免多余的空白，我们可以额外使用<code class="fe mq mr ms mh b">.trim()</code>。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7520" class="ml kb in mh b gy mm mn l mo mp">const childProcess = require('child_process');</span><span id="b344" class="ml kb in mh b gy mt mn l mo mp">let lastCommitHash = '';</span><span id="838a" class="ml kb in mh b gy mt mn l mo mp">try {<br/>  lastCommitHash = childProcess<br/>    .execSync('git rev-parse --short HEAD')<br/>    .toString()<br/>    .trim();<br/>} catch (e) {<br/>  console.error(e);<br/>}</span></pre><p id="3e46" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这样，我们就可以将值传递给之前创建的Webpack插件了。为了避免与字符串转义相关的错误，您可以使用<code class="fe mq mr ms mh b">JSON.stringify()</code>。</p><p id="fcea" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">就绪文件将如下所示:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="234c" class="ml kb in mh b gy mm mn l mo mp">const childProcess = require('child_process');</span><span id="cb5c" class="ml kb in mh b gy mt mn l mo mp">let lastCommitHash = '';</span><span id="45ee" class="ml kb in mh b gy mt mn l mo mp">try {<br/>  lastCommitHash = childProcess<br/>    .execSync('git rev-parse --short HEAD')<br/>    .toString()<br/>    .trim();<br/>} catch (e) {<br/>  console.error(e);<br/>}</span><span id="60ae" class="ml kb in mh b gy mt mn l mo mp">module.exports = {<br/>    configureWebpack: {<br/>        plugins: [<br/>           new webpack.DefinePlugin({<br/>                'process.env': {<br/>                    VUE_APP_COMMIT_HASH: JSON.stringify(lastCommitHash),<br/>                },<br/>            }),<br/>        ],<br/>    },<br/>};</span></pre><h1 id="d124" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">不难吧，嗯？</h1><p id="bd2a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">通过这种方式，您可以使用编译期间传递的任何外部数据来扩展应用程序。在我们的应用程序中，我们打印了提交散列和来自<code class="fe mq mr ms mh b">package.json</code>的当前应用程序版本。我们将版本信息组件放在了侧边栏中，让用户可以轻松访问。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/0bcc244f67f23346d4045f9bfaac787d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*-aECNFX3OUn3yTteKxt2gQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Version info next to copyright in the sidebar.</figcaption></figure><p id="6bc5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，当客户报告一个错误时，我们可以轻松地验证他正在使用的应用程序的版本，以及用于执行构建的提交。</p><p id="e3a4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">~ Dawid Witulski @ evonica—2021</p><p id="771c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="mv">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="mv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>