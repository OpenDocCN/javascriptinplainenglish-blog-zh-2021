<html>
<head>
<title>7 Concepts of Object-Oriented JavaScript You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的面向对象JavaScript的7个概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-concepts-of-object-oriented-javascript-you-need-to-know-5634363f6fdc?source=collection_archive---------3-----------------------#2021-04-06">https://javascript.plainenglish.io/7-concepts-of-object-oriented-javascript-you-need-to-know-5634363f6fdc?source=collection_archive---------3-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f396" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">像专业人士一样使用JavaScript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2acf55a092978b2bd94645a9891d2a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49bII3LtVCdF35f8Dg2Krw.png"/></div></div></figure><p id="1ca0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数时候，开发人员将面向对象编程与类似于<strong class="kt ir"> C++ </strong>和<strong class="kt ir"> Java </strong>的语言联系在一起，在这些语言中，你甚至需要为一个简单的命令行程序创建一个类。但是JavaScript不使用类，这导致了在实现OOP原则时的混乱。在JavaScript中使用OOP有很多原因，如下所示:</p><ul class=""><li id="1900" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><strong class="kt ir">封装:</strong>数据可以按照对该数据进行操作的功能进行分组(<em class="lw">简而言之，我们称之为</em> <strong class="kt ir"> <em class="lw">对象</em> </strong> <em class="lw"> ) </em>。</li><li id="2d1e" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><strong class="kt ir">聚合:</strong>一个对象可以引用另一个对象。</li><li id="ecc0" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><strong class="kt ir">继承:</strong>当一个新创建的对象与另一个对象具有相同的特征，但没有复制其核心功能。</li><li id="27d5" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><strong class="kt ir">多态性:</strong>单个接口可以使用多个对象实现。</li></ul><p id="e7b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">JavaScript中哪些人应该学习OOP？</strong></p><ul class=""><li id="8d7a" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">熟悉任何种类的<strong class="kt ir"> <em class="lw"> OOP </em> </strong> <em class="lw">编程</em>概念并希望在JavaScript中使用他们技能的热情开发人员。</li><li id="ce5d" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><strong class="kt ir">节点</strong>和<strong class="kt ir"> Web开发者</strong>试图构建大规模应用。</li><li id="26ec" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">想要获得更深入的语言知识的JavaScript开发新手。</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="743a" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">JavaScript中的两种不同值类型</h1><p id="7090" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated"><strong class="kt ir">原始类型</strong> <em class="lw"> </em>存储为简单数据类型，而<strong class="kt ir">引用类型<em class="lw"> </em> </strong>存储为普通<strong class="kt ir">对象</strong> ( <em class="lw">简单引用内存中的位置</em>)。最复杂的部分是JavaScript允许你像对待<em class="lw">引用类型</em>一样对待<em class="lw">原始类型</em>，这样语言对开发者来说更加一致。然而，在其他编程语言中，原语存储在<strong class="kt ir">栈</strong>中，引用存储在<strong class="kt ir">堆</strong>中，尽管在JavaScript中它们最初看起来可能是一样的，但是有很多不同之处。</p><h2 id="bd08" class="ng mk iq bd ml nh ni dn mp nj nk dp mt la nl nm mv le nn no mx li np nq mz nr bi translated"><strong class="ak">原始类型</strong></h2><p id="87fa" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">它们是简单的数据片段，以这种方式存储<strong class="kt ir">真</strong>或<strong class="kt ir"> 30，JavaScript中有5种基本类型，如下所示:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/ea51799d74a3c02e606bc322356da4ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgB2AxA1HqeVX2wjHt8q-g.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk"><strong class="bd nx">Primitive Types</strong></figcaption></figure><p id="8a9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，请注意，在JavaScript中，保存一个<strong class="kt ir">原语</strong>的变量直接包含一个<strong class="kt ir">原语值</strong>而不是指向该对象的指针，我们可以简单地说，当将一个原语值赋给一个变量时，该值被复制到该变量中。</p><p id="2e48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lw">例如:</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/2884bb836ad1ecd09928b77f0f547b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*troqA2h1tHe2gQZG0aRgPA.png"/></div></figure><ul class=""><li id="f27d" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">当<strong class="kt ir"> color1 </strong>被赋予<strong class="kt ir">‘蓝色’，</strong>的值，然后color2被赋予<strong class="kt ir"> </strong>的值color1将<strong class="kt ir">‘蓝色’</strong>存储在<strong class="kt ir"> color2中。</strong></li><li id="fa3a" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">尽管从外表上看它们是一样的，但在引擎盖下，有更多的东西需要了解。</li><li id="12fc" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">有时开发人员会对值是如何存储的感到困惑，这导致他们缺乏对JavaScript基础知识的理解，在这个例子中，我们可以在不影响<strong class="kt ir"> color1 </strong>的情况下更改<strong class="kt ir"> color2 </strong>的值，反之亦然。</li><li id="86ca" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">用更简单的话来说，你可以说这两个变量有完全不同的位置&amp;值的变化不会影响其余的相关变量。</li></ul><blockquote class="nz"><p id="d86b" class="oa ob iq bd oc od oe of og oh oi lm dk translated">您将从控制台结果中清楚地了解到:</p></blockquote><figure class="ok ol om on oo kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/cb8e1cfa3d46498bf634c7d71cab5cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cv1qE8IwbHrnrWUdi8kNQ.png"/></div></div></figure><p id="a036" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意:</strong>原语值本身不是对象，JavaScript使它们看起来像对象，以提供语言中一致的体验。</p><h2 id="ac4a" class="ng mk iq bd ml nh ni dn mp nj nk dp mt la nl nm mv le nn no mx li np nq mz nr bi translated"><strong class="ak">参考类型</strong></h2><p id="0963" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我们可以调用<strong class="kt ir">类</strong>作为JavaScript中最接近表示<em class="lw">引用类型</em>的东西，其中引用值是引用类型的实例。这些类型并不将对象直接保存在它所赋给的变量中。</p><p id="ef51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lw">例如:</em> </strong></p><ul class=""><li id="a84b" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">对象变量实际上并不包含对象实例，相反，它包含一个指向内存中对象所在位置的指针<strong class="kt ir">(或引用)</strong>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/a928c9377cd5ba891469af215107e679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnBqRE3fQgxMKfHV-3FiXw.png"/></div></div></figure><ul class=""><li id="6470" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">当我们把一个对象赋给一个变量时，我们就是在赋指针，这意味着如果我们把一个变量赋给另一个变量，每个变量都会得到一个指针的副本，而两个变量仍然引用内存中的同一个对象。</li></ul><blockquote class="oq or os"><p id="b708" class="kr ks lw kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><em class="iq">为了清楚地理解，让我们假设我们创建了另一个变量如下:</em></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/e844efd113d82fde049d2d3b6b47a3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCW_u6r4886g5dVHQILh8A.png"/></div></div></figure><ul class=""><li id="6c68" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">在这个例子中，<strong class="kt ir"> object1 </strong>存储了一个引用，而<strong class="kt ir"> object2 </strong>保存了<strong class="kt ir"> object1 </strong>的值，但是在第一行中仍然只有一个创建的对象实例，而这两个实例都指向那个对象。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/f0ad49223f0ec69b4e0c6e2f425d7d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sAfASqBQseMUHOZKBJsZSA.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk"><strong class="bd nx">Two Variables Pointing to One Object</strong></figcaption></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="73ca" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">函数是JavaScript中的对象</h1><p id="6656" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">您可能听说过JavaScript中的函数是对象，这几乎是真的。但是有一个很少有人知道的概念，在JavaScript中，函数与对象的区别在于存在一个内部属性名<strong class="kt ir"> [[Call]]，</strong>这些内部属性不能通过代码访问，但是它们定义了代码的行为。</p><p id="c109" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> [[Call]] </strong>属性只对函数是唯一的，它表示对象可以被执行。正如我们所知，函数是对象，它们的行为不同于其他语言中的函数，这种行为是成为JavaScript专家的关键。</p><blockquote class="oq or os"><p id="bc87" class="kr ks lw kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated">在<strong class="kt ir"> JavaScript </strong>中，我们有很多方法可以定义函数，但我将只讨论最实用的方法。</p></blockquote><h2 id="d865" class="ng mk iq bd ml nh ni dn mp nj nk dp mt la nl nm mv le nn no mx li np nq mz nr bi translated">声明与表达式</h2><p id="cf3f" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">有两个字面函数，第一个是一个<em class="lw">函数声明</em>，您可能很熟悉。</p><p id="25a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它以function关键字开始，包括函数的名称，函数的内容用大括号括起来。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/9b41cc08d1171c4a82af51ccd434bf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fyx6YhmbEji8jfC5EtD1Ew.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk"><strong class="bd nx">Function Declaration</strong></figcaption></figure><p id="7e85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个实现是函数表达式，函数后面不需要名字。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/78d1d5be5aa657bc1bc13593f8324e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zs_kj8idKfYxLxW-Aj2G5g.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk"><strong class="bd nx">Function Expression</strong></figcaption></figure><p id="9866" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个阶段，它们看起来非常相似，但是这两个实现在许多方面是不同的。</p><ul class=""><li id="7114" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">在函数声明的情况下，当代码执行时，它们被提升到上下文的顶部，这仅仅意味着您可以在代码中使用函数后定义它，而不会生成任何错误。</li></ul><p id="cb1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lw">例如:</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/3375bf08ded694370c3af585ab80c758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gNWbaYdNbzHIgNr-Z6tuGg.png"/></div></div></figure><ul class=""><li id="3d5c" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">函数<strong class="kt ir">提升</strong>只在函数声明时发生，因为函数名是预先知道的。但是，函数表达式不能被提升，因为函数只能通过变量引用，这就是下面定义的函数给出错误的原因。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/1afa6d5bbc8794a6bd2941fcba12f7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jB9b6BTuzAMPiDAfOsrltA.png"/></div></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="24d3" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">使用对象</h1><p id="f99d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">JavaScript中的对象不同于其他语言，JavaScript中的对象是动态的，它们可以在代码执行过程中的任何时候发生变化。而其他基于类的语言基于类定义锁定对象，但我们在JavaScript中没有这样的限制。JavaScript中的OOP完全依赖于您对对象的熟悉程度，如果您想提高自己的技能，了解以下概念是很好的。</p><h2 id="92df" class="ng mk iq bd ml nh ni dn mp nj nk dp mt la nl nm mv le nn no mx li np nq mz nr bi translated">检测属性</h2><p id="d29c" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">大多数时候需要检查对象中是否存在属性，初学者经常使用如下模式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/8a9541c7f86a24b0c18f636008d3c1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkVmVlk7ZE2rESzMUjyayQ.png"/></div></div></figure><p id="162b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法的问题是<strong class="kt ir"> JavaScript类型的强制</strong>会影响结果，你会遇到很多错误。</p><ul class=""><li id="9302" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">如果值为<strong class="kt ir"> <em class="lw"> truthy </em> </strong>，<strong class="kt ir"> if </strong>条件评估为true，可以是<strong class="kt ir">对象、非空字符串、非零数字、</strong>或<strong class="kt ir"> true </strong>本身<strong class="kt ir">。</strong></li><li id="f565" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">如果值为<strong class="kt ir"> <em class="lw"> falsy </em> </strong>，则可以评估为false，可以是<strong class="kt ir"> null、undefined、0、false、NaN </strong>或<strong class="kt ir">空字符串。</strong></li><li id="72ea" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">例如，如果<strong class="kt ir"> person.age </strong>是<strong class="kt ir"> 0 </strong>，那么if条件会产生假阴性，即使属性存在，条件也不会满足。</li></ul><p id="4863" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于这些问题，我们有了一种更可靠的方法来测试对象中属性的存在。使用操作符中的<strong class="kt ir">,你可以在一个特定的对象中寻找一个具有给定名称的属性，如果找到了就返回<strong class="kt ir"> true </strong>。</strong></p><p id="8f5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lw">例如:</em> </strong></p><ul class=""><li id="0c83" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">操作符中的<strong class="kt ir">检查给定的<strong class="kt ir">键</strong>是否存在于哈希表中，并返回它是否可用。</strong></li><li id="802c" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">同样，我们可以使用这个操作符检查对象中的方法，正如我们在下面的例子中可以看到的，我们已经定义了一个方法<strong class="kt ir"> renderName。</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/09411fce714eb394bc9478b63ce41a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a2h5YY2jS-SUVjEg7y8Pfg.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">The <strong class="bd nx">in</strong> Operator</figcaption></figure><h2 id="5dfe" class="ng mk iq bd ml nh ni dn mp nj nk dp mt la nl nm mv le nn no mx li np nq mz nr bi translated">删除属性</h2><p id="765e" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">当我开始使用真实世界的JavaScript应用程序时，我曾经简单地将属性设置为<strong class="kt ir"> Null，</strong>但是这种方法后来成为应用程序中性能问题的原因<strong class="kt ir">。</strong></p><p id="b292" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将属性设置为Null并不会从对象中完全删除该属性，在这种情况下，会调用值为<strong class="kt ir"> Null的<strong class="kt ir"> [[Set]] </strong>操作。</strong></p><ul class=""><li id="5658" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">要从对象中完全删除属性，您应该使用<strong class="kt ir"> delete </strong>操作符，它调用一个名为<strong class="kt ir"> [[Delete]] </strong> <em class="lw">的内部操作(只需从散列表中删除一个</em> <strong class="kt ir"> <em class="lw">键/值</em> </strong> <em class="lw">对)。</em></li></ul><p id="bbd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lw">例如:</em> </strong></p><ul class=""><li id="8867" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">在对象<strong class="kt ir"> person1 </strong>中，当我们使用<strong class="kt ir"> delete </strong>操作符删除<strong class="kt ir"> name </strong>属性时，我们可以在控制台结果中观察到<strong class="kt ir"> false </strong>语句。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/fff9a45cdc8b6736f56f757848847b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_gJHUsin8TARsCcjShWUQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">The <strong class="bd nx">delete </strong>Operator</figcaption></figure><h2 id="01fc" class="ng mk iq bd ml nh ni dn mp nj nk dp mt la nl nm mv le nn no mx li np nq mz nr bi translated">防止扩展</h2><p id="180b" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">有时候我们必须完全保护我们的对象不被进一步扩展。创建不可扩展对象的一个简单方法是使用<strong class="kt ir"> Object.prevent extensions()，</strong>这个方法接受一个参数，这个参数就是我们想要使之不可扩展的对象，仅此而已。</p><p id="eb37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lw">例如:</em> </strong></p><ul class=""><li id="8de9" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">当我们试图在对象<strong class="kt ir"> person1 </strong>中添加<strong class="kt ir"> age </strong>属性时，控制台收到一个错误，因为我们无法再在该对象中添加属性。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/00b39058149fb858e0aafc01af13e0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsXECn1CbyJlXj3XnNu6vg.png"/></div></div></figure><blockquote class="oq or os"><p id="8be6" class="kr ks lw kt b ku kv jr kw kx ky ju kz ot lb lc ld ou lf lg lh ov lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">注意:</em> </strong> <em class="iq">还有两种方法可以创建不可扩展的对象[</em><strong class="kt ir"><em class="iq">object . issealed()</em></strong><em class="iq">&amp;</em><strong class="kt ir"><em class="iq">object . ISF rozen()</em></strong><em class="iq">]，这三种方法的工作方式都是一样的。</em></p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="7c39" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">对象.原型</h1><blockquote class="nz"><p id="fe9c" class="oa ob iq bd oc od pc pd pe pf pg lm dk translated">创建对象是OOP的第一步，第二步是理解继承。</p></blockquote><figure class="ok ol om on oo kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/b7dc78f9179af9ec511c548672bf134c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zm4ICbUq-VEtoBCOvLfeQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk"><strong class="bd nx">Methods Inherited From Object.prototype</strong></figcaption></figure><p id="6b11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有的对象，也包括那些我们自己定义的对象，都是自动从Object继承的，除非特别说明。简单地说，我们可以说所有对象都继承自<strong class="kt ir"> Object.prototype. </strong>用更专业的术语来说，我们可以说任何通过对象文字定义的对象都将其<strong class="kt ir"> [[Prototype]] </strong>设置为<strong class="kt ir"> Object.prototype. </strong></p><p id="3d1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lw">例如:</em> </strong></p><ul class=""><li id="5622" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">如果我们仔细看看变量<strong class="kt ir"> <em class="lw">数据库</em> </strong>，它验证了我们关于对象如何被继承的陈述。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/3fa81329a7bd14cf1f287fb17e790eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mX3GfcO1w6jT1cDLjITpvQ.png"/></div></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="1d2b" class="ng mk iq bd ml nh ni dn mp nj nk dp mt la nl nm mv le nn no mx li np nq mz nr bi translated">结论</h2><p id="22a3" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">感谢您的阅读。我希望你已经发现这是有用的。如果是这样，一定要在评论中让我们知道。</p><p id="fd79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">延伸阅读:</strong></p><div class="pj pk gp gr pl pm"><a rel="noopener  ugc nofollow" target="_blank" href="/7-best-javascript-typescript-orms-for-2021-9552d0c7a09f"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd ir gy z fp pr fr fs ps fu fw ip bi translated">2021年7个最佳JavaScript和类型脚本格式</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">在下一个JavaScript项目中使用ORM库</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pv l"><div class="pw l px py pz pv qa kp pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a rel="noopener  ugc nofollow" target="_blank" href="/9-programming-principles-every-software-developer-should-know-9fffe3c5258"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd ir gy z fp pr fr fs ps fu fw ip bi translated">每个软件开发人员都应该知道的9条编程原则</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">很好地了解干净代码的编程原则</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pv l"><div class="qb l px py pz pv qa kp pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a rel="noopener  ugc nofollow" target="_blank" href="/6-optimization-techniques-for-react-applications-9585073bc3b7"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd ir gy z fp pr fr fs ps fu fw ip bi translated">React应用的6种优化技术</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">构建快速反应应用程序的有用技术</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pv l"><div class="qc l px py pz pv qa kp pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a rel="noopener  ugc nofollow" target="_blank" href="/9-data-structures-algorithms-you-should-know-as-a-developer-5e10946c95a0"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd ir gy z fp pr fr fs ps fu fw ip bi translated">作为开发人员，你应该知道的9种数据结构和算法</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">让你成为更好的开发者的数据结构和算法</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pv l"><div class="qd l px py pz pv qa kp pm"/></div></div></a></div><p id="921b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lw">更多内容请看</em><a class="ae qe" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>