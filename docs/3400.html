<html>
<head>
<title>Let’s Build a Simple Micro-Frontend Monorepo with Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用Next.js构建一个简单的微前端Monorepo</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-simple-micro-frontend-monorepo-with-next-js-9437737007ff?source=collection_archive---------0-----------------------#2021-07-10">https://javascript.plainenglish.io/lets-build-a-simple-micro-frontend-monorepo-with-next-js-9437737007ff?source=collection_archive---------0-----------------------#2021-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/177efacf3b7ac93608c17f998245292b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*41LhYnIPI6z1fAVq"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kejeki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelsey Weinkauf</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><p id="92c4" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">除非你一直生活在岩石下，否则你会非常清楚JavaScript生态系统有多饱和。您的技术堆栈有许多很好的选项，权衡每个选择的利弊似乎是一项相当艰巨的任务。</p><p id="99e3" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">本文将使用人们喜欢的所有流行词汇，如“Next.js”、“Monorepo”、“TypeScript”和“Micro-Frontend”，谦逊地为现代前端演示一个这样的选项。</p><h1 id="81ee" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">下一件大事</strong></h1><p id="57a9" class="pw-post-body-paragraph kh ki in kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ig bi translated">我觉得这年头选择<a class="ae jz" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>作为你的前端框架是不可能出错的。这并不是说没有一些优秀的替代品，比如Gatsby和create-react-app，事实上，如果你打算使用这些框架中的一个，你仍然可以和我一起编写代码，只需用Next.js替换你选择的框架。</p><p id="3b9c" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">重要的是微前端架构。依我拙见，将应用程序的不同部分部署到生产环境中，而其他部分并不知道，并且不会给这些部分带来任何风险，这才是王道，并且可以提供更加友好的开发人员体验。</p><p id="1ee7" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">为了实现这一点，我们将创建一个带有Yarn工作空间的简单Monorepo，并利用<a class="ae jz" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel cloud </a>的强大功能，它对mono repo提供一流的支持，包括那些包含在单个Git repo中的mono repo。关于Yarn工作空间的一个伟大的事情是共享的依赖项将被提升到根目录，而不是在每个子应用<code class="fe mi mj mk ml b">node_modules</code>中复制那些包！你可以在这里阅读更多关于<a class="ae jz" href="https://classic.yarnpkg.com/blog/2017/08/02/introducing-workspaces/" rel="noopener ugc nofollow" target="_blank">纱线工作区的信息。</a></p><h1 id="3932" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">让我们开始吧</h1><p id="fc9c" class="pw-post-body-paragraph kh ki in kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ig bi translated">好了，废话少说，让我们开始建设我们的新项目吧！首先，我们将创建一个新目录并移入其中:</p><p id="5231" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe mi mj mk ml b">$ mkdir MyApp &amp;&amp; cd MyApp</code></p><p id="efa6" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，我们将确保我们已经安装了Yarn(在本指南中，我们使用的是版本1或Yarn Classic)。</p><p id="3936" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe mi mj mk ml b">$ npm install -g yarn</code></p><p id="ce9c" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">接下来，我们将使用默认值初始化项目。您可以现在为<code class="fe mi mj mk ml b">private</code>属性键入<code class="fe mi mj mk ml b">true</code>，或者稍后手动键入。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="442d" class="mu lg in ml b gy mv mw l mx my">$ yarn init<br/>yarn init v1.22.10<br/>question name (MyApp):<br/>question version (1.0.0):<br/>question description: My App<br/>question entry point (index.js):<br/>question repository url:<br/>question author:<br/>question license (MIT):<br/>question private: true<br/>success Saved package.json<br/>✨  Done in 11.84s.</span></pre><p id="731b" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">然后我们将行<code class="fe mi mj mk ml b">"workspaces": ["packages/*"]</code>添加到我们的<code class="fe mi mj mk ml b">package.json</code>文件中。这就是告诉Yarn我们正在使用工作区所需要的全部内容，我们Monorepo的所有不同部分都可以在<code class="fe mi mj mk ml b">packages</code>目录中找到。你可以选择叫它别的名字，但是<code class="fe mi mj mk ml b">packages</code>很好听，因为它被<a class="ae jz" href="https://lerna.js.org/" rel="noopener ugc nofollow" target="_blank"> Lerna </a>使用，而且我喜欢一致性。</p><h1 id="d686" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">建立我们的第一个工作空间</strong></h1><p id="482c" class="pw-post-body-paragraph kh ki in kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ig bi translated">我们的下一步是创建我们项目的第一个“工作空间”或微前端。对于这个例子，让我们假设我们将制作一个仪表板，它将作为我们的web应用程序的主页。让我们继续创建该目录，并在其中设置一个Next.js应用程序！</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7d2f" class="mu lg in ml b gy mv mw l mx my">$ mkdir packages &amp;&amp; cd packages<br/>$ yarn create next-app --typescript</span></pre><p id="f7d9" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如果您愿意，如果您想使用JavaScript，可以省略<code class="fe mi mj mk ml b">--typescript</code>。当提示输入姓名时，键入<code class="fe mi mj mk ml b">dashboard</code>或任何符合您目的的内容。</p><h1 id="2d07" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">建立我们的第二个工作空间</strong></h1><p id="a205" class="pw-post-body-paragraph kh ki in kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ig bi translated">接下来，让我们创建另一个工作空间来存储我们共享的<a class="ae jz" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">钩子</a>。像我们的仪表板一样，它会有<code class="fe mi mj mk ml b">react</code>，但不像我们的仪表板，它没有<code class="fe mi mj mk ml b">next</code>。这个更小的钩子应用程序实际上会更复杂一些，因为我们没有使用超级<code class="fe mi mj mk ml b">create next-app</code>向导！</p><p id="2c97" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">确保在创建<code class="fe mi mj mk ml b">hooks</code>工作空间之前导航回<code class="fe mi mj mk ml b">packages</code>目录(或者只是从您的IDE创建文件和目录)。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="1237" class="mu lg in ml b gy mv mw l mx my">$ cd .. <br/>$ mkdir hooks &amp;&amp; cd hooks<br/>$ yarn init</span><span id="cf21" class="mu lg in ml b gy mz mw l mx my">question name (hooks):<br/>question version (1.0.0):<br/>question description: Shared React Hooks<br/>question entry point (index.js): dist/index.js<br/>question repository url:<br/>question author:<br/>question license (MIT):<br/>question private:</span></pre><p id="b5ab" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">请注意，稍后我将入口点设置为<code class="fe mi mj mk ml b">dist/index.js</code>。</p><p id="97a5" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我喜欢做的一件事是用一个共同的前缀将我的工作空间分组；在这种情况下，我们将使用<code class="fe mi mj mk ml b">@myapp</code>，因此让我们继续修改我们两个工作空间的<code class="fe mi mj mk ml b">package.json</code>，并将<code class="fe mi mj mk ml b">name</code>值分别更改为<code class="fe mi mj mk ml b">@myapp/dashboard</code>和<code class="fe mi mj mk ml b">@myapp/hooks</code>。</p><p id="7149" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">最后，我们希望将<code class="fe mi mj mk ml b">react</code>依赖项安装到hooks应用程序中。我将使用TypeScript，所以我也将把<code class="fe mi mj mk ml b">typescript</code> <code class="fe mi mj mk ml b">tsc</code>和<code class="fe mi mj mk ml b">@types/react</code>包安装到devDependencies中。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="5db9" class="mu lg in ml b gy mv mw l mx my">$ yarn workspace @myapp/hooks add react<br/>$ yarn workspace @myapp/hooks add typescript tsc @types/react -D<br/>$ yarn workspace @myapp/hooks tsc --init</span></pre><p id="ec4f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">你会看到一个<code class="fe mi mj mk ml b">tsconfig.json</code>文件已经被创建。取消注释并设置以下行的值:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e21e" class="mu lg in ml b gy mv mw l mx my">"declaration": true,<em class="na"><br/></em>"sourceMap": true,<br/>"outDir": "./dist",<br/>"rootDir": "./lib",</span></pre><p id="d9af" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">还记得我们把入口点设为<code class="fe mi mj mk ml b">dist/index.js</code>的时候吗？这指示TypeScript transpiler从<code class="fe mi mj mk ml b">lib</code>目录读取并将原始JavaScript输出到<code class="fe mi mj mk ml b">dist</code>目录。Yarn工作空间然后将结果<code class="fe mi mj mk ml b">dist/index.js</code>文件暴露给其他工作空间。</p><p id="db62" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">接下来，编辑hooks apps <code class="fe mi mj mk ml b">package.json</code>文件以包含以下脚本:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="19cf" class="mu lg in ml b gy mv mw l mx my">"scripts": {<br/>    "dev": "yarn run clean &amp;&amp; yarn run watch",<br/>    "build": "yarn run clean &amp;&amp; yarn run compile",<br/>    "clean": "rm -rf ./dist",<br/>    "compile": "tsc",<br/>    "watch": "tsc --watch"<br/>}</span></pre><p id="59c2" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">接下来，在hooks应用程序中创建一个<code class="fe mi mj mk ml b">.gitignore</code>，同时创建一个<code class="fe mi mj mk ml b">lib</code>目录。用以下内容填充钩子应用程序<code class="fe mi mj mk ml b">.gitignore</code>:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="31f0" class="mu lg in ml b gy mv mw l mx my">/node_modules<br/>/dist</span></pre><p id="a310" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">好了，我们都准备好了，让我们开始写代码吧！我们将编写一个简单的React钩子，它最终将被Monorepo中的其他应用程序使用。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="9f55" class="mu lg in ml b gy mv mw l mx my">// packages/hooks/lib/useDebounce.ts</span><span id="2c67" class="mu lg in ml b gy mz mw l mx my">import { useState, useEffect } from 'react';</span><span id="cbde" class="mu lg in ml b gy mz mw l mx my">const useDebounce = &lt;T&gt;(value: T, delay: number): T =&gt; {<br/>  const [debouncedValue, setDebouncedValue] = useState(value);</span><span id="f0f4" class="mu lg in ml b gy mz mw l mx my">useEffect(() =&gt; {<br/>    const handler = setTimeout(() =&gt; {<br/>      setDebouncedValue(value);<br/>    }, delay);</span><span id="1ace" class="mu lg in ml b gy mz mw l mx my">return () =&gt; {<br/>      clearTimeout(handler);<br/>    };<br/>  }, [value, delay]);</span><span id="70fc" class="mu lg in ml b gy mz mw l mx my">return debouncedValue;<br/>};</span><span id="bf98" class="mu lg in ml b gy mz mw l mx my">export default useDebounce;</span></pre></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><pre class="mq ml mr ms aw mt bi"><span id="bf5d" class="mu lg in ml b gy nb nc nd ne nf mw l mx my">// packages/hooks/lib/index.ts</span><span id="195c" class="mu lg in ml b gy mz mw l mx my">export { default as useDebounce } from "./useDebounce";</span></pre><p id="addc" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">最后，我们将把源TypeScript文件及其相关的源映射和类型文件传输到<code class="fe mi mj mk ml b">dist</code>目录，同时观察源<code class="fe mi mj mk ml b">lib</code>目录的变化:</p><p id="f5cb" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe mi mj mk ml b">$ yarn workspace @myapp/hooks run dev</code></p><h1 id="b991" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">将所有这些放在一起</strong></h1><p id="ffe4" class="pw-post-body-paragraph kh ki in kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ig bi translated">hooks应用程序是一个简单的例子。您可以创建更多应用来满足您的需求；一个共享组件应用程序，一个集中的翻译区，或者你的用户界面的其他区域，比如导航栏，评论区等等，都是有效的选择。</p><p id="16b0" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在我们的例子中，我们将使用仪表板应用程序中的<code class="fe mi mj mk ml b">useDebounce</code>挂钩。让我们在下面概述实现这一目标的步骤:</p><ul class=""><li id="5686" class="ng nh in kj b kk kl ko kp ks ni kw nj la nk le nl nm nn no bi translated">将<code class="fe mi mj mk ml b">"@myapp/hooks": "1.0.0"</code>添加到仪表板应用<code class="fe mi mj mk ml b">package.json</code>的依赖对象中</li><li id="3e1a" class="ng nh in kj b kk np ko nq ks nr kw ns la nt le nl nm nn no bi translated">从项目根目录中，运行<code class="fe mi mj mk ml b">yarn install</code>将它们链接在一起</li><li id="5a4e" class="ng nh in kj b kk np ko nq ks nr kw ns la nt le nl nm nn no bi translated">使用<code class="fe mi mj mk ml b">import { useDebounce } from "@myapp/hooks";</code>从仪表板导入挂钩，就像导入任何其他依赖关系一样</li></ul><p id="238e" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">就是这样！我们有一个伟大项目的基础，我们可以通过我们认为合适的额外工作空间来扩大规模！</p><h1 id="de7b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">独立部署微前端</strong></h1><p id="aa26" class="pw-post-body-paragraph kh ki in kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ig bi translated">这种方法的一个奇妙的好处是能够将单个应用程序分割成可以独立构建、维护和部署的独立部分。</p><p id="8118" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这篇文章不会详细介绍部署过程，但是我推荐使用Vercel，因为它有一流的Monorepo支持。您可以将项目推送到GitHub、GitLab或BitBucket，并让Vercel平台导入每个工作区。默认情况下，Vercel支持应用程序之间的代码共享，这对我们的需求至关重要。你可以在这里阅读更多关于整个过程的信息。</p><p id="86bd" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">你可以在这里找到我的包含这段代码的GitHub repo。</p><p id="5697" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">编码快乐！</p><p id="db27" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="na">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kj io"><em class="na">plain English . io</em></strong></a></p></div></div>    
</body>
</html>