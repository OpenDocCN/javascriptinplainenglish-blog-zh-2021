<html>
<head>
<title>How to Resolve Problems with CORS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决与CORS的问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-about-cors-resolve-with-simple-step-758ae7410a53?source=collection_archive---------2-----------------------#2021-04-01">https://javascript.plainenglish.io/everything-about-cors-resolve-with-simple-step-758ae7410a53?source=collection_archive---------2-----------------------#2021-04-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b0573484b6941e771eb1560ffd032568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eWZQqsRFSG1Kvy6WV8NAg.png"/></div></div></figure><p id="cd42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个web开发人员在开发网站时都会面临CORS问题。MDN文档中对CORS的描述是:</p><p id="9891" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">“跨来源资源共享(CORS)是一种基于HTTP报头的机制，它允许服务器指示除其自身以外的任何其他来源(域、方案或端口),浏览器应该允许从这些来源加载资源。CORS还依赖于一种机制，通过这种机制，浏览器向托管跨源资源的服务器发出“预检”请求，以检查服务器是否允许实际的请求。在预检过程中，浏览器会发送指示HTTP方法的标头和将在实际请求中使用的标头。</em></p><p id="8ce1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CORS又名。跨源资源共享是一种机制，这意味着网站从一个URL向另一个URL请求数据，它对前端和后端都不利，因为它注定要被发现。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/1e190edab55f1ffb06f194462b25471a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*zJaoBdpbEUYC2L4kyHhn4w.png"/></div></figure><p id="e2f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，你试图从一个不同的网址加载一个图像到你的工作网站，突然你看到它变成了一个损坏的图像，或者你可能试图调用API，结果在控制台出现CORS错误。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/cb704d4dfe34d80fa8fa3c9375e19d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LzGQgX_FmkWzaAHI.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">CORS console error</figcaption></figure><p id="5381" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为浏览器将相同的原始策略作为其安全模块的一部分。这意味着浏览器可以很好地工作在自己的URL或相同的主机上，但阻止来自外部URL的任何内容，除非双方的某些条件匹配。</p><p id="38f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以尽量用简单的语言去理解。</p><p id="9b90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当浏览器发出请求时，它会将来源添加到请求头中，并与API一起发送，相同的头在后端共享，这样，后端将检查头来源，如果来源相同，则资源将被共享，而不会询问任何问题。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/925bed675a48060a1c35481d81bdc549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jQnE3IablqWNqzI1.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">CORS issue</figcaption></figure><p id="891f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果两端的源报头不同，则添加带有跨源报头的响应。</p><pre class="kv kw kx ky gt le lf lg lh aw li bi"><span id="d18e" class="lj lk in lf b gy ll lm l ln lo">Access-Control-Allow-Origin:foo.com</span></pre><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/28397e77e14c7149f488610ce64fe836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrHdh79RoEOIerhTAwpNHA.png"/></div></div></figure><p id="da66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是最常见的问题。出于安全原因，浏览器会发生这种情况。解决这一常见方法的一个方法是在后端添加一个通配符*，这样任何请求URL都可以共享资源，但这使您的服务器处于更危险的模式，可能会受到黑客攻击。</p><p id="cdc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">别担心，我们有适当的方法来解决这个问题。</p><h1 id="c586" class="lq lk in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">如何克服这个问题</strong></h1><p id="63d3" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">因此，有几种方法可以解决这个问题，但这取决于哪种方法与服务器配置有关。</p><h2 id="386f" class="lj lk in bd lr ms mt dn lv mu mv dp lz kg mw mx md kk my mz mh ko na nb ml nc bi translated">用选项配置CORS</h2><p id="92db" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">您还可以使用CORS的配置选项对此进行进一步定制。</p><p id="f5e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用配置来允许单个域或子域访问，根据您的要求配置允许的HTTP方法，如GET和POST。以下是如何使用CORS选项允许单个域访问:</p><pre class="kv kw kx ky gt le lf lg lh aw li bi"><span id="470a" class="lj lk in lf b gy ll lm l ln lo">const express = require('express');<br/>const cors = require('cors'); <br/>const app = express(); <br/><br/>var corsOptions = {</span><span id="6260" class="lj lk in lf b gy nd lm l ln lo">   origin: ‘<a class="ae ne" href="http://localhost:8080'" rel="noopener ugc nofollow" target="_blank">http://localhost:8080'</a>, </span><span id="95ad" class="lj lk in lf b gy nd lm l ln lo">   optionsSuccessStatus: 200 // For legacy browser support</span><span id="1ab3" class="lj lk in lf b gy nd lm l ln lo">}</span><span id="be80" class="lj lk in lf b gy nd lm l ln lo">app.use(cors(corsOptions));<br/>app.get('/', (req, res) =&gt; { <br/>  res.json({ <br/>    message: 'Hello World' <br/>  }); <br/>});<br/>app.listen(2020, () =&gt; { <br/>   console.log('server is listening on port 2020'); <br/>});</span></pre><p id="cd8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果愿意，您还可以配置允许的HTTP方法</p><pre class="kv kw kx ky gt le lf lg lh aw li bi"><span id="e515" class="lj lk in lf b gy ll lm l ln lo">var corsOptions = {    <br/>    origin: 'http://localhost:8080',    <br/>    optionsSuccessStatus: 200 <em class="kt">// For legacy browser support</em>                <br/>    methods: "GET, PUT" <br/>}  <br/>app.use(cors(corsOptions));</span></pre><p id="137b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些代码行将在所有HTTP响应中添加源头。</p><h2 id="e9dd" class="lj lk in bd lr ms mt dn lv mu mv dp lz kg mw mx md kk my mz mh ko na nb ml nc bi translated">预检非标准标题</h2><p id="5fc0" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">现在，某些HTTP方法，如PUT、DELETE、PATCH，是非标准报头，需要进行预检。这就像机场对乘客的健康检查一样，只是为了确保乘客现在已经为航班起飞做好了充分的检查。</p><p id="1928" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这些HTTP方法，浏览器以同样的方式知道何时使用名为<strong class="jx io">选项</strong>的HTTP动词进行预检，并且作为响应，服务器将204为<em class="kt">是，我允许这个源发出HTTP请求，但是使用以下方法。</em>这一切的要点是确保主请求发生时没有任何灾难。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/80ec604584ccb3043be4f5783a77fb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*k2RADfsZ0XdhVt6TZklLYA.png"/></div></figure><p id="71f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我提一些飞行前的要点。服务器可以允许预检缓存具有最大期限，以便浏览器可以在一定时间内缓存请求。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cd5106332d023aa577bfef83ba1b3c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*oSg9oGQy5k3AEbYA3rIyDQ.png"/></div></figure><h2 id="328f" class="lj lk in bd lr ms mt dn lv mu mv dp lz kg mw mx md kk my mz mh ko na nb ml nc bi translated">仍然面临CORS问题？</h2><p id="bdf2" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">如果你在浏览器中仍然面临CORS问题，那么你需要做提到的步骤来找出你所面临的问题。</p><p id="7e7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原因1:打开您的网络标签，并检查允许-控制-允许-起源，如果它不存在，那么你必须在服务器上启用CORS。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f07c5f7d1b1875c266cc4ce2b1366f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*s8dBBCm7mh__rTcVy5Z7ew.png"/></div></figure><p id="3e25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原因2:如果存在，则可能是URL与请求URL和响应Allow-Control-Allow-Origin不匹配，或者您可以添加通配符*来允许所有请求URL。</p><p id="f511" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原因3:如果是预检，那么服务器可能不允许提及HTTP方法，对于给定的请求，那么您可以确保HTTP方法是正确的。</p><p id="5cda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以这些是你可以面对CORS问题的以下情况，你可以用给定的方法解决这些问题。</p><p id="0740" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继续编码，感谢阅读这篇博客。</p></div></div>    
</body>
</html>