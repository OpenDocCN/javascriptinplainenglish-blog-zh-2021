<html>
<head>
<title>Getting Started with Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Three.js入门</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-simple-introduction-to-threejs-9b060c1bb6e7?source=collection_archive---------1-----------------------#2021-02-20">https://javascript.plainenglish.io/a-simple-introduction-to-threejs-9b060c1bb6e7?source=collection_archive---------1-----------------------#2021-02-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f9a52a6d25e9e379ad83c3fdfada5500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gs7LfQAyUUmkO9KUdsNGbQ.png"/></div></div></figure><div class=""/><p id="6ff1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">被锁在里面快一年了，我有了更多的空闲时间去做那些我本来不会去做或者不感兴趣的事情。</p><p id="ee2c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我从未想过我会对绘画、摄影或篮球感兴趣，然而去年我对这三个都感兴趣。我甚至不打算再说那一年了；你知道我在说什么…</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/2d8ed3090bc59ae3070b414e5adab5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*dTExcVO2cYZj9vYH.jpg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Gladly.</figcaption></figure></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="12e3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不管怎样，在我的空闲时间里，我一直在做的许多事情中有三件是T1。ThreeJS是一个JavaScript库，允许你在浏览器中实现实时3D渲染。在我们继续之前，让我们回顾一下简单的背景。当然，如果你想直接进入三个j，可以随意跳到<strong class="jx iz">让我们开始吧</strong>部分。</p><h1 id="62f3" class="lk ll iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">一些背景</h1><p id="743e" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">好吧，<em class="mn">允许</em>不是正确的术语。从技术上讲，你可以不用三个j就能做到这一点，因为所有现代的网络浏览器都给你提供了一个叫做WebGL的图形API。如果你熟悉计算机图形学，那么你可能听说过这个叫做OpenGL的东西。这是一个API，允许你通过直接与设备的GPU交互来渲染3D图形，如果你愿意，还可以渲染2D。OpenGL并不是唯一允许你这样做的API。<a class="ae lj" href="https://docs.microsoft.com/en-us/windows/win32/direct3dgetstarted/building-your-first-directx-app" rel="noopener ugc nofollow" target="_blank">微软的DirectX API </a>、<a class="ae lj" href="https://developer.apple.com/metal/" rel="noopener ugc nofollow" target="_blank">苹果的Metal </a>，以及block上更新的kid、<a class="ae lj" href="https://www.khronos.org/vulkan/" rel="noopener ugc nofollow" target="_blank"> Vulkan </a>，也都可以做到这一点。然而，OpenGL是最著名的。</p><p id="4cde" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不过有一个问题:它有一个非常陡峭的学习曲线。记住，OpenGL是用来和你的GPU交互的，所以API必须有足够的性能来尽可能的利用你的硬件。实现性能效率的最好方法是用低级语言编写，这就是为什么OpenGL是用类似C/C++的语言编写的，叫做GLSL。为了让你对你在OpenGL中处理的东西有个概念，看看我为了渲染一个蓝色的圆圈而写的东西:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mo"><img src="../Images/b86ef75f0c194ea423fddd824ef8e383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O867Y0t6vYUdl-fTTVU-oQ.png"/></div></div></figure><p id="8771" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你或许可以用这么多代码编写一个还算过得去的React应用程序，但是计算机图形应用程序的计算量非常大，因此它们通常是对性能要求最高的应用程序之一。我的意思是，人们不得不制造硬件(GPU)来做这件事。</p><p id="fb98" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">长话短说，WebGL基本上可以让您在web浏览器中获得这种类似于OpenGL的效率。这是一个图形API，你可以使用JavaScript而不是C/C++与它交互……嗯，算是吧。现在，JavaScript是一种高级得多的编程语言——不管是好是坏——所以你可能会想:“太棒了！那么WebGL肯定是一件轻而易举的事了！。对此，我想指出的是<a class="ae lj" href="https://github.com/mdn/webgl-examples/blob/gh-pages/tutorial/sample2/webgl-demo.js" rel="noopener ugc nofollow" target="_blank">代码，你需要它来显示一个基本的白色方块</a>。</p><h2 id="a552" class="mp ll iy bd lm mq mr dn lq ms mt dp lu kg mu mv ly kk mw mx mc ko my mz mg na bi translated">然后是三个(JS)</h2><p id="e255" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">那么，ThreeJS在这一切中扮演了什么角色呢？这样，你就可以充分利用WebGL的诸多优势，同时摆脱让自己投入运营所需的繁重工作，专注于将想象中的3D内容变为现实。</p><p id="02e8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就结束了我们的背景。在继续讨论之前，我只想说，我绝不是在试图转储到OpenGL或WebGL。两者都是非常强大的API，如果你投入时间去学习它们，你会得到丰厚的回报。即使你不走远与他们，他们提供了一个大开眼界的经验，如何做计算机图形的硬件水平。事实上，这是对他们所做事情的过度简化。如果你对学习OpenGL或WebGL感兴趣，我在这篇文章的末尾发布了一些很棒的链接来帮助你入门。不管怎样，继续前进！</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="6d9a" class="lk ll iy bd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ne mb mc md nf mf mg mh bi translated">让我们开始吧。</h1><p id="34e0" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">现在我们已经排除了这种情况，让我们开始一个基本设置。</p><h2 id="9a04" class="mp ll iy bd lm mq mr dn lq ms mt dp lu kg mu mv ly kk mw mx mc ko my mz mg na bi translated">设置</h2><p id="c083" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">首先，在桌面上创建一个名为“ThreeJS”的文件夹。你可以称之为任何你想要的，并把它放在任何你想要的地方，但如果你想遵循这个教程到球座，然后做我说！</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ng"><img src="../Images/2abb29f59bb9c84e4c1adef79c0086fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtU3QWOFO4-8qQjVo0G4WA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">That wasn’t so hard, was it?</figcaption></figure><p id="8dd2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，在此文件夹中创建两个文件。第一个是常规的ole ' index.html文件。第二个是一个JavaScript文件，我们称之为script.js。复制下面的代码并将其放入您的index.html文件中:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="7c66" class="mp ll iy ni b gy nm nn l no np">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-    scale=1.0"&gt;</span><span id="3e0d" class="mp ll iy ni b gy nq nn l no np">    &lt;title&gt;Three JS Tutorial&lt;/title&gt;<br/>  &lt;/head&gt;</span><span id="e937" class="mp ll iy ni b gy nq nn l no np">&lt;body style = "margin: 0; padding: 0;"&gt;<br/>  &lt;script defer src = "https://cdnjs.cloudflare.com/ajax/libs/three.js/r125/three.js"&gt;.     <br/>  &lt;/script&gt;<br/>  &lt;script defer src = "./script.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="1f35" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们用两个脚本创建一个基本的HTML文件。第一个脚本是对ThreeJS库的CDN，而第二个脚本是我们自己的JavaScript，我们将在本教程中编写它。这两个脚本标签中的<strong class="jx iz">delay</strong>属性告诉浏览器在实际运行这些脚本之前要等到页面加载完毕。这个属性不是必需的，但由于我们使用CDN从远程服务器进行提取，这是一个很好的安全措施。还有一件事。我通常会避免使用内联样式，但我们只想清除任何默认的边界和填充，所以它对我们来说没什么问题。在本教程的剩余部分中，我们将不再涉及这个HTML文件。让我们写一些三个JS，好吗？</p><h2 id="5e5f" class="mp ll iy bd lm mq mr dn lq ms mt dp lu kg mu mv ly kk mw mx mc ko my mz mg na bi translated">现在我们开始认真起来。</h2><p id="8ba6" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">转到您的script.js文件。在本教程的剩余时间里，我们会一直在这里，所以把你的家具搬进来，舒服一下。现在，我们将要编写的第一段代码适用于您将要编写的任何ThreeJS项目。在做其他事情之前，你会需要它。这个起始代码给了我们最基本的东西:一个场景、一个摄像机和一个渲染器。将以下代码写入您的script.js文件。我们一会儿会过一遍它的含义:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="2d7d" class="mp ll iy ni b gy nm nn l no np">const scene = new THREE.Scene();<br/>const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 500);</span><span id="7556" class="mp ll iy ni b gy nq nn l no np">const renderer = new THREE.WebGLRenderer();<br/>renderer.setSize(window.innerWidth, window.innerHeight);<br/>renderer.render(scene, camera);<br/>document.body.appendChild(renderer.domElement);</span></pre><p id="1d5f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是怎么回事？首先，注意我们想从ThreeJS中使用的所有东西都可以通过使用THREE对象来调用。我们会经常这样做。任何呼…</p><p id="0246" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一行创建了我们的场景。场景对象是我们希望在应用程序中显示的所有内容所在的位置。例如，如果你想显示一个茶壶的模型，那么你可以将这个茶壶模型添加到场景中。想把这个茶壶放在地板上吗？您还必须将地板模型添加到场景中。想点亮一盏灯吗？是的，你猜对了，给场景添加灯光。</p><p id="374e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二行创建我们的摄像机，我们用它来实际观察我们的场景。ThreeJS提供了多种类型的相机，但最常见的是我们这里的透视相机。这款相机有四个参数:FOV、长宽比、近景和远景。</p><p id="9bfc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个论点是视野，或FOV。这是我们的相机可以观察的角度。更高的FOV让你不用旋转相机就能看到更多。如果你是PUBG或堡垒之夜等游戏的粉丝，那么你可能对这个很熟悉:更高的FOV让你看到你周围更多的游戏世界，从而帮助你发现更多的敌人。相反，较低的FOV会缩小你能看到的范围。使用现实生活中的相机时，较低的FOV有助于近距离摄影。放大倍数越大的镜头，FOV就越低，因此你可以将大部分像素塞进你想要拍摄的特写镜头中，比如一碗水果。</p><p id="2a45" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个参数是我们的长宽比，这是屏幕的宽度和高度的比例。最常见的宽高比是16:9宽高比，这种宽高比常见于电视和电脑显示器。这是因为最常见的屏幕分辨率—例如1280x720、1920x1080、3840x2160(又名4K)都可以缩小到16x9。不相信我？取分数1920 / 1080，并将其减少到尽可能小的分数。现在，从微型智能手机到100英寸电视，各种尺寸的设备中都有网络浏览器。如果我们硬编码一个宽高比，那么任何不同宽高比的屏幕要么通过拉伸扭曲我们的内容，要么用空白像素包围它。不管怎样，我们都会破坏用户体验。相反，我们可以让JavaScript通过输入浏览器窗口的内部宽度除以其内部高度来为我们处理这个问题。为了记录，window.innerWidth和window.innerHeight分别指我们在HTML主体中实际看到的宽度和高度。</p><p id="c744" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后两个参数，近和远，指的是我们相机的观看距离。在我们的代码中，我们的近值是0.1，而远值是500。这意味着，我们的摄像机不会观察到500米以外的任何东西。同样，小于0.1米的任何东西都不会被观察到。这个<a class="ae lj" href="http://learnwebgl.brown37.net/08_projections/projections_perspective.html" rel="noopener ugc nofollow" target="_blank">链接</a>给了你一些滑块，这样你可以看到透视相机在概念层面上是如何工作的。这篇文章是关于WebGL的，但是想法是一样的。记住，ThreeJS只是在为我们做WebGL！</p><p id="f155" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设置代码的最后四行创建了我们的渲染器。渲染器是一切汇集的地方，基本上是三个j说<em class="mn">“表演时间到了！”</em>首先，我们需要说明我们使用的是哪种渲染引擎。第一行告诉我们希望使用WebGL渲染引擎。第二行使用渲染器的setSize()方法告诉引擎我们希望渲染器的尺寸是多少。在这种情况下，我们希望它占据整个浏览器视图，所以我们传入window.innerWidth和window.innerHeight值。接下来，我们通过调用渲染器的render()方法，告诉渲染器我们到底想要渲染什么。这个方法把我们的场景和摄像机，基本上就是说“摄像机，看这个场景。现在你有什么感觉？”好吧，render()不是治疗师，但是你明白了。它告诉我们的相机观察我们的场景，所以渲染器知道<em class="mn">它需要显示什么。最后，我们需要告诉我们的浏览器<em class="mn">我们想把它放在哪里。幸运的是，我们的渲染器有一个名为domElement的属性，这是一个HTML元素，包含我们的WebGL视图，可以附加到我们的DOM中。正如你可能已经猜到的，最后一行为我们做了这些:它将我们的渲染器附加到我们网页的主体。</em></em></p><p id="b6f5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在浏览器中打开index.html文件:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/b22b901ca65954e263dece2e355c5f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2D7BF-OsnF5z_1Gc8W_Ew.png"/></div></div></figure><p id="406b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你得到的是一个没有任何意义的黑暗深渊，那么你做得很好！嗯，三个j。你不会想要这样的生活。然而，在ThreeJS中，这是好的。这意味着一切都在工作。现在，还有一件事我们需要解决。与其告诉你，不如帮我一个忙，缩小查看渲染器的窗口，然后刷新页面:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ns"><img src="../Images/ec8a57c8a2007880fdd7316c3d80a4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1DqVfXC-V7nCp8Ejynwmw.png"/></div></div></figure><p id="59f4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看起来不错，对吧？展开窗口:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nt"><img src="../Images/f7e33acddf1ca7d59644716a209a3c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36SQCqsWExjBvsv4islsgg.png"/></div></div></figure><p id="0cc7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">诶！我们希望我们的渲染器占据整个屏幕，而不是它的一部分。问题是，当我们缩小屏幕然后刷新页面时，ThreeJS完全按照我们说的做了:占据整个屏幕。然而，整个屏幕是我们缩小的窗口，所以我们得到的是一个渲染器，当它完成加载时，它只占用我们窗口的大小。不用担心，这很容易补救。我们只需在调用renderer.render()之前添加一个resize事件侦听器，并告诉它每当resize事件发生时更新所有内容:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="afeb" class="mp ll iy ni b gy nm nn l no np">window.addEventListener(‘resize’, () =&gt; {<br/>  camera.aspect = window.innerWidth / window.innerHeight;<br/>  camera.updateProjectionMatrix();<br/>  renderer.setSize(window.innerWidth, window.innerHeight);<br/>});</span></pre><p id="f796" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是这段代码的作用。每当resize事件发生时，我们首先更新纵横比。新的宽度和高度可以是任何值，并且不能保证它们的长宽比与原始窗口的相同，所以我们想立即重新计算。第二行调用摄像机的updateProjectionMatrix()方法。基本上，我们需要在任何时候改变我们的摄像机时调用它。最后，第三行将更新我们的渲染器，这样，无论如何，它将占据我们的整个浏览器视图。请注意，我们只需要11行代码就可以做到这一步。还不错。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="cc49" class="lk ll iy bd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ne mb mc md nf mf mg mh bi translated">让我们大闹一场</h1><p id="f1fd" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">现在，我们已经有了自己的场景，让我们添加一些东西。我们将从添加一个蓝色立方体开始。为了做到这一点，我们需要两样东西:一个<em class="mn">几何</em>，和一个<em class="mn">材质</em>。几何描述了我们的3D物体的形状。在这种情况下，我们的几何将是一个立方体的形状。幸运的是，ThreeJS提供了许多简单的几何图形——在计算机图形学中通常被称为<em class="mn">原始形状</em>——供我们使用。我们称这些形状为基本形状，因为它们是你可能制作的每一个3D物体的组成部分:你在电影或游戏中看到的任何3D物体都是这些基本形状的某种组合和/或修改。立方体就是这样一种形状，球体、圆锥体和圆柱体也是如此，而三个j为所有这些提供了几何形状。我们可以使用ThreeJS的BoxGeometry()对象创建立方体的几何图形。将以下代码行添加到我们的相机之后、渲染器代码之前的任意位置:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="d838" class="mp ll iy ni b gy nm nn l no np">const geometry = new THREE.BoxGeometry(1, 1, 1);</span></pre><p id="592c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将创建一个1米宽、1米长、1米深的立方体几何体。像ThreeJS中的许多东西一样，实际上有比这三个更多的参数可以传入，但是现在这些就够了。</p><p id="f5ae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要的第二样东西是我们的材料。这种材料描述了我们的物体将会是什么颜色，以及它如何与光相互作用。不同的材料可以创造不同的效果。例如，一个闪亮的球有一种光滑的材料，而我毛衣的面料有一种天鹅绒般的材料。对于我们的立方体，我们将使用ThreeJS提供的最简单的材料，MeshBasicMaterial。在我们的几何代码之后，添加以下内容:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="beef" class="mp ll iy ni b gy nm nn l no np">const material = new THREE.MeshBasicMaterial({color: “#097aff”});</span></pre><p id="acfc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这条线制作的材料是一种蓝色阴影，不在乎光。我们将很快对此进行更深入的探讨。</p><p id="940b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了几何图形和材质，我们想把它们放在一起:我们有立方体和蓝色。我们想要我们的蓝色立方体。为此，我们创建了一个叫做<em class="mn">的网格</em>。当我们把一个几何图形和一个材料结合在一起时，我们就得到一个网格。换句话说，它告诉我们我们的东西是什么形状，有什么材料。在我们的材料之后，添加下面一行代码:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="41f7" class="mp ll iy ni b gy nm nn l no np">const cube = new THREE.Mesh(geometry, material);</span></pre><p id="737d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一行代码简单地说:创建一个新的网格，它有我们的立方体几何体和蓝色材质。这是我们的蓝色立方体。我们需要做的只是简单地把它添加到我们的场景中，就像这样:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="4a6d" class="mp ll iy ni b gy nm nn l no np">scene.add(cube);</span></pre><p id="107a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要向场景中添加任何东西，我们只需将它传递给场景的add()方法。现在刷新你的浏览器！</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/b22b901ca65954e263dece2e355c5f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2D7BF-OsnF5z_1Gc8W_Ew.png"/></div></div></figure><p id="cb7b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">真令人失望，哪里出了问题？实际上没什么。立方体就在那里，只是我们看不见。我们看不到它的原因是，默认情况下，ThreeJS会将我们制作的任何新对象放在我们屏幕的中心，也就是(0，0，0)的(x，y，z)位置，也就是我们的原点。相机在原点，立方体也在原点。为了解决这个问题，我们只需要将摄像机向后移动一点，为我们的立方体腾出空间。将这行代码放在我们创建相机的位置之后:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="6068" class="mp ll iy ni b gy nm nn l no np">camera.position.z = 5;</span></pre><p id="33a1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将使我们的摄像机移动5米远。在ThreeJS中，z轴指向屏幕之外:z值越大，它离我们越近。同时，x轴穿过我们的屏幕，而y轴在屏幕上上下移动。这张照片比我能更好地解释它:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nu"><img src="../Images/bf23b07200a43e53fad233afe6f2aa42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bP_gBiWVoWavOKlSIxrKw.png"/></div></div></figure><p id="cde6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好，现在再刷新一次你的屏幕。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nv"><img src="../Images/12997ce4c3131141685ba02155505b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukDqfZQ4guatlcGJWEWe3A.png"/></div></div></figure><p id="bc56" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有用！拍拍自己的背，你用三个j做了你的第一个3D应用。实际上，这不是我们想要的。我是说，我们做了一个立方体，为什么我们得到的是一个正方形？嗯，它是一个立方体，但是是一个平放在三维空间中的立方体。为了显示更多的深度，我们可以沿着y轴旋转立方体。为此，请在我们的scene.add(cube)行之前添加以下代码:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="77af" class="mp ll iy ni b gy nm nn l no np">cube.rotation.y = 0.05;</span></pre><p id="cb6b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们得到的结果:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/4c8699204e060090350ab59194f09b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8MuVhO9KxfOUwsQqYKwdA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Told ya it was a cube.</figcaption></figure><p id="f5f6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看到了吗？一个立方体。当然，这并没有什么“阴影”，但这仅仅是因为我们的网状基本材料不与光相互作用。我们稍后会对此进行改进。</p><h2 id="c70c" class="mp ll iy bd lm mq mr dn lq ms mt dp lu kg mu mv ly kk mw mx mc ko my mz mg na bi translated">把它带到整个城市！</h2><p id="1012" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">当我们对立方体进行旋转时，你可能想知道如何制作旋转的动画。换句话说，我们如何让这个立方体自动旋转？这是介绍我们如何做到这一点的基础知识的好时机。要制作ThreeJS中的任何东西的动画，无论是旋转的立方体还是过桥的角色，每次发生变化时，我们都需要重新渲染场景。立方体旋转了0.01弧度吗？我们需要重新渲染。我们的角色眨眼了吗？是的，我们需要重新渲染。</p><p id="4edd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么我们该如何做呢？</p><p id="55bf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在过去的JavaScript时代，我们不得不使用setInterval()方法，传入一个应用我们的更改的回调，以及我们希望发生这种情况的频率(或帧速率),来构建一些简单的解决方案。因为每秒60帧(或60fps)通常是理想帧速率的几倍，所以我们希望传递的时间是1000/60，大约是16.7毫秒。幸运的是，我们生活在更好的时代……除了现在正在发生的那件事。如今，JavaScript有了一个名为requestAnimationFrame(<em class="mn">foo</em>)的本地方法，它将接受我们传入的任何函数<em class="mn"> foo </em>，并执行它，目标是60fps，并为我们处理所有校准问题。这个函数<em class="mn"> foo </em>是一个递归函数，因为我们希望它重复执行，所以我们将这个requestAnimationFrame()调用放在函数的定义中。创建一个名为animate的函数，实现它并将其放在我们的document . body . append(renderer . DOM element)行之前:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="cf1c" class="mp ll iy ni b gy nm nn l no np">const animate = () =&gt; {<br/> requestAnimationFrame(animate);<br/> cube.rotation.y += 0.02;<br/> renderer.render(scene, camera);<br/>};</span></pre><p id="1100" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的animate()函数首先调用requestAnimationFrame()函数，将自己传入，从而保证它将不断被调用。接下来，它将通过添加0.02弧度来更新我们立方体的rotation.y值。最后，它将重新渲染我们的场景，反映这一变化。要做到这一点，只需在声明之后立即调用animate ():</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="b7d4" class="mp ll iy ni b gy nm nn l no np">animate();</span></pre><p id="2630" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">刷新您的页面并…..</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nx"><img src="../Images/0ea6cc01d5472a951c8b8cb3f0f03860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uDd_QzWNumwLES-ct1nGjQ.gif"/></div></div></figure><p id="8d3c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它活着！我们不仅渲染了一个立方体，而且还让它从此快乐地旋转起来。现在，后退一步。这是我们写了多少代码:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ny"><img src="../Images/cd5f8a7d2f7b3b6d8675c67b1fa05f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yujD4CpbYvI_2PwBJDCKaQ.png"/></div></div></figure><p id="c0dc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这还不到你之前看到的那个显示静态圆圈的OpenGL例子的一半代码，但是它做了更多。我不是一个过于关注你写了多少行代码的人(尽管我在本文中如此频繁地提到这一点表明事实正好相反)，但我只是想让你明白ThreeJS为你做了多少。不管怎样，给自己一点掌声吧。你已经做了一个真正的3D网络应用程序，你可以引以为豪。</p><h2 id="c284" class="mp ll iy bd lm mq mr dn lq ms mt dp lu kg mu mv ly kk mw mx mc ko my mz mg na bi translated">让它变得阴暗</h2><p id="b3c6" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">还记得材料的作用吗？它告诉我们我们的网格如何与光相互作用。到目前为止，我们使用的MeshBasicMaterial是一种不在乎光的材料。如果你正在制作，比如说，一个2D游戏，或者一个用户界面，那么这是一个很好的素材。然而，这是相当基本的；嘿，名字里有！ThreeJS给了我们更多的材料，我们可以利用这些材料来告诉我们它们对光的反应。一种这样的材质是MeshLambertMaterial，我们将使用它给立方体添加更多的“阴影”。为此，请转到创建材质的那一行，用MeshLambertMaterial替换MeshBasicMaterial。也就是说，更换:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="2a2f" class="mp ll iy ni b gy nm nn l no np">const material = new THREE.MeshBasicMaterial({color: “#097aff”});</span></pre><p id="8c12" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="2a66" class="mp ll iy ni b gy nm nn l no np">const material = new THREE.MeshLambertMaterial({color: “#097aff”});</span></pre><p id="ccc6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在刷新您的页面，您将获得…</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/b22b901ca65954e263dece2e355c5f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2D7BF-OsnF5z_1Gc8W_Ew.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">You’ll get this screen often in computer graphics. Get used to it.</figcaption></figure><p id="c8c1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">啊，是的，我们改变了一行代码，我们的程序从几乎正常工作到崩溃，没有任何解释。如果你是编程新手，那就习惯它吧。这差不多就是你拿钱来处理的事情。</p><p id="3031" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从技术上讲，这里没有发生“错误”。请记住，与网状基底材料不同，我们的网状基底材料会受到光的影响。问题是没有光。我们所有的场景都是我们的蓝色立方体。当我们的立方体有一个MeshBasicMaterial时，这很好，因为它不关心光，而MeshLambertMatrial关心光。因为没有光，我们看不见我们的盒子。要解决这个问题，我们需要为场景添加灯光。</p><h2 id="5dfb" class="mp ll iy bd lm mq mr dn lq ms mt dp lu kg mu mv ly kk mw mx mc ko my mz mg na bi translated">放轻松</h2><p id="4e0d" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">我们要添加到场景中的最后一个对象是光源。triple js捆绑了各种各样的灯供我们使用。对于我们的例子，我们将使用方向灯。在我们创建立方体网格后，立即添加以下行:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="741b" class="mp ll iy ni b gy nm nn l no np">const light = new THREE.DirectionalLight();<br/>light.position.set(0, 2, 2);</span></pre><p id="0b7d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码将创建一个新的方向灯，并把它放在2米以上和2米以外的原点。不过，您仍然会看到黑屏。我们需要给我们的场景增加灯光。我们可以像处理立方体一样进行处理。在正下方添加此行:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="dfef" class="mp ll iy ni b gy nm nn l no np">scene.add(light);</span></pre><p id="5211" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在继续刷新您的页面。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nx"><img src="../Images/db75feb332132dabf686acf7e0a9baf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jSoHY7V6eNbLvm1-RTKl6g.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Ain’t it beautiful?</figcaption></figure><p id="0472" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好好看看吧，这次实际上是3D的！我们差不多结束了。然而，这只是最后一笔收尾工作。这没什么大不了的，但确实会让事情变得简单一些。你可能已经注意到我们的立方体边缘看起来有点粗糙。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nz"><img src="../Images/e6049c623187f51bfa34d816f56124e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ScmOS1Bk9d3BjlCK6N-vQ.png"/></div></div></figure><p id="afed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这被称为“混叠”，是计算机图形学中的一个常见问题。三个JS对此有一个快速的解决方案。我们只需要在我们的WebGLRenderer()中传递属性<em class="mn">抗锯齿</em>设置为<em class="mn">真</em>的对象。转到我们初始化渲染器的地方，并将其调整为如下所示:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="3cd3" class="mp ll iy ni b gy nm nn l no np">const renderer = new THREE.WebGLRenderer({antialias: true});</span></pre><p id="8881" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将使我们的立方体平滑，正如你从我们可笑的特写镜头中看到的:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oa"><img src="../Images/e3b7221b36f9837863609d6cf73368dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-KhTwd3X3REuOQ2cC8nHA.png"/></div></div></figure><p id="bc96" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">再次刷新你的页面，看看吧！</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nx"><img src="../Images/b90cc45c1f0395be5e34a0d0905fc6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*faBIGnbgWu-EWLQXIk8xew.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Now that’s smooth.</figcaption></figure></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="f44f" class="lk ll iy bd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ne mb mc md nf mf mg mh bi translated">包扎</h1><p id="0e3b" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">三个JS是在你的网络应用程序中实现实时3D图形的一个好方法，而不必与WebGL的困难作斗争。我上周才开始学习它，到目前为止，我一直对它很感兴趣，所以如果你刚刚开始你的三个JS之旅，并且走了这么远，那么我们在同一家公司。不过，你显然可以做比旋转立方体更多的事情。事实上，我在写这篇文章的时候正在做一个水模拟。你可以在这里观看我到目前为止的演示<a class="ae lj" href="https://akheheh.github.io/LakeJS/index.html" rel="noopener ugc nofollow" target="_blank">。单击并拖动鼠标光标，或向上或向下滚动以平移并放大或缩小。</a></p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ob"><img src="../Images/91304d96d96d8be14da52f514b86ad8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*I_F7Fxe6GdlgS-L3S8uZ7g.gif"/></div></div></figure><p id="cc05" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你觉得这个教程很有帮助。三个JS充满了乐趣，因为它可以让你在如此小的设置下完成任务。我不知道我会深入到多深，但到目前为止，我喜欢我所看到的。也许继续关注更多！</p><h1 id="6096" class="lk ll iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">有用链接</h1><ul class=""><li id="6bd9" class="oc od iy jx b jy mi kc mj kg oe kk of ko og ks oh oi oj ok bi translated"><a class="ae lj" href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene" rel="noopener ugc nofollow" target="_blank">本教程所基于的三个JS文档</a>。组织得很好，这是我发现自己在试图解决问题时不必求助于StackOverflow的罕见记录之一。</li><li id="759d" class="oc od iy jx b jy ol kc om kg on kk oo ko op ks oh oi oj ok bi translated"><a class="ae lj" href="https://webgl2fundamentals.org/" rel="noopener ugc nofollow" target="_blank"> WebGL2基础</a>。一个深入WebGL的好地方。例子似乎仅限于ES5。</li><li id="54f8" class="oc od iy jx b jy ol kc om kg on kk oo ko op ks oh oi oj ok bi translated"><a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" rel="noopener ugc nofollow" target="_blank"> WebGL: 2D和网络3D图形</a>。学习WebGL的另一个很好的资源。由Mozilla开发者网络提供。</li><li id="a8d0" class="oc od iy jx b jy ol kc om kg on kk oo ko op ks oh oi oj ok bi translated"><a class="ae lj" href="https://learnopengl.com/" rel="noopener ugc nofollow" target="_blank">学习OpenGL </a>。也许是世界上学习OpenGL的最佳资源。对于那些想一路走下去的勇敢的人来说。</li></ul><h1 id="4e43" class="lk ll iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">许可信息</h1><p id="6103" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">天空盒的图像来自Lycksele 2天空盒包，该包是根据知识共享署名3.0未转让许可证从埃米尔·佩尔森的<a class="ae lj" href="https://www.humus.name/index.php" rel="noopener ugc nofollow" target="_blank">网站</a>获得的。你可以在这里找到这个特殊的天空盒<a class="ae lj" href="https://www.humus.name/index.php?page=Textures&amp;ID=131" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c4af" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">据我所知，我正在根据知识共享署名3.0未转让许可证使用这些资产。你可以在这里找到这个许可证<a class="ae lj" href="https://creativecommons.org/licenses/by/3.0/legalcode" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>