# 从开发者友好的角度看 React 与 Vue.js

> 原文：<https://javascript.plainenglish.io/react-vs-vuejs-from-a-developer-friendliness-perspective-a67684bc2465?source=collection_archive---------12----------------------->

![](img/b9dd52be79bcb41aa720f5380832ef89.png)

Photo by [Berkay Gumustekin](https://unsplash.com/@berkaygumustekin?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/friendly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

我经常在我的 feed 文章中看到有人声称一些被大量使用的库(通常是 React 或 Angular)是宇宙中所有邪恶的来源。或者相反，一个图书馆(Vue.js，Svelte，或者通常是一个新的图书馆)是治愈人类所有开放性创伤的灵丹妙药。

尽管存在明显的愚蠢和歇斯底里，但对于那些以帮助开发人员完成任务为唯一目的的工具来说，批判性分析总是一件好事，有时这些文章有好的观点，即使隐藏在一层愚蠢的断言评论之下。有一篇文章的座右铭是“停止使用 React”或类似的东西，这让我想到，不久前，当我每天使用 React 时，为什么有人会不喜欢它？

过去五年来，我一直是 React 的开发者，来自 *Angular.js* (Angular 1.x)世界。最近，由于花了一些时间(可能是受这篇文章引发的想法的影响)，我一直在转向 Vue.js，这是我目前工作的首选框架，也是我以前选择使用的框架。我在日常使用 Vue.js 时得到的印象是，在它的帮助下编码感觉比 React 更“流畅”。作为一个程序员，我尽力去找出我为什么会有这种感觉，所以我有一个关于它的小理论。

# 举起干草叉

我在这里不是说 Vue.js 比 React“更好”,这是愚蠢的，因为它符合上述歇斯底里的文章之一。然而，我想说的是，尽管这两种解决方案对于它们计划要做的事情和它们的(稍微不同的)理想用例来说都很棒，但是随着时间的推移，我清楚地看到 React 有一点问题。这个问题无论如何都不是不可克服的，我认识的大多数人都很好地解决了这个问题。此外，它可能会影响我，尤其是因为我对代码可读性问题很敏感(请关注未来关于这方面的文章)。

事情是这样的，React 用所谓的“钩子”拥抱了异步函数式编程。这完全没问题，事实上，我喜欢函数式编程，因为我认为它使事情变得更简单，类通常是不必要的抽象。然而，我认为在编写和命名内置“钩子”来处理函数中应用程序的渲染周期时，存在某种夸大的乐观情绪。它们感觉不均匀，比它们本来应该的更不光滑。我是如此渴望摆脱 React 中的类，以至于我尽可能快地接受了 hooks/FP 语法。然而，随着时间的推移，我觉得逃课的收获在其他地方消失了。但是在哪里？

就像，通常冗余有利于友好，但是有冗余的`useCallback`和`useMemo`几乎没有好处。同时，`useEffect`作为*唯一的*方法有太多的事情要做，比如跟踪效果，在第一次渲染时触发动作，以及在应用卸载前做一些事情。

另一方面，Vue.js 即使在新的 Composition API(与 React 的钩子方向一致)中，也保留了`watch`和所有清晰简单的生命周期方法。事实上，现在这些也可以被认为是类似于“钩子”的东西，它们工作得一样好。

# Vue.js 和“生活质量”方法

Vue.js 对组合 API 所做的事情与他们过去所做的事情有些类似:当 *Angular.js* (1.x)彻底改变 API 成为 *Angular.io* (2+)时，Angular 团队说这是其速度优化的必要步骤，Vue.js 1 成为 Vue.js 2，进行了类似的优化，但基本上保持了完全相同的 API。

现在，在 React 改变为更加面向 FP 的语法并彻底改变其方式后，Vue.js 已经改变为保持不止一种而是两种有效的编写应用程序的方式:“传统的” *Options API* ，更具声明性，以及新的 *Composition API* ，更像 FP 并且可分离。除了后者提供了新的可能性，它们提供了基本相同的东西，在它们之间切换通常很容易，最重要的是，它们保留了我们如何编写应用程序的相同数量的良好冗余，这是我一直喜欢 Vue 的一点。

我记得我第一个真正的 app 在 Vue.js，是从另一个开发者那里继承来的 app。我不得不扩展它，所以我很快去找了文档，得到了最基本的东西，然后我写了一些东西，它就工作了。当我最终学会了做同样事情的更多方法时，我发现我最初使用的方法仍然有效，而且很好。在 React 中，做事情的方式要么是*单向的，要么是高速公路* …当然是通往外部库的高速公路，这种高速公路有很多，很多人甚至认为这是一种更好的方法。就我而言，我更喜欢 Vue 为我提供内置选项的方式。

拥有“选项”意味着它有许多从严格的角度来看并不需要的结构，但是当涉及到使开发人员的生活更容易时，它带来了相关的价值。简单的`emit`、`provide` / `inject`、观察器、生命周期方法、计算值、组件之外的反应，所有这些都是工具，可以使用也可以不使用。此外，这些额外的结构并没有使 Vue.js 比 React 重很多:事实上 React 更重，而且在大多数比较中也更慢。

# 反应和极简主义的坏的一面

显然，React 中可以构建很棒的东西(实际上，它的活跃社区每天都在构建这些东西)。然而，当一个组件试图在几个`useEffect`后面做太多事情时，或者当一个开发人员(渴望优化速度但不确定如何做到这一点)将几乎所有东西都放在`useCallback`或`useMemo`钩子内时，我看到一些 React 应用遭受代码“分割化”的倾向。看到这一点，甚至还有相当多的代码使用具有竞争条件问题的钩子，我只是有一种预感，人们很难理解内置钩子实际上是如何工作的，对我来说，这是关于 lib 本身的一些事情，React 团队应该考虑作为一个潜在的缺陷来解决。

我首先诊断一下这个问题，与旧的“基于类”的语法相比，我觉得在命名结构上有点缺乏清晰度。例如像`ComponentDidMount`这样的名字，它的意图是非常清楚的，但是`useCallback`不是。事实上，即使是`useEffect`也是一个相当模糊的名字，特别是关于它的许多用例和结构变体，特别是效果所依赖的值的数组和行为类似于卸载钩子的返回值函数。

此外，大多数 React 代码只依赖于三或四种类型的结构:`useState`、`useEffect`、`useMemo` / `useCallback`，有时还有`useRef`。当然，还有其他的挂钩和可能性，但它们要么只对边缘情况有效，要么没有足够的用处来普及，所以事实证明我们只有这四种。虽然我重视极简主义，但我觉得在这种情况下，我们得到了两个世界最糟糕的结果，因为 API 太不清晰，无法从它的精简中受益。难怪为了尽可能兼容 React 而设计的 framework [Solid](https://www.solidjs.com/) 为它的“钩子”选择了完全不同的命名方案，并且还有生命周期方法。

*顺便提一句，* `*useContext*` *甚至可能有用，但我经常看到它的使用(通常用于全局状态)导致代码感觉杂乱，更重要的是，非常难以阅读。我认为，所有写文章讨论放弃 Redux 而使用 React context 支持全局状态的人都应该三思，因为 Redux 肯定会导致许多样板文件，但最终，它仍然比使用上下文来承载全局存储更有意义。不过，在我看来，这些人可能只是想要一个即插即用的通用状态，而没有 Redux 带来的样板文件，也没有四处传递道具的混乱。有很多解决方案，但由于某种原因，它们似乎都不受欢迎。React 以牺牲一些额外的库字节为代价提供一个内置的解决方案可以吗？*

依我拙见，在设计这个“钩子”API 时，React 团队开发了一些太低的内部机制级别的东西，因此它反映了太多的内部工作方式，而不是专注于开发人员的工作流。获得了透明性，**可用性是代价**。

我在这篇文章的开始所说的“流动”是指:不那么严格，更友好，所以当给定我们在时间、焦点甚至技能方面的有限环境时，开发人员可以感到更轻松，并产生更好的代码。有了 Vue.js，我才知道这是可以实现的。

# 结论

抛开 React 在采用、工具和库方面的优势不谈，React 当前的 API 在我看来并不支持 Vue，也不容易在日常生活中处理，尽管它更精简。我不认为任何人希望 React 简单地变成 Vue.js 的克隆，但如果它朝着友好迈出一些小步，肯定会有所帮助。

*更多内容请看*[***plain English . io***](http://plainenglish.io)