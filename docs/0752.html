<html>
<head>
<title>How to Implement Google Photos Grid in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript实现Google相册网格</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-google-photos-grid-in-javascript-6c294bcea001?source=collection_archive---------1-----------------------#2021-02-16">https://javascript.plainenglish.io/how-to-implement-google-photos-grid-in-javascript-6c294bcea001?source=collection_archive---------1-----------------------#2021-02-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/3262d2da17930276aca83ccda0d65b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sBVim0xQA7FGMRDKKh9C9g.gif"/></div></div></figure><div class=""/><p id="9c3d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我如何用JavaScript实现可擦洗照片网格的一步一步的教程。</p><p id="7466" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谷歌照片使用虚拟可擦洗照片网格。Scrubbable photos grid将你所有的照片放在网格中，这样用户就可以跳到他们时间线中任意的年/月/日。这个网格是虚拟的，因此我们可以有效地使用用户的资源，如cpu、内存、磁盘和网络。</p><p id="c63f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇博文中，我将介绍如何用JavaScript实现这样一个网格，我们是否可以用一个简单的导航机制来代替它，跳转到任意的年/月/日，这是一个单独的设计讨论。</p><p id="4ba4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个实现将使用许多技术来使这个虚拟网格接近实际网格，包括</p><ul class=""><li id="2cb5" class="kt ku iy jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">估计并保持网格高度接近实际高度</li><li id="6556" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">仅将可见照片加载到DOM</li><li id="eacd" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">从DOM中分离不可见的照片</li><li id="542c" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">将照片完全放置在网格内</li><li id="6e51" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在某些情况下，调整滚动位置以补偿布局偏移</li></ul></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="4b11" class="lo lp iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">设计</strong></h1><p id="451f" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">在整个博客中，我将总结谷歌为他们的可擦洗网格所做的设计决定，但我会推荐查看这个<a class="ae mr" href="https://medium.com/google-design/google-photos-45b714dfbed1" rel="noopener">谷歌设计博客</a>了解细节。</p><blockquote class="ms mt mu"><p id="1d74" class="jv jw mv jx b jy jz ka kb kc kd ke kf mw kh ki kj mx kl km kn my kp kq kr ks ig bi translated"><em class="iy">我们将保持我们的设计目标与谷歌设计博客中所陈述的一样:</em></p><p id="f522" class="jv jw mv jx b jy jz ka kb kc kd ke kf mw kh ki kj mx kl km kn my kp kq kr ks ig bi translated"><strong class="jx iz">“可擦除照片</strong>——能够快速跳转到照片库的任何部分。</p><p id="ac06" class="jv jw mv jx b jy jz ka kb kc kd ke kf mw kh ki kj mx kl km kn my kp kq kr ks ig bi translated"><strong class="jx iz">对齐布局</strong> —填充浏览器的宽度并保留每张照片的纵横比(无方形裁剪)。</p><p id="c1d2" class="jv jw mv jx b jy jz ka kb kc kd ke kf mw kh ki kj mx kl km kn my kp kq kr ks ig bi translated"><strong class="jx iz"> 60fps滚动</strong> —确保页面即使在查看数千张照片时也能保持响应。</p><p id="f33f" class="jv jw mv jx b jy jz ka kb kc kd ke kf mw kh ki kj mx kl km kn my kp kq kr ks ig bi translated"><strong class="jx iz">瞬间感受</strong> —尽量减少等待任何东西加载的时间。"</p></blockquote><p id="7639" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Google已经做了额外的努力来确保行高是一致的，并且在实现对齐布局时接近目标高度，我们将在这个演示中使用Flicker的对齐布局库。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="dc76" class="lo lp iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">实施</strong></h1><p id="fec3" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">我将一步一步地实现这一点，每一步都是Github Repo中的一个提交。如果您想跳过所有详细的解释并检查最终的实现，请检查这个<a class="ae mr" href="https://glitch.com/edit/#!/scrubbable-photos-grid?path=script.js%3A15%3A0" rel="noopener ugc nofollow" target="_blank">小故障</a>。</p><p id="5b3c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的网格将被划分为部分，部分将有段，段将有瓷砖和瓷砖将有一个图像标签。当我们需要添加它们时，将会详细介绍这些划分的原因。</p><figure class="na nb nc nd gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mz"><img src="../Images/0c310672213602800ecaf2440f9cd49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFz1zr5QbcrDKdpmA0G0qg.png"/></div></div></figure><p id="ab5c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我选择JavaScript来演示在运行时事情应该如何发生，您应该能够在您选择的任何客户端框架中实现这一点。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="eb1b" class="ne lp iy bd lq nf ng dn lu nh ni dp ly kg nj nk mc kk nl nm mg ko nn no mk np bi translated">第一步。将整个网格分成若干部分，并估计它们的高度</h2><p id="ae7a" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">与分页和无限滚动相比，scrubbable grid总是将所有照片显示在网格中，从而正确表示滚动旋钮的有限高度和大小。这也让用户能够立即跳到照片的整个时间轴中的任意时间。</p><p id="787f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种低效的实现会在页面加载后立即加载元数据，如整个时间轴中所有照片的宽度和高度。使用每张照片的宽度和高度，我们可以在页面上为网格的实际高度分配空间。这将浪费大量的带宽，初始加载时间将是不可接受的。</p><p id="0a35" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了减少这个初始元数据负载，我们将把整个时间线分成虚拟部分，并估计每个部分的高度，以获得网格的估计高度。我们的初始有效载荷将由所有部分的数组组成，这些部分中有一些图像。将整个网格划分为多个部分的最简单方法是在时间线中每个月划分一个部分。因此，如果用户的时间跨度为10年，我们的初始有效载荷将由最大120个部分和每个部分的照片数量组成。</p><p id="3b20" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们首先添加带有<code class="fe nq nr ns nt b">grid div</code>的基本html作为网格的容器。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ca84" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用的API是在<code class="fe nq nr ns nt b">api.js</code>中模拟的，它基本上依赖于包含的<code class="fe nq nr ns nt b">store.json</code>的所有部分细节。我们添加了<code class="fe nq nr ns nt b">getSections</code> api来检索所有部分，并对每个部分中的图像进行计数。API使用50-550毫秒的随机延迟。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9c92" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nq nr ns nt b">getSections</code> api输出示例</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cd56" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们添加了<code class="fe nq nr ns nt b">script.js</code>来加载网格。我们的入口点是<code class="fe nq nr ns nt b">loadUi</code>，在这里我们称之为<code class="fe nq nr ns nt b">getSections</code> api。获得所有部分后，我们通过为每个具有估计高度的部分创建一个空的<code class="fe nq nr ns nt b">div</code>来分配空间。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><blockquote class="ms mt mu"><p id="1975" class="jv jw mv jx b jy jz ka kb kc kd ke kf mw kh ki kj mx kl km kn my kp kq kr ks ig bi translated"><em class="iy">如Google Design博客中所述，为了估计部分的高度，我们将假设所有图像的平均纵横比为3:2，如果水平放置，则该部分中所有图像的总宽度大约为3:2，然后除以我们的网格宽度，得到当这些图像以网格宽度包裹时部分的大约高度。</em></p></blockquote><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2876" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们添加基本的<code class="fe nq nr ns nt b">style.css</code>来突出显示部分</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="30d1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://github.com/shaileshpandit/scrubbable-photos-grid/commit/7ddef4c73ee010f248a0235bddc3a80496ec4bb5" rel="noopener ugc nofollow" target="_blank">第一步完全提交</a></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="2278" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">步骤1结果</strong> —观察所有具有估计高度的空截面div都是在加载时创建的，并给出整个网格和滚动旋钮的估计高度。</p><figure class="na nb nc nd gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/1ba835ed8d5dd02735aab16613392dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uZxJEvcfSlTdr-n030wiZA.gif"/></div></div></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="f4ab" class="ne lp iy bd lq nf ng dn lu nh ni dp ly kg nj nk mc kk nl nm mg ko nn no mk np bi translated">第二步。用段填充部分</h2><p id="1fd2" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">部分是整个网格的虚拟划分，以最小化初始负载资源，而段是网格的可视划分，供用户在逻辑组中导航和查看照片。我们将使用每天的静态片段，但可以基于位置或基于用户一天拥有的照片数量的更细粒度的时间段进行动态划分。</p><p id="7442" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们添加了<code class="fe nq nr ns nt b">getSegments(sectionId)</code> api来检索一个部分的所有片段以及每个片段中的图像。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2be3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一个<code class="fe nq nr ns nt b">getSegments(sectionId)</code>调用的示例输出</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b088" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们在<code class="fe nq nr ns nt b">script.js</code>中添加<code class="fe nq nr ns nt b">populateSection(sectionDiv)</code>方法来填充一个section div。在填充一个我们称为<code class="fe nq nr ns nt b">getSegments(sectionId)</code> api的节div时，获取所有内部节段的节段html，将其添加到节div中，并将其高度从最初设置的估计高度更新为100%。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e31e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了生成段html，我们使用<a class="ae mr" href="https://www.npmjs.com/package/justified-layout" rel="noopener ugc nofollow" target="_blank">两端对齐布局</a>库。它为我们提供了该段内所有瓷砖的绝对布局。我们使用这个绝对布局生成单独的tile html，并将其添加为segment childs。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="823b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们急切地在<code class="fe nq nr ns nt b">populateGrid</code>中调用<code class="fe nq nr ns nt b">populateSection</code>来展示填充的部分在ui和DOM中的样子。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8618" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们制作相对于片段绝对定位的图块，并在<code class="fe nq nr ns nt b">style.css</code>中高亮显示片段和图块</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c4da" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://github.com/shaileshpandit/scrubbable-photos-grid/commit/200db9fc752ae537c8f8d153148a27c5add6e0d4" rel="noopener ugc nofollow" target="_blank">第二步完全提交</a></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="8110" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">步骤2结果</strong> —观察所有急切加载的部分和段。</p><figure class="na nb nc nd gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/c8f2beccbd566aa32f0280998d9d9a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aMs5ExXV_hikBBmTnlZIPg.gif"/></div></div></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="7ee9" class="ne lp iy bd lq nf ng dn lu nh ni dp ly kg nj nk mc kk nl nm mg ko nn no mk np bi translated">第三步。延迟加载和卸载部分</h2><p id="8c07" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">虽然在前面的步骤中，我们急切地在页面加载中加载了所有的部分以进行演示，但是我们希望在部分即将进入视窗时附加它们，在它们离开视窗时分离它们。我们将使用<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交叉点观察器</a>来实现这一点。</p><p id="8574" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先我们创建<code class="fe nq nr ns nt b">sectionObserver</code> IntersectionObserver，使用<code class="fe nq nr ns nt b">handleSectionIntersection</code>作为交集处理器，并使用margin的<code class="fe nq nr ns nt b">200px</code>，这样当我们的截面垂直穿过实际视窗+ 200px的虚拟视窗时，就会触发交集。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1b43" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过填充输入部分和从虚拟视口分离输出部分来处理相交事件。由于填充一个部分需要获取异步的段，实际填充可能会偏离交集顺序。为了减轻这种情况，我们为所有部分维护<code class="fe nq nr ns nt b">lastSectionUpdateTimes</code>,并且仅在该部分没有同时更新时填充。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ec09" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过移除所有子段并且不改变高度来分离该部分。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="af66" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将“sectionObserver”附加到所有部分，而不是急切地加载“populateGrid”中的所有部分。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="44b9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://github.com/shaileshpandit/scrubbable-photos-grid/commit/b6cab98216964a789f250285cf725e91cad535a7" rel="noopener ugc nofollow" target="_blank">第3步完全提交</a></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="7582" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">步骤3结果</strong> —观察当我们滚动时，部分div是如何加载和卸载的。</p><figure class="na nb nc nd gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/95ae120b4b4b69cff44075f1898f346c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FIPjy_eowHWeU2p64doLnQ.gif"/></div></div></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="24c1" class="ne lp iy bd lq nf ng dn lu nh ni dp ly kg nj nk mc kk nl nm mg ko nn no mk np bi translated">第四步。将段和截面移动到绝对位置</h2><p id="b631" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">理想情况下，当某些部分的高度改变时，浏览器将有效地计算所有段和部分的位置变化。但是，如果我们想确保我们控制所有的定位变化，我们可以将段和部分都移动到绝对定位。我们的部分将被绝对定位在网格内，而段将被绝对定位在部分内。我们的瓷砖已经完全定位在细分市场内。</p><p id="69d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们将节和段设置为绝对位置，并删除css中的边距。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="41fd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们在<code class="fe nq nr ns nt b">sectionStates</code>中将所有区段的<code class="fe nq nr ns nt b">top</code>、<code class="fe nq nr ns nt b">height</code>和<code class="fe nq nr ns nt b">lastUpdateTime</code>维护为一个状态。我们在<code class="fe nq nr ns nt b">populateGrid</code>中初始化它，并在创建初始分离部分时使用它。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2879" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们更新<code class="fe nq nr ns nt b">populateSection</code>来生成具有绝对定位的线段，计算每个线段的顶部。我们计算该部分的新高度，检查它是否已经改变，如果已经改变，我们通过在顶部添加<code class="fe nq nr ns nt b">heightDelta</code>来移动所有接下来的部分。我们也让<code class="fe nq nr ns nt b">sectionStates</code>与这些变化保持同步。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8ce5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在分离截面后，我们不再需要保持旧的高度，因为在移除子段后，绝对高度保持不变。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8acd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://github.com/shaileshpandit/scrubbable-photos-grid/commit/ce0d430f51550ea6c69dd0a81cde9fcb5b5b8b26" rel="noopener ugc nofollow" target="_blank">第4步完全提交</a></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="cab4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">步骤4结果</strong> —观察如何通过更新所有后续部分div的顶部来保持绝对定位。</p><figure class="na nb nc nd gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/29c5c9bf5dc6c927e91f039f7504fdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xwfo1VPsMygK0T52_CAqdQ.gif"/></div></div></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="b562" class="ne lp iy bd lq nf ng dn lu nh ni dp ly kg nj nk mc kk nl nm mg ko nn no mk np bi translated">第五步。布局移动时调整滚动位置</h2><p id="9fb7" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">在这一点上，如果你尝试向下滚动，部分将会像预期的那样连接和分离，滚动会感觉正常。当用户线性滚动时，部分被附加，它们的高度改变，更多部分的顶部增加，网格高度改变，整个布局改变，但我们在滚动时没有感觉到跳跃。这是因为所有布局更改都是在当前滚动位置之后。</p><p id="30e8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们允许随机跳转到滚动位置，这将会改变。例如，如果我们在页面加载时跳转到一个随机的滚动位置，我们将处于这样的状态:在我们当前的滚动位置之前，一些分离的部分具有估计的高度。现在，如果我们向上滚动，部分将在滚动位置之前附加，并将在滚动位置之前导致布局更改。当我们滚动时，感觉整个页面都在跳动。要尝试这样做，只需将以下内容添加到步骤4提交中的<code class="fe nq nr ns nt b">loadUi</code>中，并尝试向上滚动。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ab95" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">页面跳转</strong> —观察滚动时页面跳转到新位置的感觉</p><figure class="na nb nc nd gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/31c24e84e8dfd1e0d73fc8b7a6a24d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nPcxUu6AzA8v-2dsNXfrbw.gif"/></div></div></figure><p id="33c3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决这个问题，我们检查当前的滚动位置是否在我们调整了高度的部分的前面，并在<code class="fe nq nr ns nt b">populateSection</code>的末尾通过<code class="fe nq nr ns nt b">heightDelta</code>调整滚动。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="aee7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mr" href="https://github.com/shaileshpandit/scrubbable-photos-grid/commit/df9599074b011876b9b31b2466503d47b20e98ef" rel="noopener ugc nofollow" target="_blank">第5步完全提交</a></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="4e65" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">最终结果</strong> —观察如何通过调整滚动位置来固定页面跳转</p><figure class="na nb nc nd gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/3601dcc2eb759c8c6a95aa60a4767bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2w15-ZgN_23bQm1Or-FhJQ.gif"/></div></div></figure><p id="539c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">最终小故障</strong> —打开<a class="ae mr" href="https://scrubbable-photos-grid.glitch.me" rel="noopener ugc nofollow" target="_blank">直播app </a>。使用Glitch中的倒带来查看每一步的操作。</p><figure class="na nb nc nd gt ip"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h1 id="7db5" class="lo lp iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">下一步是什么</h1><p id="8d3a" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">还有很多可以补充的，下面是一些你可以尝试的东西:</p><ul class=""><li id="4c19" class="kt ku iy jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">添加实际图像。</li><li id="c63b" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">浏览谷歌博客，添加他们提到的改进。</li><li id="de1b" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">当部分离开虚拟视口时，取消正在进行的api调用以获取片段，从而在用户快速滚动时节省带宽。当滚动速度很高时，我们甚至可以推迟获取。</li><li id="c069" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">向切片添加交叉点观察点，以便为远处的切片加载低分辨率缩略图，为较近的切片加载高分辨率缩略图。</li><li id="f4a7" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">添加像时间线而不是滚动旋钮谷歌照片，与此用户将能够跳转到任何年份/月份。</li><li id="20e0" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在像React这样的框架中实现整个东西，你可以为截面、分段和平铺创建组件。</li><li id="f958" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">这个演示假设网格占用整个视口宽度，你可以使用网格容器的宽度。它当前也不处理视口大小调整。</li><li id="7ed0" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">人们甚至可以为可擦洗网格制作开源组件。</li></ul><h1 id="40a0" class="lo lp iy bd lq lr nx lt lu lv ny lx ly lz nz mb mc md oa mf mg mh ob mj mk ml bi translated"><strong class="ak">资源</strong></h1><ul class=""><li id="6615" class="kt ku iy jx b jy mm kc mn kg oc kk od ko oe ks ky kz la lb bi translated">谷歌设计博客— <a class="ae mr" href="https://medium.com/google-design/google-photos-45b714dfbed1" rel="noopener">构建谷歌照片网络用户界面</a></li><li id="7f94" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Flickr的对齐布局库— <a class="ae mr" href="https://www.npmjs.com/package/justified-layout" rel="noopener ugc nofollow" target="_blank">对齐布局npm </a></li><li id="3a27" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">交叉口观察者— <a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交叉口观察者Api—Web Api—MDN</a></li><li id="9e8b" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Github Repo用于此实现，每个步骤都有提交— <a class="ae mr" href="https://github.com/shaileshpandit/scrubbable-photos-grid" rel="noopener ugc nofollow" target="_blank">可擦除照片网格</a></li><li id="cf5e" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">带有该实现源代码的Live应用程序— <a class="ae mr" href="https://glitch.com/edit/#!/scrubbable-photos-grid?path=script.js%3A15%3A0" rel="noopener ugc nofollow" target="_blank">故障</a></li></ul></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="5da8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你能走到这一步，我向你致敬！我喜欢实现它，更喜欢写关于它的东西。这是我很久以来的第一篇科技文章，所以非常感谢任何反馈。</p><p id="096c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最初发布于<a class="ae mr" href="https://dev.to/shaileshpandit/how-to-implement-google-photos-grid-in-javascript-575i" rel="noopener ugc nofollow" target="_blank"> dev.to </a></p></div></div>    
</body>
</html>