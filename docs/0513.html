<html>
<head>
<title>An Overview of HTTP Requests &amp; Cross-Origin Resource Sharing (CORS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP请求和跨源资源共享概述(CORS)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/quick-overview-of-http-requests-cross-origin-resource-sharing-cors-db139b41d71?source=collection_archive---------5-----------------------#2021-01-31">https://javascript.plainenglish.io/quick-overview-of-http-requests-cross-origin-resource-sharing-cors-db139b41d71?source=collection_archive---------5-----------------------#2021-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cb04" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><em class="km">快速概述URL由什么组成，HTTP请求如何工作，一些重要的请求头，跨源资源共享(CORS)。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/98e835adac456ab74c518b877dbb07b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YECeOxlko9KoOJNw8RNm3A.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk">Photo by <a class="ae ld" href="https://unsplash.com/@alinnnaaaa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Alina Grubnyak</a> on <a class="ae ld" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="32a0" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">首先，我们先来看一个URL(统一资源定位器)是什么样子的。</p><p id="91c2" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">一个示例URL由4部分组成。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi le"><img src="../Images/41ebd849ef390b531a6c11d2bc54a8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*HfJAWr4Jw7rIXHSRaG4wcw.png"/></div></figure><p id="2546" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">方案:</strong>方案标识将要使用的协议。<strong class="jq ir">协议</strong>指定数据如何传输以及如何解释请求。当你看协议的时候，你会很好的理解这个URL是用来做什么的。(例如，它是SMTP、POP3、IMAP的电子邮件协议，还是访问和管理git存储库的SSH请求，还是web的HTTP请求)</p><p id="e8f4" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> HTTP </strong> —默认情况下在端口80上运行，它指定请求中有哪些报头。</p><p id="3425" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> HTTPS </strong> —与<em class="km"> HTTP </em>协议相同，但HTTPS被认为是浏览器和服务器之间的安全通信。它与HTTP不同；</p><ul class=""><li id="3815" class="lf lg iq jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">默认情况下，在端口443上运行</li><li id="ce8f" class="lf lg iq jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">加密除请求IP之外的所有请求/响应头</li></ul><p id="6e4a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">主机名:</strong></p><p id="ade0" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">只是一个更好命名的IP地址。</p><p id="7177" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">路径:</strong></p><p id="6bf9" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">URL路径就像你的目录路径。它让用户和搜索引擎了解他们当前所在的版块，比如“/关于”版块。事实上，这一部分对于更好地优化SEO非常重要。</p><p id="dfed" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">查询参数:</strong></p><p id="081b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">它用于向服务器发送数据。这通常用于营销原因，以了解广告做得如何。以<code class="fe lt lu lv lw b">?</code>开头，以<code class="fe lt lu lv lw b">&amp;</code>分隔数据</p><p id="5a1b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> <em class="km">注意</em> </strong> <em class="km">:出于安全考虑(这样大家都能看到)不建议用查询参数发送数据，而且还有字符限制。(2048个字符后不允许)。</em></p><p id="2454" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">有了HTTP和HTTPS协议，我们还可以通过其他方式向服务器发送数据。</p><h2 id="e3c9" class="lx ly iq bd lz ma mb dn mc md me dp mf jz mg mh mi kd mj mk ml kh mm mn mo mp bi translated">请求和响应</h2><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/970643d7a3cc6e11f5f7b7fb2bbbec6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*8S-OTIgudIC9wOIbN3VETg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk">Taken from C0D3.com</figcaption></figure><p id="9b61" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当用户在浏览器中键入域名时，browser go会找到该服务器(只是其他人的计算机)并向该服务器发送请求。如果从服务器获得成功的响应，则在浏览器上呈现页面。</p><p id="f201" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> <em class="km">注意</em> </strong> <em class="km">:使用终端发送请求时(比如运行</em> <code class="fe lt lu lv lw b"><em class="km">node index.js</em></code> <em class="km">时)流程是一样的。要向服务器发送请求，您不一定需要浏览器，您也可以使用您的终端来完成。但是，如果响应是HTML，终端不会做任何事情，因为HTML只是浏览器的指令。</em></p><h2 id="5d27" class="lx ly iq bd lz ma mb dn mc md me dp mf jz mg mh mi kd mj mk ml kh mm mn mo mp bi translated">头球</h2><p id="a8c1" class="pw-post-body-paragraph jo jp iq jq b jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh mv kj kk kl ij bi translated">浏览器和服务器都需要知道彼此的一堆信息才能相互识别并最终发送请求或响应。比如IP地址、内容类型、Cookie、<a class="ae ld" href="https://en.wikipedia.org/wiki/Cache-Control" rel="noopener ugc nofollow" target="_blank">、缓存控制</a>等等。你可以在这里找到完整的列表。它们用<strong class="jq ir">报头</strong>携带这些数据，报头就是<strong class="jq ir"> </strong>键值对。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mw"><img src="../Images/b1c9f67750b7c6b89d0b16ccab035854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJ2ViLP32reDBOfeYHB46Q.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk">Request Headers Example | Taken from C0D3.com</figcaption></figure><p id="88fc" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">发送请求时，您只需手动设置两个头:<strong class="jq ir"> Content-Type </strong>和<strong class="jq ir"> Authorization </strong>。虽然您可以设置其他标题，但它们通常由浏览器自动处理。</p><p id="c15f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> Content-Type — </strong>当<strong class="jq ir"> </strong>你用body ( POST，PATCH，PUT请求)向服务器发送数据时，你需要指定它的内容类型是<code class="fe lt lu lv lw b">application/json</code>、<code class="fe lt lu lv lw b">text/html</code>、<code class="fe lt lu lv lw b"> image/gif</code>还是<code class="fe lt lu lv lw b"> video/mpeg.</code></p><p id="c6e8" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">授权</strong> —这是服务器用来识别用户的。与cookie头不同，这个头必须由开发人员在发送请求时手动设置。通常用于API请求和JWT认证。</p><h2 id="4794" class="lx ly iq bd lz ma mb dn mc md me dp mf jz mg mh mi kd mj mk ml kh mm mn mo mp bi translated">请求</h2><p id="2320" class="pw-post-body-paragraph jo jp iq jq b jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh mv kj kk kl ij bi translated">通过互联网发送的每个请求由2个强制部分和1个可选部分组成。</p><ol class=""><li id="2331" class="lf lg iq jq b jr js jv jw jz lh kd li kh lj kl mx ll lm ln bi translated"><strong class="jq ir">请求行</strong>；由请求方法(获取、发布、删除等)和路径(从URL中提取)组成</li><li id="6cca" class="lf lg iq jq b jr lo jv lp jz lq kd lr kh ls kl mx ll lm ln bi translated"><strong class="jq ir">表头</strong>上面简要说明了</li><li id="3fea" class="lf lg iq jq b jr lo jv lp jz lq kd lr kh ls kl mx ll lm ln bi translated"><strong class="jq ir"> Body </strong>(可选):当你向服务器发出POST、PUT、PATCH请求时，你需要发送一个Body来告诉服务器你想发送什么数据。示例:</li></ol><pre class="ko kp kq kr gt my lw mz na aw nb bi"><span id="fcb6" class="lx ly iq lw b gy nc nd l ne nf">axios.post(‘/users’, <br/>{id: “5fddfefc4fbd19494493cd71”, name: "username"} // <strong class="lw ir">this part is body</strong><br/>).then(console.log)</span></pre><ul class=""><li id="86ea" class="lf lg iq jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">axios是一个发送请求的库。浏览器还为您提供了一个名为<strong class="jq ir"> fetch </strong>的函数，该函数允许发送请求。还有一个过时的<strong class="jq ir">请求</strong>库发送请求。</li><li id="6add" class="lf lg iq jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><strong class="jq ir"> post </strong>是请求方法，意思是我们正在向服务器发送信息。在这里详细查看HTTP请求方法<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="4356" class="lf lg iq jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><strong class="jq ir"> '/users' </strong>是指定您在服务器中发送请求的确切位置的路径。这个URL部分其实叫API。当一个API遵循<strong class="jq ir"> REST </strong>模式，就变成了<strong class="jq ir"> REST API </strong>，让开发者快速理解和使用API。正如REST pattern所说，例如，<strong class="jq ir">路径</strong>应该总是复数形式。</li></ul><blockquote class="ng nh ni"><p id="89fc" class="jo jp km jq b jr js jt ju jv jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk kl ij bi translated">REST代表表述性状态转移，它是一套设计原则，允许你使用API来使用和修改服务器上的资源。</p></blockquote><ul class=""><li id="7421" class="lf lg iq jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated"><strong class="jq ir"> body </strong>是数据对象本身，因此服务器可以获得该数据。</li></ul><p id="7f1f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如您所见，除了在浏览器中输入域名之外，还有其他方法可以向服务器发送请求。</p><blockquote class="ng nh ni"><p id="c863" class="jo jp km jq b jr js jt ju jv jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk kl ij bi translated"><strong class="jq ir"> AJAX </strong>:从浏览器发送请求。如果有人告诉你他们知道ajax，这意味着他们知道如何从浏览器发送请求。</p></blockquote><h1 id="b708" class="nm ly iq bd lz nn no np mc nq nr ns mf nt nu nv mi nw nx ny ml nz oa ob mo oc bi translated">期权方法&amp;跨产地资源共享(CORS)</h1><p id="d16a" class="pw-post-body-paragraph jo jp iq jq b jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh mv kj kk kl ij bi translated"><strong class="jq ir">选项</strong>请求被称为<em class="km">飞行前请求。</em></p><p id="6f2d" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">目前，你看到的响应来自<em class="km">medium.com</em>服务器。假设我写了一个JS代码，当你浏览这个的时候，它发送一个POST请求到我自己的网站。这被称为<strong class="jq ir">跨域请求</strong>。</p><blockquote class="ng nh ni"><p id="0d72" class="jo jp km jq b jr js jt ju jv jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk kl ij bi translated"><strong class="jq ir">跨域请求:</strong>发送到与您当前所在的url主机名不同的url的请求。</p></blockquote><p id="53dc" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">使用我的JS代码，我希望浏览器向另一个域(另一个服务器)发送另一个请求。然而，这并不容易。出于安全原因，浏览器限制从脚本发起的跨来源HTTP请求。</p><p id="815f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">某些"<strong class="jq ir">跨域</strong>"请求，特别是Ajax请求，默认情况下被<a class="ae ld" href="https://en.wikipedia.org/wiki/Same-origin_policy" rel="noopener ugc nofollow" target="_blank">同源安全策略</a>禁止，而"<strong class="jq ir">同源</strong>"请求总是被允许的。</p><p id="b2ec" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir"> CORS </strong>定义了浏览器和服务器交互的方式，并确定允许跨源请求是否安全。</p><blockquote class="ng nh ni"><p id="582d" class="jo jp km jq b jr js jt ju jv jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk kl ij bi translated"><strong class="jq ir">跨来源资源共享</strong> ( <a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>)是一种基于HTTP报头的机制，它允许服务器指示除它自己之外的任何其他<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Glossary/origin" rel="noopener ugc nofollow" target="_blank">来源</a> s(域、方案或端口)，浏览器应该允许从这些来源加载资源。</p></blockquote><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi od"><img src="../Images/9509eb960daac49312ebf36f8777f154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J35DcnM_wbU9b4C5IZvkpQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk">Taken from <a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a></figcaption></figure><h2 id="66cd" class="lx ly iq bd lz ma mb dn mc md me dp mf jz mg mh mi kd mj mk ml kh mm mn mo mp bi translated">所以我发了一份跨产地请求。现在发生了什么？</h2><p id="2543" class="pw-post-body-paragraph jo jp iq jq b jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh mv kj kk kl ij bi translated">浏览器注意到域是不同的，所以它发送一个<strong class="jq ir">选项</strong>请求到服务器，只是为了检查请求是否被允许。这与开发者无关，它是由浏览器自动完成的。但是开发者在发送跨源请求之前，可以在请求中添加一些头，这可能有助于获得允许。</p><p id="21e4" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">就像其他浏览器请求一样，像<code class="fe lt lu lv lw b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Method" rel="noopener ugc nofollow" target="_blank">Access-Control-Request-Method</a>, <a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Headers" rel="noopener ugc nofollow" target="_blank">Access-Control-Request-Headers</a> </code>头中的一些数据是用OPTIONS方法发送的，它提供了一些信息，如真正的请求何时到来，数据类型是什么，请求方法是什么等等。</p><p id="5fbf" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果在这些情况下接受请求，服务器现在可以做出响应。故事的其余部分只取决于服务器。作为响应，服务器可能会发回一个带有<code class="fe lt lu lv lw b">Access-Control-Allow-Origin: *</code>的<code class="fe lt lu lv lw b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin" rel="noopener ugc nofollow" target="_blank">Access-Control-Allow-Origin</a></code>头，这意味着<strong class="jq ir">任何</strong>域都可以访问该资源。</p><p id="240a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">虽然它允许来自其他域的GET请求，但可能会限制POST请求。</p><h2 id="25e7" class="lx ly iq bd lz ma mb dn mc md me dp mf jz mg mh mi kd mj mk ml kh mm mn mo mp bi translated">跨域请求的一些重要响应头</h2><p id="9871" class="pw-post-body-paragraph jo jp iq jq b jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh mv kj kk kl ij bi translated"><strong class="jq ir">Access-Control-Allow-Origin</strong>—包含允许发送跨域请求的主机名。如果这与用户所在站点的主机名不匹配，则跨域将被拒绝。</p><p id="7484" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">Access-Control-Allow-Credentials</strong>—如果在响应头中为真，则跨域请求将包括cookie头。</p><p id="ee64" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">Access-Control-Allow-Methods</strong>—这是一个逗号分隔的字符串，告诉浏览器在跨域请求中允许哪些请求方法。如果请求方法未包含在此响应标头中，则不会发送请求。</p><p id="fa46" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">用于设置标题的Node.js代码之一；</p><pre class="ko kp kq kr gt my lw mz na aw nb bi"><span id="1d27" class="lx ly iq lw b gy nc nd l ne nf">router.options('/api/*', (req, res) =&gt; {<br/>  res.header('Access-Control-Allow-Credentials', true)<br/>  res.header('Access-Control-Allow-Origin', req.headers.origin)<br/>  res.header('Access-Control-Allow-Methods', 'GET, PUT, POST, PATCH, DELETE')<br/>  res.header(<br/>    'Access-Control-Allow-Headers',<br/>    'Origin, X-Requested-With, Content-Type, Accept, Credentials'<br/>  )<br/>  res.send('ok')<br/>})</span></pre><h2 id="f50d" class="lx ly iq bd lz ma mb dn mc md me dp mf jz mg mh mi kd mj mk ml kh mm mn mo mp bi translated"><strong class="ak">为什么服务器开发者需要知道这个</strong></h2><p id="061d" class="pw-post-body-paragraph jo jp iq jq b jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh mv kj kk kl ij bi translated">CORS标准意味着，服务器开发人员必须处理新的请求和响应头。他们需要用标题来划分界限，这样他们可以防止安全漏洞。</p><p id="488a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我试着简单地解释这些重要的概念，如果你有任何问题或者想知道更多关于上面提到的某个特定话题，请告诉我。</p><p id="5340" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">干杯！</p></div></div>    
</body>
</html>