<html>
<head>
<title>4 Common Patterns You Can Easily Focus On In Your React Code Reviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在您的React代码评审中，您可以轻松关注的4种常见模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/4-common-patterns-you-can-easily-focus-on-in-your-react-code-reviews-1ebb6d83b89e?source=collection_archive---------15-----------------------#2021-10-19">https://javascript.plainenglish.io/4-common-patterns-you-can-easily-focus-on-in-your-react-code-reviews-1ebb6d83b89e?source=collection_archive---------15-----------------------#2021-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e9928fda9ffdab6364e2333b2846a93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFmnjxmy6KSYkBZkbwOPCw.png"/></div></div></figure><p id="714f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React开发中，您可以使用许多不同的设计模式。将自己培养成一名更好的React开发人员的一部分是学习它们，理解它们的用例，并能够在适当的情况下应用它们。由于这个原因，这个领域有很多资源会教你如何实现它们。</p><p id="9a8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，作为React开发人员，您对这些设计模式的参与不仅仅局限于实现它们。如果你在一个工程团队中工作，你的职责通常也包括许多评审。必须仔细阅读你同事的反馈工作，理解它，并提供反馈。</p><p id="fe0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着你必须理解由你的同事而不是你自己实现的模式，或者使用你所掌握的关于这些模式的知识来提供反馈。然而，能够对React pull请求提供适当的审查需要完全不同的技能和对相同模式的理解。</p><p id="a410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要应用React模式，您最需要知道如何正确地实现它们，以及何时有意义。但是要在您的评审中应用React模式，您首先需要识别您的同事所实现的当前模式或构造。然后，您必须确定当前的实现是否有限制或缺陷。如果是这样，那么您必须确定是否有替代模式来解决这些问题，并确保它可以应用于当前的情况。最后，你需要向你的同事解释如何实现这个模式，或者帮助他们。</p><p id="8807" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这整个过程并不简单，但是如果处理得当，可以极大地提高你的评论质量。为了帮助您，本文将介绍常见的React模式，您可以在审查React pull请求时轻松使用这些模式。这些信息将帮助您成为更好的React审核者，并为您的同事提供更有意义的审核。</p><blockquote class="kw kx ky"><p id="e552" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">本文是十月系列Reviewtober的第二篇文章，在该系列文章中，我们探讨了作为React开发人员如何改进评审过程。第一篇和以后的文章可以在<a class="ae ld" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">unconnormal React</a>找到，这是一篇时事通讯，通过关注较少讨论的主题，如测试、可读性等，帮助您成为更好的React开发人员。</p></blockquote></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="3c7a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">支柱钻井</h1><p id="1d09" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">最常讨论的反应模式之一是支柱钻井。这是当一个特定的组件嵌套在一个更大的组件树中，并且需要特定的属性值，但是属性信息只在树中更高的几个级别上可用。</p><p id="1fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题的一个常见(反)模式是将值从父组件一直传递到需要它的子组件。虽然这是可行的，但这意味着中间的所有组件也必须接受该道具。不是因为他们自己需要它，而是因为他们需要沿着组件链传递它，这是次优的props API设计。</p><p id="7141" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">审查时，相对容易发现支柱钻孔的情况。大多数时候，评审是在浏览器的平台上进行的，比如Github和Gitlab。然而，在浏览器中查看只有非常有限的IDE支持。这意味着在文件之间导航需要更多的努力，这正是prop drilling要求您做的。</p><p id="1911" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您在试图理解代码的同时，不断地在文件之间切换，并在所有地方导航，那么很可能您正在处理一个prop drilling事件。在这种情况下，您可以提出几种不同的方法来解决支柱钻孔问题。根据场景，这些包括但不限于使用复合模式、反应上下文或复合组件。</p><h1 id="a44e" class="ll lm iq bd ln lo mo lq lr ls mp lu lv lw mq ly lz ma mr mc md me ms mg mh mi bi translated">多重布尔状态</h1><p id="af6d" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">随着React从类组件转移到带钩子的功能组件，我们处理状态的方式也发生了变化。不再有一个对象跟踪所有的状态属性，现在每个状态都在它们自己的<code class="fe mt mu mv mw b">useState</code>钩子中被单独跟踪。</p><p id="a73e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这导致了状态流的更好的分离，但是它也有它的缺陷。其中一个陷阱是，每当一条新信息不加思索地添加到组件中时，总是倾向于<code class="fe mt mu mv mw b">useState</code>。这可能导致不必要的状态、额外的复杂性和不可到达的状态。在处理布尔状态时，这些问题尤其突出。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="6276" class="nf lm iq mw b gy ng nh l ni nj">const Component = () =&gt; {<br/>	const [isInitialized, setIsInitialized] = useState(false);<br/>	const [isLoading, setIsLoading] = useState(false);<br/>	const [isError, setIsError] = useState(false);</span><span id="9697" class="nf lm iq mw b gy nk nh l ni nj">	// ...<br/>}</span></pre><p id="9276" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个常见的例子是，一个组件获取一些数据，并需要处理检索这些数据的逻辑。这几乎总是伴随着一个变量来跟踪数据是否加载完毕，以及一个变量来跟踪数据请求是否失败。在某些场景中，跟踪数据请求是否已经初始化也是相关的。</p><p id="d45d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这些信息的表达和思考方式，为它们中的每一个实现一个<code class="fe mt mu mv mw b">useState</code>并在一个布尔状态变量中捕获它是很常见的。这些布尔状态的问题是处理数据逻辑变得越来越困难。</p><p id="5ccc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据状态变量，数据请求可能正在等待初始化，已经在加载，但也有错误。如果你从现实的角度思考这些状态，这种情况是不可能发生的。然而，由于状态的实现方式，这些不可能和不可及的情况仍然需要在代码中考虑、实现和维护。这给代码库引入了额外的代码，增加了复杂性和维护负担。</p><p id="cadf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在审查期间，这种模式会更快地暴露出来。它由多个布尔状态表示，这些布尔状态是同一数据流或逻辑流的一部分。在以任何有意义的方式使用它们之前，这与许多组合的空值检查一起使用，以单独验证它们。</p><p id="fe1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题最直接的方法是改变状态的实现，使用不同的数据结构。使用一个枚举变量，而不是几个布尔变量。将这一点与TypeScript结合起来将会消除开发过程中必须处理的任何不可到达的状态。</p><h1 id="ca9d" class="ll lm iq bd ln lo mo lq lr ls mp lu lv lw mq ly lz ma mr mc md me ms mg mh mi bi translated">组件、挂钩和道具命名</h1><p id="7112" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">软件开发中最困难的任务之一是命名事物。不幸的是，在React开发中，我们有许多额外的实体需要命名。想想通常的变量和函数，还有组件、钩子、道具等等。这些实体的正确命名会使React代码更容易维护，可读性更好，而糟糕的命名会使代码难以阅读、理解和维护。</p><p id="f533" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了额外的实体之外，React开发的可重用性和可组合性给这件事增加了更多的难度。在一个普通的React代码库中，通常有许多小组件，每个组件都有自己的钩子、变量和props API。在所有这些实体中保持所有名称的一致和清晰本身就是一项艰巨的任务。</p><p id="08cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与开发相比，在评审期间更容易对整个结构有一个适当的鸟瞰。当审查代码时，你是在阅读所有新鲜的代码，而不是已经投入其中。由于这一点，你可以更容易地掌握上下文、联系和一致性。这些信息允许您更正确地判断实体的命名是否正确。</p><p id="340d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我所经历的关于命名组件、钩子和道具的最常见的错误是为了长度而牺牲清晰性。较短的名字更容易阅读，代码也更少，但并不总是更清晰。尤其是当有大量的实体需要命名时，尽可能清晰非常重要。因此，在名称中包含更多的信息也无妨，比如详细说明应该在什么上下文中使用它，它是什么类型，它期望什么和返回什么，等等。</p><h1 id="7ab9" class="ll lm iq bd ln lo mo lq lr ls mp lu lv lw mq ly lz ma mr mc md me ms mg mh mi bi translated">上帝组件</h1><p id="da9a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">软件开发中一个非常常见的反模式是上帝实体。这是一个实体，就像函数、类或对象一样，知道的太多，做的太多，负责的也太多。这样一个god实体的问题是，不同的代码流变得交织在一起，它们的代码变得非常紧密耦合，维护变得更加复杂，并且对god实体的某个部分进行更改可能会对其他流产生意想不到的后果。</p><p id="412c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React开发中，等效的组件要么接收大量数据，负责大量逻辑，呈现大部分UI，要么是这些功能的组合。我们讨论的相同结果也适用于这样的上帝组件。因此，最好避免在React代码库中包含这样的组件。</p><p id="44f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几个症状表明某个特定组件是上帝组件。要么是一个组件接收了几个与代码库中其余组件不成比例的道具。特别是，这些道具与数据相关，这表明大量的数据流不得不绕过这个单一的组件。或者该组件实现了许多React挂钩，无论是自定义的还是React挂钩，并且许多逻辑是在该组件内部处理的。或者结果HTML结构的很大一部分被呈现在单个地方。</p><p id="b344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当审查React代码时，由于浏览器中缺乏IDE支持，这些症状变得更加明显。您被迫以不同于您习惯的方式通读代码，这使您关注不同的方面。组件的大小和组件的props API的大小是那些方面的一部分，并且是god组件的指示。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="e502" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">最后的想法</h1><p id="44bb" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">设计模式在React开发中非常常见。作为React开发人员的一部分是了解、理解并能够在适当的情况下应用它们。除了开发之外，React模式也可以在代码评审期间应用。这将极大地提高这些评论的质量。然而，这样做并不是一件小事，需要对这些模式有不同的理解。</p><p id="3475" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了帮助您做到这一点，本文介绍了几种常见的React模式，您可以轻松地将它们集成到React拉式请求评审中。这些包括道具钻取、多重布尔状态、组件、钩子和道具的命名，以及一个god组件。提供的信息将帮助您识别它们，将它们整合到您的评论中，并提高您的React评论的质量。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="26d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，可以考虑查看一下<a class="ae ld" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">不常见的React </a>时事通讯、我的<a class="ae ld" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank"> Twitter </a>的其他条目，以便将来更新，或者我的其他(React)关于Medium的工作。</p><p id="92d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kz">更多内容看</em><a class="ae ld" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>