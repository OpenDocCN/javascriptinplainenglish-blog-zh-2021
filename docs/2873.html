<html>
<head>
<title>React Testing Library Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React测试库概述</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-testing-library-overview-1065082563d2?source=collection_archive---------9-----------------------#2021-06-11">https://javascript.plainenglish.io/react-testing-library-overview-1065082563d2?source=collection_archive---------9-----------------------#2021-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b0bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一种简单易用的酶替代品</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83133be85f7e28de098bd3fbd73eac15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_R9aLYHeT72NrXya"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">photo credit: <a class="ae ky" href="https://academy.hsoub.com/programming/javascript/react/%D8%A7%D8%AE%D8%AA%D8%A8%D8%A7%D8%B1-%D8%AA%D8%B7%D8%A8%D9%8A%D9%82%D8%A7%D8%AA-react-%D8%A8%D8%A7%D8%B3%D8%AA%D8%B9%D9%85%D8%A7%D9%84-jest-%D9%88%D9%85%D9%83%D8%AA%D8%A8%D8%A9-react-testing-library-r1138/" rel="noopener ugc nofollow" target="_blank">academy.hsoub.com</a></figcaption></figure><h2 id="18a7" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">RTL介绍</h2><p id="280f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">React测试库是由软件测试大师Kent C. Dodds创建的。目标是为流行的JavaScript测试库Enzyme提供一个更轻量级的替代品，并消除“破坏测试库”的可能性。</p><p id="f460" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">肯特是良好测试实践的倡导者。他已经写了许多关于这个主题的博客文章，这些文章是公开的，也是强烈推荐的。他解释了编写可维护的测试的重要性，这意味着如果被测试的代码被重构，它们仍然会通过。我们应该测试的是功能，而不是实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h2 id="1fc8" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">设置</h2><p id="a018" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">明确地说，React测试库并没有消除开玩笑的必要。它不是一个测试运行程序，所以你仍然想使用Jest，就像使用Enzyme一样。利用酶没有错。只是个人喜好。正如我之前提到的，RTL给了我们同样的能力来测试我们的React组件，同时去掉了一些不常用的方法。如果您是React测试的新手，请随意查看我的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/intro-to-react-component-testing-cd42853c06d3">React组件测试简介</a>，它涵盖了酶和Jest用法的基础知识。</p><p id="2c63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您使用create-react-app构建应用程序的框架，那么react测试库(和Jest)已经包含在您的依赖项中了。否则，您可以从命令行添加它。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="fec2" class="kz la in ma b gy me mf l mg mh">npm i --save-dev @testing-library/react</span></pre><p id="0e75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试文件必须以. test.js结尾命名，以便在运行“npm测试”时被识别为测试。这条命令将运行所有可用的测试套件。</p><p id="ce91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试本身仍然利用典型的“描述”、“测试”和“预期”块，但是RTL中有一些内置函数可以帮助我们模拟应用程序的预期用途和用户交互。</p><h2 id="06b7" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">渲染、筛选和调试</h2><p id="bc5a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">渲染、屏幕和调试是常用的，可以通过在文件顶部导入它们来访问，如下所示:</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="8127" class="kz la in ma b gy me mf l mg mh">import {render, screen, debug}</span></pre><p id="5a63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Render模仿作为参数传入的组件的呈现。这必须在我们测试该组件中的任何东西之前完成。在它被渲染之后，我们可以在screen关键字上添加一些查询方法，这将在当前渲染的元素上执行搜索。</p><p id="4b59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还可以对screen关键字使用debug方法。这将在您的终端中显示所有当前呈现的HTML元素，这样当我们执行模拟呈现时，您可以确切地看到页面在测试过程中的样子。最佳实践是在编写测试时将screen.debug()添加到测试的末尾，以确保您知道可以从屏幕上选择什么和不可以选择什么。</p><h2 id="ef51" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">选择/查询元素</h2><p id="afc4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在测试特定元素是否被正确呈现之前，我们需要找到这些元素。通过RTL内置的getBy、queryBy和findBy方法，查询变得很容易。使用render方法后，我们可以使用screen.debug()代码片段来查看HTML显示的内容，并确定选择所需内容的最佳方法。</p><p id="99ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">getBy方法适用于我们希望使用传递给render方法的组件呈现的内容。例如，如果您希望应用程序组件立即有一个下拉菜单，您可以运行如下测试:</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="6507" class="kz la in ma b gy me mf l mg mh">describe('App', () =&gt; {</span><span id="4835" class="kz la in ma b gy mi mf l mg mh">  test('renders drop down menu options', () =&gt; {</span><span id="b19a" class="kz la in ma b gy mi mf l mg mh">    render(&lt;App /&gt;);</span><span id="8f85" class="kz la in ma b gy mi mf l mg mh">    const dropdown = screen.getByRole('combobox');</span><span id="0a5c" class="kz la in ma b gy mi mf l mg mh">    expect(dropdown).toBeInTheDocument();</span><span id="5565" class="kz la in ma b gy mi mf l mg mh">  });</span><span id="8bff" class="kz la in ma b gy mi mf l mg mh">})</span></pre><p id="8d43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过代码编辑器中的自动完成功能，getBy有许多变体。一些最常用的变体是getByText和getByRole。如果您不确定您正在寻找的元素的角色，只需传入一个空字符串作为参数，您将看到当前呈现的HTML中所有可用角色的列表。</p><p id="9486" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您需要测试某个元素不在屏幕上，您会希望使用queryBy方法，它包含许多相同的变体，并添加。toBeNull()位于expect块的末尾。以React测试库中的这个测试为例。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="0644" class="kz la in ma b gy me mf l mg mh">describe('App', () =&gt; {</span><span id="009f" class="kz la in ma b gy mi mf l mg mh">test('renders App component', async () =&gt; {</span><span id="5edb" class="kz la in ma b gy mi mf l mg mh">render(&lt;App /&gt;);</span><span id="0b48" class="kz la in ma b gy mi mf l mg mh">expect(screen.queryByText(/Signed in as/)).toBeNull();</span><span id="76c3" class="kz la in ma b gy mi mf l mg mh">screen.debug();</span><span id="c28a" class="kz la in ma b gy mi mf l mg mh">expect(await screen.findByText(/Signed in as/)).toBeInTheDocument();</span><span id="8664" class="kz la in ma b gy mi mf l mg mh">screen.debug();</span><span id="9e8c" class="kz la in ma b gy mi mf l mg mh">});</span><span id="349b" class="kz la in ma b gy mi mf l mg mh">});</span></pre><p id="d9ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以看到使用了async和await关键字，因为我们正在测试用户登录后是否会显示“登录身份”文本。findByText方法用于在异步函数执行完毕后检查所选元素是否在文档中。</p><h2 id="6309" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">事件模拟</h2><p id="f8f2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当你想要假装一个动作发生时，使用fireEvent函数。它可以用来改变表单域的值或点击按钮。但是，在模仿用户交互时，建议使用userEvent函数。</p><p id="34c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个测试的例子，当点击“重新开始”按钮时，检查订单是否被清除。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="8920" class="kz la in ma b gy me mf l mg mh">describe('App', () =&gt; {</span><span id="e420" class="kz la in ma b gy mi mf l mg mh"> test('clears the current order when start over is clicked', () =&gt; {</span><span id="ef8c" class="kz la in ma b gy mi mf l mg mh">   render(&lt;App /&gt;);</span><span id="fd0a" class="kz la in ma b gy mi mf l mg mh">   fireEvent.change(screen.getByRole('combobox'), {</span><span id="2031" class="kz la in ma b gy mi mf l mg mh">     target: {value: 'dinner'}</span><span id="d8b3" class="kz la in ma b gy mi mf l mg mh">    })</span><span id="6836" class="kz la in ma b gy mi mf l mg mh">   const addButtons = screen.getAllByRole('button')</span><span id="3a78" class="kz la in ma b gy mi mf l mg mh">   fireEvent.click(addButtons[0])</span><span id="b032" class="kz la in ma b gy mi mf l mg mh">   const startOverButton = screen.getByText(/Start Over/)</span><span id="4e94" class="kz la in ma b gy mi mf l mg mh">   expect(startOverButton).toBeInTheDocument()</span><span id="3a64" class="kz la in ma b gy mi mf l mg mh">   fireEvent.click(startOverButton)</span><span id="ca30" class="kz la in ma b gy mi mf l mg mh">   expect(screen.queryByText(/current order/)).toBeNull()</span><span id="f504" class="kz la in ma b gy mi mf l mg mh">  });</span><span id="e72e" class="kz la in ma b gy mi mf l mg mh">})</span></pre><p id="e1d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先呈现应用程序组件，将下拉菜单中的选定值更改为“晚餐”以显示菜单选项。然后我们检查“重新开始”按钮是否被呈现。最后，我们在按钮上假装一个点击动作，并测试当前订单是否被清除。</p><h2 id="49f1" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">最后…</h2><p id="d598" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我希望这篇文章已经让您对最佳测试实践有了更好的理解，并介绍了一些您可以在将来的项目中使用的附加工具。有大量关于React测试库用例的文档、教程和博客。如果您通常使用Enzyme，我鼓励您查看下面的资源，尝试一些不同的东西。你会很高兴你做了！</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="1cb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://testing-library.com/docs/" rel="noopener ugc nofollow" target="_blank"> RTL官方文件</a></p><p id="dc62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://testing-library.com/docs/react-testing-library/cheatsheet/" rel="noopener ugc nofollow" target="_blank"> RTL小抄</a></p><p id="cfeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://www.robinwieruch.de/react-testing-library" rel="noopener ugc nofollow" target="_blank">肯特·多德初级教程</a></p><p id="2848" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://kentcdodds.com/blog/introducing-the-react-testing-library" rel="noopener ugc nofollow" target="_blank">RTL博文简介</a></p><p id="5763" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/react-testing-library-tutorial-javascript-example-code/" rel="noopener ugc nofollow" target="_blank"> FreeCodeCamp RTL教程</a></p><p id="d0bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mq">更多内容尽在</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mq">plain English . io</em></a></p></div></div>    
</body>
</html>