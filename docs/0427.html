<html>
<head>
<title>How to store data client-side with IndexedDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用IndexedDB在客户端存储数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-store-data-client-side-with-indexeddb-7d924bebe8f3?source=collection_archive---------18-----------------------#2021-01-25">https://javascript.plainenglish.io/how-to-store-data-client-side-with-indexeddb-7d924bebe8f3?source=collection_archive---------18-----------------------#2021-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cf69" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">它得到了很好的支持，允许您存储大文件，而且使用起来也没那么糟糕。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a987f0a1f90a48c292ec5f7efee280ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D0maWljP-XBCUZuU.jpg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A database isn’t much more than a set of drawers, really | Photo Credit: <a class="ae ks" href="https://unsplash.com/@jankolar" rel="noopener ugc nofollow" target="_blank">Jan Antonin Kolar</a></figcaption></figure><p id="fe06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">想象一次微积分考试，你必须在脑子里做所有的计算。这在技术上是可能的，但是绝对没有理由这样做。同样的原则也适用于在浏览器中存储内容。</p><p id="bcf8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天，有许多广泛实施的客户端存储技术。我们有cookies、<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" rel="noopener ugc nofollow" target="_blank"> Web存储API </a>和<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> IndexedDB </a>。虽然完全有可能编写一个功能完整的web应用程序而不用担心这些问题，但是您不应该这样做。那么如何使用它们呢？他们每个人都有最适合的用例。</p><h1 id="9d08" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">浏览器存储快速概述</h1><h2 id="801d" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">饼干</h2><p id="b443" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">基本上每个请求都会发送Cookies，它最适用于短数据。cookies的最大优点是服务器可以通过使用<code class="fe mz na nb nc b">Set-Cookie</code>头直接设置它们，不需要JavaScript。对于任何后续请求，客户端将发送一个包含所有先前设置的cookies的<code class="fe mz na nb nc b">Cookie</code>头。这样做的缺点是，大的cookies会严重降低请求速度。这就是接下来两项技术的用武之地。</p><h2 id="0ce1" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">网络存储</h2><p id="5530" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">Web存储API由两个相似的存储组成— <code class="fe mz na nb nc b">localStorage</code>和<code class="fe mz na nb nc b">sessionStorage</code>。它们都有相同的界面，但后者仅在浏览会话处于活动状态时持续。只要有可用内存，前者就会持续存在。这个内存限制既是它最大的优点，也是它最大的缺点。</p><p id="f98c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为这些值不会随每个请求一起发送，所以可以在不影响性能的情况下在其中存储大量数据。然而，“大”是相对的，不同浏览器的存储限制可能会有很大差异。一个好的经验法则是为你的<em class="lp">整个</em>站点存储不超过5 MB。这个限制并不理想，如果你需要存储更多，你可能需要第三个也是最后一个API。</p><h2 id="a0e7" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">索引b</h2><p id="45bd" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">有人可能会说，指数化DB被严重低估了。尽管基本上每个浏览器都支持它，但它远没有其他两个受欢迎。它不像cookies那样随每个请求一起发送，也没有网络存储的任意限制。那么是什么原因呢？</p><p id="b548" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">IndexedDB不太受欢迎的原因是，事实证明，它的使用是绝对痛苦的。您需要手动定义成功和错误处理程序，而不是使用<code class="fe mz na nb nc b">Promises</code>或<code class="fe mz na nb nc b">async/await</code>。许多库都封装了这种功能，但是它们经常是多余的。如果你需要的只是保存和加载数据，你可以自己写所有你需要的东西。</p><h1 id="26fa" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">整齐地包装索引DB</h1><p id="8867" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">虽然有很多方法可以与IndexedDB交互，但我将描述的是我个人的、<strong class="kv io">固执己见的</strong>方法。这段代码适用于一个数据库和一个表，但是应该很容易修改以适应其他用例。在我们开始编写代码之前，让我们快速列出我们需要的需求。</p><p id="fa26" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 1。理想情况下，它是某种我们可以导入和导出的类或对象。</strong></p><p id="c31b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 2。每个“对象”应该只代表一个</strong> <code class="fe mz na nb nc b">database</code> <strong class="kv io">和</strong> <code class="fe mz na nb nc b">table</code> <strong class="kv io">。</strong></p><p id="7722" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 3。很像CRUD API，我们需要读取、保存和删除键值对的方法。</strong></p><p id="2f78" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这似乎很简单。只是一个旁注——我们将在这里使用ES6 <code class="fe mz na nb nc b">class</code>语法，但是你可以随意修改。如果你只对一个文件使用一个类，你甚至不需要使用它。现在让我们开始吧。</p><h2 id="d80f" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">一些样板文件</h2><p id="43d7" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">我们本质上知道我们需要什么方法，所以我们可以剔除这些方法，并确保所有的函数都有意义。这样，就更容易编码和测试(我没有这样做，因为这是一个个人项目，但我真的应该去做)。</p><p id="06bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">嘿，看起来你在一个稍微窄一点的屏幕上。下面的代码块可能看起来不太好，但文章的其余部分应该没问题。如果你想跟上，你可以跳到一个更宽的屏幕上。我哪儿也不去(保证)。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4cf4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，我们设置了一些样板文件，其中包含了我们所有的功能和一个很好的常量配置。<code class="fe mz na nb nc b">_config</code>周围的<code class="fe mz na nb nc b">setter</code>确保配置在任何点都不能改变。这将有助于调试任何错误，并从一开始就防止它们发生。</p><p id="76a9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">样板文件完成后，是时候进入有趣的部分了。让我们看看可以用IndexedDB做些什么。</p><h2 id="e232" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">从数据库中读取</h2><p id="e32d" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">即使IndexedDB不使用<code class="fe mz na nb nc b">Promises</code>，我们也将把所有的函数包装在其中，这样我们就可以异步工作。从某种意义上说，我们将要编写的代码将有助于弥合IndexedDB和更现代的JavaScript编写方式之间的差距。在我们的<code class="fe mz na nb nc b">read</code>函数中，让我们将所有内容包装在一个新的<code class="fe mz na nb nc b">Promise</code>中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4c77" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们从数据库中获得值，我们将使用<code class="fe mz na nb nc b">resolve</code>参数沿着<code class="fe mz na nb nc b">Promise</code>链传递它。这意味着我们可以在代码中的其他地方做类似的事情:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0129" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们已经设置好了，让我们看看我们需要做些什么来打开连接。要打开实际的数据库，我们需要做的就是调用<code class="fe mz na nb nc b">window.indexedDB</code>对象的<code class="fe mz na nb nc b">open</code>方法。我们还需要处理三种不同的情况——如果有错误，如果操作成功，如果我们需要升级。我们现在就把这些剔除掉。到目前为止，我们看到的是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d8e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果<code class="fe mz na nb nc b">open</code>错误出来了，我们可以简单地用一个有用的错误信息<code class="fe mz na nb nc b">reject</code>它:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4304" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于第二个处理程序<code class="fe mz na nb nc b">onupgradeneeded</code>，我们不需要做太多。只有当我们在构造函数中提供的<code class="fe mz na nb nc b">version</code>不存在时，才会调用这个处理程序。如果数据库的版本不存在，就没有什么可读取的。因此，我们所要做的就是中止交易并拒绝<code class="fe mz na nb nc b">Promise</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="95c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就给我们留下了第三个也是最后一个处理程序，用于成功状态。这是我们真正阅读的地方。我在前面的处理程序中忽略了事务，但是现在值得花时间回顾一下。因为IndexedDB是一个NoSQL数据库，所以读写是在<strong class="kv io">事务</strong>中执行的。这些只是对数据库执行的不同操作的记录，可以用不同的方式还原或重新排序。当我们中止上面的事务时，我们所做的只是告诉计算机取消任何未决的更改。</p><p id="88c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们已经有了数据库，我们需要对我们的事务做更多的工作。首先，让我们获得实际的数据库:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0db9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们有了数据库，我们可以连续地获得事务和商店。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8e13" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一行创建了一个新事务，并声明了它的<em class="lp">范围</em>。也就是说，它告诉数据库它将只处理一个存储或表。第二个获取存储并将其赋给一个变量。</p><p id="c164" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这个变量，我们终于可以完成我们的目标了。我们可以调用该商店的<code class="fe mz na nb nc b">get</code>方法来获取与键相关联的值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3b6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们就快结束了。剩下要做的就是处理错误和成功处理程序。需要注意的一件重要事情是，我们正在检查实际结果是否存在。如果没有，我们也会抛出一个错误:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c1f8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">完成后，下面是我们的<code class="fe mz na nb nc b">read</code>函数的全部内容:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="f1ad" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">从数据库中删除</h2><p id="adc5" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated"><code class="fe mz na nb nc b">delete</code>功能经历了许多相同的步骤。这是整个函数:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3161" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您会注意到这里有两个不同之处。首先，我们在<code class="fe mz na nb nc b">objectStore</code>上调用<code class="fe mz na nb nc b">delete</code>。其次，成功处理程序会立即解决问题。除了这两个，代码基本上是相同的。第三个也是最后一个函数也是如此。</p><h2 id="b10d" class="mi lr in bd ls mj mk dn lw ml mm dp ma lc mn mo mc lg mp mq me lk mr ms mg mt bi translated">保存到数据库</h2><p id="735f" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">同样，因为它是如此的相似，这里是<code class="fe mz na nb nc b">save</code>函数的全部:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="96b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有三点不同。首先是需要填写<code class="fe mz na nb nc b">onupgradeneeded</code>处理程序。这很有意义，因为应该支持在新版本的数据库中设置值。在这里，我们简单地使用恰当命名的<code class="fe mz na nb nc b">createObjectStore</code>方法创建了<code class="fe mz na nb nc b">objectStore</code>。第二个区别是我们使用了<code class="fe mz na nb nc b">objectStore</code>的<code class="fe mz na nb nc b">put</code>方法来保存值，而不是读取或删除它。最后一个区别是，与<code class="fe mz na nb nc b">delete</code>方法一样，成功处理程序会立即解析。</p><p id="786a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">完成所有这些后，下面是所有这些看起来的样子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ec9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要使用它，您只需创建一个新的<code class="fe mz na nb nc b">DB</code>对象并调用指定的方法。例如:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="177e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">一些收尾工作</h1><p id="b256" class="pw-post-body-paragraph kt ku in kv b kw mu jo ky kz mv jr lb lc mw le lf lg mx li lj lk my lm ln lo ig bi translated">如果您想在另一个文件中使用它，只需在末尾添加一个导出语句:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7730" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，在新脚本中导入它(确保一切都支持模块)，并将其命名为:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f459" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，按原样使用。</p><p id="a504" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一如既往，别忘了关注我，获取更多类似这样的内容。我目前正在写关于<a class="ae ks" href="https://shaile.sh/devto" rel="noopener ugc nofollow" target="_blank">开发到</a>和<a class="ae ks" href="https://shaile.sh/medium" rel="noopener ugc nofollow" target="_blank">介质</a>的文章，非常感谢您对这两个平台的支持。我还建立了一个会员资格，在那里你可以获得文章的预览，并独家访问一大堆资源。此外，如果你特别喜欢这篇文章，可以考虑请我喝杯咖啡来支持我。下次见！</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="5c30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">原载于</em><a class="ae ks" href="https://shaile.sh/codes/posts/2021/01/21/storing-files-indexed-db/" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://shaile . sh</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>