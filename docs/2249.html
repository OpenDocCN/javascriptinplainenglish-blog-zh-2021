<html>
<head>
<title>Use Nginx as a Reverse Proxy for Containerized Node.js Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx作为容器化Node.js微服务的反向代理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-nginx-as-a-reverse-proxy-for-containerized-node-js-microservices-e7c4800f05a1?source=collection_archive---------2-----------------------#2021-05-11">https://javascript.plainenglish.io/using-nginx-as-a-reverse-proxy-for-containerized-node-js-microservices-e7c4800f05a1?source=collection_archive---------2-----------------------#2021-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/435c937afabe7aca339267bf42dbb5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jqdUMi76msZG3dK21iyhw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Architechture for this mockup</figcaption></figure><p id="99d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">今天，我将讨论如何使用Node.js、Nginx、Docker和Angular快速设置微服务架构(你可以使用任何客户端框架/库，如React.js、Vue.js，但出于简单起见，我选择了Angular)。</p><p id="fb52" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是我们今天要做的事情的简要总结:</p><ul class=""><li id="634d" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">设置2个基本的express.js服务器，公开非常基本的端点</li><li id="56ff" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">为这些服务器设置nginx配置(这里的每个服务器指的是一个微服务)</li><li id="fa77" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">对这些服务器进行docker化，包括将nginx web服务器设置为docker容器，并通过docker-compose运行整个工作负载</li><li id="2cd0" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">在postman中测试我们的端点</li><li id="676a" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">设置一个Angular客户端并将其归档</li><li id="d72c" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">修改Nginx配置以包含客户端的配置</li></ul><p id="e68e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是在开始之前，有人可能会问，什么是反向代理，我们为什么需要它？</p><p id="bdf7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="ll"/><strong class="kb io"><em class="ll">反向代理</em> </strong> <em class="ll">服务器是一种</em> <strong class="kb io"> <em class="ll">代理</em> </strong> <em class="ll">服务器，通常位于专用网络中的防火墙之后，并将客户端请求定向到适当的后端服务器。</em></p><p id="f70b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简单来说，当我们建立微服务架构时，我们希望我们的客户端请求根据路由模式转发到相关的微服务。例如，形式为<strong class="kb io"> /auth/ </strong>的请求应该被路由到<strong class="kb io">认证微服务</strong>。类似地，表单/ <strong class="kb io">支付/ </strong>的请求应该被转发到<strong class="kb io">支付微服务</strong>等等。因此，通常情况下，根据您使用的技术体系，您有许多选项来设置它。比如说-</p><ol class=""><li id="a934" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lm ld le lf bi translated">如果你正在使用SpringBoot，你可以使用<strong class="kb io">网飞尤里卡</strong>作为<strong class="kb io">服务发现</strong>以及<strong class="kb io"> Spring云网关</strong>来转发你的请求(然后根据你的需求将这些微服务部署为docker容器或kubernetes pods)。</li><li id="9489" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lm ld le lf bi translated">如果你正在实现一个无服务器架构(比如在AWS上)，你可以使用<strong class="kb io"> AWS服务网格</strong>和<strong class="kb io">服务发现</strong>。</li><li id="b241" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lm ld le lf bi translated">如果您使用的是<strong class="kb io"> Node.js </strong>，您可以使用<strong class="kb io"> Nginx </strong>设置一个负载平衡器和revevrse代理——这就是我们将在本文中做的事情。请注意:</li></ol><blockquote class="ln lo lp"><p id="847b" class="jz ka ll kb b kc kd ke kf kg kh ki kj lq kl km kn lr kp kq kr ls kt ku kv kw ig bi translated">上面提到的方法是一些健壮的方法，我从我的经验中知道它们被用在几个生产系统中。当然，它们不是设置网关/负载平衡器/反向代理的唯一方法。您可以在网上随意探索或寻找适合您的用例的服务。</p></blockquote><p id="db19" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以事不宜迟，让我们开始第一步:设置两个基本的express.js服务器。</p><p id="8696" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，只需启动您的终端并键入:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="fe0c" class="mc md in ly b gy me mf l mg mh">npm init -y</span></pre><p id="50a4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来安装express.js和cors包(需要cors，因为我们最终将从Angular应用程序发出请求),命令如下:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="abc6" class="mc md in ly b gy me mf l mg mh">npm i --save express cors</span></pre><p id="97dd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你可以在本文末尾分享的GitHub repo中查找确切的文件夹结构。我建议您在阅读本文时仔细阅读资源库，这样会更有意义，因为我不会在这里深入研究编码部分。</p><p id="f95a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请注意，我们将在文件夹server1(代表我们的第一个微服务)和server2(代表我们的第二个微服务)中运行上述命令两次。我们还将在这些微服务中设置一些基本的'<em class="ll"> get' </em>路线。</p><p id="f408" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些可以是你想尝试的任何有特色的信息。请根据您自己的要求随意设置。设置这两个微服务后，第一个微服务的app.js文件如下所示:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="048b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">类似地，第二个微服务的app.js如下所示:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a9e6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如你所见，这里没什么特别的。只有两个简单的服务器，响应消息略有不同。</p><p id="7849" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们将在项目根目录下创建一个名为<strong class="kb io"> nginx </strong>的新文件夹，并在其中创建一个名为<strong class="kb io"> default.conf </strong>的文件。</p><p id="1369" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个文件应该包含我们微服务的所有负载平衡和反向代理配置。配置文件如下所示:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0180" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">以上所有配置都是非常基本的，你可以在官网<a class="ae mk" href="https://docs.nginx.com/nginx/admin-guide/web-server/web-server/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ll">这里</em> </strong> </a>找到关于具体语句(或术语)的细节。请注意，这里我们只是配置“反向代理”部分，并没有明确设置任何负载平衡。我故意留下它是因为-</p><ul class=""><li id="d668" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">设置很简单，只需对上面的配置稍加修改。</li><li id="83e2" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">在部署我们的容器(尤其是docker/kubernetes容器)时，有几种其他方法可以设置负载平衡器，比如云负载平衡器。</li></ul><p id="3feb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，除了docker文件，我们已经完成了后端的配置。</p><p id="425d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们很快就把他们安置好。您必须将docker文件放在服务器(或微服务)各自的文件夹中，并将docker-compose.yml文件放在项目根目录中。</p><p id="0e40" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最终的文件夹结构如下所示(暂时忽略客户端文件夹):</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/b2e3dadc7969eb38467e55b0db5568ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROWVFIfJFCMnsbZzHik09Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Project folder structure</figcaption></figure><p id="1acc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">以下是server1和server2的docker文件以及docker-compose文件。</p><p id="4394" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">服务器1的Dockerfile:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="070a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">服务器2的Dockerfile:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d808" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">docker-撰写文件:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3232" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如你所见，这里没有什么新奇/复杂的事情发生。非常基本的东西——如果你了解docker和容器的基础知识，你应该一眼就能理解这些文件。现在我们已经设置了文件，我们可以通过在项目根目录下运行以下命令来将服务器作为容器运行:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3dde" class="mc md in ly b gy me mf l mg mh">docker-compose up --build -d</span></pre><p id="3389" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个命令提取图像并触发我们的容器。这可能需要一点时间，取决于您的网络带宽。但是一旦完成，你就可以通过输入<code class="fe mm mn mo ly b">docker container ls</code>或<code class="fe mm mn mo ly b">docker ps</code>看到你的容器在运行</p><p id="ef9b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">说到这里，我们打开Postman，测试一下我们的端点。</p><p id="671a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，根据我们的反向代理配置，我们应该能够点击<strong class="kb io">http://localhost:8080/server 1/app</strong>和<strong class="kb io">http://localhost:8080/server 2/app</strong>(注意，我们只是根据服务器名称更改了url，而基本URL保持不变)来从我们的两个服务器获得响应。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/b6d155910813d67123c29b5f236b70a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xy9V2yZ9KefHiFNRiqG__Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Response from server1</figcaption></figure><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/1a4a2b19776993460c51c9ab155fd6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZcfjwqPWPdJqmvwPQmyRA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Response from server2</figcaption></figure><p id="b18c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">耶！我们正在从我们的服务器得到回应，你知道吗？重物完成了！</p><p id="f8d6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们必须配置一个客户端(实际上它可以是任何客户端)。我个人的偏好是Angular，但是根据你的选择和需求，你可以有任何其他的库/框架。</p><p id="0a1e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">概念保持不变。但是如果您选择Angular，请随意浏览存储库，看看我都做了些什么(实际上没有什么……我只是从服务器获取响应，并在不同的组件中显示它们……就这样)。在本文中，我有意跳过这一部分，这样就不会太冗长。</p><p id="3b5a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">不过，我将为客户端共享更新后的default.conf文件、docker-compose文件和Dockerfile。</p><p id="b2b7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是客户的docker文件:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="33ea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里唯一棘手的部分是最后一行，即<code class="fe mm mn mo ly b">ng serve --prod --host 0.0.0.0</code>，它特定于Angular，以使客户端容器可以从任何网络访问(在我们的例子中，它帮助从浏览器访问客户端)。如果您使用不同的框架，您可以探索访问客户端的方法。</p><p id="1e35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">更新后的default.conf文件为:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c8be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最终的docker-compose.yml文件是:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ccd5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这就是我们的设置。一旦包含了所有这些内容，就可以再次运行docker-compose up命令来启动所有容器。在我的例子中，来自客户端(和正在运行的客户端)的响应如下所示:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/8a6568cac85031680683f479ebe3985c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StkdAX2tmXa007Xfv5zHiw.png"/></div></div></figure><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/98d2ae71a18ed6ea9739711de9dec554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ywn_hxRHFXQusNgsfSib7Q.png"/></div></div></figure><h2 id="1d8a" class="mc md in bd mp mq mr dn ms mt mu dp mv kk mw mx my ko mz na nb ks nc nd ne nf bi translated"><strong class="ak">2022年6月26日更新:</strong></h2><p id="27e3" class="pw-post-body-paragraph jz ka in kb b kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw ig bi translated">我已经更新了github repo，以包含kubernetes以及所有微服务和入口控制器的部署。您可以在“<strong class="kb io"> k8s </strong>”分支中找到这些文件。我只有在minikube上运行微服务的设置。然而，在不同的云服务提供商如AWS/GCP/Azure上运行的实现会有所不同。我让读者去探索。</p><h2 id="686e" class="mc md in bd mp mq mr dn ms mt mu dp mv kk mw mx my ko mz na nb ks nc nd ne nf bi translated"><strong class="ak">2022年12月26日更新:</strong></h2><p id="04e4" class="pw-post-body-paragraph jz ka in kb b kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw ig bi translated">修改了nginx的default.conf文件。只是去掉了一些不必要的头。希望这对你有帮助。</p><h2 id="d16b" class="mc md in bd mp mq mr dn ms mt mu dp mv kk mw mx my ko mz na nb ks nc nd ne nf bi translated">结论</h2><p id="2c21" class="pw-post-body-paragraph jz ka in kb b kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw ig bi translated">这就是所有的人。</p><p id="86e8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你看nginx和docker是如何让一个开发者的生活变得如此轻松的！您可以在此处查看GitHub repo:</p><div class="nl nm gp gr nn no"><a href="https://github.com/lakshyajit165/nginx_reverse_proxy" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">lakshyajit 165/nginx _ reverse _ proxy</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">在GitHub上创建一个帐户，为lakshyajit 165/nginx _ reverse _ proxy开发做贡献。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jt no"/></div></div></a></div><p id="ed43" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">干杯！</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><h2 id="8d59" class="mc md in bd mp mq mr dn ms mt mu dp mv kk mw mx my ko mz na nb ks nc nd ne nf bi translated">进一步阅读</h2><div class="nl nm gp gr nn no"><a href="https://bit.cloud/blog/component-driven-microservices-with-nodejs-and-bit-l64shurc" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">具有NodeJS和Bit的组件驱动的微服务</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">大多数人认为组件是前端的一部分。然而，CBSE(基于组件的软件工程)是…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">比特云</p></div></div><div class="nx l"><div class="ok l nz oa ob nx oc jt no"/></div></div></a></div></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><p id="956f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="ll">更多内容请看</em><a class="ae mk" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ll">plain English . io</em></strong></a><em class="ll">。报名参加我们的</em> <a class="ae mk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ll">免费周报</em> </strong> </a> <em class="ll">。关注我们关于</em><a class="ae mk" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ll">Twitter</em></strong></a><a class="ae mk" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ll">LinkedIn</em></strong></a><em class="ll"/><a class="ae mk" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ll">YouTube</em></strong></a><em class="ll"/><a class="ae mk" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ll">不和</em> </strong> </a> <em class="ll">。对增长黑客感兴趣？检查</em> <a class="ae mk" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="ll">电路</em> </strong> </a> <em class="ll">。</em></p></div></div>    
</body>
</html>