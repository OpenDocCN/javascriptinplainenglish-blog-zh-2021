<html>
<head>
<title>Husky + Lint-Staged on a React TypeScript Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈斯基+林特-在一个反应型脚本项目中上演</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/husky-lint-staged-on-a-react-typescript-project-automate-validation-before-submitting-your-code-8d388e63be70?source=collection_archive---------0-----------------------#2021-02-25">https://javascript.plainenglish.io/husky-lint-staged-on-a-react-typescript-project-automate-validation-before-submitting-your-code-8d388e63be70?source=collection_archive---------0-----------------------#2021-02-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="79d3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">提交代码前自动验证</h2></div><h1 id="2f80" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">介绍</h1><p id="bcea" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">即使您设置了保证某些代码质量的工具，也有可能在推送代码之前忘记执行它们。</p><p id="c662" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">为了自动化和解决这个问题，<a class="ae lv" href="https://www.npmjs.com/package/husky" rel="noopener ugc nofollow" target="_blank">哈士奇</a> + <a class="ae lv" href="https://www.npmjs.com/package/lint-staged" rel="noopener ugc nofollow" target="_blank"> Lint-Staged </a>包帮助您防止提交不遵循某些预定义规则的代码(即:单元测试验证、代码约定验证、代码格式化等)。</p><p id="2d97" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在本文中，我将向您介绍哈士奇、Lint-Staged以及如何在React TypeScript项目中使用这些包。</p><h1 id="a64f" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">先决条件</h1><p id="f2ec" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> Node.js </strong>:需要安装节点版本&gt; = 10。所以，如果你没有，请去NodeJS网站，下载并安装在你的本地机器上。(<a class="ae lv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/</a>)</p><p id="0536" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io"> Git </strong>:您需要安装Git版本&gt; = 2.13.0。所以，如果你没有，请去Git网站，下载并安装在你的本地机器上。(<a class="ae lv" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/downloads</a>)</p><h1 id="c730" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">第一步。用Git启动一个反应型脚本项目</h1><p id="5fea" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">以下命令将在文件夹<em class="lw"> my-app </em>内创建一个项目。<br/>在终端，运行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2ffe" class="mg kd in mc b gy mh mi l mj mk">npx create-react-app my-app --template typescript</span></pre><p id="cbd8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在项目文件夹中，启动git:</p><p id="2f40" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在终端上，运行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a54c" class="mg kd in mc b gy mh mi l mj mk">git init</span></pre><p id="2ae1" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="lw">注意:出于本教程的目的，您不需要指向存储库，但是如果您愿意，您可以使用以下命令进行操作:</em></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3088" class="mg kd in mc b gy mh mi l mj mk">git remote add origin &lt;your_existing_repository_cloning_url&gt;</span></pre><h1 id="4e3c" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">第二步。设置“哈士奇”套餐</h1><h2 id="0917" class="mg kd in bd ke ml mm dn ki mn mo dp km ld mp mq ko lh mr ms kq ll mt mu ks mv bi translated">安装:</h2><p id="023e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们将使用<a class="ae lv" href="https://github.com/typicode/husky/tree/master" rel="noopener ugc nofollow" target="_blank">哈士奇版本4 </a>。已经有了<a class="ae lv" href="https://dev.to/typicode/what-s-new-in-husky-5-32g5" rel="noopener ugc nofollow" target="_blank">更新版本</a>，但仅针对开源项目，或者如果您是哈斯基在<a class="ae lv" href="https://github.com/sponsors/typicode" rel="noopener ugc nofollow" target="_blank"> GitHub赞助商</a>或<a class="ae lv" href="https://opencollective.com/husky" rel="noopener ugc nofollow" target="_blank">Open collection</a>的赞助商。</p><p id="e64c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在终端上，运行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="43f0" class="mg kd in mc b gy mh mi l mj mk">npm install husky@4 --save-dev</span></pre><h2 id="0d1f" class="mg kd in bd ke ml mm dn ki mn mo dp km ld mp mq ko lh mr ms kq ll mt mu ks mv bi translated">Husky配置文件</h2><p id="fe98" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">创建一个“<em class="lw"> .huskyrc.json </em>”文件，并将其清空(我们将在前面对其进行配置)。</p><p id="1c44" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在这个文件中，我们可以定义任何<a class="ae lv" href="https://git-scm.com/docs/githooks#_hooks" rel="noopener ugc nofollow" target="_blank"> Git钩子</a>。</p><p id="aaea" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io"> <em class="lw">什么是饭桶挂钩？</em> </strong> <em class="lw"> Git挂钩是在给定的Git事件发生时可以执行的动作。即:当开发人员提交或推送一些代码时，运行所有的单元测试，如果所有测试都通过了，就完成提交/推送。</em></p><h1 id="a981" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">设置为仅在所有单元测试都通过时提交</h1><p id="6eaa" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了在提交之前触发一些动作，我们将使用名为<em class="lw">“pre-commit”</em>的Git钩子。</p><p id="a349" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在让我们创建一个动作来执行我们的'<em class="lw"> test </em>'命令脚本(在我们的'<em class="lw"> package.json </em>文件中声明)。设置这个动作的主要目的是<strong class="kw io">阻止用户提交代码，如果某些测试失败</strong>。</p><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/047a1540cbf097a90c5c9a479455ded9.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/0*mqnmz_vQ_EEEbr4J"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">command scripts on “package.json” file</figcaption></figure><p id="f0b7" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">所以，在<strong class="kw io"><em class="lw">. husk yrc . JSON</em></strong>文件里面:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ea78" class="mg kd in mc b gy mh mi l mj mk">{<br/>  "hooks": {<br/>     "pre-commit": "npm run test -- --watchAll=false"<br/>  }<br/>}</span></pre><p id="a082" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="lw">注意:如你所见，Husky配置文件可以使用“package.json”上的任何脚本，只需使用</em> <code class="fe ne nf ng mc b">npm run</code> <em class="lw">调用即可。</em></p><p id="f405" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="lw">但是等等……什么是</em> <code class="fe ne nf ng mc b"><em class="lw">-- --watchAll=false</em></code> <em class="lw">？</em></p><p id="a595" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">第一个双破折号“-”告诉我们的npm命令，我们将把参数传递给它(查看更多信息:<a class="ae lv" href="https://stackoverflow.com/questions/44743626/whats-mean-of-npm-scripts-two-dahses" rel="noopener ugc nofollow" target="_blank">NPM脚本的双破折号是什么意思？</a>)。</p><p id="0565" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">命令选项“- watchAll=false”是因为当执行“测试”脚本时，React将启动一个观察模式菜单，因此您可以选择是否要运行所有文件、特定文件、仅修改的文件等。在我们的例子中，我们不希望它问任何问题，而只是运行所有的测试。因此，我们通过添加'- watchAll=false '来关闭这种监视模式。</p><p id="a195" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在，让我们用我们全新的哈士奇配置来试试吧！</p><p id="ab27" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在提交我们的代码之前，让我们测试一下我们的命令:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0255" class="mg kd in mc b gy mh mi l mj mk">npm run test -- --watchAll=false</span></pre><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9adab0a88e5da8d709cedacacad77848.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/0*Xe7CbN8Pmx-y9_Sc"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">unit test running successfully</figcaption></figure><p id="30b8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">命令有效！太好了！因此，由于我们新的Husky配置，如果我们提交，测试应该在提交之前运行，对吗？让我们检查一下！</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="db47" class="mg kd in mc b gy mh mi l mj mk">git commit -am "I hope the test run before this commit!"</span></pre><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/5541d77c70fcd27893ad6c4a71fa9603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NhQtl5L_HOsRIbda"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">result: test ran before committing</figcaption></figure><p id="96bf" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">酷！有用！</p><p id="a60a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在，让我们看看<strong class="kw io">如果测试失败会发生什么</strong>？</p><p id="699c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">首先，用下面的Git代码撤销提交:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="90fb" class="mg kd in mc b gy mh mi l mj mk">git reset HEAD^ </span></pre><p id="ae85" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">(在这里查看更多信息:<a class="ae lv" href="https://stackoverflow.com/questions/15772134/can-i-delete-a-git-commit-but-keep-the-changes" rel="noopener ugc nofollow" target="_blank">我可以删除git提交但保留更改吗？</a>)</p><p id="3856" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在我们需要强制项目的单元测试失败。</p><p id="285b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">如果我们分析单元测试文件<strong class="kw io"><em class="lw">app . test . tsx</em></strong><em class="lw">。</em>期望<strong class="kw io"> <em class="lw"> App.tsx </em> </strong>文件呈现带有“Learn React”文本的元素。</p><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e66718362ab35d005bb52427b6b61864.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*cEGdz15cgiGl3kKf"/></div></figure><p id="5422" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">为了迫使它失败，让我们修改我们的<strong class="kw io"> <em class="lw"> App.tsx </em> </strong>文件来呈现另一个文本。</p><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div class="gh gi no"><img src="../Images/87ca71b96931cb546d209eeafc587c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*hzW-X5LpjTPefAO6"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Modifying ‘App.tsx’ file</figcaption></figure><p id="f713" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">让我们再运行一次，看看测试是否会失败:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="234a" class="mg kd in mc b gy mh mi l mj mk">npm run test -- --watchAll=false</span></pre><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi np"><img src="../Images/79e1b92e032ae55a1d52a83041e8153b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-ue70f6sjmZ98SN5"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">result: test fails</figcaption></figure><p id="ccb4" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">耶！现在让我们提交，看看会发生什么:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a303" class="mg kd in mc b gy mh mi l mj mk">git commit -am "I hope this commit will be blocked"</span></pre><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nq"><img src="../Images/8fff6927da32cf9ce33d6b621cbf67cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4M4Da2tI1KBqs5st"/></div></div></figure><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f564f6cb8902db4597daa22fc0fb1261.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/0*UOADwWQ9nG7ncWO_"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">husky response: pre-commit hook failed</figcaption></figure><p id="af77" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">看到了吗？由于测试失败，提交被阻止！很酷，对吧？</p><h1 id="98a6" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">设置仅在ESLint验证规则通过时提交</h1><p id="1b4c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们基于ReactJS项目提供的默认ESLint配置来设置一个新的操作。</p><p id="df63" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">首先，让我们在整个项目中运行ESLint，看看会发生什么:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9875" class="mg kd in mc b gy mh mi l mj mk">npx eslint .</span></pre><p id="c4e2" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">通过运行这个命令，您将看到什么也没有发生，因此这意味着整个项目的代码已经遵循了React提供的ESLint代码规则。</p><p id="e723" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="lw">注意:默认情况下，只有当违反的规则被设置为“</em>错误<em class="lw">”时，ESLint才会抛出错误。如果你还想抛出“</em>警告<em class="lw">规则违反，你可以添加“</em> - max-warnings=0 <em class="lw">”命令选项。</em></p><p id="919b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">示例:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="adcf" class="mg kd in mc b gy mh mi l mj mk">eslint . --max-warnings=0</span></pre><p id="b369" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在，让我们将我们的<strong class="kw io"> <em class="lw"> .huskyrc.json </em> </strong>文件改为使用ESLint命令:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6aaa" class="mg kd in mc b gy mh mi l mj mk">{<br/>"hooks": {<br/> "pre-commit": "eslint ."<br/> }<br/>}</span></pre><p id="6d2c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">配置完成了！</p><p id="e455" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">仅仅出于<strong class="kw io">教学目的</strong>(因此我们可以看到提交被ESLint代码规则阻止)让我们强制ESLint在某个规则上抛出一个错误，并插入一个违反该规则的代码。</p><p id="b438" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">ESLint配置设置在<strong class="kw io"> <em class="lw"> package.json </em> </strong>文件上。<br/>在json <code class="fe ne nf ng mc b">“<em class="lw">eslintConfig</em>”</code>部分，添加以下代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="73bb" class="mg kd in mc b gy mh mi l mj mk">"rules": {<br/> "@typescript-eslint/no-unused-vars": "error"<br/>}</span></pre><p id="63ec" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="lw">注意:这条规则与未使用的变量有关，所以如果某个变量在代码中声明但未使用，ESLint将抛出一个错误。</em></p><p id="307e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我们的“package.json”中的结果是:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7cbf" class="mg kd in mc b gy mh mi l mj mk">...<br/>"eslintConfig":{<br/>  "extends": [<br/>    "react-app",<br/>    "react-app/jest"<br/>  ],<br/>  "rules": {<br/>    "@typescript-eslint/no-unused-vars": "error"<br/>  }<br/>},<br/>...</span></pre><p id="87d0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在，为了强制ESLint错误，让我们声明一个变量"<em class="lw"> unusedVar </em>"并且不要在任何地方使用它。</p><p id="09cf" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">关于<strong class="kw io"> <em class="lw"> App.tsx </em> </strong>文件:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bb9b" class="mg kd in mc b gy mh mi l mj mk">...<br/>const unusedVar = "";</span><span id="91ed" class="mg kd in mc b gy ns mi l mj mk">function App() {<br/>  return (<br/>...</span></pre><p id="6e40" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">因此，让我们再次运行我们的<em class="lw"> eslint </em>命令，看看是否会抛出一个错误:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0d8c" class="mg kd in mc b gy mh mi l mj mk">npx eslint .</span></pre><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nt"><img src="../Images/ea457e78c9c1c3914c297141a26f5829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6AU2bH-8B83qsYci"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">eslint point out a code violation</figcaption></figure><p id="1254" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">让我们看看当我们尝试提交代码时会发生什么:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="af02" class="mg kd in mc b gy mh mi l mj mk">git commit -am "I hope this commit will be blocked"</span></pre><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nu"><img src="../Images/6915b6826e266342210c90bbd53638cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pYDxTxrenG-8U0_Q"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">husky response: pre-commit hook failed</figcaption></figure><p id="a72e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">看到了吗？提交被阻止，因为没有应用ESLint规则！酷！</p><h1 id="f6f6" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">ESLint自动修复和Husky问题</h1><p id="ada0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">最后的解决方案是那种<strong class="kw io">不完整的</strong>。但是为什么呢？</p><p id="5282" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">ESLint和许多其他软件包一样，可以自动修复不遵循一些基本规则的代码(例如，添加或删除分号“；”在行尾)。所以，想象一下这样一种情况，所有阻碍我们提交的坏代码都可以被ESLint用它的auto-fix ' - fix '命令选项自动修复。</p><p id="6728" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">嗯，所以我们只需要将它添加到我们的Husky配置文件中，对于这些情况，提交将与所有修复的代码一起发送，对吗？</p><p id="5bba" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">可惜没有。</p><p id="4a74" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">哈士奇无法执行所有这些动作:<br/> <em class="lw">(至少没有简单的方法做到)</em></p><ul class=""><li id="09b1" class="nv nw in kw b kx lq la lr ld nx lh ny ll nz lp oa ob oc od bi translated">修复代码</li><li id="39df" class="nv nw in kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">检查是否解决了所有问题</li><li id="3fd3" class="nv nw in kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">将固定代码添加到暂存</li><li id="34b0" class="nv nw in kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">提交代码。</li></ul><p id="4cd8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">幸运的是，我们有一个名为'<em class="lw"> lint-staged </em>的npm包可以帮我们做到这一点！让我们看看它是如何工作的。</p><h1 id="ca27" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">第三步。设置“lint暂存”程序包</h1><p id="2206" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Lint对由Git<strong class="kw io">暂存</strong>的<strong class="kw io">文件</strong>执行运行操作(换句话说。准备好提交的文件)。</p><h2 id="0803" class="mg kd in bd ke ml mm dn ki mn mo dp km ld mp mq ko lh mr ms kq ll mt mu ks mv bi translated">装置</h2><p id="a903" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在终端上，运行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1e32" class="mg kd in mc b gy mh mi l mj mk">npm install lint-staged --save-dev</span></pre><h2 id="7726" class="mg kd in bd ke ml mm dn ki mn mo dp km ld mp mq ko lh mr ms kq ll mt mu ks mv bi translated">Lint暂存配置文件</h2><p id="02c4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">创建一个<strong class="kw io"> .lintstagedrc.json </strong>文件，暂时让它为空(我们将提前配置它)。</p><p id="8ecc" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">该文件将包含仅在暂存文件上执行<strong class="kw io">的脚本。如果脚本没有抛出任何错误，则该操作所做的所有更改都会保存到暂存文件中。</strong></p><h1 id="b552" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">使用ESLint自动修复和Lint暂存:问题已解决！</h1><p id="62c9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在已经安装了Lint-Staged，让我们解决Husky的限制，并配置我们的ESLint在Staged文件上运行它的auto-fix命令。<br/>在'<strong class="kw io"><em class="lw">lintstagedrc . JSON</em></strong>上，添加以下内容:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="68ee" class="mg kd in mc b gy mh mi l mj mk">{<br/>"src/**/*.{js,ts,jsx,tsx}": [<br/>  "eslint --fix"<br/>  ]<br/>}</span></pre><p id="8687" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="lw">注意:你也可以使用</em>package . JSON上的任何脚本，只需使用<code class="fe ne nf ng mc b">npm run</code>调用它。</p><p id="8c74" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">让我解释一下这个文件的内容:</p><ul class=""><li id="eb86" class="nv nw in kw b kx lq la lr ld nx lh ny ll nz lp oa ob oc od bi translated">"<em class="lw"> src/**/*。{js，ts，jsx，tsx} </em>"告诉lint-staged将只对“src/”目录中的文件运行某些操作，并且只对那些具有<em class="lw">的文件。js '，'。ts '，'。jsx' </em>或<em class="lw">'。tsx' </em>扩展名文件。</li><li id="f454" class="nv nw in kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">动作是“<em class="lw"> eslint - fix </em>”，它执行eslint规则检查，并对代码进行自动修复。</li></ul><p id="822f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">最后，Husky现在需要调用lint-staged作为一个动作，来激活我们的<strong class="kw io"><em class="lw">. lintstagedrc . JSON</em></strong>文件配置。</p><p id="a248" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">关于<strong class="kw io"><em class="lw">. husky RC . JSON</em></strong>文件:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4080" class="mg kd in mc b gy mh mi l mj mk">{<br/>"hooks": {<br/>  "pre-commit": "lint-staged"<br/>  }<br/>}</span></pre><p id="09cd" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">理解场景:</p><ol class=""><li id="dd27" class="nv nw in kw b kx lq la lr ld nx lh ny ll nz lp oj ob oc od bi translated">当我们提交时，Husky将调用Lint-Staged。</li><li id="78b5" class="nv nw in kw b kx oe la of ld og lh oh ll oi lp oj ob oc od bi translated">Lint-Staged仅查找已转移的文件，并选择那些位于“src/”目录中并具有其中一个<em class="lw">的文件。js '，'。jsx '，'。ts '，'。tsx' </em>扩展定义。</li><li id="7541" class="nv nw in kw b kx oe la of ld og lh oh ll oi lp oj ob oc od bi translated">Lint-Staged然后将对选定的文件调用“eslint - fix”操作，检查代码规则并在可能的情况下应用自动修复。</li><li id="a38f" class="nv nw in kw b kx oe la of ld og lh oh ll oi lp oj ob oc od bi translated">如果<em class="lw"> eslint </em>成功，提交将完成，否则将被阻塞。</li></ol><p id="875e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在我们的例子中，我们预计会被阻塞，因为我们的代码中有一个未使用的变量，而ESLint本身无法自动修复这个代码冲突。</p><p id="d9b4" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">让我们看看我们新的Husky + Lint分阶段配置是否有效:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c107" class="mg kd in mc b gy mh mi l mj mk">git commit -am "I hope this commit will be blocked"</span></pre><figure class="lx ly lz ma gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ok"><img src="../Images/7825bd0ae0ae2a9a702c6e4ba26c0d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KWxg6ktlUNKo9Kqj"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Husky + Lint-Staged execution</figcaption></figure><p id="7e48" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">看到了吗？提交被阻塞是因为<em class="lw"> Husky </em>调用了<em class="lw"> Lint-Staged </em>命令，该命令调用了ESLint规则检查，正如我们所预料的那样，规则“no-unused-vars”被'<em class="lw"> App.tsx </em>'文件中未使用的变量违反了！</p><h2 id="8146" class="mg kd in bd ke ml mm dn ki mn mo dp km ld mp mq ko lh mr ms kq ll mt mu ks mv bi translated">更漂亮的自动修复和Lint-Staged:格式化JSON文件</h2><p id="f227" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果您想自动修复JSON文件，您可以设置Lint-Staged配置文件来对JSON文件运行更漂亮的自动修复格式。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="954c" class="mg kd in mc b gy mh mi l mj mk">{<br/>"src/**/*.{js,ts,jsx,tsx}": [<br/>  "eslint --fix"<br/>],<br/>"*.json": [<br/>  "prettier --write"<br/>]<br/>}</span></pre><h1 id="ba45" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">有用的提示</h1><p id="6d5d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们完成了！但是让我给你一些非常有用的提示！</p><h2 id="4a11" class="mg kd in bd ke ml mm dn ki mn mo dp km ld mp mq ko lh mr ms kq ll mt mu ks mv bi translated">通过“package.json”文件组织所有脚本</h2><p id="e178" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们已经知道“<em class="lw"> .huskyrc.json </em>”和“<em class="lw"> .lintstagedrc.json </em>”也接受使用在“<em class="lw"> package.json </em>文件上定义的脚本的动作。</p><p id="aeb9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">为了更好地组织您的项目，在"<em class="lw"> package.json </em>"文件中声明所有脚本，并在"<em class="lw"> .huskyrc.json </em>"和"<em class="lw"> .lintstagedrc.json </em>"中使用。</p><p id="6dc8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">示例:</p><p id="e02e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在'<em class="lw"> package.json </em>'上:</p><ul class=""><li id="85e4" class="nv nw in kw b kx lq la lr ld nx lh ny ll nz lp oa ob oc od bi translated">定义“<em class="lw"> lint </em>”脚本</li><li id="cdfb" class="nv nw in kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">定义“<em class="lw">测试:无观察</em>”脚本</li></ul><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="02d4" class="mg kd in mc b gy mh mi l mj mk">...<br/>"scripts": {<br/>...<br/>"test": "react-scripts test",<br/>"test:noWatch":"npm run test -- --watchAll=false",<br/>"lint": “eslint --fix"<br/>...<br/>},<br/>...</span></pre><p id="b0d8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">On ' <em class="lw"> .huskyrc.json' </em>':</p><ul class=""><li id="bf34" class="nv nw in kw b kx lq la lr ld nx lh ny ll nz lp oa ob oc od bi translated">从"<em class="lw"> package.json </em>中调用"<em class="lw"> test:noWatch </em>"脚本</li></ul><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2f75" class="mg kd in mc b gy mh mi l mj mk">{<br/>"hooks": {<br/>  "pre-commit": "npm run test:noWatch &amp;&amp; lint-staged"<br/>}<br/>}</span></pre><p id="6582" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在'<em class="lw"> .lintstagedrc.json </em>'上:</p><ul class=""><li id="0a31" class="nv nw in kw b kx lq la lr ld nx lh ny ll nz lp oa ob oc od bi translated">从"<em class="lw"> package.json </em>中调用"<em class="lw"> lint </em>"脚本</li></ul><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2e08" class="mg kd in mc b gy mh mi l mj mk">{<br/>"src/**/*.{js,ts,jsx,tsx}": [<br/>"npm run lint"<br/>  ]<br/>}</span></pre><h2 id="dcfe" class="mg kd in bd ke ml mm dn ki mn mo dp km ld mp mq ko lh mr ms kq ll mt mu ks mv bi translated">最佳哈士奇配置</h2><p id="5168" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">设置Git钩子"<em class="lw">预提交</em>"和<strong class="kw io">更快的检查</strong>(像林挺)，因为你可能会在推之前提交很多次。</p><p id="e99d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">设置Git钩子"<em class="lw">预推送</em>"和<strong class="kw io">较慢的检查</strong>(像检查单元测试)，因为你推送的次数可能会比提交的次数少。</p><p id="bee6" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">On ' <em class="lw"> .huskyrc.json </em>' ':</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b8a2" class="mg kd in mc b gy mh mi l mj mk">{<br/>"hooks": {<br/>  "pre-commit": "lint-staged",<br/>  "pre-push": "npm run test:noWatch"<br/>  }<br/>}</span></pre><h2 id="2d4f" class="mg kd in bd ke ml mm dn ki mn mo dp km ld mp mq ko lh mr ms kq ll mt mu ks mv bi translated">也在您的CI管道上配置这些验证</h2><p id="b522" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">创建这些策略不会阻止用户提交不符合预期规则的代码，因为即使是Git挂钩“<em class="lw">预提交</em>”和“<em class="lw">预推送</em>”也可以通过“<em class="lw"> - no-verify </em>”命令选项绕过。</p><p id="4073" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">为了保证没有坏代码会到达存储库，我强烈建议您也在CI(持续集成)管道过程中设置验证。但这个主题是另一个时间。</p><h1 id="ba7c" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">谢谢！</h1><p id="2760" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">希望你喜欢！非常感谢您的任何反馈！</p><h1 id="2938" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">参考资料:</h1><div class="ol om gp gr on oo"><a href="https://www.npmjs.com/package/husky" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd io gy z fp ot fr fs ou fu fw im bi translated">强壮的</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">Git挂钩变得简单</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">www.npmjs.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc my oo"/></div></div></a></div><div class="ol om gp gr on oo"><a href="https://www.npmjs.com/package/lint-staged" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd io gy z fp ot fr fs ou fu fw im bi translated">皮棉阶段</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">对暂存的git文件运行linters，不要让💩滑入你的代码库！林挺在运行时更有意义…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">www.npmjs.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc my oo"/></div></div></a></div><div class="ol om gp gr on oo"><a href="https://git-scm.com/docs/githooks#_hooks" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd io gy z fp ot fr fs ou fu fw im bi translated">Git - githooks文档</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">钩子是可以放在钩子目录中的程序，可以在git执行的某些时候触发动作。钩子…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">git-scm.com</p></div></div><div class="ox l"><div class="pe l oz pa pb ox pc my oo"/></div></div></a></div></div></div>    
</body>
</html>