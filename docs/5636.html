<html>
<head>
<title>How to Test for Existence of Nested JavaScript Object Key?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试嵌套JavaScript对象键的存在？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-test-for-existence-of-nested-javascript-object-key-4bc56a96086f?source=collection_archive---------2-----------------------#2021-11-25">https://javascript.plainenglish.io/how-to-test-for-existence-of-nested-javascript-object-key-4bc56a96086f?source=collection_archive---------2-----------------------#2021-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/071442205d3b0fcdfd0a36ab372565ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DnhxdO9Q4CKCi9eZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@contradirony?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Samantha Lam</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="053a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript对象通常嵌套在其他对象中。</p><p id="d8ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它们是动态的。</p><p id="1ae6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可能需要检查对象中是否存在嵌套属性。</p><p id="d35f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何检查一个嵌套属性是否存在于一个对象中。</p><h1 id="a5e3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">编写我们自己的函数</h1><p id="8632" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以编写自己的JavaScript函数来检查对象中是否存在深度嵌套的属性。</p><p id="a76f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="22a0" class="mn lc iq mj b gy mo mp l mq mr">const checkNested = (obj, ...props) =&gt; {<br/>  for (const prop of props) {<br/>    if (!obj || !Object.prototype.hasOwnProperty.call(obj, prop)) {<br/>      return false;<br/>    }<br/>    obj = obj[prop];<br/>  }<br/>  return true;<br/>}</span><span id="4aae" class="mn lc iq mj b gy ms mp l mq mr">const obj = {<br/>  level1: {<br/>    level2: {<br/>      level3: 'level3'<br/>    }<br/>  }<br/>};</span><span id="8e76" class="mn lc iq mj b gy ms mp l mq mr">console.log(checkNested(obj, 'level1', 'level2', 'level3'));<br/>console.log(checkNested(obj, 'level1', 'level2', 'bar'));</span></pre><p id="7817" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">obj</code>参数和<code class="fe mt mu mv mj b">props</code> rest参数创建了<code class="fe mt mu mv mj b">checkNested</code>函数。</p><p id="316f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">obj</code>是我们正在检查的对象。</p><p id="851d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">props</code>有一个属性数组，它构成了我们要寻找的嵌套属性的路径。</p><p id="c3fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在函数中，我们循环通过<code class="fe mt mu mv mj b">props</code>数组来遍历<code class="fe mt mu mv mj b">obj</code>以找到嵌套的属性。</p><p id="0467" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们检查<code class="fe mt mu mv mj b">obj</code>是否为falsy或者<code class="fe mt mu mv mj b">hasOwnProperty</code>是否返回<code class="fe mt mu mv mj b">false</code>。</p><p id="ee69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果其中任何一个是<code class="fe mt mu mv mj b">true</code>，那么我们知道该属性不存在。</p><p id="5e25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们返回<code class="fe mt mu mv mj b">false</code>。</p><p id="7059" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">Object.prototype.hasOwnProperty.call</code>而不是<code class="fe mt mu mv mj b">obj.hasOwnProperty</code>调用<code class="fe mt mu mv mj b">hasOwnProperty</code>，因为<code class="fe mt mu mv mj b">obj.hasOwnProperty</code>可以被覆盖。</p><p id="142d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">call</code>取<code class="fe mt mu mv mj b">hasOwnProperty</code>的<code class="fe mt mu mv mj b">this</code>值。</p><p id="80aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">prop</code>是属性名字符串值。</p><p id="bf3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们通过了<code class="fe mt mu mv mj b">if</code>模块，那么我们将<code class="fe mt mu mv mj b">obj</code>分配给<code class="fe mt mu mv mj b">obj[prop]</code>来更深入地查看。</p><p id="d45b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样做，因为属性是一个对象。</p><p id="1e42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果整个循环迭代成功，那么我们返回<code class="fe mt mu mv mj b">true</code>,因为路径指向我们正在寻找的属性。</p><p id="b938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">obj</code>对象测试这个函数，我们可以看到第一个控制台返回<code class="fe mt mu mv mj b">true</code>。</p><p id="e4cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而第二个果然返回<code class="fe mt mu mv mj b">false</code>。</p><h1 id="32a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">递归检查给定的属性</h1><p id="e5e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们也可以用递归函数来做检查。</p><p id="ba15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="62d8" class="mn lc iq mj b gy mo mp l mq mr">const checkNested = (obj, prop, ...restProps) =&gt; {<br/>  if (obj === undefined) {<br/>    return false;<br/>  }<br/>  if (<br/>    restProps.length === 0 &amp;&amp;<br/>    Object.prototype.hasOwnProperty.call(obj, prop)<br/>  ) {<br/>    return true;<br/>  }<br/>  return checkNested(obj[prop], ...restProps);<br/>};</span><span id="dad7" class="mn lc iq mj b gy ms mp l mq mr">const obj = {<br/>  level1: {<br/>    level2: {<br/>      level3: "level3"<br/>    }<br/>  }<br/>};</span><span id="e4f6" class="mn lc iq mj b gy ms mp l mq mr">console.log(checkNested(obj, "level1", "level2", "level3"));<br/>console.log(checkNested(obj, "level1", "level2", "foo"));</span></pre><p id="e978" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe mt mu mv mj b">checkNested</code>功能和我们之前的那个差不多。</p><p id="6ed8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同之处在于，我们从寻找的路径中获取第一个属性。</p><p id="af3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其余的留在数组中。</p><p id="41e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查<code class="fe mt mu mv mj b">restProp.length</code>是否为0，以及<code class="fe mt mu mv mj b">obj</code>是否具有<code class="fe mt mu mv mj b">prop</code>属性。</p><p id="70aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们都是<code class="fe mt mu mv mj b">true</code>，那么我们返回<code class="fe mt mu mv mj b">true</code>，因为我们遍历了整个路径并找到了属性。</p><p id="9cdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在<code class="fe mt mu mv mj b">restProps</code>中还剩下什么，那么我们调用<code class="fe mt mu mv mj b">checkNested</code>向下钻一层。</p><p id="0876" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该得到和以前一样的结果。</p><h1 id="5dab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可选链接运算符</h1><p id="2849" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">检查嵌套属性路径是否存在的另一种方法是使用可选的链接操作符，它是用<code class="fe mt mu mv mj b">?.</code>添加的。</p><p id="9049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该运算符是ES2020的新功能。</p><p id="ed73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cc79" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  level1: {<br/>    level2: {<br/>      level3: "level3"<br/>    }<br/>  }<br/>};</span><span id="4c37" class="mn lc iq mj b gy ms mp l mq mr">const value1 = obj?.level1?.level2?.level3;<br/>const value2 = obj?.level1?.level2?.foo;<br/>console.log(value1);<br/>console.log(value2);</span></pre><p id="fd34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该看到<code class="fe mt mu mv mj b">value1</code>是<code class="fe mt mu mv mj b">'level3'</code>并且<code class="fe mt mu mv mj b">value2</code>是<code class="fe mt mu mv mj b">undefined</code>，因为如果属性存在，操作符返回属性值，否则返回<code class="fe mt mu mv mj b">undefined</code>。</p><p id="02a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们减少了安全遍历深度嵌套属性所需的工作量。</p><h1 id="243e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e517" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用自己的代码或可选的链接操作符来测试是否存在深度嵌套的JavaScript对象属性。</p><p id="c661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mw">plain English . io</em></a><em class="mw">。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mw">免费周报在这里</em> </a> <em class="mw">。</em></p></div></div>    
</body>
</html>