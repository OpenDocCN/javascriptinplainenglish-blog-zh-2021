<html>
<head>
<title>Save Time by Automated Testing: Jest in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过自动化测试节省时间:Jest in Node.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/save-time-by-automated-testing-jest-in-node-js-9858bfb3b012?source=collection_archive---------13-----------------------#2021-05-17">https://javascript.plainenglish.io/save-time-by-automated-testing-jest-in-node-js-9858bfb3b012?source=collection_archive---------13-----------------------#2021-05-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c656c6fd992cb255db4df3ba326ca609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLzrwr4DFlNWVdm0AFT-sw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Automated testing using Jest</figcaption></figure><p id="f515" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Jest是一个流行的JavaScript测试框架，用于应用程序的自动化测试。自动化测试有助于您在应用程序投入使用之前最大限度地减少程序中的错误。通过编写测试用例，您可以确保新添加的功能没有错误，并且不会影响您现有的功能。</p><p id="d664" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这使得您的应用程序更加可靠、高效，同时也保证了应用程序的质量。未经测试的应用程序可能会在生产环境中导致灾难。在生产环境中识别bug也要困难得多。</p><p id="9edf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这篇文章中，我们将学习如何在Node.js项目中建立Jest测试框架，以及一些测试用例的例子。</p><h2 id="aab2" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">步骤1:设置Jest环境。</h2><p id="9f50" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated"><strong class="kb io"> 1。</strong>安装jest作为开发依赖项，因为我们在生产环境中不需要jest。我们需要超级测试来测试我们的Node.js HTTP服务器。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="c818" class="kx ky in ma b gy me mf l mg mh">npm i --save-dev jest supertest<br/>Or <br/>yarn add --dev jest supertest</span></pre><p id="17e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 2。</strong>您总是可以在package.json文件中配置jest，但是为jest所需的所有配置创建一个jest.config.js文件是一个很好的做法。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="629b" class="kx ky in ma b gy me mf l mg mh">module.exports = {<br/> clearMocks: true,<br/> collectCoverage: true,<br/> coverageDirectory: 'coverage',<br/> coveragePathIgnorePatterns: [<br/>  '/node_modules/',<br/>  '/tests/',<br/>  '/views/'<br/>  '/keys/',<br/>  '/public/',<br/>  '/models/',<br/> ],<br/> globalSetup: './tests/setup.js',<br/> globalTeardown: './tests/teardown.js'<br/> setupFiles: [<br/>  './tests/globalmocks.js',<br/> ],<br/> testEnvironment: 'node',<br/>}</span></pre><p id="79ca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的文件中，我们列出了一些配置属性，如:</p><p id="fbb9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">我</strong>。clearMocks用于指定是否在每次测试之间自动清除模拟调用和实例。</p><p id="be4a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">二</strong>。收集覆盖率指定在执行测试时是否应该收集覆盖率信息。</p><p id="9a51" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">三</strong>。覆盖率目录指定Jest应该输出其覆盖率文件的目录。</p><p id="a1b1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">四</strong>。coveragePathIgnorePatterns指定用于跳过覆盖率收集的regexp模式字符串数组。</p><p id="3c8e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> v </strong>。全局设置指定模块的路径，该模块导出在所有测试套件之前触发一次的异步函数。</p><p id="488d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">六</strong>。globalTeardown指定一个模块的路径，该模块导出一个在所有测试套件之后触发一次的异步函数。</p><p id="1071" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">七</strong>。安装文件指定了在每次测试之前设置测试环境的路径。</p><p id="57b7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> viii </strong>。测试环境指定了测试环境。<br/>关于每个配置属性的详细说明，请访问<a class="ae mi" href="https://jestjs.io/docs/en/configuration.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="0f2c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 3。</strong>现在在项目的根目录下创建一个Tests文件夹。这个文件夹将包含所有与你的测试用例相关的文件。</p><p id="def4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">a.创建setup.js文件来初始化数据库连接。您可以将测试数据库植入到初始化的数据中。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a32f" class="kx ky in ma b gy me mf l mg mh">const path = require('path')<br/>const dotenv = require('dotenv')<br/>dotenv.config({<br/> path: path.join(__dirname, '..', 'test.env'),<br/>})</span><span id="10a1" class="kx ky in ma b gy mj mf l mg mh">const models = require('../models')</span><span id="d923" class="kx ky in ma b gy mj mf l mg mh">module.exports = () =&gt; {<br/> return models.sequelize.authenticate()<br/> .then(()=&gt; {<br/>   return models.sequelize.query('SET FOREIGN_KEY_CHECKS = 0')<br/> })<br/> .then(() =&gt; {<br/>   return models.sequelize.sync({<br/>    force: true,<br/>  })<br/> })<br/>.then(()=&gt; {<br/>  return models.sequelize.query('SET FOREIGN_KEY_CHECKS = 1')<br/> }).then(() =&gt; {<br/>   //seed you DB here<br/> })<br/>}<br/>module.exports.models = models</span></pre><p id="1263" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">b.创建一个teardown.js文件来关闭数据库连接。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="1837" class="kx ky in ma b gy me mf l mg mh">const path = require('path')<br/>const dotenv = require('dotenv')<br/>dotenv.config({<br/> path: path.join(__dirname, '..', 'test.env'),<br/>})</span><span id="e340" class="kx ky in ma b gy mj mf l mg mh">const models = require('../models')</span><span id="270c" class="kx ky in ma b gy mj mf l mg mh">module.exports = async function () {<br/> await models.sequelize.close()<br/>};</span></pre><p id="6a73" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">c.创建一个globalmock.js文件来模拟第三方服务函数。使用第三方服务和库是现代项目的常见部分。很难控制第三方服务的行为，为了解决这个问题，我们模仿第三方服务。模仿只是允许您用一组假的/固定的期望输出来替换实际的实现。我们将在这篇文章的后面模拟一些函数。</p><p id="21f8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 4。</strong>让我们在Tests文件夹中创建Routes文件夹来测试所有路由文件。所有的测试用例都应该有一个“test.js”或者“spec.js”的扩展名。jest通过它识别测试文件。</p><p id="37a2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">a.创建一个index.test.js文件，写下index.js文件的所有测试用例。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4f08" class="kx ky in ma b gy me mf l mg mh">const request = require('supertest')<br/>const app = require('../../app')<br/>const client = request(app)</span><span id="a4dd" class="kx ky in ma b gy mj mf l mg mh">describe('index', () =&gt; {<br/> it('should show 200', async () =&gt; {<br/>  const res = await client.get('/')<br/>  expect(res.status).toBe(200)<br/> })<br/>})</span></pre><p id="8a44" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码中，我们导入了supertest，这将允许我们创建一个测试node.js HTTP服务器来测试所有的CRUD API。初始化你的模拟应用服务器。</p><p id="0d20" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">i. "Describe "创建一个块，将相关的测试用例组合在一起。这用于将与单个API相关的所有测试用例分组，就像将所有正面和负面测试用例分组在一起一样。它是完全可选的，你可以独立测试功能。</p><p id="efd1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">二。“It”函数执行API的实际测试。你也可以用“test”来代替它，两者是一样的。它以函数名和函数实现作为参数。</p><p id="6095" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">三。“expect”指定了期望通过测试用例的输出。例如，响应状态代码应该是200。有各种各样的方法，你可以在这里阅读<a class="ae mi" href="https://jestjs.io/docs/expect#:~:text=Reference-,expect(value),assert%20something%20about%20a%20value." rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6e65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 5。</strong>我们来为账户更新API写一套完整的测试用例。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4081" class="kx ky in ma b gy me mf l mg mh">const request = require('supertest')<br/>const app = require('../../app')<br/>const client = request(app)<br/>const urlPrefix = '/user'</span><span id="a1fb" class="kx ky in ma b gy mj mf l mg mh">describe('update User account Info', () =&gt; {</span><span id="87da" class="kx ky in ma b gy mj mf l mg mh"> it('should update user account info', async () =&gt; {<br/>   const res = await client.put(`${urlPrefix}/account_info`)<br/>    .set({<br/>      authorization: token,<br/>      Accept: 'json',<br/>     })<br/>    .send({<br/>      uId: 2,<br/>      emailId: "johnDoe@gmail.com",<br/>      firstName: "John",<br/>      lastName: "Doe",<br/>      birthDate: "1996-02-02",<br/>      height: 5.10Ft,<br/>      weight: 80Kg,<br/>      phoneNo: "+91-7777777777",<br/>      metaData: {},<br/>     })<br/>    expect(res.status).not.toEqual(200)<br/>  })</span><span id="6586" class="kx ky in ma b gy mj mf l mg mh">it('should not update user info without id', async () =&gt; {<br/>  const res = await client.put(`${urlPrefix}/account_info`)<br/>    .set({<br/>      authorization: token,<br/>      Accept: 'json',<br/>     })<br/>    .send({<br/>      emailId: "johnDoe@gmail.com",<br/>      firstName: "John",<br/>      lastName: "Doe",<br/>      birthDate: "1996-02-02",<br/>      height: 5.10Ft,<br/>      weight: 80Kg,<br/>      phoneNo: "+91-7777777777",<br/>      metaData: {},<br/>     })<br/>    expect(res.status).not.toEqual(200)<br/>  })</span><span id="4cd3" class="kx ky in ma b gy mj mf l mg mh">it('should not update user info with wrong id', async () =&gt; {<br/>  const res = await client.put(`${urlPrefix}/account_info`)<br/>    .set({<br/>      authorization: token,<br/>      Accept: 'json',<br/>     })<br/>    .send({<br/>      uId: 2000,<br/>      emailId: "johnDoe@gmail.com",<br/>      firstName: "John",<br/>      lastName: "Doe",<br/>      birthDate: "1996-02-02",<br/>      height: 5.10Ft,<br/>      weight: 80Kg,<br/>      phoneNo: "+91-7777777777",<br/>      metaData: {},<br/>     })<br/>    expect(res.status).not.toEqual(200)<br/>  })<br/>})</span></pre><p id="da68" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以进行所有HTTP调用，如get、post、put、delete等。您可以使用“set”方法设置标题。使用“Send”方法将数据作为主体参数传递。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="ff19" class="kx ky in ma b gy me mf l mg mh">// Mock Send email feature</span><span id="7749" class="kx ky in ma b gy mj mf l mg mh">jest.mock('../email-helper.js')<br/>const emailHelper = require('../email-helper')</span><span id="ea3e" class="kx ky in ma b gy mj mf l mg mh">emailHelper.sendEmail.mockImplementation((fromEmail, toEmail, substitutions) =&gt; {<br/> if (emailHelper.fromEmail &amp;&amp; emailHelper.toEmail) {<br/>   return Promise.resolve({<br/>    status: 200<br/>   })<br/> } else {<br/>   return Promise.reject(new Error("Email template dosen't exist"))<br/> }<br/>});</span></pre><p id="bac7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码中，我们模拟了send email函数，该函数使用nodemailer向用户发送电子邮件。您可以简单地模拟该函数，并在传递状态代码200时解决它。您可以模拟所有需要其输出的函数。在我们之前创建的globalmock.js文件中编写所有被模拟的函数。</p><p id="62eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 6。</strong>要运行测试用例，请使用:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="60dc" class="kx ky in ma b gy me mf l mg mh">npx jest</span></pre><p id="e33f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">就这样，你可以使用describe块编写CRUD的所有测试用例，以覆盖所有可能的场景，作为一个独立的测试用例。</p><p id="8fb2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在开发应用程序时编写测试用例可能很耗时，但有助于您在将来减少大量修复bug的时间。在将应用程序代码作为CI/CD管道的一部分移动到生产环境之前，您可以编写所有的测试用例并运行它们。</p><p id="81e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="mk">感谢阅读。</em>T11】</strong></p><p id="06f9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="mk">更多内容尽在</em><a class="ae mi" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mk">plain English . io</em></a></p></div></div>    
</body>
</html>