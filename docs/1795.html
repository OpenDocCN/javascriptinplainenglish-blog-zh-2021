<html>
<head>
<title>How to Create Paginated Pages on GatsbyJS with Pagination Controls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用分页控件在GatsbyJS上创建分页页面</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-paginated-pages-on-gatsbyjs-with-pagination-controls-49e3bb557030?source=collection_archive---------21-----------------------#2021-04-15">https://javascript.plainenglish.io/how-to-create-paginated-pages-on-gatsbyjs-with-pagination-controls-49e3bb557030?source=collection_archive---------21-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/439774c431d3b98551de772ecc71bd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4Khkosm0laGbq3aAKFiag.png"/></div></div></figure><div class=""/><p id="f08c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎回到博客！在这篇文章中，我们将看看如何在GatsbyJS网站上给页面添加分页。</p><p id="bab0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章的结尾:</p><ol class=""><li id="d5a8" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">您的网站将能够根据需要创建页面来容纳您的所有内容。</li><li id="c19b" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">页面的数量将由我们希望每页的文章数量决定。</li><li id="d040" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">最后，我们将添加控件来在页面之间导航，并能够跳到某个页面。</li></ol><h2 id="09a6" class="lk ll jb bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">我们在创造什么？</h2><p id="7154" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">下面是我的直播网站<a class="ae mi" href="https://conermurphy.com/blog/gatsbyjs-pagination-tutorial/" rel="noopener ugc nofollow" target="_blank">conermurphy.com</a>的截图。今天，我们将讨论允许我们指定我想要每页X个帖子，然后让Gatsby为我们创建页面的功能。出于本教程的目的，我将使用博客作为例子，但是这个逻辑可以应用于网站上的任何页面。比如我在网站上的笔记也是用的。</p><p id="6ee4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将以下面的URL结构结束:</p><ul class=""><li id="a759" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv mj lc ld le bi translated">yourURL.com/blog/</li><li id="006a" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">yourURL.com/blog/1 </li><li id="81f4" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">yourURL.com/blog/2 </li><li id="8ed2" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">yourURL.com/blog/3 </li></ul><p id="0358" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Check it out:</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/41fa64f75d2cd2f6398d787100749055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYysvtPeJs3as0kNcyoNyg.png"/></div></div></figure><h1 id="2e30" class="mp ll jb bd lm mq mr ms lp mt mu mv ls mw mx my lv mz na nb ly nc nd ne mb nf bi translated">Prerequisites</h1><p id="3b12" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">So, what do you need to have done already before working through this tutorial?</p><p id="bac1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">As long as you have a working blog with some posts on it you will be good to go. For the purposes of this tutorial, I won't be covering how to set up sourcing content into Gatsby. Or, how to create the individual blog posts using a template file. But, if you are interested in these tutorials please let me know.</p><p id="48f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">As long as you currently have a single page that has all your posts on it, you'll be good to go. 😃</p><p id="9d0b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">If you are looking to set up your blog for the first time, <a class="ae mi" href="https://blog.logrocket.com/creating-a-gatsby-blog-from-scratch/" rel="noopener ugc nofollow" target="_blank">log rocket在这里有很棒的教程。</a></p><h1 id="48d5" class="mp ll jb bd lm mq mr ms lp mt mu mv ls mw mx my lv mz na nb ly nc nd ne mb nf bi translated">盖茨比节点</h1><p id="bd8e" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">好了，一切都结束了，让我们开始实际编写一些代码。</p><p id="2c51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所述，我们应该已经在gatsby-node.js中将我们的帖子来源于Gatsby。</p><p id="53d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的个人文章页面生成已经设置好了，您应该有一个到createPages API的挂钩。如果不是，没关系，这里有一个快速概述。</p><h2 id="2a5e" class="lk ll jb bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated"><a class="ae mi" href="https://conermurphy.com/blog/gatsbyjs-pagination-tutorial/#createpages" rel="noopener ugc nofollow" target="_blank">创建页面</a></h2><p id="d38d" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated"><code class="fe ng nh ni nj b">createPages</code>是Gatsby Node的一个API，允许你动态创建页面。这个API在节点的来源和转换以及GraphQL模式的创建完成之后运行。点击此处了解更多信息。</p><p id="aa84" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nk">在下面的代码示例中，我在我的gatsby-node文件中使用了ES6模块，这些模块在默认情况下是不启用的。你可以按照我在Twitter上做的一个教程来设置这些。</em>T13】</p><p id="8065" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了开始设置<code class="fe ng nh ni nj b">createPages</code> API和分页页面的生成，我们需要添加下面的代码。</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="7be4" class="lk ll jb nj b gy np nq l nr ns">export async function createPages(params) {<br/>  await Promise.all([turnBlogPostsIntoPages(params)]);<br/>}</span></pre><p id="ea65" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这允许我们挂钩到createPages API。<code class="fe ng nh ni nj b">Promise.all</code>不是必需的，你可以把所有的代码添加到这个函数中。但是，为了可读性，我将各个代分离到它们自己的函数中。</p><p id="270c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了说明这一点，下面是我当前网站的一个直接副本:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="8d6a" class="lk ll jb nj b gy np nq l nr ns">export async function createPages(params) {<br/>  // After the creation of the nodes create pages for each custom type.<br/>  await Promise.all([<br/>    // Blog Posts<br/>    turnBlogPostsIntoPages(params),<br/>    // Notes Pages<br/>    turnNotesIntoPages(params),<br/>    // Turn sourced Twitter Threads into pages.<br/>    turnTwitterThreadsIntoPages(params),<br/>    // Blog Tags Pages<br/>    turnBlogPostTagsIntoPages(params),<br/>    // Turn Notes Categories into pages<br/>    turnNotesCategoriesIntoPages(params),<br/>    // Turn Twitter Threads Tags Into Pages<br/>    turnThreadsTagsIntoPages(params),<br/>    // Turn Portfolio Tags into pages<br/>    turnPortfolioTagsIntoPages(params),<br/>    // Turn Read Categories into pages.<br/>    turnReadsCategoriesIntoPages(params),<br/>  ]);<br/>}</span></pre><p id="9085" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我把所有这些函数放到<code class="fe ng nh ni nj b">createPages</code>函数中，这个函数将超过300行。这对我们的可读性肯定不好。</p><p id="85a2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，回到正题。接下来，我们需要创建我们声明的<code class="fe ng nh ni nj b">turnBlogPostsIntoPages</code>函数。</p><p id="4ad3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，在这个<code class="fe ng nh ni nj b">createPages</code>函数的上面添加一个新的函数，如下所示:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="86a4" class="lk ll jb nj b gy np nq l nr ns">async function turnBlogPostsIntoPages({ graphql, actions }) {<br/>  const { createPage } = actions;<br/>}<br/><br/>export async function createPages(params) {<br/>  await Promise.all([turnBlogPostsIntoPages(params)]);<br/>}</span></pre><p id="0c44" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们有了一个在<code class="fe ng nh ni nj b">createPages</code> API运行时被调用的函数。让我们更深入地研究这个函数，并开始让它做一些有用的事情。</p><p id="64c1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是完成的代码，我们马上就要分解它。</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="db6c" class="lk ll jb nj b gy np nq l nr ns">async function turnBlogPostsIntoPages({ graphql, actions }) {<br/>  // 0: Destructuring out the action createPage which is used to create the pages.<br/>  const { createPage } = actions;<br/><br/>  // 1: Query for all of blog post data. Most importantly the totalCount which we will use later on.<br/>  const {<br/>    data: {<br/>      blog: { edges: blogPosts, totalCount: blogTotalCount },<br/>    },<br/>  } = await graphql(`<br/>    query {<br/>      blog: allMdx(filter: { fields: { contentCategory: { eq: "blog" } } }) {<br/>        edges {<br/>          node {<br/>            fields {<br/>              slug<br/>              contentCategory<br/>            }<br/>            frontmatter {<br/>              title<br/>              date(formatString: "DD/MM/YYYY")<br/>            }<br/>          }<br/>        }<br/>        totalCount<br/>      }<br/>    }<br/>  `);<br/><br/>  // 2: Create a page for every blog post node. (This is for indivual blog posts.)<br/>  blogPosts.forEach(({ node }, index) =&gt; {<br/>    createPage({<br/>      path: node.fields.slug,<br/>      component: path.resolve("./src/templates/Blog.js"),<br/>      context: {<br/>        slug: node.fields.slug,<br/>        prev: index === 0 ? null : blogPosts[index - 1].node,<br/>        next: index === blogPosts.length - 1 ? null : blogPosts[index + 1].node,<br/>      },<br/>    });<br/>  });<br/><br/>  // 3: Create the main blog pages containing the posts..<br/>  const blogTemplate = path.resolve("./src/pages/blog.js");<br/><br/>  const pageSize = 6; // Total number of posts on each page<br/>  const pageCount = Math.ceil(blogTotalCount / pageSize); // Total number of pages required.<br/><br/>  // Loop through each page required (1 to x) and create a new blog page for each.<br/>  Array.from({ length: pageCount }).forEach((_, i) =&gt; {<br/>    createPage({<br/>      path: `/blog/${i === 0 ? "" : i + 1}`,<br/>      blogTemplate,<br/>      // Context is passed to the page so we can skip the required amount of posts on each page.<br/>      context: {<br/>        skip: i * pageSize,<br/>        currentPage: i + 1,<br/>        pageSize,<br/>      },<br/>    });<br/>  });<br/>}</span></pre><p id="f2af" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您已经在GatsbyJS上完成了一个博客的设置，那么您可能已经有了一些类似这样的代码。让我们分解每个步骤，看看发生了什么。</p><ol class=""><li id="7e5a" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">这是我们析构createPage动作的地方。这是用来从我们提供的信息实际创建页面。</li><li id="e72f" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们查询与GraphQL中的帖子相关的所有信息。最重要的是<code class="fe ng nh ni nj b">totalCount</code>这个数字，因为这是用来计算我们以后需要多少页的。</li><li id="588c" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">这是使用我们在上面构造的createPage操作创建单个博客文章的地方。</li><li id="8212" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">这是本教程中我们感兴趣的步骤。这是我们创建分页博客文章的地方。让我们在下面对此进行更详细的分析。</li></ol><h2 id="e646" class="lk ll jb bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">分解分页</h2><p id="fca2" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">下面是本教程中我们特别感兴趣的代码:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="e441" class="lk ll jb nj b gy np nq l nr ns">const blogTemplate = path.resolve("./src/pages/blog.js");<br/><br/>const pageSize = 6; // Total number of posts on each page<br/>const pageCount = Math.ceil(blogTotalCount / pageSize); // Total number of pages required.<br/><br/>// Loop through each page required (1 to x) and create a new blog page for each.<br/>Array.from({ length: pageCount }).forEach((_, i) =&gt; {<br/>  createPage({<br/>    path: `/blog/${i === 0 ? "" : i + 1}`,<br/>    blogTemplate,<br/>    // Context is passed to the page so we can skip the required amount of posts on each page.<br/>    context: {<br/>      skip: i * pageSize,<br/>      currentPage: i + 1,<br/>      pageSize,<br/>    },<br/>  });<br/>});</span></pre><p id="cc1d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看这里发生了什么。</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="bbbe" class="lk ll jb nj b gy np nq l nr ns">const blogTemplate = path.resolve("./src/pages/blog.js");</span></pre><p id="93f5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们导入将用于创建所有分页页面的模板文件。请注意，这是pages目录中的实际博客页面。而不是用于创建位于templates文件夹中的单个帖子的文件。</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="aed7" class="lk ll jb nj b gy np nq l nr ns">const pageSize = 6; // Total number of posts on each page<br/>const pageCount = Math.ceil(blogTotalCount / pageSize); // Total number of pages required.</span></pre><p id="79b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建另外两个变量来控制页面大小和我们需要多少页面。这是通过将<code class="fe ng nh ni nj b">pageSize</code>变量设置为我们希望每页上的文章数量来实现的。然后我们用这个变量来计算出我们需要多少页。</p><p id="9667" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过从graphQL查询中取出<code class="fe ng nh ni nj b">totalnumber</code>并将其除以页面大小来实现这一点。通过舍入这个结果，它告诉我们需要多少页。</p><p id="34c1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们进入有趣的部分:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="5840" class="lk ll jb nj b gy np nq l nr ns">// Loop through each page required (1 to x) and create a new blog page for each.<br/>Array.from({ length: pageCount }).forEach((_, i) =&gt; {<br/>  createPage({<br/>    path: `/blog/${i === 0 ? "" : i + 1}`,<br/>    blogTemplate,<br/>    // Context is passed to the page so we can skip the required amount of posts on each page.<br/>    context: {<br/>      skip: i * pageSize,<br/>      currentPage: i + 1,<br/>      pageSize,<br/>    },<br/>  });<br/>});</span></pre><p id="4956" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是怎么回事？</p><p id="ceef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中最重要的部分是第2行发生的事情。这是使我们能够创建多个博客页面的部分。</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="04ed" class="lk ll jb nj b gy np nq l nr ns">Array.from({ length: pageCount }).forEach((_, i) =&gt; {});</span></pre><p id="4876" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个变量告诉我们需要多少页(<code class="fe ng nh ni nj b">pageCount</code>)。但是，为了让这个对我们有用，我们需要能够循环所有通向这个点的数字。这将允许我们为每个号码创建一个单独的页面。</p><p id="03e2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是上面这条线出现的地方。我们使用<code class="fe ng nh ni nj b">Array.from({ length: pageCount })</code>来创建一个长度为我们需要创建的页数的数组。是的，数组项将是空白的，但这没关系，因为我们只对索引感兴趣。</p><p id="f790" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了访问索引，我们用一个<code class="fe ng nh ni nj b">.forEach((_, i) =&gt; {})</code>链接到<code class="fe ng nh ni nj b">Array.from()</code>，如上所示。因为我们只对索引感兴趣，所以我们可以跳过forEach的第一个参数。这将代表数组中当前索引的实际项目(空白)。然后，这允许我们访问第二个参数，它表示当前项的索引。</p><p id="b186" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在能够循环遍历一个可变长度的数组，以允许我们创建所需数量的页面。现在我们需要做实际的创作。</p><p id="85dc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以用下面的代码做到这一点:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="ffc3" class="lk ll jb nj b gy np nq l nr ns">createPage({<br/>  path: `/blog/${i === 0 ? "" : i + 1}`,<br/>  component: blogTemplate,<br/>  // Context is passed to the page so we can skip the required amount of posts on each page.<br/>  context: {<br/>    skip: i * pageSize,<br/>    currentPage: i + 1,<br/>    pageSize,<br/>  },<br/>});</span></pre><p id="72d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来分析一下这是怎么回事。</p><p id="e1ad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们向<code class="fe ng nh ni nj b">createPage</code>动作传递一系列参数，它们是:</p><ul class=""><li id="94aa" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv mj lc ld le bi translated">路径:将为其创建页面的URL。</li><li id="0c95" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">组件:这是将用于模板化页面的文件。</li><li id="4aa2" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">context:包含传递给页面的数据的对象。</li><li id="b122" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">skip:我们传递它来告诉页面在GraphQL查询中跳过多少篇文章。我们通过将当前索引乘以页面大小来计算。所以第一页应该是:<code class="fe ng nh ni nj b">0 * 6 = 0</code>，第二页应该是:<code class="fe ng nh ni nj b">1 * 6 = 6</code>。这确保了我们为每个页面跳过正确的文章数量。</li><li id="1082" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">currentPage:告诉页面当前是什么页面，我们将在以后使用它进行导航。</li><li id="41bc" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">pageSize:我们定义的页面大小。</li></ul><p id="f9db" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博文的最后一节，背景数据会更有意义。这时，我们将研究如何创建分页控件，以便在我们创建的页面之间移动。但是，现在让我们看看我们需要对页面文件进行的更改，以便它可以使用我们传递的<code class="fe ng nh ni nj b">skip</code>和<code class="fe ng nh ni nj b">pageSize</code>上下文。</p><h1 id="9efe" class="mp ll jb bd lm mq mr ms lp mt mu mv ls mw mx my lv mz na nb ly nc nd ne mb nf bi translated">修改页面文件</h1><p id="ec92" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">现在，我们有了<code class="fe ng nh ni nj b">gatsby-node.js</code>文件设置，并准备好为我们创建所有的页面。我们现在需要修改为我们列出所有帖子的页面文件。</p><h2 id="8f70" class="lk ll jb bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">更新GraphQL查询</h2><p id="fc8c" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">首先，我们需要更新页面上运行的GraphQL查询。您应该已经有了如下所示的内容:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="34ad" class="lk ll jb nj b gy np nq l nr ns">export const query = graphql`<br/>  query {<br/>    blog: allMdx(<br/>      sort: {<br/>        order: [DESC, DESC]<br/>        fields: [frontmatter___date, frontmatter___id]<br/>      }<br/>      filter: { fields: { contentCategory: { eq: "blog" } } }<br/>    ) {<br/>      edges {<br/>        node {<br/>          fields {<br/>            slug<br/>          }<br/>          frontmatter {<br/>            date(formatString: "DD/MM/YYYY")<br/>            tags<br/>            title<br/>            id<br/>            image {<br/>              childImageSharp {<br/>                fluid(maxWidth: 400) {<br/>                  ...GatsbyImageSharpFluid<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>      totalCount<br/>    }<br/>  }<br/>`;</span></pre><p id="35c5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个查询中需要注意的重要部分是，我们正在获取所有的博客文章。此时，除了我用来选择所有博客内容的过滤器之外，对查询没有任何限制。</p><p id="3447" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们看看我们需要添加什么。</p><p id="8570" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还记得当我们编辑<code class="fe ng nh ni nj b">gatsby-node.js</code>文件时，我们将一些上下文传递给页面吗？最著名的是<code class="fe ng nh ni nj b">skip</code>和<code class="fe ng nh ni nj b">pageSize</code>。因为我们将它们作为上下文传递给页面，所以我们可以在GraphQL中使用它们作为变量。</p><p id="1720" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一下修改后的查询，然后我们将对它们进行分解:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="b86d" class="lk ll jb nj b gy np nq l nr ns">export const query = graphql`<br/>  query($skip: Int = 0, $pageSize: Int = 6) {<br/>    blog: allMdx(<br/>      limit: $pageSize<br/>      skip: $skip<br/>      sort: {<br/>        order: [DESC, DESC]<br/>        fields: [frontmatter___date, frontmatter___id]<br/>      }<br/>      filter: { fields: { contentCategory: { eq: "blog" } } }<br/>    ) {<br/>      edges {<br/>        node {<br/>          fields {<br/>            slug<br/>          }<br/>          frontmatter {<br/>            date(formatString: "DD/MM/YYYY")<br/>            tags<br/>            title<br/>            id<br/>            image {<br/>              childImageSharp {<br/>                fluid(maxWidth: 400) {<br/>                  ...GatsbyImageSharpFluid<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>      totalCount<br/>    }<br/>  }<br/>`;</span></pre><p id="4b64" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在查询的第一行看到的，我们添加了两个变量作为上下文传递。让我们更深入地看看这一行:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="98ce" class="lk ll jb nj b gy np nq l nr ns">query($skip: Int = 0, $pageSize: Int = 6 ) {</span></pre><p id="2042" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不熟悉GraphQL语法。下面是正在发生的事情的快速概述。</p><ul class=""><li id="8862" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv mj lc ld le bi translated">$skip:这是变量的名称</li><li id="6f5b" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">Int:这是变量的数据类型</li><li id="0c65" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv mj lc ld le bi translated">= 0:这是变量的默认值。</li></ul><p id="c9b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在这一行中，我们接受两个都是整数的变量，并给它们一个默认值。</p><p id="d32e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们看看它们在查询中的使用位置:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="b4b5" class="lk ll jb nj b gy np nq l nr ns">query($skip: Int = 0, $pageSize: Int = 6 ) {<br/>    blog: allMdx(<br/>      limit: $pageSize<br/>      skip: $skip<br/>      sort: { order: [DESC, DESC], fields: [frontmatter___date, frontmatter___id] }<br/>      filter: { fields: { contentCategory: { eq: "blog" } } }<br/>    )<br/>    // Rest of the query goes here...<br/>}</span></pre><p id="a288" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们添加了<code class="fe ng nh ni nj b">skip</code>和<code class="fe ng nh ni nj b">pageSize</code>变量。它们被传递给查询的<code class="fe ng nh ni nj b">skip</code>和<code class="fe ng nh ni nj b">limit</code>属性。</p><p id="760b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将其转换为第1页的实际值，它看起来会是这样的:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="312b" class="lk ll jb nj b gy np nq l nr ns">query($skip: Int = 0, $pageSize: Int = 6 ) {<br/>    blog: allMdx(<br/>      limit: 6<br/>      skip: 0<br/>      sort: { order: [DESC, DESC], fields: [frontmatter___date, frontmatter___id] }<br/>      filter: { fields: { contentCategory: { eq: "blog" } } }<br/>    )<br/>    // Rest of the query goes here...<br/>}</span></pre><p id="7d44" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为我们希望将结果限制为6个值，并且我们跳过0，因为我们在第一页上。如果我们以第2页为例，我们可以开始了解它是如何工作的。</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="7f83" class="lk ll jb nj b gy np nq l nr ns">query($skip: Int = 0, $pageSize: Int = 6 ) {<br/>    blog: allMdx(<br/>      limit: 6<br/>      skip: 6<br/>      sort: { order: [DESC, DESC], fields: [frontmatter___date, frontmatter___id] }<br/>      filter: { fields: { contentCategory: { eq: "blog" } } }<br/>    )<br/>    // Rest of the query goes here...<br/>}</span></pre><p id="3a17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唯一改变的是跳过值。现在，我们跳过前6个值，而不是跳过0个值。然后，我们从数据集中的第7项开始，最多返回6个值。</p><p id="b9ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是重复的每一页，我们产生，直到我们已经涵盖了所有的职位。</p><p id="1717" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="nk">注意:</em> </strong> <em class="nk">如果你想让你的首页显示最新的帖子你需要在查询中使用</em> <code class="fe ng nh ni nj b"><em class="nk">sort</em></code> <em class="nk">属性。关于如何使用frontmatter___date字段进行排序，请参见我上面的示例。</em></p><h1 id="5f75" class="mp ll jb bd lm mq mr ms lp mt mu mv ls mw mx my lv mz na nb ly nc nd ne mb nf bi translated">分页控件</h1><p id="804a" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">让我们的帖子分页显示在几页上真是太好了。但是，如果我们必须在它们之间移动的唯一方式是通过改变URL，我们将有问题。</p><p id="785e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是添加分页控件将帮助我们的地方。我们将添加几个专用按钮，允许在页面上下移动。我们还将在按钮中间添加一个页面列表，这样如果你愿意，你可以跳过页面。</p><h2 id="4522" class="lk ll jb bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">创建分页组件</h2><p id="4808" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在我们可以在页面中实现它之前，我们首先需要创建我们的<code class="fe ng nh ni nj b">Pagination</code>组件。现在让我们看一下代码。</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="bad6" class="lk ll jb nj b gy np nq l nr ns">export default function Pagination({ pageSize, totalCount, currentPage }) {<br/>  const totalPages = Math.ceil(totalCount / pageSize);<br/>  const prevPage = currentPage - 1;<br/>  const nextPage = currentPage + 1;<br/>  const hasNextPage = nextPage &lt;= totalPages;<br/>  const hasPrevPage = prevPage &gt;= 1;<br/><br/>  const prevLink = prevPage === 1 ? "blog" : `blog/${prevPage}`;<br/>  const nextLink = `blog/${nextPage}`;<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Link title="prev page" disabled={!hasPrevPage} to={prevLink}&gt;<br/>        &amp;#8592; &lt;span className="word"&gt;Previous&lt;/span&gt;{" "}<br/>      &lt;/Link&gt;<br/>      {Array.from({ length: totalPages }).map((_, i) =&gt; (<br/>        &lt;Link<br/>          key={`blog-page-${i}`}<br/>          className={currentPage === 1 &amp;&amp; i === 0 ? "current" : ""}<br/>          to={`blog/${i === 0 ? "" : i + 1}`}<br/>        &gt;<br/>          {i + 1}<br/>        &lt;/Link&gt;<br/>      ))}<br/>      &lt;Link title="next page" disabled={!hasNextPage} to={nextLink}&gt;<br/>        &lt;span className="word"&gt;Next&lt;/span&gt; &amp;#8594;<br/>      &lt;/Link&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="d56f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码并不复杂，我们有几个来自Gatsby的<code class="fe ng nh ni nj b">Link</code>元素。然后是我们之前的另一个<code class="fe ng nh ni nj b">Array.from()</code>特色菜。不过这次我们没有使用<code class="fe ng nh ni nj b">.forEach()</code>，而是使用了<code class="fe ng nh ni nj b">.map()</code>，因为我们想要返回元素。</p><p id="f6c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来分析一下。</p><h2 id="3861" class="lk ll jb bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">创建链接</h2><p id="bcef" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">我们要看的第一部分是根据我们传入的道具为我们生成链接的代码。代码如下:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="75e8" class="lk ll jb nj b gy np nq l nr ns">export default function Pagination({<br/>  pageSize,<br/>  totalCount,<br/>  currentPage<br/>}) {<br/>  const totalPages = Math.ceil(totalCount / pageSize);<br/>  const prevPage = currentPage - 1;<br/>  const nextPage = currentPage + 1;<br/>  const hasNextPage = nextPage &lt;= totalPages;<br/>  const hasPrevPage = prevPage &gt;= 1;<br/><br/>  const prevLink = prevPage === 1 ? "blog" : `blog/${prevPage}`;<br/>  const nextLink = `blog/${nextPage}`;<br/><br/>  // ... Rest of the component here</span></pre><p id="fb41" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，我们在这里做什么？</p><p id="f145" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们传入一系列道具:</p><ol class=""><li id="8922" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">pageSize:我们希望每页上的文章数量。</li><li id="7553" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">totalCount:博客页面上来自GraphQL查询的博客帖子总数</li><li id="0a96" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">currentPage:这来自我们在<code class="fe ng nh ni nj b">gatsby-node.js</code>中添加的上下文。它在页面上被析构出来，然后传递给组件。</li></ol><p id="fac8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此之后，我们创建一系列变量，用于确定是否有另一个页面要导航到。如果有，URL是什么。</p><ol class=""><li id="e7d6" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">totalPages: Int:所需的总页数</li><li id="70cc" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">prevPage: Int:根据当前页计算出前一页的索引。</li><li id="9f26" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">Int:根据当前页面计算出下一个页面的索引。</li><li id="97bf" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">hasNextPage: Bool:检查<code class="fe ng nh ni nj b">nextPage</code>是否小于等于<code class="fe ng nh ni nj b">totalPages</code>。</li><li id="4886" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">hasPrevPage: Bool:检查<code class="fe ng nh ni nj b">prevPage</code>变量是否大于或等于1。</li></ol><p id="0844" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这5个变量在整个组件中用来决定元素是否应该显示。但是，我们一会儿就会讲到。首先，我们需要创建下一个和上一个链接，这是我们最后的两个变量。</p><ol class=""><li id="ec90" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">prevLink: Str:检查<code class="fe ng nh ni nj b">prevPage</code>变量是否等于1。如果是这样，将变量设置为<code class="fe ng nh ni nj b">'blog'</code>，这会将您重定向到主博客页面。如果不是，将变量设置为<code class="fe ng nh ni nj b">blog/${prevPage}</code>。</li><li id="3345" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">nextLink: Str:这个设置为<code class="fe ng nh ni nj b">blog/${nextPage}</code>。这样做是因为我们有一个单独的变量来控制是否有另一个页面。</li></ol><p id="4f1e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经讨论了创建元素所需的所有变量，让我们看看如何制作按钮。</p><h2 id="d89a" class="lk ll jb bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">下一个和上一个按钮</h2><p id="8e45" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">“上一页”和“下一页”按钮的代码实际上是相似的，只是做了一些文字上的修改。出于这个原因，我将只分解其中一个，这样我们就可以了解它们是如何工作的。首先让我们看一下完整的代码，这样您就可以看到不同之处了:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="4388" class="lk ll jb nj b gy np nq l nr ns">&lt;Link title="prev page" disabled={!hasPrevPage} to={prevLink}&gt;<br/>  &amp;#8592; &lt;span className="word"&gt;Previous&lt;/span&gt;{' '}<br/>&lt;/Link&gt;<br/><br/>&lt;Link title="next page" disabled={!hasNextPage} to={nextLink}&gt;<br/>  &lt;span className="word"&gt;Next&lt;/span&gt; &amp;#8594;<br/>&lt;/Link&gt;</span></pre><p id="36ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">链接的结构是一个Gatsby <code class="fe ng nh ni nj b">Link</code>元素，包装一个描述按钮功能的<code class="fe ng nh ni nj b">span</code>。让我们看看我们用它们做了什么:</p><ol class=""><li id="ec65" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">title: Str:我们在元素上设置了一个title属性，向用户声明每个链接的作用。</li><li id="c854" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">disabled: Bool:这是两个变量<code class="fe ng nh ni nj b">hasPrevPage</code>和<code class="fe ng nh ni nj b">hasNextPage</code>出现的地方。如果变量表示下一页或上一页在可用页面之外，它将禁用链接。然后CSS对其进行样式化，以降低不透明度并防止用户点击它们。检查以下代码。</li><li id="ed62" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">to: Str:这是我们希望元素被点击时导航到的目的地。</li></ol><p id="ec0a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这包括了功能，最后一部分是添加文本元素以在屏幕上标记它们。为此，我们使用一个<code class="fe ng nh ni nj b">span</code>来包装相关的单词和一个取决于按钮的下一个/上一个箭头。</p><p id="fca3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">禁用链接的CSS代码:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="0439" class="lk ll jb nj b gy np nq l nr ns">&amp;[disabled] {<br/>      pointer-events: none;<br/>      text-decoration: line-through;<br/>      color: var(--black);<br/>      opacity: 0.5;<br/>    }</span></pre><h2 id="a1e9" class="lk ll jb bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">添加所有页面</h2><p id="5b48" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">分页组件就要完成了。我们只需要添加上一页和下一页按钮之间的链接。</p><p id="39e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是添加页面链接的代码:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="94ad" class="lk ll jb nj b gy np nq l nr ns">{<br/>  Array.from({ length: totalPages }).map((_, i) =&gt; (<br/>    &lt;Link<br/>      key={`blog-page-${i}`}<br/>      className={currentPage === 1 &amp;&amp; i === 0 ? "current" : ""}<br/>      to={`blog/${i === 0 ? "" : i + 1}`}<br/>    &gt;<br/>      {i + 1}<br/>    &lt;/Link&gt;<br/>  ));<br/>}</span></pre><p id="3b91" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它基于与我们过去在<code class="fe ng nh ni nj b">gatsby-node.js</code>中生成每个页面相似的原理。然而，我们没有使用<code class="fe ng nh ni nj b">.forEach()</code>来遍历每个索引，而是使用<code class="fe ng nh ni nj b">.map()</code>来返回<code class="fe ng nh ni nj b">Link</code>元素。</p><p id="beb7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来分析一下这个代码块中发生了什么:</p><ol class=""><li id="6e0d" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们创建一个长度等于<code class="fe ng nh ni nj b">totalPages</code>的数组，然后映射每个索引。</li><li id="782c" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们创建一个<code class="fe ng nh ni nj b">Link</code>元素，并向它传递3个属性:</li><li id="37ce" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">key: Str:从map返回元素时，React需要标准键属性。</li><li id="56a8" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">className: Str:用于将“当前”类添加到元素中，如果我们在页面上允许样式化的话。</li><li id="ef71" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">to: Str:我们希望链接导航到的目的地。</li><li id="8b1b" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">最后，我们将索引加1的文本添加到<code class="fe ng nh ni nj b">Link</code>中，以否定JavaScript数组的0索引。</li></ol><p id="f2ee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我们添加的当前元素样式的CSS:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="cd02" class="lk ll jb nj b gy np nq l nr ns">&amp;[aria-current],<br/>&amp;.current {<br/>  color: var(--green);<br/>  font-weight: 600;<br/>  border-bottom: 2px solid var(--green);<br/>}</span></pre><h1 id="4b42" class="mp ll jb bd lm mq mr ms lp mt mu mv ls mw mx my lv mz na nb ly nc nd ne mb nf bi translated">添加到页面文件</h1><p id="b717" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">我们现在已经创建了分页组件，是时候将它添加到我们的博客页面文件中了，如下所示:</p><pre class="ml mm mn mo gt nl nj nm nn aw no bi"><span id="4e89" class="lk ll jb nj b gy np nq l nr ns">return (<br/>  &lt;&gt;<br/>    &lt;Pagination<br/>      pageSize={6}<br/>      totalCount={totalCount}<br/>      currentPage={currentPage || 1}<br/>    /&gt;<br/>    &lt;AllPostsContainer&gt;<br/>      {blogPosts.map((post) =&gt; (<br/>        &lt;BlogPostCard<br/>          key={`blogPostCard-${post.node.frontmatter.id}`}<br/>          post={post}<br/>        /&gt;<br/>      ))}<br/>    &lt;/AllPostsContainer&gt;<br/>    &lt;Pagination<br/>      pageSize={6}<br/>      totalCount={totalCount}<br/>      currentPage={currentPage || 1}<br/>    /&gt;<br/>  &lt;/&gt;<br/>);</span></pre><p id="8de5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们已经拆分了整个分页组件，现在的问题是传入所需的属性:</p><ol class=""><li id="f24f" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">pageSize: Int:每个页面上的文章总数</li><li id="c561" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">totalCount: Int:来自GraphQL查询的帖子总数。</li><li id="ee45" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如果不为1，则从上下文获取当前页面的索引。</li></ol><p id="e682" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在应该已经准备好了，可以开始了。</p><h1 id="877f" class="mp ll jb bd lm mq mr ms lp mt mu mv ls mw mx my lv mz na nb ly nc nd ne mb nf bi translated">结论</h1><p id="b4ac" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果一切都按计划进行，您应该有类似这样的功能:</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/18e64cadb740e4c2e675bfbb600bed6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1lszxkFPWNn-y5Kk.gif"/></div></div></figure><p id="cb29" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了一两个部分之外，我没有在本文中包括CSS，以尽量减少帖子的长度。但是，如果你对所有的CSS感兴趣，可以在我网站的<a class="ae mi" href="https://github.com/conermurphy/conermurphy.com" rel="noopener ugc nofollow" target="_blank"> Github上找到。</a></p><p id="7e46" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一件事我没有包括在这篇文章中，但是我建议你把你的<code class="fe ng nh ni nj b">pageSize</code>变量存储在一个<code class="fe ng nh ni nj b">.env</code>文件中。然后你可以用<code class="fe ng nh ni nj b">parseInt(process.env.GATSBY_PAGE_SIZE)}</code>把它导入盖茨比。这意味着如果你想改变每页的文章数量，你只需要在一个地方改变它。</p><p id="fdf6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章对你有所帮助，如果你有，我会非常感谢你在社交媒体上与他人分享，这样他们也可以从中受益。如果你有任何我想听的反馈，你可以通过推特<a class="ae mi" href="https://twitter.com/MrConerMurphy" rel="noopener ugc nofollow" target="_blank">联系我。</a></p><p id="e0f8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。😃</p><p id="092a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nk">这篇文章最初发表在我的博客</em><a class="ae mi" href="https://conermurphy.com/" rel="noopener ugc nofollow" target="_blank"><em class="nk">conermurphy.com</em></a><em class="nk">上。如果你有兴趣在我的帖子发布后立即阅读，请考虑在</em><a class="ae mi" href="https://twitter.com/MrConerMurphy" rel="noopener ugc nofollow" target="_blank"><em class="nk">Twitter</em></a><em class="nk">上关注我。</em></p><p id="1c96" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nk">更多内容尽在</em> <a class="ae mi" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="nk">说白了</em> </strong> </a></p></div></div>    
</body>
</html>