<html>
<head>
<title>How to Send Data Between Chrome Extension Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Chrome扩展脚本之间发送数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-send-data-between-chrome-extension-scripts-1182ce67b659?source=collection_archive---------1-----------------------#2021-07-23">https://javascript.plainenglish.io/how-to-send-data-between-chrome-extension-scripts-1182ce67b659?source=collection_archive---------1-----------------------#2021-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="efbd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一次性消息传递和长期连接</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2b5c926444021699fde5b86d4511c0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-KFfGj3SkeOVgsBePg93w.png"/></div></div></figure><h1 id="a42f" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="fbff" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你想创建一个具有复杂功能的Chrome扩展，很可能你需要你的背景、内容和弹出脚本一起工作并相互作用。</p><p id="26bd" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在本教程中，我想解释我们如何用一次性消息和长期连接在Chrome扩展的不同组件之间发送数据。</p><p id="3ffa" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在继续阅读之前，由于这篇文章只讨论了消息传递，你应该已经很好地了解了如何创建一个chrome扩展并上传到Chrome扩展页面进行测试。</p><p id="7d72" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">本教程将使用清单v3编写。与v2的一个很大区别是使用async/await的能力。但是如果你使用v2，你可以只使用回调而不是async/await。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="8746" class="kr ks iq bd kt ku mr kw kx ky ms la lb jw mt jx ld jz mu ka lf kc mv kd lh li bi translated">架构的简要概述</h1><p id="eb0d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">要真正理解不同组件之间的消息传递是如何工作的，理解一个扩展的架构并知道每个部分负责什么是很重要的。</p><p id="da9e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">对于扩展，我们关心3个主要组件:</p><ul class=""><li id="fe4b" class="mw mx iq ll b lm mf lp mg ls my lw mz ma na me nb nc nd ne bi translated">UI元素</li><li id="fd0b" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nb nc nd ne bi translated">背景脚本</li><li id="d592" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nb nc nd ne bi translated">内容脚本</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/f5402470db188ad7286aa459a883529e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGBfwV7ZN3kNgT0W85wfzg.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk"><a class="ae np" href="https://developer.chrome.com/docs/extensions/mv3/architecture-overview/" rel="noopener ugc nofollow" target="_blank">https://developer.chrome.com/docs/extensions/mv3/architecture-overview/</a></figcaption></figure><p id="490b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">UI元素是单击扩展图标时显示的内容，它可以包含一个JavaScript文件(popup.js ),这使得它可以与用户交互。然而，由于JavaScript逻辑仅用于弹出窗口，它不能应用于用户当前查看的实际网页。</p><p id="4aee" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了操作和阅读网页，我们需要使用内容脚本。内容脚本将在加载到浏览器中的页面的上下文中执行，因此，如果我们想要更改某些信息或站点的美观性，它将非常有用。</p><p id="4296" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">最后，后台脚本(或v3中的service worker)主要用于事件处理。它被加载一次，如果没有感兴趣的事件被触发，它就保持空闲。它不能直接访问DOM，但是对于拦截站点的传出和传入请求非常有用。</p><p id="6ff2" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">正如您所看到的，所有3个组件有不同的用途，它们可以在浏览器中访问不同的内容。因此，我们需要让它们相互对话，并对不同的消息做出反应，以实现复杂的功能。</p><p id="86c6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">需要记住的一个关键点是，内容脚本存在于当前活动选项卡的上下文中。因此，任何时候我们想要从弹出窗口或后台脚本与内容脚本通信，我们都需要指定将消息发送到哪个选项卡，对于一次性消息和长期连接都是如此。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1705" class="kr ks iq bd kt ku mr kw kx ky ms la lb jw mt jx ld jz mu ka lf kc mv kd lh li bi translated">一次性消息</h1><p id="b055" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果您希望向扩展的其他部分发送单个消息，一次性消息非常有用。您可以从内容脚本向popup发送一次性请求，反之亦然，并对回复消息做出反应。</p><p id="b002" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">从高层次上来说，这个想法是，其中一个脚本将作为消息发送者，而接收者将设置一个消息监听器来监听任何传入的消息。当收到消息时，侦听器运行，并可以选择向消息发送方发回响应。使用<code class="fe nq nr ns nt b">chrome.runtime.onMessage.addListener</code>添加监听器。</p><p id="6172" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">根据接收者的不同，Chrome为我们公开了两种方法:<code class="fe nq nr ns nt b">chrome.runtime.sendMessage</code>和<code class="fe nq nr ns nt b">chrome.tabs.sendMessage</code>。知道何时使用哪种方法很重要。</p><p id="4b38" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当向内容脚本发送消息时，我们需要指定将消息发送到哪个选项卡。因此，我们需要先检索活动选项卡信息，然后使用<code class="fe nq nr ns nt b">tabs.sendMessage</code>。要使用选项卡API并访问活动选项卡，您需要在您的<code class="fe nq nr ns nt b">manifest.json</code>中的权限下添加<code class="fe nq nr ns nt b">tabs</code>和<code class="fe nq nr ns nt b">activeTab</code>。</p><p id="ba39" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果我们从内容脚本发送消息，那么我们应该使用<code class="fe nq nr ns nt b">runtime.sendMessage</code>,因为我们想把它发送到应用程序或扩展页面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9e8e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">上面的代码显示了一个扩展的弹出动作如何触发站点外观的改变。当用户点击<code class="fe nq nr ns nt b">sendMessageButton</code>时，处理程序将查询当前活动的选项卡，并使用<code class="fe nq nr ns nt b">sendMessage</code>向该选项卡的内容脚本发送消息。</p><p id="706e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">该方法接受3个参数:</p><ul class=""><li id="6ca2" class="mw mx iq ll b lm mf lp mg ls my lw mz ma na me nb nc nd ne bi translated"><strong class="ll ir">标签Id: </strong>活动标签Id</li><li id="c71d" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nb nc nd ne bi translated"><strong class="ll ir">消息</strong>:可以是包含数据的JSON对象</li><li id="5d4d" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nb nc nd ne bi translated"><strong class="ll ir">响应回调</strong>:接收方回复后运行的函数</li></ul><p id="d367" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在<code class="fe nq nr ns nt b">content.js</code>端，也就是接收者，它需要监听传入的消息。这是通过使用<code class="fe nq nr ns nt b">chrome.runtime.onMessage.addListener</code>设置一个监听器来完成的。listener函数是这样一个函数:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="880a" class="oa ks iq nt b gy ob oc l od oe">(message: any, sender: <a class="ae np" href="https://developer.chrome.com/docs/extensions/reference/runtime/#type-MessageSender" rel="noopener ugc nofollow" target="_blank">MessageSender</a>, sendResponse: function) =&gt; {...}</span></pre><p id="f16b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">message参数是使用<code class="fe nq nr ns nt b">sendMessage</code>发送的消息发送者，sender是一个包含发送消息的脚本上下文信息的对象，而<code class="fe nq nr ns nt b">sendResponse</code>是一个函数，它接受一个JSON-fiable对象来回复发送者。</p><p id="ef50" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果您正在从内容脚本向弹出窗口发送消息，那么您只需要使用<code class="fe nq nr ns nt b">chrome.runtime.sendMessage</code>而不是<code class="fe nq nr ns nt b">tabs.sendMessage</code>。<code class="fe nq nr ns nt b">runtime.sendMessage</code>没有将页签标识作为第一个参数，但是函数签名的其余部分与<code class="fe nq nr ns nt b">tabs.sendMessage</code>相同。接收方代码保持不变:<code class="fe nq nr ns nt b">chrome.runtime.onMessage.addListener</code>。</p><p id="ab44" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe nq nr ns nt b">popup.js</code>中可以有多个元素向接收者发送不同的消息，以对用户正在查看的当前活动网站执行不同的操作。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="2f93" class="kr ks iq bd kt ku mr kw kx ky ms la lb jw mt jx ld jz mu ka lf kc mv kd lh li bi translated">长期联系</h1><p id="47fd" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">长寿命连接允许您打开比单个请求持续时间更长的连接。您可以分别使用<code class="fe nq nr ns nt b">runtime.connect</code>和<code class="fe nq nr ns nt b">tabs.connect</code>进行操作。</p><p id="38b7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们直接进入打开从弹出窗口到内容脚本的连接的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk">popup.js</figcaption></figure><p id="1e42" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在第8行，我们打开了一个到活动标签的内容脚本的连接，我们传递了一个带有名称字段的JSON对象。该名称字段允许我们区分多个开放连接(如果您的分机有)。<code class="fe nq nr ns nt b">connect</code>方法返回一个端口对象，我们可以用这个对象通过<code class="fe nq nr ns nt b">port.postMessage</code>发送消息，也可以选择添加一个<code class="fe nq nr ns nt b">onMessage</code>监听器来监听任何回复。</p><p id="84dc" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在第14行，我们将向接收端发送一条消息(内容脚本)。该消息是一个JSON对象，包含您想要的任何数据。在我们的例子中，我们正在传递<code class="fe nq nr ns nt b">idInput</code>输入框的值。</p><p id="dc5e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在第18行，我们正在设置<code class="fe nq nr ns nt b">onMessage</code>监听器，当接收者回复时会被触发。我们希望回复信息有一个<code class="fe nq nr ns nt b">exists</code>字段，我们将根据该值将按钮背景颜色设置为绿色或黄色。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk">content.js</figcaption></figure><p id="846f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了监听传入的消息，我们需要在<code class="fe nq nr ns nt b">runtime.onConnect</code>事件监听器中实现监听器功能，这对于<code class="fe nq nr ns nt b">popup.js</code>和<code class="fe nq nr ns nt b">content.js</code>都是一样的。</p><p id="b62a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当调用<code class="fe nq nr ns nt b">.connect</code>、<code class="fe nq nr ns nt b">onConnect</code>事件的弹出脚本被激发时，一个端口对象被包含在监听器中。我们可以使用这个对象使用<code class="fe nq nr ns nt b">.onMessage.addListener</code>添加消息监听器，或者使用<code class="fe nq nr ns nt b">port.postMessage</code>回复。</p><p id="cf54" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在第3行，我们检查端口对象的名称。可以想象，您可能有其他不同名称的连接，这是您可以定制内容脚本行为的地方。然后，监听器试图在活动页面上找到一个ID来自<code class="fe nq nr ns nt b">msg</code>对象的元素。这个<code class="fe nq nr ns nt b">msg</code>对象是从弹出菜单传入<code class="fe nq nr ns nt b">postMessage</code>的参数。</p><p id="2ed2" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在第6行和第10行，我们向发件人发回了一条消息。这将启动在<code class="fe nq nr ns nt b">popup.js</code>中定义的<code class="fe nq nr ns nt b">onMessage</code>监听器，完成通信周期。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="f268" class="kr ks iq bd kt ku mr kw kx ky ms la lb jw mt jx ld jz mu ka lf kc mv kd lh li bi translated">结论</h1><p id="df21" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果您试图创建一个具有复杂功能的扩展，希望本教程能对您有所帮助。关于消息传递的更深入的信息，<a class="ae np" href="https://developer.chrome.com/docs/extensions/mv3/messaging/" rel="noopener ugc nofollow" target="_blank"> Chrome文档</a>总是真实的来源。</p><p id="5903" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll ir"> <em class="of">感谢阅读！</em> </strong></p><p id="f7ea" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><em class="of">更多内容请看</em><a class="ae np" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="of">plain English . io</em></a></p></div></div>    
</body>
</html>