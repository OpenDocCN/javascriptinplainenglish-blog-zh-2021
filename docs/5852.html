<html>
<head>
<title>Should You Trust JavaScript Execution?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应该信任JavaScript执行吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/about-trusting-javascript-execution-8c6b478d6021?source=collection_archive---------2-----------------------#2021-12-15">https://javascript.plainenglish.io/about-trusting-javascript-execution-8c6b478d6021?source=collection_archive---------2-----------------------#2021-12-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9bb5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript是最动态的脚本编程语言之一。本文强调了与JS相关的安全问题。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2a7f0ae9a1d5672880cfc0a5cf8f4af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mhFixqCqk1bE_Ph1i2dQw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@cytonn_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Cytonn Photography</a> on <a class="ae ks" href="https://unsplash.com/s/photos/trust?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7f84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在脚本编程语言中，<em class="lp"> JS </em>无疑是最有活力的语言之一，或者更好地说，是一种可以定义、截取、覆盖几乎所有东西的语言，包括用于通过秘密/密码加密和解密任何东西的<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto" rel="noopener ugc nofollow" target="_blank">crypto . precious</a>命名空间。</p><p id="31da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一事实通常被低估了，除非我们从事的项目希望确保用户不会泄露数据，不会被采集指纹，不会在网上冲浪时受到间谍软件的攻击，等等。</p><p id="4244" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然肯定的是，“人们必须信任登陆在网站上的脚本”，或者你的后端项目，但现实是，广告行业，几乎没有人直接控制，从<em class="lp"> JS框架</em>开发者开始，会尽一切可能使我们的网上冲浪有利可图，它需要跟踪，cookies，或类似的变通办法，指纹，并不时地使用极其邪恶的代码(顺便说一句，我在这个领域工作，与邪恶的代码作斗争，我们每天也试图保护用户免受这些类型的利用)。</p><p id="a1a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过<em class="lp"> npm </em>或类似方式添加常规黑客尝试，我们就在这里了！</p><h2 id="d281" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">有多糟糕？</h2><p id="ba13" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">每个人都认为污染本地/内置原型应该被禁止，但这并不意味着不能这样做。此外，我们可以拥有这个世界上所有的林挺规则，但那只是关于我们的项目，而不是关于我们的软件将由T21执行的地方，我们能看出区别吗？</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="4ef3" class="lq lr in mp b gy mt mu l mv mw">const {[Symbol.iterator]: iterator} = Array.prototype;</span><span id="06db" class="lq lr in mp b gy mx mu l mv mw">Object.defineProperty(<br/>  Array.prototype,<br/>  Symbol.iterator,<br/>  {<br/>    value() {<br/>      console.log('MitM', this);<br/>      return iterator.call(this);<br/>      //             ^^^^^ keep reading<br/>    }<br/>  }<br/>);</span></pre><p id="fdc3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一小段代码将允许任何人设置它:</p><ul class=""><li id="9efb" class="my mz in kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">读取任何被调用的函数、方法或<code class="fe nh ni nj mp b">new Class(...args)</code>可能做的每个<code class="fe nh ni nj mp b">...spread</code>操作</li><li id="cd18" class="my mz in kv b kw nk kz nl lc nm lg nn lk no lo nd ne nf ng bi translated">阅读每一篇<code class="fe nh ni nj mp b">Array.from</code>操作</li><li id="1d32" class="my mz in kv b kw nk kz nl lc nm lg nn lk no lo nd ne nf ng bi translated">在每一个<code class="fe nh ni nj mp b">for/of</code>循环开始之前，或者在它发生的时候阅读它</li><li id="9729" class="my mz in kv b kw nk kz nl lc nm lg nn lk no lo nd ne nf ng bi translated">读取通过条目数组创建的每个<code class="fe nh ni nj mp b">Set</code>或<code class="fe nh ni nj mp b">Map</code></li><li id="7b5f" class="my mz in kv b kw nk kz nl lc nm lg nn lk no lo nd ne nf ng bi translated">拦截每一次<code class="fe nh ni nj mp b">const [value, update] = useState(init)</code>的使用，因为析构数组显然也会受到影响</li><li id="5cd5" class="my mz in kv b kw nk kz nl lc nm lg nn lk no lo nd ne nf ng bi translated">…等等…在使用web应用程序时，允许访问几乎所有类型的共享数据</li></ul><p id="d335" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们添加一个<code class="fe nh ni nj mp b">typeof</code>检查来过滤字符串，定义一些常见的(历史上丑陋的、无意义的、破碎的、愚蠢的……)<code class="fe nh ni nj mp b">/^[a-z0-9#$_+!?.-]{8,}$/i</code>reg exp，连同一个经典的<code class="fe nh ni nj mp b">/^[^@]+@\S+$/</code>，等瞧:<strong class="kv io">如果认证数据被传播，没有登录是安全的。</strong>🤯</p><p id="d085" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些类型的邪恶覆盖也可以写在代码后面，使其几乎不可能被检测到，通过污染<code class="fe nh ni nj mp b">Function.prototype.toString</code>和任何其他我们用来检测<code class="fe nh ni nj mp b">[native code]</code>是否存在的方法，所以基本上，先有邪恶，后有邪恶。</p><h1 id="110e" class="np lr in bd ls nq nr ns lv nt nu nv ly jt nw ju mb jw nx jx me jz ny ka mh nz bi translated">⚠️不仅阵</h1><p id="6b5b" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">这个<code class="fe nh ni nj mp b">Array.prototype</code>把戏已经很有趣了，但是人们也可以同样容易地毒害每一个原型(请不要这样做🙏):</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="e847" class="lq lr in mp b gy mt mu l mv mw">for (const key of Reflect.ownKeys(self)) {<br/>  // ignore non-classes maybe, typeof next!<br/>  if (!/^[A-Z]/.test(key))<br/>    continue;</span><span id="4d08" class="lq lr in mp b gy mx mu l mv mw">  const Builtin = self[key];<br/>  if (<br/>    typeof Builtin === 'function' &amp;&amp;<br/>    // ignore Proxy or others<br/>    'prototype' in Builtin &amp;&amp;<br/>    // filter by iterator presence<br/>    Builtin.prototype.hasOwnProperty(Symbol.iterator)<br/>  ) {<br/>    // trap it<br/>    const {[Symbol.iterator]: iterator} = Builtin.prototype;<br/>    // override<br/>    Object.defineProperty(<br/>      Builtin.prototype,<br/>      Symbol.iterator,<br/>      {<br/>        value() {<br/>          // win 🥳<br/>          console.log('MitM', this);<br/>          return iterator.call(this);<br/>          //             ^^^^^ keep reading<br/>        }<br/>      }<br/>    );<br/>  }<br/>}</span><span id="dadc" class="lq lr in mp b gy mx mu l mv mw">// tadaaaaaa 🎉<br/>[...new Set([1, 2, 3])]<br/>// two MitM logs for you</span></pre><p id="4635" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，是的，几乎每一个已知的事物都有可能被毒害，除了少数好人。🤠</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="d582" class="lq lr in mp b gy mt mu l mv mw">function noProblem() {<br/>  console.log(...arguments);<br/>}</span><span id="d983" class="lq lr in mp b gy mx mu l mv mw">// 1, 2, 3<br/>noProblem(1, 2, 3);</span><span id="af8c" class="lq lr in mp b gy mx mu l mv mw">const alsoNoProblem = (...args) =&gt; {<br/>  console.log.apply(console, args);<br/>  //         ^^^^^^ keep reading<br/>};</span><span id="0746" class="lq lr in mp b gy mx mu l mv mw">// 4, 5, 6<br/>alsoNoProblem(4, 5, 6);</span></pre><ul class=""><li id="158a" class="my mz in kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">对象不是一个数组，<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#browser_compatibility" rel="noopener ugc nofollow" target="_blank">它有自己的迭代器</a>已经有一段时间了，所以散布它是非常安全的🦄</li><li id="24d3" class="my mz in kv b kw nk kz nl lc nm lg nn lk no lo nd ne nf ng bi translated"><code class="fe nh ni nj mp b">...rest</code>参数只是引擎的语法提示，但在接收时不会被迭代，它们只是一个数组。然而，如果我们将它们展开，它们会通过<code class="fe nh ni nj mp b">Array.prototype</code>，因此如果我们将它们展开，不会发生任何变化；它仍然是不安全的，因此我们需要<em class="lp">申请</em>(然而，继续阅读)</li></ul><h1 id="9c7b" class="np lr in bd ls nq nr ns lv nt nu nv ly jt nw ju mb jw nx jx me jz ny ka mh nz bi translated">⚠️不仅是可写的</h1><p id="04c2" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">如果我们还在跟踪到底发生了什么，那么显而易见的是，毒害任何根原型都会提供极其强大的攻击，我相信99%的网站都不会想到这一点。让我们看另一个例子:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="106d" class="lq lr in mp b gy mt mu l mv mw">class User {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  auth(password) {<br/>    return fetch(<br/>      '/authenticate',<br/>      {<br/>        headers: {<br/>          Authorization: `Basic ${<br/>            btoa(`${this.name}:${password}`<br/>          )}`<br/>        }<br/>      }<br/>    );<br/>  }<br/>}</span></pre><p id="5de8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们快速列出这几行代码中所有可能出错的地方，好吗？</p><ul class=""><li id="30b9" class="my mz in kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated"><code class="fe nh ni nj mp b">Object.defineProperties(Object.prototype, {name, {get(){}, set(){}}, password: {get(){}, set(){}}, email: {get(){}, set(){}}})</code>可以在任何时候用来拦截所有愚蠢的类(包括mines ),这些类只是在构造函数中附加属性，根本不需要到达<code class="fe nh ni nj mp b">User</code>原型</li><li id="9a82" class="my mz in kv b kw nk kz nl lc nm lg nn lk no lo nd ne nf ng bi translated"><code class="fe nh ni nj mp b">fetch</code>全局函数可以被毒化以拦截任何类型的头，包括那些带有<em class="lp"> OAuth </em>凭证的头，或者更糟</li><li id="6437" class="my mz in kv b kw nk kz nl lc nm lg nn lk no lo nd ne nf ng bi translated"><code class="fe nh ni nj mp b">btoa</code>全局函数也会中毒，并拦截凭证</li></ul><p id="0efc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简而言之，我很抱歉以这种方式把事情搞成这样，但基本上，我们注定要失败。💣</p><h1 id="da20" class="np lr in bd ls nq nr ns lv nt nu nv ly jt nw ju mb jw nx jx me jz ny ka mh nz bi translated">⚠️不仅仅是JavaScript</h1><p id="893e" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">如果我们明白每一种针对JS的编程语言都会给我们无法控制的代码增加一个额外的间接层，从而使问题变得更大并且不容易解决，那么这一段就不需要了，但是因为我知道通常情况不是这样，所以让我们展示一些实际的例子。👍</p><h2 id="4aa3" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">以打字打的文件</h2><p id="5e76" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">生产中会有各种各样的变化，一旦发生变化，就会有<strong class="kv io">零额外信任</strong> <em class="lp"> TS </em>带到桌面上，实际上完全相反:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="e82f" class="lq lr in mp b gy mt mu l mv mw">//TS<br/>class User {<br/>  public name = '';<br/>  private pass = '';<br/>}</span><span id="e4d5" class="lq lr in mp b gy mx mu l mv mw">// becomes this JS: busted<br/>class User {<br/>    constructor() {<br/>        this.name = '';<br/>        this.pass = '';<br/>    }<br/>}</span></pre><p id="f6c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">公共和私有字段都成为<code class="fe nh ni nj mp b">constructor</code>潜在的设置者，因此任何拦截这些属性的恶意代码都可以在运行时毒害实例，以便随时检索名称和密码。</p><p id="38c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“<em class="lp">很公平</em>”，我听到有人在喊，“<em class="lp">那我就用真的私处吧！</em>“，确定！</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="79c3" class="lq lr in mp b gy mt mu l mv mw">// TS<br/>class User {<br/>  name = '';<br/>  #pass = '';<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="0939" class="lq lr in mp b gy mx mu l mv mw">// becomes this JS: busted<br/>var _User_pass;<br/>class User {<br/>    constructor(name) {<br/>        this.name = '';<br/>        _User_pass.set(this, '');<br/>        this.name = name;<br/>    }<br/>}<br/>_User_pass = new WeakMap();</span></pre><p id="b93c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是今天TS在其最新的游戏中提供给我的默认设置，目标是ES2017，这是一个非常明智的目标。(阅读:请不要把重点放在“<em class="lp">但ESNext目标是纯粹的</em>”废话，谢谢！)</p><p id="ca1b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着任何在任何时间点污染了<code class="fe nh ni nj mp b">WeakMap.prototype.set</code>方法的邪恶代码，将能够准确地拦截所有那些我们不想暴露的私有变量或实例…这有多"<em class="lp">伟大</em>"啊？😢</p><p id="6aa3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我可以继续说一段时间:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="dddd" class="lq lr in mp b gy mt mu l mv mw">// TS<br/>function merge(a:object, b:object) {<br/>  return {...a, ...b};<br/>}</span><span id="afe1" class="lq lr in mp b gy mx mu l mv mw">// becomes this JS: busted<br/>function merge(a, b) {<br/>    return Object.assign(Object.assign({}, a), b);<br/>}</span></pre><p id="39e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，如果任何邪恶的代码会毒害<code class="fe nh ni nj mp b">Object.assign</code>，那么所有的<em class="lp"> TS </em>实例都将被轻易地暴露出来，因此其他所有成为<code class="fe nh ni nj mp b">Global.utility(...args)</code>调用的事情也是如此。</p><h2 id="f3f6" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">镖</h2><p id="aeaa" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">老实说，我不知道Dart的生态系统，也不知道疯狂的JS脚本是否会不被注意地进入100%的Dart项目，但毫无疑问，它的运行时充满了潜在的攻击。</p><p id="625b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，如果我们美化我能找到的最基本的示例输出:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="c156" class="lq lr in mp b gy mt mu l mv mw">void main() {<br/>  for (int i = 0; i &lt; 5; i++) {<br/>    print('hello ${i + 1}');<br/>  }<br/>}</span></pre><p id="f240" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们会注意到，整个JS Dart的运行时重复访问每个全局<code class="fe nh ni nj mp b">Object</code>实用程序，包括<code class="fe nh ni nj mp b">defineProperty</code>和其他。</p><p id="0496" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不过有趣的是，Dart的运行时似乎没有遇到我们之前讨论的<code class="fe nh ni nj mp b">Symbol.iterator</code>问题，主要是因为它的代码似乎也针对旧浏览器，但它也做诸如<code class="fe nh ni nj mp b">Array.prototype.push.apply(target, arguments)</code>的操作，退回到“<em class="lp">一切容易暴露的</em>类别，就像<em class="lp"> TypeScript </em>。</p><p id="ecb0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">"<em class="lp">等等……为什么呼叫或申请不安全？“谢谢你的关心。😎</em></p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="8b44" class="lq lr in mp b gy mt mu l mv mw">const {call} = Function.prototype;<br/>Object.defineProperty(<br/>  Function.prototype,<br/>  'call',<br/>  {<br/>    value(context, ...args) {<br/>      console.log(context, args);<br/>      return call.apply(this, [context, ...args]);<br/>    }<br/>  }<br/>);</span></pre><p id="517e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我想强调的是，通过JS原语传递的所有东西都可能以这样或那样的方式中毒:这清楚吗？</p><h2 id="9e9b" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">Node.js &amp; Deno</h2><p id="1778" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">是的伙计们，<strong class="kv io">是的</strong>！我所说的一切都源于ECMAScript规范，并不局限于浏览器，它只是关于JavaScript是如何定义的，以及它如何工作了20多年！</p><h2 id="f758" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">…甚至巴贝尔？</h2><p id="028f" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">哦，看在上帝的份上，是的！</p><h2 id="bd7a" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">好吧…那么，外面有什么安全的地方吗？</h2><p id="ae4b" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">可能有，但是因为没有人足够重视这个被最广泛部署的编程语言低估的安全问题，简短的答案是<strong class="kv io">不</strong>，但是我们可以做得更好，更安全地保护我们的环境，只要多信任我们的代码一点点，它只需要4行代码，至少作为起点。🌈</p><h1 id="664b" class="np lr in bd ls nq nr ns lv nt nu nv ly jt nw ju mb jw nx jx me jz ny ka mh nz bi translated">功能陷阱缓解</h1><p id="9af3" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">我已经在10多年前提到过这种技术<a class="ae ks" href="https://webreflection.blogspot.com/2011/10/bind-apply-and-call-trap.html" rel="noopener ugc nofollow" target="_blank">，要点是</a><a class="ae ks" href="https://github.com/WebReflection/proxy-pants/blob/main/esm/function.js#L3-L6" rel="noopener ugc nofollow" target="_blank">我们可以捕获最原始的实用程序来调用任何东西，这样在运行时就不会有任何干扰:</a></p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="3aeb" class="lq lr in mp b gy mt mu l mv mw">const {apply: a, bind: b, call: c} = Function;<br/>const apply = c.bind(a);<br/>const bind = c.bind(b);<br/>const call = c.bind(c);</span></pre><p id="9e0d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，我们现在可以捕获我们喜欢的每个类的<code class="fe nh ni nj mp b">Symbol.iterator</code>生成器，以便我们可以直接调用它来迭代:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="2999" class="lq lr in mp b gy mt mu l mv mw">const {[Symbol.iterator]: iterator} = Array.prototype;<br/>const iterate = arr =&gt; call(iterator, arr);</span><span id="dfc8" class="lq lr in mp b gy mx mu l mv mw">// example<br/>for (const safe of iterate([1, 2, 3]));</span></pre><p id="aa98" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们现在可以<code class="fe nh ni nj mp b">iterate([literally, any, array, value])</code>并且100%确定没有任何东西可以拦截传递的参数，只要我们的陷阱在任何可能的恶意代码之前<strong class="kv io">就存在。幸运的是，基于广告的脚本笨重，因此，很少作为第一个阻止脚本加载，特别是由于搜索引擎的排名，这是一个惩罚这种笨重，缓慢和阻止脚本的指标。</strong></p><p id="efdf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，实际上不能保证我们的代码在任何其他代码之前运行，特别是在这个世界上，每个人都迫不及待地使用最新的工具/捆绑器，而且一旦整个事情产生了一个输出，几乎没有人知道什么会进入生产中…我们做得很好！🤝</p><h2 id="8ce2" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">保护任何东西</h2><p id="46b3" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">如果我们理解了<code class="fe nh ni nj mp b">iterate(array)</code>是如何工作的，我们也可以探索<code class="fe nh ni nj mp b">bind</code>的用法，通过它的所有者来保护任何方法:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="a1c2" class="lq lr in mp b gy mt mu l mv mw">// defining literals is always safe 🍻<br/>// and so is the access to own properties<br/>const obj = {<br/>  name: 'safe',<br/>  method() {<br/>    console.log(this.name);<br/>  }<br/>};</span><span id="1699" class="lq lr in mp b gy mx mu l mv mw">const method = bind(obj.method, obj);<br/>method(); // "safe"</span></pre><p id="2581" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样的事情也可以一劳永逸地发生在公共事业上:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="100c" class="lq lr in mp b gy mt mu l mv mw">const assign = bind(Object.assign, Object);<br/>const entries = bind(Object.entries, Object);</span></pre><p id="9261" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然，我们可以想象为我们需要的每一个该死的全局实用程序这样做可能会非常耗时，这就是为什么我创建了<a class="ae ks" href="https://github.com/WebReflection/proxy-pants#readme" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> proxy-pants </strong> </a>，这是一个友好的树摇动模块，充满了罕见的常见用例，以一种安全的方式一次性绑定方法或访问器。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="6a38" class="lq lr in mp b gy mt mu l mv mw">import {bound} from 'proxy-pants';</span><span id="66d1" class="lq lr in mp b gy mx mu l mv mw">const {<br/>  assign,<br/>  entries,<br/>  defineProperty,<br/>  getPrototypeOf<br/>} = bound(Object);</span></pre><p id="8e4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">清楚了吗？我们传递任何实例或全局实用程序，从现在开始，我们需要做的就是直接使用<code class="fe nh ni nj mp b">assign({}, a, b)</code>或<code class="fe nh ni nj mp b">entries(ref)</code>，而不必担心恶意代码。😇</p><p id="10d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">等等，你是在问<em class="lp">访问者</em>吗？好吧，这里有一个例子:</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="4eb0" class="lq lr in mp b gy mt mu l mv mw">import {accessor} from 'proxy-pants';<br/><br/>const {textContent} = accessor(document.body);<br/><br/>// get the current body text<br/>textContent();<br/><br/>// set the new one<br/>textContent('proxy pants!');</span></pre><p id="4dbf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">调用方</em>还是<em class="lp">应用方</em>？没问题！</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="3211" class="lq lr in mp b gy mt mu l mv mw">import {applier, caller} from 'proxy-pants';<br/><br/>const {hasOwnProperty, toString} = caller(Object.prototype);<br/><br/>hasOwnProperty({any: 'object'}, 'any'); // true<br/>toString(null); // [object Null]<br/><br/>const {fromCharCode} = applier(String);<br/>const charCodes = (...args) =&gt; fromCharCode(String, args);</span><span id="ef15" class="lq lr in mp b gy mx mu l mv mw">charCodes(60, 61, 62); // &lt;=&gt;</span></pre><p id="4ab2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">TL；DR </em>我已经写了各种库和助手，围绕这个“<em class="lp">安全和可信执行</em>”和<a class="ae ks" href="https://github.com/WebReflection/proxy-pants#readme" rel="noopener ugc nofollow" target="_blank"> proxy-pants </a>包括这些技术，因为我们已经测试过这些技术在野外工作，我们的用户可以睡得更好，肯定更安全，所以如果你想至少保护你的代码的最关键部分，请随意使用这个库😉</p><h1 id="ab42" class="np lr in bd ls nq nr ns lv nt nu nv ly jt nw ju mb jw nx jx me jz ny ka mh nz bi translated">🎯行动建议</h1><p id="674a" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">我真的希望没有人应该编写像<code class="fe nh ni nj mp b">[...call(iterator, arr)]</code>这样的<em class="lp">颠倒的代码</em>，或者甚至<code class="fe nh ni nj mp b">[...iterate(arr)]</code>，而不是自然的<code class="fe nh ni nj mp b">[...arr]</code>操作，好的一面是<strong class="kv io">没有人需要重构任何东西</strong>或者改变他们的代码基础，或者删除<em class="lp">类型脚本</em>，或者<em class="lp"> Dart </em>，以便能够控制他们的应用程序的安全级别，除了之外的<strong class="kv io">可能是核心库作者，或者关于安全、密码、安全的库已经了解并关注我的人，不应该对我从头开始编写几乎所有类型的模块这一事实感到惊讶，在这篇文章中，你可以找到我这样做的几个原因:Web开发人员很少把安全问题看得非常严重，但是尽管许多人经常欺负仍然编写普通JS的人，而不是使用我们现在拥有的任何间接方式， 我想提醒你的是，那些为你的超级酷的安全的JS代码创建transpilers的人，通常也不会对这些细节给予足够的关注，所以你在那里运行的任何代码，都可能容易受到我在这篇文章中描述的所有攻击。</strong></p><h2 id="cb34" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">最后但同样重要的是:性能！</h2><p id="dedd" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">当涉及到增加安全性时，关键路径上稍微慢一点的代码不应该是决定性因素，但是也就是说，很难衡量<code class="fe nh ni nj mp b">[...call(iterator, arr)]</code>和<code class="fe nh ni nj mp b">[...arr]</code>之间的差异，后者需要解析其原型和迭代器，而前者是作用域中众所周知的引用，不需要原型解析。🤘</p><h2 id="eab9" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">…但也…</h2><p id="4335" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">你可以完全否认我在这里写的一切，特别是因为我敢于触及<em class="lp"> TypeScript </em>或<em class="lp"> Dart </em>最令人痛苦的一点，即缺乏对翻译目标的控制，但这篇文章的整个目标是让<strong class="kv io">你</strong>意识到这些类型的攻击是存在的，尤其是对翻译的代码，所以你更好地理解如何减轻这些，你可能已经用ts或dart🥂做到了这一点</p><h2 id="cfb1" class="lq lr in bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">作为总结</h2><p id="f2f1" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc ml le lf lg mm li lj lk mn lm ln lo ig bi translated">只需编写您喜欢的代码，做您喜欢的事情，但是如果安全性是一个问题，请注意有一些模式可以防止运行时库破坏您的产品，并且记住我已经写了很多解决方案，我非常乐意帮助您保护更多您关心的<em class="lp">特定部分，如果有意义的话，希望其余部分不会泄漏或不安全。👋</em></p><p id="8501" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢您的阅读。</p><p id="4aa5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lp">plain English . io</em></a><em class="lp">。在这里报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">免费周报</em> </a> <em class="lp">。</em></p></div></div>    
</body>
</html>