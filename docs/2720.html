<html>
<head>
<title>15 Things To Cover When Writing Unit Tests in Jasmine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jasmine编写单元测试时要注意的15件事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/15-things-to-cover-when-writing-unit-tests-in-jasmine-b309e0c27115?source=collection_archive---------3-----------------------#2021-06-04">https://javascript.plainenglish.io/15-things-to-cover-when-writing-unit-tests-in-jasmine-b309e0c27115?source=collection_archive---------3-----------------------#2021-06-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="08f6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解一些我认为每个开发人员在用Jasmine编写单元测试时应该涉及的内容。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e13cfbdae35e1dfc1b9099bb35c257db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L334tY40QbIp6CYdiyeOVw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://www.pexels.com/@markusspiske?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">Markus Spiske</strong></a> from <a class="ae ks" href="https://www.pexels.com/photo/text-2004161/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">Pexels</strong></a></figcaption></figure><p id="133a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在这篇文章中，我将分享你在Jasmine中为Angular应用程序编写单元测试时可以做的15件事。</p><h2 id="36a3" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated"><strong class="ak">内容</strong></h2><ol class=""><li id="6c79" class="mj mk in kw b kx ml la mm ld mn lh mo ll mp lp mq mr ms mt bi translated"><a class="ae ks" href="#848a" rel="noopener ugc nofollow"> <strong class="kw io">测试功能被称为</strong> </a></li><li id="13ca" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#1ea9" rel="noopener ugc nofollow"> <strong class="kw io">检测字段被更新</strong> </a></li><li id="0bcf" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#e308" rel="noopener ugc nofollow"> <strong class="kw io">测试功能结果</strong> </a></li><li id="402a" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#e5ec" rel="noopener ugc nofollow"> <strong class="kw io">测试Getters和setter</strong></a></li><li id="a3c2" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#cbb1" rel="noopener ugc nofollow"> <strong class="kw io">测试订阅量和可观察量</strong> </a></li><li id="862c" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#c8d2" rel="noopener ugc nofollow"> <strong class="kw io">测试自己的异步函数</strong> </a></li><li id="d63a" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#7816" rel="noopener ugc nofollow"> <strong class="kw io">测试导航</strong> </a></li><li id="8ace" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#5104" rel="noopener ugc nofollow"> <strong class="kw io">测试模态</strong> </a></li><li id="0954" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#12cd" rel="noopener ugc nofollow"> <strong class="kw io">测试本地存储</strong> </a></li><li id="2da6" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#9c1d" rel="noopener ugc nofollow"> <strong class="kw io">测试上推组件</strong> </a></li><li id="702a" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#e407" rel="noopener ugc nofollow"> <strong class="kw io">测试变化检测器</strong> </a></li><li id="699f" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#0436" rel="noopener ugc nofollow"> <strong class="kw io">测试构造函数中的</strong> </a></li><li id="a42f" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#f943" rel="noopener ugc nofollow"> <strong class="kw io">测试构造函数中的变化检测器</strong> </a></li><li id="4174" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#d213" rel="noopener ugc nofollow"> <strong class="kw io">测试<em class="mz">不可变. js </em>数据</strong> </a></li><li id="87eb" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#c6f0" rel="noopener ugc nofollow"> <strong class="kw io">用测试线束测试第三方组件</strong> </a></li></ol><h2 id="848a" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated"><strong class="ak"> 1。测试功能被称为</strong></h2><p id="52b7" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">可能最常见的单元测试是测试一个函数在另一个函数中被调用。它可以是组件或服务上的功能。为此，我们在我们期望被调用的函数上创建一个spy，并使用<code class="fe nd ne nf ng b"><strong class="kw io">toHaveBeenCalledWith()</strong></code>监听和检查它是否被调用</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e9f9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您也可以使用<code class="fe nd ne nf ng b"><strong class="kw io">not.toHaveBeenCalledWith()</strong></code>检查函数是否被调用</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1ff4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你也不必把间谍的结果赋给一个变量。你可以用这种方式来检查间谍</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6753" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您也可以通过将间谍的返回类型设置为<code class="fe nd ne nf ng b"><strong class="kw io">any</strong></code>并使用对象键符号而不是点符号来获取对函数的引用来监视私有函数，如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="1ea9" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">2.测试字段已更新</h2><p id="be5d" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">可能第二个最常见的测试是测试组件字段的值在某个函数被调用后是否被更新。</p><p id="0b31" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">首先，我们初始化该字段的值，然后执行函数并检查新值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="e308" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">3.测试功能结果</h2><p id="af9e" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">您还需要检查您的函数是否为不同的输入产生了正确的结果。您只想检查键值，但要由您来决定尝试什么和多少输入，尝试所有不同的可能组合是浪费时间。</p><p id="90bc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您的单元测试可能如下所示。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="e5ec" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">4.测试吸气剂和沉降剂</h2><p id="c028" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">您也可以测试组件中的吸气剂和沉降剂。假设我们有下面的getter函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1735" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您可以像调用任何其他函数一样在您的单元测试中调用getter，但是不要像这样在末尾添加括号</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f9e0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您也可以测试setter函数。假设您有以下设置程序。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="135c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您可以通过给单元测试赋值来调用设置器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="cbb1" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">5.测试订阅和可观察项</h2><p id="ac6c" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">当可观测值发出新值时，您可以测试调用了正确的函数并且更新了正确的字段。</p><p id="4956" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">当测试异步代码时，您需要等待一个可观察的完成并完成发射值，或者等待某个时间<code class="fe nd ne nf ng b"><strong class="kw io">x</strong></code>它发射下一个值，然后您需要在<code class="fe nd ne nf ng b"><strong class="kw io">fakeAsync()</strong></code>中包装您的单元测试并使用<code class="fe nd ne nf ng b"><strong class="kw io">tick().</strong></code>这模拟时间的流逝并跳到所有异步代码完成的时候，或者某个时间以后的<code class="fe nd ne nf ng b"><strong class="kw io">x </strong></code>。然后，您可以直接测试结果，实际上不必等待观察到的结果。您的单元测试将如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c329" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">处理异步代码的旧方法是将测试包装在<code class="fe nd ne nf ng b"><strong class="kw io">async()</strong></code> <strong class="kw io"> </strong>中，并使用<code class="fe nd ne nf ng b"><strong class="kw io">fixture.whenStable().then(() =&gt; {})</strong></code> <strong class="kw io"> </strong>实际上等待所有当前活动的订阅完成。新的方法使这些可观察到的东西立即发出它们的值，并加速你的单元测试。</p><p id="7f44" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设我们有下面的例子，当用户在最后半秒钟没有在搜索输入中键入任何内容时，我们使用<code class="fe nd ne nf ng b"><strong class="kw io">debounceTime(500)</strong></code>调用函数<code class="fe nd ne nf ng b"><strong class="kw io">getFirstPage()</strong> </code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="99db" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们需要在<code class="fe nd ne nf ng b"><strong class="kw io">fakeAsync()</strong></code>中包装我们的测试，发出一个新值，然后使用<code class="fe nd ne nf ng b"><strong class="kw io">tick(500)</strong></code> <strong class="kw io">等待半秒钟。然后我们可以检查是否已经调用了<code class="fe nd ne nf ng b"><strong class="kw io">getFirstPage()</strong></code>。使用<code class="fe nd ne nf ng b"><strong class="kw io">tick()</strong></code> <strong class="kw io"> </strong>而不指定一个值是行不通的，因为管道<code class="fe nd ne nf ng b"><strong class="kw io">debounceTime()</strong></code>永远不会完成它自己，并将继续发出新的值，所以我们需要跳过一段时间。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7310" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你用完全相同的方式测试<code class="fe nd ne nf ng b"><strong class="kw io">setTimeout(() =&gt; {},x)</strong></code>。你需要通过使用<code class="fe nd ne nf ng b"><strong class="kw io">tick(x)</strong></code> <strong class="kw io">在单元测试中等待函数被调用。</strong></p><h2 id="c8d2" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">6.测试您自己的异步函数</h2><p id="b290" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">您还可以测试自己的异步函数，这些函数返回一个可观察的。这最常用于测试当您进行API调用时会发生正确的事情。假设在组件<code class="fe nd ne nf ng b"><strong class="kw io">ngOnInit()</strong></code>初始化期间订阅了一个异步函数，如下所示。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="15a2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们需要检查函数<code class="fe nd ne nf ng b"><strong class="kw io">handleData()</strong></code>是否被调用，字段<code class="fe nd ne nf ng b"><strong class="kw io">data</strong></code>是否被设置。</p><p id="7ee5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们首先需要确保订阅是通过调用<code class="fe nd ne nf ng b"><strong class="kw io">ngOnInit()</strong></code>创建的。在这种情况下，当您创建组件时，这已经在组件初始化期间被调用，这应该已经在<code class="fe nd ne nf ng b"><strong class="kw io">beforeEach()</strong></code>块中完成。</p><p id="e975" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在我们需要释放一个新的价值。有两种方法可以做到这一点，通过在我们的测试中创建一个主题，并使用一个spy来临时使<code class="fe nd ne nf ng b"><strong class="kw io">getData()</strong></code> <strong class="kw io"> </strong>返回这个主题或它的可观察对象。然后我们可以用这个主题来产生一个新的价值。我们也可以编辑我们模仿的<code class="fe nd ne nf ng b"><strong class="kw io">apiService</strong></code> <strong class="kw io"> </strong>并在其中创建一个新的私有主题，然后更改<code class="fe nd ne nf ng b"><strong class="kw io">getData()</strong></code> <strong class="kw io"> </strong>使其返回该主题的可观察值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5830" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">然后在单元测试中，我们只需抓取我们刚刚创建的主题<code class="fe nd ne nf ng b"><strong class="kw io">getDataSubject</strong></code> <strong class="kw io"> </strong>并发出一个新值。检查<code class="fe nd ne nf ng b"><strong class="kw io">handleData()</strong></code>函数是否被调用的单元测试可能如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="7816" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">7.测试导航</h2><p id="4e30" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">为了测试Angular应用程序中的导航路线是否正确，您首先需要设置您的测试环境，以使用与生产应用程序相同的导航路线，这可以在您的测试床上使用<code class="fe nd ne nf ng b"><strong class="kw io">RouterTestingModule</strong></code>来完成。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0411" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设我们有以下路由，并想测试我们是否可以导航到/home路径。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5d54" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在单元测试中，我们将认证服务的<code class="fe nd ne nf ng b"><strong class="kw io">canActivate()</strong></code>方法设置为返回true，这样用户就可以导航到这个路径。然后我们尝试使用<code class="fe nd ne nf ng b"><strong class="kw io">router.navigate()</strong></code> <strong class="kw io"> </strong>进行导航，以检查/home是否是有效路线。然后使用tick等待导航完成。单元测试看起来会像这样</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="5104" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">8.测试模型</h2><p id="97b9" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">当我们处理一个使用模态的组件时，我们需要确保模态首先被显示，否则当我们试图使用<code class="fe nd ne nf ng b"><strong class="kw io">querySelector()</strong></code>获取它时，我们什么也找不到。</p><p id="f229" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在包含模态的组件的单元测试文件中，在<code class="fe nd ne nf ng b"><strong class="kw io">beforeEach()</strong></code> <strong class="kw io"> </strong>块中，您可以确保<code class="fe nd ne nf ng b"><strong class="kw io">display</strong></code> CSS属性设置正确，并应用您需要的任何类来使模态出现。然后再次调用<code class="fe nd ne nf ng b"><strong class="kw io">detectChanges()</strong></code>更新UI。现在你可以使用<code class="fe nd ne nf ng b"><strong class="kw io">querySelector()</strong></code> <strong class="kw io"> </strong>从UI中抓取模态。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="12cd" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">9.测试本地存储</h2><p id="04a6" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">您也可以在单元测试中测试本地存储。我们实际上并不测试本地存储是否返回并保存正确的值，而是测试函数本身是否被调用。</p><p id="6c34" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了测试一个函数是否保存了一些东西到本地存储器，你可以检查是否用正确的键和值调用了<code class="fe nd ne nf ng b"><strong class="kw io">setItem()</strong></code>函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a16e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了测试一个函数从本地存储中加载了什么，你可以检查是否用正确的键调用了<code class="fe nd ne nf ng b"><strong class="kw io">getItem()</strong></code>函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="9c1d" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">10.测试推送组件</h2><p id="f6af" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">推式组件是那些将变更检测策略设置为<code class="fe nd ne nf ng b"><strong class="kw io">OnPush</strong></code>的组件。这意味着只有当字段被分配了新的引用时，UI才会自动更新，并且如果字段的值被更改，UI不会总是更新。</p><p id="b9b1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">因此，如果像字符串这样的不可变字段被更新，它就会更新，但如果像数组这样的可变字段被更新，它就不会更新。这有助于防止UI随着每一个微小的变化而不断更新，最终使它变得更加反应迟钝。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0dbc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">目前，有一个长期悬而未决的问题，能够测试推组件在角度。当你使用<code class="fe nd ne nf ng b"><strong class="kw io">componentFixture.detectChanges()</strong></code>时，它只在你第一次使用时更新用户界面，之后就不再工作了。</p><p id="e6a3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><a class="ae ks" href="https://github.com/angular/angular/issues/12313" rel="noopener ugc nofollow" target="_blank">https://github.com/angular/angular/issues/12313</a></p><p id="d7c3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这意味着目前不可能测试按下行为。目前我们唯一能做的就是完全禁用单元测试中的推送功能，并在设置测试平台时，将单元测试中的变更检测策略设置回默认值。至少这样您可以继续其他单元测试，因为<code class="fe nd ne nf ng b"><strong class="kw io">componentFixture.detectChanges()</strong></code> <strong class="kw io"> </strong>将再次正确工作。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="e407" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">11.测试变化检测器</h2><p id="b26c" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">当组件字段更新时，更改检测器自动更新UI，但是您可以通过分离更改检测器并调用<code class="fe nd ne nf ng b"><strong class="kw io">detectChanges()</strong></code>手动更新UI来更改它，以便它仅在您想要时更新。这有助于保持应用程序的响应性，因为在每次小的更改后都不会重新加载数据。</p><p id="bbc2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">例如，我们可能有下面的代码，其中我们加载一些数据，最后，我们更新用户界面。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e6fc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是如果我们在组件中分离变更检测器，那么在单元测试中使用<code class="fe nd ne nf ng b"><strong class="kw io">componentFixture.detectChanges()</strong></code>将不再有效。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2bcc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">相反，我们需要获取对组件中使用的变化检测器的引用，并在其上调用<code class="fe nd ne nf ng b"><strong class="kw io">detectChanges()</strong></code> <strong class="kw io"> </strong>，如下所示。</p><pre class="kd ke kf kg gt nj ng nk nl aw nm bi"><span id="e5b1" class="lq lr in ng b gy nn no l np nq"><strong class="ng io">component['_cdr'].detectChanges();</strong></span></pre><p id="c41a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">另外，如果您想测试在您的组件中调用了<code class="fe nd ne nf ng b"><strong class="kw io">detectChanges()</strong></code>方法，您可以像这样在您的单元测试中监视变更检测器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="0436" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">12.在构造函数中测试函数</h2><p id="c4fd" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">您可能希望在组件的构造函数期间调用测试函数，但是构造函数只在您创建组件时调用一次，这通常在单元测试运行之前在<code class="fe nd ne nf ng b"><strong class="kw io">beforeEach()</strong></code>块中完成。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7275" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这使得在构造函数中测试任何东西变得不可能，但是我们能做的就是在单元测试中使用测试床创建另一个组件。这将至少允许我们测试任何正在使用的服务。</p><p id="04da" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设我们有下面这个名为<code class="fe nd ne nf ng b"><strong class="kw io">MyComponent</strong></code>的组件的构造函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bc49" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们首先监视测试中使用的服务的功能<code class="fe nd ne nf ng b"><strong class="kw io">getData()</strong></code>，然后使用测试床创建一个使用相同服务的新组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="f943" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">13.测试构造函数中的变化检测器</h2><p id="6cae" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">我们已经看到了如何编写单元测试来检查UI是否更新。但是假设我们在构造过程中更新UI或者分离变更检测器，我们之前做的就不行了。</p><p id="9ffc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">相反，我们需要使用组件的服务注入器获取对变更检测器服务的引用，然后我们可以窥探变更检测器的功能。假设我们有下面这个名为<code class="fe nd ne nf ng b"><strong class="kw io">MyComponent</strong></code>的组件的构造函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b069" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">检查变更检测器是否被分离的单元测试将是</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="d213" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">14.测试<em class="nr">不可变. js </em>数据</h2><p id="fd40" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">当您使用immutable.js库时，您可能会遇到试图使值相等的问题。这是因为使用的数据结构不同。假设我们有下面的单元测试，其中我们试图使用<code class="fe nd ne nf ng b"><strong class="kw io">toEqual()</strong></code>使一些数据相等。以下测试不起作用。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d0c3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了解决这个问题，我们需要使用不可变. js库中的等式操作符<code class="fe nd ne nf ng b"><strong class="kw io">is()</strong></code>，如下所示。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="c6f0" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">15.使用测试工具测试第三方组件</h2><p id="c733" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld na lf lg lh nb lj lk ll nc ln lo lp ig bi translated">Angular 9中引入了组件工具，它为用户提供了一种简单的方法来测试他们的应用程序在使用你创建的组件时是否工作正常。</p><p id="19f4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">组件线束需要由组件库(如Angular Material)的作者创建，因此可能不适用于所有库。</p><p id="ece7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">之前，您需要知道组件的具体实现和结构，以便找到并获取它显示的标签，并通过使用大量查询来检查它的设置是否正确。例如<code class="fe nd ne nf ng b"><strong class="kw io">fixture.debugElement.query()</strong></code></p><p id="b105" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">组件装具现在允许您通过使用装具上的一个属性轻松地获取这个标签，并且您不再需要担心您的测试在它们对组件进行任何更改时会中断。</p><p id="b155" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您使用HarnessLoader来获取组件的线束，然后您可以轻松地获取不同的属性并轻松地模拟用户交互，例如用户通过简单地调用一个方法来单击和选择下拉列表中的选项。</p><p id="dc46" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="mz">更多内容看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mz">plain English . io</em></a></p></div></div>    
</body>
</html>