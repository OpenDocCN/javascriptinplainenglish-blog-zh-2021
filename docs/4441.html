<html>
<head>
<title>What is the Equivalent of the componentDidMount Method in a React Function/Hooks Component?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在反应函数/钩子组件中，什么是组件安装方法的等价物？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-the-equivalent-of-the-componentdidmount-method-in-a-react-function-hooks-component-703df5aed7f6?source=collection_archive---------8-----------------------#2021-09-04">https://javascript.plainenglish.io/what-is-the-equivalent-of-the-componentdidmount-method-in-a-react-function-hooks-component-703df5aed7f6?source=collection_archive---------8-----------------------#2021-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/52936a7f69ec37756ccd9a44e1ff47bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vox3Md1Vjn3_NN7O"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@_yero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Yero</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="23d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们用类创建反应组件时，我们运行我们的代码，当组件装入<code class="fe lb lc ld le b">componentDidMount</code>钩子时加载。</p><p id="a545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，对于反应组件，这是不可用的。</p><p id="f469" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何使用React函数组件中的<code class="fe lb lc ld le b">componentDidMount</code>钩子产生相同的结果。</p><h1 id="bc3e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">useEffect钩子</h1><p id="2ca1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">只有当组件挂载时才能运行代码，我们可以使用<code class="fe lb lc ld le b">useEffect</code>钩子。</p><p id="533a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们传入一个空数组作为第二个参数，那么第一个参数中的<code class="fe lb lc ld le b">useEffect</code>回调将只在组件挂载时运行。</p><p id="e5eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e03a" class="mq lg iq le b gy mr ms l mt mu">import React, { useEffect } from "react";</span><span id="81c1" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  useEffect(() =&gt; {<br/>    console.log("mounted");<br/>  }, []);</span><span id="81e5" class="mq lg iq le b gy mv ms l mt mu">  return &lt;div className="App"&gt;&lt;/div&gt;;<br/>}</span></pre><p id="1fa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们应该只在安装组件时看到记录的<code class="fe lb lc ld le b">'mounted'</code>字符串。</p><h1 id="253f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">反应挂钩等同于组件更新</h1><p id="5764" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">componentDidUpdate</code>生命周期方法的等价物也是<code class="fe lb lc ld le b">useEffect</code>钩子。</p><p id="9193" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">componentDidUpdate</code>当状态或道具改变值时运行。</p><p id="5931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以对<code class="fe lb lc ld le b">useEffect</code>做同样的事情，将我们想要观察的状态或属性值传递到数组中，就像传递到<code class="fe lb lc ld le b">useEffect</code>的第二个参数中一样。</p><p id="eaa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ad64" class="mq lg iq le b gy mr ms l mt mu">import React, { useEffect, useState } from "react";</span><span id="dd5c" class="mq lg iq le b gy mv ms l mt mu">const Count = ({ count }) =&gt; {<br/>  useEffect(() =&gt; {<br/>    console.log(count);<br/>  }, [count]);</span><span id="176e" class="mq lg iq le b gy mv ms l mt mu">  return &lt;p&gt;{count}&lt;/p&gt;;<br/>};</span><span id="50d2" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const [count, setCount] = useState(0);</span><span id="1dd2" class="mq lg iq le b gy mv ms l mt mu">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;increment&lt;/button&gt;<br/>      &lt;Count count={count} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="255c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe lb lc ld le b">Count</code>组件中的<code class="fe lb lc ld le b">useEffect</code>挂钩观察<code class="fe lb lc ld le b">count</code>支柱的更新。</p><p id="03a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要观察一种状态，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a034" class="mq lg iq le b gy mr ms l mt mu">import React, { useEffect, useState } from "react";</span><span id="43dc" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const [count, setCount] = useState(0);</span><span id="f84a" class="mq lg iq le b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    console.log(count);<br/>  }, [count]);</span><span id="ff67" class="mq lg iq le b gy mv ms l mt mu">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;increment&lt;/button&gt;<br/>      &lt;p&gt;{count}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="fd7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lb lc ld le b">useEffect</code>钩同样的方式观察<code class="fe lb lc ld le b">count</code>状态。</p><h1 id="e967" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">等效于组件的反作用挂钩将卸载</h1><p id="3806" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">反应类组件中的<code class="fe lb lc ld le b">componentWillUnmount</code>生命周期方法允许我们在卸载组件时运行代码。</p><p id="6c11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以再次用<code class="fe lb lc ld le b">useEffect</code>钩子做同样的事情。</p><p id="2d61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要在<code class="fe lb lc ld le b">useEffect</code>回调中返回一个函数就可以了。</p><p id="6a94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回的函数将在组件卸载时运行。</p><p id="962b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0a5b" class="mq lg iq le b gy mr ms l mt mu">import React, { useEffect } from "react";</span><span id="0c57" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  useEffect(() =&gt; {<br/>    console.log("mounted");<br/>    return () =&gt; {<br/>      console.log("unmounted");<br/>    };<br/>  }, []);</span><span id="6b2d" class="mq lg iq le b gy mv ms l mt mu">  return &lt;div className="App"&gt;&lt;/div&gt;;<br/>}</span></pre><p id="ab78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第<code class="fe lb lc ld le b">useEffect</code>回调中返回一个函数。</p><p id="0e12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们卸载<code class="fe lb lc ld le b">App</code>组件时，应该会看到<code class="fe lb lc ld le b">'unmounted'</code>。</p><h1 id="ef30" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="07be" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用反应函数组件中的<code class="fe lb lc ld le b">useEffect</code>钩子来做生命周期方法可以在类组件中做的事情。</p></div></div>    
</body>
</html>