<html>
<head>
<title>How To Sanitize Your Express App Against MongoDB Injection &amp; Cross-Site Scripting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何针对MongoDB注入和跨站点脚本清理您的Express应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-sanitize-your-express-app-against-mongodb-injection-cross-site-scripting-6a22f4e822aa?source=collection_archive---------1-----------------------#2021-12-19">https://javascript.plainenglish.io/how-to-sanitize-your-express-app-against-mongodb-injection-cross-site-scripting-6a22f4e822aa?source=collection_archive---------1-----------------------#2021-12-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0844f4a9a9988605f4d1851b3625b761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uEgULUbBBZ_e3Lp_83PTQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image by Author via <a class="ae jz" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank">Canva</a></figcaption></figure><p id="bdea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名web开发人员，解决应用程序中可能出现的每一个<strong class="kc io"><em class="ky"/></strong>安全问题不是你的工作。web应用程序中的安全性是一个完全不同的领域，如果您在生产环境中工作，会有不同的团队来担心安全性问题。</p><p id="2edb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">话虽如此，但是，您可以采取一些初步措施来防范最常见和最基本的安全问题。一旦完成了应用程序的开发，您就可以在部署之前针对这种潜在的攻击实现某种级别的基本安全性。</p><p id="e237" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> MongoDB注入(NoSQL注入)</strong>和<strong class="kc io">跨站脚本(XSS) </strong>就是这样一些你需要解决的基本安全漏洞。首先，让我们看看这些术语的含义，以及为什么会有问题。</p><h1 id="eafb" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">MongoDB注射液</h1><p id="830b" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">你可能以前听说过SQL注入和NoSQL的注入在概念上非常相似。简单来说，这意味着，<em class="ky">注入一些查询/命令作为用户输入的一部分，目的是操纵存储在我们数据库中的数据。</em>这可能会有问题，因为注入的命令将在服务器端执行，并且对存储的数据存在潜在威胁。</p><p id="3446" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在关系数据库的情况下，注入命令相对容易，因为查询和语法非常相似。</p><p id="c5b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑以下查询:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5621" class="ml la in mh b gy mm mn l mo mp"><strong class="mh io">const</strong> user = "SELECT * FROM users WHERE name = '" + userName + "'";</span></pre><p id="a078" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个“用户名”可以来自搜索输入。现在，当用户在搜索字段中输入一些纯SQL而不是搜索词时，就会发生SQL注入，就像这样，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="eff9" class="ml la in mh b gy mm mn l mo mp">a';<strong class="mh io">DROP</strong> <strong class="mh io">TABLE</strong> users; <strong class="mh io">SELECT</strong> * <strong class="mh io">FROM</strong> userinfo <strong class="mh io">WHERE</strong> 't' = 't</span></pre><p id="df67" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将导致下面的总体查询，</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="638e" class="ml la in mh b gy mm mn l mo mp"><strong class="mh io">SELECT</strong> * <strong class="mh io">FROM</strong> users <strong class="mh io">WHERE</strong> name = 'a';<strong class="mh io">DROP</strong> <strong class="mh io">TABLE</strong> users; <strong class="mh io">SELECT</strong> * <strong class="mh io">FROM</strong> userinfo <strong class="mh io">WHERE</strong> 't' = 't';</span></pre><p id="2012" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">执行上述查询将删除“<em class="ky"> users </em>”表，还将显示来自“<em class="ky"> userinfo </em>”表的记录。这说明了注入命令是如何有害的。</p><p id="d1a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在NoSQL数据库中，语法和查询会根据您使用的具体数据库而有很大的不同。MongoDB查询与Apache Cassandra或Redis的查询非常不同。此外，这些查询是用后端语言编写的，如JavaScript、Python或Java，而不是用SQL编写的关系数据库中的统一查询。</p><p id="1c2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">MongoDB使用<em class="ky">二进制JSON (BSON) </em>数据格式，并附带一个安全的BSON查询组装工具。所以与SQL不同，它不可能注入直接的字符串。然而，我们开发的plain express应用程序也不能免受NoSQL注入漏洞的影响。</p><p id="bad3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们举个例子。</p><p id="cb77" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑一个类似的情况，我们在主页上有一个搜索字段(不安全的用户输入)，允许用户搜索特定的项目。这个搜索字段应该接受纯文本，对吗？我们可以搜索“john”或“ice cream ”,匹配的结果需要被取出来给我们看。Mongo查询将如下所示，</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/4221b8b9c92af96c0c8f9328c7118fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsgsnWtrypeWikcgonqSag.jpeg"/></div></div></figure><p id="36c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象“用户Id”来自搜索字段。那么，如果用户在搜索栏中输入类似这样的内容会怎么样呢？</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/a4c7b2085e2504f0e34fb7dc812c7c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXhziWl8MCXBSYSa7HH3Rg.jpeg"/></div></div></figure><p id="b02e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样修改了原始查询，</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/4e9375ee1026d6b70988f8b217125f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9mwpwFe2cRUvDPCzcrLXg.jpeg"/></div></div></figure><p id="5802" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">执行该查询将获取所有用户,因为从技术上讲，每个用户id都大于一个空字符串。简单地说，这将导致查询出数据库中的每个用户。</p><h1 id="5c1e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">防止MongoDB注射</h1><p id="3d7f" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">现在我们知道了注射意味着什么，我们需要找到方法来阻止它在我们的express应用程序中发生。多亏了<a class="ae jz" href="https://www.npmjs.com/package/express-mongo-sanitize" rel="noopener ugc nofollow" target="_blank">特快猫鼬消毒</a> npm包，这并不困难。我们所要做的就是，安装它，然后需要它并使用它。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="40cb" class="ml la in mh b gy mm mn l mo mp">npm install express-mongo-sanitize</span></pre><p id="8a2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以像这样使用它，</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/1d03cf2f424098fddee55de349ae61c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rTWeQFpCwAFkyWe25nH5A.jpeg"/></div></div></figure><p id="9de7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将完全消除MongoDB中任何带有禁止字符的输入，如' $ '符号。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ec10" class="ml la in mh b gy mm mn l mo mp">app.use(<br/>  mongoSanitize({<br/>    replaceWith: '_',<br/>  }),<br/>);</span></pre><p id="73da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以添加上面的代码片段，用'-'字符替换任何禁止的字符。</p><h1 id="eaad" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">跨站点脚本</h1><p id="bdfe" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">我们在应用程序中必须解决的另一个常见和普遍的安全问题是跨站点脚本，也称为XSS。如果一个糟糕的演员可以在别人的网站上运行客户端脚本，那么它可以被解释为XXS。跨站脚本是一种对网站的恶意攻击方式，它可以在网站中造成许多不必要的操纵行为。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/ccf0b8bf5d5e903b32dcd770e9b9c4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOE5oongvQ6NOXfyBREwmQ.jpeg"/></div></div></figure><p id="6826" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://xss-game.appspot.com/" rel="noopener ugc nofollow" target="_blank"> XSS-game.appspot </a>是一款演示游戏，在这里你可以体验将客户端脚本注入网站的概念。这里，我在搜索栏中添加了一个'<em class="ky"> &lt;脚本&gt;alert(" hi ")&lt;/script&gt;</em>'，它提示我一个alert，说<em class="ky">“hi”。</em></p><p id="28fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，这在现实世界中可能会有很大的问题，因为作为用户，我们不应该弄乱网站的功能。你可能认为提醒一些事情没什么大不了的，但是它很容易失控，迫使攻击者在网站上进行不必要的行为。</p><p id="c662" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">XSS的概念可能导致许多攻击，如<strong class="kc io">窃取cookies、劫持用户帐户、泄露敏感数据</strong>等。因此，在我们的express应用程序中至少实现一个基本机制以防止任何可能的XSS攻击是极其重要的。</p><h1 id="6215" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">防止跨站点脚本</h1><p id="e9b5" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">如果你正在使用<a class="ae jz" href="https://express-validator.github.io/docs/" rel="noopener ugc nofollow" target="_blank"> express-validator </a>来验证你的输入，那么这对你有好处，因为转义HTML功能是内置的。但是如果你依赖于joi进行验证，那么你需要做一些额外的工作来避免HTML和基本上停止跨站点脚本。</p><p id="06a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">joi允许我们创建自己的扩展，我们可以利用它来实现自己的HTML转义功能。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fef9" class="ml la in mh b gy mm mn l mo mp">const joi = require('joi');<br/>const sanitizeHtml = require('sanitize-html');</span><span id="7b28" class="ml la in mh b gy mu mn l mo mp">const extension = (joi) =&gt; ({<br/> type: 'string',<br/> base: joi.string(),<br/> messages: {<br/>  'string.escapeHTML': '{{#label}} must not include HTML!'<br/> },<br/> rules: {<br/>  escapeHTML: {<br/>   validate(value, helpers) {<br/>    const clean = sanitizeHtml(value, {<br/>     allowedTags: [],<br/>     allowedAttributes: {}<br/>    });<br/>    if (clean !== value) return helpers.error('string.escapeHTML', { value });<br/>    return clean;<br/>   }<br/>  }<br/> }<br/>});</span></pre><p id="16e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在这里所做的是，我在“<em class="ky"> joi.string() </em>的基础上创建了一个扩展来转义HTML。随着扩展的完成，我们可以添加<em class="ky">。escapeHTML() </em>方法，从而清理HTML。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6a0a" class="ml la in mh b gy mm mn l mo mp">module.exports.userSchema = Joi.object({</span><span id="9dd1" class="ml la in mh b gy mu mn l mo mp">    name: Joi.string().required().escapeHTML(),</span><span id="a7a9" class="ml la in mh b gy mu mn l mo mp">});</span></pre><p id="f1f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我还使用了一个名为<a class="ae jz" href="https://www.npmjs.com/package/sanitize-html" rel="noopener ugc nofollow" target="_blank"> sanitize-html </a>的包来实际剥离扩展中输入的html标签，如<em class="ky"> &lt;脚本&gt;、&lt; p &gt; </em>等。所以你还需要安装<a class="ae jz" href="https://www.npmjs.com/package/sanitize-html" rel="noopener ugc nofollow" target="_blank"> sanitize-html </a> npm包。这个<em class="ky">清理Html() </em>来自为我们完成工作的那个包。我通过将<em class="ky"> allowedTags </em>设置为一个空数组来禁止每个标签，但是如果你愿意，你可以有选择地允许一些标签。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><p id="c254" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你对express应用程序中的基本漏洞以及如何将危害最小化有所了解。下次见！</p><p id="2143" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">说白了. io </em> </a> <em class="ky">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">免费周报在这里</em> </a> <em class="ky">。</em></p></div></div>    
</body>
</html>