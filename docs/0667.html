<html>
<head>
<title>The Node.js Developer Roadmap for 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js年开发者路线图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-developer-roadmap-for-2021-2ae9c057bff4?source=collection_archive---------0-----------------------#2021-02-11">https://javascript.plainenglish.io/node-js-developer-roadmap-for-2021-2ae9c057bff4?source=collection_archive---------0-----------------------#2021-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d08f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">成为Node.js开发人员的路线图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fad35fb7a69c755bb20688f9c6296e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POl37BWWEribnWpMAo6YiA.png"/></div></div></figure><p id="2b38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Node.js自发布以来一直是最大的游戏规则改变者之一，像<strong class="kt ir">优步、Medium、PayPal </strong> &amp; <strong class="kt ir">沃尔玛</strong>这样的大公司将他们的技术栈转移到<strong class="kt ir">Node.js。</strong>你可以用node . js开发真正强大的应用程序，如实时跟踪应用程序、视频和文本聊天引擎、社交媒体应用程序等。学习Node.js正成为开发人员最热门的技能之一，我准备的路线图是基于我自己的经验和技巧。在深入研究这个Node.js路线图之前，请确保您有一个明确的<strong class="kt ir"><em class="ln"/></strong>&amp;<strong class="kt ir"><em class="ln">简明的</em> </strong>您想要用Node.js构建的目标，否则您将像我一样在学习路径之间放弃。保持一个目标将帮助你专注于学习最重要的技能，而不是弄清楚你是否需要学习它们。</p><h1 id="b227" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">先决条件</h1><h2 id="1c44" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated"><strong class="ak"> 1。JavaScript </strong></h2><p id="1ac9" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">如果您是一名前端开发人员，希望掌握一些后端技能，那么在开始构建Node.js应用程序之前，您不必花费大量时间学习JavaScript。但是，如果您是一个完全的初学者，希望在尽可能短的时间内掌握Node.js，那么在深入Node.js环境之前，您必须学习以下概念。</p><ul class=""><li id="56b2" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">箭头功能</li><li id="32d3" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">类型</li><li id="25b5" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">公式</li><li id="3e7f" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">功能</li><li id="0471" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">词汇结构</li><li id="3331" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">这</li><li id="f73f" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">循环和范围</li><li id="75dc" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">数组</li><li id="edc2" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">模板文字</li><li id="6677" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">严格模式</li><li id="4542" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">ES6/ES7</li></ul><p id="791c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Node.js中，你将会处理大量的异步编程，为此，建议学习以下概念。</p><ul class=""><li id="5f80" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">定时器</li><li id="f22a" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">承诺</li><li id="145a" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">关闭</li><li id="32a9" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">事件循环</li><li id="251d" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">异步编程和回调</li></ul><h2 id="735a" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">2.NPM</h2><p id="a22e" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">节点包管理器是世界上最大的<strong class="kt ir">软件注册中心</strong>，拥有超过800，000个代码包。当我们开发需要大量依赖项的应用程序时，正确地使用NPM和T21会有很大的帮助，因为用NPM管理软件包会变得非常方便。</p><p id="5245" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NPM由三个不同的部分组成</p><ul class=""><li id="f56e" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">命令行界面(CLI): 它运行在机器的终端环境中，也是大多数开发人员与NPM交互的方式</li><li id="189a" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">注册表:</strong>JavaScript软件和元信息的大型公共数据库。</li><li id="0a73" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">网站:你可以发现新的软件包，并管理你的npm体验的其他方面。</li></ul><p id="618a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NPM用于管理多个版本的代码和代码依赖，不下载就运行包<strong class="kt ir"> <em class="ln">(使用npx) </em> </strong>，等等。</p><h2 id="c297" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">3.Node.js基础知识</h2><p id="d420" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated"><strong class="kt ir">事件发射器:</strong>它们是<strong class="kt ir"> Node.js </strong>中的对象，通过发送消息来触发事件，以表示一个动作已经完成。我们也可以编写自己的代码来监听来自事件发射器的事件。<em class="ln">比如</em>，如果你做过一些前端工作，那么你大概知道我们的应用程序中需要处理多少交互，比如<strong class="kt ir">鼠标点击、键盘按键、</strong>等鼠标移动。类似地，在Node.js的后端环境中，我们可以使用events模块构建一个类似的系统，该模块提供了用于处理事件的<strong class="kt ir"> EventEmitter </strong>类。</p><p id="19b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">回调:</strong>这些是任务完成时调用的函数，它防止任何类型的阻塞，同时允许其余代码同时运行。因为我们必须在Node.js中处理大量异步任务，所以我们到处都需要它们来创建无缝且更快的应用程序。<strong class="kt ir">例如，</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/923c6277fde035b4cc5fe73b277a1d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qY_nCYOlS-NixenH4-zzSQ.png"/></div></div></figure><p id="bfde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">Buffers:</strong>node . js中一个名为Buffer的类被设计用来处理原始的二进制数据。它们对应于在<strong class="kt ir"> V8 </strong>之外分配的一些原始内存。缓冲区是一个不能调整大小的整数数组，有一大堆专门用于二进制数据的方法。例如，buffer中的整数表示从<strong class="kt ir"> 0 </strong>到<strong class="kt ir"> 255 </strong>的有限值的字节，如果您<strong class="kt ir"><em class="ln">console . log()</em></strong>打印一个Buffer实例，将会收到一串十六进制的值。</p><p id="2c06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">模块系统:</strong>作为Node.js生态系统的一部分，您将使用Node.js提供的模块来实现复杂的功能，这些JavaScript文件包含所有有组织的复杂功能，任何人都可以通过Node.js应用程序重用这些功能。</p><h1 id="b17a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">发展技能</h1><p id="9052" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated"><strong class="kt ir">版本控制系统(Git，GitHub): </strong>你不会想在代码中弄乱一些东西，却不知道如何恢复的情况下。使用像<strong class="kt ir"> Git </strong>这样的VCS，你可以管理大型项目&amp;如果你已经非常熟悉使用VCS，那么确保你有版本控制系统的坚实基础。</p><p id="ff61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> HTTP/HTTPS协议:</strong>关于如何使用传输协议传输数据的基础知识将使你成为一名更好的Node.js开发人员，对HTTP和HTTPS如何工作的良好理解是每个后端开发人员都应该充分理解的。HTTPS使用一种被称为传输层安全<strong class="kt ir"> (TLS) </strong>的加密协议来加密通信。在后端环境中有很多东西需要学习，如果你不知道web是如何工作的，可能会有点糊涂，有4种请求方法负责web上的任何基本通信:</p><ul class=""><li id="abca" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><strong class="kt ir"> GET: </strong>用于检索资源的表示</li><li id="81f3" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir"> POST: </strong>用于创建新的资源</li><li id="f76c" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir"> PUT: </strong>用于更新功能</li><li id="08b7" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">补丁:</strong>用于修改功能</li><li id="b1d5" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">删除:</strong>用于删除由URL标识的资源</li><li id="2161" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">选项:</strong>为给定的URL或服务器请求允许的通信选项</li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="947c" class="lo lp iq bd lq lr nt lt lu lv nu lx ly jw nv jx ma jz nw ka mc kc nx kd me mf bi translated">Web框架</h1><p id="cc25" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">注意:</em> </strong> <em class="ln">所有这些web框架都是值得了解的，如果你正在用Node.js构建一个个人项目，那么建议坚持使用单一框架，否则学习的道路会很宽。</em></p><p id="370d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Express.js: </strong>提供了构建我们的应用程序所需的非常简单的接口和工具，使用起来非常灵活，并且在<strong class="kt ir"> npm </strong>上提供了许多可以直接插入Express的模块。</p><p id="56c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Meteor.js: </strong>一个制作JavaScript应用程序的优秀框架，内置了支持<strong class="kt ir"> GraphQL的<strong class="kt ir"> MongoDB </strong>处理程序。</strong>当你运行“meteor create myapp”并运行它时，一个<strong class="kt ir">HTML</strong>/<strong class="kt ir">JavaScript</strong>网页被提供了一个MongoDB后端。您可以使用Meteor.js作为您的框架列表中的一个有效的替代方案，帮助您减少开发时间并简化维护。否则，如果你正在构建一个简单的web应用程序，我会推荐坚持使用<strong class="kt ir"> Express </strong>。</p><p id="1de0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Sails.js: </strong>一个<strong class="kt ir"> MVC </strong>框架可以让你快速构建REST APIs、单页应用、实时应用。如果你希望掌握一些重要的技能，那么强烈推荐Sails.js，因为它有很多好处，比如WebSockets的实时支持，它使用“约定胜于配置”的方法。</p><p id="4583" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你正在寻找构建健壮的、经得起未来考验的、易于维护的应用程序，那么Koa.js是一个不错的选择。一个<strong class="kt ir"> Koa </strong>应用程序是一个包含一些中间件功能的数组的对象，这些功能稍后以堆栈的方式执行。</p><p id="ff50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Nest.js: </strong>受Angular启发，用<strong class="kt ir"> TypeScript </strong>构建，在引擎盖下使用Express.js，这使得它可以兼容大多数Express中间件。您可以使用Nest.js构建高效且可伸缩的应用程序，因为它为将代码组织到单独的模块中提供了一个很好的模块化结构。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="0e3c" class="lo lp iq bd lq lr nt lt lu lv nu lx ly jw nv jx ma jz nw ka mc kc nx kd me mf bi translated">数据库管理</h1><p id="7ac7" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">在学习Node.js的过程中，你将会接触到大量的背景知识。你将会清楚而简明地了解我们如何设计后端系统，超越SQL或MySQL取决于具体情况，当你处理新类型的项目时，你可能需要学习其他后端的东西。</p><p id="3302" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">注:</em> </strong> <em class="ln">我们大部分时间都在使用</em> <strong class="kt ir"> <em class="ln">关系数据库。</em> </strong> <em class="ln">例如，我们对模型数据像</em> <strong class="kt ir">产品、类别、</strong> <em class="ln">标签等使用表格。表格包含列和行，类似于电子表格。</em></p><p id="f752" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> SQL Server: </strong>微软开发的关系数据库管理系统，支持<strong class="kt ir"> ANSI SQL </strong>(一种标准的SQL语言)。然而，SQL有它自己的实现。</p><p id="1c48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">MySQL: 另一个伟大的数据库管理系统，允许你创建关系数据库。Oracle开发的开源后端软件，MySQL也让我们获得了选择的灵活性，因为我们可以根据需要更改源代码。与<strong class="kt ir"> Oracle数据库</strong> &amp; <strong class="kt ir">微软SQL server相比，MySQL是一个相当容易的替代方案。</strong></p><p id="3bc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">PostgreSQL: 由全球开发团队开发，因为它是开源的。它可以在所有主流操作系统上运行，包括Linux、UNIX &amp; Windows。PostgreSQL支持SQL标准的很大一部分，同时提供了一些很棒的特性，如<strong class="kt ir">复杂SQL查询、外键、触发器、事务、多版本并发控制(MVCC)、可伸缩复制器等。</strong></p><ul class=""><li id="8172" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">MySQL的一个改进版本，它内置了各种强大的特性、安全性和性能改进，这些都是MySQL所没有的。对于大型应用程序，您应该选择MariaDB而不是MySQL，这有几个原因。例如，MariaDB有一个较大的连接池，支持多达200，000多个连接，而MySQL有一个较小的连接池。<em class="ln">总之，</em> <strong class="kt ir"> <em class="ln"> MariaDB </em> </strong> <em class="ln">比</em><strong class="kt ir"><em class="ln">MySQL</em></strong><em class="ln">快。</em></li></ul><h2 id="c141" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated"><strong class="ak">云数据库服务</strong></h2><p id="22b0" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated"><strong class="kt ir"> Azure CosmosDB: </strong>一种全球分布的数据库服务，你可以远程管理你的数据，使用云数据库给了你许多优势，因为使用你可以用来扩展和分发的工具，扩展和管理大型应用程序变得有点容易，所有这些都是由<strong class="kt ir">微软Azure </strong>提供的。此外，它支持使用一个后端的多个数据模型，这意味着它可以用于文档、键值、关系图模型。由于它不依赖于任何模式，你可以称之为<strong class="kt ir"> NoSQL </strong>数据库，但它确实支持查询语言和<strong class="kt ir"><em class="ln"/></strong>事务支持。</p><p id="2082" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Amazon DynamoDB: </strong>据我所知<strong class="kt ir"> Amazon DynamoDB </strong>是一个很好的选择，如果你已经有一些SQL的经验，它是一个完全托管的NoSQL数据库服务，提供更快和可预测的性能，具有惊人的可伸缩性。您可以创建数据库表来存储和检索任意数量的数据，并为任意级别的请求流量提供服务</p><h2 id="2e2b" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">2.NoSQL数据库</h2><p id="0c63" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated"><strong class="kt ir"> MongoDB: </strong>一个面向文档的NoSQL数据库，专门用于大容量数据存储，因为我们在其他关系数据库中有表和行，MongoDB使用集合和文档。文档由键-值对组成，这些键-值对是MongoDB &amp;集合中的基本数据单元，包含文档和函数的集合，相当于关系数据库表</p><p id="2b6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Redis，我们可以处理数据库、缓存和消息代理。它使用像<strong class="kt ir">字符串、哈希、列表、集合、位图、超级日志</strong> &amp; <strong class="kt ir">地理空间索引</strong>这样的数据结构来以键值对的形式存储数据。如果你对我们在哪里使用Redix感到困惑，这里有一个例子。</p><p id="109b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设在我们的应用程序中，我们必须处理被授权在应用程序中执行不同操作的用户，每次我们对用户进行身份验证时，我们都必须获得他们对应用程序中控制访问的授权。这种方法没有任何问题，因为我们有像<strong class="kt ir"> JOSE </strong>这样的好标准，同时保持我们的<strong class="kt ir">密钥材料安全</strong>，但是如果我们的应用程序有多个授权，那么这种情况就变得很难扩展。我们可以将用户的授权存储在某种形式的数据库中，并向用户提供一个<strong class="kt ir">键值</strong>(称为令牌)，而不是将授权列表发送给用户。</p><h2 id="3385" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated"><strong class="ak">阿帕奇卡珊德拉</strong></h2><p id="a216" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">一个高度可扩展的高性能分布式数据库，旨在处理许多服务器上的大量数据，没有单点故障。它创建于脸书，不同于其他关系数据库管理系统。分布式设计基于亚马逊的DynamoDB和谷歌的BigTable的数据模型。</p><h2 id="9d0e" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated"><strong class="ak"> LiteDB </strong></h2><p id="ceb7" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">一款非常轻便快速的<strong class="kt ir">。NoSQL嵌入式数据库，带有无服务器文档存储。您可以在小型桌面应用程序和小型web应用程序中使用<em class="ln"> LiteDB </em>，这些应用程序为每个用户的每个帐户存储使用一个数据库。</strong></p><h2 id="8994" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">3.搜索引擎</h2><p id="5f71" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">注:</em> </strong> <em class="ln">如果你在想我们为什么需要一个搜索引擎，那么这里有一个例子，我们使用谷歌作为搜索引擎，但它本身就是一个基于网络的应用程序。</em><strong class="kt ir"><em class="ln">Solr</em></strong><em class="ln">和</em><strong class="kt ir"><em class="ln">elastic search</em></strong><em class="ln">是后端框架，如果提供了任何类型的数据集，它会在其上创建一个索引，同时使该数据可供在服务器上搜索。你可以用Solr作为搜索引擎来维护一个拥有数百万用户的网站。</em></p><h2 id="2db9" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated"><strong class="ak">弹性搜索</strong></h2><p id="a396" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">一个基于Apache Lucene和Java开发的搜索和分析引擎。使用ElasticSearch，您可以实时存储和分析大量数据。因为它搜索索引而不是搜索文本，所以在弹性搜索中也实现了很好的搜索性能。其核心是，它使用基于结构的文档，而不是带有大量<strong class="kt ir"><em class="ln">REST API</em></strong>的表和模式来存储和搜索数据。你可以把ElasticSearch想象成一个处理<strong class="kt ir"> <em class="ln"> JSON </em> </strong>请求并给你返回JSON数据的服务器。</p><h2 id="e0c2" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated"><strong class="ak"> Solr </strong></h2><p id="a441" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">它提供了非常先进的实时搜索功能，如字段搜索，布尔查询，阶段查询，模糊查询，拼写检查，自动完成，等等。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="c5fd" class="lo lp iq bd lq lr nt lt lu lv nu lx ly jw nv jx ma jz nw ka mc kc nx kd me mf bi translated">贮藏</h1><blockquote class="ny"><p id="0e71" class="nz oa iq bd ob oc od oe of og oh lm dk translated">缓存就是将文件副本存储在高速缓存中的过程，通过减少网络调用，可以访问这些副本以获得更快的网络响应。</p></blockquote><h2 id="4bcd" class="mg lp iq bd lq mh oi dn lu mj oj dp ly la ok mm ma le ol mo mc li om mq me mr bi translated"><strong class="ak">内存缓存</strong></h2><p id="dafe" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">这种技术通常也称为缓存，因为大多数时候，缓存与服务器中的内存相关联。在这种技术中，服务器内存的一部分被用作缓存，我们在其中存储了减少应用程序中的网络调用所需的所有数据。在Node.js中，我们有<strong class="kt ir">节点缓存</strong>和<strong class="kt ir">内存缓存</strong>作为一些优秀的库来处理节点服务器中的内存缓存。</p><h2 id="4071" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated"><strong class="ak">分布式缓存</strong></h2><p id="4644" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">在这种缓存技术中，我们将多个网络的内存合并到一个内存数据存储中，稍后我们将使用该存储作为最终的数据缓存来证明对数据的快速访问。这种技术尤其适用于大量数据和大量网络调用，同时允许通过向集群添加更多服务器内存来实现增量扩展和伸缩。<strong class="kt ir"> Redis </strong>是关于<a class="ae on" href="https://www.youtube.com/watch?v=U3RkDLtS7uY" rel="noopener ugc nofollow" target="_blank"> <em class="ln">分布式缓存</em> </a>最广为人知的东西之一，但是你可以通过学习<strong class="kt ir"> Memcached来超越它。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/e76685f09fef5f0129f586d678633f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdJCEb4Z2RnrS9LDsClSBQ.png"/></div></div><figcaption class="op oq gj gh gi or os bd b be z dk"><strong class="bd ot">Distributed Caching</strong></figcaption></figure><h1 id="1705" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">模板引擎</h1><p id="f97c" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">使用模板引擎，我们可以在我们的应用程序中使用静态模板文件，而在运行时，这个<strong class="kt ir"><em class="ln"/></strong>模板引擎用实际值替换模板文件中的变量，然后将模板转换成发送给客户端的<strong class="kt ir"> HTML </strong>文件。下面列出了一些流行的模板引擎。</p><ul class=""><li id="7060" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><strong class="kt ir"> Mustache.js </strong></li><li id="4420" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">车把</strong></li><li id="e400" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir"> EJS </strong></li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="b825" class="lo lp iq bd lq lr nt lt lu lv nu lx ly jw nv jx ma jz nw ka mc kc nx kd me mf bi translated">实时通信</h1><h2 id="1533" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated"><strong class="ak"> Socket.io </strong></h2><p id="a4fc" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">当谈到理解套接字中的实时通信时，有很多内容。IO如果你刚开始做后端开发，实时通信背后的主要逻辑是在客户端和服务器之间。它允许<strong class="kt ir">客户端</strong>服务器之间的双向&amp;数据流，你可以把双向数据流看作是两个终端之间的同步数据流，以实现实时通信行为，这些类型的行为都是在客户端有Socket时启用的。浏览器中的IO以及与Socket集成的服务器。IO包。并且数据可以以<strong class="kt ir"> JSON </strong>请求的形式发送。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/6df4e8dbfbcf8bc16781dbfb220c6476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3o736V76bvWM79TiQyhMQ.png"/></div></div><figcaption class="op oq gj gh gi or os bd b be z dk"><strong class="bd ot">Socket.IO Downloads</strong></figcaption></figure></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="8b6e" class="lo lp iq bd lq lr nt lt lu lv nu lx ly jw nv jx ma jz nw ka mc kc nx kd me mf bi translated">API客户端</h1><h2 id="80af" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">休息</h2><p id="92f4" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">在REST之前，API是围绕远程过程调用(RPC)开发的，API看起来像一些本地执行的代码。许多技术试图解决这个问题，使用类似RPC的堆栈来隐藏根本问题，然后引入REST来以更好的方式构建基于web的API。</p><p id="8bdb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在REST中，该架构使用简单的HTTP调用进行通信，而不是复杂的选项，如<strong class="kt ir"> COBRA、COM+、RPC </strong>。在REST中，调用是基于消息的，并且依赖于<em class="ln"> HTTP </em>标准来描述这些消息。在<strong class="kt ir"> <em class="ln"> Node.js </em> </strong>生态系统中，你可以选择<strong class="kt ir"> node-rest-client </strong>和<strong class="kt ir"> Axios </strong>，它们都为更快的web应用提供了很好的服务。</p><h2 id="f323" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">GraphQL</h2><p id="5e00" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">GraphQL是REST的一个很好的替代方案，它使用的API优先向客户机提供它们所请求的数据。一个灵活且对开发人员友好的替代方案，因为您甚至可以在一个名为<strong class="kt ir"> GraphiQL的IDE中部署它。</strong>您还可以在不影响现有<strong class="kt ir">查询</strong>的情况下添加或删除字段，并使用任何首选方法构建API。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="e002" class="lo lp iq bd lq lr nt lt lu lv nu lx ly jw nv jx ma jz nw ka mc kc nx kd me mf bi translated">测试</h1><h2 id="4ef6" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">单元测试框架</h2><blockquote class="ny"><p id="de31" class="nz oa iq bd ob oc od oe of og oh lm dk translated">在单元测试中，我们孤立地测试单个单元/组件，其中单元可以是应用程序中最小的可测试代码部分。在<strong class="ak"> Node.js </strong>中，下面列出了最好的单元测试框架之一:</p></blockquote><ul class=""><li id="edb2" class="mx my iq kt b ku ov kx ow la ox le oy li oz lm nc nd ne nf bi translated">Jest: 一个非常流行的测试框架，以简单著称，由<strong class="kt ir">脸书</strong>开发。在所有测试框架中，Jest拥有最好的支持并行测试的文档，这意味着您可以在它们自己的过程中运行每个测试，以最大化性能。</li><li id="0396" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">Mocha: 它服务于节点应用程序单元测试框架的旧标准，支持异步操作，如回调，承诺高度可扩展和可定制的断言。</li><li id="2b3b" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">柴:</strong>可以和Mocha一起使用，可以作为Node.js的<strong class="kt ir"> <em class="ln"> TDD/BDD </em> </strong>断言库，可以和任何基于<strong class="kt ir"> JavaScript </strong>的测试框架配对。</li></ul><h2 id="6723" class="mg lp iq bd lq mh mi dn lu mj mk dp ly la ml mm ma le mn mo mc li mp mq me mr bi translated">嘲弄的</h2><p id="8c5c" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">在<strong class="kt ir">单元测试中，</strong>测试应该是小而轻量级的，但是有些被测对象依赖于其他对象。</p><p id="bd5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">例如</em> </strong>，需要与服务器通信或与<strong class="kt ir">网络服务对话的对象</strong>，由于那我们失去了以快速和轻量级的方式运行测试的能力，这就是<strong class="kt ir"><em class="ln"/></strong>发挥作用的地方。在Mocking中，我们不需要任何类型的实际数据库或任何类型的连接来运行我们的测试，它只是返回带有预期结果的对象。所以只有简单的对象来模拟实际结果，这样我们就可以不受任何限制地更快地运行测试。</p><blockquote class="ny"><p id="5f6e" class="nz oa iq bd ob oc od oe of og oh lm dk translated"><strong class="ak">我已经列出了一些很棒的帖子，来了解你如何使用Sinon和Jasmine来执行嘲讽。</strong></p></blockquote><ul class=""><li id="721d" class="mx my iq kt b ku ov kx ow la ox le oy li oz lm nc nd ne nf bi translated"><a class="ae on" href="https://stackabuse.com/using-mocks-for-testing-in-javascript-with-sinon-js/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">兴农</strong> </a></li><li id="4637" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae on" href="https://eclipsesource.com/blogs/2014/03/27/mocks-in-jasmine-tests/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">茉莉</strong> </a></li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="f1a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">node . js库的一些好消息</strong></p><ul class=""><li id="c022" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><strong class="kt ir"> <em class="ln"> Async.js </em> </strong></li><li id="3eff" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir"> <em class="ln"> PM2 </em> </strong></li><li id="7c02" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">T31】commander . jsT33】</strong></li><li id="d955" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir"> <em class="ln">节点邮件</em> </strong></li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt pa"><a href="https://medium.com/javascript-in-plain-english/react-learning-roadmap-for-2021-a1c0f7456186" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">react 2021年学习路线图</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">学习的路线图React我希望我知道</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po kp pa"/></div></div></a></div></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt pa"><a href="https://medium.com/javascript-in-plain-english/mastering-the-git-command-line-b2c6efe4f4ad" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">掌握Git命令行</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">像专家一样使用Git版本控制系统</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pp l pl pm pn pj po kp pa"/></div></div></a></div></div></div>    
</body>
</html>