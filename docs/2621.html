<html>
<head>
<title>A Deeper Dive into the ‘useEffect’ Hook in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中对“useEffect”挂钩的深入探究</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-deeper-dive-into-the-useeffect-hook-in-react-4c932215ad00?source=collection_archive---------1-----------------------#2021-05-30">https://javascript.plainenglish.io/a-deeper-dive-into-the-useeffect-hook-in-react-4c932215ad00?source=collection_archive---------1-----------------------#2021-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/6e8de96c4acac568753e03ca53162a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*PAAjcc7Jhaamrk2Rkv3rvg.png"/></div></figure><p id="0709" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在钩子出现之前，我们只能在类组件中使用<strong class="jt io">状态</strong>或<strong class="jt io">生命周期方法</strong>。然而，现在有了钩子，React为我们提供了类似于<em class="kp">使用状态</em>、<em class="kp">使用效果</em>、<em class="kp">使用上下文</em>、<em class="kp"> useRef </em>等函数，这些函数在函数组件中提供了额外的功能。</p><p id="7599" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们本质上可以像在类组件中一样“挂钩”React特性。例如，如果您正在处理一个功能组件文件，并且发现自己需要向它添加状态，没问题！您可以简单地使用useState钩子。React钩子中有一个对我来说比较难掌握的函数是<strong class="jt io"> useEffect </strong>钩子。因此，让我们深入研究一下它是什么，什么时候使用它，以及如何使用它。</p><h1 id="4c6f" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">什么是useEffect？</strong></h1><p id="a71a" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated"><strong class="jt io">使用效果</strong>本质上是<em class="kp">“使用副作用”的简称它允许你在功能组件中添加副作用，或者本质上，类似生命周期方法的东西。如果您还不熟悉钩子，基本上它是componentDidMount、componentDidUpdate和componentWillUnmount生命周期方法，所有这些都组合在一个称为useEffect的有效函数中。</em></p><p id="0924" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在React组件中，有两种常见的副作用——不需要清理的副作用和需要清理的副作用。这些影响的例子包括获取数据、注册事件监听器或设置对外部数据源的订阅。</p><p id="c741" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">基于类的组件中的生命周期方法和功能组件中的useEffect挂钩之间的区别在于，开发人员可以更容易地直接识别在类中做什么的代码部分。语法更加明确，例如，对于“反点击”任务看到componentDidMount，对于初始点击之后的另一次点击看到componentDidUpdate。useEffect允许我们减少这段代码的重复。</p><h1 id="4ef0" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">使用useEffect挂钩</h1><p id="6de7" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">为了在函数组件中使用它，我们将它添加到文件顶部的import React语句中。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/2e444275e6e3528cde98ebda1985201d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*4xImSR0X_mZ7IbxcSWGeWw.png"/></div></figure><p id="049f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">标准语法如下所示。我们调用<strong class="jt io"> useEffect，</strong>然后我们提供一个函数作为<strong class="jt io">第一个参数</strong>，也就是<strong class="jt io"> ( ) = &gt; { }。第一个参数总是函数。这放在箭头后的花括号内。下面的第二张图更多地展示了这种结构，给出了上下文，其中“效果”是我们想要执行的功能或“副作用”。</strong></p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/550f5b23016b191131a2ad520e479710.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*GqW6QzdcOKpReZtAApamhQ.png"/></div></figure><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/cf7eb582226e7ab3355694a9cbefe300.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*drrcxK08PguX8DPLiNIM3g.png"/></div></figure><p id="753c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们放在useEffect函数中的第二个参数是在代码被执行时控制<strong class="jt io">的。这要么是一个数组，里面有像上面看到的<strong class="jt io">【输入】</strong>一样的东西，要么是一个空数组<strong class="jt io"> [] </strong>，要么根本没有数组。由于第二个参数是可选的，下面的代码也同样有效。</strong></p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/65ebb650196368a846e712469f1b1a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*zGkN0donPhX6IQWuyUf-8w.png"/></div></figure><p id="b418" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么，这三者之间有什么区别呢？在三种情况下，我们会配置useEffect钩子来自动运行我们的代码。：</p><ol class=""><li id="eb69" class="mb mc in jt b ju jv jy jz kc md kg me kk mf ko mg mh mi mj bi translated"><strong class="jt io">[]</strong><em class="kp">*空数组*</em><strong class="jt io">:</strong><em class="kp"/><strong class="jt io"><br/></strong>仅在第一次渲染组件时</li><li id="4af7" class="mb mc in jt b ju mk jy ml kc mm kg mn kk mo ko mg mh mi mj bi translated"><strong class="jt io"> …。</strong><em class="kp">* nothing *</em><strong class="jt io">:</strong><em class="kp"><br/></em>组件第一次渲染时以及以后每次重新渲染时</li><li id="c1ce" class="mb mc in jt b ju mk jy ml kc mm kg mn kk mo ko mg mh mi mj bi translated"><strong class="jt io">【数据】</strong><em class="kp">*内部有数据的数组* </em> <strong class="jt io"> : </strong> <br/>组件第一次渲染时，以及每当组件重新渲染且某段数据发生变化时。</li></ol><p id="3c43" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们举例说明这些场景。在这个例子中，我们有一个页面，用户可以在这里输入并看到他们的短语打印在屏幕上。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/4b401aebd10b66ae1d7216815c1f5985.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*Qom97cwgoq_Kl89p2CCSOw.png"/></div></figure><p id="498d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是我们的代码。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/97d81a315b35037383af6cb96ee1d5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RrBt0MxwsiPljzMJK0Lfeg.png"/></div></div></figure><p id="2c00" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我在useEffect函数内部和外部添加了console.logs，这样我们就可以使用控制台看到不同副作用的行为。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/4114be356bd12f8fee09125e18267fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*HB48oM-F2PXkCx9Cvrwvkg.png"/></div></figure><p id="35ff" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一旦页面加载完毕，我们会看到一个初始控制台日志“我在每次渲染时运行<em class="kp">”和“我在使用效果</em>中运行<em class="kp">和</em> <em class="kp">”。如果没有参数，我们的useEffect会在每次渲染后被调用。</em></p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mw"><img src="../Images/ae432745727fe4fba06b349730935004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KWSNJXnUGR0oMz9-Z-CavA.gif"/></div></div></figure><p id="0e16" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">很少会没有第二个参数，因为通常会有一个包含数据的数组或一个空数组。但是出于演示的目的，我想让你看看当你跳过提供依赖数组时是什么样子。</p><p id="8938" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，我们添加一个空数组作为第二个参数。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/875b0f50fd4d0ef8cf2a784dbe6fff25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*5iCkSlHYgZzCbrgfbT-W3g.png"/></div></figure><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi my"><img src="../Images/bd53d6832eff761eaa75a8f42c72d4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OMMR5385XY1XTV0wqA1dcw.gif"/></div></div></figure><p id="4b02" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于空数组，我们看到useEffect中的文本只在初始渲染时运行。每次修改后，我们只能在控制台中看到“我在每次渲染时运行”。</p><p id="f2f0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在来看第三个场景，一个包含数据的数组。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/4c26e5a9e3032f296fcdf62bac9ecf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*GNZRUL_8Vsq38oGkN8ryOg.png"/></div></figure><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi na"><img src="../Images/79c6b42894397e44f7d75047d9bb29cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wwF9GSG_UVCQ4f3S9WGrfA.gif"/></div></div></figure><p id="a6fc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有了一个包含数据的数组，我们的效果将在初始渲染时运行，并且如果数据在上次渲染后发生了变化，它也将在每次重新渲染后运行。</p><h1 id="2964" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">卸载呢？</h1><p id="2dc9" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">如开头所述，useEffect将生命周期方法componentDidMount、componentDidUpdate和componentWillUnmount组合成一个函数。到目前为止，我们只看到了安装和更新。为了实现componentWillUnmount，也称为“清理”，我们只需在我们的效果函数下面，在我们的第二个参数之前返回一个函数。下面反映了语法方面的情况。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1d864a34094718917434a9d2300a9bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*S8a7fFyOXvQs2ZsEphXgvg.png"/></div></figure><p id="c14a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">效果中的这个返回是一个可选功能，充当效果的清理工具。</p><p id="3603" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于这个例子，我修改了我的代码，增加了一个“显示/隐藏切换”按钮。当我们切换到“隐藏”时，我们有一个console.log，它打印“<strong class="jt io"> <em class="kp"> Unmount </em> </strong>”，当我们切换到“显示”时，它打印“<strong class="jt io"> <em class="kp"> Rende </em> </strong> r”到屏幕上。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/2cac7826ca98d47166df7b0e4eb90b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRKyGN2eLLCY92mNVRpelg.png"/></div></div></figure><p id="6171" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">正如你可以在我们的useEffect中看到的，我们跳过了添加第二个参数。让我们看看在第8–9行添加清理机制后会发生什么。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nd"><img src="../Images/f6c4f1e3539e21dd7b1459a2b37a1c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*areP46IBGeQj1WcgVxwxCw.gif"/></div></div></figure><p id="07db" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当我们切换show/hide按钮时，当<strong class="jt io"> Hello </strong>消失时，它打印“<em class="kp"> unmount </em>”，当它重新出现时，它打印“Render”。但是，当我单击“re-render”按钮时，每次单击都会同时打印卸载和渲染。那么，为什么它在每次渲染后也“卸载”，而不是在卸载期间只卸载一次呢？这是因为我们必须记住，每次在没有依赖关系(也就是第二个参数(<strong class="jt io"> [] </strong>或<strong class="jt io">【某些数据】</strong>)的情况下，渲染时都会调用效果。</p><p id="ac3a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你想运行一个效果并且只清理一次，记得传入空数组作为第二个参数。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b8d216d84408af352efddcbdd3b824ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*Zf9pKMswK8QRWUN5iFPcYg.png"/></div></figure><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/a1b1eb4ef983d7c3bc34840f6ecc6743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/1*m9v-KEPhIAdrIhVqkDHW2A.gif"/></div></figure><p id="1618" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这里，当我们单击Show/Hide切换时，它会像我们期望的那样在控制台上打印Unmount和Render。但是，当我们单击re-render时，控制台中不会打印任何内容，因此只在装载(显示)或卸载(隐藏)时运行一次。这种方法是一种稍微好一点的优化性能的方法，因为我们减少了调用清理函数的次数。</p><h1 id="3e8e" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">关于useEffect需要注意的几件事</h1><ul class=""><li id="7a71" class="mb mc in jt b ju lo jy lp kc ng kg nh kk ni ko nj mh mi mj bi translated">正如我们在例子中看到的，useEffect在每次渲染后运行。查看useEffect运行时间的最佳方式是打开控制台，这样您就可以看到。</li><li id="6b4f" class="mb mc in jt b ju mk jy ml kc mm kg mn kk mo ko nj mh mi mj bi translated">您可以使用多个useEffect函数来分离单个组件中的关注点。尽管一个单独的useEffect被设计成只处理一个问题，但是如果需要的话，不要犹豫使用几个。这比用一个效果处理几个问题要好得多。</li><li id="34ff" class="mb mc in jt b ju mk jy ml kc mm kg mn kk mo ko nj mh mi mj bi translated">确保不要不必要地重新渲染组件。您可以通过提供第二个参数来防止这种情况，第二个参数可以是包含数据或值的数组，也可以是空数组。</li></ul><h1 id="5390" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="aeb8" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">希望这能对useEffect有所启发，不管你是钩子新手还是只知道使用它的基本知识。它非常强大，并为您的React应用程序添加了如此多的功能。</p><p id="5c74" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">虽然基于类的组件很少在较新的React应用或项目中使用，但我认为知道这一点仍然很重要，即使是对那些新React的人来说。你可能会加入一家公司，最终不得不从事具有基于类的组件的遗留代码。了解生命周期方法和useEffect的差异、相似性、利弊将对您的职业生涯和React发展大有裨益。编码快乐！</p><p id="abf9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kp">更多内容尽在</em><a class="ae nk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kp">plain English . io</em></a></p></div></div>    
</body>
</html>