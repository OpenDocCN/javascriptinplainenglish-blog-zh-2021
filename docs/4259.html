<html>
<head>
<title>JavaScript: Recursion, Tail-Call Optimization and Trampolining with Pictures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:递归、尾调用优化和图片蹦床</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/js-recursion-and-tail-call-optimization-with-pictures-cbf8f766a31?source=collection_archive---------9-----------------------#2021-08-24">https://javascript.plainenglish.io/js-recursion-and-tail-call-optimization-with-pictures-cbf8f766a31?source=collection_archive---------9-----------------------#2021-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2632f215f8a40d3d12106f92a7e46abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pBfqHYXyil9Qt3rwdE0jA.jpeg"/></div></div></figure><p id="6cf2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">递归允许通过将问题分解成小问题来解决问题。递归函数总是包含两个部分:</p><ul class=""><li id="6f3e" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io">基本情况</strong> —递归函数计算特定值而不调用递归函数本身的终止条件</li><li id="c90e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">递归情况</strong> —调用自身的函数的一部分</li></ul><p id="866b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里最重要的部分是带有终止条件的<strong class="jx io">基础案例</strong>。如果你错过了它——递归无限期地运行，直到程序崩溃，因此作为一个经验法则——当你开始递归实现时——首先定义一个终止条件。</p><p id="6d59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们实现一个返回从1到N的数字之和的函数:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="cf87" class="lq lr in lm b gy ls lt l lu lv">sum(N) = N + sum(N-1) = <br/>       = N + (N-1) + sum(N-2) = <br/>       = N + (N-1) + (N-2) + sum(N-3) = <br/>         .... until N !== 1 ....<br/>       = N + (N-1) + (N-2) + ... + 1</span></pre><p id="19dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现如下所示:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/7391ec94eca2b564053f64996eb86764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AJioH3N_ax_xhVHsI4NNA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 1 — Recursion implementation</figcaption></figure><h1 id="58f8" class="mb lr in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">递归限制，调用堆栈</h1><p id="bb77" class="pw-post-body-paragraph jv jw in jx b jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks ig bi translated">递归有一个限制，它是由调用堆栈的可能最大大小定义的。这是什么意思？当我们调用一个函数时，JS引擎创建一个<em class="nd">函数执行上下文</em>，它保存函数处理所需的一切——局部变量、<code class="fe ne nf ng lm b">this</code>的值等等。并将它放在调用堆栈的顶部。让我们想象一下，我们调用一个函数<code class="fe ne nf ng lm b">sum(4)</code>。JS引擎将这个函数推到调用堆栈的顶部，并为带有局部变量的函数创建执行上下文，我们的函数只有一个局部变量<code class="fe ne nf ng lm b">n=4</code>:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/77c265f7adf52b7aa40576fbe384351e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-V0PVIhjEPbz_soJNZ0yJw.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 2</figcaption></figure><p id="e9d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<code class="fe ne nf ng lm b">n!==1</code>，我们需要调用另一个函数<code class="fe ne nf ng lm b">sum(3)</code>，JS引擎用一个新的执行上下文将这个新函数推到调用堆栈的顶部，这个新的执行上下文只包含一个局部变量<code class="fe ne nf ng lm b">n=3</code>:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/b2cb0a6d4efaa1fb37511c69445d2337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSUL9bjCU8i1J1rqEJbhJg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 3</figcaption></figure><p id="2eac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">调用堆栈继续增长，直到下一个函数达到终止条件，此时<code class="fe ne nf ng lm b">n==1</code>:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/a40078bf810b3806e5b75eafa794335a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dv4vuV1Fy0Eq41ciXjCaRA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 4</figcaption></figure><p id="8445" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们到达终止条件，调用栈就停止增长，JS引擎开始从调用栈中推出函数:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/edbd3866a791e58dc79a4acc6fa8396c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOhyTtVDF9y2OYsSutStOg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 5</figcaption></figure><p id="7ac0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是用执行上下文从调用堆栈中推出函数，其中<code class="fe ne nf ng lm b">n=2</code>:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/e1022f9591f204baa9b324407abdfdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1pfmeAyd6at06AS9chLqg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 6</figcaption></figure><p id="d83a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它一直持续到调用堆栈为空，并且我们到达全局程序的上下文:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/7ae0397b30c5f51631e915ca3947f312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlmJSgJgSWi2VEdCtySnRQ.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 7</figcaption></figure><p id="152c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嵌套函数调用的常见数量称为<strong class="jx io">一个递归深度</strong>，在我们的例子中，它等于<code class="fe ne nf ng lm b">N</code>。</p><p id="7aad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">递归深度的最大值受调用堆栈的最大大小限制。您肯定可以依赖10 000次调用，但是JS引擎是否允许您推送100 000次以上的嵌套函数调用(框架)值得怀疑。我已经在Chrome v. 92.0.4515.131中测试了实现的函数<code class="fe ne nf ng lm b">sum</code>，它允许我在<code class="fe ne nf ng lm b">n=10_428</code>时得到结果，在<code class="fe ne nf ng lm b">n=10_429</code>时崩溃</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/2df1f0c7f36b6722974682f5545dd430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgRIr3DGoXFIoVJNfnU-2Q.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 8</figcaption></figure><h1 id="6f4a" class="mb lr in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated"><strong class="ak">如果我达到了最大调用堆栈大小该怎么办</strong></h1><p id="7199" class="pw-post-body-paragraph jv jw in jx b jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks ig bi translated">如果你看一下图1中的框图，我相信你能认出它，它看起来类似于任何循环的框图(<em class="nd">，而对于</em>):</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/9f64de8d94385d1d2325c10ed67c2c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAwWJiukt-RvazeQDIiDSg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 9 — Comparison block diagram for recursion and loop</figcaption></figure><p id="303f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以不同的方式使用循环重写<code class="fe ne nf ng lm b">sum</code>函数:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/1944694764f504b91a02572bb20e4abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CrUNTtPS5bDb2i6Jb-J3g.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 10</figcaption></figure><blockquote class="np nq nr"><p id="3522" class="jv jw nd jx b jy jz ka kb kc kd ke kf ns kh ki kj nt kl km kn nu kp kq kr ks ig bi translated">这里的主要思想是:<strong class="jx io">任何递归都可以写成一个循环。此外，从性能角度来看，使用循环实现更加有效</strong></p></blockquote><p id="8cf2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，在这个句子之后，可能会有一个问题——使用递归而不是循环有什么好处？</p><p id="d7eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，使用循环是一种强制性的方法，在函数式编程中，我们需要遵循递归所遵循的声明性方法。</p><p id="2aed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个好处是递归实现更短更简洁，更容易掌握和维护。</p><h1 id="3b07" class="mb lr in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated"><strong class="ak">尾部调用优化(TCO) </strong></h1><p id="ccb3" class="pw-post-body-paragraph jv jw in jx b jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks ig bi translated">ES6提供了<em class="nd">尾部调用优化</em>，我们可以在不增加调用栈的情况下进行一些函数调用。当一个函数调用另一个函数作为最后一步(尾部位置)时，编译器知道当前函数上下文中没有编译器需要保留的内容来处理下一个函数调用，在这种情况下，JS引擎可能会丢弃当前堆栈帧，因为它没有更多工作要做。</p><blockquote class="np nq nr"><p id="a758" class="jv jw nd jx b jy jz ka kb kc kd ke kf ns kh ki kj nt kl km kn nu kp kq kr ks ig bi translated">在大多数情况下，您可以通过将所有必要的状态作为函数目标的一部分从一个函数上下文转移到下一个函数上下文来实现这一点。</p></blockquote><p id="772a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们遵循这条规则，按照编译器应用<em class="nd">尾调用优化</em>的方式重写图1中的递归。同样，主要思想是，我们应该将递归调用作为函数的最后一步，并将当前函数上下文中所有需要的变量作为参数放到下一个函数调用中:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/47d2558538bec9872a55ce997f862ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-asyAS6G7gFfjdB5-u70cg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 11— Recursion with TCO</figcaption></figure><p id="1d05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们比较一下，在不使用/使用尾部调用优化的情况下实现递归时，调用堆栈是什么样子的:</p><p id="46d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> —无TCO(图1中提供的实现):</strong></p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="90f0" class="lq lr in lm b gy ls lt l lu lv">sum(4)<br/>   4 + sum(3)<br/>      4 + 3 + sum(2)<br/>         4 + 3 + 2 + sum(1)<br/>            4 + 3 + 2 + 1<br/>         4 + 3 + 3<br/>      4 + 6<br/>   10<br/>return 10</span></pre><p id="9398" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> —具有TCO(图11中提供的实现):</strong></p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="1674" class="lq lr in lm b gy ls lt l lu lv">sum(4)<br/>   sum(3, 4)<br/>   sum(2, 7)<br/>   sum(1, 9)<br/>   return 10<br/>return 10</span></pre><p id="9e06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TCO递归的调用堆栈只包含全局上下文顶部的一个帧(图12)，而不是一个接一个堆叠的一堆帧(图4)。</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/ed4796a2e8ec0669f11557733593cf86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgRpq993ds_39G8I0RLRGg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 12</figcaption></figure><p id="14b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">TCO警告</strong></p><p id="ef97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不幸的是，在撰写本文时，Safari是唯一一款附带TCO的浏览器。Node在6.5版本中实现了tail调用，但是它被隐藏在一个标志后面(后来他们在Node 8中完全移除了对TCO的支持)。</p><p id="0984" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且V8引擎(Chrome浏览器、NodeJS)的TCO在未来实现上还有不确定性(更多详情<a class="ae nx" href="https://stackoverflow.com/questions/42788139/es6-tail-recursion-optimisation-stack-overflow" rel="noopener ugc nofollow" target="_blank">此处</a>)。</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/e547c99ba9aed8b42ad5403d31fe630c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwSe50W00JamV4LDKX8txA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Most browsers do not have support for TCO. Source: <a class="ae nx" href="https://kangax.github.io/compat-table/es6/" rel="noopener ugc nofollow" target="_blank">https://kangax.github.io/compat-table/es6/</a>.</figcaption></figure><p id="ce9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将向您展示一个方法<code class="fe ne nf ng lm b">console</code>,您可以用它来跟踪调用堆栈，并找出浏览器是否真正支持这个功能。现在是<code class="fe ne nf ng lm b">console.trace</code></p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/18d5f02437cc49af649c0f0594d10852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gR2Q8MuP1suM9ogvfUGPow.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 13 — console.trace for Chrome browser</figcaption></figure><h1 id="5a1b" class="mb lr in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">蹦床</h1><p id="4ba1" class="pw-post-body-paragraph jv jw in jx b jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks ig bi translated">蹦床是一种以迭代的方式模拟TCO的方法，对于控制函数栈增长非常理想。</p><p id="36f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它是一个函数，将另一个函数作为输入，并反复调用它，直到某个条件出现。这个函数可能看起来像这样:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="44af" class="lq lr in lm b gy ls lt l lu lv">const trampoline = fn =&gt; (...args) =&gt; {<br/>  let result = fn(...args)<br/>  while (typeof result === 'function') {<br/>    result = result()<br/>  }<br/>  return result<br/>}</span></pre><p id="be82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还需要重写我们的<code class="fe ne nf ng lm b">sum</code>函数，而不是调用函数本身，让我们封装另一个函数，让这个调用变得懒惰:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="c63b" class="lq lr in lm b gy ls lt l lu lv">function sum(n, acc = 0) {<br/>   return n === 0<br/>      ? acc<br/>      : () =&gt; sum(n - 1, acc + n)<br/>}</span></pre><p id="2d0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步——用<code class="fe ne nf ng lm b">trampoline</code>包装<code class="fe ne nf ng lm b">sum</code>函数并调用它:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="c279" class="lq lr in lm b gy ls lt l lu lv">const optimizedRecirsionFn = trampoline(sum);<br/>optimizedRecirsionFn(100_000)</span></pre><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/374bb894032f84d967e2df34a55c91af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBXCYr0QEKbUtwS8x2RZDQ.png"/></div></div></figure><h1 id="5c5c" class="mb lr in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">使用setTimeout模拟TCO</h1><p id="4fd1" class="pw-post-body-paragraph jv jw in jx b jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks ig bi translated"><strong class="jx io">它根本不应该用来优化递归</strong>，它只是一种帮助初学者更深入理解JS方法的技巧。</p><p id="fb0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">调用栈通常用于处理同步代码，但是如果我们使用JS的异步特性会怎么样呢？</p><p id="d371" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们调用递归的下一步时，让我们通过零超时的<code class="fe ne nf ng lm b">setTimeout</code>函数调用它，这允许JS引擎将这个函数放在<em class="nd">任务队列</em>中，而不是在调用栈顶推一个新的帧。一旦全局程序完成了所有同步操作，事件循环就将此函数推入空堆栈:</p><p id="e6da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看起来是这样的:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="4206" class="lq lr in lm b gy ls lt l lu lv">function <em class="nd">sum</em>(n, cb, acc = 0) {<br/>    if (n === 1) {<br/>        return cb(acc + n);<br/>    }<br/>    <em class="nd">setTimeout</em>(() =&gt; <em class="nd">sum</em>(n - 1, cb, acc + n), 0)<br/>}<br/>sum(50_000, res =&gt; console.log(res))</span></pre><p id="2cf6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这需要几个小时才能完成，但至少我们没有超过调用堆栈的最大大小:)。</p><p id="3dd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，这个实现只是为了好玩，不应该使用。</p><p id="6f24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nd">更多内容请看</em><a class="ae nx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nd">plain English . io</em></strong></a></p></div></div>    
</body>
</html>