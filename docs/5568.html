<html>
<head>
<title>How to Build A Plugin System with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js构建插件系统</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-plugin-system-with-node-js-68c097eb3a2e?source=collection_archive---------3-----------------------#2021-11-19">https://javascript.plainenglish.io/how-to-build-a-plugin-system-with-node-js-68c097eb3a2e?source=collection_archive---------3-----------------------#2021-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a53d20c39947268f0c9ac5b3fb1448ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qIwIRhKpV2I5nsTz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@thomasjsn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Thomas Jensen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c5b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你正在构建一个极简的产品，但是想要增加额外的定制或者扩展，那么插件是一个很好的方法。它们允许用任何人都可以创建的额外代码定制每个实例。</p><p id="03eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将用一个插件系统扩展一个最小的web服务器，创建一个插件，并在服务器上使用该插件。我已经创建了一个非常基本的网络服务器。我们将用它作为起始代码。</p><h1 id="3d78" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是插件</h1><p id="599c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">但是在我们开始之前，什么是插件？插件是一段额外的代码，它扩展了程序通常能做的事情。Web扩展就是一个很好的例子。他们利用现有的API，并在其上构建新的功能。在某些情况下，它们还可以用来修补主要软件提供商尚未解决的错误和缺陷。</p><p id="ccf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将构建一个请求计数插件，以及加载和卸载该插件的系统。</p><h1 id="46f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">入门指南</h1><p id="bfa5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们首先创建一个新的Node.js项目。我将在本教程中使用NPM，但我也会添加纱线命令。</p><ol class=""><li id="83f0" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">mkdir my-plugin-app</code></li><li id="0eb2" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">cd my-plugin-app</code></li><li id="3a68" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">npm init -y</code> ( <code class="fe mn mo mp mq b">yarn init -y</code>)</li><li id="b42c" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">npm i express</code> ( <code class="fe mn mo mp mq b">yarn add express</code>)</li></ol><p id="7a34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不会为我们的插件系统创建一个应用程序。相反，我们将使用这个起始代码。只有一个端点的简单服务器。创建一个<code class="fe mn mo mp mq b">index.js</code>文件并添加这个启动代码。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="aa3c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">我们的第一个插件</strong></h1><p id="e7d6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了了解我们的插件系统将会做什么，让我们创建一个包含插件需要的所有东西的小插件。我们将要实现的插件系统类型有两个事件。<code class="fe mn mo mp mq b">load</code>和<code class="fe mn mo mp mq b">unload</code>是我们将直接调用插件中任何代码的两次。<code class="fe mn mo mp mq b">load</code>设置任何额外的路由、中间件或任何其他插件的一部分，而<code class="fe mn mo mp mq b">unload</code>告诉我们安全地停止我们正在做的任何事情并保存任何持久数据。</p><p id="d225" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个插件将建立一个中间件来统计我们收到的请求数量。此外，它将添加一个API路由，这样我们就可以查询到目前为止已经发出的请求的数量。该插件将导出两个不同的函数，每个事件一个。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="2760" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">加载插件</strong></h1><p id="3547" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的插件系统将与主应用程序放在一个单独的类中，我们将把它放在一个新文件<code class="fe mn mo mp mq b">plugins.js</code>中。这个类的目的是加载和卸载插件。</p><p id="a447" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">load</code>函数获取一个插件文件的路径，并使用<code class="fe mn mo mp mq b">require</code>方法在运行时加载它。<code class="fe mn mo mp mq b">loadFromConfig</code>方法允许我们加载配置文件中定义的插件。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="108c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用一个<code class="fe mn mo mp mq b">plugins.json</code>文件来存储我们希望加载的所有插件的路径，然后调用<code class="fe mn mo mp mq b">loadFromConfig</code>方法来一次性加载它们。将<code class="fe mn mo mp mq b">plugins.json</code>文件放在与代码相同的目录中。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2427" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将在应用程序中创建一个插件实例。导入<code class="fe mn mo mp mq b">Plugins</code>类，在构造函数中创建一个实例，调用<code class="fe mn mo mp mq b">loadFromConfig</code>，将路径留空(默认为<code class="fe mn mo mp mq b">./plugins.json</code>)。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="1340" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">卸载插件</strong></h1><p id="fb99" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们现在需要处理从插件中导出的<code class="fe mn mo mp mq b">unload</code>方法。一旦我们这样做了，我们需要从插件集合中删除它。我们还将包含一个<code class="fe mn mo mp mq b">stop</code>方法，它将卸载所有插件。我们稍后将使用这种方法来实现安全关机。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="264a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">安全关机</strong></h1><p id="09ff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了确保插件在应用关闭时有机会卸载，我们需要调用<code class="fe mn mo mp mq b">Plugins.stop</code>。在<code class="fe mn mo mp mq b">index.js</code>代码中，我包含了一个<code class="fe mn mo mp mq b">stop</code>方法，当应用程序被终止时会调用这个方法，我们刚刚在<code class="fe mn mo mp mq b">Plugins</code>类中添加了一个<code class="fe mn mo mp mq b">stop</code>方法。所以当我们的app <code class="fe mn mo mp mq b">stop</code>方法被调用时，我们就调用<code class="fe mn mo mp mq b">Plugins.stop</code>方法。</p><p id="f34e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将以下内容添加到<code class="fe mn mo mp mq b">App.stop</code>方法中。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="757a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">结论</strong></h1><p id="39a2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">插件很酷，我们可以毫不费力地将它们添加到我们的应用程序中。插件系统可能比我在这里介绍的要复杂得多，但是现在你已经对什么是插件有了基本的了解，并且知道如何构建一个系统来为应用程序添加插件。</p><h1 id="802f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">挑战</strong></h1><p id="80de" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们只是触及了表面，所以这里有一些挑战，让你更进一步。</p><ul class=""><li id="8adf" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la nc mk ml mm bi translated">添加一些检查，以确保在每个插件中都导出了“load”和“unload”方法。</li><li id="ff38" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la nc mk ml mm bi translated">增加了对节点包的支持，可以作为一个插件使用，而不是一个单独的文件。在加载模块之前，请注意安装依赖项。</li><li id="2e3a" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la nc mk ml mm bi translated">最后，将此添加到您自己的项目中。找一个可以进行额外定制的项目，尝试添加你自己的插件管理器。</li></ul><p id="b8c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nd">更多内容看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="nd">plain English . io</em></strong></a></p></div></div>    
</body>
</html>