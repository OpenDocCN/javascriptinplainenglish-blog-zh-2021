<html>
<head>
<title>Making A Web-Based Flappy Bird Clone With p5.js | Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用p5.js制作基于Web的Flappy Bird克隆|第4部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/making-a-web-based-flappy-bird-clone-with-p5-js-part-4-9164d8d25f2f?source=collection_archive---------7-----------------------#2021-06-29">https://javascript.plainenglish.io/making-a-web-based-flappy-bird-clone-with-p5-js-part-4-9164d8d25f2f?source=collection_archive---------7-----------------------#2021-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/76f346c8e4d0ec32b885df850db8c5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*V35iN2RCMU_pOcLX8xK9mA.png"/></div></figure><h2 id="2344" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">概述</h2><p id="b572" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">这是Flappy鸟克隆系列的第4部分。你可以在这里找到第一部<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-web-based-flappy-bird-clone-with-p5-js-part-1-2913fde25c8a">，在这里</a>找到第二部<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/making-a-web-based-flappy-bird-clone-with-p5-js-part-2-c554254881b1">，在这里</a>找到第三部<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/making-a-web-based-flappy-bird-clone-with-p5-js-part-3-32d4e96b8737">。在上一篇文章中，我通过动画演示了bird的跳跃和下落，回顾了它的更新逻辑。有了这些，我们就有了制作游戏的所有组件，所以我们将在这个系列的最后一篇文章中关注游戏逻辑的添加。</a></p><h2 id="b56b" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">重访管道</h2><p id="5048" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">让我们想想这个游戏是怎么玩的。当你思考这个问题的时候，你得到一分的唯一时间是当小鸟经过一组管道的时候，游戏结束的唯一时间是当小鸟碰到一个管道或者地面的时候。所以管道是拼图中重要的一块，我们需要把我们的游戏逻辑和它们联系起来。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="b092" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">首先，让我们看看如何判断鸟儿何时通过了管道</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="57ad" class="jr js in lv b gy lz ma l mb mc">// Pipe.js</span><span id="eea1" class="jr js in lv b gy md ma l mb mc">function Pipe(){<br/> ...<br/> this.isPassed = (bird) =&gt; {<br/>  return bird.x &gt; this.x + Math.floor(this.scaledWidth / 2);<br/> };<br/>}</span></pre><p id="d415" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">简单地说，我们只需要检查鸟的x位置，以及它是否大于管道的x位置。在这种情况下，只有当鸟通过管道的中点时，才算通过。</p><p id="dd46" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">在我们继续之前，让我们也编写代码来检查鸟是否与管道发生了碰撞。</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="82bd" class="jr js in lv b gy lz ma l mb mc">// Pipe.js</span><span id="f78f" class="jr js in lv b gy md ma l mb mc">function Pipe(){<br/> ...<br/> this.isCollided = (bird) =&gt; {<br/>  const cx = bird.x;<br/>  const cy = bird.y;<br/>  const dia = BIRD_IMG[0].width * bird.SCALE * 0.85;</span><span id="8020" class="jr js in lv b gy md ma l mb mc">  const topPosition = this.y - this.scaledHeight - this.gap;<br/>  const collideTop = collideRectCircle(<br/>   this.x,<br/>   topPosition,<br/>   this.scaledWidth,<br/>   this.scaledHeight,<br/>   cx,<br/>   cy,<br/>   dia<br/>  );<br/>  const collideBottom = collideRectCircle(<br/>   this.x,<br/>   this.y,<br/>   this.scaledWidth,<br/>   this.scaledHeight,<br/>   cx,<br/>   cy,<br/>   dia<br/>  );</span><span id="e0a3" class="jr js in lv b gy md ma l mb mc">  return collideTop || collideBottom;<br/> };<br/>}</span></pre><p id="9c97" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">在这个方法中，我们使用一个名为collideRectCircle的函数来确定鸟是否与管道发生了碰撞。碰撞矩形的定义如下</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="d57b" class="jr js in lv b gy lz ma l mb mc">// Utils.js</span><span id="0fbd" class="jr js in lv b gy md ma l mb mc">collideRectCircle = function (rx, ry, rw, rh, cx, cy, diameter) {<br/> //2d<br/> // temporary variables to set edges for testing<br/> var testX = cx;<br/> var testY = cy;</span><span id="128a" class="jr js in lv b gy md ma l mb mc">// which edge is closest?<br/> if (cx &lt; rx) {<br/> testX = rx; // left edge<br/> } else if (cx &gt; rx + rw) {<br/> testX = rx + rw;<br/> } // right edge</span><span id="e690" class="jr js in lv b gy md ma l mb mc">if (cy &lt; ry) {<br/> testY = ry; // top edge<br/> } else if (cy &gt; ry + rh) {<br/> testY = ry + rh;<br/> } // bottom edge</span><span id="6bda" class="jr js in lv b gy md ma l mb mc">// // get distance from closest edges<br/> var distance = this.dist(cx, cy, testX, testY);</span><span id="2a1f" class="jr js in lv b gy md ma l mb mc">// if the distance is less than the radius, collision!<br/> if (distance &lt;= diameter / 2) {<br/> return true;<br/> }<br/> return false;<br/>};</span></pre><p id="de8a" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">老实说，我实际上是从一个库复制了这段代码，我现在不记得这个库的名字了，但是它应该对我们的目的有用。该代码用于检测一个圆是否与一个矩形发生碰撞，其中我们的鸟是圆，管道是矩形。我发现对于我们的目的来说，估计击中框是鸟上的一个圆是相当准确的——不相信我？好吧，让我们在鸟身上画个圈看看。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="me lo l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Seems close enough to me</figcaption></figure><h2 id="4bc3" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">记分</h2><p id="5a22" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">好了，现在我们可以检测小鸟何时通过管道，我们可以添加一个计分机制。首先，分数对象…</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="a263" class="jr js in lv b gy lz ma l mb mc">function Score(currentScore=0) {<br/> this.currentScore = currentScore;</span><span id="78ac" class="jr js in lv b gy md ma l mb mc"> this.show = () =&gt; {<br/>  textSize(32);<br/>  fill(255, 255, 255);<br/>  text(this.currentScore.toString(), 20, 40);<br/> };</span><span id="3ca5" class="jr js in lv b gy md ma l mb mc"> this.incrementBy = (amount) =&gt; {<br/>  this.currentScore += amount;<br/> };<br/>}</span></pre><p id="fe92" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">当然，文本对象仍然是一个p5对象，需要被明确告知在每一帧中呈现。</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="7067" class="jr js in lv b gy lz ma l mb mc">function pipesUpdate() {<br/> ...<br/> if (pipe.isPassed(bird) &amp;&amp; !pipe.isPassedCounted) {<br/>  score.incrementBy(1);<br/>  pipe.isPassedCounted = true; <br/> }<br/>}</span></pre><p id="dbc3" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">在这里，您可能已经注意到，如果我们已经通过了管道，我们只需在当前分数上加1。但是，我们还向管道添加了一个名为isPassedCounted的属性。记住pipesUpdate在每一帧都运行，这个检查让我们知道当我们第一次通过这个管道时，我们已经增加了分数，这样有助于在鸟已经通过管道后分数不会继续增加。</p><h2 id="44ba" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">杀死这只鸟</h2><p id="d6e3" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">我们已经非常接近完成游戏了。首先，让我们创建一个函数来设置所有的游戏开始条件，初始化我们需要的所有对象。</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="3dd9" class="jr js in lv b gy lz ma l mb mc">// index.js</span><span id="15f0" class="jr js in lv b gy md ma l mb mc">...<br/>function setup() {<br/> createCanvas(WIN_WIDTH, WIN_HEIGHT);<br/> //add the following lines to fix bugs<br/> angleMode(DEGREES); <br/> frameRate(30);<br/><br/> gameStartConditions();<br/>}</span><span id="62b8" class="jr js in lv b gy md ma l mb mc">function gameStartConditions() {<br/> bird = new Bird();<br/> ground = new Ground();<br/> score = new Score(0);<br/> gamePlay = true;<br/> pipes = [];<br/>}</span></pre><p id="851b" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">正如你在这里看到的，我们已经封装了游戏开始所需的所有对象初始化。我们也将把游戏设置为真——只要游戏仍然是真的，鸟就是活着的。一旦游戏性是假的，你应该不能让鸟跳了，因为它掉到了地上，地面上的位置更新和管道应该停止。这个逻辑可以在我们的draw函数中轻松控制。</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="8bcb" class="jr js in lv b gy lz ma l mb mc">// index.js<br/>function draw() {<br/> background(BG_IMG);</span><span id="78fd" class="jr js in lv b gy md ma l mb mc"> if (gamePlay) {<br/>  pipesUpdate();<br/>  ground.update();<br/> }</span><span id="0cfd" class="jr js in lv b gy md ma l mb mc"> pipes.forEach((pipe) =&gt; {<br/>  pipe.show();<br/>  });</span><span id="bb69" class="jr js in lv b gy md ma l mb mc"> score.show();<br/> ground.show();</span><span id="c47e" class="jr js in lv b gy md ma l mb mc"> bird.update();</span><span id="a524" class="jr js in lv b gy md ma l mb mc"> imageMode(CORNER);<br/>}</span></pre><p id="35e3" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">如果游戏是真的，我们想更新管道和地面。我们还希望管道和地面即使在游戏结束后仍然显示在屏幕上——这就是为什么我们将这些对象的显示和更新方法分开。这里我们仍然需要担心的一件事是，这只鸟仍然能够跳跃——实际上，这只鸟又是如何跳跃的呢？</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="a5ec" class="jr js in lv b gy lz ma l mb mc">function keyPressed() {<br/> if (key === “ “) {<br/> jumpEvent();<br/> }<br/>}</span><span id="b236" class="jr js in lv b gy md ma l mb mc">function mouseClicked() {<br/> jumpEvent();<br/>}</span><span id="906f" class="jr js in lv b gy md ma l mb mc">function jumpEvent() {<br/> gamePlay &amp;&amp; bird.jump();<br/> !gamePlay &amp;&amp; bird.hitGround() &amp;&amp; gameStartConditions();<br/>}</span></pre><p id="723d" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">正如你所看到的，我们将jumpEvent提取到一个函数中，在这个函数中，我们说如果游戏性仍然是真的，那么小鸟可以跳跃，但是如果游戏性是假的，小鸟撞到了地面，用户事件将触发游戏重置，用户可以重新开始游戏。</p><h2 id="cec6" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">还有几件事</h2><p id="411a" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">我们还没有处理导致这只鸟死亡的实际事件。</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="e3d7" class="jr js in lv b gy lz ma l mb mc">// index.js<br/>function pipesUpdate() {<br/> ...</span><span id="4609" class="jr js in lv b gy md ma l mb mc"> pipes.forEach((pipe, idx) =&gt; {<br/>  ...</span><span id="f620" class="jr js in lv b gy md ma l mb mc">  if (pipe.isCollided(bird)) {<br/>   gamePlay = false;<br/>  }<br/> });<br/>}</span></pre><p id="7f85" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">如果这只鸟撞到地面，我们也希望它死掉</p><pre class="lj lk ll lm gt lu lv lw lx aw ly bi"><span id="d403" class="jr js in lv b gy lz ma l mb mc">// Bird.js</span><span id="647a" class="jr js in lv b gy md ma l mb mc">function Bird(){<br/> ...<br/> this.update = () =&gt; {<br/>  ...<br/>  if (this.hitGround()) {<br/>   gamePlay = false;<br/>  }<br/> }<br/>}</span></pre><h2 id="914b" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">好了</h2><p id="00f4" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">如果你已经完成了这篇教程，那么恭喜你。你现在应该能够用p5做一些很酷的事情，也希望能学到一点如何制作一个简单的游戏。</p><p id="5585" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">当然，为了简洁起见，有许多地方我必须浏览，但是如果有任何问题，请让我知道。你可以点击此链接<a class="ae li" href="https://birdflap.netlify.app/" rel="noopener ugc nofollow" target="_blank">https://birdflap.netlify.app/</a>试用游戏的部署版本。</p><p id="fc48" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated">如果有足够的需求，我可能还会做一个如何在Netlify上部署游戏的教程。我就说这些。</p><p id="4a09" class="pw-post-body-paragraph kn ko in kp b kq lp ks kt ku lq kw kx ka lr kz la ke ls lc ld ki lt lf lg lh ig bi translated"><em class="mj">更多内容尽在</em><a class="ae li" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kp io"><em class="mj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>