<html>
<head>
<title>What are Pure Functions and Why are They Useful?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是纯函数，为什么有用？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/pure-functions-why-c925c55347b8?source=collection_archive---------4-----------------------#2021-09-26">https://javascript.plainenglish.io/pure-functions-why-c925c55347b8?source=collection_archive---------4-----------------------#2021-09-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b38a2bf9726e30a56a375eac7292632e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5qulAJmALcvCKAYL"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ed5f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">纯函数使得应用程序状态<strong class="kc io"> <em class="ky">在执行的任何时候都是可预测的</em> </strong>。这极大地减少了我们应用程序中容易出错的地方。</p><p id="a7be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看两段代码来理解纯函数。</p><p id="ef0f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码1:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="89b4" class="li lj in le b gy lk ll l lm ln"><strong class="le io">const addPure = (a , b) =&gt; a + b<br/>const subPure = (a , b) =&gt; a - b<br/></strong>const addOutput = <strong class="le io">addPure</strong> (1 , 2) // 3<br/>const subOutput = <strong class="le io">subPure</strong> (10 , 5) // 5<br/>const addOutput = <strong class="le io">addPure</strong> (1 , 2) // 3<br/>const subOutput = <strong class="le io">subPure</strong> (10 , 5) // 5</span></pre><p id="b42a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码2:世纪之争的两个不纯函数。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="e1e8" class="li lj in le b gy lk ll l lm ln">let add1 = 5<br/>let add2 = 10<br/>let sub1 = 20<br/>let sub2 = 10</span><span id="7bb2" class="li lj in le b gy lo ll l lm ln">const <strong class="le io">addImpure</strong> = (a1, a2) =&gt; {<br/>  // My masterstroke addition algorithm.<br/>  a1 = a1 + add1<br/>  a2 = a2 + add2<br/>  <br/>  // Also, Let me modify sub1 a lil bit. Why not?<br/>  sub1 = sub1 + (sub1 - sub2) * 2</span><span id="c258" class="li lj in le b gy lo ll l lm ln">  // return the carefully crafted output<br/>  return a1 + a2<br/>}</span><span id="c6f1" class="li lj in le b gy lo ll l lm ln">const <strong class="le io">subImpure</strong> = (s1, s2) =&gt; {<br/>  // PI is an important recipe while cooking subtraction.<br/>  s1 = s1 &gt; Math.PI ? s1 + sub1 : (s1 - add2) * 3<br/>  s2 = Math.fround(s2 * Math.PI - sub2)</span><span id="d25a" class="li lj in le b gy lo ll l lm ln">  // Oh yea? eat this.<br/>  add1 = 0<br/>  add2 = 0</span><span id="ee67" class="li lj in le b gy lo ll l lm ln">  return s1 - s2<br/>}</span><span id="89df" class="li lj in le b gy lo ll l lm ln">const ImpureAddOutput = addImpure(1, 2) // 18<br/>const ImpureSubOutput = subImpure(10, 5) // 44.29203653335571<br/>const ImpureAddOutput2 = addImpure(1, 2) // 3<br/>const ImpureSubOutput2 = subImpure(10, 5) // 104.29203653335571</span></pre><p id="efd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子可能看起来滑稽或愚蠢，你可能会想"<em class="ky">在现实生活中谁会这样编码呢？</em>”。</p><p id="96d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">杂质开始很简单。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="1afc" class="li lj in le b gy lk ll l lm ln">Hey, Let me just update the wish list count in the nav bar Component <strong class="le io"><em class="ky">along with</em></strong> <strong class="le io"><em class="ky">this</em></strong>.</span></pre><p id="fd0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">两个星期后，我们会有一个让我们挠头的错误，“谁在更改我在导航栏中的愿望清单计数？<em class="ky">太诡异了。”</em></p><p id="db8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">纯函数的核心原则是，</p><ol class=""><li id="df7f" class="lp lq in kc b kd ke kh ki kl lr kp ls kt lt kx lu lv lw lx bi translated">在应用程序执行的任何时间点，当使用<strong class="kc io">相同输入</strong>调用时，这些函数保证返回<strong class="kc io">相同输出</strong>。</li><li id="ce8f" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated">执行<strong class="kc io">无副作用</strong>。不修改外部状态，不写入数据库，不记录控制台日志，等等。</li></ol><h2 id="9d77" class="li lj in bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated">没有副作用？</h2><p id="0da4" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">如果不改变什么，软件是没有用的。用户在应用程序中执行的任何操作都是副作用。它需要写入数据库、更新值等等。</p><p id="77ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，学习这种技术有什么意义呢？在讨论了几个要点后，我们将进入那一部分。</p><h2 id="24db" class="li lj in bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated">减压器模式</h2><p id="862b" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">好吧。您想要修改应用程序中的状态或对象。让我们用纯洁的方式来做它。</p><p id="df04" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请看<strong class="kc io">下面的<em class="ky">减速器</em>下面的</strong>功能。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ae26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要点</p><ul class=""><li id="c2b8" class="lp lq in kc b kd ke kh ki kl lr kp ls kt lt kx nb lv lw lx bi translated"><strong class="kc io">不变性:</strong><code class="fe nc nd ne le b">initialState</code>将在应用生命周期的任何时间点保持<code class="fe nc nd ne le b">{name:’John’, age: 87}</code>。我们创建的任何对象都将保持不变，直到它们被垃圾回收。没有人会变异！</li><li id="8655" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx nb lv lw lx bi translated">我们使用<code class="fe nc nd ne le b">reducerFunction</code>为我们做改变。我们通过<strong class="kc io">状态</strong>和在该状态下要执行的<strong class="kc io">动作</strong>。如果没有变异，它会根据动作类型生成一个新状态并返回。</li><li id="085c" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx nb lv lw lx bi translated"><code class="fe nc nd ne le b">state</code>可以代表我们需要修改的任何状态。<code class="fe nc nd ne le b">action</code>参数通常携带一个<strong class="kc io">类型的</strong>和可选的<strong class="kc io">有效载荷</strong>数据，减速器功能可能需要这些数据来进行状态修改。</li></ul><p id="e237" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更多要点:</p><ul class=""><li id="2975" class="lp lq in kc b kd ke kh ki kl lr kp ls kt lt kx nb lv lw lx bi translated">reducer函数需要知道状态的结构。</li><li id="63b6" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx nb lv lw lx bi translated">如果你想知道为每个变化创建一个新的实例有多高效。</li></ul><h2 id="d3e2" class="li lj in bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated">纯函数是如何无bug的？</h2><p id="dc71" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">他们不是。在上面的例子中，我们可以修改案例<code class="fe nc nd ne le b">‘DEC_AGE’</code>来增加年龄。这是意想不到的行为。那是一只虫子。</p><p id="982a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不可变的特性允许像Redux DevTools这样的工具做下面的事情。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e5c07ffd796e652e4a3c9b89b0002c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*5Yav6bbvwfdJxzpkU8Y6jQ.gif"/></div></figure><blockquote class="ng"><p id="d002" class="nh ni in bd nj nk nl nm nn no np kx dk translated">我们可以像视频中的帧一样跟踪状态实例。对于可变数据结构，这是不可能的。</p></blockquote><p id="8a7c" class="pw-post-body-paragraph ka kb in kc b kd nq kf kg kh nr kj kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">它跟踪每一个被派遣的行动。(不再有控制台日志)。并且我们可以精确定位导致意外状态变化的动作。</p><p id="7fb1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想更详细地了解redux架构，请跟随<a class="ae jz" href="https://karthickragavendran.medium.com/enterprise-application-architecture-with-redux-time-machine-attached-3da8c12b115a" rel="noopener">这个</a>。</p><h2 id="d80d" class="li lj in bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated">隔离我们项目中不纯的代码。</h2><blockquote class="ng"><p id="69ac" class="nh ni in bd nj nk nv nw nx ny nz kx dk translated">尽可能把功能做的纯粹一些。这使得不纯的代码在应用程序崩溃时备受指责。</p></blockquote><p id="48c2" class="pw-post-body-paragraph ka kb in kc b kd nq kf kg kh nr kj kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">任何项目都有哪些杂质？将数据库调用或任何不纯的代码放在一个单独的模块中，您甚至可以将其命名为<code class="fe nc nd ne le b">sideEffects.ts</code>！</p><p id="068f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您正在使用React，请使用像redux这样的功能状态管理系统，它会自动使项目的大部分功能正常化。我开始使用redux时并没有意识到它的好处，但后来我意识到使用redux的项目相对来说更健壮，而且不太容易出错。</p><p id="9d8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这都是关于纯函数的。有意识的努力写尽可能多的函数<strong class="kc io"> <em class="ky">纯</em> </strong>。隔离不纯的函数。</p><p id="945a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/c5825f67d5c54cb8751a50c66da043c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*zUm7UlLpJyuQNRrT-ZqOSA.png"/></div></figure><p id="a8c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>