<html>
<head>
<title>Two Sum Problem: Hash Map Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两个和问题:哈希映射解决方案</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/two-sum-problem-hash-map-solution-581779a56022?source=collection_archive---------6-----------------------#2021-03-31">https://javascript.plainenglish.io/two-sum-problem-hash-map-solution-581779a56022?source=collection_archive---------6-----------------------#2021-03-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="17bd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果你在算法上挣扎，害怕它们，或者只是不知道从哪里开始，这篇文章是给你的！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ffe8e4961b1b486a4a716af37138c8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GUQMpGChfpIHwGVs.jpg"/></div></div></figure><p id="5889" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以一起来看一个最常见的、“简单”级别的求职面试问题:<strong class="kq io">两个总和</strong>。这个问题有很多种，所以一定要向你的面试官澄清给定场景的确切措辞/细节，并考虑任何潜在的边缘情况(如空数组、重复元素、负数或0等)。你的面试官会欣赏你的想法，可能会给你更多的信息，对你有很大的帮助。我将把重点放在标准的问题场景上，它的措辞相当宽容，大概是这样的:</p><p id="e3dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">“给定一个非空的非重复整数数组和一个目标和，返回两个数字(任意顺序)的数组，这两个数字的和达到目标和。”</em></p><p id="39b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">快速边注:有时你可能会得到一个“真实生活”的场景，这实际上是<strong class="kq io">两个伪装的总和</strong>，这实际上发生在我的一个朋友身上。他被要求考虑一系列不同长度的电影，一次飞行的总时长，并被要求编写一个算法，返回两个不同的电影，其长度加起来等于一次飞行的长度。这是典型的“伪装的两个总和”,你需要能够很快发现这一点。</p><h2 id="dbdd" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak">解决方案</strong></h2><p id="710f" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">通常有三种方法来解决这个问题，它们的效率程度不同:暴力破解(效率最低)、二分搜索法(比暴力破解好，但还不够好)和散列图/表(最佳解决方案)。</p><p id="d0d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我现在将提供一种编写散列映射解决方案的可能方法，然后解释为什么它是三种方法中最有效的。</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="1944" class="ll lm in mk b gy mo mp l mq mr">function twoSum(array, target) {</span><span id="7468" class="ll lm in mk b gy ms mp l mq mr"> let storage = {}  // declaring our storage hash</span><span id="dfcc" class="ll lm in mk b gy ms mp l mq mr"> for (const num of array) {</span><span id="2e4d" class="ll lm in mk b gy ms mp l mq mr">  const comp = target - num<br/> <br/>  if (comp in storage) {<br/> <br/>   return [comp, num]<br/> <br/>  } else {<br/> <br/>   storage[num] = true  // storing the integer in our hash<br/> <br/>  }</span><span id="7701" class="ll lm in mk b gy ms mp l mq mr"> }<br/>  <br/> return [] // if no match is found, return an empty array</span><span id="4bac" class="ll lm in mk b gy ms mp l mq mr">}</span></pre><p id="b84c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我认为这里最重要的一行是<em class="lk"> for </em>循环中的第一行，在这里我们声明了一个<em class="lk">const</em>comp(comp的缩写)。如果我们有一个整数数组，我们将通过一个接一个地寻找我们的获胜对，我们也有一个目标和，我们需要知道我们需要添加到数组中的每个整数，以弥补和。我们通过从目标总和中减去num(数组中的整数)来计算这个数字。</p><p id="3482" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们有了丢失的部分，我们需要检查我们在开始时声明的(最初为空的)存储散列，看看它是否有我们的补整数。在迭代的第一层，当我们还在查看数组中的第一个整数时，我们的存储散列是空的，所以我们将第一个整数作为值为true的<strong class="kq io">键</strong>存储在那里。我们对数组中的每个整数做同样的事情，在我们的散列中寻找补码，如果我们还没有存储它，我们就把我们的整数存储在散列中，然后继续处理数组中的下一个整数。我们的散列随着我们在数组中移动而增长，使用散列作为参考点，并用不成功的整数填充它，直到我们遍历了整个数组。如果在查看了数组中的每个整数之后，我们都没有找到补数，那么我们将返回一个空数组，以表示没有两个不同的整数可以加到目标上。此时，我们也将数组中的每个整数放入存储哈希中。</p><p id="dc50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它有助于将这个过程可视化，这个过程本质上是两个步骤:从数组中的第一个数字开始，检查最初为空的散列的补码，然后将第一个数字存储在散列中。然后查看数组中的第二个数字，并在哈希中查找包含第一个(前一个)数字的补码。如果在散列中找不到补码，就移动到第三个数字，重复这个过程，直到找到补码。</p><p id="e847" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于哈希映射作为一种数据结构的性质，这种解决方案是最佳的。如果你走蛮力路线，你将会以无数的嵌套循环结束，这将是昂贵的。二分搜索法路线会变得不必要的复杂(在我看来),有更多的代码行，而且比哈希表更昂贵。一般来说，我建议在需要重复查找时使用散列。对于时间和空间复杂度来说，哈希映射解决方案的成本是<strong class="kq io"> O(n)，因为它只需要检查内存中的特定位置。</strong></p><p id="60de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">希望这对你的算法之旅有所帮助！</p><p id="62b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容尽在</em><a class="ae mt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>