<html>
<head>
<title>How Multiple Requests Work with Single Thread, Event Loop &amp; Blocking Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多个请求如何与单线程、事件循环和阻塞代码一起工作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/single-thread-event-loop-blocking-code-e023f9bc7ce5?source=collection_archive---------8-----------------------#2021-02-19">https://javascript.plainenglish.io/single-thread-event-loop-blocking-code-e023f9bc7ce5?source=collection_archive---------8-----------------------#2021-02-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6b0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">必须记住Node.js只使用一个JavaScript线程。</p><p id="07d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的问题是，我们如何提出多个请求？</p><p id="a95f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">事件</strong> <strong class="jm io">循环</strong>—<strong class="jm io"><em class="ki">事件循环</em> </strong>不处理传入的文件，但它处理回调，这样当我们的代码被发送到<em class="ki">工作池</em>，在那里我们的应用程序被重载，它将在<em class="ki">工作池</em>完成后触发回调(就像当我们写一个文件时)，然后由<strong class="jm io"> <em class="ki">事件循环</em> </strong>处理。</p><p id="1286" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">工人池:</strong>工人池独立于<strong class="jm io">事件循环</strong>和<strong class="jm io">请求</strong>中的<strong class="jm io">工作。这将在独立于事件循环的线程上运行。</strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b54da9d0df1964dd01d8ffe81056c19b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJjwaNvvML6iDnDQAAAzrA.png"/></div></div></figure><p id="f60e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">关于事件循环的更多信息</strong></p><p id="0006" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件循环由Node.js运行。它保持Node.js运行，并处理所有工作池回调。它通过删减Node.js代码来实现这一点。记住事件循环有一个顺序，它通过回调的顺序。</p><p id="aa0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">事件循环顺序</strong></p><p id="f409" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在每个循环的开始，事件循环:</p><ul class=""><li id="b926" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><strong class="jm io">首先</strong>检查是否有任何<strong class="jm io">定时器</strong>比如SetTimeout，setInterval这些都是回调()</li><li id="1126" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><strong class="jm io">然后</strong>，事件循环将检查是否有可能已经被推迟的<strong class="jm io">未决</strong>回调()。如果这些callback()操作完成，事件循环将依次执行所述callback()。</li><li id="068b" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><strong class="jm io">轮询:</strong>上述循环完成后，<strong class="jm io">轮询阶段</strong>将开始。这基本上意味着事件循环将检索任何新的I/o event并执行它们的回调。如果回调不能完成，那么它将推迟回调，并在下一次迭代中返回，检查回调是否准备好执行。轮询阶段还将检查是否有任何要执行的计时器回调，如果有，将跳转到计时器执行。</li><li id="b091" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><strong class="jm io">检查</strong>将执行<strong class="jm io">立即回调()</strong>，并且仅在所有其他打开的回调被执行或延迟后执行。</li><li id="6d58" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><strong class="jm io"> Close: </strong>现在，在事件循环迭代结束时，Node.js将执行任何快速事件回调()。</li><li id="fc43" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated"><strong class="jm io">最后</strong>我们可能会退出进程，但前提是有任何打开的事件监听器。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lj"><img src="../Images/7feb4898f9380702a5855b4ee8f69653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUW5BmoXrg0V11KZ6TZiXg.png"/></div></div></figure><ul class=""><li id="35ea" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><em class="ki">投票阶段审美范例</em></li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lk"><img src="../Images/b90e413d170a0757fbd5382d0b1f1705.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*9tMaLXBRluJMyCKwjaJ9rA.png"/></div></div></figure><p id="223f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">投票阶段美学示例(检查计时器回调时)</em></p><h2 id="5b24" class="ll lm in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">Node.js服务器上的事件侦听器</h2><p id="3d6b" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">当我们用Node.js createServer()打开事件监听器时，这是一个永远不会关闭的无限引用，所以我们的事件循环永远不会退出。</p><p id="5d06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，默认情况下，createServer()方法从不存在。</p><p id="06c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样。希望这篇文章对你有所帮助。谢谢你。</p><p id="bdd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容尽在</em><a class="ae mj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ki">plain English . io</em></a></p></div></div>    
</body>
</html>