# 理解记忆化&使用记忆反应钩子

> 原文：<https://javascript.plainenglish.io/memoization-the-usememo-react-hook-9aeddc96d6fd?source=collection_archive---------11----------------------->

![](img/c1eb275809632f33c4fce2f84fe24b27.png)

Let’s Memoize!

在 React 的组件生命周期中，当进行更新时，组件被重新呈现。如果检测到 React 的虚拟 DOM 和浏览器内 DOM 之间存在差异(即 difs ),就会出现这种情况，在这种情况下，包含 difs 的组件(以及这些组件的任何子组件)会在浏览器内重新呈现。如果你对这个概念不熟悉，或者你想重温一下 React 的虚拟 DOM 的功能，可以看看我在下面链接的关于这个主题的帖子(*插件*)。

[](https://denalibalser.medium.com/react-the-virtual-dom-d450b72df918) [## React &虚拟 DOM

### 首先，域对象模型(DOM)是由浏览器解析的表示，由文档的…

denalibalser.medium.com](https://denalibalser.medium.com/react-the-virtual-dom-d450b72df918) 

虽然这一功能是 React 如此强大的部分原因，但如果您的组件包含由于与另一个组件连接而需要重新呈现的昂贵函数，它很容易降低应用程序的性能。此外，当 React 查找组件中的变化时，可能会检测到 JavaScript 处理浅层比较和等式的方式导致的意外 difs 导致冗余的重新呈现。

如果您的组件包含昂贵的操作(例如长循环函数或从 API 获取大量数据)，这些不必要/意外的重新渲染会显著影响性能并导致较差的用户体验。React 引入了`memo`概念来解决这个问题。

## 记忆入门

*记忆化*是一种优化技术，通过将昂贵的函数调用结果存储在缓存中(以便有效地“记住”)并在再次提供相同参数时返回这些结果，来提高程序的速度。当这种技术应用于一个函数时，该函数被*记忆*。

举个简单的例子，假设我们有一个函数，它接受一个整数作为参数，并返回该输入乘以 **2** 。我们提供 **2** 作为函数调用的参数，并返回**4**——如果该函数在每次将 **2** 作为参数提供给函数调用时使用记忆，结果将被记忆并返回，而无需执行函数中的表达式。

虽然上面的例子非常简单，但是您可以想象在重新呈现组件的上下文中，对于一个更复杂、更昂贵的函数，记忆化将会带来多大的好处。

## 使用 useMemo 提高性能

`useMemo`是一个 React 钩子，它可以通过记忆来帮助提高应用程序性能——或者存储昂贵函数的结果，并在组件重新呈现时显示存储的结果，而不必重新运行函数，除非提供给函数的输入发生变化(在这种情况下，函数将重新运行)。

现在，`useMemo`长什么样？参考 [React 文档](https://reactjs.org/docs/hooks-reference.html#usememo)，`useMemo`表示如下:

```
const memoizedValue = React.useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

如上所示，`useMemo`接受一个函数和一组依赖项。这些依赖项的作用类似于函数中的参数。依赖列表中的元素是`useMemo`寻找的——如果在重新渲染之前和期间依赖之间没有差异，那么函数结果将保持不变。如果存在依赖性差异，则该函数将在重新渲染期间重新运行。可以想象，这可以显著降低重新呈现组件的开销，因为整个组件都可以重新呈现，而不必重新运行函数(如果依赖关系保持不变)，相反，存储的结果将在组件重新呈现中返回。

`useMemo`的主要用例是包装大而昂贵的函数，如果在每次重新渲染时重新运行，会降低应用程序的性能。

下面是一个将`useMemo`应用于一个项目数组的例子，该数组使用了两个昂贵的函数:

```
const Cats = React.useMemo(() =>
  allTheCats.map(cat => ({
    ...cat,
    catProp1: firstExpensiveFunction(props.first),
    catProp2: secondExpensiveFunction(props.second)
  })), [allTheCats]
)
```

这里，`useMemo`函数将在第一次渲染时运行(因为依赖项是新的)，线程将被阻塞，直到两个昂贵的函数完成。在下面的组件重新渲染中，如果`allTheCats`没有改变，这些昂贵的函数不需要重新运行。初始函数调用的结果将存储在`Cats`变量中并从该变量中访问，并且保持不变，直到依赖关系发生变化。

由此产生的用户体验就好像这些昂贵的功能被即时呈现，使得`useMemo`的应用程序更适合组件中昂贵的同步功能。

## 要记住的事情

在编写代码时，最好先写出函数，然后再看是否可以重构来优化性能。在应用程序中过多使用`useMemo`会对性能产生负面影响。

为了确定您是否应该合并`useMemo`，您可以利用分析工具来定位可以通过使用`useMemo`来改进的性能问题。何时记忆的一个例子是在一个函数中定义了大量的变量(占用大量内存)。

请记住，`useMemo`钩子有可能提高应用程序的性能——但是如果过度使用也会降低应用程序的速度，因为它用得越多，应用程序需要分配的内存就越多。

*更多内容尽在*[***plain English . io***](http://plainenglish.io/)