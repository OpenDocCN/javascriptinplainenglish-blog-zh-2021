<html>
<head>
<title>Combine GraphQL with TypeORM in NestJS using Perch Query Builder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Perch查询生成器在NestJS中将GraphQL与TypeORM结合起来</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/combine-graphql-with-typeorm-and-nestjs-using-perch-query-builder-503e6342c35e?source=collection_archive---------6-----------------------#2021-01-03">https://javascript.plainenglish.io/combine-graphql-with-typeorm-and-nestjs-using-perch-query-builder-503e6342c35e?source=collection_archive---------6-----------------------#2021-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/eea791c7b003f3b8b0dd169d5b16e37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJlTGC7MMbEfTYXPgZw96w.png"/></div></div></figure><div class=""/><div class=""><h2 id="5684" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">无限制的规范化深度、参数、过滤、排序和分页，无需为每个ORM实体定制特殊的逻辑</h2></div><p id="6ab4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">免责声明:我是Perch查询构建器包的作者。</p><p id="5a94" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">本文假设您已经基本掌握了<a class="ae lk" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>，以及它是如何用<a class="ae lk" href="https://docs.nestjs.com/techniques/database" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>和<a class="ae lk" href="https://docs.nestjs.com/graphql/quick-start" rel="noopener ugc nofollow" target="_blank"> NestJS GraphQL包</a>实现的。如果你正在寻找如何启动和运行一个基本项目，看看链接中发布的文档。本文还使用了代码优先的方法，如果您不确定这是什么意思的话<a class="ae lk" href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/" rel="noopener ugc nofollow" target="_blank">这</a>很好地概括了模式优先方法的优点和区别。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="ef77" class="ls lt iy bd lu lv lw lx ly lz ma mb mc ke md kf me kh mf ki mg kk mh kl mi mj bi translated">什么，为什么，为谁</h1><p id="9585" class="pw-post-body-paragraph kn ko iy kp b kq mk jz ks kt ml kc kv kw mm ky kz la mn lc ld le mo lg lh li ig bi translated">GraphQL正迅速成为未来API的主要组成部分，它提供了一个新的、更加动态的视角来看待应用程序的数据层应该如何使用和开发。使用GraphQL优先的方法，每个特性都围绕着一个GraphQL模式，允许您的前端团队和API团队独立工作，知道这两个部分在准备就绪时将一起工作。我们可以在一个请求中提供我们想要的所有属性和关系，而不是简单的解析相同对象结构的REST API端点(可能只是查找其他端点来代替实际的子节点)。</p><p id="fa14" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在我使用NestJS和TypeORM的经验中，GraphQL的集成有点古怪。首先，查询的结构和深度只在一个半神秘的对象(<em class="lj">@ Info()Info:graphqresolveinfo</em>)中提供给自定义解析器，并且没有明确的途径来处理查询中的选定属性，如果我们想要构造TypeORM查询以满足传入GraphQL查询的深度要求，这是一个问题。</p><p id="5f21" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这个包的目标是在GraphQL和TypeORM实现之间架起一座桥梁。PerchQueryBuilder提供了所有这些与实体的文字结构无关的特性，允许您轻松简单地与GraphQL集成，而不是编写一个定制的解析器，它只能深入到<em class="lj"> n </em>层，或者编写您自己的定制排序、过滤和分页处理。由于这个包只是试图将GraphQL转换成TypeORM，所以处理查询时就好像它们是对ORM实体属性和关系名称的直接转换，因为它依赖于TypeORM对实体的定义。例如，如果您有一个名为Book的实体，它与一个名为<em class="lj"> author </em>的author实体有多对一的关系，那么您需要指定<em class="lj"> author </em>作为查询的一个选定属性(以及Author下的任何属性)来检索它。</p><p id="867e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这个包是为那些希望构建API层的开发人员准备的，当他们的模式在ORM中定义时，他们可以检索和提供对象。例如，选择了<em class="lj">标题</em>属性的图书查询检索图书及其标题，选择了<em class="lj">图书</em>关系的作者查询检索作者及其基础图书等。没有通过事件层触发器或其他形式的对象操作(通过请求)分配的计算属性，尽管此包没有添加任何限制或干扰这些类型的操作。</p><h1 id="cada" class="ls lt iy bd lu lv mp lx ly lz mq mb mc ke mr kf me kh ms ki mg kk mt kl mi mj bi translated">装置</h1><p id="a04a" class="pw-post-body-paragraph kn ko iy kp b kq mk jz ks kt ml kc kv kw mm ky kz la mn lc ld le mo lg lh li ig bi translated">从npm下载Perch查询构建器包</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="1004" class="nd lt iy mz b gy ne nf l ng nh">$ npm i --save perch-query-builder@latest</span></pre><h1 id="015b" class="ls lt iy bd lu lv mp lx ly lz mq mb mc ke mr kf me kh ms ki mg kk mt kl mi mj bi translated">使用</h1><p id="09bb" class="pw-post-body-paragraph kn ko iy kp b kq mk jz ks kt ml kc kv kw mm ky kz la mn lc ld le mo lg lh li ig bi translated">Perch Query Builder是一个尽可能轻量级和不引人注目的包，这意味着它不需要任何特殊的配置或导入到模块中。对于我们的文件结构，假设我们有以下解析器、实体和参数</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="8bf7" class="nd lt iy mz b gy ne nf l ng nh">+-- entities<br/>|   +-- book.ts<br/>|   +-- author.ts<br/>+-- resolvers<br/>|   +-- book-resolver.ts<br/>|   +-- author-resolver.ts<br/>+-- arguments<br/>|   +-- book-args.ts<br/>|   +-- author-args.ts<br/>+-- app.module.ts</span></pre><p id="be86" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是我们的图书实体</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Our Book Entity</figcaption></figure><p id="0201" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是我们的作者实体:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Our Author entity</figcaption></figure><p id="9893" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是我们书中的论点:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Book Argument Class</figcaption></figure><p id="673c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">最后，在BookResolver类中，我们使用了Perch查询生成器:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Book Resolver Class</figcaption></figure><p id="739d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如您所见，在公共GraphQL层和ORM层之间架起一座桥梁只需要一行代码。PerchQueryBuilder.find <t>方法接受GraphQLResolveInfo和实体的存储库，并将利用这两者来构造要返回的适当查询。如果我们想查询带有书名和作者姓名的书籍，我们只需要一个如下结构的查询:</t></p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Book GraphQL query with author selected</figcaption></figure><p id="a384" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果我们想搜索一本id为<em class="lj"> 5 </em>或者书名为“<em class="lj">莫比·迪克”</em>的书，我们应该这样构造它:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Using arguments to grab specific results</figcaption></figure><h1 id="2ba0" class="ls lt iy bd lu lv mp lx ly lz mq mb mc ke mr kf me kh ms ki mg kk mt kl mi mj bi translated">整理</h1><p id="bbca" class="pw-post-body-paragraph kn ko iy kp b kq mk jz ks kt ml kc kv kw mm ky kz la mn lc ld le mo lg lh li ig bi translated">Perch Query Builder提供了使用给定属性对结果进行升序或降序排序的能力。为了将这种能力添加到我们的books查询中，我们需要做的就是将OrderByArgs类作为另一个参数添加到解析器中。</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Book resolver with sorting arguments added to the definition</figcaption></figure><p id="2192" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">就配置而言，不需要任何其他操作，因为参数类OrderByArgs只是为您的模式提供这些参数的定义。对从我们的图书查询返回的图书进行排序，如下所示:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Use the sorting arguments in your query</figcaption></figure><h1 id="cbd1" class="ls lt iy bd lu lv mp lx ly lz mq mb mc ke mr kf me kh ms ki mg kk mt kl mi mj bi translated">标页数</h1><p id="823f" class="pw-post-body-paragraph kn ko iy kp b kq mk jz ks kt ml kc kv kw mm ky kz la mn lc ld le mo lg lh li ig bi translated">目前，分页简单明了。为了对响应进行分段，我们只能向查询添加偏移量和限制。在未来，我希望能够像GraphQL网站中描述的那样，提供基于光标的分页功能。为了给我们的Book resolver类添加分页功能，我们需要做与排序功能完全相同的事情。</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Use pagination and sorting in your Book resolver</figcaption></figure><p id="24a9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">无需进一步配置！现在，我们能够添加一个偏移量，并限制查询中实体的数量。</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Use pagination in your query</figcaption></figure><p id="a056" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">使用Perch查询生成器提供的所有功能进行最终查询:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">All Perch Query Builder features used</figcaption></figure><p id="837a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">项目及文件链接:【https://github.com/wesleyyoung/perch-query-builder T2】</p></div></div>    
</body>
</html>