<html>
<head>
<title>How to Create and Manipulate DOM Nodes in Vanilla JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vanilla JS中创建和操作DOM节点</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/working-with-the-dom-in-vanilla-js-apps-part-1-bf8ccc0faaed?source=collection_archive---------0-----------------------#2021-12-05">https://javascript.plainenglish.io/working-with-the-dom-in-vanilla-js-apps-part-1-bf8ccc0faaed?source=collection_archive---------0-----------------------#2021-12-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1619" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在普通JS应用程序中使用DOM(第1部分):在没有框架的情况下创建和操作DOM节点的技巧。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4b420e5e9cf1dd1f39a0771fb4277c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eOyoIuung8-qFcb_"/></div></div></figure><p id="c4bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在前一篇文章中，我概述了普通JS项目的基本设置。在那里，我提到了与DOM节点创建和操作相关的一些事情，并承诺在下一篇文章中更详细地讨论这些内容。</p><p id="fe80" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">掌握DOM操作是普通JS项目成功的关键。幸运的是，DOM操纵不是火箭科学。您只需要DOM API的一个较小的子集和本文中的一些提示。正如一切香草，难的部分是适应新的(旧的？)的思维方式和对现有资源的创造性利用。正如我告诉我的一个队友的那样，“一旦你停止使用框架，你会发现你比你想象的更加足智多谋。”(他们做到了。)</p><p id="4542" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我写这篇文章的时候，我意识到需要两篇文章来涵盖我认为对大多数应用程序来说必不可少的东西。因此，这是文章的第一部分。在第一部分中，我们将介绍DOM节点的创建，并将重点放在操作单个节点上。在第二部分，我们将讨论节点列表。</p><h1 id="ec66" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">创建DOM节点</h1><p id="3a6b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">有几种方法可以创建DOM节点。最明显的方法是将它们添加到HTML页面中。我们将在本文后面对此进行更详细的讨论。现在，让我们看看典型的纯JavaScript方法。</p><p id="1c64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">先是德高望重的<code class="fe mi mj mk ml b">document.createElement()</code>:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="b153" class="mq lm in ml b gy mr ms l mt mu">let $node = document.createElement('div')<br/>$node.className = 'my-node'<br/>let $child = document.createElement('div')<br/>$child.className = 'my-child'<br/>$node.append(child)</span></pre><p id="bf94" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我希望子节点只是一些文本时，我使用<code class="fe mi mj mk ml b">document.createTextNode()</code>:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="c7b7" class="mq lm in ml b gy mr ms l mt mu">let $node = document.createElement('div')<br/>$node.className = 'my-node'<br/>let $textChild = document.createTextNode('some text')<br/>$node.append(textChild)</span></pre><p id="38b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我的节点只包含文本，我不会单独创建文本节点。我可以简单地使用<code class="fe mi mj mk ml b">Element.textContent</code>属性:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="08f7" class="mq lm in ml b gy mr ms l mt mu">let $node = document.createElement('div')<br/>$node.className = 'my-node'<br/>$node.textContent = 'some text'</span></pre><p id="3eba" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我要创建更复杂的节点树，我更喜欢使用带有模板字符串的<code class="fe mi mj mk ml b">Element.innerHTML</code>:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="2901" class="mq lm in ml b gy mr ms l mt mu">let $form = document.createElement('form')<br/>$form.innerHTML = `<br/>  &lt;label&gt;<br/>    name: &lt;input type="text"&gt;<br/>  &lt;/label&gt;<br/>  &lt;button&gt;Save&lt;/button&gt;<br/>`</span></pre><p id="e8e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就性能而言，使用<code class="fe mi mj mk ml b">document.createElement()</code>和<code class="fe mi mj mk ml b">Element.innerHTML</code>没有明显的区别，即使我们考虑到使用后一种技术，如果我们需要引用它们，我们需要选择已创建的节点。</p><p id="e4bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">模板字符串的使用非常适合这一目的，因为一些现代编辑器可以将这些字符串视为独立的语言上下文。例如，在JetBrains IDEs和Atom编辑器中，HTML突出显示和代码智能功能可以无缝工作，HTML可以自动检测，无需我的干预。很有想法！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/953fca01237eb726c0c36e133e3bb19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*aA5brROCoNWD5MObP2XQBA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">A JetBrains IDE treating the template string as HTML and offering attribute completion</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1e6fed4f9adcb60f53175b150c929664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*J-LNpPnAnUTduC0gtl2nsg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Atom detecting the HTML inside a template string and offering attribute completion</figcaption></figure><p id="6aa8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于<code class="fe mi mj mk ml b">Element.innerHTML</code>,我们总是需要一个单独的DOM元素作为我们想要放入其中的任何HTML的根。但是有时我们想创建一个HTML，它是一个元素列表，我们不需要根节点。为了处理这种情况，我们可以使用<code class="fe mi mj mk ml b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template" rel="noopener ugc nofollow" target="_blank">template</a></code>元素:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="ad1e" class="mq lm in ml b gy mr ms l mt mu">let $list = document.getElementById('my-list')<br/>let $children = document.getElementById('template')<br/>$children.innerHTML = `<br/>  &lt;li class="item"&gt;First item&lt;/li&gt;<br/>  &lt;li class="item"&gt;Second item&lt;/li&gt;<br/>`<br/>$list.append(children.content)</span></pre><p id="9283" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意，对于<code class="fe mi mj mk ml b">template</code>元素，我附加了<code class="fe mi mj mk ml b">HTMLTemplateElement.content</code>属性，而不是元素本身。此元素不是普通元素。它是web组件规范的一部分，专门用于存储稍后会用到但不会立即呈现的元素。<code class="fe mi mj mk ml b">HTMLTemplateElement.content</code>属性表示一个与模板内容匹配的<code class="fe mi mj mk ml b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" rel="noopener ugc nofollow" target="_blank">DocumentFragment</a></code>对象。</p><p id="63c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">DOM节点的创建远不止这些，但是我们不会深入研究所有的细微差别，因为它们中的大部分对于下一个模式都不是很有用:</p><h1 id="fbdf" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">HTML作为DOM节点储存库</h1><p id="c6f4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">用JavaScript创建DOM节点既不昂贵也不太复杂，但我仍然避免这样做。我不回避，因为这不是一个好的模式。我避免这样做，因为我一开始就不需要这样做。</p><blockquote class="nb"><p id="aef7" class="nc nd in bd ne nf ng nh ni nj nk lj dk translated">不需要做的工作才是最好的工作。</p></blockquote><p id="dc5d" class="pw-post-body-paragraph ko kp in kq b kr nl jo kt ku nm jr kw kx nn kz la lb no ld le lf np lh li lj ig bi translated">当浏览器加载HTML文件时，它将解析该文件并将所有元素转换为DOM节点，并将它们放入<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" rel="noopener ugc nofollow" target="_blank"> DOM树</a>。这是自动发生的，并且(通常)发生在应用程序开始执行之前，所以页面的整个DOM树已经存在，可以使用了。</p><p id="f158" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个不可低估的优势。在一个典型的“现代”JavaScript应用程序中，第一个可用的DOM节点是在脚本被加载、解析和评估之后创建的。当我们的脚本还在加载的时候，让浏览器为我们做所有困难的工作，我们节省了很多时间。</p><p id="7e80" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将内容放在HTML文件中的另一个好处是，我们可以在加载JavaScript时显示一些静态内容，并在评估代码后使其具有交互性。即使捆绑包稍微大了一点，这也能让用户马上看到一些东西。(顺便提一下，这是一种可以用于典型的基于框架的构建的技术，而不需要求助于<a class="ae lk" href="https://en.wikipedia.org/wiki/Server-side_scripting" rel="noopener ugc nofollow" target="_blank"> SSR </a>和NextJS之类的框架。)</p><p id="c85b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当加载JavaScript时，HTML页面本身就变成了我们将在应用程序中使用的DOM节点的存储库。随着应用程序进入各种状态，我们将向它添加几乎所有我们以后需要的东西。</p><p id="ce5c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作为题外话，我还将讲述直接添加到HTML页面的<code class="fe mi mj mk ml b">&lt;template&gt;</code>标签的实验结果。我最初认为我可以这样使用它们:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="c999" class="mq lm in ml b gy mr ms l mt mu">let $template = documnet.getElementById('my-template')<br/>let $nodes = $template.content.cloneNode(true)<br/>$parent.append($nodes)</span></pre><p id="2b37" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，这种方法比本文中列出的其他创建DOM节点的方法要慢得多，所以我已经停止使用它了。</p><h1 id="a7df" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">最初隐藏的元素</h1><p id="61a7" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">为了使节点库有用，我们隐藏了不想在第一次渲染时立即显示在页面上的内容。我们不需要在JavaScript中做任何事情来实现这一点。我们只需要几行CSS代码。</p><p id="bad4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我通常在CSS中有这样的内容:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="74e3" class="mq lm in ml b gy mr ms l mt mu">.hidden {<br/>  display: none;<br/>}</span></pre><p id="236b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据我想要显示元素的方式，我可能会使用不同的方法来隐藏它们。例如，这种隐藏元素的方式适用于淡入效果(例如，对于模态对话框):</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="fe85" class="mq lm in ml b gy mr ms l mt mu">.invisible {<br/>  opacity: 0;<br/>  pointer-events: none;<br/>}</span></pre><p id="e6db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我可以为HTML中的任何标签添加这些类。</p><p id="8ed6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果CSS文件很大，那么在应用<code class="fe mi mj mk ml b">hidden</code>类之前可能会有一个视觉上的小问题。如果发生这种情况，我会在您的页面上包含一个<code class="fe mi mj mk ml b">&lt;style&gt;</code>标签，并在其中包含<code class="fe mi mj mk ml b">.hidden</code>规则:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="23fb" class="mq lm in ml b gy mr ms l mt mu">&lt;head&gt;<br/>  ....<br/>  &lt;style&gt;<br/>    .hidden {<br/>      display: none;<br/>    }<br/>  &lt;/style&gt;<br/>&lt;/head&gt;</span></pre><p id="77de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这保证了规则将在第一次渲染时应用。</p><p id="d698" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以下是您以后需要的一些物品示例:</p><ul class=""><li id="6230" class="nr ns in kq b kr ks ku kv kx nt lb nu lf nv lj nw nx ny nz bi translated">同一个UI元素的不同互斥状态——我通常会在HTML中有同一个UI的多个版本，并使用<code class="fe mi mj mk ml b">hidden</code>类在它们之间切换。</li><li id="e153" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated"><strong class="kq io">消息</strong>—这包括错误消息和各种通知、祝酒词等。如果需要的话，我会将<code class="fe mi mj mk ml b">hidden</code>类从它们中移除。</li><li id="d863" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated"><strong class="kq io">弹出对话框和模态</strong>——当它们显示时，我会从它们中移除<code class="fe mi mj mk ml b">hidden</code>类，当它们关闭时，添加<code class="fe mi mj mk ml b">hidden</code>类。</li></ul><p id="4172" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不需要为其创建变体的一些示例是在其上执行以下操作的节点:</p><ul class=""><li id="a401" class="nr ns in kq b kr ks ku kv kx nt lb nu lf nv lj nw nx ny nz bi translated"><strong class="kq io">仅更改文本内容</strong>——我将简单地使用<code class="fe mi mj mk ml b">Element.textContent</code>分配新内容。</li><li id="9893" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated"><strong class="kq io">仅更改类</strong> —我会更新类，而不是预先应用带有不同类的节点的两个版本。</li><li id="fad7" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated"><strong class="kq io">仅更改属性/特性</strong>—我会更新属性，而不是拥有具有不同属性的各种节点。</li></ul><h1 id="4a5a" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">HTML和初始应用程序状态</h1><p id="60d4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">需要记住的一点是应用程序状态和HTML之间的同步。虽然您也可以用JavaScript来实现，但我发现用HTML来实现更有效。它为您节省了一些管理初始状态的工作。正如我喜欢说的，这是你(和你的应用程序)不必做的工作。</p><p id="cd8f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里举个小例子。如果我们有一个选择列表，并且初始应用程序状态是默认选择第二个选项，我们也可以这样编写HTML:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="1f03" class="mq lm in ml b gy mr ms l mt mu">&lt;select id="my-select"&gt;<br/>  &lt;option value="A"&gt;Option A&lt;/option&gt;<br/>  &lt;option value="B" selected&gt;Option B&lt;/option&gt;<br/>  &lt;option value="C"&gt;Option C&lt;/option&gt;<br/>&lt;/select&gt;</span></pre><p id="f550" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一些状态是动态的(例如，依赖于对一些HTTP请求的响应，或<code class="fe mi mj mk ml b">localStorage</code>)。我们不能单独使用HTML来处理动态初始状态，所以需要推迟到加载JavaScript之后。在这种情况下，我们将简单地编写HTML代码，使我们尽可能接近。</p><p id="19d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有一个<em class="nq">风险</em>会使状态和初始视图不同步，因为我们现在有<em class="nq">两个</em>真相来源。在这种情况下，我对此没有意见，因为我得到的是交换。我不相信风险驱动的开发。另一方面，我确实相信修正程序员的错误，从错误中学习，而不会对犯错误感到内疚。(如果你找到了一种每次都能写出没有错误的软件的方法，一定要让我知道，尽管我可能会改变主意。)和往常一样，这是我喜欢的做事方式，显然，你可以无视这个建议。YMMV。</p><h1 id="43d6" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">动态代码加载</h1><p id="8de4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">DOM操作还可以用于动态代码加载，而不仅仅是页面元素的操作。</p><p id="a515" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了动态加载一些JavaScript，我们只需在页面上创建一个<code class="fe mi mj mk ml b">&lt;script&gt;</code>标签:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="3b6a" class="mq lm in ml b gy mr ms l mt mu">let $script = document.createElement('script')<br/>$script.defer = true<br/>$script.src = 'some.js'<br/>document.head.append($script)</span></pre><p id="255e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">(如果上面看起来有点熟悉，你可能在Google Analytics集成的片段中看到过。)</p><p id="2642" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您想等待模块加载，您需要在添加标签之前将<code class="fe mi mj mk ml b">Element.onload</code>事件监听器分配给<code class="fe mi mj mk ml b">&lt;script&gt;</code>标签。</p><p id="31c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">(如果您喜欢不使用任何DOM操作的咖啡/茶/水，您可以使用<a class="ae lk" href="https://caniuse.com/es6-module" rel="noopener ugc nofollow" target="_blank">原生ES6模块</a>。我赞成这种方法，因为它几乎是免费的。只是我对我现在所拥有的很满意，所以我还没有在模块上投入任何时间。)</p><p id="df95" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您也可以动态加载CSS:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="7f84" class="mq lm in ml b gy mr ms l mt mu">let $link = document.createElement('link')<br/>$link.rel = 'stylesheet'<br/>$link.href = (document.body.dataset.theme || 'default') + '.css'<br/>document.head.append($link)</span></pre><p id="786d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您还可以动态添加<code class="fe mi mj mk ml b">&lt;style&gt;</code>标签，并使用JavaScript填充内容:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="70d7" class="mq lm in ml b gy mr ms l mt mu">let $style = document.createElement('style')<br/>$style.textContent = `<br/>  .sidebar {<br/>    max-wdith: ${getSidebarMaxWidth()}px;<br/>  }<br/>`<br/>document.head.append($style)</span></pre><p id="56c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当与CSS自定义属性结合使用时，上述功能尤其强大。</p><h1 id="915f" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">访问DOM节点</h1><p id="d65b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">现在我们的JavaScript已经加载，页面也已经完全解析，我们可以开始访问和操作节点了。通常的方法是获取对节点的引用，然后对其执行操作。</p><p id="93e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">DOM API提供了多种访问DOM节点的方法，包括流行的<code class="fe mi mj mk ml b">Element.querySelector()</code>和<code class="fe mi mj mk ml b">Element.querySelectorAll()</code>方法，老派的<code class="fe mi mj mk ml b">Element.getElementById()</code>和<code class="fe mi mj mk ml b">Element.getElementByClassName()</code>，像<code class="fe mi mj mk ml b">Element.childNodes</code>、<code class="fe mi mj mk ml b">Element.children</code>、<code class="fe mi mj mk ml b">Element.firstElementChild</code>这样的属性，全局变量等等。</p><p id="4722" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我不会讨论使用各种方法的优缺点，相反，我会根据我的研究和基准为您提供一些基本规则:</p><ol class=""><li id="064a" class="nr ns in kq b kr ks ku kv kx nt lb nu lf nv lj of nx ny nz bi translated">理想情况下，您希望使用<code class="fe mi mj mk ml b">id</code>属性精确定位节点，并使用<code class="fe mi mj mk ml b">document.getElementById()</code>选择它，因为这是获得对单个节点的引用的最快方法。</li><li id="23ab" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj of nx ny nz bi translated">如果您想通过类选择一个特定的子节点，使用带有类选择器的<code class="fe mi mj mk ml b">Element.querySelector()</code>。确保调用父元素上的方法，而不是<code class="fe mi mj mk ml b">document</code>对象。</li><li id="0334" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj of nx ny nz bi translated">如果您想要访问一个子节点列表以便以后迭代，使用<code class="fe mi mj mk ml b">Element.children</code>属性，并使用<code class="fe mi mj mk ml b">for</code>循环迭代它。您也可以使用<code class="fe mi mj mk ml b">Array.from()</code>将它转换成一个数组，最好是在您创建引用时。</li><li id="4b21" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj of nx ny nz bi translated">如果您想选择第一个子元素，使用<code class="fe mi mj mk ml b">Element.firstElementChild</code>。<code class="fe mi mj mk ml b">Element.fistChild</code>还包括文本节点，速度较慢。您通常不需要文本节点，因为可以使用<code class="fe mi mj mk ml b">Element.textContent</code>获得文本。</li><li id="a797" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj of nx ny nz bi translated">如果您想保留共享相同选择器的节点列表的引用，请使用<code class="fe mi mj mk ml b">Element.querySelectorAll()</code>。请记住，这个列表不是动态的，所以如果您的目标是随时间变化的元素集合，您将需要根据需要进行查询。</li></ol><p id="144f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这几乎涵盖了我到目前为止遇到的所有案例。</p><p id="3696" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在应用程序开始工作之前，最好立即创建对将要使用的所有DOM节点的所有引用，并把它们放在可以访问的地方。将它们保持在模块范围内通常是最直接的方法，所以我建议这样做，除非你有具体的(最好是非宗教的)理由用其他方式。</p><h1 id="cbb1" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">操作单个DOM节点</h1><p id="95ed" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">尽管有许多方法可以操作DOM节点，但是在实际应用程序中，通常没有那么多方法可以操作它们。以下是您需要在单个节点上进行的最典型操作的列表，大致按频率排序:</p><ul class=""><li id="b278" class="nr ns in kq b kr ks ku kv kx nt lb nu lf nv lj nw nx ny nz bi translated">更改类别(切换/添加/删除)</li><li id="f2ba" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">设置文本内容</li><li id="0ee0" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">设置属性/特性</li><li id="8841" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">设置CSS自定义属性</li><li id="7f31" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">添加/删除事件侦听器</li><li id="6c55" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">更新HTML内容</li></ul><p id="5921" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有时您将需要执行其他操作，但是列出的是更经常遇到的操作。让我们快速浏览一遍。</p><h2 id="c51d" class="mq lm in bd ln og oh dn lr oi oj dp lv kx ok ol lx lb om on lz lf oo op mb oq bi translated">改变类别</h2><p id="dc78" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">要设置类别，您可以使用以下方法之一:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="545d" class="mq lm in ml b gy mr ms l mt mu">$node.className = 'some-class'<br/>$node.classList.add('some-class')<br/>$node.classList.remove('some-class')<br/>$node.classList.toggle('some-class')</span></pre><p id="d3f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当您想要完全替换<code class="fe mi mj mk ml b">class</code>属性的内容时，应该使用<code class="fe mi mj mk ml b">Element.className</code>属性(例如，当我们刚刚创建了一个新元素时)。如果我们想确保单个类的存在或不存在，您需要分别使用<code class="fe mi mj mk ml b">Element.classList.add()</code>和<code class="fe mi mj mk ml b">Element.classList.remove()</code>。对于所有其他情况，你应该选择<code class="fe mi mj mk ml b">Element.clasList.toggle().</code></p><p id="6d0b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mi mj mk ml b">Element.classList.toggle()</code>方法特别强大，因为它支持强制某种状态的附加参数。我稍后会谈到这一点。</p><p id="5f0c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我看到不熟悉普通JS的开发人员会这样做:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="c75b" class="mq lm in ml b gy mr ms l mt mu">if ($node.classList.includes('foo')) $node.classList.remove('foo')<br/>else $node.classList.add('foo')</span></pre><p id="c5dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不是最佳方法，原因有二:</p><ol class=""><li id="106f" class="nr ns in kq b kr ks ku kv kx nt lb nu lf nv lj of nx ny nz bi translated">它使用DOM而不是存储在JavaScript数据结构中的内部应用程序状态来测试状态。</li><li id="1024" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj of nx ny nz bi translated">我们已经有了一个达到同样效果的方法，就是<code class="fe mi mj mk ml b">Element.classList.toggle()</code>。</li></ol><h2 id="11ec" class="mq lm in bd ln og oh dn lr oi oj dp lv kx ok ol lx lb om on lz lf oo op mb oq bi translated">更改文本内容</h2><p id="24ce" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">使用<code class="fe mi mj mk ml b">Element.textContent</code>属性设置节点的文本内容。除非我知道我需要<code class="fe mi mj mk ml b">Element.innerText</code>，否则我总是用<code class="fe mi mj mk ml b">Element.textContent</code>。后者不考虑DOM树中文本节点和非文本节点的区别，因此更具性能，这通常也是我想要的。当设置文本内容时，我有时可能有部分文本不是动态的。例如:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="80af" class="mq lm in ml b gy mr ms l mt mu">&lt;span id="name"&gt;Your name is: Bob&lt;/span&gt;</span></pre><p id="493a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，我希望<code class="fe mi mj mk ml b">Bob</code>改变，而不是<code class="fe mi mj mk ml b">Your name is:</code>。我可以很容易地构造一个字符串作为<code class="fe mi mj mk ml b">'Your name is: ' + name</code>，并赋予它:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="7f41" class="mq lm in ml b gy mr ms l mt mu">let $name = document.getElementById('name')<br/>$name.textContent = 'Your name is: ' + name</span></pre><p id="1e97" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我也可以通过将动态部分包装在一个元素中并给它一个<code class="fe mi mj mk ml b">id</code>或<code class="fe mi mj mk ml b">class</code>属性来避免这样做:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="14c4" class="mq lm in ml b gy mr ms l mt mu">&lt;span&gt;Your name is: &lt;span id="name"&gt;Bob&lt;/span&gt;&lt;/span&gt;</span></pre><p id="38a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后我可以只设置名称:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="0b93" class="mq lm in ml b gy mr ms l mt mu">let $name = document.getElementById('name')<br/>$name.textContent = name</span></pre><p id="0812" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我更喜欢后一种形式，因为这意味着我的JavaScript工作要少一些。</p><h2 id="d8ae" class="mq lm in bd ln og oh dn lr oi oj dp lv kx ok ol lx lb om on lz lf oo op mb oq bi translated">设置属性和特性</h2><p id="fb59" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">有时候我们需要设置像<code class="fe mi mj mk ml b">checked</code>或者<code class="fe mi mj mk ml b">disabled</code>这样的属性。我们可以使用<code class="fe mi mj mk ml b">Element.setAttribute()</code>或者直接分配给<code class="fe mi mj mk ml b">Element.property</code>来完成。</p><p id="d3ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">几乎所有的HTML属性都被映射到DOM节点属性，更新属性也会更新属性，反之亦然。虽然这两种方法之间没有明显的区别，但为了简单起见，我更喜欢给属性赋值，通过扩展，可以得到更小的非统一有效负载大小。</p><p id="eb23" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有些属性<em class="nq">不能用属性</em>设置(我想我记得有些ARIA相关的不能)。</p><h2 id="62e8" class="mq lm in bd ln og oh dn lr oi oj dp lv kx ok ol lx lb om on lz lf oo op mb oq bi translated">设置CSS自定义属性</h2><p id="58de" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">通常，控制某个元素的外观需要修改它上面的类。还有一些情况下，外观会更直接地受到JavaScript值的影响，例如元素在屏幕上被拖动，或者一些外观属性会受到CSS中无法计算的值的影响(例如，在视口中的位置)。在这种情况下，我们可以使用<code class="fe mi mj mk ml b">Element.style</code>属性(或属性)并将CSS规则直接添加到元素中。</p><p id="8800" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，我可能有一个滑块，它的位置是这样更新的:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="a565" class="mq lm in ml b gy mr ms l mt mu">$slider.style.left = `${sliderLeftPos}%`</span></pre><p id="265d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是有更好的方法。我们可以不直接分配CSS规则，而是分配<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="noopener ugc nofollow" target="_blank"> CSS自定义属性</a>(也称为CSS变量)。</p><p id="3cbc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我最近遇到了一种情况，我想控制自定义选择列表元素的CSS transform-origin，根据它在视窗中的相对位置和列表的宽度来设置打开的方向。最初，我尝试这样做:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="0572" class="mq lm in ml b gy mr ms l mt mu">$node.classList.toggle('open-left', !canOpenRight)<br/>$node.classList.toggle('open-top', !canOpenBottom)</span></pre><p id="c5d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我很快意识到，因为<code class="fe mi mj mk ml b">transform-origin</code>规则不能叠加，我将不得不创建四个不同的类，或者我将需要使用复合选择器，这两者都不吸引我。相反，我决定使用CSS自定义属性来设置<code class="fe mi mj mk ml b">transform-origin</code>规则的水平和垂直值。在CSS中，我有这样一个声明:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="8139" class="mq lm in ml b gy mr ms l mt mu">.select-list {<br/>  /* Default values */<br/>  --origin-h: left;<br/>  --origin-v: top;<br/>  transform-origin: var(--origin-h) var(--origin-v);<br/>}</span></pre><p id="a405" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后在JavaScript中，我简单地覆盖了这些属性:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="1bfc" class="mq lm in ml b gy mr ms l mt mu">let { style } = $node<br/>style.setProperty('--origin-h', canOpenRight ? 'left' : 'right')<br/>style.setProperty('--origin-v', canOpenBottom ? 'top' : 'bottom')</span></pre><p id="85cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于设置自定义属性，您需要使用<code class="fe mi mj mk ml b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/setProperty" rel="noopener ugc nofollow" target="_blank">Element.style.setProperty()</a></code>方法。这个方法适用于任何CSS属性，但是对于自定义属性，这是我发现的唯一有效的方法。</p><p id="5fc5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为我们只处理属性，不干涉CSS如何使用它们，所以我们在CSS和JavaScript之间保持了一个清晰的界限。因为这些不是完整的类，我们仍然可以对使用属性的规则应用不同的覆盖。例如:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="d9a0" class="mq lm in ml b gy mr ms l mt mu">.select-list-always-top-left {<br/>  transform-origin: left top;<br/>}</span></pre><p id="4e98" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们应用上面的类，我们赋予<code class="fe mi mj mk ml b">--origin-h</code>或<code class="fe mi mj mk ml b">--origin-v</code>什么值不再重要。</p><h2 id="ebc7" class="mq lm in bd ln og oh dn lr oi oj dp lv kx ok ol lx lb om on lz lf oo op mb oq bi translated">添加/删除事件侦听器</h2><p id="8f8f" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在绝大多数情况下，不需要不断地添加和删除事件侦听器。通常只需添加一次，并在应用程序的整个生命周期中保持活动状态就足够了。</p><p id="2638" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，分配事件侦听器的典型方式如下:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="0e0f" class="mq lm in ml b gy mr ms l mt mu">node.oninput = ev =&gt; onEdit(ev.target.value)</span></pre><p id="5248" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当全局添加事件监听器时，通常使用<code class="fe mi mj mk ml b">Element.addEventListener()</code>(例如，在<code class="fe mi mj mk ml b">window</code>或<code class="fe mi mj mk ml b">document.body</code>上)。另一种可能使用<code class="fe mi mj mk ml b">Element.addEventListner()</code>的情况是当我们需要向单个元素添加多个事件侦听器时，但是这种情况很少发生，而且必须有一个很好的理由(你总是可以从一个侦听器中调用两个不同的函数，所以为什么要分配两个单独的侦听器，等等。等。).有时出现的第三种用例是事件侦听器只需要被触发一次。在这种情况下，我们可以使用<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#syntax" rel="noopener ugc nofollow" target="_blank">选项参数</a>来指定这样的行为。</p><p id="1f1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们想在一堆节点上处理一个事件，我们可以遍历所有节点并给它们分配相同的侦听器，或者我们可以求助于事件委托。事件委托是一种技术，其中事件在父节点之一上处理，然后由实际的目标进行过滤。</p><p id="89f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们使用<code class="fe mi mj mk ml b">Element.innerHTML</code>更新节点的内容时，事件委托特别方便，因为我们不必遍历子元素来单独添加侦听器。</p><p id="fa6a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我假设我有一些类似这样的HTML:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="203e" class="mq lm in ml b gy mr ms l mt mu">&lt;ul id="list"&gt;<br/>  &lt;li&gt;<br/>    Item 1: &lt;button class="open" data-id="0"&gt;open&lt;/button&gt;<br/>  &lt;/li&gt;<br/>  &lt;li&gt;<br/>    Item 2: &lt;button class="open" data-id="1"&gt;open&lt;/button&gt;<br/>  &lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="285a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">列表中可以有任意数量的项目，我想处理按钮点击。为了在这种情况下使用事件委托，我会这样做:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="3032" class="mq lm in ml b gy mr ms l mt mu">let $list = document.getElementById('list')<br/>$list.onclick = ev =&gt; {<br/>  let { target } = ev<br/>  if (!target.matches('.open')) return<br/>  onOpen(Number(target.dataset.id))<br/>}</span></pre><p id="a002" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事件委托的缺点是，找到我们感兴趣的实际子元素可能会变得复杂和/或昂贵，并抵消其便利性的好处。比方说，我的按钮包含其他元素，也可以接收点击。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="6032" class="mq lm in ml b gy mr ms l mt mu">&lt;ul id="list"&gt;<br/>  &lt;li&gt;<br/>    Item 1: <br/>    &lt;button class="open" data-id="0"&gt;<br/>      &lt;span class="icon icon-open"&gt;open&lt;/span&gt;<br/>    &lt;/button&gt;<br/>  &lt;/li&gt;<br/>  &lt;li&gt;<br/>    Item 2: <br/>    &lt;button class="open" data-id="1"&gt;<br/>      &lt;span class="icon icon-open"&gt;open&lt;/span&gt;<br/>    &lt;/button&gt;<br/>  &lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="05fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下，我之前使用的委托代码将不起作用，因为事件目标(通常)将是<code class="fe mi mj mk ml b">span.icon</code>。为了解决这个问题，我需要找出事件目标的祖先是按钮:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="3f11" class="mq lm in ml b gy mr ms l mt mu">let $list = document.getElementById('list')<br/>$list.onclick = ev =&gt; {<br/>  let { target } = ev<br/>  let realTarget = target.closest('button.open')<br/>  if (!realTarget) return<br/>  onOpen(Number(realTarget.dataset.id))<br/>}</span></pre><p id="305e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据意外匹配处理事件的节点之外的元素的可能性(例如，在这种情况下，<code class="fe mi mj mk ml b">#list</code>可能恰好嵌套在<code class="fe mi mj mk ml b">button.open</code>中)，委托还有多种变化，但是在这一点上，我将开始考虑在节点上循环，因为我不想有一个太复杂(或太聪明)的事件侦听器。</p><h2 id="4d67" class="mq lm in bd ln og oh dn lr oi oj dp lv kx ok ol lx lb om on lz lf oo op mb oq bi translated">更新HTML内容</h2><p id="5912" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">节点的HTML内容可以被部分修改或完全替换。</p><p id="8175" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有长期滥用框架的历史，你可能会认为修改一个节点的HTML内容和替换它是一回事。您可以更新状态，并使用最初用于生成初始版本的相同函数重新生成内容。这是一种声明性的、虚拟的DOM思维方式，它与我们现有的实际API不太匹配。</p><p id="5495" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从所涉及的操作的总成本的角度来看，使用目标操作修改内容更便宜，并且由于用于执行这些操作的方法是<em class="nq">必要的</em>，我们需要考虑最大效率。</p><p id="3256" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">修改内容通常意味着执行以下操作之一:</p><ul class=""><li id="16dc" class="nr ns in kq b kr ks ku kv kx nt lb nu lf nv lj nw nx ny nz bi translated">删除不再需要的节点</li><li id="ef87" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">在末尾添加一个节点</li><li id="d4b6" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">在某处插入一个节点</li><li id="d867" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">更改节点的顺序</li></ul><p id="af5c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在删除一个节点之前，考虑隐藏它是否能达到同样的效果。如果我们以后想要出于同样的目的重用节点，那么隐藏节点是首选，因为它可以节省我们以后重新创建它的成本。</p><p id="1310" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与删除一样，在考虑实际创建和添加新节点之前，请考虑取消隐藏现有节点。当我们知道可能需要多少节点时，保留一个额外节点池是一个好策略。</p><p id="744b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了插入一个节点，您可以在显示它之前将一个隐藏的额外节点移动到正确的位置。</p><p id="4349" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当更改节点的顺序时，请记住，如果您将节点添加到树的另一部分，它会自动从其先前的位置删除。当我们谈到列表时，我们会看到所有这些是如何工作的。</p><p id="87c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用<code class="fe mi mj mk ml b">Element.innerHTML</code>属性可以替换节点的内容。这很有效，因为它可以一次性清除现有节点并创建新节点。我不知道还有什么其他方法可以做到这一点。由于<code class="fe mi mj mk ml b">Element.innerHTML</code>通常是我创建新节点的首选方式，使用相同的技术替换它们也为代码库增加了一点一致性。</p><p id="c5f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，有一些复杂的算法可以将DOM子树同步到期望的状态。您可以从任何流行的虚拟DOM实现中获取这些内容。它们需要一些修改，因为DOM节点不是数组成员，当它们从树中取出时不会被复制，这在一定程度上提高了算法的效率，但这是可行的。自从我开始做香草开发，我还不需要这种火力。这样的代码既不容易阅读，也不小(短的代码至少有一百行)。不过，我认为意识到它的存在是个好主意。</p><p id="eea3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些操作在管理节点列表时更常用，所以我们将在第2部分用具体的例子来讨论它们。</p><h1 id="6d27" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">声明性与命令性操作</h1><p id="f605" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我将所有DOM操作分为两类:</p><ul class=""><li id="8aad" class="nr ns in kq b kr ks ku kv kx nt lb nu lf nv lj nw nx ny nz bi translated">声明性操作</li><li id="2097" class="nr ns in kq b kr oa ku ob kx oc lb od lf oe lj nw nx ny nz bi translated">命令式操纵</li></ul><p id="e242" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">(请不要将这些术语与编程风格混淆。我在这里不严格地使用它们来描述心智模型。)</p><p id="2f2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，当使用<code class="fe mi mj mk ml b">Element.classList.toggle()</code>方法设置一个类时，第二个参数提供了一个机会来实施与应用程序状态一致的状态:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="af90" class="mq lm in ml b gy mr ms l mt mu">$error.classList.toggle('hidden', !state.formError)</span></pre><p id="18f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是我所说的声明性操作，因为它是应用程序状态和元素期望状态之间的直接映射。声明性操作的其他示例包括:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="0b2e" class="mq lm in ml b gy mr ms l mt mu">$node.innerHTML = someHTML<br/>$node.disabled = !state.isActive<br/>$node.toggleAttribute('data-active', sate.isActive)<br/>$node.setAttribute('data-id', item.id)</span></pre><p id="554e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">声明性操作的一个重要特性是，不管你执行多少次，它们的效果总是一样的(换句话说，它们是<a class="ae lk" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">等幂</a>)。这允许我们以各种方式简单地更新状态，同时每次执行相同的声明性操作来同步状态和DOM。</p><p id="83a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">命令式操作是指我们指示元素执行某件事情的操作。这里有几个例子:</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="edf3" class="mq lm in ml b gy mr ms l mt mu">$node.append($child)<br/>$node.play()<br/>$node.dispatchEvent(new Event('click'))</span></pre><p id="8c05" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与声明性操作不同，命令性操作不是等幂的。</p><p id="689a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然如果我能告诉你“总是执行声明性操作”并完成它会很好，但情况远没有那么清楚。你两者都需要。话虽如此，你的应用程序中的大多数操作<em class="nq">可以</em>是声明性的，所以不要错过机会。如果你在适当的地方使用声明性操作，它可以使你的代码更简单。</p><p id="44b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，请记住始终按照预期使用提供的API。当命令式操作更合适时，不要试图强制声明式操作，反之亦然。只要有不匹配的地方，你就会被迫在两个世界之间编写适配器，这导致了额外的复杂性。</p><h1 id="8ab8" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">一个更完整的例子</h1><p id="3484" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">为了说明本文中讨论的一些技术，让我们看一个比较完整的例子，当应用程序完全初始化之前涉及到一些异步操作时，我将如何在应用程序中切换视图。</p><p id="7b09" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我从一些表示不同状态的HTML开始。在这种情况下，初始视图将只是一个“Loading…”消息，因为我需要在显示应用程序界面之前加载一些数据。这个视图是唯一没有<code class="fe mi mj mk ml b">hidden</code>类的视图。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="113e" class="mq lm in ml b gy mr ms l mt mu">&lt;div id="view-loading" class="view"&gt;Loading...&lt;/div&gt;</span><span id="b9ab" class="mq lm in ml b gy or ms l mt mu">&lt;div id="view-failure" class="view hidden"&gt;Failed to load!&lt;/div&gt;</span><span id="aef5" class="mq lm in ml b gy or ms l mt mu">&lt;div id="view-needs-login" class="view hidden"&gt;<br/>  &lt;form&gt; .... &lt;/form&gt;<br/>&lt;/div&gt;</span><span id="2a84" class="mq lm in ml b gy or ms l mt mu">&lt;div id="view-ready" class="view hidden"&gt;<br/>  &lt;h1&gt;Welcome to the app&lt;/h1&gt;<br/>  &lt;p&gt;You have &lt;span id="message-count"&gt;0 messages&lt;/span&gt;&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="d214" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在JavaScript中，当我们从一种状态转换到另一种状态时，我们加载数据并计算我们想要显示哪个视图。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="0d69" class="mq lm in ml b gy mr ms l mt mu">const View = {<br/>  LOADING: 0, <br/>  OK: 1, <br/>  NEEDS_AUTH: 2, <br/>  ERROR: 3,<br/>}</span><span id="6bd9" class="mq lm in ml b gy or ms l mt mu">// Application data<br/>let state = {<br/>  loading: true,<br/>  authenticated: false,<br/>  error: false,<br/>  data: null,<br/>}<br/>let loadData = () =&gt; fetch('/verify')<br/>  .then(resp =&gt; {<br/>    state.authenticated = resp.ok<br/>    if (resp.ok) return fetch('/data/')<br/>  })<br/>  .then(resp =&gt; {<br/>    state.error = !resp.ok<br/>    if (resp &amp;&amp; resp.ok) return resp.json()<br/>  })<br/>  .then(data =&gt; {<br/>    state.data = data ?? null<br/>    state.loading = false<br/>  })<br/>  .catch(() =&gt; {<br/>    state.loading = false<br/>    state.error = true<br/>    state.data = null<br/>  })<br/>let currentView = () =&gt; {<br/>  if (state.loading) return View.LOADING<br/>  if (state.error) return View.ERROR<br/>  if (!state.authenticated) return View.NEEDS_AUTH<br/>  return View.READY<br/>}<br/>let messageCount = () =&gt; sate.data &amp;&amp; state.data.messages.length</span><span id="70bd" class="mq lm in ml b gy or ms l mt mu">// DOM node references<br/>let $viewLoading = document.getElementById('view-loading')<br/>let $viewFailure = document.getElementByid('view-failure')<br/>let $viewNeedsLogin = document.getElementById('view-needs-login')<br/>let $viewReady = document.getElementById('view-ready')<br/>let $currentView = $viewLoading<br/>let $$viewNodes = [ // NB: indexes match View ID's<br/>  $viewLoading,<br/>  $viewReady,<br/>  $viewNeedsLogin,<br/>  $viewFailure,<br/>}<br/>let $messageCount = document.getElementById('message-count')</span><span id="b715" class="mq lm in ml b gy or ms l mt mu">// DOM manipulation<br/>let updateView = () =&gt; {<br/>  let $nextView = $$viewNodes[currentView()]<br/>  if ($nextView === $currentView) return<br/>  $currentView.classList.add('hidden')<br/>  $nextView.classList.remove('hidden')<br/>  $currentView = $nextView<br/>}<br/>let updateMessageCount = () =&gt; {<br/>  let n = messageCount() ?? 0<br/>  $messageCount.textContent = <br/>    `${n || 'no'} message${n == 1 ? '' : 's'}`<br/>  $messageCount.classList.toggle('warning', n &gt; 100)<br/>}<br/>let updateInitialView = () =&gt; {<br/>  updateMessageCount()<br/>  updateView()<br/>}</span><span id="253b" class="mq lm in ml b gy or ms l mt mu">// Initialize the app<br/>loadData().then(updateInitialView)</span></pre><p id="4792" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">总而言之，对当前视图的引用存储在变量<code class="fe mi mj mk ml b">$currentView</code>中。当切换视图时，我们将<code class="fe mi mj mk ml b">'hidden'</code>类添加到由<code class="fe mi mj mk ml b">$currentView</code>指向的元素中，然后将它从下一个视图中移除。然后我们为下一次更新更新<code class="fe mi mj mk ml b">$currentView</code>参考。</p><p id="c8c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种方法可以用于任何基于状态将一个节点换成另一个节点的情况。</p><h2 id="7307" class="mq lm in bd ln og oh dn lr oi oj dp lv kx ok ol lx lb om on lz lf oo op mb oq bi translated">关于使用帮助函数</h2><p id="e5df" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">顺便提一下，当过渡到Vanilla时，我们中的许多人最初为我们觉得有点太冗长的东西创建助手函数(例如，用<code class="fe mi mj mk ml b">hide()</code>而不是<code class="fe mi mj mk ml b">Element.classList.add('hidden')</code>，<code class="fe mi mj mk ml b">toggle()</code>来管理当前显示的元素引用并与其他元素交换)。当我使用我的应用程序时，我发现我并没有像我想象的那样从这些助手中受益。它可能看起来“更干净”，但它最终引入了一堆新功能，连我都需要时不时地查阅这些功能。此外，随着边缘案例的出现，我给它们添加了越来越多的附加功能，最终得到了迷你框架。</p><p id="8a6f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我已经决定完全避免使用助手，并且发现没有它们代码也很容易管理。更重要的是，不需要查找(太多)函数就可以很容易地判断代码在做什么。更不用说<a class="ae lk" href="https://www.karlton.org/2017/12/naming-things-hard/" rel="noopener ugc nofollow" target="_blank">这个让人头疼的</a>命名了。</p><p id="eb89" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我文章中的任何内容一样，YMMV。</p><h1 id="9b0c" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">下一个</h1><p id="f0c4" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">下一篇文章将讨论DOM节点列表的创建和更新，以及这些操作的必要性。</p><h1 id="5bfb" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">你愿意全职从事香草JS吗？</h1><p id="7a3d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><em class="nq">如果你想加入一个遵循上述原则的团队，你可能会有兴趣了解一下</em><a class="ae lk" href="https://coinmetrics.io/" rel="noopener ugc nofollow" target="_blank"><em class="nq">Coin Metrics</em></a><em class="nq">是</em> <a class="ae lk" href="https://boards.greenhouse.io/coinmetrics/jobs/4031704004" rel="noopener ugc nofollow" target="_blank"> <em class="nq">招聘</em> </a> <em class="nq">(香草)JavaScript开发人员加入他们的前端工程团队。</em></p><p id="8524" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nq">更多内容请看</em><a class="ae lk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nq">plain English . io</em></a><em class="nq">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nq">免费周报在这里</em> </a> <em class="nq">。</em></p></div></div>    
</body>
</html>