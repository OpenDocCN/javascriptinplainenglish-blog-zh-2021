<html>
<head>
<title>Using the Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用平台</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-platform-instead-of-frameworks-33b4607fc3cc?source=collection_archive---------6-----------------------#2021-09-03">https://javascript.plainenglish.io/using-the-platform-instead-of-frameworks-33b4607fc3cc?source=collection_archive---------6-----------------------#2021-09-03</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><div class=""><h2 id="2216" class="pw-subtitle-paragraph jl in io bd b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dk translated">无框架、无构建的网站:2021年它们能带你走多远？</h2></div><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj kd"><img src="../Images/0a2de658c4fe73da66bb0879a14dff02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLrKeFPzEmK6IDnahMWQBA.png"/></div></div><figcaption class="kp kq gk gi gj kr ks bd b be z dk">A still from an animated diagram in <a class="ae kt" href="https://schematics.elisehe.in" rel="noopener ugc nofollow" target="_blank">Schematics: A Love Story</a>, a framework-free website that uses no build tools. Incidentally a metaphor for volatility in JavaScript trends.</figcaption></figure><p id="8d5a" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我最近看到了Daniel Kehoe的一系列文章，介绍了无栈方式(Stackless Way)，这是对web开发的一种乐观看法，建议我们“使用平台”(语言内置的现代功能)而不是框架，并构建每隔几年就会被替换的工具。</p><p id="123e" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这是一个好时机——框架疲劳是真实存在的！所以，我没有最终使用Rollup来替换我们的一个代码库中的一个古老的Browserify版本(它也可以真正使用从Polymer到LitElement的升级…)，而是决定使用“无堆栈”。我花了很长时间构思了一个动作设计项目，只用浏览器的原生功能构建了它:普通的JavaScript、ES6模块和web组件。</p><p id="a6c2" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">在一个没有依赖的代码库上工作是一种重新发现我在2021年可以免费得到什么的方式，以及我通过将框架、编译器和捆绑器结合在一起所增加的价值。我想分享我在这个过程中学到的东西(以及我需要忘记的东西)。</p><h2 id="fe10" class="lr ls io bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">该项目</h2><p id="b683" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">这个项目本身，<a class="ae kt" href="https://schematics.elisehe.in/" rel="noopener ugc nofollow" target="_blank"><em class="lq">Schematics:A Love Story</em></a>，是一本同名视觉诗集的动画图表集。如果你对详细的实现感兴趣，可以看看GitHub上的<a class="ae kt" href="https://github.com/elisehein/schematics" rel="noopener ugc nofollow" target="_blank">库</a>。</p><div class="mp mq gq gs mr ms"><a href="https://schematics.elisehe.in" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fp"><div class="mu ab mv cl cj mw"><h2 class="bd ip gz z fq mx fs ft my fv fx in bi translated">示意图→一个爱情故事</h2><div class="mz l"><h3 class="bd b gz z fq mx fs ft my fv fx dk translated">朱利安·希巴德的视觉诗集，由伊莉斯·海因制作。</h3></div><div class="na l"><p class="bd b dl z fq mx fs ft my fv fx dk translated">schematics.elisehe.in</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kn ms"/></div></div></a></div><h1 id="0e76" class="nh ls io bd lt ni nj nk lw nl nm nn lz ju no jv mc jx np jy mf ka nq kb mi nr bi translated">无堆叠方式</h1><p id="72ed" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">丹尼尔·凯霍并不是唯一一个反对现代网络复杂性的人。弗兰克·奇梅罗的<a class="ae kt" href="https://frankchimero.com/blog/2018/everything-easy/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">万事开头难</em> </a>每次都能打动我，最近，我很享受<a class="ae kt" href="https://medium.com/codex/youre-missing-out-on-vanilla-js-91aceec917d6" rel="noopener">这种关于缺乏对普通JS欣赏的轻松咆哮</a>。</p><p id="a50d" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">出于深思熟虑的目的添加外部JS依赖项的呼吁已经变得很普遍，但一些思想流派质疑单页面应用程序作为一个整体的概念:毕竟，服务器端呈现仍然是一个东西。页面也可以预先构建到一个完全静态的网站中，并从CDN提供服务(参见<a class="ae kt" href="https://jamstack.org/what-is-jamstack/" rel="noopener ugc nofollow" target="_blank"> Jamstack </a>)。这些方法认识到，我们可以将当前由前端框架管理的一些复杂性转移到堆栈的其他地方。</p><p id="8fd9" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">但是Kehoe关于无堆栈的系列文章感觉有点不同。这不仅仅是关于JavaScript——这是对作为平台的网络原生特性的全心投入(路由？只要确保每个网址匹配一个. html文件！)</p><p id="f73e" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">当然，这种纯粹主义是有限度的。对我来说，无堆栈的方式不太现实，更像是一种学习和反省的工具，一种后退一步重新爱上平台的方式。</p><p id="0a84" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">由于完全是关于动作设计，我自己的项目依赖于许多a <code class="fe ns nt nu nv b">setTimeout</code>和页面转换——一个单页应用程序，真的……只是手工制作的。使之成为可能的两个主要技术是ES6模块和web组件，它们与模块cdn一起构成了无堆栈方式的支柱。</p><h1 id="9399" class="nh ls io bd lt ni nj nk lw nl nm nn lz ju no jv mc jx np jy mf ka nq kb mi nr bi translated">ES6模块</h1><p id="6de3" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">如果您从事web开发已经有一段时间了，您可能还记得这样做:</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="9685" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">鉴于JavaScript缺乏对本地导入/导出机制的支持，我们只能在文档<code class="fe ns nt nu nv b">&lt;head&gt;</code>中单独列出所有需要的脚本。这当然不是最理想的:</p><ul class=""><li id="c955" class="ny nz io kw b kx ky la lb ld oa lh ob ll oc lp od oe of og bi translated">每个脚本标签发起一个HTTP请求；</li><li id="29cc" class="ny nz io kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">没有命名空间(所有脚本都存在于全局范围内)；</li><li id="b823" class="ny nz io kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">执行顺序是线性的，直接映射到脚本标签的顺序。</li></ul><p id="062e" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">为了解决这个问题，JavaScript的模块化方法在过去的几年里激增(AMD、UMD、CommonJS)，随之而来的是构建工具和捆绑器来将模块化代码转换成浏览器可以理解的东西。</p><p id="0b2a" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">ECMAScript模块(也称为ESM或ES6模块)是JavaScript中第一个<em class="lq">本机</em>模块标准。我在这里强调<em class="lq"> native </em>，因为这意味着我们可以抛弃构建工具和捆绑器，而支持HTML中的<code class="fe ns nt nu nv b">&lt;script type=“module”&gt;</code>和JS中的<code class="fe ns nt nu nv b">import</code> / <code class="fe ns nt nu nv b">export</code>:</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nw nx l"/></div></figure><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nw nx l"/></div></figure><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="c353" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated"><strong class="kw ip">对模块化的原生支持是迈向无构建代码库的最重要的一步。</strong>如果我的余生只能接触到一个<a class="ae kt" href="http://es6-features.org/" rel="noopener ugc nofollow" target="_blank"> ES6特性</a>，我相信模块会带我实现结构良好的原生JavaScript。</p><p id="12bb" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">不需要构建你的JS应用程序是不可思议的。为<em class="lq">原理图</em>设置目录结构，跳过<code class="fe ns nt nu nv b">npm run build</code>并看到我的源文件被镜像——照原样——我兴奋得头昏脑胀！—在浏览器中。这让我想起了我刚开始建网站的时候，双击<code class="fe ns nt nu nv b">index.html</code>就足以预览你的作品。</p><p id="d49c" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">如果您使用ES6模块，您确实需要一个本地服务器(所以双击一个HTML文件可能会永远成为过去)。但是在编辑代码和在浏览器中查看更改之间没有延迟，并且您在检查器中看到的源代码正是您在编辑器中键入的内容(没有sourcemaps！).</p><p id="0c92" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">别管更快的编辑-编译-调试周期——这直接说明了Chimero对今天的代码库中缺乏可读性的<a class="ae kt" href="https://frankchimero.com/blog/2018/everything-easy/" rel="noopener ugc nofollow" target="_blank">的担忧，这是学习这门手艺的障碍</a>:</p><blockquote class="om"><p id="490e" class="on oo io bd op oq or os ot ou ov lp dk translated">以前，网站可以自我解释；现在，需要有人带你走一遍。模糊来自于复杂而不清晰。我相信源的易读性是网络最重要的属性之一。[……]帮助某人<em class="ow">编写</em>标记的最好方法是确保他们能够<em class="ow">阅读</em>标记。</p><p id="de41" class="on oo io bd op oq or os ot ou ov lp dk translated">— <a class="ae kt" href="https://frankchimero.com/blog/2018/everything-easy/" rel="noopener ugc nofollow" target="_blank">弗兰克·奇梅罗</a></p></blockquote><h2 id="3284" class="lr ls io bd lt lu ox dn lw lx oy dp lz ld oz mb mc lh pa me mf ll pb mh mi mj bi translated">应用捆绑包的未来</h2><p id="2f75" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">仅仅因为你不需要一个构建工具来运行你的代码，并不意味着你不应该使用一个产品构建来优化性能。我这里指的不是变性，而是缩小、扭曲、摇晃树木等。</p><p id="b298" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我将JavaScript捆绑到一个单一的<code class="fe ns nt nu nv b">app.js</code>文件中已经有很长时间了，我的第一反应是将所有的东西连接到一个单一的脚本中<em class="lq"> Schematics </em>。当然，这不适用于ES6模块——文件的概念是不同模块之间的界限，没有办法为每个文件指定多个模块。</p><p id="cb04" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">幸运的是，您不需要将ES6模块捆绑到一个文件中来提高性能。让我重复一遍:<strong class="kw ip">您不需要将您的ES6模块捆绑到一个文件中来提高性能</strong>。</p><p id="3a45" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">原因如下:</p><ol class=""><li id="c971" class="ny nz io kw b kx ky la lb ld oa lh ob ll oc lp pc oe of og bi translated"><code class="fe ns nt nu nv b">&lt;script type=“module"&gt;</code>请求在默认情况下被<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules#other_differences_between_modules_and_standard_scripts" rel="noopener ugc nofollow" target="_blank">延迟</a>:它们不会阻塞文档解析。</li><li id="199a" class="ny nz io kw b kx oh la oi ld oj lh ok ll ol lp pc oe of og bi translated">从单独的源文件为所有模块提供服务对于缓存来说是非常好的，因为不受某些更改影响的模块可以继续从缓存中检索。当您提供单个包时，任何一个更改都会使整个包失效。</li><li id="b7f3" class="ny nz io kw b kx oh la oi ld oj lh ok ll ol lp pc oe of og bi translated">你可以通过使用<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports" rel="noopener ugc nofollow" target="_blank">动态导入</a>来延迟加载部分代码——在运行时，在你真正需要的时候导入模块。</li><li id="4432" class="ny nz io kw b kx oh la oi ld oj lh ok ll ol lp pc oe of og bi translated">可以用<code class="fe ns nt nu nv b"><a class="ae kt" href="https://developers.google.com/web/updates/2017/12/modulepreload" rel="noopener ugc nofollow" target="_blank">modulepreload</a></code>预加载关键模块。这将在主线程之外立即开始解析和编译链接的模块。</li><li id="d129" class="ny nz io kw b kx oh la oi ld oj lh ok ll ol lp pc oe of og bi translated">最后，HTTP2将来可能允许我们从第一个<code class="fe ns nt nu nv b">&lt;script type=“module”&gt;</code>请求中解析整个依赖图，并在一个响应中发回所有需要的文件。目前，这需要在服务器端编写定制的逻辑。</li></ol><p id="cf45" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">不要忘记包的大小:</p><blockquote class="om"><p id="2cd7" class="on oo io bd op oq or os ot ou ov lp dk translated">如果您检查由最流行的捆绑器生成的输出代码，您会发现许多样板文件，它们的唯一目的是动态加载其他代码和管理依赖关系，但是如果我们只是使用带有导入和导出语句的模块，这些都是不需要的！</p><p id="7e1d" class="on oo io bd op oq or os ot ou ov lp dk translated">— <a class="ae kt" href="https://philipwalton.com/articles/using-native-javascript-modules-in-production-today" rel="noopener ugc nofollow" target="_blank">菲利普·沃顿</a></p></blockquote><p id="6536" class="pw-post-body-paragraph ku kv io kw b kx pd jp kz la pe js lc ld pf lf lg lh pg lj lk ll ph ln lo lp ih bi translated">有关ES6模块负载性能和应用捆绑包的更多细节和有趣讨论，请参见ECMAScript讨论档案上的<a class="ae kt" href="https://esdiscuss.org/topic/fwd-are-es6-modules-in-browsers-going-to-get-loaded-level-by-level" rel="noopener ugc nofollow" target="_blank">这个帖子。规范还没有确定下来，有很多想法在流传，有些比其他的更大胆(我个人最喜欢的是将整个模块依赖图作为. zip文件提供的建议)。</a></p><blockquote class="om"><p id="d3b6" class="on oo io bd op oq or os ot ou ov lp dk translated">不过，Chrome中有大量正在进行的模块工作，所以我们越来越接近让bundlers得到他们应得的休息了！</p><p id="3d15" class="on oo io bd op oq or os ot ou ov lp dk translated">— <a class="ae kt" href="https://developers.google.com/web/updates/2017/12/modulepreload" rel="noopener ugc nofollow" target="_blank">塞尔吉奥·戈麦斯</a></p></blockquote><p id="4b74" class="pw-post-body-paragraph ku kv io kw b kx pd jp kz la pe js lc ld pf lf lg lh pg lj lk ll ph ln lo lp ih bi translated">更多阅读:</p><div class="mp mq gq gs mr ms"><a href="https://philipwalton.com/articles/using-native-javascript-modules-in-production-today/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fp"><div class="mu ab mv cl cj mw"><h2 class="bd ip gz z fq mx fs ft my fv fx in bi translated">在今天的生产中使用原生JavaScript模块</h2><div class="mz l"><h3 class="bd b gz z fq mx fs ft my fv fx dk translated">关于web开发、开源、软件架构和未来的思考。</h3></div><div class="na l"><p class="bd b dl z fq mx fs ft my fv fx dk translated">philipwalton.com</p></div></div><div class="nb l"><div class="pi l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq gq gs mr ms"><a href="https://tutorials.yax.com/articles/javascript/import/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fp"><div class="mu ab mv cl cj mw"><h2 class="bd ip gz z fq mx fs ft my fv fx in bi translated">JavaScript导入说明</h2><div class="mz l"><h3 class="bd b gz z fq mx fs ft my fv fx dk translated">Javascript 'import '语句:它的目的和使用方法。来自关于无堆栈web的一系列文章…</h3></div><div class="na l"><p class="bd b dl z fq mx fs ft my fv fx dk translated">tutorials.yax.com</p></div></div><div class="nb l"><div class="pj l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq gq gs mr ms"><a href="https://medium.com/backticks-tildes/introduction-to-es6-modules-49956f580da" rel="noopener follow" target="_blank"><div class="mt ab fp"><div class="mu ab mv cl cj mw"><h2 class="bd ip gz z fq mx fs ft my fv fx in bi translated">ES6模块简介</h2><div class="mz l"><h3 class="bd b gz z fq mx fs ft my fv fx dk translated">软件工程的一个重要方面是效率。每个成功的应用程序都需要一个坚实的架构…</h3></div><div class="na l"><p class="bd b dl z fq mx fs ft my fv fx dk translated">medium.com</p></div></div><div class="nb l"><div class="pk l nd ne nf nb ng kn ms"/></div></div></a></div><h1 id="ce7c" class="nh ls io bd lt ni nj nk lw nl nm nn lz ju no jv mc jx np jy mf ka nq kb mi nr bi translated">Web组件</h1><p id="2d81" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">Web组件是几种本地技术(自定义元素、影子DOM和HTML模板)的总称，这些技术让我们将元素的标记和动态行为捆绑到一段可重用的代码中，在高层上与React或Vue组件没有什么不同。截至2021年5月，<a class="ae kt" href="https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">所有制作Web组件的方法</em> </a>列出了一个假想的<code class="fe ns nt nu nv b">&lt;my-counter&gt;</code>组件的55种变体，用于跨捆绑包大小、编码风格和性能的比较。当然，本地web组件脱颖而出，因为它们没有外部依赖性(因此，具有无与伦比的小捆绑包大小)。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="pl nx l"/></div></figure><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="pl nx l"/></div></figure><p id="c8fd" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这里是我自己对web组件的一些印象，当谈到DX和架构时，与外部框架进行比较。</p><h2 id="41a8" class="lr ls io bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">阴影DOM和<template/></h2><p id="923f" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">影子DOM，一种保持主文档不可访问组件内部的方式，理论上是一个简洁的特性，但是当处理<em class="lq">原理图</em>时，它并没有真正出现。我认为影子DOM在跨多个站点和不可预测的上下文(比如UI库中的元素)重用组件的情况下非常有用；对于你的标准<code class="fe ns nt nu nv b">&lt;site-specific-header-dropdown&gt;</code>，并没有增加多少价值。</p><p id="a5f9" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated"><code class="fe ns nt nu nv b">&lt;template&gt;</code>和<code class="fe ns nt nu nv b">&lt;slot&gt;</code>元素(后者只有在使用shadow DOM时才有用)是作为一种在JS中添加隐藏标记的方式出现的，但是如果你习惯了像JSX这样的东西，它们会显得笨拙。此外，如果目标是创建可移植的组件,可以包含在一个应用程序中，那么<code class="fe ns nt nu nv b">&lt;template&gt;</code>标签<a class="ae kt" href="https://stackoverflow.com/a/53317973" rel="noopener ugc nofollow" target="_blank">似乎是反直觉的。当在HTML中声明时，任何引用了<code class="fe ns nt nu nv b">&lt;template&gt;</code>的JavaScript都会假设在主文档中有什么是可用的。事实上，有时<em class="lq">图表</em>中的<code class="fe ns nt nu nv b">index.html</code>感觉像是各种<code class="fe ns nt nu nv b">&lt;template&gt;</code>的垃圾场，而不是页面结构的简洁概述。</a></p><p id="a48b" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">HTML导入是一个可能允许我们将JS和HTML打包成一个包的提议，让<code class="fe ns nt nu nv b">&lt;template&gt;</code>成为这场秀的明星。不幸的是，这一功能从未实现。</p><p id="8219" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">另一个<a class="ae kt" href="https://github.com/whatwg/html/issues/2254" rel="noopener ugc nofollow" target="_blank">提出的特性</a>是一种向<code class="fe ns nt nu nv b">&lt;template&gt;</code>标签中的节点添加变量、简单语句和事件处理程序的方法。其要点与您目前在前端框架中看到的类似:</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="0d1c" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">习惯于框架中内置的数据绑定，直到上面的变量被自动更新，这个特性才感觉是半生不熟的。目前，很难在一个地方测量一个组件的完整的声明性标记，因为更新逻辑通过查询选择器、<code class="fe ns nt nu nv b">innerHTML</code>、文档片段等分散在整个类中。</p><div class="mp mq gq gs mr ms"><a href="https://github.blog/2021-05-04-how-we-use-web-components-at-github/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fp"><div class="mu ab mv cl cj mw"><h2 class="bd ip gz z fq mx fs ft my fv fx in bi translated">我们如何在GitHub | GitHub博客上使用Web组件</h2><div class="mz l"><h3 class="bd b gz z fq mx fs ft my fv fx dk translated">GitHub一直是Web组件的支持者。下面是我们如何使用它们。</h3></div><div class="na l"><p class="bd b dl z fq mx fs ft my fv fx dk translated">github.blog</p></div></div><div class="nb l"><div class="pm l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq gq gs mr ms"><a href="https://medium.com/swlh/https-medium-com-drmoerkerke-data-binding-for-web-components-in-just-a-few-lines-of-code-33f0a46943b3" rel="noopener follow" target="_blank"><div class="mt ab fp"><div class="mu ab mv cl cj mw"><h2 class="bd ip gz z fq mx fs ft my fv fx in bi translated">仅用几行代码实现Web组件的数据绑定</h2><div class="mz l"><h3 class="bd b gz z fq mx fs ft my fv fx dk translated">这不是火箭科学，而且虚拟DOM通常都是多余的。</h3></div><div class="na l"><p class="bd b dl z fq mx fs ft my fv fx dk translated">medium.com</p></div></div><div class="nb l"><div class="pn l nd ne nf nb ng kn ms"/></div></div></a></div><h2 id="37e0" class="lr ls io bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">扩展本机元素</h2><p id="97b5" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">我最感兴趣的web组件特性，也是第三方框架无法提供的特性，是扩展本地HTML元素的能力。这允许您继承组件中该元素的任何内置行为，包括特定于可访问性的属性。不幸的是，<a class="ae kt" href="https://dev.to/lkraav/comment/ad06" rel="noopener ugc nofollow" target="_blank">苹果已经决定不支持Safari </a>中的可定制元素。</p><p id="5d5a" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这令人失望。使用前端框架，我们经常实现自己的、更时髦的原生HTML元素版本。尤其是输入元素，比如下拉菜单和单选按钮，很难用CSS来设计样式，而且经常用JS来复制。但是复制所需的ARIA属性、键盘导航等需要额外的努力——我们可以通过可定制的元素免费获得这些东西。</p><h2 id="836d" class="lr ls io bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">一路向下的组件？</h2><p id="c46c" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">虽然ES模块引发了对未来的兴奋，但我对原生web组件取代传统前端框架的前景并不感兴趣。但是事后看来，用JS框架来衡量web组件是没有意义的。</p><p id="3754" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">作为一个React用户，将我的<code class="fe ns nt nu nv b">App.js</code>根组件连接到一个<code class="fe ns nt nu nv b">&lt;div id=“app”&gt;</code>根节点，然后沿着树向下，在更小的组件中工作，这是我习惯于考虑spa的方式。尽管您可以<em class="lq">将您的组件</em>附加到单独的DOM节点上(您也可以轻松地混合和匹配框架)，但更标准的方法是让框架驱动整个页面。</p><p id="4754" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">当使用web组件时，这将很快土崩瓦解。在原子UI元素的层次上，它们闪闪发光；对于业务逻辑和用户流，您应该遵从堆栈的不同部分。至于静态内容——如果原始标记可以完美地完成这项工作，为什么还要用JavaScript来呈现呢？</p><p id="3d3b" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">因此，我发现我的思维模式从一个只有一个大组件的应用程序转变为默认使用组件的<em class="lq">而不是</em>，在这个过程中打破了组件和框架之间的联系。</p><p id="1225" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">在<em class="lq"> Schematics </em>的例子中，我只在原生HTML标签中间整齐地放置了几个主要的定制元素。这个想法的简单说明:</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="964a" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">事后看来，组件应该封装一些UI的行为和外观似乎是显而易见的。但是，正如<a class="ae kt" href="https://dev.to/redbar0n/what-happened-to-components-being-just-a-visual-thing-22hc" rel="noopener ugc nofollow" target="_blank">这篇文章很好地描述的</a>，随着JS框架的扩散，“我们已经在路的另一边的沟渠中着陆:将各种各样的行为作为组件放入同一个JSX标记的结构中”。</p><blockquote class="om"><p id="ac03" class="on oo io bd op oq or os ot ou ov lp dk translated"><em class="ow">“React渲染你的UI并响应事件”是</em> <a class="ae kt" href="https://youtu.be/x7cQ3mrcKaY?t=79" rel="noopener ugc nofollow" target="_blank"> <em class="ow">怎么介绍的</em> </a> <em class="ow">。不是:“React是一种在声明性标记的层次结构中转换和执行所有逻辑的方法”，因为它在许多情况下已经退化为。</em></p><p id="b59f" class="on oo io bd op oq or os ot ou ov lp dk translated"><em class="ow"> — </em> <a class="ae kt" href="https://dev.to/redbar0n/what-happened-to-components-being-just-a-visual-thing-22hc" rel="noopener ugc nofollow" target="_blank"> <em class="ow">磁钢</em> </a></p></blockquote></div><div class="ab cl po pp hs pq" role="separator"><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt"/></div><div class="ih ii ij ik il"><p id="f0fa" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这些想法大多基于第一印象。如果你对web组件规范的状态有兴趣，我向<a class="ae kt" href="https://webreflection.medium.com/about-web-components-cc3e8b4035b0" rel="noopener">推荐Andrea Giammarchi </a>的这篇优秀文章，它在web 30年历史的背景下对该特性进行了批判性的审视。</p><div class="mp mq gq gs mr ms"><a href="https://webreflection.medium.com/about-web-components-cc3e8b4035b0" rel="noopener follow" target="_blank"><div class="mt ab fp"><div class="mu ab mv cl cj mw"><h2 class="bd ip gz z fq mx fs ft my fv fx in bi translated">关于Web组件</h2><div class="mz l"><h3 class="bd b gz z fq mx fs ft my fv fx dk translated">1998年，W3C提出了一种方法，通过CSS的行为属性，优雅地增强任何内置元素…</h3></div><div class="na l"><p class="bd b dl z fq mx fs ft my fv fx dk translated">webreflection.medium.com</p></div></div><div class="nb l"><div class="pv l nd ne nf nb ng kn ms"/></div></div></a></div><h1 id="720d" class="nh ls io bd lt ni nj nk lw nl nm nn lz ju no jv mc jx np jy mf ka nq kb mi nr bi translated">无堆栈的未来</h1><p id="b64e" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated"><em class="lq"> Schematics </em>就架构而言是一个简单的项目，web组件和ES6模块带我走了大部分的路。但我无法想象自己在没有框架的情况下构建一个更复杂的应用程序。使用像Jekyll这样的生成器，完全静态的站点也更容易构建:当你只使用浏览器和文本编辑器时，像跨页面重用标记这样的事情是不可能的(谦逊的<code class="fe ns nt nu nv b">&lt;iframe&gt;</code>可能不同意我的观点……)。</p><p id="e23c" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">抛开技术限制不谈，我在这次练习中意识到的一个问题是普通JavaScript缺乏标准。因为我们太习惯于框架规定如何构建我们的代码库，所以如果你决定手工制作你的JavaScript，没有很多既定的指导方针。不要在意高级架构——甚至你定义一个类、使用静态变量或者实现组合的方式都有一系列的方法。Web组件填补了UI方面的空白；也许如果更多的开发人员敢于走向无框架(在适当的时候！围绕最佳实践的讨论将更有成效。</p><h1 id="5c08" class="nh ls io bd lt ni nj nk lw nl nm nn lz ju no jv mc jx np jy mf ka nq kb mi nr bi translated">了解平台</h1><p id="da18" class="pw-post-body-paragraph ku kv io kw b kx mk jp kz la ml js lc ld mm lf lg lh mn lj lk ll mo ln lo lp ih bi translated">在没有框架或构建工具的情况下开发web应用程序本身并不是最终目标。正如丹尼尔·凯霍在《无栈通讯》中所说:</p><blockquote class="om"><p id="172f" class="on oo io bd op oq or os ot ou ov lp dk translated"><em class="ow">我不认为几年后我们会谈论“无堆栈”。这只是任何web开发人员的专业锦囊妙计的一部分。</em></p></blockquote><p id="3c62" class="pw-post-body-paragraph ku kv io kw b kx pd jp kz la pe js lc ld pf lf lg lh pg lj lk ll ph ln lo lp ih bi translated">我很乐意看到这种情况发生。我特别鄙视那些把运行<code class="fe ns nt nu nv b">create-react-app</code>作为第一步的初级JavaScript教程，这个练习更加坚定了我的信念，即每个初级程序员都应该在钻研框架之前掌握HTML、CSS和普通JS。web固有的特性是所有框架所共有的，了解这个平台有助于在面对变化时打下更坚实的基础。</p></div><div class="ab cl po pp hs pq" role="separator"><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt"/></div><div class="ih ii ij ik il"><p id="58aa" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated"><em class="lq">原载于2021年8月22日</em><a class="ae kt" href="https://elisehe.in/2021/08/22/using-the-platform" rel="noopener ugc nofollow" target="_blank"><strong class="kw ip"><em class="lq">https://Elise he . in</em></strong></a><em class="lq">。</em></p><p id="1765" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated"><em class="lq">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kw ip"><em class="lq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>