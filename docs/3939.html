<html>
<head>
<title>Introduction to Generator Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的生成器函数简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-generator-functions-in-javascript-e587f5f53d76?source=collection_archive---------24-----------------------#2021-08-06">https://javascript.plainenglish.io/introduction-to-generator-functions-in-javascript-e587f5f53d76?source=collection_archive---------24-----------------------#2021-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/01309f4e1e83b8d0c8e9bce821e302bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JlLqZRZVaKFbVt2p"/></div></div></figure><p id="332c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生成器是JavaScript中的一个高级概念，但是很容易理解。生成器是JavaScript中的特殊函数，它可以根据需要返回多个值，不像常规函数只能返回一个值。</p><p id="2779" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与正常功能不同，发电机功能的执行可在中途<strong class="jx io">停止</strong>并可恢复。</p><h1 id="e05a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何创建生成器函数</h1><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="08c7" class="ma ku in lw b gy mb mc l md me">function* generatorFunction(){</span><span id="42aa" class="ma ku in lw b gy mf mc l md me">}</span></pre><p id="2637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建生成函数有一个特殊的语法，它与普通的函数语法没有太大的不同。</p><p id="c377" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">function关键字后面的*使这个函数成为一个生成器函数。</p><h1 id="e4b7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何使用上面创建的生成器函数</h1><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8761" class="ma ku in lw b gy mb mc l md me">function* generatorFunction(){<br/>  console.log("Start")<br/>  yield 7;<br/>  console.log("Midway")<br/>  yield 8;<br/>  console.log("Stop")<br/>}</span><span id="c13f" class="ma ku in lw b gy mf mc l md me">const gen = generatorFunction();</span><span id="a0cb" class="ma ku in lw b gy mf mc l md me">let result = gen.next();<br/>console.log(result.value) // logs 7<br/>result = gen.next();<br/>console.log(result.value) // logs 8</span></pre><p id="755d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里介绍另一个关键词yield。您可以将yield视为返回关键字，但对于生成器函数。让我们举一个例子</p><p id="9f94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看这里发生了什么:</p><ol class=""><li id="5e16" class="mg mh in jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">我们定义一个生成函数，它首先产生(返回)数字7，然后产生数字8。我们还添加了几个控制台日志。</li><li id="9db3" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">我们在这里调用generatorFunction并将返回值存储在变量<code class="fe mu mv mw lw b">gen</code>中</li><li id="9b75" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">通常，当使用普通函数时，你会期望变量<code class="fe mu mv mw lw b">gen</code>保存值7。</li><li id="2a26" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">但对于发电机来说，情况并非如此。<code class="fe mu mv mw lw b">gen</code>变量不存储生成器生成的值，而是存储由<code class="fe mu mv mw lw b">generatorFunction</code>返回的<code class="fe mu mv mw lw b">Generator</code>对象</li><li id="d2be" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated"><code class="fe mu mv mw lw b">gen</code>对象有一个方法<code class="fe mu mv mw lw b">next()</code></li><li id="f7ee" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">第一次调用<code class="fe mu mv mw lw b">gen.next()</code>方法开始执行生成器函数，当它到达<code class="fe mu mv mw lw b">yield</code>时，它在那里停止函数并返回一个具有两个属性<code class="fe mu mv mw lw b">value</code>和<code class="fe mu mv mw lw b">done</code>的对象。<strong class="jx io">值</strong>是产生的值，而<strong class="jx io">完成</strong>是一个布尔值，它告诉我们发生器功能是否完全执行完毕</li><li id="40bb" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">所以在上面的例子中，当第一次调用<code class="fe mu mv mw lw b">gen.next()</code>时，生成器函数开始执行。“开始”被记录到控制台，然后发生器产生值7。这时它停止函数并返回一个对象，这个对象(在本例中)将是<code class="fe mu mv mw lw b">{ value : 7 , done : false }</code>。<strong class="jx io">值</strong>是产出值，为7。<strong class="jx io">完成</strong>就是<code class="fe mu mv mw lw b">false</code>因为发电机还没有完全执行；函数中还有一些代码行尚未执行。“7”被记录到控制台。</li><li id="ec78" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated"><code class="fe mu mv mw lw b">gen.next()</code>方法的下一次(第二次)调用从它之前停止的点恢复生成器函数。因此，“中途”被记录到控制台，然后生成器产生值8。它在那里停止函数并返回<code class="fe mu mv mw lw b">{ value: 8, done: false}</code>,因为产生的值是8，函数还没有执行完。“8”被记录到控制台。</li><li id="ac19" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">“停止”不会被记录到控制台，因为我们再也不会呼叫<code class="fe mu mv mw lw b">gen.next()</code></li></ol><h1 id="17fb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">笔记</h1><ul class=""><li id="0b6f" class="mg mh in jx b jy mx kc my kg mz kk na ko nb ks nc mm mn mo bi translated">在上面的例子中，如果我们第三次调用<code class="fe mu mv mw lw b">gen.next()</code>，控制台上会记录“Stop ”,返回的对象是<code class="fe mu mv mw lw b">{ value : undefined, done : true</code>。注意这次done属性是真的。这是因为生成器的所有代码都已经执行完了。而value属性是未定义的？这是因为生成器没有产生任何值。如果在此之后继续调用<code class="fe mu mv mw lw b">gen.next()</code>，结果将始终是<code class="fe mu mv mw lw b">{ value : undefined, done : true</code></li><li id="e875" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks nc mm mn mo bi translated">无法重新启动生成器对象。一旦它执行完毕，你就不能重启它了。如果你想再次运行一个生成器函数，通过调用<code class="fe mu mv mw lw b">generatorFunction</code>创建一个新的<code class="fe mu mv mw lw b">Generator</code>对象，并将其存储在一个新的变量中。然后你就可以处理这个变量了。</li><li id="bf2b" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks nc mm mn mo bi translated">上述观点的例子</li></ul><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1fa4" class="ma ku in lw b gy mb mc l md me">const newGen = generatorFunction();</span><span id="4e0e" class="ma ku in lw b gy mf mc l md me">const newResult = newGen.next():</span><span id="f634" class="ma ku in lw b gy mf mc l md me">console.log(newResult).value) // logs 7</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="3098" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nk">原发布于</em><a class="ae nl" href="https://parth2412.hashnode.dev/introduction-to-generator-functions-in-javascript" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://parth 2412 . hash node . dev</em></a><em class="nk">。</em></p><p id="254f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nk">更多内容请看</em><a class="ae nl" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>