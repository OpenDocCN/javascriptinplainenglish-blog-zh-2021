# 如果你的代码是垃圾，Node 的垃圾收集器就没用了

> 原文：<https://javascript.plainenglish.io/if-your-code-is-garbage-nodes-garbage-collector-won-t-help-f48d32d3bc9a?source=collection_archive---------5----------------------->

## 以下是你需要知道的

![](img/ce8d26aa4aff6a73507e914385795b5b.png)

Photo by [Paweł Czerwiński](https://unsplash.com/@pawel_czerwinski?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

垃圾听起来不好——那是因为它不好。它甚至会使你的程序崩溃。但是这是什么意思呢？

当执行代码时，东西被存储在内存中——这样我们的程序可以快速访问它们。我们也可以在内存中动态创建新的东西。然而，内存是有限的，所以删除不再需要的项目是个好主意。这正是垃圾收集器为我们做的——它删除内存中的内容，为新内容腾出空间。

如果无用的东西没有被删除，内存变得越来越满，我们说内存泄漏。这些错误的致命之处在于——当你发现它们的时候已经太晚了。当内存满到极限时，程序不能创建新的对象——它必须中止。

以下是关于 JavaScript 中的内存泄漏，尤其是 Node.js 中的内存泄漏，您需要了解的内容。

# 什么是内存泄漏，什么不是？

简单地说:如果不删除不用的东西，这可能会导致内存泄漏。

要是这么简单就好了——因为它更多的是关于垃圾收集器**认为不再被使用的东西**。

GC 的行为是防御性的，有时**不会移除不再需要的**物品。这就是为什么仅仅依赖垃圾收集器是致命的——它不是全知的。

**让我们看一个危险的例子。**

上面的代码每秒输出一次对象需要多少内存。

5 秒钟后，一个巨大的数组被创建。

当然，这需要很大的内存。但事实上，它从未被使用过。

在这里，您可以看到内存使用量每秒钟是如何变化的:

![](img/c48a16141261bd07c2de43d4e3a7492a.png)

创建数组后，内存使用量急剧增加。仅仅过了几秒钟，使用量又下降了——GC 已经删除了该数组，因为不再需要它了。学习:GC 是间歇工作的。

因此，在这种情况下，GC 可以正确地检测未使用的对象。

但是也有我们不能依赖 GC 的情况。

让我们来看看这个:

代码与第一个例子只有很小的不同。
这里我们把大数组存放在全局范围内。该数组实际上仍未被使用——但垃圾收集器对此有不同的看法。

当您运行它时，您会注意到内存使用量再次上升，但也没有下降。垃圾收集器认为该数组很重要，因此不会移除它。

**学习:**从 **setTimeout** 、 **setInterval、**等引用全局作用域变量是危险的。

# 怪异的 JS 行为导致内存泄漏

通常你用 **var、let 或 const 来声明变量。**

如果我们不这样做，变量无论如何都会存在。

后台发生的事情可能会有问题。无论我们在哪里“错误地”声明了变量，它都会被赋给全局对象——即使它应该只在函数的范围内。

这里有一个例子。

这是合法的代码。
不出所料，该变量只在函数范围内可用——我们不能在 greet-function 之外记录它。

当只删除 const-keyword 时，它看起来像这样，一切都变了。

上面的代码也可以。

该变量突然在全局范围内可用，这意味着垃圾收集器不会清理它。

代码示例在 Node.js 中——没有窗口对象，只有全局对象。两者都是顶级对象。因此，如果将“全局”替换为“窗口”，这些示例在浏览器中的工作方式是相同的

# 有时候 GC 会捉弄你

垃圾收集器帮助你释放程序的内存。如果内存没有被再次释放，并且变得越来越满，程序将最终终止。

但是垃圾收集器究竟在什么时候查看需要删除什么呢？正是这一点可能导致垮台。我向您展示了如何输出堆的使用情况。这是查找漏洞的有力工具。

问题是:并不是所有看起来像内存泄漏的事情都是内存泄漏。如果您跟踪内存使用情况，一开始它可能会上升但不会下降——这看起来像是内存泄漏，但这可能是因为 GC 还没有开始删除任何东西。

有一个强大的技巧来测试您的代码是否存在内存泄漏:我们可以故意调用 Node.js 中的垃圾收集器，重要的是:这是以性能为代价的，所以建议只在开发期间使用这个技巧。

要手动运行垃圾收集器，我们必须像这样启动我们的应用程序:`node --expose-gc index.js`。用`global.gc()`我们可以调用垃圾收集器。

您已经知道了代码，这需要几秒钟的时间来清理内存。但是通过我们的技巧，我们可以立即打开 GC。

![](img/0b3fc2aeec2b17effe00e1008ebb8090.png)

只需添加以下代码:

```
setInterval(function() { 
  global.gc()
}, 3500)
```

![](img/09363eba73701b6c691bc15b5c7069ce.png)

在第 3 秒，垃圾被创建；半秒钟后，我们再次移除它。很方便，不是吗？

## [加入我的时事通讯，了解最新消息](http://eepurl.com/hacY0v)