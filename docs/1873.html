<html>
<head>
<title>How to Replicate Reducer Logic into Multiple IDs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Reducer逻辑复制到多个id中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/replicating-reducer-logic-into-multiple-ids-691a72e40f63?source=collection_archive---------22-----------------------#2021-04-19">https://javascript.plainenglish.io/replicating-reducer-logic-into-multiple-ids-691a72e40f63?source=collection_archive---------22-----------------------#2021-04-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b4c14b960d81a5e4762c17e9523fc004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKtMVJ-oQw3u3ssx55i3yg.png"/></div></div></figure><p id="742a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Redux是一个强大的应用程序状态管理器，与React一起广泛使用。一旦定义了一个Reducer，您可能希望将这个文件的完全相同的逻辑复制到多个标识符中。</p><blockquote class="kt ku kv"><p id="44a9" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">TL；博士</strong> — <a class="ae la" href="https://gist.github.com/pflevy/bc555d0e6fa159894ece9316997e3433" rel="noopener ugc nofollow" target="_blank">完整的代码要点</a> || <a class="ae la" href="https://codesandbox.io/s/multiple-ids-reducer-example-1v7h1" rel="noopener ugc nofollow" target="_blank">代码盒示例</a></p></blockquote><h2 id="c481" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">会实现什么？</h2><p id="e168" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">让我们假设一个“汽车”减速器支持和控制下面的结构:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8dc1" class="lb lc in me b gy mi mj l mk ml">{<br/>    name: 'Car Reducer Example',<br/>    maxSpeed: 150,<br/>    famousPilots: []<br/>}</span></pre><p id="14c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您将实现以下目标:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2c8b" class="lb lc in me b gy mi mj l mk ml">byId:{<br/>    111: {<br/>        name: 'Car Reducer Example 2',<br/>        maxSpeed: 150,<br/>        famousPilots: []<br/>    },<br/>    1040: {<br/>        name: 'Car Reducer Example 2',<br/>        maxSpeed: 160,<br/>        famousPilots: []<br/>    },<br/>}</span></pre><p id="899d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">整个reducer逻辑(处理动作、更新状态)将被单独复制到每个ID。您只需定义一次减速器结构，然后根据需要重用它。</p><p id="7dc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据不仅仅是后端的责任。前端应该明智地构建其数据流，专注于为用户提供无缝体验。</p><p id="c17b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个例子。假设您希望显示一个关于应用程序中最活跃用户的信息的屏幕。您的减压器负责处理来自该屏幕的数据:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8fcf" class="lb lc in me b gy mi mj l mk ml">{<br/>   mostActiveUser: 'User X Name',<br/>   totalNumberOfPosts: 77,<br/>   ...otherProperties<br/>}</span></pre><p id="aa64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该结构解决了在屏幕上显示所需信息的要求。然而，它的能力有限，因为它只能在特定的时间段内保存数据<strong class="jx io">。</strong></p><p id="9958" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果显示的信息与四月有关，为了将用户可视化更改为五月，您将<strong class="jx io">覆盖整个数据</strong>，一旦用户决定再次检查四月，这是对资源和时间的<strong class="jx io">浪费。<br/>你不仅会让用户等待一些他们之前已经拥有的数据，而且你还会向服务器发出重复的请求。</strong></p><p id="c2de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应用多个id的处理程序<strong class="jx io">将月份视为标识符</strong>您可以实现以下功能:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="90e8" class="lb lc in me b gy mi mj l mk ml">byId:{<br/>    '2020-04': {<br/>       mostActiveUser: 'User X Name',<br/>       totalNumberOfPosts: 77,<br/>       ...otherProperties<br/>    },<br/>    '2020-05': {<br/>       mostActiveUser: 'User Y Name',<br/>       totalNumberOfPosts: 53,<br/>       ...otherProperties<br/>    },<br/>}</span></pre><p id="f577" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">缩减器保持不变，它的实现没有改变。然而，你可以通过使它能够重现它负责的每一个变化来增强它，但是要在特定的月份处理这些变化。</p><p id="098c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">实例</strong></p><p id="d900" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下面的例子中，一个缩减器被设计用来保存单个神奇宝贝的数据。为了复制其逻辑，应用了多重id处理程序，并且神奇宝贝名称被用作标识符。</p><p id="2325" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意<strong class="jx io">减速器结构</strong>保存了一个<strong class="jx io">单个</strong>神奇宝贝的数据。<br/>使用处理程序，其逻辑被复制到<strong class="jx io">多个</strong>神奇宝贝。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="84a5" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">应用这种功能的动机是什么？</h2><p id="275b" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">上面的例子显示了相当简单的情况，具有简单的结构。在现实世界的应用程序中，reducers更有可能控制更多的数据，并负责处理复杂的操作。</p><p id="5cc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦定义了这个结构，您应该避免通过简单地将代码从一个缩减器复制到另一个来复制它。我们将经历构建处理程序的过程，以复制整个reducer功能来处理多个id。</p><p id="8bec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您希望将整个reducer逻辑应用于多个动态项目，即在获取一些数据之前还不可用的标识符，就像实例中的神奇宝贝名称一样，这是非常强大的。</p><p id="245d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过<strong class="jx io">而不是</strong>进行重复请求，避免浪费资源也很有效，这在用户体验中也起着重要作用，因为你不会让用户等待他已经拥有的信息。</p><h2 id="aa32" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">入门指南</h2><p id="fb01" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">构建这样的处理程序时，首先要注意的是reducers只是函数:它们需要两个参数(state和action ),并根据传递的动作返回更新后的状态。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="a850" class="lb lc in me b gy mi mj l mk ml">// Reducer function example<br/>function myReducer(state,action) =&gt; {<br/>    switch(action.type){<br/>        default: return state<br/>    }<br/>}</span></pre><p id="98c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着我们被允许在它上面应用一个函数，并且<strong class="jx io">对将要使用的最终状态</strong>进行修改。这是高阶减速器的概念。</p><h2 id="7c17" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">创建多id缩减器处理程序</h2><p id="6af6" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">创建一个新文件，并插入以下代码:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="706d" class="lb lc in me b gy mi mj l mk ml">export const multipleIdsReducerHandler = (reducerFunction) =&gt; (state = {}, action) =&gt; {<br/>    const { internalReducerId } = action<br/>    if(internalReducerId === undefined) return state<br/>}</span></pre><p id="ca5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，它做了一个简单的工作，它将接收一个reducer函数(我们希望将它的功能扩展到多个id中)，然后像任何reducer一样接收状态和动作。如果属性<strong class="jx io"> internalReducerId </strong>不在<strong class="jx io">动作</strong>中，它将自动返回当前状态。</p><p id="5a53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，定义了一个结构来标识reducer逻辑应该应用到哪个特定的Id上:<strong class="jx io"> internalReducerId必须存在于动作</strong>上，以便处理程序能够<strong class="jx io">标识在哪个对象(ID)上应用所需reducer的执行结果</strong>。</p><p id="29c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的代码负责执行所需的reducer，并从动作调用中获得结果状态。此外，底部的比较避免了在不是所需的缩减器上包含新的ID。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e70b" class="lb lc in me b gy mi mj l mk ml">    const newState = reducerFunction(state.byId?.[internalReducerId] || {}, action)</span><span id="29b5" class="lb lc in me b gy mo mj l mk ml">    if(Object.keys(newState).length === 0 ) return state</span></pre><p id="259f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想象以下场景，multipleIdsReducerHandler应用于两个reducer<strong class="jx io">上:如果我们在Reducer1上设置了一个ID，那么它也不应该在Reducer2上设置。由于<strong class="jx io">当一个动作被分派时，所有的reducer函数都在运行，</strong>我们将陷入第二个reducer的“默认”情况(因为它没有实现被分派的动作)。但是在这一点上，我们不能继续我们的操作，否则，我们将把ID属性(在动作中定义为internalReducerId)添加到所有实现处理程序的reducers中，这就是为什么我们在识别到这个尝试时自动返回状态。</strong></p><p id="fe01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在剩下的就是从期望的reducer的执行中获取结果，并将其设置为指定的ID，然后返回整个状态。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d546" class="lb lc in me b gy mi mj l mk ml">return {<br/>    ...state,<br/>    byId:{<br/>        ...state.byId,<br/>        [internalReducerId]: { ...newState }<br/>    }<br/>}</span></pre><p id="ed12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">处理程序已完成。简单，但功能强大。你可以检查<a class="ae la" href="https://gist.github.com/pflevy/bc555d0e6fa159894ece9316997e3433" rel="noopener ugc nofollow" target="_blank">这个要点</a>的完整代码。</p><p id="8248" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要应用它，将<strong class="jx io">multipleids Reducer handler</strong>导入到您想要的Reducer文件中，并用它包装它的导出:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5cae" class="lb lc in me b gy mi mj l mk ml">export default <strong class="me io">multipleIdsReducerHandler(</strong>myReducerFunction<strong class="me io">)</strong></span></pre><p id="ef79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并且当调度一个与期望的reducer相关的动作时，总是包含<strong class="jx io"> internalReducerId属性:</strong></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="033f" class="lb lc in me b gy mi mj l mk ml">dispatch({ ...otherProperties, <strong class="me io">internalReducerId: myId</strong> })</span></pre><h2 id="08f2" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">多id缩减器处理程序的完整代码</h2><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mp mn l"/></div></figure><p id="c08d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你也可以从神奇宝贝的例子中查看这个<a class="ae la" href="https://codesandbox.io/s/multiple-ids-reducer-example-1v7h1?fontsize=14&amp;hidenavigation=1&amp;theme=dark&amp;view=preview" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>来查看实现细节。</p><h2 id="f463" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated"><strong class="ak">奖金型派单</strong></h2><p id="177b" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">如果您正在使用TypeScript，那么最好将<strong class="jx io"> dispatch </strong>函数类型化，以便在调度动作时强制要求internalReducerId属性。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="49ce" class="lb lc in me b gy mi mj l mk ml">export type DispatchWithMultipleIds = (<br/>    args: {<br/>        [x: string]:any;<br/>        internalReducerId: string;<br/>    }<br/>) =&gt; void;</span></pre><p id="db12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只需导入类型并在dispatch参数上使用它。例如:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6760" class="lb lc in me b gy mi mj l mk ml">return async (dispatch: DispatchWithMultipleIds, getState) =&gt; ...</span></pre><p id="0447" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">你可以在</em> <a class="ae la" href="https://redux.js.org/recipes/structuring-reducers/reusing-reducer-logic" rel="noopener ugc nofollow" target="_blank"> <em class="kw">官方Redux文档</em> </a> <em class="kw">上了解更多关于高阶减速器和重用减速器逻辑的知识。</em></p><p id="2a31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">更多内容请看</em><a class="ae la" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kw">plain English . io</em></a></p></div></div>    
</body>
</html>