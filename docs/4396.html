<html>
<head>
<title>Conditional React Context: Treating Each Consumer Differently</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">条件反应上下文:区别对待每个消费者</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/conditional-react-context-treating-each-consumer-differently-9af48ff81bef?source=collection_archive---------6-----------------------#2021-09-02">https://javascript.plainenglish.io/conditional-react-context-treating-each-consumer-differently-9af48ff81bef?source=collection_archive---------6-----------------------#2021-09-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/39d58adb2b7bc4d9d29e68cb0073182c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UYL506uymDLN4yDf"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d5a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您经常使用React上下文，很快您就会意识到当它被更新时，这是一个繁重的操作。因此人们倾向于给孩子加上一个<code class="fe ky kz la lb b">React.memo</code>。然后瞧，事情马上就变得不同了，或者有时什么也没发生。:)</p><p id="9f9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个组件应用程序提供一些价值。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="03ef" class="lk ll in lb b gy lm ln l lo lp">const App = ({ aProp }) =&gt; {<br/>  const [aState, ] = useState(...)<br/>  <br/>  return (<br/>    &lt;Context.Provider value={...}&gt;<br/>      &lt;Indirection /&gt;<br/>    &lt;/Context.Provider&gt;<br/>  ) <br/>}</span></pre><p id="30f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是渲染所有内容的挂载配置文件。</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/f38ac64d19a92a3a0b9fa5b04506a019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4u-n2Y-u_v8K549bag9Tjw.png"/></div></div></figure><p id="d447" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在中间添加一个间接组件来保存以下两个消费者Child和Child2。这个组件在以后的优化中很有用。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="8a17" class="lk ll in lb b gy lm ln l lo lp">const Indirection = (() =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Child /&gt;<br/>      &lt;Title /&gt;<br/>    &lt;/&gt;<br/>  )<br/>})</span></pre><h2 id="4011" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">上下文提供者</h2><p id="e2aa" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">只读上下文与此对话无关，因为在装载时，所有内容都会被呈现。如果之后上下文保持不变，就不再需要渲染了。</p><p id="88ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们有状态变化时，一切都变得有趣和有争议。由于应用程序上的属性或状态改变，触发对<code class="fe ky kz la lb b">ContextProvider</code>的更新。</p><p id="fd29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上下文提供者没有机会退出，因为在应用程序的协调过程中，它已经被标记为具有一组新的<code class="fe ky kz la lb b">children</code>道具。提供商做两件事。一种是独特的，将上下文变化传播到所有消费者纤程。第二个是，像大多数组件一样，将自己的子组件整合到纤程中。</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/6693535524bcf483a93017b4bf81fb39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VC-1UJ4V5SgCiyLxRzBSkw.png"/></div></div></figure><p id="8e93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将传播放在一边，一旦这一系列协调开始，提供者的所有子代都被呈现，包括它的子代的子代，等等，见上图。提供者下的所有内容都被呈现，因为传播确保了所有消费者都位于该上下文中。</p><p id="bb91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是有些东西闻起来不对劲。你可能会想，既然间接寻址没有道具，为什么要呈现呢？每个消费者之间都有间接路径，这些路径可能很长。在我们的例子中，我们想要从渲染中摆脱的是Indirection和Child2之间的Title和div，因为那里没有任何变化。</p><h2 id="42cc" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">反应备忘录</h2><p id="e33c" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">所以不能加个<code class="fe ky kz la lb b">React.memo</code>来救援吗？让我们试一试。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="b6be" class="lk ll in lb b gy lm ln l lo lp">const Indirection = <strong class="lb io">React</strong>.<strong class="lb io">memo</strong>(() =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Child /&gt;<br/>      &lt;Title /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="99c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在将<code class="fe ky kz la lb b">memo</code>应用到间接组件之后，当App的状态发生变化时，Child和Child2仍然会被呈现，这很好。</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/7ee0db823938a50ee0d52c2506ed2ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3Lu5blmZKvs5kMccw7I4Q.png"/></div></div></figure><p id="facb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有趣的是，Indirection和Child2之间的路径被去掉了，如上图中的灰色所示。还有什么会有这种颜色？对，App(上面还有一个，Root)。</p><p id="fef1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所发生的是，从更高的层次，间接成为另一个根。如果一个分派是一个典型的呈现路径，那么现在我们从一个新的根开始得到多个呈现路径的组合，在我们的例子中是间接的。这不是很神奇吗？</p><p id="4872" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这是我们的想法，也是供应商应该做的。所以这里有一个百万美元的问题:为什么带有memo的间接方式不能被添加为默认的提供者行为？我不知道。但是所有与Provider相关的React测试都带有Indirection (with memo)组件。</p><h1 id="af6c" class="mp ll in bd lr mq mr ms lu mt mu mv lx mw mx my ma mz na nb md nc nd ne mg nf bi translated">有条件的消费者</h1><p id="a469" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我们这么想吧。随着<code class="fe ky kz la lb b">React.memo</code>的应用，这将使上下文在组件通信方面变得非常强大。</p><p id="4957" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个问题来了，我们能保释出更多的孩子吗？尤其是当一个消费者不同于另一个消费者时。</p><h2 id="fefb" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">改变的比特</h2><p id="be9c" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">有一个不受欢迎的功能，实际上最近被React团队关闭了。它使用了上下文的第二个参数。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="5dad" class="lk ll in lb b gy lm ln l lo lp">const calculateChangedBits = (oldProps, newProps) =&gt; {<br/>  const bits = newProps % 2 === 0 ? 0b10 : 0b01<br/>  return bits<br/>}</span><span id="0716" class="lk ll in lb b gy ng ln l lo lp">const AContext = createContext(0, calculateChangedBits)</span></pre><p id="29c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当创建带有值的上下文时，它允许您添加一个函数来指定您想要监视的所有可能的场景。在前面的代码中，我们根据值是偶数还是奇数设置了两种情况。</p><p id="a76b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">消费者可以从<code class="fe ky kz la lb b">useContext</code>的第二个论点开始监控案例。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="8ff3" class="lk ll in lb b gy lm ln l lo lp">const Child = () =&gt; {<br/>  const a = useContext(AContext, 0b11)<br/>  return &lt;div&gt;{a}&lt;/div&gt;<br/>}</span><span id="2e53" class="lk ll in lb b gy ng ln l lo lp">const Child2 = () =&gt; {<br/>  const a = useContext(AContext, 0b10)<br/>  return &lt;Nothing2 a={a} /&gt;<br/>}</span></pre><p id="fd11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以要求每个消费者听不同的场景。在上面的代码中，我们要求Child render处理偶数和奇数，Child2只处理偶数。</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/b63dc7407458bffe32770d6855c00bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPp_pVQBqcrAt0w9ATv_SA.png"/></div></div></figure><p id="6e37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当更改为奇数时，整个Child2分支都会被保释，因为它实际上不会在提供者传播时获得更新请求。疯狂的库尔！</p><h2 id="df60" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">上下文选择器</h2><p id="e267" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">虽然我认为<code class="fe ky kz la lb b">changedBits</code>是一个聪明的想法，但自从它被引入后就没有受到任何欢迎。我们可以理解，从使用的角度来看，这个想法很难卖给客户，也就是我们。</p><p id="0c7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，React团队开始尝试能够吸引更多受众的方法。总而言之，上下文是支持React之外的全局状态的唯一方法。</p><p id="c86c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种新方法被称为上下文选择器，类似于redux选择器，因为在2021年6月最后一次测试运行的React提案也应该适用于React的常规和并发版本。</p><p id="2da1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个提议中，每个消费者可以监控一个属性的变化。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="e9ec" class="lk ll in lb b gy lm ln l lo lp">const Child = () =&gt; {<br/>  const { a, b } = useContextSelector(AContext, v =&gt; v.a)<br/>  return &lt;div&gt;{a} - {b}&lt;/div&gt;<br/>}</span><span id="756b" class="lk ll in lb b gy ng ln l lo lp">const Child2 = () =&gt; {<br/>  const { a, b } = useContextSelector(AContext, v =&gt; v.b &lt; 3)<br/>  return &lt;Nothing2 a={b} /&gt;<br/>}</span></pre><p id="c402" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一个孩子中，它使用<code class="fe ky kz la lb b">useContextSelector</code>在属性<code class="fe ky kz la lb b">a</code>改变时应用渲染，同样，第二个孩子在表达式<code class="fe ky kz la lb b">b &lt; 3</code>改变时渲染。</p><p id="cd6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要设置上下文，我们可以将两个属性都放在那里。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="32d5" class="lk ll in lb b gy lm ln l lo lp">function useContextSelector(Context, selector) {<br/>  return useContext(Context, { unstable_selector: selector });<br/>}</span><span id="f0a1" class="lk ll in lb b gy ng ln l lo lp">const AContext = createContext({ a: 0, b: 0, dispatch: null })</span></pre><p id="3232" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">显然，这更容易使用，因为我们可以构造一个变量来动态监控。正如你在下面看到的，如果属性<code class="fe ky kz la lb b">a</code>没有改变，这个孩子就被保释出来了。</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/518200f211ee48e729966a39f825ac7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clHWpM4D0rLw6vW8klyUJQ.png"/></div></div></figure><h2 id="972e" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">摘要</h2><p id="ea00" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">我们已经讨论过了。希望我们能开始看到语境的力量。它是一个本地化的共享变量，可以以合理的成本覆盖一个区域的更新。</p><p id="93a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果未来朝着上述方向发展，而且很有可能是这样，那么上下文或多或少会是一个迷你redux。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="6247" class="lk ll in lb b gy lm ln l lo lp">const StoreContext = createContext({<br/>  user: object,<br/>  theme: object,<br/>  site: object, <br/>  loginUser: () =&gt; void, <br/>  changeTheme: () =&gt; void,<br/>})</span></pre><p id="adb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将把所有的全局骰子放在一个存储中，包括当前用户、主题和站点信息，以及登录和主题改变等操作。</p><p id="65bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，在任何组件中，我们可以只做</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="1b43" class="lk ll in lb b gy lm ln l lo lp">const userSelector = v =&gt; v.user</span><span id="002a" class="lk ll in lb b gy ng ln l lo lp">const AComponent = () =&gt; {<br/>  const { user, loginUser } = useContextSelector(<br/>    StoreContext, userSelector<br/>  )</span><span id="6159" class="lk ll in lb b gy ng ln l lo lp">  ...<br/>} </span></pre><p id="be83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与现在相比，我们的优势在于，在用户登录后，所有需要用户信息的组件都会被渲染，而不会造成任何其他损失。</p><p id="60dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ni">plain English . io</em></strong></a></p></div></div>    
</body>
</html>