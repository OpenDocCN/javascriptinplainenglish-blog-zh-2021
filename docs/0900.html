<html>
<head>
<title>10 Things Every Nest.js Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个Nest.js开发者都应该知道的10件事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-things-every-nest-js-developer-should-know-911dec32f66a?source=collection_archive---------1-----------------------#2021-02-25">https://javascript.plainenglish.io/10-things-every-nest-js-developer-should-know-911dec32f66a?source=collection_archive---------1-----------------------#2021-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e344" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何像坏蛋一样使用Nest.js</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aa189f1cee76b7b4c6d2fe57d9f703c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gq1yDGOeO2BzcOsz"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@cookiethepom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cookie the Pom</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7b06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我发现Nest.js的时候，我立马就搞定了。Nest.js是一个现代化的、类型脚本友好的框架，可以用来构建任何东西。</p><p id="1c41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在每天使用它一年后，它仍然是正确的。</p><p id="b597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，<strong class="ky ir">框架是新的</strong>。学的时候卡了很多。有时文档可以更好，有时我希望有更多的指导。</p><p id="a6c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我学到了很多，想在这篇文章中与你分享。因此，没有进一步的原因，这里是我的<strong class="ky ir">每个Nest.js开发者应该知道的10件事</strong>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="aef8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">1.API需要一个全局前缀</h1><p id="639e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为您的API设置一个全局前缀是一个很好的做法。我通常会给我的API端点加上前缀<code class="fe mw mx my mz b">/api/v1</code>。</p><p id="a338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么我们需要前缀？<a class="ae kv" href="https://www.quora.com/Why-do-developers-use-the-API-V1-prefix-while-developing-a-server-side-API" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">格拉森伯格</strong> </a>解释道:</p><blockquote class="na nb nc"><p id="8887" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">“好的API在设计时都考虑到了向后兼容性。在增强/添加API时，API管理人员应该确保已经连接到该API的应用程序不会受到影响。”</p></blockquote><p id="71bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，API前缀是为了<strong class="ky ir">向后兼容</strong>和<strong class="ky ir">清晰</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/ea711437cf7f8ec358fb8617e2faf17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYJGKj1MfAgx_W1Eb4WGhw.png"/></div></div></figure><h1 id="bdd4" class="lz ma iq bd mb mc ni me mf mg nj mi mj jw nk jx ml jz nl ka mn kc nm kd mp mq bi translated">2.模块化！</h1><p id="81b3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Nest.js采用模块化结构。你的应用程序应该被分成块，分成<strong class="ky ir">模块。</strong></p><p id="1e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常将你的应用程序按照功能划分成文件夹，按照主题而不是类型。</p><p id="2e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">这是一个按类型划分的项目:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2026a178edb28a879ee6041e7b47e798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*wEGYZu2ksGAnKMnxB4sTaQ.png"/></div></figure><p id="9a0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">这个是按主题拆分的:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/03600d38278e7f3c4f593cb49f32b8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*ZjHOC-nK_7eei07-iXEInw.png"/></div></figure><p id="5171" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Nest.js来说，模块是一个包含一个<code class="fe mw mx my mz b">@Module({})</code>装饰器的<code class="fe mw mx my mz b">.module.ts</code>文件的文件夹。但是也不尽然！不是每个文件夹都需要有一个<code class="fe mw mx my mz b">.module.ts</code>文件。例如，您可以创建一个文件夹"<strong class="ky ir"> utils" </strong>，在其中存储您的助手和JSON文件。</p><p id="8412" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将你的文件组织到主题文件夹中，你会变得清晰明了，并且避免很多错误。此外，如果您不遵守这个原则，Nest.js可能会在构建过程中崩溃。</p><h1 id="0134" class="lz ma iq bd mb mc ni me mf mg nj mi mj jw nk jx ml jz nl ka mn kc nm kd mp mq bi translated">3.使用dto</h1><p id="8522" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><strong class="ky ir"> DTO =数据传输对象</strong>。dto就像接口，但它们的全部目标是传输数据并验证数据。它们主要用于路由器/控制器。</p><p id="7d8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用它们，您可以简化API主体和查询验证逻辑。例如，下面的AuthDto自动将用户的电子邮件和密码映射到一个对象<code class="fe mw mx my mz b">dto</code>来执行验证</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/b6771d5efc20419b05629d3152e93f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg8Z7GuwWmL0iZ7HZzPHdw.png"/></div></div></figure><p id="e9e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望密码超过5个字符，您可以将d to与class-validator包配对来自动抛出错误。</p><p id="ed97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多技巧可以让我们的dto变得不可思议，但那是以后的事了。</p><h1 id="d1ed" class="lz ma iq bd mb mc ni me mf mg nj mi mj jw nk jx ml jz nl ka mn kc nm kd mp mq bi translated">4.始终使用数据映射器/存储库模式，而不是活动记录</h1><p id="9ecf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果您正在使用PostgreSQL或MySQL之类的关系数据库，那您就在天堂了。Nest.js附带了TypeOrm，这是Typescript最强大的Orm之一。</p><p id="b292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeOrm可以使用两种模式，一种是由ruby on rails推广的<strong class="ky ir">活动记录模式</strong>，另一种是使用存储库的<strong class="ky ir">数据映射模式</strong>。</p><blockquote class="na nb nc"><p id="81ac" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">使用活动记录方法，您可以在模型内部定义所有的查询方法，并使用模型方法保存、删除和加载对象。</p></blockquote><p id="e0ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是使用活动记录模式的情况:</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="9505" class="nu ma iq mz b gy nv nw l nx ny">const user = new UserEntity()<br/>user.name = "Vladimir"<br/>user.job = "programmer"<br/><em class="nd">await</em> user.save()</span></pre><blockquote class="na nb nc"><p id="8b64" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">使用数据映射器方法，您可以在称为“存储库”的单独类中定义所有查询方法，并使用存储库保存、删除和加载对象。</p></blockquote><p id="4b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是使用数据映射器模式的情况:</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="1077" class="nu ma iq mz b gy nv nw l nx ny">const user = this.userRepository.create()<br/>user.name = "Vladimir"<br/>user.job = "programmer"<br/><em class="nd">await</em> this.userRepository.save(user)</span></pre><p id="36ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然活动记录乍一看似乎更好，但它违背了Nest.js提供的模块化，因为活动记录与<strong class="ky ir">全局实体</strong>一起工作，而数据映射器需要在使用实体之前将它们注入每个模块。</p><p id="e039" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据映射器可能看起来有点冗长，但对于大中型项目来说，它是一个更好的解决方案。它对于测试来说也很棒，因为它与依赖注入一起工作！</p><h1 id="d822" class="lz ma iq bd mb mc ni me mf mg nj mi mj jw nk jx ml jz nl ka mn kc nm kd mp mq bi translated">6.使用相对路径，而不是绝对路径</h1><p id="783f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您可以使用绝对路径或相对路径来导入es6模块。Nest.js将在开发中工作，但当你试图构建它时，它将崩溃。当你使用Nest.js时，总是使用相对导入路径。你以后会感谢我的。(当您<code class="fe mw mx my mz b">npm run build</code>时，绝对路径会出现错误)</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="b97e" class="nu ma iq mz b gy nv nw l nx ny">// relative imports<br/><em class="nd">import</em> { SecurityService } <em class="nd">from</em> '../security/security.service';<br/><em class="nd">import</em> { CommentService } <em class="nd">from</em> '../comment/comment.service';</span><span id="8c5d" class="nu ma iq mz b gy nz nw l nx ny">// absolute imports<br/><em class="nd">import</em> { SecurityService } <em class="nd">from</em> 'src/security/security.service';<br/><em class="nd">import</em> { CommentService } <em class="nd">from</em> 'src/comment/comment.service';</span></pre><h1 id="5332" class="lz ma iq bd mb mc ni me mf mg nj mi mj jw nk jx ml jz nl ka mn kc nm kd mp mq bi translated">7.若要隐藏数据，请使用Exclude()</h1><p id="9070" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">通常通过转换器过滤从数据库中获得的数据。转换器的全部目标是删除或格式化来自数据库的数据。那会导致很多垃圾逻辑。</p><p id="5db7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免它<a class="ae kv" href="https://docs.nestjs.com/techniques/serialization#serialization" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">你可以使用</strong> </a> <code class="fe mw mx my mz b">@Exclude()</code>装饰器。</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="7433" class="nu ma iq mz b gy nv nw l nx ny">import { <strong class="mz ir">Exclude</strong> } from 'class-transformer';<br/><br/>export class UserEntity {<br/>  id: number;<br/>  firstName: string;<br/>  lastName: string;<br/><br/>  <strong class="mz ir">@Exclude()</strong><br/>  password: string;<br/><br/>  constructor(partial: Partial&lt;UserEntity&gt;) {<br/>    Object.assign(this, partial);<br/>  }<br/>}</span></pre><h1 id="4a75" class="lz ma iq bd mb mc ni me mf mg nj mi mj jw nk jx ml jz nl ka mn kc nm kd mp mq bi translated">8.使用实体getters</h1><p id="84b3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一些逻辑可以作为属性直接附加到您的实体<strong class="ky ir">上。最常见的用例与密码散列和获取全名有关。但是注意不要让你的实体负载过多的逻辑。为此使用<a class="ae kv" href="https://docs.nestjs.com/techniques/database#custom-repository" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">自定义库</strong> </a></strong></p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="ee0b" class="nu ma iq mz b gy nv nw l nx ny">import { Exclude } from 'class-transformer';<br/><br/>export class UserEntity {<br/>  id: number;<br/>  firstName: string;<br/>  lastName: string;<br/><br/>  <strong class="mz ir">get fullName</strong>() {<br/>    return this.firstName + " " + this.lastName;<br/>  }<br/>}</span></pre><h1 id="30f3" class="lz ma iq bd mb mc ni me mf mg nj mi mj jw nk jx ml jz nl ka mn kc nm kd mp mq bi translated">9.使用集中式命名导出</h1><p id="34eb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您可以从同一个文件夹中导入所有的<strong class="ky ir">，而不是从不同的文件中导入您的类。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/92deaf39156b5421f91177c0266ba8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKDXv6mOs5s06l4_FTuH-g.png"/></div></div></figure><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="a2b7" class="nu ma iq mz b gy nv nw l nx ny">// inside index.ts<br/><em class="nd">export</em> * <em class="nd">from</em> './createPost.dto';<br/><em class="nd">export</em> * <em class="nd">from</em> './editPost.dto';<br/><em class="nd">export</em> * <em class="nd">from</em> './editPostCategory.dto';<br/><em class="nd">export</em> * <em class="nd">from</em> './editPostStatus.dto';</span><span id="f572" class="nu ma iq mz b gy nz nw l nx ny"><strong class="mz ir">// and so to import those dtos you use</strong><br/>import { CreatePostDto, EditPostDto } from './dto'</span><span id="8699" class="nu ma iq mz b gy nz nw l nx ny"><strong class="mz ir">// instead of</strong><br/>import { CreatePostDto } from './dto/createPost.dto'<br/>import { EditPostDto } from './dto/editPost.dto'</span></pre><p id="d9c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更干净吧。</p><h1 id="8854" class="lz ma iq bd mb mc ni me mf mg nj mi mj jw nk jx ml jz nl ka mn kc nm kd mp mq bi translated">10.使用自定义装饰器来简化您的逻辑</h1><p id="e2a6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果使用decorators，您的逻辑可以大大简化。</p><p id="2518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，<strong class="ky ir"> GetUserIdFromJwt </strong>将把用户“sub”字段从请求对象中分离出来，这是我们之前用Jwt策略验证过的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/3bb3a92a4dfab4b04c0f58232e6aea6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s75Q2Mt1rH_KPj04McKiDQ.png"/></div></div></figure><p id="2730" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以你可以像这样在你的路线中直接使用这个逻辑</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/e88086a8c3e5538c63846d1b7b2b8487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzaBmNg7jQSqx7mIyxzEdA.png"/></div></div></figure><p id="ea81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以为<strong class="ky ir">的各种东西</strong>使用定制装饰器。装饰者的另一个非常方便的用例是分页。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0343" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">下一步是什么？</h1><p id="9d47" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我希望您喜欢这篇文章，并发现它很有用。当我继续记录我的创业和软件开发之路时，你可以在Twitter上关注我。</p><p id="4110" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击此处阅读类似文章:</p><div class="od oe gp gr of og"><a href="https://www.codewithvlad.com/blog/nestjs-caching-with-redis" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">NestJs缓存与Redis |代码与Vlad博客</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">恭喜你！您已经部署了一个越来越受欢迎的NestJs应用程序！很多用户都在使用你的应用程序…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.codewithvlad.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kp og"/></div></div></a></div><p id="6a96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">详见</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nd">plain English . io</em></strong></a></p></div></div>    
</body>
</html>