<html>
<head>
<title>Automated Testing in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的自动化测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/automated-testing-in-node-js-2aa306d091?source=collection_archive---------16-----------------------#2021-05-15">https://javascript.plainenglish.io/automated-testing-in-node-js-2aa306d091?source=collection_archive---------16-----------------------#2021-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5137dd773188d434ea846ffb6e133dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yowTcpRtP_ic6q3Eh87koA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Node.js libraries Jest and Puppeteer</figcaption></figure><p id="1c1c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">软件开发生命周期的一个非常重要的方面是保证软件的质量。一个人可能会用最优化的算法，全神贯注地写出最好的代码，但他仍然不能对任何软件中的错误免疫。</p><p id="9713" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有两种广泛的测试方法。</p><p id="dc8c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第一种方法可以是为所有测试用例手动测试产品中的特性。</p><p id="ed3a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一种方法是编写自动化测试用例。</p><p id="500d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">后一种方法的好处是，当一个人改变代码中的某些东西时，他可以立即运行测试用例，如果新代码破坏了某些东西，就会得到错误，并且他不需要再次手动检查所有的测试用例。它节省时间。</p><p id="486d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">编写自动化测试案例也有助于我们思考可能的问题和边缘案例。因此，用代码编写测试用例被认为是一个好的实践。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="594c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Node.js中的自动化测试可以分为三种类型:</p><ul class=""><li id="38fb" class="le lf in kb b kc kd kg kh kk lg ko lh ks li kw lj lk ll lm bi translated"><strong class="kb io">单元测试</strong>:测试一个隔离的功能。</li><li id="72c5" class="le lf in kb b kc ln kg lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kb io">集成测试</strong>:测试一个调用另一个函数的函数。</li><li id="0756" class="le lf in kb b kc ln kg lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kb io">端到端测试</strong>:以自动化的方式测试可以从浏览器或应用程序的用户界面手动完成的工作。</li></ul><p id="3510" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">单元测试是最容易编写的，而且编写得相当广泛。端到端测试很复杂，因此很少编写。综合测试在复杂性和写作频率方面居中。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="989d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">测试设置可分为三个级别:</p><ul class=""><li id="549d" class="le lf in kb b kc kd kg kh kk lg ko lh ks li kw lj lk ll lm bi translated">测试运行程序:执行您的测试并总结您的结果。例如摩卡</li><li id="b8e2" class="le lf in kb b kc ln kg lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kb io">断言库:</strong>定义测试逻辑，条件。如柴</li><li id="2853" class="le lf in kb b kc ln kg lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kb io">无头浏览器:</strong>模拟浏览器交互。例如木偶师</li></ul><p id="557b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，有一个npm包执行<strong class="kb io">测试运行器</strong>以及<strong class="kb io">断言库</strong>的角色。那个npm包是<strong class="kb io"> jest </strong>。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c1cb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用package.json中的上述代码片段将jest包含为测试库，并使用<strong class="kb io">NPM I jest-save-dev</strong>将jest添加到开发依赖项列表中</p><p id="c789" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，我们可以创建一个以* <strong class="kb io"> .test.js </strong>结尾的文件，在这个文件中，我们可以定义要对每个想要测试的函数的输出执行的所有测试。让我们分析一下*.test.js文件中的代码片段。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="ly lx l"/></div></figure><p id="0091" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">假设<strong class="kb io"> getIntroduction </strong>是一个函数，它返回一个描述特定人年龄的字符串。它有两个参数，第一个是定义人名的字符串，第二个是定义年龄的数字。</p><p id="7d29" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">测试</strong>由相同的名称定义。第一个参数是字符串形式的测试用例的名称。第二个参数是一个匿名函数，包含对getIntroduction函数结果的断言。<strong class="kb io"> expect </strong>是定义断言的关键字。</p><p id="f830" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果该功能的输出符合预期，<strong class="kb io"> npm运行测试</strong>将显示通过，如果该功能的输出不符合预期，<strong class="kb io"> npm运行测试</strong>将显示失败。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="aed3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">端到端测试:</strong>为了执行端到端UI测试，我们将使用名为<strong class="kb io">木偶师</strong>的npm包。安装它非常简单，只需执行<br/>NPM I-保存木偶师</p><p id="80b4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">木偶师将帮助我们模拟浏览器，允许我们指定浏览器屏幕的尺寸，允许我们调整在浏览器上执行的动作的速度，允许我们指定是以无头方式还是以完全成熟的方式启动浏览器。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lz lx l"/></div></figure><p id="8f2e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，我们用puppeteer.launch方法初始化浏览器。它会启动chromium浏览器。你可以在chrome浏览器的地址栏下方看到这条消息。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/9056d54610a077d7ac60d375b825b9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jcCD3Uk3b3id77CZDGyfA.png"/></div></div></figure><p id="4b8d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在launch方法中，我们有一个名为<strong class="kb io"> headless </strong>的键，它指定我们是否希望在不打开浏览器窗口的情况下以headless ie的形式启动浏览器。<strong class="kb io"> slowMo </strong>指定测试的执行速度。较高的数字意味着操作速度，如点击，打字等将会变慢。在<strong class="kb io">参数中，</strong>用户可以指定将要进行测试的浏览器的窗口大小。</p><p id="a270" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦浏览器启动，使用<strong class="kb io"> browser.newPage() </strong>打开一个新页面或标签。然后，要指定应该在这个选项卡或页面上打开的url，可以调用页面的<strong class="kb io"> goto(url) </strong>方法。每个函数调用都以<strong class="kb io"> await </strong>关键字开始，表示每个浏览器操作本身就是一个异步操作。</p><p id="4ac8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来是我们指定在E2E测试中将被自动化的动作的部分。可以模拟一个点击动作<strong class="kb io">page . click(' valid html element selector ')</strong>或者模拟通过<strong class="kb io">page . type(' valid html element selector '，text) </strong>其中text包含我们要填充到文本框中的字符串、input元素或者任何与我们的<strong class="kb io"> html选择器</strong>匹配的可写html元素。</p><p id="411e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，wait page . type(' input . input-text '，' Hello World！')<em class="mb"> </em>会用类<strong class="kb io">‘input-text’</strong>找到html <strong class="kb io"> &lt; input &gt; </strong>元素，并在那里模拟输入字符串‘Hello World’。类似地，await page.click('#search-btn ')将模拟点击id为search-btn的html元素。</p><p id="1c2f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在到了验证我们的自动化操作的输出的部分。要验证它们，可以使用第页的<strong class="kb io"> $eval </strong>方法。举个例子，</p><p id="0a39" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">const finalText = await page。$eval('。输入-文本'，el =&gt; el.textContent)</p><p id="774b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">finalText变量将使用类“input-text”在html元素中存储文本值。从div中取出文本内容。有时，_value键用于从html元素中提取文本内容。</p><p id="bd24" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下一个任务很简单，将这个值传递给jest断言，即<br/> expect(finalText)。“你好，世界！”).因此，我们的行动得到了验证</p><p id="2f04" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一次成功的测试运行应该是这样的</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/aa0e6008252a156c4ec96dcf09ee82fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rCIx2NJSaQNJZnFW5hArg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Command line output for a successful run of test cases</figcaption></figure></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="5dd3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">不能低估自动化测试在软件开发生命周期中的作用。人们不应该认为编写测试用例是一项琐碎而平凡的工作，它会延迟产品开发。然而，大多数有经验的开发人员认为，编写包括单元测试和E2E测试在内的测试用例不仅可以减少代码中可能出现的错误，还可以减少修复的迭代次数，并随着时间的推移节省开发人员的时间和精力。</p><p id="2863" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">总而言之，有三样东西可以让软件没有错误:测试，更多的测试，甚至更多的测试！</p><p id="c81c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="mb">更多内容尽在</em><a class="ae md" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="mb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>