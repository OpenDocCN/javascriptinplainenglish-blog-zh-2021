<html>
<head>
<title>How to perform Server-Push in HTTP/2 with Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Express在HTTP/2中执行服务器推送</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/server-push-in-http-2-with-express-js-96454ab9fb8c?source=collection_archive---------6-----------------------#2021-04-10">https://javascript.plainenglish.io/server-push-in-http-2-with-express-js-96454ab9fb8c?source=collection_archive---------6-----------------------#2021-04-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dac5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然在Express中使用http2是可能的，默认情况下服务器推送也是可能的。但是使用服务器推送来获得最佳性能需要更多的努力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b3bd22bb11fca2ac278bc89bdc624254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0KmDqDEIxWBT5Ev-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@jordanharrison?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jordan Harrison</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4206" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我上一篇文章的延续，解释了如何使用<strong class="jm io"> http2-express-bridge </strong>来支持HTTP/2和Express js的使用。可以在这里阅读之前的文章<a class="ae ky" href="https://rahulramesha.medium.com/serving-hello-world-with-http2-and-express-js-4dd0ffe76860" rel="noopener">。</a></p><p id="2280" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们想象在HTTP/1.1中提供一个包含CSS和Javascript链接的HTML页面。</p><ul class=""><li id="c290" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">浏览器/客户端向服务器请求路径。</li><li id="869b" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">服务器用一个HTML文件响应，然后关闭连接。</li><li id="5349" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">浏览器读取文件并意识到它需要CSS和Javascript文件，然后分别请求这些路径。</li><li id="f9ee" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">因此，需要建立多个连接来获取加载页面所需的所有文件。</li></ul><p id="c828" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道你在想什么——这听起来效率很低，事实也确实如此。有了HTTP/2的多路复用，即使避免了多个连接，客户机仍然必须通过HTML文件才能意识到它需要来自服务器的其他文件。</p><p id="5668" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<strong class="jm io">服务器推送</strong>，服务器可以决定推送必要的文件以及请求的文件。在一个连接中发送所有内容。使用<strong class="jm io"> http2-express-bridge </strong>，将<code class="fe ln lo lp lq b">push()</code>方法添加到响应对象中。可以按如下方式使用:</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="16c8" class="lv lw in lq b gy lx ly l lz ma">app.get('/bar', (req, res) =&gt; {</span><span id="0370" class="lv lw in lq b gy mb ly l lz ma">    res.push(['/bar.js', '/foo.js'], staticPath)<br/>    res.send(`<br/>        &lt;!DOCTYPE html&gt;<br/>        &lt;html lang="en"&gt;<br/>            &lt;head&gt;<br/>                &lt;meta charset="UTF-8"&gt;<br/>                &lt;title&gt;Bar Document&lt;/title&gt;<br/>            &lt;/head&gt;<br/>            &lt;body&gt;<br/>                This is a bar document.<br/>                &lt;script src="/foo.js"&gt;&lt;/script&gt;<br/>                &lt;script src="/bar.js"&gt;&lt;/script&gt;<br/>            &lt;/body&gt;<br/>        &lt;/html&gt;`);</span><span id="eae4" class="lv lw in lq b gy mb ly l lz ma">})</span></pre><p id="4846" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">push()</code>方法接受两个参数。</p><ul class=""><li id="3611" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">第一个参数是单个路径或路径数组。这些路径应该与HTML中的路径完全相同。</li><li id="4631" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第二个参数是提供文件的静态路径。</li></ul><p id="b264" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">push()</code>方法被设计成即使它导致错误，它也只是记录错误并发送响应。</p><p id="0b7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅此而已，它应该能提高你的表现。但也不尽然！</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h2 id="a739" class="lv lw in bd mj mk ml dn mm mn mo dp mp jv mq mr ms jz mt mu mv kd mw mx my mz bi translated"><strong class="ak">呃？为什么不呢？</strong></h2><p id="e6df" class="pw-post-body-paragraph jk jl in jm b jn na jp jq jr nb jt ju jv nc jx jy jz nd kb kc kd ne kf kg kh ig bi translated">这样做的问题是，每次请求路径时，服务器都会推送文件，即使浏览器已经缓存了它们。</p><p id="85aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这只是问题之一。为了优化服务器推送的性能，必须遵循一些原则。详情请参见<a class="ae ky" href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">HTTP/2推送的经验法则</a>。</p><p id="9cbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我同意在您的服务器上实现这些指导方针似乎是一项艰巨的工作。但值得庆幸的是，谷歌的一名工程师已经创建了一个通用的解决方案包<a class="ae ky" href="https://www.npmjs.com/package/h2-auto-push" rel="noopener ugc nofollow" target="_blank">H2-自动推送</a>。你可以在这里阅读它是如何工作的以及它的性能结果<a class="ae ky" href="https://medium.com/the-node-js-collection/node-js-can-http-2-push-b491894e1bb1" rel="noopener">(由软件包的创建者编写；强烈推荐去看看)。</a></p><p id="467a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个包不能开箱即用，它必须适应正在使用的框架。<a class="ae ky" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> Fastify </a>已经在<a class="ae ky" href="https://www.npmjs.com/package/fastify-auto-push" rel="noopener ugc nofollow" target="_blank">Fastify-自动推送</a>中进行了改编。我决定把它改编成Express，在<a class="ae ky" href="https://www.npmjs.com/package/http2-express-autopush" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">http 2-Express-autopush</strong></a>。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="138c" class="lv lw in lq b gy lx ly l lz ma">npm install http2-express-autopush</span></pre><p id="7333" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个包是一个express中间件，在它的基本版本中可以完全像<em class="nf"> express.static </em>中间件一样使用。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="5cc2" class="lv lw in lq b gy lx ly l lz ma">const autopush = require('http2-express-autopush')</span><span id="f782" class="lv lw in lq b gy mb ly l lz ma">...</span><span id="aba3" class="lv lw in lq b gy mb ly l lz ma">app.use(autopush(staticPath))</span></pre><p id="2e17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，中间件的基本功能就是从路径中提供静态文件。除此之外，它还观察请求的路径，并记录从同一客户端请求的文件。因此，下次它从不同的客户端收到请求时，它会推送记录的路径，并发送一个cookie。此cookie包含已推送文件的信息。因此，它不会在同一个会话中将它们推送到客户端。</p><p id="25ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这个中间件，您不需要特别地按需推送，让中间件决定何时按需推送文件。</p><p id="688c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中间件有可选的第二个和第三个参数。</p><ul class=""><li id="1813" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">第二个参数与<em class="nf"> express.static </em>中间件中的第二个参数相同。</li><li id="9624" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第三个参数是一个对象，其值可用于微调要推送的路径。</li></ul><p id="8e99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下第三个参数是:</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="dd2a" class="lv lw in lq b gy lx ly l lz ma">{  <br/>    warmupDuration: 500,<br/>    promotionRatio: 0.8,<br/>    demotionRatio: 0.2,<br/>    minimumRequests: 1 <br/>}</span></pre><p id="eb2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里阅读关于这些参数<a class="ae ky" href="https://www.npmjs.com/package/h2-auto-push#assetcacheconfig" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><p id="2a24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这已经使您具备了使用<strong class="jm io">服务器推送</strong>和Express来获得最佳性能的知识。</p><p id="0715" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nf">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nf">plain English . io</em></a></p></div></div>    
</body>
</html>