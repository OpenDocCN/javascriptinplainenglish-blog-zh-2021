<html>
<head>
<title>Awesome Next.js API Routes with next-api-decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用next-API-decorator的Awesome Next.js API路由</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/awesome-next-js-api-routes-with-next-api-decorators-d6117f963bee?source=collection_archive---------4-----------------------#2021-11-10">https://javascript.plainenglish.io/awesome-next-js-api-routes-with-next-api-decorators-d6117f963bee?source=collection_archive---------4-----------------------#2021-11-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a692ff5daa5d1096110fcbfe8e59d130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f9UejiBr8bajU3SI"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@foxxmd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Duncan</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4228" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">构建一个现代的web应用程序可能是一项复杂的任务——如果你想构建某个东西，你可能会开始考虑架构，以及如何分离你的关注点，并且有许多方法可以实现。传统上来说，这意味着有一个独立的前端和后端，有独立的代码库，可能使用不同的语言、框架或技术来完成工作。</p><p id="5007" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将使用前端开发领域的优秀工具Next.js来研究一个替代方案。我们将研究一个整体架构如何变得方便和强大，而不一定会受到通常与这种方法相关联的紧耦合的影响。但是首先，快速入门一下Next.js是如何工作的。</p><h1 id="c0b8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Next如何工作</h1><p id="fb2a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果你是这项技术的新手，Next.js是一个<a class="ae jz" href="https://jamstack.org/" rel="noopener ugc nofollow" target="_blank"> Jamstack </a>框架，旨在解决一些与构建传统单页面应用程序(spa)相关的问题。它不仅支持服务器端渲染，还支持静态站点生成，允许开发者用一些静态页面构建应用(想想marketing / about pages！)和一些加载速度超快的、SEO友好的动态页面。根据您的用例，您通常可以使用Next.js来满足您的需求，很少有警告。</p><p id="aa2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，这是可行的，因为当你“运行”一个Next.js应用程序时，你实际上是在运行一个Node.js服务器(尽管如果你正在构建一个完全静态的站点，你可以导出所有的静态文件并在任何地方托管它们，但我们在这里不会讨论这种方法)。因此，你的应用程序是“活的”，这与Create React应用程序形成对比，在Create React应用程序中，JS包托管在某个地方并下载到客户端，整个应用程序仅在客户端呈现。</p><p id="faeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那又怎样？</p><p id="6486" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，有可能定义一些只在服务器上运行的代码，而客户端永远看不到。考虑到我们只有服务器端的代码，我们可能开始做一些以前不能(更像是<em class="mb">不应该</em>)在客户端做的事情，例如，直接与数据库对话，执行需要几次单独调用的操作，等等。这听起来是不是越来越像HTTP API了？</p><p id="7480" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Next.js在其架构中以一等公民的身份支持这一理念。路由是自以为是的，并使用文件系统来确定应用程序中的页面路由，使用名为<code class="fe mc md me mf b">pages</code>的目录中的文件和文件夹来建立这一点——例如，如果你在<code class="fe mc md me mf b">pages/todos</code>中创建了一个名为<code class="fe mc md me mf b">mine.tsx</code>的文件，你将能够在<code class="fe mc md me mf b">&lt;your-domain&gt;/todos/mine</code>时在浏览器中找到该页面。路径<code class="fe mc md me mf b">pages/api</code>下的任何东西都只会在服务器上运行。我们做到了！我们称之为<a class="ae jz" href="https://nextjs.org/docs/api-routes/introduction" rel="noopener ugc nofollow" target="_blank">的下一个API路由</a>。这意味着我们可以用一个代码库构建一个全栈的应用，一个“单片”架构。马上，我们免费得到了几个好东西:</p><ul class=""><li id="e6bb" class="mg mh in kc b kd ke kh ki kl mi kp mj kt mk kx ml mm mn mo bi translated">整个应用的单一构建流程和易于运行的开发环境(只需运行<code class="fe mc md me mf b">next dev</code>)</li><li id="9841" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">更简单的部署(在任何节点兼容的环境中，<code class="fe mc md me mf b">next build</code>然后是<code class="fe mc md me mf b">next start</code>)</li><li id="88e8" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">默认情况下，没有CORS担心，前端和后端是相同的起源！</li><li id="6f90" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">默认情况下类似Monorepo的共享(同样考虑<code class="fe mc md me mf b">tsconfig</code>、<code class="fe mc md me mf b">jest</code>、<code class="fe mc md me mf b">eslint</code>)，无需使用类似<code class="fe mc md me mf b">lerna</code>的monorepo管理器</li></ul><p id="3cf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更有经验的开发人员可能会认为这样的方法是一种倒退，但它更像是朝着更好地整合代码和资源迈出的一步，这是有争议的。逻辑关注点可以被分离，而无需物理分离本身，整体架构开始对Web应用程序更有意义，最显著的是增量静态再生和服务器端呈现的兴起。</p><h2 id="a448" class="mu kz in bd la mv mw dn le mx my dp li kl mz na lm kp nb nc lq kt nd ne lu nf bi translated">API路线</h2><p id="decc" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如文档中所列，用Next构建API路由看起来很像用Node.js构建基本API:</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Taken from the Next.js docs (linked above!)</figcaption></figure><p id="def0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单明了。您可以使用这种方法非常快速简单地构建一些服务器端功能！</p><p id="2dd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，如果我们想开始构建一个REST API，在同一个端点上区分不同的HTTP方法，根据资源对我们的API建模，会怎么样呢？如果我们想开始将行为组合到我们的API端点中会怎么样？</p><p id="8f44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的例子很快扩展成这样:</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Not super nice…</figcaption></figure><p id="90d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可能是最好的情况，因为我们已经能够将所有实际的业务逻辑分解到函数<code class="fe mc md me mf b">doSomething</code>、<code class="fe mc md me mf b">checkAuth</code>、<code class="fe mc md me mf b">doSomethingElse</code>和<code class="fe mc md me mf b">doAThirdThing</code>中。一旦我们开始接收请求体，情况可能会变得更糟。并不可怕，但是我们可以使它更容易阅读，更容易维护。</p><h2 id="70f5" class="mu kz in bd la mv mw dn le mx my dp li kl mz na lm kp nb nc lq kt nd ne lu nf bi translated">NestJS</h2><p id="e3c3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">通常，开发人员在构建API时会选择框架，因为它们提供了表示资源的替代方法，以及许多旨在简化这一过程的工具和实用程序。一个这样的例子是<a class="ae jz" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>(不要与Next.js混淆！).这是一个内置电池的强大“构建高效、可伸缩的服务器端应用程序的框架”。深受<a class="ae jz" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>的启发，这个框架允许开发者使用抽象来表示API路线，包括可重用的服务、控制器、模块等等。</p><p id="76d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是从其文档中复制的一个简单示例:</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4631" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所看到的，这种方法使用OOP思想和decorators来实现前面描述的目标。我们只指定我们打算作为类上的方法使用的HTTP方法，而不是函数中的控制流路径。声明性更强一点，如果我们希望构建REST API，这是一个很好的基础。</p><p id="77b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么接下来我们如何利用这种方法。JS API路由？</p><h2 id="1aff" class="mu kz in bd la mv mw dn le mx my dp li kl mz na lm kp nb nc lq kt nd ne lu nf bi translated">下一个api装饰者</h2><p id="1752" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">这个库是由阿姆斯特丹的电子商务技术机构AMS 的<a class="ae jz" href="https://storyofams.com/" rel="noopener ugc nofollow" target="_blank"> Story的优秀人员编写的，他们决定使用这些概念开发一个解决方案，使构建API更容易与Next.js一起扩展。</a></p><p id="4ec9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们重温一下我们之前使用他们的库重写的复杂示例，以演示它是如何工作的:</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1061" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所看到的，我们改变了表达资源处理器的方式，用一个类替换了一个函数。最重要的是，该类的方法用decorators进行了注释，以表达它们的目的。</p><p id="ca37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，由你决定你更喜欢哪一个，因为这种方法并不会使它更简洁。但是，如前所述，它确实将我们描述资源的方式从命令式转变为声明式。我在构建Next.js APIs时发现，这种方法更容易维护，因为随着应用程序的增长，最终每条路线和每个处理程序<strong class="kc io">会</strong>和<strong class="kc io">会</strong>变得更加复杂。</p><h2 id="6dc0" class="mu kz in bd la mv mw dn le mx my dp li kl mz na lm kp nb nc lq kt nd ne lu nf bi translated">定制装饰</h2><p id="7143" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">这个例子中我想看的最后一件事是我们现在在这个处理程序中的一些方法上看到的<code class="fe mc md me mf b">requiresAuth</code>装饰器。我最近为一个项目写了类似这个自定义处理程序的东西，它被证明非常有用。这是通过使用由<code class="fe mc md me mf b">next-api-decorators</code>提供的<code class="fe mc md me mf b">createMiddlewareDecorator</code>工具完成的:</p><figure class="ng nh ni nj gt jo"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Instant, composable protection for any route + method combo!</figcaption></figure><p id="e909" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很强的东西💪</p><p id="a55b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法非常灵活，可以应用于这两个类及其方法，以适应各种用例并理清您的实际业务逻辑。</p><h1 id="2d07" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">包扎</h1><p id="b132" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我在这里展示的例子非常简单，只是让您了解使用Next.js及其API routes构建全栈应用程序的实用方法，以及如何使用<code class="fe mc md me mf b">next-api-decorators</code>使其成为可伸缩的服务器端应用程序。</p><p id="5881" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有兴趣了解更多，请查看这个惊人的库的<a class="ae jz" href="https://next-api-decorators.vercel.app/" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae jz" href="https://github.com/storyofams/next-api-decorators" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><p id="615b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！</p><p id="9a28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">💙</p><p id="dd02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mb">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>