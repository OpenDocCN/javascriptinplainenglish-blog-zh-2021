<html>
<head>
<title>Demystifying JavaScript Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开JavaScript范围的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-javascript-scope-abdbe68914fd?source=collection_archive---------4-----------------------#2021-09-12">https://javascript.plainenglish.io/demystifying-javascript-scope-abdbe68914fd?source=collection_archive---------4-----------------------#2021-09-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fe56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作用域是名称绑定的属性，它告诉我们哪些名称绑定在程序的特定部分或给定时间点是可访问的。名称绑定是指与实体相关联的名称。实体可以是变量、函数等。定义这些范围的规则称为范围规则。</p><p id="a860" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，有两种类型的作用域——词法作用域和动态作用域。词法范围根据名称绑定的定义位置(词法上下文)及其在源代码中的位置来解析名称绑定。动态范围根据程序状态解析名称绑定，程序状态由执行上下文(运行时上下文)决定。</p><p id="1dd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript是一种词汇范围的语言。所有与变量、函数等相关联的名字都是基于它们被定义的位置以及它们在源代码中的位置来解析的。</p><p id="ba3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常在词法范围内，子函数在本地词法上下文中搜索名字，如果失败，它就转移到外部函数并搜索其本地词法上下文。</p><p id="bb6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种情况一直持续到最外层的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97dbeb9839776175af413c167e7528a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utpTdIvo4yxGWmmVeyL-cA.jpeg"/></div></div></figure><p id="698a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上图是词法作用域的清晰表示，其中<strong class="jm io">函数C </strong>可以访问<strong class="jm io">函数C、函数B、函数A和全局函数</strong>中存在的所有变量；<strong class="jm io">函数B </strong>可以访问<strong class="jm io">函数B、函数A和全局函数</strong>中存在的所有变量；<strong class="jm io">函数A </strong>可以访问<strong class="jm io">函数A和全局函数</strong>中的所有变量，而<strong class="jm io">全局函数</strong>只能访问<strong class="jm io">全局函数</strong>中的变量。</p><p id="88d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望现在您对JavaScript中的词法范围有了一个清晰的了解。让我们在一个真实的代码片段中应用这些知识，并尝试更深入地理解它。</p><h1 id="fd44" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">案例1</h1><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="e1a0" class="lx kv in lt b gy ly lz l ma mb"><br/>var myCar = {<br/> model: “Nissan”,<br/> type: “XUV”,<br/> color: “black”,<br/> price: 1500000<br/>}<br/>function calLoanPercentage(number) {<br/> return myCar.price * number/100;<br/>}<br/>console.log(calLoadPercentage(25));<br/></span></pre><p id="b20a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当JavaScript引擎解析上面的代码片段时，它为代码中出现的所有名称绑定准备了一个范围计划。在这种情况下，从<strong class="jm io"> myCar </strong>开始。它检查这是否存在。如果它不存在，它为这个名称绑定(<strong class="jm io"> myCar </strong>)创建一个作用域(<strong class="jm io">全局作用域，因为它是最外层的函数</strong>)并继续前进。</p><p id="f70c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，它遇到了一个新的名称绑定，就是函数，<strong class="jm io">calloan percentage(number)</strong>。这个名称绑定也将与<strong class="jm io"> myCar </strong>具有相同的范围，因为它们都在同一级别。在函数的情况下，还将创建一个称为局部作用域的附加作用域，其中函数中存在的所有参数和其他变量都属于该作用域。</p><p id="21e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些名称绑定不能从外部函数调用。<br/>在执行阶段，JavaScript引擎开始逐行执行代码。首先，它将检查是否有一个名为<strong class="jm io"> myCar </strong>的名称绑定，如果存在，它将赋值。然后它直接转到控制台语句。</p><p id="2706" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在控制台语句中，我们调用参数值为25的函数<strong class="jm io"> calLoanPercentage(25) </strong>。一旦JavaScript执行了这个，它就在内存中检查名称绑定<strong class="jm io"> calLoanPercentage() </strong>，如果存在，它就获取函数定义并开始执行。</p><p id="d9dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，它将定义它的参数，并为它分配参数值25。之后会返回<strong class="jm io"> myCar.price * number/100 </strong>。在执行该语句时，它将首先尝试在本地内存中查找<strong class="jm io"> myCar </strong>。当它没有找到时，它将移动到外部函数并在内存中搜索。</p><p id="4cb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当它找到时，它将获取该值并检查属性<strong class="jm io">价格</strong>，这是存在的，因此返回值1500000。类似地，它在本地存储器中搜索变量<strong class="jm io">编号</strong>。</p><p id="73a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当它找到时，它将获取值并对表达式求值。评估后的值作为参数传递给<strong class="jm io"> console.log() </strong>方法，该方法将该值打印到控制台。</p><h1 id="49e2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">案例2</h1><pre class="kj kk kl km gt ls lt lu lv aw lw bi"><span id="5313" class="lx kv in lt b gy ly lz l ma mb"><br/>var functionExpression = function printOne() {<br/> var text = “hello”;<br/> console.log(text);<br/>}<br/>functionExpression() // prints “hello”<br/>printOne() // ReferenceError: printOne is not defined<br/></span></pre><p id="e9bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们使用了命名函数表达式。在这种情况下，名称<strong class="jm io"> printOne </strong>将在函数的局部范围内，而不在全局范围内。</p><p id="7ec2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么当我们试图通过函数名<strong class="jm io"> printOne </strong>调用函数时会出现引用错误的原因。</p><p id="d9ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么在<strong class="jm io"> const </strong>和<strong class="jm io"> let </strong>声明的情况下，作用域是如何工作的呢？好吧，我很快会在我的下一篇博客《坚持住》中对此进行详细报道。在此之前，如果你觉得这篇文章有用，请表达你的爱，并在社交媒体上分享这篇文章。请随时通过Twitter、LinkedIn或电子邮件与我联系。</p><p id="6e5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mc">更多内容请看</em><a class="ae md" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>