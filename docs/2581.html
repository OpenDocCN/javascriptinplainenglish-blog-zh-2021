<html>
<head>
<title>Using Redux and Firestore in Your React Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Web应用程序中使用Redux和Firestore</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-redux-and-firestore-in-your-react-web-app-eb38a9b316f8?source=collection_archive---------11-----------------------#2021-05-27">https://javascript.plainenglish.io/using-redux-and-firestore-in-your-react-web-app-eb38a9b316f8?source=collection_archive---------11-----------------------#2021-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/676909466444ba3803780c54f02a9c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlxxmP6ESTWYGzHFg7wDDQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Redux is a state management framework and Firestore is a NoSQL database provided by Google</figcaption></figure><h1 id="7fc6" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Redux</h1><h2 id="a3e1" class="kx ka in bd kb ky kz dn kf la lb dp kj lc ld le kn lf lg lh kr li lj lk kv ll bi translated">介绍</h2><p id="d0b2" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">Redux是JavaScript的一个状态管理工具，它使得在应用程序中维护状态变得更加简单。</p><p id="cd19" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">它在React应用程序中特别有用，因为它可以让您避免通过许多不同的子组件向下传递道具的行为，直到它到达需要数据的深层嵌套组件。</p><p id="73bc" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">相反，应用程序的所有状态信息都存储在一个叫做<em class="mm">的存储中。</em> <a class="ae mn" href="https://redux.js.org/faq/store-setup" rel="noopener ugc nofollow" target="_blank">以下是关于如何在React应用中设置商店的指南</a></p><p id="9a86" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">使用Redux，一旦创建了一个商店，任何设置为使用Redux功能的组件都可以直接从商店中访问信息。再也不用担心传道具或者用回调更新家长了。Redux的MapStateToProps和MapDispatchToProps函数(结合一个称为reducer的东西)将为您处理所有这些。</p><h2 id="cf98" class="kx ka in bd kb ky kz dn kf la lb dp kj lc ld le kn lf lg lh kr li lj lk kv ll bi translated">mapStateToProps</h2><p id="990d" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">mapStateToProps函数确实如其名所示。它会将商店中您希望您的组件可以访问的任何商品映射到您的组件道具。这听起来可能令人困惑，但当你看到一个例子时，这并不太糟糕。</p><p id="38c4" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">假设我们有一个叫做食品杂货的组件。我们想让我们的杂货组件访问应用程序状态中存储的所有杂货的当前列表。这些存在于名为state.groceryList的属性中。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1734" class="kx ka in mt b gy mx my l mz na">// Groceries.js</span><span id="96af" class="kx ka in mt b gy nb my l mz na">function mapStateToProps(state) {</span><span id="9442" class="kx ka in mt b gy nb my l mz na">  const { groceryList } = state</span><span id="0e5b" class="kx ka in mt b gy nb my l mz na">  return { <br/>    fruits: groceryList.fruits<br/>    veggies: groceryList.veggies<br/>    dairy: groceryList.dairy<br/>  }</span><span id="45d6" class="kx ka in mt b gy nb my l mz na">}</span><span id="9f6f" class="kx ka in mt b gy nb my l mz na">export default connect(mapStateToProps)(Groceries)</span></pre><p id="925d" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">mapStateToProps函数被逐行传递一个表示整个Redux存储的参数“state”。</p><p id="7290" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">然后，使用prop析构将属性groceryList从状态中取出，并将其赋给一个也称为groceryList的变量。</p><p id="7122" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">从那里，mapStateToProps的返回值表示将被添加到组件属性对象中的属性。因此，在上面的例子中，食品杂货将有props.fruits、props.veggies和props.dairy，所有这些都被添加到由其父代传递到食品杂货中的任何其他属性中。</p><p id="9263" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">最后一行是什么赋予了食品杂货自我支撑的能力。connect函数接受1或2个函数(在本例中，mapDispatchToProps的第2个参数为空),然后将每个函数的返回值赋给杂货的Props对象。理论上，您可以随意调用这个函数，connect仍然会将它的第一个参数的返回值赋给props，但是约定是将其称为mapStateToProps。</p><h2 id="8759" class="kx ka in bd kb ky kz dn kf la lb dp kj lc ld le kn lf lg lh kr li lj lk kv ll bi translated">mapDispatchToProps</h2><p id="60f0" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">mapDispatchToProps函数做的事情与mapStateToProps非常相似，但它不是让您访问应用程序的状态，而是让您的组件函数称为actions，用于更新Redux的状态。</p><p id="ebca" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">它们通过将一个动作分派给一个称为reducer的文件来实现这一点。我将在下一节解释这个缩减器，所以现在，让我们把重点放在mapDispatchToProps函数上。</p><p id="df75" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">假设我们使用redux在应用程序的状态中存储一个用户名。第一次加载应用程序时，它可能还不知道你的名字，或者可能有一些其他功能需要你更改用户名。为了设置/更新这个name属性，我们需要使用一个Redux动作来更新商店。这就是mapDispatchToProps的用武之地。</p><p id="0e49" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">我们将从实际执行名称更新的代码开始。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3fcf" class="kx ka in mt b gy mx my l mz na">const setName = (name) =&gt; ({<br/>  type: 'SET_NAME',<br/>  name,<br/>})</span></pre><p id="f384" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">所以你要做的是传递给setName一个字符串，它表示名字应该是什么。然后，在组件的底部，您希望创建mapDispatchToProps函数，如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b8b5" class="kx ka in mt b gy mx my l mz na">const mapDispatchToProps = (dispatch) =&gt; ({<br/>  setName: (name) =&gt; dispatch(setName(name)),<br/>})</span></pre><p id="4057" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">上面的函数接受dispatch函数作为参数。然后这个函数返回一个带有setName属性的对象，它的值也是一个函数。setName属性是一个函数，它接受一个Name参数，然后传递我们在第一个代码块中定义的setName函数作为调度函数的参数。这些都将被映射到组件的props，所以您可以通过调用props.setName来访问这个函数。</p><p id="f3fe" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">然后，dispatch将setName(name)函数的返回发送给rootReducer。请记住，setName(name)的返回值是一个具有“SET_Name”类型属性和传递给它的名称字符串的NAME属性的对象。</p><h2 id="985f" class="kx ka in bd kb ky kz dn kf la lb dp kj lc ld le kn lf lg lh kr li lj lk kv ll bi translated">还原剂</h2><p id="40c1" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">缩减器是由一堆switch-case语句组成的。如果它所传递的动作的类型属性与其中一种情况相匹配，您将在case语句中找到相应的代码。同样，这很难用语言来解释，所以我们来看一个例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ece5" class="kx ka in mt b gy mx my l mz na">const name = (state = '', action) =&gt; {<br/>  switch(action.type) {<br/>    case 'SET_NAME':<br/>      return action.name;<br/>    default :<br/>       return state;<br/>  }<br/>}</span></pre><p id="1c71" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">继续以setName为例，我们的reducer被传递了setName操作，它的类型是‘SET _ NAME’。因为action.type与我们的reducer中的“SET_NAME”的大小写相匹配，所以我们的reducer将返回action.name，它是包含我们想要保存在Redux存储中的名称的字符串。</p><p id="b00c" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">现在，如果您查看Redux的state.name属性，它将是setName传递给它的任何名称。所以综合起来看:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e42a" class="kx ka in mt b gy mx my l mz na">//calling:</span><span id="abcb" class="kx ka in mt b gy nb my l mz na">props.setName('Chris')</span><span id="bbad" class="kx ka in mt b gy nb my l mz na">//results in dispatch calling:</span><span id="104d" class="kx ka in mt b gy nb my l mz na">dispatch(setName('Chris'))</span><span id="618d" class="kx ka in mt b gy nb my l mz na">//which then is passed to our reducer as:</span><span id="ef83" class="kx ka in mt b gy nb my l mz na">const name = ('', {type: 'SET_NAME', name: 'Chris'})</span><span id="38aa" class="kx ka in mt b gy nb my l mz na">//when ends up setting store.state.name = 'Chris'</span></pre><h2 id="25ed" class="kx ka in bd kb ky kz dn kf la lb dp kj lc ld le kn lf lg lh kr li lj lk kv ll bi translated">连接</h2><p id="d594" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">让所有这些动作、状态变量和reducer一起工作的最后一步是方便的connect函数。Connect是Redux提供的一个函数(记得从你的组件顶部的‘react-Redux’导入)包装你的组件，并允许它有效地传递自身props。</p><p id="308a" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">Connect最多接受4个可选参数，但它们必须按照定义的顺序。今天我们只关注前两个，即mapStateToProps和mapDispatchToProps。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="066f" class="kx ka in mt b gy mx my l mz na">import { connect } from 'react-redux'</span><span id="412c" class="kx ka in mt b gy nb my l mz na">const connectToStore = connect(mapStateToProps, mapDispatchToProps)<br/>const ConnectedComponent = connectToStore(Component)</span></pre><p id="ab7f" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">上述函数将把mSP和mDP的返回值映射到组件的props。connect返回另一个函数，该函数接受组件应该作为参数包装。</p><p id="d22b" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">实际上，您通常会看到它在一个步骤中完成，如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7cd9" class="kx ka in mt b gy mx my l mz na">connect(mapStateToProps, mapDispatchToProps)(Component)</span></pre><p id="b669" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">这和上面的两行完全一样，但是更清晰，而且通常是预期的语法，所以一定要以这种方式学习。</p><p id="0159" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">您并不总是希望mapStateToProps和mapDispatch都支持您的组件，因此两者都不是必需的。如果您只想要mapStateToProps，您只能传递一个参数，如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9c1f" class="kx ka in mt b gy mx my l mz na">connect(mapStateToProps)(Component)</span></pre><p id="e2d6" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">但是，如果您只需要mapDispatchToProps，因为connect期望mapStateToProps作为第一个参数，所以您需要在第一个槽中传递null，如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4911" class="kx ka in mt b gy mx my l mz na">connect(null, mapDispatchToProps)(Component)</span></pre><h1 id="c4fe" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Firestore</h1><p id="5fa8" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">你可以在React应用中安装一个非常有用的包来使用Redux和Firebase，这个包的名字叫做<a class="ae mn" href="http://react-redux-firebase.com/docs/getting_started" rel="noopener ugc nofollow" target="_blank"> react-redux-firebase </a>。</p><h2 id="4534" class="kx ka in bd kb ky kz dn kf la lb dp kj lc ld le kn lf lg lh kr li lj lk kv ll bi translated">firestoreConnect</h2><p id="afc4" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">react-redux-firebase npm提供了一个名为firestoreConnect的高阶功能，允许您使用react的生命周期挂钩来监听/取消监听Firestore的更新。</p><p id="ade8" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">假设您在Firestore中有一个聊天和消息的数据库，您希望听到任何更改，以便重新呈现您的应用程序。您可以使用firestoreConnect并向它传递一个数组，其中包含您想要监听的路径。它看起来会像这样:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0384" class="kx ka in mt b gy mx my l mz na">firestoreConnect(() =&gt; ['todos']), // sync todos collection from Firestore into redux</span></pre><p id="ebc4" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">一个更复杂的版本甚至可能是这样的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e493" class="kx ka in mt b gy mx my l mz na">firestoreConnect((props) =&gt; [</span><span id="2fb5" class="kx ka in mt b gy nb my l mz na">  {<br/>    collection: "chats",<br/>    doc: props.match.params.chatId,<br/>    subcollections: [<br/>      {<br/>      collection: "messages",<br/>      orderBy: ["timestamp", "desc"],<br/>      },<br/>    ],</span><span id="870d" class="kx ka in mt b gy nb my l mz na">    limit: props.convLimit</span><span id="9bb4" class="kx ka in mt b gy nb my l mz na">    storeAs: "conversation_" + props.match.params.chatId,</span><span id="c62c" class="kx ka in mt b gy nb my l mz na">   },<br/>])</span></pre><p id="d25d" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">您现在可以直接在Redux中从Firestore访问所有这些收藏和文档。</p><h1 id="99d6" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">将这一切结合在一起</h1><p id="5216" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">最后，为了让所有这些不同的部分协同工作，我们将使用Redux库提供的一个名为compose的函数。</p><h2 id="1ed0" class="kx ka in bd kb ky kz dn kf la lb dp kj lc ld le kn lf lg lh kr li lj lk kv ll bi translated">构成</h2><p id="4f70" class="pw-post-body-paragraph lm ln in lo b lp lq lr ls lt lu lv lw lc lx ly lz lf ma mb mc li md me mf mg ig bi translated">compose允许您以一种清晰的语法将多个“存储增强器”串在一起，而不必将它们作为参数互相传递。使用connect with firestoreConnect时，您需要以下语法:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="06e6" class="kx ka in mt b gy mx my l mz na">export default compose(</span><span id="8014" class="kx ka in mt b gy nb my l mz na">  connect(mapStateToProps, mapDispatchToProps),<br/>  <!-- -->firestoreConnect(() =&gt; ['todos'])</span><span id="ea49" class="kx ka in mt b gy nb my l mz na">)(Component);</span></pre><p id="76bd" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated">现在，您已经将mapStateToProps、mapDispatchToProps和fireStoreConnect的所有功能连接到了您的组件！</p><p id="ccc5" class="pw-post-body-paragraph lm ln in lo b lp mh lr ls lt mi lv lw lc mj ly lz lf mk mb mc li ml me mf mg ig bi translated"><em class="mm">更多内容尽在</em><a class="ae mn" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>