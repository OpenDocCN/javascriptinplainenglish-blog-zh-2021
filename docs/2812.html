<html>
<head>
<title>Redirect After Login with Reach Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Reach路由器登录后重定向</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/redirect-after-login-with-reach-router-29c5d7398cb1?source=collection_archive---------16-----------------------#2021-06-08">https://javascript.plainenglish.io/redirect-after-login-with-reach-router-29c5d7398cb1?source=collection_archive---------16-----------------------#2021-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e1fc2e19dad40e6898813c8ca8923cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8YwoYpKb0eYxXVt7akktxA.jpeg"/></div></div></figure><p id="5df4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">登录后重定向用户是web应用程序中的一个常见功能。通常情况下，当用户的会话过期，他们需要再次登录才能看到他们最初请求的页面时，它就会显示出来。</p><p id="40f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种体验是用户所期望的，但需要由开发人员具体实现。</p><p id="1f4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将回顾我最近是如何实现这个特性的。</p><p id="53ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将利用浏览器窗口中的位置对象。我还将使用React路由库Reach路由器。你不一定要用<a class="ae kt" href="https://reach.tech/router/" rel="noopener ugc nofollow" target="_blank"> Reach </a>路由器来做这个工作，原理应该是一样的。</p><p id="9abc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从我的有效会话检查开始。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="a6a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的应用程序有一个包装所有认证视图的高阶组件。如果用户的会话过期，我会将他们重定向到登录页面。</p><p id="39d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最重要的是从location对象中捕获路径名，并将其保存在某个地方。</p><p id="d2a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe la lb lc ld b">{state: {from: location.pathname}}</code></p><p id="f742" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到达路由器建议将这样的变量添加到location.state对象中。你可以保存它，只要确保它在一个容易从应用程序的其他部分访问的地方。</p><p id="52ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，让我们看看登录页面。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="9795" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户在这里登陆时，我使用Reach Router提供的<code class="fe la lb lc ld b">useLocation()</code>钩子来获取窗口。位置对象。</p><p id="4d2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的登录页面本身并不关心用户来自哪里。所以我将把我们之前添加的<code class="fe la lb lc ld b">location.state.from</code>值传递到我的登录函数中。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="ae0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我的用户成功登录，我就检查从登录页面传来的可选变量。如果已经设置，用户应该被带到他们最初想访问的页面。</p><p id="8d0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我选择将from值传递给我的登录函数有两个原因:</p><ol class=""><li id="ecf5" class="le lf in jx b jy jz kc kd kg lg kk lh ko li ks lj lk ll lm bi translated">只能在功能组件内部调用<code class="fe la lb lc ld b">useLocation()</code>钩子，而我的登录请求在我的应用程序中的其他地方被调用。</li><li id="aa6b" class="le lf in jx b jy ln kc lo kg lp kk lq ko lr ks lj lk ll lm bi translated">这使得我的函数更容易测试。</li></ol><p id="bd6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果用户有他们想要访问的特定路线，他们在登录后将被成功重定向到该路线。</p><p id="b564" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ls">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ls">plain English . io</em></a></p></div></div>    
</body>
</html>