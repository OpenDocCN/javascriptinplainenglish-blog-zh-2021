<html>
<head>
<title>Next.js — Handling Cookies in getServerSideProps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js —在getServerSideProps中处理Cookies</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-using-cookies-in-getserversideprops-89c03a216b0b?source=collection_archive---------1-----------------------#2021-03-16">https://javascript.plainenglish.io/next-js-using-cookies-in-getserversideprops-89c03a216b0b?source=collection_archive---------1-----------------------#2021-03-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/54f13e83cb31e66ab742be92c2e50203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQP0NWfKVKj4ZrGDiOS9sA.png"/></div></div></figure><div class=""/><p id="dc6d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我冒险在Next.js中构建一个认证工作流时，我发现自己在努力处理<strong class="jx iz"> getServerSideProps中的cookies。</strong></p><h1 id="e656" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">问题是</h1><p id="8ad8" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在呈现页面之前，我想在服务器上获取我的用户数据，这意味着我首先需要验证访问令牌，该令牌在浏览器cookie中加密。我希望能够在呈现页面之前更新、删除和设置多个新的cookies。</p><p id="0cc7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我需要重用验证用户令牌的功能，所以我需要能够在getServerSideProps函数范围之外的指定函数中处理cookies。例如，从getServerSideProps内部向我的API发出请求。<strong class="jx iz">这就是事情变得棘手的地方。</strong></p><p id="0406" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在尝试这些cookie操作时，我很快意识到:</p><blockquote class="lw lx ly"><p id="5b14" class="jv jw lz jx b jy jz ka kb kc kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ks ig bi translated">无论您是从getServerSideProps还是普通的API端点调用cookie处理函数，这都很重要。</p></blockquote><p id="1da9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我发现当通过Postman测试我的验证端点时，cookies设置得很好。但是当我从<strong class="jx iz"> </strong> getServerSideProps加载页面时，它们并没有在浏览器中设置</p><p id="9ed5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么会这样呢？</p><p id="091c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您不像调用API路由那样从浏览器调用getServerSideProps <strong class="jx iz">，因此您不能使用相同的方法在浏览器中设置cookies。我们必须使用Next.js的<a class="ae md" href="https://nextjs.org/docs/api-reference/data-fetching/getInitialProps#context-object" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">上下文对象</strong> </a>而不是节点的请求对象。我们将在图书馆的帮助下完成这项工作。但是这些库不会为我们提供一个集成的方法来将cookies从函数传递到getServerSideProps</strong></p><p id="9eb1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们进入服务器渲染之前，让我解释一下我是如何在一个普通的API请求中处理cookies的。</p><h1 id="c6cf" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">从客户端读取/写入cookies</h1><p id="abc2" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我决定模仿Express的cookie处理，并在我的响应对象上添加一个res.cookie函数。这样做的原因是，当在vanilla Node.js中工作时，我们必须通过以下方式设置cookies:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5ec2" class="mn ku iy mj b gy mo mp l mq mr">res.setHeader(“set-cookie”, value)</span></pre><p id="5093" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie" rel="noopener ugc nofollow" target="_blank">文件所述</a>:</p><blockquote class="lw lx ly"><p id="9610" class="jv jw lz jx b jy jz ka kb kc kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ks ig bi translated">要发送多个cookies，应该在同一个响应中发送多个<code class="fe ms mt mu mj b"><strong class="jx iz">Set-Cookie</strong></code>头。</p></blockquote><p id="1704" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，您不能多次调用res.setHeader并期望最终的头包含您的所有cookies。它只会将标头设置为您传递的最后一个值。</p><p id="886f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你要做的是将一个<strong class="jx iz">序列化cookie</strong>的<strong class="jx iz">数组</strong>传递给头文件<strong class="jx iz">。</strong></p><h2 id="9771" class="mn ku iy bd kv mv mw dn kz mx my dp ld kg mz na lh kk nb nc ll ko nd ne lp nf bi translated">这是蓝图:</h2><p id="11ce" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我希望有一个简单的、类似express的<strong class="jx iz"> res.cookie </strong>函数，它将cookie添加到一个数组中，然后能够调用函数<strong class="jx iz"> res.sendCookies </strong>，将cookie的数组实际写入标头。</p><h2 id="6c0b" class="mn ku iy bd kv mv mw dn kz mx my dp ld kg mz na lh kk nb nc ll ko nd ne lp nf bi translated">使用包装</h2><p id="674f" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们可以通过在包装器中导出函数，向本地req和res对象添加任何我们想要的函数。这是我们使用res.cookie的方式。</p><p id="829a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是使用包装器后的无服务器功能:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a99a" class="mn ku iy mj b gy mo mp l mq mr">import wrapper from 'utils/wrapper';</span><span id="da7f" class="mn ku iy mj b gy ng mp l mq mr">const handler = async (req, res, next) =&gt; {<br/>    // code and such<br/>};</span><span id="b69d" class="mn ku iy mj b gy ng mp l mq mr">export default wrapper(handler);</span></pre><p id="3b82" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是包装纸里面的一瞥:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f3de" class="mn ku iy mj b gy mo mp l mq mr">  import cookie from ‘utils/cookies’;</span><span id="eb79" class="mn ku iy mj b gy ng mp l mq mr">  const wrapper = handler =&gt; {</span><span id="5c21" class="mn ku iy mj b gy ng mp l mq mr">    return (req, res, next) =&gt; {</span><span id="ef8f" class="mn ku iy mj b gy ng mp l mq mr">       res.cookieArray = [];</span><span id="c28b" class="mn ku iy mj b gy ng mp l mq mr">       res.cookie = (name, value, options) =&gt; {<br/>         cookie(res, name, value, options);<br/>       };</span><span id="d523" class="mn ku iy mj b gy ng mp l mq mr">       res.sendCookies = () =&gt; {<br/>         res.setHeader('set-cookie', res.cookieArray);<br/>       };</span><span id="66aa" class="mn ku iy mj b gy ng mp l mq mr">       return handler(req, res, next);</span><span id="6394" class="mn ku iy mj b gy ng mp l mq mr">    };<br/>  };</span></pre><h2 id="52f8" class="mn ku iy bd kv mv mw dn kz mx my dp ld kg mz na lh kk nb nc ll ko nd ne lp nf bi translated">res.cookie()</h2><p id="9144" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这个函数根据<strong class="jx iz">值</strong>参数是否为空来设置或删除一个cookie，方法是将它序列化并推送到我们的res.cookieArray</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eb01" class="mn ku iy mj b gy mo mp l mq mr">import { serialize } from ‘cookie’;</span><span id="8902" class="mn ku iy mj b gy ng mp l mq mr">const cookie = (res, name, value, options) =&gt; {<br/>  if (!options) options = {};<br/>  options.path = ‘/’;<br/>  const stringValue = (typeof value === ‘object’)<br/>      ? ‘j:’ + JSON.stringify(value) <br/>      : String(value)</span><span id="22cd" class="mn ku iy mj b gy ng mp l mq mr">if (‘maxAge’ in options) {<br/>    options.expires = new Date(Date.now() + options.maxAge);<br/>    options.maxAge /= 1000;<br/>  };<br/>  if (!value) {<br/>    options.expires = new Date(Date.now() — 1000);<br/>  };</span><span id="1241" class="mn ku iy mj b gy ng mp l mq mr"><strong class="mj iz">// if we pass a value, it sets the cookie<br/></strong>  if (value) {<br/>    res.cookieArray.push(<strong class="mj iz">serialize</strong>(name, String(stringValue), options))</span><span id="8ea6" class="mn ku iy mj b gy ng mp l mq mr"><strong class="mj iz">// if we do not pass an empty string as a value, it deletes the cookie<br/></strong>  } else {<br/>    res.cookieArray.push(<strong class="mj iz">serialize</strong>(name, ‘’, options))<br/>  };</span><span id="c118" class="mn ku iy mj b gy ng mp l mq mr">}</span><span id="a407" class="mn ku iy mj b gy ng mp l mq mr">export default cookie;</span></pre><p id="8639" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这段代码，当您直接从浏览器或Postman调用API时，您应该能够处理写入和删除cookies。</p><p id="4386" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在getServerSideProps中处理cookies。</p><h1 id="3790" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><em class="nh">从服务器读取</em>cookie</h1><p id="7095" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这相当简单。依靠解析Next.js的上下文对象的外部库就足够了，而不是自己尝试。我使用<a class="ae md" href="https://www.npmjs.com/package/next-cookies" rel="noopener ugc nofollow" target="_blank"> next-cookies </a> to <strong class="jx iz">获取服务器上的</strong> cookies:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ba1e" class="mn ku iy mj b gy mo mp l mq mr">import cookies from ‘next-cookies’;</span><span id="fe0d" class="mn ku iy mj b gy ng mp l mq mr">const c = cookies(context);</span><span id="2097" class="mn ku iy mj b gy ng mp l mq mr">const myAuthenticationCookie = c.authenticationToken;</span></pre><p id="3e8c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是更棘手的部分:</p><h1 id="6f38" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">从服务器写入cookies</h1><p id="efb7" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们已经通过添加一个<strong class="jx iz"> res.cookiess </strong>方法和一个<strong class="jx iz"> res.cookieArray </strong>方法，为如何在控制器函数和API端点中处理cookie打下了基础。</p><p id="156e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从一开始就考虑我的情况。我从 getServerSideProps向我的API <strong class="jx iz">上的一个端点发出一个获取请求。当它返回一个响应时，我将无法访问一直用来累积cookies的res对象。所以我只需要在我的回复中返回cookieArray。</strong></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a647" class="mn ku iy mj b gy mo mp l mq mr">return res.json({<br/>  otherData: data,<br/>  cookieArray: res.cookieArray<br/>});</span></pre><p id="8499" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，在getServerSideProps中，我需要解析这个cookieArray并将每个cookie写到<strong class="jx iz">上下文</strong>对象上。我创建了一个像这样调用的函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1f63" class="mn ku iy mj b gy mo mp l mq mr">parseCookies(res.data.cookieArray, context);</span></pre><p id="3b1d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意<strong class="jx iz">上下文</strong>是Node.js的原生对象，从这里开始:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a96f" class="mn ku iy mj b gy mo mp l mq mr">export async function getServerSideProps(<strong class="mj iz">context</strong>) {};</span></pre><p id="d766" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，这里是我的parseCookies函数。为了完成向上下文对象写入的繁重工作，我依赖于<a class="ae md" href="https://www.npmjs.com/package/next-cookie" rel="noopener ugc nofollow" target="_blank"> next-cookie </a>(与<strong class="jx iz">next-cookie</strong>相反)。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9194" class="mn ku iy mj b gy mo mp l mq mr">import { useCookie } from 'next-cookie';</span><span id="87e8" class="mn ku iy mj b gy ng mp l mq mr">function parseCookies(array, context) {<br/>  const cookie = useCookie(context);<br/>    for (let string of array) {<br/>      const arr = string.split(';')</span><span id="15c4" class="mn ku iy mj b gy ng mp l mq mr">      const options = {};<br/>      const key = arr[0].split('=')[0];<br/>      const value = arr[0].split('=')[1];</span><span id="0662" class="mn ku iy mj b gy ng mp l mq mr">      arr.shift();<br/>      for (let option of arr) {<br/>        let key = option.split('=')[0].slice(1);<br/>        let value = option.split('=')[1];</span><span id="fd93" class="mn ku iy mj b gy ng mp l mq mr">        if (key === 'Path') key='path'<br/>        else if (key === 'Expires') key='expires'<br/>        else if (key === 'HttpOnly') key='httpOnly', value=true;<br/>        options[key] = value;<br/>      };</span><span id="4326" class="mn ku iy mj b gy ng mp l mq mr">    if (value !== '') cookie.set(key, value, options)<br/>    else cookie.remove(key);<br/>  };<br/>};</span><span id="9b43" class="mn ku iy mj b gy ng mp l mq mr">export default parseCookies;</span></pre><p id="16d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本质上，这将解析我传递给cookieArray的序列化cookie字符串，并使用从next-cookie导入的函数设置或删除每个字符串。</p><h1 id="9f5d" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">改进您的Next.js无服务器框架</h1><p id="ffeb" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我正在努力充分利用Next.js的API，并使用一个类似Express的框架，这样我就可以将后端逻辑留给控制器，而不是将所有东西都塞进Next.js的无服务器函数中。如果你想达到类似的结果，看看我的文章<a class="ae md" href="https://blog.usejournal.com/express-like-framework-in-next-js-27a884a0264d" rel="noopener ugc nofollow" target="_blank">在Next.js中创建一个类似Express的框架</a></p></div></div>    
</body>
</html>