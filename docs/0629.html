<html>
<head>
<title>An Introduction to Queues and Stacks in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中队列和堆栈的介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-introduction-to-queues-and-stacks-in-javascript-efa26203386c?source=collection_archive---------9-----------------------#2021-02-08">https://javascript.plainenglish.io/an-introduction-to-queues-and-stacks-in-javascript-efa26203386c?source=collection_archive---------9-----------------------#2021-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="990a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在代码中使用队列和堆栈数据结构的初学者指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/12c443fa5a212a7a60da7b225cef0044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uEc0MhwWRle0jIZ8"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@levidjones?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Levi Jones</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8ef0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当你开始学习数据结构和算法时，事情会变得非常复杂。因此，本文旨在放慢速度，让您熟悉两种常见的数据结构(队列和堆栈),这两种数据结构通常用作更复杂算法实现中的基本构件。</p><p id="9f06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> P.S. </strong> <br/>你已经在你的代码中使用这些数据结构了，只是你不知道而已！</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="0720" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">行列</h1><p id="7f0f" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">好吧，那么什么是队列？一个更官方的定义是这样的:</p><p id="57d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mt">“按顺序维护的元素集合，可以通过在集合后面添加新元素或删除集合前面的现有元素来修改。”</em></p><p id="1a9c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最终，队列是一个<strong class="kv io">先进先出(FIFO) </strong>的数据结构。下面这张简单的图片展示了这一过程:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/51621a9f478b3ec76bd31e5353a52e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*fB0Vgx-NDM3X3zrP.png"/></div></figure><p id="71ac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很好，您应该对这些是如何工作的有一个非常清晰的概念，如果您有一点JavaScript编码的经验，您可能已经猜到我们将使用哪种数据类型来创建我们的第一个队列。</p><p id="9454" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">没错一个<strong class="kv io">阵</strong>！</p><ol class=""><li id="6842" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">使用。push()方法，我们可以通过从数据结构的<strong class="kv io"/><em class="mt"/>后面添加新元素来填充我们的数组(也称为<strong class="kv io">入队</strong>)。</li><li id="808e" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">使用。shift()方法，我们可以通过从数据结构的<strong class="kv io">前端</strong>移除元素来从我们的数组中移除元素(也叫<strong class="kv io">出列</strong>)。</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="03b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好了，现在我们了解了如何创建一个队列，让我们更形式化一些，给我们的队列一些结构。</p><p id="b7cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个例子中，我们将使用一个类(以OOP或面向对象的编程风格)实现一个队列，并添加一些有用的方法来操作和查看它的不同部分。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="bc0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以在上一个例子中，我们构建了队列，并添加了一些方法来对它进行一些处理。在下一个例子中，我们将做同样的事情，但是使用稍微更函数化的编程风格。在这种方法中，我们永远不会直接改变现有的队列。相反，每个函数将创建并返回队列的新副本。</p><p id="b733" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript不是真正的函数式语言，所以这不是一个完美的例子，但它应该说明了另一种思考数据结构构造的方式。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="ba36" class="nl lx in bd ly nm nn dn mc no np dp mg lc nq nr mi lg ns nt mk lk nu nv mm nw bi translated">挑战1</h2><p id="fd8a" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">在上面的例子中，我使用数组来构建每个队列，因为它们易于理解，易于编写，并且是JavaScript中非常常见的模式。但是，您可以使用不同的数据类型来实现队列，只要它按照上面提到的FIFO原理工作。所以这是你的挑战:</p><blockquote class="nx"><p id="68c2" class="ny nz in bd oa ob oc od oe of og lo dk translated"><strong class="ak"> <em class="oh">用字符串代替数组创建队列。</em>T24】</strong></p></blockquote></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="2b26" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">大量</h1><p id="7859" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">既然我们已经理解了什么是队列，那么用栈来包装我们的思想就相当简单了。与队列(FIFO)不同，堆栈是遵循<strong class="kv io">后进先出(LIFO) </strong>原则的数据结构。下图说明了这在实践中是如何工作的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/2deca43c890e810077fa21a676278036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hp77x-uojEvKi-cT.png"/></div></div></figure><p id="8e9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，使用数组，我们将在JavaScript中实现一个堆栈数据结构。</p><ol class=""><li id="9b47" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">我们可以使用。对<strong class="kv io">的push()方法将</strong>元素从<strong class="kv io">后面的</strong>添加到堆栈中，就像我们对队列所做的那样。</li><li id="9752" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">但是与队列不同，我们将使用。pop()方法将<strong class="kv io">中的</strong>元素从堆栈的<strong class="kv io">后面</strong>中移除。</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="694a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太棒了，所以从上面的代码中可以看出，除了如何移除元素之外，Stack与Queue几乎完全相同。</p><p id="51f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们将仔细看看使用类对象构建堆栈的OOP方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="9ada" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，为了更好地衡量，我们将构建一个功能性更强的堆栈。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="147f" class="nl lx in bd ly nm nn dn mc no np dp mg lc nq nr mi lg ns nt mk lk nu nv mm nw bi translated">挑战2</h2><p id="f158" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">同样，我使用数组来构建每个堆栈。但是，您可以使用不同的数据类型实现堆栈，只要它根据LIFO原则运行。所以这是你的挑战:</p><blockquote class="nx"><p id="2404" class="ny nz in bd oa ob oc od oe of og lo dk translated">使用对象而不是数组创建堆栈。</p></blockquote></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="6161" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">结论</h1><p id="6e1b" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">这就是队列和堆栈。虽然它们看起来相对简单，但它们经常在更复杂的数据结构和算法中使用，并与它们结合使用。当你在面试和工作中遇到真正棘手的问题时，对这些基本概念有一个坚实的理解将为你以后的成功做好准备。</p><p id="37c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读，一如既往，继续编码！</p><p id="ee9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看看一些更复杂的算法，看看您是否能发现队列和堆栈在哪里使用:</p><div class="oj ok gp gr ol om"><a href="https://medium.com/@tom.w.j.sanderson/selection-sort-algorithm-101-f324e33ded2a" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">选择排序算法101</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">用JavaScript实现选择排序算法</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa km om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://medium.com/swlh/merge-sort-algorithm-101-c4fdea276289" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">合并排序算法101</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">JavaScript中递归和迭代合并排序实现概述。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa km om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://medium.com/@tom.w.j.sanderson/insertion-sort-algorithm-101-1ac309f5b0e7" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">插入排序算法101</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">JavaScript插入排序算法的迭代和递归实现指南。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa km om"/></div></div></a></div><p id="4272" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">来源</p><div class="oj ok gp gr ol om"><a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">队列(抽象数据类型)</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在计算机科学中，队列是按顺序维护的实体的集合，可以被修改</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">en.wikipedia.org</p></div></div><div class="ov l"><div class="pd l ox oy oz ov pa km om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">堆栈(抽象数据类型)</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在计算机科学中，栈是一种抽象的数据类型，作为元素的集合，有两个主要的作用…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">en.wikipedia.org</p></div></div><div class="ov l"><div class="pe l ox oy oz ov pa km om"/></div></div></a></div></div></div>    
</body>
</html>