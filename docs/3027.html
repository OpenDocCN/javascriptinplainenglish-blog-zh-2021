<html>
<head>
<title>How to Create a Custom Cursor in React — Part 2 [Mathematical explanation]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中创建自定义光标—第2部分[数学解释]</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-custom-cursor-in-react-part-2-mathematical-explanation-2193b52c43ba?source=collection_archive---------13-----------------------#2021-06-19">https://javascript.plainenglish.io/how-to-create-a-custom-cursor-in-react-part-2-mathematical-explanation-2193b52c43ba?source=collection_archive---------13-----------------------#2021-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jk jl jm jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/decad83d63235cdfa990adef2b002293.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7NktCSlm9Ey09ZxwVdLL5w.png"/></div></figure><p id="97d8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你正在寻找源代码，那么它可以在视频中找到。</p><figure class="kp kq kr ks gt jn"><div class="bz fp l di"><div class="kt ku l"/></div></figure><p id="9e82" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请观看此视频以示支持。😢</p><p id="5cc0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">本文主要关注光标动画的数学部分(光标轮廓)。文章的第1部分与代码部分完全相关，如果你想了解它是如何工作的，你可以跟随它。</p><p id="6cf3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">主要部分围绕这个功能—</p><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kw"><img src="../Images/1b596255233f8c0fc0221b91688f5713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sN4opGFu9sAXb3S5w-GaAw.png"/></div></div></figure><p id="3e2e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> requestAnimationFrame </strong>也为我们提供了一个<strong class="jt io">时间戳</strong>变量，我们可以用它来查看递归函数在什么时间间隔后被调用。</p><p id="90bd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们还需要在每次调用这个函数时存储<strong class="jt io"> x </strong>和<strong class="jt io"> y </strong>点。因此，我们可以创建一个函数来存储这三个属性。</p><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lb"><img src="../Images/0bd91e85d133cd676783bba940094f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3HQwTY5cFtKJIvEMar5BZQ.png"/></div></div></figure><p id="18ec" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们还需要调整我们的<strong class="jt io"> animateOutline </strong>函数，以便获得想要的输出。</p><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lc"><img src="../Images/5fed447b752b471bcea2b991dbee8b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YwETzckuW3fdkP7z8CV7g.png"/></div></div></figure><p id="0ff2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们正在将<strong class="jt io">坐标对象</strong>推入坐标<strong class="jt io">数组</strong>中。</p><p id="7985" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">添加了新的条件来阻止<strong class="jt io"> requestAnimationFrame </strong>函数再次调用它。根据条件，我们会递归调用它，直到<strong class="jt io">光标轮廓的</strong> <strong class="jt io">坐标</strong>不等于<strong class="jt io">光标点的</strong> <strong class="jt io">坐标</strong>为止。</p><p id="f6b3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当坐标相等时，我们将记录控制台日志。我们将使用<code class="fe ld le lf lg b">console.table</code>函数，因为它提供了一个漂亮的输出表格视图。</p><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lh"><img src="../Images/4c8d5883c490d8710aea728e3a5f5f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lduz2kgdFQpoS6rVo2LGCA.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">The head of the data</figcaption></figure><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lm"><img src="../Images/a29a0b5c4bae5e57a10c9995347f6566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYd8NTo8_URq0jAVVg-RbQ.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">The tail of the data</figcaption></figure><p id="8d40" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">从这些数据中我们可以得出一些结论——</p><ul class=""><li id="a475" class="ln lo in jt b ju jv jy jz kc lp kg lq kk lr ko ls lt lu lv bi translated">时间戳之间的差异几乎是恒定的，即16–17毫秒。如果你读了这篇文章，你就会知道它模拟的是60FPS (1000/60)。这个1000ms除以60等于16.67ms。</li><li id="1357" class="ln lo in jt b ju lw jy lx kc ly kg lz kk ma ko ls lt lu lv bi translated">在动画的初始阶段，数据点有很大的差异，但随着时间的增加，差异会减小。</li></ul><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/7f1d969d15220dd5800e1789588c369d.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*674g9P7kihYlHOqJ9oaX4A.png"/></div></figure><p id="704f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们将新值和以前的值相加。endX 是常数，所以如果我们在每次迭代后从它减去<strong class="jt io"> x </strong>，分子将继续减少。最终它变得有点接近0。</p><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/9d599bd41d34570d42d6d81dc367361c.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*TA7kTCWftFCmEh9hXNdWSQ.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">The head data of the difference in between dot and outline</figcaption></figure><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/bcdbfbaba0641c40798704ed8dce593f.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*68adUf7kiQnKh3m-P5phFw.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">The tail data of the difference in between dot and outline</figcaption></figure><p id="bc4c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们画出关于时间戳的x点，我们会得到这样一个图</p><figure class="kp kq kr ks gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/695c5d2a13f142482a5ca34d5a710445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBGFZ-EbB6sqKFCNemrNWA.jpeg"/></div></div></figure><p id="6d2f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有点像对数图和放松三次贝塞尔函数。在初始阶段增加很快，然后增长率下降。</p><p id="5dc5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">就是这样，这就是我们如何能够在JavaScript的帮助下，实现这种平滑的过渡。🤩🥳</p><p id="6531" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="mf">更多内容看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="mf">plain English . io</em></strong></a></p></div></div>    
</body>
</html>