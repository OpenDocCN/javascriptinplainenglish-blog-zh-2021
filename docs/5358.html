<html>
<head>
<title>Simple Guide to Write User-Defined Type Guards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写用户自定义类型保护的简单指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simple-guide-to-write-user-defined-type-guards-9c3becdca321?source=collection_archive---------12-----------------------#2021-11-03">https://javascript.plainenglish.io/simple-guide-to-write-user-defined-type-guards-9c3becdca321?source=collection_archive---------12-----------------------#2021-11-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4676" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么、何时以及如何编写用户定义的类型保护</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ae621706f0eaf566cd64933a7a8329e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*74KP7irYpPtYdIZW"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@davidmartinjr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Martin</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2fe9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这篇文章中，我将分享我编写用户自定义类型守卫的经验。该员额分为:</p><ul class=""><li id="0e8d" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io">什么</strong>是用户自定义类型的防护？</li><li id="33b5" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">什么时候</strong>写一个用户自定义类型的守卫？</li><li id="2858" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">如何</strong>编写一个自定义类型的守卫？</li></ul><p id="7463" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="3761" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">什么</strong>是用户自定义类型的防护？</h1><p id="e0dd" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">当你听到一个新事物时，第一反应通常是<strong class="kv io">什么？</strong>我们先来解释一下守卫型。</p><p id="d345" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">类型保护基本上是TypeScript中提供的保护变量类型的东西。例如，如果我说<code class="fe nh ni nj nk b">isCoolToday: boolean</code>，除了<code class="fe nh ni nj nk b">true</code>或<code class="fe nh ni nj nk b">false</code>之外的任何东西都会给你错误。</p><p id="1f85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">类型保护检查代码，并告诉您您给变量分配了错误的数据类型。</p><p id="3a90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们知道什么是类型保护。那么<strong class="kv io">用户自定义的</strong>部分呢？</p><p id="6ea6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可能会出现TypeScript无法为我们进行类型保护和检查的情况，这就是我们开发人员必须自己编写类型保护的情况。这就是所谓的<strong class="kv io">用户自定义类型保护</strong>。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="d869" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">什么时候</strong>写一个自定义类型的守护？</h1><p id="bb74" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">所以现在我明白是什么了，下一个问题是</p><blockquote class="nl"><p id="4b00" class="nm nn in bd no np nq nr ns nt nu lo dk translated">我什么时候需要这个？我在什么样的情况下写这个？</p></blockquote><p id="a46e" class="pw-post-body-paragraph kt ku in kv b kw nv jo ky kz nw jr lb lc nx le lf lg ny li lj lk nz lm ln lo ig bi translated">要知道“什么时候”，让我举一个场景和代码的例子，以便有一个更清晰的画面。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/04d5b1d10aea80bc36b7960370c4998b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNUR3hRP7Qs13RV4yXGgZQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Check this out in <a class="ae ks" href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCpTiAzoswD2IAwnADakBGiA1gApwCep+cAJsgN4BQyvyrcMHABcnHnwlgM2XARAB9YK1EgArgFsK0ANziJvOOvyrwKjVqi79fVhCwIowAA55CorFNABzK3wC+XAFcXKCQsIgo6Jg4CK4gAGJwwKQQrCTkVAh0jMxsYhLQUPhQotzWvFLRsoSKyshqmjp6+oXF8gj4tmaNls0FUEVQ8up2OF4Q7p4gPn18rUO2QslYk47TvrwBQR3YYMhYECCs9Ews7AC8yAAUTjlnolEysXLplDQnuewAPmjSMXGJZKpV6ZbKnNgASmQ5wAfPk+MAYNdbuDWAA6ARCKFlcoAelxyAAEphWCl9qoEEgsFhkAg4Admn5kBBSAd4dZ8USSWT4ED2HSGRIgn5dEA" rel="noopener ugc nofollow" target="_blank">TypeScript Playground</a></figcaption></figure><p id="28d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这通常发生在上述情况下，其中:</p><ul class=""><li id="a512" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">首先，你有一个<strong class="kv io">参数，它可以是两种不同的类型</strong>，比如<code class="fe nh ni nj nk b">TransactionCallbnackPayload</code>和<code class="fe nh ni nj nk b">TransactionFailedCallbackPayload</code></li><li id="6595" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">其次，对参数有一个<strong class="kv io">条件验证，比如验证<code class="fe nh ni nj nk b">payload.data</code>，如上面第20行所示。</strong></li></ul><p id="02e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，TypeScript不知道哪种类型的有效载荷将被传递到函数中，因为它可能是<code class="fe nh ni nj nk b">TransactionCallbnackPayload</code>和<code class="fe nh ni nj nk b">TransactionFailedCallbackPayload</code>之间的任何一个。也正因为如此，TypeScript向您报告了一个错误，即<code class="fe nh ni nj nk b">data</code>字段可能未定义，因为<code class="fe nh ni nj nk b">TransactionFailedCallbackPayload</code>不包含<code class="fe nh ni nj nk b">data</code>。</p><p id="898b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当你遇到上述情况时，就是那个时刻——你需要写一个<strong class="kv io">自定义类型守护</strong>的时刻。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="046b" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">如何</strong>编写一个自定义类型的守卫？</h1><p id="00ae" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">对于这一部分，TypeScript提供了非常棒的文档，教你如何编写。我个人比较喜欢这本<a class="ae ks" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" rel="noopener ugc nofollow" target="_blank">手册</a>。虽然它被弃用，但仍然非常有用，我喜欢它的写作方式。</p><p id="885e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，我仍将通过两种方式来编写我在代码中探索和使用的用户定义的类型保护:</p><ul class=""><li id="2a64" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">使用<code class="fe nh ni nj nk b">in</code>运算符—更简单的方法</li><li id="3d97" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">使用类型谓词</li></ul><h2 id="795a" class="ob ml in bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">一种更简单的方法——In运算符</h2><p id="a3cd" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">使用<code class="fe nh ni nj nk b">in</code>操作符相对简单直接。在代码中应该是这样的。</p><p id="8a2e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面代码的亮点在第20行— <code class="fe nh ni nj nk b">if ('data' in payload)</code>。这一行帮助我们检查有效载荷中是否存在数据，我们用它来区分有效载荷。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h2 id="1f69" class="ob ml in bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">第二种方法—类型谓词</h2><p id="f756" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">我可能会说，在你的代码库中使用类型谓词会更具可伸缩性。稍后我将解释更多关于可伸缩性的内容。</p><p id="1421" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，什么是类型谓词？返回类型的函数是类型谓词。</p><p id="265c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看用<strong class="kv io">类型谓词</strong>实现时的样子。下面是完整的源代码。但是突出显示的部分是从第19行开始的。这是我们定义类型谓词的地方。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="2b8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们基本上探索了两种方法来实现这一点。为什么我说类型谓词方法更“可伸缩”。我从这几点思考:</p><ul class=""><li id="46fe" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io">可重用性</strong> —我可以在整个存储库中重用类型谓词，我只需要导入它们。</li><li id="17b4" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">可维护性</strong> —我可以很容易地维护这个函数，如果我改变了有效载荷的数据结构，我只需要更新类型谓词的实现。如果我要使用<code class="fe nh ni nj nk b">in</code>操作符，我可能必须找到它并把它们都换掉。</li></ul></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="9ded" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">结论</h1><p id="3ca4" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">在这篇文章中，我们探讨了用户定义类型保护的内容、时间和方式。除此之外，我们还看了使用<code class="fe nh ni nj nk b">in</code>操作符和类型谓词的用户定义类型保护的实现。</p><p id="774d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望你喜欢这篇文章，并在下一篇文章中看到你。</p><h1 id="11de" class="mk ml in bd mm mn op mp mq mr oq mt mu jt or ju mw jw os jx my jz ot ka na nb bi translated">参考</h1><ul class=""><li id="4dca" class="lp lq in kv b kw nc kz nd lc ou lg ov lk ow lo lu lv lw lx bi translated">Mike North的打字培训——他在Frontendmasters上有一门非常好的打字课程。如果你感兴趣，一定要去看看。</li></ul><p id="34b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ox">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="ox">plain English . io</em></strong></a></p></div></div>    
</body>
</html>