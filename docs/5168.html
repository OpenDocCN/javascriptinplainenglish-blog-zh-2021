<html>
<head>
<title>How to Listen to Events on Dynamically Created Elements with JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript监听动态创建的元素上的事件？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-listen-to-events-on-dynamically-created-elements-with-javascript-1d300d17d0e?source=collection_archive---------8-----------------------#2021-10-20">https://javascript.plainenglish.io/how-to-listen-to-events-on-dynamically-created-elements-with-javascript-1d300d17d0e?source=collection_archive---------8-----------------------#2021-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1771e29713327feb3aa90f43d3a2b4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ivjwU7eiFdw4KEfI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@arnold_antoo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Antoo</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2651" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网页中的许多项目都是用JavaScript动态创建的。</p><p id="6a01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们必须监听它们发出的事件，这样我们就可以使用它们做一些事情，而不是静态地显示内容。</p><p id="8618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何监听用JavaScript动态创建的元素上的事件。</p><h1 id="65c8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事件委托</h1><p id="0b3a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以监听在具有动态创建的元素的容器元素上发出的事件。</p><p id="84de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在事件监听器中，我们可以检查哪个项目正在发出事件，根据发出事件的元素来做我们想要的事情。</p><p id="89e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是可能的，因为一个元素发出的事件会向上冒泡到它的父元素和祖先元素，一直到<code class="fe me mf mg mh b">body</code>和<code class="fe me mf mg mh b">html</code>元素，除非我们手动停止它。</p><p id="c46a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们允许事件传播，<code class="fe me mf mg mh b">body</code>元素的事件监听器将从它的所有后代元素中选取事件。</p><p id="337e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下HTML:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5f3e" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;</span><span id="aa01" class="mq lc iq mh b gy mv ms l mt mu">&lt;/div&gt;</span></pre><p id="c79f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后编写以下JavaScript来监听由动态创建的<code class="fe me mf mg mh b">p</code>元素发出的点击事件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cd78" class="mq lc iq mh b gy mr ms l mt mu">const div = document.querySelector('div')<br/>for (let i = 1; i &lt;= 100; i++) {<br/>  const p = document.createElement('p')<br/>  p.className = i % 2 === 1 ? 'odd' : 'even'<br/>  p.textContent = 'hello'<br/>  div.appendChild(p)<br/>}</span><span id="278e" class="mq lc iq mh b gy mv ms l mt mu">document.addEventListener('click', (e) =&gt; {<br/>  if (e.target.className.includes('odd')) {<br/>    console.log('odd element clicked', e.target.textContent)<br/>  } else if (e.target.className.includes('even')) {<br/>    console.log('even element clicked', e.target.textContent)<br/>  }<br/>});</span></pre><p id="9d21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用<code class="fe me mf mg mh b">document.querySelector</code>获得了div元素。</p><p id="14e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用for循环在div内部添加<code class="fe me mf mg mh b">p</code>元素100次。</p><p id="d99f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们设置元素的<code class="fe me mf mg mh b">className</code>来设置<code class="fe me mf mg mh b">class</code>属性的值。</p><p id="c513" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">textContent</code>有<code class="fe me mf mg mh b">p</code>元素的内容值。</p><p id="5bc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用div上的<code class="fe me mf mg mh b">appendChild</code>来添加div中的<code class="fe me mf mg mh b">p</code>元素。</p><p id="9cd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后为了监听我们刚刚添加的<code class="fe me mf mg mh b">p</code>元素上的点击事件，我们监听<code class="fe me mf mg mh b">document</code>的点击，它是<code class="fe me mf mg mh b">body</code>元素。</p><p id="ab7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">addEventListener</code>将点击监听器添加到<code class="fe me mf mg mh b">body</code>元素中。</p><p id="594b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们传入一个回调函数作为<code class="fe me mf mg mh b">addEventListener</code>的第二个参数。</p><p id="7460" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">e</code>参数是事件对象。</p><p id="749f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它包含关于发出事件的原始元素的信息。</p><p id="291a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">e.target</code>属性获取最初发出事件的元素。</p><p id="69d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以获得具有<code class="fe me mf mg mh b">e.target.className</code>属性的元素的<code class="fe me mf mg mh b">class</code>属性的值。</p><p id="98da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用属性<code class="fe me mf mg mh b">e.target.textContent</code>得到属性<code class="fe me mf mg mh b">textContent</code>的值。</p><h1 id="0d86" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7894" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过事件委托来监听由动态创建的HTML元素发出的事件。</p><p id="a264" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是监听来自发出事件的元素的祖先的事件，然后检查哪个元素在回调中发出了事件。</p><p id="2ca0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>