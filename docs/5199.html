<html>
<head>
<title>Create High-Performance JavaScript APIs using Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust创建高性能的JavaScript APIs</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-high-performance-javascript-apis-using-rust-89fced9a924b?source=collection_archive---------4-----------------------#2021-10-22">https://javascript.plainenglish.io/create-high-performance-javascript-apis-using-rust-89fced9a924b?source=collection_archive---------4-----------------------#2021-10-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c829" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> WasmEdge </em> </a> <em class="kj">融合了Rust的性能和JavaScript的易用性</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/741ca0b8022f768da0d81362509c0b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*grRAfXlvo47n4k5x"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a3c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我之前的文章中，我讨论了如何将JavaScript代码嵌入到Rust程序中。然而，对于JavaScript开发人员来说，需求往往是相反的——将Rust函数合并到JavaScript APIs中。这使得开发人员能够用“纯JavaScript”编写程序，同时还能利用高性能的Rust函数。使用<a class="ae ki" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> WasmEdge运行时</a>，您可以做到这一点。</p><p id="4a58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们来看几个例子。查看<a class="ae ki" href="https://github.com/second-state/wasmedge-quickjs/" rel="noopener ugc nofollow" target="_blank">wasmedge-quick js</a>Github repo，并转到<code class="fe la lb lc ld b">examples/embed_js</code>文件夹继续跟进。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="315f" class="li lj in ld b gy lk ll l lm ln">$ git clone https://github.com/second-state/wasmedge-quickjs<br/>$ cd examples/embed_js</span></pre><p id="31e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您必须安装<a class="ae ki" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank"> Rust </a>和<a class="ae ki" href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md" rel="noopener ugc nofollow" target="_blank"> WasmEdge </a>来构建和运行本文中的示例。</p><p id="f184" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe la lb lc ld b">embed_js</code>演示展示了如何在Rust中嵌入JavaScript的几个不同例子。您可以构建并运行所有示例，如下所示。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="3863" class="li lj in ld b gy lk ll l lm ln">$ cargo build --target wasm32-wasi --release<br/>$ wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi lo"><img src="../Images/5619c481c997797ee26971a17d64bc09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHhZ8whc9Tn2dfyWDMPFBg.jpeg"/></div></div></figure><h1 id="2c77" class="lp lj in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">创建一个JavaScript函数API</h1><p id="ecec" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">下面的代码片段定义了一个Rust函数，它可以作为API集成到JavaScript解释器中。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="8fa8" class="li lj in ld b gy lk ll l lm ln">fn run_rust_function(ctx: &amp;mut Context) {</span><span id="c03f" class="li lj in ld b gy mr ll l lm ln">    struct HelloFn;<br/>    impl JsFn for HelloFn {<br/>        fn call(_ctx: &amp;mut Context, _this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {<br/>            println!("hello from rust");<br/>            println!("argv={:?}", argv);<br/>            JsValue::UnDefined<br/>        }<br/>    }<br/>    <br/>    ...<br/>}</span></pre><p id="fbdf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的代码片段展示了如何将这个Rust函数添加到JavaScript解释器中，给出一个名字<code class="fe la lb lc ld b">hi()</code>作为它的JavaScript API，然后从JavaScript代码中调用它。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="175e" class="li lj in ld b gy lk ll l lm ln">fn run_rust_function(ctx: &amp;mut Context) {<br/>    ...<br/>    <br/>    let f = ctx.new_function::&lt;HelloFn&gt;("hello");<br/>    ctx.get_global().set("hi", f.into());<br/>    let code = r#"hi(1,2,3)"#;<br/>    let r = ctx.eval_global_str(code);<br/>    println!("return value:{:?}", r);<br/>}</span></pre><p id="d2ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行结果如下。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="8ea4" class="li lj in ld b gy lk ll l lm ln">hello from rust<br/>argv=[Int(1), Int(2), Int(3)]<br/>return value:UnDefined</span></pre><p id="64fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这种方法，您可以创建一个带有定制API函数的JavaScript解释器。解释器在WasmEdge内部运行，可以执行JavaScript代码，从CLI或网络调用这样的API函数。</p><h1 id="17df" class="lp lj in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">创建JavaScript对象API</h1><p id="9481" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">在JavaScript API设计中，我们有时需要提供一个封装了数据和函数的对象。在下面的例子中，我们为JavaScript API定义了一个Rust函数。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="2ead" class="li lj in ld b gy lk ll l lm ln">fn rust_new_object_and_js_call(ctx: &amp;mut Context) {</span><span id="93b3" class="li lj in ld b gy mr ll l lm ln">    struct ObjectFn;<br/>    impl JsFn for ObjectFn {<br/>        fn call(_ctx: &amp;mut Context, this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {<br/>            println!("hello from rust");<br/>            println!("argv={:?}", argv);<br/>            if let JsValue::Object(obj) = this_val {<br/>                let obj_map = obj.to_map();<br/>                println!("this={:#?}", obj_map);<br/>            }<br/>            JsValue::UnDefined<br/>        }<br/>    }</span></pre><p id="1738" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们在Rust端创建一个“对象”，设置它的数据字段，然后将Rust函数注册为与对象相关联的JavaScript函数。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="01af" class="li lj in ld b gy lk ll l lm ln">let mut obj = ctx.new_object();<br/>    obj.set("a", 1.into());<br/>    obj.set("b", ctx.new_string("abc").into());<br/>    <br/>    let f = ctx.new_function::&lt;ObjectFn&gt;("anything");<br/>    obj.set("f", f.into());</span></pre><p id="6238" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们让Rust“object”在JavaScript解释器中作为JavaScript对象<code class="fe la lb lc ld b">test_obj</code>可用。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="b7e5" class="li lj in ld b gy lk ll l lm ln">ctx.get_global().set("test_obj", obj.into());</span></pre><p id="08a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在JavaScript代码中，你现在可以直接使用<code class="fe la lb lc ld b">test_obj</code>作为API的一部分。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="6f6b" class="li lj in ld b gy lk ll l lm ln">let code = r#"<br/>      print('test_obj keys=',Object.keys(test_obj))<br/>      print('test_obj.a=',test_obj.a)<br/>      print('test_obj.b=',test_obj.b)<br/>      test_obj.f(1,2,3,"hi")<br/>    "#;</span><span id="3c40" class="li lj in ld b gy mr ll l lm ln">    ctx.eval_global_str(code);<br/>}</span></pre><p id="aaf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行结果如下。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="3101" class="li lj in ld b gy lk ll l lm ln">test_obj keys= a,b,f<br/>test_obj.a= 1<br/>test_obj.b= abc<br/>hello from rust<br/>argv=[Int(1), Int(2), Int(3), String(JsString(hi))]<br/>this=Ok(<br/>    {<br/>        "a": Int(<br/>            1,<br/>        ),<br/>        "b": String(<br/>            JsString(<br/>                abc,<br/>            ),<br/>        ),<br/>        "f": Function(<br/>            JsFunction(<br/>                function anything() {<br/>                    [native code]<br/>                },<br/>            ),<br/>        ),<br/>    },<br/>)</span></pre><h1 id="8ef3" class="lp lj in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">一个完整的JavaScript对象API</h1><p id="be89" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">在前面的例子中，我们演示了从Rust创建JavaScript APIs的简单例子。在这个例子中，我们将创建一个完整的Rust模块，并使它作为一个JavaScript对象API可用。该项目位于<a class="ae ki" href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_rust_module" rel="noopener ugc nofollow" target="_blank">examples/embed _ rust _ module</a>文件夹中。您可以在WasmEdge中将它作为标准Rust应用程序来构建和运行。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="43b2" class="li lj in ld b gy lk ll l lm ln">$ cargo build --target wasm32-wasi --release<br/>$ wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm</span></pre><p id="fd1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对象的Rust实现是一个模块，如下所示。它有数据字段、构造函数、getters和setters以及函数。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="5208" class="li lj in ld b gy lk ll l lm ln">mod point {<br/>    use wasmedge_quickjs::*;</span><span id="f4bb" class="li lj in ld b gy mr ll l lm ln">    #[derive(Debug)]<br/>    struct Point(i32, i32);</span><span id="f4df" class="li lj in ld b gy mr ll l lm ln">    struct PointDef;</span><span id="c4f0" class="li lj in ld b gy mr ll l lm ln">    impl JsClassDef&lt;Point&gt; for PointDef {<br/>        const CLASS_NAME: &amp;'static str = "Point\0";<br/>        const CONSTRUCTOR_ARGC: u8 = 2;</span><span id="39aa" class="li lj in ld b gy mr ll l lm ln">        fn constructor(_: &amp;mut Context, argv: &amp;[JsValue]) -&gt; Option&lt;Point&gt; {<br/>            println!("rust-&gt; new Point {:?}", argv);<br/>            let x = argv.get(0);<br/>            let y = argv.get(1);<br/>            if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {<br/>                Some(Point(*x, *y))<br/>            } else {<br/>                None<br/>            }<br/>        }</span><span id="8a9d" class="li lj in ld b gy mr ll l lm ln">        fn proto_init(p: &amp;mut JsClassProto&lt;Point, PointDef&gt;) {<br/>            struct X;<br/>            impl JsClassGetterSetter&lt;Point&gt; for X {<br/>                const NAME: &amp;'static str = "x\0";</span><span id="b48f" class="li lj in ld b gy mr ll l lm ln">                fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {<br/>                    println!("rust-&gt; get x");<br/>                    this_val.0.into()<br/>                }</span><span id="7b4c" class="li lj in ld b gy mr ll l lm ln">                fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {<br/>                    println!("rust-&gt; set x:{:?}", val);<br/>                    if let JsValue::Int(x) = val {<br/>                        this_val.0 = x<br/>                    }<br/>                }<br/>            }</span><span id="8800" class="li lj in ld b gy mr ll l lm ln">            struct Y;<br/>            impl JsClassGetterSetter&lt;Point&gt; for Y {<br/>                const NAME: &amp;'static str = "y\0";</span><span id="343f" class="li lj in ld b gy mr ll l lm ln">                fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {<br/>                    println!("rust-&gt; get y");<br/>                    this_val.1.into()<br/>                }</span><span id="131d" class="li lj in ld b gy mr ll l lm ln">                fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {<br/>                    println!("rust-&gt; set y:{:?}", val);<br/>                    if let JsValue::Int(y) = val {<br/>                        this_val.1 = y<br/>                    }<br/>                }<br/>            }</span><span id="eea4" class="li lj in ld b gy mr ll l lm ln">            struct FnPrint;<br/>            impl JsMethod&lt;Point&gt; for FnPrint {<br/>                const NAME: &amp;'static str = "pprint\0";<br/>                const LEN: u8 = 0;</span><span id="6a0a" class="li lj in ld b gy mr ll l lm ln">                fn call(_: &amp;mut Context, this_val: &amp;mut Point, _argv: &amp;[JsValue]) -&gt; JsValue {<br/>                    println!("rust-&gt; pprint: {:?}", this_val);<br/>                    JsValue::Int(1)<br/>                }<br/>            }</span><span id="f707" class="li lj in ld b gy mr ll l lm ln">            p.add_getter_setter(X);<br/>            p.add_getter_setter(Y);<br/>            p.add_function(FnPrint);<br/>        }<br/>    }</span><span id="4173" class="li lj in ld b gy mr ll l lm ln">    struct PointModule;<br/>    impl ModuleInit for PointModule {<br/>        fn init_module(ctx: &amp;mut Context, m: &amp;mut JsModuleDef) {<br/>            m.add_export("Point\0", PointDef::class_value(ctx));<br/>        }<br/>    }</span><span id="40fe" class="li lj in ld b gy mr ll l lm ln">    pub fn init_point_module(ctx: &amp;mut Context) {<br/>        ctx.register_class(PointDef);<br/>        ctx.register_module("point\0", PointModule, &amp;["Point\0"]);<br/>    }<br/>}</span></pre><p id="5e76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在解释器实现中，我们首先调用<code class="fe la lb lc ld b">point::init_point_module</code>向JavaScript上下文注册Rust模块，然后我们可以运行一个简单使用<code class="fe la lb lc ld b">point</code>对象的JavaScript程序。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="86e7" class="li lj in ld b gy lk ll l lm ln">use wasmedge_quickjs::*;<br/>fn main() {<br/>    let mut ctx = Context::new();<br/>    point::init_point_module(&amp;mut ctx);</span><span id="0b9b" class="li lj in ld b gy mr ll l lm ln">    let code = r#"<br/>      import('point').then((point)=&gt;{<br/>        let p0 = new point.Point(1,2)<br/>        print("js-&gt;",p0.x,p0.y)<br/>        p0.pprint()<br/>        try{<br/>            let p = new point.Point()<br/>            print("js-&gt; p:",p)<br/>            print("js-&gt;",p.x,p.y)<br/>            p.x=2<br/>            p.pprint()<br/>        } catch(e) {<br/>            print("An error has been caught");<br/>            print(e)<br/>        }    <br/>      })<br/>    "#;</span><span id="1499" class="li lj in ld b gy mr ll l lm ln">    ctx.eval_global_str(code);<br/>    ctx.promise_loop_poll();<br/>}</span></pre><p id="c13f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述应用程序的执行结果如下。</p><pre class="kl km kn ko gt le ld lf lg aw lh bi"><span id="e7bc" class="li lj in ld b gy lk ll l lm ln">rust-&gt; new Point [Int(1), Int(2)]<br/>rust-&gt; get x<br/>rust-&gt; get y<br/>js-&gt; 1 2<br/>rust-&gt; pprint: Point(1, 2)<br/>rust-&gt; new Point []<br/>js-&gt; p: undefined<br/>An error has been caught<br/>TypeError: cannot read property 'x' of undefined</span></pre><h1 id="626f" class="lp lj in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">下一步是什么</h1><p id="e8b0" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">使用Rust函数和模块来实现JavaScript API是一个强大的想法。它允许WasmEdge运行时显著提高JavaScript应用程序的性能。然而，那些Rust函数仍然需要编译成WebAssembly字节码。对于一些函数，比如AI推理，直接从WasmEdge调用原生C库函数效率更高。在<a class="ae ki" href="https://www.secondstate.io/articles/call-native-functions-from-javascript/" rel="noopener ugc nofollow" target="_blank">的下一篇文章</a>中，我将讨论如何对WasmEdge进行检测以支持C原生函数，然后将这些函数公开为Rust和JavaScript API。</p><p id="df95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本系列文章:</p><ul class=""><li id="09d7" class="ms mt in jm b jn jo jr js jv mu jz mv kd mw kh mx my mz na bi translated"><a class="ae ki" href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/" rel="noopener ugc nofollow" target="_blank">使用WasmEdge在WebAssembly中运行JavaScript</a></li><li id="dcd7" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated"><a class="ae ki" href="https://www.secondstate.io/articles/embed-javascript-in-rust/" rel="noopener ugc nofollow" target="_blank">将JavaScript整合到Rust应用中</a></li><li id="5cde" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated"><a class="ae ki" href="https://www.secondstate.io/articles/embed-rust-in-javascript/" rel="noopener ugc nofollow" target="_blank">使用Rust创建高性能JavaScript API</a></li><li id="56da" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated"><a class="ae ki" href="https://www.secondstate.io/articles/call-native-functions-from-javascript/" rel="noopener ugc nofollow" target="_blank">从JavaScript调用本地函数</a></li></ul><p id="f0e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">云原生WebAssembly中的JavaScript仍然是下一代云和边缘计算基础设施中的新兴领域。我们才刚刚开始！如果您有兴趣，请加入我们的<a class="ae ki" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> WasmEdge </a>项目(或者通过提出功能请求问题告诉我们您想要什么)。</p><p id="8442" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">更多内容看</em><a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>