<html>
<head>
<title>How to Implement Infinite Scroll Behavior</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现无限滚动行为</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-infinite-scroll-behavior-2dabff25901f?source=collection_archive---------9-----------------------#2021-08-03">https://javascript.plainenglish.io/implementing-infinite-scroll-behavior-2dabff25901f?source=collection_archive---------9-----------------------#2021-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="246d" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">学习反应JS</h2><div class=""/><div class=""><h2 id="bc9c" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">利用MDN的交叉观察器</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/025d30270f7c5f34f3fdab3537a419ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_CA8g6afHxBhYUaJMv2uQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@danfreemanphoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Dan Freeman</a> on <a class="ae lb" href="https://unsplash.com/s/photos/spiral?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0268" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在过去的一周里，我决定在我当前的项目中加入一个无限滚动的特性。任何在互联网上呆过哪怕是很短时间的人都可能熟悉这种行为。给定提要、新闻页面、列表等。，当用户滚动时，内容将持续加载，提供无缝的提要，直到用户查看了所有可用的数据或达到其他限制。</p><p id="8e37" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我知道<em class="ly">想要做什么</em>，但我不确定<em class="ly">如何</em>着手实现这个功能。我很高兴地发现MDN提供了一个名为<code class="fe lz ma mb mc b">IntersectionObserver</code>的API，这在这方面非常有帮助。学习这项技术已经在我的“待办事项”清单上有一段时间了，我很高兴现在已经把它添加到我的工具箱中。</p><h1 id="9bf7" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">可交付成果</h1><ul class=""><li id="1a03" class="mv mw in le b lf mx li my ll mz lp na lt nb lx nc nd ne nf bi translated">当用户第一次访问页面时，会加载一定数量的内容</li><li id="6896" class="mv mw in le b lf ng li nh ll ni lp nj lt nk lx nc nd ne nf bi translated">当用户向下滚动时，向服务器发出一个异步请求，返回下一批内容。</li><li id="1539" class="mv mw in le b lf ng li nh ll ni lp nj lt nk lx nc nd ne nf bi translated">附加内容被附加到页面的底部，允许用户无限地连续向下滚动(或者直到所有可用的内容都被显示)。</li></ul><h1 id="93a4" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">相关阅读</h1><p id="471a" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll nl ln lo lp nm lr ls lt nn lv lw lx ig bi translated">本演练要求对React refs有基本的了解。如果您不熟悉React中的引用，我建议您先阅读以下文章:</p><ul class=""><li id="ee13" class="mv mw in le b lf lg li lj ll no lp np lt nq lx nc nd ne nf bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/whats-a-ref-anyway-2a6979ad173f"> <strong class="le ix"> <em class="ly">到底什么是裁判？</em> </strong> </a></li><li id="238d" class="mv mw in le b lf ng li nh ll ni lp nj lt nk lx nc nd ne nf bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/understanding-callback-refs-107a21d831d7"> <strong class="le ix"> <em class="ly">理解回调引用</em> </strong> </a></li></ul><p id="c6f7" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">它们都是快速阅读，肯定会加深你对无限滚动的理解，并做出总体反应。阅读它们？好吧，酷。我们继续。</p><h1 id="f3eb" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">用另一个名称分页</h1><p id="34ac" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll nl ln lo lp nm lr ls lt nn lv lw lx ig bi translated">当你开始使用它时，无限滚动只是显示分页数据的另一种方式。分页将数据集合分解成不同的可管理的块，并按顺序向用户显示这些块。无限滚动的工作方式类似，但不是将块分成不同的页面，而是在用户滚动时异步加载内容，从而导致内容的无休止输入。</p><p id="4f18" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这意味着您对服务器的调用看起来像任何其他涉及分页的请求。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Standard Redux GET action to retrieve paginated data from an API back end.</figcaption></figure><h1 id="0226" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">观察十字路口</h1><p id="b657" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll nl ln lo lp nm lr ls lt nn lv lw lx ig bi translated">因此，我们有从后端请求数据的逻辑，但是我们如何知道何时发出这些请求呢？这就是MDN的<code class="fe lz ma mb mc b">IntersectionObserver</code>发挥作用的地方:</p><blockquote class="nt nu nv"><p id="d682" class="lc ld ly le b lf lg jx lh li lj ka lk nw lm ln lo nx lq lr ls ny lu lv lw lx ig bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交集观察器API </a>提供了一种异步观察目标元素与祖先元素或顶层文档的<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport" rel="noopener ugc nofollow" target="_blank">视口</a>交集变化的方法。</p></blockquote><p id="baed" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><code class="fe lz ma mb mc b">IntersectionObserver</code>构造函数接受一个回调函数，默认情况下，每当目标元素进入用户的视窗时，这个函数就会被执行。目标元素作为参数传递给一个<code class="fe lz ma mb mc b">entries</code>数组中的回调函数，以便根据需要记录或操作。</p><p id="4dd2" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="ly"> ( </em> <strong class="le ix"> <em class="ly">先不说:</em> </strong> <em class="ly">初始化观察者时，通过传递一个附加的</em> <code class="fe lz ma mb mc b"><em class="ly">options</em></code> <em class="ly">对象，可以微调交叉点事件触发的时间。查看</em> <a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver" rel="noopener ugc nofollow" target="_blank"> <em class="ly"> MDN的文档</em> </a> <em class="ly">了解更多信息)</em></p><p id="9ce4" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">当元素作为一个参数单独传递给观察者的<code class="fe lz ma mb mc b">.observe()</code>方法时，观察者会跟踪这些元素。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="ce87" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">将它并入React</h1><p id="2af8" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll nl ln lo lp nm lr ls lt nn lv lw lx ig bi translated">在本教程的帮助下，我将<code class="fe lz ma mb mc b">IntersectionObserver</code>合并到我的项目中。利用<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/understanding-callback-refs-107a21d831d7"> <strong class="le ix">回调引用</strong> </a>，我们可以将观察者与它可能正在观察的任何元素断开连接，然后创建一个新的<code class="fe lz ma mb mc b">IntersectionObserver</code>对象来观察页面上最后呈现的元素。<code class="fe lz ma mb mc b">observer</code>使用自己的回调函数，该函数递增本地状态中存储的<code class="fe lz ma mb mc b">pageNum</code>。结合前面显示的调度<code class="fe lz ma mb mc b">GET</code>请求的<code class="fe lz ma mb mc b">useEffect</code>钩子，你瞧，无限滚动！</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a6de" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">你在自己的一个项目中实现过无限滚动吗？如果是，您是否利用了上面显示的方法，或者实施了不同的策略？</p><p id="c34a" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="ly">更多内容请看</em><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ly">plain English . io</em></a></p></div></div>    
</body>
</html>