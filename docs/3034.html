<html>
<head>
<title>Visualization of Node.js Event Emitter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js事件发射器的可视化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/visualization-of-node-js-event-emitter-4f7c9fe3a477?source=collection_archive---------4-----------------------#2021-06-20">https://javascript.plainenglish.io/visualization-of-node-js-event-emitter-4f7c9fe3a477?source=collection_archive---------4-----------------------#2021-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="36f7" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">事件发射器的基本概述</h1><p id="318e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">正如我们所知，官方页面将Node.js描述为“一个异步的<strong class="kk io">事件驱动的</strong> JavaScript运行时。”</p><blockquote class="lg lh li"><p id="eec0" class="ki kj lj kk b kl lk kn ko kp ll kr ks lm ln kv kw lo lp kz la lq lr ld le lf ig bi translated">作为异步事件驱动的JavaScript运行时，Node.js旨在构建可伸缩的网络应用。</p></blockquote><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/faa7fb223533b0b54e35ac8c2079d257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MEjUfI9BIoCLdpkA9_FHTA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Basic of Event Emitter</figcaption></figure><p id="cc48" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated">EventEmitter是由events模块提供的对象。它将函数与事件绑定在一起。然后，这个绑定函数用于处理事件并相应地执行操作。我们可以在应用程序的任何部分发出事件，并有一个监听它的函数设置。</p><p id="c124" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io">观察者模式</strong>内置在节点js核心中，可以通过<strong class="kk io"> EventEmitter </strong>类获得。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h2 id="1c87" class="mp jl in bd jm mq mr dn jq ms mt dp ju kt mu mv jy kx mw mx kc lb my mz kg na bi translated">观察者模式</h2><p id="39de" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">观察者是一种行为模式，这意味着关注对象之间的通信。</p><p id="c6d6" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated">观察者模式有两个组成部分</p><ol class=""><li id="f8ce" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf ng nh ni nj bi translated"><strong class="kk io"> Subject </strong> —状态发生变化时能够通知的组件。</li><li id="9649" class="nb nc in kk b kl nk kp nl kt nm kx nn lb no lf ng nh ni nj bi translated"><strong class="kk io">观察者</strong> —可以监听主题通知的组件。</li></ol><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi np"><img src="../Images/c9c0634792809eeeea0696e248c30b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WmLlE4WI8z3nSVwIe6inA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Observer Pattern</figcaption></figure><p id="9eac" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io">观察者模式</strong>是一种<a class="ae nq" href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" rel="noopener ugc nofollow" target="_blank">软件设计模式</a>，其中一个名为<strong class="kk io">主题</strong>的<a class="ae nq" href="https://en.wikipedia.org/wiki/Object_(computer_science)#Objects_in_object-oriented_programming" rel="noopener ugc nofollow" target="_blank">对象</a>维护一个名为<strong class="kk io">观察者</strong>的依赖者列表，并自动通知它们任何状态变化，通常通过调用它们的<a class="ae nq" href="https://en.wikipedia.org/wiki/Method_(computer_science)" rel="noopener ugc nofollow" target="_blank">方法</a>之一。</p><div class="nr ns gp gr nt nu"><a href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">观察者模式-维基百科</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">观察者模式是一种软件设计模式，在这种模式中，一个名为subject的对象维护着它的…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">en.wikipedia.org</p></div></div><div class="od l"><div class="oe l of og oh od oi mc nu"/></div></div></a></div></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="456b" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io">event emitter的基本方法</strong></p><p id="d236" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io"> 1。on(事件，监听器)</strong></p><ul class=""><li id="cdda" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">将侦听器添加到指定事件的侦听器数组的末尾。</li></ul><pre class="lt lu lv lw gt ok ol om on aw oo bi"><span id="e0cb" class="mp jl in ol b gy op oq l or os">const EventEmitter = require('events')<br/><br/>const myEvent = new EventEmitter();<br/><br/>myEvent.on('test', () =&gt; console.log('Test from on'));<br/><br/>myEvent.prependListener('test', () =&gt; console.log('Test from prependListener'));<br/><br/>myEvent.emit('test');<br/><br/>// Prints:<br/>//   Test from on<br/>//   Test from prependListener</span></pre><ul class=""><li id="3702" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">默认情况下，事件侦听器按照添加的顺序被调用。可以使用<strong class="kk io">emitter . prepend listener()</strong>方法替代将事件监听器添加到监听器数组的开头。</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ot"><img src="../Images/f7cbf84454942f85683c9079c6086908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNgqxRrUzBs9jVY6CiegzA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><strong class="bd ou">on(event, listener)</strong></figcaption></figure><p id="9d2e" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io"> 2。一次(事件，听者)</strong></p><ul class=""><li id="4414" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">为事件添加一次性侦听器。该侦听器仅在下一次触发事件时被调用，之后将被移除。</li></ul><pre class="lt lu lv lw gt ok ol om on aw oo bi"><span id="0d3f" class="mp jl in ol b gy op oq l or os">const EventEmitter = require('events')<br/><br/>const myEvent = new EventEmitter();<br/><br/>myEvent.once('test', () =&gt; console.log('Test from once'));<br/><br/>myEvent.emit('test');<br/><br/>// Prints:<br/>//   Test from once</span></pre><ul class=""><li id="92c1" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">为名为eventName的事件添加一次性侦听器函数。下次触发eventName时，将删除该侦听器，然后调用它。</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ov"><img src="../Images/4e9d3a5103450ade98511e822696f081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aajj8QdvAgIYQc-hQyA5wQ.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><strong class="bd ou">once(event, listener)</strong></figcaption></figure><p id="d255" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io"> 3。emit(event，[arg1]，[arg2]，[…]) </strong></p><ul class=""><li id="e6b7" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">使用提供的参数按顺序执行每个侦听器。如果事件有侦听器，则返回true，否则返回false。</li></ul><pre class="lt lu lv lw gt ok ol om on aw oo bi"><span id="b1d0" class="mp jl in ol b gy op oq l or os">const EventEmitter = require('events')<br/><br/>const myEvent = new EventEmitter();<br/><br/>// First listener<br/>myEvent.on('test', () =&gt; {<br/>  console.log('First test listener');<br/>});<br/><br/>// Second listener<br/>myEvent.on('test', (arg1, arg2) =&gt; {<br/>  console.log(`Second test listener with parameters ${arg1}, ${arg2}`);<br/>});<br/><br/>// Third listener<br/>myEvent.on('test', (...args) =&gt; {<br/>  const parameters = args.join(', ');<br/>  console.log(`Third test listener with parameters ${parameters}`);<br/>});<br/><br/>myEvent.emit('test', 1,2,3);<br/><br/>// Prints : <br/>// First test listener<br/>// Second test listener with parameters 1, 2<br/>// Third test listener with parameters 1, 2, 3</span></pre><ul class=""><li id="c41a" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">按照注册顺序同步调用为名为eventName的事件注册的每个侦听器，并将提供的参数传递给每个侦听器。</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ow"><img src="../Images/fd467daeef14b7b5ccf138b2621aaa69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41FpLZ2HXjLz2IzJ0mEWew.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><strong class="bd ou">emit(event, [arg1], [arg2], […])</strong></figcaption></figure><p id="6ded" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io"> 4。removeListener(事件，监听器)</strong></p><ul class=""><li id="0408" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">从指定事件的侦听器数组中移除一个侦听器。</li></ul><pre class="lt lu lv lw gt ok ol om on aw oo bi"><span id="6276" class="mp jl in ol b gy op oq l or os">const EventEmitter = require('events');<br/><br/>const myEvent = new EventEmitter();<br/><br/>const callbackA = () =&gt; {<br/>  console.log('A');<br/>  myEvent.removeListener('event', callbackB);<br/>};<br/><br/>const callbackB = () =&gt; {<br/>  console.log('B');<br/>};<br/><br/>myEvent.on('event', callbackA);<br/><br/>myEvent.on('event', callbackB);<br/><br/>// callbackA removes listener callbackB but it will still be called.<br/>// Internal listener array at time of emit [callbackA, callbackB]<br/>myEvent.emit('event');<br/>// Prints:<br/>//   A<br/>//   B<br/><br/>// callbackB is now removed.<br/>// Internal listener array [callbackA]<br/>myEvent.emit('event');<br/>// Prints:<br/>//   A</span></pre><p id="dbe5" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io"> 5。remove all listeners([事件]) </strong></p><ul class=""><li id="6cd0" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">移除所有侦听器或指定事件的侦听器。</li><li id="b2bf" class="nb nc in kk b kl nk kp nl kt nm kx nn lb no lf oj nh ni nj bi translated">删除代码中其他地方添加的侦听器是一种不好的做法，特别是当EventEmitter实例是由其他组件或模块(例如套接字或文件流)创建的时候。</li></ul><p id="5c3d" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io"> 6。setMaxListeners(n) </strong></p><ul class=""><li id="38eb" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">默认情况下，如果为特定事件添加了10个以上的侦听器，EventEmitters将打印一条警告。</li></ul><pre class="lt lu lv lw gt ok ol om on aw oo bi"><span id="ffa4" class="mp jl in ol b gy op oq l or os">const EventEmitter = require('events')<br/><br/>const myEvent = new EventEmitter();<br/><br/>myEvent.on('test', () =&gt; console.log('Test from on'));<br/>myEvent.once('test', () =&gt; {<br/>  // do stuff<br/>  console.log('getMaxListeners Before', myEvent.getMaxListeners());<br/>  myEvent.setMaxListeners(Math.max(myEvent.getMaxListeners() - 1, 0));<br/>  console.log('getMaxListeners After', myEvent.getMaxListeners());<br/>});<br/>myEvent.emit('test');<br/><br/>// Prints :<br/>// Test from on<br/>// getMaxListeners Before 10<br/>// getMaxListeners After 9</span></pre><ul class=""><li id="4b2c" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">这是一个有用的缺省值，有助于发现内存泄漏。</li></ul><p id="f8fc" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io"> 7。监听器(事件)</strong></p><ul class=""><li id="b4c6" class="nb nc in kk b kl lk kp ll kt nd kx ne lb nf lf oj nh ni nj bi translated">返回指定事件的侦听器数组。</li><li id="e51a" class="nb nc in kk b kl nk kp nl kt nm kx nn lb no lf oj nh ni nj bi translated">返回名为eventName的事件的侦听器数组的副本。</li></ul><pre class="lt lu lv lw gt ok ol om on aw oo bi"><span id="e878" class="mp jl in ol b gy op oq l or os">const EventEmitter = require('events')<br/><br/>const myEvent = new EventEmitter();<br/><br/>myEvent.on('test', function testListeners() { console.log('Test the myEvent.listeners'); });<br/>myEvent.emit('test');<br/>const eventListeners = myEvent.listeners('test');<br/>console.log('listeners', eventListeners);<br/><br/>// Prints :<br/>// Test the myEvent.listeners<br/>// listeners [ [Function: testListeners] ]</span></pre></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="ff44" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io">参考文献</strong></p><div class="nr ns gp gr nt nu"><a href="https://nodejs.org/api/events.html" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">事件| Node.js v16.3.0文档</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">Node.js核心API的大部分都是围绕惯用的异步事件驱动架构构建的，其中某些种类…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">nodejs.org</p></div></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://refactoring.guru/design-patterns/observer" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd io gy z fp nz fr fs oa fu fw im bi translated">观察者</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">也称为:事件订阅者、侦听器观察者是一种行为设计模式，它允许您定义订阅…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">重构大师</p></div></div><div class="od l"><div class="ox l of og oh od oi mc nu"/></div></div></a></div><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="oy oz l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk"><strong class="ak">Essential methods of the EventEmitter</strong></figcaption></figure><p id="0e18" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><em class="lj">更多内容请看</em><a class="ae nq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="lj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>