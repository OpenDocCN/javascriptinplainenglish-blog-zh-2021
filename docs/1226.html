<html>
<head>
<title>A TypeScript Runtime Data Validators Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript运行时数据验证器比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-typescript-runtime-data-validators-comparison-eeedc6b0583a?source=collection_archive---------5-----------------------#2021-03-15">https://javascript.plainenglish.io/a-typescript-runtime-data-validators-comparison-eeedc6b0583a?source=collection_archive---------5-----------------------#2021-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="15fb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:io-ts</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cc708dd902314af51a3e40f3bad469cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cK4Fn7OnF5m7eNtGmMt71A.jpeg"/></div></div></figure><p id="9418" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是基于我的实践经验的运行时数据验证器比较系列报告的第二篇。在继续本系列的其余部分之前，您应该阅读第一篇文章中的介绍，以理解制作该报告所涉及的目标和测试方法。</p><ol class=""><li id="b685" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-50a6abf3c559">简介</a></li><li id="effe" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">io-ts</li><li id="c4bd" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-c422e431926a"> joi </a></li><li id="dda3" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-15f0ea2e3265">没错</a></li><li id="0f65" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-cdbb532f0b89"> ajv </a></li><li id="436f" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-92887e22ee65">佐德</a></li><li id="442e" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-67cb9abb599b">超级结构</a></li></ol><h1 id="9383" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">介绍</h1><p id="e831" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated"><a class="ae lt" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>是一个“运行时型io解码/编码系统”。它的创建者gcanti还为TypeScript中的类型函数编程创建了流行的库“fp-ts”。“fp-ts”是“io-ts”的对等依赖。“io-ts”和“fp-ts”都属于函数式编程范式。没有“fp-ts”和对函数式编程概念的一些理解，“io-ts”真的不能使用。</p><h1 id="0428" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">设计目标的实现</h1><h2 id="8d81" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">1.一个定义，多种用途——通过小故障实现</h2><p id="b3c8" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">静态TypeScript类型可以使用TypeOf运算符从运行时模式(在io-ts中称为“编解码器”)中推断出来。下面显示了如何定义“Person”模式，以及如何从中推断出相应的TypeScript类型。注意“fp-ts”中“管道”的使用和代码的函数式编程风格。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/880c09a0c94aae6eef8478ee262d2dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBFm2SrCFx5cqn8HFmF82g.png"/></div></div></figure><p id="3fdf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在VS代码中，将鼠标光标移动到推断出的类型上会显示其详细信息。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/7d349b4cebcf55e9696739f7416c7a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*slXcuk3TrM0ODpyvTOWSJA.png"/></div></figure><p id="17bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，推断的类型并不尽可能好地匹配运行时架构。“sex”属性应该是可选的，并且可以作为文字类型的联合(' M'|'F'|'O ')而不是字符串类型。</p><h2 id="e236" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">2.可组合和可扩展的模式—已实现</h2><p id="53be" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">“驱动程序”模式是通过扩展“人员”模式来定义的，无需重新定义其中的属性。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/570c98359a93894a0f3e71bf051ba7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*vcG6xN9EL4MVPfmzm3Q3JA.png"/></div></figure><p id="3944" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“车队”模式是通过组装“驾驶员”和“车辆”模式来定义的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/fb191d11c360c443c11090530ba4ffd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*AQVQiGqOWjCXPSq6e5Mmvg.png"/></div></figure><h2 id="60fb" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">3.丰富的功能集—不太丰富</h2><p id="36cc" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">一些常见的验证特性，比如要求最小/最大字符串长度和匹配字符串模式，并不是现成的。它们需要由自定义的“refine”来提供。</p><h2 id="42dd" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">4.完成和中止-早期验证-仅完成验证</h2><p id="f577" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">io-ts完成验证并返回一个包含输入数据中所有失败的结果对象。然而，有用的信息隐藏在无数的包装器中，需要一个报告器(提供了默认的报告器)来检索和利用这些信息。</p><p id="2a96" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在io-ts文档中没有提到提前中止验证。</p><h2 id="c0e7" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">5.可组合和可定制—存档</h2><p id="32ea" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">请参见“人员”模式。io-ts中的验证“解码器”可以通过“管道”或其他组合符(如“联合”和“细化”)进行组合。您还可以定义自定义解码器或“细化”。</p><p id="2548" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是一个自定义的“优化”,用于验证字符串是否有最小长度。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/81ad18c053dfa73d3c99a35100b7762e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nx_EcwmsJdXgyPuRPPIXhw.png"/></div></div></figure><h2 id="19bc" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">6.类型强制和默认—已实现</h2><p id="5e11" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">类型强制和默认值都可以通过编写自定义的“解析”组合子来实现。“解析”组合子可以接收输入类型的值，并输出不同类型的值。下面是用于提供默认值的“withDefault”组合器。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f3b56b9a75a016491dfa5f75afc42015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*dEdUyZDm9tAk4i9ltkFu-A.png"/></div></figure><h2 id="09cc" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">7.可遍历模式-未实现</h2><p id="419a" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">我只是不知道如何从io-ts解码器中遍历和提取信息。</p><h2 id="18dc" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">8.标准—否</h2><h1 id="71c4" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">摘要</h1><p id="5cea" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">io-ts非常灵活，但对函数式编程也非常固执，甚至将函数式编程的纯粹性置于流畅的开发人员体验之上。它的文档有点稀疏，缺乏细节。要使用io-ts，你确实不能避免使用fp-ts和函数式编程。如果你不熟悉函数式编程概念，姑且说它确实有一个学习曲线。</p><p id="77de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一方面，如果你是一个坚持严格的函数式编程规则的人，io-ts和fp-ts对你来说都可能是一个不错的选择。</p><p id="1df3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="no">代表</em> <a class="ae lt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="no">团队，感谢阅读。</em></strong></a></p></div></div>    
</body>
</html>