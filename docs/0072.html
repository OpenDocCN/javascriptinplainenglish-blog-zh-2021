<html>
<head>
<title>What are Binary Search Algorithms?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是二分搜索法算法？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-word-on-binary-search-241df807761e?source=collection_archive---------29-----------------------#2021-01-04">https://javascript.plainenglish.io/a-word-on-binary-search-241df807761e?source=collection_archive---------29-----------------------#2021-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bb34ad9b35a263f979eb3ef68c1aef6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vKz-FFqF4E3pLBbm.jpg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Binary Search — Chopping things in half over and over again</figcaption></figure><p id="1921" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">新年的第一周，我一直在研究的最相关的算法之一是二分搜索法算法。二分搜索法就是这样一种有用的算法，因为它有效地使事情更容易找到，并且不会太复杂而难以理解。从另一个角度来看，这有点像一遍又一遍地把一根木头劈成两半，直到你到达你想要的劈砍点。具体就二分搜索法而言，这一理想点将是我们的目标数字点。</p><h1 id="e330" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">二分搜索法到底是什么？</h1><p id="9698" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">二分搜索法的意思是，在一组排序有序的事物中，也许是一组数字，将该组的中间值与您试图搜索的事物(目标)进行比较，以查看这两者是否匹配。如果它们是匹配的，那么你已经找到了你一直在寻找的东西，但是如果不是，那么排序后的组被切成两半，并且只观察适用于中间与目标如何比较的任何一边。例如，如果你要找的东西比中间值大，那么你应该看右边，因为那里有更大的东西。</p><p id="20b2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">实现这一概念的一个简单例子是:</p><p id="7b03" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们在这个数组的5个数字列表中寻找数字4(目标):</p><p id="eaa9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi">[1, 2, 3, 4, 5].</p><p id="d125" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先你可以看中间，看到3是中间的数字。3比4小，3比4小。因为这些数字是有序的，所以从3的右边寻找更大的数字4是有意义的。1和2被淘汰现在4是[3，4，5]的新中间，等于我们要找的目标。</p><p id="72a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在进行一些编码。我将一步一步地讲述我是如何使用JavaScript解决二分搜索法算法的，并像往常一样尽可能地简化这个过程。</p><h1 id="706d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">问题是</h1><p id="61db" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">编写一个函数，它接受一个排序的整数数组和一个目标数，并使用二分搜索法算法来确定目标数是否在数组中。如果是，那么函数应该返回目标数字的索引。如果不是，则返回-1。</p><h1 id="7350" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解决方案</h1><p id="f481" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">首先使用关键字函数，我将我们的函数称为binarySearch函数，并给它上面列出的输入；一个数组和一个目标数。此外，为了使用二分搜索法风格的算法，我们需要两个指针，即左指针和右指针。这些变量将代表数组中每一边的索引。左边代表第一个数字，右边代表最后一个数字。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fd49" class="mj ky in mf b gy mk ml l mm mn">function binarySearch(array, target) {</span><span id="52dd" class="mj ky in mf b gy mo ml l mm mn">  let left = 0<br/>  let right = array.length-1</span></pre><p id="fa27" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此时，我将使用for循环来遍历数组中的所有数字，以应用我们的逻辑。接下来是初始化一个中间变量，该变量使用Math.floor赋值。Math.floor会将我们的结果向下舍入到小于或等于括号中值的最大整数。在括号中，我们将把左指针和右指针的索引加在一起，然后除以2得到平均值，这个值大约在数组的中间。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="703c" class="mj ky in mf b gy mk ml l mm mn">function binarySearch(array, target) {</span><span id="de99" class="mj ky in mf b gy mo ml l mm mn">  let left = 0<br/>  let right = array.length-1</span><span id="c9fa" class="mj ky in mf b gy mo ml l mm mn">  for (let i=0; i&lt;array.length; i++){<br/>   let middle = Math.floor((left+right) / 2)</span></pre><p id="6c82" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在下一阶段，我们将编写一个if语句，检查数组中间的数字是否与目标数字相同。如果是，那么我们已经找到了我们要找的数字，所以我们将返回该数字的索引。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b483" class="mj ky in mf b gy mk ml l mm mn">function binarySearch(array, target) {</span><span id="b035" class="mj ky in mf b gy mo ml l mm mn">  let left = 0<br/>  let right = array.length-1</span><span id="4071" class="mj ky in mf b gy mo ml l mm mn">  for (let i=0; i&lt;array.length; i++){<br/>   let middle = Math.floor((left+right) / 2)<br/>   if(array[middle] === target){<br/>     return array.indexOf(target)</span></pre><p id="9630" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果我们没有找到我们要寻找的目标数，那么下一步我们就必须遍历下面写的else if语句。这两者是相反的，因为在这一点上我们可以有两种可能性。我们寻找的目标要么比中间的数字小，要么比中间的数字大。</p><p id="02cf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第一个else if条件声明，如果中间的数字大于目标值，则将右边的变量赋给中间的左边。当我们把现在看到的数字移到左边时，这就是“削波”开始的地方。</p><p id="a854" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如前所述，第二个else if条件正好相反。如果目标数字高于中间的数字，那么我们需要将左边的变量从中间第一个右边的空格开始赋值。在这种情况下,“削波”应该在右边。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f1b2" class="mj ky in mf b gy mk ml l mm mn">function binarySearch(array, target) {</span><span id="b9d3" class="mj ky in mf b gy mo ml l mm mn">let left = 0<br/>let right = array.length-1<br/>for (let i=0; i&lt;array.length; i++){<br/>  let middle = Math.floor((left+right) / 2)<br/>  if(array[middle] === target){<br/>   return array.indexOf(target)<br/>  } else if (array[middle] &gt; target){<br/>   right = middle-1<br/>  } else if (array[middle] &lt; target){<br/>   left = middle +1<br/>  }</span></pre><p id="b136" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">只有一种可能性，如果我们的if条件都不满足。那就是我们要找的数字在我们的数组中不存在。如果是这样，根据问题陈述，我们需要返回-1并关闭我们的函数，如下所示。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f83d" class="mj ky in mf b gy mk ml l mm mn">function binarySearch(array, target) {</span><span id="07c5" class="mj ky in mf b gy mo ml l mm mn">let left = 0<br/>let right = array.length-1<br/>for (let i=0; i&lt;array.length; i++){<br/>  let middle = Math.floor((left+right) / 2)<br/>  if(array[middle] === target){<br/>   return array.indexOf(target)<br/>  } else if (array[middle] &gt; target){<br/>   right = middle-1<br/>  } else if (array[middle] &lt; target){<br/>   left = middle +1<br/>  }<br/>}<br/> return -1<br/>}</span></pre><p id="5ec9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这就是我们算法的结尾。我发现理解这个算法是理解比这个更难的算法的关键之一。在学习如何对数据进行排序以获得所需结果的模式时，二分搜索法算法是需要真正掌握的最基本的概念之一，所以我鼓励其他人花时间去理解它。感谢您阅读本指南，祝您新年快乐，充满新的机遇。</p></div></div>    
</body>
</html>