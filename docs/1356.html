<html>
<head>
<title>How to Avoid Object Mutation in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免JavaScript中的对象突变</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-how-to-avoid-object-mutation-7cd733913a9f?source=collection_archive---------3-----------------------#2021-03-22">https://javascript.plainenglish.io/javascript-how-to-avoid-object-mutation-7cd733913a9f?source=collection_archive---------3-----------------------#2021-03-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c3b0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">避免JavaScript中对象变异的三种快速方法&amp;免费的乔恩·斯图尔特gif</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b7870491c318580b6764c7f7deb3e0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0xkxN1CWjQp4RlB1"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Possessed Photography</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b02e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我最近写了JavaScript中的<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/javascript-mutable-vs-immutable-1efb662d78c8">可变数据和</a>不可变数据。我用来展示对象可变性的例子是这样的:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="9f99" class="lu lv in lq b gy lw lx l ly lz">let character = {<br/>    firstName: 'Captain',<br/>    lastName: 'America'<br/>}</span><span id="16ff" class="lu lv in lq b gy ma lx l ly lz">let avenger = character;</span><span id="8c7c" class="lu lv in lq b gy ma lx l ly lz">character.lastName = 'Marvel';</span><span id="e3f0" class="lu lv in lq b gy ma lx l ly lz">console.log(avenger.lastName);</span></pre><p id="001b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我让读者猜猜控制台上打印了什么(是<code class="fe mb mc md lq b">// Marvel</code> btw ),这让我想到了避免对象突变的方法。</p><p id="40e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有一些方法可以避免我们最初的<code class="fe mb mc md lq b">character</code>对象发生变异:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="ff3c" class="lu lv in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">1.创建新对象</h2><p id="2d84" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">这似乎是显而易见的，但你总是可以创建一个新的对象！这可能需要多几行代码，但是这样，当你需要改变一个对象，并且在内存中有多个变量指向同一个对象时，你就可以避免麻烦。对于我们的对象，我们甚至可以将存储在<code class="fe mb mc md lq b">character.firstName</code>的值用于<code class="fe mb mc md lq b">avenger</code>指向的新对象。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="1f91" class="lu lv in lq b gy lw lx l ly lz">let character = {<br/>    firstName: 'Captain',<br/>    lastName: 'America'<br/>};</span><span id="eec7" class="lu lv in lq b gy ma lx l ly lz">let avenger = {<br/>    firstName: character.firstName,<br/>    lastName: 'Marvel'<br/>};</span><span id="df8b" class="lu lv in lq b gy ma lx l ly lz">character.firstName === avenger.firstName;</span><span id="b87e" class="lu lv in lq b gy ma lx l ly lz">// true</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc mf l"/></div></figure><h2 id="4241" class="lu lv in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">2.<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"> Object.assign( ) </a></h2><p id="29e2" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">随着<a class="ae ks" href="https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_%E2%80%93_ECMAScript_2015" rel="noopener ugc nofollow" target="_blank"> ES6 </a>的引入，JS给了我们使用这种方法将所有属性从一个对象复制到另一个对象的能力。<strong class="kv io">如果使用不当，该方法会使对象变异。我想说清楚这一点。通过在目标参数中提供一个空对象，可以很容易地避免改变对象。<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#description" rel="noopener ugc nofollow" target="_blank"> MDN </a>总是支持我们应对故障:</strong></p><blockquote class="nd ne nf"><p id="0279" class="kt ku ng kv b kw kx jo ky kz la jr lb nh ld le lf ni lh li lj nj ll lm ln lo ig bi translated">如果目标对象中的属性具有相同的<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" rel="noopener ugc nofollow" target="_blank">键</a>，则它们会被源中的属性覆盖。较新的源的属性会覆盖较早的属性。</p></blockquote><p id="eaad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了避免分配给<code class="fe mb mc md lq b">character</code>变量的对象发生突变，使用<code class="fe mb mc md lq b">Object.assign()</code>方法，我们执行以下操作:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="792f" class="lu lv in lq b gy lw lx l ly lz">let character = {<br/>    firstName: 'Captain',<br/>    lastName: 'America'<br/>};</span><span id="04ed" class="lu lv in lq b gy ma lx l ly lz">let avenger = Object.assign({}, character);<br/>avenger.lastName = 'Marvel';</span></pre><p id="ed74" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的代码将创建一个分配给<code class="fe mb mc md lq b">avenger</code>变量的新对象，然后我们将把<code class="fe mb mc md lq b">lastName</code>属性更改为字符串<code class="fe mb mc md lq b">‘Marvel’</code>，以获得我们想要的结果，而不改变分配给<code class="fe mb mc md lq b">character</code>变量的原始对象。但是，我们实际上可以通过执行以下操作，在<code class="fe mb mc md lq b">Object.assign()</code>方法中一举获得我们想要的结果:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="6627" class="lu lv in lq b gy lw lx l ly lz">let character = {<br/>    firstName: 'Captain',<br/>    lastName: 'America'<br/>};</span><span id="e3d0" class="lu lv in lq b gy ma lx l ly lz">let avenger = Object.assign({}, character, { lastName: 'Marvel' });</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="f970" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ng">边注:我想再迭代一次使用</em> <code class="fe mb mc md lq b">Object.assign()</code>时，传入空对象作为第一个参数(目标参数)的重要性。<em class="ng">使用该方法时，返回目标对象。所以，如果你给一个对象分配了属性，你就有可能改变这个对象。请看下面的例子来了解这一点:</em></p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="39ea" class="lu lv in lq b gy lw lx l ly lz">let character = {<br/>    firstName: 'Captain',<br/>    lastName: 'America'<br/>};</span><span id="6a49" class="lu lv in lq b gy ma lx l ly lz">let avenger = Object.assign({}, character, { lastName: 'Marvel' });</span><span id="a4ab" class="lu lv in lq b gy ma lx l ly lz">let newAvenger = Object.assign(avenger, { firstName: 'Ms.; });</span><span id="009c" class="lu lv in lq b gy ma lx l ly lz">console.log(avenger);<br/>console.log(newAvenger);</span><span id="3a14" class="lu lv in lq b gy ma lx l ly lz">// { firstName: 'Ms.',<br/>     lastName: 'Marvel<br/>   }</span><span id="5b74" class="lu lv in lq b gy ma lx l ly lz">// { firstName: 'Ms.',<br/>     lastName: 'Marvel'<br/>   }</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl mf l"/></div></figure><p id="dcaa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ng">从乔恩的困惑中可以看出，我们对分配给</em> <code class="fe mb mc md lq b">avenger</code> <em class="ng">变量的目标对象进行了变异。我们现在有两个变量(</em><code class="fe mb mc md lq b">avenger</code><em class="ng">&amp;</em><code class="fe mb mc md lq b">newAvenger</code><em class="ng">)分配给内存中的这个对象，这不是我们想要的结果。现在，当我们使用任何一个变量来分配新的属性或属性值时，我们都有可能在没有意识到的情况下改变这个对象。</em></p><h2 id="c3dc" class="lu lv in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">3.<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">传播语法</a></h2><p id="999f" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">最后，为了一些语法上的好处，我们使用了spread操作符。你看到的是同样的想法，但我觉得更悦目一些。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="382c" class="lu lv in lq b gy lw lx l ly lz">let character = {<br/>    firstName: 'Captain',<br/>    lastName: 'America'<br/>};</span><span id="dec9" class="lu lv in lq b gy ma lx l ly lz">let avenger = { ...character };<br/>avenger.lastName = 'Marvel';</span></pre><p id="facc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这比前面的方法要简单得多，并且达到了相同的效果！但是，(<em class="ng">我打赌你已经预见到了这一点</em>)我们可以像这样使用spread运算符来获得相同的结果:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="2a23" class="lu lv in lq b gy lw lx l ly lz">let character = {<br/>    firstName: 'Captain',<br/>    lastName: 'America'<br/>};</span><span id="335f" class="lu lv in lq b gy ma lx l ly lz">let avenger = { ...character, lastName: 'Marvel' };</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm mf l"/></div></figure></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="03da" class="nu lv in bd mg nv nw nx mj ny nz oa mm jt ob ju mp jw oc jx ms jz od ka mv oe bi translated">结论</h1><p id="ce48" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">易变的对象，和突变，不必害怕。这可能会变得棘手，但总而言之，有许多不同的方法来避免变异对象。我希望这是有帮助的，如果你想到任何其他方法来避免突变，请告诉我。</p><p id="d39c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">快乐编码🤓</p></div></div>    
</body>
</html>