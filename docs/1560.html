<html>
<head>
<title>Introduction To Angular Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度可观测量介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-angular-observables-38dbe00dfa30?source=collection_archive---------7-----------------------#2021-04-03">https://javascript.plainenglish.io/introduction-to-angular-observables-38dbe00dfa30?source=collection_archive---------7-----------------------#2021-04-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b0e814215f580b2945b428d98bd6625a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*as7i9RuiV3KJgIBY"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@freddymarschall?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Freddy Marschall</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fe1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Angular中，可观察对象是从名为<code class="fe ky kz la lb b">rxjs</code>的包中导入的对象。</p><p id="ff54" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用简单的话来定义一个可观察对象，我们可以说一个<strong class="kc io">可观察对象</strong>是数据发出的来源。此外，还有一个<strong class="kc io">观察器</strong>，用于观察由可观察对象发出的任何数据包。在可观测者和观察者之间，有一个由可观测者发射多个事件的流。</p><p id="2a43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可观察对象可以在各种情况下发出数据包。其中一些列举如下:</p><ul class=""><li id="11d4" class="lc ld in kc b kd ke kh ki kl le kp lf kt lg kx lh li lj lk bi translated">开发人员已经以编程方式配置了可观察对象来发出数据。</li><li id="c9b7" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">在Angular HTTP中，可观察对象与HTTP请求相链接。当响应到来时，它作为数据包发出。</li><li id="76b2" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">observable被配置为在用户输入时发出数据，如按钮点击、悬停等。</li></ul><p id="f10e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可观察对象发出的数据包是三种类型的通知，可以通过三种方式使用回调来处理</p><ol class=""><li id="8081" class="lc ld in kc b kd ke kh ki kl le kp lf kt lg kx lq li lj lk bi translated"><code class="fe ky kz la lb b">next</code> —它是每个交付值的处理程序。在执行开始后调用零次或多次。</li><li id="e6f4" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lq li lj lk bi translated"><code class="fe ky kz la lb b">error</code> —它是一个错误通知的处理程序。一个错误中止了可观察实例的执行。</li><li id="7ef7" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lq li lj lk bi translated"><code class="fe ky kz la lb b">complete</code> —是执行完成通知的处理程序。执行完成后，延迟值可以继续传递给下一个处理程序。</li></ol><p id="cf4b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上述三种方法中的第一种方法(即<code class="fe ky kz la lb b">next</code>)开始，我们编写代码，当我们接收到一个新的数据包时做一些事情。在第二种方法(即<code class="fe ky kz la lb b">error</code>)中，我们编写代码在收到错误消息时做一些事情。在第三种方法中(即<code class="fe ky kz la lb b">complete</code>)，我们编写代码在可观察完成时做一些事情。</p><p id="4d9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">HTTP可观察对象是一种可以发出所有三种类型通知的可观察对象。但是附属于用户输入(如按钮点击等)的可观察的。)永远不会完成。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="149b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们借助一个例子来理解这个概念。在本例中，我们将创建一个可观察对象，并模拟处理观察对象发出的数据包的所有三种方式。</p><p id="3f5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们将打开终端，使用命令— <code class="fe ky kz la lb b">ng new exercise</code>初始化一个名为<code class="fe ky kz la lb b">exercise</code>的新angular项目。然后我们将导航到<code class="fe ky kz la lb b">exercise</code>文件夹。</p><p id="08ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，Angular将生成一个<code class="fe ky kz la lb b">app</code>组件。然后，我们将使用命令<code class="fe ky kz la lb b">ng g c comp-one</code>生成另一个组件。</p><p id="1941" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们的<code class="fe ky kz la lb b">app</code>目录将如下所示:</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/510094795dcb8dc606c169db6686e902.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*so30atwIJOTw1pQkJkuBGw.png"/></div></figure><p id="afed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们将打开<code class="fe ky kz la lb b">app-routing.module.ts</code>文件，并编写以下代码:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="bf94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的文件设定了我们的路线。</p><p id="117e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe ky kz la lb b">app.component.html</code>文件中，我们必须按如下方式放置路由器出口——</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e432" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们将为<code class="fe ky kz la lb b">comp-two.component.ts</code>文件中的可观察对象编写代码。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="0814" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当上述组件被初始化时，它将创建一个可观察的对象，该对象每秒都会发出数据，并通过订阅该可观察的对象来接收数据。</p><p id="9ad7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们将在<code class="fe ky kz la lb b">comp-one.component.html</code>文件中创建一个按钮，它将打开<code class="fe ky kz la lb b">comp-two</code>，结果，它将创建可观察的。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="a6b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们将在<code class="fe ky kz la lb b">comp-two.component.html</code>文件中创建另一个按钮，这将把用户带回到<code class="fe ky kz la lb b">comp-one</code>。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="9081" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们使用命令<code class="fe ky kz la lb b">ng serve</code>运行我们的应用程序，那么我们可以看到下面的结果:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mf me l"/></div></figure><p id="1a1b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这段视频中，我们观察到当我们第一次打开<code class="fe ky kz la lb b">comp-two</code>时，可观察到的东西被创建了，因为它开始将数据记录到控制台中。但是当我们离开这个组件时，可观察到的仍在发出数据。当我们再次打开这个组件时，一个新的可观察到的东西和旧的一起被创建了。这就是内存泄漏发生的方式。为了防止这种情况，一旦组件被破坏，我们就必须取消订阅可观察到的东西。</p><p id="6d0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为解决上述问题，我们对<code class="fe ky kz la lb b">comp-two.component.ts</code>文件做如下修改:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="fff6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们再次运行应用程序，我们将得到以下结果——</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mg me l"/></div></figure></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="dd71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在前面的例子中，我们用<code class="fe ky kz la lb b">next</code>方法处理发射的数据只是因为我们知道<code class="fe ky kz la lb b">setInterval</code>不会产生任何错误。但是在HTTP请求的情况下，我们可能会得到错误。所以，我们必须妥善处理它们。</p><p id="8cbc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们通过在前面的例子中创建我们自己的错误来理解错误处理部分。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b744" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述修改将产生以下输出:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mf me l"/></div></figure><p id="15ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，可观察到的将会发出一条错误消息，但是我们没有正确处理。所以，现在我们会妥善处理。为此，我们必须在代码中进行以下修改:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="98df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过进行上述修改，我们将得到以下结果——</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mf me l"/></div></figure><blockquote class="mh mi mj"><p id="9ba6" class="ka kb mk kc b kd ke kf kg kh ki kj kk ml km kn ko mm kq kr ks mn ku kv kw kx ig bi translated">我们必须注意的是，当一个可观测值发出错误时，它<strong class="kc io">会抵消</strong>该可观测值。</p></blockquote></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="9736" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像HTTP observables在请求-响应周期完成后发出一条完整的消息一样，我们将在下面的例子中通过修改<code class="fe ky kz la lb b">comp-two.component.ts</code>中的代码来模拟同样的情况。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1028" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行应用程序后，我们将得到以下结果:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="mf me l"/></div></figure></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="2cc3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">参考</strong>:【https://angular.io/guide/observables】T2—角度可观测量</p><p id="9766" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mk">更多内容尽在</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>