<html>
<head>
<title>One Thing People Forget About Recursive Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人们忘记了JavaScript中递归函数的一件事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-most-important-thing-about-recursive-functions-in-javascript-5f71147ea9ba?source=collection_archive---------13-----------------------#2021-06-14">https://javascript.plainenglish.io/the-most-important-thing-about-recursive-functions-in-javascript-5f71147ea9ba?source=collection_archive---------13-----------------------#2021-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5d0337ff218b6bbdfa8baea8a48878bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s1TQNoHEBx2fzvAY"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="ka"><p id="fac0" class="kb kc in bd kd ke kf kg kh ki kj kk dk translated">“要理解递归，首先必须理解递归”——斯蒂芬·霍金</p></blockquote><p id="e9b8" class="pw-post-body-paragraph kl km in kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh kk ig bi translated">递归有许多陷阱。大多数JavaScript开发人员在遇到特定问题之前甚至不会考虑使用它。递归函数很少受到关注，尤其是在JavaScript中，因为有一些很大的性能限制。</p><p id="f789" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">在本文中，我将介绍什么是递归函数，与经典迭代相比有什么优势，以及使用递归函数时您可能永远不会忘记的一件事。</p><h1 id="a1ff" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">什么是递归函数？</h1><p id="7cdc" class="pw-post-body-paragraph kl km in kn b ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh kk ig bi translated">如果你已经知道这一点，请随意跳到下一部分。对于其他任何人来说，<em class="mq">递归函数是称自己为</em>的函数。使用递归的一个经典例子是生成行Fibonacci (0，1，1，2，3，5，…)。考虑这个函数:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6af8" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">你看到这里发生了什么吗？斐波那契函数正在调用自己。例如，如果我们调用<em class="mq"> fibonacci(3) </em>，我们的响应将是2。如果我们从视觉上来看，情况是这样的:</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/024f29e7930594b51f49590c98855c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvKA_FpvHGIMSVwQZ9hpHw.png"/></div></div></figure><p id="1ede" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">或者如果我们从调用堆栈的角度来看:</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/96bb0cdb738e4be232357cfee6f6607c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2mviFgF7HNRGgyeAmXygg.png"/></div></div></figure><p id="1e69" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">我们调用参数值为3的函数。该函数将首先调用<em class="mq">Fibonacci(3–2)，</em>，这将返回一个整数值1。该函数返回，然后将执行<em class="mq">Fibonacci(3–1)</em>调用<em class="mq"> </em>，这又需要使用参数0和1再调用<em class="mq"> fibonacci </em>函数2次。然后堆栈最终会收缩，直到我们回到原来的函数中，函数调用返回2。</p><p id="da71" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">虽然这是一个非常简单的例子，但是我希望您能够理解递归函数所代表的意思。你可能在想:这很好，但在现实世界中有什么用呢？</p><h1 id="9a77" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">与经典迭代相比的真实用例及优势。</h1><p id="46b0" class="pw-post-body-paragraph kl km in kn b ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh kk ig bi translated">当我准备撰写本文时，我问我的开发人员朋友，他们在过去几年中是否使用了很多递归。反应是明确的。他们都用过一两次，大多数人只是抄袭了StackOverflow的剧本。</p><p id="7554" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">那么有哪些使用递归的例子呢？这里有一个小清单。</p><ul class=""><li id="726c" class="mz na in kn b ko li ks lj kw nb la nc le nd kk ne nf ng nh bi translated">递归循环遍历目录，对文件和目录执行CRUD操作。</li><li id="b29a" class="mz na in kn b ko ni ks nj kw nk la nl le nm kk ne nf ng nh bi translated">排序算法(快速排序等)</li><li id="f210" class="mz na in kn b ko ni ks nj kw nk la nl le nm kk ne nf ng nh bi translated">在HTML和XML中导航</li><li id="02df" class="mz na in kn b ko ni ks nj kw nk la nl le nm kk ne nf ng nh bi translated">游戏开发中的碰撞检测</li><li id="9dd9" class="mz na in kn b ko ni ks nj kw nk la nl le nm kk ne nf ng nh bi translated">内容管理系统中的面包屑生成</li><li id="a1eb" class="mz na in kn b ko ni ks nj kw nk la nl le nm kk ne nf ng nh bi translated">解决数独游戏😄</li></ul><p id="1154" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">有很多例子，传统的函数式程序员会更喜欢递归，因为它更具声明性。在我们的代码中，状态是在调用堆栈中捕获的，而不是显式地循环和保存状态。如果条件决策或<a class="ae jz" href="https://www.geeksforgeeks.org/backtracking-introduction/" rel="noopener ugc nofollow" target="_blank">回溯</a>是必要的，递归是非常有趣的。</p><p id="df74" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">我并不主张你应该用递归来代替所有的for循环。如果一个for循环变得太复杂，尝试将你的逻辑封装在递归函数中可能是明智的，对于下一个必须阅读你的代码的人来说，它们可能更容易理解。</p><h1 id="c129" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">你永远不应该忘记的事情</h1><p id="ec5c" class="pw-post-body-paragraph kl km in kn b ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh kk ig bi translated">当我们在屏幕后面递归调用函数时，我们的调用堆栈会增长。这在上图中可以看到。如果我们调用整数值为100，000的<em class="mq">斐波那契</em>函数会怎么样。对我们的申请有什么影响？</p><p id="5436" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">在JavaScript中，如果引擎认为调用堆栈增长过多，应该停止，它就会介入。你会看到，你会得到一个叫做<strong class="kn io">范围误差的东西。</strong>不像其他一些语言，没有硬性限制。当引擎认为内存使用因调用堆栈的大量增长而失去控制时，它将介入。</p><p id="8999" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">但是如果你真的想得到斐波那契数列的第100，000个值，是不是不可能用递归函数计算出来呢？</p><h2 id="5b2a" class="nn lo in bd lp no np dn lt nq nr dp lx kw ns nt mb la nu nv mf le nw nx mj ny bi translated">尾部呼叫</h2><p id="1e8d" class="pw-post-body-paragraph kl km in kn b ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh kk ig bi translated">进来的时候，尾巴在叫。尾部调用不是JavaScript特有的，它们是优化递归函数的通用技术。</p><p id="3b49" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">其思想是，如果从递归函数的最后一行调用一个函数，调用函数可以从调用堆栈中删除。</p><p id="ae13" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">例如，考虑这个函数:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="45d8" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">它会将从1到某个特定数字的所有数字相加，因此，例如，对于3，结果将是3 + 2 + 1 = 6。在调用堆栈中，这将如下所示:</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/d49cd09ef8bd64b5c6f51b02653b26e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5AdrElXExwpE4HzFrPLnkQ.png"/></div></div></figure><p id="e13e" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">当编程语言实现尾部调用时，实际发生情况是这样的:</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/f321e82f6fe02b369515254164422d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2G9PaPJVIB8uB2UIIfIf6Q.png"/></div></div></figure><p id="e18c" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">而不是必须跟踪调用函数。尾部调用优化语言将从调用堆栈中删除调用函数，最终只返回最后一个被调用函数的结果。<strong class="kn io">只有当调用函数有一个返回语句，其中只调用一个函数</strong>时，这才有可能。如果函数有一个类似于<em class="mq">的返回语句，返回1+sumOneToNumber(x)；</em>它不能执行这种优化，因为求和必须在最后一次调用后执行。</p><p id="83e5" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">这样，我们可以防止调用堆栈失控，并防止RangeError。</p><p id="92cf" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">除了。</p><p id="5190" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">JavaScript以一种称为“适当的尾部调用”(PTC)的特定形式实现尾部调用。然而，这仅在ES6之后才可用，在ES6之前，无法保证会应用尾部调用优化。</p><p id="22f0" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">同样需要注意的是，只有在严格模式下使用JavaScript时，PTC才起作用。如果你还没有听说过“严格”模式，这是值得一读的。</p><p id="480c" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">这些限制可能是到目前为止我们还没有在JavaScript中看到多少递归应用的原因。这当然值得进一步讨论，因为我相信使用递归函数可以极大地增强可读性，这是一个好的软件项目中最重要的指标。</p><h1 id="37af" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="3764" class="pw-post-body-paragraph kl km in kn b ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh kk ig bi translated">如果应用时疏忽，递归是一种危险的技术。您可能会在生产环境中部署一些代码时遇到一个范围错误，这种情况在开发过程中不会发生，因为您的测试应用程序中没有那么多数据。</p><p id="0f2e" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">在这篇博客中，我解释了什么是递归函数。具体是做什么的，在现实场景中可以应用到哪里，使用的时候有什么需要注意的地方。</p><p id="106b" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated">我希望你学到了一些新的东西，这篇博文将有助于你在未来做出更好的决定。祝你好运！</p><p id="4b89" class="pw-post-body-paragraph kl km in kn b ko li kq kr ks lj ku kv kw lk ky kz la ll lc ld le lm lg lh kk ig bi translated"><em class="mq">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mq">plain English . io</em></a></p></div></div>    
</body>
</html>