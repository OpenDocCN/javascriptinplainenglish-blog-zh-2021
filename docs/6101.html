<html>
<head>
<title>Understand Derived State in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解React中的派生状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-derived-state-in-react-1491a9ee3a6b?source=collection_archive---------2-----------------------#2021-12-31">https://javascript.plainenglish.io/understanding-derived-state-in-react-1491a9ee3a6b?source=collection_archive---------2-----------------------#2021-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="590a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解隐藏的风险以及我们如何从了解这些风险中获益。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/51072f7b591dba6b512ef97995e08291.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*OtNwFVjXn-2EalYVchdlbw.jpeg"/></div></figure><p id="072b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg"> Prop </em>概念在形成我们令人敬畏的框架——React中起着重要作用。它是组件之间通信的主要方法之一，向下绕过它，加强父组件和子组件之间的关系。它不仅用于描述组件，有时还播种数据以形成初始状态，这是另一种奇妙的用法，但由于存在隐藏的风险而引起争议，本文旨在指出它们，并让我们看看如何从理解它们中受益。</p><h1 id="653a" class="lh li in bd lj lk ll lm ln lo lp lq lr jt ls ju lt jw lu jx lv jz lw ka lx ly bi translated">目录:</h1><ul class=""><li id="d013" class="lz ma in km b kn mb kq mc kt md kx me lb mf lf mg mh mi mj bi translated"><strong class="km io">什么是派生状态？我们为什么需要它？</strong></li><li id="d3cb" class="lz ma in km b kn mk kq ml kt mm kx mn lb mo lf mg mh mi mj bi translated"><strong class="km io">真理的两个来源:</strong>它带来了什么问题，以及解决方案？</li><li id="ff16" class="lz ma in km b kn mk kq ml kt mm kx mn lb mo lf mg mh mi mj bi translated"><strong class="km io">意外变异道具:</strong>不可预知的虫子</li><li id="2e3f" class="lz ma in km b kn mk kq ml kt mm kx mn lb mo lf mg mh mi mj bi translated"><strong class="km io">总结</strong></li></ul><h1 id="d912" class="lh li in bd lj lk ll lm ln lo lp lq lr jt ls ju lt jw lu jx lv jz lw ka lx ly bi translated"><strong class="ak">什么是派生状态？我们为什么需要它？</strong></h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/2ae44d2885bc60c38c52f803fa5ca584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yNesmiO81Qptb_Gz_w0Zg.png"/></div></div></figure><p id="d00f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当一个属性被用来初始化一个状态时，这个状态被称为<strong class="km io">派生状态</strong>。我们可以把prop看作一个数据依赖，状态用它来形成它的缺省值。像我的<code class="fe mu mv mw mx b">SetContainer</code>一样，组件有一个名为<code class="fe mu mv mw mx b">sets</code>的状态，我使用<code class="fe mu mv mw mx b">props.sets</code>来初始化<code class="fe mu mv mw mx b">sets</code>。</p><p id="3843" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为什么我们不直接使用<code class="fe mu mv mw mx b">props.sets</code>呢？为什么要映射到另一个变量(<code class="fe mu mv mw mx b">sets</code>状态)才能使用？</p><p id="12ac" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">很棒的问题！简答:暂时突变。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b1da" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">假设我们有一个列表，比如说一个健身锻炼列表，每个锻炼都有自己的细节，就像许多<code class="fe mu mv mw mx b">sets</code>一样，每组包含不同的持续时间、节奏和休息时间。用户可以选择一个练习并选择编辑细节，在他们编辑后，练习细节必须返回到其原始的<code class="fe mu mv mw mx b">sets</code>细节。所以整个过程绝对像是<code class="fe mu mv mw mx b">sets</code>上的临时突变。我们改变集合并把它呈现出来，一旦我们做了，我们就把它放回去。我们需要<code class="fe mu mv mw mx b">SetContainer</code>来获取原始集合，并且只改变它们作用域内的集合，不影响原始集合。这里的原始集合是<code class="fe mu mv mw mx b">props.sets</code>，我们要变异的集合是<code class="fe mu mv mw mx b">sets</code>。通过这种方式，我们确保了通过设置状态进行更改的能力，并且不会影响原始设置。在示例gif中，我编辑了一个从15到20的值，当我退出编辑模式时，它又回到了15，不要介意应用程序lol中的语言。</p><p id="fc1d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如你所见，甚至<strong class="km io">派生状态</strong>也被称为反模式，有时我们需要它。就我个人而言，我认为反模式一点也不好，它并不完美，它包含了隐藏的风险，但是如果我们意识到这些风险，无论如何它仍然是一个好的方法！我的文章不是要批判<strong class="km io">衍生状态</strong>，而是要认识风险，战胜风险！</p><h1 id="50fd" class="lh li in bd lj lk ll lm ln lo lp lq lr jt ls ju lt jw lu jx lv jz lw ka lx ly bi translated">真理两个来源</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi na"><img src="../Images/197fd10f6159e88a30dc882057226c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sO-QzThr7A_gJnPCHsPMYw.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Who doesn’t love Conan?</figcaption></figure><p id="021f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为柯南大声呐喊lol💁</p><p id="1b9c" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当我们学习React时，我们肯定在某个地方遇到过真理的<strong class="km io">单一来源</strong>，比如在Redux principle中，或者看到其他开发人员在Twitter上讨论它，甚至许多博客帖子都提到它。</p><p id="611d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对我来说，<strong class="km io">单一的真理来源</strong>经常被误解，这并不意味着所有的东西都来自同一个地方，这意味着对于每一个特定的数据，都有一个特定的来源。这使得容易跟踪数据流，减轻编程的挫折感。</p><p id="9419" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">通过从道具中导出状态，你把一件事情的真相来源一分为二。它原本是一个单独的东西(prop)，派生的状态让它分叉，并可能失去同步，导致类似下面我在StackOverflow上发现的问题。</p><div class="nf ng gp gr nh ni"><a href="https://stackoverflow.com/questions/54865764/react-usestate-does-not-reload-state-from-props" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">React.useState不从props重新加载状态</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">我们使用useState为变量设置初始值的功能组件，如果我们通过…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">stackoverflow.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ki ni"/></div></div></a></div><p id="c26c" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">简单解释一下这个问题，他使用一个道具到初始状态，当道具改变时，他期望状态会像它是如何从道具中派生出来的那样更新，但是没有。他的代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nx"><img src="../Images/433d318a543bd806d784d9342d6df442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-7ZtiiKh0ko2W9rekJdMw.png"/></div></div></figure><p id="6e60" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在函数组件内部，函数内部的几乎所有东西都会重新运行它所调用的每一个(重新渲染)，这是javascript的函数行为。这个钩子有点特殊，因为它的创建不会被重复执行，很像在类组件的构造函数中设置状态。这就导致了上面的问题，“useState不从props重新加载状态”。</p><p id="0cf9" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这样写，他的组件可能会丢失来自<code class="fe mu mv mw mx b">props.user</code>的未来更新，他的数据流现在被分成两个源，正如我们在这里看到的，它们是不同步的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6a357a8149d746ca61a3cfb550cba119.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*dLWu7S5zd5BiTzlTQjVKSg.gif"/></div></figure><p id="0edd" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在问题跟帖里，别人给他的解决方案<code class="fe mu mv mw mx b">useEffect</code>:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nz"><img src="../Images/7dcf53e6cf7fcfb8e7a678b139a8e5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-RETcz9YTvywrfqP-G2Zg.png"/></div></div></figure><p id="ad3f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">只要满足第二个参数中的条件依赖，这就可以工作，不像<code class="fe mu mv mw mx b">useState</code>，<code class="fe mu mv mw mx b">useEffect</code>在每次渲染后重新执行。现在他有办法同步他的道具和状态，每次他的<code class="fe mu mv mw mx b">props.user</code>更新时，他为他的<code class="fe mu mv mw mx b">user</code>状态设置一个新值，但另一个问题出现了，让我给你看。</p><p id="7a40" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">就像我上面提到的临时突变一样，如果这个<code class="fe mu mv mw mx b">Avatar</code>组件的唯一目的是显示化身，那么它不需要派生状态。这有点像编辑阿凡达，这样更有意义。</p><p id="a410" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">假设我们正在做编辑头像的功能，我们让用户选择他们的个人资料图片，他们想要多少次就有多少次，我们不想更新<code class="fe mu mv mw mx b">props.user</code>数据或立即向服务器发送更新请求，这是浪费。我们希望对用户的最终决定进行实际更新，比如他选择了5次个人资料，在第5次选择时，我们向我们的服务器发送更新请求，并在本地更新<code class="fe mu mv mw mx b">props.user</code>。在我看来，我只是需要，不需要整个<code class="fe mu mv mw mx b">props.user</code>的数据，但无论如何我只是坚持上面的StackOverflow问题。</p><p id="5d00" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在选择/编辑头像时，<code class="fe mu mv mw mx b">props.user</code>突然变化，<code class="fe mu mv mw mx b">useEffect</code>同步<code class="fe mu mv mw mx b">user</code>状态和<code class="fe mu mv mw mx b">props.user</code>。通过设置一个新的状态，我们失去了暂时的突变，我们的编辑。我们必须通过缓存我们的编辑并在<code class="fe mu mv mw mx b">useEffect</code>中执行条件<code class="fe mu mv mw mx b">setUser</code>来修复它。</p><p id="6409" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">想象我们的数据流要复杂得多，两个真实的来源会导致更大的问题，而且真的很难追踪。</p><p id="3064" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">然而，如果你清楚地表明这个属性只是为组件的内部控制状态提供种子数据，那么它就不是一个反模式。</p><p id="5226" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">派生状态</strong>很少使用，最好只在你的组件的内部状态不需要与来自父组件的道具同步时使用，或者甚至当你需要同步时，记住不要做<strong class="km io">无条件状态更新</strong>，总是检查你的逻辑，找出它是否需要任何条件。</p><h1 id="ff00" class="lh li in bd lj lk ll lm ln lo lp lq lr jt ls ju lt jw lu jx lv jz lw ka lx ly bi translated"><strong class="ak">意外变异道具</strong></h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/5ee63201398a087c57b818697e9d333b.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*SyWtefssUlPLkHcgWLLmOw.jpeg"/></div></figure><p id="c0f3" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">每个框架都有自己的生态系统和一套规则。设置这些规则是为了确保开发者不会破坏框架的愿景/生态系统。React也是如此，它的更新过程主要是异步的。从一开始，我们就被教导不要直接改变状态/道具，进程必须是异步的，React通过教我们使用<code class="fe mu mv mw mx b">this.setState</code>或调度<code class="fe mu mv mw mx b">React<em class="lg">.</em>SetStateAction</code>(从<code class="fe mu mv mw mx b">useState</code>返回的元组的第二个值)来教育它，我确实向他们解释清楚了<a class="ae ob" rel="noopener ugc nofollow" target="_blank" href="/react-native-the-state-world-59721cbf0521">为什么是异步的</a>？在我之前的博客文章中，Redux也把这作为他们文档中的主要规则之一。这些强调了不直接改变状态/道具的重要性，这是一个必须遵循的规则。</p><p id="454e" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">也就是说，每个人至少都会犯一次错误，这可能是因为缺乏知识，或者粗心大意，或者缺乏编程工具的支持。当你的应用程序不能像预期的那样工作，或者你的组件不能正确渲染时，会导致逻辑错误。让我们找出原因！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oc"><img src="../Images/fe4927688450f0abfdc0f3bf40190789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUVQCD8DDEdpgZ6hEqz7KQ.png"/></div></div></figure><p id="c24d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">例如，我们的<code class="fe mu mv mw mx b">Greeting</code>组件，假设它可以显示一些类似“Hello 31/12/2021”的文本，并使用<code class="fe mu mv mw mx b">props.date</code>来初始化<code class="fe mu mv mw mx b">dateState</code> —派生状态。在<code class="fe mu mv mw mx b">updateYear</code>函数中，我们要更新<code class="fe mu mv mw mx b">dateState</code>的<code class="fe mu mv mw mx b">year</code>。通常，我们会对对象的副本进行更改，以便它不会影响对象，但有时，在匆忙中，我们会忘记并执行类似以下操作:</p><pre class="kd ke kf kg gt od mx oe of aw og bi"><span id="9e3b" class="oh li in mx b gy oi oj l ok ol">const newDate = dateState<br/>newDate.year = newYear</span></pre><p id="960b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个影响到<code class="fe mu mv mw mx b">props.date</code>，直接把它变了，而且因为<code class="fe mu mv mw mx b">today</code>、<code class="fe mu mv mw mx b">newDate</code>、<code class="fe mu mv mw mx b">dateState</code>、<code class="fe mu mv mw mx b">props.date</code>有相同的引用，我们不小心把<code class="fe mu mv mw mx b">today</code>变了。比方说，我使用其他组件<code class="fe mu mv mw mx b">today</code>进行一些计算，在一个更新批次后，计算突然产生错误的结果，没有经验，新手会很难发现。</p><p id="9269" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">所以记得在使用<strong class="km io">派生状态</strong>时对一个对象的副本进行修改，并小心选择如何进行复制，有多种选择，在Javascript中在<strong class="km io">深层复制</strong>和<strong class="km io">浅层复制</strong>之间做出决定。</p><h1 id="9b47" class="lh li in bd lj lk ll lm ln lo lp lq lr jt ls ju lt jw lu jx lv jz lw ka lx ly bi translated">摘要</h1><p id="bc2d" class="pw-post-body-paragraph kk kl in km b kn mb jo kp kq mc jr ks kt om kv kw kx on kz la lb oo ld le lf ig bi translated">派生状态是一种反模式，但是当我们需要临时改变数据时，它仍然是一种很好的方法，对于这种情况，我认为它是最简单的方法。</p><p id="6dc7" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当然，两个真实的来源比一个真实的来源更难管理。当你的组件不会在意来自父级道具(用于派生状态的道具)的更新，或者你真的需要在状态和道具之间同步的时候，使用派生状态是最理想的，切记不要无条件更新。</p><p id="e33d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">直接改变道具是有问题的，必须小心地更新衍生状态，特别是当你的状态是物体的时候。</p><p id="9c41" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lg">更多内容看</em> <a class="ae ob" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lg">说白了. io </em> </a> <em class="lg">。报名参加我们的</em> <a class="ae ob" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lg">免费每周简讯</em> </a> <em class="lg">。在我们的</em> <a class="ae ob" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="lg">社区</em> </a> <em class="lg">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>