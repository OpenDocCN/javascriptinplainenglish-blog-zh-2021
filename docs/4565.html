<html>
<head>
<title>What are MongoDB One-to-N Relationships?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是MongoDB一对N关系？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mongodb-one-to-n-relationships-an-outline-6cd9e9f9584c?source=collection_archive---------7-----------------------#2021-09-11">https://javascript.plainenglish.io/mongodb-one-to-n-relationships-an-outline-6cd9e9f9584c?source=collection_archive---------7-----------------------#2021-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/30b2afa2a3b9e732c89c29dd8c366ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WeJGJQ8vsNHQqcen_F95A.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://www.pexels.com/@gilberto-reyes-259461?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Gilberto Reyes</a> from <a class="ae jz" href="https://www.pexels.com/photo/brown-and-white-american-pit-bull-terrier-with-brown-costume-825949/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="12f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你好世界！今天，我想到了解决您在设计MongoDB模式时可能会遇到的许多紧迫问题之一。你们中的一些人可能熟悉<em class="ky"> SQL </em>以及其中的关系是如何严格构建的。</p><p id="5bf3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<em class="ky"> SQL </em>中，大多数情况下，你有一个通用的方法来消除不同实体之间的关系。但是就MongoD而言，它的终极灵活性并不是没有代价的。那就是有很多<em class="ky">方法可以把事情搞砸。他们说自由伴随着责任。让我们看看MongoDB模式设计的一些简化的经验法则。</em></p><p id="53a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我将说明如何为Mongo中的<em class="ky">一对N关系</em>提出<em class="ky">明智的</em>模式。在<em class="ky"> SQL </em>中，这都浓缩在<em class="ky">一对多关系</em>下。但是对于Mongo来说，可以说最终的权力在你身上。所以在开始模式设计之前，你必须彻底思考。</p><p id="bd82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">一对多关系</em>在Mongo中，可以再细分为三个更小的块。</p><ol class=""><li id="e90c" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">一对几关系。</li><li id="8983" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">一对多关系。</li><li id="b0e0" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">一对十亿的关系。</li></ol><h2 id="7a80" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">一对几关系。</h2><p id="cc69" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">这是<em class="ky">一对多关系</em>的一个特例。顾名思义，它的意思就是<em class="ky">T21。不多(很多)，不是<em class="ky">方式</em>太多<em class="ky">而是</em>少。</em></p><p id="2ad7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这方面的一个例子是，一个“用户”有<em class="ky">几个</em>地址。一个“用户”拥有500或10000个地址是不太可能的，对吗？</p><p id="e4c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，最好的方法是，通过为每个“用户”在一个数组中嵌入地址细节来设计您的模式。同样，这不是一成不变的，您可以使用三种方法中的任何一种来绘制数据。但是在这种情况下，如果你采用这种方法，就不会那么累了。</p><p id="8078" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的意思是:</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/7d3615c772f47c626f0a00323de69379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBD-6xLME53QuLef7G99CA.jpeg"/></div></div></figure><p id="e8c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的主要障碍是“地址”是<em class="ky">而不是</em>一个独立的实体。它总是与特定的“用户”相关联。</p><p id="c990" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在执行任何过程之前，必须考虑您的需求，仔细检查您的模式是否符合您的需求。</p><h2 id="e199" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">一对多关系</h2><p id="12ec" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">这也算是钉钉子的<em class="ky">中庸之道</em>。可以这样涉及，如果你在<em class="ky">一对N关系</em>中的‘N’是<em class="ky">不是</em>太少，但同时<em class="ky">不是</em>狂大。为了更清楚地形象化这一点，考虑一个工厂。最有可能的是，它会生产出更多的产品。但不是成千上万(至少为了论证起见)。</p><p id="7303" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以将您的每件产品分别存储在集合中，并将“参考”添加到工厂数组中的每件产品中。简而言之，您可以将子引用(产品id)推送到父引用(工厂)中的数组。</p><p id="9b79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑下面的例子:</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/afe7826e2915e331a9e5ef1bd534288f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYKg_6dGYD7vgIruCo0Cwg.jpeg"/></div></div></figure><p id="3133" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您所要做的就是将产品id和相关工厂映射在一起。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/a629bb121d1dccde5e154c90a527ea92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-9Pcc1cwRZCvIqiLWLvOw.jpeg"/></div></div></figure><p id="1892" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个产品都有自己的文档，同时它们在父集合中被“引用”，在这里是<em class="ky">工厂</em>。与前面的方法不同，产品<em class="ky">在这里是一个独立的实体。您可以随时查询它们，而不必与工厂打交道。</em></p><h2 id="65f8" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">一对十亿的关系</h2><p id="be9d" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">这是在MongoDB中规划数据的最后一种方式，但也是最重要的一种方式。让我们快速看一下它是如何完成的。</p><p id="9e9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一下你正在克隆Twitter。有数以百万计的用户，每个人都有无数条推文(除非他们像我一样)。所以，如果你要给这种关系设定界限，考虑一下下面的方法。</p><p id="6014" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果在这种情况下使用<em class="ky">一对多</em>方法，那么每当用户发推文时，你的“用户”数组就会被推文id填满。所以解决这个问题的最好方法是在child中添加一个parent引用。这是将用户id作为引用从“用户”集合添加到“Tweets”集合。每个实体当然都是独立的实体。让我告诉你我的意思:</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/03f8c10c8ad33c6a2f8d9fdd87d943be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZStbO6kZOsg5pwp97LCx7g.jpeg"/></div></div></figure><p id="3d01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以创建一个单独的“用户”集合，并在每次添加新推文时引用“推文”表中的“用户id”。</p><p id="dd2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"><em class="ky"/></strong>这里要提的一点是，有<strong class="kc io"> <em class="ky">没有</em> </strong>硬性规定说你要遵循这些方法。这些是制作模式的一般方法，非常欢迎您根据需要对它们进行调整。</p><p id="669f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你的应用程序不像Twitter那么庞大，有那么多数据，你甚至可以考虑'<em class="ky">双向引用'</em>'，在“Tweets”中存储“User”引用，反之亦然。当您试图从集合中查询出数据时，这会很方便。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="c75f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读。我希望这对你有意义。一定要在评论里让我知道你的想法。</p><p id="03e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>