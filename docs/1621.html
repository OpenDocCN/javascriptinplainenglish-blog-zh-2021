<html>
<head>
<title>Improve JavaScript Code Quality with These Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过这些最佳实践提高JavaScript代码质量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improve-javascript-code-quality-with-these-best-practices-ee883a124d8e?source=collection_archive---------6-----------------------#2021-04-07">https://javascript.plainenglish.io/improve-javascript-code-quality-with-these-best-practices-ee883a124d8e?source=collection_archive---------6-----------------------#2021-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cc40ce24c0d346936e57e33247258142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKa7Ydli6gg1_XkJTBNmLw.png"/></div></div></figure><p id="c322" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您现在编写JavaScript，那么了解该语言在过去几年中的所有更新是值得的。自2015年以来，随着ES6的发布，每年都会发布ECMAScript规范的新版本。每一次迭代都为语言增加了新的特性、新的语法以及生活质量的提高。大多数浏览器和Node.js中的JavaScript引擎都很快赶上了，你的代码也应该跟上。这是因为JavaScript的每一次新的迭代都会带来新的习惯用法和新的方式来表达您的代码，而且很多时候，这些变化可能会使您和您的合作者的代码更易于维护。</p><p id="21a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一些最新的ECMAScript特性，通过归纳，您可以利用JavaScript和Node.js来编写更简洁、更易读的代码。</p><h1 id="97d7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">1.阻止带分数的声明</h1><p id="32fd" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">自语言诞生以来，JavaScript开发人员就一直使用<code class="fe lx ly lz ma b">var</code>来声明变量。关键字<code class="fe lx ly lz ma b">var</code>有其独特之处，其中最大的问题是使用它所创建的变量的范围。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="4575" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">var</strong> x <strong class="ma io">=</strong> 10<br/><strong class="ma io">if</strong> (<strong class="ma io">true</strong>) {<br/>  <strong class="ma io">var</strong> x <strong class="ma io">=</strong> 15     <em class="mo">// inner declaration overrides declaration in parent scope<br/></em>  console.log(x) <em class="mo">// prints 15<br/></em>}<br/>console.log(x)   <em class="mo">// prints 15</em></span></pre><p id="3af3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为用<code class="fe lx ly lz ma b">var</code>定义的变量不是块范围的，所以在更窄的范围内重新定义它们会影响外部范围的值。</p><p id="f799" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有两个新的关键字取代了<code class="fe lx ly lz ma b">var</code>，即<code class="fe lx ly lz ma b">let</code>和<code class="fe lx ly lz ma b">const</code>，它们没有这个缺点。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="0eed" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">let</strong> y <strong class="ma io">=</strong> 10<br/><strong class="ma io">if</strong> (<strong class="ma io">true</strong>) {<br/>  <strong class="ma io">let</strong> y <strong class="ma io">=</strong> 15       <em class="mo">// inner declaration is scoped within the if block<br/></em>  console.log(y)   <em class="mo">// prints 15<br/></em>}<br/>console.log(y)     <em class="mo">// prints 10</em></span></pre><p id="1a3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">const</code>和<code class="fe lx ly lz ma b">let</code>在语义上有所不同，用<code class="fe lx ly lz ma b">const</code>声明的变量不能在其作用域内被重新分配。这并不意味着它们是不可变的，只是它们的引用不能被改变。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="2d8e" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">const</strong> x <strong class="ma io">=</strong> []</span><span id="54d8" class="mj kv in ma b gy mp ml l mm mn">x.push("Hello", "World!")<br/>x <em class="mo">// ["Hello", "World!"]</em></span><span id="c073" class="mj kv in ma b gy mp ml l mm mn">x <strong class="ma io">=</strong> [] <em class="mo">// TypeError: Attempted to assign to readonly property.</em></span></pre><h1 id="6b9a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">2.箭头功能</h1><p id="0948" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">箭头函数是JavaScript最近引入的另一个非常重要的特性。它们带来了许多好处。首先也是最重要的，它们使JavaScript的功能方面看起来更漂亮，写起来更简单。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="00bc" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">let</strong> x <strong class="ma io">=</strong> [1, 2, 3, 4]</span><span id="26e6" class="mj kv in ma b gy mp ml l mm mn">x.map(val =&gt; val <strong class="ma io">*</strong> 2)                <em class="mo">// [2, 4, 6, 8]<br/></em>x.filter(val =&gt; val <strong class="ma io">%</strong> 2 <strong class="ma io">==</strong> 0)        <em class="mo">// [2, 4]<br/></em>x.reduce((acc, val) =&gt; acc <strong class="ma io">+</strong> val, 0) <em class="mo">// 10</em></span></pre><p id="190b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面所有的例子中，以独特的箭头<code class="fe lx ly lz ma b">=&gt;</code>命名的箭头函数用简洁的语法取代了传统的函数。</p><ol class=""><li id="16d1" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">如果函数体是单个表达式，则范围括号<code class="fe lx ly lz ma b">{}</code>和<code class="fe lx ly lz ma b">return</code>关键字是隐含的，不需要编写。</li><li id="1846" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">如果函数只有一个参数，参数括号<code class="fe lx ly lz ma b">()</code>是隐含的，不需要编写。</li><li id="42cb" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">如果函数体表达式是一个字典，必须用括号<code class="fe lx ly lz ma b">()</code>括起来。</li></ol><p id="f9b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">arrow函数的另一个显著优点是它们不定义作用域，而是存在于父作用域中。这避免了使用<code class="fe lx ly lz ma b">this</code>关键字时可能出现的许多陷阱。箭头功能对<code class="fe lx ly lz ma b">this</code>没有绑定。在arrow函数内部，<code class="fe lx ly lz ma b">this</code>的值与父作用域中的值相同。因此，arrow函数不能用作方法或构造函数。Arrow功能不适用于<code class="fe lx ly lz ma b">apply</code>、<code class="fe lx ly lz ma b">bind</code>或<code class="fe lx ly lz ma b">call</code>，并且对<code class="fe lx ly lz ma b">super</code>没有绑定。</p><p id="b7b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们也有某些其他的局限性，比如缺少传统功能可以访问的<code class="fe lx ly lz ma b">arguments</code>对象，无法从功能体中<code class="fe lx ly lz ma b">yield</code>。</p><p id="dea1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，arrow函数不是标准函数的1:1替代品，而是JavaScript特性集的受欢迎的补充。</p><h1 id="16d9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">3.可选链接</h1><p id="5861" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">想象一个像这个<code class="fe lx ly lz ma b">person</code>对象一样的深度嵌套的数据结构。假设您想知道这个人的名字和姓氏。您可以这样用JavaScript编写:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e6d4" class="mj kv in ma b gy mk ml l mm mn">person <strong class="ma io">=</strong> {<br/>  name<strong class="ma io">:</strong> {<br/>    first<strong class="ma io">:</strong> 'John',<br/>    last<strong class="ma io">:</strong> 'Doe',<br/>  },<br/>  age<strong class="ma io">:</strong> 42<br/>}<br/>person.name.first <em class="mo">// 'John'<br/></em>person.name.last  <em class="mo">// 'Doe'</em></span></pre><p id="30d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在想象一下如果<code class="fe lx ly lz ma b">person</code>对象不包含嵌套的<code class="fe lx ly lz ma b">name</code>对象会发生什么。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="d58e" class="mj kv in ma b gy mk ml l mm mn">person <strong class="ma io">=</strong> {<br/>  age<strong class="ma io">:</strong> 42<br/>}<br/>person.name.first <em class="mo">// TypeError: Cannot read property 'first' of undefined<br/></em>person.name.last  <em class="mo">// TypeError: Cannot read property 'last' of undefined</em></span></pre><p id="0a60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了避免这样的错误，开发人员不得不求助于下面这样的代码，这种代码不必要地冗长，难以阅读，并且令人不快——这是一个非常糟糕的三个形容词。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="5f41" class="mj kv in ma b gy mk ml l mm mn">person <strong class="ma io">&amp;&amp;</strong> person.name <strong class="ma io">&amp;&amp;</strong> person.name.first <em class="mo">// undefined</em></span></pre><p id="ee60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">满足可选链接，这是JavaScript的一个新特性，消除了这种畸形。可选链接一旦遇到<code class="fe lx ly lz ma b">null</code>或<code class="fe lx ly lz ma b">undefined</code>值就使挖掘过程短路，并返回<code class="fe lx ly lz ma b">undefined</code>而不产生错误。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="6276" class="mj kv in ma b gy mk ml l mm mn">person<strong class="ma io">?</strong>.name<strong class="ma io">?</strong>.first <em class="mo">// undefined</em></span></pre><p id="c98a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生成的代码更加简洁明了。</p><h1 id="3e40" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">4.类似零的合并</h1><p id="21f3" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在引入类似null的合并运算符之前，如果没有输入，JavaScript开发人员使用or运算符<code class="fe lx ly lz ma b">||</code>返回默认值。这带来了一个重要的警告，即即使是合法但虚假的值也会导致回到默认值。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e46e" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">function</strong> print(val) {<br/>	<strong class="ma io">return</strong> val <strong class="ma io">||</strong> 'Missing'<br/>}</span><span id="f5db" class="mj kv in ma b gy mp ml l mm mn">print(<strong class="ma io">undefined</strong>) <em class="mo">// 'Missing'<br/></em>print(<strong class="ma io">null</strong>)      <em class="mo">// 'Missing'</em></span><span id="bdc9" class="mj kv in ma b gy mp ml l mm mn">print(0)         <em class="mo">// 'Missing'<br/></em>print('')        <em class="mo">// 'Missing'<br/></em>print(<strong class="ma io">false</strong>)     <em class="mo">// 'Missing'<br/></em>print(<strong class="ma io">NaN</strong>)       <em class="mo">// 'Missing'</em></span></pre><p id="83a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript现在提出了空合并运算符<code class="fe lx ly lz ma b">??</code>，它提供了一个更好的选择，因为如果前面的表达式是空的，它只会导致回退。这里的null-ish指的是<code class="fe lx ly lz ma b">null</code>或<code class="fe lx ly lz ma b">undefined</code>的值。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="4dc0" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">function</strong> print(val) {<br/>	<strong class="ma io">return</strong> val <strong class="ma io">??</strong> 'Missing'<br/>}</span><span id="2562" class="mj kv in ma b gy mp ml l mm mn">print(<strong class="ma io">undefined</strong>) <em class="mo">// 'Missing'<br/></em>print(<strong class="ma io">null</strong>)      <em class="mo">// 'Missing'</em></span><span id="96b7" class="mj kv in ma b gy mp ml l mm mn">print(0)         <em class="mo">// 0<br/></em>print('')        <em class="mo">// ''<br/></em>print(<strong class="ma io">false</strong>)     <em class="mo">// false<br/></em>print(<strong class="ma io">NaN</strong>)       <em class="mo">// NaN</em></span></pre><p id="dd7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，你可以确保如果你的程序接受虚假的值作为合法的输入，你不会用错误来代替它们。</p><h1 id="47b4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">5.逻辑分配</h1><p id="e73c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">假设你想给一个变量赋值，当且仅当这个值当前为空时。这样写的逻辑方式应该是这样的:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="ca07" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">if</strong> (x <strong class="ma io">===</strong> <strong class="ma io">null</strong> <strong class="ma io">||</strong> x <strong class="ma io">==</strong> <strong class="ma io">undefined</strong>) {<br/>	x <strong class="ma io">=</strong> y<br/>}</span></pre><p id="28e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您知道短路是如何工作的，那么您可能希望使用null-ish合并操作符用一个更简洁的版本来替换这3行代码。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="de62" class="mj kv in ma b gy mk ml l mm mn">x <strong class="ma io">??</strong> (x <strong class="ma io">=</strong> y) <em class="mo">// x = y if x is nullish, else no effect</em></span></pre><p id="a72e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们使用null-ish合并操作符的短路特性来执行第二部分<code class="fe lx ly lz ma b">x = y</code>,如果<code class="fe lx ly lz ma b">x</code>是null-ish。代码非常简洁，但仍然不容易阅读或理解。逻辑null-ish赋值消除了对这种变通方法的需要。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="4c2b" class="mj kv in ma b gy mk ml l mm mn">x <strong class="ma io">??=</strong> y <em class="mo">// x = y if x is nullish, else no effect</em></span></pre><p id="0522" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，JavaScript也引入了逻辑AND赋值<code class="fe lx ly lz ma b">&amp;&amp;=</code>和逻辑OR赋值<code class="fe lx ly lz ma b">||=</code>操作符。这些运算符仅在满足特定条件时执行赋值，否则无效。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="6bd4" class="mj kv in ma b gy mk ml l mm mn">x <strong class="ma io">||=</strong> y <em class="mo">// x = y if x is falsy, else no effect<br/></em>x <strong class="ma io">&amp;&amp;=</strong> y <em class="mo">// x = y if x is truthy, else no effect</em></span></pre><p id="af94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提示:如果你以前写过Ruby，你会看到<code class="fe lx ly lz ma b">||=</code>和<code class="fe lx ly lz ma b">&amp;&amp;=</code>操作符，因为Ruby没有falsy值的概念。</p><h1 id="a59b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">6.命名捕获组</h1><p id="d7a3" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们先快速回顾一下正则表达式中的捕获组。捕获组是字符串的一部分，它匹配括号中正则表达式的一部分。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="bead" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">let</strong> re <strong class="ma io">=</strong> /(\d{4})-(\d{2})-(\d{2})/<br/><strong class="ma io">let</strong> result <strong class="ma io">=</strong> re.exec('Pi day this year falls on 2021-03-14!')</span><span id="dadf" class="mj kv in ma b gy mp ml l mm mn">result[0] <em class="mo">// '2020-03-14', the complete match<br/></em>result[1] <em class="mo">// '2020', the first capture group<br/></em>result[2] <em class="mo">// '03', the second capture group<br/></em>result[3] <em class="mo">// '14', the third capture group</em></span></pre><p id="a8e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正则表达式支持命名捕获组已经有一段时间了，这是一种通过名称而不是索引来引用捕获组的方式。现在，在ES9中，这个特性已经发展到了JavaScript。现在，结果对象包含一个嵌套的groups对象，其中每个捕获组的值都映射到它的名称。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="83a2" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">let</strong> re <strong class="ma io">=</strong> /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/<br/><strong class="ma io">let</strong> result <strong class="ma io">=</strong> re.exec('Pi day this year falls on 2021-03-14!')</span><span id="45ff" class="mj kv in ma b gy mp ml l mm mn">result.groups.year  <em class="mo">// '2020', the group named 'year'<br/></em>result.groups.month <em class="mo">// '03', the group named 'month'<br/></em>result.groups.day   <em class="mo">// '14', the group named 'day'</em></span></pre><p id="3841" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">新的API与另一个新的JavaScript特性——非结构化赋值——配合得非常好。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="b8fe" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">let</strong> re <strong class="ma io">=</strong> /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/<br/><strong class="ma io">let</strong> result <strong class="ma io">=</strong> re.exec('Pi day this year falls on 2021-03-14!')<br/><strong class="ma io">let</strong> { year, month, day } <strong class="ma io">=</strong> result.groups</span><span id="b9a2" class="mj kv in ma b gy mp ml l mm mn">year  <em class="mo">// '2020'<br/></em>month <em class="mo">// '03'<br/></em>day   <em class="mo">// '14'</em></span></pre><h1 id="a684" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">7.<code class="fe lx ly lz ma b">async</code> &amp; <code class="fe lx ly lz ma b">await</code></h1><p id="8f6a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">JavaScript的强大之处之一是它的异步性。这意味着许多可能需要长时间运行或耗费时间的函数可以返回一个承诺，而不会阻塞执行。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="c4fe" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">const</strong> url <strong class="ma io">=</strong> 'https://the-one-api.dev/v2/book'<br/><strong class="ma io">let</strong> prom <strong class="ma io">=</strong> fetch(url)<br/>prom <em class="mo">// Promise {&lt;pending&gt;}</em></span><span id="c25a" class="mj kv in ma b gy mp ml l mm mn"><em class="mo">// wait a bit<br/></em>prom <em class="mo">// Promise {&lt;fullfilled&gt;: Response}, if no errors<br/>// or<br/></em>prom <em class="mo">// Promise {&lt;rejected&gt;: Error message}, if any error</em></span></pre><p id="c26c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对fetch的调用返回一个创建时状态为“待定”的承诺。很快，当API返回响应时，它转换到“已完成”状态，并且可以访问它包装的响应。在Promises的世界中，您可以做类似这样的事情来进行API调用，并将响应解析为JSON。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="45d5" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">const</strong> url <strong class="ma io">=</strong> 'https://the-one-api.dev/v2/book'<br/><strong class="ma io">let</strong> prom <strong class="ma io">=</strong> fetch(url)<br/>prom                               <em class="mo">// Promise {&lt;fullfilled&gt;: Response}<br/></em>  .then(res =&gt; res.json())<br/>  .then(json =&gt; console.log(json)) <em class="mo">// prints response, if no errors<br/></em>  .<strong class="ma io">catch</strong>(err =&gt; console.log(err))  <em class="mo">// prints error message, if any error</em></span></pre><p id="ddc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2017年，JavaScript宣布了两个新的关键词<code class="fe lx ly lz ma b">async</code>和<code class="fe lx ly lz ma b">await</code>，这使得处理和处理承诺更加容易和流畅。它们不能代替承诺；它们仅仅是强大的承诺概念之上的语法糖。</p><p id="775d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">await</code>使所有代码看起来都像同步的JavaScript，而不是发生在一系列“然后”函数中。作为额外的好处，您可以将<code class="fe lx ly lz ma b">try...catch</code>与<code class="fe lx ly lz ma b">await</code>一起使用，而不是像直接使用Promises那样处理“catch”函数中的错误。与<code class="fe lx ly lz ma b">await</code>相同的代码如下所示。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="fd27" class="mj kv in ma b gy mk ml l mm mn"><strong class="ma io">const</strong> url <strong class="ma io">=</strong> 'https://the-one-api.dev/v2/book'<br/><strong class="ma io">let</strong> res <strong class="ma io">=</strong> await fetch(url) <em class="mo">// Promise {&lt;fullfilled&gt;: Response} -await-&gt; Response<br/></em><strong class="ma io">try</strong> {<br/>	<strong class="ma io">let</strong> json <strong class="ma io">=</strong> await res.json()<br/>	console.log(json) <em class="mo">// prints response, if no errors<br/></em>} <strong class="ma io">catch</strong>(err) {<br/>  console.log(err)  <em class="mo">// prints error message, if any error<br/></em>}</span></pre><p id="365d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lx ly lz ma b">async</code>关键字是同一枚硬币的另一面，因为它包装了任何要在承诺内发送的数据。考虑下面的异步函数来添加几个数字。在现实世界中，您的代码会做一些更复杂的事情。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="07e8" class="mj kv in ma b gy mk ml l mm mn">async <strong class="ma io">function</strong> sum(...nums) {<br/>    <strong class="ma io">return</strong> nums.reduce((agg, val) =&gt; agg <strong class="ma io">+</strong> val, 0)<br/>}</span><span id="43ad" class="mj kv in ma b gy mp ml l mm mn">sum(1, 2, 3)                    <em class="mo">// Promise {&lt;fulfilled&gt;: 6}<br/></em>  .then(res =&gt; console.log(res) <em class="mo">// prints 6</em></span><span id="c6d8" class="mj kv in ma b gy mp ml l mm mn"><strong class="ma io">let</strong> res <strong class="ma io">=</strong> await sum(1, 2, 3)    <em class="mo">// Promise {&lt;fulfilled&gt;: 6} -await-&gt; 6<br/></em>console.log(res)                <em class="mo">// prints 6</em></span></pre><p id="9dc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些新功能只是冰山一角。我们甚至还没有触及表面。JavaScript在不断发展，并且每年都有新的特性被添加到该语言中。很难跟上手动引入该语言的不断涌现的新特性和习惯用法。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="dc14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mo">原创于</em> <a class="ae kt" href="https://deepsource.io/blog/javascript-code-quality-best-practices/?utm_source=medium&amp;utm_medium=jsinplainenglish&amp;utm_campaign=contentdistribution&amp;utm_term=jscodequality" rel="noopener ugc nofollow" target="_blank"> <em class="mo">深源博客</em> </a> <em class="mo">。</em></p></div></div>    
</body>
</html>