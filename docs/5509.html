<html>
<head>
<title>Every Single Basic Sorting Algorithm Thoroughly Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每一个基本的排序算法彻底解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basic-sorting-algorithms-explained-d061833240e1?source=collection_archive---------9-----------------------#2021-11-15">https://javascript.plainenglish.io/basic-sorting-algorithms-explained-d061833240e1?source=collection_archive---------9-----------------------#2021-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5ac9503a1627e17e591bfdebfe8d72df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vcRWcLYNpFxFyr1e"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3888" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">排序是计算机科学领域中最基本也是最常用的算法之一。它是按升序或降序排列数据的一系列步骤。此外，这也是你深入“算法世界”之前的一个网关算法。<br/> <br/>这些算法在构建复杂系统的时候很有价值。全面的用例超出了本文档的范围(它可能是一个独立的博客，排序如何为系统增加价值，也许以后)。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/bcac400274fab434484589538bde7fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/1*V7Ruq4ziGnHEHTuA01LwpQ.gif"/></div></figure><p id="75cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将介绍一些基本的排序算法，以及常用排序算法的实现和效率。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h1 id="2806" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">冒泡排序</strong></h1><p id="b86e" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">这个排序算法是基于比较的。在每次迭代中，我们比较相邻的元素。如果它们没有按顺序排列，那么它们就会被交换。</p><h2 id="8470" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">伪代码</strong></h2><pre class="kz la lb lc gt mz na nb nc aw nd bi"><span id="5f17" class="mn ll in na b gy ne nf l ng nh"><strong class="na io">procedure</strong> bubbleSort(A : list <strong class="na io">of</strong> sortable items)<br/>    n := length(A)<br/>    <strong class="na io">repeat</strong><br/>        swapped := <strong class="na io">false</strong><br/>        <strong class="na io">for</strong> i := 1 <strong class="na io">to</strong> n-1 inclusive <strong class="na io">do</strong><br/>            /* <strong class="na io">if</strong> this pair <strong class="na io">is</strong> out <strong class="na io">of</strong> order */<br/>            <strong class="na io">if</strong> A[i-1] &gt; A[i] <strong class="na io">then</strong><br/>                /* swap them <strong class="na io">and</strong> remember something changed */<br/>                swap(A[i-1], A[i])<br/>                swapped := <strong class="na io">true</strong><br/>            <strong class="na io">end</strong> <strong class="na io">if</strong><br/>        <strong class="na io">end</strong> <strong class="na io">for</strong><br/>    <strong class="na io">until</strong> <strong class="na io">not</strong> swapped<br/><strong class="na io">end</strong> <strong class="na io">procedure</strong></span></pre><p id="a8e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://en.wikipedia.org/wiki/Bubble_sort" rel="noopener ugc nofollow" target="_blank"> <em class="ni">伪代码来源</em> </a></p><h2 id="8cc6" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">实施</strong></h2><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/7f8ef5cb2bb2e6a6b37197e0fd077f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeqpnsJAUMa83XCUxP7tag.png"/></div></div></figure><blockquote class="nk nl nm"><p id="7cf8" class="ka kb ni kc b kd ke kf kg kh ki kj kk nn km kn ko no kq kr ks np ku kv kw kx ig bi translated">在上面的例子中，我们希望数组按升序排列。在第一次迭代中:8&gt;5，所以我们交换它。我们继续下一组，如此类推，直到我们到达最后一对。经过这一关后，我们会注意到最高的数字将在其合法的最终位置。</p><p id="a290" class="ka kb ni kc b kd ke kf kg kh ki kj kk nn km kn ko no kq kr ks np ku kv kw kx ig bi translated">我们对部分排序的数组重复上述操作。但是这次，我们只比较n-1个元素。最后，我们会看到第二高的数字将会在倒数第二个位置。下一次迭代是n-2，以此类推。在上面的例子中，我们看到了第二遍完成的正确顺序。我们不会知道，代码会继续运行。我们遍历数组的次数是n*(n-1)*(n-2)…2*1= n！</p></blockquote><h2 id="d9d9" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated">有趣的事实</h2><p id="969f" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">最小的元素到达顶部就像一个气泡到达湖的顶部，从深处！！！！</p><h2 id="8382" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">最佳、最差和一般情况</strong></h2><p id="61b2" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">空间复杂度:O(1)</p><p id="5a99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最坏情况时间复杂度:O(n)</p><p id="1ba2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">平均案例时间复杂度:O(n)</p><p id="dbb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最佳情况时间复杂度:O(n)</p><h2 id="3af5" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">优缺点</strong></h2><p id="959f" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">该算法易于理解和实现。由于其简单性，它是计算机科学中排序算法的基础。冒泡排序<a class="ae jz" href="https://www.baeldung.com/cs/stable-sorting-algorithms" rel="noopener ugc nofollow" target="_blank">是一种稳定的排序算法</a>，多边形填充算法使用了冒泡排序的概念。(哦！大词，你可以在提供的链接中读到它)</p><p id="ff98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种算法的一个缺点是，对于大型数据集来说，它变得非常慢。当链表的大小增加时，该算法的效率急剧下降，平均时间呈二次方增加。</p><h1 id="5a5a" class="lk ll in bd lm ln nq lp lq lr nr lt lu lv ns lx ly lz nt mb mc md nu mf mg mh bi translated"><strong class="ak"> 2。选择排序</strong></h1><p id="2cfc" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">该算法从未排序的列表中搜索最小的元素，并将该元素移动到新列表中。列表变小一个。重复简化列表中的第一步。继续迭代，直到所有元素都在新元素中。</p><h2 id="4bde" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">伪代码:</strong></h2><pre class="kz la lb lc gt mz na nb nc aw nd bi"><span id="0d36" class="mn ll in na b gy ne nf l ng nh"><strong class="na io">selectionSort</strong>(arr){<br/>n = Arr.length</span><span id="4567" class="mn ll in na b gy nv nf l ng nh">for ( i = 0 ; i &lt; n ; i++){<br/>//Finding the smallest element in the sub array<br/>  let min = i;<br/>   for(let j = i+1 ; j&lt; n ;j++){<br/>        if(arr[j] &lt; arr[min]){<br/>         min = j;<br/>      }<br/>   }</span><span id="836c" class="mn ll in na b gy nv nf l ng nh">  if (min != i){<br/>  //swapping the elements<br/>  temp = arr[i];<br/>  arr[i] = arr[min];<br/>  arr[min] = temp;<br/>   }<br/> }<br/> return arr;<br/>}</span></pre><h2 id="75c1" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">实施:</strong></h2><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/84c724b88c9ee5c250fab6dbb5a76522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYheGcZ9kF-nXTmvrCG6mg.png"/></div></div></figure><p id="a605" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">在实现中，第一个元素将与数组中的其余元素进行比较。一旦找到，这个最小的元素将从未排序的列表中删除，并添加到一个新的列表中。<br/>现在原始列表只有n-1个元素。我们在简化的列表上重复上述过程。再次从未排序列表中删除最小的元素，并作为第二个元素添加到排序列表中。像冒泡排序一样，选择排序也迭代n*(n-1)*(n-2)…2*1。并且没有元素留在未排序的部分中。在这个算法中，我们选择最小的元素并移入一个新的列表。因此命名为选择排序。</em></p><h2 id="4c50" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">最佳、最差和一般情况</strong></h2><p id="c7b1" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">空间复杂度:O(1)辅助</p><p id="0e44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最坏情况时间复杂度:O(n)比较，O(n)交换</p><p id="054f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">平均案例时间复杂度:O(n)比较，O(n)交换</p><p id="898c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最佳情况时间复杂度:O(n)比较，O(1)交换</p><h2 id="e60c" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">冒泡排序和选择排序的区别</strong></h2><p id="b3c1" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">与选择排序相比，冒泡排序算法效率较低。在选择排序中，我们每次都需要更少的比较。</p><p id="e621" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是不能识别该列表在第一次迭代中是否已经是排序的列表。这在冒泡排序算法中是可能的。</p><h1 id="93b2" class="lk ll in bd lm ln nq lp lq lr nr lt lu lv ns lx ly lz nt mb mc md nu mf mg mh bi translated"><strong class="ak"> 3。插入排序</strong></h1><p id="9ef1" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">该算法一次对列表中的一个元素进行排序。它的工作原理类似于你对手中扑克牌的排序。它将列表分为已排序和未排序部分。从未排序的部分选取元素，并将其推送到列表的排序部分。</p><h2 id="7839" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><a class="ae jz" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">伪代码</strong> </a> <strong class="ak"> : </strong></h2><pre class="kz la lb lc gt mz na nb nc aw nd bi"><span id="310b" class="mn ll in na b gy ne nf l ng nh">i ← 1<br/><strong class="na io">while</strong> i &lt; length(A)<br/>    j ← i<br/>    <strong class="na io">while</strong> j &gt; 0 <strong class="na io">and</strong> A[j-1] &gt; A[j]<br/>        <strong class="na io">swap</strong> A[j] and A[j-1]<br/>        j ← j - 1<br/>    <strong class="na io">end while</strong><br/>    i ← i + 1<br/><strong class="na io">end while</strong></span></pre><h2 id="b640" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">实施:</strong></h2><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/041e27804b5a5f26de13cddc5b7019bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kidBG4-zecUEgaxj5M67-w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The elements highlighted in red color are the ones that are swapped(sorted)</figcaption></figure><blockquote class="nk nl nm"><p id="2aee" class="ka kb ni kc b kd ke kf kg kh ki kj kk nn km kn ko no kq kr ks np ku kv kw kx ig bi translated">以红色突出显示的元素是交换的元素(已排序)。</p></blockquote><p id="e7f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">排序从第二个项目开始，因为只有一个元素的列表被视为已排序。该索引处的元素称为键。</em> <strong class="kc io"> <em class="ni">如果键小于索引j处的元素，则键向左移动一个位置。</em> </strong> <em class="ni">该过程继续，直到索引j处的元素小于该键。</em></p><h1 id="c77b" class="lk ll in bd lm ln nq lp lq lr nr lt lu lv ns lx ly lz nt mb mc md nu mf mg mh bi translated"><strong class="ak">最佳、最差和一般情况</strong></h1><p id="82ea" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">空间复杂度:O(n)总，O(1)辅助</p><p id="f3c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最坏情况时间复杂度:O(n)比较和交换</p><p id="65cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">平均案例时间复杂度:O(n)比较，O(1)交换</p><p id="17fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最佳情况时间复杂度:O(n)比较，O(1)交换</p><h2 id="faa0" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">该算法的关键要点</strong></h2><p id="cbbd" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">插入排序非常类似于选择排序算法。主要区别在于插入排序从关键字向后扫描，而选择排序向前扫描。也就是说，选择排序使第一个<em class="ni"> k </em>元素成为列表中最小的未排序部分。而在插入排序中，第一个<em class="ni"> k </em>元素只是列表中的元素。</p><h2 id="43ad" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">优势</strong></h2><p id="cfb8" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">该算法对于小数据集是有效的，并且比选择排序和冒泡排序更有效。该算法适用于排序或部分排序的数据集。它不改变具有相同键的元素的相对顺序，并且只需要恒定量O(1)的额外存储空间。</p><h1 id="3cd5" class="lk ll in bd lm ln nq lp lq lr nr lt lu lv ns lx ly lz nt mb mc md nu mf mg mh bi translated"><strong class="ak"> 4。快速排序</strong></h1><p id="7fa5" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">该算法是一种递归排序算法，遵循分治法。我们从列表中选择一个元素，通常是最后一个元素。这个元素是枢纽元素。元素以这样一种方式重新排列，即比枢轴小的元素移动到左侧。并且高于向右侧的枢轴移动。</p><p id="996c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个算法是一个<a class="ae jz" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">就地算法</a>，这意味着所有的数字都在原始数组本身中进行<strong class="kc io">排序。</strong></p><blockquote class="nk nl nm"><p id="a2d2" class="ka kb ni kc b kd ke kf kg kh ki kj kk nn km kn ko no kq kr ks np ku kv kw kx ig bi translated">递归是一个调用自身的函数。这个函数总是有一个阻止函数调用自身的条件。</p></blockquote><h2 id="8cef" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><a class="ae jz" href="https://www.geeksforgeeks.org/quick-sort/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">伪代码</strong> </a></h2><pre class="kz la lb lc gt mz na nb nc aw nd bi"><span id="8794" class="mn ll in na b gy ne nf l ng nh">/* low  --&gt; Starting index,  high  --&gt; Ending index */<br/>quickSort(arr[], low, high)<br/>{<br/>    if (low &lt; high)<br/>    {<br/>        /* pi is partitioning index, arr[pi] is now<br/>           at right place */<br/>        pi = partition(arr, low, high);<br/><br/>        quickSort(arr, low, pi - 1);  // Before pi<br/>        quickSort(arr, pi + 1, high); // After pi<br/>    }<br/>}</span></pre><h2 id="212b" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">实施</strong></h2><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/6f7ffbe3b82fafc121dcab4b5eea3cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDWQ9HQyjMg8m5BTeK_TWg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://www.geeksforgeeks.org/quick-sort/" rel="noopener ugc nofollow" target="_blank">Quick Sort implementation source</a></figcaption></figure><p id="52ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">首先，选择pivot元素，通过比较子数组是小于还是大于pivot，将数组分成两个子数组。这个过程一直持续到数组中的所有元素都排序完毕。</em></p><h2 id="1183" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">最佳、最差和一般情况</strong></h2><p id="b1b8" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">空间复杂度:O(n)</p><p id="c74e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最坏情况时间复杂度:O(n)</p><p id="0ce4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">平均案例时间复杂度:O(n log n)</p><p id="3398" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最佳情况时间复杂度:O(log n)简单分区</p><h2 id="5da9" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">该算法的关键要点</strong></h2><p id="3e90" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">Quicksort不是一个稳定的算法，因为它根据轴心的位置交换元素。由于该算法是适当的，所以当空间可用性存在限制时，它是适用的。</p><h1 id="2a91" class="lk ll in bd lm ln nq lp lq lr nr lt lu lv ns lx ly lz nt mb mc md nu mf mg mh bi translated"><strong class="ak"> 5。合并排序</strong></h1><p id="8e03" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">这个算法也是一种分治法。首先，数组被分成包含一个元素的更小的部分。较小的部分被重复合并，直到剩下一部分，形成一个排序的数组。</p><h2 id="070e" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><a class="ae jz" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">伪代码</strong> </a></h2><pre class="kz la lb lc gt mz na nb nc aw nd bi"><span id="b93b" class="mn ll in na b gy ne nf l ng nh"><strong class="na io">MergeSort(arr[], l,  r)</strong><br/>If r &gt; l<br/>     <strong class="na io">1. </strong>Find the middle point to divide the array into two halves:  <br/>             middle m = l+ (r-l)/2<br/>    <strong class="na io"> 2. </strong>Call mergeSort for first half:   <br/>             Call mergeSort(arr, l, m)<br/>     <strong class="na io">3.</strong> Call mergeSort for second half:<br/>             Call mergeSort(arr, m+1, r)<br/>     <strong class="na io">4. </strong>Merge the two halves sorted in step 2 and 3:<br/>             Call merge(arr, l, m, r)</span></pre><h2 id="aff3" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">实施</strong></h2><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/048ffb64a290ca6feaaadf98d552220b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*5N_oJ40Yheaqh3lX5cvpJg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="b858" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">首先，将数组分为两部分。除法过程以同样的方式继续，直到只剩下一个元素数组。在分割之后，子阵列被合并，从单个元素开始，以便每个合并的子阵列被排序。它重复进行，直到出现一个排序后的数组。</em></p><h2 id="b72e" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">最佳、最差和一般情况</strong></h2><p id="79f5" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">最坏情况时间复杂度:O(n log n)</p><p id="8005" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">平均案例时间复杂度:θ(n log n)</p><p id="b549" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最佳情况时间复杂度:ω(n log n)</p><h2 id="325a" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">合并排序的关键要点</strong></h2><p id="e71a" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">对于较大的数组大小或数据集，Mergesort效率更高，速度更快；而对于较小的数组大小或数据集，Quicksort效率更高，速度更快。它是稳定的，因为具有相等值的两个元素以与输入数组相同的顺序出现在排序输出中。</p><h2 id="9180" class="mn ll in bd lm mo mp dn lq mq mr dp lu kl ms mt ly kp mu mv mc kt mw mx mg my bi translated"><strong class="ak">结论</strong></h2><p id="0ec6" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">在本文中，我们介绍了排序算法和常见类型的排序算法。</p><p id="4b8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了正确的理解，开发人员就可以根据数据集的大小、空间和性能，找出有效使用哪种排序算法。</p><p id="e25e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！</p><p id="8f90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ni">plain English . io</em></strong></a></p></div></div>    
</body>
</html>