<html>
<head>
<title>Dynamically Add And Remove CanActivate Route Guards In Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态添加和删除可启用角度路由防护</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dynamically-add-and-remove-canactivate-route-guards-in-angular-e7820ab4e061?source=collection_archive---------4-----------------------#2021-02-08">https://javascript.plainenglish.io/dynamically-add-and-remove-canactivate-route-guards-in-angular-e7820ab4e061?source=collection_archive---------4-----------------------#2021-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f6d9558d2219cb7b0d617c023cf94801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EBURPg15HaDTRnJEkyRWQ.png"/></div></div></figure><p id="8f0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个角度应用程序都实现了通过路由表的导航。经验丰富的Angular开发人员意识到在路线上添加防护装置以确保路径安全的重要性。</p><p id="2ffc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时，开发人员可能会要求使用相同路径到达<strong class="jx io">的某些流不会被该路径上的守卫</strong>阻塞。很多时候，大多数开发人员通过在防护中添加额外的逻辑来实现这一点。这本身不是一个坏主意，但这意味着守卫在穿越路线时会被击中并激活，即使这不是必需的。</p><p id="45c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是<a class="ae kt" href="https://www.npmjs.com/package/aop-routing" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">AOP——路由</strong> </a> <strong class="jx io"> </strong>库进来的地方！</p><h2 id="5186" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">本文将解释如何使用aop-routing库，在运行时轻松更新Angular路由表，以在导航过程中移除或添加路由上的CanActivate防护。</h2><p id="82b9" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated"><strong class="jx io">从Angular version 11开始，没有在应用程序运行时动态添加或删除CanActivate防护的本机方法。</strong></p><p id="2fb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您没有听说过<strong class="jx io"> aop-routing </strong>库，请在这里阅读更多关于它的内容:<a class="ae kt" href="https://medium.com/analytics-vidhya/the-aop-routing-library-for-angular-9ada05f1741d" rel="noopener">Aop-routing for Angular</a></p><p id="fa85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ls"> Aop-Routing库通过简单的排版装饰器提供了在Angular中执行</em> <a class="ae kt" href="https://medium.com/analytics-vidhya/angular-routing-imperative-vs-popstate-7d254b495c54" rel="noopener"> <em class="ls">命令和Popstate导航</em> </a> <em class="ls">操作的能力，而不需要导入Angular Router对象。</em></p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bc230b28935bb79764c94bca1070e310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5b09Io3a4z-WB3zLG7DJ8w.png"/></div></div></figure><h2 id="78ea" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">让我们从3个简单的步骤将aop库添加到我们的角度应用程序开始:</h2><ol class=""><li id="cadd" class="me mf in jx b jy ln kc lo kg mg kk mh ko mi ks mj mk ml mm bi translated">将aop路由库安装到您的角度应用中</li></ol><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="1da0" class="ku kv in mo b gy ms mt l mu mv">npm install aop-routing</span></pre><p id="1205" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.安装库后，将<strong class="jx io"> AopRoutingModule </strong>添加到应用程序的顶层/根模块导入数组中。</p><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="59d5" class="ku kv in mo b gy ms mt l mu mv">imports: [<br/>   ...<br/>    AopRoutingModule<br/>  ]</span></pre><p id="72b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.将<strong class="jx io"> AopNavigationService </strong>依赖项添加到顶级/根模块构造函数中。</p><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="84c7" class="ku kv in mo b gy ms mt l mu mv">export class AppModule {<br/>  constructor(private navigationService: AopNavigationService) {}<br/> }</span></pre><p id="b8fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要启用aop路由库的动态路由表更新，请将以下对象添加到导入中的AopRoutingModule:</p><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="f74e" class="ku kv in mo b gy ms mt l mu mv"><br/>@NgModule({<br/> …<br/> imports: [<br/> …<br/> AopRoutingModule.forRoot({expirementNav<strong class="mo io">: </strong>true})<br/> ],<br/> …<br/>})</span></pre></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><p id="5c47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的示例源代码可以在Stackblitz中访问。<br/> <strong class="jx io">源代码:</strong></p><p id="e727" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://stackblitz.com/edit/aop-routing-dynamic-guards?file=src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/aop-routing-dynamic-guards?文件=src/app/app.component.ts </a></p><p id="c648" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">应用</strong>:</p><p id="2853" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://aop-routing-dynamic-guards.stackblitz.io" rel="noopener ugc nofollow" target="_blank">https://AOP-routing-dynamic-guards . stackblitz . io</a></p><p id="a8f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:为了正确显示打印输出，请确保来回导航到不同的页面。例如，如果您已经在第3页点击了“<strong class="jx io">移除第3页的防护装置</strong>”按钮，然后再次点击<strong class="jx io">第3页</strong>按钮，<strong class="jx io">您将看不到输出的差异，因为角度路由引擎知道它在同一个激活的组件</strong>上。要正确测试，请在不同页面之间来回导航，以查看正确的输出。</p><p id="460d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于以下示例，我们将使用下面的路由表:</p><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="840a" class="ku kv in mo b gy ms mt l mu mv">const routes: Routes = [</span><span id="57e1" class="ku kv in mo b gy mw mt l mu mv">{ path: "page1", component: Page1Component },</span><span id="25a5" class="ku kv in mo b gy mw mt l mu mv">{ path: "page2", component: Page2Component, canActivate: [TestGuard2] },</span><span id="9a9c" class="ku kv in mo b gy mw mt l mu mv">{ path: "page3", component: Page3Component, canActivate: [TestGuard2, TestGuard3] },</span><span id="a625" class="ku kv in mo b gy mw mt l mu mv">];</span></pre><p id="e679" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从上面的片段中可以得出以下结论:</p><ul class=""><li id="21d9" class="me mf in jx b jy jz kc kd kg mx kk my ko mz ks na mk ml mm bi translated">页面1在其路由上没有保护</li><li id="ff71" class="me mf in jx b jy nb kc nc kg nd kk ne ko nf ks na mk ml mm bi translated">页面2在其路线上有<strong class="jx io"> TestGuard2 </strong></li><li id="45b7" class="me mf in jx b jy nb kc nc kg nd kk ne ko nf ks na mk ml mm bi translated">页面3在其路线上有<strong class="jx io"> TestGuard2 </strong>和<strong class="jx io"> TestGuard3 </strong></li></ul><p id="cba9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我们的<strong class="jx io"> app.component.ts </strong>和<strong class="jx io">app.component.html</strong></p><p id="1f2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">AppComponent.ts有3个简单的方法，使用aop-routing库分别导航到页面1、页面2和页面3:</p><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="daf9" class="ku kv in mo b gy ms mt l mu mv">import { Component, VERSION } from "@angular/core";<br/>import { RouteNext } from "aop-routing";</span><span id="a7da" class="ku kv in mo b gy mw mt l mu mv">@Component({<br/>selector: "my-app",<br/>templateUrl: "./app.component.html",<br/>styleUrls: ["./app.component.css"]<br/>})</span><span id="d2c8" class="ku kv in mo b gy mw mt l mu mv">export class AppComponent {</span><span id="f398" class="ku kv in mo b gy mw mt l mu mv">name = "Angular " + VERSION.major;</span><span id="a2ef" class="ku kv in mo b gy mw mt l mu mv">@RouteNext("page1")<br/>public goToNextPage1() {<br/> this.setNavigationMessage("Navigating to page1");<br/> this.displayService.guardMsg = "";<br/>}</span><span id="062d" class="ku kv in mo b gy mw mt l mu mv">@RouteNext("page2")<br/>public goToNextPage2() {<br/> this.setNavigationMessage("Navigating to page2");<br/> this.displayService.guardMsg = "";<br/>}</span><span id="e0b5" class="ku kv in mo b gy mw mt l mu mv">@RouteNext("page3")<br/>public goToNextPage3() {<br/> this.setNavigationMessage("Navigating to page3");<br/> this.displayService.guardMsg = "";<br/>}</span><span id="75dd" class="ku kv in mo b gy mw mt l mu mv">}</span></pre><p id="eb32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">app.component.html</p><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="1f69" class="ku kv in mo b gy ms mt l mu mv">&lt;hello name="{{ name }}"&gt;&lt;/hello&gt;</span><span id="9100" class="ku kv in mo b gy mw mt l mu mv">&lt;p&gt;Start editing to see some magic happen :)&lt;/p&gt;</span><span id="b1ab" class="ku kv in mo b gy mw mt l mu mv">&lt;button (click)="goToNextPage1()"&gt;Page1&lt;/button&gt;</span><span id="02c0" class="ku kv in mo b gy mw mt l mu mv">&lt;button (click)="goToNextPage2()"&gt;Page2&lt;/button&gt;</span><span id="a802" class="ku kv in mo b gy mw mt l mu mv">&lt;button (click)="goToNextPage3()"&gt;Page3&lt;/button&gt;</span><span id="4b0f" class="ku kv in mo b gy mw mt l mu mv">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre><p id="4f79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是<strong class="jx io"> TestGuard2 </strong>的实现(其他守卫的实现基本相同)。当守卫被击中时，它会在屏幕上打印出友好的<strong class="jx io">‘来自守卫x </strong>的问候’。</p><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="5883" class="ku kv in mo b gy ms mt l mu mv">import { Injectable } from "@angular/core";<br/>import { CanActivate } from "@angular/router";</span><span id="976c" class="ku kv in mo b gy mw mt l mu mv">@Injectable({providedIn: "root"})<br/>export class TestGuard2 implements CanActivate {</span><span id="a836" class="ku kv in mo b gy mw mt l mu mv">public canActivate(): boolean {</span><span id="08b0" class="ku kv in mo b gy mw mt l mu mv"> this.displayService.addGuardMsg('Hello from guard 2');</span><span id="7500" class="ku kv in mo b gy mw mt l mu mv">return true;<br/>}}</span></pre><p id="8346" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单重述一下上面的代码，单击每个按钮将调用其对应的方法，这将输出消息消息'<strong class="jx io">导航到pagex </strong> ' <strong class="jx io"> </strong>，如果该页面上有守卫，守卫将登录到屏幕'<strong class="jx io">Hello from guard x【T27]'</strong></p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/aaf47cbbd893f573612b0d2104ef1d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVbVNv0K8iZ7VL1u59kFEg.png"/></div></div></figure></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="719b" class="nh kv in bd kw ni nj nk kz nl nm nn lc no np nq lf nr ns nt li nu nv nw ll nx bi translated">向路径动态添加防护</h1><p id="ddda" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">让我们看看在应用程序运行时给page1添加一个保护是多么容易。</p><p id="a059" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们看看单击Page1以确定其路由上没有保护的输出。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/6338cd9903e5c55d98f01b6ad99a59ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZsfHJYnjMjjSrRWJmgjKQA.png"/></div></div></figure><ol class=""><li id="9615" class="me mf in jx b jy jz kc kd kg mx kk my ko mz ks mj mk ml mm bi translated">我们将创建一个名为'<strong class="jx io"> Page1 with guard </strong>的新按钮，它将调用在AppComponent.ts中创建的新方法'<strong class="jx io"> addGuardToPage1 </strong></li></ol><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="94f3" class="ku kv in mo b gy ms mt l mu mv">import { RouteNext, RouteTransform } from "aop-routing";<br/>import { TestGuard1 } from "./pages/guards/testguard1";</span><span id="4c64" class="ku kv in mo b gy mw mt l mu mv">@RouteNext()<br/>public addGuardToPage1() {</span><span id="5ad8" class="ku kv in mo b gy mw mt l mu mv">this.setNavigationMessage("Navigating to page1 and adding guard");<br/>this.displayService.guardMsg = "";</span><span id="81c7" class="ku kv in mo b gy mw mt l mu mv">const routeTransform: RouteTransform = {<br/>    path: 'page1',<br/>    canActivateGuards: [TestGuard1]<br/> };<br/>return {routeTransform}</span><span id="b779" class="ku kv in mo b gy mw mt l mu mv">}</span></pre><p id="9d2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.点击新的<strong class="jx io">‘带防护装置的第1页</strong>’按钮将把<strong class="jx io">测试防护装置1 </strong>添加到<strong class="jx io">第1页</strong>并导航到它。下面是输出。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/12429ba13fdc58335bb8e22f089d68c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oj1HQZNZ3xgSJOCz7SNbAA.png"/></div></div></figure></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="4b01" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">动态移除路线中的防护:</h2><ol class=""><li id="43e9" class="me mf in jx b jy ln kc lo kg mg kk mh ko mi ks mj mk ml mm bi translated">我们将创建一个名为“移除第3页上的防护”的新按钮，该按钮将调用在AppComponent.ts中创建的新方法“<strong class="jx io"> removeGuardOnPage3 </strong>”。该方法将从第3页路由中移除<strong class="jx io"> TestGuard2 </strong>，但保留<strong class="jx io"> TestGuard3 </strong>。</li></ol><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="7e4e" class="ku kv in mo b gy ms mt l mu mv">@RouteNext()<br/>public removeGuardOnPage3() {</span><span id="8955" class="ku kv in mo b gy mw mt l mu mv">this.setNavigationMessage("Navigating to page3 and removing TestGuard2 from its path");</span><span id="6206" class="ku kv in mo b gy mw mt l mu mv">this.displayService.guardMsg = "";</span><span id="de5c" class="ku kv in mo b gy mw mt l mu mv">const routeTransform: RouteTransform = {<br/>path: "page3",<br/>canActivateGuards: [TestGuard2]<br/>};</span><span id="15fa" class="ku kv in mo b gy mw mt l mu mv">return { routeTransform };</span><span id="e614" class="ku kv in mo b gy mw mt l mu mv">}</span></pre><p id="d0da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们回想一下，当我们点击第3页按钮导航到第3页时，它将点击TestGuard2和TestGuard3，输出如下</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi gj"><img src="../Images/27403c329a6b9f1dea9b9cb18f84ed30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlWKYd1xY-cczGzVwTiY6A.png"/></div></div></figure><p id="d604" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.现在，当我们单击“<strong class="jx io">移除第3页上的特定守卫</strong>”按钮时，您会注意到导航不会点击<strong class="jx io"> TestGuard2 </strong>，并且我们将不再看到来自守卫2 的输出“<strong class="jx io"> Hello”</strong></p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/b11ce67a0d0d94f927a47dc8ce7b3e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHMq1UREZBbWzHjnTDNBIQ.png"/></div></div></figure><p id="3852" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">您会注意到添加和删除特定防护的代码是相同的</strong>。这是因为aop-routing库很聪明，知道如果传递给它的动作的保护已经存在，它将删除它，否则它将添加它。</p><blockquote class="ob oc od"><p id="8782" class="jv jw ls jx b jy jz ka kb kc kd ke kf oe kh ki kj of kl km kn og kp kq kr ks ig bi translated">aop-routing库很聪明，它知道如果传递给它动作的保护已经存在，它将删除它，否则它将添加它。</p></blockquote></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="af01" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">移除路线上的所有防护装置:</h2><p id="8c0a" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">从一条路由中删除所有的保护非常简单，就像上一步一样，所需要做的就是<strong class="jx io">向RouteTransform对象</strong>的canActivateGuards属性返回一个空数组。</p><ol class=""><li id="20ba" class="me mf in jx b jy jz kc kd kg mx kk my ko mz ks mj mk ml mm bi translated">我们将创建一个名为“移除第3页上的所有防护”的新按钮，该按钮将调用在AppComponent.ts中创建的新方法“<strong class="jx io"> removeAllGuardOnRoute </strong>”。该方法将移除第3页路径上的所有防护。</li></ol><pre class="ma mb mc md gt mn mo mp mq aw mr bi"><span id="5f11" class="ku kv in mo b gy ms mt l mu mv">@RouteNext()<br/>public removeAllGuardOnRoute() {</span><span id="d567" class="ku kv in mo b gy mw mt l mu mv">this.setNavigationMessage("Navigating to page3 and removing all guards in its path");</span><span id="8b06" class="ku kv in mo b gy mw mt l mu mv">this.displayService.guardMsg = "";</span><span id="be88" class="ku kv in mo b gy mw mt l mu mv">const routeTransform: RouteTransform = {<br/>path: "page3",<br/>canActivateGuards: []<br/>};</span><span id="382d" class="ku kv in mo b gy mw mt l mu mv">return { routeTransform };</span><span id="5f42" class="ku kv in mo b gy mw mt l mu mv">}</span></pre><p id="993c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.现在，当我们点击第页上的“<strong class="jx io">移除所有守卫”时，我们将不会看到任何守卫被击中，也不会看到他们的任何消息被打印到屏幕上。我们只会看到打印到屏幕上的'<strong class="jx io">导航到第3页并移除其路径上的所有防护装置</strong>':</strong></p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/81cc4cd864312417fa8bf8648457f41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qeacCEsJKd0moAbr60lX7w.png"/></div></div></figure><p id="2625" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>需要记住的一点是，<strong class="jx io">当aop-routing库更新路由表时，它会在导航完成后将其恢复到原始状态。</strong></p><p id="c0d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢这篇文章，一定要看看我下面的其他文章！</p><ul class=""><li id="2e5f" class="me mf in jx b jy jz kc kd kg mx kk my ko mz ks na mk ml mm bi translated"><a class="ae kt" href="https://medium.com/p/b324d20cc277" rel="noopener"> <strong class="jx io">地图vs WeakMap </strong> </a></li><li id="8257" class="me mf in jx b jy nb kc nc kg nd kk ne ko nf ks na mk ml mm bi translated"><a class="ae kt" href="https://medium.com/analytics-vidhya/the-aop-routing-library-for-angular-9ada05f1741d" rel="noopener"><strong class="jx io">Aop-路由库</strong> </a></li><li id="849b" class="me mf in jx b jy nb kc nc kg nd kk ne ko nf ks na mk ml mm bi translated"><a class="ae kt" href="https://medium.com/analytics-vidhya/angular-routing-imperative-vs-popstate-7d254b495c54" rel="noopener"> <strong class="jx io">角度路由:命令式vs PopState </strong> </a></li><li id="bf17" class="me mf in jx b jy nb kc nc kg nd kk ne ko nf ks na mk ml mm bi translated"><a class="ae kt" href="https://ericsarpong.medium.com/asynchronous-programming-in-a-nutshell-theory-d5fd07cf3b22" rel="noopener"> <strong class="jx io">简单地说异步编程(理论)</strong> </a></li><li id="2691" class="me mf in jx b jy nb kc nc kg nd kk ne ko nf ks na mk ml mm bi translated"><a class="ae kt" href="https://medium.com/@ericsarpong/what-is-a-typescript-tuple-814a016f61fd" rel="noopener"> <strong class="jx io">什么是类型脚本元组</strong> </a></li><li id="8fc3" class="me mf in jx b jy nb kc nc kg nd kk ne ko nf ks na mk ml mm bi translated"><a class="ae kt" href="https://medium.com/@ericsarpong/deep-dive-into-javascript-map-object-24c012e0b3fe" rel="noopener"> <strong class="jx io">深度潜入Javascript图</strong> </a></li></ul></div></div>    
</body>
</html>