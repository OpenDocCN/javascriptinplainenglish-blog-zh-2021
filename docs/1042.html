<html>
<head>
<title>Tailwind JSX and class composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">顺风JSX与班级作文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tailwind-jsx-and-class-composition-e62946f030f7?source=collection_archive---------16-----------------------#2021-03-04">https://javascript.plainenglish.io/tailwind-jsx-and-class-composition-e62946f030f7?source=collection_archive---------16-----------------------#2021-03-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b2df63ec84608d236adc9817cf92a0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvWUyiaOF-TGPjObNz7jOA.jpeg"/></div></div></figure><p id="2524" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae kt" href="https://areknawo.com/my-mixed-feelings-about-tailwind-css/" rel="noopener ugc nofollow" target="_blank">我初看</a>在<a class="ae kt" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">T5】顺风CSS  </a>之后，就没怎么用过了。正如我在以前的博客中所说，我对顺风的感觉是复杂的。我欣赏实用优先、受约束的设计，但不喜欢它的类如何“膨胀”我的HTML代码，也不喜欢它的配置过程如何乏味。</p><h1 id="8f52" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">顺风2.0版</h1><p id="b7f7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">话虽如此，我在开发我的产品时又看了一眼Tailwind—<a class="ae kt" href="https://codewrite.io" rel="noopener ugc nofollow" target="_blank">code write</a>(开发人员的博客工具)。我用Vue 3 构建了它，由于当时没有任何好的UI库，我决定用Tailwind。</p><p id="fd97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在在<a class="ae kt" href="https://blog.tailwindcss.com/tailwindcss-v2" rel="noopener ugc nofollow" target="_blank"> v2.0 </a>中，Tailwind没有太大变化。然而，在经历了最初的配置痛苦之后，我体验了在中等规模的代码库中使用它的感觉。老实说，这是非常好的！我通过修改我的格式配置绕过了<code class="fe lx ly lz ma b">className</code>“膨胀”,并且在<strong class="jx io"> WebStorm </strong>中为Tailwind类提供了良好的自动完成功能，工作流非常流畅。</p><h1 id="7d34" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">班级作文</h1><p id="3e3e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">然而，随着项目的发展，一个新的问题出现了，它与创建新的组件有关。</p><p id="e867" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Vue中，有一个很好的特性，可以自动将DOM属性传递给顶层组件节点，我经常使用它。这可能不是最佳实践，因为它可能对可伸缩性不利，但是如果您正确使用它，它可以创造奇迹。</p><p id="f096" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也就是说，顺风并不容易。因为所有的实用程序类都是自动排序的，所以当你想改变<code class="fe lx ly lz ma b">Button</code>组件的填充时，你不能覆盖“默认”类。</p><p id="e9e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">许多顺风用户都<a class="ae kt" href="https://github.com/tailwindlabs/tailwindcss/discussions/1446" rel="noopener ugc nofollow" target="_blank">知道这个实用程序类组合的问题。可悲的是，没有明确的解决方案，所有可用的都只是一堆变通办法。除非Tailwind的架构或CSS的本质发生了变化(不确定)，否则我们只能使用现有的东西。</a></p><h2 id="2b44" class="mb kv in bd kw mc md dn la me mf dp le kg mg mh li kk mi mj lm ko mk ml lq mm bi translated">变通办法</h2><p id="e272" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">那么，我们如何解决这个问题呢？嗯，有几种方法，从完全放弃课堂作文开始…</p><p id="3fee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">弃课作文</strong></p><p id="8c56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果没有类组合，您将失去一些灵活性，并且不得不编写一些额外的代码。然而，它也可以引导您为您的组件创建一个更加稳定和可伸缩的基础。</p><p id="b1ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那是我走的路线。我分析了改变组件以适应所有用例的所有方法，并将它们集成到基于prop的配置中。然后，这个配置与一个小的实用函数一起用于生成最终的<code class="fe lx ly lz ma b">className</code>字符串。</p><p id="e9f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">@应用指令</strong></p><p id="05fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个解决方案是使用<code class="fe lx ly lz ma b">@apply</code> <a class="ae kt" href="https://tailwindcss.com/docs/functions-and-directives#apply" rel="noopener ugc nofollow" target="_blank">指令</a>提取组件的基本样式(在其他Tailwind类之前)。这样，您就可以随时轻松地覆盖样式。</p><p id="3767" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，您仍然只能进行一次覆盖，这种解决方案会将您的CSS实用程序类从您的HTML/JSX剥离到外部CSS文件中，这可能不是您想要的。</p><p id="c630" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> twin.macro </strong></p><p id="0a08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，你可以使用一个名为<a class="ae kt" href="https://github.com/ben-rogerson/twin.macro" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> twin.macro </em> </a>或类似的库。它<em class="mn">“融合了Tailwind的魔力和CSS-in-JS的灵活性</em>它是一个<a class="ae kt" href="https://github.com/kentcdodds/babel-plugin-macros" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Babel宏</strong></a>——一种在编译时由Babel处理的实用函数，其结果会直接插入到您的代码中。在这种情况下，它将Tailwind实用程序类处理成CSS字符串，可以与您选择的CSS-in-JS库一起使用(<code class="fe lx ly lz ma b">emotion</code>、<code class="fe lx ly lz ma b">styled-components</code>、<code class="fe lx ly lz ma b">goober</code>)。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cd18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其工作方式是，使用CSS字符串，您本质上做一些类似于<code class="fe lx ly lz ma b">@apply</code>指令的事情，但是在JS-Babel宏级别。使用生成的CSS字符串和CSS-in-JS的强大功能，您可以创建一个新的CSS类——一个不会与它后面的任何类发生冲突的类。</p><p id="d055" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法真正解决了构图问题。它确实涉及更多的运行时处理，并且需要使用Babel宏，但是可以为您的代码增加很多灵活性，并且没有任何其他缺点。</p><h1 id="f66b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">运行时顺风</h1><p id="abfd" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">所以，看起来<code class="fe lx ly lz ma b">twin.macro</code>很有优势。不如我们更进一步？</p><p id="c835" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显然，<strong class="jx io"> CSS-in-JS </strong>是顺风中的类组成的解决方案。然而，<code class="fe lx ly lz ma b">twin.macro</code>仅仅是抓伤了它的潜力，被巴别塔宏的可能性所限制。您必须正确地导入它(常量<code class="fe lx ly lz ma b">import tw from 'twin.macro'</code>，在每个文件的顶部，没有自动插入或重新导出它的可能性)，并且自动完成是有缺陷的。当然，它节省了一些运行时性能，但是如果我们愿意牺牲它来获得更好的开发体验呢？</p><p id="5cc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你对假设的<em class="mn">《顺风JSX》</em>有什么看法？一个库，在这里你的类实用程序变成了JSX道具，一个与你选择的JS框架完美集成的库，在TSX时提供了强大的自动完成功能，并且由于CSS-in-JS的强大功能，可以很容易地编写？</p><p id="7b3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“顺风JSX”并不存在，但是有一些图书馆做着我刚刚描述的事情——让我们去看看吧！</p><h1 id="c902" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">风格化的系统/主题用户界面</h1><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/7c9bbbaa8d05681a1cdae257881dca07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNYKpbp_AEoP4ZBu3LvYOw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Styled System landing page</figcaption></figure><p id="f6d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://styled-system.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Styled System </strong> </a>是一个利用道具进行UI开发的React库。</p><p id="68bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有点像顺风，但对JS来说。它允许你为“受约束的设计”定义一个主题，创建可以在整个UI中使用的自定义道具，并以用户熟悉的方式完成所有这些——通过<strong class="jx io">道具</strong>和<a class="ae kt" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">样式化组件</em> </a>。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8462" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可悲的是，风格化系统的开发似乎有点过时了。<a class="ae kt" href="https://theme-ui.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">主题UI </strong> </a>可以认为是它的“精神继承者”。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/94d433c42d7f842f2e83d931f6602ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pA01QGMGyhQozUyW8E1aPQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Theme UI landing page</figcaption></figure><p id="d2fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它由同一个系统UI团队开发，有更多的功能，但是使用了一个<code class="fe lx ly lz ma b">sx</code>道具，而不是像它的前身那样使用多个。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0ac9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就我个人而言，我更喜欢风格化系统的方法，但是主题用户界面还是很不错的。</p><h1 id="7c19" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">XStyled</h1><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/218dd06d3732ecee0c5ecebe2fd3d66c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vMl-iGp_ZRHriYs4Ta1nQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">XStyled landing page</figcaption></figure><p id="4942" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，<a class="ae kt" href="https://xstyled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> XStyled </strong> </a>差不多是你能得到的最接近“官方”顺风JSX的了。它的文档看起来很熟悉，作者<a class="ae kt" href="https://xstyled.dev/docs/introduction/" rel="noopener ugc nofollow" target="_blank">公开陈述了</a>它的顺风灵感。</p><p id="7187" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">XStyled与React和<em class="mn">风格化组件</em>或<em class="mn">情感</em>一起作为“插件”放在它们上面。它的功能与Tailwind和Styled组件非常相似——您已经有了所有的“实用道具”,您可以在以<code class="fe lx ly lz ma b">x</code>命名的元素上使用它们，并且还有一个用于约束设计的配置。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0f89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">XStyled很快引起了我的注意。它的文档很详细，打字稿自动补全功能也很有效。</p><p id="4863" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，在使用Tailwind之后，有些实用程序的名称非常冗长，我无法习惯。例如，我不得不像在《顺风》中那样使用<code class="fe lx ly lz ma b">position=”fixed”</code>而不是<code class="fe lx ly lz ma b">fixed</code>，但这只是一个你可以忽略的吹毛求疵。</p><h1 id="4544" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Chakra UI</h1><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/9a5d0a7487a28fd300d8d228c31f0132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpHtWm0awTkyzYthdhondg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Chakra UI landing page</figcaption></figure><p id="120a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，<a class="ae kt" href="https://chakra-ui.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Chakra UI </strong> </a>是其中最受欢迎的(至少基于GitHub stars)——这是有原因的。它就像是前面提到的所有库的最佳组合，在它上面有一个完整的UI库！</p><p id="49cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Chakra UI结合了类似于XStyled中看到的“实用工具-道具”(但这次用了更多的快捷键— <code class="fe lx ly lz ma b">position = pos</code>)，以及Styled系统中的简单配置，还有额外的<code class="fe lx ly lz ma b">sx</code>道具以防你需要。所有这些，还有一个现成的、可访问的、高度可配置的组件库(他们可以使用所有的实用工具)。基本上，这是一个一体化的包，包含了你想从基于运行时的Tailwind的最佳版本中得到的一切！</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9fe5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，您已经有了创建您可能想要的组件的所有方法，您已经有了一个现成的组件的大集合，以及一系列其他特性。TypeScript支持非常好(甚至有一个<a class="ae kt" href="https://chakra-ui.com/docs/theming/advanced#theme-typings" rel="noopener ugc nofollow" target="_blank">特殊的CLI工具</a>来为不可能生成类型的地方生成类型)，我想我唯一的抱怨是它只适用于React。</p><h1 id="6bba" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="0745" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">你对所有这些基于JSX的运行时顺风替代品有什么看法？</p><p id="51f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就我个人而言，我认为他们真的有所发现。他们提供的开发体验只是在另一个层面上。Chakra UI显然是最好的，但其他人都很接近。</p><p id="d174" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管如此，顺风公司仍有很多优势。它是所有软件中最不冗长的，它的命名方案使用起来很棒，也很容易记住，它不涉及任何JavaScript处理，而且——对我来说最重要的是——它是独立于框架的。</p><p id="b3db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，由于我对Vue 3的热爱，我将坚持使用Tailwind和我自己的类编写工具。我可能会考虑使用<code class="fe lx ly lz ma b">twin.macro</code>或者甚至建造“我自己的脉轮UI ”,但是对于Vue来说，那是遥远的未来。</p><p id="f29c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，要了解更多的web dev和Tailwind内容，请在<a class="ae kt" href="https://twitter.com/areknawo" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kt" href="https://www.facebook.com/areknawoblog" rel="noopener ugc nofollow" target="_blank">脸书</a>或通过<a class="ae kt" href="#newsletter" rel="noopener ugc nofollow">我的简讯</a>关注我。感谢阅读，并有一个不错的编码！</p></div></div>    
</body>
</html>