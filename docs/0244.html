<html>
<head>
<title>Scaling Performance in Vue.js Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js应用中的扩展性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/scaling-performance-in-vue-js-applications-a868c8746cef?source=collection_archive---------2-----------------------#2021-01-14">https://javascript.plainenglish.io/scaling-performance-in-vue-js-applications-a868c8746cef?source=collection_archive---------2-----------------------#2021-01-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f723" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Vue.js应用中的扩展性能和优化。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/231c5471461f7943ab4af97be9ffca65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y7P6M-BgBUoII27b"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lukepeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luke Peters</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7668" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">vue应用程序的性能优化在应用程序体系结构中起着重要的作用。</p><p id="64c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更高性能的应用程序将确保提高用户保留率、改善用户体验和更高的转化率。</p><p id="96d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据谷歌的研究，如果加载时间超过3秒，53%的移动用户会离开网站？除此之外，超过一半的测试页面超过2MB。</p><p id="0a63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您的应用性能直接影响其搜索排名和转化率。另一方面，Pinterest将他们的初始等待时间缩短了40%，这导致搜索引擎流量和注册量增加了15%。沃尔玛也有类似的结果，每减少一秒钟的装载时间，他们的转化率就增加2%。</p><p id="e1c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一方面，必应的研究表明，2秒钟的延迟导致每个访问者的收入损失4.3%，点击量减少3.75%。</p><p id="add7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更高的性能将确保您的公司或业务增加其用户保留率，这意味着销售或利润的增加。</p><p id="cf61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">我们如何在VueJS应用程序中实现性能？</strong></p><p id="c716" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将看到我们可以实现的各种方法来提高VueJS应用程序的性能和优化。</p><p id="9b89" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">异步组件加载/惰性加载</strong></p><p id="c8b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">组件的异步加载是惰性加载应用程序部分(块)的过程。它确保了组件只在需要的时候被加载。</p><p id="ceb5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据vueshool.io的说法，Lazy loading可以确保捆绑包被拆分，并且只提供需要的部分，这样用户就不会浪费时间下载和解析不使用的代码。</p><p id="7e3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">部件同步/静态加载</strong></p><p id="505c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">组件的静态加载是用默认的import语句加载组件。，我们使用如下所示的本机导入语法。</p><p id="3a34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">加载了静态import语句的组件将被添加到现有的应用程序捆绑包中。如果不使用代码拆分，那么应用程序核心将变得更大，从而影响应用程序的整体性能。</p><p id="1b7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面的代码片段将动态加载照片组件。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="827a" class="lu lv in lq b gy lw lx l ly lz">// static loading of the photo component</span><span id="8fb4" class="lu lv in lq b gy ma lx l ly lz">import Photos from “@/components/photos”;</span></pre><p id="2893" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了动态加载组件，我们必须从默认的静态组件导入更改为动态组件导入。</p><p id="ba34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">构件动态加载</strong></p><p id="7fb2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了动态加载一个组件，我们声明了一个常量并附加了一个arrow函数，后跟默认的静态import语句。</p><p id="7cad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也可以添加一个网络包魔术评论。注释将告诉webpack为我们的块分配我们提供的名称，否则webpack将自动生成一个名称。</p><p id="eaf0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">参见下面的示例。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="e381" class="lu lv in lq b gy lw lx l ly lz">// dynamic import of the photos component</span><span id="2687" class="lu lv in lq b gy ma lx l ly lz">const Photos = () =&gt;import(/* webpackChunkName: “Photos” */ “@/components/photos”);</span></pre><p id="1e63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们转到我们的开发工具并打开网络标签，我们可以看到我们的块已经被分配了我们在webpack的块名注释中提供的名称。</p><p id="0313" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">见下文</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mb"><img src="../Images/f4736e94f4f4d6948d5bc10a653422d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o3Z7yePGv4ZMmoyC"/></div></div></figure><p id="b074" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Webpack的神奇评论</p><p id="9c41" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了vue3，我们可以使用暂记定义组件来延迟加载组件。</p><p id="ad3a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">悬念使得在加载过程中显示回退内容变得容易。暂停边界还有助于控制视图部分何时准备好进行渲染。</p><p id="9989" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要使用defineAsyncComponent，我们首先必须从vue导入它，以便在我们的应用程序中使用。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="8708" class="lu lv in lq b gy lw lx l ly lz">// dynamic import of the photos component with suspense</span><span id="e448" class="lu lv in lq b gy ma lx l ly lz">&lt;template&gt;</span><span id="c360" class="lu lv in lq b gy ma lx l ly lz">&lt;img alt=”Vue logo” src=”./assets/logo.png” /&gt;</span><span id="1965" class="lu lv in lq b gy ma lx l ly lz">&lt;HelloWorld msg=”Welcome to Your Vue.js App” /&gt;</span><span id="f72c" class="lu lv in lq b gy ma lx l ly lz">&lt;/template&gt;</span><span id="3c8a" class="lu lv in lq b gy ma lx l ly lz">&lt;script&gt;</span><span id="4650" class="lu lv in lq b gy ma lx l ly lz"><em class="mc">import</em> { defineAsyncComponent } <em class="mc">from</em> “vue”;</span><span id="6dcb" class="lu lv in lq b gy ma lx l ly lz">const HelloWorld = defineAsyncComponent(() =&gt;</span><span id="3b59" class="lu lv in lq b gy ma lx l ly lz">import(“./components/HelloWorld.vue”)</span><span id="6e71" class="lu lv in lq b gy ma lx l ly lz">);</span><span id="d828" class="lu lv in lq b gy ma lx l ly lz"><em class="mc">export</em> <em class="mc">default</em> {</span><span id="7e1d" class="lu lv in lq b gy ma lx l ly lz">name: “App”,</span><span id="6e42" class="lu lv in lq b gy ma lx l ly lz">components: {</span><span id="4e71" class="lu lv in lq b gy ma lx l ly lz">HelloWorld,</span><span id="24cb" class="lu lv in lq b gy ma lx l ly lz">},</span><span id="0cb0" class="lu lv in lq b gy ma lx l ly lz">};</span><span id="a9de" class="lu lv in lq b gy ma lx l ly lz">&lt;/script&gt;</span></pre><p id="9ce4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于vue 3中组件异步加载的更多信息</p><div class="md me gp gr mf mg"><a href="https://medium.com/javascript-in-plain-english/asynchronous-component-loading-in-vue-3-f8cd0860da23" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">Vue 3中的异步组件加载</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">使用defineAsyncComponent在Vue 3中异步加载</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">medium.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu km mg"/></div></div></a></div><p id="c802" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">惰性装载路线</strong></p><p id="a0d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当使用完全构建在VueJS之上的Nuxtjs时，它会开箱即用地对每个路由进行代码拆分。</p><p id="ba5b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要延迟加载路径，只需使用与我们延迟加载组件相同的方式。</p><p id="3052" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> WebP图像和图像压缩</strong></p><p id="51ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">优化应用程序时，图像压缩非常重要。与较大的图像文件相比，较亮的图像执行速度更快。除此之外，更小的图像也会导致更少的加载时间。</p><p id="b127" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过压缩图像，我们使我们的网站变得更轻，从而提供更短的加载时间。</p><p id="97bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">什么是WebP？</strong></p><p id="fef5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一种新的网络图像格式。</p><p id="ede7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">WebP是一种现代图像格式，为网络上的图像提供卓越的无损和有损压缩。使用WebP，网站管理员和web开发人员可以创建更小、更丰富的图像，使web速度更快。</p><p id="e1b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据<a class="ae ks" href="https://developers.google.com/speed/webp" rel="noopener ugc nofollow" target="_blank"> dev Mozilla </a>的说法，WebP无损图像的大小比png小26%。在同等的SSIM质量指数下，WebP有损图像比可比较的JPEG图像小25–34%。</p><p id="c132" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">无损WebP支持透明性(也称为alpha通道),成本仅为22%的额外字节。对于可接受有损RGB压缩的情况，有损WebP也支持透明，通常提供比PNG小3倍的文件大小。</p><p id="fdd1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从14版本开始，Chrome、Firefox、Edge和Safari都支持WebP。</p><p id="170d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们将JPG图像转换为WebP，并注意大小和性能的差异。WebP图像在保持图像质量的同时具有最小的尺寸。</p><p id="250d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">转换前</strong></p><p id="e00c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Jpg图像文件(70.1kb)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a95958e01f5fb0021d69ee56a1805cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/0*0t4IrLiDwciaSVGG"/></div></figure><p id="cf81" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">未优化的jpg文件</p><p id="2f0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">原始jpg图像(转换前)</p><p id="a8ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">转换后</strong></p><p id="7621" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">WebP图像文件(3.43kb)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8dd76371397403bd3a02fdf3ad0ea4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/0*47dYX8D4a28Jir5l"/></div></figure><p id="9809" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最终图像(转换后)</p><p id="8d36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望你能看到这个巨大的碎片变成了一个更小的图像文件。</p><p id="093e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从70.1kb到3.43kb的羽毛大小。更轻的图像文件不是吗？</p><p id="4a80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我还找到了这个网站，它帮助我将图片转换成网络视频</p><p id="d9cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">代码拆分</strong></p><p id="84fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">代码拆分是将应用程序拆分成延迟加载的程序块的过程。</p><p id="675d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据dev Mozilla的说法，代码分割是将代码分割成不同的包或组件，然后按需或并行加载。</p><p id="c942" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">随着应用程序变得越来越复杂或被维护，CSS和JavaScripts文件或包的字节数也会增加，尤其是当包含的第三方库的数量和大小增加时。</p><p id="c2ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了避免下载巨大文件的需求，可以将脚本分割成多个较小的文件。然后，页面加载时所需的功能可以立即下载，在页面或应用程序交互后，额外的脚本可以延迟加载，从而提高性能。虽然代码总量是相同的(甚至可能多几个字节)，但初始加载期间所需的代码量可以减少。</p><p id="76d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">代码分割是Webpack和Browserify等捆绑包支持的一个特性，它们可以创建多个可以在运行时动态加载的捆绑包。</p><p id="2392" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们如何使用webpack进行代码拆分</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="a224" class="lu lv in lq b gy lw lx l ly lz"><em class="mc">// Build Configuration (https://go.nuxtjs.dev/config-build)</em></span><span id="e441" class="lu lv in lq b gy ma lx l ly lz">build: {</span><span id="e390" class="lu lv in lq b gy ma lx l ly lz">configureWebpack: {</span><span id="598e" class="lu lv in lq b gy ma lx l ly lz">optimization: {</span><span id="3558" class="lu lv in lq b gy ma lx l ly lz">runtimeChunk: ‘single’,</span><span id="b40b" class="lu lv in lq b gy ma lx l ly lz">splitChunks: {</span><span id="50eb" class="lu lv in lq b gy ma lx l ly lz">chunks: ‘all’,</span><span id="c441" class="lu lv in lq b gy ma lx l ly lz">maxInitialRequests: Infinity,</span><span id="3c8d" class="lu lv in lq b gy ma lx l ly lz">minSize: 0,</span><span id="d994" class="lu lv in lq b gy ma lx l ly lz">cacheGroups: {</span><span id="4345" class="lu lv in lq b gy ma lx l ly lz">vendor: {</span><span id="18d4" class="lu lv in lq b gy ma lx l ly lz">test: /[\\/]node_modules[\\/]/,</span><span id="8518" class="lu lv in lq b gy ma lx l ly lz">name(module) {</span><span id="1568" class="lu lv in lq b gy ma lx l ly lz">const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|<em class="mc">$</em>)/)[1];</span><span id="7b0e" class="lu lv in lq b gy ma lx l ly lz"><em class="mc">return</em> `npm.${packageName.replace(‘@’, ‘’)}`;</span><span id="4d62" class="lu lv in lq b gy ma lx l ly lz">},},},},},},</span><span id="47a8" class="lu lv in lq b gy ma lx l ly lz">analyze: true,</span><span id="5cf7" class="lu lv in lq b gy ma lx l ly lz">}</span></pre><p id="3d4b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">使用purge提取未使用的CSS </strong></p><p id="a42b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当你构建你的应用程序时，你可能会决定使用一个CSS框架，比如TailwindCSS，Bootstrap，MaterializeCSS，Foundation等等。但是您将只使用一小部分框架样式，并且会包含许多未使用的CSS样式。</p><p id="bffc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据<a class="ae ks" href="https://purgecss.com/" rel="noopener ugc nofollow" target="_blank">的说法，PurgeCSS </a>是一个移除无用CSS的工具。它可以是你开发工作流程的一部分。</p><p id="c2b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是PurgeCSS发挥作用的地方。PurgeCSS分析我们的应用程序内容、样式和您的CSS文件。然后，它将文件中使用的选择器与内容文件中的选择器进行匹配。它从你的CSS中移除未使用的选择器，产生更小的CSS文件</p><p id="8ac7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">资源</strong></p><ul class=""><li id="1933" class="mx my in kv b kw kx kz la lc mz lg na lk nb lo nc nd ne nf bi translated"><a class="ae ks" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js官方文档</a></li><li id="9cbd" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated"><a class="ae ks" href="https://purgecss.com/" rel="noopener ugc nofollow" target="_blank">清除CSS文档。</a></li><li id="1bc5" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated"><a class="ae ks" href="https://developer.mozilla.org" rel="noopener ugc nofollow" target="_blank">开发上颌文档。</a></li></ul><p id="260b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">结论</strong></p><p id="2312" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简单回顾一下，我们已经看到了一些实现VueJS应用程序性能和优化的最佳实践。</p><p id="8ab7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在VueJS应用程序中扩展性能和优化的一些方法有:</p><ul class=""><li id="17e7" class="mx my in kv b kw kx kz la lc mz lg na lk nb lo nc nd ne nf bi translated">组件的异步加载</li><li id="01c8" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">异步装载路线</li><li id="dfdf" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">图像压缩或使用WebP图像</li><li id="90ff" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">未使用的CSS样式的树抖动(当使用CSS框架时)</li></ul><p id="c91d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢您通读这篇文章。如果你觉得这篇文章有帮助，请不要犹豫，分享出来。</p><h2 id="7a6c" class="lu lv in bd nl nm nn dn no np nq dp nr lc ns nt nu lg nv nw nx lk ny nz oa ob bi translated"><strong class="ak">更多阅读:</strong></h2><div class="md me gp gr mf mg"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-algorithm-and-data-structure-challenge-fizz-buzz-5ef81800cb99"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">JavaScript算法和数据结构挑战——Fizz Buzz</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">JavaScript中的Fizz Buzz challenge黑客团队的一个编程挑战的解决方案。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mp l"><div class="oc l mr ms mt mp mu km mg"/></div></div></a></div><div class="md me gp gr mf mg"><a rel="noopener  ugc nofollow" target="_blank" href="/8-javascript-array-methods-you-should-know-81947c9e46de"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">你应该知道的8种JavaScript数组方法</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">JavaScript中的数组方法你需要用例子来了解。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mp l"><div class="od l mr ms mt mp mu km mg"/></div></div></a></div></div></div>    
</body>
</html>