<html>
<head>
<title>Agnostic State: How to Reduce Dependency on a Store with the Functional Approach in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不可知状态:如何使用React中的函数方法减少对存储的依赖</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/agnostic-state-b0c7d4d7584a?source=collection_archive---------11-----------------------#2021-08-04">https://javascript.plainenglish.io/agnostic-state-b0c7d4d7584a?source=collection_archive---------11-----------------------#2021-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5c7137229979a77213c8cb0af4b35edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fcREl4PYhFGdXLsx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nicolasthomas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicolas Thomas</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3073" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">简介</strong></h1><p id="5519" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果您使用React库开发过JavaScript应用程序，您可能听说过函数式方法和钩子的概念。虽然大多数开发新项目的团队选择带钩子的功能组件而不是类组件。在React存在的这些年里，生产中有许多遗留代码库需要维护和开发。</p><p id="5f48" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">除了改变编写组件的方法，还有一个趋势是使状态容器现代化。所以在一些项目中，有一个过渡，比如将<em class="me"> Redux </em>切换到<em class="me"> Mobx </em>，转换<em class="me"> redux-observable </em>，以及其他改进。谁知道明天会发明什么？:)</p><p id="765b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">由于我们工作领域的特殊性，总会有一个与业务部门就新特性的引入和项目的技术债务进行争论的过程，这通常包括重构过程。结合Redux使用React应用程序的示例，我将展示如何以最少的痛苦迁移到依赖性更低、更灵活的架构，这将允许您在未来实施新的技术解决方案时问题更少、浪费的时间更少。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="591e" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated"><strong class="ak">动机</strong></h1><p id="f47f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">由于我们正在逐步将组件转移到功能性方法，停留在旧的商店连接上没有意义。如今，react-redux提供了开箱即用的许多灵活解决方案，如<em class="me"> useStore </em>、<em class="me"> useSelector </em>、<em class="me"> useDispatch </em>等。(使用React上下文的类似方法可以在其他状态容器中找到)。函数式方法在架构上提供了灵活性，这有利于伸缩和重构。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="d09d" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated"><strong class="ak">问题</strong></h1><h2 id="0fd2" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">1 .派遣的行动</h2><p id="c338" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最有可能使用API的是像<a class="ae kc" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>或<a class="ae kc" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>这样的东西。在redux-thunk的例子中，我们使用异步操作来提交到存储。目前，由于需要异步调用，我们的典型操作如下所示:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/7317d841b4b90ffe4489894de90a820c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNTL2zBqQ-jQcHkoNlUpFg.png"/></div></div></figure><p id="8cc9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">当在组件内部调用时，这导致了极其尴尬的重用。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/86d73b28f1d51252f76c7f2a447c1f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHkc3koEfoECtFXcuer0jQ.png"/></div></div></figure><h2 id="6e31" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">2.“垃圾”代码</h2><p id="1e3d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">通常，当使用类方法编写组件时，它包含与显示逻辑不直接相关的代码，因此生命周期方法增加了，这增加了支持这种组件的复杂性。</p><p id="8756" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">不仅如此，在组件的闭包中，还有子查询函数、度量设置、数据处理(这些与显示没有直接关系)等。将所有这类处理数据的情况与渲染分开，以便将组件作为一个独立的结构来处理，会方便得多。</p><h2 id="3d48" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated"><strong class="ak"> 3。扩展处理程序</strong></h2><p id="8c6b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">许多项目都有DOM元素事件处理程序，这些处理程序会导致商店树的不同部分发生变化，或者在JSX中显示之前准备聚合数据。有时，如此大量的改变商店的行动必须保持分离，不能组合。这就是为什么我们的组件的方法携带了太多额外的逻辑。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/37692ed66a52ff9e430f369209834e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EPPLD2uKpbuLJx2rKb7Mg.png"/></div></div></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/9b139ba32fbc75b1bfb68f180f73c66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnBJtey-R9Iwv_RYTXaSOQ.png"/></div></div></figure><p id="41a5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">聚合和序列化逻辑可以有更复杂的实现，这也混淆了显示层的一般逻辑。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="dd3d" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated"><strong class="ak">解决方案</strong></h1><p id="ae8f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">前一个模块中描述的常见问题的解决方案可以是在商店和功能组件之间形成一个中间数据层。这种方法可能有点类似于后端应用程序的三层架构(<em class="me">控制器</em>&lt;-&gt;-<em class="me">服务</em> &lt; - &gt; <em class="me">存储库</em>)或angular应用程序，其中控制器传递数据以进行显示。</p><h2 id="0e10" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated"><strong class="ak"> 1。装订分派</strong></h2><p id="4998" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了处理当前的动作，你可以创建一个钩子来准备使用状态层。钩子包装了组件中使用的动作，并将它们绑定到dispatch，这样可以方便地重用方法。如果有必要放弃旧的动作实现，我们总是可以改变隐藏的实现。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/d758c045b54ed84fe4cfd01c778939b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GUEI3-1UkEliI52_OeQa5g.png"/></div></div></figure><h2 id="b54b" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">2.连接到Redux商店</h2><p id="a8d4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们形成选择器挂钩来接收商店实体和准备好的在商店内部使用的动作。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/0c96f1bf9cc226d66fd111498a214bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67ga9cgMV8lFcxI--SWbRA.png"/></div></div></figure><p id="3e96" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果描述的动作没有绑定到dispatch，我们将能够在不可知状态下声明方法。</p><h2 id="fa22" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">3.在渲染层中使用</h2><p id="1ebf" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最初，<em class="me"> useConnect </em>似乎足以提供来自商店的数据，但是数据需要放入一个对象中，该对象将被传递给生成JSX的函数。因此，为了方便调用，有必要应用currying方法。因此，我们绑定了状态初始化和提交，以便在组件内部使用。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/214be2457917a308f4112e98b9228629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXiZ7-_3naCBooe34A95KQ.png"/></div></div></figure></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="fb03" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">用法示例</h1><h2 id="fd8e" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated"><strong class="ak"> 1。初始化组件</strong>的不可知状态</h2><p id="0516" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于简单的组件，在组件内部声明数据拦截器(<em class="me"> useDate </em>)就足够了，但是对于复杂的组件，在我看来，还是放在单独的文件里比较好。因此，状态级依赖关系将只是不可知状态数据，而不可知状态依赖关系将是存储数据。回到所描述的方法的思想，如果有必要改变状态的容器，显示层将不会进入受影响的区域。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/0874fda2b7b6e823e6a79200377db6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJGPVcft8fNTCTTl5tlnZQ.png"/></div></div></figure><p id="ea56" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">从上面的例子中，您可以看到我们正在为我们的状态创建一个javascript对象。因此，不可知论国家有能力:</p><ul class=""><li id="69be" class="nn no iq ld b le lz li ma lm np lq nq lu nr ly ns nt nu nv bi translated">从商店直接转移到显示层。</li><li id="920c" class="nn no iq ld b le nw li nx lm ny lq nz lu oa ly ns nt nu nv bi translated">为聚合/添加/重用逻辑添加您自己的函数。</li><li id="edcd" class="nn no iq ld b le nw li nx lm ny lq nz lu oa ly ns nt nu nv bi translated">通过getter函数聚合数据。</li></ul><p id="d3c8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">P.S .为了简单组件的易用性，我们可以充分利用decorators！</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/759d4a42d11836357de12a59414f79db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32C1ila-q8yAFhYyD5_9bA.png"/></div></div></figure><h2 id="1999" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">2.在组件内部使用不可知状态</h2><p id="3830" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了使用不可知状态，我们调用<em class="me"> useData </em>()函数(如果需要，我们可以传递props)。当再次被调用时(因为使用了currying)，我们得到状态参数，我们用它来填充JSX。需要注意的是，对于需要使用第三方钩子的组件，可以添加函数<em class="me"> useRender </em> (state) {}。这是创建函数上下文所必需的。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/78a257040aa31ef794ca9b94e1d60bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzUBoy9nO4IcUBvm3hFA6w.png"/></div></div></figure><p id="3f12" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于简单的组件，lambda函数就足够了。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/96d70e079ce6f2780e25e570e3c710c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auRAPcZWUdV6kzmjeUoa7g.png"/></div></div></figure><p id="4d89" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">优势:</p><ul class=""><li id="8355" class="nn no iq ld b le lz li ma lm np lq nq lu nr ly ns nt nu nv bi translated">摆脱存储依赖。</li><li id="f44e" class="nn no iq ld b le nw li nx lm ny lq nz lu oa ly ns nt nu nv bi translated">没有道具和状态的混合。(如果你需要传递创建不可知论国家的道具，你可以这么做)</li><li id="8ac3" class="nn no iq ld b le nw li nx lm ny lq nz lu oa ly ns nt nu nv bi translated">易于感知。</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="ee0e" class="kd ke iq bd kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la bi translated">结论</h1><p id="9292" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">带有React钩子的函数式方法是一个强大的工具，它可以以相对较低的成本对您的架构进行大的修改。如果您的项目中有遗留代码，并且您不知道从哪里开始，我建议您查看所描述的解决方案。本文并不打算成为一个全面的指南，但是它确实提供了一个降低项目依赖项的紧密耦合的一般概念。</p><p id="50ed" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="me">更多内容尽在</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="me">plain English . io</em></strong></a></p></div></div>    
</body>
</html>