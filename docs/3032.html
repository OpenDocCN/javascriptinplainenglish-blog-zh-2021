<html>
<head>
<title>Array.at() Will Change How We Access Array Values in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Array.at()将改变我们在JavaScript中访问数组值的方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/array-at-will-change-how-we-access-array-values-in-javascript-517c3a13d505?source=collection_archive---------2-----------------------#2021-06-20">https://javascript.plainenglish.io/array-at-will-change-how-we-access-array-values-in-javascript-517c3a13d505?source=collection_archive---------2-----------------------#2021-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="95d4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在JavaScript中访问负索引，以及这如何随着Array.prototype.at()而改变</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d4ff610010508b378b4c570b6dfdc0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wxnYxo_0eH2ADFJd"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lastnameeaster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">La-Rel Easter</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2bcc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有时候，我觉得迫切需要反向访问数组元素，可能是最后一项或倒数第二项。</p><p id="ceb7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实现它的方法从来都不简单，就像在其他语言中，你只需要说array[-1]就可以得到最后一项。</p><p id="489e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">相反，我们不得不做类似<code class="fe lp lq lr ls b">array[array.length-1]</code>之类的事情。</p><p id="cf8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">[]</code>语法不是特定于数组和字符串的；它适用于所有对象。通过索引引用一个值，像<code class="fe lp lq lr ls b">array[1]</code>，实际上只是用键<code class="fe lp lq lr ls b">1</code>引用对象的属性，这是任何对象都可以拥有的东西。所以<code class="fe lp lq lr ls b">array[-1]</code>在今天的代码中已经“工作”了，但是它返回对象的<code class="fe lp lq lr ls b">-1</code>属性的值，而不是返回一个从末尾向后计数的索引。</p><h2 id="fd18" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">访问元素</h2><p id="833b" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">试图获取数组中不存在的索引值将会在JavaScript中返回undefined。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="6fcf" class="lt lu in ls b gy mv mw l mx my">const arr=['a', 'b', 'c', 'd', 'e'];</span><span id="e073" class="lt lu in ls b gy mz mw l mx my">arr[1] // b</span><span id="70d9" class="lt lu in ls b gy mz mw l mx my">arr[4] // e</span><span id="a57f" class="lt lu in ls b gy mz mw l mx my">arr[-1] // undefined</span></pre><p id="e258" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有什么选项来访问最后一个元素，目前我们可以做<code class="fe lp lq lr ls b">arr[arr.length — 1]</code>或<code class="fe lp lq lr ls b">arr.slice(-1)[0]</code>，这将给我们<code class="fe lp lq lr ls b">e</code>作为上述数组的输出。</p><h2 id="272d" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">拟建物业—“at”</h2><p id="00b4" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">有了这个新属性，访问数组中的元素将变得更加方便。</p><p id="c5cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们访问值的方式不会随着的<strong class="kv io">而改变，但是访问负索引将变得容易。下面是它的样子:</strong></p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="6b00" class="lt lu in ls b gy mv mw l mx my">const arr=['a', 'b', 'c', 'd', 'e'];</span><span id="7b4e" class="lt lu in ls b gy mz mw l mx my">arr.at(1) // b</span><span id="7d08" class="lt lu in ls b gy mz mw l mx my">arr.at(4) // e</span><span id="1aaf" class="lt lu in ls b gy mz mw l mx my">arr.at(-1) // e</span><span id="fa44" class="lt lu in ls b gy mz mw l mx my">arr.at(10) // undefined</span></pre><h2 id="c62b" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">结论</h2><p id="08f5" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">希望这将很快推进到第4阶段，并被正式采用。我对此感到非常兴奋，并且可以看到这成为访问数组元素的语法糖。</p><p id="f63e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有一个<a class="ae ks" href="https://github.com/tc39/proposal-array-last" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> last </strong> </a>属性正在讨论中(访问数组/字符串的最后一个元素)，但它仍处于第1阶段，很可能会因为这个新属性 中的<a class="ae ks" href="https://github.com/tc39/proposal-relative-indexing-method" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">而被放弃，因为它已经是第3阶段了，并解决了相同的目的和更多的问题。</strong></a></p><div class="na nb gp gr nc nd"><a href="https://github.com/tc39/proposal-relative-indexing-method" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">tc39/建议相对索引方法</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">TC39建议增加一个。at()方法对所有基本的可索引类(Array，String，TypedArray) Stage: 3…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr km nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://github.com/tc39/proposal-array-last" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">tc39/建议-阵列-最后</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">(目前是第一阶段)该提案的支持者(@keithamus)目前不打算进入第二阶段。其他提议…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="ns l no np nq nm nr km nd"/></div></div></a></div><p id="906a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nt">更多内容看</em><a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>