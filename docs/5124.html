<html>
<head>
<title>State Management for Complex Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复杂Web组件的状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/state-management-for-complex-web-components-cb4e370bfd6e?source=collection_archive---------3-----------------------#2021-10-18">https://javascript.plainenglish.io/state-management-for-complex-web-components-cb4e370bfd6e?source=collection_archive---------3-----------------------#2021-10-18</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="7fbf" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如何在LitElement组件中使用Redux</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/5528a3e340dece049aeec4a18ee4d0da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGcU73flISkekJM8elOsGw.png"/></div></div></figure><p id="6ecc" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Web组件可能是构建与几乎所有JavaScript框架兼容的独立小部件的最佳选择。为什么？因为它们体积小、速度快、封装好，并且可以完全没有依赖性。</p><p id="324c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在想象构建一个包含复杂配置、控件、事件甚至公共API的丰富小部件。当用户与您的组件交互时，我们需要保留更改。它称之为国家。放在内存中，在那里我们存储小部件配置，当这个配置改变时，我们重新呈现视图。</p><p id="240c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当web组件很简单时，我们可以将状态存储在元素实例中，并通过属性和事件传递数据。但是对于更复杂的小部件，您可能会面临跨深度嵌套元素传递数据的副作用和复杂性问题。</p><p id="68b5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">一个可能的解决方案是Redux。这是一个小库，用于存储状态并通知其变化。对于构建web组件，我们可以使用LitElement库。</p><h2 id="44e2" class="lo lp ir bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">发展</h2><p id="c1ce" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">首先，我们需要初始化项目。最快的方法之一是使用@open-ws生成器来设置初始结构、依赖项和开发服务器。</p><p id="79f8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">需要回答一些问题的引导方式:<code class="fe mm mn mo mp b">npm init @open-wc</code></p><p id="c3d4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">没有问题的单一命令:</p><pre class="kh ki kj kk gu mq mp mr ms aw mt bi"><span id="7426" class="lo lp ir mp b gz mu mv l mw mx">npm init @open-wc — type scaffold — scaffoldType wc — features linting — typescript true — tagName todo-list — writeToDisk true — installDependencies npm</span></pre><p id="ec1a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">生成器将创建一个非常通用的组件结构。出于教程目的，让我们稍微简化一下。</p><ul class=""><li id="2280" class="my mz ir ku b kv kw ky kz lb na lf nb lj nc ln nd ne nf ng bi translated">从src文件夹中删除todo-list.ts和index.ts。</li><li id="a2b8" class="my mz ir ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">将第16行替换为“导入”../dist/src/todo list . js '；在demo/index.html中。</li><li id="b0e5" class="my mz ir ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">移除const title = 'Hello owc World！'；</li><li id="3205" class="my mz ir ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">并删除第21行的title属性。</li></ul><p id="7213" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe mm mn mo mp b">TodoList.ts</code>一开始我们也简化一下。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><blockquote class="no np nq"><p id="b0cb" class="ks kt nr ku b kv kw js kx ky kz jv la ns lc ld le nt lg lh li nu lk ll lm ln ik bi translated">我们使用了@ custom element(' todo-list ')decorator，而不是使用window . custom elements . define(' todo-list '，todo list)；</p></blockquote><p id="aad7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如您所见，我们有两个奇怪的标记和两个js导入。这些标签也是具有其职责的web组件。一个将包含输入和添加任务的逻辑，第二个将显示列表。让我们执行它们。</p><p id="52de" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">首先在src中创建一个名为<code class="fe mm mn mo mp b">components</code>的文件夹，然后创建两个ts文件:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="a4fe" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">要提交表单，用户需要在输入中键入一些内容，然后按回车键。具有相应名称<code class="fe mm mn mo mp b">submit</code>的回调只是在这个阶段清除输入，但稍后我们将处理值。</p><p id="8e4d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">接下来，我们需要第二个组件来显示已创建任务的列表。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="27cd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在，我们可以运行npm start，开发服务器应该会启动，我们会看到一个到演示服务器的链接。</p><pre class="kh ki kj kk gu mq mp mr ms aw mt bi"><span id="716b" class="lo lp ir mp b gz mu mv l mw mx">Web Dev Server started…<br/>Root dir: /Users/user_name/Dev/lit-redux/todo-list<br/>Local: <a class="ae nv" href="http://localhost:8000/demo/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/demo/</a><br/>Network: <a class="ae nv" href="http://192.168.1.179:8000/demo/" rel="noopener ugc nofollow" target="_blank">http://192.168.1.179:8000/demo/</a></span></pre><p id="42e1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以看到浏览器h2标题，输入，在这一步总是清空任务列表。因此，我们需要保存任务列表、用于修改该状态的函数以及事件，以便知道状态何时被更改。</p><h2 id="525d" class="lo lp ir bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">添加商店</h2><p id="8c52" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">我们创建了两个组件，但它们是独立的组件，目前互不影响。当然，我们可以将输入值传递给父组件，然后将其提供给列表组件。但是我们在这里看到的是商店模式的实现。</p><p id="34ed" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这种模式意味着我们有一个对象。这个对象是我们的状态，我们在其中保存设置、输入值、建议选项以及我们需要的一切。然后，我们订阅该对象的更改，并像使用初始状态一样重新呈现我们的视图。这意味着我们总是单向流动。当用户提交输入值时，我们分派一个动作“将值放入任务列表”并将其保存到存储中。然后，列表从存储中接收更新后的列表，并重新呈现带有任务列表的视图。</p><p id="14e2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们安装库:<code class="fe mm mn mo mp b">npm install redux</code></p><p id="5cb6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在我们需要创建一个函数，根据调用的动作修改当前的存储。首先，在src文件夹中创建一个新的文件夹存储，然后创建一个新的文件reducers.ts。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="da4f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">对于这个演示，我们只实现了两个动作。首先将新任务推送到数组<code class="fe mm mn mo mp b">state.tasks</code>。第二种方法通过索引找到一个任务，并将其标记为完成或未完成。</p><p id="aacf" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以提到，我们有从actions.js导入的ACTION_LIST。该文件定义了动作调用时的动作列表和所需参数。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="77f9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在我们只需要用这个reducer和actions创建一个store。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="2ec9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">商店对行动一无所知。它只有一个初始状态和一个缩减器。缩减器将根据所提供的操作名称对每个更改进行操作。这就是为什么将动作名称导出为枚举是一个好的做法。</p><p id="b873" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以创建任意数量的减速器。在创建store实例时，只需用combineReducers将它们组合起来。</p><p id="b04a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们添加了<code class="fe mm mn mo mp b">(window as any).__REDUX_DEVTOOLS_EXTENSION__?.()</code>奇怪的代码。这一行不是必需的，但是它让我们能够使用<a class="ae nv" href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd" rel="noopener ugc nofollow" target="_blank"> Redux DevTools chrome扩展</a>来调试存储更改。</p><p id="9097" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">此外，我还添加了一个注释，即创建商店的实例不是最佳选择。通常情况下，这是可以的，但是对于web组件来说就不行了，因为我们可能在一个页面上有多个组件实例。因此，当我们从单个文件导入const时，webpack或任何其他捆绑器会将它作为单个代码用于多个web组件，以便小部件共享同一个store对象。</p><p id="21fd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们需要在根类中创建一个实例，并通过属性在子类之间共享它，以避免这个问题。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="72a5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后为将使用该存储的组件创建一个基类。你可能已经在<code class="fe mm mn mo mp b">TaskList.ts</code>中找到了它的用法。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="ecbf" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在在根<code class="fe mm mn mo mp b">TodoList.ts</code>类中创建store实例，并将其作为属性传递给子组件。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="31be" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe mm mn mo mp b">AddTask.ts</code>和<code class="fe mm mn mo mp b">TaskList.ts</code>组件将正确地接收一个store实例，因为它们是从声明该属性的<code class="fe mm mn mo mp b">base-element.ts</code>继承的。</p><h2 id="aba8" class="lo lp ir bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">结论</h2><p id="6ac1" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">使用redux，我们将在扩展web组件时简化复杂性增长。此外，我们可以根据自己的意愿，用任意数量的减少器和动作来组织商店。</p><p id="feb8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以创建一个带有存储订阅回调的基类，并在使用该存储的组件中从该基类继承。</p><p id="ab4a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果您知道小部件在同一个页面上被多次使用，不要忘记通过属性传递store实例。</p><p id="60bd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">完整演示可在<a class="ae nv" href="https://github.com/Golosay/lit-redux-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="524c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">感谢阅读！请关注我，不要错过我的下一篇关于使用Redux的承诺和HTTP请求的文章。</strong></p><p id="5d4e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><em class="nr">更多内容请看</em><a class="ae nv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku is"><em class="nr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>