<html>
<head>
<title>9 HTML Template Unit Tests for Angular Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular应用程序的9个HTML模板单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/9-html-template-unit-tests-to-write-for-angular-apps-f1970b2cda4e?source=collection_archive---------2-----------------------#2021-06-19">https://javascript.plainenglish.io/9-html-template-unit-tests-to-write-for-angular-apps-f1970b2cda4e?source=collection_archive---------2-----------------------#2021-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="08f6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解一些可以用Jasmine编写的单元测试，以覆盖Angular应用程序的HTML模板</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/beb16c50b78d5e4a2807c3aac1569624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ic9Ou8ZXZeiADVCXpOaKIw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://www.pexels.com/@negativespace?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">Negative Space</strong></a> from <a class="ae ks" href="https://www.pexels.com/photo/grayscale-photo-of-computer-laptop-near-white-notebook-and-ceramic-mug-on-table-169573/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">Pexels</strong></a></figcaption></figure><p id="6553" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在本文中，我将分享9个不同的单元测试，你可以用Jasmine为你的HTML模板编写。</p><p id="51e0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">更新:如果你想了解更多关于为你的HTML模板编写单元测试的知识，请查看我在</strong> <a class="ae ks" href="https://www.udemy.com/course/unit-testing-angular-9-with-jasmine-html-templates/?couponCode=97A89C11964B3C318DAA" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> Udemy </strong> </a> <strong class="kw io">上的课程。你可以在短时间内免费得到它，所以趁它还在，现在就去买吧！</strong></p><h2 id="36a3" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">内容</h2><ol class=""><li id="6c79" class="mj mk in kw b kx ml la mm ld mn lh mo ll mp lp mq mr ms mt bi translated"><a class="ae ks" href="#6e1b" rel="noopener ugc nofollow"> <strong class="kw io">测试组件显示在</strong> </a>界面中</li><li id="13ca" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#1b68" rel="noopener ugc nofollow"> <strong class="kw io">测试文本显示在</strong> </a>界面中</li><li id="0bcf" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#b9cf" rel="noopener ugc nofollow"> <strong class="kw io">测试*ngIfs </strong> </a></li><li id="402a" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#6360" rel="noopener ugc nofollow"> <strong class="kw io">测试*ngFors </strong> </a></li><li id="a3c2" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#58f7" rel="noopener ugc nofollow"> <strong class="kw io">测试【ng class】</strong></a></li><li id="862c" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#285c" rel="noopener ugc nofollow"> <strong class="kw io">测试子组件输出</strong> </a></li><li id="90f7" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#9cec" rel="noopener ugc nofollow"> <strong class="kw io">测试子组件输入</strong> </a></li><li id="d63a" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#2362" rel="noopener ugc nofollow"> <strong class="kw io">测试用户输入和文本区域</strong> </a></li><li id="8ace" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><a class="ae ks" href="#bf1c" rel="noopener ugc nofollow"> <strong class="kw io">测试第三方组件</strong> </a></li></ol><p id="7ebf" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你可以在<a class="ae ks" href="https://github.com/s3nt1n3lz21/ExampleAngularApp/tree/main/example-angular-app" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上找到与本文相关的所有代码。</p><h2 id="6e1b" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">1.测试组件显示在用户界面中</h2><p id="6496" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">您可以编写的最简单的测试是检查组件当前是否显示在UI中。为此，我们需要从UI中获取元素，有几种不同的方法可以做到这一点。这些都列在下表中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="31d1" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">query()和queryAll()</h2><p id="a22b" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我们获取HTML元素的第一种方法是使用<code class="fe ne nf ng nh b"><strong class="kw io">query()</strong></code>和<code class="fe ne nf ng nh b"><strong class="kw io">queryAll()</strong></code>函数。<code class="fe ne nf ng nh b"><strong class="kw io">query()</strong></code> <strong class="kw io"> </strong>将返回第一个匹配元素，<code class="fe ne nf ng nh b"><strong class="kw io">queryAll()</strong></code>将返回所有匹配元素。这些函数返回一个对元素的非静态引用，这意味着当UI更新时，元素也会更新。</p><p id="eb25" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您可以通过元素的id、元素的类或元素的选择器来查找元素。您在<code class="fe ne nf ng nh b"><strong class="kw io">query()</strong></code>中使用函数<code class="fe ne nf ng nh b"><strong class="kw io">By.css()</strong></code>，然后传入您想要的元素的id、类或选择器。</p><ul class=""><li id="3c06" class="mj mk in kw b kx ky la lb ld ni lh nj ll nk lp nl mr ms mt bi translated"><strong class="kw io">选择器</strong> : <code class="fe ne nf ng nh b"><strong class="kw io">query(By.css('div'))</strong></code>传入你想要的元素的选择器，比如<code class="fe ne nf ng nh b"><strong class="kw io">&lt;div&gt;&lt;/div&gt;</strong></code>的选择器是<code class="fe ne nf ng nh b"><strong class="kw io">div</strong></code> <strong class="kw io">。</strong></li><li id="e0cc" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp nl mr ms mt bi translated"><strong class="kw io"> Id </strong> : <code class="fe ne nf ng nh b"><strong class="kw io">query(By.css('#title'))</strong></code> <strong class="kw io"> </strong>你需要包含一个哈希<code class="fe ne nf ng nh b"><strong class="kw io">#</strong></code></li><li id="1e51" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp nl mr ms mt bi translated"><strong class="kw io">类</strong> : <code class="fe ne nf ng nh b"><strong class="kw io">query(By.css('.title'))</strong></code>你需要包含一个点<code class="fe ne nf ng nh b"><strong class="kw io">.</strong></code></li></ul><p id="3ca8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这些函数返回一个类型为<code class="fe ne nf ng nh b"><strong class="kw io">DebugElement</strong></code>的对象，您可以通过使用<code class="fe ne nf ng nh b"><strong class="kw io">.nativeElement</strong></code>来访问HTML元素。</p><ul class=""><li id="a82e" class="mj mk in kw b kx ky la lb ld ni lh nj ll nk lp nl mr ms mt bi translated"><strong class="kw io">HTML元素</strong> : <code class="fe ne nf ng nh b"><strong class="kw io">query(By.css('#title')).nativeElement</strong></code></li></ul><p id="0cf9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您还可以使用<code class="fe ne nf ng nh b"><strong class="kw io">.componentInstance</strong></code>获得对Typescript组件的引用。然后，您可以检查组件上字段的值。</p><ul class=""><li id="273f" class="mj mk in kw b kx ky la lb ld ni lh nj ll nk lp nl mr ms mt bi translated"><strong class="kw io">打字稿组件</strong> : <code class="fe ne nf ng nh b"><strong class="kw io">query(By.css('#title')).componentInstance</strong></code></li></ul><h2 id="dc97" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">使用query()抓取元素</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="e516" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">使用queryAll()抓取元素</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="4a3b" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">querySelector()和querySelectorAll()</h2><p id="7eca" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">您也可以使用<code class="fe ne nf ng nh b"><strong class="kw io">debugElement.nativeElement</strong></code>上的<code class="fe ne nf ng nh b"><strong class="kw io">querySelector()</strong></code>和<code class="fe ne nf ng nh b"><strong class="kw io">querySelectorAll()</strong></code>功能。这些函数返回元素的静态副本，这意味着元素不会在UI更新时更新。</p><p id="f849" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您还可以使用这些函数通过元素的id、元素的类或元素的选择器来搜索元素。</p><ul class=""><li id="04a4" class="mj mk in kw b kx ky la lb ld ni lh nj ll nk lp nl mr ms mt bi translated"><strong class="kw io">选择器</strong> : <code class="fe ne nf ng nh b"><strong class="kw io">querySelector('div')</strong></code>传入你想要的元素的选择器，比如<code class="fe ne nf ng nh b"><strong class="kw io">&lt;div&gt;&lt;/div&gt;</strong></code>的选择器是<code class="fe ne nf ng nh b"><strong class="kw io">div</strong></code> <strong class="kw io">。</strong></li><li id="7d35" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp nl mr ms mt bi translated"><strong class="kw io"> Id </strong> : <code class="fe ne nf ng nh b"><strong class="kw io">querySelector('#title')</strong></code> <strong class="kw io"> </strong>你需要包含一个哈希<code class="fe ne nf ng nh b"><strong class="kw io">#</strong></code></li><li id="ee55" class="mj mk in kw b kx mu la mv ld mw lh mx ll my lp nl mr ms mt bi translated"><strong class="kw io">类</strong> : <code class="fe ne nf ng nh b"><strong class="kw io">querySelector('.title')</strong></code>你需要包含一个点<code class="fe ne nf ng nh b"><strong class="kw io">.</strong></code></li></ul><p id="c12c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这些函数返回一个类型为<code class="fe ne nf ng nh b"><strong class="kw io">Element</strong></code>或<code class="fe ne nf ng nh b"><strong class="kw io">NodeList</strong></code>的对象。这些就像原生元素，所以你不必使用<code class="fe ne nf ng nh b"><strong class="kw io">.nativeInstance</strong></code>。但这也意味着您无法获得对typescript组件的引用。</p><p id="ce3a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">大多数时候可以用<code class="fe ne nf ng nh b"><strong class="kw io">querySelector()</strong></code>和<code class="fe ne nf ng nh b"><strong class="kw io">querySelectorAll()</strong></code>。如果需要访问<code class="fe ne nf ng nh b"><strong class="kw io">.componentInstance</strong></code>，只需使用<code class="fe ne nf ng nh b"><strong class="kw io">query()</strong></code>和<code class="fe ne nf ng nh b"><strong class="kw io">queryAll()</strong></code>。</p><h2 id="838e" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated"><strong class="ak">使用querySelector()抓取元素</strong></h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="c6c4" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated"><strong class="ak">使用querySelectorAll()抓取元素</strong></h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="1b68" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">2.测试文本显示在用户界面中</h2><p id="0d35" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">您可以检查某些特定文本是否显示在UI中。假设我们有下面的HTML模板显示“欢迎回来！”消息。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a3c9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们可以使用任何不同的函数来获取元素内部的文本。</p><p id="86fc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> query()和queryAll() </strong></p><p id="840b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们可以使用<code class="fe ne nf ng nh b"><strong class="kw io">.nativeElement</strong></code>并检查它的<code class="fe ne nf ng nh b"><strong class="kw io">.innerText</strong></code> <strong class="kw io"> </strong>来抓取文本。这将返回该元素及其子组件中包含的所有文本。如果你想去掉所有的空格和换行符，你可以在返回的字符串上使用<code class="fe ne nf ng nh b"><strong class="kw io">.trim()</strong></code> <strong class="kw io"> </strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1c7f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> querySelector()和querySelectorAll() </strong></p><p id="9a20" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们也可以通过检查<code class="fe ne nf ng nh b"><strong class="kw io">.innerText</strong></code>来抓取文本。同样，这将返回该元素及其子组件中包含的所有文本。可以用<code class="fe ne nf ng nh b"><strong class="kw io">.trim()</strong></code> <strong class="kw io"> </strong>去掉所有空格和换行符。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="b9cf" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">3.测试* ngIfs</h2><p id="45b3" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我们还可以测试<code class="fe ne nf ng nh b"><strong class="kw io">*ngIf</strong></code>,检查正确的组件是否在应该显示的时候显示出来。我们可以编写一个测试来检查组件在条件为真时是否显示，一个测试来检查组件在条件为假时是否不显示。如果<code class="fe ne nf ng nh b"><strong class="kw io">*ngIf</strong></code>的条件语句更复杂，那么您可以编写更多的单元测试。</p><p id="9a2e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设我们有一个这样的模板</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a9d9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们可以编写一个单元测试，当字段<code class="fe ne nf ng nh b"><strong class="kw io">showTitle</strong></code>为真时检查id为<code class="fe ne nf ng nh b"><strong class="kw io">title</strong></code>的元素是否存在，当<code class="fe ne nf ng nh b"><strong class="kw io">showTitle</strong></code>为假时检查该元素是否不存在。我们可以使用<code class="fe ne nf ng nh b"><strong class="kw io">toBeTruthy()</strong></code> <strong class="kw io"> </strong>和<code class="fe ne nf ng nh b"><strong class="kw io">toBeFalsy()</strong></code> <strong class="kw io"> </strong>来检查组件是否存在。</p><p id="2276" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">首先，我们将<code class="fe ne nf ng nh b"><strong class="kw io">showTitle </strong></code>的值设置为true，然后通过调用<code class="fe ne nf ng nh b"><strong class="kw io">detectChanges()</strong></code>更新UI，并检查UI中现在是否存在组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9d8d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">有时在<code class="fe ne nf ng nh b"><strong class="kw io">*ngIf</strong></code>条件下可能会用到一个函数。在这种情况下，您可以在单元测试中更改该函数的返回值，然后更新UI。假设我们有下面的HTML模板。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e6e0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">单元测试应该是</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="6360" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">4.测试*ngFors</h2><p id="b2b9" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我们还可以测试<code class="fe ne nf ng nh b"><strong class="kw io">*ngFors</strong></code>并检查是否显示了正确数量的子组件，以及这些子组件是否传递了正确的数据。我们可以使用<code class="fe ne nf ng nh b"><strong class="kw io">queryAll()</strong></code>或<code class="fe ne nf ng nh b"><strong class="kw io">querySelectorAll()</strong></code>来抓取多个元素。</p><p id="9365" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设我们有下面的HTML模板和一些子组件，每个子组件都有一个类<code class="fe ne nf ng nh b"><strong class="kw io">.rows</strong></code> <strong class="kw io"> </strong>。从字段<code class="fe ne nf ng nh b"><strong class="kw io">messages</strong></code> <strong class="kw io"> </strong>向每个子组件传递一个字符串。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d614" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">检查子组件数量是否正确以及正确的数据是否被传递到子组件的单元测试应该是</p><h2 id="53ca" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">queryAll()</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="f96e" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">querySelectorAll()</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="58f7" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">5.测试[ngClass]</h2><p id="47fd" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我们可以测试使用<code class="fe ne nf ng nh b"><strong class="kw io">[ngClass]</strong></code>的元素是否应用了正确的类。我们可以编写一个单元测试来检查当条件为真时是否应用了该类，编写一个单元测试来检查当条件为假时是否应用了该类。</p><p id="0070" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设我们有下面的HTML模板，其中有一个id为<code class="fe ne nf ng nh b"><strong class="kw io">title</strong></code>的div元素。当字段<code class="fe ne nf ng nh b"><strong class="kw io">activeTitle</strong></code>为真时，它有类<code class="fe ne nf ng nh b"><strong class="kw io">active</strong></code>，当字段<code class="fe ne nf ng nh b"><strong class="kw io">activeTitle</strong></code>为假时，它没有类<code class="fe ne nf ng nh b"><strong class="kw io">active</strong></code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="651a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们获取元素并检查它的<code class="fe ne nf ng nh b"><strong class="kw io">classList</strong></code>是否包含字符串<code class="fe ne nf ng nh b"><strong class="kw io">'active'</strong></code>。对此的单元测试应该是</p><h2 id="f449" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">query()和queryAll()</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="f7d8" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">querySelector()和querySelectorAll()</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="285c" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">6.测试子组件输出</h2><p id="9517" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我们还可以检查当子组件的输出事件触发时是否调用了正确的函数。假设我们有下面的HTML模板。我们有一个子组件<code class="fe ne nf ng nh b"><strong class="kw io">app-child-component</strong></code>，它的输出<code class="fe ne nf ng nh b"><strong class="kw io">outputData</strong></code>在输出事件触发时调用函数<code class="fe ne nf ng nh b"><strong class="kw io">updateData</strong></code> <strong class="kw io"> </strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c2ac" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们先窥探<code class="fe ne nf ng nh b"><strong class="kw io">updateData</strong></code> <strong class="kw io"> </strong>函数，然后抓取HTML元素，用<code class="fe ne nf ng nh b"><strong class="kw io">dispatchEvent()</strong></code>模拟一个事件。我们向该函数传递一个类型为<code class="fe ne nf ng nh b"><strong class="kw io">outputData</strong></code>的新事件。</p><h2 id="2d77" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">query()和queryAll()</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="bf23" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">querySelector()和querySelectorAll()</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="9cec" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">7.测试子组件输入</h2><p id="bdd4" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我们还可以检查当前组件是否通过它们的输入将正确的数据传递给了其子组件。假设我们有一个包含以下HTML的组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="aaf0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">它包含一个带有选择器<code class="fe ne nf ng nh b"><strong class="kw io">app-child-component</strong></code>的子组件，并有一个输入<code class="fe ne nf ng nh b"><strong class="kw io">inputData</strong></code> <strong class="kw io"> </strong>，变量<code class="fe ne nf ng nh b"><strong class="kw io">title</strong></code>通过该输入传递下去。因为这个子组件是我们自己的定制组件，所以我们使用<code class="fe ne nf ng nh b"><strong class="kw io">query()</strong></code>获取组件并得到<code class="fe ne nf ng nh b"><strong class="kw io">.componentInstance</strong></code>。然后我们可以检查输入<code class="fe ne nf ng nh b"><strong class="kw io">inputData</strong></code> <strong class="kw io"> </strong>的值。</p><p id="45c7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> query()和queryAll() </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6583" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">注意，这里不能使用<code class="fe ne nf ng nh b"><strong class="kw io">querySelector()</strong></code>或<code class="fe ne nf ng nh b"><strong class="kw io">querySelectorAll()</strong></code>，因为我们需要访问<code class="fe ne nf ng nh b"><strong class="kw io">.componentInstance</strong></code> <strong class="kw io"> </strong>上的输入。</p><h2 id="2362" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">8.测试用户输入和文本区域</h2><p id="287e" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我们还可以检查当用户在输入或文本区域元素中键入字符串时，正确的字段是否会更新。在下面的例子中，我们想要检查当用户输入一个新值时字段<code class="fe ne nf ng nh b"><strong class="kw io">title</strong></code>是否被更新。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="473d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们首先初始化字段<code class="fe ne nf ng nh b"><strong class="kw io">title</strong></code>的值，然后通过id获取输入元素并得到<code class="fe ne nf ng nh b"><strong class="kw io">.nativeElement</strong></code>。我们手动设置输入的新值，然后使用<code class="fe ne nf ng nh b"><strong class="kw io">dispatchEvent()</strong></code>模拟用户输入事件，并传入类型为<code class="fe ne nf ng nh b"><strong class="kw io">input</strong></code>的新事件。这将使用新值更新该字段。</p><p id="5f74" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> query()和queryAll() </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3f53" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io"> querySelector()和querySelectorAll() </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="bf1c" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">9.测试第三方组件</h2><p id="9548" class="pw-post-body-paragraph ku kv in kw b kx ml jo kz la mm jr lc ld mz lf lg lh na lj lk ll nb ln lo lp ig bi translated">我们还可以测试第三方组件在用户与它们交互时是否更新了正确的字段。</p><p id="c733" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Angular 9中引入了组件工具，当用户使用另一个库中的第三方组件时，它为用户提供了一种简单的方法来测试他们的应用程序是否正常工作。</p><p id="19f4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">组件线束需要由组件库(如Angular Material)的作者创建，因此可能不适用于所有库。</p><p id="ece7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在使用组件之前，您必须知道组件的具体实现和结构，以便模拟用户在下拉列表中选择一个选项，或者找到并抓取组件显示的标签，并通过使用大量查询来检查它的设置是否正确。例如<code class="fe ne nf ng nh b"><strong class="kw io">fixture.debugElement.query()</strong></code></p><p id="b155" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您可以使用<code class="fe ne nf ng nh b"><strong class="kw io">HarnessLoader</strong></code>来获取组件的线束，然后您可以通过线束上的属性轻松地获取组件上的标签，或者通过简单地调用一个方法来模拟用户交互，比如用户单击并选择下拉菜单中的选项。</p><p id="df0f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是如果没有组件的控制，我们首先需要找出如何模拟用户交互。我们可以通过检查他们组件的文档和查看他们如何编写单元测试来找到这些信息。通常他们的组件会有一个GitHub页面。</p><p id="d1d5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">ng-选择组件</strong></p><p id="439b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">例如，让我们看一下ng-select组件，它被用作下拉选择器。如果我们去他们的<a class="ae ks" href="https://github.com/ng-select/ng-select/blob/master/src/ng-select/lib/ng-select.component.spec.ts" rel="noopener ugc nofollow" target="_blank"> GitHub </a>页面看看他们的单元测试，我们可以看到他们使用一个助手函数<code class="fe ne nf ng nh b"><strong class="kw io">selectOption()</strong></code>来模拟用户点击下拉菜单中的一个选项。</p><p id="079f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们可以使用类似的辅助函数<code class="fe ne nf ng nh b"><strong class="kw io">triggerKeyDownEvent()</strong></code>来模拟用户选择不同的键。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e263" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">假设我们有下面的HTML模板，带有一个id为<code class="fe ne nf ng nh b"><strong class="kw io">optionDropdown</strong></code>的ng-select组件。可能选项的列表来自字段<code class="fe ne nf ng nh b"><strong class="kw io">options</strong></code>，我们可以将下拉列表中的选定值绑定到字段<code class="fe ne nf ng nh b"><strong class="kw io">option</strong></code>。当用户选择一个新值时，我们也可以调用函数<code class="fe ne nf ng nh b"><strong class="kw io">selectOption()</strong></code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d285" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们可以编写一个单元测试来检查<code class="fe ne nf ng nh b"><strong class="kw io">selectOption()</strong></code>函数是否被调用</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="771e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">并且另一个单元测试检查字段<code class="fe ne nf ng nh b"><strong class="kw io">option</strong></code>被更新</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d6b8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="nm">更多内容看</em> <a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="nm">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>