<html>
<head>
<title>How to detect when an input() value changes in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测输入()值在角度上的变化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-detect-when-an-input-value-changes-in-angular-5872c77517fc?source=collection_archive---------2-----------------------#2021-07-22">https://javascript.plainenglish.io/how-to-detect-when-an-input-value-changes-in-angular-5872c77517fc?source=collection_archive---------2-----------------------#2021-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1661" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">角度基础2021</h2><div class=""/><div class=""><h2 id="5675" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">检测输入值何时改变角度</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/82f7a1097e73476dee353fb651d2f70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DwhTYS8DG55X9gs5"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@lenneek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Elena Koycheva</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="be5b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在angular应用程序中，我们主要处理父子组件关系，但有时会发生这样的情况，我们的父组件做了一些更改，但子组件不会直接通知或更改值。<strong class="lh ja">我们如何通知孩子或直接更新输入值？</strong></p><h2 id="c905" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">1.使用ngOnChanges()生命周期方法</h2><p id="0040" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">当组件中的任何输入值发生变化时，调用ngOnChanges 方法。这个方法有一个<strong class="lh ja"> SimpleChanges </strong>对象，从中我们可以比较当前和以前的值。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="257a" class="mb mc iq mz b gy nd ne l nf ng">@Input() testId: string;<br/>        <br/>    ngOnChanges(changes: SimpleChanges) {<br/>        <br/>        this.doSomething(changes.testId.currentValue);<br/>        // <br/>        <br/>    }</span></pre><h2 id="fdd9" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">2.使用输入设置器和Getter属性</h2><p id="e043" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们可以创建getter和setter方法，这样做的好处是无论何时发生变化，setter都会设置值，而我们得到更新后的值。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="f7cb" class="mb mc iq mz b gy nd ne l nf ng">private _<!-- -->testId<!-- -->: string;</span><span id="e408" class="mb mc iq mz b gy nh ne l nf ng"><a class="ae le" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank">@Input</a>() set <!-- -->testId<!-- -->(value: string) {</span><span id="47ca" class="mb mc iq mz b gy nh ne l nf ng">this._<!-- -->testId<!-- -->= value;<br/>    this.changeHappened(this._<!-- -->testId<!-- -->);</span><span id="4d1c" class="mb mc iq mz b gy nh ne l nf ng">}</span><span id="3fa2" class="mb mc iq mz b gy nh ne l nf ng">get <!-- -->testId<!-- -->(): string {</span><span id="03b7" class="mb mc iq mz b gy nh ne l nf ng">return this._<!-- -->testId<!-- -->;</span><span id="1ffb" class="mb mc iq mz b gy nh ne l nf ng">}</span></pre><h2 id="bde3" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">3.我们可以使用异步管道。</h2><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="41ec" class="mb mc iq mz b gy nd ne l nf ng"><a class="ae le" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>    selector: 'child-component',<br/>    template: `&lt;p&gt;{{ data }}&lt;/p&gt;`,<br/>})<br/>export class SubComponent implements OnInit {<br/>    <a class="ae le" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank">@Input</a>() data: string;</span><span id="ac89" class="mb mc iq mz b gy nh ne l nf ng">ngOnInit() {<br/>        console.log('received data', this.data);<br/>    }<br/>}</span><span id="edac" class="mb mc iq mz b gy nh ne l nf ng"><a class="ae le" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>    selector: 'Parent-app',<br/>    template: `<br/>    &lt;h1&gt;Hello {{name}}&lt;/h1&gt;<br/>    &lt;sub-component [data]="data$ | async"&gt;&lt;/sub-component&gt;<br/>  `<br/>})<br/>export class ParentCOmponent {<br/>    data$ = Observable.of('Values').delay(1000);<br/>}</span></pre><p id="a152" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">异步管道执行以下任务。</p><ul class=""><li id="7c1c" class="ni nj iq lh b li lj ll lm lo nk ls nl lw nm ma nn no np nq bi translated"><code class="fe nr ns nt mz b">async</code>管道订阅<code class="fe nr ns nt mz b">Observable </code>并返回最新发出的值。</li><li id="15ba" class="ni nj iq lh b li nu ll nv lo nw ls nx lw ny ma nn no np nq bi translated">当我们得到新的变化时，这个管道将只检查变化</li><li id="466d" class="ni nj iq lh b li nu ll nv lo nw ls nx lw ny ma nn no np nq bi translated">这将有助于避免任何内存泄漏。</li></ul><h2 id="1230" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">您应该使用哪种方法？</h2><p id="8021" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">如果您需要检查以前的值和当前的值，并对多个输入一起进行一些检查，那么最好使用ngOnChanges()，因为我们需要在setter和getter中处理多个东西。</p><p id="d601" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最有效的方法是使用异步管道，因为它有助于取消订阅，最终有助于不写或不关心取消订阅。</p><h2 id="4400" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">在某些情况下，角度变化检测可能不会触发</h2><p id="e214" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">通常，每当父组件更改它传递给子组件的数据时，setter和ngOnChanges的更改检测都会触发，<strong class="lh ja">假设数据是JS原语数据类型(字符串、数字、布尔)</strong>。但是，在下面的场景中，它不会启动，我们需要小心。</p><ol class=""><li id="8d01" class="ni nj iq lh b li lj ll lm lo nk ls nl lw nm ma nz no np nq bi translated">如果我们使用一个嵌套的对象或数组，可能会发生变化检测不会自己通知，因为我们可能需要创建一个新的数组或对象，就像这样<code class="fe nr ns nt mz b">data= {...data};</code></li><li id="16d9" class="ni nj iq lh b li nu ll nv lo nw ls nx lw ny ma nz no np nq bi translated">如果您在外部更改数据，angular将不会知道这些更改。我们需要在组件中使用ChangeDetectorRef或NgZone来使angular意识到外部变化，从而触发变化检测。</li></ol><p id="ee84" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">参考文献:</strong></p><h1 id="c6df" class="oa mc iq bd md ob oc od mg oe of og mj kf oh kg mm ki oi kj mp kl oj km ms ok bi translated">进一步阅读</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a265" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="on">更多内容请看</em><a class="ae le" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"><em class="on">plain English . io</em></strong></a></p></div></div>    
</body>
</html>