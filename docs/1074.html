<html>
<head>
<title>The Basics of Test Driven Development with Jest and Enzyme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest和Enzyme测试驱动开发的基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-basics-of-test-driven-development-with-jest-and-enzyme-a97cb4c88ec0?source=collection_archive---------8-----------------------#2021-03-06">https://javascript.plainenglish.io/the-basics-of-test-driven-development-with-jest-and-enzyme-a97cb4c88ec0?source=collection_archive---------8-----------------------#2021-03-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2cdecb303a227acd6eb1d98cd4a848b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rvjl8MSimui_AdkRw2N4TA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jantined?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jantine Doornbos</a> on <a class="ae jz" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="769b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，我开始学习测试驱动开发(TDD)。顾名思义，这意味着在编写任何功能代码之前都要编写测试。最多，编写一个外壳版本的代码，以便测试可以调用它，但是在编写测试之前，代码不应该起作用。</p><p id="3412" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在任何真正的代码被编写之前，测试应该总是失败的。如果他们不是，你应该怀疑！否则，您不能确定您的测试实际上捕捉到了任何错误。</p><h2 id="03e2" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">为什么是TDD？</strong></h2><p id="844c" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">TDD是自动化的，比手工测试更有效。如果测试是提前编写的，代码往往会得到更好的规划，更容易测试和修改，有更少的错误，并且有更好的代码覆盖率。</p><p id="ff7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于提前编写测试的另一个注意事项是:测试应该基于行为而不是实现来编写。这将避免在代码改变时不得不重写测试。</p><h2 id="765b" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">测试类型</strong></h2><p id="5f4d" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">有三种主要类型的测试。我们将只完成一个单元测试的例子。</p><p id="9515" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">单元测试</strong>:测试一段代码，通常是一个函数。这些测试更容易诊断，因为它们很有针对性。然而，这意味着它们也很脆弱，因为它们只能测试某些功能是否按照我们想要的方式工作。这并不意味着我们的应用程序作为一个整体在工作。</p><p id="64bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">集成测试</strong>:测试多个单元如何协同工作。它比单元测试更健壮，因为它测试的范围更广。然而，诊断故障可能更加困难。</p><p id="9466" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">验收</strong>:端到端(E2E)测试是用户从用户界面到数据库与应用程序的实际交互方式。这通常包括硒之类的东西，这不会在本文中讨论。</p><p id="aad3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为单元测试和集成各有所长，并且可以弥补彼此的不足，所以要由程序员和他们的团队来评估两者之间的适当平衡。</p><h2 id="affb" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">笑话和酶</strong></h2><p id="35e5" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我已经在React中使用Jest和酶开始了我的测试之旅。这篇文章假设你对React有一些基本的了解，并且已经用<code class="fe lw lx ly lz b">create-react-app</code>设置了一个应用。这将不包括Redux或Hooks。</p><p id="0f20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Jest是包含在<code class="fe lw lx ly lz b">create-react-app</code>中的一个JavaScript测试框架，尽管它的用途并不局限于React。Enzyme(由Airbnb创建)是一个库，可以更容易地专门测试React组件。它没有包含在<code class="fe lw lx ly lz b">create-react-app</code>中，但是为了使测试更容易，它和Jest一起使用是很常见的。</p><h2 id="8d3e" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">浅vs安装</strong></h2><p id="3243" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">Enzyme创建了一个虚拟DOM，允许在没有浏览器的情况下进行测试。通过Enzyme，我们可以使用jQuery风格的选择器在DOM中进行搜索。渲染有两种方式。第一种方式是<code class="fe lw lx ly lz b">shallow</code>渲染，它深入到代码的一个层次，而不用担心组件的子组件的行为。第二种呈现方式是用<code class="fe lw lx ly lz b">mount</code>，它更深入一层，测试一个组件的子组件。两者都有利弊，这里的<a class="ae jz" href="https://kentcdodds.com/blog/why-i-never-use-shallow-rendering/" rel="noopener ugc nofollow" target="_blank">和这里的</a>和<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/in-defense-of-shallow-rendering-5f627f7c155d">已经详细讨论过了。因为这篇文章是关于基础的，我们将停留在浅显的一端。</a></p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/582c1be0624687984b9e0fa850f82899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbCbv9s6YouQ4td-t0F7Zw.png"/></div></div></figure><h2 id="a09e" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">创建基本测试</strong></h2><p id="983c" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">终于！是时候创建一个基本测试了。对于这个测试，我们现在要做的就是确保我们的<code class="fe lw lx ly lz b">&lt;App /&gt;</code>组件被渲染。</p><p id="a0cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，Jest已经包含在<code class="fe lw lx ly lz b">create-react-app</code>中。您可以通过运行下面的命令单独安装Enzyme。</p><p id="f68d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lw lx ly lz b">npm install --save-dev enzyme jest-enzyme enzyme-adapter-react-16</code></p><p id="d253" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">* *注意:在本文发表时，React已更新为React 17，但酶适配器17不可用。在大多数情况下，酶适配器16将会起作用。我相信存在的问题是与<code class="fe lw lx ly lz b">mount</code>有关的，这里就不赘述了。然而，如果需要，这里有一个非官方的酶适配器17<a class="ae jz" href="https://www.npmjs.com/package/@wojtekmaj/enzyme-adapter-react-17" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="96d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的主要<code class="fe lw lx ly lz b">App</code>组件应该看起来像这样。如果您在<code class="fe lw lx ly lz b">div</code>中修改了一些内容，这没关系，但是为了简单起见，暂时不要修改任何子组件。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="59b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，你的<code class="fe lw lx ly lz b">App.test.js</code>文件应该是这样的，但是我们很快就会做很多改变！</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="eed4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们使用的是酶，我们可以从<code class="fe lw lx ly lz b">@testing-libary/react</code>中删除导入。我们可以添加<code class="fe lw lx ly lz b">import Enzyme, { shallow } from enzyme;</code>来配置<code class="fe lw lx ly lz b">Enzyme</code>使用适配器，添加<code class="fe lw lx ly lz b">{ shallow }</code>来创建我们之前讨论过的浅层渲染。添加<code class="fe lw lx ly lz b">import EnzymeAdapter from ‘enzyme-adapter-react-16’</code>创建适配器。请注意，如果您决定使用非官方的2017适配器，此导入可能会有所不同，您应该参考该文档。</p><p id="b04e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完全删除<code class="fe lw lx ly lz b">test()</code>及其所有内容，这样我们就可以一步一步地编写一个新的。</p><p id="a031" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要设置一个酶反应适配器的新实例，在导入下面添加<code class="fe lw lx ly lz b">Enzyme.configure({ adapter: new enzymeAdapter() });</code>。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="c858" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们编写测试之前，您应该运行<code class="fe lw lx ly lz b">create-react-app</code>附带的脚本<code class="fe lw lx ly lz b">npm test</code>。您应该会看到以下错误:</p><pre class="mb mc md me gt mh lz mi mj aw mk bi"><span id="296c" class="ky kz in lz b gy ml mm l mn mo">FAIL  src/App.test.js<br/>  ● Test suite failed to run</span><span id="7ad5" class="ky kz in lz b gy mp mm l mn mo">Your test suite must contain at least one test.</span><span id="7c94" class="ky kz in lz b gy mp mm l mn mo">at onResult (node_modules/@jest/core/build/TestScheduler.js:175:18)<br/>      at node_modules/@jest/core/build/TestScheduler.js:304:17<br/>      at node_modules/emittery/index.js:260:13<br/>          at Array.map (&lt;anonymous&gt;)<br/>      at Emittery.Typed.emit (node_modules/emittery/index.js:258:23)</span><span id="d1ce" class="ky kz in lz b gy mp mm l mn mo">Test Suites: 1 failed, 1 total<br/>Tests:       0 total<br/>Snapshots:   0 total<br/>Time:        6.499 s<br/>Ran all test suites related to changed files.</span><span id="c83b" class="ky kz in lz b gy mp mm l mn mo">Watch Usage<br/> › Press a to run all tests.<br/> › Press f to run only failed tests.<br/> › Press q to quit watch mode.<br/> › Press p to filter by a filename regex pattern.<br/> › Press t to filter by a test name regex pattern.<br/> › Press Enter to trigger a test run.</span></pre><p id="e87b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你得到了这个错误，太好了！您的测试套件设置正确。注意，你可以使用<code class="fe lw lx ly lz b">Watch Usage</code>下的任何命令。</p><p id="659c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们写一个测试！让我们测试一下<code class="fe lw lx ly lz b">App</code>组件的渲染是否没有错误。为此，编写一个新的空测试shell。在测试中，我们想要对我们的组件<code class="fe lw lx ly lz b">App</code>进行浅层渲染。我们将正在测试的组件放在从酶库导入的<code class="fe lw lx ly lz b">shallow</code>包装器中。按照惯例，我们把这个叫做<code class="fe lw lx ly lz b">wrapper</code>。</p><pre class="mb mc md me gt mh lz mi mj aw mk bi"><span id="78c5" class="ky kz in lz b gy ml mm l mn mo">test("renders without error", () =&gt; { <br/>   const wrapper = shallow(&lt;App/&gt;);<br/>});</span></pre><p id="ac0b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你在这里运行<code class="fe lw lx ly lz b">npm test</code>，你的测试应该是通过的。然而，由于这是测试驱动的开发，我们希望我们的测试在通过之前失败。为了解决这个问题，在我们正在渲染的组件的顶层添加一个<code class="fe lw lx ly lz b">data-test</code>属性。在这种情况下，那就是<code class="fe lw lx ly lz b">&lt;App /&gt;</code>中的<code class="fe lw lx ly lz b">div</code>。注意，你不需要使用<code class="fe lw lx ly lz b">data-test</code>来工作，但这是惯例。现在让它为空，这样我们可以在测试中找到属性，让它失败。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a5f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以向测试中添加更多的条件。导航回<code class="fe lw lx ly lz b">App.test.js</code>，在这里我们将使用<code class="fe lw lx ly lz b">wrapper</code>上的<code class="fe lw lx ly lz b">find(selector)</code>找到我们计划添加到浅层组件中的<code class="fe lw lx ly lz b">data-test</code>值。让我们假设<code class="fe lw lx ly lz b">data-test</code>值将是<code class="fe lw lx ly lz b">component-app</code>。注意，选择器的属性语法在<a class="ae jz" href="https://enzymejs.github.io/enzyme/docs/api/selector.html" rel="noopener ugc nofollow" target="_blank">文档</a>中有更详细的描述。</p><pre class="mb mc md me gt mh lz mi mj aw mk bi"><span id="70e7" class="ky kz in lz b gy ml mm l mn mo">test("renders without error", () =&gt; { <br/>   const wrapper = shallow(&lt;App/&gt;);<br/>   const appComponent = wrapper.find("[data-test='component-app']")   <br/>});</span></pre><p id="ef3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了！到目前为止，我们可以识别正在呈现的组件，并根据其值找到属性。然而，如果您运行<code class="fe lw lx ly lz b">npm test</code>，您将看到测试仍然通过。这是因为到目前为止我们只定义了两个变量。我们还没有做断言语句，这是你用来实际测试某个东西的。您需要一个断言语句来抛出错误，否则您的测试永远不会失败。</p><p id="1351" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们可以使用来自<a class="ae jz" href="https://jestjs.io/docs/en/expect" rel="noopener ugc nofollow" target="_blank"> Jest </a>的<code class="fe lw lx ly lz b">expect</code>断言。在这种特殊情况下，我们可以检查以确保返回的长度为1，以确保我们只接收节点返回。一个常用的方法是<code class="fe lw lx ly lz b">.toBe(value)</code>，你可以在<a class="ae jz" href="https://jestjs.io/docs/en/expect#tobevalue" rel="noopener ugc nofollow" target="_blank">文档</a>中读到更多。</p><pre class="mb mc md me gt mh lz mi mj aw mk bi"><span id="24c7" class="ky kz in lz b gy ml mm l mn mo">expect(appComponent.length).toBe(1);</span></pre><p id="3182" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整的<code class="fe lw lx ly lz b">App.test.js</code>文件应该是这样的:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="50f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行<code class="fe lw lx ly lz b">npm test</code>如果它还没有运行，希望你会得到你的第一次失败:</p><pre class="mb mc md me gt mh lz mi mj aw mk bi"><span id="7c2c" class="ky kz in lz b gy ml mm l mn mo">FAIL  src/App.test.js (5.451 s)<br/>  ✕ renders without error (11 ms)</span><span id="8046" class="ky kz in lz b gy mp mm l mn mo">● renders without error</span><span id="c95b" class="ky kz in lz b gy mp mm l mn mo">expect(received).toBe(expected) // Object.is equality</span><span id="e171" class="ky kz in lz b gy mp mm l mn mo">Expected: 1<br/>Received: 0</span><span id="fdbf" class="ky kz in lz b gy mp mm l mn mo">18 |   const appComponent = findByTestAttr(wrapper,"component-app")<br/>      19 |   // //need this test to fail first<br/>    &gt; 20 |   expect(appComponent.length).toBe(1)<br/>         |                               ^<br/>      21 |<br/>      22 | });<br/>      23 |</span><span id="4995" class="ky kz in lz b gy mp mm l mn mo">at Object.&lt;anonymous&gt; (src/App.test.js:20:31)</span><span id="4e28" class="ky kz in lz b gy mp mm l mn mo">Test Suites: 1 failed, 1 total<br/>Tests:       1 failed, 1 total<br/>Snapshots:   0 total<br/>Time:        7.379 s<br/>Ran all test suites.</span></pre><p id="3a48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完美！错误的重要部分清楚地表明，我们期望一个节点具有值为<code class="fe lw lx ly lz b">component-app</code>的<code class="fe lw lx ly lz b">data-test</code>属性。我们的<code class="fe lw lx ly lz b">&lt;App /&gt;</code>组件没有这个，所以测试失败了。</p><p id="aa8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了通过这个测试，您可以导航回<code class="fe lw lx ly lz b">App.js</code>并在。您的文件应该如下所示。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b441" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着<code class="fe lw lx ly lz b">npm test</code>运行，应该会得到这个结果。</p><pre class="mb mc md me gt mh lz mi mj aw mk bi"><span id="9307" class="ky kz in lz b gy ml mm l mn mo">PASS  src/App.test.js<br/>  ✓ renders without error (8 ms)</span><span id="3f01" class="ky kz in lz b gy mp mm l mn mo">Test Suites: 1 passed, 1 total<br/>Tests:       1 passed, 1 total<br/>Snapshots:   0 total<br/>Time:        3.578 s, estimated 6 s<br/>Ran all test suites.</span></pre><p id="cb9a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章对开始测试驱动开发有所帮助！这当然是一个非常基本的测试，但是这将帮助您理解为什么编写好的测试如此重要。</p><p id="7dac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">来源:<a class="ae jz" href="https://blog.logrocket.com/jest-and-enzyme-unit-testing-in-react-in-2021/" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/jest-and-enzyme-unit-testing-in-react-in-2021/</a></p><p id="78f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.udemy.com/course/react-testing-with-jest-and-enzyme/" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/react-testing-with jest-and-enzyme/</a></p></div></div>    
</body>
</html>