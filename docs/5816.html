<html>
<head>
<title>CSS Container Query: A Media Query on Steroids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS容器查询:类固醇上的媒体查询</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/css-container-query-a-media-query-on-steroids-1cc9381aa670?source=collection_archive---------4-----------------------#2021-12-11">https://javascript.plainenglish.io/css-container-query-a-media-query-on-steroids-1cc9381aa670?source=collection_archive---------4-----------------------#2021-12-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/b361bd855a50e156ade8ca4cd6742efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*lmfPg0AVDBvqbk5W.jpg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Just a bunch of containers</figcaption></figure><p id="3b2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">她终于来了。嗯，差不多了。</p><p id="517d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最受欢迎的网络功能之一终于问世了。截至今天，container query还在第一个<strong class="jx io">公开工作草案</strong>中——这意味着这个特性已经被证明是必不可少的，并且被认为有可能包含在未来的版本中。</p><p id="5905" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你现在甚至可以在谷歌浏览器上试用。在你的Chrome浏览器上进入<code class="fe kt ku kv kw b">chrome://flags/#enable-container-queries</code>，设置为<code class="fe kt ku kv kw b">enabled</code>，你就可以开始了。</p><h1 id="6d78" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">容器查询</h1><p id="ad8f" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">一个新的CSS查询，为后代元素提供了基于容器应用样式规则的可能性。</p><p id="4977" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然媒体查询基于视口和媒体首选项应用特定的样式，但容器查询允许被包含的元素以容器元素为目标，从而更进一步。这为所包含的元素提供了更细粒度的控制。</p><p id="ba89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是容器查询的简单用法，</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Simple Container Query Example</figcaption></figure><p id="d19d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这基本上是告诉浏览器，如果容器至少有300像素宽，就应用样式<code class="fe kt ku kv kw b">background-color: blue</code> <strong class="jx io">。</strong></p><p id="9e19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">语法相当简单，非常类似于媒体查询的语法。容器查询附带了<strong class="jx io">三个额外属性</strong>和<strong class="jx io">一个规则</strong>。</p><p id="33bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们有<code class="fe kt ku kv kw b">container-type</code>，该属性用于将元素建立为<strong class="jx io">查询容器</strong>，这将允许子组件对其进行查询。</p><p id="a3d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其次，<code class="fe kt ku kv kw b">container-name</code>为容器设置一个名称，以便进一步过滤。有时我们可能不想把最近的祖先容器作为目标，这个属性作为一个出口。</p><p id="bcec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，<code class="fe kt ku kv kw b">container</code>被用作一个速记属性，可以用来在一个声明中同时设置<code class="fe kt ku kv kw b">container-type</code>和<code class="fe kt ku kv kw b">container-name</code>。</p><p id="7ed3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了定位容器，我们使用<code class="fe kt ku kv kw b">@container</code>来指定定位最近的包容上下文的规则。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">@container Rule</figcaption></figure><p id="4d7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是非常令人兴奋的，因为子元素可以意识到它的周围环境，并可以自己决定如何反应。</p><h1 id="d5cb" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">高度模块化的组件</h1><p id="416c" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">考虑一个<strong class="jx io">卡</strong>组件，一个你以前可能见过的相当普通的元素。该组件具有以下属性:缩略图、标题、描述和一些标签。</p><p id="6c95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们希望组件能够适应不同的屏幕尺寸。在最小的视口中，缩略图和细节垂直堆叠。在稍大的视窗中，缩略图将位于左侧。最后，在最大的视窗中，我们的内容将位于缩略图之上。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/75d4ea2901959a4e73c9dfa18ff300dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iU4XiEwlLZVqPnm_wkUEwQ.png"/></div></div></figure><p id="339e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从HTML代码开始，</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Card HTML</figcaption></figure><p id="8aa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有CSS，</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Card CSS</figcaption></figure><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/839686fb09b0cb146b770bc8bd01401a.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*2Wd_jZ0nHDvm-vCE6JG7YA.png"/></div></figure><p id="5cae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止还不错。我们的卡在较小的屏幕上看起来很好，与我们计划的完全一样。</p><p id="5110" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在稍大的视口上，我们将使用容器查询来帮助我们处理转换，而不是媒体查询。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="bfc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用<code class="fe kt ku kv kw b">display: flex;</code>水平堆叠内容，我们还对缩略图和细节做了一些小的调整，以确保它看起来仍然不错。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mm"><img src="../Images/4c135e5fdbd5802bfe422e1ff8f1bfd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3WIiH3ALEqsUwT-JsoFaQ.png"/></div></div></figure><p id="e140" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，在最大的视口上，我们更新了我们的缩略图来填充空间，在缩略图的顶部添加了一些黑色的覆盖层<code class="fe kt ku kv kw b">background: linear-gradient(....);</code>，我们还将我们的<code class="fe kt ku kv kw b">.card-detail</code>设置为<code class="fe kt ku kv kw b">position: absolute;</code>并将我们的标题和描述的颜色更改为<code class="fe kt ku kv kw b">#ffffff</code></p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="c8e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果容器至少有<code class="fe kt ku kv kw b">560px</code>宽，我们的卡现在看起来就像这样。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mn"><img src="../Images/ff49ab80ddebd49fe45c197fbb6fe585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydPQygaZGy34yXcEZwSyrA.png"/></div></div></figure><p id="fb04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太棒了，我们的卡片组件在不同的视窗上看起来很棒。但更重要的是，容器查询的优势在于我们可以在更复杂的布局中重用相同的组件。</p><p id="6ba3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我创建了一个示例来演示容器查询的强大功能，</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9536" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mo"><img src="../Images/a855aceef9b9432c04bd26d630ed1a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDId_YuNIpO6kCuUAh1GKw.png"/></div></div></figure><p id="dc60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同一视口下的相同组件可以很好地适应不同的布局。如果没有容器查询，您将需要一个变通方法来使它工作，也许通过添加类名来区分选择器或者涉及Javascript。</p><p id="90cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，通过媒体查询依赖全局视口使得我们的组件不那么模块化——换句话说，它们在不同的布局中更难重用。</p><h1 id="2550" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">尺寸和其他方面</h1><p id="1693" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">我们可能并不总是提前知道维度。但是不用担心，容器查询附带了许多声明性查询类型，您可以使用它们来评估容器。</p><h2 id="e12d" class="mp ky in bd kz mq mr dn ld ms mt dp lh kg mu mv ll kk mw mx lp ko my mz lt na bi translated">容器大小查询</h2><p id="3639" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">第一种类型，即<a class="ae nb" href="https://drafts.csswg.org/css-contain-3/#size-container" rel="noopener ugc nofollow" target="_blank">容器大小查询</a>建立容器，以便根据其大小进行查询。这种类型的可能值有<code class="fe kt ku kv kw b">size</code>、<code class="fe kt ku kv kw b">inline-size</code>和<code class="fe kt ku kv kw b">block-size</code>。</p><p id="ef42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">size</code>类型根据内嵌轴和块轴的大小建立要查询的容器。</p><p id="5269" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在CSS中，内嵌轴和块轴指的是文本在行内流动的方向。例如，在英语中，文本从左到右，从上到下流动。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5208cbcb0b1fe9461a50cbc391e9169a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*Z1HPO7kokvAXEOIpdSz1lA.png"/></div></figure><p id="964e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设置为<code class="fe kt ku kv kw b">size</code>类型的容器允许通过其<code class="fe kt ku kv kw b">width</code>和<code class="fe kt ku kv kw b">height</code>进行查询。同样，<code class="fe kt ku kv kw b">inline-size</code>和<code class="fe kt ku kv kw b">block-size</code>分别允许查询集装箱的<code class="fe kt ku kv kw b">width</code>和<code class="fe kt ku kv kw b">height</code>。</p><h2 id="7fb0" class="mp ky in bd kz mq mr dn ld ms mt dp lh kg mu mv ll kk mw mx lp ko my mz lt na bi translated">容器样式查询</h2><p id="c8a8" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">第二种叫做<a class="ae nb" href="https://drafts.csswg.org/css-contain-3/#style-container" rel="noopener ugc nofollow" target="_blank">容器式查询</a>。这种类型提供了基于其单一的特定属性来查询容器的可能性。</p><h2 id="4bd6" class="mp ky in bd kz mq mr dn ld ms mt dp lh kg mu mv ll kk mw mx lp ko my mz lt na bi translated">容器状态查询</h2><p id="b523" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">第三种类型，<a class="ae nb" href="https://drafts.csswg.org/css-contain-3/#state-container" rel="noopener ugc nofollow" target="_blank">容器状态查询</a>建立容器，以便能够对容器的“当前状态”进行查询，例如<code class="fe kt ku kv kw b">position: sticky</code>容器是否“卡住”或者它当前是否在屏幕上可见。</p><p id="1e2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最有可能的是，你只需要在正常情况下查询大小，但我不在这里判断😅。此外，这些仍然是草案，可能会在未来发生* *的变化。但是它确实让我们看到了容器查询的可能性。</p><h1 id="890c" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="b1fc" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">响应式设计的想法非常棒——一个如此多功能的用户界面，无论你在什么设备上，它总是看起来优雅而完美。到目前为止，这个想法在目前的技术水平下基本上是可以实现的。</p><p id="38e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我说主要是因为有些情况仅仅依靠媒体的询问是无法解决的。为了让组件优雅地适应复杂的布局，经常需要做许多小的调整。这些是container query想要解决的一些问题。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="5c0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nk">最初发布于</em><a class="ae nb" href="https://frendyguo.me/css-container-query/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://frendy Guo . me</em></a><em class="nk">。</em></p><p id="aee2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nk">更多内容看</em> <a class="ae nb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nk">说白了就是</em> </a> <em class="nk">。报名参加我们的</em> <a class="ae nb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nk">免费每周简讯</em> </a> <em class="nk">。在我们的</em> <a class="ae nb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nk">社区不和谐</em> </a> <em class="nk">获得独家获得写作机会和建议。</em></p></div></div>    
</body>
</html>