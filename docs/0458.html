<html>
<head>
<title>Improving Webpack Developer Experience</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改善Webpack开发人员体验</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improving-webpack-developer-experience-e565e04220aa?source=collection_archive---------11-----------------------#2021-01-27">https://javascript.plainenglish.io/improving-webpack-developer-experience-e565e04220aa?source=collection_archive---------11-----------------------#2021-01-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1d23" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用Create React App的React开发工具</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/81d94bedb9a7fbd8dd73386e5e75dbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X3hG23BCpbbIu8iV"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="49a0" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="5248" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我用自己的Webpack配置已经很久了。但是对于快速的演示项目，比如那些中型文章，使用定制的构建系统是没有意义的。于是我又开始用Create React App。我已经忘记很久的所有难以置信的开发人员体验又回来了——比如如果我想要的端口正在使用，允许我使用不同的端口，使用现有的浏览器标签而不是打开新的标签，以及使用新安装的依赖项自动重建。所有这些好的特性让我思考——我能不能在不使用Create React应用程序的情况下拥有同样的功能？</p><h1 id="a2f0" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">React开发工具</h1><p id="b7c3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="https://www.npmjs.com/package/react-dev-utils" rel="noopener ugc nofollow" target="_blank"> React Dev Utils </a>是Create React App的构建工具库。因为这是一个单独的专用包，所以即使您没有使用Create React App，也可以使用它们！要安装，运行<code class="fe mh mi mj mk b">npm install --save-dev react-dev-utils</code>。现在，让我们深入其中一些工具，看看它们如何让你的生活变得更加轻松。</p><h1 id="5d62" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">选择端口</h1><p id="2257" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">您是否遇到过您想要的端口被占用的情况？如果您在同一个开发端口上运行多个项目，这个问题会经常出现。你会收到这条信息</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="28a9" class="mp ku in mk b gy mq mr l ms mt">Error: listen EADDRINUSE: address already in use 127.0.0.1:3000</span></pre><p id="0e6c" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">Webpack Dev服务器将无法启动。要解决这个问题，您必须找到并终止使用您的端口的另一个进程，或者使用不同的端口重新启动Webpack Dev Server。</p><p id="cbee" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">React Dev Utils提供了<code class="fe mh mi mj mk b">WebpackDevServerUtils.choosePort</code>实用程序来自动检测所需的端口是否正在使用，并选择另一个端口。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="8d7e" class="mp ku in mk b gy mq mr l ms mt">const { choosePort } = require('react-dev-utils/WebpackDevServerUtils');</span><span id="437c" class="mp ku in mk b gy mz mr l ms mt">const desiredPort = parseInt(process.env.PORT, 10) || 3000;</span><span id="c135" class="mp ku in mk b gy mz mr l ms mt">const config = async () =&gt; {<br/>  const port = await choosePort(host, desiredPort);<br/>  if (!port) {<br/>    process.exit();<br/>  }</span><span id="0aec" class="mp ku in mk b gy mz mr l ms mt">  // Webpack configuration<br/>  return {<br/>    ...<br/>    devServer: {<br/>      port,<br/>    },<br/>  };<br/>};</span><span id="0d3e" class="mp ku in mk b gy mz mr l ms mt">module.exports = config;</span></pre><p id="7a64" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">不要使用对象配置，而是将Webpack配置导出为异步函数。如果所需的端口正在使用中，<code class="fe mh mi mj mk b">choosePort</code>将阻塞并等待用户输入。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="e9ed" class="mp ku in mk b gy mq mr l ms mt">Something is already running on port 3000.<br/>Would you like to run the app on another port instead?</span></pre><p id="b45d" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">如果用户键入<code class="fe mh mi mj mk b">y</code>(表示是)，那么实用程序将自动找到下一个可用端口。如果用户键入<code class="fe mh mi mj mk b">n</code>(代表否)，那么实用程序将返回<code class="fe mh mi mj mk b">null</code>，过程将退出。现在，您可以优雅地解决端口冲突问题。</p><h1 id="0afb" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><code class="fe mh mi mj mk b">Open Browser</code></h1><p id="59f7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在启动Webpack Dev服务器之后，您很可能需要打开浏览器到指定的开发URL。为了自动做到这一点，Webpack Dev服务器提供了一个<code class="fe mh mi mj mk b">open</code>标志。但它以一种愚蠢的方式做到了这一点——它总是用指定的主机和端口打开一个新的浏览器选项卡，忽略任何具有相同URL的现有浏览器选项卡。这会导致过多的浏览器标签打开到同一个页面，这也有降低多个热重新加载标签的性能的副作用。</p><p id="34e3" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">对于Mac上的Chrome用户，React Dev Util的<code class="fe mh mi mj mk b">openBrowser</code>实用程序可以智能地使用现有的浏览器标签。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="8e4d" class="mp ku in mk b gy mq mr l ms mt">const openBrowser = require('react-dev-utils/openBrowser');</span><span id="dc80" class="mp ku in mk b gy mz mr l ms mt">const host = process.env.HOST || 'localhost';<br/>const port = parseInt(process.env.PORT, 10) || 3000;</span><span id="035a" class="mp ku in mk b gy mz mr l ms mt">module.exports = {<br/>  ...<br/>  devServer: {<br/>    onListening: () =&gt; {<br/>      openBrowser(`<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/${host}:${port}`">http://${host}:${port}`</a>);<br/>    },<br/>    port,<br/>    host,<br/>  },<br/>};</span></pre><p id="dbdc" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">利用Webpack Dev服务器开始监听指定主机端口上的连接后调用的<code class="fe mh mi mj mk b">onListening</code>钩子，我们可以调用<code class="fe mh mi mj mk b">openBrowser</code>实用程序。如果这个URL有Chrome标签，它会智能地切换到那个标签。如果没有，它会像<code class="fe mh mi mj mk b">open</code>标志一样打开一个新标签。现在，你将不再有重复和不必要的浏览器标签。</p><h1 id="e07a" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><code class="fe mh mi mj mk b">WatchMissingNodeModulesPlugin</code></h1><p id="6141" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">Webpack Dev Server的热重装在检测到代码和依赖关系变化时会自动重建，但也有检测失败的情况。使用未安装的软件包就是其中之一。在这种情况下，Webpack Dev Server将无法像预期的那样编译，但是在软件包安装后，它仍然无法恢复。要解决这个问题，您需要重新启动Webpack Dev服务器。React Dev Util的<code class="fe mh mi mj mk b">WatchMissingNodeModulesPlugin</code>解决了这个问题。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="5ad6" class="mp ku in mk b gy mq mr l ms mt">const WatchMissingNodeModulesPlugin = require('react-dev-utils/WatchMissingNodeModulesPlugin');</span><span id="9935" class="mp ku in mk b gy mz mr l ms mt">module.exports = {<br/>  ...<br/>  plugins: [<br/>    new WatchMissingNodeModulesPlugin(path.resolve('node_modules')),<br/>  ],<br/>};</span></pre><p id="9db4" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated"><code class="fe mh mi mj mk b">WatchMissingNodeModulesPlugin</code>将检测缺失的依赖项并观察<code class="fe mh mi mj mk b">node_modules</code>。如果它们出现，插件将自动触发重建。现在，您将不再需要在使用尚未安装的包后重启Webpack Dev服务器。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="6560" class="kt ku in bd kv kw nh ky kz la ni lc ld jt nj ju lf jw nk jx lh jz nl ka lj lk bi translated">最后的想法</h1><p id="df53" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">即使您使用自己的Webpack配置，Create React App的构建工具仍然可以改善您的开发人员体验。它提供了工具来解决诸如端口冲突、不必要的浏览器标签和丢失包重建失败等不便。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="f726" class="kt ku in bd kv kw nh ky kz la ni lc ld jt nj ju lf jw nk jx lh jz nl ka lj lk bi translated">资源</h1><ul class=""><li id="d543" class="nm nn in ln b lo lp lr ls lu no ly np mc nq mg nr ns nt nu bi translated"><a class="ae ks" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">官方Webpack文档</a></li><li id="34b8" class="nm nn in ln b lo nv lr nw lu nx ly ny mc nz mg nr ns nt nu bi translated"><a class="ae ks" href="https://webpack.js.org/configuration/dev-server/" rel="noopener ugc nofollow" target="_blank">官方Webpack开发服务器文档</a></li><li id="44a4" class="nm nn in ln b lo nv lr nw lu nx ly ny mc nz mg nr ns nt nu bi translated"><a class="ae ks" href="https://www.npmjs.com/package/react-dev-utils" rel="noopener ugc nofollow" target="_blank">官方反应开发文档</a></li></ul></div></div>    
</body>
</html>