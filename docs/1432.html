<html>
<head>
<title>How CSS-in-JS Libraries Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS-in-JS库如何工作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-css-in-js-libraries-work-da4145b1b6c7?source=collection_archive---------6-----------------------#2021-03-26">https://javascript.plainenglish.io/how-css-in-js-libraries-work-da4145b1b6c7?source=collection_archive---------6-----------------------#2021-03-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d3fd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用样式化组件描述的CSS-in-JS库的内部</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1fbe141e22ff128ef3c2260922251246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*91CTAJQKgd1-GNTu"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@kobuagency?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">KOBU Agency</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f7eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看一个如何用样式化组件来样式化<code class="fe lp lq lr ls b">div</code>的例子。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="d2d0" class="lx ly in ls b gy lz ma l mb mc">import styled from 'styled-components';  </span><span id="87fb" class="lx ly in ls b gy md ma l mb mc">const AwesomeStyledDiv = styled.div`  <br/>    width: 20px;  <br/>    height: 10px;  <br/>    background-color: blue; <br/>`</span></pre><p id="4461" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的例子中，我们已经:</p><ol class=""><li id="d31e" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated">从名为<code class="fe lp lq lr ls b">styled</code>的样式组件中导入了一些东西。</li><li id="e66c" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">定义了HTML元素的样式，在这里是一个<code class="fe lp lq lr ls b">div</code>。</li><li id="8798" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">给这个<code class="fe lp lq lr ls b">div</code>增加了一些造型。</li></ol><p id="0226" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">AwesomeStyledDiv</code>现在可以像项目中定义的任何其他React组件一样使用。</p><p id="a1ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您曾经使用过样式化组件，那么您可能已经写了几百遍这样的东西，但是您是否想过这个语法是如何被翻译成样式化的<code class="fe lp lq lr ls b">div</code>？</p><h1 id="07df" class="ms ly in bd mt mu mv mw mx my mz na nb jt nc ju nd jw ne jx nf jz ng ka nh ni bi translated">那些逆记号是关于什么的？</h1><p id="18a3" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">您很可能只在ES6中使用模板文字时使用反斜线，比如:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="319e" class="lx ly in ls b gy lz ma l mb mc">const greeting = `hello ${name}!`;</span></pre><p id="5fbb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有一种更高级的模板文字形式，称为“标记模板文字”。标记模板允许你用模板文本调用一个函数。以这种方式调用时，函数被称为“标记函数”。</p><p id="e569" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大多数情况下，您会像这样调用函数:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="dc2a" class="lx ly in ls b gy lz ma l mb mc">const logFirstArgument = (arg1) =&gt; {   <br/>    console.log(arg1); <br/>}  </span><span id="ae52" class="lx ly in ls b gy md ma l mb mc">logFirstArgument('call me');  // output: 'call me'</span></pre><p id="10fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是你知道你也可以不用花括号调用这个函数，而是用一个模板文字吗？(在你的chrome主机上试试这个)。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="a844" class="lx ly in ls b gy lz ma l mb mc">logFirstArgument`call me`;  </span><span id="fa79" class="lx ly in ls b gy md ma l mb mc">// output: [ 'call me' ]</span></pre><p id="c096" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这两种调用函数的方式之间唯一的区别是参数如何传递给函数。注意，对于带标签的模板，我们的第一个参数被包装在一个数组中！这里有一点很重要，这里没有什么babel/webpack魔法，这个语法是ES6的一部分。</p><h1 id="e2dc" class="ms ly in bd mt mu mv mw mx my mz na nb jt nc ju nd jw ne jx nf jz ng ka nh ni bi translated">当用模板文字调用函数时，参数是如何解释的？</h1><p id="8e88" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">在上面的例子中，我们注意到当我们用一个模板文本调用一个函数时，传递给函数的字符串被包装到一个数组中(很快会有更多的介绍)。</p><p id="ff60" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们试图用一个有“插值”的模板文字调用一个函数时，事情变得更加有趣了(正如我们在上面看到的，类似于<code class="fe lp lq lr ls b">`hello ${name}`</code>)。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="6614" class="lx ly in ls b gy lz ma l mb mc">const readerName = 'reader';</span><span id="ad75" class="lx ly in ls b gy md ma l mb mc">const logFirstAndSecondArguments = (arg1, arg2) =&gt; {<br/>  console.log(arg1);<br/>  console.log(arg2);<br/>}</span><span id="5ac3" class="lx ly in ls b gy md ma l mb mc">logFirstAndSecondArguments`call me ${readerName}`</span><span id="0518" class="lx ly in ls b gy md ma l mb mc">// output:<br/>// [ 'call me ', '' ]<br/>// 'reader'</span></pre><p id="b974" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这看起来可能有点吓人，但事实是:</p><ol class=""><li id="6d7b" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated">第一个参数是我们的<code class="fe lp lq lr ls b">readerName</code>占位符周围的一个数组‘split’。</li><li id="97a2" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">第二个参数是<code class="fe lp lq lr ls b">readerName</code>占位符中的表达式，在本例中，它是一个解析为<code class="fe lp lq lr ls b">'reader'</code>的变量。</li></ol><p id="aa2a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你添加到字符串中的任何额外的插值都会做同样的事情:</p><ol class=""><li id="8420" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated">第一个参数将围绕<strong class="kv io">所有占位符“拆分”。</strong></li><li id="9cfe" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">后续参数将接收传递给每个附加占位符的表达式。</li></ol><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="bc82" class="lx ly in ls b gy lz ma l mb mc">const firstName = 'reader';<br/>const lastName = 'readerHead';</span><span id="3bb4" class="lx ly in ls b gy md ma l mb mc">const logFirstSecondThirdArguments = (arg1, arg2, arg3) =&gt; {<br/>  console.log(arg1);<br/>  console.log(arg2);<br/>  console.log(arg3);<br/>}</span><span id="9509" class="lx ly in ls b gy md ma l mb mc">logFirstSecondThirdArguments`first name: ${firstName}, lastname: ${lastName}`</span><span id="4716" class="lx ly in ls b gy md ma l mb mc">// output:<br/>// [ 'first name: ', ', lastname: ', '' ]<br/>// 'reader'<br/>// 'readerHead'</span></pre><h1 id="8fa7" class="ms ly in bd mt mu mv mw mx my mz na nb jt nc ju nd jw ne jx nf jz ng ka nh ni bi translated">如果我们的占位符包含一个函数会发生什么？</h1><p id="ea01" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">既然我们可以在占位符中传递任何表达式，那么让我们看看当我们传递一个函数时会发生什么；</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="0d63" class="lx ly in ls b gy lz ma l mb mc">const readerName = 'reader';<br/>const logFirstAndSecondArguments = (arg1, arg2) =&gt; {<br/>  console.log(arg1);<br/>  console.log(arg2);<br/>  console.log(arg2());<br/>}</span><span id="9088" class="lx ly in ls b gy md ma l mb mc">const returnHello = () =&gt; 'hello'</span><span id="f895" class="lx ly in ls b gy md ma l mb mc">logFirstAndSecondArguments`call me ${returnHello}`</span><span id="9b86" class="lx ly in ls b gy md ma l mb mc">// output<br/>// [ 'call me ', '' ]<br/>// ƒ returnHello()<br/>// 'hello'</span></pre><p id="97e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里真正酷的事情是我们可以在<code class="fe lp lq lr ls b">logFirstAndSecondArguments</code>函数中访问<code class="fe lp lq lr ls b">returnHello</code>函数(并且它可以被调用)!这种学习对于如何设计组件和工作是至关重要的。</p><h1 id="891f" class="ms ly in bd mt mu mv mw mx my mz na nb jt nc ju nd jw ne jx nf jz ng ka nh ni bi translated">这很好，但是为什么我们要再次讨论这个问题，它对样式化组件有什么帮助？</h1><p id="9a5f" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">让我们回到第一个带有样式化组件的样式化<code class="fe lp lq lr ls b">div</code>的例子:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="fb78" class="lx ly in ls b gy lz ma l mb mc">import styled from 'styled-components';</span><span id="4554" class="lx ly in ls b gy md ma l mb mc">const AwesomeStyledDiv = styled.div`  <br/>    width: 20px;  <br/>    height: 10px;  <br/>    background-color: blue; <br/>`</span></pre><p id="dfe8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在研究了标记的模板文字之后，这里发生的事情应该更清楚了:</p><ol class=""><li id="fbf5" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated"><code class="fe lp lq lr ls b">styled.div</code>只是我们导入的一个函数。</li><li id="1eb6" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">当我们用模板文本调用这个函数时，这个函数以我们刚刚讨论过的相同方式接收参数。在这种情况下，它将是作为第一个参数的<strong class="kv io">整个样式字符串，包装在一个数组中。</strong></li></ol><p id="e184" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们定义的styled-component根据传递的属性改变了CSS属性，我们也可以根据我们刚刚了解到的情况进行推理:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="0dd0" class="lx ly in ls b gy lz ma l mb mc">import styled from 'styled-components';</span><span id="9317" class="lx ly in ls b gy md ma l mb mc">const AwesomeStyledDiv = styled.div`  <br/>    width: 20px;  <br/>    height: 10px;  <br/>    background-color: ${props =&gt; props.isRed ? 'red' : 'blue'}; <br/>`</span></pre><p id="0afb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以假设<code class="fe lp lq lr ls b">styled.div</code>函数将接收两个参数:</p><ol class=""><li id="425b" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated">它的第一个参数是一个字符串数组，围绕<code class="fe lp lq lr ls b">${props =&gt; props.isRed ? 'red' : 'blue'}</code>分开。大概是:<code class="fe lp lq lr ls b">['width:20px;height:10px;background-color: ', '']</code></li><li id="fc0b" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">它的第二个参数将包含占位符中的表达式，在本例中是函数<code class="fe lp lq lr ls b">props =&gt; props.isRed ? 'red' : 'blue'</code>。</li></ol><h1 id="18d3" class="ms ly in bd mt mu mv mw mx my mz na nb jt nc ju nd jw ne jx nf jz ng ka nh ni bi translated">有了这些知识，让我们构建一个简化版本的样式化组件！</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0d45" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们仔细分析一下这个片段中到底发生了什么:</p><ol class=""><li id="ba8b" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated">我们创建了一个名为<code class="fe lp lq lr ls b">styledComponentFactory</code>的工厂函数(如果你不知道工厂函数是什么，它只是一个用于创建东西的设计模式)。</li><li id="027e" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">这个函数可以用一个<code class="fe lp lq lr ls b">Component</code>调用，在这个例子中，它是一个HTML <code class="fe lp lq lr ls b">div</code>。它返回另一个函数。</li><li id="9b2a" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">第二个函数是我们的标签函数(用一个模板文本调用)并返回一个React组件(<code class="fe lp lq lr ls b">ReturnedComponent</code>)，我们将在应用程序中的任何地方使用它。</li><li id="95ab" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">在第一次渲染之后(比如在挂载时，通过<code class="fe lp lq lr ls b">React.useEffect</code>)，我们在<code class="fe lp lq lr ls b">Component</code>上设置样式属性。</li></ol><p id="442e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="nq">注意</em> </strong>:这个代码片段只对没有插值的模板文字有效。</p><h1 id="b4f3" class="ms ly in bd mt mu mv mw mx my mz na nb jt nc ju nd jw ne jx nf jz ng ka nh ni bi translated">让我们更进一步</h1><p id="9e05" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">你可能会问，创建一个样式化组件克隆的目的是什么？如果它不允许你根据你传递的属性来改变CSS属性，让我们来编辑我们的克隆，让它工作。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4786" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里没有太大的变化，区别都在<code class="fe lp lq lr ls b">useEffect</code>块。</p><ol class=""><li id="2bdb" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated">我们移除了依赖数组<code class="fe lp lq lr ls b">[]</code>，以便<code class="fe lp lq lr ls b">useEffect</code>块在每次渲染后运行(在装载和更新时，考虑到改变属性值)。</li><li id="7fa9" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">我们使用reduce将样式字符串与调用模板文本中的每个函数(或获取表达式的值)的结果连接起来。请记住，当使用模板文本调用函数时:第一个参数是占位符周围的数组<strong class="kv io">，所有其他参数是占位符</strong>中的<strong class="kv io">表达式。</strong></li><li id="8f08" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">元素的样式属性设置为该样式字符串。</li></ol><h1 id="4d84" class="ms ly in bd mt mu mv mw mx my mz na nb jt nc ju nd jw ne jx nf jz ng ka nh ni bi translated">这与样式化组件的实际实现有何不同？</h1><p id="7f0c" class="pw-post-body-paragraph kt ku in kv b kw nj jo ky kz nk jr lb lc nl le lf lg nm li lj lk nn lm ln lo ig bi translated">本文讨论的是styled-components内部工作的简化版本。一个主要的区别是，我们的组件将<code class="fe lp lq lr ls b">style</code>属性中的所有样式直接放在HTML元素上。不需要太多的细节，还有几件事情正在发生:</p><ol class=""><li id="9182" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated">如上所述，它不内嵌样式。</li><li id="19f2" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">还会进行一些CSS预处理(允许嵌套样式和基于浏览器的前缀样式)。</li><li id="2ae2" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">创建一个唯一的散列并作为类名。这个散列类接收我们传递的自定义样式。然后在我们的HTML文档中的<code class="fe lp lq lr ls b">&lt;head /&gt;</code>的末尾注入一个<code class="fe lp lq lr ls b">&lt;style&gt;</code>标签。</li></ol><h1 id="665b" class="ms ly in bd mt mu mv mw mx my mz na nb jt nc ju nd jw ne jx nf jz ng ka nh ni bi translated">结论</h1><ol class=""><li id="0ae0" class="me mf in kv b kw nj kz nk lc nr lg ns lk nt lo mj mk ml mm bi translated">styled-components使用带标签的模板文字来构建您的样式组件。</li><li id="66e9" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">没有巴别塔魔术使这一工作，这是所有的ES6和风格化的组件内部逻辑！</li><li id="adab" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">用模板文字调用函数时:第一个参数是占位符周围拆分的数组<strong class="kv io">，所有附加参数都是占位符</strong>中的<strong class="kv io">表达式。</strong></li><li id="f962" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated">构建一个简单的样式组件克隆非常简单。</li></ol><p id="be7d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">非常感谢阅读，我希望这是有帮助的！</p></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><p id="bd4b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">参考资料和进一步阅读:</p><ol class=""><li id="5a91" class="me mf in kv b kw kx kz la lc mg lg mh lk mi lo mj mk ml mm bi translated"><a class="ae ks" href="https://mxstbr.blog/2016/11/styled-components-magic-explained/" rel="noopener ugc nofollow" target="_blank">https://MX stbr . blog/2016/11/styled-components-magic-explained/</a></li><li id="4c8d" class="me mf in kv b kw mn kz mo lc mp lg mq lk mr lo mj mk ml mm bi translated"><a class="ae ks" href="https://medium.com/styled-components/how-styled-components-works-618a69970421" rel="noopener">https://medium . com/styled-components/how-styled-components-works-618 a 69970421</a></li></ol></div></div>    
</body>
</html>