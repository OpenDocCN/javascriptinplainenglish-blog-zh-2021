<html>
<head>
<title>Functional JavaScript: Writing a simple Command-line Game (Part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript:编写简单的命令行游戏(第4部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-javascript-writing-a-simple-comand-line-game-part-3-26c73a15b0d0?source=collection_archive---------8-----------------------#2021-04-28">https://javascript.plainenglish.io/functional-javascript-writing-a-simple-comand-line-game-part-3-26c73a15b0d0?source=collection_archive---------8-----------------------#2021-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0827ec192a4742b5b4123e986f41b3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGldC6PU8JnORP4WXmereA.png"/></div></div></figure><p id="34df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一节中，我们将重温最初在第1部分中发布的代码。我们已经做了大量的重构工作，并且编写了一些测试。现在我们必须修改角色对象来使用物品和武器。希望您会看到代码更容易阅读，更不容易出错。</p><p id="6099" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们能够修复一些潜在的问题，并确保我们已经涵盖了许多边缘情况。更重要的是，我们可以重温战斗逻辑，并添加一个神奇的武器。</p><p id="21c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们回顾一下一个角色的代码以及它是如何进化的。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b6eb" class="lc ld in ky b gy le lf l lg lh">// character.js<br/>const <strong class="ky io"><em class="li">weapons </em></strong>= require("./weapons");<br/>const bag = require("./bag");<br/><br/>const character = function(who, attrib) {<br/>    attrib = attrib || {};<br/>    const _name = who;<br/>    const dv = (value,def ) =&gt; (typeof value === "undefined")?def:value;<br/>    let _hp = dv( attrib.hp, 10 );<br/>    let _level = dv( attrib.level, 1 );<br/>    const _bag = bag("Bag of Holding",5);<br/>    let _weapon =  dv( attrib.weapon, <strong class="ky io"><em class="li">weapons</em></strong>.hand);<br/><br/>    function name() {<br/>        return _name;<br/>    }<br/>    function hit() {<br/>        return _hp -= 1;<br/>    }<br/>    function dead() {<br/>        return _hp === 0<br/>    }<br/>    function stash( item ) {<br/>        let err = _bag.stash(item)<br/>        if ( err == null) {<br/>            <strong class="ky io"><em class="li">console</em></strong>.log("You found the " + item.name() + " and stashed it away");<br/>        } else {<br/>            <strong class="ky io"><em class="li">console</em></strong>.log("You can only stash items and not " + typeof item );<br/>        }<br/>    }<br/>    function use( itemName ) {<br/>        const item = _bag.fetch( itemName );<br/>        if (item &amp;&amp; item.isWeapon) {<br/>            <strong class="ky io"><em class="li">console</em></strong>.log( "You grab the " + item.name() + " and get ready to fight");<br/>            _weapon = item;<br/>        } else {<br/>            <strong class="ky io"><em class="li">console</em></strong>.log( "You use the " + item.name() + " it doesn't seem to do much")<br/>            _bag.stash( item );<br/>        }<br/>        return true;<br/>    }<br/>    function getBag() {<br/>        return _bag;<br/>    }<br/>    function getWeapon() {<br/>        return _weapon;<br/>    }<br/>    function level() {<br/>        return _level;<br/>    }<br/>    function levelUp() {<br/>        _hp += 1;<br/>        return _level += 1;<br/>    }<br/>    return { name, stash, getBag, use, getWeapon, hit, dead, level, levelUp, isCharacter : true }<br/>}<br/><br/>module.exports = character;</span></pre><p id="4ecb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里需要指出几个项目，控制台的输出现在在角色对象中，我们已经从其他组件中删除了消息。我们已经将更复杂的功能抽象成更小的单元，支持正式测试。我已经省略了这些新对象的测试代码，但是它看起来与前面的例子非常相似。我会在系列的最后把所有代码发布在github上。</p><p id="656b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个策略强调了封装的价值，特别是组件中“私有”数据的不可访问性。在我们最初的版本中，为了修改这个包，我们必须知道它使用了一个数组。在我们重构的例子中，我们在内部切换到使用一个对象。将来，我们可以转而使用地图或其他数据结构，而消费者不会意识到这种变化。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="8702" class="lc ld in ky b gy le lf l lg lh">_bag.push( item );</span></pre><p id="7a53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相对</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="18c0" class="lc ld in ky b gy le lf l lg lh">bag.stash( item );</span></pre><p id="ecad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个简单的改变隐藏了很多功能。包括错误处理、限制袋子大小的容量以及确保袋子只能容纳物品。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="d27b" class="lc ld in ky b gy le lf l lg lh">function stash( item ) {<br/>    if ( size() &gt;= _size ) {<br/>        return “Your bag is full, you have to drop an item first”;<br/>    }<br/>    if ( !item.isItem ) {<br/>        return “A bag can only be filled with items not “ + typeof item + “‘s”;<br/>    }<br/>    _items[item.name()] = item;<br/>    return null;<br/>}</span></pre><p id="61bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继续战斗！</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4387" class="lc ld in ky b gy le lf l lg lh">// fight.js<br/>// dieroll simulates a die roll, d12 + a modifier<br/>function dieroll( level )<br/>{<br/>    const rand = ( num ) =&gt; <strong class="ky io"><em class="li">Math</em></strong>.floor( <strong class="ky io"><em class="li">Math</em></strong>.random() * num )<br/>    return rand( 12 ) + rand( level );<br/>}<br/><br/>function fight( char1, char2 ) {<br/>    while (true) {<br/>        const c1roll = dieroll(char1.level()) + char1.getWeapon().strength();<br/>        const c2roll = dieroll(char2.level()) + char2.getWeapon().strength();<br/><br/>        if (c1roll &lt; c2roll) {<br/>            char1.hit();<br/>            <strong class="ky io"><em class="li">console</em></strong>.log( char2.name() + " strikes the " + char1.name());<br/>        } else if ( c1roll &gt; c2roll ) {<br/>            char2.hit()<br/>            <strong class="ky io"><em class="li">console</em></strong>.log( char1.name() + " strikes the " + char2.name());<br/>        } else {<br/>            <strong class="ky io"><em class="li">console</em></strong>.log( "Both missed" );<br/>        }<br/><br/>        if (char1.dead()) {<br/>            <strong class="ky io"><em class="li">console</em></strong>.log( char1.name() + " is dead, killed by the " + char2.name());<br/>            return true;<br/>        }<br/>        if (char2.dead()) {<br/>            <strong class="ky io"><em class="li">console</em></strong>.log( char2.name() + " is dead, killed by the " + char1.name());<br/>            return false;<br/>        }<br/>    }<br/>}<br/><br/>module.exports = fight;</span></pre><p id="ada7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码看起来与我们的原始版本非常相似，尽管我们不再“神奇地”获得我们现在称之为方法的武器的力量。在这个简单的例子中，它似乎没有增加很多，但是让我们想象我们想要定义一个“法宝”来选择一个随机的强度。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="fdc1" class="lc ld in ky b gy le lf l lg lh">// magicweapon.js<br/>const weapon = require( "./weapon");<br/><br/>const rand = ( num ) =&gt; <strong class="ky io"><em class="li">Math</em></strong>.floor( <strong class="ky io"><em class="li">Math</em></strong>.random() * num )<br/><br/>const magicweapon = function( n, s ) {<br/>    const _weapon = weapon( n, s );<br/><br/>    function strength() {<br/>        const value = rand( _weapon.strength() );<br/>        <strong class="ky io"><em class="li">console</em></strong>.log("Using a wand of strength " + value );<br/>        return value;<br/>    }<br/>    return { ..._weapon, strength, isMagicWeapon : true }<br/>}<br/>module.exports = magicweapon;</span></pre><p id="a1e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以组合现有的武器并覆盖力量方法，从1到基础力量中随机选择。</p><p id="0ad5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们需要一种方法来运行这些代码；让我们安排一些比赛。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="feaa" class="lc ld in ky b gy le lf l lg lh">const character = require( "../character");<br/>const fight = require( "../fight");<br/>const <strong class="ky io"><em class="li">weapons </em></strong>= require( "../weapons");<br/>const magic = require( "../magicweapon");<br/><br/>const wand = magic( "wand", 20 );<br/><br/>function round1() {<br/>    <strong class="ky io"><em class="li">console</em></strong>.log( "Round 1")<br/>    const you = character("Rogue");<br/>    const npc = character("Grump Ork", {hp: 5, weapon: <strong class="ky io"><em class="li">weapons</em></strong>.hammer});<br/><br/>    fight(you, npc);<br/>}<br/><br/>function round2() {<br/>    <strong class="ky io"><em class="li">console</em></strong>.log( "Round 2")<br/>    const you = character("Fighter");<br/>    const npc = character("Grump Ork 2", {hp: 5, weapon: <strong class="ky io"><em class="li">weapons</em></strong>.hammer});<br/>    you.stash( <strong class="ky io"><em class="li">weapons</em></strong>.long_sword );<br/>    you.use( <strong class="ky io"><em class="li">weapons</em></strong>.long_sword.name());<br/>    fight(you, npc);<br/>}<br/><br/>function round3() {<br/>    <strong class="ky io"><em class="li">console</em></strong>.log( "Round 3")<br/>    const you = character("Wizard");<br/>    const npc = character("Grump Ork 3", {hp: 5, weapon: <strong class="ky io"><em class="li">weapons</em></strong>.hammer});<br/>    you.stash( wand );<br/>    you.use( wand.name());<br/>    fight(you, npc);<br/>}<br/><br/>round1();<br/>round2();<br/>round3();</span></pre><p id="09a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">巫师的最后一轮看起来像下面这样。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="0b2f" class="lc ld in ky b gy le lf l lg lh">Round 3<br/>You found the wand and stashed it away<br/>You grab the wand and get ready to fight<br/>Using a wand of strength 17<br/>Wizard strikes the Grump Ork 3<br/>Using a wand of strength 8<br/>both missed<br/>Using a wand of strength 12<br/>Wizard strikes the Grump Ork 3<br/>Using a wand of strength 7<br/>Wizard strikes the Grump Ork 3<br/>Using a wand of strength 13<br/>Wizard strikes the Grump Ork 3<br/>Using a wand of strength 0<br/>Grump Ork 3 strikes the Wizard<br/>Using a wand of strength 11<br/>Wizard strikes the Grump Ork 3<br/>Grump Ork 3 is dead, killed by the Wizard</span></pre><p id="8130" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数时候，玩家赢了；有时候，Ork会走运。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="0829" class="lc ld in ky b gy le lf l lg lh">Round 1<br/>Grump Ork strikes the Rogue<br/>Both missed<br/>Grump Ork strikes the Rogue<br/>Grump Ork strikes the Rogue<br/>Grump Ork strikes the Rogue<br/>Grump Ork strikes the Rogue<br/>Both missed<br/>Grump Ork strikes the Rogue<br/>Grump Ork strikes the Rogue<br/>Grump Ork strikes the Rogue<br/>Rogue strikes the Grump Ork<br/>Grump Ork strikes the Rogue<br/>Grump Ork strikes the Rogue<br/>Rogue is dead, killed by the Grump Ork</span></pre><p id="e71d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一节到此为止；下一次，我们将从制造迷宫的房间开始。</p><div class="lj lk gp gr ll lm"><a rel="noopener  ugc nofollow" target="_blank" href="/functional-javascript-writing-a-simple-command-line-game-335ab9fcc005"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd io gy z fp lr fr fs ls fu fw im bi translated">函数式JavaScript:编写简单的命令行游戏(第1部分)</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">使用JavaScript和功能对象模型，我们为Node.js创建了一个简单命令行游戏的第一部分。</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma jt lm"/></div></div></a></div><div class="lj lk gp gr ll lm"><a rel="noopener  ugc nofollow" target="_blank" href="/functional-javascript-classes-without-the-class-keyword-6e2de50a3698"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd io gy z fp lr fr fs ls fu fw im bi translated">函数式JavaScript:没有“class”关键字的类</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">了解如何在不使用class关键字的情况下使用函数式JavaScript来定义类。根据…中使用的样式</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lv l"><div class="mb l lx ly lz lv ma jt lm"/></div></div></a></div><p id="794e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="li">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>