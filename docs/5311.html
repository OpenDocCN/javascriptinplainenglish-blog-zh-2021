<html>
<head>
<title>What is Better: Preloading or Caching JavaScript Modules?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预加载和缓存JavaScript模块哪个更好？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-better-preloading-or-caching-javascript-modules-246d3573e6ad?source=collection_archive---------12-----------------------#2021-11-01">https://javascript.plainenglish.io/what-is-better-preloading-or-caching-javascript-modules-246d3573e6ad?source=collection_archive---------12-----------------------#2021-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c55c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对用户和开发者都更好。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f9c00854cf824579fe171054d694dd6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2KOtucyUfWwAPJFv5V3cw.png"/></div></div></figure><p id="738e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">捆绑对用户来说是好事，但对开发者来说却是噩梦。在开发过程中依赖bundlers特别烦人。不幸的是，捆绑并不总是可选的。比如不得不transpile的开发者，注定要捆绑。</p><p id="548b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模块的预加载和缓存是两种主要的技术，可以减轻开发人员对没有正当理由的捆绑器的使用。</p><p id="da0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://marian-caikovski.medium.com/javascript-modules-and-browser-cache-4050b72ec51c" rel="noopener">我之前描述了模块预加载的基本原理和显著效果。</a></p><p id="55ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://marian-caikovski.medium.com/javascript-modules-and-browser-cache-4050b72ec51c" rel="noopener">缓存模块甚至更有效，但是，应该适当地进行缓存，以便在发布新版本的web应用程序时可以轻松地更新缓存的模块。</a></p><h2 id="3a6e" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">如果模块预加载并缓存在自动刷新的最新缓存中，会发生什么情况？</h2><p id="0733" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">对于这个实验，我修改了在<a class="ae ln" href="https://marian-caikovski.medium.com/does-preloading-of-modules-make-sense-7c3ee9ccdd45" rel="noopener">上一篇关于预加载</a>的文章中描述的样本网页。</p><p id="e6bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，在基准测试期间，我测量了由255个模块组成的模块依赖树的加载时间。实验树是具有8个级别的完美二叉树，分别包含1、2、4、8、16、32、64和128个模块。在浏览器知道任何叶模块之前，它已经发出了7个顺序请求来加载它的7个父模块。这棵树纯粹是实验性的，而不是真实的。</p><p id="d26b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">整个模块树的加载时间在四种不同的设置中测量:</p><ul class=""><li id="c4cb" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">模块没有被预加载和缓存</li><li id="24e8" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">模块是预加载的，但不是缓存的</li><li id="6fe5" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">模块不会被预加载，而是被缓存到自动刷新缓存中</li><li id="35db" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">模块被预加载并缓存到自动刷新缓存中</li></ul><p id="bece" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在示例页面中，上面列出的四个条件由四行<code class="fe na nb nc nd b">iframes</code>表示。页面逐渐地，一个接一个地加载<code class="fe na nb nc nd b">iframe</code>s——一次只加载一个<code class="fe na nb nc nd b">iframe</code>。为了计算每个设置的代表性平均加载时间，十个<code class="fe na nb nc nd b">iframe</code>被加载到每行中。</p><p id="f367" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由不同种类的<code class="fe na nb nc nd b">iframe</code>加载的模块仅仅在它们的响应头上有所不同。不应该被缓存的模块用<code class="fe na nb nc nd b">Cache-control: no-store, max-age=0</code>服务，而被缓存的模块用<code class="fe na nb nc nd b">Cache-Control: stale-while-revalidate=604800</code>服务。</p><h2 id="6130" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">结果</h2><p id="62b3" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">你可以在样本页面<a class="ae ln" href="https://preloadandcache.onrender.com/" rel="noopener ugc nofollow" target="_blank">https://preloadandcache.onrender.com/</a>看到结果</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/ea60f9b4abe441270c1aab7cf700c07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgOWti7VDok2f7MJwCPh-A.png"/></div></div></figure><p id="362c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，缓存的模块存储在自动刷新的缓存中。我认为这是一个非常酷的模块友好特性。看看当我稍微改变所有四个<em class="nf"> module1.js </em>中的代码，使它们的输出明显改变时会发生什么。使用更新后的代码，每个<code class="fe na nb nc nd b">iframe</code>将显示毫秒，后跟一个星号:</p><pre class="kg kh ki kj gt ng nd nh ni aw nj bi"><span id="03f4" class="lo lp iq nd b gy nk nl l nm nn">import val2 from './module2.js';<br/>import val3 from './module3.js';</span><span id="c81f" class="lo lp iq nd b gy no nl l nm nn">const total=Date.now()-t0;<br/> document.querySelector('div').replaceChildren(total<strong class="nd ir">+"*"</strong> );<br/> <br/>window.parent.postMessage(total,"*");<br/>console.log(val2+val3);</span></pre><p id="0789" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你在上面提到的帖子中描述了代码，但在这里你不需要理解更多，在新版本的页面中，数字后面会跟着<strong class="kt ir"> * </strong>。所以我部署了页面的新版本，并在浏览器中重新加载它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/fa9ede63c23c310d8013e6451110f175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3iAq-dHGc69L2JyK9yVDA.png"/></div></div></figure><p id="0bfc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好看吗？缓存的模块由缓存提供，但是在提供模块之后，浏览器会向服务器检查所使用的模块是否是最新的。如果它过期，缓存将从服务器加载其最新版本。</p><h1 id="447e" class="nq lp iq bd lq nr ns nt lt nu nv nw lw jw nx jx lz jz ny ka mc kc nz kd mf oa bi translated">结论</h1><p id="b9d8" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">预加载模块大大减少了首次访问时的页面加载时间。如果模块被缓存，那么在以后访问页面时预加载它们只会稍微减少可以忽略的页面加载时间。</p><p id="c392" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我相信第一次访问可以看作是应用程序的安装，每个用户都知道这需要一些时间。如果应用程序没有用，快速的首次加载不会有太大帮助。然而，模块预加载很容易实现，即使是第一次页面加载也应该更快。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="4f7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例代码可以从<a class="ae ln" href="https://github.com/marianc000/preloadCache" rel="noopener ugc nofollow" target="_blank">https://github.com/marianc000/preloadCache</a>下载</p><p id="b839" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nf">更多内容请看</em><a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nf">plain English . io</em></strong></a></p></div></div>    
</body>
</html>