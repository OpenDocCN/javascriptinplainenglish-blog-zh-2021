<html>
<head>
<title>How does React render based on changes?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React如何基于变化进行渲染？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-does-react-render-based-on-changes-ec928486cf59?source=collection_archive---------6-----------------------#2021-08-21">https://javascript.plainenglish.io/how-does-react-render-based-on-changes-ec928486cf59?source=collection_archive---------6-----------------------#2021-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2f1a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React中每次渲染时是否检查所有道具？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a636056e24006d91c39810d7bc0144ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3mFQeSHOqN7rk8x_WonmA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React Profiler Figure</figcaption></figure><p id="985a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">先从一些常识说起。我们了解到，在决定渲染每个纤维之前，会检查所有道具。</p><blockquote class="lo lp lq"><p id="9483" class="ks kt lr ku b kv kw jo kx ky kz jr la ls lc ld le lt lg lh li lu lk ll lm ln ig bi translated">可以说纤程是树的一个组成部分或一个节点。在本文中，我们互换使用它们。</p></blockquote><p id="04ed" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这样对吗？抛开这一点，它真的没有告诉我们太多，前。它的起点和终点。它也没有告诉我们道具和状态之间的区别。</p><p id="0a53" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们用一个例子来说明这件事。在上图中，其中一个组件(第一个彩色块)的状态已经改变。它定义了这个组件，如下所示。</p><pre class="kd ke kf kg gt lv lw lx ly aw lz bi"><span id="ee31" class="ma mb in lw b gy mc md l me mf">const Title = () =&gt; {<br/>  const [count, dispatch] = useState(0)<br/>  const onClick = () =&gt; { dispatch(1) }</span><span id="f585" class="ma mb in lw b gy mg md l me mf">  return &lt;Child onClick={onClick} count={count /&gt;<br/>}</span></pre><p id="e472" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是一个非常简单的组件，它将一个<code class="fe mh mi mj lw b">state</code>传递给它的子组件。在某一点上，我们点击它，因此增加状态到一个新的值。让我们称这个纤程为动作开始的源纤程。</p><h2 id="165c" class="ma mb in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">在到达源光纤之前</h2><p id="8e1a" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">让我们写一些伪代码来看看这是如何工作的。为了方便起见，我们将光纤分成两个阵营，一个是到达源光纤之前的光纤，一个是源光纤之下的光纤。</p><p id="8f08" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当React收到一个更新请求时，它从树的最顶端开始遍历。在到达源纤程之前，沿途的每个纤程都通过克隆前一场景中的纤程来保释，如以下伪代码所示。</p><pre class="kd ke kf kg gt lv lw lx ly aw lz bi"><span id="a1fb" class="ma mb in lw b gy mc md l me mf">function beginWork(fiber) {<br/>  if (!anyWorkOnFiber) {<br/>    return bailoutOnAlreadyFinishedWork(fiber)<br/>  }<br/>}</span></pre><p id="9aaf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在我们的侧写图中，深灰色表示紧急援助。这些纤维代表了在儿童中没有工作但包含一些工作的纤维。React标记它们，以便它知道如何到达源纤维。紧急救援通过重用以前协调的子对象跳过渲染。</p><p id="2382" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">同样的紧急情况也适用于剖面图中的浅灰色点状颜色。那些纤程代表不在源纤程的祖先分支中的纤程。所以他们没有任何工作，也没有任何工作在它的任何一个孩子身上。</p><h2 id="99c5" class="ma mb in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated"><strong class="ak">下源光纤</strong></h2><p id="c006" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">好了，现在我们到了源光纤。因为这个纤维有工作要做，它需要一个新的渲染。</p><pre class="kd ke kf kg gt lv lw lx ly aw lz bi"><span id="eabf" class="ma mb in lw b gy mc md l me mf">function beginWork(fiber) {<br/>  let didReceiveUpdate</span><span id="9dfb" class="ma mb in lw b gy mg md l me mf">  const children = renderFiber(fiber) </span><span id="5ddc" class="ma mb in lw b gy mg md l me mf">  if (!didReceiveUpdate) {<br/>    return bailoutOnAlreadyFinishedWork(fiber)<br/>  }</span><span id="a1df" class="ma mb in lw b gy mg md l me mf">  reconcileChildren(fiber, children)<br/>  return fiber.child<br/>}</span></pre><p id="8aa0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果它是一个功能组件，它调用函数并返回被调和成纤程的子元素。在所有子纤维准备好之后，它返回第一个子纤维以继续渲染工作。这基本上就是<code class="fe mh mi mj lw b">beginWork</code>所做的。</p><p id="ec68" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在渲染之前创建了一个标志<code class="fe mh mi mj lw b">didReceiveUpdate</code>，它最初是假的，在渲染过程中，如果检测到状态变化，任何钩子都可以把它改成<code class="fe mh mi mj lw b">true</code>。渲染之后，如果这个标志仍然是假的，那么我们知道在这个纤程中没有任何改变。因此它可以在渲染后被保释出来。无论有没有紧急援助，渲染都需要按照Profiler图中的颜色块所示进行。</p><h2 id="e0ba" class="ma mb in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">渲染从源纤维开始</h2><p id="5e78" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">所以我们有两个版本的<code class="fe mh mi mj lw b">beginWork</code>用于纤程，在源纤程之前和之下。React如何在两者之间切换？当然，React实际上有许多其他途径，但本文试图将其过度简化，这样我们至少可以理解主要途径。</p><pre class="kd ke kf kg gt lv lw lx ly aw lz bi"><span id="9d70" class="ma mb in lw b gy mc md l me mf">function beginWork(fiber) {<br/>  let didReceiveUpdate</span><span id="2862" class="ma mb in lw b gy mg md l me mf">  if (oldProps !== newProps) {<br/>    didReceiveUpdate = true<br/>    beginWorkBeforeSourceFiber()<br/>  } else {<br/>    beginWorkUnderSourceFiber()<br/>  }<br/>  ...<br/>}</span></pre><p id="fc87" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在<code class="fe mh mi mj lw b">beginWork</code>开始的时候，它检查了这个纤维在前一个和当前之间的道具。如果它改变了，它实际上认为纤维在源纤维下面？哇！？注意严格的等号运算符<code class="fe mh mi mj lw b">!==</code>。它不是检查里面的每个道具，而是检查整个道具对象。</p><p id="b68e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这一行翻译过来就是<strong class="ku io">如果一个父元素被渲染，一个子元素会得到一个新的道具，因此它也需要被渲染</strong>。</p><p id="5b1b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当一个子体被调和成一个纤程时，它创建一个带有<code class="fe mh mi mj lw b">newProps</code>的纤程。只要一个父渲染，它就进入所有子和孙的新道具和新渲染的政权。有可能打破这种制度的是一个子纤维与<code class="fe mh mi mj lw b">didReceiveUpdate</code>渲染后为假。</p><h2 id="69bd" class="ma mb in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">道具是被动的东西</h2><p id="d0e6" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">道具真的是一个被动的东西，就像一个函数的参数一样。它总是和组件在一起。如果它不是一个渲染，假设至少有一个道具是从状态变化中派生出来的(或与状态变化相关联)，它就不能为它的子对象获得新的道具。</p><p id="f603" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果一个组件没有被渲染，道具永远不会被更新以反馈给子组件，因此道具本身在理论上不能作为一个原因进行改变。更有趣的是，整个道具(而不是道具内部的每个单独的道具)用于检查是否应该执行渲染。</p><p id="9c08" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以状态和道具有点鸡和蛋的关系。这么说吧，</p><pre class="kd ke kf kg gt lv lw lx ly aw lz bi"><span id="0f66" class="ma mb in lw b gy mc md l me mf">React.render(&lt;App /&gt;, ...)</span></pre><p id="5336" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">也许只有当我们第一次调用渲染时，props才会变得活跃，但是在前面的代码中，我们倾向于为props放置<code class="fe mh mi mj lw b">{}</code>。因此大多数时候道具根本不是驱动新渲染的力量。</p><p id="7591" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">那么为什么有时我们说我们可以跳过不变道具的渲染呢？也许“跳过”的意思也不是主动时态，它只是意味着道具可以从一些渲染中过滤掉，比如在<code class="fe mh mi mj lw b">React.memo</code>的例子中。</p><h2 id="0dc8" class="ma mb in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">结论</h2><p id="722e" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">在状态改变时，道具被用来通过新的渲染发送更深层次的信息。然而，是否对纤维执行新的渲染是由该状态改变而不是任何单独的属性改变来确定的。</p><p id="109f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lr">更多内容请看</em><a class="ae ng" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>