<html>
<head>
<title>A beginner’s guide to Arrays in JavaScript (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数组入门指南(第2部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-beginners-guide-to-arrays-in-javascript-part-2-4fe0665bd2a3?source=collection_archive---------15-----------------------#2021-01-27">https://javascript.plainenglish.io/a-beginners-guide-to-arrays-in-javascript-part-2-4fe0665bd2a3?source=collection_archive---------15-----------------------#2021-01-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b2e9573a55be479627286e512f0c91b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffn_8KUwJzhcDuQP5a4oow.jpeg"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="73c3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><em class="la">如果你还没看完第一部分，点击</em> <a class="ae lb" href="https://medium.com/javascript-in-plain-english/array-data-type-and-array-methods-in-javascript-50a29af0c49b" rel="noopener"> <em class="la"> </em> <strong class="ke io"> <em class="la">这里</em> </strong> </a> <em class="la">。</em></p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="941a" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated">6。的方法。pop() </h2><p id="1a31" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated"><code class="fe ma mb mc md b">pop()</code>方法从数组中移除最后一个元素并返回该元素。此方法更改数组的长度。语法:<code class="fe ma mb mc md b"> <strong class="ke io">arr.pop()</strong></code>。如果你在一个空数组上调用<code class="fe ma mb mc md b">pop()</code>，它会返回<code class="fe ma mb mc md b">undefined</code>。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/f82ed39b1afa1286f34b1fd06f633697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wy7SfpVScqUOJrAyepJo4A.png"/></div></div></figure><p id="e705" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的产出:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/f50597c7105e5955aa43b656b354f1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nHxnRirz6n9FcMjPVLskg.png"/></div></div></figure><p id="6cd8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果我们像你上面看到的那样写代码，那么从数组中删除的最后一个值将会显示在屏幕上。如果要在删除屏幕上的最后一个元素后打印数组:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/07d15a86a408bfd6fbae7e2ec5394528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmE5TpmkPiJUHowyMUB6GA.png"/></div></div></figure><p id="47b8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/a5a860374ae8fbdea11b65323953bc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2GJAkcJC9x629GtA9MTVQ.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="da41" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated"><strong class="ak"> 7。的方法。unshift() </strong></h2><p id="9e60" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated"><code class="fe ma mb mc md b">unshift()</code>方法将一个或多个元素添加到数组的开头，并返回数组的新长度。语法:<code class="fe ma mb mc md b">arr.unshift(element1[, ...[, elementN]])</code></p><p id="020e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">虽然这个方法类似于<code class="fe ma mb mc md b"> push () </code>方法，唯一的区别是用<code class="fe ma mb mc md b">.unshift ()</code>方法添加到数组的值替换了数组的第一个元素，其他元素的索引向右移动一个单位。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/1d859be300fa9db641adfd59ea7fc25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FdhWe6yCjTsD__Cp4t8Ew.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Before adding an element to the Array with the .unshift () method:</figcaption></figure><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/c9126fc8b10d0d1bcffa2ceb4d8df81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtRNwXZpHbiGwui4yMoZUw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">After adding an element to the Array with the .unshift () method:</figcaption></figure><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/2e05264bfa0fee50f8449dda5678e79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4VizdvTK0TPyg7C7fmqsw.png"/></div></div></figure><p id="3bf8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/d41ce3b36d55051a36d4cf308613b646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPoBcSKosg9EO7wq28Mnfw.png"/></div></div></figure><p id="e9aa" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><em class="la">如你所见，如果我们这样写代码，它会在元素添加到数组后打印出数组中元素的个数。如果我们想打印数组本身，那么:</em></p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/cf768260743b7ab3b47b500909c40a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehG8P8X1WdLGhfV6r2JjUQ.png"/></div></div></figure><p id="04a6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/30979fec948e97f625d001c838ad6edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQZoRfxPoVwWkrfJlfH8cw.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="b1ba" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated"><strong class="ak"> 8。的方法。shift() </strong></h2><p id="4f19" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated">方法从数组中移除元素并返回移除的元素。此方法更改数组的长度。语法:<code class="fe ma mb mc md b"><strong class="ke io">arr.shift()</strong></code></p><p id="87ab" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe ma mb mc md b">shift()</code>方法移除第0个索引处的元素，并将连续索引处的值下移，然后返回移除的值。如果<code class="fe ma mb mc md b">length</code>属性为0，则返回<code class="fe ma mb mc md b">undefined</code>。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/1f5b7d3c98b0c426a2cd31f6718e0ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2Cc9HMkQBvkCdNWDdyFGA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">before the shift () method</figcaption></figure><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/f84cd16bbe1d3428dc6bc4faff068a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IsJtmdStlG9k8F8qWrHbcA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">after the shift() method</figcaption></figure><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/e15d7d95121f79aa6f76e5315fc62540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmJZbMo1l1i41fkjiLFyvQ.png"/></div></div></figure><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/79a2842f4f7477b1af3240cdad9a0d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRCrkFuLplBW5B7CBCiqIA.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="5652" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated"><strong class="ak"> 9。的方法。slice() </strong></h2><p id="75b1" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated"><code class="fe ma mb mc md b">slice() </code>方法返回一个数组中选中的元素，作为一个新的数组对象。<code class="fe ma mb mc md b">slice() </code>方法选择从给定的开始参数开始的元素，并在给定的结束参数结束，但不包括给定的结束参数。<br/> <strong class="ke io">注:</strong>原数组不会改变。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/addc1e226eece2fb8729e2841ea84bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZgokmuM7052bmUkATOyeQ.png"/></div></div></figure><p id="b69a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/3ff1092fb7cbdaead314101513804afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1M2QH5bYBgmNBtAAhBaQw.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="a3ec" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated">10。的方法。拼接()</h2><p id="9ca0" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated">方法的作用是:在数组中添加/删除条目，并返回被删除的条目。语法:</p><p id="513a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe ma mb mc md b">let arrDeletedItems = arr.splice(start[, deleteCount[, item1[, item2[, ...]]]])</code></p><p id="6973" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe ma mb mc md b"><strong class="ke io">start</strong></code>开始改变数组的索引。</p><p id="a207" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果大于数组的长度，<code class="fe ma mb mc md b"><strong class="ke io">start</strong></code>将被设置为数组的长度。在这种情况下，不会删除任何元素，但是该方法将作为一个添加函数，添加与item[n*]所提供的一样多的元素。</p><p id="5e4a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果是负数，它将从数组的末尾开始计算。(在这种情况下，原点<code class="fe ma mb mc md b"><strong class="ke io">-1</strong></code>，意为<code class="fe ma mb mc md b"><strong class="ke io">-n</strong></code>是第<code class="fe ma mb mc md b">n</code>个最后元素的索引，因此等同于<code class="fe ma mb mc md b"><strong class="ke io">array.length - n</strong></code>的索引。)如果<code class="fe ma mb mc md b"><strong class="ke io">array.length + start</strong></code>小于<code class="fe ma mb mc md b"><strong class="ke io">0</strong></code>，将从索引<code class="fe ma mb mc md b"><strong class="ke io">0</strong></code>开始。</p><p id="4386" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe ma mb mc md b"><strong class="ke io">deleteCount</strong></code>可选一个整数，表示数组中要从<code class="fe ma mb mc md b"><strong class="ke io">start</strong></code>中移除的元素个数。如果省略<code class="fe ma mb mc md b"><strong class="ke io">deleteCount</strong></code>，或者其值等于或大于<code class="fe ma mb mc md b"><strong class="ke io">array.length - start</strong></code>(即等于或大于数组中剩余的元素数，从<code class="fe ma mb mc md b"><strong class="ke io">start</strong></code>开始)，那么从<code class="fe ma mb mc md b"><strong class="ke io">start</strong></code>到数组末尾的所有元素都将被删除。</p><p id="f352" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果<code class="fe ma mb mc md b"><strong class="ke io">deleteCount</strong></code>为<code class="fe ma mb mc md b"><strong class="ke io">0</strong></code>或<code class="fe ma mb mc md b"><strong class="ke io">negative</strong></code>，则不移除任何元素。在这种情况下，您应该至少指定一个新元素。</p><p id="92e7" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">从<code class="fe ma mb mc md b">start</code>开始，可选要添加到数组中的元素。如果不指定任何元素，<code class="fe ma mb mc md b">splice()</code>只会从数组中删除元素。</p><p id="7c68" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io">注意:</strong>这个方法改变了原来的数组。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/0d60402d7f6e835c50e8cdd457e842bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DoMxonupQpfsE9DQLMxmGg.png"/></div></div></figure><p id="605b" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/7bda86580059fba15193a875fff8dab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-qNXUbcaH064fSlkXJnkA.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="0933" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated"><strong class="ak"> 11。的方法。反向()</strong></h2><p id="ac06" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated"><code class="fe ma mb mc md b">reverse()</code>方法在适当的位置反转数组。第一个数组元素成为<code class="fe ma mb mc md b"><strong class="ke io">last</strong></code>，最后一个数组元素成为<code class="fe ma mb mc md b"><strong class="ke io">first</strong></code>。<code class="fe ma mb mc md b">reverse()</code>方法就地转置调用数组对象的元素，改变数组，并返回对数组的引用。<code class="fe ma mb mc md b">reverse()</code>是有意仿制的；此方法可被调用或应用于类似数组的对象。不包含反映一系列连续的、从零开始的数字属性中的最后一个属性的长度属性的对象可能不会以任何有意义的方式表现。</p><p id="000c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">语法:<code class="fe ma mb mc md b"><strong class="ke io">arr.reverse()</strong></code></p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/71fdb47e781bff084b900f1dab9c3c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZ77i4LB25zc96zRQzEviQ.png"/></div></div></figure><p id="e1a3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/cf5ff1da9b398b1a0214f2a7a356d7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDghRn2XHpgw9dwaRPjkoQ.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="7267" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated"><strong class="ak"> 12。的方法。concat() </strong></h2><p id="11d4" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated">方法用于合并两个或更多的数组。此方法不更改现有数组，而是返回一个新数组。语法是:<code class="fe ma mb mc md b"><strong class="ke io">const new_array = old_array.concat([value1[, value2[, …[, valueN]]]])</strong></code></p><p id="524a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe ma mb mc md b">concat()</code>方法创建一个新的数组，由调用它的对象中的元素组成，对于每个参数，依次是该参数的元素(如果参数是数组)或参数本身(如果参数不是数组)。它不会递归到嵌套数组参数中。</p><p id="56df" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe ma mb mc md b">concat()</code>方法不会改变这个数组或任何作为参数提供的数组，而是返回一个浅层副本，其中包含从原始数组组合而来的相同元素的副本。原始数组的元素被复制到新数组中，如下所示:</p><ol class=""><li id="bb55" class="mw mx in ke b kf kg kj kk kn my kr mz kv na kz nb nc nd ne bi translated">对象引用(而不是实际的对象):concat将对象引用复制到新数组中。原始数组和新数组都引用同一个对象。也就是说，如果修改了被引用的对象，这些更改对新数组和原始数组都是可见的。这包括也是数组的数组参数元素。</li><li id="5ee7" class="mw mx in ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">数据类型，如字符串、数字和布尔(不是字符串、数字和布尔对象):concat将字符串和数字的值复制到新数组中。</li></ol><p id="5308" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io">注意:</strong>连接数组/值将保持原始值不变。此外，对新数组的任何操作(除了对作为对象引用的元素的操作)都不会对原始数组产生影响，反之亦然。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/757b55c1acc39b6869ef45ad85063e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPLHS88WsE68kadp8kwUXg.png"/></div></div></figure><p id="b79b" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/4fb1024eaa7534a45601f104810069c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sc8gDlKfSZhry2LJ7rYI5w.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/facd505b76392c3350dcd0e26a4365cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_bHB4YpdtcEEn5R55m0rQ.png"/></div></div></figure><p id="87e5" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/c9a8be439a05da592de1de9ffac4d789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3L1t-OAUEK9CoHy2LPHeA.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="c7f2" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated"><strong class="ak"> 13。的方法。sort() </strong></h2><p id="f6b0" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated">方法对数组中的元素进行排序，并返回排序后的数组。默认的排序顺序是升序，建立在将元素转换成字符串，然后比较它们的<code class="fe ma mb mc md b"><strong class="ke io"> UTF-16</strong></code>代码单元值序列的基础上。排序的时间和空间复杂度无法保证，因为它取决于实现。语法:<code class="fe ma mb mc md b"><strong class="ke io"> arr.sort([compareFunction])</strong></code></p><p id="6ac2" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果没有提供compareFunction，所有非未定义的数组元素将被转换为字符串并按照<code class="fe ma mb mc md b">UTF-16</code>代码单元的顺序比较字符串。例如，<code class="fe ma mb mc md b">“banana”</code>在<code class="fe ma mb mc md b">“cherry”</code>之前。在数字排序中，<code class="fe ma mb mc md b">9</code>在<code class="fe ma mb mc md b">80</code>之前，但是因为数字被转换为字符串，所以按照Unicode顺序，<code class="fe ma mb mc md b">“80”</code>在<code class="fe ma mb mc md b">“9”</code>之前。所有未定义的元素都被排序到数组的末尾。如果提供了<code class="fe ma mb mc md b">compareFunction</code>，则所有非未定义的数组元素都按照比较函数的返回值排序(所有未定义的元素都排序到数组的末尾，不调用<code class="fe ma mb mc md b">compareFunction</code>)。如果a和b是被比较的两个元素，那么:</p><ol class=""><li id="6656" class="mw mx in ke b kf kg kj kk kn my kr mz kv na kz nb nc nd ne bi translated">如果<code class="fe ma mb mc md b">compareFunction(a, b) </code>返回的值小于<code class="fe ma mb mc md b">0</code>，则将a排序到比b低的索引(即a先出现)。</li><li id="56dc" class="mw mx in ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">如果<code class="fe ma mb mc md b">compareFunction(a, b)</code>返回<code class="fe ma mb mc md b">0</code>，则a和b相对于彼此保持不变，但是相对于所有不同的元素进行排序。</li><li id="9b20" class="mw mx in ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">如果<code class="fe ma mb mc md b">compareFunction(a, b)</code>返回大于<code class="fe ma mb mc md b">0</code>的值，则将b排序到低于a的索引(即b先出现)。</li><li id="94d5" class="mw mx in ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated"><code class="fe ma mb mc md b">compareFunction(a, b)</code>当给定一对特定的元素a和b作为其两个参数时，必须始终返回相同的值。如果返回不一致的结果，则排序顺序是未定义的。</li></ol><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/0ee2f3a62860d0aaa6da5c3498e21e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7MzZFjOS9Rq5X2_ykomxQ.png"/></div></div></figure><p id="f397" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/55285abe5eb05e968e17cb45a71b47f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnqWYQ4Rs0dP8FHm3zbS5A.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/4f95430e07c7823704aff9ab575668f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1fIwMuNi45v7LK9WyCy6g.png"/></div></div></figure><p id="98dc" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/b3a95f3e825648c673511ab0400e0fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oe2QdZE04QyhVgA6fX8N8A.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/5c34281f64ba2f19176d16e50de43658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPRMWHaYlA8GLEu3y7SsFw.png"/></div></div></figure><p id="a1f9" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/a782e9e17f37354dfff7bada5c6c1724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSuP6Gei7T7idan7aI-8jw.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="8199" class="lc ld in bd le lf lg dn lh li lj dp lk kn ll lm ln kr lo lp lq kv lr ls lt lu bi translated">14。的方法。查找()</h2><p id="001e" class="pw-post-body-paragraph kc kd in ke b kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ig bi translated"><code class="fe ma mb mc md b">find()</code>方法返回满足测试函数的数组中第一个元素的值。如果<code class="fe ma mb mc md b">no values</code>满足测试函数，则返回<code class="fe ma mb mc md b">undefined</code>。</p><ol class=""><li id="a8ca" class="mw mx in ke b kf kg kj kk kn my kr mz kv na kz nb nc nd ne bi translated">如果你需要在数组中找到的元素的索引，使用<code class="fe ma mb mc md b"> findIndex()</code>。</li><li id="f61f" class="mw mx in ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">如果你需要找到一个值的索引，使用<code class="fe ma mb mc md b">.indexOf()</code>。(它类似于<code class="fe ma mb mc md b">findIndex()</code>，但是检查每个元素是否与值相等，而不是使用测试函数。)</li><li id="f810" class="mw mx in ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">如果你需要发现一个值是否存在于一个数组中，使用<code class="fe ma mb mc md b">.includes()</code>。同样，它检查每个元素是否与值相等，而不是使用测试函数。</li><li id="f39b" class="mw mx in ke b kf nf kj ng kn nh kr ni kv nj kz nb nc nd ne bi translated">如果您需要查找是否有任何元素满足提供的测试函数，请使用<code class="fe ma mb mc md b">.some()</code>。<br/>语法:<code class="fe ma mb mc md b"><strong class="ke io"> arr.find(callback(element[, index[, array]])[, thisArg])</strong></code><br/><br/><code class="fe ma mb mc md b">.find()</code>方法对数组的每个索引执行一次<code class="fe ma mb mc md b"><strong class="ke io">callback function</strong></code>，直到回调返回一个真值。如果是这样，find会立即返回该元素的值。否则，find返回undefined。<br/> <br/> <code class="fe ma mb mc md b">callback</code>为数组的每个索引调用，而不仅仅是那些赋值的索引。这意味着与只访问赋值的方法相比，它对于稀疏数组可能效率较低。<br/> <br/>如果提供了一个<code class="fe ma mb mc md b">thisArg</code>参数用于查找，它将在每次回调调用中用作this值。如果没有提供，则使用undefined。<br/><br/><code class="fe ma mb mc md b">.find()</code>方法不会改变调用它的数组，但是提供给回调函数可以。如果是这样，find处理的元素将在第一次调用callback之前设置。因此:</li></ol><p id="de7c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">1) <code class="fe ma mb mc md b"> callback</code>在调用find开始后不会访问任何添加到数组中的元素。<br/> 2)如果<code class="fe ma mb mc md b">callback</code>改变了数组中一个现有的尚未被访问的元素，则传递给<code class="fe ma mb mc md b">callback</code>的值将是find访问该元素索引时的值。被删除的元素仍然被访问。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/f8a8b1c847d559f4a6fd9a7dcf4bdf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuNGIMbYVAM5JRF2-qLYZA.png"/></div></div></figure><p id="d34d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的输出是:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/65dc03bb2153708a6786130b8ab6d785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7G0KW8nAl74eX38bXRNnA.png"/></div></div></figure></div></div>    
</body>
</html>