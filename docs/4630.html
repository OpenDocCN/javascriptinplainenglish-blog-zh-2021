<html>
<head>
<title>What is NGXS and How to Use it in Angular?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGXS是什么，如何在Angular中使用？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-ngxs-and-how-to-use-it-in-angular-f975f5cfac40?source=collection_archive---------5-----------------------#2021-09-15">https://javascript.plainenglish.io/what-is-ngxs-and-how-to-use-it-in-angular-f975f5cfac40?source=collection_archive---------5-----------------------#2021-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/36e51c3fd89f9917bc768c8394ace74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a85a_qHcaLvGdEfx"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="ka kb kc"><p id="0ec7" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">任何现代的web应用程序都需要一种现代的方式来处理反应式编程的挑战。在本指南中，我们将看看NGXS如何帮助您实现这一点。</p></blockquote><p id="758b" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">现在，您已经准备好了web应用程序，您开始觉得有一种方法可以更好地处理反应式编程问题。好消息是，有一种东西可以解决这个问题，那就是NGXS。</p><p id="2379" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">但是，你可能想知道NGXS是什么。简单地说，它是一个库，使您的应用程序能够以一种可预测的方式拥有一个真实的来源。</p><p id="f3dd" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">因此，本教程的第一部分将介绍什么是NGXS，第二部分将展示在角度状态管理时使用它所需的移动部件。</p><p id="728c" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">最后，我们将看看如何将Angular NGXS添加到您的Angular应用程序中，以及如何使用它来更新您的应用程序。</p><h2 id="0dd5" class="lf lg in bd lh li lj dn lk ll lm dp ln lc lo lp lq ld lr ls lt le lu lv lw lx bi translated">NGXS是什么？</h2><p id="e7f2" class="pw-post-body-paragraph kd ke in kg b kh ly kj kk kl lz kn ko lc ma kr ks ld mb kv kw le mc kz la lb ig bi translated">如上所述，它是一个角度状态管理库。好吧，这是正确的，但它是什么？好吧，要理解它是什么，最好是理解是什么让它滴答作响，就像，什么是运动的部分。</p><p id="eecc" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">定义ngx有三个核心部分:</p><ul class=""><li id="163a" class="md me in kg b kh ki kl km lc mf ld mg le mh lb mi mj mk ml bi translated">状态。</li><li id="342a" class="md me in kg b kh mm kl mn lc mo ld mp le mq lb mi mj mk ml bi translated">模型。</li><li id="629c" class="md me in kg b kh mm kl mn lc mo ld mp le mq lb mi mj mk ml bi translated">行动。</li></ul><p id="b251" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">嗯，我知道如果你使用过其他的状态管理库，比如NgRx，你一定想知道为什么我们没有选择器和缩减器。简单地说，NGXS比NgRx有更少的样板文件。</p><h2 id="63b0" class="lf lg in bd lh li lj dn lk ll lm dp ln lc lo lp lq ld lr ls lt le lu lv lw lx bi translated">NGXS的活动部件。</h2><p id="372c" class="pw-post-body-paragraph kd ke in kg b kh ly kj kk kl lz kn ko lc ma kr ks ld mb kv kw le mc kz la lb ig bi translated">因此，有了核心部分，接下来的事情是了解它们实际上是什么。</p><p id="7c5f" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="kg io">状态</strong></p><p id="55ed" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">是的，你猜对了，这定义了你的web应用程序的当前地位。它包含了应用程序可用的最新更新，因此也保持了用户界面的同步。</p><p id="3205" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">另一个<strong class="kg io">重要的</strong>区别是<strong class="kg io">不像NGXS </strong>那样，我们有单独的减速器用于创建下一个状态，而<strong class="kg io">有角度的NGXS </strong>，下一个状态实际上是在状态本身内创建的！</p><p id="db8e" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">好吧，这可能是一个很大的接受，但不要担心，我们将在底部看到一个例子。</p><p id="8b93" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="kg io">型号</strong></p><p id="844c" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这只是你的商店看起来像什么的一个简单定义。</p><p id="6033" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="kg io">动作</strong></p><p id="10fc" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">嗯，似乎在ngxs和ngrx中，动作都是不变的特性。正如您可能已经猜到的那样，动作决定了应用程序中紧接着需要做什么<strong class="kg io">。</strong></p><p id="621e" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">当然，一次可能会发生多个动作，例如，您有Websockets。现在，为了区分这些动作，每个动作都以一种独特的方式定义，正如您将在提供的示例中看到的那样。</p><h2 id="7817" class="lf lg in bd lh li lj dn lk ll lm dp ln lc lo lp lq ld lr ls lt le lu lv lw lx bi translated">所以现在剩下的就是如何使用NGXS了。</h2><p id="516c" class="pw-post-body-paragraph kd ke in kg b kh ly kj kk kl lz kn ko lc ma kr ks ld mb kv kw le mc kz la lb ig bi translated">我们将使用一个假设的应用程序，例如从spotify这样的地方获取艺术家。然后我们的组件将完全由Angular NGXS更新，因此不再依赖于<strong class="kg io"> rxjs observables </strong>等。</p><p id="7eb9" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="kg io">第一步</strong></p><p id="fb2c" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我们将创建一个模型文件和一个接口文件。这些接口将定义我们的数据属性的外观。至于模型文件，我们将只有模型定义。</p><p id="71d8" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">定义接口:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5903" class="lf lg in mw b gy na nb l nc nd">export interface IArtist {<br/>  image: string;<br/>  name: string;<br/>  genres: Array;<br/>  albums: Array;<br/>  uuid: string;<br/>}</span></pre><p id="ab65" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">定义我们的角度NGXS模型:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c562" class="lf lg in mw b gy na nb l nc nd">import { IArtist } from "./interfaces";<br/><br/>export interface ArtistsStateModel {<br/>    searchResults: Array;<br/>}</span></pre><p id="8629" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="kg io">第二步</strong></p><p id="989e" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我们将创建一个动作文件，并添加一个获取艺术家的动作。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="739d" class="lf lg in mw b gy na nb l nc nd">export namespace ArtistsActions {<br/>    export class SearchForArtist {<br/>        static readonly type = '[Artists] Search For Artist';<br/>        constructor (<br/>            public searchTerm: string<br/>        ) {}<br/>    }<br/>}</span></pre><p id="9b7c" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">所以，解释一下上面的代码:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="af0c" class="lf lg in mw b gy na nb l nc nd">export namespace ArtistsActions</span></pre><p id="7e1f" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在这里，我们命名空间这个动作文件，并包装我们所有的动作，所以我们只是作为一个单元导入命名空间的名称，而不是导入单个的动作。这减少了出错的可能性，并使代码看起来更整洁。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ceb8" class="lf lg in mw b gy na nb l nc nd">static readonly type</span></pre><p id="b8a9" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这一行将定义我们操作的名称。你可以把它想象成你希望应用程序如何识别你的动作。</p><p id="62fc" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这个名字可以是你想要的任何名字，但是最好是这样的:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="bc22" class="lf lg in mw b gy na nb l nc nd">'[Component calling the action] Name of the action'</span></pre><p id="9e07" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">因为这将更容易排除故障。</p><p id="93f3" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">另一个重要部分是:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="84ea" class="lf lg in mw b gy na nb l nc nd">constructor (<br/>    public searchTerm: string<br/>) {}</span></pre><p id="2fe5" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">嗯，你猜对了。这是要传递给操作的参数。在这种情况下，我们传递的是searchTerm。但是如果您不需要这个NGXS操作来接收任何参数，那么它是可选的。</p><p id="9ca9" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="kg io">第三步</strong></p><p id="e917" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">现在，我们定义我们的角度NGXS状态，像这样:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="63db" class="lf lg in mw b gy na nb l nc nd">import { Injectable } from "@angular/core";<br/>import { Action, State, StateContext, StateToken } from "@ngxs/store";<br/>import { ArtistsActions } from "./actions";<br/>import { ArtistsStateModel } from "./model";<br/>import { produce } from 'immer';<br/>import { ApiService } from "../services/api.services";<br/>import { tap } from "rxjs/operators";<br/><br/>const ARTIST_STATE_TOKEN = new StateToken('artists');<br/><br/>@State({<br/>    name: ARTIST_STATE_TOKEN,<br/>    defaults: {<br/>        searchResults: []<br/>    }<br/>})<br/>@Injectable()<br/>export class ArtistsState {<br/>    constructor(<br/>        private apiService: ApiService<br/>    ) {}<br/><br/>    @Action(ArtistsActions.SearchForArtist)<br/>    searchForArtist(ctx: StateContext, action: ArtistsActions.SearchForArtist) {<br/>        return this.apiService.get('search', {q: action.searchTerm, type: 'artist'}).pipe(<br/>            tap(r =&gt; ctx.setState(produce(draft =&gt; {<br/>                draft.searchResults = r;<br/>            })))<br/>        )<br/>    }<br/>}</span></pre><p id="e11c" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">逐行破解这段代码:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e326" class="lf lg in mw b gy na nb l nc nd">const ARTIST_STATE_TOKEN = new StateToken('artists');</span></pre><p id="0ca7" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在这里，我们定义了如何在整体角度状态管理中识别整个应用状态的这个<strong class="kg io">片段</strong>。<strong class="kg io"> StateToken </strong>接受的类型是状态的模型定义，在本例中是<strong class="kg io">artiststatemodel</strong>，名称是状态的<strong class="kg io">片段</strong>的字符串标识。</p><p id="8800" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">下一部分是这样的:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6b86" class="lf lg in mw b gy na nb l nc nd">@State({<br/>    name: ARTIST_STATE_TOKEN,<br/>    defaults: {<br/>        searchResults: []<br/>    }<br/>})</span></pre><p id="6f87" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这只是简单地设置由我们的状态令牌标识的名称，以及初始状态(作为<strong class="kg io"> defaults </strong>传入)，它应该类似于模型定义。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e23b" class="lf lg in mw b gy na nb l nc nd">@Injectable()</span></pre><p id="2bf0" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">嗯，Angular NGXS状态是一种服务。这就是为什么我们使用<strong class="kg io">@ injectible()</strong>装饰器来定义它。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="de63" class="lf lg in mw b gy na nb l nc nd">constructor(<br/>    private apiService: ApiService<br/>) {}</span></pre><p id="0aef" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在这里，我们注入将要使用的服务，在我们的例子中，因为我们正在发出外部请求，所以我们添加了我们的ApiService。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4487" class="lf lg in mw b gy na nb l nc nd">@Action(ArtistsActions.SearchForArtist)</span></pre><p id="372e" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">还记得我们说过行动说明需要做什么吗，嗯，就是这样。这个<strong class="kg io"> @Action </strong>装饰器将接受一个它需要监听的动作参数，并在这样一个动作被<strong class="kg io">分派</strong>时执行。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="851c" class="lf lg in mw b gy na nb l nc nd">searchForArtist(ctx: StateContext, action: ArtistsActions.SearchForArtist) {<br/>    return this.apiService.get('search', {q: action.searchTerm, type: 'artist'}).pipe(<br/>        tap(r =&gt; ctx.setState(produce(draft =&gt; {<br/>            draft.searchResults = r;<br/>        })))<br/>    )<br/>}</span></pre><p id="89e5" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">所以，上面的方法是修饰类方法，它接受一个上下文(状态模型)和一个动作(修饰它的动作)。</p><p id="6199" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">请注意，我们正在将融入其中。这是因为我们需要调用api上的实际获取。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e260" class="lf lg in mw b gy na nb l nc nd">action.searchTerm</span></pre><p id="4e8e" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">记住这段代码，我们在我们的动作中定义了它，现在我们将像这样得到它。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9887" class="lf lg in mw b gy na nb l nc nd">tap(r =&gt; ctx.setState(produce(draft =&gt; {<br/>    draft.searchResults = r;<br/>})))</span></pre><p id="a77e" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这实际上是最重要的一点，因为这使得用新的结果更新状态成为可能。</p><p id="d14b" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我们有从<strong class="kg io"> immerjs </strong>导入的<strong class="kg io"> produce </strong>方法(这不在本教程范围内)。它的作用是可以更新当前状态的草稿版本，并返回它，这样<strong class="kg io">草稿的</strong>更新的<strong class="kg io">属性</strong>就可以映射到与之匹配的状态<strong class="kg io">属性</strong>上，从而更新状态。这是因为直接更新ngxs状态是不可取的。</p><p id="f6fd" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">因此，您可以看到<strong class="kg io"> tap </strong>给我们的内容，我们现在将它设置为我们想要更新的状态的属性。</p><p id="31f5" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="kg io">第四步</strong></p><p id="1821" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">现在，让我们定义我们的组件:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3294" class="lf lg in mw b gy na nb l nc nd">import { Component } from '@angular/core';<br/>import { IArtist } from "./interfaces";<br/>import { ArtistsActions } from './actions';<br/><br/>@Component({<br/>  moduleId: 'module.id',<br/>  selector: 'lib-artists',<br/>  templateUrl: 'artists.component.html',<br/>  styleUrls: [<br/>    'artists.component.scss'<br/>  ]<br/>})<br/>export class ArtistsComponent {<br/>  private searchResults$: Observable&gt; = new Observable&gt;();<br/><br/>  /**<br/>   * <br/>   */<br/>   public getSearchResults$(): Observable&gt; {<br/>    return this.searchResults$;<br/>  }<br/><br/>  constructor(<br/>    private store: Store<br/>  ) {<br/>    this.searchResults$ = this.store.select(state =&gt; state.artists.searchResults || of([]))<br/>  }<br/><br/>  /**<br/>   * <br/>   * @param searchTerm <br/>   */<br/>  public emitSearchEvent(searchTerm: string): void {<br/>    this.store.dispatch(new ArtistsActions.SearchForArtist(searchTerm));<br/>  }<br/>}</span></pre><p id="2490" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">上面的大部分代码都是简单的Angular，所以我们将重点放在与Angular状态管理相关的部分。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9ae2" class="lf lg in mw b gy na nb l nc nd">private searchResults$: Observable&gt; = new Observable&gt;();</span></pre><p id="a398" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这部分定义了我们可观察的搜索结果。结果将是一个艺术类型的列表。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4e1f" class="lf lg in mw b gy na nb l nc nd">/**<br/>* <br/>*/<br/>public getSearchResults$(): Observable&gt; {<br/>    return this.searchResults$;<br/>}</span></pre><p id="fd62" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这是一个getter方法，我们将在html中使用。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="37f1" class="lf lg in mw b gy na nb l nc nd">constructor(<br/>    private store: Store<br/>) {<br/>    this.searchResults$ = this.store.select(state =&gt; state.artists.searchResults || of([]));<br/>}</span></pre><p id="aea3" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我们需要定义存储，以便我们可以使用它的方法。第一种方法是<strong class="kg io">。选择</strong>方法，这将返回一个可观察到的最新搜索结果。注意，因为搜索结果可能是空的，所以我们使用操作符的<strong class="kg io"> RxJS返回一个空数组的初始可观察值。</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6281" class="lf lg in mw b gy na nb l nc nd">/**<br/> * <br/> * @param searchTerm <br/> */<br/>public emitSearchEvent(searchTerm: string): void {<br/>  this.store.dispatch(new ArtistsActions.SearchForArtist(searchTerm));<br/>}</span></pre><p id="751f" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这个方法将在用户搜索时监听，然后分派动作。</p><p id="b81a" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">第五步</p><p id="6150" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">最后，在我们的搜索组件html文件中，我们将添加以下内容:</p><p id="1ec0" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">因此，在这里，我们使用一个异步管道从我们的<strong class="kg io"> getSearchResults$() </strong>方法中读取最新发出的值。</p><h2 id="79db" class="lf lg in bd lh li lj dn lk ll lm dp ln lc lo lp lq ld lr ls lt le lu lv lw lx bi translated">结论</h2><p id="2ca3" class="pw-post-body-paragraph kd ke in kg b kh ly kj kk kl lz kn ko lc ma kr ks ld mb kv kw le mc kz la lb ig bi translated">如您所见，使用NGXS解决角度状态管理问题非常简单。</p><p id="070d" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">好了，现在就这样。</p><p id="af6b" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="kg io">快乐编码！</strong></p><blockquote class="ka kb kc"><p id="eb2c" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">有没有兴趣学习<strong class="kg io">国家管理</strong>？在我的网站上查看类似的精彩文章:<a class="ae jz" href="https://bingeoncode.com/category/state-management" rel="noopener ugc nofollow" target="_blank">沉迷于代码&gt;状态管理</a></p></blockquote></div></div>    
</body>
</html>