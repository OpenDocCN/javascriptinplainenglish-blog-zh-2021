<html>
<head>
<title>How to Create a Heap Data Structure in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中创建堆数据结构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/heap-heap-heap-d423320a4997?source=collection_archive---------8-----------------------#2021-02-27">https://javascript.plainenglish.io/heap-heap-heap-d423320a4997?source=collection_archive---------8-----------------------#2021-02-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2efd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎来到垃圾堆。堆有一个二叉查找树式的结构。每个父节点都有两个子节点，它们都源自一个根。可以通过两种方式对堆进行排序:</p><p id="3c5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">最大堆:</strong>最大堆的最大值将作为根，并且每个父节点的值总是大于其子节点。</p><p id="590a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">最小堆:</strong>最小堆的根节点值最小，每个父节点的值总是小于其子节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/593fe80dd5c36c3ab32b653a5ef4a6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*wlpbofdXeOTsTr8_uWpUlg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Max and Min Heap</figcaption></figure><p id="6865" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆在兄弟之间没有隐含的顺序。较大的一个可以是左子节点或右子节点，这并不重要。堆越紧凑越好。每个节点的所有子节点都已满，剩下的子节点先被填满。</p><h1 id="6186" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">实施</strong></h1><p id="8748" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在本文的其余部分，我们将重点讨论最大堆。我们可以使用数组来实现上面的最大堆。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="cb6d" class="mc kv in ly b gy md me l mf mg">[30,22,27,16,11,23,9]</span></pre><p id="d32d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到我们的根位于索引0，它的子节点位于索引1和2。我们如何知道哪些索引是索引1和2处节点的子节点？</p><p id="da6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于数组的任何第I个索引:</p><ul class=""><li id="d752" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">左子级存储在2 * i + 1索引中。</li><li id="d82a" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">右子级存储在2 * i + 2索引中。</li><li id="766c" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">对于索引I处的任何子节点，其父节点位于floor((i-1)/2)索引处。</li></ul><h1 id="b6a1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">插入</h1><p id="a299" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们将使用之前的堆，并尝试插入一个值为32的新节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/ea11f858d6c9992aeedd4eb3db08c61c.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*uihIjjjyZw1BlMFT3k2-5A.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Inserting a node</figcaption></figure><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="f823" class="mc kv in ly b gy md me l mf mg">[30,22,27,16,11,23,9,32]</span></pre><p id="ca10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的新节点被添加到数组的末尾。这与我们希望的节点位置相去甚远。该节点是整个阵列中最大的节点。我们可以使用泡沫技术将我们的新价值带到正确的地方。我们将32与其父节点16进行比较。我们看到32比16大得多，所以我们想交换两个节点的位置。我们的阵列现在看起来像:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="8aa6" class="mc kv in ly b gy md me l mf mg">[30,22,27,32,11,23,9,16]</span></pre><p id="8b64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们继续这种比较和交换我们的节点和父节点的模式，直到我们找到一个比我们的节点大的父节点。这个过程叫做<strong class="jm io">冒泡</strong>。我们的最终堆看起来像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ce8b01ed076a4d4a579fb732b14cfbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*9bcj2clQi7j-yPGX23fG0Q.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Organized Max Heap</figcaption></figure><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="e887" class="mc kv in ly b gy md me l mf mg">[32,30,27,22,11,23,9,16]</span></pre><p id="f288" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这在代码中是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="cf91" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">移除最大的元素</h1><p id="b1ca" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在最大堆中，最大的元素是根。我们必须向上移动整棵树来恢复我们的堆。让我们回到最初的最大堆:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3c3e8f6c24070fb19bacef59b4948e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*duY4LfiTasqAy_ZnxAETQA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Initial Max Heap</figcaption></figure><p id="00f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们取出根，并将其与堆中的最后一个值(最右边的节点)交换。9是新根。我们的新阵列看起来像:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="d901" class="mc kv in ly b gy md me l mf mg">[9,22,27,16,11,23]</span></pre><p id="6a10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们必须通过<strong class="jm io">冒泡</strong>来定顺序。我们将节点与左右子节点进行比较，看哪一个最大。9明显小于22和27。27是两者中较大的一个，所以我们想用9和27交换位置。该阵列现在看起来像:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="e77b" class="mc kv in ly b gy md me l mf mg">[27,22,9,16,11,23]</span></pre><p id="9962" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的9号节点还没就位。我们一直比较和交换我们的节点，直到它的子节点比它小。我们的最终堆看起来像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6e2f902a542296ed08812f7504e17d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*WykYr7Y2Y6WJPFr9YyU9GA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Organized Max Heap</figcaption></figure><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="c096" class="mc kv in ly b gy md me l mf mg">[27,22,23,16,11,9]</span></pre><p id="05f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这在代码中是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f52f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一些方法可以递归地重新组织堆，我的一些资源会用到这些方法。</p><h1 id="0550" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">大O</h1><p id="00dd" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">插入— O(对数N)</p><p id="3727" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">移除-O(log N)</p><p id="ca73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">搜索-O(N)</p><p id="c692" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下一篇文章中，我们将讨论优先级队列。优先级队列是堆最有用的实现之一。对于一个小的潜峰，优先级队列是一个数据结构，其中每个元素都有一个优先级。优先级较高的元素优先于优先级较低的元素。</p><h1 id="52cd" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">资源</h1><p id="c3b8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">关于堆的更多资源，我建议查看这些有用的链接。</p><p id="8ab7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="nb">酷显一堆:</em></strong><a class="ae nc" href="https://visualgo.net/en/heap" rel="noopener ugc nofollow" target="_blank">https://visualgo.net/en/heap</a></p><p id="cb99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae nc" href="https://medium.com/swlh/data-structures-heaps-b039868a521b" rel="noopener">https://medium.com/swlh/data-structures-heaps-b039868a521b</a></p><p id="9594" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae nc" href="https://medium.com/basecs/learning-to-love-heaps-cef2b273a238" rel="noopener">https://media . com/base cs/learning to love-heps-cef 2b 273 a 238</a></p><p id="f078" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae nc" href="https://medium.com/basecs/heapify-all-the-things-with-heap-sort-55ee1c93af82" rel="noopener">https://media . com/basecs/heap ify-with-heap-sort-55ee 1c 93 af82</a></p><p id="6343" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae nc" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/learn/lecture/8344810#overview" rel="noopener ugc nofollow" target="_blank">ude my . com/course/js-算法与数据结构-master class/lean/讲座/8344810 #概述</a></p></div></div>    
</body>
</html>