<html>
<head>
<title>Build a Card Memory Game with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React构建一个卡片记忆游戏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-card-memory-game-in-react-e6400b226b8f?source=collection_archive---------0-----------------------#2021-04-03">https://javascript.plainenglish.io/building-a-card-memory-game-in-react-e6400b226b8f?source=collection_archive---------0-----------------------#2021-04-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/7fdc0c53100604138ad9b3709c5e95bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfFCdF0GVcEMhIK9ESU-Bg.jpeg"/></div></div></figure><div class=""/><p id="3979" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们经常遇到小游戏，想知道它有多复杂？我们能建造它吗？我们通常不会超越它。然而在本帖中，我们将构建一个简单的记忆游戏，这个游戏很容易玩，也很容易开发。</p><p id="f1e2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">卡片记忆游戏是一个简单的测试玩家记忆力的游戏。在一副成对的牌中，玩家需要在连续的回合中选择一对匹配的牌。当所有匹配对都被选择时，玩家赢得游戏。</p><p id="39ae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个简单的用户界面可能是这样的:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi kt"><img src="../Images/bea5e8adab4ff5bc11af5ab6035161c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2h0p5Z46ryIHMI2OyZAb8g.png"/></div></div></figure><h2 id="12b6" class="ky kz iy bd la lb lc dn ld le lf dp lg kg lh li lj kk lk ll lm ko ln lo lp lq bi translated">让我们来确定游戏规则</h2><p id="106e" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">除非我们知道规则，否则我们无法制作游戏。所以让我们在这里陈述它们:</p><ul class=""><li id="d086" class="lw lx iy jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">我们需要一套洗牌的纸牌。我们这副牌中每张牌必须有一对。</li><li id="741c" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">游戏必须翻转玩家点击的牌。一次最多显示两张卡片。</li><li id="81d7" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">游戏将处理匹配和不匹配的卡片。不匹配的牌在短时间后会被翻回来。匹配的牌从这副牌中取出。</li><li id="fb02" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">每当玩家选择一对，游戏将增加当前移动计数</li><li id="729e" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">一旦所有配对都被找到，玩家会看到一个带有分数的确认对话框。</li><li id="0a97" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">游戏提供了重新启动的功能。</li></ul><h2 id="6c90" class="ky kz iy bd la lb lc dn ld le lf dp lg kg lh li lj kk lk ll lm ko ln lo lp lq bi translated">那么我们还在等什么呢...让我们开始吧。</h2><p id="d97d" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们首先定义我们的卡结构。对于卡片，我们创建一个具有类型属性和图像源的对象。</p><pre class="ku kv kw kx gt mk ml mm mn aw mo bi"><span id="a2b6" class="ky kz iy ml b gy mp mq l mr ms">{<br/>   type: 'Pickachu',<br/>   image: require('../images/Pickachu.png')<br/>}</span></pre><p id="6e9b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在下一步是洗牌。啊，是的，这是最重要的一步。如果我们不洗牌，这就不是真正的记忆游戏</p><h2 id="b195" class="ky kz iy bd la lb lc dn ld le lf dp lg kg lh li lj kk lk ll lm ko ln lo lp lq bi translated"><strong class="ak"> 1。洗牌</strong></h2><p id="dd4a" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我将使用<a class="ae mt" href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> Fisher-Yates洗牌算法</strong> </a>来洗牌，但我们可以使用任何给我们一个随机数组的算法或代码。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Fisher Yates shuffle algorithm to shuffle our card deck</figcaption></figure><h2 id="dabd" class="ky kz iy bd la lb lc dn ld le lf dp lg kg lh li lj kk lk ll lm ko ln lo lp lq bi translated">2.一副牌的渲染板</h2><p id="d4cb" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在本例中，我们使用了12张卡(6对)。洗牌后，我们将它们呈现为一个3x4的网格。你可以选择将你的卡片分成3组，每组4个物品，然后使用嵌套贴图或者CSS flexbox或者grid来渲染。我将使用CSS Grid来渲染它，因为用一维数组更容易处理更新。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Layout Component</figcaption></figure><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Grid container CSS</figcaption></figure><h2 id="3d9b" class="ky kz iy bd la lb lc dn ld le lf dp lg kg lh li lj kk lk ll lm ko ln lo lp lq bi translated">3.翻转卡片，评估匹配和计算移动</h2><p id="7eb8" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">下一步是为用户提供一个交互来翻牌并评估是否匹配。为此，我们维护以下状态</p><ul class=""><li id="92c4" class="lw lx iy jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated"><strong class="jx iz"> openCards </strong>追踪玩家已经翻出来的牌</li><li id="1ebe" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><strong class="jx iz">清除的牌</strong>用于跟踪已经匹配并需要从该副牌中移除的牌</li><li id="8df8" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><strong class="jx iz">移动</strong>跟踪玩家的移动。</li></ul><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Handling Flip and evaluate</figcaption></figure><p id="fc99" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一次我们最多只能保持两张卡处于<strong class="jx iz">打开卡</strong>状态。因为我们有一个静态数组，我们实际上并没有从我们的原始卡牌数组中删除任何东西，我们可以只存储在<strong class="jx iz"> openCards </strong>状态下打开的卡牌的索引。基于<strong class="jx iz">打开的卡片和清除的卡片</strong>状态，我们分别传递一个prop<strong class="jx iz">is lipped</strong>或<strong class="jx iz"> isInactive </strong>到我们的卡片组件，然后它将使用该组件添加各自的类。</p><blockquote class="na nb nc"><p id="bbf1" class="jv jw nd jx b jy jz ka kb kc kd ke kf ne kh ki kj nf kl km kn ng kp kq kr ks ig bi translated">一定要看看<a class="ae mt" href="https://3dtransforms.desandro.com/card-flip" rel="noopener ugc nofollow" target="_blank">这篇精彩的博客</a>，它解释了如何处理翻转卡片动画。</p><p id="4f42" class="jv jw nd jx b jy jz ka kb kc kd ke kf ne kh ki kj nf kl km kn ng kp kq kr ks ig bi translated"><strong class="jx iz">注意</strong>:由于我们为翻牌添加了动画，我们在几秒钟后评估一场比赛，以允许翻牌过渡。</p></blockquote><h2 id="8b32" class="ky kz iy bd la lb lc dn ld le lf dp lg kg lh li lj kk lk ll lm ko ln lo lp lq bi translated">4.检查游戏完成情况</h2><p id="9664" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">每次我们评估一个匹配，我们检查是否所有的配对都被找到了。如果是，我们向玩家展示一个完成模型。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="57f2" class="ky kz iy bd la lb lc dn ld le lf dp lg kg lh li lj kk lk ll lm ko ln lo lp lq bi translated"><strong class="ak"> 5。最后，我们的重启功能</strong></h2><p id="a490" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">嗯，重启很简单，我们只需<strong class="jx iz">重置</strong>我们的状态，然后重新洗牌。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="030c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">万岁！这就是我们基本的记忆卡游戏。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="nh mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Codesandbox playground</figcaption></figure><h2 id="535f" class="ky kz iy bd la lb lc dn ld le lf dp lg kg lh li lj kk lk ll lm ko ln lo lp lq bi translated"><strong class="ak">结论</strong></h2><p id="1b7d" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我很高兴我们走到了这一步。我们创建了一副混洗的牌，将其呈现在一块板上，添加了翻转功能，并对其进行了配对评估。我们可以扩展这个例子来添加一个计时器，添加玩家的最佳分数，并支持更高数量的卡。</p><p id="d38f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以查看这个Github库中的完整代码。</p><p id="0ffb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nd">更多内容请看</em><a class="ae mt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="nd">plain English . io</em></strong></a></p></div></div>    
</body>
</html>