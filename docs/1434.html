<html>
<head>
<title>Clean Architecture Vuex by example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实例清洁建筑Vuex</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/clean-architecture-vuex-by-example-a65cf2c18d5f?source=collection_archive---------0-----------------------#2021-03-27">https://javascript.plainenglish.io/clean-architecture-vuex-by-example-a65cf2c18d5f?source=collection_archive---------0-----------------------#2021-03-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d7f3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何保持你的Vuex架构干净可维护，举例说明？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3c43504a3402567d3ebc8dc0d0e3f877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVFgTuvRqxIfx-TVWJ2TcA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@benchaccounting" rel="noopener ugc nofollow" target="_blank">Bench Accounting</a> on <a class="ae ks" href="https://unsplash.com/photos/nvzvOPQW0gc" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="4103" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">介绍</h2><p id="cef2" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">本文探讨了如何为Vuex创建干净架构的技巧和诀窍。这个架构的灵感来自于官方文档、我的导师以及其他一些来自我的经验和互联网的参考资料。</p><p id="7a43" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">基于<a class="ae ks" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>官方文档，Vuex是用于<a class="ae ks" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>应用的状态管理模式+库。它充当应用程序中所有组件的集中存储，规则确保状态只能以可预测的方式变化。</p><p id="109b" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">简单来说，VueJs是一个采用基于组件的架构的框架，所以每个组件都被设计成Vue文件的一小块，可以在组件之间重用。因此，不排除一些小组件需要协同工作或使用相同数据的可能性。这就是为什么我们需要Vuex来帮助我们解决这个问题。Vuex就像一个全局变量和全局函数，可以被我们拥有的每个组件使用。Vuex还帮助我们更集中地管理API调用和存储响应数据，因此一个API调用和数据可以在我们Vue项目的每个组件中使用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/a29b38b6ca5b5f2612a0ffc79c2cd98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIoNyRO6s_52W68Y-0usJw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Vuex Architecture from official docs</figcaption></figure><h2 id="1f99" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">深入了解如何注册和创建Vuex模块</h2><p id="fb15" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">对于本文的其余部分，让我们假设我们正在使用Vuex构建一个简单的Vue应用程序，该程序使用具有干净架构的<a class="ae ks" href="https://swapi.dev/" rel="noopener ugc nofollow" target="_blank"> Swapi.dev </a>显示星球大战电影中的人和星球的列表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/d6936b2ebb88bdf9d030ff133ec002d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3o5ZpsSZGoBZpA80olfaw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Installing Vuex to our Vue App flow</figcaption></figure><p id="7f3d" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">首先，我们需要基于每个作用域创建一个新的store模块。<br/>这是我们创建商店模块时的模板。每个存储模块都包含状态、突变、动作和获取器，我们将在下一节了解每个模块的更多信息。确保添加<strong class="lr io">命名的</strong>属性。这意味着在访问存储模块之前，我们必须首先指定名称空间名称，这将使您的Vuex更加干净和可维护。我们将在最后一节看到更多的例子。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="a450" class="kt ku in mq b gy mu mv l mw mx">const state = {}<br/>const mutations = {}<br/>const actions = {}<br/>const getters = {}</span><span id="f631" class="kt ku in mq b gy my mv l mw mx"><em class="mz">export default </em>{<br/>  namespaced: <em class="mz">true</em>,<br/>  state,<br/>  mutations,<br/>  actions,<br/>  getters<br/>}</span></pre><p id="ac59" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在我们创建完我们需要的商店模块后，我们必须组合所有的商店模块并创建成一个Vuex商店。<br/>实际上，您可以直接在下面的代码中创建一个存储模块(state、getters、actions ),而无需创建像people模块或planets模块这样的单独模块。<br/>但是出于干净架构的目的，我必须说<strong class="lr io">不要这样做</strong>最好创建几个小模块，然后像这个例子一样把它们组合成一个。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="2e83" class="kt ku in mq b gy mu mv l mw mx">import Vue from 'vue'<br/>import Vuex from 'vuex'<br/>import people from './module/people'<br/>import planets from './module/planets'</span><span id="cf30" class="kt ku in mq b gy my mv l mw mx">Vue.use(Vuex)</span><span id="4eb8" class="kt ku in mq b gy my mv l mw mx">const store = new Vuex.Store({<br/>  modules: {<br/>    'people': people, // You can rename your namespaced in here<br/>    planets // will auto set the namespaced name equals with planets<br/>  }<br/>});</span><span id="94aa" class="kt ku in mq b gy my mv l mw mx">export default store</span></pre><p id="fb95" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">之后，您将几个存储模块组合在一起，并将其捆绑成一个模块。下一步是您必须在创建Vue应用程序时注册它，以便Vue应用程序可以使用我们之前创建的所有Vuex商店模块。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="bee9" class="kt ku in mq b gy mu mv l mw mx"><em class="mz">import </em>Vue <em class="mz">from </em>'vue'<br/><em class="mz">import </em>App <em class="mz">from </em>'./App.vue'<br/><em class="mz">import </em>store <em class="mz">from </em>'./store'<em class="mz"><br/><br/>new </em>Vue({<br/>  render: h =&gt; h(App),<br/>  store<br/>}).$mount('#app')</span></pre></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h2 id="ad49" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">深入研究创建单一商店模块</h2><p id="2582" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">对于单个商店模块的其余部分，我们只关注人商店模块，因为人和行星商店模块或多或少有点相似。你也可以在我的<a class="ae ks" href="https://github.com/hanssagita/vuex-example" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中查看行星实现。<br/>首先，我总是先从状态开始，把状态简化成一个包含数据的全局变量。对于这个例子，我们想要存储星球大战人物数据。由于我们有不止一个人的数据，我们将把它存储在一个数组中。在这个例子中，我用一个空数组的默认值定义了一个people字段。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="3895" class="kt ku in mq b gy mu mv l mw mx"><em class="mz">const </em>state = {<br/>  people: []<br/>}</span></pre><p id="90e8" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">其次，在我们知道我们想要存储什么样的全局变量之后，我们需要创建一个突变来修改状态值。因为它就像一个全局变量，我们需要在不调用突变的情况下保护要编辑的状态，只有突变才能改变状态值。在这个例子中，我在修改状态值时使用了spread操作符，因为在JavaScript中，如果我们只使用equals (=)，那么值只复制引用，而不深度复制数组值。恐怕又是一个bug，很难调试。因此，在对新值进行变异时，最好使用spread运算符。对于对象，还要确保使用spread运算符。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="e7f8" class="kt ku in mq b gy mu mv l mw mx"><em class="mz">const </em>mutations = {<br/>  setPeople(state, payload) {<br/>    state.people = [...payload]<br/>  }<br/>}</span><span id="93fb" class="kt ku in mq b gy my mv l mw mx">// Tips<br/>// mutate array value use this --&gt; = [...payload]<br/>// mutate object value with --&gt; = {...payload}<br/>// mutate string, number or boolean value with --&gt; = payload</span></pre><p id="1d17" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">第三，我们来看行动。简单来说，动作就像一个全局函数，可以在我们定义的每个组件中调用。大多数情况下，操作用于处理API调用和更改状态值。在动作中，我们通常调用突变来改变状态值。</p><p id="709e" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在我看来，为了更干净的建筑。我建议为API创建一个新的单独文件。对于这个例子，我使用了Axios，并将Axios future promise与回调函数相结合。Axios将调用来自<a class="ae ks" href="https://swapi.dev/" rel="noopener ugc nofollow" target="_blank"> Swapi.dev </a>的get请求，然后返回一些响应并触发带有结果的成功回调。有些请求失败了。它将运行catch并返回失败回调以及错误响应。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="26aa" class="kt ku in mq b gy mu mv l mw mx"><em class="mz">import </em>axios <em class="mz">from </em>'axios'<br/><br/><em class="mz">const getPeople </em>= (success, fail) =&gt; {<br/>  axios<br/>    .get('https://swapi.dev/api/people/') // backend Url<br/>    .then((response) =&gt; success(response)) // request success<br/>    .catch((response) =&gt; fail(response)) // request fail<br/>};<br/><br/><em class="mz">export </em>{ <em class="mz">getPeople </em>}</span></pre><p id="c633" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在完成和准备所有API调用并将其与回调结合之后，现在我们可以返回到我们的商店模块。在这个动作中，我们将调用我们之前在单独的文件中定义的API，我们在对象成功和失败中接受2个参数，与API中相同，成功用于在完成API调用后触发一些函数。我们通常使用它来显示和隐藏加载或触发一些跟踪器，对于失败回调，我们通常使用它来向客户显示错误消息或处理组件中的错误处理程序。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="c8ed" class="kt ku in mq b gy mu mv l mw mx">import { getPeople } from '@/api'</span><span id="bf11" class="kt ku in mq b gy my mv l mw mx"><em class="mz">const </em>actions = {<br/>  getPeopleAction({ commit }, { success, fail } = {}) {<br/>    getPeople( // Call the API<br/>      (response) =&gt; { // Success Callback<br/>        commit('setPeople', response.data.results) // call mutations<br/>        // Trigger to view another success Callback<br/>        success &amp;&amp; success(response) <br/>      },<br/>      (response) =&gt; { // Fail Callback<br/>        fail &amp;&amp; fail(response) // Trigger to view fail callback<br/>      }<br/>    )<br/>  }<br/>}</span></pre><p id="621e" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">最后但同样重要的是，Getters根据存储状态计算派生状态。Getters是可选的，你可以有也可以没有。如果您需要修改值的状态，您可以拥有它。对于这个例子，我试图区分男性和女性，我们可以使用getters来处理。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="28e4" class="kt ku in mq b gy mu mv l mw mx"><em class="mz">const </em>getters = {<br/>  male (state) {<br/>    <em class="mz">return </em>state.people.filter(person =&gt; person.gender === 'male') <br/>  },<br/>  female (state) {<br/>    <em class="mz">return </em>state.people.filter(person =&gt; person.gender === 'female')<br/>  }<br/>};</span></pre></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h2 id="1980" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">深入探讨如何从视图或组件访问商店模块</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/fc78514b7f3568d7564cef9de6597ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*WOE-8R5-RdcIGakVeg0T1w.png"/></div></figure><p id="40a2" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">首先，先从状态说起。要访问状态，我们需要从Vuex导入mapState，并将其映射到一个计算值，如下面的示例代码所示。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="7e01" class="kt ku in mq b gy mu mv l mw mx">import { mapState } from 'vuex'<br/>export default {<br/>  name: "People",<br/>  computed: {<br/>    // First parameter is the namespaced name<br/>    // Second parameter is the list of state<br/>    ...mapState('people', ['people']),<br/>  }<br/>}</span><span id="5cee" class="kt ku in mq b gy my mv l mw mx"><em class="mz">// Bonus tips<br/>// If you want to access more than one store modules<br/>// You need to define another mapState inside computed<br/></em>computed: {<br/>    ...mapState('people', ['people']), // first module<br/>    ...mapState('planets', ['planets']) // second module<br/>  }</span></pre><p id="9ee7" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">其次是动作，您需要从Vuex导入mapActions并将其放在方法中，因为动作类似于全局方法。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="3750" class="kt ku in mq b gy mu mv l mw mx">import { mapActions } from 'vuex'<br/>export default {<br/>  name: "People",<br/>  data () {<br/>    return {<br/>      isLoading: false<br/>    }<br/>  },<br/>  methods: {<br/>    ...mapActions('people', ['getPeopleAction']),<br/>    handleSuccess () {<br/>      this.isLoading = false<br/>      console.log('success fetch data')<br/>    },<br/>    handleFail () {<br/>      this.isLoading = false<br/>      console.log('failed fetch data')<br/>    }<br/>  },<br/>  created () { // created will be running before component rendered<br/>    this.isLoading = true // loading variable became true<br/>    this.getPeopleAction({ // call the actions we define<br/>      success: this.handleSuccess, // will run this after success<br/>      fail: this.handleFail // will run this if failed<br/>    })<br/>  },<br/>}</span></pre><p id="ee26" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">最后但同样重要的是，getters它和mapState差不多，我们需要从Vuex导入mapGetters并把它放在computed里面。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="2d36" class="kt ku in mq b gy mu mv l mw mx">import { mapGetters } from 'vuex'<br/>export default {<br/>  name: "People",<br/>  computed: {<br/>    // First parameter is the namespaced name<br/>    // Second parameter is the list of getters<br/>    ...mapGetters('people', ['male', 'female']),<br/>  }<br/>}</span></pre><p id="e766" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated"><a class="ae ks" href="https://github.com/hanssagita/vuex-example" rel="noopener ugc nofollow" target="_blank">我的Github上的代码示例</a></p><h1 id="65a0" class="ni ku in bd kv nj nk nl ky nm nn no lb jt np ju lf jw nq jx lj jz nr ka ln ns bi translated">结论</h1><p id="df15" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">Vuex是状态管理，它存储你所有的Vue应用逻辑。你必须确保用我分享的一些技巧和窍门来保持它的整洁和可维护性。</p><p id="4fb3" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">就这样，如果你觉得这篇文章有帮助，请在评论中告诉我们。也可以在<a class="ae ks" href="https://medium.com/@hanssagita" rel="noopener">中</a>和<a class="ae ks" href="https://www.linkedin.com/in/hans-sagita/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我</p></div></div>    
</body>
</html>