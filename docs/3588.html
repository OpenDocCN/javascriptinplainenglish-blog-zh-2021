<html>
<head>
<title>Always Keep Your Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">永远信守诺言</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/always-keep-your-promises-fee1487fff16?source=collection_archive---------11-----------------------#2021-07-19">https://javascript.plainenglish.io/always-keep-your-promises-fee1487fff16?source=collection_archive---------11-----------------------#2021-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5c7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的承诺是什么，它们是如何工作的？</h2></div><p id="cd50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想知道JavaScript承诺是什么吗？你是否厌倦了使用回调？</p><p id="e9c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个指南，让你了解承诺以及它们如何简化你的生活。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/67a21f86b22d694a0c79a91578fddbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ivpOL4l3pH_014om.jpeg"/></div></div></figure><h2 id="15a9" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak">回访的缺点——为什么承诺更好？</strong></h2><p id="c096" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">承诺比回访更好有几个原因:</p><ul class=""><li id="b895" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">由于回调是作为参数传递的，如果参数的数量增加，可能会混淆什么是输入，什么是返回值。</li><li id="9066" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">回调不处理在它们内部使用的函数抛出的错误(例如JSON.parse)。</li><li id="2b62" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kh ir">回调地狱</strong>——如果有多个函数要用回调函数依次调用，这很容易导致所谓的回调地狱。</li></ul><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="b57f" class="ln lo iq na b gy ne nf l ng nh">firstRequestMethod(function(response) {  <br/>    secondRequestMethod(response, function(nextResponse) {    <br/>        thirdRequestMethod(nextResponse, function(finalResponse) {     <br/>            console.log('Final response: ' + finalResponse);    <br/>        }, failureCallback);  <br/>    }, failureCallback);<br/>}, failureCallback);</span></pre><ul class=""><li id="f48c" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">当我们使用回调函数时，它们可以依赖于调用她的函数</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e05d6cdab46fe200cf898ba02e6d124f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*Ee95FquGSvuONtuq"/></div></figure><h2 id="dc14" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak">什么是承诺？</strong></h2><p id="eb42" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">一个<code class="fe nj nk nl na b"><strong class="kh ir">Promise</strong></code>是一个在承诺产生时不一定知道的值的代理。它允许您将处理程序与异步操作的最终成功值或失败原因相关联。这使得异步方法像同步方法一样返回值:异步方法不是立即返回最终值，而是返回一个<em class="nm">承诺</em>在将来的某个时间提供该值。</p><p id="59ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，承诺，顾名思义就是在未来某个价值会被回报的承诺。这可能是成功值，也可能是失败值。因为在执行的时候，那个值并不存在，所以对于一个值的未来承诺，返回一个承诺。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/59e10499e9be277c9380008bf752d4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*7P1Td3GO_k5ahLCB.jpg"/></div></figure><p id="b14f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当正在执行的任务具有不确定的完成时间时，这尤其重要。在最常见的情况下，这可能是一个需要不同时间的网络调用。您不希望在得到响应之前暂停执行，因此返回了一个承诺，执行可以继续。一旦值可用，它将在承诺中返回。</p><h2 id="f7e8" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak">承诺入门</strong></h2><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="6de5" class="ln lo iq na b gy ne nf l ng nh">const myFirstPromise = new Promise((resolve, reject) =&gt; {  <br/>    // check condition here<br/>});</span></pre><p id="a99d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">promise的构造函数resolve和reject有两个参数。如果满足条件，则承诺解决，否则拒绝。</p><p id="abcc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以添加如下示例条件，以创建一个将返回解决或拒绝的示例承诺。在下面的示例中，如果条件为真，它将返回一个已解决的else rejected承诺。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="0aa0" class="ln lo iq na b gy ne nf l ng nh">    val condition = true<br/>    <!-- -->const myFirstPromise = new Promise((resolve, reject) =&gt; {  <br/>        if(condition) {    <br/>            resolve('Promise is resolved successfully.');  <br/>        } else {    <br/>            reject('Promise is rejected');  <br/>        }<br/>    });</span></pre><h2 id="ce00" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak">利用承诺</strong></h2><p id="606a" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在这里，您使用。然后()和。catch()方法。then()方法用于已解决的承诺，而我们需要使用catch()方法来处理失败。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="f37e" class="ln lo iq na b gy ne nf l ng nh">myFirstPromise<br/>.then((successMsg) =&gt; {<br/>    console.log(successMsg);<br/>})<br/>.catch((errorMsg) =&gt; { <br/>    console.log(errorMsg);<br/>});</span></pre><p id="e856" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，如果<code class="fe nj nk nl na b">myFirstPromise</code>返回一个Promise.resolve()，那么then()块中提到的代码将被触发。如果它返回了一个Promise.reject()，那么catch块将被触发。</p><h2 id="4c41" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak">承诺的状态</strong></h2><p id="f838" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">承诺对象有3种状态:</p><ul class=""><li id="b973" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kh ir">待定:</strong>初始状态，承诺成功或失败前</li><li id="e181" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kh ir">已解决:</strong>已完成承诺</li><li id="3f2c" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kh ir">拒绝:</strong>承诺失败</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi no"><img src="../Images/ea2f0706af26952034f26acbe36cc899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oJyjOUIAw-u4brGO.png"/></div></div></figure><h2 id="0f71" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak">连锁承诺</strong></h2><p id="f225" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">您也可以链接多个。然后()或。catch()块。例如，如果下面的承诺返回了一个字符串JSON对象。第一个将得到字符串JSON。它可以返回解析后的JSON，这将被发送到第二个then块。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="194f" class="ln lo iq na b gy ne nf l ng nh">promiseReturnsJSONString<br/>.then((stringJSON) =&gt; {<br/>    return JSON.parse(stringJSON)<br/>})<br/>.then((jsonObj) =&gt; {<br/>    console.log(jsonObj)<br/>}<br/>.catch((errorMsg) =&gt; { <br/>    console.log(errorMsg);<br/>});</span></pre><h2 id="801d" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak">finally()处理函数</strong></h2><p id="680b" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">还可以将finally()块与。然后()和。catch()。每次承诺为<code class="fe nj nk nl na b">settled</code>时都会被调用。无论承诺是<code class="fe nj nk nl na b">fulfilled</code>还是<code class="fe nj nk nl na b">rejected</code>都会被调用。当你想做某事而不考虑承诺的最终状态时，这很有用。这个处理程序不需要任何参数，因为没有传递任何东西给它。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="f9fc" class="ln lo iq na b gy ne nf l ng nh">myPromise<br/>.then((receivedData) =&gt; {     <br/>    console.log(receivedData)   })   <br/>.catch((error) =&gt; {         <br/>    console.log(error)   })   <br/>.finally(() =&gt; {     <br/>    console.log('Promise is done.')   })</span></pre><h1 id="a4fd" class="np lo iq bd lp nq nr ns ls nt nu nv lv jw nw jx ly jz nx ka mb kc ny kd me nz bi translated">更多关于承诺</h1><p id="e1f0" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在你已经理解了承诺的基本内容以及如何使用它们，让我向你介绍几个更多的概念，你可能会根据你的需求的复杂性来使用这些概念，尤其是当多个承诺出现时。</p><h2 id="413f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak"> Promise.all() </strong></h2><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="c8db" class="ln lo iq na b gy ne nf l ng nh">const allPromise = Promise.all([promise1, promise2, ...]);</span></pre><p id="af20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你将承诺传递给<code class="fe nj nk nl na b">Promise.all()</code>时，它会尝试解决所有的承诺。当你通过的所有承诺都被解决后，<code class="fe nj nk nl na b">Promise.all()</code>将返回一个包含所有值的承诺。然后，您可以通过将<code class="fe nj nk nl na b">then()</code>处理程序与回调函数一起附加到<code class="fe nj nk nl na b">Promise.all()</code>来访问这个值。</p><p id="94c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当某件事情发生并且其中一个承诺被拒绝时,<code class="fe nj nk nl na b">Promise.all()</code>将立即返回被拒绝的值。记住这一点很重要。如果一个承诺“失败”<code class="fe nj nk nl na b">Promise.all()</code>将只返回被拒绝的值。它不会从任何以前解决的承诺中返回数据。[ <a class="ae oa" href="https://blog.alexdevero.com/javascript-promises/" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="d83d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你在做一些需要全有或全无的操作时，这会特别有用。例如，如果您正在进行银行交易，您可能希望检查当前帐户余额，检查是否允许借记以及是否满足最小余额条件，借记帐户，更新帐户数据库，更新交易数据库，向用户提供确认。现在，如果在任何一个步骤中，您收到一个失败，您可能也想回滚所有以前的步骤。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="9195" class="ln lo iq na b gy ne nf l ng nh">const <!-- -->promise1<!-- --> = new Promise((resolve, reject) =&gt; {   <br/>    setTimeout(function() {     <br/>      resolve('myPromiseOne has been resolved.')   }, 500) })</span><span id="7ad0" class="ln lo iq na b gy ob nf l ng nh">const <!-- -->promise2<!-- --> = new Promise((resolve, reject) =&gt; {      <br/>    setTimeout(function() {     <br/>      resolve('myPromiseTwo has been resolved.')   }, 1000) })</span><span id="0baf" class="ln lo iq na b gy ob nf l ng nh">const allPromise = Promise.all([promise1, promise2]);</span></pre><p id="1cd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您可以使用一个<code class="fe nj nk nl na b">then</code>able语法提取承诺解析值:</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="1659" class="ln lo iq na b gy ne nf l ng nh">allPromise.then(values =&gt; {<br/>  values; // [valueOfPromise1, valueOfPromise2, ...]<br/>}).catch(error =&gt; {<br/>  error;  // rejectReason of any first rejected promise<br/>});</span></pre><p id="db4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nj nk nl na b">Promise.all([...])</code>是一个有用的帮助函数，它允许你使用快速失败策略并行执行异步操作，并将结果聚集到一个数组中。</p><h2 id="1c2f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak"> Promise.allSettled() </strong></h2><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="99a6" class="ln lo iq na b gy ne nf l ng nh">const anyPromise = Promise.<!-- -->allSettled<!-- -->([promise1, promise2, ...]);</span></pre><p id="b4d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nj nk nl na b"><strong class="kh ir">Promise.allSettled()</strong></code>方法返回一个承诺，该承诺在所有给定承诺完成或被拒绝后解析，并带有一个对象数组，每个对象描述每个承诺的结果。</p><p id="195a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果任务相互独立，这将非常有用。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="0124" class="ln lo iq na b gy ne nf l ng nh">const <!-- -->promise1<!-- --> = new Promise((resolve, reject) =&gt; {   <br/>    setTimeout(function() {     <br/>      resolve('myPromiseOne is resolved.')   }, 500) })</span><span id="cea1" class="ln lo iq na b gy ob nf l ng nh">const <!-- -->promise2<!-- --> = new Promise((resolve, reject) =&gt; {      <br/>    setTimeout(function() {     <br/>      reject('myPromiseTwo is rejected.')   }, 1000) })</span><span id="29db" class="ln lo iq na b gy ob nf l ng nh">const allSettledPromise = Promise.allSettled([promise1, promise2]);</span></pre><p id="d16b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在这种情况下，输出将是:</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="efc1" class="ln lo iq na b gy ne nf l ng nh">allSettledPromise.then(values =&gt; {<br/>  console.log(values); <br/>});</span><span id="8834" class="ln lo iq na b gy ob nf l ng nh">// [<br/>//   {status: "fulfilled", value: '<!-- -->myPromiseOne is resolved.'<!-- -->},<br/>//   {status: "rejected", value: '<!-- -->myPromiseTwo is rejected.'<!-- -->},<br/>// ]</span></pre><h2 id="38a6" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak"> Promise.any() </strong></h2><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="882d" class="ln lo iq na b gy ne nf l ng nh">const anyPromise = Promise.any([promise1, promise2, ...]);</span></pre><p id="9470" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顾名思义，这与Promise.all()正好相反。这将返回承诺列表中解决的第一个承诺。</p><p id="f58e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="893c" class="ln lo iq na b gy ne nf l ng nh">const <!-- -->promise1<!-- --> = new Promise((resolve, reject) =&gt; {   <br/>    setTimeout(function() {     <br/>      reject('myPromiseOne has been rejected.')   }, 500) })</span><span id="ecb9" class="ln lo iq na b gy ob nf l ng nh">const <!-- -->promise2<!-- --> = new Promise((resolve, reject) =&gt; {      <br/>    setTimeout(function() {     <br/>      resolve('myPromiseTwo has been resolved.')   }, 1000) })</span><span id="93c9" class="ln lo iq na b gy ob nf l ng nh">const <!-- -->promise3<!-- --> = new Promise((resolve, reject) =&gt; {      <br/>    setTimeout(function() {     <br/>      resolve('myPromiseThree has been resolved.')   }, 1000) })</span><span id="eadb" class="ln lo iq na b gy ob nf l ng nh">const anyPromise = Promise.any([promise1, promise2, promise3]);</span></pre><p id="18b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，任何承诺都具有承诺2的值</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="82b0" class="ln lo iq na b gy ne nf l ng nh">anyPromise.then(<!-- -->(value) =&gt; <br/>  console.log(value). // 'myPromiseTwo has been resolved.'<br/>}).catch((error) =&gt; {<br/>  error;  // rejectReason of any first rejected promise<br/>});</span></pre><p id="028e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当所有的承诺都失败时，catch块才会被触发。</p><p id="e539" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nm">示例:您可以使用它的一个示例是，如果您从多个来源获取一些数据以获得高可用性，并且一旦您从任何来源获得数据，您就可以返回。你不需要别人给你。</em></p><h2 id="384f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak"> Promise.race() </strong></h2><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="9e45" class="ln lo iq na b gy ne nf l ng nh">const racePromise = Promise.race([promise1, promise2, ...]);</span></pre><p id="ab8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nj nk nl na b"><strong class="kh ir">Promise.race()</strong></code>方法返回一个承诺，该承诺在iterable中的一个承诺满足或拒绝时立即满足或拒绝，并带有该承诺的值或原因。</p><blockquote class="oc od oe"><p id="6712" class="kf kg nm kh b ki kj jr kk kl km ju kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated"><strong class="kh ir">注意</strong> —与返回第一个解析值的<strong class="kh ir"> Promise.any() </strong>不同，P <strong class="kh ir"> romise.race() </strong>将返回第一个完成的承诺，无论它是被解析还是被拒绝。</p></blockquote><h2 id="7421" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated"><strong class="ak">了解更多信息的伟大链接</strong></h2><ul class=""><li id="a00d" class="ml mm iq kh b ki mg kl mh ko oi ks oj kw ok la mq mr ms mt bi translated">https://www . loginradius . com/blog/async/callback-vs-promises-vs-async-await/</li><li id="83e3" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">https://blog.alexdevero.com/javascript-promises/</li><li id="6b31" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Promise</li><li id="275f" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">https://ivanjov.com/do-you-promise/</li><li id="e412" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">https://dmitripavlutin.com/what-is-javascript-promise/</li><li id="d51a" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">https://code burst . io/a-simple-guide-to-es6-promises-d 71 bacd 2e 13 a</li></ul><h1 id="9b3f" class="np lo iq bd lp nq nr ns ls nt nu nv lv jw nw jx ly jz nx ka mb kc ny kd me nz bi translated">希望这对你有帮助！</h1><blockquote class="oc od oe"><p id="51cd" class="kf kg nm kh b ki kj jr kk kl km ju kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated">如果你想了解更多关于<strong class="kh ir">ASYNC()…AWAIT()…</strong><a class="ae oa" href="https://sicpic.medium.com/what-is-async-await-and-how-to-use-it-20ef88bb0f1" rel="noopener"><strong class="kh ir">点击这里</strong> </a> <strong class="kh ir">。</strong></p></blockquote><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ol"><img src="../Images/4ee995e59f8058966df6b454d9601ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-xGBZjF91aY5D4C5.png"/></div></div></figure><p id="6f43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nm">更多内容请看</em><a class="ae oa" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>