<html>
<head>
<title>From Zero to Dijkstra — The Shortest Path to the Shortest Path Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到Dijkstra最短路径到最短路径算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/from-zero-to-dijkstra-the-shortest-path-to-the-shortest-path-algorithm-f070e224f99e?source=collection_archive---------7-----------------------#2021-06-25">https://javascript.plainenglish.io/from-zero-to-dijkstra-the-shortest-path-to-the-shortest-path-algorithm-f070e224f99e?source=collection_archive---------7-----------------------#2021-06-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b59e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:二进制堆和排队</h2></div><p id="c2b7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">任何花时间研究数据结构和算法的程序员都听说过臭名昭著的“Dijkstra算法”。这是一种由荷兰计算机科学家Edsger Dijkstra发现的复杂算法，它可以找到图上任意两点之间的最短路径。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/4a95e481647cd8320d5e18a04b784a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*OmNbbzykpOMoiYzql-p2FA.jpeg"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Edsger Dijkstra (image from Wikipedia)</figcaption></figure><p id="3fc8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">任何基本的DS&amp;A课程都可能以重新创建Dijkstra算法而告终，因为它需要许多不同的数据结构和问题解决模式的知识，这些知识最终形成最终产品。</p><p id="c1fc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个博客系列的目标是教你如何从几乎没有数据结构的知识开始解决这个算法。在我们开始之前，您应该有一些基本的必备知识:</p><ul class=""><li id="0989" class="lk ll in ke b kf kg ki kj kl lm kp ln kt lo kx lp lq lr ls bi translated">Javascript基础——数组和对象</li><li id="f6f7" class="lk ll in ke b kf lt ki lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">JS中的类</a></li></ul><p id="b24e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！其余的可以在对任何其他数据结构一无所知的情况下教授。让我们从Dijkstra之旅的第一部分开始:优先级队列和二进制堆。</p><h1 id="7377" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">什么是优先级队列？</h1><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/0fbbd7522b20842df78d45f1c6dfbbb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rxXks091MM87q2uZ"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Photo by <a class="ae ly" href="https://unsplash.com/@mael_balland?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mael BALLAND</a> on <a class="ae ly" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="12c5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">优先级队列对Dijkstra算法很重要，原因将变得显而易见，但现在，让我们只讨论它们是什么。“队列”是遵循<strong class="ke io">先进先出(FIFO) </strong>规则的数据结构。这意味着，首先放入队列的数据将首先被处理。想象一下在熟食店排队，你拿着一张票，你的号码按照你收到票的顺序被叫出来。</p><p id="ed82" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">优先级队列是一种特殊类型的队列，其中每条数据(在本例中是一个<strong class="ke io">节点</strong>)都有一个优先级。把它想象成一家医院:你两个小时前因胃痛入院。尽管你已经等了很长时间，但受枪伤的人会被第一个看到。他有更高的优先权。</p><p id="943b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为队列一次处理一个数据(<strong class="ke io">入队</strong>和<strong class="ke io">出队</strong>)，所以唯一重要的问题是“最高优先级的项目是什么？”因此，数据结构知道什么要出列，新节点在哪里排队。实现这一点的简单方法是使用<strong class="ke io">二进制堆。</strong></p><h1 id="01f7" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">什么是二进制堆？</h1><p id="f4b6" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">这是一个好问题。二进制堆是一种<strong class="ke io">树</strong>结构。不要害怕，你以前见过树(DOM像树一样设置)。树只是父母和孩子的集合。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nb"><img src="../Images/9e0bfd6703625862187c9aa40a77c7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HFyBW6PpI3p4vM_1"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Photo by <a class="ae ly" href="https://unsplash.com/@akummur?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adarsh Kummur</a> on <a class="ae ly" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="008e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二进制堆是一棵树，其中每个父节点最多只有两个孩子。在<strong class="ke io">最大二进制堆</strong>中，每个子堆的值都小于父堆的值。参见下面的例子。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/54d1fd1cfbaab01c0e4ddf36c146a029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrWGvHd3NDX6AHt9LN28xw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Max Binary Heap</figcaption></figure><p id="f0d9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个<strong class="ke io"> min二进制堆</strong>也是同样的想法，除了在孩子比父母大的时候。您可能会看到这对于优先级队列是多么有用。如果我们有一个最小二进制堆，我们将能够推断出<strong class="ke io">最低值节点</strong>必须总是树的根。如果我们总是在甲板上有最低的价值，那么这听起来像一个优先队列。</p><p id="fb5c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们总是让<strong class="ke io">从顶部的</strong>出列，我们将总是取<strong class="ke io">的最低值</strong>。这意味着，如果我们将优先级设置为最低值是最重要的，我们可以始终确保将优先级最高的节点出队。让我们开始吧。</p><h1 id="fd80" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated"><strong class="ak">实现最小二进制堆</strong></h1><p id="00d5" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">让我们从最小二进制堆开始，因为它比直接进入优先级队列稍微简单一些，并且从一开始就更有意义。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/730da0ea1c512dae7f635ca5942f79c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*V46BUK74t6EINroVSyqSpg.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Min Binary Heap and Corresponding Array</figcaption></figure><p id="2ef0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您在这张图片中看到的，我们有一个最小二进制堆。节点可以用一个简单的数组来表示。只要我们保持最小二进制堆的规则稳定，我们就可以用数组来表示它:</p><ul class=""><li id="4b56" class="lk ll in ke b kf kg ki kj kl lm kp ln kt lo kx lp lq lr ls bi translated">根是最小值</li><li id="9858" class="lk ll in ke b kf lt ki lu kl lv kp lw kt lx kx lp lq lr ls bi translated">每个节点最多有2个子节点</li><li id="7df0" class="lk ll in ke b kf lt ki lu kl lv kp lw kt lx kx lp lq lr ls bi translated">孩子总是比他们的直系父母大。</li><li id="16af" class="lk ll in ke b kf lt ki lu kl lv kp lw kt lx kx lp lq lr ls bi translated">在创建另一个层之前，填充每个子节点。</li></ul><p id="06da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你会注意到我用颜色标记了父母和孩子，以便更容易看到他们在阵列上的位置。如果进一步推断该模式，您会注意到父索引与其子索引之间的关系是<em class="ne">(其中n = parent index)</em><strong class="ke io"><em class="ne">2n+1</em></strong><em class="ne">(</em>左子<em class="ne"> ) </em>或<strong class="ke io"><em class="ne">2n+2</em></strong><em class="ne">(</em>右子<em class="ne">)。</em></p><p id="c325" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用这种关系来“交换”数组中的值，本质上是改变堆的布局，同时只操纵数组结构。</p><h2 id="c07e" class="nf ma in bd mb ng nh dn mf ni nj dp mj kl nk nl ml kp nm nn mn kt no np mp nq bi translated"><strong class="ak">入队(二进制堆)</strong></h2><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/730da0ea1c512dae7f635ca5942f79c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*V46BUK74t6EINroVSyqSpg.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Min Binary Heap</figcaption></figure><p id="6dcf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们想将数字“4”添加到我们的堆中。我们可以断定它不会成为根(它大于3！)但它应该作为“3”的直接子级，因为它是堆中下一个最小的值。我们可以通过在数组结构的末尾添加“4 ”,并编写一个算法来比较/交换它的值和它的父值，直到它将堆“冒泡”到正确的位置。</p><p id="111f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很简单。让我们首先编写一个名为“最小二进制堆”的类，并使用这个“冒泡”功能创建一个简单的“入队”函数。</p><pre class="kz la lb lc gt nr ns nt nu aw nv bi"><span id="3077" class="nf ma in ns b gy nw nx l ny nz">class MinBinaryHeap {<br/>    constructor() {<br/>        this.values = [];<br/>    }<br/>    <br/>    enqueue(element) {<br/>        this.values.push(element);<br/>        this.bubbleUp();<br/>    }</span></pre><p id="9a23" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，我们的MinBinaryHeap只是一个由<strong class="ke io"> this.values. </strong>引用的数组。我们的enqueue函数只是将新元素推到数组的末尾，然后调用我们方便的<strong class="ke io"> bubbleUp() </strong>函数来确定放置位置。要是<strong class="ke io"> bubbleUp() </strong>是一个内置函数就好了！但是不行，我们必须自己建造它！</p><p id="ca64" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要一种识别“新”元素的方法，以及它的父节点是什么。还记得公式<em class="ne"> 2n+1或者2n+2吗？</em>好吧，我们可以反过来用以下方法找到父节点:</p><pre class="kz la lb lc gt nr ns nt nu aw nv bi"><span id="55f6" class="nf ma in ns b gy nw nx l ny nz">//Reference 'new' Element<br/>let idx = this.values.length - 1;<br/>const element = this.values[idx];</span><span id="f1d2" class="nf ma in ns b gy oa nx l ny nz">//Find 'parent' element<br/>let parentIdx = Math.floor( (idx-1) / 2 );<br/>let parent = this.values[parentIdx];</span></pre><p id="a653" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“new”元素的索引是数组中的最后一个索引。由于我们正在反转<em class="ne"> 2n+1 | 2n+2 </em>公式，我们可以“Math.floor”找到单亲索引，不管我们是在左边还是右边的孩子。</p><p id="4a47" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以实现一个“while”循环，在父元素和子元素之间进行交换，直到我们的“new”元素到达一个点，在这个点上，它要么到达堆的顶部，要么比它的父元素大(这样就不需要进一步交换)</p><pre class="kz la lb lc gt nr ns nt nu aw nv bi"><span id="6cc6" class="nf ma in ns b gy nw nx l ny nz">//while the index is NOT the top of the heap</span><span id="69ed" class="nf ma in ns b gy oa nx l ny nz">while(idx &gt; 0) {<br/>// if the child element is greater/equal to the parent, exit the loop<br/>   <br/>    if (element &gt;= parent) break;</span><span id="0d9c" class="nf ma in ns b gy oa nx l ny nz">// else, swap parent and child and reassign the 'new' element's index to be what the parent's was.</span><span id="134b" class="nf ma in ns b gy oa nx l ny nz">    if (element &gt; parent) {<br/>        this.values[parentIdx];<br/>        this.values[idx] = parent;<br/>        idx = parentIdx;<br/>}</span></pre><p id="9d0c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看整个<strong class="ke io"> enqueue() </strong>和<strong class="ke io"> bubbleUp() </strong>函数是如何写出来。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/43f245296e5f4680bdc09662f8de20b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*7SCZ1dtu9og3w85ozfSLFA.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">enqueue() and bubbleUp()</figcaption></figure><p id="4789" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还不算太糟，是吧？这个教程有点长，但是让我们回顾一下我们已经学了什么和我们还需要学什么。</p><h2 id="90f4" class="nf ma in bd mb ng nh dn mf ni nj dp mj kl nk nl ml kp nm nn mn kt no np mp nq bi translated">我们学到了什么</h2><ul class=""><li id="34f7" class="lk ll in ke b kf mw ki mx kl oc kp od kt oe kx lp lq lr ls bi translated">什么是优先级队列？</li><li id="30e2" class="lk ll in ke b kf lt ki lu kl lv kp lw kt lx kx lp lq lr ls bi translated">什么是最小/最大二进制堆？</li><li id="22cd" class="lk ll in ke b kf lt ki lu kl lv kp lw kt lx kx lp lq lr ls bi translated">我们如何将新值放入二进制堆？</li></ul><p id="db69" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一节中，我们将处理更复杂的<strong class="ke io"> dequeue() </strong>函数，然后看看如何将这个二进制堆变成传说中的优先级队列(提示:这比您想象的要简单得多)。</p><p id="6ced" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读，如果您有任何问题或有其他数据结构/算法主题希望我介绍，请在评论中告诉我。</p><p id="908e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ne">更多内容请看</em><a class="ae ly" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ne">plain English . io</em></strong></a></p></div></div>    
</body>
</html>