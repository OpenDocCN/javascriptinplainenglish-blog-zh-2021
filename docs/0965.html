<html>
<head>
<title>This, Hoisting and Execution Context in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的提升和执行上下文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/this-hoisting-and-execution-context-in-javascript-f508a261691f?source=collection_archive---------16-----------------------#2021-02-28">https://javascript.plainenglish.io/this-hoisting-and-execution-context-in-javascript-f508a261691f?source=collection_archive---------16-----------------------#2021-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1fd576e0424bbb50922fd1993a24faf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*svYUaST5g7amW7WR"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5e47" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">这</h1><p id="6c79" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果你一直在学习JavaScript，你可能会碰到“这个”几次，通常会有一个简单的解释，然后是类似“不要担心它是如何工作的，以后会更有意义”的内容。现在是稍后，这是什么？</p><p id="1f15" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io"> <em class="mb"> This: </em> </strong> <em class="mb">一个执行上下文(全局、函数或eval)的属性，在非严格模式下，总是对一个对象的引用，在严格模式下可以是任意值。</em> <a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"> -MDN文档</a></p><p id="0f71" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">要理解这意味着什么，你必须理解JavaScript如何执行代码。让我们从对这一点的基本理解、这一点的不同示例以及手动设置这一点的值开始，然后我们将继续执行上下文，最后是提升。</p><p id="e447" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">解释MDN引用的一个更简单的方法是，对于函数来说，它的值是调用它的上下文，对于事件侦听器来说，它是侦听器所附加的元素，对于方法来说，它是拥有该方法的对象。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f284" class="ml kb in mh b gy mm mn l mo mp">function returnThis () {<br/>  return this<br/>}</span></pre><p id="3ea0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这个例子中，调用return这将返回窗口对象(在浏览器中),因为函数是在全局上下文中声明的，因此属于全局对象，这意味着它没有在另一个函数或对象中声明。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="bf02" class="ml kb in mh b gy mm mn l mo mp">class WhatIsThis {<br/>  returnThis () {<br/>    return this<br/>  }<br/>}<br/>let test = new WhatIsThis</span></pre><p id="cd79" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在此示例中，test.returnThis()返回“test”引用的what is的实例，因为what is是拥有returnThis()方法的对象。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3598" class="ml kb in mh b gy mm mn l mo mp">function log () {console.log(this)}</span><span id="ad23" class="ml kb in mh b gy mq mn l mo mp">const button = document.querySelector('button');</span><span id="9717" class="ml kb in mh b gy mq mn l mo mp">buttons.addEventListener('click', log);</span></pre><p id="2c1f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">对于这个例子，假设我们有一个网页，其中包含一个带有事件监听器的按钮，事件监听器在被触发时调用日志功能。你用我做的这个<a class="ae jz" href="https://codepen.io/SVRourke/pen/ZEBxRRo" rel="noopener ugc nofollow" target="_blank"> codepen </a>试试，你会看到按钮DOM元素在按钮被按下的时候被记录到控制台。这是因为事件侦听器中的值是侦听器所附加的元素，但是，如果我们不使用事件侦听器而直接在控制台中运行log()，它将返回窗口对象。这是因为函数中的这个值是由调用它的上下文决定的，这意味着当在事件侦听器中调用log()时，log中的这个值就是DOM button元素！</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1837" class="ml kb in mh b gy mm mn l mo mp">function external () {<br/>  return this.name<br/>}</span><span id="0849" class="ml kb in mh b gy mq mn l mo mp">let person = {<br/>  name: "Sam",<br/>  age: 27<br/>}</span><span id="bd2b" class="ml kb in mh b gy mq mn l mo mp">let sam = external.bind(person)</span><span id="86dc" class="ml kb in mh b gy mq mn l mo mp">console.log(sam())</span></pre><p id="e733" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">此代码示例显示了如何使用？bind()，使用a.bind(b)将返回一个新函数，其主体和作用域与a相同，但与b中的相同。在此代码示例中，我们定义了返回this.name的函数external，如果external按原样调用，它将返回一个空字符串。我们还创建了一个具有两个属性的对象“person ”:姓名和年龄。接下来，我们使用bind()创建一个名为sam的新函数，该函数使用this of person和函数external。通过调用sam()，您将看到返回了person对象的name属性。</p><h1 id="f844" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">执行上下文</h1><p id="e060" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">当你运行一个脚本时，你可能会认为JavaScript引擎一行一行地运行你的代码，同时执行代码，然而这是不正确的，因为JavaScript引擎分两个阶段运行:创建和执行。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="bdbc" class="ml kb in mh b gy mm mn l mo mp">const myName = 'Sam';</span><span id="19b1" class="ml kb in mh b gy mq mn l mo mp">function greet (name) {<br/>  return `Hello ${name}`;	<br/>}<br/>const greetSam = greet(myName);</span><span id="14a9" class="ml kb in mh b gy mq mn l mo mp">console.log(greetSam)</span></pre><p id="7db4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们将像JavaScript引擎一样一步一步地浏览这段代码。当您第一次执行这个脚本时，JavaScript创建第一个执行上下文，全局执行上下文并将其绑定到关键字this，它还为变量myName和greetSam以及greet()的函数声明分配内存，但是它将变量存储为未定义。</p><p id="5752" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在创建阶段之后，JavaScript转到执行阶段，在那里它给变量赋值并执行函数调用。每当JavaScript调用一个函数时，它都会为该函数创建新的执行上下文，再次经历每个新上下文的创建和执行阶段，将结果值返回给全局执行上下文，该上下文继续执行剩余的代码。为了在进入执行阶段后继续我们的示例，JavaScript引擎将:</p><ol class=""><li id="d355" class="mr ms in la b lb lw lf lx lj mt ln mu lr mv lv mw mx my mz bi translated">将字符串“Sam”赋给变量myName。</li><li id="760c" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">为greetSam中greet()的调用创建一个新的执行上下文</li><li id="c022" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">执行greet()调用的上下文</li><li id="518e" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">将greet()的结果返回给全局执行上下文。</li><li id="6018" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">将返回值赋给变量greetSam</li><li id="fb2a" class="mr ms in la b lb na lf nb lj nc ln nd lr ne lv mw mx my mz bi translated">将greetSam的值记录到控制台</li></ol><h1 id="f06f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">提升</h1><p id="f206" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">提升是一种将JavaScript构建执行上下文的方式概念化的方式，这种方式会影响代码执行期间变量和函数何时可用。在执行代码之前，创建阶段将所有变量和函数放入内存的方式，使所有变量和函数声明看起来好像都被“吊”到了文件的顶部，例如:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1a2f" class="ml kb in mh b gy mm mn l mo mp">greetUser()</span><span id="8aa0" class="ml kb in mh b gy mq mn l mo mp">function greetUser () {<br/>  console.log('Hello')<br/>}</span></pre><p id="e8d7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在本例中，greetUser()函数在编写之前就被调用了，您可能会直觉地认为这会导致错误，但是在创建阶段，greetUser声明是在调用执行之前被挂起的。</p><p id="4046" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">仅悬挂声明:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="d09a" class="ml kb in mh b gy mm mn l mo mp">console.log(x) // Undefined<br/>var x;         // Declaration</span><span id="45a2" class="ml kb in mh b gy mq mn l mo mp">// let &amp; const not hoisted, cannot reference before init<br/>// const must have initializer in declaration<br/>console.log(y) // ReferenceError<br/>let y = 6;     // Declaration and Initialization NO HOIST</span></pre><p id="1f74" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">对JavaScript执行代码的方式有了基本的了解，代码提升应该是一个相当简单的概念。</p><h1 id="96ee" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="9b52" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">希望这篇文章能帮助一些人更好地理解这个，提升，和JavaScript代码执行，我知道它肯定对我有帮助。</p><p id="a347" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果你喜欢我的写作，请随意查看我的网站，并在T2的LinkedIn上与我联系</p><p id="0910" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="mb">更多内容尽在</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="mb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>