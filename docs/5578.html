<html>
<head>
<title>Jest: Writing Unit Tests You Can Depend On</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest:编写你可以依赖的单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/jest-writing-unit-tests-you-can-depend-on-8028e159e678?source=collection_archive---------13-----------------------#2021-11-19">https://javascript.plainenglish.io/jest-writing-unit-tests-you-can-depend-on-8028e159e678?source=collection_archive---------13-----------------------#2021-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="51b9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们都知道我们应该写测试。但是你从哪里开始呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5e22c8e11a24d93010b3da557f0803ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fg8nchrr72u5wpov"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Like a good set of wrenches, unit tests are essential to any Software developers toolkit. Photo by<a class="ae kv" href="https://unsplash.com/@nina_mercado?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Nina Mercado</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="34ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我一直想在一个大家都写测试的环境下工作。对我来说，这感觉就像圣杯一样——如果做得好，会给我(和项目中的每个人)信心，相信我所做的更改没有破坏代码库中的其他东西。它们对我的另一个爱好——CICD来说是必不可少的，这也意味着我可以让新手不受限制地访问代码库，知道如果/当他们破坏了一些东西，测试将会失败，然后无法投入生产。但就像圣杯一样，它们总是有点遥不可及，因为迄今为止我工作过的所有地方都将快速交付置于长期稳定性之上。</p><p id="f85c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我找到了一个我们应该写测试的地方。但现在的问题是‘我们如何写出好的测试’？</p><p id="240d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使测试有效，它们需要真实地反映组件在现实生活中的使用情况。如果函数只将两个数字相加，测试会相当简单。但是如果组件包括交互性，那么测试应该包括交互性，因此会更加复杂。例如，一个选择组件应该有初始值或占位符的测试，点击事件，可能还有样式等等。</p><p id="d032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章并不打算详尽列出你可以在<a class="ae kv" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>中做的所有事情。它也不是使用<a class="ae kv" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>的权威指南。但是它的目的是让你知道在不同的场景下应该测试什么。随意组合&amp;匹配方法以满足您的需求。</p><h2 id="3037" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">单元测试与集成测试</h2><p id="276e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在我开始给出建议之前，熟悉一下行话可能是个好主意。</p><p id="c71a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多类型的测试。如需详细指南，请参考<a class="ae kv" href="https://stackoverflow.com/questions/520064/what-are-unit-tests-integration-tests-smoke-tests-and-regression-tests/520116#520116" rel="noopener ugc nofollow" target="_blank">这篇非常有见地的堆栈溢出帖子</a>。</p><p id="8036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将讨论单元测试——测试特定功能的小而简洁的测试(有一个狭窄的焦点)。我们将模拟所有的外部函数调用和依赖，以使我们的测试干净并且总是可重复的。</p><p id="3db2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们不同于集成测试，集成测试被广泛定义为覆盖多个系统的测试(比单元测试有更广泛的关注点)</p><h2 id="30e7" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">堆栈</h2><p id="3707" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我的测试堆栈由2个(+1)核心工具组成:</p><ul class=""><li id="f331" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">Jest  —测试框架</li><li id="7767" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://testing-library.com/docs" rel="noopener ugc nofollow" target="_blank">测试库</a> — UI测试库</li><li id="edd9" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">TS Jest  —让Jest与Typescript一起工作</li></ul><p id="3ca3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这3个工具处理从编写和运行测试、与DOM交互(如果需要)到导出测试覆盖(<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/making-sonarcloud-play-nicely-with-jest-fa271f559024">到Sonarcloud </a>)的所有事情</p><p id="2f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们开始吧。</p><h2 id="ccbb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">简单的功能</h2><p id="71dc" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">从一个将两个值相加的函数开始。这里的测试同样简单。当我用2和3作为参数运行函数时，它应该返回5。如果是的话，我们知道代码是有效的。如果没有，我们知道我们有一个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Shows the add function and how to test it — expect 2 + 3 to equal 5.</figcaption></figure><p id="b283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我只有一个测试，但是你可以为同一个函数编写多个测试。目标应该是像在现实生活中一样测试这个功能。</p><p id="ac3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有一个React组件，这个过程非常相似。测试库提供了渲染组件的工具。我们测试它的渲染是否没有错误，并检查它的外观——例如，它里面有文本吗？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A simple component with text inside. You wouldn’t be building the component in the test (you will be importing it) but it serves to demo the test.</figcaption></figure><h2 id="e5cc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">调用其他函数的函数</h2><p id="014d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当我们拥有调用其他函数的函数时，事情会变得稍微有趣一些(并且更有生活气息)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="86d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我有一个调用另一个函数从API端点获取用户的函数。</p><p id="0f64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的挑战是我们如何保证fetch调用总是有效的。如果我们不控制端点，这将尤其具有挑战性。这就是<a class="ae kv" href="https://jestjs.io/docs/mock-functions" rel="noopener ugc nofollow" target="_blank">笑话嘲讽</a>的用武之地。</p><p id="df9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模拟允许我们模仿/覆盖一个函数的响应。这使我们能够完全控制将什么数据传递到我们要测试的代码中。记住，在单元测试中，我们只是试图在有限的范围内测试我们的代码。我们不写API或集成测试。保持简单！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="252f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的测试中，我模拟了端点文件中的<code class="fe ng nh ni nj b">getUsers</code>函数。我用一个简单的承诺覆盖了fetch调用，该承诺返回一个由3个字符串组成的数组。我知道如果数组中有3个字符串，<code class="fe ng nh ni nj b">countUsers</code>函数应该总是返回3。</p><p id="62e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更进一步，如果我试图调用的函数带有参数，我应该编写测试来确保正确的参数被传递给它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="04f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的测试中，你可以看到我们模拟了<code class="fe ng nh ni nj b">getUser</code>函数，和以前一样，我测试了函数<code class="fe ng nh ni nj b">getUserName</code>的结果。但是这里我们也检查了模拟<code class="fe ng nh ni nj b">getUser</code>函数是否被调用，以及调用它的参数是什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="67b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，这将始终是<code class="fe ng nh ni nj b">1234</code>，因为我为演示硬编码了它。但是在现实生活中，你会有动态变量作为参数，这就是这种测试特别有价值的地方。</p><p id="d58d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的测试还引入了另一种技术，<code class="fe ng nh ni nj b">jest.requireActual</code>。您可能会遇到这样的情况，您只想模拟文件中的一些函数，而不是所有函数。<code class="fe ng nh ni nj b">jest.requireActual</code>允许我们获得“实际的”文件，当与spread操作符配对时，我们只模拟我们需要的函数——在本例中是<code class="fe ng nh ni nj b">getUser</code>。</p><p id="cef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模仿函数允许我们缩小测试的范围，保持它们的一致性，使它们更容易阅读和维护。</p><h2 id="f396" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">修改状态的函数</h2><p id="5d0f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们的功能经常与状态交互。下面是一个按钮组件，当单击它时，调用一个Redux动作，当与一个Redux(为简单起见省略)配对时，将更新Redux状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c57a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了模拟涉及状态的交互，我使用<code class="fe ng nh ni nj b">redux-mock-store</code>和<code class="fe ng nh ni nj b">react-redux</code>来包装组件并模拟初始状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6312" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，当按钮被点击时，我调度Redux动作。<code class="fe ng nh ni nj b">store.getActions</code>返回所有动作调用的数组，我们可以根据预期对其进行测试。</p><p id="da1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:不要试图修改<code class="fe ng nh ni nj b">getActions</code>响应。编写修改测试结果的代码会引入错误，使测试更难阅读和维护。</p><h2 id="f2b6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">事件</h2><p id="5f62" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在前面的段落中，我提到了click事件，它对按钮很有用，可能是您最常用的事件。但是我们可以使用许多其他的事件，包括<code class="fe ng nh ni nj b">drop</code>、<code class="fe ng nh ni nj b">change</code>、<code class="fe ng nh ni nj b">keyup</code>、<code class="fe ng nh ni nj b">keydown</code>和<code class="fe ng nh ni nj b">paste</code>(这里是<a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-events" rel="noopener ugc nofollow" target="_blank">的完整列表</a>)来模拟交互性。</p><p id="5239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的例子的基础上，我有一个文本输入组件，当值改变时，它会更新状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试这一点，我呈现了组件并检查是否设置了占位符属性。测试库有一个名为<code class="fe ng nh ni nj b">type</code>的<code class="fe ng nh ni nj b">userEvent</code>，它模仿输入字段中的输入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="feec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们得到了返回所有动作调用的Actions。我们不希望测试立即完成，而是等待一段时间。测试库有一个<a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-async/#waitfor" rel="noopener ugc nofollow" target="_blank"> </a> <code class="fe ng nh ni nj b"><a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-async/#waitfor" rel="noopener ugc nofollow" target="_blank">waitFor</a></code>函数，可以与async/await一起使用，以等待条件为真(默认为1s，但可以配置更长时间)。这对于不会立即发生的组件更改非常有用。</p><h2 id="c1af" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">每个测试</h2><p id="c097" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当编写测试时，我优先考虑可读性，而不是枯燥。我希望能够将我的测试交给另一个人，他们可以一步一步地通过测试和代码测试，并能够找出发生了什么。</p><p id="48ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是就像所有规则一样，也有例外。</p><p id="d8ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于几乎相同但有一些小变化的测试，我可以使用test.each，这是一个jest函数，允许我们多次运行测试，每次使用不同的参数。</p><p id="4c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到前面的加法函数示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="00cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想将不同的参数传递给我们的add函数，我们可以使用<code class="fe ng nh ni nj b">test.each</code>。有<a class="ae kv" href="https://jestjs.io/docs/api#testeachtablename-fn-timeout" rel="noopener ugc nofollow" target="_blank">不同的方法</a>来指定test.each，但我更喜欢表格方法，因为我可以指定列标题，并在测试标题和参数中使用标识符。</p><p id="950c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我用不同的输入参数运行了3次测试，并测试了每个参数的结果。</p><p id="c97f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个过于简单的例子，但在现实生活中，这种方法可以在许多情况下使用。例如改变函数参数或初始状态值。这意味着我不必复制和粘贴测试代码。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="6ea1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这不是所有Jest和测试库功能的扩展列表，但它有望让您初步了解您可以(并且应该)测试什么。最终，单元测试是工具箱的一部分，工具箱包括其他类型的测试，您希望能够依靠这些测试来捕捉流氓错误。拥有良好的测试覆盖率可以更容易地让新人加入进来，知道如果他们破坏了什么，就会被发现。</p><p id="2a66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，永远不要认为测试已经完成。你可能有100%的覆盖率，但这并不意味着你已经考虑到了每一个用例。当组件因为用户做了你没有想到的事情而崩溃时，你应该将这个工作流添加到测试中。现在，当您编辑或更新组件时，您知道它必须通过新的测试用例才能为您的所有用户工作。</p><p id="72b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读本文</p><p id="aa20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你觉得这很有用</p><p id="b6a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大卫</p><p id="44f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高级前端开发人员@ <a class="ae kv" href="https://tripactions.com/" rel="noopener ugc nofollow" target="_blank"> TripActions </a></p><p id="c213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nr">更多内容看</em> <strong class="ky ir"> <em class="nr"> </em> </strong> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nr">说白了. io </em> </strong> </a> <em class="nr">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nr">免费周报在这里</em> </strong> </a> <em class="nr">。</em></p></div></div>    
</body>
</html>