<html>
<head>
<title>A Simple Guide to Breadth First Search in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中广度优先搜索的简单指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/breadth-first-breath-first-search-482eb6ec7c3c?source=collection_archive---------4-----------------------#2021-01-03">https://javascript.plainenglish.io/breadth-first-breath-first-search-482eb6ec7c3c?source=collection_archive---------4-----------------------#2021-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="24e6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">广度优先(呼吸第一..)搜索</h2></div><h2 id="c531" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">你知道他们怎么说:“如果你能教它，那么你真的知道你在说什么？”</h2><p id="2930" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh kl li lj lk kp ll lm ln kt lo lp lq lr ig bi translated">这么说吧，这就是我今天要做的。所以——非常欢迎编辑和评论！</p><h2 id="0f7f" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">广度优先搜索</strong></h2><p id="c95f" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh kl li lj lk kp ll lm ln kt lo lp lq lr ig bi translated">如果您还没有遇到过，广度优先搜索是一种以特定顺序访问节点的算法，首先是根节点，然后是相邻节点。换句话说，如果我每边有两个邻居，我会从我的房子开始，然后同时访问我左右两边的邻居——然后在我邻居的邻居中继续这个趋势。我需要一个视觉效果，所以我做了一个:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/540e0a8dccb8bbc00a3a67b53ca6cae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*4-8mNVf_FqMJbjARiKeTMQ.png"/></div></figure><p id="de58" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">我知道——疯狂的邻居，对吗？！让我们投入其中，继续我们的生活。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="1e5e" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">两个有用的定义</strong></h2><p id="7ae1" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh kl li lj lk kp ll lm ln kt lo lp lq lr ig bi translated">顶点:两条边相交的点。在这种情况下，房子。</p><p id="382c" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated"><strong class="lb io">边/边:</strong>连接——两个相连的顶点。这两栋房子在彼此之间形成了一条通道。</p><p id="e39e" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">在代码中:</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="9e7d" class="kc kd in mn b gy mr ms l mt mu">edges = [<br/>['myhouse', 'momanddad'],<br/>['momanddad', 'niece1'],<br/>['momanddad', 'nephew'],<br/>['myhouse', 'inlaws'],<br/>['inlaws', 'kid2'],<br/>['inlaws', 'kid1']<br/>]</span><span id="9ec3" class="kc kd in mn b gy mv ms l mt mu">vertices = [<br/>{name: 'myhouse', distance: null, predecessor: null},<br/>{name: 'momanddad', distance: null, predecessor: null},<br/>{name: 'inlaws', distance: null, predecessor: null},<br/>{name: 'niece1', distance: null, predecessor: null},<br/>{name: 'nephew', distance: null, predecessor: null},<br/>{name: 'kid1', distance: null, predecessor: null},<br/>{name: 'kid2', distance: null, predecessor: null}<br/>]</span></pre></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="6cac" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">找到一个节点</strong></h2><p id="7161" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh kl li lj lk kp ll lm ln kt lo lp lq lr ig bi translated">在许多这样的算法中，能够找到一个节点是很有帮助的——所以让我们为此编写代码。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="f101" class="kc kd in mn b gy mr ms l mt mu">function findNode(nodeName, vertices){<br/>     return vertices.find(vertex=&gt; vertex.name == nodeName)<br/>}</span><span id="6a58" class="kc kd in mn b gy mv ms l mt mu">In Action:<br/>findNode('myhouse', vertices)</span><span id="d87e" class="kc kd in mn b gy mv ms l mt mu">RETURNS the vertex OBJECT if found.<br/>{name: 'myhouse', distance: null, predecessor: null}</span></pre><p id="e1db" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated"><strong class="lb io">距离:</strong>正如你在顶点列表中看到的——为了让我们有一个结构，我们需要跟踪两个节点之间的距离。对于我们的根节点，距离是0。对于两个相邻节点，距离为1，因为它们距离根节点1。</p><p id="fc88" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated"><strong class="lb io">前任:</strong>跟踪该算法内部的另一种方法是记录前任。当探索邻居的房子时，我的房子就成了他们的前身。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="44a3" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">BFS一个节点上的两个动作</strong></h2><p id="3ec0" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh kl li lj lk kp ll lm ln kt lo lp lq lr ig bi translated">在BFS的一个节点上有两种操作。一个是<em class="mw">访问</em>一个节点。另一个是<em class="mw">探索</em>一个节点，这意味着弄清楚它的相邻节点是什么。坚持我的房子类比，我可以参观我的房子，但是如果我探索它——我发现我有两个邻居！——我爸妈和我亲家。听起来是个有趣的社区，是吧？</p><p id="0a7c" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">我们知道如何访问/找到一个节点，让我们通过返回它的相邻节点来探索一个节点。让我们用代码实现它，然后让我们把它分解并提炼出来。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="8c8c" class="kc kd in mn b gy mr ms l mt mu">function findAdjacent(nodeName, vertices, edges) {<br/>     return edges.filter(function(edge){<br/>          return edge.includes(nodeName)<br/>     }).map(function(edge) {<br/>          return edge.filter(function(node){<br/>               return (node !=nodeName)<br/>          })[0]<br/>     }).map(function(name){<br/>           return findNode(name, vertices)<br/>     }).filter(function(node){<br/>          return node.distance == null<br/>     })<br/>}</span></pre><p id="de6c" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">我不知道你怎么想，但是这个解决方案让我很困惑，因为我是一个视觉学习者。先重写一遍，然后再分解。这是使用箭头函数的另一种方法。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="2938" class="kc kd in mn b gy mr ms l mt mu">function findAdjacent(nodeName, vertices, edges){<br/>     return edges.filter(edge =&gt; {<br/>          return edge.includes(nodeName)<br/>     }).map(edge =&gt; {<br/>          return edge.filter(node =&gt; {<br/>               return node != nodeName<br/>          })[0]<br/>     }).map(name =&gt; {<br/>          return findNode(name, vertices)<br/>     }).filter(node =&gt; {<br/>          return node.distance == null<br/>     })<br/>}</span></pre><p id="977c" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">再用ES6的箭头函数和隐式返回(如果对你有帮助的话)来概括</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="2abb" class="kc kd in mn b gy mr ms l mt mu">function findAdjacent(nodeName, vertices, edges){<br/>     return edges.filter(edge =&gt; edge.includes(nodeName)).map(edge =&gt; edge.filter(node =&gt;<br/>     node != nodeName)[0]).map(name =&gt;<br/>          findNode(name, vertices)).filter(node =&gt;<br/>              node.distance == null)<br/>}</span></pre></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="d917" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">分解</strong></h2><p id="7004" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh kl li lj lk kp ll lm ln kt lo lp lq lr ig bi translated">让我们一步一步地分解它。我喜欢用“如果(y)/这些/那些”来代替所有的箭头。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="a2a9" class="kc kd in mn b gy mr ms l mt mu">return edges.filter(edge =&gt; edge.includes(nodeName))</span></pre><p id="322b" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">^返回所有的边(这是数组中的两组锚点)<em class="mw">，如果这两个点包含节点名，我们当前已经将节点名设置为字符串“myhouse”。记住过滤器迭代器会自动返回一个数组，所以这就是我们目前正在做的事情。</em></p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="fc05" class="kc kd in mn b gy mr ms l mt mu">edges = [<br/>['myhouse', 'momanddad'],<br/>['momanddad', 'niece1'],<br/>['momanddad', 'nephew'],<br/>['myhouse', 'inlaws'],<br/>['inlaws', 'kid2'],<br/>['inlaws', 'kid1']<br/>]</span><span id="44ed" class="kc kd in mn b gy mv ms l mt mu">//after above line of code<br/>RETURNS<br/>[['myhouse', 'inlaws'],['myhouse', 'momanddad']]</span></pre><p id="7b5d" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">然后，获取返回值，并映射它</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="e9f2" class="kc kd in mn b gy mr ms l mt mu">.map(edge =&gt; edge.filter(node =&gt; node != nodeName)[0])</span></pre><p id="165a" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">遍历每组边，取每个节点，如果节点不等于给定的节点名，则过滤它们<em class="mw">。</em></p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="1d3f" class="kc kd in mn b gy mr ms l mt mu">//examine each set<br/>['myhouse', 'momanddad']<br/>['myhouse', 'inlaws']<br/>//filter that array for nodes if it DOES NOT MATCH, therefore we are left with an array of:</span><span id="ae13" class="kc kd in mn b gy mv ms l mt mu">RETURNS<br/>['inlaws', 'momanddad']</span></pre><p id="bedc" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">现在来映射这个数组，这次返回数组中每一项的对象节点。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="bb7a" class="kc kd in mn b gy mr ms l mt mu">.map(name =&gt; findNode(name, vertices))</span><span id="f623" class="kc kd in mn b gy mv ms l mt mu">Goes thru <br/>'inlaws'</span><span id="a8b4" class="kc kd in mn b gy mv ms l mt mu">performs findNode on it ('inlaws', vertices)<br/>RETURNS from the vertices list<br/>{name: 'inlaws', distance: null, predecessor: null}</span><span id="1e34" class="kc kd in mn b gy mv ms l mt mu">Moves to<br/>'momanddad'<br/>RETURNS<br/>{name: 'momanddad', distance: null, predecessor: null}</span></pre><p id="8d01" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">请记住，MAP返回一个数组，因此我们的实际返回结果如下所示:</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="5250" class="kc kd in mn b gy mr ms l mt mu">[{name: 'momanddad', distance: null, predecessor: null}, {name: 'inlaws', distance: null, predecessor: null}]</span></pre><p id="a62f" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">最后，如果 node.distance为空，则过滤数组<em class="mw">。这意味着该节点尚未被浏览。一旦节点被探索，我们将增加它的距离。稍后会详细介绍。</em></p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="a9bb" class="kc kd in mn b gy mr ms l mt mu">.filter(node =&gt; node.distance == null})</span><span id="6391" class="kc kd in mn b gy mv ms l mt mu">So we filter this array to ensure that all the distances are null. They are indeed NULL -- <br/>RETURNS<br/>[{name: 'momanddad', distance: null, predecessor: null}, {name: 'inlaws', distance: null, predecessor: null}]</span></pre></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="f81a" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated"><strong class="lb io">探索—标记距离和前任</strong></p><p id="eaee" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">现在我们需要一种方法来知道一个(或多个)节点已经被浏览。所以我们需要一个方法，标记与前一个节点的距离，使前一个节点成为前任。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="eb9c" class="kc kd in mn b gy mr ms l mt mu">function explored(node, adjacentNodes){<br/>     const current = node<br/>     adjacentNodes.forEach(node =&gt; {<br/>          node.distance = current.distance + 1<br/>          node.predecessor = current<br/>     })<br/>     return adjacentNodes<br/>}</span></pre><p id="e8f3" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">重要的是要注意我们在这里传递给这个函数的参数是什么。在这种情况下—“节点”是一个完整的对象，看起来像这样:</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="5c1b" class="kc kd in mn b gy mr ms l mt mu">{name: 'myhouse', distance: null, predecessor: null}</span></pre><p id="ead0" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">adjacentNodes看起来像findAdjacent函数的返回值。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="7f3f" class="kc kd in mn b gy mr ms l mt mu">[{name: 'momanddad', distance: null, predecessor: null}, {name: 'inlaws', distance: null, predecessor: null}]</span></pre><p id="17f8" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">在我们执行了所研究的函数之后，下面是返回值:</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="9eb3" class="kc kd in mn b gy mr ms l mt mu">[{  name: 'momanddad',<br/>    distance: 1,<br/>    predecessor: { name: 'myhouse', distance: null, predecessor: null }<br/> },<br/> {  name: 'inlaws',<br/>    distance: 1,<br/>    predecessor: { name: 'myhouse', distance: null, predecessor: null }<br/>}]</span></pre></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="822c" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated"><strong class="lb io">广度优先搜索算法</strong></p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="b227" class="kc kd in mn b gy mr ms l mt mu">function bfs(startingNode, vertices, edges){<br/>     startingNode.distance = 0<br/>     let queue = [startingNode]<br/>     let discovered = [startingNode]<br/>     <br/>     while(queue.length != 0){<br/>          let currentNode = queue.shift()<br/>          let adjacentNodes = findAdjacent(currentNode.name, vertices, edges)<br/>          discovered = discovered.concat(adjacentNodes);<br/>          explored(currentNode, adjacentNodes)<br/>          queue = queue.concat(adjacentNodes)<br/>     }</span><span id="d20c" class="kc kd in mn b gy mv ms l mt mu">     return discovered<br/>}</span></pre><p id="3d58" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">好的。我们来解构一下这个。</p><p id="556b" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">首先，让我们将startingNode.distance设置为0，因此在我们探索的方法中，我们不会尝试将1加到null。非常简单，但这是新的根节点对象:</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="b92e" class="kc kd in mn b gy mr ms l mt mu">{name: 'myhouse', distance: 0, predecessor: null}</span></pre><p id="f5dc" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">然后，我们创建一个队列，这样我们就知道下一步要探索哪个节点。我们用startingNode创建队列。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="bc6a" class="kc kd in mn b gy mr ms l mt mu">let queue = [startingNode]</span><span id="df14" class="kc kd in mn b gy mv ms l mt mu">//or more visually...</span><span id="0164" class="kc kd in mn b gy mv ms l mt mu">queue = [{name: 'myhouse', distance: 0, predecessor: null}]</span></pre><p id="5f16" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">然后创建一个发现的数组或用于按发现顺序输出节点的数组，它看起来与队列相同。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="a4d6" class="kc kd in mn b gy mr ms l mt mu">let discovered = [startingNode]</span></pre><p id="423a" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">根据队列长度开始循环:</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="1c01" class="kc kd in mn b gy mr ms l mt mu">while(queue.length != 0){</span></pre><p id="189f" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">将当前节点设置为队列中的第一个节点。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="af74" class="kc kd in mn b gy mr ms l mt mu">let currentNode = queue.shift()</span></pre><p id="d97a" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">浏览当前节点的相邻节点(也称为添加距离和前任节点)</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="1b95" class="kc kd in mn b gy mr ms l mt mu">let adjacentNodes = explored(currentNode.name, vertices, edges)</span></pre><p id="1a7b" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">请注意，这将返回一个对象数组。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="8107" class="kc kd in mn b gy mr ms l mt mu">RETURNS<br/>adjacentNodes = [<br/>  { name: 'momanddad', distance: null, predecessor: null },<br/>  { name: 'inlaws', distance: null, predecessor: null }<br/>]</span></pre><p id="2eb8" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">然后，我们将它们添加到将打印的已发现节点列表中。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="f08a" class="kc kd in mn b gy mr ms l mt mu">discovered = discovered.concat(adjacentNodes);</span></pre><p id="0ba6" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">并标记已被探索过。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="f73b" class="kc kd in mn b gy mr ms l mt mu">explored(currentNode, adjacentNodes)</span><span id="1337" class="kc kd in mn b gy mv ms l mt mu">RETURNS<br/>[<br/>  {<br/>    name: 'momanddad',<br/>    distance: 1,<br/>    predecessor: { name: 'myhouse', distance: 0, predecessor: null }<br/>  },<br/>  {<br/>    name: 'inlaws',<br/>    distance: 1,<br/>    predecessor: { name: 'myhouse', distance: 0, predecessor: null }<br/>  }<br/>]</span></pre><p id="0c9b" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">将相邻节点添加到队列中，以便可以浏览它们的相邻节点(nephew1、nephew1、kid1、kid2)</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="ea0d" class="kc kd in mn b gy mr ms l mt mu">queue = queue.concat(adjacentNodes)</span></pre><p id="44d4" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">最后，按顺序返回列表。</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="0d56" class="kc kd in mn b gy mr ms l mt mu">return discovered<br/>RETURNS<br/>[<br/>  { name: 'myhouse', distance: 0, predecessor: null },<br/>  {<br/>    name: 'momanddad',<br/>    distance: 1,<br/>    predecessor: { name: 'myhouse', distance: 0, predecessor: null }<br/>  },<br/>  {<br/>    name: 'inlaws',<br/>    distance: 1,<br/>    predecessor: { name: 'myhouse', distance: 0, predecessor: null }<br/>  },<br/>  {<br/>    name: 'niece1',<br/>    distance: 2,<br/>    predecessor: { name: 'momanddad', distance: 1, predecessor: [Object] }<br/>  },<br/>  {<br/>    name: 'nephew',<br/>    distance: 2,<br/>    predecessor: { name: 'momanddad', distance: 1, predecessor: [Object] }<br/>  },<br/>  {<br/>    name: 'kid2',<br/>    distance: 2,<br/>    predecessor: { name: 'inlaws', distance: 1, predecessor: [Object] }<br/>  },<br/>  {<br/>    name: 'kid1',<br/>    distance: 2,<br/>    predecessor: { name: 'inlaws', distance: 1, predecessor: [Object] }<br/>  }<br/>]</span></pre><p id="01fc" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">对于更简单的打印输出，您总是可以这样做:</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="5030" class="kc kd in mn b gy mr ms l mt mu">bfs(startingNode, vertices, edges).map(node =&gt; node.name)</span></pre><p id="fc28" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">它将返回:</p><pre class="lt lu lv lw gt mm mn mo mp aw mq bi"><span id="234c" class="kc kd in mn b gy mr ms l mt mu">[<br/>  'myhouse',<br/>  'momanddad',<br/>  'inlaws',<br/>  'niece1',<br/>  'nephew',<br/>  'kid2',<br/>  'kid1'<br/>]</span></pre><p id="c3c6" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">就是这样！现在深呼吸。我是说呼吸。我不建议你住得离家人那么近，除非你“明白”自己在做什么。是的，我去过那里。</p><p id="888a" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated">代码打开！~凯尔西</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="0d34" class="pw-post-body-paragraph kz la in lb b lc ma jo le lf mb jr lh kl mc lj lk kp md lm ln kt me lp lq lr ig bi translated"><em class="mw">代码信用&amp;许可信息:https://github.com/learn-co-students/bfs-lab-g-416</em></p></div></div>    
</body>
</html>