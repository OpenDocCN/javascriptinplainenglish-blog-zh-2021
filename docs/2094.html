<html>
<head>
<title>Validating a Sudoku Board in JavaScript: A Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript验证数独板:深潜</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-validate-a-sudoku-board-a-deep-dive-72d94d292cb3?source=collection_archive---------7-----------------------#2021-05-03">https://javascript.plainenglish.io/how-to-validate-a-sudoku-board-a-deep-dive-72d94d292cb3?source=collection_archive---------7-----------------------#2021-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e92f76a3dd95884019bae3aa96e47c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9iUGaT-NSSVo8vYHD2Cqg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Winkler</a> on <a class="ae jz" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6062" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有时，我喜欢在网上查看一些编码挑战，看看我是否能找到问题的解决方案。</p><p id="897e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，我遇到了一个练习题，目标是确定数独板是否有效。这正合我的胃口，因为我喜欢数独和一个很好的挑战。这些挑战可以成为学习新技能甚至准备面试的绝佳资源。我将回顾如何理解这些问题，提供一个详细解释的解决方案，并以一些额外的资源结束。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="bf4d" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">概观</h1><ul class=""><li id="938a" class="md me in kc b kd mf kh mg kl mh kp mi kt mj kx mk ml mm mn bi translated">理解问题</li><li id="96ef" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">解答—行、列和网格</li><li id="e0e4" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">结论和附加资源</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="c4c6" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">理解问题</h1><p id="113c" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">这无疑是开发解决方案最重要的部分。如果你没有完全理解这个问题，你就不能完全找到解决这个问题的方法。</p><p id="7a58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于如何理解这些问题，我有一套体系。</p><ul class=""><li id="3dfc" class="md me in kc b kd ke kh ki kl mw kp mx kt my kx mk ml mm mn bi translated">不要立即开始编写代码或思考解决方案。至少把问题慢慢读两遍。</li><li id="4a65" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">输入——它们是什么？它们如何与你正在使用的语言相对应？</li><li id="ab87" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">边缘案例——您可能没有涵盖的场景有哪些？你能针对边缘情况进行测试吗？</li><li id="25bd" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">输出—将输入转换为期望的输出需要什么？需要什么类型的操作？</li></ul><h2 id="c92e" class="mz lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">问题是</h2><figure class="nm nn no np gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/c41bcb3f60e0eeef6d16edd95fa49a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDUEKbO74pB9hjHJe9X43w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">By Tim Stellmach, Wikimedia Commons</figcaption></figure><ul class=""><li id="b28e" class="md me in kc b kd ke kh ki kl mw kp mx kt my kx mk ml mm mn bi translated">每一行必须包含数字1-9，不能有重复的数字</li><li id="67bb" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">每列必须包含数字1-9，不能有重复的数字</li><li id="34b7" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">每个3x3网格必须包含数字1–9，不能有重复的数字</li></ul><p id="f2cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">棋盘(输入)是一个数组的数组。每个数组包含行的“数字”,空格用“.”表示。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="5299" class="mz lg in nr b gy nv nw l nx ny">[["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]</span></pre><p id="7c19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果板是有效的，输出应该是指示<code class="fe nz oa ob nr b">true</code>的布尔值，否则它应该返回<code class="fe nz oa ob nr b">false</code>。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="33a9" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解决办法</h1><p id="117b" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">所以分解这个过程。</p><p id="d4c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">输入— </strong>我们可以看问题，看到一个数组的数组。这非常适合JavaScript，因为我们可以利用像<code class="fe nz oa ob nr b">filter()</code>这样的内置操作，并且我们可以只用数组来完成大部分工作。</p><p id="2f7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">输出— </strong>我们只需要一个布尔型的输出，它很容易返回一个简单的真或假。我们还可以利用这个简单的输出来分而治之地进行验证。例如，如果行有效，则返回true。如果第<em class="oc">行和第</em>列有效，则返回true。当然，最后，如果行、列<em class="oc">和</em>网格是有效的，那么整个棋盘也是有效的。这是我们将要采取的方法。</p><h2 id="d44a" class="mz lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">行</h2><p id="e823" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">验证行是最容易验证的，也是最容易开始的。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="e471" class="mz lg in nr b gy nv nw l nx ny">var isValidSudoku = function (board) {<br/>  const validated = [];</span><span id="23ba" class="mz lg in nr b gy od nw l nx ny">  board.forEach((row) =&gt; {<br/>    // filter out empty spaces<br/>    const digits = row.filter((character) =&gt; character !== '.');<br/>    const isValid = digits.length === [...new Set(digits)].length;</span><span id="aa36" class="mz lg in nr b gy od nw l nx ny">    validated.push(isValid);<br/>  });</span><span id="78d8" class="mz lg in nr b gy od nw l nx ny">  return validated.every((value) =&gt; value === true);<br/>};</span></pre><p id="1882" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这看起来相当简单明了，但是让我们来分析一下到底发生了什么。</p><ol class=""><li id="2976" class="md me in kc b kd ke kh ki kl mw kp mx kt my kx oe ml mm mn bi translated">我们创建一个空数组，最终将保存九个布尔值(每行一个)</li><li id="6352" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">首先，我们过滤掉空格，因为我们不关心它们，我们只想要数字。</li><li id="afd6" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">检查<code class="fe nz oa ob nr b">digits</code>的长度是否等于一套新<code class="fe nz oa ob nr b">digits</code>的长度。如果长度相同，则为真，该行有效。</li><li id="d025" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">然后，我们将该值推送到<code class="fe nz oa ob nr b">validated</code>数组。</li><li id="0dc2" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">如果<code class="fe nz oa ob nr b">validated</code>数组中的所有值都为真，那么这些行是有效的。</li></ol><h2 id="8061" class="mz lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">列</h2><p id="68c7" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">现在已经验证了这些行，我们已经完成了三分之一。列是要验证的下一个业务顺序，但是它们稍微复杂一些。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="54df" class="mz lg in nr b gy nv nw l nx ny">const validate = (array) =&gt; {<br/>  // filter out empty spaces<br/>  const digits = array.filter((character) =&gt; character !== '.');<br/>  return digits.length === [...new Set(digits)].length;<br/>};</span><span id="a273" class="mz lg in nr b gy od nw l nx ny">var isValidSudoku = function (board) {<br/>  const validated = [];</span><span id="aa38" class="mz lg in nr b gy od nw l nx ny">  board.forEach((row, rowIndex) =&gt; {<br/>    //rows<br/>    validated.push(validate(row));</span><span id="a50d" class="mz lg in nr b gy od nw l nx ny">    //columns<br/>    const column = [];<br/>    for (let columnIndex = 0; columnIndex &lt; board.length; columnIndex++) {<br/>      column.push(board[columnIndex][rowIndex]);<br/>    }</span><span id="a93e" class="mz lg in nr b gy od nw l nx ny">    validated.push(validate(column));<br/>  });</span><span id="db96" class="mz lg in nr b gy od nw l nx ny">  return validated.every((value) =&gt; value === true);<br/>};</span></pre><ol class=""><li id="779b" class="md me in kc b kd ke kh ki kl mw kp mx kt my kx oe ml mm mn bi translated">首先，我们将过滤和比较(验证)移到了它自己的<code class="fe nz oa ob nr b">validate</code>函数中。我们将对行、列和网格使用这个函数，您很快就会看到。</li><li id="6a93" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">创建一个<code class="fe nz oa ob nr b">column</code>数组，其中for循环将使用行和列索引将值推入列数组。</li><li id="aa10" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">一旦<code class="fe nz oa ob nr b">column</code>有了所有的值，就使用<code class="fe nz oa ob nr b">validate</code>函数对其进行验证，并将其推入到验证过的数组中。</li><li id="884e" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">如果<code class="fe nz oa ob nr b">validated</code>数组中的所有值都为真，则行和列有效。</li></ol><p id="fe1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这让我们几乎一路验证电路板。然而，我们仍然需要验证网格。</p><h2 id="0c8f" class="mz lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">网格</h2><p id="52d7" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们现在已经验证了数独棋盘三分之二的场景。现在，验证数独板最困难的部分是3x3网格。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="9af1" class="mz lg in nr b gy nv nw l nx ny">// validate function from previous code block removed for easier reading</span><span id="f006" class="mz lg in nr b gy od nw l nx ny">var isValidSudoku = function (board) {<br/>  const [validated, grids] = [[], []];</span><span id="b7a8" class="mz lg in nr b gy od nw l nx ny">  board.forEach((row, rowIndex) =&gt; {<br/>    // rows<br/>    validated.push(validate(row));</span><span id="0ae9" class="mz lg in nr b gy od nw l nx ny">    // columns<br/>    const column = [];<br/>    for (let columnIndex = 0; columnIndex &lt; board.length; columnIndex++) {<br/>      column.push(board[columnIndex][rowIndex]);<br/>    }<br/>    validated.push(validate(column));</span><span id="e729" class="mz lg in nr b gy od nw l nx ny">    //grids<br/>    grids.push([]);<br/>  });</span><span id="bca5" class="mz lg in nr b gy od nw l nx ny">  //grids<br/>  board.forEach((row, rowIndex) =&gt; {<br/>    row.forEach((character, charIndex) =&gt; {<br/>      let gridRow = 0;<br/>      if (rowIndex &gt;= 3 &amp;&amp; rowIndex &lt;= 5) {<br/>        gridRow = 1;<br/>      } else if (rowIndex &gt;= 6 &amp;&amp; rowIndex &lt;= 8) {<br/>        gridRow = 2;<br/>      }</span><span id="f805" class="mz lg in nr b gy od nw l nx ny">      if (charIndex &gt;= 3 &amp;&amp; charIndex &lt;= 5) {<br/>        gridRow += 3;<br/>      } else if (charIndex &gt;= 6 &amp;&amp; charIndex &lt;= 8) {<br/>        gridRow += 6;<br/>      }</span><span id="dd31" class="mz lg in nr b gy od nw l nx ny">      grids[gridRow].push(character);<br/>    });<br/>  });</span><span id="0cd4" class="mz lg in nr b gy od nw l nx ny">  grids.forEach((grid) =&gt; {<br/>    validated.push(validate(grid));<br/>  });</span><span id="9e14" class="mz lg in nr b gy od nw l nx ny">  return validated.every((value) =&gt; value === true);<br/>};</span></pre><ol class=""><li id="fd31" class="md me in kc b kd ke kh ki kl mw kp mx kt my kx oe ml mm mn bi translated">第一步是使用数组析构将一个空数组赋给<code class="fe nz oa ob nr b">validated</code>和<code class="fe nz oa ob nr b">grids</code>变量。</li><li id="8c11" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">在一行的每次迭代中，我们将一个空数组推入到<code class="fe nz oa ob nr b">grids</code>数组中。</li><li id="fb37" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx oe ml mm mn bi translated">现在最困难的部分是填充这些网格阵列。一个视觉可能会有很大帮助，这是下面。因此，如果<code class="fe nz oa ob nr b">charIndex</code>在0和2之间，我们不会给<code class="fe nz oa ob nr b">girdRow</code>变量添加任何值。然而，如果<code class="fe nz oa ob nr b">charIndex</code>在3和5之间，那么这些值在新的列中，并且<code class="fe nz oa ob nr b">gridRow</code>的值应该增加3。同样的想法也适用于当<code class="fe nz oa ob nr b">charIndex</code>在6和8之间时，它在最后一列，gridRow应该增加6。</li></ol><figure class="nm nn no np gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/0b67cc7076fd2b3313a91757566b57eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfXaE16d0xCDz0AzmKV74A.png"/></div></div></figure><p id="3d76" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.现在我们可以迭代<code class="fe nz oa ob nr b">grids</code>中的每个数组，并将验证过的数组推送到<code class="fe nz oa ob nr b">validated</code>数组</p><p id="b575" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.如果<code class="fe nz oa ob nr b">validated</code>数组中的所有值都为真，那么行、列和网格都有效。</p><p id="68e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就结束了整个解决方案。我们已经解决了每种情况，验证了行、列、网格，并确定了整个棋盘是否有效。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="fe62" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论和附加资源</h1><p id="79c5" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我希望您学到了一些关于如何应对这些类型的编码挑战的有价值的东西。如果你想看看这个特别的挑战，你可以在<a class="ae jz" href="https://leetcode.com/problems/valid-sudoku/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>上查看。LeetCode将为您提供运行时和内存使用的分析，并与其他用户提交的数据进行比较。上面的解决方案非常高效，比其他92.86%的JavaScript提交都要快。</p><figure class="nm nn no np gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/f497c54033272a8d04094549adeba096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akz7ZeDPFhbSBbsll407hA.png"/></div></div></figure><p id="a3a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码也可以在我的<a class="ae jz" href="https://github.com/tengel92/Medium" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上找到。可以拉回购运行<code class="fe nz oa ob nr b">npm install</code>。安装完依赖项后，您可以查看<code class="fe nz oa ob nr b">valid-sudoku.js</code>并使用<code class="fe nz oa ob nr b">npm run js:sudoku</code>运行该文件。下面是一个GitHub要点，包含了我们在文章中讨论过的代码。</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="96c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="oc">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>