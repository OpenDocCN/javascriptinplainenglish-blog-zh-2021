<html>
<head>
<title>Advanced TypeScript Type Guards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级打字稿类型保护</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-advanced-type-guards-7a2b7354b819?source=collection_archive---------7-----------------------#2021-05-07">https://javascript.plainenglish.io/typescript-advanced-type-guards-7a2b7354b819?source=collection_archive---------7-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e4c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何确定车辆是汽车？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/7bafab185daf876059eeec5eddb6f908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*7Zh4wEiM_3t-6XPCAfC7aA.png"/></div></figure><p id="2153" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我重温了TypeScript文档，以刷新我对已知内容的记忆，并检查我不知道的内容。我想在我做完那件事之后，分享我的发现会很好。</p><p id="e75d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我从Type Guards开始，但是我想创作更多与高级TypeScript相关的文章(或者至少是文档中所说的高级水平)。今天我将集中讨论区分类型的方法。所以，事不宜迟，让我们开始吧。</p><h2 id="2e2c" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated"><strong class="ak">区分类型</strong></h2><p id="504c" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我们将试图解决的问题是一个常见的情况。该方法接收某个泛型类型作为参数，在我们的例子中是<code class="fe mh mi mj mk b">Vehicle</code>，然后尝试使用更具体类型的属性，<code class="fe mh mi mj mk b">fly</code>用于<code class="fe mh mi mj mk b">Plane</code>，而<code class="fe mh mi mj mk b">drive</code>用于<code class="fe mh mi mj mk b">Car</code>。</p><p id="2f24" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">那么如何才能从题目中回答问题呢？<em class="ml">如何确定车辆是汽车？如何缩小一个类型的范围？我们来看看两个接口<code class="fe mh mi mj mk b">Car</code>和<code class="fe mh mi mj mk b">Plane</code>，类型<code class="fe mh mi mj mk b">Vehicle</code>和方法<code class="fe mh mi mj mk b">goTo</code>。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/d302ff1d7b619a2d29349b87d2195573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NDBT1iNDNFW6HUXBjiUYw.png"/></div></div></figure><p id="fb76" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe mh mi mj mk b">goTo</code>是当我们的车辆是<code class="fe mh mi mj mk b">Car</code>或<code class="fe mh mi mj mk b">Plane</code>时我们想要使用的方法，以便调用适当的行驶方法。</p><p id="cf8e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，方法<code class="fe mh mi mj mk b">goTo</code>无法区分<code class="fe mh mi mj mk b">vehcicle</code>是<code class="fe mh mi mj mk b">Car</code>还是<code class="fe mh mi mj mk b">Plane</code>，我们只能对两个接口使用相同的属性。回到我们的问题:我们如何区分它们？我们如何检查接口中成员的存在？我们必须保证一个成员的存在，我们可以使用类型保护来实现。</p><p id="0f7f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="ml">类型保护是一个执行运行时检查的表达式，它保证类型在某个范围内。</em></p><p id="ae91" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看看如何使用不同的类型:</p><p id="34f1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">使用操作器</strong>中的<em class="ml"/></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mr"><img src="../Images/e931ff78898db9565effe1dbc5975d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSRnumF5qus-cp4VotAdPw.png"/></div></div></figure><p id="7311" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">属性访问器</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ms"><img src="../Images/810e1f9404d9918e642c721951928689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkROIazvgKhbuAk2PRll8g.png"/></div></div></figure><p id="f62e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我看来，这不是最好的方法，因为在你说(cast)运载工具是飞机或汽车(第15-16行)之后，你可能会失去验证，并且可以毫无意义地调用使用对象的属性(第22行)。</p><h2 id="da9d" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated"><strong class="ak">自定义类型防护</strong></h2><p id="a9de" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">首先，我们必须定义一个函数，它的返回类型谓词:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mt"><img src="../Images/ea2867e513f26bf1e5e05132dd2523e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u03uWLTWAyEE4kyKxnV_Xw.png"/></div></div></figure><p id="0464" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">请注意我们所说的返回类型，即我们期望的确切类型(<code class="fe mh mi mj mk b">parameterName is Type</code>)</p><p id="8d87" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后我们可以这样使用它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/92cb08dda6ea2fa43a5dda7aad05de45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*0LsuMjKG8m07liwj5_MQ1Q.png"/></div></figure><p id="2ad0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这保证了更具体的类型。这种方式增加了可读性，并允许我们再次使用<code class="fe mh mi mj mk b">isPlane</code>函数进行过滤:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mv"><img src="../Images/c4c9d4c153ed246bdc0d010072d17aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vondxmDJSR-pXXhk9dBduQ.png"/></div></div></figure><h2 id="799c" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated"><strong class="ak">其他类型的防护装置</strong></h2><p id="b6e4" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">除了我上面描述的方法，我们还有另外两种区分类型的方法:</p><p id="d9f8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">类型的</strong></p><p id="e9a3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们试着检查一个变量是不是某种原始类型(<code class="fe mh mi mj mk b">number</code>、<code class="fe mh mi mj mk b">string</code>等等)。要做到这一点，你不必写一个特殊的函数，你只需使用关键字<code class="fe mh mi mj mk b">typeof</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/88e5955c7c727b2e34243468f4c7c25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*TNLjNASBBb68JOXcw-GvZg.png"/></div></figure><p id="8e35" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">实例of </strong></p><p id="d28c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">instanceof type guard用于使用构造函数缩小类型，类似于它在JavaScript中的工作方式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mx"><img src="../Images/fb8d3dbe87d0cfb52cb6a6166d74aa8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-T-rthJpg1QrhPcNCfnt9Q.png"/></div></div></figure><p id="3adc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如你所见，<code class="fe mh mi mj mk b">instanceof</code>的右边是一个构造函数。然后，在条件(第86行)中，我们知道图形属于<code class="fe mh mi mj mk b">Square</code>类型，因此我们可以为该类型使用任何特定的属性。</p><h2 id="9e11" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated"><strong class="ak">收尾思路</strong></h2><p id="4350" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我更喜欢使用一个用户定义的类型保护，带有一个定义的函数，它的返回类型是谓词，用于基本类型<code class="fe mh mi mj mk b">typeof</code>。为什么？在我看来，这种方式增加了可读性。</p><p id="e620" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">玩一会儿。自己尝试不同的东西！</p><p id="8a5d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">推特</strong>:<a class="ae my" href="https://twitter.com/k_wdowik" rel="noopener ugc nofollow" target="_blank"><em class="ml">k _ wdowik</em></a></p><p id="4209" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="ml">更多内容请看</em><a class="ae my" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ml">plain English . io</em></a></p></div></div>    
</body>
</html>