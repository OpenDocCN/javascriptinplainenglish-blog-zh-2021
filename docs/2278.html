<html>
<head>
<title>15 Ways to Improve the Performance of Your React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高React应用程序性能的15种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/15-ways-to-improve-the-performance-of-your-react-application-459c93904eaf?source=collection_archive---------6-----------------------#2021-05-12">https://javascript.plainenglish.io/15-ways-to-improve-the-performance-of-your-react-application-459c93904eaf?source=collection_archive---------6-----------------------#2021-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cd60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发高性能应用程序必须遵循的原则。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/66f1e8929005214202313710922f6214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2NkuXz7Le_xAngT86T4Sg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Banner Image inspired from Canva</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="cc4c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">入门指南</h1><p id="b8b9" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我不会花太多时间来介绍这个话题。因此，让我们直接进入提高性能的方法。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="9fb9" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">使用onBlur从输入值</strong>更新状态</h1><p id="a2bb" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">比起直接从input元素更新state或redux store，我更喜欢使用onBlur属性而不是onChange。onChange严重地造成了许多性能问题，尤其是在与redux一起使用时，所以要尽量避免。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c714" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">静态组件的用户纯组件</h1><p id="1278" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">如果你确定任何特定的子组件是静态的，或者不会频繁地改变，那么就把它作为一个纯组件。这避免了荒谬地重新呈现甚至不需要的特定组件。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="3fd1" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用记忆优先摇晃树</h1><p id="5120" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">内存化意味着缓存结果以提高性能。使用useMemo钩子或其他方式来记忆组件基本上就是在虚拟DOM中缓存组件节点，并且只在特定组件的状态或属性改变时更新。这在处理大型列表集时非常有效。我更喜欢使用列表中的每一项，这样React DOM就可以执行树抖动。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="ad0c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在React挂钩或componentshouldUpdate方法中使用条件呈现</h1><p id="cda6" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">无论是使用类组件还是功能组件，都要确保在useEffect或componentShouldUpdate方法中提供有条件的重新呈现。大多数时候，我们会忘记处理它，即使我们知道这可能会导致不必要的重新渲染。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="acb3" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在处理大量图像时使用延迟加载</h1><p id="e2f3" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我已经报道了一个关于Next.js的新图像组件的故事。我不知道我们如何在React Native中使用它，但在React中，总是喜欢延迟加载，特别是当你的应用程序有大量文件渲染时。</p><div class="ml mm gp gr mn mo"><a href="https://medium.com/nerd-for-tech/a-perfect-way-to-load-images-in-react-f730d00119bf" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">在React中加载图像的完美方式</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">在下一个JS中使用图像，缓存和延迟加载——正确的方法</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc kv mo"/></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5e27" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">更喜欢分页，而不是获取所有数据</h1><p id="caf0" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">这很容易理解，但是我们仍然避免使用这种现象。提供分页对你的产品的商业方面有影响，因为你的用户很少去第3或第4页，除非你的网站是亚马逊。但是，快速加载10个项目比在10-20秒内加载20 -30个项目要好得多。此外，获取前10项比获取所有项要快得多。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="7ef8" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">首选GraphQL以避免过度获取数据</h1><p id="e316" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">当我在开发比特币和其他货币的图表时，我明白了为什么我们的图表速度慢且有点滞后的主要问题。这是因为我们过度获取数据。对于我来说，过度获取前端不需要的键值对毫无意义。无论如何，我们最终对REST端点进行了GraphQL查询，这将我们的应用程序性能提高了40%。这太棒了。</p><div class="ml mm gp gr mn mo"><a rel="noopener  ugc nofollow" target="_blank" href="/calling-rest-api-inside-graphql-queries-e715c0f2da44"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">在GraphQL查询中调用REST API</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">您不需要将我们的后端从REST切换到GraphQL，而是在Graph QL中获取REST查询。</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc kv mo"/></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="7b30" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">避免重新渲染，这是一个常见的错误</h1><p id="bb50" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">重新渲染或不必要的渲染在React应用程序中很常见。我不会详细介绍这一点，因为这是一个常见的错误，互联网上有大量的文章可供学习。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="8912" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">小心内存泄漏，尤其是在React Native中</h1><p id="e45b" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">这很重要。大多数情况下，当您的模拟器在开发过程中关闭时，这是因为内存泄漏。当JavaScript函数填满堆堆栈或执行无限循环时，就会发生内存泄漏。因此，请确保结束while或for循环，或者从您在任何组件中调用的函数返回一些值。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="07fc" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">如果使用Axios，请使用cancel token属性来避免过度调用API</h1><p id="a514" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我会报道一个关于此事的完整详细的新故事。Axios确实提供了一种取消令牌的方法来取消API请求，以防您已经创建了一个API。当你想频繁地调用API时，这是一个优化且有用的过程。例如用于搜索输入或过滤输入等。</p><p id="dfe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多信息:</p><div class="ml mm gp gr mn mo"><a href="https://github.com/axios/axios#cancellation" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">axios/axios</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">基于Promise的浏览器和node . js HTTP客户端新的axios docs网站:单击此处从…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="ne l mz na nb mx nc kv mo"/></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a963" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在useState中使用回调函数，而不是调用多个setState</h1><p id="0294" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">让我给你举个例子:</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="195f" class="nk lj iq ng b gy nl nm l nn no">const [ formValue, setFormValues ] = useState({<br/>  email: String,<br/>  password: String,<br/>  username: String,<br/>  rememberMe: Boolean<br/>});</span><span id="bad0" class="nk lj iq ng b gy np nm l nn no">function handleFormChange(e){<br/>  const name = e.target.name;<br/>  const val = e.target.value;<br/>  setFormValues(prev =&gt; ({...prev, [name]: val }))<br/>}</span></pre><p id="ffb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是使用setState函数中的回调来更新状态的最佳方式，而不是为每个要更新的状态值调用不同的set state。所以确保你以适当的方式使用了<strong class="jp ir">使用状态</strong>钩子。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="79cb" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">尽量不要给useEffect或componentDidMount以及构造函数方法施加太大的压力</h1><p id="b40e" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">大多数时候，我们更喜欢在componentDidMount或useEffect钩子中进行API调用。这是一个好主意，但是有时候，一个组件需要3-4个API请求。在这种情况下，我们的使用效果或组件已经超负荷或压力过大。即使您想发出3-4个API请求，也最好使用<code class="fe nq nr ns ng b"><strong class="jp ir">Axios.all</strong></code>方法，同时向用户显示一些数据获取指示器。以优先的方式按照特定的顺序进行API调用总是一个好方法。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="4ef7" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在React Native中，首选FlatList或SectionList，而不是map函数</h1><p id="d893" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我已经讲述了一个关于如何将FlatList用于记忆的项目以及惰性加载和分页属性的详细故事。这对React原生应用的性能非常重要。使用<strong class="jp ir"> ScrollView </strong>组件而不是FlatList确实会对性能领域产生影响。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a01f" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">测量页面呈现时间</h1><p id="4fe5" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我还在搜索第三方工具来测量React和React原生应用中每个页面的页面渲染时间。这对于分析应用程序的整体性能非常有帮助。了解每一个页面在初始呈现时所花费的时间，包括那些API调用的时间，将肯定有助于我们提高页面速度，方法是首先对最重要的组件进行优先级排序，并按照特定的顺序进行那些API调用。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="f231" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">最后，一定要提供映射项的键</h1><p id="54a4" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我们知道React使用虚拟DOM来区分或比较节点，React使用键值。如果您忘记提供密钥，那么所有项目都将被视为相同，React将无法区分。这使得虚拟DOM很难跟踪这些变化。不使用<strong class="jp ir">键</strong>来区分虚拟DOM和实际DOM意味着您没有以最有效的方式使用虚拟DOM属性，这又会导致性能问题。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a074" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="75b9" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">提高应用程序的性能并不是一件容易的事情。这确实需要大量的知识和对框架如何工作的理解。我强烈建议选择贵公司的绩效任务，因为它可以提高你的知识。</p><p id="a847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在以后的文章中介绍更多与性能相关的内容。因此，要获得更新或友好的链接，您可以订阅我们的周刊。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="96f5" class="nk lj iq ng b gy nl nm l nn no"><a class="ae nt" href="http://www.ihatereading.in/subscribe" rel="noopener ugc nofollow" target="_blank"><strong class="ng ir">Weekly magazine</strong></a></span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><div class="km kn ko kp gt mo"><a rel="noopener  ugc nofollow" target="_blank" href="/serverless-function-in-next-js-3cd0d22ab983"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">下一个JS中的无服务器功能</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">下一篇JS详细了解无服务器功能</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mx l"><div class="nu l mz na nb mx nc kv mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://medium.com/nerd-for-tech/best-redux-architecture-explained-in-5-minutes-9b993f0169c0" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">5分钟解释最佳Redux架构。</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">你每次都应该遵循的Redux架构。可扩展、高度可扩展且易于随时更换…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">medium.com</p></div></div><div class="mx l"><div class="nv l mz na nb mx nc kv mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a rel="noopener  ugc nofollow" target="_blank" href="/the-easiest-way-to-manage-token-and-created-protected-pages-in-frontend-c60db33f1921"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">管理令牌和创建的受保护页面的最简单方法</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">避免在Redux或LocalStorage中存储身份验证令牌，而是使用Cookies。</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mx l"><div class="nw l mz na nb mx nc kv mo"/></div></div></a></div><h2 id="f389" class="nk lj iq bd lk nx ny dn lo nz oa dp ls jy ob oc lw kc od oe ma kg of og me oh bi translated">进一步阅读</h2><div class="ml mm gp gr mn mo"><a rel="noopener  ugc nofollow" target="_blank" href="/5-tools-practices-to-help-you-develop-faster-in-react-b884c1b20fc2"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">帮助您在React中更快开发的5种工具和实践</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">React工具、技巧和最佳实践将帮助您更快地构建应用</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mx l"><div class="oi l mz na nb mx nc kv mo"/></div></div></a></div><p id="4d5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="oj">更多内容请看</em><a class="ae nt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="oj">plain English . io</em></strong></a><em class="oj">。报名参加我们的</em> <a class="ae nt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="oj">免费周报</em> </strong> </a> <em class="oj">。关注我们关于</em><a class="ae nt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="oj">Twitter</em></strong></a><a class="ae nt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="oj">LinkedIn</em></strong></a><em class="oj"/><a class="ae nt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="oj">YouTube</em></strong></a><em class="oj"/><a class="ae nt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="oj">不和</em> </strong> </a> <em class="oj">。</em></p></div></div>    
</body>
</html>