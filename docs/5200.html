<html>
<head>
<title>The JavaScript .at() Method Will Change the Way You Handle Strings and Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript。at()方法将改变你处理字符串和数组的方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-javascript-at-method-will-change-the-way-you-handle-strings-and-arrays-403bb68c5fe8?source=collection_archive---------5-----------------------#2021-10-22">https://javascript.plainenglish.io/the-javascript-at-method-will-change-the-way-you-handle-strings-and-arrays-403bb68c5fe8?source=collection_archive---------5-----------------------#2021-10-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jp jq jr js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi jo"><img src="../Images/109ff7612656d6ff79bb88f3ef27fc5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFP5Z53JPKAVT7Yx6LfjNQ.png"/></div></div></figure><p id="5e06" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">JavaScript <code class="fe jk jl jm jn b">.at()</code>方法是在ECMA International TC39的相对索引提案的8月发布中引入的，以允许开发人员基于他们的索引获取元素。</p><p id="c6c2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在JavaScript中选择元素是开发中经常发生的事情，但是，在引入<code class="fe jk jl jm jn b">.at()</code>方法之前，JavaScript已经有了从列表的开头或结尾或者在一个字符串中选择元素或字符的方法和技术。</p><p id="28c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">括号符号<code class="fe jk jl jm jn b">[]</code>通常用于获取特定索引处的元素。但是，这也有缺点。例如，我们不能使用像<code class="fe jk jl jm jn b">arr[-1]</code>这样的负索引语法来访问列表中的最后一项，这在Python中很流行。</p><p id="f9f5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，开发人员求助于使用<code class="fe jk jl jm jn b">slice()</code>方法和<code class="fe jk jl jm jn b">length</code>属性从列表末尾抓取项目。尽管如此，它们也有各自的缺点。</p><p id="b36d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在本教程中，我们将看看JavaScript <code class="fe jk jl jm jn b">.at()</code>方法，它的用例，以及与现有方法相比，它如何改善开发人员的体验。</p><h1 id="ab0e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">可索引对象原型</h1><p id="c93e" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated"><code class="fe jk jl jm jn b">.at()</code>方法位于可转位物体的<code class="fe jk jl jm jn b">prototype</code>上。</p><p id="28ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些可以制定索引条目的对象包括类似于<code class="fe jk jl jm jn b">Array</code>、<code class="fe jk jl jm jn b">String</code>和<code class="fe jk jl jm jn b">TypedArray</code>的类，它们分别是<code class="fe jk jl jm jn b">Array.prototype.at()</code>、<code class="fe jk jl jm jn b">String.prototype.at()</code>和<code class="fe jk jl jm jn b">%TypedArray%.prototype.at()</code>。</p><p id="dbff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，我们可以直接在这些可索引对象上执行<code class="fe jk jl jm jn b">.at()</code>方法。</p><h1 id="a887" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">获取列表元素的现有方法</h1><p id="63fe" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">为了了解<code class="fe jk jl jm jn b">.at()</code>方法的优势，我们将快速浏览一些现有的方法，以便进行比较。这也将作为初学者的复习。</p><p id="aa19" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们考虑一个名为<code class="fe jk jl jm jn b">arr</code>的元素数组:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="f0d4" class="mi ky in jn b gy mj mk l ml mm">const arr = [1, 2, "three", 4, 5, true, false];</span></pre><p id="4bac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过在<code class="fe jk jl jm jn b">arr</code>数组上使用括号符号<code class="fe jk jl jm jn b">[]</code>，我们可以获得特定索引处的元素。例如，<code class="fe jk jl jm jn b">arr[0]</code>返回第一个元素，<code class="fe jk jl jm jn b">1</code>，依此类推。但是，要从未知长度的末端获取一个项目，我们使用<code class="fe jk jl jm jn b">length</code>属性或<code class="fe jk jl jm jn b">slice()</code>方法。</p><h1 id="c68e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用<code class="fe jk jl jm jn b">length</code>属性</h1><p id="244a" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated"><code class="fe jk jl jm jn b">length</code>属性的语法编写如下:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="bbd9" class="mi ky in jn b gy mj mk l ml mm">arr[arr.length - N];</span></pre><p id="cf78" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里，<code class="fe jk jl jm jn b">N</code>等于从列表末尾开始的第n个元素，通过使用该语法，我们可以从列表末尾获取任何元素。</p><p id="2de0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在下面的代码中，我们使用语法来获取<code class="fe jk jl jm jn b">arr</code>数组的最后一个元素:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="8807" class="mi ky in jn b gy mj mk l ml mm">const arr = [1, 2, "three", 4, 5, true, false];<br/>const lastItem = arr[arr.length - 1];<br/>console.log(lastItem);  // Expected Output: false</span></pre><p id="c5af" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这样做很好，但是对于一个简单的任务来说，语法可能不方便而且很乏味。此外，在处理函数的返回值时，它的一个缺点是迫使我们在应用语法之前首先将返回值存储在一个变量中:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="4c8f" class="mi ky in jn b gy mj mk l ml mm">function appendNumber(arr, N) {<br/>  arr.push(N);<br/>  return arr;<br/>}<br/><br/>const tempArr = appendNumber([1, 2, "three", 4, 5, true, false], 6);<br/>console.log(tempArr[tempArr.length - 1]); // Expected Output: 6</span></pre><p id="82d5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码中，在应用<code class="fe jk jl jm jn b">length</code>属性之前，<code class="fe jk jl jm jn b">appendNumber()</code>函数的返回值首先存储在<code class="fe jk jl jm jn b">tempArr</code>变量中。</p><h1 id="4093" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe jk jl jm jn b">slice()</code>方法</h1><p id="cc5d" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">开发人员也可以<a class="ae mn" href="https://blog.logrocket.com/javascript-array-methods/slice" rel="noopener ugc nofollow" target="_blank">使用</a> <code class="fe jk jl jm jn b"><a class="ae mn" href="https://blog.logrocket.com/javascript-array-methods/slice" rel="noopener ugc nofollow" target="_blank">slice()</a></code> <a class="ae mn" href="https://blog.logrocket.com/javascript-array-methods/slice" rel="noopener ugc nofollow" target="_blank">方法</a>使用下面的语法抓取列表的最后一项:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="2064" class="mi ky in jn b gy mj mk l ml mm">arr.slice(-1)[0]</span></pre><p id="c604" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这种语法允许负索引，您将在本教程后面的<code class="fe jk jl jm jn b">.at()</code>方法中看到。</p><p id="71e3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里的负索引表示从数组末尾的偏移量。例如，<code class="fe jk jl jm jn b">slice(-1)</code>从后面删除最后一项并返回一个新数组；<code class="fe jk jl jm jn b">slice(-2)</code>删除最后两个，依此类推。</p><p id="a8e3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是在这里，焦点是最后一项，因此是语法中的<code class="fe jk jl jm jn b">slice(-1)</code>。然后，<code class="fe jk jl jm jn b">[0]</code>符号选择该索引处的项目。</p><p id="b56c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用该语法，我们可以获取<code class="fe jk jl jm jn b">arr</code>数组的最后一项，如下所示:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="2e70" class="mi ky in jn b gy mj mk l ml mm">const arr = [1, 2, "three", 4, 5, true, false];<br/><br/>console.log(arr.slice(-1)[0]); // Expected Output: false</span></pre><p id="de96" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">与上面的<code class="fe jk jl jm jn b">length</code>属性不同，这个方法不强迫我们在使用语法之前存储函数的返回值。因此使其更加灵活:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="037d" class="mi ky in jn b gy mj mk l ml mm">function appendNumber(arr, N) {<br/>  arr.push(N);<br/>  return arr;<br/>}<br/><br/>console.log(appendNumber([1, 2, "three", 4, 5, true, false], 6).slice(-1)[0]); // 6</span></pre><p id="1402" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">尽管如此，语法看起来很奇怪，没有描述它的意图。当然，这也很不方便。</p><h1 id="a3d2" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么不用<code class="fe jk jl jm jn b">arr[-1]</code>访问最后一个数组元素？</h1><p id="8307" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">这个问题经常出现在JavaScript初学者身上，尤其是如果他们来自Python这样的编程语言。</p><p id="2f6a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">JavaScript中的<code class="fe jk jl jm jn b">arr[-1]</code>符号是一个有效的对象属性。记住JavaScript中的一切，包括数组，都是对象。所以每当我们使用括号符号时，例如，<code class="fe jk jl jm jn b">arr[0]</code>，我们用键<code class="fe jk jl jm jn b">0</code>引用对象的属性。</p><p id="7df2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过重写对象符号中的<code class="fe jk jl jm jn b">arr</code>数组，我们得到了这样的结果:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="4ad9" class="mi ky in jn b gy mj mk l ml mm">const arr = {<br/>  0: 1,<br/>  1: 2,<br/>  3: "three",<br/>  // ...<br/>};<br/><br/>console.log(arr[0]); // Expected Output: 1</span></pre><p id="9c6e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码中，我们没有一个键<code class="fe jk jl jm jn b">-1</code>。所以，<code class="fe jk jl jm jn b">arr[-1]</code>返回一个值<code class="fe jk jl jm jn b">undefined</code>。如果对象属性有一个键<code class="fe jk jl jm jn b">-1</code>，如下面的代码所示，<code class="fe jk jl jm jn b">arr[-1]</code>将返回其相应的值:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="630b" class="mi ky in jn b gy mj mk l ml mm">const arr = {<br/>  "-1": "valid"<br/>};<br/><br/>console.log(arr[-1]); // Expected Output: valid</span></pre><p id="16e7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这意味着我们不能使用<code class="fe jk jl jm jn b">arr[-1]</code>来抓取最后一个元素，因为它已经是一个有效的语法了。为了使用负索引语法从列表末尾返回一个元素，我们将使用<code class="fe jk jl jm jn b">.at()</code>方法。</p><h1 id="6781" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe jk jl jm jn b">.at()</code>语法</h1><p id="29b4" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">当使用<code class="fe jk jl jm jn b">.at()</code>语法时，它接收要返回的项的索引。当传递负索引时，它从列表或字符串的末尾开始计数，并返回找到的项或字符。否则，返回<code class="fe jk jl jm jn b">undefined</code>:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="8b4c" class="mi ky in jn b gy mj mk l ml mm">at(index)</span></pre><h1 id="4535" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe jk jl jm jn b">.at()</code>实践中的方法</h1><p id="e1b8" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">如前所述，<code class="fe jk jl jm jn b">.at()</code>方法接收要返回的项目的索引。在这一节中，我们将讨论它的用例。</p><p id="1ce5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们重温一下<code class="fe jk jl jm jn b">arr</code>数组，看看<code class="fe jk jl jm jn b">.at()</code>方法如何让我们无缝返回一个索引元素:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="e046" class="mi ky in jn b gy mj mk l ml mm">const arr = [1, 2, "three", 4, 5, true, false];<br/><br/>console.log(arr.at(0)); // Expected Output: 1<br/>console.log(arr.at(2)); // Expected Output: "three"<br/>console.log(arr.at(-1)); // Expected Output: false<br/>console.log(arr.at(-3)); // Expected Output: 5</span></pre><p id="1b62" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当一个正索引传递给<code class="fe jk jl jm jn b">.at()</code>方法时，它返回该索引处的元素。对于负索引，它从列表中的最后一个元素开始倒数，并返回该元素。</p><p id="52bb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码中，<code class="fe jk jl jm jn b">at(-1)</code>从数组末尾开始计数1，并返回<code class="fe jk jl jm jn b">false</code>，这是找到的元素。同理，<code class="fe jk jl jm jn b">at(-3)</code>从末尾数三，返回<code class="fe jk jl jm jn b">5</code>。</p><p id="4763" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">像数组一样，我们可以对字符串做同样的事情:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="72fe" class="mi ky in jn b gy mj mk l ml mm">const str = "The last alphabet is z";<br/><br/>console.log(str.at(0)); // Expected Output: T<br/>console.log(str.at(-1)); // Expected Output: z</span></pre><p id="f1b3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">正如我们所见，这种方法使用起来很愉快。仅仅用<code class="fe jk jl jm jn b">.at(-1)</code>，我们就得到<code class="fe jk jl jm jn b">str</code>字符串的最后一个字符。如果我们对<code class="fe jk jl jm jn b">length</code>属性执行同样的任务，我们会有一个更长的语法，就像这样:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="a8ef" class="mi ky in jn b gy mj mk l ml mm">console.log(str[str.length - 1]); // Expected Output: z</span></pre><h1 id="8f4b" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">处理函数的返回值</h1><p id="5bb8" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">与<code class="fe jk jl jm jn b">length</code>属性不同的是，<code class="fe jk jl jm jn b">.at()</code>方法不会强迫我们在使用函数之前将返回值存储在变量中。</p><p id="37a2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面的代码输出推入数组的最后一个元素:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="9d55" class="mi ky in jn b gy mj mk l ml mm">function appendNumber(arr, N) {<br/>  arr.push(N);<br/>  return arr;<br/>}</span><span id="1485" class="mi ky in jn b gy mo mk l ml mm">console.log(appendNumber([1, 2, "three", 4, 5, true, false], 6).at(-1));<br/>// Expected Output: 6</span></pre><p id="0463" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在代码中，<code class="fe jk jl jm jn b">.at()</code>方法直接应用于返回值，而无需先将值存储在变量中。</p><h1 id="6e2f" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe jk jl jm jn b">.at()</code>方法接受带小数的数字</h1><p id="7af5" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">当一个带小数的数字传递给<code class="fe jk jl jm jn b">.at()</code>方法时，它会考虑小数点前的值，并返回该索引处的项。</p><p id="5616" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们来看看下面的代码:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="7ab2" class="mi ky in jn b gy mj mk l ml mm">const arr = [1, 2, "three", 4, 5, true, false];<br/>console.log(arr.at(0.6)); // Expected Output: 1<br/>console.log(arr.at(-3.6)); // Expected Output: 5</span></pre><p id="44a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码中，第一个控制台输出索引为<code class="fe jk jl jm jn b">0</code>的项目，而第二个控制台从数组末尾开始计数3，并输出找到的项目。</p><p id="131e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们想要随机选择一个索引元素时，这是有益的。这可以用一个石头剪子布游戏项目来演示。我们可以使用<code class="fe jk jl jm jn b">.at()</code>方法语法来为计算机确定一个随机选择。</p><p id="4a19" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面的代码说明了我们如何应用<code class="fe jk jl jm jn b">.at()</code>方法来随机选择计算机的选项:</p><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="6055" class="mi ky in jn b gy mj mk l ml mm">const computerOptions = ["rock", "paper", "scissors"];<br/>const randomIndex = Math.random() * computerOptions.length;</span><span id="56de" class="mi ky in jn b gy mo mk l ml mm">console.log(computerOptions.at(randomIndex));</span></pre><figure class="ma mb mc md gt js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi jo"><img src="../Images/bab98d33ef4d8190993fa9dd8aa0529c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zOjYAcU0tijZ3m9m.png"/></div></div></figure><pre class="ma mb mc md gt me jn mf mg aw mh bi"><span id="0b1a" class="mi ky in jn b gy mj mk l ml mm">const arr = [1, 2, "three", 4, 5, true, false];<br/>console.log(arr[0.6]); // Expected Output: undefined</span></pre><p id="d598" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe jk jl jm jn b">.at()</code>方法为我们省去了使用<code class="fe jk jl jm jn b">Math.floor</code>对随机数取整的额外步骤。</p><h1 id="ac81" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="b295" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">正如我们在本教程中所看到的,<code class="fe jk jl jm jn b">.at()</code>方法在根据索引抓取项目时非常有用。与先前存在的方法相比，它使用起来也很简洁。</p><p id="039a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="mp">更多内容请看</em><a class="ae mn" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="mp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>