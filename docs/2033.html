<html>
<head>
<title>Understanding Design Systems — Designing Component APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解设计系统—设计组件API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/design-systems-designing-component-apis-25dcf81d26f5?source=collection_archive---------3-----------------------#2021-04-29">https://javascript.plainenglish.io/design-systems-designing-component-apis-25dcf81d26f5?source=collection_archive---------3-----------------------#2021-04-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bb2f8edeb37ddc45d2d67655c770241e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*609Pa1E_7sFTZZXPRaXfNw@2x.png"/></div></div></figure><p id="d6ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不久以前，web用户界面主要是使用标准的HTML和CSS构建的。React、Vue.js、Angular和Polymer等框架的兴起，使得在同一应用程序甚至不同产品的不同部分之间<strong class="jx io">包装和重用UI组件</strong>成为可能。</p><p id="9277" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组件找到了与<strong class="jx io">设计系统</strong>的完美匹配，这使得它们能够从样式指南或参考样式表发展成成熟的库，其中包含用于设置组件外观、内容和行为的<strong class="jx io">应用编程接口(API)</strong>。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="a101" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.组件与仅CSS</h1><p id="29eb" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">设计系统可以实现为组件库或纯CSS样式表。虽然两者各有利弊，但在这篇文章中，我将重点介绍基于组件的方法。</p><p id="291e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与仅使用CSS的库相比，使用组件有许多优点，其中我认为最有价值的是:</p><ul class=""><li id="ce40" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated"><strong class="jx io">设计可以保持一致</strong>只暴露应该定制的部分。</li><li id="419d" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated"><strong class="jx io">通过在组件内部封装逻辑、样式和标记，产品代码变得更容易阅读和维护</strong>。</li><li id="ffed" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated"><strong class="jx io">冲突的类名和其他定义可以避免</strong>，因为它们被隔离在组件范围内。</li></ul><p id="fa32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为一个例子，让我们看看材质设计的按钮实现的两种方式。如果只有标签、图标和类型是可定制的，组件方法只暴露必要的API，而纯CSS方法暴露所有的复杂性:</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/aa404c1441b2ead504288ce2db5c9eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whbXv83ob-aapk0xKjrKww.png"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Material Design button — Web component</figcaption></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Material Design button — CSS-only</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="adc8" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.设计师为什么要在意？</h1><p id="8e5b" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">由于API对最终用户来说是不可见的，所以不清楚为什么UX的设计者应该参与设计它们。</p><p id="5635" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组件在到达最终用户之前首先由产品团队组装，API是组件和使用它的产品设计者或开发者之间的主要接口。从这个角度来看，开发人员和设计师是设计系统的第一批用户，他们的经验也应该被考虑。</p><p id="b123" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设计良好的API将增加开发人员的经验，降低他们实现自己的解决方案的风险，从而提高生产率并增强最终产品的一致性。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="434d" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.要考虑的因素</h1><p id="6a13" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在设计组件及其相应的API时，应该考虑一些关键因素，以确保它们易于使用，与系统的其余部分保持一致，并且易于在将来进行扩展和维护。</p><p id="2738" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">—</p><h2 id="8b0e" class="nc lb in bd lc nd ne dn lg nf ng dp lk kg nh ni lo kk nj nk ls ko nl nm lw nn bi translated">a)哪些部分可以隔离？</h2><p id="787b" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">复杂的组件很难消费。为了简化它们的API，隔离更小的、可重用的元素是一个很好的实践。</p><p id="ac4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些元素可以包装在父组件中，或者由消费者手动添加为子元素，这取决于预期的变化量(参见d段关于插槽的内容)。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7d5e8701a04d6ae7f3fc43402899817e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EF0PPIt4KUb-9pk8KJrmtg.png"/></div></figure><p id="da30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">—</p><h2 id="3fe3" class="nc lb in bd lc nd ne dn lg nf ng dp lk kg nh ni lo kk nj nk ls ko nl nm lw nn bi translated">应该提供哪些变化？</h2><p id="177c" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">通过对所有可能用例的概述，设计师可以帮助定义组件的哪些部分应该通过使用<strong class="jx io">属性</strong>进行定制，哪些应该保持稳定，避免不必要的变化，从而增强设计的一致性。</p><p id="9534" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下图中，<code class="fe no np nq nr b">label</code>和<code class="fe no np nq nr b">icon</code>是可定制的，而<code class="fe no np nq nr b">icon-color</code>和<code class="fe no np nq nr b">removable</code>不能改变。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/08b5e97a5233b2153b9e32d4e443015e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qC-utGyDsLrgWJdLN7CgQ.png"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fbea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">—</p><h2 id="d1a1" class="nc lb in bd lc nd ne dn lg nf ng dp lk kg nh ni lo kk nj nk ls ko nl nm lw nn bi translated">c)哪些风格应该是可定制的？</h2><p id="2e70" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">由于消费者无法访问封装的内容，定制风格只能通过API来完成。</p><p id="671f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">css变量可用于改变单个CSS值(如<code class="fe no np nq nr b">--border-radius</code>)。如果对于给定的变化应该一起改变多个样式(例如，改变图标颜色和字体大小的警告类型)，可以使用属性来代替。</p><p id="3f4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">变量可被定义为一个全局主题(例如<code class="fe no np nq nr b">--accent-color</code>)并针对单个组件进行修改，或者新变量可仅针对给定组件进行定义(例如<code class="fe no np nq nr b">--footer-padding</code>)</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/802222306d5ae8cf885a83ba242a645b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DOOveDOZAcgEzmR1f_4lA.png"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f3eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">—</p><h2 id="ff65" class="nc lb in bd lc nd ne dn lg nf ng dp lk kg nh ni lo kk nj nk ls ko nl nm lw nn bi translated">d)该组件未来将如何发展？</h2><p id="6d89" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">随着新用例的出现，组件及其API会随着时间的推移而发展。由于这个原因，它们应该<strong class="jx io">为变更</strong>而设计，基于事实或者对用例如何发展的预测。</p><p id="fb08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当新的用例出现时，一个没有考虑到进化而设计的API很可能导致<strong class="jx io">突破性的改变</strong>。</p><p id="e70a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下图中，对话框的<strong class="jx io">警告</strong>变化可以被定义为<code class="fe no np nq nr b">warning</code>布尔属性，但是如果<strong class="jx io">错误</strong>或<strong class="jx io">成功</strong>用例预计在未来出现，它可以被定义为<code class="fe no np nq nr b">type="warning"</code>字符串属性。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/1c7be5d9c50f6e7af964ab4e753674ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlbA7BUckrFgsl1Xh4F_zg.png"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="92c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">—</p><h2 id="ae7a" class="nc lb in bd lc nd ne dn lg nf ng dp lk kg nh ni lo kk nj nk ls ko nl nm lw nn bi translated">e)可以在哪里插入内容？</h2><p id="67a7" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">并非组件的所有功能都需要预先定义并通过特定的API提供。</p><p id="56b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于需要更多灵活性的用例，消费者应该能够在预定义的插槽(也称为门户、容器或子区域)中插入自定义内容。</p><p id="b084" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Slots可以定义其子元素的显示方式(例如，从上到下或从左到右，它们之间有8px的空间)，但是消费者可以完全控制插入元素的样式，因为它们没有被封装。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/09506821566635d1a9e91b7daf5a4038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OfZEhF7ZIR-WJWWr1NIUFg.gif"/></div></figure><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="bc55" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="a375" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">虽然对于最终用户来说，组件易于使用是极其重要的，但开发人员和设计人员应该被视为设计系统和组件库的第一手用户，设计易于使用的API将显著改善他们的体验。</p><p id="3f78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理解组件API如何工作的设计人员可以在定义组件时做出更有意义的决定，这也将增强与开发人员的交流。</p><p id="9753" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ns" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nt">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>