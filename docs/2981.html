<html>
<head>
<title>How to Create an Optimized Real-Time Search with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React创建优化的实时搜索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-an-optimized-real-time-search-with-react-6dd4026f4fa9?source=collection_archive---------1-----------------------#2021-06-17">https://javascript.plainenglish.io/how-to-create-an-optimized-real-time-search-with-react-6dd4026f4fa9?source=collection_archive---------1-----------------------#2021-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8329" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用反跳和记忆技术创建带有React挂钩的优化实时搜索功能。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/64b87f8c8b7c4dbee7c8e438e1efb219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1L28WZgDGw05KB2uP58Ylg@2x.png"/></div></div></figure><p id="8184" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发任何类型的应用程序时，最常见的场景之一是允许用户搜索某些东西。然而，即使这很常见，也可能很棘手，因为很容易实现带有性能问题的搜索功能。那么，如何才能做得更好呢？</p><p id="941e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将看到如何使用两种流行的优化技术来创建高效的搜索特性:<em class="ln">去抖动</em>和<em class="ln">记忆化</em>。</p><p id="76d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管我们将使用React，但是请记住，这些技术不是React特定的，您可以在任何语言或框架中使用它们。</p><p id="474c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最终的结果将看起来像<a class="ae lo" href="https://angelofaella.github.io/realtime-search-bar" rel="noopener ugc nofollow" target="_blank">这个</a>。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="8201" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">项目设置</h1><p id="ce4f" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们将创建两个主要组件:<code class="fe mt mu mv mw b">App</code>和<code class="fe mt mu mv mw b">SearchBar</code>。</p><p id="97cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mt mu mv mw b">App</code>组件包含一个标题、一个<code class="fe mt mu mv mw b">SearchBar</code>和一个<code class="fe mt mu mv mw b">div</code>来显示搜索结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6f84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，<code class="fe mt mu mv mw b">SearchBar</code>组件只包含一个简单的<code class="fe mt mu mv mw b">input</code>字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c6f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用几行CSS(你可以在GitHub <a class="ae lo" href="https://github.com/AngeloFaella/realtime-search-bar" rel="noopener ugc nofollow" target="_blank">资源库</a>看到所有的源代码)，这就是我们的app的样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/4d0a0f8bbbc30f44f9a81e9b93002c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUcszmQv-dONE72XJ8qLjA.png"/></div></div></figure><h1 id="7f1a" class="lw lx iq bd ly lz na mb mc md nb mf mg jw nc jx mi jz nd ka mk kc ne kd mm mn bi translated">实时搜索</h1><p id="632b" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们希望在用户书写时接收输入，并实时呈现结果。为了实现这一点，我们可以利用输入字段的<code class="fe mt mu mv mw b">onChange</code>事件，每次他的值改变时都会调用这个事件。</p><p id="7377" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次触发<code class="fe mt mu mv mw b">onChange</code>时，我们调用<code class="fe mt mu mv mw b">App</code>组件的<code class="fe mt mu mv mw b">onSearchSubmit</code>回调函数，将输入值作为参数传递。</p><p id="a61e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以利用两个反作用挂钩:</p><ol class=""><li id="f4dd" class="nf ng iq kt b ku kv kx ky la nh le ni li nj lm nk nl nm nn bi translated"><code class="fe mt mu mv mw b">useState</code>:当输入改变时，我们将新值存储在一个名为<code class="fe mt mu mv mw b">term</code>的状态变量中。</li><li id="c711" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><code class="fe mt mu mv mw b">useEffect</code>:每次<code class="fe mt mu mv mw b">term</code>更新时，我们调用<code class="fe mt mu mv mw b">onSearchSubmit</code>，将新的搜索词作为参数传递。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="99d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于调试的目的，在<code class="fe mt mu mv mw b">onSearchSubmit</code>中，我们记录搜索词，看看是否一切正常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a922" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从控制台中，您可以看到每输入一个新字符都会提交一个新的搜索(效率不是很高，对吧？我们稍后会对此进行改进)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/bc40d32c84755b0c07798765ce1fc0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8dkCbGt4ikJfG0cVc4Fjw.png"/></div></div></figure><h1 id="0027" class="lw lx iq bd ly lz na mb mc md nb mf mg jw nc jx mi jz nd ka mk kc ne kd mm mn bi translated">应用程序接口</h1><p id="83f9" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">是时候添加一个真正的API来测试我们的搜索特性了。</p><p id="36f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这个例子，我选择了<a class="ae lo" href="https://github.com/RocktimSaikia/anime-chan" rel="noopener ugc nofollow" target="_blank"> Animechan </a>，这是一个很好的提供动画引用的宁静API。获取某个动画的一组引用的最简单的方法是发送一个带有参数<code class="fe mt mu mv mw b">title</code>作为查询字符串的请求。</p><p id="226f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到这一点，我们现在可以在<code class="fe mt mu mv mw b">onSearchSubmit</code>回调函数中写入HTTP请求。</p><p id="57a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们得到报价，我们就将它们存储在<code class="fe mt mu mv mw b">App</code>州。为了渲染结果，我们首先映射引号数组，为每个元素创建一个<code class="fe mt mu mv mw b">Quote</code>组件，然后在主要部分显示<code class="fe mt mu mv mw b">Quote</code>列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="efd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mt mu mv mw b">Quote</code>是一个非常简单的组件，显示了一个引语，他的作者，以及取自的动画。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7c2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以得到一些真正的动漫名言了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/37ebdf30c9400433b6008450a5dd2037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qhO6EeNJTW1W5D7XE8hy7Q.png"/></div></div></figure><p id="544f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一切似乎都很好，但让它“正常工作”是不够的。我们可以做得更好。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="9182" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">去抖</h1><p id="4404" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">我们喜欢实时效果，但是为输入的每个字符提交一个新的搜索太低效了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/bc40d32c84755b0c07798765ce1fc0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8dkCbGt4ikJfG0cVc4Fjw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">A new search is submitted for each character typed</figcaption></figure><p id="38c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了避免这种情况，我们引入了所谓的<em class="ln">去抖功能。</em></p><p id="3c07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mt mu mv mw b">debounce</code>功能会延迟<code class="fe mt mu mv mw b">onChange</code>事件的处理，直到用户停止键入一段预定的时间。这将大大减少对<code class="fe mt mu mv mw b">onSearchSubmit</code>功能的调用次数。</p><p id="d473" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在我们的<code class="fe mt mu mv mw b">SearchBar</code>组件中实现去抖功能，我们可以使用以下策略:</p><ol class=""><li id="1c86" class="nf ng iq kt b ku kv kx ky la nh le ni li nj lm nk nl nm nn bi translated">当输入改变时，我们更新一个名为<code class="fe mt mu mv mw b">debounceTerm</code>的状态变量。</li><li id="0126" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">每次<code class="fe mt mu mv mw b">debounceTerm</code>改变，一个<code class="fe mt mu mv mw b">useEffect</code>钩子安排一个定时器在1秒后更新<code class="fe mt mu mv mw b">term</code>的值。</li><li id="69ca" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">如果<code class="fe mt mu mv mw b">debounceTerm</code>的另一次更新在不到1秒钟的时间内发生，先前的计时器将被取消(使用useEffect 的<a class="ae lo" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">清除功能)，并计划新的计时器。</a></li><li id="af37" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">当定时器启动并更新<code class="fe mt mu mv mw b">term</code>时，新的搜索被提交。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="022a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们可以看到，现在只有一个搜索提交后，1秒钟从最后一个字符键入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/c4613ca563ea6164a125de7ea80c01a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ul0aVDwwk1PAtOQ9TkdZkQ.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">search with debouncing</figcaption></figure><p id="096e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我选择了1秒钟来找到优化和搜索速度之间的正确平衡。根据您的需求，您可以选择或多或少的高时间，分别提高效率或加快响应速度。</p><h1 id="a343" class="lw lx iq bd ly lz na mb mc md nb mf mg jw nc jx mi jz nd ka mk kc ne kd mm mn bi translated">记忆</h1><p id="c085" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">如果我们用相同的输入连续进行两次搜索会发生什么？正如我们从控制台的Network选项卡中看到的，我们实际上进行了两次API调用，以获得几秒钟前得到的同一组报价。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/d4f65605ba74dc0f455fbce17f3ecb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kJeN4KWBbwcSZwwNJnOW4Q.gif"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Redundant API call</figcaption></figure><p id="9001" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果这看起来没什么大不了的，想象一个场景，您为每个API调用付费。</p><p id="6546" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们可以实施一种叫做<em class="ln">记忆</em>的技术。记忆化(是的，没有字母R)是一种优化技术，它包括存储昂贵的函数调用的结果，并在相同的输入再次出现时返回缓存的结果。</p><p id="7594" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从头开始创建记忆功能并不难，但是有几个实现可供使用。我们将使用流行库<a class="ae lo" href="https://lodash.com" rel="noopener ugc nofollow" target="_blank"> lodash </a>中的<code class="fe mt mu mv mw b">memoize</code>函数。</p><p id="c0c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了保持项目的有序，我将API调用转移到了另一个文件中，在<code class="fe mt mu mv mw b">src/apis/animeChan.js</code>中。在这里，我们导入<code class="fe mt mu mv mw b">lodash</code>，并将进行调用的异步函数作为输入参数传递给<code class="fe mt mu mv mw b">memoize</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="95f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此时，在<code class="fe mt mu mv mw b">App</code>组件中，我们可以调用<code class="fe mt mu mv mw b">requestQuotes</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="90db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到控制台，我们可以看到，无论我们用相同的输入进行多少次搜索，API调用只是每个标题一次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/725e7b2d5d3b12729937038e74784376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*U6lDWqozSmUjgVuK8Cf-3A.gif"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Memoized API call</figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="c5e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">去抖</em>和<em class="ln">记忆</em>是每个开发者都应该知道的简单而强大的技术。当然，搜索功能只是您可以使用它们的用例之一。</p><p id="2703" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">去抖动</em>可用于限制函数被调用的速率，这通常是一个耗时的函数。<em class="ln">内存化</em>可用于缓存任何“昂贵”函数的结果。</p><h1 id="f7ea" class="lw lx iq bd ly lz na mb mc md nb mf mg jw nc jx mi jz nd ka mk kc ne kd mm mn bi translated">资源</h1><ul class=""><li id="dec9" class="nf ng iq kt b ku mo kx mp la ob le oc li od lm oe nl nm nn bi translated">Github回购:<a class="ae lo" href="https://github.com/AngeloFaella/realtime-search-bar" rel="noopener ugc nofollow" target="_blank">https://github.com/AngeloFaella/realtime-search-bar</a></li><li id="9e75" class="nf ng iq kt b ku no kx np la nq le nr li ns lm oe nl nm nn bi translated">活生生的例子:<a class="ae lo" href="https://angelofaella.github.io/realtime-search-bar/" rel="noopener ugc nofollow" target="_blank">https://angelofaella.github.io/realtime-search-bar</a></li><li id="1fb2" class="nf ng iq kt b ku no kx np la nq le nr li ns lm oe nl nm nn bi translated">animechan API:<a class="ae lo" href="https://github.com/RocktimSaikia/anime-chan" rel="noopener ugc nofollow" target="_blank">https://github.com/RocktimSaikia/anime-chan</a></li><li id="6b9e" class="nf ng iq kt b ku no kx np la nq le nr li ns lm oe nl nm nn bi translated">洛达什:<a class="ae lo" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">https://lodash.com</a></li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="e3d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您喜欢这篇文章，您可能也会喜欢:</p><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/bringing-python-lists-to-javascript-with-proxy-api-1db8c3e559b4"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">使用代理API将Python列表引入JavaScript</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">如何使用JavaScript代理API创建一个带切片和负索引的类Python列表对象？</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="or l"><div class="os l ot ou ov or ow kp oi"/></div></div></a></div><p id="93d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">更多内容请看</em><a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ln">plain English . io</em></a></p></div></div>    
</body>
</html>