<html>
<head>
<title>Effective TypeScript: 62 Specific Ways to Improve Your TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效的打字稿:62种改进打字稿的具体方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/effective-typescript-62-specific-ways-to-improve-your-typescript-5a9462ed260a?source=collection_archive---------2-----------------------#2021-02-20">https://javascript.plainenglish.io/effective-typescript-62-specific-ways-to-improve-your-typescript-5a9462ed260a?source=collection_archive---------2-----------------------#2021-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1e02" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">…简而言之</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/731c1f00e941dfbc00f3f98f4b24e20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bng_1SZMq-iuQGIZC-c_uQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lucamartini?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Luca Martini</a> on <a class="ae kv" href="https://unsplash.com/s/photos/types?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="966c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我个人对这个话题的看法</h2><p id="e0de" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">2019年，我不得不决定是选择<em class="ml"> TypeScript </em>还是<em class="ml"> JavaScript </em>为工业领域的MVP进行web界面的前端开发。在后台，我确信不会使用<em class="ml">的打字稿</em>或者<em class="ml">的JavaScript </em>。在前端，我不太确定是用<em class="ml">类型脚本</em>还是用<em class="ml"> JavaScript </em>。我已经在个人网站项目中实现了一些JavaScript，但我不会称自己为专业的前端开发人员。然而，我知道缺乏打字会成为一个问题。</p><p id="9a18" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">然而，只要在前端开发和维护少量简单的逻辑，打字的缺乏就不会那么重要。然而，如果需要越来越复杂的逻辑，最好还是坚持使用<em class="ml">类型的脚本</em>。</p><p id="250e" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">更多的上下文:此外，在一个质量要求很高的领域，我可能会为以后的项目选择错误的语言。在我能够读完这本书之前，我必须决定选择哪种语言。从之前的<em class="ml">有效… </em>丛书(<a class="ae kv" href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/" rel="noopener ugc nofollow" target="_blank"> <em class="ml">有效现代C++ </em> </a>和<a class="ae kv" href="https://www.oreilly.com/library/view/effective-python-90/9780134854717/" rel="noopener ugc nofollow" target="_blank"> <em class="ml">有效Python </em> </a>)中学到了很多。我决定获得<a class="ae kv" href="https://www.oreilly.com/library/view/effective-typescript/9781492053736/" rel="noopener ugc nofollow" target="_blank"> <em class="ml">有效的打字稿:62种提高你使用打字稿</em> </a>的具体方法在尽可能少的时间里学习尽可能多的与实践相关的东西。</p><h2 id="d3a9" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">没什么好补充的！</h2><p id="99a8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这本书的结构有助于从头到尾阅读。可以按照任意顺序阅读单个提示(“项目”)。然而，我建议从头到尾读一遍。至少对我来说，这本书不会让我大开眼界。</p><p id="abe3" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">内容切中要害。这些物品被分门别类。几乎所有的条目都涉及类型系统。这些提示是关于添加到JavaScript w.r.t .类型之上的主题。这听起来很无聊，但对我来说非常有趣。代码可靠性，在<em class="ml"> JavaScript </em>中可能出错但在<em class="ml"> TypeScript </em>中不会出错的事情(如果你不使用<em class="ml">任何</em>)。</p><p id="43e0" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated"><em class="ml"> TypeScript </em>代码被编译成<em class="ml"> JavaScript </em>代码的含义也非常有用(编译时与运行时)。动态类型、可选类型提示的<em class="ml"> Python </em>和静态类型的<em class="ml"> C++ </em>的区别非常有趣。然而，如果你搜索一本讲述<em class="ml"> TypeScript </em>编程基础的书，它可能不适合你。大多数项目都有一个或几个例子的解释。</p><p id="a123" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">此外每个项目都有一个<em class="ml">要记住的事情</em>部分。因为这篇文章是对我自己的思想支持，所以从现在开始我几乎只引用内容。然而，除了从这篇文章中获得价值，你可能还得阅读这本书。</p><ol class=""><li id="5500" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk mw mx my mz bi translated">了解TypeScript(第1至第5项)</li><li id="471d" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk mw mx my mz bi translated">TypeScript的类型系统(第6至18项)</li><li id="86d4" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk mw mx my mz bi translated">类型推断(第19至27项)</li><li id="b401" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk mw mx my mz bi translated">型号设计(第28至37项)</li><li id="abf8" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk mw mx my mz bi translated">使用任何(项目38至44)</li><li id="f1b9" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk mw mx my mz bi translated">类型声明和@types(第45到52项)</li><li id="a988" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk mw mx my mz bi translated">编写和运行您的代码(第53至57项)</li><li id="1333" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk mw mx my mz bi translated">迁移您的代码(第58至62项)</li></ol><h2 id="eb7c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第1项:理解TypeScript和JavaScript之间的关系</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/6e07e24e36dc9caec4662e1c0ff0e4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAgVyN09d4_nTkVRxdqThA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">[Effective TypeScript, p. 2]</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/73c02ed990155787752f36ffbae2dc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SX8MvOGoLXlMowIdxVs6tw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">[Effective TypeScript, p. 5]</figcaption></figure><p id="c000" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">要记住的事情[有效打字稿，第6/7页]:</p><ul class=""><li id="d193" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">TypeScript是JavaScript的超集。换句话说，所有的JavaScript程序都已经是类型脚本程序了。TypeScript有它自己的语法，所以一般来说，TypeScript程序不是有效的JavaScript程序。</li><li id="a612" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">TypeScript添加了一个类型系统，该系统模拟JavaScript的运行时行为，并试图找出将在运行时引发异常的代码。但是你不应该期望它标记每一个异常。代码有可能通过类型检查，但在运行时仍会抛出。</li><li id="b198" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">虽然TypeScript的类型系统在很大程度上模拟了JavaScript的行为，但有些构造是JavaScript允许的，但TypeScript选择禁止，比如调用参数数量错误的函数。这在很大程度上是一个品味问题。</li></ul><h2 id="a1ce" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第二条:知道你使用的是哪种类型</h2><p id="4774" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第9/10页]:</p><ul class=""><li id="6f2c" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">TypeScript编译器包括几个影响语言核心方面的设置。</li><li id="3ff3" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用tsconfig.json而不是命令行选项配置TypeScript。</li><li id="496f" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">除非您要将JavaScript项目转换为TypeScript，否则请打开noImplicitAny。</li><li id="8b6e" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用strictNullChecks来防止“未定义不是对象”样式的运行时错误。</li><li id="6220" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">旨在使strict能够获得TypeScript所能提供的最彻底的检查。</li></ul><h2 id="e776" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第3条:理解代码生成与类型无关</h2><p id="332b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">标题:</p><ul class=""><li id="f084" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">有类型错误的代码会产生输出</li><li id="fa7c" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">您不能在运行时检查TypeScript类型</li><li id="34c8" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">类型运算不能影响运行时值</li><li id="c149" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">运行时类型可能与声明的类型不同</li><li id="a350" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">不能基于TypeScript类型重载函数</li><li id="1d77" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">TypeScript类型对运行时性能没有影响</li></ul><p id="24aa" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">要记住的事情[有效打字稿，第16页]:</p><ul class=""><li id="c228" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">代码生成独立于类型系统。这意味着TypeScript类型不会影响代码的运行时行为或性能。</li><li id="0d0c" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">有类型错误的程序有可能产生代码(“编译”)。</li><li id="69d1" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">TypeScript类型在运行时不可用。要在运行时查询一个类型，您需要某种方法来重建它。标记联合和属性检查是实现这一点的常用方法。有些构造(如class)引入了TypeScript类型和运行时可用的值。</li></ul><h2 id="56fc" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第4项:熟悉结构类型</h2><p id="16dd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第19/20页]:</p><ul class=""><li id="e76a" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">请理解JavaScript是鸭类型的，TypeScript使用结构类型来对此建模:可分配给接口的值可能具有类型声明中明确列出的属性之外的属性。类型不是“密封的”</li><li id="8224" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">请注意，类也遵循结构化类型规则。您可能没有您期望的类的实例！</li><li id="dfab" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用结构类型来促进单元测试。</li></ul><h2 id="7a85" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第5项:限制任何类型的使用</h2><p id="87ad" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">标题:</p><ul class=""><li id="52d1" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">任何类型都没有类型安全</li><li id="bce3" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">任何让你毁约</li><li id="75f0" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">没有任何类型的语言服务</li><li id="9091" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">当你重构代码时，任何类型都会掩盖错误</li><li id="f0a3" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">任何隐藏你的类型设计</li><li id="e6e5" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">任何破坏都凝结在打字系统中</li></ul><p id="d38d" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">要记住的事情[有效打字稿，第24页]:</p><ul class=""><li id="2422" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">any类型有效地抑制了类型检查器和TypeScript语言服务。它会掩盖真正的问题，损害开发人员的体验，破坏对类型系统的信心。能避免就避免使用！</li></ul><h2 id="3501" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第6项:使用你的编辑器询问和探索类型系统</h2><p id="9d27" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第29页]:</p><ul class=""><li id="d7d5" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">通过使用可以使用TypeScript语言服务的编辑器来利用它们。</li><li id="aeba" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用您的编辑器为类型系统如何工作以及TypeScript如何推断类型建立直觉。</li><li id="e20d" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">知道如何进入类型声明文件，看看它们是如何模拟行为的。</li></ul><h2 id="3476" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第7项:将类型视为一组值</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/0ddf7964e061c54cf8c14ea819a30f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_WRqkMsH5V7PycXHRJ0Eg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">[Effective TypeScript, p. 32]</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/c8501f508dfdd0fe6e115b7413708c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZfmGaqEtmAOibrYDkcyDA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">[Effective TypeScript, p. 34]</figcaption></figure><p id="c435" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">要记住的事情[有效打字稿，第35页]:</p><ul class=""><li id="3f5c" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">将类型视为值的集合(类型的域)。这些集合可以是有限的(例如，布尔或文字类型)，也可以是无限的(例如，数字或字符串)。</li><li id="f7e3" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">TypeScript类型形成交叉集(维恩图)而不是严格的层次结构。两种类型可以重叠，但都不是对方的子类型。</li><li id="31c9" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">请记住，一个对象仍然可以属于一个类型，即使它有类型声明中没有提到的附加属性。</li><li id="45dc" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">类型运算适用于集合的定义域。A和Bis的交集A的定义域和B的定义域的交集。对于对象类型，这意味着A&amp; B中的值同时具有A和b的属性</li><li id="5687" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">将“扩展”、“可分配给”和“的子类型”视为“的子集”的同义词</li></ul><h2 id="5f2c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第8条:知道如何判断一个符号是在类型空间还是值空间</h2><p id="d4df" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第40页]:</p><ul class=""><li id="2538" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">知道如何在读取TypeScript表达式时判断自己是在类型空间还是值空间。使用TypeScript playground来建立对此的直觉。</li><li id="4845" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">每个值都有一个类型，但是类型没有值。像类型和接口这样的构造只存在于类型空间中。</li><li id="df9d" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">“foo”可能是字符串文字，也可能是字符串文字类型。意识到这种区别，并了解如何辨别这两者。</li><li id="88a7" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">typeof、this以及许多其他操作符和关键字在类型空间和值空间中具有不同的含义。</li><li id="b5fd" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">有些构造，如class或enum，既引入了类型又引入了值。</li></ul><h2 id="c641" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第9条:更喜欢类型声明而不是类型断言</h2><p id="dcbf" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第43页]:</p><ul class=""><li id="3a37" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">更喜欢类型声明(:type)而不是类型断言(as Type)。</li><li id="ed90" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">知道如何注释一个箭头函数的返回类型。</li><li id="401d" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">当您知道一些TypeScript不知道的类型时，请使用类型断言和非空断言。</li></ul><h2 id="7be3" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第10条:避免对象包装类型(字符串、数字、布尔值、符号、BigInt)</h2><p id="d0a2" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第46页]:</p><ul class=""><li id="b353" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">理解如何使用对象包装类型来提供基元值的方法。避免实例化它们或直接使用它们。</li><li id="ae17" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">避免TypeScript对象包装类型。请改用基本类型:string代替String，number代替Number，boolean代替Boolean，symbol代替Symbol，bigint代替BigInt。</li></ul><h2 id="b64e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第11条:认识超额财产检查的局限性</h2><p id="9039" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第49页]:</p><ul class=""><li id="5f8e" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">当您将对象文本赋给变量或将它作为参数传递给函数时，它会经历额外的属性检查。</li><li id="5038" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">过剩属性检查是一种有效的查找错误的方法，但它不同于由TypeScript类型检查器完成的通常的结构可赋值性检查。将这些过程混为一谈会让你更难建立一个可分配性的心智模型。</li><li id="6349" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">请注意过度属性检查的限制:引入中间变量将会取消这些检查。</li></ul><h2 id="4f90" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第12条:尽可能对整个函数表达式应用类型</h2><p id="5c8f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第52页]:</p><ul class=""><li id="e600" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">考虑将类型批注应用于整个函数表达式，而不是它们的参数和返回类型。</li><li id="28f3" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果您重复编写相同类型的签名，请找出一个函数类型或寻找一个现有的类型。如果你是一个库的作者，为commoncallbacks提供类型。</li><li id="f643" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用typeof fn匹配另一个函数的签名。</li></ul><h2 id="1080" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第13条:知道类型和接口的区别</h2><p id="0058" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第56页]:</p><ul class=""><li id="5458" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">理解类型和接口的区别和相似之处。</li><li id="3c73" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">知道如何使用任一种语法编写相同的类型。</li><li id="18e9" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">在决定在您的项目中使用哪一种时，请考虑已建立的风格以及增强是否有益。</li></ul><h2 id="7a38" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第14条:使用类型操作和泛型来避免重复</h2><p id="c5ef" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第64页]:</p><ul class=""><li id="e948" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">DRY(不要重复自己)原则既适用于逻辑，也适用于类型。</li><li id="ad38" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">命名类型而不是重复它们。使用扩展来避免接口中的重复字段。</li><li id="bd5c" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">了解TypeScript提供的在类型之间进行映射的工具。这些类型包括keyof、typeof、索引和映射类型。</li><li id="6927" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">泛型类型相当于类型的函数。使用它们在类型之间映射，而不是重复类型。使用扩展来约束泛型类型。</li><li id="90e5" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">熟悉标准库中定义的泛型类型，如Pick、Partial和ReturnType。</li></ul><h2 id="b52f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第15项:对动态数据使用索引签名</h2><p id="80ec" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第67页]:</p><ul class=""><li id="f3cc" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">当直到运行时才能知道对象的属性时，使用索引签名，例如，如果从CSV文件加载它们。</li><li id="fc8b" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">考虑将undefined添加到索引签名的值类型中，以实现更安全的访问。</li><li id="c7fc" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">尽可能使用更精确的类型来索引签名:接口、记录或映射类型。</li></ul><h2 id="0556" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第16项:优先使用数组、元组和ArrayLike对索引签名进行编号</h2><p id="6b79" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第70/71页]:</p><ul class=""><li id="0597" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">要明白数组是对象，所以它们的键是字符串，不是数字。numberas索引签名是一个纯粹的类型脚本构造，旨在帮助捕获bug。</li><li id="3317" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">比起自己在索引签名中使用数字，更喜欢使用数组、元组或类数组类型。</li></ul><h2 id="0236" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第17项:使用readonly来避免与突变相关的错误</h2><p id="dd61" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第77页]:</p><ul class=""><li id="c504" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">如果你的函数不修改它的参数，那么把它们声明为readonly。这使得它的契约更加清晰，并防止实现中的意外变化。</li><li id="7002" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用readonlyto来防止突变错误，并找到代码中发生突变的地方。</li><li id="6e10" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">理解const和readonly的区别。</li><li id="69a6" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">要明白readonly是浅薄的。</li></ul><h2 id="8a99" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第18项:使用映射类型保持值同步</h2><p id="77b1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第80页]:</p><ul class=""><li id="9132" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">使用映射类型来保持相关值和类型的同步。</li><li id="b204" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">考虑在向接口添加新属性时使用映射类型来强制选择。</li></ul><h2 id="1261" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第19条:避免用可推断的类型来混淆你的代码</h2><p id="36e8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第87页]:</p><ul class=""><li id="5920" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">当TypeScript可以推断相同的类型时，避免编写类型批注。</li><li id="5b1e" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">理想情况下，您的代码在函数/方法签名中有类型注释，但在代码体的局部变量中没有。</li><li id="c5c4" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">考虑对对象文字和函数返回类型使用显式注释，即使它们可以被推断出来。这将有助于防止用户代码中出现实现错误。</li></ul><h2 id="d3e8" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第20条:对不同的类型使用不同的变量</h2><p id="e6a8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第89/90页]:</p><ul class=""><li id="5fbe" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">虽然变量值可以改变，但它的类型通常不会改变。</li><li id="37fe" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">为了避免人类读者和类型检查器的混淆，避免对不同类型的值重用变量。</li></ul><h2 id="e894" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第21项:了解类型扩展</h2><p id="a266" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第93页]:</p><ul class=""><li id="35ad" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">了解TypeScript如何通过扩展常量来从常量中推断类型。</li><li id="db43" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">熟悉影响这种行为的方式:const、类型注释、上下文和as const。</li></ul><h2 id="e2e2" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第22项:了解类型收缩</h2><p id="aaeb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第96页]:</p><ul class=""><li id="e522" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">理解TypeScript如何基于条件和其他类型的控制流来缩小类型。</li><li id="ef26" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用标记/区分联合和用户定义的类型保护来帮助缩小范围。</li></ul><h2 id="d8b7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第23项:一次性创建所有对象</h2><p id="21de" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第99页]:</p><ul class=""><li id="0559" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">我更喜欢一次完成所有的东西，而不是一点一点地完成。使用对象扩展({…a，…b})以类型安全的方式添加属性。</li><li id="7c3c" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">知道如何有条件地向对象添加属性。</li></ul><h2 id="2c84" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第24条:使用别名时要保持一致</h2><p id="7b68" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第102页]:</p><ul class=""><li id="694d" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">别名可以防止TypeScript缩小类型。如果您为avariable创建别名，请始终如一地使用它。</li><li id="90c9" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用析构语法来鼓励一致的命名。</li><li id="8e97" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">请注意函数调用可能会使属性的类型细化无效。信任对局部变量的细化多于对属性的细化。</li></ul><h2 id="3f02" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第25条:对同步代码使用异步函数代替回调</h2><p id="a582" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第107页]:</p><ul class=""><li id="e6bd" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">为了更好的可组合性和类型流，更喜欢承诺而不是回调。</li><li id="1158" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">可能的话，最好使用异步和等待，而不是原始承诺。它们生成更精确、更简单的代码，并消除了各类错误。</li><li id="682c" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果一个函数返回一个承诺，就声明它是异步的。</li></ul><h2 id="3a4a" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第26项:理解上下文是如何在类型推断中使用的</h2><p id="826e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第111页]:</p><ul class=""><li id="37c7" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">注意上下文是如何在类型推断中使用的。</li><li id="e0d2" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果分解变量会引入类型错误，请考虑添加类型声明。</li><li id="80b6" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果变量确实是一个常数，使用const断言(作为const)。但是请注意，这可能会导致使用中出现错误，而不是定义错误。</li></ul><h2 id="3a3d" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第27项:使用函数构造和库来帮助类型流</h2><p id="8a33" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第115页]:</p><ul class=""><li id="8332" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">使用内置的函数构造和实用程序库中的函数构造(如Lodash ),而不是手工创建的构造，以改善类型流，提高可读性，并减少对显式类型注释的需求。</li></ul><h2 id="e957" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第28项:首选总是表示有效状态的类型</h2><p id="5a2c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第122页]:</p><ul class=""><li id="7873" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">既表示有效状态又表示无效状态的类型很可能导致混乱和容易出错的代码。</li><li id="876e" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">首选只表示有效状态的类型。即使它们更长或更难表达，它们最终也会节省你的时间和痛苦！</li></ul><h2 id="f6e7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第29条:对你所接受的要宽容，对你所生产的要严格</h2><p id="48f2" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第125页]:</p><ul class=""><li id="1e81" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">输入类型往往比输出类型更广泛。可选属性和uniontypes在参数类型中比在返回类型中更常见。</li><li id="c871" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">为了在参数和返回类型之间重用类型，引入一个规范形式(对于返回类型)和一个松散形式(对于参数)。</li></ul><h2 id="bc47" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第30条:不要在文档中重复类型信息</h2><p id="bcee" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第127页]:</p><ul class=""><li id="ff1c" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">避免在注释和变量名中重复类型信息。在最好的情况下，它是类型声明的重复，在最坏的情况下，它将导致信息冲突。</li><li id="fe12" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果类型中没有明确的单位，可以考虑在变量名中包含单位(如timeMs或temperatureC)。</li></ul><h2 id="50bd" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第31项:将空值推到类型的外围</h2><p id="b41c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第130页]:</p><ul class=""><li id="40fd" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">避免这样的设计:一个值为空或非空与另一个值为空或非空隐式相关。</li><li id="ba15" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">通过使较大的对象为空或完全非空，将空值推到API的边界。这将使代码对于人类读者和类型检查器来说都更加清晰。</li><li id="c172" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">考虑创建一个完全非空的类，并在所有值都可用时构造它。</li><li id="e8ff" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">虽然strictNullChecks可能会标记出代码中的许多问题，但它对于揭示函数在空值方面的行为是不可或缺的。</li></ul><h2 id="b31c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第32项:比起联合的接口，更喜欢接口的联合</h2><p id="d9b8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第134页]:</p><ul class=""><li id="28e1" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">具有多个联合类型属性的接口通常是错误的，因为它们模糊了这些属性之间的关系。</li><li id="1442" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">接口的联合更加精确，可以被TypeScript理解。</li><li id="1318" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">考虑在您的结构中添加一个“标记”,以便于TypeScript的控制流分析。因为它们得到了很好的支持，标记联合在TypeScript代码中无处不在。</li></ul><h2 id="83db" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第33项:首选更精确的字符串类型</h2><p id="747a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第138页]:</p><ul class=""><li id="b22c" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">避免“字符串型”代码。在并非每个字符串都是可能的情况下，最好使用更合适的类型。</li><li id="d448" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">更倾向于使用string literal类型的联合，而不是更准确地描述变量定义域的stringif。您将得到更严格的类型检查，并改善开发体验。</li><li id="3e85" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">对于期望成为对象属性的函数参数，首选keyof T而不是string。</li></ul><h2 id="6030" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第34条:不完整的类型比不准确的类型更好</h2><p id="31f0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第142页]:</p><ul class=""><li id="d5a9" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">避免类型安全的恐怖山谷:不正确的类型通常比没有类型更糟糕。</li><li id="3bdc" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果您不能准确地建模一个类型，就不要不准确地建模！使用任何或未知来确认差距。</li><li id="bfb7" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">随着打字越来越精确，请注意错误信息和自动完成功能。这不仅仅是关于正确性:开发者体验也很重要。</li></ul><h2 id="fdad" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第35项:从API和规范生成类型，而不是数据</h2><p id="8306" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第147页]:</p><ul class=""><li id="2304" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">考虑为API调用和数据格式生成类型，以在代码的边缘获得类型安全。</li><li id="ba8d" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">更喜欢从规范而不是数据中生成代码。罕见病例很重要！</li></ul><h2 id="9336" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第36项:使用问题域语言的名称类型</h2><p id="6f8f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第149页]:</p><ul class=""><li id="611e" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">尽可能重用问题领域中的名称，以提高代码的可读性和抽象程度。</li><li id="a7dc" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">避免对同一事物使用不同的名字:使名字的区别有意义。</li></ul><h2 id="026c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第37项:考虑将“品牌”用于名义打字</h2><p id="2feb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第152页]:</p><ul class=""><li id="8bcf" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">TypeScript使用结构化(“duck”)类型，这有时会导致令人惊讶的结果。如果你需要名义上的打字，考虑把“品牌”贴在你的价值观上，以示区别。</li><li id="92ee" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">在某些情况下，你可以在类型系统中完全附加品牌，而不是在运行时。您可以使用这种技术在TypeScript的类型系统之外对属性进行建模。</li></ul><h2 id="31d1" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第38条:对任何类型使用尽可能窄的范围</h2><p id="e85f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第155页]:</p><ul class=""><li id="4553" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">尽可能缩小any的使用范围，以避免在代码中的其他地方出现不必要的类型安全损失。</li><li id="cd31" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">永远不要从函数中返回any类型。这将悄悄地导致调用该函数的任何客户端失去类型安全。</li><li id="472c" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果您需要消除一个错误，可以考虑将@ts-ignore作为any的替代方法。</li></ul><h2 id="af43" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第39条:比起简单的any，更喜欢any的精确变体</h2><p id="85c3" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第157页]:</p><ul class=""><li id="8345" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">当您使用any时，请考虑任何JavaScript值是否是真正允许的。</li><li id="850d" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果any[]或{[id:string]:any }或()=&gt; any能够更准确地为您的数据建模，那么最好使用更精确的形式。</li></ul><h2 id="31f8" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第40项:在良好类型的函数中隐藏不安全的类型断言</h2><p id="4e88" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第159页]:</p><ul class=""><li id="50ab" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">有时，不安全的类型断言是必要的或权宜之计。当你需要使用它的时候，把它藏在一个有正确签名的函数里。</li></ul><h2 id="f91c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第41项:理解进化</h2><p id="b646" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第162页]:</p><ul class=""><li id="b89f" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">虽然TypeScript类型通常只细化，但隐式any和any[]类型是允许发展的。你应该能够识别和理解这个结构出现的地方。</li><li id="7964" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">为了更好地进行错误检查，请考虑提供显式类型注释，而不是使用evolving any。</li></ul><h2 id="83f2" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第42项:对于未知类型的值，使用unknown而不是any</h2><p id="3441" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第165/166页]:</p><ul class=""><li id="6e6b" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">未知类型是任何类型的类型安全替代。当你知道你有一个值，但不知道它的类型是什么时，使用它。</li><li id="1a8a" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用unknown强制用户使用类型断言或进行类型检查。</li><li id="fb11" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">理解{}、对象、未知之间的区别。</li></ul><h2 id="3d7f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第43项:首选类型安全方法进行猴子修补</h2><p id="3593" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第168页]:</p><ul class=""><li id="db34" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">比起在全局或DOM上存储数据，更喜欢结构化代码。</li><li id="e376" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果必须在内置类型上存储数据，请使用类型安全的方法之一(扩充或断言自定义接口)。</li><li id="f196" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">理解扩充的范围问题。</li></ul><h2 id="b408" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第44条:跟踪你的类型覆盖率，防止类型安全的倒退</h2><p id="5d6a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第170页]:</p><ul class=""><li id="b494" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">即使没有设置任何类型，任何类型都可以通过显式Any或第三方类型声明(@types)进入您的代码。</li><li id="8d73" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">考虑跟踪你的程序的类型有多好。这将鼓励您重新考虑使用any的决定，并随着时间的推移增加类型安全性。</li></ul><h2 id="1f29" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第45项:将TypeScript和@types放在devDependencies中</h2><p id="3678" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第173页]:</p><ul class=""><li id="de12" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">避免在系统范围内安装TypeScript。使TypeScript成为项目的devDependency，以确保团队中的每个人都使用一致的版本。</li><li id="5d97" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">将@types依赖项放在devDependencies中，而不是dependencies中。如果您在运行时需要@types，那么您可能需要重新设计您的流程。</li></ul><h2 id="1493" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第46项:理解类型声明中涉及的三个版本</h2><p id="ecf3" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第177页]:</p><ul class=""><li id="4874" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">@types依赖项涉及三个版本:库版本、@types版本和TypeScript版本。</li><li id="dfcd" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">如果更新库，请确保更新相应的@types。</li><li id="1d8e" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">理解绑定类型与在确定类型上发布它们的优缺点。如果您的库是用TypeScript编写的，那么最好使用绑定类型，如果不是，那么就一定要类型化。</li></ul><h2 id="912c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第47项:导出公共API中出现的所有类型</h2><p id="27cd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第178页]:</p><ul class=""><li id="c0b0" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">导出在任何公共方法中以任何形式出现的类型。你的用户无论如何都可以提取它们，所以你也可以让他们更容易提取。</li></ul><h2 id="8d86" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第48项:将TSDoc用于API注释</h2><p id="414e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第181页]:</p><ul class=""><li id="25d0" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">使用JSDoc-/TSDoc格式的注释来记录导出的函数、类和类型。这有助于编辑在最相关的时候向用户展示信息。</li><li id="8334" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用@param、@returns和Markdown进行格式化。</li><li id="8bfa" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">避免在文件中包含类型信息(见第30项)。</li></ul><h2 id="2a83" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第49项:在回调中为此提供一个类型</h2><p id="e6da" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第181页]:</p><ul class=""><li id="55a9" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">理解这种绑定是如何工作的。</li><li id="82c8" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">当它是你的API的一部分时，在回调中提供一个类型。</li></ul><h2 id="b235" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第50条:优先选择条件类型而不是重载声明</h2><p id="e6bc" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第187页]:</p><ul class=""><li id="90bf" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">优先选择条件类型而不是重载类型声明。通过在联合上分布，条件类型允许您的声明支持联合类型，而无需额外的重载。</li></ul><h2 id="c3cd" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第51项:服务器依赖关系的镜像类型</h2><p id="ba65" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第188页]:</p><ul class=""><li id="f2a2" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">使用结构化类型来切断不重要的依赖关系。</li><li id="2053" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">不要强迫JavaScript用户依赖@types。不要强迫web开发者依赖NodeJS。</li></ul><h2 id="40ae" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第52条:注意测试类型的陷阱</h2><p id="4f8e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第192/193页]:</p><ul class=""><li id="0ec8" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">测试类型时，要注意相等性和可赋值性之间的区别，尤其是对于函数类型。</li><li id="2883" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">对于使用回调的函数，测试回调参数的推断类型。如果它是你的API的一部分，不要忘记测试它的类型。</li><li id="3440" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">警惕任何涉及类型的in测试。可以考虑使用dtslintforstricter这样的工具，不太容易出错的检查。</li></ul><h2 id="2fb7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第53项:ECMAScript功能优于ECMAScript功能</h2><p id="8dc5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第200页]:</p><ul class=""><li id="2141" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">总的来说，您可以通过从代码中移除所有类型来将TypeScript转换为JavaScript。</li><li id="394a" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">枚举、参数属性、三重斜杠导入和装饰符是这个规则的历史例外。</li><li id="f2c5" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">为了让TypeScript在您的代码库中的角色尽可能清晰，我建议避免这些功能。</li></ul><h2 id="84b8" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第54项:知道如何迭代对象</h2><p id="2abe" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第202页]:</p><ul class=""><li id="b9ba" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">当您确切知道键是什么时，使用let k: keyof T和for-in循环来迭代对象。请注意，函数作为参数接收的任何对象都可能有额外的键。</li><li id="4316" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用Object.entries迭代任何对象的键和值。</li></ul><h2 id="a7c2" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第55项:了解DOM层次结构</h2><p id="ee81" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第202页]:</p><ul class=""><li id="a7ae" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">DOM有一个类型层次结构，在编写JavaScript时通常可以忽略它。但是这些类型在TypeScript中变得更加重要。理解它们将有助于您为浏览器编写类型脚本。</li><li id="8eef" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">了解Node、Element、HTMLElement和EventTarget之间的区别，以及Event和MouseEvent之间的区别。</li><li id="93bf" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">要么在代码中为DOM元素和事件使用足够具体的类型，要么给TypeScript上下文来推断它。</li></ul><h2 id="919f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第56条:不要依靠隐私来隐藏信息</h2><p id="0d48" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第209页]:</p><ul class=""><li id="b066" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">私有访问修饰符只能通过类型系统来实施。它在运行时不起作用，可以通过断言绕过。不要认为它会隐藏数据。</li><li id="a2bd" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">为了更可靠地隐藏信息，请使用闭包。</li></ul><h2 id="3933" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第57项:使用源映射调试TypeScript</h2><p id="a67c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第214页]:</p><ul class=""><li id="91ac" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">不要调试生成的JavaScript。使用源映射在运行时调试您的TypeScript代码。</li><li id="4f11" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">确保您的源映射一直映射到您运行的代码。</li><li id="d1fa" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">根据您的设置，您的源映射可能包含原始代码的内联副本。除非你知道你在做什么，否则不要发表它们！</li></ul><h2 id="69c1" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第58项:编写现代JavaScript</h2><p id="1b77" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">标题:</p><ul class=""><li id="2c83" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">使用ECMAScript模块</li><li id="f911" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用类而不是原型</li><li id="844a" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用let/const代替var</li><li id="ad6f" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用for-of或数组方法，而不是for(；；)</li><li id="6ab5" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">优先选择箭头函数而不是函数表达式</li><li id="57c3" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用压缩对象文本和析构赋值</li><li id="555e" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用默认函数参数</li><li id="c33d" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用async/await代替原始承诺或回调</li><li id="b272" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">不要在TypeScript中使用严格的</li></ul><p id="919d" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">要记住的事情[有效打字稿，第223页]:</p><ul class=""><li id="dfdc" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">TypeScript允许您在任何运行时环境下编写现代JavaScript。通过使用它所支持的语言特性来利用这一点。除了改进您的代码库之外，这将有助于TypeScript理解您的代码。</li><li id="1a01" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用TypeScript学习语言特性，如类、析构和异步/等待。</li><li id="3c60" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">不要为“使用严格”而烦恼:TypeScript更严格。</li><li id="a6e2" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">查看TC39 GitHub repo和TypeScript发行说明，了解所有最新的语言特性。</li></ul><h2 id="e674" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第59项:使用@ts-check和JSDoc试验TypeScript</h2><p id="d0cb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第227/228页]:</p><ul class=""><li id="68a5" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">将“// @ts-check”添加到JavaScript文件的顶部，以启用类型检查。</li><li id="9b3f" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">识别常见错误。知道如何声明全局变量并为第三方库添加类型声明。</li><li id="f586" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">使用JSDoc注释进行类型断言和更好的类型推断。</li><li id="499c" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">不要花太多时间让你的代码用JSDoc完美地输入。请记住，目标是转换为。ts！</li></ul><h2 id="4a25" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第60项:使用allowJs混合使用TypeScript和JavaScript</h2><p id="f17b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第229页]:</p><ul class=""><li id="2421" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">在过渡项目时，使用allowJs编译器选项来支持混合的JavaScript和TypeScript。</li><li id="3561" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">在开始大规模迁移之前，获取您的测试并构建使用TypeScript的链。</li></ul><h2 id="c276" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第61条:一个模块一个模块地转换你的依赖图</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/a0b94ef83c72191e3f65f8786c202629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mk-L_3M9LObwGbO8tl6S3A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">[Effective TyeScript, p. 230]</figcaption></figure><p id="9251" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">要记住的事情[有效打字稿，第233/234页]:</p><ul class=""><li id="c63a" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">通过为第三方模块和外部API调用添加@types来开始迁移。</li><li id="8759" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">从依赖图的底部开始向上迁移您的模块。第一个模块通常是某种实用程序代码。考虑可视化依赖图来帮助您跟踪进度。</li><li id="3d6d" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">当你发现奇怪的设计时，抵制重构代码的冲动。为将来的重构保留一个想法列表，但是要把重点放在类型脚本转换上。</li><li id="d551" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">请注意转换过程中出现的常见错误。如有必要，复制JSDoc注释，以避免在转换时失去类型安全性。</li></ul><h2 id="4d03" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第62条:在启用无迁移之前，不要认为迁移完成</h2><p id="dc7c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要记住的事情[有效打字稿，第235页]:</p><ul class=""><li id="85b2" class="mr ms iq lu b lv mm ly mn lf mt lj mu ln mv mk nh mx my mz bi translated">在采用noImplicitAny之前，不要认为您的TypeScript迁移已经完成。松散的类型检查可以掩盖类型声明中的真正错误。</li><li id="bc5b" class="mr ms iq lu b lv na ly nb lf nc lj nd ln ne mk nh mx my mz bi translated">在强制执行无插入之前，逐渐修复类型错误。在采用更严格的检查之前，给你的团队一个熟悉TypeScript的机会。</li></ul><h2 id="43e7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">参考</h2><ul class=""><li id="d149" class="mr ms iq lu b lv lw ly lz lf nl lj nm ln nn mk nh mx my mz bi translated">【有效打字稿】:范德卡姆，丹，ed。(2019) <em class="ml">有效的打字稿:改善你打字稿的62种具体方法</em>。第一版。塞瓦斯托波尔:奥莱利</li></ul><p id="c02c" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">快乐阅读:)</p></div></div>    
</body>
</html>