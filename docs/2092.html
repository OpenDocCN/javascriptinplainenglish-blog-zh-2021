<html>
<head>
<title>React-Leaflet v3: Creating a Mapping Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react-活页v3:创建地图应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-leaflet-v3-creating-a-mapping-application-d5477f19bdeb?source=collection_archive---------5-----------------------#2021-05-03">https://javascript.plainenglish.io/react-leaflet-v3-creating-a-mapping-application-d5477f19bdeb?source=collection_archive---------5-----------------------#2021-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/eac8e6958a61b9705ca86c2035389c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzDvYF7H94e-x4QHi5JT-g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Thanks for the view, NASA!</figcaption></figure><p id="aa18" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你读过我的文章“<a class="ae kx" href="https://medium.com/@jharriswebdev/using-leaflet-js-in-a-react-project-build-a-mapping-application-f97aeef25c33" rel="noopener">在React项目中使用fleet . js:构建一个地图应用</a>”，那么你就会知道我们可以在React项目中创建一个全功能的传单地图，而不需要使用<a class="ae kx" href="https://react-leaflet.js.org/" rel="noopener ugc nofollow" target="_blank">React-fleet</a>绑定。如果你没看过，那就去看看吧！</p><p id="95e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是我们创建的传单组件的代码:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="12c2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这工作得很好，但是我们的代码不是很有反应性，因为我们用vanilla传单操作DOM，并把所有东西渲染到一个“map”div中。让我们来看看如何用React-Leaflet创建一个合适的开源React地图应用程序。</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="7f0d" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">一些需要记住的事情</h1><p id="d797" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">重要的是要记住，反应传单不是取代传单。它只是提供了一种方法来创建传单层作为React组件，而不是像我们在vanilla-Leaflet/React应用程序中使用的那样使用<code class="fe mo mp mq mr b">useRef</code> / <code class="fe mo mp mq mr b">useEffect</code>设置。这意味着我们的React-小叶组件的行为可能与标准React组件不同。来自<a class="ae kx" href="https://react-leaflet.js.org/docs/start-introduction" rel="noopener ugc nofollow" target="_blank">React-传单文档</a>:</p><h2 id="bfca" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">DOM渲染</h2><blockquote class="ne nf ng"><p id="0725" class="jz ka nh kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw ig bi translated">React不会将小叶层渲染到DOM，这种渲染是由小叶本身完成的。React在渲染<code class="fe mo mp mq mr b"><a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#mapcontainer" rel="noopener ugc nofollow" target="_blank">MapContainer</a></code> <a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#mapcontainer" rel="noopener ugc nofollow" target="_blank">组件</a><a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#ui-layers" rel="noopener ugc nofollow" target="_blank">UI层组件</a>的内容时，只渲染一个<code class="fe mo mp mq mr b">&lt;div&gt;</code>元素。</p></blockquote><p id="cdca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">还记得我们如何在<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/using-leaflet-js-in-a-react-project-6b23c30ed464">普通传单贴图</a>中将所有东西渲染到一个div中吗？React-Leaflet也在幕后做着同样的事情。</p><h2 id="ac4a" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">组件属性</h2><blockquote class="ne nf ng"><p id="7fde" class="jz ka nh kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw ig bi translated">当组件第一次呈现时，传递给组件的属性用于创建相关的小叶实例，并且在默认情况下应该被视为不可变的。</p><p id="448c" class="jz ka nh kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw ig bi translated">在第一次渲染时，所有这些属性都应该被活页支持，但是当它们改变时不会在UI中更新，除非它们被明确地记录为可变的。</p><p id="0da0" class="jz ka nh kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw ig bi translated">可变属性变化通过引用进行比较(除非另有说明)，并通过调用小叶元素实例上的相关方法来应用。</p></blockquote><p id="4975" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">同样，这与我们的香草传单地图非常相似。小叶元素只有在组件第一次安装时才被实例化，就像我们使用<code class="fe mo mp mq mr b">useEffect</code>钩子一样，然后使用refs修改。</p><h2 id="68af" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">反应上下文</h2><blockquote class="ne nf ng"><p id="fbf3" class="jz ka nh kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw ig bi translated">React Leaflet使用<a class="ae kx" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React的上下文API </a>使一些Leaflet elements实例对需要它的子元素可用。</p><p id="be85" class="jz ka nh kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw ig bi translated">每个传单地图实例都有自己的React上下文，由<code class="fe mo mp mq mr b"><a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#mapcontainer" rel="noopener ugc nofollow" target="_blank">MapContainer</a></code> <a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#mapcontainer" rel="noopener ugc nofollow" target="_blank">组件</a>创建。React小叶提供的其他组件和钩子只能作为一个<code class="fe mo mp mq mr b">MapContainer</code>的后代。</p></blockquote><p id="91f4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">React-Leaflet使用上下文API使它的实例和状态对它的所有子节点可用。一旦我们开始处理地图事件，您将会看到一个这样的例子。</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="26df" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">入门指南</h1><p id="488e" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">为了使设置更容易，我有一个<a class="ae kx" href="https://stackblitz.com/edit/react-leaflet-medium-demo-starter" rel="noopener ugc nofollow" target="_blank">启动器供你在Stack Blitz </a>上使用。如果您喜欢在本地机器上继续操作，请查看文档的<a class="ae kx" href="https://react-leaflet.js.org/docs/start-installation" rel="noopener ugc nofollow" target="_blank">安装部分。<strong class="kb io">记得安装传单和React-传单！</strong>另请注意，我们将在本演示中使用来自</a><a class="ae kx" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>的一些样式和组件。你也可以克隆这个<a class="ae kx" href="https://github.com/jharris711/react-leaflet-medium-demo-final" rel="noopener ugc nofollow" target="_blank"> GitHub repo的成品代码</a>。</p><p id="9037" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在<code class="fe mo mp mq mr b">public/index.html</code>中，我们可以粘贴传单的CSS和Javascript文件的CDN链接:</p><h2 id="810e" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">index.html</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><p id="2a56" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，我们可以设置我们的<code class="fe mo mp mq mr b">MapContainer</code>和地图平铺层。<code class="fe mo mp mq mr b">MapContainer</code>创建小叶图实例，并通过<a class="ae kx" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>与其所有子实例共享该实例。就我们的目的而言，我们现在只是将<code class="fe mo mp mq mr b">center</code>、<code class="fe mo mp mq mr b">zoom</code>、<code class="fe mo mp mq mr b">style</code>、<code class="fe mo mp mq mr b">zoomControl</code>道具传递给<code class="fe mo mp mq mr b">MapContainer</code>而已，但是你可以在中查看这个<a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#mapcontainer" rel="noopener ugc nofollow" target="_blank">道具列表以备后用。我们将把地图的中心放在美国(<code class="fe mo mp mq mr b">[37.0902, -95.7129]</code>)上，将<code class="fe mo mp mq mr b">zoom</code>设置为<code class="fe mo mp mq mr b">3</code>，将<code class="fe mo mp mq mr b">zoomControl</code>设置为<code class="fe mo mp mq mr b">false</code>，因为我们将一点一点地添加一个。<code class="fe mo mp mq mr b">style</code>支柱也需要设定高度和宽度。</a></p><p id="826a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在<code class="fe mo mp mq mr b">src/map</code>中我们可以创建一个名为<code class="fe mo mp mq mr b">Map.jsx</code>的新文件，然后将其导入到我们的<code class="fe mo mp mq mr b">App.js</code>文件中:</p><h2 id="48dc" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Map.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><h2 id="c95f" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">App.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><p id="785c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，您的屏幕上应该有一个空地图，如下所示:</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/1ff21ce3ede8706e21841b3d86d86997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RX89gezo5HYOZmTbw8sTPQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Excited yet?</figcaption></figure></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="13a5" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">添加控件</h1><p id="cd7e" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">现在我们已经启动并运行了地图，让我们添加一个<code class="fe mo mp mq mr b">Z<a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#zoomcontrol" rel="noopener ugc nofollow" target="_blank">oomControl</a></code>和一个<code class="fe mo mp mq mr b">L<a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#layerscontrol" rel="noopener ugc nofollow" target="_blank">ayersControl</a></code>。</p><p id="cefb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mo mp mq mr b">ZoomControl</code>超级简单。我们需要导入<code class="fe mo mp mq mr b">ZoomControl</code>组件，并将其放在<code class="fe mo mp mq mr b">TileLayer</code>组件的正下方。我们还想传递一个<code class="fe mo mp mq mr b">position</code>道具给它，值<code class="fe mo mp mq mr b">'topright'</code>:</p><h2 id="4e5a" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Map.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><p id="e7d7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mo mp mq mr b">LayersControl</code>有点不同。我们可以导入这个组件，并将其放在我们刚刚设置的<code class="fe mo mp mq mr b">ZoomControl</code>的正上方。然后，我们使用<code class="fe mo mp mq mr b">LayersControl.BaseLayers</code>和<code class="fe mo mp mq mr b">LayersControl.Overlay</code>将我们的图层添加到控件中。稍后我们将使用<code class="fe mo mp mq mr b">LayersControl.Overlay</code>组件来切换图层，如标记和圆圈，但现在，我们将把<code class="fe mo mp mq mr b">TileLayer</code>组件放在<code class="fe mo mp mq mr b">LayersControl.BaseLayers</code>组件内。让我们也添加第二个地图平铺选项，这样我们就可以实际使用我们的层控制。前往<a class="ae kx" href="https://leaflet-extras.github.io/leaflet-providers/preview/" rel="noopener ugc nofollow" target="_blank">传单提供者</a>演示，选择第二个要使用的图块，然后像这样设置您的代码:</p><h2 id="899d" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Map.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/bf155b096a5aa99766959fa0986dc772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zN_huq4v-gEXjLkRWYGG7g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Sweet controls, bro.</figcaption></figure><p id="d397" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">关于这方面的进一步阅读，<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-a-react-leaflet-control-component-with-leaflet-routing-machine-8eef98259f20">查看这篇关于如何使用React-Leaflet核心API </a>创建定制控件组件的文章。</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="d563" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">访问映射实例和事件监听器</h1><p id="fe8d" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">回想一下这篇文章的部分的<strong class="kb io">要记住的事情。我们了解到<code class="fe mo mp mq mr b">MapContainer</code>使小叶地图实例对其子节点可用，而访问该状态的挂钩仅对其子节点可用。正因为如此，将<code class="fe mo mp mq mr b">MapContainer</code>逻辑从层逻辑中分离出来对我们是有好处的。在<code class="fe mo mp mq mr b">src/map</code>中，让我们创建一个名为<code class="fe mo mp mq mr b">Layers.jsx</code>的新文件，并将我们的<code class="fe mo mp mq mr b">LayersControl</code>组件复制/粘贴到这里:</strong></p><h2 id="7337" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><h2 id="33b2" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Map.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><p id="eac4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">传单地图实例有许多方法可用于<a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#map-methods-for-getting-map-state" rel="noopener ugc nofollow" target="_blank">获取</a>和<a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#map-methods-for-modifying-map-state" rel="noopener ugc nofollow" target="_blank">设置</a>其状态。为了使用这些方法，React-leafle为我们提供了<code class="fe mo mp mq mr b"><a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#usemap" rel="noopener ugc nofollow" target="_blank">useMap</a></code> <a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#usemap" rel="noopener ugc nofollow" target="_blank">钩子</a>。假设我们想要得到地图的初始边界和缩放级别。我们将调用组件顶部的<code class="fe mo mp mq mr b">useMap</code>，并将其赋给一个变量，比如说<code class="fe mo mp mq mr b">map</code>，然后每当我们想要使用活页贴图方法时，就引用该变量:</p><h2 id="47a5" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><p id="1430" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，如果我们想在每次边界和缩放级别改变时获取它们，我们可以使用<code class="fe mo mp mq mr b"><a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#usemapevents" rel="noopener ugc nofollow" target="_blank">useMapEvents</a></code> <a class="ae kx" href="https://react-leaflet.js.org/docs/api-map#usemapevents" rel="noopener ugc nofollow" target="_blank">钩子</a>。我们以与<code class="fe mo mp mq mr b">useMap</code>挂钩相同的方式导入它，但是我们将把<a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#map-event" rel="noopener ugc nofollow" target="_blank">传单地图事件处理程序</a>附加到地图实例，如下所示:</p><h2 id="5bec" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="e4f6" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用GeoJSON显示数据</h1><p id="5585" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">在构建地图应用程序的过程中，很有可能会以geoJSON格式获取和显示数据。如果您不熟悉geoJSON格式，请从这里的 开始<a class="ae kx" href="https://sumit-arora.medium.com/what-is-geojson-geojson-basics-visualize-geojson-open-geojson-using-qgis-open-geojson-3432039e336d#:~:text=The%20GeoJSON%20is%20a%20format,JavaScript%20Object%20Notation%20(JSON).&amp;text=And%20GeoJSON%20basically%20uses%20this,properties%2C%20and%20their%20spatial%20extents." rel="noopener"> <strong class="kb io">。我们的地图目前以美国为中心，所以我们将使用怀俄明州、蒙大拿州和南达科他州的地理数据。我已经在<code class="fe mo mp mq mr b">src/data</code>中为每个状态设置了包含geoJSON的文件。</strong></a></p><p id="1203" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了显示geoJSON，我们将使用<code class="fe mo mp mq mr b"><a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#geojson" rel="noopener ugc nofollow" target="_blank">GeoJSON</a></code> <a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#geojson" rel="noopener ugc nofollow" target="_blank">反作用-小叶层组件</a>。我们将数据导入到<code class="fe mo mp mq mr b">Layers.jsx</code>中，将数据放入一个处于状态的数组中，然后使用<code class="fe mo mp mq mr b">.map()</code>迭代该数组并返回<code class="fe mo mp mq mr b">GeoJSON</code>层。当迭代数据时，我们需要传递在每组geoJSON的<code class="fe mo mp mq mr b">features</code>数组中找到的<code class="fe mo mp mq mr b">geometry</code>属性，它给<code class="fe mo mp mq mr b">GeoJSON</code>层提供要创建的层的类型和坐标。我们还需要为每个GeoJSON层提供一个唯一的密钥，所以我们将使用在每个<code class="fe mo mp mq mr b">features</code>数组的<code class="fe mo mp mq mr b">properties</code>中找到的<code class="fe mo mp mq mr b">display_name</code>。如果您想改变<code class="fe mo mp mq mr b">GeoJSON</code>图层的样式，可以将<a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#path" rel="noopener ugc nofollow" target="_blank">选项对象传递给<code class="fe mo mp mq mr b"><a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#path" rel="noopener ugc nofollow" target="_blank">pathOptions</a></code><code class="fe mo mp mq mr b">LayersControl</code></a><a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#path" rel="noopener ugc nofollow" target="_blank">道具</a>。以下是所有这些将会是什么样子:</p><h2 id="9523" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/4ed160c9e9822fcb11c59a11680739f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJ8d39UDrr1y4KytmjEe7w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Those are some good lookin’ states, right there.</figcaption></figure></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="88f0" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">向图层控件添加覆盖</h1><p id="ff8f" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">为了给我们的<code class="fe mo mp mq mr b">LayersControl</code>添加基础图层，我们对每个要添加到地图中的基础图层使用<code class="fe mo mp mq mr b">LayersControl.BaseLayer</code>。这是一个非常相似的过程，以添加所需的覆盖。代替<code class="fe mo mp mq mr b">LayersControl.BaseLayer</code>，我们将在<code class="fe mo mp mq mr b">LayersControl.Overlay</code>中包装我们的图层，提供一个<code class="fe mo mp mq mr b">name</code>并将<code class="fe mo mp mq mr b">checked</code>设置为等于<code class="fe mo mp mq mr b">true</code>，这样图层默认出现在地图上:</p><h2 id="b8b0" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/317ad3788858de25c3d49532ec7f9d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QiLk6QK6QX4UWqesYilvCA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Montana &amp; South Dakota: A Love Story</figcaption></figure></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="e303" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用图层组添加标记和弹出窗口</h1><p id="c07f" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">比方说，我们想通过显示一些与geoJSON一起使用的标记来为地图的UI添加更多内容。创建点标记非常简单。我们只需导入<a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#marker" rel="noopener ugc nofollow" target="_blank"> React-Leaflet的</a> <code class="fe mo mp mq mr b"><a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#marker" rel="noopener ugc nofollow" target="_blank">Marker</a></code> <a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#marker" rel="noopener ugc nofollow" target="_blank">层组件</a>，用<code class="fe mo mp mq mr b">Geojson</code>层组件包装它，并将我们将使用<a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#latlng" rel="noopener ugc nofollow" target="_blank"> Leaflet的</a> <code class="fe mo mp mq mr b"><a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#latlng" rel="noopener ugc nofollow" target="_blank">LatLng</a></code> <a class="ae kx" href="https://leafletjs.com/reference-1.7.1.html#latlng" rel="noopener ugc nofollow" target="_blank">方法</a>创建的一个latLng对象传递给它的<code class="fe mo mp mq mr b">position</code> prop。我们还将导入<code class="fe mo mp mq mr b"><a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#popup" rel="noopener ugc nofollow" target="_blank">Popup</a></code> <a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#popup" rel="noopener ugc nofollow" target="_blank">图层组件</a>，添加一些文本，并用<code class="fe mo mp mq mr b">Marker</code>组件将其包装。我们也可以使用像<a class="ae kx" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"> Material UI </a>这样的库来给我们的弹出窗口添加一些额外的样式。现在，我们将只使用材质UI <code class="fe mo mp mq mr b">Typography</code>和<code class="fe mo mp mq mr b">Divider</code>组件:</p><h2 id="af6f" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/c24bd85b4a318f470284569d61dc95d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyPCrbNX8nA-jmkgc2aJpQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Montana is super cool, I swear.</figcaption></figure><p id="4cf1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意到什么奇怪的事情了吗，特别是关于<code class="fe mo mp mq mr b">LayersControl</code>？每个名字都出现了两次。这是因为<code class="fe mo mp mq mr b">LayersControl</code>为同名的边框和点标记添加了切换，这是我们不希望发生的。要解决这个问题，我们只需告诉<code class="fe mo mp mq mr b">LayersControl</code>说<code class="fe mo mp mq mr b">GeoJson</code>和<code class="fe mo mp mq mr b">Marker</code>组件是<code class="fe mo mp mq mr b">LayerGroup</code>的一部分。只需导入<a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#layergroup" rel="noopener ugc nofollow" target="_blank"> React-Leaflet </a> <code class="fe mo mp mq mr b"><a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#layergroup" rel="noopener ugc nofollow" target="_blank">LayerGroup</a></code> <a class="ae kx" href="https://react-leaflet.js.org/docs/api-components#layergroup" rel="noopener ugc nofollow" target="_blank">组件</a>，并将其作为<code class="fe mo mp mq mr b">GeoJSON</code>和<code class="fe mo mp mq mr b">Marker</code>的包装器:</p><h2 id="51e8" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/0cc5474ba36b7df37b6141c169e5c2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OT_qcufXH0qIgF9g4ipAsw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">I heard Kanye lives around here somewhere…</figcaption></figure></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="b2cb" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">层事件处理程序</h1><p id="4dff" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">有时我们想要修改地图上的元素，比如用<code class="fe mo mp mq mr b">onmouseover</code>事件改变<code class="fe mo mp mq mr b">GeoJSON</code>的<code class="fe mo mp mq mr b">fillOpacity</code>，然后再改变<code class="fe mo mp mq mr b">onmouseout</code>。为了增加这个功能，我们将使用<code class="fe mo mp mq mr b">GeoJSON</code>的<code class="fe mo mp mq mr b">eventHandlers</code>属性:</p><h2 id="7a0e" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="ea0b" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">包裹</h1><p id="6d4d" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">好了，我们现在有了一个用React-Leaflet版本3构建的工作地图应用程序！下面是我们代码的最终版本(<a class="ae kx" href="https://github.com/jharris711/react-leaflet-medium-demo-final" rel="noopener ugc nofollow" target="_blank"> GitHub </a>):</p><h2 id="bfc4" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Layers.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><h2 id="b366" class="ms lm in bd ln mt mu dn lr mv mw dp lv kk mx my lz ko mz na md ks nb nc mh nd bi translated">Map.jsx</h2><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="nl ld l"/></div></figure><p id="40d8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我鼓励你通读这些文档，因为你可以用这个包做很多很酷的事情。</p><p id="bbf0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在你练习使用React-Leaflet公共API提供的所有钩子和组件之后，去看看文档的<a class="ae kx" href="https://react-leaflet.js.org/docs/core-introduction" rel="noopener ugc nofollow" target="_blank">核心API部分。核心API允许您创建自定义传单组件，并扩展第三方传单插件以与React-Leaflet一起工作。</a></p><p id="7ce0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了帮助你理解核心API是如何工作的，<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/creating-an-ellipse-in-react-leaflet-72e2c5beff03"> <strong class="kb io">看看我写的这篇文章</strong> </a>向你展示如何用<a class="ae kx" href="https://github.com/jdfergason/Leaflet.Ellipse#leafletellipse" rel="noopener ugc nofollow" target="_blank">传单创建一个定制的椭圆组件。椭圆</a>。你也可以<a class="ae kx" href="https://jharriswebdev.medium.com/how-to-create-a-react-leaflet-control-component-with-leaflet-routing-machine-8eef98259f20" rel="noopener">看看这篇文章，这篇文章</a>向你展示了如何用传单-路由-机器创建定制的控制组件。</p><p id="f5cf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你喜欢这篇文章，请留下你的掌声，并关注我的文章。也可以在<a class="ae kx" href="https://www.linkedin.com/in/joshsharris/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。感谢阅读！</p><p id="64f7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae kx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>