<html>
<head>
<title>A Deep Dive into Shallow Copy and Deep Copy in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究JavaScript中的浅层复制和深层复制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/shallow-copy-and-deep-copy-in-javascript-a0a04104ab5c?source=collection_archive---------1-----------------------#2021-02-07">https://javascript.plainenglish.io/shallow-copy-and-deep-copy-in-javascript-a0a04104ab5c?source=collection_archive---------1-----------------------#2021-02-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e01d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript中的数据类型可以分为两大类——<strong class="jm io"><em class="ki">原始数据类型</em> </strong>和<strong class="jm io"> <em class="ki">引用数据类型。</em> </strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/67f3ad1edcda8c89f56f2c5af02dc7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NdX4JHxJEqjEc4C31KLsQ.png"/></div></div></figure><p id="ee1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">原始数据类型:</strong>赋给原始数据类型变量的值是<strong class="jm io">紧耦合</strong>。这意味着，每当您创建原始数据类型变量的副本时，该值都会被复制到新变量所指向的新内存位置。当你制作副本时，它将是一个<strong class="jm io">真实副本。</strong></p><p id="4c64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">引用数据类型:</strong>然而，对于引用数据类型，它存储存储对象的内存位置的地址。复制引用数据类型有两种，分别是<strong class="jm io">浅复制</strong>和<strong class="jm io">深复制</strong>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kv"><img src="../Images/bc56ac98ad1f79609a8e5e45b240a607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWaSRnWAYdJ1FG2NjkqVew.png"/></div></div></figure><h1 id="f2b9" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">浅抄</strong></h1><p id="f5bf" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">浅拷贝<em class="ki"> </em>简单地<strong class="jm io">指向原始集合结构(对象或数组)的引用地址</strong>，它保存新变量中的值，即只拷贝集合结构，不拷贝元素。</p><p id="3575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当字段值是<strong class="jm io"> </strong>引用类型时，它只是复制引用地址，不会创建新对象。被引用的对象因此被<em class="ki">共享。</em></p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="f692" class="me kx in ma b gy mf mg l mh mi"><em class="ki">let originalObject= {name: "apple", type: "fruit"};<br/>let clonedObject= originalObject;</em></span><span id="4ceb" class="me kx in ma b gy mj mg l mh mi"><em class="ki">clonedObject.name = ‘orange’;</em></span><span id="2bd1" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Output</em></strong><em class="ki">:<br/>clonedObject= {name: “orange”, type: “fruit”}<br/>originalObject= {name: “orange”, type: “fruit”}</em></span></pre><p id="a12b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">浅层复制很简单，通常也很便宜，因为它们通常可以通过简单地复制引用地址来实现。类似地，这可以在数组中观察到。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="2681" class="me kx in ma b gy mf mg l mh mi"><em class="ki">let originalArr = [1,2,3];<br/>let clonedArr = originalArr;<br/>clonedArr.push(4);</em></span><span id="8c8d" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Output</em></strong>:<br/><em class="ki">clonedArr = [1,2,3,4]<br/>originalArr= [1,2,3,4]</em></span></pre><p id="0ae4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，没有引用复制对象也有变通方法。</p><p id="2274" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 1。</span> <strong class="jm io"> Spread运算符</strong> ( <code class="fe mt mu mv ma b">…</code>)是对数组或对象进行浅层复制的一种便捷方式——当没有嵌套时，它工作得非常好。</p><p id="8608" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这对于创建不会因旧引用而出现意外行为的新数组实例非常有用。因此，扩展运算符对于在反应状态下添加到数组非常有用。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="e5fe" class="me kx in ma b gy mf mg l mh mi"><strong class="ma io"><em class="ki">Example 1</em></strong>:<br/><em class="ki">let originalObject = {name: “apple”};<br/></em>let clonedObject = {...originalObject};<em class="ki"><br/>clonedObject.name = ‘orange’;</em></span><span id="d241" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Output</em></strong><em class="ki">:<br/>clonedObject= {name: “orange”}<br/>originalObject= {name: “apple”}</em></span><span id="747c" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Example 2</em></strong><em class="ki">:<br/>let originalObject = {name: “apple”, price: {chennai: 120}};<br/></em>let clonedObject = {...originalObject};</span><span id="098e" class="me kx in ma b gy mj mg l mh mi"><em class="ki">clonedObject.name =”orange”; // will not reflect in originalObject<br/>clonedObject.price.chennai = “100”; //will reflect in originalObject also</em></span><span id="4938" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Output</em></strong><em class="ki">:<br/>clonedObject = {name: “orange”, price: {chennai: 100}}<br/>originalObject = {name: “apple”, price: {chennai: 100}}</em></span></pre><p id="0d90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 2。</span> <strong class="jm io"> Object.assign() </strong>方法将源对象的可枚举属性复制到目标对象。此外，只有当对象/数组包含基本类型值时，才能使用这种方法。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="5bea" class="me kx in ma b gy mf mg l mh mi"><strong class="ma io"><em class="ki">Example 1</em></strong>:<br/><em class="ki">let originalObject = {name: “apple”};<br/>let clonedObject = Object.assign({}, originalObject);<br/>clonedObject.name = ‘orange’;</em></span><span id="1026" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Output</em></strong><em class="ki">:<br/>clonedObject= {name: “orange”}<br/>originalObject= {name: “apple”}</em></span><span id="2ea4" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Example 2</em></strong><em class="ki">:<br/>let originalObject = {name: “apple”, price: {chennai: 120}};<br/>let clonedObject = Object.assign({}, originalObject);</em></span><span id="5378" class="me kx in ma b gy mj mg l mh mi"><em class="ki">clonedObject.name =”orange”; // will not reflect in originalObject<br/>clonedObject.price.chennai = “100”; //will reflect in originalObject also</em></span><span id="98c4" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Output</em></strong><em class="ki">:<br/>clonedObject = {name: “orange”, price: {chennai: 100}}<br/>originalObject = {name: “apple”, price: {chennai: 100}}</em></span></pre><p id="86d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 3。</span> <strong class="jm io"> Slice() </strong> —特别是对于数组，使用内置的<code class="fe mt mu mv ma b">.slice()</code>方法与spread操作符的工作原理相同—创建一个级别的浅层副本:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="4e67" class="me kx in ma b gy mf mg l mh mi"><strong class="ma io"><em class="ki">Example 1</em></strong>:<br/>let originalArr = [1,2,3,4,5]<br/>let clonedArr = originalArr.slice();<br/>clonedArr.push(6);</span><span id="db02" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Output</em></strong><em class="ki">:<br/></em>originalArr <em class="ki">= </em>[1, 2, 3, 4, 5]<em class="ki"><br/></em>clonedArr <em class="ki">= </em>[1, 2, 3, 4, 5, 6]</span></pre><p id="4662" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 4。</span> <strong class="jm io"> Array.from() </strong> —另一种复制JavaScript数组的方法是使用<code class="fe mt mu mv ma b">Array.from()</code>，这也将进行浅层复制。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="8787" class="me kx in ma b gy mf mg l mh mi"><strong class="ma io"><em class="ki">Example 1</em></strong>:<br/>let originalArr = [1,2,3,4,5]<br/>let clonedArr = Array.from(originalArr);<br/>clonedArr.push(6);</span><span id="fc3f" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io"><em class="ki">Output</em></strong><em class="ki">:<br/></em>originalArr <em class="ki">= </em>[1, 2, 3, 4, 5]<em class="ki"><br/></em>clonedArr <em class="ki">= </em>[1, 2, 3, 4, 5, 6]</span></pre><p id="8c23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些方法<strong class="jm io"> </strong>将<strong class="jm io">复制到第一级</strong>。如果对象包含任何嵌套对象或数组，那么内部复制的引用类型值将引用其内存地址，即浅复制将意外工作，因为嵌套对象实际上没有被克隆。为了克服这一点，我们需要迭代和复制，直到最后一级，但这种方法是昂贵的，不推荐。对于深度嵌套的对象，需要一个深度副本。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="6fc9" class="kw kx in bd ky kz nd lb lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt bi translated"><strong class="ak">深度复制</strong></h1><p id="4aa9" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">它只是创建一个<strong class="jm io">副本</strong>，将<em class="ki">源对象</em>的所有属性复制到<em class="ki">目标对象中。</em>换句话说，基元类型和引用类型属性都将被分配给<strong class="jm io">新的内存位置</strong>。</p><p id="2a80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，如果<em class="ki">源对象</em>变得不存在，那么<em class="ki">目标对象</em>仍然存在于内存中。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ni"><img src="../Images/a46efe0cdb6182bdb8d6df1c90820d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRe3J-4HOZkEbGU4zWlfdA.jpeg"/></div></div></figure><p id="1e2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正确的说法应该是<strong class="jm io">克隆</strong>，这里你知道它们完全相同，但又不同(即作为两个不同的实体存储在内存空间中)。</p><p id="9717" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它用于将JavaScript对象复制到一个新的变量，而不是通过引用。</p><p id="993d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">严格相等运算符(<code class="fe mt mu mv ma b">===</code>)表明嵌套引用对于浅拷贝是相同的，而对于深拷贝是不同的。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="7272" class="me kx in ma b gy mf mg l mh mi">const nestedArr = [["1"] ,["2"] ,["3"]];<br/>const nestedCopyWithSpread = [...nestedArr];</span><span id="c9b7" class="me kx in ma b gy mj mg l mh mi">console.log(nestedArr[0] === nestedCopyWithSpread[0]); <br/>// true -- Shallow copy (same reference)</span><span id="06d3" class="me kx in ma b gy mj mg l mh mi">const nestedCopyWithJSON = JSON.parse(JSON.stringify(nestedArr));</span><span id="8c60" class="me kx in ma b gy mj mg l mh mi">console.log(nestedArr[0] === nestedCopyWithJSON[0]);<br/>// false -- Deep copy (different references)</span></pre><p id="3d78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有许多制作深层副本(或深层克隆)的方法:</p><p id="30d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 1。</span><strong class="jm io"/>—<strong class="jm io"/>如果不在对象中使用<code class="fe mt mu mv ma b">Date</code>、函数、<code class="fe mt mu mv ma b">undefined</code>、<code class="fe mt mu mv ma b">Infinity</code>、【NaN】、正则表达式、映射、集合、Blobs、文件列表、ImageDatas、稀疏数组、类型化数组或其他复杂类型，深度克隆对象的一个非常简单的一行程序是:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="5085" class="me kx in ma b gy mf mg l mh mi"><strong class="ma io">var clonedObject = JSON.parse(JSON.stringify(originalObject));</strong></span><span id="e5a2" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io">Example</strong>:</span><span id="422a" class="me kx in ma b gy mj mg l mh mi"><em class="ki">let originalObject = {name: “apple”, price: {chennai: 120}};<br/>let clonedObject = </em>JSON.parse(JSON.stringify(originalObject));</span><span id="124f" class="me kx in ma b gy mj mg l mh mi"><em class="ki">clonedObject.name =”orange”;<br/>clonedObject.price.chennai = “100”;</em></span><span id="63f1" class="me kx in ma b gy mj mg l mh mi"><strong class="ma io">Output</strong><em class="ki">:<br/>clonedObject = {name: “orange”, price: {chennai: 100}}<br/>originalObject = {name: “apple”, price: {chennai: 120}}</em></span></pre><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f835" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 2。</span><strong class="jm io">Lodash—</strong>It<strong class="jm io"/>是一个JavaScript库，它提供了多个实用函数，Lodash库最常用的函数之一是<strong class="jm io"> cloneDeep() </strong>方法。这个方法有助于对象的深度克隆，还可以克隆不可序列化的属性，这是JSON.stringify()方法的一个限制。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="585a" class="me kx in ma b gy mf mg l mh mi">import _ from "lodash" // Import the entire lodash library</span><span id="7eb2" class="me kx in ma b gy mj mg l mh mi">//import { clone, cloneDeep } from "lodash" // Alternatively: Import just the clone methods from lodash</span><span id="a0f3" class="me kx in ma b gy mj mg l mh mi">const nestedArr = [["1"] ,["2"] ,["3"]];</span><span id="35ad" class="me kx in ma b gy mj mg l mh mi">const shallowCopyWithLodashClone = _.clone(nestedArr)<br/>console.log(nestedArr[0] === shallowCopyWithLodashClone[0]);<br/>// true -- Shallow copy (same reference)</span><span id="0697" class="me kx in ma b gy mj mg l mh mi">const deepCopyWithLodashCloneDeep = _.cloneDeep(nestedArray)<br/>console.log(nestedArr[0] === deepCopyWithLodashCloneDeep[0]);<br/>// false -- Deep copy (different reference)</span></pre><p id="a2bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 3。</span> <strong class="jm io"> Ramda — </strong>函数式编程库Ramda包含了<code class="fe mt mu mv ma b">R.clone()</code>方法，可以对对象或数组进行深度复制。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="7838" class="me kx in ma b gy mf mg l mh mi">import R from "ramda" // Import the entire ramda library</span><span id="8b50" class="me kx in ma b gy mj mg l mh mi">// import { clone } from "ramda" // Alternatively: Import just the clone methods from ramda</span><span id="a0bf" class="me kx in ma b gy mj mg l mh mi">const nestedArr = [["1"] ,["2"] ,["3"]];</span><span id="628e" class="me kx in ma b gy mj mg l mh mi">const deepCopyWithRamdaClone = R.clone(nestedArray)<br/>console.log(nestedArr[0] === deepCopyWithRamdaClone[0]);<br/>// false -- Deep copy (different reference)</span></pre><p id="ccb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 4。</span> <strong class="jm io">自定义函数— </strong>编写一个递归JavaScript函数来制作嵌套对象或数组的深层副本是相当容易的。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="409f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 5。</span> <strong class="jm io"> rdfc — </strong>为了获得最佳性能，库<code class="fe mt mu mv ma b">rfdc</code>(真正快速的深度克隆)进行深度复制的速度将比lodash的<code class="fe mt mu mv ma b">_.cloneDeep.</code>快大约400%,使用<code class="fe mt mu mv ma b">rfdc</code>非常简单，就像其他库一样:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="bea4" class="me kx in ma b gy mf mg l mh mi">const clone = require('rfdc')() // Returns the deep copy function<br/>clone({a: 37, b: {c: 3700}}) // {a: 37, b: {c: 3700}}</span></pre><ul class=""><li id="2a64" class="nl nm in jm b jn jo jr js jv nn jz no kd np kh nq nr ns nt bi translated"><code class="fe mt mu mv ma b">rdfc</code>克隆所有JSON类型:<code class="fe mt mu mv ma b">Object, Array, Number, String, null</code></li><li id="3b77" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated">附加支持:<code class="fe mt mu mv ma b">Date</code>(复制)、<code class="fe mt mu mv ma b">undefined</code>(复制)、<code class="fe mt mu mv ma b">Function</code>(引用)、<code class="fe mt mu mv ma b">AsyncFunction</code>(引用)、<code class="fe mt mu mv ma b">GeneratorFunction</code>(引用)、<code class="fe mt mu mv ma b">arguments</code>(复制到普通对象)</li><li id="e038" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated">所有其他类型的输出值与<code class="fe mt mu mv ma b">JSON.parse(JSON.stringify(o))</code>的输出相匹配。</li><li id="895b" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated"><code class="fe mt mu mv ma b">rfdc</code>库支持所有类型，也支持带有可选标志的循环引用，这会降低大约25%的性能。</li><li id="8f46" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated">循环引用会破坏其他讨论过的深度复制算法。如果你正在处理一个大型复杂的对象，比如从3MB的JSON文件中加载的对象(大小为15MB ),这样的库会很有用。</li></ul></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="ebcb" class="kw kx in bd ky kz nd lb lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt bi translated">复制算法的性能</h1><p id="42c3" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在各种复制算法中，浅层复制是最快的，其次是使用自定义函数或<code class="fe mt mu mv ma b">rfdc.</code>从最好到最差排序的深层复制<em class="ki"> :- </em></p><ol class=""><li id="bdea" class="nl nm in jm b jn jo jr js jv nn jz no kd np kh nz nr ns nt bi translated">重新分配"<code class="fe mt mu mv ma b">=</code>"(仅字符串数组、数字数组)</li><li id="373d" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nz nr ns nt bi translated">切片(仅字符串数组、数字数组)</li><li id="8b99" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nz nr ns nt bi translated">自定义函数:for循环或递归复制/ <code class="fe mt mu mv ma b">rfdc</code></li><li id="c2fe" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nz nr ns nt bi translated"><code class="fe mt mu mv ma b">JSON.parse</code>(仅字符串数组、数字数组、对象数组)</li><li id="a3e8" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nz nr ns nt bi translated">洛达什的<code class="fe mt mu mv ma b">_.cloneDeep</code></li></ol></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="f92c" class="kw kx in bd ky kz nd lb lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt bi translated">结论</h1><ul class=""><li id="da97" class="nl nm in jm b jn lu jr lv jv oa jz ob kd oc kh nq nr ns nt bi translated">事实上，在JavaScript中避免深度复制是很容易的——如果你不能将对象和数组嵌套在一起的话。因为在这种情况下——没有嵌套，对象和数组只包含原始值——使用spread操作符(<code class="fe mt mu mv ma b">…</code>)、<code class="fe mt mu mv ma b">.slice()</code>和<code class="fe mt mu mv ma b">.assign()</code>进行浅层复制都很有效。</li><li id="d81c" class="nl nm in jm b jn nu jr nv jv nw jz nx kd ny kh nq nr ns nt bi translated">但是，在现实世界中，对象内部有数组，反之亦然，那么就需要使用深度拷贝。我推荐<code class="fe mt mu mv ma b">rfdc</code>给深度克隆。</li></ul><p id="a6c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(注意，有些人也可能建议使用<code class="fe mt mu mv ma b">JSON.stringify()</code>后接<code class="fe mt mu mv ma b">JSON.parse()</code>，但这不是制作深层副本的可靠方式。)</p></div></div>    
</body>
</html>