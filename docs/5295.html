<html>
<head>
<title>Use React and Feature Flags To Roll Out New UI Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和Feature标志推出新的UI组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-react-and-feature-flags-to-roll-out-new-ui-components-eba130f28729?source=collection_archive---------0-----------------------#2021-10-31">https://javascript.plainenglish.io/use-react-and-feature-flags-to-roll-out-new-ui-components-eba130f28729?source=collection_archive---------0-----------------------#2021-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="39fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">随着开关的拨动</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a188467fff9db43f71aa8373d8f5b86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sViPWB4sXg5xE1TT"/></div></div></figure><p id="90e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近，在<a class="ae ln" href="https://www.getparallax.com/" rel="noopener ugc nofollow" target="_blank"> Parallax </a>，我和我的团队对我们的用户界面进行了一次彻底的更新。我们更新了按钮、输入、选择、对话框和许多其他视觉元素。以下是对这一努力的一小部分的解释。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="e67c" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">问题</h1><p id="0fcb" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">2021年夏天，我和我的团队面临了一些有趣的挑战。下一组工作将包括:</p><ul class=""><li id="0488" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">用新的样式更新我们的许多共享组件(按钮、输入、选择、对话框等)</li><li id="bff6" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">这些更新中有许多会影响设计，但我们也会抓住机会精简组件API</li><li id="8b2c" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">我们应该计划<em class="ng">而不是</em>能够一次发布所有内容。这样做将意味着巨大的变化和高风险的发布</li><li id="e5b5" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">我们应该能够在不改变代码的情况下在新旧组件变体之间进行切换</li></ul><p id="b0fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们深入研究一下。</p><p id="62a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更新设计并不是什么新鲜事。这经常发生，这是我们计划好的。一次做这么多是全新的，也是一项相当大的任务。</p><p id="85eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一次做这么多的更改，同时还要继续维护当前的组件，这又增加了一层复杂性。这是必要的，否则我们会错过我们必须做出这些改变的窗口，在这将结束后不久，新的功能工作就要开始了。这种巨大的变化将导致大量的技术债务。它增加了在<strong class="kt ir">T5之前和T7之后的努力。我们同意这一点，但这不是一个折扣。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/d22043cda8f7fcdda7449e96c8b868d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cPFx-0XPU4uapH0z"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Photo by <a class="ae ln" href="https://unsplash.com/@marekpiwnicki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marek Piwnicki</a> on <a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7f4d" class="lv lw iq bd lx ly nm ma mb mc nn me mf jw no jx mh jz np ka mj kc nq kd ml mm bi translated">思维能力</h1><p id="36f7" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">进入这个项目时，我们知道我们需要某种<a class="ae ln" href="https://martinfowler.com/articles/feature-toggles.html" rel="noopener ugc nofollow" target="_blank">特征标志</a>。我们已经在UI(和BE)中的其他地方使用了<a class="ae ln" href="https://launchdarkly.com/" rel="noopener ugc nofollow" target="_blank">Launch darky</a>,所以那个部分已经就位了。</p><p id="662d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了特性标志解决方案之后，下一个主要挑战是找到一种方法来保留当前的组件，同时更新每个实现以按需使用新的变化。这使得事情变得有趣。我们是就地更新，还是在旧版本的基础上增加新版本？这两种策略各有利弊，经过深思熟虑后，我们认为这两种策略都不是正确的前进方向。我们会两者都用！</p><p id="0fa5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，随着大方向的确定，我们需要找出一些方法来按需在旧的或新的组件变体之间切换，<strong class="kt ir">而不必改变任何代码</strong>。我们的UI是基于<a class="ae ln" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>(具体来说就是<a class="ae ln" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>)构建的，所以这实际上是一次相当短暂的冒险。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="f992" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">解决办法</h1><p id="432b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">经过相当多的深思熟虑，我们决定创建一个名为<code class="fe nr ns nt nu b">UiExperiment</code>的新组件(我们在共享组件前加了前缀<code class="fe nr ns nt nu b">Ui</code>，以便于识别)。该组件将接受一个<em class="ng">【旧】</em>组件和一个<em class="ng">【新】</em>组件(<code class="fe nr ns nt nu b">ReactNode</code>)作为道具，并且还接受一个道具来确定哪一个应该呈现哪一个将由特征标志驱动。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">UiExperiment React component, with Typescript</figcaption></figure><p id="39ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ng">注:</em><code class="fe nr ns nt nu b"><em class="ng">ExperimentName</em></code><em class="ng"/><code class="fe nr ns nt nu b"><em class="ng">Experiment</em></code><em class="ng">住在这个部件旁边只是为了便于演示。在现实生活中，这些都生活在一个</em> <code class="fe nr ns nt nu b"><em class="ng">*.constants.ts </em></code> <em class="ng">和</em> <code class="fe nr ns nt nu b"><em class="ng">*.types.ts</em></code> <em class="ng">文件旁边的组件文件中。</em></p><p id="6e47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据设计，这是一个非常简单的组件。如果<code class="fe nr ns nt nu b">isExperimentActive</code>作为<code class="fe nr ns nt nu b">false</code>传递，那么渲染作为<code class="fe nr ns nt nu b">props.a</code>传递的内容。如果作为<code class="fe nr ns nt nu b">true</code>传递，则渲染<code class="fe nr ns nt nu b">props.b</code>。在现实生活中，<code class="fe nr ns nt nu b">isExperimentActive</code>的值来自于一个特征标志。不过，你可能会看到，这可能会比我们在这里所做的更加强大。也许利用这样的组件进行真正的实验，或者用它进行访问控制，等等。</p><p id="2124" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在在应用程序中使用<code class="fe nr ns nt nu b">UiExperiment</code>非常简单。在我们将旧组件换成新组件的地方，我们在当前组件周围添加<code class="fe nr ns nt nu b">UiExperiment</code>，然后在其旁边添加新组件。我们现在可以做所有这些工作，继续推向生产，当我们准备好向我们的用户发布这些更新时，只需"<em class="ng">拨动开关"</em><em class="ng"/>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Example usage of UiExperiment component</figcaption></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="d696" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">等一下，我们再来看看那些<code class="fe nr ns nt nu b">props</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">UiExperiment props and supporting types</figcaption></figure><p id="5e83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们为什么要这样设置<code class="fe nr ns nt nu b">props</code>？嗯，我们正在做一些未来的工作。我们构建这个组件是为了解决今天的一个问题，但我们很早就意识到它也可以用于其他一些很酷的事情。如果我们想在两个以上的组件上做实验呢？还是基于某种旗帜提供不同的体验？</p><p id="17b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nr ns nt nu b">UiExperiment</code>原来的api没有使用道具<code class="fe nr ns nt nu b">isExperimentActive</code>，只是一个简单的标志。相反，我们将<code class="fe nr ns nt nu b">ExperimentName</code>作为一个名为<code class="fe nr ns nt nu b">activeExperiment.</code>的道具传递，这意味着我们可以进行<code class="fe nr ns nt nu b">n</code>次实验<em class="ng">和</em>它将是强类型的！</p><p id="1384" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不过，我要说的是，我们在这里使用简单切换的原因是，在实践中，这实际上比我们计划的要多。实现组件必须先做一些逻辑工作来传递正确的枚举，而不是传递标志，这并不理想。它最终变得太笨重，导致代码更难阅读。</p><p id="c77b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将来我们可能会带回那个道具，但是对于这个项目来说，它没有任何意义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/729aa37a28ca2c9402a37df5dc24b0d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KuSbG_9VWTVEbHJV"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Photo by <a class="ae ln" href="https://unsplash.com/@ratushny?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dmitry Ratushny</a> on <a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7e73" class="lv lw iq bd lx ly nm ma mb mc nn me mf jw no jx mh jz np ka mj kc nq kd ml mm bi translated">学习</h1><h2 id="f02c" class="ny lw iq bd lx nz oa dn mb ob oc dp mf la od oe mh le of og mj li oh oi ml oj bi translated">现有组件API</h2><p id="c339" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">一些读者可能想知道为什么我们没有把这个逻辑开关放在每个现有的UI组件中？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">What if we used a flag on existing components?</figcaption></figure><p id="4571" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们当然可以做到这一点，在某些情况下我们做到了。不过，在很大程度上，我们希望有一些可移植的东西，在整个应用程序中易于重复。当我们在一个组件上使用了一个标志时，通常是因为我们只是切换了样式，仅此而已。在这些情况下，将标志放在组件上是有意义的。</p><p id="2186" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一部分原因是因为大部分时间工作不仅仅是更新设计，还包括更新组件API。在许多情况下，更有意义的做法是构建全新的简单组件，然后利用<code class="fe nr ns nt nu b">UiExperiment</code>在新旧版本之间切换。</p><h2 id="7291" class="ny lw iq bd lx nz oa dn mb ob oc dp mf la od oe mh le of og mj li oh oi ml oj bi translated">清除</h2><p id="fcae" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">这项工作需要计划在发布前完成工作，但也需要在发布后完成工作。使用<code class="fe nr ns nt nu b">UiExperiment</code>会招致技术债务，我们计划在发布后尽快移除。</p><p id="04fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nr ns nt nu b">UiExperiment</code>的一个好处是新的组件版本已经就位。一旦我们准备好清理并删除所有旧代码，我们就删除了围绕新实现的东西。这将是纯粹的减法，这使得这一点更容易。我们可以很容易地移除包装<code class="fe nr ns nt nu b">UiExperiment</code>并删除旧的组件，我们就完成了。Typescript将通过从组件中移除prop并处理任何作为结果弹出的TS错误来指导我们使用<code class="fe nr ns nt nu b">isV1</code>标志。</p><h2 id="5455" class="ny lw iq bd lx nz oa dn mb ob oc dp mf la od oe mh le of og mj li oh oi ml oj bi translated">命名</h2><p id="c7cc" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们仍然对道具名<code class="fe nr ns nt nu b">a</code>和<code class="fe nr ns nt nu b">b</code>不满意。我和我的团队非常认真地对待命名，这两个名字仍然感觉像…嗯，这些本来可以更好。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9ac3" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="c31f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">这个组件成了我们的救命稻草！它允许我们在将功能推向生产的同时，进行所有的UI更新。因为我们提前计划使用功能标志，我们可以通过<a class="ae ln" href="https://launchdarkly.com/" rel="noopener ugc nofollow" target="_blank">黑暗启动</a>和针对特定用户的目标标志状态更进一步。这意味着在我们向所有用户推出之前，我们可以在生产的幕后测试所有的设计更新！</p><p id="c6b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最终，这个组件完成了我们需要的一切，甚至更多，并继续存在于我们的应用中。事实上，我们在数百个地方使用这种技术所产生的技术债务也比我们想象的要少。在我们发布这些更新后，我们能够移除所有与这项工作相关的<code class="fe nr ns nt nu b">UiExperiments</code>。我们计划了大约整整两周，但结果我们不需要它，它只需要一周！！🎉</p><p id="5c53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想自己动手修补和<code class="fe nr ns nt nu b">UiExperiment</code>，我为我的读者准备了一个简单的<a class="ae ln" href="https://codesandbox.io/s/ui-experiment-example-eoj94" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>。</p><p id="c4e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你以前做过类似的事情吗？有没有更好的办法？我很想听听，请在评论中告诉我吧！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="d775" class="ny lw iq bd lx nz oa dn mb ob oc dp mf la od oe mh le of og mj li oh oi ml oj bi translated">参考</h2><ul class=""><li id="9315" class="ms mt iq kt b ku mn kx mo la ok le ol li om lm mx my mz na bi translated"><a class="ae ln" href="https://martinfowler.com/articles/feature-toggles.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/articles/feature-toggles.html</a></li><li id="4d21" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><a class="ae ln" href="https://launchdarkly.com/" rel="noopener ugc nofollow" target="_blank">https://launchdarkly.com/</a></li><li id="6b6f" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><a class="ae ln" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/</a></li><li id="6f37" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><a class="ae ln" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/</a></li><li id="5554" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><a class="ae ln" href="https://medium.com/counterarts/tinker-with-purpose-9fb4f5a52459" rel="noopener">https://medium . com/counterarts/tinker-with-purpose-9 FB 4 F5 a 52459</a></li><li id="0a67" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><a class="ae ln" href="https://codesandbox.io/s/ui-experiment-example-eoj94" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/ui-experiment-example-eoj94</a></li></ul><p id="8728" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ng">更多内容请看</em><a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ng">plain English . io</em></strong></a></p></div></div>    
</body>
</html>