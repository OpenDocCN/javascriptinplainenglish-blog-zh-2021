# 两个和问题:哈希映射解决方案

> 原文：<https://javascript.plainenglish.io/two-sum-problem-hash-map-solution-581779a56022?source=collection_archive---------6----------------------->

## 如果你在算法上挣扎，害怕它们，或者只是不知道从哪里开始，这篇文章是给你的！

![](img/ffe8e4961b1b486a4a716af37138c8b7.png)

我们可以一起来看一个最常见的、“简单”级别的求职面试问题:**两个总和**。这个问题有很多种，所以一定要向你的面试官澄清给定场景的确切措辞/细节，并考虑任何潜在的边缘情况(如空数组、重复元素、负数或 0 等)。你的面试官会欣赏你的想法，可能会给你更多的信息，对你有很大的帮助。我将把重点放在标准的问题场景上，它的措辞相当宽容，大概是这样的:

*“给定一个非空的非重复整数数组和一个目标和，返回两个数字(任意顺序)的数组，这两个数字的和达到目标和。”*

快速边注:有时你可能会得到一个“真实生活”的场景，这实际上是**两个伪装的总和**，这实际上发生在我的一个朋友身上。他被要求考虑一系列不同长度的电影，一次飞行的总时长，并被要求编写一个算法，返回两个不同的电影，其长度加起来等于一次飞行的长度。这是典型的“伪装的两个总和”,你需要能够很快发现这一点。

## **解决方案**

通常有三种方法来解决这个问题，它们的效率程度不同:暴力破解(效率最低)、二分搜索法(比暴力破解好，但还不够好)和散列图/表(最佳解决方案)。

我现在将提供一种编写散列映射解决方案的可能方法，然后解释为什么它是三种方法中最有效的。

```
function twoSum(array, target) { let storage = {}  // declaring our storage hash for (const num of array) { const comp = target - num

  if (comp in storage) {

   return [comp, num]

  } else {

   storage[num] = true  // storing the integer in our hash

  } }

 return [] // if no match is found, return an empty array}
```

我认为这里最重要的一行是 *for* 循环中的第一行，在这里我们声明了一个*const*comp(comp 的缩写)。如果我们有一个整数数组，我们将通过一个接一个地寻找我们的获胜对，我们也有一个目标和，我们需要知道我们需要添加到数组中的每个整数，以弥补和。我们通过从目标总和中减去 num(数组中的整数)来计算这个数字。

现在我们有了丢失的部分，我们需要检查我们在开始时声明的(最初为空的)存储散列，看看它是否有我们的补整数。在迭代的第一层，当我们还在查看数组中的第一个整数时，我们的存储散列是空的，所以我们将第一个整数作为值为 true 的**键**存储在那里。我们对数组中的每个整数做同样的事情，在我们的散列中寻找补码，如果我们还没有存储它，我们就把我们的整数存储在散列中，然后继续处理数组中的下一个整数。我们的散列随着我们在数组中移动而增长，使用散列作为参考点，并用不成功的整数填充它，直到我们遍历了整个数组。如果在查看了数组中的每个整数之后，我们都没有找到补数，那么我们将返回一个空数组，以表示没有两个不同的整数可以加到目标上。此时，我们也将数组中的每个整数放入存储哈希中。

它有助于将这个过程可视化，这个过程本质上是两个步骤:从数组中的第一个数字开始，检查最初为空的散列的补码，然后将第一个数字存储在散列中。然后查看数组中的第二个数字，并在哈希中查找包含第一个(前一个)数字的补码。如果在散列中找不到补码，就移动到第三个数字，重复这个过程，直到找到补码。

由于哈希映射作为一种数据结构的性质，这种解决方案是最佳的。如果你走蛮力路线，你将会以无数的嵌套循环结束，这将是昂贵的。二分搜索法路线会变得不必要的复杂(在我看来),有更多的代码行，而且比哈希表更昂贵。一般来说，我建议在需要重复查找时使用散列。对于时间和空间复杂度来说，哈希映射解决方案的成本是 **O(n)，因为它只需要检查内存中的特定位置。**

希望这对你的算法之旅有所帮助！

*更多内容尽在*[***plain English . io***](https://plainenglish.io/)