<html>
<head>
<title>API Server Setup with Express.js and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express.js和TypeScript设置API服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/api-server-setup-with-express-js-and-typescript-part-2-531f9546993c?source=collection_archive---------1-----------------------#2021-02-22">https://javascript.plainenglish.io/api-server-setup-with-express-js-and-typescript-part-2-531f9546993c?source=collection_archive---------1-----------------------#2021-02-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="51f2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:创建模型、路由器和控制器</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4727d56770d6c554640bc7915f101833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xu6sBN2e6ExZS68FS83hgQ.png"/></div></div></figure><p id="92f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上一个教程中，我们创建了一个非常基本的Express.js的“Hello World”实现。在本系列的这一部分中，我们将创建一个模型、路由器和控制器。目标是创建一个电影查找API。</p><p id="db79" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">打开我们在<a class="ae lk" href="https://wardprice.medium.com/api-server-setup-with-express-js-mongodb-and-typescript-part-1-bea7e4f5b526" rel="noopener">上一个教程</a>里做的app me。如果你现在刚刚加入，你可以从我的github上克隆下来，这里<a class="ae lk" href="https://github.com/woink/expressBlog/tree/8c5b9f599860daf5a48dda79e813a47a1bb20751" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="51a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，现在我们准备好了，首先让我们安装<code class="fe ll lm ln lo b">body-parser</code>。尽管到目前为止我们只有一个非常简单的服务器，但是当我们开始添加来自和去往<code class="fe ll lm ln lo b">body-parser</code>的请求时，我们的生活会变得更加容易。它获取原始请求，提取我们需要在服务器中处理的数据，并将其放在<code class="fe ll lm ln lo b">req.body</code>上。</p><h1 id="464f" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">安装bodyParser</h1><p id="062b" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">在您的终端中运行以下命令。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="ce48" class="mq lq in lo b gy mr ms l mt mu">$ npm i body-parser</span></pre><p id="8fa3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了将它合并到我们的服务器中，让我们通过将这一行添加到我们的<code class="fe ll lm ln lo b">index.ts</code>文件的顶部来导入它。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="b4ae" class="mq lq in lo b gy mr ms l mt mu">import bodyParser from 'body-parser'</span></pre><p id="c45f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，在当前的<code class="fe ll lm ln lo b">app.get()</code>语句之上，我们添加了以下两个命令。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="a9db" class="mq lq in lo b gy mr ms l mt mu">app.use(bodyParser.json())<br/>app.use(bodyParser.urlencoded({ extended: true }))</span></pre><p id="f611" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是做什么的？<code class="fe ll lm ln lo b">app.use</code>安装以下函数，如果路径与请求中指定的路径匹配，将运行该函数。函数<code class="fe ll lm ln lo b">bodyParser.json()</code>将解析json请求中的文本，并将该对象装载到<code class="fe ll lm ln lo b">req.body</code>中。下一行，<code class="fe ll lm ln lo b">bodyParser.urlencoded({ extended: true })</code>将文本解析为URL编码的数据，并将结果对象装载到<code class="fe ll lm ln lo b">req.body</code>上，这对于post请求非常重要，因为URL编码的数据是浏览器从表单发送post请求的方式。更多信息请查看<a class="ae lk" href="https://stackoverflow.com/questions/38306569/what-does-body-parser-do-with-express/48364778" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出帖子</a>。</p><p id="e7a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们，因为我们要添加一个路由器，继续删除这条线。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="8ee9" class="mq lq in lo b gy mr ms l mt mu">app.use('/', (req, res) =&gt; {<br/>  res.send('Hello World!')<br/>})</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="f8b4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">最初设置路由器</h1><p id="c5c1" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">在<code class="fe ll lm ln lo b">src</code>文件夹中创建3个文件夹，<code class="fe ll lm ln lo b">routes</code>，<code class="fe ll lm ln lo b">controllers</code>，<code class="fe ll lm ln lo b">models</code>。我们将利用<a class="ae lk" href="https://en.wikipedia.org/wiki/Model–view–controller" rel="noopener ugc nofollow" target="_blank"> MVC模式</a>创建这个api，但是当然没有视图。</p><p id="0436" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在routes文件夹中创建文件<code class="fe ll lm ln lo b">index.ts</code>。我们将导入<code class="fe ll lm ln lo b">express</code>，然后创建路由器并将其导出，以便我们可以在<code class="fe ll lm ln lo b">src/index.ts</code>中使用它。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="b92a" class="mq lq in lo b gy mr ms l mt mu">import express from 'express'</span><span id="adbc" class="mq lq in lo b gy mx ms l mt mu">const router = express.Router()</span><span id="f478" class="mq lq in lo b gy mx ms l mt mu">export default router</span></pre><p id="8b81" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ll lm ln lo b">src/index.ts</code>文件中导入我们新创建的路由器。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="f8fa" class="mq lq in lo b gy mr ms l mt mu">import routes from './routes'</span></pre><p id="0a99" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就在<code class="fe ll lm ln lo b">bodyParser</code>语句的下面加上这一行。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="d5da" class="mq lq in lo b gy mr ms l mt mu">app.use(routes)</span></pre><p id="03c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个路由器索引还没有做任何事情，但那是因为我们没有路由！接下来让我们创建控制器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="bc7f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nf">我知道这有点令人困惑，我们现在有两个</em> <code class="fe ll lm ln lo b"><em class="nf">index.ts</em></code> <em class="nf">文件，但是在Node.js中，当你将一个文件夹导入到一个组件时，如果没有指定文件，Node.js将查找一个</em> <code class="fe ll lm ln lo b"><em class="nf">index.ts</em></code> <em class="nf">文件。此外，正如您将看到的，我们刚刚创建的</em> <code class="fe ll lm ln lo b">routes/index.ts</code> <em class="nf">文件将充当相应控制器的切换面板。稍后会有更多的介绍… </em></p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="d1dc" class="lp lq in bd lr ls ng lu lv lw nh ly lz jt ni ju mb jw nj jx md jz nk ka mf mg bi translated">设置控制器</h1><p id="bd95" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">在控制器文件夹中添加一个文件名<code class="fe ll lm ln lo b">moviesController.ts</code>。这个文件将处理访问某个端点时发生的逻辑。现在，在这个文件中，我们必须导入express要使用的类型。</p><p id="5fc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在文件的顶部添加…</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="e741" class="mq lq in lo b gy mr ms l mt mu">import { Request, Response, NextFunction } from 'express'</span></pre><p id="e782" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，为了给路由器做好准备，让我们再次创建“Hello World”响应。</p><p id="9523" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">创建一个名为<code class="fe ll lm ln lo b">getHello</code>的函数。我们将创建一个普通的同步函数，因为这将是简单而直接的。在本系列的下一部分，我们将添加MongoDB作为我们的数据库。然后我们将使这些函数异步。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="857d" class="mq lq in lo b gy mr ms l mt mu">function getHello(req: Request, res: Response, next: NextFunction) {<br/>  res.send('Hello World!')<br/>}</span></pre><p id="56a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们必须导出该函数，以便在路由器中使用。在文件的底部添加以下内容…</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="70ec" class="mq lq in lo b gy mr ms l mt mu">export default { getHello }</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="de12" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">将路线连接到控制器</h1><p id="7bfa" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">在routes文件夹中创建一个名为<code class="fe ll lm ln lo b">movieRoutes.ts</code>的新文件，导入express并导入我们刚刚创建的控制器，以及像我们之前在<code class="fe ll lm ln lo b">routes/index.ts</code>文件中所做的那样创建一个路由器。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="074a" class="mq lq in lo b gy mr ms l mt mu">import express form 'express'<br/>import moviesController from '../controllers/movieController'</span><span id="02cf" class="mq lq in lo b gy mx ms l mt mu">const router = express.Router()</span><span id="253d" class="mq lq in lo b gy mx ms l mt mu">export default router</span></pre><p id="6aaf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们到达<code class="fe ll lm ln lo b">'/'</code>端点时，我希望它从我们的<code class="fe ll lm ln lo b">getHello</code>函数返回<code class="fe ll lm ln lo b">Hello World</code>。在<code class="fe ll lm ln lo b">export default router</code>行之前添加以下行。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="e76e" class="mq lq in lo b gy mr ms l mt mu">router.get('/', movieController.getHello)</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a532" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好吧，就差一点了！现在我们需要做的就是将它合并到<code class="fe ll lm ln lo b">routes/index.ts</code>中。导入<code class="fe ll lm ln lo b">movieRoutes.ts</code>文件，然后利用路由器允许它被使用。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="e170" class="mq lq in lo b gy mr ms l mt mu">import movieRoutes from './movieRoutes'</span><span id="5658" class="mq lq in lo b gy mx ms l mt mu">router.use('/api/v1/movies', movieRoutes)</span></pre><p id="ce0b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">太好了。现在如果我们在终端运行<code class="fe ll lm ln lo b">npm start</code>。然后导航到<code class="fe ll lm ln lo b">localhost:3000/api/v1/movies</code>它应该返回<code class="fe ll lm ln lo b">Hello World!</code>。我们现在有了一个更模块化、更容易维护的基础。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="c12f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可能会问自己，为什么我们为<code class="fe ll lm ln lo b">moviesController</code>创建了一个<code class="fe ll lm ln lo b">routes/index.ts</code>文件，然后又创建了另一个路由器文件？嗯，这是为未来而建。如果api真的要升级到新版本，我们需要做的就是在新电影控制器的routes文件中设置该路由。这将一切分开，所以更容易找到快速有效地做出改变的地方。</p><p id="6433" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下次，我们添加MongoDB！</p><p id="b451" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://github.com/woink/expressBlog/tree/8400e6a999491bc5aeb384d326dafe718f0be617" rel="noopener ugc nofollow" target="_blank">克隆完整代码</a></p><p id="345b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">快乐编码！！</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="4b64" class="lp lq in bd lr ls ng lu lv lw nh ly lz jt ni ju mb jw nj jx md jz nk ka mf mg bi translated">系列教程</h1><p id="eab8" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated"><a class="ae lk" href="https://wardprice.medium.com/api-server-setup-with-express-js-mongodb-and-typescript-part-1-bea7e4f5b526" rel="noopener"> <strong class="kq io">第1部分:“你好，世界！”</strong> </a></p><p id="7895" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">第2部分:设置路由器</strong></p><p id="2d11" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://wardprice.medium.com/api-server-setup-with-express-js-typescript-and-mongodb-part-3-b02409f072e4" rel="noopener"> <strong class="kq io">第3部分:连接MongoDB </strong> </a></p></div></div>    
</body>
</html>