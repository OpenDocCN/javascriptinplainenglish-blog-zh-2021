<html>
<head>
<title>Hoisting in JavaScript: A Brief But Comprehensive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的提升:简要而全面的指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hoisting-in-javascript-a-brief-but-comprehensive-guide-4da5e48ab435?source=collection_archive---------5-----------------------#2021-09-10">https://javascript.plainenglish.io/hoisting-in-javascript-a-brief-but-comprehensive-guide-4da5e48ab435?source=collection_archive---------5-----------------------#2021-09-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5e328e930c8396edaa4827fd2a37f474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naTcsMhWic7QYBzPaSc5Nw.png"/></div></div></figure><p id="89e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我解释什么是提升之前，我强烈建议你去看一下我在这个系列的<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/javascript-execution-context-behind-the-scenes-1463a0ef3dd8">上一篇</a>关于JavaScript执行上下文的文章，我也将在这篇文章中<strong class="jx io">简单地</strong>介绍一下。提升与JavaScript如何在幕后执行有很大关系，我已经用非常简单的术语解释了它，并在那篇文章中提供了可视化示例，所以请务必查看。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><blockquote class="lb lc ld"><p id="8c81" class="jv jw le jx b jy jz ka kb kc kd ke kf lf kh ki kj lg kl km kn lh kp kq kr ks ig bi translated"><em class="in">我也有一个单独的视频。你可以在这里看</em><a class="ae kt" href="https://youtu.be/nnCykighqxI" rel="noopener ugc nofollow" target="_blank"><em class="in"/></a><em class="in">。</em></p></blockquote></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="60fe" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">执行环境:简要回顾</h2><p id="b5ca" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">每当您在浏览器上运行JavaScript文件时，都会创建一个执行上下文。执行上下文只是为当前正在执行的代码块创建的环境。因此，在运行文件时，最初会为整个文件创建一个“<strong class="jx io">全局执行上下文”</strong>。当JS引擎遍历文件并遇到一个函数时，会创建一个单独的<strong class="jx io">函数执行上下文</strong>。这些上下文中的代码基本上分两个阶段执行。一个“<strong class="jx io">创建阶段”</strong>和一个“<strong class="jx io">执行阶段</strong>”。</p><p id="74e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在创建阶段，变量和函数声明首先存储在内存<strong class="jx io">中，而</strong>没有用它们的实际值初始化。变量改为用名为“<strong class="jx io">未定义</strong>”的值初始化。在函数的情况下，它们在内存中被原样复制。</p><p id="014e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在执行阶段，变量被赋予它们的原始值，然后脚本被逐行执行。在函数的情况下，如上所述，将创建一个<strong class="jx io">单独的执行上下文</strong>，其再次经历相同的创建- &gt;执行阶段。</p><p id="aaf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，为了更清楚地了解这到底是如何工作的，一步一步地举例，去阅读这个播放列表中的<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/javascript-execution-context-behind-the-scenes-1463a0ef3dd8">上一篇文章</a>。</p><h2 id="8b60" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">什么是吊装？</h2><p id="351e" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">提升这个词的字面意思是举起或举起某物。在JavaScript的上下文中，提升意味着提高或提升变量/函数声明(实际上不是)。让我们看一个简单的例子。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a0c4" class="li lj in ml b gy mp mq l mr ms">1. console.log(name)<br/>2. var name = "James";<br/>3. <br/>4. getName();<br/>5. function getName(){<br/>6.    console.log("My name is " + name)<br/>7. }</span></pre><p id="15b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于以前使用过编译编程语言的人来说，这可能有点奇怪。在声明变量“<strong class="jx io"> name”之前，</strong>我们在第一行访问它。类似地，我们在创建函数"<strong class="jx io"> getName" </strong>之前，在第4行调用了它。您可能认为这将抛出一个错误，但它的工作(有点)没有任何错误。这是输出的样子</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7e02" class="li lj in ml b gy mp mq l mr ms">undefined<br/>My name is James</span></pre><p id="f0fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前所述，javascript文件通常分两个阶段执行，即创建和执行阶段。在执行之前，变量和函数被分配内存。变量用值“<strong class="jx io">未定义</strong>初始化，函数直接存储在内存中。因此，在执行第1行的<strong class="jx io"> console.log </strong>之前，Javascript引擎已经扫描了整个文件，并用“<strong class="jx io"> undefined </strong>”初始化了变量。</p><p id="560a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个甚至在变量和函数执行之前就给它们分配内存的过程叫做<strong class="jx io">提升</strong>。</p><p id="836d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们执行getName函数时，它的声明已经在内存中了，并且在函数之前初始化的Name变量在函数内部是可访问的，所以它像预期的那样工作。</p><h2 id="e9b9" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">怪癖</h2><h2 id="73f7" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated"><strong class="ak"> 1。让</strong> vs <strong class="ak"> var </strong></h2><p id="9353" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">好的，如果你认为你已经理解了提升是如何工作的，让我们来测试一下。您能预测以下代码的输出吗？</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="cac0" class="li lj in ml b gy mp mq l mr ms">1. console.log(name)<br/>2. let name = "James";<br/>3. <br/>4. getName();<br/>5. function getName(){<br/>6.    console.log("My name is " + name)<br/>7. }</span></pre><p id="70c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里唯一不同的是，我们使用了"<strong class="jx io"> let" </strong>来声明名称变量，而不是"<strong class="jx io"> var </strong>"。不幸的是，这种微小的变化会导致错误。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="bea4" class="li lj in ml b gy mp mq l mr ms">ReferenceError: Cannot access 'name' before initialization</span></pre><p id="8884" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为“<strong class="jx io">让</strong>处理<strong class="jx io">变量初始化</strong>与“<strong class="jx io">变量初始化</strong>”不同。<br/>当使用"<strong class="jx io"> var </strong>"时，变量声明&amp;初始化发生在创建阶段本身，随后在执行阶段，它被赋予其原始值。<br/>在“<strong class="jx io"> let </strong>的情况下，只有变量声明发生在创建阶段。它的初始化发生在执行阶段。因此，当我们试图在执行阶段访问该变量时，它只是被声明了，还没有初始化，因此出现了引用错误。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8bf16ff721526f61f6cab6e507ead949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4aVaKwBbMFjw3COYhv8ag.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Difference between let and var declarations</figcaption></figure><h2 id="06bd" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">2.函数表达式</h2><p id="91a6" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">尝试预测下面这段代码的输出。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="915f" class="li lj in ml b gy mp mq l mr ms">1. console.log(name)<br/>2. var name = "James";<br/>3. <br/>4. getName();<br/>5. var getName = function(){<br/>6.    console.log("My name is " + name)<br/>7. }</span></pre><p id="a013" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里唯一的区别是，我们已经使用函数表达式声明了函数getName。这会给我们带来下面的错误。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8432" class="li lj in ml b gy mp mq l mr ms">TypeError: getName is not a function</span></pre><p id="cb9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对提升有正确的理解，你一定知道为什么会这样。当我们用var声明一个函数的时候，JS引擎<strong class="jx io">把它提升为一个变量</strong>。所以当它在执行阶段执行getName函数时，它的内存中没有getName函数。它有一个getName变量。这就是它给我们一个类型错误的原因，说getName不是函数。</p><h2 id="45ab" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">关键要点</h2><ul class=""><li id="aa18" class="mx my in jx b jy mb kc mc kg mz kk na ko nb ks nc nd ne nf bi translated">JavaScript <strong class="jx io">并不真正</strong>提升或举起它的变量声明。</li><li id="e8c8" class="mx my in jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">let &amp; const在创建阶段被<strong class="jx io">声明</strong>，在执行阶段被<strong class="jx io">初始化+赋值</strong>。</li><li id="c457" class="mx my in jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">var在创建阶段被<strong class="jx io">声明+初始化</strong>，在执行阶段被<strong class="jx io">赋值</strong>。</li><li id="4e3c" class="mx my in jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">始终在作用域的顶部声明变量和函数，以避免不良行为。</li><li id="d159" class="mx my in jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">最好使用const来避免由于意外的可变性而引起的混乱</li><li id="bfea" class="mx my in jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated">在你想改变变量的情况下，使用let over var。</li></ul><p id="507a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望这能清楚JS是如何在幕后执行的。我正在将多个高级Javascript概念整理成一系列文章。关注我，了解最新动态。欢迎在评论区分享你的见解或疑问。你可以通过我的社交网站与我联系，如下所述。干杯！</p><p id="c738" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae kt" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae kt" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">Github</a></p><p id="57fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="le">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="le">plain English . io</em></strong></a></p></div></div>    
</body>
</html>