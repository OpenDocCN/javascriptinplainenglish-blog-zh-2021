<html>
<head>
<title>Using TypeScript with hapi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将TypeScript与hapi一起使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-typescript-with-hapi-73af8cc81118?source=collection_archive---------10-----------------------#2021-03-11">https://javascript.plainenglish.io/using-typescript-with-hapi-73af8cc81118?source=collection_archive---------10-----------------------#2021-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ca93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近一直在用<a class="ae kl" href="https://hapi.dev" rel="noopener ugc nofollow" target="_blank"> hapi </a>，决定同时开始用TypeScript。当我看的时候，虽然似乎没有太多的一起使用它们。以下是我学到的。</p><p id="50b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将假设您对JavaScript有一定程度的熟悉，并对什么是TypeScript有基本的了解。</p><p id="b8d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不是这样，我肯定会推荐阅读MDN JavaScript教程，然后是5分钟的脚本介绍。</p><p id="bb1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我选择在下面的例子中使用<a class="ae kl" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank">纱线</a>；如果您使用的是<a class="ae kl" href="https://docs.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>，只需将<code class="fe km kn ko kp b">yarn add</code>改为<code class="fe km kn ko kp b">npm install</code>。</p><p id="07d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经包括了你需要什么来启动和运行系统，并试图在我们进行的过程中进行解释，但这篇文章不会深入到任何特定的点。我试着在我们进行的过程中加入相关的链接，但是如果我遗漏了什么，一定要让我知道，我会试着做得更好。</p><h2 id="2110" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">创建初始服务器</h2><h2 id="733d" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">行政事务</h2><p id="2881" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">第一件事——创建一个项目目录和<code class="fe km kn ko kp b">package.json</code>文件。然后安装<a class="ae kl" href="https://hapi.dev/" rel="noopener ugc nofollow" target="_blank"> hapi </a>用于生产，因为我们知道我们会需要它。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="1289" class="kq kr iq kp b gy lw lx l ly lz">$ mkdir hapi_typescript<br/>$ cd hapi_typescript<br/>$ yarn init -y<br/>$ yarn add @hapi/hapi</span></pre><p id="9f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要更多的开发包。这里我们添加了TypeScript系统本身，以及hapi和node的类型定义。</p><p id="f0c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不安装它们，TypeScript就不知道Node或hapi的任何类型细节，所以它会抱怨一些实际上并不是问题的东西。</p><p id="7d4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望能够看到实际的问题，并从使用Node和hapi的类型安全中受益。这篇文章中的类型定义都来自于<a class="ae kl" href="https://definitelytyped.org/" rel="noopener ugc nofollow" target="_blank">确定类型的</a>。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="5471" class="kq kr iq kp b gy lw lx l ly lz">$ yarn add -D typescript @types/hapi__hapi @types/node<br/>$ yarn add -D nodemon npm-run-all</span></pre><p id="66ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们必须用TypeScript选项创建一个<code class="fe km kn ko kp b">tsconfig.json</code>文件。最简单的办法就是让<code class="fe km kn ko kp b">tsc</code>为我们做这件事。(<code class="fe km kn ko kp b">tsc</code>是TypeScript编译器可执行文件。)</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="9a77" class="kq kr iq kp b gy lw lx l ly lz">$ npx tsc --init</span></pre><p id="8b5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个基本系统，我们将只调整两个选项— <code class="fe km kn ko kp b">outDir</code>(编译后的JavaScript放在哪里)和<code class="fe km kn ko kp b">rootDir</code>(源代码放在哪里):</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="5b53" class="kq kr iq kp b gy lw lx l ly lz">"outDir": "./lib",<br/>    "rootDir": "./src",</span></pre><p id="5b79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管理的最后一点——我们将把这些脚本添加到<code class="fe km kn ko kp b">package.json </code>文件中，以便于开发。</p><p id="989b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">dev:tsc</code>在<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">监视模式</a>下启动编译器，这意味着它会监视任何更改并自动重建。</p><p id="ac33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">dev:serve</code>使用<code class="fe km kn ko kp b"><a class="ae kl" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank">nodemon</a></code>在JavaScript改变时自动重新加载服务器。</p><p id="a1ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">dev</code>使用<code class="fe km kn ko kp b"><a class="ae kl" href="https://github.com/mysticatea/npm-run-all" rel="noopener ugc nofollow" target="_blank">npm-run-all</a></code>同时运行两个命令，所以你不必打开两个终端。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="c46d" class="kq kr iq kp b gy lw lx l ly lz">    "scripts": {<br/>        "dev:tsc": "tsc --watch -p .",<br/>        "dev:serve": "nodemon -e js -w lib lib/main.js",<br/>        "dev": "run-p dev:*"<br/>    }</span></pre><h2 id="17ad" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">代码！</h2><p id="bc30" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">对——现在我们终于可以做一些编码了！我们将把包含服务器安装代码的文件与实际启动它的文件分开。当我们开始添加测试时，它会有回报的。</p><p id="c42d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意变量的类型声明和函数的返回类型。如果你打算使用TypeScript，你也可以从编译器捕捉类型错误中受益…</p><p id="edd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">src/server.ts</code>:</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="7cfa" class="kq kr iq kp b gy lw lx l ly lz">'use strict';<br/><br/>import Hapi from "@hapi/hapi";<br/>import { Server } from "@hapi/hapi";<br/><br/>export let server: Server;<br/><br/>export const init = async function(): Promise&lt;Server&gt; {<br/>    server = Hapi.server({<br/>        port: process.env.PORT || 4000,<br/>        host: '0.0.0.0'<br/>    });<br/><br/>	// Routes will go here<br/><br/>    return server;<br/>};<br/><br/>export const start = async function (): Promise&lt;void&gt; {<br/>    console.log(`Listening on ${server.settings.host}:${server.settings.port}`);<br/>    return server.start();<br/>};<br/><br/>process.on('unhandledRejection', (err) =&gt; {<br/>    console.error("unhandledRejection");<br/>    console.error(err);<br/>    process.exit(1);<br/>});</span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="07ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">src/main.ts</code>:</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="83eb" class="kq kr iq kp b gy lw lx l ly lz">import { init, start } from "./server";<br/><br/>init().then(() =&gt; start());</span></pre><h2 id="9c9d" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">给它一个旋转</h2><p id="f340" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">与其在这里使用<code class="fe km kn ko kp b">yarn dev</code>，不如让我们单独尝试这些阶段。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="572b" class="kq kr iq kp b gy lw lx l ly lz">$ yarn dev:tsc<br/>[19:54:59] Starting compilation in watch mode...<br/><br/>[19:55:00] Found 0 errors. Watching for file changes.</span></pre><p id="6b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，看起来很有希望。Ctrl-C退出并启动服务器:</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="e52f" class="kq kr iq kp b gy lw lx l ly lz">$ yarn dev:serve<br/>yarn run v1.22.10<br/>$ nodemon -e js -w lib lib/main.js<br/>[nodemon] 2.0.7<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] watching path(s): lib/**/*<br/>[nodemon] watching extensions: js<br/>[nodemon] starting `node lib/main.js`<br/>Starting server, listening on 0.0.0.0:4000</span></pre><p id="bee8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还活着！是<strong class="jp ir">活着</strong>！</p><h2 id="d001" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">下一步</h2><p id="3f39" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">嗯；它还活着，但并没有做多少有用的事情。让我们听一个请求并发送一个回复。</p><h2 id="20eb" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">试验</h2><p id="492d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">因为我们正在添加功能，所以让我们添加一个测试。(出于通常的原因，测试是好的；这不是说服你需要他们的地方。)</p><h2 id="652d" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">设置</h2><p id="bb4c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们将在<code class="fe km kn ko kp b">test</code>保留我们的。我们将使用<code class="fe km kn ko kp b"><a class="ae kl" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">chai</a></code>和<code class="fe km kn ko kp b"><a class="ae kl" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">mocha</a></code>来运行它们；因为我们使用的是TypeScript，所以我们还想从DefinitelyTyped添加相关的类型注释。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="b56c" class="kq kr iq kp b gy lw lx l ly lz">$ mkdir test<br/>$ yarn add -D chai mocha @types/chai @types/mocha</span></pre><p id="0826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将使用<code class="fe km kn ko kp b">ts-node</code>来直接运行它们，而不是将它们编译成JavaScript。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="e752" class="kq kr iq kp b gy lw lx l ly lz">$ yarn add -D ts-node</span></pre><p id="e09d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要稍微调整一下<code class="fe km kn ko kp b">tsconfig.json</code>，告诉<code class="fe km kn ko kp b">tsc</code>不要尝试构建测试。将此添加到<code class="fe km kn ko kp b">compilerOptions</code>对象的末尾。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="3c92" class="kq kr iq kp b gy lw lx l ly lz">"exclude": [<br/>    "test"<br/>]</span></pre><p id="a44e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于最后一点管理，我们将把这个脚本添加到<code class="fe km kn ko kp b">package.json</code>中，以便于运行测试。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="ebcb" class="kq kr iq kp b gy lw lx l ly lz">"test": "NODE_ENV=test mocha -r ts-node/register test/**/*.test.ts"</span></pre><h2 id="eb8c" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">实际测试代码！</h2><p id="b6bf" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">最后，是时候添加我们的第一个测试了！</p><p id="6cf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">test/index.test.ts</code>:</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="61b8" class="kq kr iq kp b gy lw lx l ly lz">import { Server } from "@hapi/hapi";<br/>import { describe, it, beforeEach, afterEach } from "mocha";<br/>import { expect } from "chai";<br/><br/>import { init } from "../src/server";<br/><br/>describe("smoke test", async () =&gt; {<br/>    let server: Server;<br/><br/>    beforeEach((done) =&gt; {<br/>        init().then(s =&gt; { server = s; done(); });<br/>    })<br/>    afterEach((done) =&gt; {<br/>        server.stop().then(() =&gt; done());<br/>    });<br/><br/>    it("index responds", async () =&gt; {<br/>        const res = await server.inject({<br/>            method: "get",<br/>            url: "/"<br/>        });<br/>        expect(res.statusCode).to.equal(200);<br/>        expect(res.result).to.equal("Hello! Nice to have met you.");<br/>    });<br/>})</span></pre><p id="2490" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先是导入我们将要使用的各种类型。然后我们从<code class="fe km kn ko kp b">server.ts</code>文件中导入<code class="fe km kn ko kp b">init</code>函数。</p><p id="ce4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每次测试之前，<code class="fe km kn ko kp b">beforeEach</code>函数会创建一个干净的服务器对象，<code class="fe km kn ko kp b">afterEach</code>函数会对其进行清理。分离服务器代码现在有了回报——我们可以初始化测试中使用的服务器，而实际上没有启动它的开销。</p><p id="d31b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试本身利用了hapi <code class="fe km kn ko kp b">inject</code>方法，调用服务器代码，而实际上不必进行HTTP调用。在这里，我们要走的是<code class="fe km kn ko kp b">/</code>路线；您可以看到测试期望调用成功，并带有一条很好的小消息。</p><p id="2ee3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们还没有写那个代码，所以如果我们运行它…</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="77c2" class="kq kr iq kp b gy lw lx l ly lz">0 passing (37ms)<br/>  1 failing<br/><br/>  1) smoke test<br/>       index responds:<br/><br/>      AssertionError: expected 404 to equal 200<br/>      + expected - actual<br/><br/>      -404<br/>      +200<br/><br/>      at hapi-typescript/test/index.test.ts:22:35<br/>      [trace continues]</span></pre><p id="b934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料，失败了。让我们解决这个问题。</p><h2 id="fab2" class="kq kr iq bd ks kt ku dn kv kw kx dp ky jy kz la lb kc lc ld le kg lf lg lh li bi translated">服务器代码</h2><p id="d33c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们现在回到<code class="fe km kn ko kp b">server.ts</code>了。第一件事是修改文件顶部的类型导入，以包含<code class="fe km kn ko kp b">Request</code>类型:</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="8649" class="kq kr iq kp b gy lw lx l ly lz">import { Request, Server } from "@hapi/hapi";</span></pre><p id="70d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将需要它来执行<code class="fe km kn ko kp b">index</code>函数，该函数为我们进行实际的回复。在这种情况下，它只是返回一个字符串，所以我们将它声明为返回类型。声明<code class="fe km kn ko kp b">request</code>的类型可以确保我们不使用该对象上不存在的任何属性或方法。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="7507" class="kq kr iq kp b gy lw lx l ly lz">function index(request: Request): string {<br/>    console.log("Processing request", request.info.id);<br/>    return "Hello! Nice to have met you.";<br/>}</span></pre><p id="b197" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要在<code class="fe km kn ko kp b">init()</code>函数中连接路线，在前面代码中的注释指出了这一点。</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="3b06" class="kq kr iq kp b gy lw lx l ly lz">    server.route({<br/>        method: "GET",<br/>        path: "/",<br/>        handler: index<br/>    });</span></pre><p id="1bf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们进行测试…</p><pre class="lo lp lq lr gt ls kp lt lu aw lv bi"><span id="4529" class="kq kr iq kp b gy lw lx l ly lz">smoke test<br/>    ✓ index responds<br/><br/><br/>  1 passing (33ms)<br/><br/>✨  Done in 2.25s.</span></pre><p id="9114" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">万岁！幸福随之而来！</p><p id="3c81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是在同一个文件中定义的一条路线。下一篇文章将从另一个文件导入路径(通过适当的测试)，但是我认为这篇文章已经足够长了！</p></div></div>    
</body>
</html>