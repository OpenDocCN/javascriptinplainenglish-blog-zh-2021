<html>
<head>
<title>Create an Inverted Proxy in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript创建一个反向代理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introducing-inverted-proxy-8f53429534c6?source=collection_archive---------17-----------------------#2021-06-10">https://javascript.plainenglish.io/introducing-inverted-proxy-8f53429534c6?source=collection_archive---------17-----------------------#2021-06-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1f1e25401822bbd19a1253933cf80964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHfl_W7lWg8oe5ZXF4HTBQ.png"/></div></div></figure><p id="36c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于那些熟悉(或者已经在积极使用)ES6代理对象的人来说，你是否曾经希望它不会改变对象的身份？</p><p id="c6ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您是否曾经希望可以使用带有本机功能的代理对象，这些功能需要原始的、非代理包装的实例？我做到了。</p><p id="6a94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实上，我正在做的一个项目需要这个功能。我一直在使用我在这里提到的<a class="ae kt" href="https://github.com/rdking/ClassicJS" rel="noopener ugc nofollow" target="_blank"> ClassicJS </a>库开发一个基于HTML定制元素的新前端库:</p><div class="ku kv gp gr kw kx"><a href="https://medium.com/javascript-in-plain-english/data-encapsulation-in-javascript-76730d89c3dc" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">JavaScript中的数据封装</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">当JavaScript在Netscape Navigator中首次发布后不久，我第一次遇到它时，它非常…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll jt kx"/></div></div></a></div><p id="b96a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我喜欢像这样一起做多个相关的项目。不管你的测试套件看起来有多完整，在测试你创建的库时，没有什么比实际使用更好的了。这是了解你的库对于你的目标领域有多完整的最快方法。因此，带着这个想法，我在开发新的标记库时改进了ClassJS。</p><p id="2dc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您可能想象的那样，我在ClassicJS中使用代理来进行特权访问控制。唯一的问题是，这意味着ClassicJS产生的实例对象和<code class="fe lm ln lo lp b">class </code>构造函数总是被包装在一个代理中。这对构造函数来说不是问题，因为<code class="fe lm ln lo lp b">customElements.define()</code>可以处理调用代理包装的构造函数。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/a9f9a0a16272f30cbbca1c0d3e5bb8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*-wXVtXHwBw_gqPJ8.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">From: Disney’s Aladdin</figcaption></figure><p id="da63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，为了与HTML定制元素兼容，<code class="fe lm ln lo lp b">class</code>构造函数不允许返回除本机基<code class="fe lm ln lo lp b">class</code>返回的对象之外的任何内容。</p><p id="d432" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，即使是返回tag元素的代理包装版本也会导致<code class="fe lm ln lo lp b">customElements.define()</code>抛出错误。我猜到会发生这种情况，但我想知道是否有一种方法可以返回本机对象，同时允许一些针对它调用的函数将<code class="fe lm ln lo lp b">this</code>视为代理实例，从而允许<code class="fe lm ln lo lp b">private</code>和<code class="fe lm ln lo lp b">protected</code>数据继续工作。</p><p id="d046" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个有点奇怪的需求。代理的正常使用给予用户代理包装的对象，而对该对象的方法的调用接收本机实例(薄膜情况)或代理包装的对象(监视器情况)。我想要的是给用户原生的、未包装的对象，但干扰对成员的访问，用代理包装的对象替代任何调用。</p><p id="689f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是反向代理背后的基本概念。</p><p id="2c1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不想重复车轮，我首先在互联网上做了一些研究。可悲的是，我没有找到任何有用的东西。这看起来不太像是有人试图做同样的事情，或者也许我只是在错误的地方寻找。所以像往常一样，我试着自己做。事实证明这并不难做到，或者至少如果在代理构造的时候能够很容易地识别出需要做特权事情的函数，这并不难做到。</p><h1 id="7e10" class="lz ma in bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">准备“倒置”代理</strong></h1><p id="15ce" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">因为与大多数编程工作相比，想要做这样的事情通常有点冒险，所以我将创建代理定制html标记。</p><p id="d6ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看一看以下内容:</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">jsFiddle of an example Inverted Proxy</figcaption></figure><p id="902e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码给出了一个例子，说明如何从一个本地对象调用成员函数，在函数中使用你的代理对象作为<code class="fe lm ln lo lp b">this</code>。您还可以使用包装函数来实现这种效果。这其实只是一个6步流程:</p><ol class=""><li id="b5bf" class="ne nf in jx b jy jz kc kd kg ng kk nh ko ni ks nj nk nl nm bi translated">获取本机实例对象。</li><li id="f9a0" class="ne nf in jx b jy nn kc no kg np kk nq ko nr ks nj nk nl nm bi translated">创建一个从预期原型继承的新原型对象。</li><li id="6c40" class="ne nf in jx b jy nn kc no kg np kk nq ko nr ks nj nk nl nm bi translated">为新原型中需要使用代理的每个原型成员创建包装函数。这包括访问器方法！</li><li id="b5df" class="ne nf in jx b jy nn kc no kg np kk nq ko nr ks nj nk nl nm bi translated">在实例上设置新原型。</li><li id="1359" class="ne nf in jx b jy nn kc no kg np kk nq ko nr ks nj nk nl nm bi translated">创建实例的新代理，并保存它。</li><li id="8d61" class="ne nf in jx b jy nn kc no kg np kk nq ko nr ks nj nk nl nm bi translated">返回原始实例。</li></ol><p id="5650" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，步骤3的包装函数是由<code class="fe lm ln lo lp b">getDef</code>函数创建的。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Function used to wrap instance members for an inverted proxy.</figcaption></figure><p id="61e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个函数查看原型的属性，使用<code class="fe lm ln lo lp b">makeRedirect</code>为属性定义上的任何函数值创建包装函数。</p><p id="235e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是所有需要代理访问的呼叫被捕获的方式。</p><p id="2a00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们需要实际的包装函数:</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">The actual wrapper generator</figcaption></figure><p id="d03c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道，<code class="fe lm ln lo lp b">eval</code>按说是邪恶的。对于那些相信这一点的人来说，我不想费事去说服你们。虽然<code class="fe lm ln lo lp b">eval</code>可能很危险，但它也有它的好处。对于上面的函数，由于<code class="fe lm ln lo lp b">fn</code>是一个函数，而<code class="fe lm ln lo lp b">makeRedirect</code>正在创建另一个函数，所以使用<code class="fe lm ln lo lp b">eval</code>来确保函数名被正确保存是没有问题的。</p><p id="b8d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由<code class="fe lm ln lo lp b">eval</code>语句创建的函数只是查找在上面的步骤5中创建的代理，并使用它来调用目标函数。</p><h1 id="da00" class="lz ma in bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">结论</h1><p id="309d" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">差不多就是这么多了。有些细节你需要小心。例如，您需要小心处理对本机方法的调用。为了让反向代理为ClassicJS工作，我确保将本机函数绑定到原始实例对象。这意味着代理包装类原型。幸运的是，HTML定制元素功能并不关心标签实例的原型是什么样子。</p><p id="fcc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TC39的本意只是让Proxy成为一种制造膜的工具，但事实证明，它的用途远远超出了他们的预期。这全在于你如何设置事情。现在，如果引擎开发者能让代理工作得更快就好了！</p><p id="584c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ns">更多内容看</em><a class="ae kt" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ns">plain English . io</em></strong></a></p></div></div>    
</body>
</html>