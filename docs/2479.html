<html>
<head>
<title>Stop using actions in Vuex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在Vuex中使用动作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-using-actions-in-vuex-a14e23a7b0e6?source=collection_archive---------0-----------------------#2021-05-22">https://javascript.plainenglish.io/stop-using-actions-in-vuex-a14e23a7b0e6?source=collection_archive---------0-----------------------#2021-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="552b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过将所有“业务逻辑”转移到常规功能中，将其从Vuex商店中移除</h2></div><h2 id="bd29" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题是</h2><p id="3612" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">如果您使用的是Redux或Vuex之类的状态管理库，您很可能会编写大量包含您的业务逻辑的“action”方法。(本文对Vuex和Redux都适用。但由于这几天在用Vuex，我就用Vuex举例)</p><p id="881a" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">以下是Vuex中常见的简化商店定义示例。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6651" class="kc kd in mb b gy mf mg l mh mi">// STORE <strong class="mb io"><br/>import * as searchApiClient from '@/apiClients/searchApiClient';</strong><br/>... <br/>{<br/>  namespaced: true,<br/>  state: {<br/>    isSearchInProgress: false,<br/>    searchResults: {},<br/>  },<br/>  getters: {<br/>    [getterNames.resultsCount]: (state) =&gt;<br/>      (state.searchResults.results || []).length,<br/>  },<br/>  mutations: {<br/>    [mutationNames.searchStarted](state) {<br/>      state.isSearchInProgress = true;<br/>      state.searchResults = {};<br/>    },<br/>    [mutationNames.searchCompleted](state, { results }) {<br/>      state.isSearchInProgress = false;<br/>      state.searchResults = results;<br/>    },<br/>  },<br/>  <em class="mj">actions: {<br/>    </em><strong class="mb io"><em class="mj">async [actionNames.getSearchResultsAsync](context, { query })</em></strong><em class="mj"> {<br/></em><strong class="mb io"><em class="mj">      if (!query) {<br/>        return;<br/>      }</em></strong><em class="mj"><br/>      context.commit(mutationNames.searchStarted);</em></span><span id="4822" class="kc kd in mb b gy mk mg l mh mi"><strong class="mb io"><em class="mj">      const results = await searchApiClient.searchAsync(query);</em></strong></span><span id="beac" class="kc kd in mb b gy mk mg l mh mi"><em class="mj">      context.commit(mutationNames.searchCompleted, { results });<br/>    },<br/>  },</em><br/>}</span></pre><p id="af8e" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">为了使示例完整，当您拥有这个商店时，您可以在Vue组件中使用它，如下所示:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fddd" class="kc kd in mb b gy mf mg l mh mi">// COMPONENT <br/>computed: {<br/>  ...mapState(moduleNames.search, {<br/>    searchResults: (state) =&gt; state.searchResults.results,<br/>    isSearchInProgress: (state) =&gt; state.isSearchInProgress,<br/>  }),<br/>  ...mapGetters(moduleNames.search, [getterNames.resultsCount]),<br/>},<br/>methods: {<br/>  async searchAsync() {<br/>    await <strong class="mb io">this.$store.dispatch</strong>(<br/>      <strong class="mb io">`${moduleNames.search}/${actionNames.getSearchResultsAsync}`</strong>,<br/>      { query: this.query }<br/>    );<br/>  },<br/>},</span></pre><blockquote class="ml mm mn"><p id="7aaa" class="ky kz mj la b lb lr jo ld le ls jr lg mo lt li lj mp lu ll lm mq lv lo lp lq ig bi translated"><strong class="la io">什么是业务逻辑<br/> </strong>这里的<code class="fe mr ms mt mb b">async getSearchResultsAsync(context, params)</code>方法就是你的业务逻辑。它包含:</p><p id="f3b1" class="ky kz mj la b lb lr jo ld le ls jr lg mo lt li lj mp lu ll lm mq lv lo lp lq ig bi translated">*验证<code class="fe mr ms mt mb b">if (!query) {return;}<br/></code> *外部api交互<code class="fe mr ms mt mb b">await searchApiClient.searchAsync(query)<br/></code> *此处不可见，但主要包含其他业务逻辑的编排<code class="fe mr ms mt mb b">context.dispatch('tracking/trackAsync', ....)</code></p></blockquote><p id="168c" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">上面的示例代码表示了一个依赖关系图，如下所示:</p><figure class="lw lx ly lz gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mu"><img src="../Images/dec28b0091fb22400aac46531bd393d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2srH2QESbua3dAv_zFzaw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">An app using Vuex generally looks like this</figcaption></figure><p id="cc0c" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">如您所见，商店很快就变成了“应用程序”。你很有可能对州立图书馆深恶痛绝，但仍然需要使用它们。因为这种代码组织带来了一些问题:</p><ul class=""><li id="3297" class="ng nh in la b lb lr le ls kl ni kp nj kt nk lq nl nm nn no bi translated"><strong class="la io">很难读懂并遵循</strong> <br/>你不直接调用“动作”，而是调用一个<code class="fe mr ms mt mb b">dispatch </code>方法，并给出你的“动作方法”的名称。您依赖于与名称匹配的<em class="mj">字符串。调用代码和被调用函数之间没有直接关系。IDE不能帮助您导航到该操作。您需要对姓名进行字符串搜索，并找到正确的匹配项。❌</em></li><li id="d640" class="ng nh in la b lb np le nq kl nr kp ns kt nt lq nl nm nn no bi translated"><strong class="la io">调试困难</strong> <br/>同上但调试时。调用堆栈被额外的“管道”层弄得错综复杂。❌</li><li id="5ce4" class="ng nh in la b lb np le nq kl nr kp ns kt nt lq nl nm nn no bi translated"><strong class="la io">商店是个怪物</strong> <br/>商店直接依赖于外部API的客户端。业务逻辑通常依赖于外部API访问和其他业务逻辑(碰巧也依赖于其他一些外部API访问)。当一个全局对象包含你的业务逻辑时，它自然会依赖于所有这些。 ❌</li><li id="a23e" class="ng nh in la b lb np le nq kl nr kp ns kt nt lq nl nm nn no bi translated"><strong class="la io">测试难</strong> <br/>你在开始写测试的时候就体会到了这种“依赖”问题带来的悲哀。尝试在一个非平凡的应用程序中模仿你的商店(或你的商店的一部分)。你开始嘲笑你的整个系统，甚至只是为了测试一个微小的功能。❌</li><li id="b7bd" class="ng nh in la b lb np le nq kl nr kp ns kt nt lq nl nm nn no bi translated"><strong class="la io">很难组织</strong> <br/>商业逻辑一般与你的“状态”的不同“子模块”的组合有关。所以有时候，无论你把你的商业逻辑放在哪里，感觉它都不属于那里。(提示:因为它属于别的地方)❌</li></ul><p id="4cfd" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">此外，“store”是您的大型全局单例数据对象。它已经包含了一个对象中的所有数据。当你把你所有的逻辑也放入那个物体时，它就变成了一个热气腾腾的意大利面条/怪物/上帝物体的完美例子。</p><h1 id="b8d8" class="nu kd in bd ke nv nw nx kh ny nz oa kk jt ob ju ko jw oc jx ks jz od ka kw oe bi translated">解决方案</h1><p id="541a" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">存储本质上是一个“内存数据库”,您可以对其进行读写操作。状态管理库在用<code class="fe mr ms mt mb b">mapState</code>和<code class="fe mr ms mt mb b">mapGetters</code>连接从数据库到UI组件的通知机制方面做得很好。这些都是很棒的使用机制，Vuex让它变得特别简单和直观。继续使用<strong class="la io">，但停止使用</strong> <code class="fe mr ms mt mb b"><strong class="la io">actions</strong></code>。将您的业务逻辑转移到普通的旧功能中，并从代码库中完全删除存储操作。</p><p id="e3c5" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">下面是它的样子:</p><figure class="lw lx ly lz gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi of"><img src="../Images/ca4072c84d069b9ba2af3f5ca1f69d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeAHMFy5T5sPHfm_I4diNA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Actions moved out of the store to become “services”</figcaption></figure><p id="53f3" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">上面的例子会变成这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8fc2" class="kc kd in mb b gy mf mg l mh mi">// STORE <br/>{<br/>  namespaced: true,<br/>  state: () =&gt; createInitialState(),<br/>  getters: {<br/>    [getterNames.resultsCount]: (state) =&gt;<br/>      (state.searchResults.results || []).length,<br/>  },<br/>  mutations: {<br/>    [mutationNames.searchStarted](state) {<br/>      state.isSearchInProgress = true;<br/>      state.searchResults = {};<br/>    },<br/>    [mutationNames.searchCompleted](state, { results }) {<br/>      state.isSearchInProgress = false;<br/>      state.searchResults = results;<br/>    },<br/>  },<br/>};</span></pre><p id="269a" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">您可以在常规函数中定义您的业务逻辑:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c3a7" class="kc kd in mb b gy mf mg l mh mi">// SERVICE <strong class="mb io"><br/>import * as searchApiClient from '@/apiClients/searchApiClient';</strong></span><span id="219e" class="kc kd in mb b gy mk mg l mh mi">export async function searchAsync (store, query) {<br/>  if (!!query == false) {<br/>    return;<br/>  }</span><span id="0152" class="kc kd in mb b gy mk mg l mh mi"><strong class="mb io">  store.commit(mutationNames.searchStarted);</strong></span><span id="c7c4" class="kc kd in mb b gy mk mg l mh mi">  const results = await searchApiClient.searchAsync(query);   <strong class="mb io">  </strong></span><span id="ece2" class="kc kd in mb b gy mk mg l mh mi"><strong class="mb io">  store.commit(mutationNames.searchCompleted, { results }); </strong><br/>};</span></pre><p id="6d07" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">尽可能简单地编写您的所有逻辑，并通过突变与您的存储(数据库)进行交互(这是一种“存储库”模式)。干净、简单、整洁。</p><p id="90d7" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">为了使示例完整，您可以在Vue组件中使用商店和服务，如下所示:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0eb8" class="kc kd in mb b gy mf mg l mh mi">// COMPONENT <strong class="mb io"><br/>import * as searchService from '@/services/searchService';</strong><br/>computed: {<br/>  ...mapState(moduleNames.search, {<br/>    searchResults: (state) =&gt; state.searchResults.results,<br/>    isSearchInProgress: (state) =&gt; state.isSearchInProgress,<br/>  }),<br/>  ...mapGetters(moduleNames.search, [getterNames.resultsCount]),<br/>},<br/>methods: {<br/>  async searchAsync() {<br/>    <strong class="mb io"><em class="mj">await searchService.searchAsync(this.$store, this.query);</em></strong><br/>  },<br/>},</span></pre><p id="e567" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">好了，好处:</p><ul class=""><li id="c712" class="ng nh in la b lb lr le ls kl ni kp nj kt nk lq nl nm nn no bi translated"><strong class="la io">更容易阅读和跟随</strong> <br/>无字符串匹配。组件对业务逻辑的调用是直接的。IDE又是你的朋友了。它将让您导航到定义，显示智能感知和参数。所有的好东西。你对其他“业务逻辑方法”的调用也是直接的。代码导航又回到了它应该的样子。✔️</li><li id="f141" class="ng nh in la b lb np le nq kl nr kp ns kt nt lq nl nm nn no bi translated"><strong class="la io">更容易调试<br/> </strong>没有管道层。电话是直拨的。调用堆栈是干净的。✔️</li><li id="d8da" class="ng nh in la b lb np le nq kl nr kp ns kt nt lq nl nm nn no bi translated"><strong class="la io">存储要简单得多</strong> <br/>它不依赖于外部API调用，也不依赖于动作方法中复杂的交互。(<em class="mj">不过，请注意，如果你的业务逻辑本来就很复杂，那么这种基本的复杂性不会因为你把它从一个地方移到另一个地方而消失😃但至少你的“商店”会更容易管理</em> ) ✔️</li><li id="229d" class="ng nh in la b lb np le nq kl nr kp ns kt nt lq nl nm nn no bi translated"><strong class="la io">更容易测试</strong> <br/>我们将存储简化为一个没有外部依赖性的内存对象。<strong class="la io">再也不用嘲笑商店了。对于每个测试，您可以创建一个您的原始存储的副本并直接使用它。当您需要模拟您的业务逻辑方法时，您可以使用测试库的标准实用程序以更简单的方式模拟它们。✔️</strong></li><li id="3d55" class="ng nh in la b lb np le nq kl nr kp ns kt nt lq nl nm nn no bi translated"><strong class="la io">现在更容易组织</strong> <br/>了，因为业务逻辑功能现在不必坐在商店里靠近一堆数据，可以随意以任何方式组织它们。✔️</li></ul><h1 id="eac5" class="nu kd in bd ke nv nw nx kh ny nz oa kk jt ob ju ko jw oc jx ks jz od ka kw oe bi translated">不利方面？</h1><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="90e1" class="kc kd in mb b gy mf mg l mh mi">export async function searchAsync (<strong class="mb io">store, </strong>query) {</span></pre><p id="afca" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">您需要将商店实例传递给业务逻辑方法。向每个方法添加额外的参数可能看起来是重复和枯燥的。随意把它当作一个问题，用“全局存储提供者”或“参数依赖注入”机制来解决它。</p><p id="23a8" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">我喜欢直截了当。也更容易测试。所以我不认为这是一个缺点。代码写一遍，读一百遍。我为了更大的利益而优化。</p><p id="42a4" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated"><strong class="la io">下面是一个工作实例:</strong><a class="ae og" href="https://github.com/veyselozdemir/vuex-no-actions" rel="noopener ugc nofollow" target="_blank">https://github.com/veyselozdemir/vuex-no-actions</a></p><h1 id="c2b7" class="nu kd in bd ke nv nw nx kh ny nz oa kk jt ob ju ko jw oc jx ks jz od ka kw oe bi translated">结论</h1><p id="4ce6" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">好了，非常感谢你读到这里。你读了1000多字。这是一项成就😃</p><p id="8bb2" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated"><strong class="la io">关键要点:</strong>不要用动作。</p><p id="b9b2" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated"><strong class="la io">更多要点:</strong>保持你的商店精简和吝啬。将交互限制在getters和variation(setter)上。用常规方法编写您的业务逻辑。当您依赖于存储时，将存储作为显式参数传递到那里，而不是使用神奇的管道库。</p><h2 id="edea" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> TLDR </strong></h2><p id="529a" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">将所有的“业务逻辑”移至普通的旧函数中，从Vuex存储中删除它们，并从存储中删除所有的 <code class="fe mr ms mt mb b"><strong class="la io">action</strong></code> <strong class="la io">方法</strong>。您的代码将更容易编写，更容易测试，最重要的是更容易阅读。</p><p id="a1c7" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated">如果你想直接跳到一个例子:<a class="ae og" href="https://github.com/veyselozdemir/vuex-no-actions" rel="noopener ugc nofollow" target="_blank">https://github.com/veyselozdemir/vuex-no-actions</a></p><p id="80cb" class="pw-post-body-paragraph ky kz in la b lb lr jo ld le ls jr lg kl lt li lj kp lu ll lm kt lv lo lp lq ig bi translated"><em class="mj">更多内容请看</em><a class="ae og" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="mj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>