<html>
<head>
<title>JavaScript — Interview Preparation Guide (50 Output related questions)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript —面试准备指南(50个与输出相关的问题)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/50-javascript-output-questions-818d45c3e381?source=collection_archive---------0-----------------------#2021-04-13">https://javascript.plainenglish.io/50-javascript-output-questions-818d45c3e381?source=collection_archive---------0-----------------------#2021-04-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a84e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">前端开发人员备忘单</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dce2ac66454f2a8848e494fef75d40f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej-0rmwV7cQAgHztPWv8KQ.png"/></div></div></figure><h2 id="8559" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题1:(字符串、数字、布尔型)</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="235c" class="ko kp in ll b gy lp lq l lr ls">var num = 8;<br/>var num = 10;<br/>console.log(num);</span></pre><p id="5495" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> 10 <br/> <strong class="lv io">解释— </strong>用<code class="fe mm mn mo ll b">var</code>关键字，可以声明多个同名变量。该变量将保存最新的值。你不能用<code class="fe mm mn mo ll b">let</code>或<code class="fe mm mn mo ll b">const</code>做到这一点，因为它们是块范围的。</p><h2 id="7683" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题2:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="3e34" class="ko kp in ll b gy lp lq l lr ls">function sayHi() {<br/>  console.log(name);<br/>  console.log(age);<br/>  var name = 'Ayush';<br/>  let age = 21;<br/>}<br/><br/>sayHi();</span></pre><p id="d6a7" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">undefined</code>和<code class="fe mm mn mo ll b">ReferenceError</code> <br/> <strong class="lv io">解释— </strong>在函数内部，我们先用<code class="fe mm mn mo ll b">var</code>关键字声明<code class="fe mm mn mo ll b">name</code>变量。这意味着变量被提升(内存空间是在创建阶段设置的)，默认值为<code class="fe mm mn mo ll b">undefined</code>，直到我们实际到达定义变量的那一行。我们还没有在试图记录<code class="fe mm mn mo ll b">name</code>变量的那一行定义变量，所以它仍然保存着<code class="fe mm mn mo ll b">undefined</code>的值。</p><p id="9dca" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">带有<code class="fe mm mn mo ll b">let</code>关键字的变量(和<code class="fe mm mn mo ll b">const</code>)被提升，但与<code class="fe mm mn mo ll b">var</code>不同，不要让<em class="mp">初始化</em>。在我们声明(初始化)它们之前，它们是不可访问的。这被称为“时间死区”。当我们试图在声明变量之前访问它们时，JavaScript抛出一个<code class="fe mm mn mo ll b">ReferenceError</code>。</p><h2 id="a28a" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题3:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="20e0" class="ko kp in ll b gy lp lq l lr ls">function getAge() {<br/>  'use strict';<br/>  age = 21;<br/>  console.log(age);<br/>}<br/><br/>getAge();</span></pre><p id="a497" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">ReferenceError</code> <br/> <strong class="lv io">解释— </strong>用<code class="fe mm mn mo ll b">"use strict"</code>，可以确保不意外声明全局变量。我们从来没有声明过变量<code class="fe mm mn mo ll b">age</code>，由于我们使用了<code class="fe mm mn mo ll b">"use strict"</code>，它会抛出一个引用错误。如果我们不使用<code class="fe mm mn mo ll b">"use strict"</code>，它可能已经工作了，因为属性<code class="fe mm mn mo ll b">age</code>已经被添加到全局对象中。</p><h2 id="6d50" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题4:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="ee76" class="ko kp in ll b gy lp lq l lr ls">+true;<br/>!'Ayush';</span></pre><p id="b2e2" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong> <code class="fe mm mn mo ll b">1</code>和<code class="fe mm mn mo ll b">false<br/></code> <strong class="lv io">解释— </strong>一元加号试图将一个操作数转换成一个数。<code class="fe mm mn mo ll b">true</code>是<code class="fe mm mn mo ll b">1</code>，<code class="fe mm mn mo ll b">false</code>是<code class="fe mm mn mo ll b">0</code>。</p><p id="e9e9" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">字符串<code class="fe mm mn mo ll b">'Ayush'</code>是一个真值。我们实际上问的是，“这个真值是假的吗？”。这将返回<code class="fe mm mn mo ll b">false</code>。</p><h2 id="d30c" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">问题5: </strong></h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="d21e" class="ko kp in ll b gy lp lq l lr ls">let number = 0;<br/>console.log(number++);<br/>console.log(++number);<br/>console.log(number);</span></pre><p id="e00c" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong> <code class="fe mm mn mo ll b">0 2 2</code>。<br/> <strong class="lv io">解释— </strong>后缀一元运算符<code class="fe mm mn mo ll b">++</code>:</p><ol class=""><li id="422a" class="mq mr in lv b lw lx lz ma kx ms lb mt lf mu ml mv mw mx my bi translated">返回值(这将返回<code class="fe mm mn mo ll b">0</code>)。</li><li id="3cb8" class="mq mr in lv b lw mz lz na kx nb lb nc lf nd ml mv mw mx my bi translated">增加数值(数字现在是<code class="fe mm mn mo ll b">1</code>)。</li></ol><p id="88d0" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">前缀一元运算符<code class="fe mm mn mo ll b">++</code>:</p><ol class=""><li id="8b2b" class="mq mr in lv b lw lx lz ma kx ms lb mt lf mu ml mv mw mx my bi translated">增加数值(数字现在是<code class="fe mm mn mo ll b">2</code>)。</li><li id="8943" class="mq mr in lv b lw mz lz na kx nb lb nc lf nd ml mv mw mx my bi translated">返回值(这将返回<code class="fe mm mn mo ll b">2</code>)。</li></ol><p id="2907" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">这将返回<code class="fe mm mn mo ll b">0 2 2</code>。</p><h2 id="2824" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题6:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="6d40" class="ko kp in ll b gy lp lq l lr ls">function sum(a, b) {<br/>  return a + b;<br/>}<br/><br/>sum(1, '2');</span></pre><p id="4de1" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">"12"</code> <br/> <strong class="lv io">解释— </strong> JavaScript是一种动态类型化的语言:我们不指定某些变量是什么类型。值可以在你不知道的情况下自动转换成另一种类型，这叫做<em class="mp">隐式类型强制</em>。强制是从一种类型转换成另一种类型。</p><p id="f5d4" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">在本例中，JavaScript将数字<code class="fe mm mn mo ll b">1</code>转换为字符串，以便函数有意义并返回值。在添加数字类型(<code class="fe mm mn mo ll b">1</code>)和字符串类型(<code class="fe mm mn mo ll b">'2'</code>)时，数字被视为字符串。我们可以像<code class="fe mm mn mo ll b">"Hello" + "World"</code>一样连接字符串，所以这里发生的是<code class="fe mm mn mo ll b">"1" + "2"</code>返回<code class="fe mm mn mo ll b">"12"</code>。</p><h2 id="f6ff" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">问题7: </strong></h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="2104" class="ko kp in ll b gy lp lq l lr ls">String.prototype.giveAyushPizza = () =&gt; {<br/>  return 'Just give Ayush pizza already!';<br/>};<br/><br/>const name = 'Ayush';<br/><br/>name.giveAyushPizza();</span></pre><p id="2d6d" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">"Just give Ayush pizza already!"</code> <br/> <strong class="lv io">解释— </strong> <code class="fe mm mn mo ll b">String</code>是一个内置的构造函数，我们可以给它添加属性。我只是在它的原型上添加了一个方法。原始字符串被自动转换成字符串对象，由字符串原型函数生成。所以，所有的字符串(字符串对象)都可以访问那个方法！</p><h2 id="1f2e" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题8:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="fae4" class="ko kp in ll b gy lp lq l lr ls">for (let i = 1; i &lt; 5; i++) {<br/>  if (i === 3) continue;<br/>  console.log(i);<br/>}</span></pre><p id="9543" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">1</code> <code class="fe mm mn mo ll b">2</code> <code class="fe mm mn mo ll b">4<br/></code> <strong class="lv io">解释— </strong>如果某个条件返回<code class="fe mm mn mo ll b">true</code>，则<code class="fe mm mn mo ll b">continue</code>语句跳过一次迭代。</p><h2 id="86d9" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题9:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="1aa6" class="ko kp in ll b gy lp lq l lr ls">function sayHi() {<br/>  return (() =&gt; 0)();<br/>}<br/><br/>console.log(typeof sayHi());</span></pre><p id="b32e" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">"number"</code> <br/> <strong class="lv io">解释—</strong><code class="fe mm mn mo ll b">sayHi</code>函数返回立即调用的函数表达式(IIFE)的返回值。这个函数返回了类型为<code class="fe mm mn mo ll b">"number"</code>的<code class="fe mm mn mo ll b">0</code>。</p><p id="f925" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">仅供参考:内置类型只有7种:<code class="fe mm mn mo ll b">null</code>、<code class="fe mm mn mo ll b">undefined</code>、<code class="fe mm mn mo ll b">boolean</code>、<code class="fe mm mn mo ll b">number</code>、<code class="fe mm mn mo ll b">string</code>、<code class="fe mm mn mo ll b">object</code>、<code class="fe mm mn mo ll b">symbol</code>。<code class="fe mm mn mo ll b">"function"</code>不是类型，因为函数是对象，所以它属于类型<code class="fe mm mn mo ll b">"object"</code>。</p><h2 id="e5e4" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题10:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="cfa8" class="ko kp in ll b gy lp lq l lr ls">console.log(typeof typeof 1);</span></pre><p id="da7c" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">"string"</code> <br/> <strong class="lv io">解释— </strong> <code class="fe mm mn mo ll b">typeof 1</code>返回<code class="fe mm mn mo ll b">"number"</code>。并且<code class="fe mm mn mo ll b">typeof "number"</code>返回<code class="fe mm mn mo ll b">"string"</code>。</p><h2 id="0223" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题11:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="59c9" class="ko kp in ll b gy lp lq l lr ls">!!null;<br/>!!'';<br/>!!1;</span></pre><p id="e5a6" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong> <code class="fe mm mn mo ll b">false</code> <code class="fe mm mn mo ll b">false</code> <code class="fe mm mn mo ll b">true</code> <br/> <strong class="lv io">解释— </strong> <code class="fe mm mn mo ll b">null</code>是falsy。<code class="fe mm mn mo ll b">!null</code>返回<code class="fe mm mn mo ll b">true</code>。<code class="fe mm mn mo ll b">!true</code>返回<code class="fe mm mn mo ll b">false</code>。</p><p id="ac94" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><code class="fe mm mn mo ll b">""</code>是福尔西。<code class="fe mm mn mo ll b">!""</code>返回<code class="fe mm mn mo ll b">true</code>。<code class="fe mm mn mo ll b">!true</code>返回<code class="fe mm mn mo ll b">false</code>。</p><p id="2ee1" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><code class="fe mm mn mo ll b">1</code>是真理。<code class="fe mm mn mo ll b">!1</code>返回<code class="fe mm mn mo ll b">false</code>。<code class="fe mm mn mo ll b">!false</code>返回<code class="fe mm mn mo ll b">true</code>。</p><h2 id="a116" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题12:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="12cc" class="ko kp in ll b gy lp lq l lr ls">[...'Ayush'];</span></pre><p id="a6ea" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong> <code class="fe mm mn mo ll b">["A", "y", "u", "s", "h"]</code> <br/> <strong class="lv io">解释— </strong>一个字符串是可迭代的。spread运算符将iterable的每个字符映射到一个元素。</p><h2 id="9731" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题13:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="93b1" class="ko kp in ll b gy lp lq l lr ls">console.log(3 + 4 + '5');</span></pre><p id="e2de" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong> <code class="fe mm mn mo ll b">"75"</code> <br/> <strong class="lv io">解释— </strong>运算符结合律是编译器对表达式求值的顺序，可以是从左到右，也可以是从右到左。只有当所有操作员都有相同的<em class="mp">优先级时，才会发生这种情况。我们只有一种类型的操作员:<code class="fe mm mn mo ll b">+</code>。对于加法，结合性是从左到右的。</em></p><p id="c802" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">首先得到评估。这导致了数字<code class="fe mm mn mo ll b">7</code>。</p><p id="3dff" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><code class="fe mm mn mo ll b">7 + '5'</code>因强制而导致<code class="fe mm mn mo ll b">"75"</code>。JavaScript将数字<code class="fe mm mn mo ll b">7</code>转换成一个字符串。我们可以使用<code class="fe mm mn mo ll b">+</code>操作符连接两个字符串。<code class="fe mm mn mo ll b">"7" + "5"</code>导致<code class="fe mm mn mo ll b">"75"</code>。</p><h2 id="2f2c" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题14:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="4a96" class="ko kp in ll b gy lp lq l lr ls">var a = 10;<br/>var b = a;<br/>b = 20;</span><span id="cccf" class="ko kp in ll b gy ne lq l lr ls">console.log(a);<br/>console.log(b);</span><span id="dec5" class="ko kp in ll b gy ne lq l lr ls">var a = 'Ayush';<br/>var b = a;<br/>b = 'Verma';</span><span id="8e4f" class="ko kp in ll b gy ne lq l lr ls">console.log(a);<br/>console.log(b);</span></pre><p id="f227" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案—<br/></strong><code class="fe mm mn mo ll b">1. 10 and 20 </code><br/><code class="fe mm mn mo ll b">2. "Ayush" and "Verma"</code><br/><strong class="lv io">解释— </strong>赋给原语数据类型变量的值是<strong class="lv io">紧耦合</strong>。这意味着，每当您创建原始数据类型变量的副本时，该值都会被复制到新变量所指向的新内存位置。当你制作一个副本时，它将是一个真正的副本。</p><h2 id="cc9b" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题15:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="b831" class="ko kp in ll b gy lp lq l lr ls">function sum(){<br/>  return arguments.reduce((a, b) =&gt; a + b);<br/>}<br/><br/>console.log(sum(1,2,3)); (1)</span><span id="489b" class="ko kp in ll b gy ne lq l lr ls">function sum(...arguments){<br/>  return arguments.reduce((a, b) =&gt; a + b);<br/>}<br/><br/>console.log(sum(1,2,3)); (2)</span></pre><p id="1c53" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— <br/> </strong> 1。将会引发错误。<br/> 2。6 <br/> <strong class="lv io">解释</strong> — <br/> 1。参数不是全功能数组，它们只有一个方法<code class="fe mm mn mo ll b">length</code>。其他方法不能用在他们身上。<br/> 2。<code class="fe mm mn mo ll b">...</code> rest操作符创建所有函数参数的数组。然后我们用这个返回它们的和。</p><h2 id="9f5c" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题16:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="976c" class="ko kp in ll b gy lp lq l lr ls">console.log(1 == '1');<br/>console.log(false == '0');<br/>console.log(true == '1');<br/>console.log('1' == '01');<br/>console.log(10 == 5 + 5);</span></pre><p id="7f90" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong>真真假假真。<br/> <strong class="lv io">解释</strong> — <code class="fe mm mn mo ll b">'1' == '01'</code>当我们在这里比较两个字符串时，它们是不同的，但其他都是相等的。</p><p id="c278" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">问题17: </strong></p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="4a38" class="ko kp in ll b gy lp lq l lr ls">console.log('1' - - '1'); (1)<br/>console.log('1' + - '1'); (2)</span></pre><p id="89a1" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— <br/> </strong> 1。2 <br/> 2。“1–1”<br/><strong class="lv io">解释</strong> — <br/> 1。使用类型强制字符串被转换为数字并被视为<code class="fe mm mn mo ll b">1 - -1</code> = <code class="fe mm mn mo ll b">2</code>。<br/> 2。+运算符在javascript中用于字符串的串联，所以计算为<code class="fe mm mn mo ll b">'1' + '-1'</code> = <code class="fe mm mn mo ll b">1-1</code>。</p><p id="e5ca" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">问题18: </strong></p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="3428" class="ko kp in ll b gy lp lq l lr ls">let lang = 'javascript';<br/>(function(){<br/>   let lang = 'java';<br/>})();<br/><br/>console.log(lang); (1)</span><span id="124d" class="ko kp in ll b gy ne lq l lr ls">(function(){<br/>   var lang2 = 'java';<br/>})();<br/><br/>console.log(lang2); (2)</span></pre><p id="7446" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— <br/> </strong> 1。<br/> 2。将会引发错误。<br/> <strong class="lv io">解说</strong> — <br/> 1。用<code class="fe mm mn mo ll b">let</code>定义的变量是阻塞范围，不会添加到全局对象中。<br/> 2。用<code class="fe mm mn mo ll b">var</code>关键字声明的变量是函数作用域的，所以将函数封装在闭包里会限制它在外部被访问，这就是它抛出错误的原因</p><p id="5c03" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">问题19: </strong></p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="020d" class="ko kp in ll b gy lp lq l lr ls">(function(){<br/>   console.log(typeof this);<br/>}).call(10);</span></pre><p id="cc7c" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong>对象<strong class="lv io"> <br/>解释</strong> — <code class="fe mm mn mo ll b">call</code>调用带有新<code class="fe mm mn mo ll b">this</code>的函数，在本例中是<code class="fe mm mn mo ll b">10</code>，它基本上是<code class="fe mm mn mo ll b">Number</code>的构造函数，<code class="fe mm mn mo ll b">Number</code>是javascript中的对象。</p><p id="5f76" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">问题20: </strong></p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="073d" class="ko kp in ll b gy lp lq l lr ls">console.log("<a class="ae nf" href="https://ayushv.medium.com/" rel="noopener">ayushv.medium.com/</a>" instanceof String); (1)</span><span id="7c0d" class="ko kp in ll b gy ne lq l lr ls">const s = new String('<a class="ae nf" href="https://ayushv.medium.com/" rel="noopener">ayushv.medium.com/</a>');<br/>console.log(s instanceof String); (2)</span></pre><p id="1aa3" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— <br/> </strong> 1。假<br/> 2。true <br/> <strong class="lv io">解释</strong> —只有用<code class="fe mm mn mo ll b">String()</code>构造函数定义的字符串才是它的实例。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h2 id="1bae" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题21:(对象，数组)</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="f81f" class="ko kp in ll b gy lp lq l lr ls">const obj = { a: 'one', b: 'two', a: 'three' };<br/>console.log(obj);</span></pre><p id="e1ce" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">{ a: "three", b: "two"}"</code> <br/> <strong class="lv io">解释— </strong>如果你有两个同名的键，那么这个键会被替换。它仍将位于第一个位置，但具有最后指定的值。</p><h2 id="8f93" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题22:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="6e81" class="ko kp in ll b gy lp lq l lr ls">let c = { greeting: 'Hey!' };<br/>let d;</span><span id="8b01" class="ko kp in ll b gy ne lq l lr ls">d = c;<br/>c.greeting = 'Hello';<br/>console.log(d.greeting);</span></pre><p id="b5e0" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">Hello</code> <br/> <strong class="lv io">解释— </strong>在JavaScript中，所有对象在设置为彼此相等时，都通过<em class="mp">引用</em>进行交互。</p><p id="1df6" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">首先，变量<code class="fe mm mn mo ll b">c</code>保存一个对象的值。稍后，我们给<code class="fe mm mn mo ll b">d</code>赋予与<code class="fe mm mn mo ll b">c</code>相同的引用。当你改变一个对象时，你改变了所有的对象。</p><h2 id="efd6" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题23:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="756a" class="ko kp in ll b gy lp lq l lr ls">let a = 3;<br/>let b = new Number(3);<br/>let c = 3;</span><span id="8767" class="ko kp in ll b gy ne lq l lr ls">console.log(a == b);<br/>console.log(a === b);<br/>console.log(b === c);</span></pre><p id="6644" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong> <code class="fe mm mn mo ll b">true</code> <code class="fe mm mn mo ll b">false</code> <code class="fe mm mn mo ll b">false</code> <br/> <strong class="lv io">解释— </strong> <code class="fe mm mn mo ll b">new Number()</code>是内置函数构造器。虽然它看起来像一个数字，但它不是真正的数字:它有一堆额外的功能，是一个对象。</p><p id="15ee" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">当我们使用<code class="fe mm mn mo ll b">==</code>运算符时，它只检查是否有相同的<em class="mp">值</em>。它们的值都是<code class="fe mm mn mo ll b">3</code>，所以它返回<code class="fe mm mn mo ll b">true</code>。</p><p id="b2e0" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">然而，当我们使用<code class="fe mm mn mo ll b">===</code>操作符时，值<em class="mp">和</em>类型应该是相同的。不是:<code class="fe mm mn mo ll b">new Number()</code>不是数字，是对象。双双返回<code class="fe mm mn mo ll b">false.</code></p><h2 id="5303" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题24:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="d804" class="ko kp in ll b gy lp lq l lr ls">function getAge(...args) {<br/>  console.log(typeof args);<br/>}<br/><br/>getAge(21);</span></pre><p id="07d0" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">"object"</code> <br/> <strong class="lv io">解释—</strong>rest参数(<code class="fe mm mn mo ll b">...args</code>)让我们将所有剩余的参数“收集”到一个数组中。数组是一个对象，所以<code class="fe mm mn mo ll b">typeof args</code>返回<code class="fe mm mn mo ll b">"object"</code>。</p><h2 id="fa66" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题25:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="7976" class="ko kp in ll b gy lp lq l lr ls">let greeting;<br/>greetign = {}; // Typo!<br/>console.log(greetign);</span></pre><p id="d4cc" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">{}</code> <br/> <strong class="lv io">解释— </strong>它记录对象，因为我们只是在全局对象上创建了一个空对象！当我们把<code class="fe mm mn mo ll b">greeting</code>错打成<code class="fe mm mn mo ll b">greetign</code>时，JS解释器实际上把这个看成<code class="fe mm mn mo ll b">global.greetign = {}</code>(或者浏览器中的<code class="fe mm mn mo ll b">window.greetign = {}</code>)。</p><p id="8b60" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">为了避免这种情况，我们可以使用<code class="fe mm mn mo ll b">"use strict"</code>。这可以确保在将变量设置为任何值之前，您已经声明了该变量。</p><h2 id="6279" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题26:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="e8e3" class="ko kp in ll b gy lp lq l lr ls">function checkAge(data) {<br/>  if (data === { age: 18 }) {<br/>    console.log('You are an adult!');<br/>  } else if (data == { age: 18 }) {<br/>    console.log('You are still an adult.');<br/>  } else {<br/>    console.log(`Hmm.. You don't have an age I guess`);<br/>  }<br/>}<br/><br/>checkAge({ age: 18 });</span></pre><p id="d58c" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">Hmm.. You don't have an age I guess</code> <br/> <strong class="lv io">解释— </strong>测试相等时，原语通过其<em class="mp">值</em>进行比较，对象通过其<em class="mp">引用</em>进行比较。JavaScript检查对象是否引用了内存中的相同位置。</p><p id="a5d3" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">我们比较的两个对象没有这个:我们作为参数传递的对象引用了内存中不同的位置，而不是我们用来检查相等性的对象。</p><p id="837f" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">这就是为什么<code class="fe mm mn mo ll b">{ age: 18 } === { age: 18 }</code>和<code class="fe mm mn mo ll b">{ age: 18 } == { age: 18 }</code>都返回<code class="fe mm mn mo ll b">false</code>的原因。</p><h2 id="215a" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题27:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="d1e7" class="ko kp in ll b gy lp lq l lr ls">const obj = { 1: 'a', 2: 'b', 3: 'c' };<br/>const set = new Set([1, 2, 3, 4, 5]);<br/><br/>obj.hasOwnProperty('1');<br/>obj.hasOwnProperty(1);<br/>set.has('1');<br/>set.has(1);</span></pre><p id="d1c7" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答—</strong><code class="fe mm mn mo ll b">true</code><code class="fe mm mn mo ll b">true</code><code class="fe mm mn mo ll b">false</code><code class="fe mm mn mo ll b">true</code><br/><strong class="lv io">解释— </strong>所有的对象键(不包括符号)都是头罩下的字符串，即使你自己不把它打成字符串。这就是为什么<code class="fe mm mn mo ll b">obj.hasOwnProperty('1')</code>也返回true。</p><p id="9097" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">对一组来说就不是这样了。我们的集合中没有<code class="fe mm mn mo ll b">'1'</code>:<code class="fe mm mn mo ll b">set.has('1')</code>返回<code class="fe mm mn mo ll b">false</code>。它的数值类型为<code class="fe mm mn mo ll b">1</code>，<code class="fe mm mn mo ll b">set.has(1)</code>返回<code class="fe mm mn mo ll b">true</code>。</p><h2 id="a015" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题28:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="2e1d" class="ko kp in ll b gy lp lq l lr ls">const a = {};<br/>const b = { key: 'b' };<br/>const c = { key: 'c' };<br/><br/>a[b] = 123;<br/>a[c] = 456;<br/><br/>console.log(a[b]);</span></pre><p id="543f" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong> <code class="fe mm mn mo ll b">456</code> <br/> <strong class="lv io">解释— </strong>对象键自动转换成字符串。我们试图将一个对象设置为对象<code class="fe mm mn mo ll b">a</code>的键，值为<code class="fe mm mn mo ll b">123</code>。</p><p id="cf9d" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">然而，当我们字符串化一个对象时，它变成了<code class="fe mm mn mo ll b">"[object Object]"</code>。所以我们在这里说的是。然后，我们可以尝试再次做同样的事情。<code class="fe mm mn mo ll b">c</code>是我们隐式字符串化的另一个对象。于是乎，<code class="fe mm mn mo ll b">a["[object Object]"] = 456</code>。</p><p id="3933" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">然后，我们登录<code class="fe mm mn mo ll b">a[b]</code>，实际上是<code class="fe mm mn mo ll b">a["[object Object]"]</code>。我们只是将其设置为<code class="fe mm mn mo ll b">456</code>，所以它返回<code class="fe mm mn mo ll b">456</code>。</p><h2 id="03b0" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题29:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="9d15" class="ko kp in ll b gy lp lq l lr ls">const numbers = [1, 2, 3];<br/>numbers[10] = 11;<br/>console.log(numbers);</span></pre><p id="a7a3" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">[1, 2, 3, 7 x empty, 11]</code> <br/> <strong class="lv io">解释— </strong>当你给数组中的一个元素设置的值超过了数组的长度，JavaScript就会创建一个叫做“空槽”的东西。这些实际上有<code class="fe mm mn mo ll b">undefined</code>的值，但是你会看到类似于:</p><p id="8457" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><code class="fe mm mn mo ll b">[1, 2, 3, 7 x empty, 11]</code></p><p id="e0c5" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">取决于你在哪里运行它(每个浏览器、节点等都不一样。).</p><h2 id="09c9" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题30:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="b38b" class="ko kp in ll b gy lp lq l lr ls">let person = { name: 'Ayush' };<br/>const members = [person];<br/>person = null;<br/><br/>console.log(members);</span></pre><p id="0066" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答— </strong> <code class="fe mm mn mo ll b">[{ name: "Ayush" }]</code> <br/> <strong class="lv io">解释— </strong>我们只修改了<code class="fe mm mn mo ll b">person</code>变量的值，而不是数组中的第一个元素，因为该元素有一个不同的(复制的)对对象的引用。<code class="fe mm mn mo ll b">members</code>中的第一个元素仍然保持其对原始对象的引用。当我们记录<code class="fe mm mn mo ll b">members</code>数组时，第一个元素仍然保存被记录的对象的值。</p><h2 id="7a30" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题31:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="69ca" class="ko kp in ll b gy lp lq l lr ls">const person = {<br/>  name: 'Ayush',<br/>  age: 21,<br/>};<br/><br/>for (const item in person) {<br/>  console.log(item);<br/>}</span></pre><p id="5fdb" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">"name", "age"</code> <br/> <strong class="lv io">解释— </strong>用一个<code class="fe mm mn mo ll b">for-in</code>循环，我们可以迭代对象键，这里是<code class="fe mm mn mo ll b">name</code>和<code class="fe mm mn mo ll b">age</code>。在幕后，对象键是字符串(如果它们不是符号的话)。在每次循环中，我们将<code class="fe mm mn mo ll b">item</code>的值设置为等于它正在迭代的当前键。首先，<code class="fe mm mn mo ll b">item</code>等于<code class="fe mm mn mo ll b">name</code>，并被记录。然后，<code class="fe mm mn mo ll b">item</code>等于<code class="fe mm mn mo ll b">age</code>，记录下来。</p><h2 id="df40" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题32:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="7273" class="ko kp in ll b gy lp lq l lr ls">[1, 2, 3].map(num =&gt; {<br/>  if (typeof num === 'number') return;<br/>  return num * 2;<br/>});</span></pre><p id="dbec" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">[undefined, undefined, undefined]</code> <br/> <strong class="lv io">解释— </strong>映射数组时，<code class="fe mm mn mo ll b">num</code>的值等于当前循环的元素。在这种情况下，元素是数字，所以if语句的条件<code class="fe mm mn mo ll b">typeof num === "number"</code>返回<code class="fe mm mn mo ll b">true</code>。map函数创建一个新数组，并插入从该函数返回的值。</p><p id="54b8" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">但是，我们不返回值。当我们没有从函数返回值时，函数返回<code class="fe mm mn mo ll b">undefined</code>。对于数组中的每个元素，函数块都被调用，所以对于每个元素，我们返回<code class="fe mm mn mo ll b">undefined</code>。</p><h2 id="66fc" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题33:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="5b17" class="ko kp in ll b gy lp lq l lr ls">var obj = {a:1};<br/>var secondObj = obj;<br/>secondObj.a = 2;</span><span id="fe76" class="ko kp in ll b gy ne lq l lr ls">console.log(obj);<br/>console.log(secondObj);</span><span id="4613" class="ko kp in ll b gy ne lq l lr ls">var obj = {a:1};<br/>var secondObj = obj;<br/>secondObj = {a:2};</span><span id="ee92" class="ko kp in ll b gy ne lq l lr ls">console.log(obj);<br/>console.log(secondObj);</span></pre><p id="1eda" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— <br/> </strong> <code class="fe mm mn mo ll b">1. { a:2 }</code>和<code class="fe mm mn mo ll b">{ a:2 }<br/> 2. { a:1 }</code><code class="fe mm mn mo ll b">{ a:2 }</code><strong class="lv io"><br/>解释— <br/> </strong> 1。如果对象属性被改变，那么新的对象指向相同的内存地址，所以原来的对象属性也会改变。<br/>(引用调用)2。如果该对象被重新分配了一个新对象，那么它将被分配到一个新的内存位置，即它将是一个<strong class="lv io">真实副本</strong>(通过值调用)。</p><h2 id="4738" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题34:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="70bc" class="ko kp in ll b gy lp lq l lr ls">const arrTest = [10, 20, 30, 40, 50][1, 3];   <br/>console.log(arrTest);</span></pre><p id="fbe5" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">40</code> <strong class="lv io"> <br/>解释— </strong>第二个数组的最后一个元素作为索引，像<code class="fe mm mn mo ll b">arrTest[3]</code>一样从第一个数组中获取值。</p><h2 id="c6ee" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题35:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="a1d8" class="ko kp in ll b gy lp lq l lr ls">console.log([] + []);               (1)<br/>console.log([1] + []);              (2)<br/>console.log([1] + "abc");           (3)<br/>console.log([1, 2, 3] + [1, 3, 4]); (4)</span></pre><p id="72cb" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— <br/> </strong> <code class="fe mm mn mo ll b">1. ""<br/> 2. "1"<br/> 3. "1abc"<br/>2. "1,2,31,3,4"<br/></code> <strong class="lv io">解释— <br/> </strong> 1 .在console.log中打印时，空数组被视为Array.toString()，因此它会打印一个空字符串。<br/> 2。在console.log中打印的空数组被视为<code class="fe mm mn mo ll b">Array.toString()</code>，因此基本上是<code class="fe mm mn mo ll b">“1” + “”</code> = <code class="fe mm mn mo ll b">""</code>。<br/> 3。<code class="fe mm mn mo ll b">“1” + “abc”</code> = <code class="fe mm mn mo ll b">"1abc"</code>。<br/> 4。<code class="fe mm mn mo ll b">“1, 2, 3” + “1, 3, 4”</code> = <code class="fe mm mn mo ll b">"1,2,31,3,4"</code>。</p><h2 id="8f6b" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题36:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="c38e" class="ko kp in ll b gy lp lq l lr ls">const ans1 = NaN === NaN;<br/>const ans2 = Object.is(NaN, NaN);<br/>console.log(ans1, ans2);</span></pre><p id="73ee" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong>假真<br/> <strong class="lv io">解释— </strong> <code class="fe mm mn mo ll b">NaN</code>是唯一值所以在相等性检查中失败，但它是同一个对象所以<code class="fe mm mn mo ll b">Object.is</code>返回<code class="fe mm mn mo ll b">true</code>。</p><h2 id="db24" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题37:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="c65a" class="ko kp in ll b gy lp lq l lr ls">var a = 3;<br/>var b = {<br/>  a: 9,<br/>  b: ++a<br/>};<br/>console.log(a + b.a + ++b.b);</span></pre><p id="c091" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> 18 <br/> <strong class="lv io">解释— </strong>前缀运算符递增数字后返回。所以下面的表达式会被求值为<code class="fe mm mn mo ll b">4 + 9 + 5</code> = <code class="fe mm mn mo ll b">18</code>。</p><h2 id="b223" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题38:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="176b" class="ko kp in ll b gy lp lq l lr ls">const arr = [1, 2, undefined, NaN, null, false, true, "", 'abc', 3];<br/>console.log(arr.filter(Boolean)); (1)</span><span id="10c7" class="ko kp in ll b gy ne lq l lr ls">const arr = [1, 2, undefined, NaN, null, false, true, "", 'abc', 3];<br/>console.log(arr.filter(!Boolean)); (2)</span></pre><p id="2882" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— <br/> 1。</strong>【1，2，真，《abc》，3】。<strong class="lv io">T29】2。它会抛出一个错误。<br/> <strong class="lv io">解释— <br/> </strong> 1。<code class="fe mm mn mo ll b">Array.filter()</code>返回符合条件的数组。因为我们已经传递了Boolean，所以它返回所有的真值。<br/> 2。当<code class="fe mm mn mo ll b">Array.filter()</code>接受一个函数时，<code class="fe mm mn mo ll b">!Boolean</code>返回不是函数的<code class="fe mm mn mo ll b">false</code>，因此抛出一个错误<code class="fe mm mn mo ll b">Uncaught TypeError: false is not a function</code>。</strong></p><h2 id="73f7" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题39:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="13dd" class="ko kp in ll b gy lp lq l lr ls">const person = {<br/>  name: 'Ayush Verma',<br/>  .25e2: 25<br/>};<br/><br/>console.log(person[25]);<br/>console.log(person[.25e2]);<br/>console.log(person['.25e2']);</span></pre><p id="5b6a" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> 25 25未定义<strong class="lv io"> <br/>解释— </strong>在分配键时，对象对数值表达式求值，所以它变成了<code class="fe mm mn mo ll b">person[.25e2] = person[25]</code>。因此，当我们使用<code class="fe mm mn mo ll b">25</code>和<code class="fe mm mn mo ll b">.25e2</code>进行访问时，它返回值，但对于<code class="fe mm mn mo ll b">'.25e2'</code>是<code class="fe mm mn mo ll b">undefined</code>。</p><h2 id="f9ff" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题40:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="7424" class="ko kp in ll b gy lp lq l lr ls">console.log(new Array(3).toString());</span></pre><p id="322b" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong>“，，”<strong class="lv io"> <br/>解释— </strong> <code class="fe mm mn mo ll b">Array.toString()</code>用逗号分隔值创建数组的字符串。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h2 id="26d0" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题41: (setTimeout和“this”关键字)</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="4262" class="ko kp in ll b gy lp lq l lr ls">const foo = () =&gt; console.log('First');<br/>const bar = () =&gt; setTimeout(() =&gt; console.log('Second'));<br/>const baz = () =&gt; console.log('Third');</span><span id="24b3" class="ko kp in ll b gy ne lq l lr ls">bar();<br/>foo();<br/>baz();</span></pre><p id="3b57" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">First</code> <code class="fe mm mn mo ll b">Third</code> <code class="fe mm mn mo ll b">Second</code> <br/> <strong class="lv io">解释— </strong>我们有一个<code class="fe mm mn mo ll b">setTimeout</code>函数，先调用它。然而，它是最后被记录的。</p><p id="a2ad" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">这是因为，在浏览器中，我们不仅有运行时引擎，我们还有一个叫做<code class="fe mm mn mo ll b">WebAPI</code>的东西。<code class="fe mm mn mo ll b">WebAPI</code>为我们提供了<code class="fe mm mn mo ll b">setTimeout</code>函数，例如DOM。WebAPI不能在准备好的时候就把东西添加到堆栈中。相反，它将回调函数推到一个叫做<em class="mp">队列</em>的地方。事件循环查看堆栈和任务队列。如果堆栈是空的，它将获取队列中的第一个内容，并将其推送到堆栈上。</p><h2 id="e6ea" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题42:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="85c6" class="ko kp in ll b gy lp lq l lr ls">for (var i = 0; i &lt; 3; i++) {<br/>  setTimeout(() =&gt; console.log(i), 1);<br/>}</span><span id="f660" class="ko kp in ll b gy ne lq l lr ls">for (let i = 0; i &lt; 3; i++) {<br/>  setTimeout(() =&gt; console.log(i), 1);<br/>}</span></pre><p id="05e1" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">3 3 3</code>和<code class="fe mm mn mo ll b">0 1 2<br/></code> <strong class="lv io">解释— </strong>由于JavaScript中的事件队列，<code class="fe mm mn mo ll b">setTimeout</code>回调函数在循环执行完毕后被调用<em class="mp">。因为第一个循环中的变量<code class="fe mm mn mo ll b">i</code>是使用<code class="fe mm mn mo ll b">var</code>关键字声明的，所以这个值是全局的。在循环过程中，我们使用一元运算符<code class="fe mm mn mo ll b">++</code>，每次都将<code class="fe mm mn mo ll b">i</code>的值增加<code class="fe mm mn mo ll b">1</code>。在调用<code class="fe mm mn mo ll b">setTimeout</code>回调函数时，第一个例子中的<code class="fe mm mn mo ll b">i</code>等于<code class="fe mm mn mo ll b">3</code>。</em></p><p id="8f1b" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">在第二个循环中，变量<code class="fe mm mn mo ll b">i</code>是用<code class="fe mm mn mo ll b">let</code>关键字声明的:用<code class="fe mm mn mo ll b">let</code>(和<code class="fe mm mn mo ll b">const</code>)关键字声明的变量是块范围的(块是在<code class="fe mm mn mo ll b">{ }</code>之间的任何东西)。在每次迭代中，<code class="fe mm mn mo ll b">i</code>将有一个新的值，并且每个值都在循环中。</p><h2 id="c280" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题43:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="785a" class="ko kp in ll b gy lp lq l lr ls">let obj = {<br/>    x: 2,<br/>    getX: function() {<br/>        setTimeout(() =&gt; console.log('a'), 0);<br/>        new Promise( res =&gt;  res(1)).then(v =&gt; console.log(v));<br/>        setTimeout(() =&gt; console.log('b'), 0);<br/>    }<br/>}</span><span id="aefa" class="ko kp in ll b gy ne lq l lr ls">obj.getX();</span></pre><p id="ff14" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">答案— </strong> <code class="fe mm mn mo ll b">1 a b</code> <strong class="lv io"> <br/>解释— </strong>一个宏任务完成后，先依次执行其他所有的微任务，然后执行下一个宏任务。</p><p id="62b8" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">微任务包括:<code class="fe mm mn mo ll b">MutationObserver</code>、<code class="fe mm mn mo ll b">Promise.then()</code>和<code class="fe mm mn mo ll b">Promise.catch()</code>，其他基于Promise的技术如fetch API、V8垃圾收集过程、节点环境中的<code class="fe mm mn mo ll b">process.nextTick()</code>。</p><p id="5d28" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">宏任务包括初始脚本、<code class="fe mm mn mo ll b">setTimeout</code>、<code class="fe mm mn mo ll b">setInterval</code>、<code class="fe mm mn mo ll b">setImmediate</code>、I/O、UI渲染。</p><p id="45a2" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">由于事件循环<em class="mp">的优先级</em>使作业从作业队列(存储已履行承诺的回调)中出队优先于任务队列(存储超时的<code class="fe mm mn mo ll b">setTimeout()</code>回调)中的任务，所以立即解决的承诺比立即计时器处理得更快。</p><h2 id="061c" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题44:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="88e5" class="ko kp in ll b gy lp lq l lr ls">const shape = {<br/>  radius: 10,<br/>  diameter() {<br/>    return this.radius * 2;<br/>  },<br/>  perimeter: () =&gt; 2 * Math.PI * this.radius,<br/>};</span><span id="900b" class="ko kp in ll b gy ne lq l lr ls">console.log(shape.diameter());<br/>console.log(shape.perimeter());</span></pre><p id="f046" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答—</strong><code class="fe mm mn mo ll b">20</code><code class="fe mm mn mo ll b">NaN<br/></code><strong class="lv io">解释— </strong>注意，<code class="fe mm mn mo ll b">diameter</code>的值是常规函数，而<code class="fe mm mn mo ll b">perimeter</code>的值是箭头函数。</p><p id="3e9f" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">对于箭头函数，<code class="fe mm mn mo ll b">this</code>关键字引用它当前的周围范围，不像常规函数！这意味着当我们调用<code class="fe mm mn mo ll b">perimeter</code>时，它不是指shape对象，而是指它的周围范围(比如window)。</p><p id="1beb" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">那个对象上没有值<code class="fe mm mn mo ll b">radius</code>，它返回<code class="fe mm mn mo ll b">NaN</code>。</p><h2 id="eb93" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题45:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="3042" class="ko kp in ll b gy lp lq l lr ls">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}<br/><br/>const member = new Person('Ayush', 'Verma');<br/>Person.getFullName = function() {<br/>  return `${this.firstName} ${this.lastName}`;<br/>};<br/><br/>console.log(member.getFullName());</span></pre><p id="c25d" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">TypeError<br/></code> <strong class="lv io">解释— </strong>在JavaScript中，函数是对象，因此，方法<code class="fe mm mn mo ll b">getFullName</code>被添加到构造函数对象本身。因此，我们可以调用<code class="fe mm mn mo ll b">Person.getFullName()</code>，但是<code class="fe mm mn mo ll b">member.getFullName</code>抛出一个<code class="fe mm mn mo ll b">TypeError</code>。</p><p id="8ddc" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">如果希望一个方法对所有对象实例都可用，必须将其添加到prototype属性中:</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="3af7" class="ko kp in ll b gy lp lq l lr ls">Person.prototype.getFullName = function() {<br/>  return `${this.firstName} ${this.lastName}`;<br/>};</span></pre><h2 id="efbf" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题46:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="026b" class="ko kp in ll b gy lp lq l lr ls">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}<br/><br/>const ayush = new Person('Ayush', 'Verma');<br/>const sarah = Person('Sarah', 'Smith');<br/><br/>console.log(ayush);<br/>console.log(sarah);</span></pre><p id="439e" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">Person {firstName: "Ayush", lastName: "Verma"}</code>和<code class="fe mm mn mo ll b">undefined<br/></code> <strong class="lv io">解释— </strong>对于<code class="fe mm mn mo ll b">sarah</code>，我们没有使用<code class="fe mm mn mo ll b">new</code>关键字。使用<code class="fe mm mn mo ll b">new</code>时，<code class="fe mm mn mo ll b">this</code>是指我们新建的空对象。但是，如果不加<code class="fe mm mn mo ll b">new</code>，<code class="fe mm mn mo ll b">this</code>指的是全局对象！</p><p id="d439" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">我们说<code class="fe mm mn mo ll b">this.firstName</code>等于<code class="fe mm mn mo ll b">"Sarah"</code>，<code class="fe mm mn mo ll b">this.lastName</code>等于<code class="fe mm mn mo ll b">"Smith"</code>。我们实际做的是定义<code class="fe mm mn mo ll b">global.firstName = 'Sarah'</code>和<code class="fe mm mn mo ll b">global.lastName = 'Smith'</code>。<code class="fe mm mn mo ll b">sarah</code>本身是左边的<code class="fe mm mn mo ll b">undefined</code>，因为我们没有从<code class="fe mm mn mo ll b">Person</code>函数返回值。</p><h2 id="2b21" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题47:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="5859" class="ko kp in ll b gy lp lq l lr ls">const person = { name: 'Ayush' };<br/><br/>function sayHi(age) {<br/>  return `${this.name} is ${age}`;<br/>}<br/><br/>console.log(sayHi.call(person, 21));<br/>console.log(sayHi.bind(person, 21));</span></pre><p id="1709" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— </strong> <code class="fe mm mn mo ll b">Ayush is 21</code> <code class="fe mm mn mo ll b">function<br/></code> <strong class="lv io">解释— </strong>有了这两者，我们就可以传递我们希望<code class="fe mm mn mo ll b">this</code>关键字所指的对象。但是，<code class="fe mm mn mo ll b">.call</code>也是<em class="mp">立即执行</em>！</p><p id="3fd4" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><code class="fe mm mn mo ll b">.bind.</code>返回函数的<em class="mp">副本</em>，但是带有绑定的上下文！它不会立即执行。</p><h2 id="4583" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题48:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="45e1" class="ko kp in ll b gy lp lq l lr ls">let obj = {<br/>    x: 2,<br/>    getX: function() {<br/>        console.log(this.x);<br/>    }<br/>}</span><span id="a3fe" class="ko kp in ll b gy ne lq l lr ls">obj.getX(); (1)</span><span id="7029" class="ko kp in ll b gy ne lq l lr ls">let x = 5;<br/>let obj = {<br/>    x: 2,<br/>    getX:() =&gt; {<br/>        console.log(this.x)<br/>    }<br/>}</span><span id="16fd" class="ko kp in ll b gy ne lq l lr ls">obj.getX(); (2)</span><span id="40ed" class="ko kp in ll b gy ne lq l lr ls">let x = 5;<br/>let obj = {<br/>    x: 2,<br/>    getX: function(){<br/>        let x = 10;<br/>        console.log(this.x);<br/>    }<br/>}</span><span id="4fa3" class="ko kp in ll b gy ne lq l lr ls">let y = obj.getX;<br/>y(); (3)</span></pre><p id="af8a" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— <br/> </strong> <code class="fe mm mn mo ll b">1) 2<br/> 2) undefined<br/> 3) undefined<br/></code> <strong class="lv io">解释— </strong>第一种情况是常规函数，根据调用函数的<strong class="lv io"> <em class="mp">上下文</em> </strong>将<code class="fe mm mn mo ll b">this</code>关键字绑定到不同的值。这里obj正在调用这个函数，它将指向当前obj。</p><p id="639f" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">第二种情况是一个箭头函数，它将使用<code class="fe mm mn mo ll b">this</code>在它们的<strong class="lv io"> <em class="mp">词法范围</em> </strong> <em class="mp">中的值，即x在周围范围中的</em>值。这里环绕的是全局范围或窗口对象。在这种情况下，“x”被声明为let，<code class="fe mm mn mo ll b">let</code>与<code class="fe mm mn mo ll b">var</code>不同，不在全局对象上创建属性。“x”不存在，即返回未定义。如果“x”被声明为var，它将返回5。</p><p id="4332" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">在第三种情况下，“y”被赋值为<code class="fe mm mn mo ll b">obj.getX,</code>，并且“y”在全局范围或窗口对象中。因此,“this”将指向全局范围，即全局“x ”,由于“x”被声明为let，所以全局“x”是未定义的。如果“x”被声明为var，它将返回5。</p><h2 id="c4d1" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题49:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="5954" class="ko kp in ll b gy lp lq l lr ls">let a = 10, b = 20;<br/>setTimeout(function () {<br/>  console.log('Ayush');<br/>  a++;<br/>  b++;<br/>  console.log(a + b);<br/>});<br/>console.log(a + b);</span></pre><p id="5a6e" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答—</strong>30“ayu sh”32。<br/> <strong class="lv io">解释— </strong> Settimeout在事件循环中把函数压入BOM栈或者在主函数执行完一切后执行。所以结果打印在主函数的console.log之后。</p><h2 id="48b6" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题50:</h2><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="69b4" class="ko kp in ll b gy lp lq l lr ls">function a() {<br/>  this.site = 'Ayush';<br/><br/>  function b(){<br/>    console.log(this.site);<br/>  } <br/>  <br/>  b();<br/>}<br/><br/>var site = 'Wikipedia';<br/>a(); (1)</span><span id="46ba" class="ko kp in ll b gy ne lq l lr ls">function a() {<br/>  this.site = 'Ayush';<br/><br/>  function b(){<br/>    console.log(this.site);<br/>  } <br/>  <br/>  b();<br/>}<br/><br/>var site = 'Wikipedia';<br/>new a(); (2)</span><span id="55d0" class="ko kp in ll b gy ne lq l lr ls">function a() {<br/>  this.site = 'Ayush';<br/><br/>  function b(){<br/>    console.log(this.site);<br/>  } <br/>  <br/>  b();<br/>}<br/><br/>let site = 'Wikipedia';<br/>new a(); (3)</span></pre><p id="8db7" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">回答— <br/> </strong> <code class="fe mm mn mo ll b">1. 'Ayush'</code>。<br/> <code class="fe mm mn mo ll b">2. 'Wikipedia'<br/> 3. undefined</code></p><p id="2720" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><strong class="lv io">解释— <br/> </strong> 1。当执行具有正常语法的函数时，如果在执行时没有设置，将使用最近的父节点的值<code class="fe mm mn mo ll b">this</code>，所以在这种情况下它是<code class="fe mm mn mo ll b">window</code>，然后我们在<code class="fe mm mn mo ll b">window</code>对象中更新设置属性<code class="fe mm mn mo ll b">site</code>并在内部访问它，所以它是<code class="fe mm mn mo ll b">'Ayush'</code>。</p><p id="f7df" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">2.当用关键字<code class="fe mm mn mo ll b">new</code>调用一个函数作为构造函数时，那么<code class="fe mm mn mo ll b">this</code>的值将是在执行时创建的新对象，所以目前是<code class="fe mm mn mo ll b">{ site: 'Ayush' }</code>。</p><p id="d50f" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">但是当一个具有正常语法的函数被执行时，<code class="fe mm mn mo ll b">this</code>的值将默认为全局范围，如果它在执行时没有被赋值的话，所以它是<code class="fe mm mn mo ll b">b()</code>的<code class="fe mm mn mo ll b">window</code>并且<code class="fe mm mn mo ll b">var site = 'Wikipedia';</code>将该值添加到全局对象，因此当它在<code class="fe mm mn mo ll b">b()</code>内部被访问时，它打印<code class="fe mm mn mo ll b">'Wikipedia'</code>。</p><p id="3118" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">3.用<code class="fe mm mn mo ll b">let</code>定义的变量不会添加到全局范围。因此，未定义。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><p id="3411" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated">我希望你已经发现这是有用的。感谢您的阅读！</p><p id="3268" class="pw-post-body-paragraph lt lu in lv b lw lx jo ly lz ma jr mb kx mc md me lb mf mg mh lf mi mj mk ml ig bi translated"><em class="mp">更多内容请看</em><a class="ae nf" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lv io"><em class="mp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>