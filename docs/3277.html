<html>
<head>
<title>JavaScript Promise Cheat Sheet — Basic Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Promise备忘单—基本操作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-promise-cheat-sheet-basic-operations-7c7589aaa4a0?source=collection_archive---------10-----------------------#2021-07-04">https://javascript.plainenglish.io/javascript-promise-cheat-sheet-basic-operations-7c7589aaa4a0?source=collection_archive---------10-----------------------#2021-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f09f96bce1cad943866eb378f71d0e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zE3-6UM7BxM9SjZ2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kat_katerina?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Katerina Pavlyuchkova</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript promises让我们可以轻松地将非IO阻塞的异步代码顺序添加到我们的JavaScript应用程序中。</p><p id="624f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，它们在任何地方都被使用。</p><p id="613a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何在JavaScript代码中使用承诺。</p><h1 id="dcdf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创造一个承诺</h1><p id="e22a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Promise</code>构造函数创建一个承诺。</p><p id="de10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="420c" class="mq lc iq mh b gy mr ms l mt mu">const myPromise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    resolve('foo');<br/>  }, 300);<br/>});</span></pre><p id="a8d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将回调传递给<code class="fe me mf mg mh b">Promise</code>构造函数。</p><p id="96ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">resolve</code>通过返回值实现承诺。</p><p id="1912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">reject</code>是一个抛出错误的函数。</p><h1 id="d839" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">then方法</h1><p id="9e10" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">then</code>方法来获得承诺的解析值。</p><p id="b42f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b08c" class="mq lc iq mh b gy mr ms l mt mu">const myPromise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    resolve('foo');<br/>  }, 300);<br/>});</span><span id="62e1" class="mq lc iq mh b gy mv ms l mt mu">myPromise<br/>  .then(<br/>    val =&gt; console.log(val),<br/>    err =&gt; console.log(err)<br/>  )</span></pre><p id="99f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个<code class="fe me mf mg mh b">then</code>回调将解析的值作为参数。</p><p id="b726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个<code class="fe me mf mg mh b">then</code>回调将被拒绝的值作为参数。</p><h1 id="ac7a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">连锁承诺</h1><p id="e51c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过在<code class="fe me mf mg mh b">then</code>回调中返回一个承诺来链接多个承诺。</p><p id="1d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c5d0" class="mq lc iq mh b gy mr ms l mt mu">Promise.resolve(1)<br/>  .then(() =&gt; Promise.resolve(2))<br/>  .then((val) =&gt; console.log(val))</span></pre><p id="a9bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称<code class="fe me mf mg mh b">Promise.resolve</code>为创造一个解决问题的承诺。</p><p id="8cff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一个<code class="fe me mf mg mh b">then</code>回调中，我们返回由<code class="fe me mf mg mh b">Promise.resolve(2)</code>创建的承诺。</p><p id="24ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们用<code class="fe me mf mg mh b">val</code>参数获得该承诺的解析值。</p><p id="3607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe me mf mg mh b">val</code>是2。</p><h1 id="a636" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">同时运行所有承诺</h1><p id="3ee1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Promise.all</code>方法同时运行所有承诺。</p><p id="0b14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="af0a" class="mq lc iq mh b gy mr ms l mt mu">Promise.all([<br/>    Promise.resolve(1),<br/>    Promise.resolve(2),<br/>    Promise.resolve(3),<br/>  ])<br/>  .then((vals) =&gt; console.log(vals))</span></pre><p id="047f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们给<code class="fe me mf mg mh b">Promise.all</code>打电话，提出了3个解决问题的承诺。</p><p id="8c59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">then</code>回调中，我们有<code class="fe me mf mg mh b">vals</code>参数，它有一个已解析值的数组。</p><p id="6d5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe me mf mg mh b">vals</code>就是<code class="fe me mf mg mh b">[1, 2, 3]</code>，是所有承诺的解析值。</p><h1 id="75ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不管结果如何，都要等待所有的承诺得到解决</h1><p id="03bf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Promise.allSettled</code>方法同时运行所有承诺，并获得它们的结果，不管它们是被解决还是被拒绝。</p><p id="57db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="158f" class="mq lc iq mh b gy mr ms l mt mu">Promise.allSettled([<br/>    Promise.resolve(1),<br/>    Promise.reject('error'),<br/>    Promise.resolve(3),<br/>  ])<br/>  .then((vals) =&gt; console.log(vals))</span></pre><p id="4008" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5a52" class="mq lc iq mh b gy mr ms l mt mu">[<br/>  {<br/>    "status": "fulfilled",<br/>    "value": 1<br/>  },<br/>  {<br/>    "status": "rejected",<br/>    "reason": "error"<br/>  },<br/>  {<br/>    "status": "fulfilled",<br/>    "value": 3<br/>  }<br/>]</span></pre><p id="0684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe me mf mg mh b">vals</code>的值。</p><p id="e017" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">status</code>有出息的地位。</p><p id="cf7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe me mf mg mh b">value</code>有数值。</p><h1 id="c2bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">等到第一个承诺解决</h1><p id="d521" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">方法让我们等到第一个承诺被解决。</p><p id="58ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4b6e" class="mq lc iq mh b gy mr ms l mt mu">Promise.any([<br/>    Promise.reject('error'),<br/>    Promise.resolve(1),<br/>    Promise.resolve(3),<br/>  ])<br/>  .then((val) =&gt; console.log(val))</span></pre><p id="68d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是1，因为它是第一个解析的承诺。</p><p id="5c84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.any</code>返回一个承诺，其值为解决的第一个承诺的值。</p><h1 id="5ab0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">等到任何一个承诺被解决或拒绝</h1><p id="b115" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Promise.race</code>方法等待，直到任何承诺解决或拒绝。</p><p id="87da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="248b" class="mq lc iq mh b gy mr ms l mt mu">Promise.race([<br/>    Promise.reject('error'),<br/>    Promise.resolve(1),<br/>    Promise.resolve(3),<br/>  ])<br/>  .then((val) =&gt; console.log(val))<br/>  .catch((err) =&gt; console.log(err))</span></pre><p id="f3c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">catch</code>回调将记录<code class="fe me mf mg mh b">'error'</code>，因为第一个承诺因<code class="fe me mf mg mh b">'error'</code>原因被拒绝。</p><h1 id="79ff" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c197" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用承诺来简化异步JavaScript代码的编写。</p><p id="0ae2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容尽在</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>