<html>
<head>
<title>Create Client-Side Auth with Finite State Machines, Redux and Redux Sagas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用有限状态机Redux和Redux Sagas创建客户端Auth</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/client-side-authentication-via-finite-state-machines-redux-and-redux-sagas-cd3e0e2bd9ab?source=collection_archive---------8-----------------------#2021-01-05">https://javascript.plainenglish.io/client-side-authentication-via-finite-state-machines-redux-and-redux-sagas-cd3e0e2bd9ab?source=collection_archive---------8-----------------------#2021-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/28b59673bbe197a7046c1b246af72112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JmQh8LcpRKQVQxNdQQ68A.jpeg"/></div></div></figure><blockquote class="jv jw jx"><p id="acdf" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">"只有那些敢于冒险走得太远的人，才有可能发现自己能走多远。"艾略特</p></blockquote></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="2be5" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">可以说，软件工程中我最喜欢的一个方面是总有新想法的空间。尝试新事物不需要任何人的许可，你只要去做就行了。有时候你的新想法出奇地有效，有时候则不然，但这就是尝试新事物的乐趣所在。</p><p id="5364" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">我想在本文中讨论的“新”想法是使用有限状态机结合Redux和Redux-Saga来处理React应用程序中的客户端身份验证。我给单词<em class="ka"> new </em>加上引号的原因是因为这些概念中的每一个都已经存在了相当长的一段时间。然而，据我所知，将它们放在一起处理客户端身份验证是一个新想法。</p><p id="3ecd" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">本文将分为6个部分:</p><ol class=""><li id="2ef3" class="lh li in kb b kc kd kg kh le lj lf lk lg ll kw lm ln lo lp bi translated">我们要建造什么？</li><li id="6688" class="lh li in kb b kc lq kg lr le ls lf lt lg lu kw lm ln lo lp bi translated">什么是状态机？</li><li id="ea02" class="lh li in kb b kc lq kg lr le ls lf lt lg lu kw lm ln lo lp bi translated">什么是传奇？</li><li id="5e98" class="lh li in kb b kc lq kg lr le ls lf lt lg lu kw lm ln lo lp bi translated">基本应用程序设置。</li><li id="cee0" class="lh li in kb b kc lq kg lr le ls lf lt lg lu kw lm ln lo lp bi translated">构建认证架构。</li><li id="39e4" class="lh li in kb b kc lq kg lr le ls lf lt lg lu kw lm ln lo lp bi translated">构建身份验证用户界面。</li></ol></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="37e3" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">我们正在建造的东西</h1><p id="778d" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">在你继续阅读之前，我认为了解我们到底在构建什么，并确定你是否有兴趣继续下去是很重要的。本文的最终目标是拥有一个简单的React应用程序，它使用连接到redux的有限状态机实现身份验证，并使用redux-sagas作为处理异步操作(API调用)的独立线程。</p><p id="e62c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">不会有任何形式的CSS，HTML或样式的重点。HTML将尽可能保持最小，因为本文的重点是身份验证架构，而不是用户界面。在这篇文章的最后，你将有一个允许用户登录，设置他们的帐户和注销的应用程序。您将能够采用本文中介绍的思想，对其进行扩展，并将其应用到您的应用程序中。</p><h1 id="57b0" class="lv lw in bd lx ly my ma mb mc mz me mf mg na mi mj mk nb mm mn mo nc mq mr ms bi translated">引入状态机</h1><p id="0fe2" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">有限状态机是描述系统行为的数学模型，该系统在任何给定时刻只能处于一种状态。该模型还描述了系统如何在其有限的状态集之间转换。信不信由你，你可能已经隐式地编写了一个状态机，甚至还没有意识到。</p><p id="3886" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">你可能想知道为什么我用一张交通灯的图片作为这篇文章的英雄形象。我这样做的原因是因为交通灯是有限状态机。让我们想想最简单的交通灯，它有三种状态:停止(红色)、减速(黄色)和通行(绿色)。交通灯有三种状态，在任何给定的时间，它只能处于其中一种状态。你不可能有一个交通灯同时告诉你停止<em class="ka">和</em>前进。那将是微软制造的交通灯。</p><p id="0599" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">现在，让我们考虑一下交通灯的规则，以及它如何在三种状态之间转换。交通灯不能从绿色变成红色。只能从绿色，到黄色，再到红色。从红色，它不能回到黄色，它必须先过渡到绿色，然后黄色等等。交通灯是一个有限状态机。它有一组有限的状态，对于如何在这些状态之间转换有严格的规则，并且一次只能处于一种状态。</p><p id="02f2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">那么，这如何应用于编程呢？当你想到你过去写的一些代码时，你可能会想到一些例子，你实际上使用了一个状态机，而你甚至没有意识到。例如，您可能已经构建了一个从API加载一些数据的组件。该组件可能有3种状态:正在加载、失败和已解决。它可能还隐含有规则，即您不能从已解决状态转换回失败状态，这将是一种糟糕的用户体验。</p><p id="6e3f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">状态机非常适合前端应用。构建前端应用程序的全部本质是根据一些当前的本地状态向用户显示信息。无论是身份验证状态、api调用的异步状态还是基于其他的状态。我们将应用有限状态机的概念来更容易、更安全地处理客户端认证。</p><p id="a076" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">下面是我们将要构建的状态机的可视化。机器有以下三种状态:<code class="fe nd ne nf ng b">signIn</code>、<code class="fe nd ne nf ng b">signedIn</code>和<code class="fe nd ne nf ng b">accountSetup</code>。每个状态基于一个事件(如<code class="fe nd ne nf ng b">auth/LOGIN</code>)执行一个转换(箭头表示转换)。每个转变都伴随着一系列的动作，比如<code class="fe nd ne nf ng b">setUser</code>。这种形象化在以后会更有意义，但是你可以在阅读的时候回头参考它。</p><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/a65593f70949fb0e4c4184eaab11b231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zy_i6eS2oXv2o1sxIBfAWA.png"/></div></div></figure><p id="527a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated"><a class="ae nm" href="https://xstate.js.org/viz/?gist=9eea8173e53528572e15a9f2a0d4df1d" rel="noopener ugc nofollow" target="_blank">https://xstate.js.org/viz/?gist = 9 EEA 8173 e 53528572 e 15 a 9 F2 a 0d 4d f1 d</a></p><h1 id="9df3" class="lv lw in bd lx ly my ma mb mc mz me mf mg na mi mj mk nb mm mn mo nc mq mr ms bi translated">介绍Redux Sagas</h1><p id="89e7" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">出于本文的目的，我将假设您已经熟悉Redux本身。如果你不是，那么我建议你在开始钻研redux Saga之前先读一些关于Redux的文章。</p><p id="e7b8" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">在我们讨论Redux Saga之前，我们需要讨论一下Saga模式。Sagas的概念源于寻找一种更好的方法来管理跨多个服务或业务领域的顺序事务的需要，以及在一个或多个事务失败的情况下保持系统中数据一致性的需要。一个真实世界的例子将能够更好地解释这一点，所以让我们这样做。</p><p id="c894" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">假设我们有一个电子商务应用程序，用户订购了一台新电视。为了成功下订单，必须进行一系列连续的“交易”。首先，您的应用程序可能会检查库存数据库，以确保电视有库存，然后它可能会在该商品上放置一个临时标志，以表明它即将被购买。然后，您需要从用户的银行核实他们有足够的资金并执行交易。然后，您需要返回到库存数据库，并从库存中删除该商品。然后，您可能想要向第三方发送通知。</p><p id="0b9f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">在上面的示例中，您可以看到跨不同服务进行了多次“交易”，即您的订单数据库、库存数据库、银行服务、通知服务。如果在这些步骤中的任何一个发生错误，saga模式可以很容易地撤销(或重试)所有以前的事务，从而防止所有不同服务之间的数据不一致。</p><p id="c502" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">Redux Saga通过Redux中间件将Saga模式带给客户端。您可以将Redux Saga视为应用程序中的一个独立线程，它总是在后台“运行”,并响应通过Redux操作分派的事件。你的用户将作为这些事件以及其他传奇的触发器。</p><p id="646e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">例如，用户点击一个“添加到购物车”按钮，该按钮将一个动作分派给redux，redux saga然后启动相应的saga。成功后，该传奇会发送一个动作，启动另一个发送确认电子邮件的传奇。一旦saga完成，它就会更新您的redux store，并更新您的“Basket Total”组件，以反映购物车中所有商品的新总数。随着应用程序复杂性的增加，您可以开始看到前端sagas的优势在哪里。一旦我们开始构建应用程序，好处将变得更加明显。</p><h1 id="3058" class="lv lw in bd lx ly my ma mb mc mz me mf mg na mi mj mk nb mm mn mo nc mq mr ms bi translated">关于生成器函数的快速注释</h1><p id="7d9d" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">我不打算深入研究生成器函数，但是不提到它们对我来说太疯狂了。Redux Saga是由ES6生成器函数实现的，它是一类特殊的函数，可以停止和启动(或退出和重新进入)。它们看起来像这样，其中星号(*)用于让JavaScript知道这个函数是一个生成器:</p><pre class="ni nj nk nl gt nn ng no np aw nq bi"><span id="c5c1" class="nr lw in ng b gy ns nt l nu nv">function* addToCartSaga(item) {<br/>     const result = yield addToCart(item);     <br/>     yield 'Hello';<br/>     yield sayGoodbyeAfter4Seconds();<br/>}</span></pre><p id="d39f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">关键字<code class="fe nd ne nf ng b">yield</code>告诉JavaScript等待这行代码完成。每个<code class="fe nd ne nf ng b">yield</code>返回一个<code class="fe nd ne nf ng b">Iterator</code>，它可以用来启动下一个<code class="fe nd ne nf ng b">yield</code>。</p><pre class="ni nj nk nl gt nn ng no np aw nq bi"><span id="1198" class="nr lw in ng b gy ns nt l nu nv">const <!-- -->gen<!-- --> = <!-- -->addToCartSaga<!-- -->(item);<br/><br/>console.log(<!-- -->gen<!-- -->.next().value); // the item from the cart<br/>console.log(<!-- -->gen<!-- -->.next().value); // 'Hello'<br/>console.log(<!-- -->gen<!-- -->.next().value); // 'Goodbye'</span></pre><p id="10de" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">生成器最强大的功能是函数上下文(思考范围或变量)将在停止和开始时保存。Redux saga使用生成器功能，使我们能够构建强大的异步控制流，可以在任何时间点停止、启动和重新启动。</p><h1 id="83cd" class="lv lw in bd lx ly my ma mb mc mz me mf mg na mi mj mk nb mm mn mo nc mq mr ms bi translated">基本应用程序设置</h1><p id="04d0" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">为了节省时间，我不打算完成安装应用程序的整个过程。我提供了一个使用<strong class="kb io"> Create-React-App </strong>构建的初始报告，你可以用来跟进。所以只需克隆repo，运行<code class="fe nd ne nf ng b">yarn install</code>然后运行<code class="fe nd ne nf ng b">yarn start</code>，你就会看到一个基本的应用程序。repo将为您提供尽快启动和运行所需的一切，并避免处理偏离本文学习目标的样板代码。一旦应用程序启动并运行，请继续阅读。</p><p id="89cc" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">您可以在这里找到repo:<a class="ae nm" href="https://github.com/jerrywithaz/client-auth-state-machines-redux-sagas-starter" rel="noopener ugc nofollow" target="_blank">https://github . com/jerrywitaz/client-auth-state-machines-redux-sagas-starter</a></p><h1 id="a1b6" class="lv lw in bd lx ly my ma mb mc mz me mf mg na mi mj mk nb mm mn mo nc mq mr ms bi translated">结合XState、Redux和Redux-Saga</h1><p id="9fc1" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">现在，我们已经过了核心概念并得到了基本的应用程序设置，差不多是时候编写实际的代码了！但首先，我想解释一下您克隆的repo中某些文件的用途，以免丢失或混淆。</p><h2 id="fca3" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">src/redux/auth/actions.ts</h2><p id="699c" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">该文件的目的是设置我们的动作创建者。动作创建器是接受一些参数集并返回redux动作对象的函数。它们是一个很好的声明性抽象，可以防止您在需要调度操作时键入对象。相反，您会这样做:</p><pre class="ni nj nk nl gt nn ng no np aw nq bi"><span id="5e17" class="nr lw in ng b gy ns nt l nu nv">dispatch(login(username, password));</span><span id="ea14" class="nr lw in ng b gy oh nt l nu nv">## instead of</span><span id="6d76" class="nr lw in ng b gy oh nt l nu nv">dispatch({ type: 'auth/LOGIN', payload: { username, password }});</span></pre><h2 id="3822" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">src/redux/auth/api.ts</h2><p id="45fd" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">这是一个充当我们的模拟后端api的文件。出于本文的目的，不需要实际的后端，如果您愿意，您可以添加自己的后端。这里的“api”只是简单地解决了类似于使用像<code class="fe nd ne nf ng b">Axios</code>这样的库进行api请求的承诺。</p><h2 id="439b" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">src/redux/auth/hooks.ts</h2><p id="734d" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">我将单独写一篇关于这个模式的文章，但是我非常喜欢创建自定义钩子，以便从redux商店的不同地方选择状态。这些简单的单线挂钩让您的组件简单易读。例如:</p><pre class="ni nj nk nl gt nn ng no np aw nq bi"><span id="162e" class="nr lw in ng b gy ns nt l nu nv">import { useAuthStatus } from "./redux/auth/hooks";</span><span id="0018" class="nr lw in ng b gy oh nt l nu nv">function AuthComponent() {<br/>    const authStatus = useAuthStatus();</span><span id="1e35" class="nr lw in ng b gy oh nt l nu nv">    if (authStatus === 'signedIn')<br/>        return &lt;SignInComponent /&gt;<br/>}</span></pre><h2 id="f44d" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">src/redux/auth/machine.ts</h2><p id="364f" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">该文件将包含我们的身份验证状态机，并将定义身份验证控制流的有效状态和转换。</p><h2 id="857b" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">src/redux/auth/reduce . ts</h2><p id="0f2d" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">这个文件将包含我们的认证缩减器，它将由认证状态机提供动力。</p><h2 id="92e2" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">src/redux/auth/sagas.ts</h2><p id="dca0" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">该文件将包含我们的认证传奇。</p><h2 id="d586" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">src/redux/auth/selecters . ts</h2><p id="9ec8" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">它包含redux选择器，可以有效地从我们的身份验证状态中选择一个状态。</p><h2 id="0a07" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">src/redux/auth/types.ts</h2><p id="df29" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">该文件的目的是设置身份验证状态所需的所有TypeScript定义。我们定义了存储上的身份验证状态的形状，以及可以分派给身份验证缩减器的每个动作的形状。</p><h2 id="ac85" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">定义机器</h2><p id="da9a" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">好了，现在是代码时间！认证架构的第一个也是最重要的部分是认证状态机，它将控制用户如何通过我们的认证协议的流程。我们将使用名为<code class="fe nd ne nf ng b">xstate</code>的库来创建我们的状态机。让我们打开<code class="fe nd ne nf ng b">machine.ts</code>并添加以下几行:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="09e5" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">这里我们使用<code class="fe nd ne nf ng b">xstate</code>建立一个基本的状态机。我们给机器一个名为<code class="fe nd ne nf ng b">auth</code>的唯一标识符，我们定义它的初始状态<code class="fe nd ne nf ng b">signIn</code>，我们初始化它的本地上下文，本地上下文将存储机器的附加上下文信息，如<code class="fe nd ne nf ng b">user</code>对象。您还会注意到，我们为机器定义了3种状态:<code class="fe nd ne nf ng b">signIn</code>、<code class="fe nd ne nf ng b">signedIn</code>和<code class="fe nd ne nf ng b">accountSetup</code>。下一步是定义每个状态的有效转换。</p><p id="7b70" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">使用<code class="fe nd ne nf ng b">xstate</code>，您可以将任何给定状态的基本转换定义为:</p><pre class="ni nj nk nl gt nn ng no np aw nq bi"><span id="ad6d" class="nr lw in ng b gy ns nt l nu nv">accountSetup: {<br/>  on: {<br/>    "auth/LOGIN_SUCCESS": {<br/>      target: "signedIn",<br/>      actions: ["setUser", "unsetError", "unsetLoading"],<br/>    },<br/>  }<br/>},</span></pre><p id="99c0" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">这告诉<code class="fe nd ne nf ng b">xstate</code>当auth machines状态值为<code class="fe nd ne nf ng b">accountSetup</code>时，我们可以响应类型为<code class="fe nd ne nf ng b">auth/LOGIN_SUCCESS</code>的事件。<code class="fe nd ne nf ng b">target</code>表示当<code class="fe nd ne nf ng b">auth/LOGIN_SUCCESS</code>事件发生时，我们将转换到<code class="fe nd ne nf ng b">signedIn</code>状态。<code class="fe nd ne nf ng b">actions</code>属性表示当<code class="fe nd ne nf ng b">auth/LOGIN_SUCCESS</code>事件发生时，我们希望执行以下动作(我们将很快定义这些动作)。</p><p id="3351" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">现在你已经理解了定义转换的基础，让我们将所有允许的转换添加到我们机器上的<code class="fe nd ne nf ng b">state</code>对象中。复制以下代码:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a875" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">现在我们已经定义了所有的状态及其转换。我们需要做的最后一件事是定义我们的<code class="fe nd ne nf ng b">actions</code>。<code class="fe nd ne nf ng b">xstate</code>中的动作负责更新状态机的上下文。将以下代码添加到您机器上的<code class="fe nd ne nf ng b">actions</code>属性中:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="aa85" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">创建减速器</h2><p id="08b7" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">我们现在有一个完全工作的状态机来控制我们的身份验证状态。我们需要做的下一件事是将这个机器连接到我们的reducer，这样对身份验证状态机的更改就可以在redux中持久化。打开<code class="fe nd ne nf ng b">reducer.ts</code>并添加以下代码:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="7469" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">我们正在创建一个标准的redux reducer，只是我们使用状态机通过机器的<code class="fe nd ne nf ng b">transition</code>方法来管理转换。</p><h2 id="34bb" class="nr lw in bd lx nw nx dn mb ny nz dp mf le oa ob mj lf oc od mn lg oe of mr og bi translated">创造传奇</h2><p id="7bd6" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">我们需要完成的最后一步是创建sagas，它负责向后端发出api请求，并将成功和失败发送回redux。</p><p id="02c5" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">Redux-Saga中的Saga实际上不会发出任何异步请求，也不会自己执行任何代码，它们只是描述应该发生什么。代码的实际执行由中间件处理。你的传奇只会产生这样的效果，比如“<em class="ka">调用</em>一个名为login的函数”或者“<em class="ka">让</em>一个名为loginSuccess的动作”。你可以从<code class="fe nd ne nf ng b">redux-saga/effects</code>导入特效。</p><p id="7840" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">因此，一个简单的登录传奇应该是这样的:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="655a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">如前所述，使用redux saga构建的saga不执行您的功能，saga中间件执行。每个<code class="fe nd ne nf ng b">yield</code>语句返回一个效果描述符，如下所示:</p><pre class="ni nj nk nl gt nn ng no np aw nq bi"><span id="5dfa" class="nr lw in ng b gy ns nt l nu nv">{<br/>  CALL: {<br/>    fn: loginApi,<br/>    args: ['test@email.com', 'password']<br/>  }<br/>}</span></pre><p id="41a3" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">我们需要让我们的sagas工作的另一件事是，我们需要设置“观察者”sagas，它将负责告诉saga中间件每当一个动作被分派给redux以匹配特定的动作类型时就执行某个saga。例如，您可能想告诉redux saga在调度类型为<code class="fe nd ne nf ng b">auth/LOGIN</code>的动作时执行<code class="fe nd ne nf ng b">loginSaga</code>。登录观察器传奇看起来像这样:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2842" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">让我们利用以上所有信息，创建3个传奇:<code class="fe nd ne nf ng b">login</code>、<code class="fe nd ne nf ng b">logout</code>和<code class="fe nd ne nf ng b">accountSetup</code>。每个saga对应于认证状态机的一个有效状态。打开<code class="fe nd ne nf ng b">sagas.ts</code>并粘贴以下代码:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ea24" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">所以，让我们来分解一下。我们建立了一个登录传奇，注销传奇和帐户设置传奇。用户必须做的第一件事是登录，所以每当登录动作被调度时，我们将通过执行<code class="fe nd ne nf ng b">loginSaga</code>来响应。根据用户的状态，我们要么分派一个<code class="fe nd ne nf ng b">loginSuccess</code>动作，要么分派一个<code class="fe nd ne nf ng b">confirmPassword</code>动作。</p><p id="fac2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">如果您还记得，当我们设置我们的状态机时，我们定义了一个转换，允许用户在调度类型为<code class="fe nd ne nf ng b">auth/CONFIRM_USER</code>的事件时从<code class="fe nd ne nf ng b">signIn</code>转换到<code class="fe nd ne nf ng b">accountSetup</code>:</p><pre class="ni nj nk nl gt nn ng no np aw nq bi"><span id="ed44" class="nr lw in ng b gy ns nt l nu nv">"auth/CONFIRM_USER":{            <br/>    "target":"accountSetup",            <br/>    "actions":["setUser","unsetError","unsetLoading"]         <br/>}</span></pre><p id="0f5f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">希望现在你能看到我们的国家机器和我们的传奇之间的联系。我们的状态机定义了我们的状态和受保护的转换，因此我们的应用程序永远不会处于无效状态。Redux saga负责实际调用触发我们状态变化的函数。每个传奇就像它自己的微服务，进行一个或多个交易，然后将事件分派回redux，redux然后基于这些事件启动其他传奇。</p><p id="e7fa" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">此时，我们已经定义了我们的状态机，将它与我们的reducer配对以持久化状态，并且我们已经创建了我们处理副作用的传奇。我们的认证架构已经可以使用了！</p><h1 id="beee" class="lv lw in bd lx ly my ma mb mc mz me mf mg na mi mj mk nb mm mn mo nc mq mr ms bi translated">构建用户界面</h1><p id="f8a4" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">最后要做的是将我们的redux状态连接到我们的React UI，这样我们就可以根据状态显示/隐藏信息。正如我在本文开头提到的，这篇文章的重点不是HTML和CSS，所以我将只编写最简单的HTML来演示如何在React组件中使用我们的身份验证状态机。</p><p id="7149" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">因此，打开<code class="fe nd ne nf ng b">src/App.tsx</code>并粘贴以下代码:</p><figure class="ni nj nk nl gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8067" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">那么，让我们来分析一下发生了什么。我们使用从redux auth状态导出的定制钩子来获取当前的身份验证状态。由于我们使用状态机，我们知道我们的应用程序只能处于三种状态:<code class="fe nd ne nf ng b">signIn</code>、<code class="fe nd ne nf ng b">accountSetup</code>或<code class="fe nd ne nf ng b">signedIn</code>。根据应用程序的身份验证状态，我们显示3个不同的按钮。我们还设置了硬编码的按钮处理程序，当每个按钮被点击时，它将动作分派给redux存储。</p><p id="7b42" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">使用redux sagas的一个巨大好处是我们可以保持组件同步。你会注意到阅读我们的组件是多么简单和容易。我们不必进行任何异步调用，也不必担心确保我们的组件仍处于挂载状态。我们只是简单地从redux获取状态并分派动作。测试传奇也非常(我的意思是非常)容易，但是我会做一个单独的文章，所以敬请关注！</p><h1 id="ed87" class="lv lw in bd lx ly my ma mb mc mz me mf mg na mi mj mk nb mm mn mo nc mq mr ms bi translated">结论</h1><p id="b642" class="pw-post-body-paragraph jy jz in kb b kc mt ke kf kg mu ki kj le mv km kn lf mw kq kr lg mx ku kv kw ig bi translated">身份验证是许多应用程序的核心，每个人的处理方式都不一样。身份认证流程通常很复杂，并且有许多移动部分，很难以清晰的方式进行管理。我们可以将有限状态机的完整性与saga模式的灵活性结合起来，构建一个易于管理、易于扩展和易于测试的认证系统。</p><p id="d743" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">你可以在这里下载完整的演示报告:<a class="ae nm" href="https://github.com/jerrywithaz/client-auth-state-machines-redux-sagas" rel="noopener ugc nofollow" target="_blank">https://github . com/jerrywithaz/client-auth-state-machines-redux-sagas</a></p><p id="e8df" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj le kl km kn lf kp kq kr lg kt ku kv kw ig bi translated">如果你有任何问题或者想让我澄清什么，请在评论中告诉我。我将会写一篇关于测试状态机和传奇的后续文章。</p></div></div>    
</body>
</html>