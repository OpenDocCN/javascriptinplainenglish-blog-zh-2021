<html>
<head>
<title>Everything New in TypeScript 4.5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.5中的所有新功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-new-in-typescript-4-5-f57b0b3dc437?source=collection_archive---------9-----------------------#2021-12-22">https://javascript.plainenglish.io/everything-new-in-typescript-4-5-f57b0b3dc437?source=collection_archive---------9-----------------------#2021-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8eb2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个更好的TypeScript版本终于出现了</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0d6c5c5790e2de919a6180f8c6da064d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DU4TA-mrd2wz_X7g4PwjjA.png"/></div></div></figure><h2 id="5ddd" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.期待的类型和承诺的改进</h2><p id="d412" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在<strong class="lp ir"> JavaScript中，</strong>开发者在使用内置方法时面临挑战，如<strong class="lp ir"> promise.all </strong>，在<em class="mg"> TypeScript 4.5 </em>中，引入了新的<strong class="lp ir">wait</strong>类型，用于建模操作，如<strong class="lp ir"> async </strong>函数中的<strong class="lp ir">wait</strong>。</p><blockquote class="mh mi mj"><p id="834a" class="ln lo mg lp b lq mk jr ls lt ml ju lv mm mn lx ly mo mp ma mb mq mr md me mf ij bi translated">此功能提供了以下功能:</p></blockquote><ul class=""><li id="a728" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">递归展开。</li><li id="f0e3" class="ms mt iq lp b lq nb lt nc la nd le ne li nf mf mx my mz na bi translated">解决类似<strong class="lp ir">【the nables】</strong>的承诺不需要类似的<strong class="lp ir">承诺。</strong></li><li id="1542" class="ms mt iq lp b lq nb lt nc la nd le ne li nf mf mx my mz na bi translated"><strong class="lp ir">不承诺</strong>不兑现<strong class="lp ir">绝不兑现</strong>。</li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="5ea6" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.nod_modules的Lib支持</h2><p id="8516" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">TypeScript附带了一堆以<strong class="lp ir"> <em class="mg"> .d.ts </em> </strong>结尾的声明文件，这些文件用于<strong class="lp ir">类型检查，</strong>它们也代表了标准的<strong class="lp ir">DOM API</strong>和内置的<strong class="lp ir">API</strong>。</p><ul class=""><li id="29f7" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">我们提供的<em class="mg">属性</em>，<em class="mg">方法</em> &amp; <em class="mg">函数</em>取决于我们运行的JavaScript版本。因此，通过更改<strong class="lp ir">目标</strong>值来使用目标编译器设置，从而启用哪个<strong class="lp ir">库</strong>文件被加载。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/bf2ed401a754e6c3d9ecf6082f104172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*likw4szFxTd9GdImBl6coQ.png"/></div></div></figure><ul class=""><li id="c63f" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">在上面的设置中，你可以观察到<strong class="lp ir"> es5 </strong>的目标值，这意味着我们不能使用<strong class="lp ir"> es6 </strong>功能。</li><li id="e847" class="ms mt iq lp b lq nb lt nc la nd le ne li nf mf mx my mz na bi translated">在通过改变目标值来装载哪些<strong class="lp ir"> lib </strong>文件时，我们不得不面对处理对TypeScript的内置声明文件的更改的不利方面，这对于频繁变化的DOM APIs来说是一个挑战</li></ul><blockquote class="mh mi mj"><p id="a379" class="ln lo mg lp b lq mk jr ls lt ml ju lv mm mn lx ly mo mp ma mb mq mr md me mf ij bi translated">在<strong class="lp ir"><em class="iq">TypeScript 4.5</em></strong>中，我们有一种新的方法来处理内置的<strong class="lp ir"> lib </strong>。</p></blockquote><ul class=""><li id="0f8b" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">这是通过将我们的项目锁定到特定版本的<strong class="lp ir">DOM API</strong>来实现的。</li><li id="53dc" class="ms mt iq lp b lq nb lt nc la nd le ne li nf mf mx my mz na bi translated">我们要看一下<strong class="lp ir"> node_modules </strong>中一个名为<strong class="lp ir"> @typescript/lib </strong>的包。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/4712bd06ad94cc7893dd5466d2b8e615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYNDtxkTOka534fBzuHa7g.png"/></div></div></figure><ul class=""><li id="7a2a" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">通过将上述代码添加到我们的<strong class="lp ir"> package.json </strong>文件中，我们可以轻松地锁定我们的项目版本的<strong class="lp ir"><em class="mg">DOM API</em>。</strong></li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="ba72" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">3.条件类型的尾递归消除</h2><p id="534b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">TypeScript附带了一个称为启发式的特性，该特性使它能够在编译具有无限递归的程序时失败。这些特性是防止堆栈溢出所必需的。</p><ul class=""><li id="6be4" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">在以前的版本中，类型实例化深度限制是<strong class="lp ir"> 50 </strong>，这意味着在50次迭代之后，程序将是非终止类型。</li><li id="58ac" class="ms mt iq lp b lq nb lt nc la nd le ne li nf mf mx my mz na bi translated">但是，在4.5版本中，实例化限制增加到了<strong class="lp ir"> 100 </strong>。</li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="06b0" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">4.导入名称的类型修饰符</h2><p id="f15d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在TypeScript中— <strong class="lp ir"> preserveValueImports </strong>防止TypeScript编译器在使用<strong class="lp ir">类型</strong>导入时移除有用的导入。TypeScript需要一种方法来告诉编译器移除此类导入。</p><p id="1314" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mn lx ly le mp ma mb li mr md me mf ij bi translated"><strong class="lp ir"> <em class="mg">例如:</em> </strong></p><ul class=""><li id="b0ec" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">在以前版本的TypeScript中，导入相当混乱。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/561cf013dbb7816d8bc328a53f429eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lP9pHQUv0e17y45jjsfv6Q.png"/></div></div></figure><ul class=""><li id="dd8a" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">在这种情况下，<em class="mg">编译器</em>或<em class="mg">构建工具</em>没有办法丢弃<strong class="lp ir"> FC </strong>并使用<strong class="lp ir"> useState </strong>。</li><li id="0170" class="ms mt iq lp b lq nb lt nc la nd le ne li nf mf mx my mz na bi translated">为了消除这种不确定性，<strong class="lp ir"> TS </strong>将类型导入标记为<strong class="lp ir"><em class="mg"/></strong>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/02c2310d844f21f8328c0e005e6224be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5RxvBNRbe6xdcgVMvReRTw.png"/></div></div></figure><ul class=""><li id="1325" class="ms mt iq lp b lq mk lt ml la mu le mv li mw mf mx my mz na bi translated">但是在<strong class="lp ir"> TypeScript 4.5 </strong>中，我们已经得到了如下清晰的方法。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/4942e4478c66f8d433b649895dbfb215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mNDA7aXc004wBZywpIX3Q.png"/></div></div></figure></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="bff4" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">5.模板字符串类型作为判别式</h2><p id="746a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">早期版本的TypeScript很难识别具有模板字符串类型的类型检查值。在<strong class="lp ir"><em class="mg">TypeScript 4.5</em></strong>中，这个问题已经解决，现在TypeScript可以成功地使用<em class="mg">模板字符串类型</em>缩小值。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="580b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">6.导入断言</h2><p id="a03f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">该功能与<strong class="lp ir">正常导入</strong>和<strong class="lp ir">动态导入</strong>一起工作，该功能使用户能够传递附加信息。此外，这个特性在指定模块类型时也很方便。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="77a7" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">7.新代码片段完成</h2><ul class=""><li id="4a67" class="ms mt iq lp b lq lr lt lu la nr le ns li nt mf mx my mz na bi translated"><strong class="lp ir">对于类中的方法:</strong>当处理方法实现时，TypeScript使用方法体的<strong class="lp ir">完整签名</strong>和<strong class="lp ir">大括号</strong>来完成方法名称。完成后，光标将直接跳转到方法体。</li><li id="9d78" class="ms mt iq lp b lq nb lt nc la nd le ne li nf mf mx my mz na bi translated"><strong class="lp ir">对于JSX属性:</strong>新版本的<em class="mg"> TypeScript </em>改进了我们编写JSX属性的方式，增加了初始化器和智能光标。</li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="fd5a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">8.使用realpathSync.native加快加载速度</h2><p id="0407" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">根据documentation TypeScript，4.5现在将在Windows机器上的某些代码库上加速项目加载5–13%。这是由于TypeScript编译器现在在所有操作系统上都使用了<strong class="lp ir"> Node.js </strong>中的<strong class="lp ir"><em class="mg">realpathsync . native</em></strong>函数。</p><blockquote class="nu"><p id="9512" class="nv nw iq bd nx ny nz oa ob oc od mf dk translated">注意:您可以查看TypeScript官方文档，了解TypeScript 4.5中引入的所有新特性，因为我只提到了必要的特性。</p></blockquote></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt oe"><a rel="noopener  ugc nofollow" target="_blank" href="/6-best-react-ui-libraries-in-2022-767989d2ee9e"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">2022年6个最佳用户界面库</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">提升你的反应前端技能</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><div class="ot ou gp gr ov oe"><a rel="noopener  ugc nofollow" target="_blank" href="/6-ui-ux-design-principles-for-self-taught-developers-c6326f6d9c0d"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">6自学成才的开发人员的UI/UX设计原则</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">提升你的自学程序员之旅。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="ow l op oq or on os kp oe"/></div></div></a></div><div class="ot ou gp gr ov oe"><a rel="noopener  ugc nofollow" target="_blank" href="/object-freeze-vs-object-seal-in-javascript-4f66f7d24754"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">JavaScript中的Object.freeze()与Object.seal()</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">理解JavaScript中的不变性</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="ox l op oq or on os kp oe"/></div></div></a></div><p id="9772" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv la mn lx ly le mp ma mb li mr md me mf ij bi translated"><em class="mg">更多内容看</em> <a class="ae oy" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="mg">说白了. io </em> </strong> </a> <strong class="lp ir"> <em class="mg">。</em> </strong> <em class="mg">报名参加我们的</em> <a class="ae oy" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="mg">免费每周简讯点击这里</em> </strong> </a> <strong class="lp ir"> <em class="mg">。</em> </strong></p></div></div>    
</body>
</html>