<html>
<head>
<title>How to Inspect the JavaScript FormData Instance?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检查JavaScript FormData实例？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-inspect-the-javascript-formdata-instance-796cbeb408a4?source=collection_archive---------5-----------------------#2021-09-30">https://javascript.plainenglish.io/how-to-inspect-the-javascript-formdata-instance-796cbeb408a4?source=collection_archive---------5-----------------------#2021-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/92a4afd40caefb0638259041b2e5030e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E5qVjlPCKp82O-tT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@paulius005?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paulius Dragunas</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2d8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有一个HTML表单，那么输入的数据可能存储在从<code class="fe lb lc ld le b">FormData</code>实例创建的对象中。</p><p id="8fd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何检查从<code class="fe lb lc ld le b">FormData</code>构造函数创建的对象。</p><h1 id="5ccd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">带有entries方法的for-of循环</h1><p id="4a93" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用for-of循环遍历<code class="fe lb lc ld le b">FormData</code>实例的键值对来检查它们的值。</p><p id="9fc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得键值对，我们可以使用<code class="fe lb lc ld le b">FormData</code>实例的<code class="fe lb lc ld le b">entries</code>方法来返回数组中的键值对。</p><p id="31cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c2d8" class="mq lg iq le b gy mr ms l mt mu">const formData = new FormData();<br/>formData.append('key1', 'value1');<br/>formData.append('key2', 'value2');</span><span id="a20b" class="mq lg iq le b gy mv ms l mt mu">for (const [key, value] of formData.entries()) {<br/>  console.log(key, value);<br/>}</span></pre><p id="c8b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0af6" class="mq lg iq le b gy mr ms l mt mu">key1 value1<br/>key2 value2</span></pre><p id="bc74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lb lc ld le b">FormData</code>构造函数创建了<code class="fe lb lc ld le b">formData</code>对象。</p><p id="5665" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们分别用键和值调用<code class="fe lb lc ld le b">append</code>，将条目添加到<code class="fe lb lc ld le b">formData</code>对象中。</p><p id="792b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们调用<code class="fe lb lc ld le b">formData.entries</code>返回一个数组，数组中有键值对。</p><p id="7c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在for-of循环中，我们析构键值对并用<code class="fe lb lc ld le b">console.log</code>记录它们。</p><h1 id="ea53" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">省略entries方法</h1><p id="c4ce" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以省略<code class="fe lb lc ld le b">entries</code>方法，因为<code class="fe lb lc ld le b">formData</code>是一个可迭代的对象。</p><p id="972c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有一个迭代器来返回键值对。</p><p id="4686" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以将其简化为:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4049" class="mq lg iq le b gy mr ms l mt mu">const formData = new FormData();<br/>formData.append('key1', 'value1');<br/>formData.append('key2', 'value2');</span><span id="d303" class="mq lg iq le b gy mv ms l mt mu">for (const [key, value] of formData) {<br/>  console.log(key, value);<br/>}</span></pre><h1 id="6733" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">对象. fromEntries</h1><p id="e836" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们还可以使用<code class="fe lb lc ld le b">Object.fromEntries</code>将键-值对放入一个易于检查的对象中。</p><p id="88eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为一个<code class="fe lb lc ld le b">FormData</code>实例有一个迭代器，它返回数组中的键值对数组。</p><p id="82d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2cad" class="mq lg iq le b gy mr ms l mt mu">const formData = new FormData();<br/>formData.append('key1', 'value1');<br/>formData.append('key2', 'value2');<br/>console.log(Object.fromEntries(formData))</span></pre><p id="e8e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="300f" class="mq lg iq le b gy mr ms l mt mu">{key1: "value1", key2: "value2"}</span></pre><p id="5e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从控制台日志中。</p><h1 id="2c59" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用响应构造函数</h1><p id="cb6b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">Response</code>构造函数将<code class="fe lb lc ld le b">FormData</code>实例转换成我们可以轻松检查的文本。</p><p id="abd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="98c3" class="mq lg iq le b gy mr ms l mt mu">const formData = new FormData();<br/>formData.append('key1', 'value1');<br/>formData.append('key2', 'value2');</span><span id="d5f4" class="mq lg iq le b gy mv ms l mt mu">(async () =&gt; {<br/>  const text = await new Response(formData).text()<br/>  console.log(text)<br/>})()</span></pre><p id="b98a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">text</code>方法返回一个承诺，所以我们把它放在一个异步函数中。</p><p id="6c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lb lc ld le b">text</code>大概是这样的:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2a69" class="mq lg iq le b gy mr ms l mt mu">------WebKitFormBoundaryzCHPG30oZJEPIn1B<br/>Content-Disposition: form-data; name="key1"</span><span id="9626" class="mq lg iq le b gy mv ms l mt mu">value1<br/>------WebKitFormBoundaryzCHPG30oZJEPIn1B<br/>Content-Disposition: form-data; name="key2"</span><span id="360f" class="mq lg iq le b gy mv ms l mt mu">value2<br/>------WebKitFormBoundaryzCHPG30oZJEPIn1B--</span></pre><p id="3499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们只关心检查它，那么我们可以使用<code class="fe lb lc ld le b">text</code>方法。</p><h1 id="e13a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="f20a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">有几种方法可以检查一个<code class="fe lb lc ld le b">FormData</code>实例。</p><p id="283f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是一个iterable对象，所以我们可以对它使用for-of循环。</p><p id="4d3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以将它转换成一个<code class="fe lb lc ld le b">Response</code>实例，并使用<code class="fe lb lc ld le b">text</code>方法来检查它。</p><p id="3623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>