# 异步 JavaScript 的传奇:承诺

> 原文：<https://javascript.plainenglish.io/the-saga-of-async-javascript-promises-8ddef2477c24?source=collection_archive---------16----------------------->

![](img/d8cae2497be12604ca0167e32603ee67.png)

# 介绍

我们一直在学习异步 JavaScript 模式，现在应该可以理解为什么[回调](https://medium.com/@romansarder/the-saga-of-async-javascript-callbacks-6f56b3490f4d)经常不能充分解决我们的日常问题，以及它们如何帮助 [Thunks](https://medium.com/@romansarder/the-saga-of-async-javascript-thunks-3606f7de0123) 发展成为一个强大的轻量级工具。虽然它没有解决**信任问题**和**控制权倒置**问题，但我们吸取的教训最终导致了下一个模式的诞生——**承诺**。

# 解释方法

有了概念上的理解和关于思维创新和缺陷的知识，我们现在准备看看承诺能给我们带来什么。我们不打算深入研究 Promise API，并马上用那些花哨的方法和属性淹没自己。最终，特定的方法名称和设计解决方案可能会因实现而异，但基本的核心思想将始终保持不变。我们将首先处理这个概念，看看当前的 JavaScript 是如何用 API 来表达它的。

# 占位符

什么是承诺的真实例子？这件事似乎很容易解释。让我们想象自己来到一家餐馆。我们大多数人都喜欢某种汉堡，不是吗？所以你来点一份。你通常会得到什么回报？带有订单号的收据。最终，当订单准备好时，你会用你的收据换汉堡，但在此之前，你可以放心地思考并开始推理，就好像它已经在你手中一样。收据变成了未来汉堡的占位符。承诺就像那样。对于一些将来会实现的价值，你会得到一个占位符——一个**承诺**——它以后可以被“交换”成一个真实的价值。

# 控制反转:第三回合

似乎思考和承诺都遵循着相似的哲学——它们给你提供了一些你可以利用的东西，直到真正的价值显现出来。但是我们遇到了 Thunks 的控制反转问题，因为它们在幕后使用了回调。我们传递了一个函数，并期待最好的结果。你怎么能“逆转”控制的逆转呢？如果我们能够控制在值准备好之后运行的代码的执行，会怎么样？让我们举一个愚蠢的例子来说明这个问题有多严重:

```
fancyAsyncFunctionFromLibrary(function () {
    chargeCreditCard()
})
```

# 救援的伪代码

我们还不打算使用当前的 Promise API 来帮助自己解决这个问题。想象一下，你根本没有发明承诺。动动你的脑细胞，试着想一个办法，用伪代码解决这段代码中的控制反转问题。我们如何修改上面的例子来控制回调的执行？谢天谢地，编程中有很多模式可以启发你。那么**事件发射器**呢？

```
const futureValuePlaceholder = fancyAsyncFunctionFromLibrary()
​
futureValuePlaceholder.on('complete', chargeCreditCard);
```

我们给自己做了一个`fancyAsyncFunctionFromLibrary`，它现在返回一个事件发射器。给定你能得到的事件的知识，我们能以我们想要的任何方式附加我们的回调。在本例中，一旦该函数中的某些内容完成，我们就运行回调函数，这样我们就可以向信用卡收费。我们可以用同样的方式订阅错误事件。或者我们可以决定不这样做。我们甚至可以想象，一旦一个完整的事件发生，我们自己就会脱离我们的听众。使用这个模型，我们可以做很多事情。我们写的伪代码基本上是这样说的:“给我一个触发不同事件的对象，我将决定订阅什么事件，以及如何运行我的函数来响应它们”。有趣的是，它看起来和我们日常使用的承诺没什么不同。我们用`then`代替了`on`方法，它实际上知道应该给你的回调订阅什么事件。尽管回调仍然是我们代码的重要组成部分，但我们能够重新获得对执行的控制，并使用一个漂亮干净的 API 按照我们的方式运行我们的函数。总而言之，你可以认为承诺的另一种方式是**它们很像事件发射器**。但是要解决控制反转灾难，我们需要的不仅仅是 API。有一个缺失的部分。

# 信任实施

我们可能仍然不确定我们的回调将如何运行。有一个关于回调的相当多的担忧的列表，正威胁着我们新生的事件发射器。我们迫切需要信任来消除这些。如果这些承诺不包含信任实施机制，它们就没有多大用处。幸运的是，当您在当前的 JavaScript 中使用 Promises 时，JavaScript 本身会确保:

*   承诺是不可改变的
*   错误不会被吞噬
*   这个承诺要么成功，要么失败
*   它只解决一次
*   远处没有行动

很整洁，是吧？有了定义明确和严格的行为，我们不再质疑自己回调的运行方式。**不可变的**部分也很重要。JavaScript 确保当你将你的承诺传递给第三方代码时，它不会以任何方式发生变异或改变。你不能同时影响承诺的状态和其中的价值。在距离处没有**动作。此外，我们的代码现在不会被多次调用，无论如何我们总是会得到一个错误。即使你没有在承诺中明确处理这个错误，它也会以`Unhandled Promise rejection`的形式出现，你也不会错过编译器对你的咆哮。**

# 给我们看看承诺，先生

让我们看看我们之前写的伪代码，这次使用承诺:

```
fancyAsyncFunctionFromLibraryWithPromise () {
    return new Promise((resolve, reject) => {
        fancyAsyncFunctionFromLibrary(resolve)
    })
}
​
fancyAsyncFunctionFromLibraryWithPromise()
    .then(chargeCreditCard)
    .catch(handleError)
```

我们的`fancyAsyncFunctionFromLibrary`现在返回一个我们自己创造的承诺。你将得到一个**一级**对象，你可以像传递其他值一样传递它。当构造一个承诺时，您传递给它一个回调，该回调需要两个参数:一个`resolve`和`reject`函数。这些是你的工具，让你把承诺的状态转换成完全履行或拒绝的状态。我们调用一个`then`方法来附加一个回调函数，这个回调函数将在 Promise 完成后被执行，换句话说，resolve 函数在我们的 Promise 中被调用。如果有承诺值的话，回调会收到一个承诺值。另一方面，有一个用于错误处理的 catch 方法，其工作方式类似。我们只需要处理两种可能的情况，我们需要两种相应的方法。代码本身读起来很像人类的语言:“做一些需要时间的事情，然后把它传递给这个函数，但是如果出了问题，捕捉错误并把它传递给这个函数”。

# 流控制

让我们试着用 promises 编写一些操作序列，看看它们在一个更常见的例子中是什么样子的:

```
readFileOnePromise
    .then(fileContents => {
        console.log('first file', fileContents)
​
        return readFileTwoPromise
    })
    .then(fileContents => {
        console.log('second file', fileContents)
​
        return readFileThreePromise
    })
    .then(fileContents => {
        console.log('third file', fileContents)
    })
```

这一次，操作之间的时间依赖性不会导致更多的嵌套，它们在整个程序中都保持在同一层次上。一个显著的特点是**链接**，这使得处理承诺变得更加容易。

# 链接

链接是一种语法，它允许您在没有中间变量的情况下进行多个对象方法调用。这是通过每个返回对象的方法来实现的。在`then`方法的回调中，你可以返回一个承诺或者一个值。如果您返回了一个承诺，下一个`then`将不会触发它的回调，直到这个承诺被解决。您可以用同样的方式处理这两者，这将产生一个与时间无关的值包装器，非常像 Thunks。但是通常只有 API 让人们使用承诺，并认为他们是异步编程世界中的银弹。请记住，承诺的重要部分不是它们的 API，而是它们的想法和概念，在过去的某个时候，它们革新了你在程序中使用异步代码的方式。这是关于他们最终解决控制反转问题的能力，同时保持作为数据容器的优势，您可以传递数据，并作为未来值的占位符。

# 复试..又来了？

是的，我们还有复试。实际上，如果你仔细观察承诺，你会发现它们可能看起来像**回拨经理**！这是我能想到的第三种也是最后一种承诺方式。他们使用回调来完成同样众所周知的任务——一旦某件事情完成就运行代码，此外，他们还带来了我们需要的信任。承诺中重要的一点是他们**进一步缩小了异步和同步代码之间的差距**。关于同步函数有两件非常重要的事情:

*   他们回报价值
*   他们抛出错误

# 承诺作文

更重要的是，如果我们谈论的是**函数组合**，如果组合中的任何函数抛出错误，该错误将绕过所有其他组合层，并一直向上传播，以便客户端代码能够捕捉到它。在回调的情况下，返回值是不可能的，因为它们在调用时还没有准备好。类似地，您不能抛出错误，因为没有人来捕捉它们，而对于回调，您将需要手动传播这些错误。承诺通过说明每个函数都应该返回一个承诺并保证会出现错误，在将这些东西带回异步世界方面发挥了重要作用。如果写得正确，那些 then/catch 块**以与它们的同步对应物**相似的方式组成，通过实现创建一个组合链，拒绝能够在任何阶段中断它，只有声明他准备好处理它的人才能处理它。

# 一点函数式编程

方法不应被视为“回调附加机制”，而应被视为“转换应用程序”。它基本上允许我们对一个承诺中的价值进行转换，并创建一个新的承诺，这个新的承诺将被传递下去。从这个角度来看，承诺非常类似于**单子**，它们有能力链接和应用潜在价值的功能。尽管当前用于 promises 的 JavaScript API 本身并不像函数式程序员所期望的那样 100%纯粹，但是承诺的单子性质是非常明显的。

# 更多花哨的 API

承诺伴随着大量额外的方法来提高你的流量控制。`Promise.all`将接受一个承诺数组，并返回一个新的承诺，一旦所有的承诺都解决了，这个新的承诺也就解决了。`Promise.any`在某种程度上是类似的，它期望一系列的承诺，但是将返回一个承诺，一旦至少一个承诺被解决，该承诺将被解决。如果没有已解决的承诺，结果承诺将被拒绝。我不会详细介绍 JavaScript 中 Promise 对象的每一个方法，但是您可能已经明白了。承诺还为您提供了一些有用的抽象概念，帮助您在更复杂的场景中编排不止一个承诺，而是一组承诺。一旦你开始发现文档，你会发现你自己正在创造这些抽象。目前并不是所有的都实现了，但是没有人阻止你使用第三方 promise 库。你甚至可以自己创造一个！

# 下降趋势

我注意到有一些关于承诺的文章，在谈到负面影响时，集中在 **API 误用**上。他们中也有许多人根本不谈论任何与承诺有关的问题。还有一些事情是承诺没有解决或提供的。我对承诺的大多数问题的态度可以描述为“啊，但是这个和那个也很方便，尽管它在这种模式中没有意义”。击败了我们的主要敌人——控制反转，我们现在只需要寻找更多的特性来完善我们的工具集。你会看到下面描述的事情都在呼吁创造另一种模式来和承诺一起使用。因此，将这些要点视为“最好拥有”，而不是“需要解决”。

# 仍然在主流之外

这可能是一个有争议的观点。虽然承诺减少了您正在处理的嵌套回调的数量，但它们并没有完全删除它们。使用标准承诺，我们的同步代码没有办法“等待”承诺。考虑这个例子:

```
const func = (value) => {
    let promise = somePromiseBasedFunction();
​
    let promiseValue = ?;
    promise.then(function(result){
        // I can access the value here, but there's
        // no way for me to get it up in the main
        // scope and have `func` return its value
    });
​
    const finalValue = someOtherFunction(promiseValue);
    return finalValue;
}
```

虽然承诺的目的是不阻止你的程序，但我们经常真的需要这种可用的机制。这将进一步缩小同步和异步代码之间的差距。从技术上来说，这个问题在后来的 JavaScript 版本中通过 **async/await** 得到了解决，但是这些都是基于生成器的，将在另一篇文章中讨论。

# 不可取消

这也与承诺背后的意识形态相矛盾。毫无疑问，用 AJAX 请求取消承诺的能力非常棒，但这也意味着承诺不再是不可改变的，我们现在突然容易受到“远距离操作”问题的影响。

# 缺失的抽象

只是一个“很好拥有”的东西，它经常让你从头开始创建那些方法，或者使用第三方库作为替代。在某些情况下，当前实现的可用承诺抽象列表可能会有一点限制。例如，想象你自己一连打了 10 个`then`电话，并试图记住每次你都需要回复一个承诺来使一个组合工作。当处理一个长的链时，它很容易变得令人讨厌并且容易出错。接受可变数量的函数并为您完成任务的`sequence`方法怎么样？它会自动链接这些函数调用，并确保每个调用都会返回下一个调用所需的任何内容。正如我所说的，人们至少可以想出一些有用的方法，这些方法在当前的 API 中是不存在的，如果能在语言本身中实现它们就太好了。

# 结尾部分

这是一次伟大的旅程。我们最终摆脱了控制反转的问题，通过积累我们在模式上的知识和经验，我们成功地深入到承诺中，并正确地理解了它们为什么会成为一件事情。在这一点上，创造承诺对你来说应该是一件非常明显的事情，因为这种模式主要是对以前错误的纠正。他们目前是我们武器库中一个重要而强大的工具，而且在一段时间内他们会保持这种状态。但是理想的异步程序员的生活画面是不完整的，并且缺少需要实现的特性和概念。与回调类似，承诺本身将作为下一个模式的基础，这将增强它们的能力，为我们提供更好的体验。随着我们的深入，话题会变得越来越有挑战性，所以我很高兴告诉你其他的模式。在下一篇文章中，我们将讨论 [**异步生成器**](https://medium.com/@romansarder/the-saga-of-async-javascript-generators-40b517029b68) ，看看异步/等待特性是如何工作的。

*更多内容看*[***plain English . io***](http://plainenglish.io/)