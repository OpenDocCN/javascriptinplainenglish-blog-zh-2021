<html>
<head>
<title>JavaScript — Getting Started with Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript——从承诺开始</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-getting-started-with-promises-a666a739e76a?source=collection_archive---------16-----------------------#2021-08-13">https://javascript.plainenglish.io/javascript-getting-started-with-promises-a666a739e76a?source=collection_archive---------16-----------------------#2021-08-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fb83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很多时候，当程序或网页中的操作被请求时，请求的结果不能立即用于进一步的处理。在这种情况下，操作被认为是异步的。为了更顺利地处理这种特定情况，JavaScript有一个名为<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promise </a>的对象，它代表异步操作的最终完成或失败，并为程序员提供处理异步操作和数据的方法。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/4bb1b8eab1231332454750a4d985297f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUk7tFDnT-NW534Hpbpl6g.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">JavaScript Promises</figcaption></figure><h2 id="66f1" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">问题是</h2><p id="1460" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在开始承诺和使用承诺之前，最好先了解它们帮助解决的问题。通常在JavaScript中，一个函数在返回自己的结果之前依赖于另一个函数的结果。例如，考虑一组复杂的数学运算，这些运算一个接一个地执行，并依赖于前一个运算的结果才能执行下一个运算。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="8002" class="kz la in ly b gy mc md l me mf">const add = (n1, n2) =&gt; {<br/>  return n1 + n2;<br/>};</span><span id="0352" class="kz la in ly b gy mg md l me mf">const square = (n) =&gt; {<br/>  return n * n;<br/>};</span><span id="fd2d" class="kz la in ly b gy mg md l me mf">let v1 = add(5, 8);<br/>let v2 = square(v1);<br/>console.log(v2); // 169</span></pre><p id="a0cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码按照从上到下的顺序执行。每个函数都能够在下一个使用结果的函数执行之前返回一个结果。然而，在某些情况下，函数在返回结果之前需要一些时间才能完成，JavaScript在执行代码时不会等待。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="8abb" class="kz la in ly b gy mc md l me mf">const add = (n1, n2) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    return n1 + n2;<br/>  }, 2000);<br/>};</span><span id="ffeb" class="kz la in ly b gy mg md l me mf">const square = (n) =&gt; {<br/>  return n * n;<br/>};</span><span id="da8c" class="kz la in ly b gy mg md l me mf">let result = add(5, 8);<br/>console.log(square(result)); // NaN</span></pre><p id="85e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面代码的区别在于<code class="fe mh mi mj ly b">add</code>函数在完成操作并返回结果之前有2秒的延迟。到那时，代码的剩余部分已经运行了。在第二个函数执行时，变量<code class="fe mh mi mj ly b">v1</code>的值为<code class="fe mh mi mj ly b">undefined</code>，当传递给<code class="fe mh mi mj ly b">square</code>函数时，返回<code class="fe mh mi mj ly b">NaN</code>，该值在第一个函数返回其计算值之前输出。</p><h2 id="c358" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">召回救援</h2><p id="ef8f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在ES6将承诺添加到JavaScript之前，处理异步操作的最佳方式是使用回调。回调基本上是一个函数，它作为参数传递给另一个函数，然后在第一个函数的主体中被调用。这样做的一个常见原因是为了处理异步数据检索——程序的进展依赖于数据，这些数据可能需要一段时间才能返回并供程序的下一部分使用。一个典型的例子是异步等待程序的另一部分需要的来自API的数据继续。</p><p id="c88d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，上面的例子目前无法处理在<code class="fe mh mi mj ly b">add</code>函数完成之前调用<code class="fe mh mi mj ly b">square</code>函数的情况。为了解决这个问题，可以从<code class="fe mh mi mj ly b">add</code>函数回调调用<code class="fe mh mi mj ly b">square</code>函数，如下所示:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="0067" class="kz la in ly b gy mc md l me mf">const add = (n1, n2, callback) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    let calculation = n1 + n2;<br/>    callback(calculation);<br/>  }, 2000);<br/>};</span><span id="28a8" class="kz la in ly b gy mg md l me mf">const square = (n) =&gt; {<br/>  return n * n;<br/>};</span><span id="574b" class="kz la in ly b gy mg md l me mf">add(5, 8, (result) =&gt; {<br/>  console.log(square(result));<br/>});</span></pre><p id="2aa5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的例子异步执行<code class="fe mh mi mj ly b">add</code>函数，然后将<code class="fe mh mi mj ly b">add</code>函数的结果传递给<code class="fe mh mi mj ly b">square</code>函数。然后，<code class="fe mh mi mj ly b">square</code>函数使用<code class="fe mh mi mj ly b">add</code>函数的结果来计算结果的平方。在这种情况下，即使有2秒的延迟，<code class="fe mh mi mj ly b">square</code>函数也能够使用<code class="fe mh mi mj ly b">add</code>函数的结果，因为回调依赖于<code class="fe mh mi mj ly b">add</code>函数的结果。</p><p id="de74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面这个简单的例子并不难理解。然而，一个操作在完成之前可能需要几个步骤，这将需要多个回调。例如，考虑以下代码:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="5900" class="kz la in ly b gy mc md l me mf">const add = (n1, n2, callback) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    let result = n1 + n2;<br/>    callback(result);<br/>  }, 2000);<br/>};</span><span id="8866" class="kz la in ly b gy mg md l me mf">const multiply = (n1, n2, callback) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    let result = n1 * n2;<br/>    callback(result);<br/>  }, 2000);<br/>};</span><span id="4544" class="kz la in ly b gy mg md l me mf">const subtract = (n1, n2, callback) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    let result = n1 - n2;<br/>    callback(result);<br/>  }, 2000);<br/>});</span><span id="25cc" class="kz la in ly b gy mg md l me mf">const square = (n) =&gt; {<br/>  return n * n;<br/>};</span><span id="9e01" class="kz la in ly b gy mg md l me mf">add(5, 8, (result) =&gt; {<br/>  multiply(result, 5, (result) =&gt; {<br/>    subtract(result, 8, (result) =&gt; {<br/>      console.log(square(result));<br/>    });<br/>  });<br/>});</span></pre><p id="66d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管这个例子看起来并不复杂，但它确实显示了回调模式是如何变得嵌套很深的，并且对于比上面显示的更复杂的任务，理解发生了什么会变得非常困难。谢天谢地，JavaScript的开发者认识到了这个问题，并提出了解决方案。</p><h2 id="e011" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">用承诺改善回访</h2><p id="e013" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如上所述，回调的问题是它们会变得复杂，难以维护和/或理解。相互嵌套的多个回调会很快变得难以控制，有时被称为<a class="ae ki" href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" rel="noopener ugc nofollow" target="_blank">末日金字塔</a>。此外，当异步请求没有成功完成时，回调不提供任何内置的错误处理。这个功能必须由开发人员添加。</p><p id="18d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promise </a>对象的引入有助于解决这些问题，并提供了一种更优雅的处理异步操作的方式。承诺表示异步操作的最终完成或失败，并为程序员提供了处理异步操作和数据的方法。</p><p id="e62b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">承诺背后的核心思想是，当异步操作正在进行时，它将返回一个可用于跟踪操作进度的中间值。一旦操作完成，承诺要么解析为最终值，要么不解析。该值可用于确定操作的成功或失败。</p><p id="9875" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">承诺的核心概念是承诺可以经历的不同状态:</p><ul class=""><li id="1e9b" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">待定——承诺处于初始状态，既未解决(履行)也未拒绝</li><li id="147a" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">已履行(已解决)-承诺操作已成功完成</li><li id="fb90" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">拒绝-承诺操作失败</li></ul><p id="488e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入resolved或rejected选项将触发相关的处理程序，这些处理程序通过调用Promise <code class="fe mh mi mj ly b">then</code>方法来处理。</p><h2 id="04c7" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">履行承诺</h2><p id="fb19" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">利用承诺可以通过使用预先存在的承诺来完成，通常以可以作为承诺使用的外部库或API的形式，或者通过用构造函数创建一个<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" rel="noopener ugc nofollow" target="_blank">新承诺</a>来完成。通过从零开始创造一个承诺，有可能理解一个承诺在内部做什么。</p><p id="d374" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下示例显示了如何创建新承诺的基础知识。promise期望一个包含定制代码的<code class="fe mh mi mj ly b">executor</code>函数来指示promise如何解决或拒绝promise。executor函数包括resolve函数和reject函数的签名，这些签名可用于传递由相应的resolve和reject函数处理的值。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="8440" class="kz la in ly b gy mc md l me mf">const myPromise = new Promise((resolve, reject) =&gt; {<br/>  resolve('promise is resolved');<br/>});</span><span id="7660" class="kz la in ly b gy mg md l me mf">myPromise.then((result) =&gt; {<br/>  console.log(result);<br/>});</span></pre><p id="2e8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个更复杂的示例展示了如何添加控制流，以根据executor函数中逻辑运算的结果来确定是否使用resolve或reject函数。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="fd50" class="kz la in ly b gy mc md l me mf">const additionPromise = (number1, number2) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      if (typeof number1 === 'number' &amp;&amp; typeof number2 === 'number') {<br/>        let result = number1 + number2;<br/>        resolve(result);<br/>      } else {<br/>        reject('Please use numbers');<br/>      }<br/>    }, 2000);<br/>  });<br/>};</span><span id="bbe3" class="kz la in ly b gy mg md l me mf">additionPromise(5, 7)<br/>  .then((result) =&gt; {<br/>    console.log(result);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.error(error);<br/>  })<br/>  .finally(() =&gt; {<br/>    console.log('promise completed');<br/>  });</span><span id="cced" class="kz la in ly b gy mg md l me mf">// 12<br/>// promise completed</span><span id="51c4" class="kz la in ly b gy mg md l me mf">additionPromise(5, 'hello')<br/>  .then((result) =&gt; {<br/>    console.log(result);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.error(error);<br/>  })<br/>  .finally(() =&gt; {<br/>    console.log('promise completed');<br/>  });</span><span id="d539" class="kz la in ly b gy mg md l me mf">// Please use numbers<br/>// promise completed</span></pre><p id="9533" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的承诺展示了几个不同的概念。首先，函数<code class="fe mh mi mj ly b">additionPromise</code>是一个常规函数，它接受两个参数并返回一个承诺。promise由一个包含resolve和reject函数处理程序的executor函数组成。执行器还包含一个<code class="fe mh mi mj ly b">setTimeout</code>函数来演示承诺的异步本质。如果传递的参数为逻辑运算返回true，数字被相加，结果变量被传递给resolve函数，该函数可由<code class="fe mh mi mj ly b">then</code>方法调用。</p><p id="d0cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果逻辑运算返回false，则调用reject函数，传入一个字符串值。处理这种情况的方法是调用promise上的<code class="fe mh mi mj ly b">catch</code>方法。如果调用reject函数，promise将绕过所有resolve(包括chained) <code class="fe mh mi mj ly b">then</code>方法，使用<code class="fe mh mi mj ly b">catch</code>方法。最后，可以调用一个可选的<code class="fe mh mi mj ly b">finally</code>方法。无论承诺是被解决还是被拒绝，都将调用此方法。</p><h2 id="4a31" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">连锁承诺</h2><p id="3c3c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如上所述，承诺可以链接在一起，这允许在返回最终结果之前处理多个承诺，包括多个流程。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="3aa3" class="kz la in ly b gy mc md l me mf">const additionPromise = (number1, number2) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      if (typeof number1 === 'number' &amp;&amp; typeof number2 === 'number') {<br/>        let result = number1 + number2;<br/>        resolve(result);<br/>      } else {<br/>        reject('Please use numbers');<br/>      }<br/>    }, 2000);<br/>  });<br/>};</span><span id="f880" class="kz la in ly b gy mg md l me mf">const squarePromise = (number) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      if (typeof number === 'number') {<br/>        let result = number * number;<br/>        resolve(result);<br/>      } else {<br/>        reject('Please use a valid number');<br/>      }<br/>    }, 2000);<br/>  });<br/>};</span><span id="4ed3" class="kz la in ly b gy mg md l me mf">additionPromise(2, 4)<br/>  .then((result) =&gt; {<br/>    return squarePromise(result);<br/>  })<br/>  .then((result) =&gt; {<br/>    console.log(`final result: ${result}`);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.log(error);<br/>  })<br/>  .finally(() =&gt; {<br/>    console.log('promise operation completed');<br/>  });</span><span id="f958" class="kz la in ly b gy mg md l me mf">// final result: 36<br/>// promise operation completed</span></pre><p id="ff25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的例子展示了如何使用多个承诺，并且每个承诺都解析返回一个结果，该结果可以被承诺用来单步执行异步操作。</p><h2 id="b79a" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">结论</h2><p id="e84c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果承诺只能通过消费的方式实现，那就很难理解了。通过创造一个承诺并理解它们是如何组成的，就更容易理解使用它们的最佳步骤。</p><p id="b453" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="my">更多内容尽在</em><a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="my">plain English . io</em></strong></a></p></div></div>    
</body>
</html>