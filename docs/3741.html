<html>
<head>
<title>How TypeScript Solves JavaScript’s Problem With Immutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript如何解决JavaScript的不变性问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-immutability-b52bece7b9ea?source=collection_archive---------6-----------------------#2021-07-27">https://javascript.plainenglish.io/typescript-immutability-b52bece7b9ea?source=collection_archive---------6-----------------------#2021-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1428" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">TypeScript中的不可变对象、数组、元组和集</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/02a4f06a617cf3fd26d09aa47f6f45de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-7wVpk1g_20wvYbTCbN6Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="9e7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不久前我写了关于JavaScript 中的<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/immutable-js-efe6b42e122f"> Immutable.js。</a></p><p id="650f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么？因为JavaScript在不变性上有点小问题。<br/>简单回顾一下，以防你不确定<em class="ls">不变性</em>是什么意思:</p><blockquote class="lt lu lv"><p id="0d9f" class="kv kw ls kx b ky kz jr la lb lc ju ld lw lf lg lh lx lj lk ll ly ln lo lp lq ij bi translated">[…]一个<strong class="kx ir">不可变对象</strong>是一个对象，它的状态在被创建后不能被修改。<br/> — Goetz等人<em class="iq">实践中的Java并发</em>。艾迪森·韦斯利专业版，2006年</p></blockquote><p id="5e6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们想到不可变数据结构时，我们通常会想到JavaScript中的<em class="ls"> const </em>关键字。但是剧透:不，<code class="fe lz ma mb mc b">const</code>通常不会使我们的变量不可变。</p><p id="5973" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">常量变量的不变性仅适用于原始数据类型。这里有一个例子。例如，布尔值和数字都是JavaScript中的原始数据类型。</p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="7f03" class="mh mi iq mc b gy mj mk l ml mm">const value = 1 <br/>value = 2</span><span id="49e4" class="mh mi iq mc b gy mn mk l ml mm">// error - we cannot modify the variable </span></pre><p id="6996" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们使用一个布尔值，例如，<code class="fe lz ma mb mc b">true</code>或其他50%时，也会出现同样的错误。玩笑归玩笑，我们刚刚看到的，是一个不可变的变量。<br/>然而，当涉及到对象时，比如数组或普通对象，在JavaScript中通过const-keyword没有不变性。</p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="d562" class="mh mi iq mc b gy mj mk l ml mm">const obj = {<br/>  name: "Max"<br/>}</span><span id="57ea" class="mh mi iq mc b gy mn mk l ml mm">obj.name = "Tom"</span></pre><p id="b33f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这实际上会改变对象的name属性—它是可变的，而不是不可变的。在我关于这个问题的文章中，我提供了一个不可变的. js库作为解决方案。然而，TypeScript也有一个——不会增加我们的生产代码。</p><p id="9802" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看如何在TypeScript中实现不变性。</p><h1 id="7e3e" class="mo mi iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">TypeScript中不可变的普通对象</h1><p id="4bd7" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">TypeScript覆盖了一个叫做接口的特性——你可以把它想象成一个对象的蓝图。属性及其定义方式必须适用于实现的对象。在TS中定义属性的方法之一是将其设为只读:</p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="2c5e" class="mh mi iq mc b gy mj mk l ml mm">interface Person {<br/> readonly name: string <br/>}</span><span id="c09e" class="mh mi iq mc b gy mn mk l ml mm">const max: Person = {<br/> name: "Max"<br/>}</span></pre><p id="0dd6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们不能改变值<code class="fe lz ma mb mc b">max.name</code>，因为我们把它定义为只读。</p><p id="0844" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了接口，我们还可以使用类。只读设置也适用于此。</p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="3769" class="mh mi iq mc b gy mj mk l ml mm">class Person { </span><span id="0001" class="mh mi iq mc b gy mn mk l ml mm"> constructor(name: string) {<br/>   this.name = name <br/> }</span><span id="5c5d" class="mh mi iq mc b gy mn mk l ml mm"> readonly name: string <br/>}</span><span id="f750" class="mh mi iq mc b gy mn mk l ml mm">const max = new Person("Max")</span></pre><h1 id="d667" class="mo mi iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">使数组不可变</h1><p id="44ed" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">因为数组也是对象，所以它们在JavaScript中也是可变的。为了避免这种情况，我们可以对阵列应用只读设置:</p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="b105" class="mh mi iq mc b gy mj mk l ml mm">const names: ReadonlyArray&lt;string&gt; = ["max", "carl"]</span><span id="f44d" class="mh mi iq mc b gy mn mk l ml mm">names[0] = "tom" // error! </span></pre><h1 id="ec4b" class="mo mi iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">使元组不可变</h1><p id="d8ad" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">元组的工作方式类似于数组——但相比之下，它们精确地定义了元素的数量和类型。</p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="3827" class="mh mi iq mc b gy mj mk l ml mm">const fullName: readonly [string, string] = ["John", "Doe"];</span></pre><h1 id="6914" class="mo mi iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">使集合不可变</h1><p id="ced6" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">最后，让我们讨论一下TypeScript中的集合，以及如何使它们不可变。该集合的特点是每个值只出现一次——尽管您可以声明一个具有几个相同值的集合，例如，如果您记录该集合，则只有<code class="fe lz ma mb mc b">1, 2, 3, 3</code>会在终端中打印出来。</p><p id="0c35" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不可变集合可以用下面一行创建:</p><pre class="kg kh ki kj gt md mc me mf aw mg bi"><span id="6cd9" class="mh mi iq mc b gy mj mk l ml mm">let numberSet: ReadonlySet&lt;number&gt; = new Set([1, 2, 3])</span></pre><p id="81e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这会导致add函数不再对它起作用。</p><p id="7777" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读！</p><p id="b96f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls">更多内容看</em><a class="ae lr" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ls">plain English . io</em></strong></a></p></div></div>    
</body>
</html>