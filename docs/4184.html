<html>
<head>
<title>The Algo Alcove: Binary Tree Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法壁龛:二叉树遍历</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-algo-alcove-binary-tree-traversal-af0e8f7ce55e?source=collection_archive---------17-----------------------#2021-08-19">https://javascript.plainenglish.io/the-algo-alcove-binary-tree-traversal-af0e8f7ce55e?source=collection_archive---------17-----------------------#2021-08-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fcaaf103fc6043381da347d9fb635aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iCddKLv8dJRqTf25"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@veeterzy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">veeterzy</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8075" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎回到Algo Alcove的另一个版本，在这里我们将关注一个对许多LeetCode问题都很重要的共同概念:二叉树遍历(也许我应该把这个叫做“数据结构书房”？？).</p><p id="465e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二叉树就是<strong class="kc io">树</strong>结构，它的建立是为了确保每个<strong class="kc io">节点</strong>最多只有两个子节点，一个<strong class="kc io">在左边，</strong>和一个<strong class="kc io">在右边。</strong></p><p id="0b58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你需要复习什么是树，可以看看我的博客<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/from-zero-to-dijkstra-the-shortest-path-to-the-shortest-path-algorithm-f070e224f99e">中的</a>，我在那里谈到了二进制堆(另一种类型的<strong class="kc io">树</strong>结构)。</p><p id="e48e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">遍历</strong>一棵树就是在给定<strong class="kc io">根</strong>节点的情况下，访问树的每个节点的术语。如何处理收集的数据取决于您自己，但是遍历每个节点本身就是一项技术，因此了解一些方法会有所帮助。</p><h1 id="9020" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">广度优先搜索(BFS)</h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/a9e7428180b41bc576f682cdae4b5d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWKXkbECHVeX16PE7kEJdw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Binary Search Tree</figcaption></figure><p id="10e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里是一个标准的<strong class="kc io">二叉查找树。</strong>我们可以看到，每个节点最多有两个子节点(一左一右)，有些节点有1个或者没有。在这个图中我们还可以看到，它们是按照<strong class="kc io">级</strong>或者从节点到<strong class="kc io">根</strong>(顶层节点)的距离来组织的。</p><p id="5a8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们看到[2，3]在同一层上，[4，5，6]和[7，8，9]也分组在一起。在广度优先搜索中，我们寻找<strong class="kc io">广度、</strong>并一层一层地遍历，直到用尽所有选项。为此，我们可以实现一个<strong class="kc io">队列</strong>结构。</p><p id="6234" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">队列很容易理解。它遵循先进先出(<strong class="kc io"> FIFO </strong>)的顺序。就像在熟食店排队一样，如果你是第一个拿到号码的人，你的号码将是第一个被叫到的。</p><p id="3f14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的队列将跟踪哪些节点我们还没有<strong class="kc io">访问</strong>(“访问”在这个上下文中意味着将我们的值推送到一个数组中，该数组最终将保存所有9个节点的值)当您访问一个节点时，您可以执行任意数量的操作，但是因为我们只是展示如何遍历每个节点，所以我们将在一个数组中保存所有的值。</p><p id="5e58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是搜索操作的伪代码:</p><ul class=""><li id="9902" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">创建一个队列。<strong class="kc io">入队</strong>根。</li><li id="ebff" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">创建一个循环，当队列不为空时运行<strong class="kc io">。</strong></li><li id="e9ac" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc io">出列。</strong>访问‘那个节点’。(推入数组)。</li><li id="abbf" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">将该节点的左子节点排入队列(如果存在)。</li><li id="6550" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">将该节点的右子节点排入队列(如果存在)。</li></ul><p id="0f03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！现在我们来看看它是如何写出来的。</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="a2aa" class="mu kz in mq b gy mv mw l mx my">function BFS(root) {<br/>    let queue = [root];<br/>    let result = [];<br/>   <br/>    while (queue.length) {<br/>        let node = queue.shift();<br/>        result.push(node.val);</span><span id="4f73" class="mu kz in mq b gy mz mw l mx my">        if (node.left) queue.push(node.left);<br/>        if (node.right) queue.push(node.right);<br/>    }<br/>    return result;</span></pre><p id="457d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们在示例树上运行这个，结果数组将看起来像<code class="fe na nb nc mq b">[1,2,3,4,5,6,7,8,9]</code></p><p id="6e46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很简单，对吧？现在，我们先来看看<strong class="kc io">深度搜索</strong>。DFS有三种主要类型:<strong class="kc io">前序、后序和按序。</strong></p><h1 id="0b43" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">深度优先搜索</h1><h1 id="de7c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">预购</h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/1db05c684e4083ef57600cc0b62f7cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HCxrMEUIasPGdf5oM67gw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Another Tree!</figcaption></figure><p id="333d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">前序、中序、后序都很像，不用怕。它们是深度优先搜索的例子，我们可以使用<strong class="kc io">递归</strong>来使我们的生活更加简单。</p><p id="80b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">深度优先搜索遍历整个树，在返回之前一直向下到一个叶节点(考虑垂直而不是水平)。我们也可以使用递归来帮助我们，因为它利用了树的一个有趣的属性:从技术上讲，每个节点都是另一个子树的“根”。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/cd2c4fdbe097f102e1f1c14dafda61b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1tORops7YtwkrukkvFDvQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Subtrees</figcaption></figure><p id="69fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以看到高亮部分实际上是他们自己的二分搜索法树。这意味着它们可以成为递归函数中的参数。</p><p id="3cec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能记得递归函数有一个<strong class="kc io">基础用例</strong>和一个<strong class="kc io">递归调用</strong>。<strong class="kc io"> </strong>我们正在进行<strong class="kc io">预先排序</strong>深度优先搜索，这意味着我们将在调用子树上的递归函数之前“访问”我们的节点。我们来看伪代码。</p><ul class=""><li id="4928" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">设置一个<strong class="kc io">结果</strong>数组。</li><li id="f309" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">创建一个助手函数(递归):</li><li id="7f40" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">1.基本情况:如果节点为空，则返回。</li><li id="1cc3" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">2.访问当前节点。</li><li id="412b" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">3.递归调用左边<strong class="kc io">子树上的函数。</strong></li><li id="246b" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">4.递归调用右边子树上的函数。</li></ul><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="6e5c" class="mu kz in mq b gy mv mw l mx my">function DFSPreOrder(root) {<br/>    let results = [];<br/>    <br/>    function traverse(node) {<br/>        if (node === null) return;<br/>        <br/>        results.push(node.val);</span><span id="4534" class="mu kz in mq b gy mz mw l mx my">        traverse(node.left);<br/>        traverse(node.right);<br/>    }<br/>    traverse(root);<br/>    return results;<br/>}</span></pre><p id="18f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样。如果我们回头看我们的图片，我们会看到我们的结果数组将按照数字的顺序输出<code class="fe na nb nc mq b">[1,2,3,4,5,6,7,8,9]</code></p><h1 id="730a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">按顺序</h1><p id="b596" class="pw-post-body-paragraph ka kb in kc b kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ig bi translated">In order与Pre-order相同，除了您想要递归地调用左边的树和右边的树来“访问”您的中间节点<strong class="kc io">。这样，在移动到子树的“根”之前，您总是先访问最左边的节点，最后访问右边的节点。</strong></p><p id="7af2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是代码，请注意，除了两行交换之外，它们完全相同。</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="77ea" class="mu kz in mq b gy mv mw l mx my">function DFSInOrder(root) {<br/>    let results = [];<br/>    <br/>    function traverse(node) {<br/>        if (node === null) return;</span><span id="aca2" class="mu kz in mq b gy mz mw l mx my">        traverse(node.left);    //This line<br/>        results.push(node.val); // Swapped with this line<br/>        traverse(node.right);<br/>    }<br/>    traverse(root);<br/>    return results;<br/>}</span></pre><p id="f0fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有一个更新的树来精确显示节点将被访问的顺序。从1-9开始跟着走。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/7f124eaf763541506ca6fdac00b1cda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Td549RNnTfR3juqgxp7q_A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">In-Order Traversal</figcaption></figure><p id="695f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以看到我们一直调用左边的子树，然后是那个子树的根，然后是右边的子树。</p><h1 id="c766" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">后期订单</h1><p id="7c64" class="pw-post-body-paragraph ka kb in kc b kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ig bi translated">你大概能猜到最后一个要去哪里，所以我闭嘴给你看代码:</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="5b23" class="mu kz in mq b gy mv mw l mx my">function DFSPostOrder(root) {<br/>    let results = [];<br/>    <br/>    function traverse(node) {<br/>        if (node === null) return;</span><span id="1641" class="mu kz in mq b gy mz mw l mx my">        traverse(node.left);<br/>        traverse(node.right);    //This line<br/>        results.push(node.val); // Swapped with this line<br/>    }<br/>    traverse(root);<br/>    return results;<br/>}</span></pre><p id="e510" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是它的样子。从1–9开始跟进:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/df7f64992e85c4ad05f73f794ee9310e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oSirsG9eM-ftN2UOyfyUKQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Post-Order Traversal</figcaption></figure><p id="0c2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那就是树遍历！在回答算法问题时，了解这些不同的技术非常有帮助。有时，您可能必须找到一棵树的最小深度(广度优先搜索)，或者可能沿着垂直轴反转一棵树(DFS预排序)。不管你在做什么，记住这些基本原则是非常有帮助的。</p><p id="f652" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你喜欢学习更多关于奇妙的树木世界的知识(Lorax会感到非常自豪)。非常感谢您的阅读，下次再见！</p><p id="dc0f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nm">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>