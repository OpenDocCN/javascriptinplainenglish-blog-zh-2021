<html>
<head>
<title>Getting Started with Loaders and Plugins in Webpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack中的加载器和插件入门</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-loaders-and-plugins-in-webpack-269a2b151c38?source=collection_archive---------16-----------------------#2021-02-13">https://javascript.plainenglish.io/getting-started-with-loaders-and-plugins-in-webpack-269a2b151c38?source=collection_archive---------16-----------------------#2021-02-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/80394bbd6fbccf92d52f980ec71afc35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynbMu1n8iZbMqlPXXUVwjQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://www.pexels.com/@mnnewmanphoto?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Megan Newman</a> from <a class="ae jz" href="https://www.pexels.com/photo/jellyfish-underwater-1748265/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="cebd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2016年，我在澳大利亚旅行了几周，平生第一次尝试冲浪。我喜欢它，但每当我下水时，我都有一种不安的感觉。水面下有水母，在我观察了几个不幸的游泳者后，我知道触摸它们会受伤。</p><p id="4e92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对我来说，Webpack有点像这些水母。这是发展环境的一部分，有理由存在，但我们通常会尽量远离对方，因为我们知道任何接触对我们双方来说都是痛苦的。不幸的是，我最近在工作中遇到的许多技术问题似乎都与webpack有关，因此避免接触很少是一种选择。我通常会向一位同事寻求帮助，我们通过谷歌和大量实验解决了这个问题。</p><p id="0282" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对我来说，关于webpack的大部分困惑都源于我自己从来没有设置过它，也没有真正理解它背后发生了什么。我想很多人都是这样，因为你通常不会从头开始配置webpack。例如，当您开始一个新的Vue项目时，Vue CLI将为您预配置webpack。我想React也是如此。这很方便，因为您不想在每次启动新项目时都花半个小时来设置webpack。但是如果你至少一次都没有自己设置过，那么一旦你不得不定制它，这种“魔力”就很难理解了。因此，让我们看看引擎盖下，并建立自己的webpack。不过，我们不会把一堆现有的插件缝合在一起。我们将从头开始建造它们💪。</p><h1 id="2f2a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">webpack试图解决的问题</h1><p id="0318" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们从头开始，弄清楚webpack实际上是什么。<a class="ae jz" href="https://webpack.js.org/concepts/" rel="noopener ugc nofollow" target="_blank"> webpack文档</a>将webpack描述为<em class="mb">“现代JavaScript应用的静态模块捆绑器”</em>这听起来很棒，但是如果你不太了解bundlers，那么，最重要的是，这听起来非常抽象。简而言之，webpack会查看您的JavaScript代码，找出它的所有依赖项，并将它们打包到一个目录中，作为一个或多个文件。</p><p id="831c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几年前，这是不必要的，因为JavaScript应用程序通常没有那么大。你可以在HTML中包含几个<code class="fe mc md me mf b">&lt;script&gt;</code>标签。但是现在，应用程序已经变得如此之大，以至于如果你试图以正确的顺序手动包含所有的JavaScript文件，你的脑袋会爆炸。但是webpack走得更远，它使得捆绑图像、样式表甚至你的HTML成为可能。它通过加载器和插件完成所有这些工作，使得webpack非常具有可定制性——有时还会让你脑袋爆炸。</p><h1 id="2cc1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">项目设置</h1><p id="60cc" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将构建一个简单的前端应用程序，包括一些HTML，CSS和JavaScript，并将所有这些与webpack捆绑在一起。这将是一个很小的项目，但它应该足以说明webpack背后的一些概念。让我们设置项目文件夹并安装webpack和<a class="ae jz" href="https://github.com/webpack/webpack-cli#readme" rel="noopener ugc nofollow" target="_blank"> webpack-cli </a>。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2bea" class="mo kz in mf b gy mp mq l mr ms">mkdir webpack-from-scratch<br/>cd webpack-from-scratch<br/>mkdir src<br/>echo "console.log('Hello world');" &gt; src/index.js<br/>yarn add -D webpack webpack-cli</span></pre><p id="5213" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以从终端运行<code class="fe mc md me mf b">yarn webpack bundle</code>，webpack会捆绑我们的<code class="fe mc md me mf b">index.js</code>，输出到<code class="fe mc md me mf b">dist/main.js</code>。webpack如何知道为我们捆绑哪个文件？按照惯例。默认的webpack配置假设存在一个<code class="fe mc md me mf b">src/index.js</code>文件，并使用它作为包的入口点。“入口点”是webpack开始构建依赖关系树的源文件。您可以<a class="ae jz" href="https://webpack.js.org/concepts/entry-points/" rel="noopener ugc nofollow" target="_blank">更改入口点，甚至添加多个入口点</a>，但是在我们的例子中我们不必这样做。让我们来看看我们捆绑的应用程序的内容:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">dist/main.js</figcaption></figure><p id="5a91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，webpack还没有真正给我们的项目增加任何价值。我们可以很容易地把<code class="fe mc md me mf b">index.js</code>文件复制到我们自己身上。但我们会谈到这一点。首先，让我们添加一个HTML文件来加载JavaScript代码。稍后我们将研究如何自动捆绑它，但是现在，让我们将文件保存在<code class="fe mc md me mf b">dist/</code>文件夹中。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">dist/index.html</figcaption></figure><p id="ed61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在浏览器中打开该文件，您应该会看到“Hello world”记录到您的开发人员控制台。接下来，让我们让我们的JavaScript实际做一些事情。在我们的网站上显示当前时间怎么样？为了保持代码模块化，创建一个新文件<code class="fe mc md me mf b">src/dateFormat.js</code>来导出一个函数:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">src/dateFormat.js</figcaption></figure><p id="d7e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在<code class="fe mc md me mf b">index.js</code>中导入函数，在网页上显示当前的工作日和时间，并每秒更新一次。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">src/index.js</figcaption></figure><p id="26f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行<code class="fe mc md me mf b">yarn webpack bundle</code>重建应用程序，然后再次打开<code class="fe mc md me mf b">index.html</code>。您应该会看到每秒更新一次的时钟。当您再次打开捆绑文件时，您会看到webpack已经包含了来自<code class="fe mc md me mf b">src/dateFormat.js</code>的代码。它还精简了代码。</p><p id="5518" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们想给我们的页面添加一些样式。在过去，我们会自己创建样式表并将其添加到HTML中。但是让webpack处理我们所有的资产有一些好处:每个模块可以显式地导入它所依赖的资产。这使得开发人员更容易跟踪依赖关系，并且允许webpack只包含包中实际需要的东西。例如，如果您的网站有五个使用不同JavaScript和样式表的页面，您可以创建五个包，每个包都有自己的依赖树。只要你的代码库很小，这可能听起来没什么大不了的，但最终，你的应用程序会增长。排除不需要的代码可能会在页面加载过程中产生几毫秒的差异，而这在web上可能是永恒的。</p><h1 id="7801" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用webpack加载样式表</h1><p id="7f7f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将样式保存在<code class="fe mc md me mf b">src/style.css</code>中。让我们给正文一个明亮的背景颜色，将文本居中，并更改字体系列和大小:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">src/style.css</figcaption></figure><p id="9ffa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们在<code class="fe mc md me mf b">index.js</code>文件中导入样式表时，webpack会将它添加到依赖关系树中，并尝试在编译期间加载它。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">src/index.js</figcaption></figure><p id="deb4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行<code class="fe mc md me mf b">yarn webpack bundle</code>会给我们以下错误:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="9d95" class="mo kz in mf b gy mp mq l mr ms">You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See <a class="ae jz" href="https://webpack.js.org/concepts#loaders" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/concepts#loaders</a></span></pre><p id="b222" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Webpack不知道如何处理样式表。我们将不得不添加一个适当的加载程序来解决这个问题。</p><h1 id="de0e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建我们自己的样式表加载器</h1><p id="999c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">当webpack遇到导入语句时，它会将导入文件的内容加载到一个UTF-8字符串中。webpack加载器只是一个函数。它将字符串作为参数，可以选择对其应用转换，并返回结果。真的就这么简单。您可以用几行JavaScript代码构建一个加载器:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">An example loader</figcaption></figure><p id="e010" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，webpack只知道如何导入JavaScript文件。但是你可以配置webpack为其他文件类型使用不同的加载器，并且你可以<a class="ae jz" href="https://webpack.js.org/concepts/loaders/#loader-features" rel="noopener ugc nofollow" target="_blank">为相同的文件类型链接多个加载器</a>。然后，每个加载器将转换资源，并将结果输出传递给链中的下一个加载器。加载器可以以他们喜欢的任何方式转换输入，但是链中的最后一个加载器<strong class="kc io">必须产生一个有效的JavaScript模块</strong>，它将代替原始资源被执行。</p><p id="6b68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望加载器将样式表复制到我们的构建目录中。那么它应该导出生成文件的路径，而不是返回样式表内容。我们可以使用webpack的loader上下文中的<a class="ae jz" href="https://webpack.js.org/api/loaders/#thisemitfile" rel="noopener ugc nofollow" target="_blank"> emitFile </a>函数将样式表发送到构建目录。让我们在<code class="fe mc md me mf b">webpack/CssLoader.js</code>中创建一个样式表加载器:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">webpack/CssLoader.js</figcaption></figure><p id="5917" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将输出一个带有随机文件名的<code class="fe mc md me mf b">.css</code>文件，并返回一个导出文件路径的模块。我们使用一个随机的文件名来避免导入多个具有相同basename的样式表时的名称冲突。至关重要的是，你<strong class="kc io">将加载器定义为普通函数</strong>而不是箭头函数，因为后者不能通过<code class="fe mc md me mf b">this</code>访问加载器上下文。</p><p id="8a93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最初，我试图从加载器返回普通文件路径，希望能够导入它。这不起作用，因为文件路径不是有效的JavaScript代码。还记得我之前说过，链中的最后一个加载器必须返回一个有效的JavaScript模块吗？请这样想:当您导入一个模块时，webpack将评估该模块的源代码来代替导入，并在当前范围内公开该模块的导出。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A simplified explanation of the import statement</figcaption></figure><p id="18d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据上面的示例，返回普通文件路径将产生以下结果:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">An example of importing an invalid module</figcaption></figure><p id="e266" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这不是有效的JavaScript代码。首先，没有导出，所以计算的代码不返回值。第二，文件路径没有用引号括起来，导致语法错误。当然，这是对复杂事物的一个非常简单(可能有些错误)的解释，但是我希望它有助于理解加载器的输出是什么样子。<br/>顺便说一下，很容易改变加载器来处理其他文件类型，例如图像。看看关于raw loaders 的webpack文档，了解如何在不将资源转换为UTF-8字符串的情况下加载资源。</p><p id="d701" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经创建了我们的加载器，我们需要告诉webpack使用它。让我们创建一个webpack配置文件:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="e512" class="mo kz in mf b gy mp mq l mr ms">touch webpack.config.js</span></pre><p id="f780" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并为<code class="fe mc md me mf b">.css</code>文件设置加载器规则:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">webpack.config.js</figcaption></figure><p id="8659" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以运行<code class="fe mc md me mf b">yarn webpack bundle</code>而不会出现任何错误。但是我们还没有将样式表添加到HTML中，所以它不会做任何事情。让我们使用JavaScript将样式表附加到DOM中:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">src/index.js</figcaption></figure><p id="61b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再次捆绑应用程序，你应该会看到一个美丽，明亮的背景🎉。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/225d93e6fc7120d29207914ef245496d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0M8YGY0mC2_LV8iR.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">An impressively styled clock on the web</figcaption></figure><p id="4d8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，这有一个缺点:<code class="fe mc md me mf b">&lt;link&gt;</code>标签是在运行时由我们的JavaScript代码添加到DOM中的，这意味着它是最后加载的，在网页呈现之后，JavaScript代码执行之后。理想情况下，我们希望在编译期间将<code class="fe mc md me mf b">&lt;link&gt;</code>标签添加到HTML中。我们如何做到这一点？用我们自己的插件！</p><h1 id="c666" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">构建一个插件在编译时生成HTML</h1><p id="b29e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">最初，我们已经创建了<code class="fe mc md me mf b">index.html</code>文件，并手动将其复制到<code class="fe mc md me mf b">dist/</code>文件夹中。当然，我们也可以继续为这个HTML文件添加一个样式表的<code class="fe mc md me mf b">&lt;link&gt;</code>标签。但是如果我们有不止一个样式表呢？这很快变得不可收拾。如果webpack自动为我们做到这一点岂不是很棒？我们可以用装载机来做吗？<br/>加载器没有模块所依赖的其他资源的信息。我们可以创建一个HTML加载器，但是它不知道需要将哪些样式表添加到模板中。相反，我们必须创建一个webpack插件。让我们来看看插件是如何工作的。</p><p id="4d2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们运行<code class="fe mc md me mf b">webpack bundle</code>命令时，webpack运行一系列步骤来生成最终的包。它解决依赖性，优化代码，释放资产——这个列表很长。一个插件允许我们挂钩到这些步骤中的每一个来做额外的工作。不幸的是，尽管编写一个插件本身并不复杂，但我很难弄清楚所有可用的钩子是如何工作的，以及我必须使用哪一个。webpack文档包含了可用钩子的列表，但是关于每个钩子的信息非常有限。对我帮助最大的是钻研一些webpack插件的源代码<a class="ae jz" href="https://github.com/webpack/webpack/tree/master/lib" rel="noopener ugc nofollow" target="_blank">。好消息是你很少需要自己写插件。现有的webpack插件有很多</a><a class="ae jz" href="https://webpack.js.org/plugins/" rel="noopener ugc nofollow" target="_blank"/>，你平时想做的大部分东西已经被别人想出来了。例如，类似于我们将要构建的插件(事实上，它要强大得多)是<a class="ae jz" href="https://webpack.js.org/plugins/html-webpack-plugin/" rel="noopener ugc nofollow" target="_blank"> html-webpack-plugin </a>。但我们是来拆纸盒的，所以磨快你的刀。</p><p id="d21c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">插件是一个带有<code class="fe mc md me mf b">apply</code>方法的JavaScript类。该方法接收一个编译器实例作为参数，它公开了一个我们可以利用的钩子列表。在webpack发出所有资产后，我们需要挂钩到编译中，因为这允许我们获得需要添加到HTML模板的样式表列表。<br/>我们进入<code class="fe mc md me mf b">thisCompilation</code>钩子，这反过来让我们能够访问<code class="fe mc md me mf b">compilationContext</code>。这再次暴露了我们可以利用的几个钩子，其中之一是<code class="fe mc md me mf b">processAssets</code>钩子。<code class="fe mc md me mf b">processAssets</code>挂钩有多个阶段，我们挂钩到输出额外资产的阶段。我说过这东西很复杂吗？希望代码能让这一点更加清晰。让我们在<code class="fe mc md me mf b">webpack/HtmlPlugin.js</code>中创建插件:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">webpack/HtmlPlugin.js</figcaption></figure><p id="2dd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">存在嵌套钩子的事实并没有减少这种混乱。我怎么知道要接入哪个钩子？我只是看了一下<a class="ae jz" href="https://webpack.js.org/plugins/html-webpack-plugin/" rel="noopener ugc nofollow" target="_blank"> html-webpack-plugin </a>的源代码，看看他们做了什么。关于 <code class="fe mc md me mf b"><a class="ae jz" href="https://webpack.js.org/api/compilation-hooks/#processassets" rel="noopener ugc nofollow" target="_blank">processAssets</a></code> <a class="ae jz" href="https://webpack.js.org/api/compilation-hooks/#processassets" rel="noopener ugc nofollow" target="_blank">钩子</a>的<a class="ae jz" href="https://webpack.js.org/api/compilation-hooks/#processassets" rel="noopener ugc nofollow" target="_blank"> webpack文档实际上很不错，但是我不认为我自己会找到这个钩子。我还运行了许多测试编译，在那里我只是<code class="fe mc md me mf b">console.logged</code>钩子的参数，看看它们的接口是什么。</a></p><p id="e12e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">钩子使用了一个HTML模板，我们还没有创建它。让我们接下来这样做:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">webpack/HtmlPlugin.html</figcaption></figure><p id="e748" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，让我们将插件添加到我们的webpack配置中:</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">webpack.config.js</figcaption></figure><p id="dcc3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与我们添加自定义加载器时不同，我们需要导入插件，实例化它并将插件实例传递给webpack。现在您可以从<code class="fe mc md me mf b">index.js</code>中删除事件监听器，但是保留样式表导入。我们不再需要<code class="fe mc md me mf b">stylesheetPath</code>，但是如果没有导入，webpack不会将样式表添加到依赖关系树中。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">src/index.js</figcaption></figure><p id="ace7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您再次运行<code class="fe mc md me mf b">yarn webpack bundle</code>时，它应该向输出目录发出三个文件:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="65f8" class="mo kz in mf b gy mp mq l mr ms">dist/<br/>|- 1612259960631-0.19359674520973624.css<br/>|- index.html<br/>|- main.js</span></pre><p id="1a18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mc md me mf b">index.html</code>应该仍然有加粗的文本和美妙的背景颜色，但是现在样式在JavaScript之前加载。</p><h1 id="c83e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="5de1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">回过头来看，我们从与webpack捆绑在一起的一个JavaScript文件开始。然后我们添加了一个样式表，并构建了自己的webpack加载器来导入它。最后，我们开发了一个插件，它可以生成一个HTML文件，并用<code class="fe mc md me mf b">&lt;link&gt;</code>标签填充到所有的包样式表中。</p><p id="e6fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，您通常不会从头开始构建它。有更好的webpack加载器和插件可以做得更好，我们只用几行代码就做到了。但我希望你这次享受了为自己建造东西的练习——至少我享受了。我现在也不那么害怕深入webpack了，尽管我们仍然只是触及了表面。关于webpack能做的事情，你可以写一整本书。谈到书籍，我认为survivejs.com上的<a class="ae jz" href="https://survivejs.com/webpack/foreword/" rel="noopener ugc nofollow" target="_blank"> webpack书籍是了解webpack更多信息的绝佳资源。如果你不断尝试，就把它作为参考。例如，您可以扩展插件，让它自动添加链接到JavaScript包的<code class="fe mc md me mf b">&lt;script&gt;</code>标签。如果您决定</a><a class="ae jz" href="https://webpack.js.org/configuration/output/#outputfilename" rel="noopener ugc nofollow" target="_blank">更改包名</a>或者如果您配置webpack输出多个包，这将非常有用。</p><p id="2145" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="bd6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mb">原载于2021年2月13日</em><a class="ae jz" href="https://stricker.digital/posts/unboxing-webpack/" rel="noopener ugc nofollow" target="_blank"><em class="mb">https://stricker . digital</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>