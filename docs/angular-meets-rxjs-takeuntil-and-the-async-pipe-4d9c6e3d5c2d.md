# Angular 符合 RxJS:“take until”和“async”管道

> 原文：<https://javascript.plainenglish.io/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d?source=collection_archive---------3----------------------->

![](img/930715dfa12b3fbc5d1bb3016070dc80.png)

Photo by [Lauren George](https://unsplash.com/@bigspringsstudio?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

# 介绍

这篇文章属于名为“ **Angular meets RxJS** ”的系列文章，在这篇文章中，我尽我所能在“Angular”上下文中使用“RxJS”来解释反应式编程。

# 目录

[基本概念](/angular-meets-rxjs-basic-concepts-f178d8fe0e02)
[RxJS 科目](/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3)
[RxJS 运算符(第 1 部分)](/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e)
[RxJS 运算符(第 2 部分)](/angular-meets-rxjs-rxjs-operators-60d8b2140d20)
[RxJS 运算符(第 3 部分)](https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-e64caa5f72e7)
“take until”和“async”管道
[高阶可观测量](https://ssougnez.medium.com/angular-meets-rxjs-higher-order-observables-632e560ce2d0)
[错误处理](https://ssougnez.medium.com/angular-meets-rxjs-error-handling-8fad48721e49)
RxJS 调度器(即将推出)

# 在这篇文章中

将“RxJS”与“Angular”一起使用的一个挑战是，我们需要以最佳方式释放 observables 使用的资源，以避免内存泄漏。到目前为止，我们看到的唯一方法是调用订阅的“取消订阅”功能。尽管它工作得很好，但像这样管理订阅会变得很麻烦。

在本文中，我们将看到简化订阅管理的两种方法:“takeUntil”操作符和“async”管道。

# 具体的例子

您可能很熟悉在组件中订阅永无止境的可观察对象的情况。在这种情况下，您必须取消订阅“ngOnDestroy”钩子中的可观察对象，以避免内存泄漏。

一个典型的例子是某种计数器组件，它显示自初始化以来经过的秒数。这种组件的代码可以是:

及其模板:

这段代码很好，并按预期工作。对可观察对象的订阅在“ngOnInit”钩子中创建，并在“ngOnDestroy”钩子中释放。然而，总是这样管理订阅会很麻烦，尤其是当你必须订阅多个 observables 时。

# “拿”可以有所帮助

“take”操作符可以帮助减少订阅的数量。事实上，有时候，即使你认同一个永无止境的可观察值，也可能你只对第一个值感兴趣。例如，假设您想在一秒钟后以一种被动的方式只执行一次(因此不使用“setTimeout”)，您可以通过使用“timer”操作符和“take”操作符来完成输出可观察值。

在这种情况下，我们订阅源可观察对象，然后一旦源可观察对象发出第一个值，就完成输出。您可以在本文的[中找到关于“take”操作符的更多信息。](/angular-meets-rxjs-rxjs-operators-60d8b2140d20)

# “takeUntil”拯救世界

![](img/374d170eebac4aabb3eacf246ea256b9.png)

“takeUntil”是一个非常酷的操作符，它发出源可观测值，直到另一个可观测值发出一个值。它的大理石图如下:

![](img/45e9a97f08cf14ce20396ed3ead095d1.png)

我们可以使用该运算符来避免像这样管理订阅:

在这个版本的代码中，我们创建了一个“[主题](/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3)，并在“ngOnDestroy”钩子中发出一个值。我们还完成了它，因为我们以后不再需要它。我们还通过使用“takeUntil”操作符将订阅更改为可观察对象，以指定我们希望在可观察对象“_subject”发出后立即完成输出可观察对象。

现在，我已经听到你说“好的，很酷，但是…现在我有一个主题而不是订阅，它甚至有更多的代码，所以我为什么要使用它？”。

第一个原因是它极大地改进了管理多个订阅的方式。事实上，当订阅其他 observabless 时，你也可以使用“takeUntil”和“_subject ”,这样当组件被销毁时，你就可以取消订阅所有 observable。

但是使用这种方法的更好的方法是创建以下基本组件:

现在，您唯一要做的就是扩展这个组件，并使用“takeUntil”和“destroy$”可观察值。

这是我在所有“Angular”应用程序中使用的一种方法，它工作得非常好，特别是因为大多数时候，你将不得不通过一些操作符来传递你的可观察对象，以实现你想要的，所以只需在正确的位置添加“takeUntil”就可以避免管理订阅。

# “异步”管道

尽管“takeUntil”方法非常简洁，但“Angular”团队有一个好主意，创造了令人敬畏的**“异步”管道。当处理可观测量时，这个管道使一切变得容易。**

> **这个管道也可以用来管理承诺，但我们不会在本文中讨论它**

**该管道用于声明性地订阅“Angular”模板中的可观察对象，并在发出值后立即更新视图，最大的好处是该管道可以为您处理订阅。例如，您以前的代码可以像这样得到很大的改进:**

**如你所见，我们过去使用的大部分代码已经消失了。唯一剩下的就是创造可观察的事物。当然，我们还需要更新模板来使用“异步”管道。**

**就是这样…基本上，通过这样做，您请求管道订阅可观察对象，并在使用管道的组件被破坏后立即取消订阅。您将整个订阅管理卸载到“Angular”的“async”管道中。**

# **关于“异步”管道的更多信息**

**“异步”管道提供了两个很好的特性，我想在本文结束之前谈谈。**

## **如果可观察到的变化呢？**

**在“Angular”应用程序中，通常有一些组件只是用来显示数据。例如，我们可以考虑使用一个“用户组件”来显示用户的数据。关于那件事有两种不同的观点:**

*   **创建一个期望显示整个对象的输入。**
*   **创建一个期望显示对象 id 的输入。**

**正如我们将在下一篇文章中看到的，我越来越喜欢使用商店来管理我的“Angular”应用程序。长话短说，商店就像数据库的一部分，其中充满了应用程序需要的数据。**

**如果我必须创建一个“UserComponent ”,我可能会在我的存储中有一个用户映射，我将通过查询来检索用户的数据。因为我们还没有看到如何在“Angular”中创建一个商店，所以我将使用一些伪代码，但是最后，您的组件可能看起来像这样:**

**基本上，我们只是在组件初始化期间，根据输入的“userId”查询存储以检索用户。函数“selectUser”返回一个在用户数据改变时发出用户数据的可观察对象。**

**尽管这种方法是有效的，但是这个组件有一个问题:“如果 userId 改变了怎么办？”。事实上，如果输入的值发生变化，我们必须更新我们的可观察值，以便返回由新值“userId”标识的用户的数据。我对此做了很多实验，不幸的是，我没有找到一个完美的解决方案，然而，我找到了一个接近完美的解决方案，这要感谢[这篇 StackOverflow 帖子](https://stackoverflow.com/questions/64287715/use-an-observable-store-and-a-component-input-with-angular)。**

**想法是在 setter 中转换我们的输入，并更新那里的可观察值:**

**现在，我们只需在每次“userId”改变时更新可观察对象。然而，如果“异步”管道没有那么好，这是不可能的。事实上，假设组件加载了输入“1”。当用户“1”的数据改变时，可观察对象被创建并发出值。当我们在模板中使用“async”管道时，创建了对此可观察对象的订阅，但是过了一会儿，输入的值发生了变化，这意味着创建了一个新的可观察对象并将其放入“data$”中，那么活动订阅会发生什么情况呢？“异步”管道简单地取消订阅。事实上，这个管道足够聪明，可以检测到可观察的引用何时发生变化，并取消所有活动订阅，这使得上面的代码可行。**

## **与 ngIf 异步**

**如果我们继续上面的“UserComponent ”,我们可以想象该模板如下所示:**

**不太好。事实上，一旦我们想要显示一个值，就需要订阅可观察值，这是非常麻烦的。如果您认为在上面的例子中，我们创建了三个不同的订阅只是为了显示一些数据，那就更是个问题了。**

**在这种情况下，一个非常好的解决方案是使用“ngIf … as”指令:**

**这已经很清楚了，好消息是我们将活动订阅的数量减少到了一个。因此，基本上，“异步”管道订阅可观察对象，并将发出的值放在本地模板变量“user”中。之后，你可以使用“用户”作为一个常规变量。如果你真的想拥有一个好的组件，你可以预见用户被获取的情况。**

**这样，如果可观察对象没有发出一个值或发出一个“假”值，将显示文本“正在加载”。**

# **最后的想法**

**在本文中，我们学习了如何在我们的“Angular”组件中大幅减少要管理的订阅数量。我们可以通过使用“takeUntil”操作符和强大的“async”管道来实现这一点。现在我们已经准备好讨论最复杂的“RxJS”主题之一:更高阶的可观测值。**

**[![](img/6d60b235fcc46a4bd696b90e886419ee.png)](https://www.buymeacoffee.com/ssougnez)**