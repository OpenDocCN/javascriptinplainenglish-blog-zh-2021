<html>
<head>
<title>Big O Notation Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O批注解释道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/big-o-notation-explained-1f6a99328c82?source=collection_archive---------4-----------------------#2021-10-20">https://javascript.plainenglish.io/big-o-notation-explained-1f6a99328c82?source=collection_archive---------4-----------------------#2021-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2d24" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">大O符号解释，没有任何复杂的数学，使用简单的例子！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9a4cfaee31aec4ad581a60976e672a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMvrf0jn2wAkkHpwWtXHNw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Big O Time Complexity, Image: <a class="kv kw ep" href="https://medium.com/u/e98d079ebca8?source=post_page-----1f6a99328c82--------------------------------" rel="noopener" target="_blank">Arek Jaworski</a></figcaption></figure><h1 id="1021" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">介绍</h1><p id="73d2" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在计算机科学中，大O符号用于描述当输入大小增长时算法如何执行。输入越大，我们的算法需要执行的计算(操作)就越多。</p><p id="3730" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们可以测量时间(一个<em class="mq">算法</em>需要多少时间)或空间(一个<em class="mq">算法</em>需要多少内存)。</p><p id="b33d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在本文中，我们将关注时间复杂性。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="705c" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在我们真正开始之前，我们必须理解一个关键概念。大O用于测量算法和<strong class="lr ir">的<em class="mq">复杂度，而不是</em></strong>实际的总执行时间。我们不需要检查和计算每一行代码！我们看到的是使算法运行得更慢或更快的<em class="mq">关键操作</em>，例如循环或递归调用。</p><p id="fe01" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir">例子:</strong>很明显，打印出一个字符比打印出一整页文字需要的时间要少(尤其是在真正的打印机上，而不是在屏幕上)。然而，在这两种情况下，算法的<em class="mq">复杂度是相同的。这听起来可能有点违背我们刚才所说的-更大的输入(即更长的文本)-需要更多的打印操作。然而，如果我们把它转换成代码:</em></p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="3470" class="nd ky iq mz b gy ne nf l ng nh">function print(text) {<br/>    console.log(text);<br/>}</span><span id="bec8" class="nd ky iq mz b gy ni nf l ng nh">print('a');<br/>print('abcdefghijklmnopqrstuvwxyz');</span></pre><p id="abd2" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在这两种情况下，我们使用了相同的伪<code class="fe nj nk nl mz b">print</code> " <em class="mq">算法</em>，并且我们调用了一次<code class="fe nj nk nl mz b">console.log</code>，这意味着<code class="fe nj nk nl mz b">print</code>函数的<em class="mq">复杂度</em>没有改变。在这两种情况下，算法的<em class="mq">复杂度是相同的。然而，<em class="mq">程序</em>的实际<em class="mq">执行时间</em>可能会有所不同。</em></p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="3f5e" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在下一部分中，我们将看看不同的示例算法，并检查它们相应的时间复杂度。我们将从最快的算法开始，逐渐转向较慢的算法。</p><h1 id="bea7" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">O(1) —常数</h1><p id="7b61" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">理想算法和最快算法需要相同的时间来返回结果。</p><p id="5f50" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">一个非常简单的例子是从数组中返回元素。不管这是第一个、最后一个还是任何随机元素，所需的时间(操作次数)总是相同的。它是常数，因此我们使用<code class="fe nj nk nl mz b">O(1)</code>来描述这种情况:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2c5f" class="nd ky iq mz b gy ne nf l ng nh">const array = ['a', 'b', 'c', 'd', 'e', 'f'];</span><span id="3fc7" class="nd ky iq mz b gy ni nf l ng nh">const first  = array[0];   // one operation, x time needed<br/>const last   = array[5];   // one operation, x time needed<br/>const random = array[1];   // one operation, x time needed</span></pre><p id="dc30" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们可能会注意到，速度较快的计算机比速度较慢(或较旧)的计算机执行速度更快。重要的是，相同的计算机，运行相同的软件，会给出相同的、恒定的时间结果。</p><p id="4323" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">请注意<strong class="lr ir">我们没有对硬件进行基准测试，但是我们对算法进行了基准测试</strong>。</p><p id="3497" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">另一个简单的例子是将字符串打印到控制台输出:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a95a" class="nd ky iq mz b gy ne nf l ng nh">function print() {<br/>    console.log('Hello World');<br/>}</span><span id="8753" class="nd ky iq mz b gy ni nf l ng nh">print(); // console.log function called once, y time needed<br/>print(); // console.log function called once, y time needed</span></pre><h1 id="c6ee" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">O (log n) —对数</h1><p id="d2d3" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">接下来是<code class="fe nj nk nl mz b">O(log n)</code>，这意味着当输入呈指数增长时(<code class="fe nj nk nl mz b">10</code>、<code class="fe nj nk nl mz b">100</code>、<code class="fe nj nk nl mz b">1000</code>、<code class="fe nj nk nl mz b">10000</code>，所需时间呈线性增长(1秒、2秒、3秒、4秒)，等等。</p><p id="b68d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">二分搜索法(或任何分治算法)是复杂性的一个很好的例子。我们接受输入，把它切成两半，然后重复，直到找到我们想要的值。</p><p id="e017" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">示例:猜数字</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="5e49" class="nd ky iq mz b gy ne nf l ng nh">Guess the number between 1 and N (let's use N = 100):<br/>Answer: 50;<br/>Higher!</span><span id="7c61" class="nd ky iq mz b gy ni nf l ng nh">Answer: 75<br/>Higher!</span><span id="67e1" class="nd ky iq mz b gy ni nf l ng nh">Answer: 88<br/>Lower!</span><span id="b6c2" class="nd ky iq mz b gy ni nf l ng nh">Answer: 82<br/>Lower!</span><span id="2953" class="nd ky iq mz b gy ni nf l ng nh">Answer: 79<br/>Higher!</span><span id="97e0" class="nd ky iq mz b gy ni nf l ng nh">Answer: 80<br/>Higher!</span><span id="c996" class="nd ky iq mz b gy ni nf l ng nh">Answer: 81<br/>Correct!</span></pre><p id="2d5d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们可以看到，在<em class="mq">最坏情况</em>的场景中，如果我们不幸运，将需要多达7次迭代才能猜对数字。</p><p id="f371" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们可以用下面的方式用<code class="fe nj nk nl mz b">print</code>和<code class="fe nj nk nl mz b">for loop</code>来模拟:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="33c2" class="nd ky iq mz b gy ne nf l ng nh">function print(n) {<br/>    for(let i = n; i &gt;= 1; i = i / 2) {<br/>        console.log('Hello World');<br/>    }<br/>}</span><span id="275b" class="nd ky iq mz b gy ni nf l ng nh">print(1);   // console.log called once for n = 1<br/>print(10);  // console.log called 4 times for n = 10<br/>print(100); // console.log called 7 times for n = 100</span></pre><h1 id="be6e" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">O(n) —线性</h1><p id="8ca1" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">这个比之前的稍微慢一点(如果你还没有注意到的话——我们从最快到最慢)。然而，它是最直接的，因为它是线性的，这意味着更多的输入=更多的操作=更多的时间。</p><p id="efe2" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">如果我们跳回我们的<code class="fe nj nk nl mz b">print</code>函数，那么我们可以把它重构为:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a02c" class="nd ky iq mz b gy ne nf l ng nh">function print(n) {<br/>    for (let i = 0; i &lt; n; i++) {<br/>        console.log('Hello World');<br/>    }<br/>}</span></pre><p id="c762" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们可以看到，对于<code class="fe nj nk nl mz b">n = 1</code>，我们调用了<code class="fe nj nk nl mz b">console.log</code>一次。对于<code class="fe nj nk nl mz b">n = 10</code>，我们调用了<code class="fe nj nk nl mz b">console.log</code> 10次，以此类推。完成所有功能循环所需的时间(操作次数)呈线性增长。</p><p id="aede" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">因此，如果我们创建一个名为<code class="fe nj nk nl mz b">doublePrint</code>的函数</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="463c" class="nd ky iq mz b gy ne nf l ng nh">function doublePrint(n) {<br/>    for (let i = 0; i &lt; n; i++) {<br/>        console.log('Hello World');<br/>        console.log('Hello World Again');<br/>    }<br/>}</span></pre><p id="bdc5" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们可以看到<code class="fe nj nk nl mz b">console.log</code>调用的数量翻倍，这意味着<code class="fe nj nk nl mz b">print</code>比<code class="fe nj nk nl mz b">doublePrint</code>快，但是两种情况下的复杂度都是线性的。</p><p id="6365" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">对于<code class="fe nj nk nl mz b">print</code>是<code class="fe nj nk nl mz b">O(n)</code>，对于<code class="fe nj nk nl mz b">doublePrint</code>是<code class="fe nj nk nl mz b">O(2n)</code>，并且……因为我们不需要计算每一个操作，我们甚至可以简化<code class="fe nj nk nl mz b">doublePrint</code>使其成为<code class="fe nj nk nl mz b">O(n)</code>:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="ee89" class="nd ky iq mz b gy ne nf l ng nh">function doublePrint(n) {<br/>    for (let i = 0; i &lt; n; i++) {<br/>       console.log('Hello World', 'Hello World Again');<br/>    }<br/>}</span></pre><p id="da2b" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">值得注意的是，我们不测量实际打印时间！如果我们使用普通的打印机，那么整篇文章就不会神奇地打印在纸上。显然，打印出更多的字符和行需要更多的时间。</p><p id="5e91" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们测量和比较的是算法的实际<em class="mq">复杂度，在这种情况下<code class="fe nj nk nl mz b">print</code>和<code class="fe nj nk nl mz b">doublePrint</code>都同样复杂。</em></p><h1 id="4185" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">O(n log n) —线性和对数</h1><p id="bd8d" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们已经讨论了对数<code class="fe nj nk nl mz b">O(log n)</code>和线性<code class="fe nj nk nl mz b">O(n)</code>复杂性，这一个将是两者的结合。因此，比以前的要慢。我们将重构<code class="fe nj nk nl mz b">print</code>，使其变得更加复杂，并将<code class="fe nj nk nl mz b">O(log n)</code>包装在<code class="fe nj nk nl mz b">O(n)</code>中，如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f87b" class="nd ky iq mz b gy ne nf l ng nh">function print(n) {<br/>    for (let i = 0; i &lt; n; i++) {<br/>        for (let j = n; j &gt;= 1; j = j / 2) {<br/>            console.log('Hello World');<br/>        }<br/>    }<br/>}</span></pre><p id="1540" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们可以立即看到，这是更复杂的代码(伪算法)，需要更多的时间来完成，因为现在实际上有两个循环。</p><p id="c732" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们可以对此进行基准测试，并查看输出:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="33ff" class="nd ky iq mz b gy ne nf l ng nh">+-----+-------------+<br/>|   n | console.log |<br/>+-----+-------------+<br/>|   1 |           1 |<br/>|   2 |           4 |<br/>|   5 |          15 |<br/>|  10 |          40 |<br/>|  20 |         100 |<br/>|  50 |         300 |<br/>| 100 |         700 |<br/>| 200 |        1600 |<br/>| 500 |        4500 |<br/>+-----+-------------+</span></pre><h1 id="c748" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">O (n ) — N的平方</h1><p id="af9d" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在这个阶段，我们应该很容易预测如何得到<code class="fe nj nk nl mz b">O(n²)</code>的复杂度——这将需要两个循环:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a987" class="nd ky iq mz b gy ne nf l ng nh">function print(n) {<br/>    for (let i = 0; i &lt; n; i++) {<br/>        for (let j = 0; j &lt; n; j++) {<br/>            console.log('Hello World');<br/>        }<br/>    }<br/>}</span></pre><h1 id="5752" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">O (n！)—阶乘</h1><p id="a756" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">最后，让我们看看阶乘复杂度有多慢。阶乘是数列相乘的最终结果。我们可以用下面的公式来定义阶乘:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="cbe5" class="nd ky iq mz b gy ne nf l ng nh">n! = n x (n - 1) x (n - 2) x ... x 1</span></pre><p id="f230" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">示例:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="d85e" class="nd ky iq mz b gy ne nf l ng nh">1! = 1<br/>2! = 2 x 1 = 2<br/>3! = 3 x 2 x 1 = 6<br/>4! = 4 x 3 x 2 x 1 = 24<br/>5! = 5 x 4 x 3 x 2 x 1 = 120</span></pre><p id="317c" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">正如我们所看到的，我们需要多个for循环来计算最终结果。为了实现这一点，我们将使用递归并重构代码:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="38ac" class="nd ky iq mz b gy ne nf l ng nh">function print(n) {<br/>    for (let i = 0; i &lt; n; i++) {<br/>        print(n - 1);<br/>        if (n === 1) console.log('Hello World');<br/>    }<br/>}</span></pre><p id="6f47" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><code class="fe nj nk nl mz b">print</code>函数将<code class="fe nj nk nl mz b">n</code>作为输入参数，然后以<code class="fe nj nk nl mz b">n — 1</code>作为输入参数递归调用自身。一旦<code class="fe nj nk nl mz b">n === 1</code>那么我们就做<code class="fe nj nk nl mz b">console.log</code></p><p id="3ca5" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">这样我们就可以模拟阶乘复杂度了！</p><h1 id="bd3b" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">比较</h1><p id="99bb" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">最后，让我们并排比较一下每个复杂度。列中的数字表示使用给定的<code class="fe nj nk nl mz b">n</code>数字作为输入，每个算法调用<code class="fe nj nk nl mz b">console.log</code>的次数:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="85e5" class="nd ky iq mz b gy ne nf l ng nh">+-----+------+----------+------+------------+---------+---------+<br/>|   n | O(1) | O(log n) | O(n) | O(n log n) |   O(n²) |   O(n!) |<br/>+-----+------+----------+------+------------+---------+---------+<br/>|   1 |    1 |        1 |    1 |          1 |       1 |       1 |<br/>|   2 |    1 |        2 |    2 |          4 |       4 |       2 | <br/>|   5 |    1 |        3 |    5 |         15 |      25 |     120 |<br/>|  10 |    1 |        4 |   10 |         40 |     100 | 3628800 |   <br/>|  20 |    1 |        5 |   20 |        100 |     400 | ....... |<br/>|  50 |    1 |        6 |   50 |        300 |    2500 | ....... |<br/>| 100 |    1 |        7 |  100 |        700 |  100000 | ....... |<br/>| 200 |    1 |        8 |  200 |       1600 |  400000 | ....... |<br/>| 500 |    1 |        9 |  500 |       4500 | 2500000 | ....... |<br/>+-----+------+----------+------+------------+---------+---------+</span></pre><p id="5270" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">请注意，从20的阶乘开始，也就是从<code class="fe nj nk nl mz b">20!</code>开始，很难用没有科学符号的数字来表示，因为<code class="fe nj nk nl mz b">20!</code>等于<code class="fe nj nk nl mz b">2432902008176640000</code>。因此，所有这些巨大的数字都被点代替了。</p><p id="af0a" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">这些比较结果用于生成本文顶部的图表图像。</p><h1 id="27f1" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">摘要</h1><ul class=""><li id="3cfe" class="nm nn iq lr b ls lt lv lw ly no mc np mg nq mk nr ns nt nu bi translated">大O符号用于衡量和比较算法的<em class="mq">复杂度。</em></li><li id="a54b" class="nm nn iq lr b ls nv lv nw ly nx mc ny mg nz mk nr ns nt nu bi translated">大O符号不计算总执行时间。</li><li id="5624" class="nm nn iq lr b ls nv lv nw ly nx mc ny mg nz mk nr ns nt nu bi translated">我们不需要检查每一行代码。</li><li id="b290" class="nm nn iq lr b ls nv lv nw ly nx mc ny mg nz mk nr ns nt nu bi translated">大O符号用于基准测试<em class="mq">算法</em>和<strong class="lr ir">而不是硬件</strong>。</li></ul><p id="c6b9" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><em class="mq">更多内容请看</em><a class="ae oa" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lr ir"><em class="mq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>