<html>
<head>
<title>Let’s Build a MERN Stack E-Commerce Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们建立一个MERN堆栈电子商务网络应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-accb4c14ce71?source=collection_archive---------1-----------------------#2021-02-03">https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-accb4c14ce71?source=collection_archive---------1-----------------------#2021-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa7e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第4部分:构建购物车并订购路线和控制器</h2></div><h2 id="4a36" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在第四部分中，我们将构建这个项目中处理购物车和订单所需的REST APIs。我们将使用条纹结帐来处理支付。</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/2708c4abe9fe97f32cf576a75bcca98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GeHg2FnaxcrZyGwx"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@robertocortese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roberto Cortese</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a4a5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">朋友们好！这是我们最近开始的MERN堆栈系列的第四部分。在第一部分中，我们都学习了如何建立项目，并对项目中使用的各种东西进行了解释，在第二部分中，我们在Mongoose和MongoDB的帮助下开发了项目的所有模型。</p><p id="6eaa" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在第三部分中，我们开始构建REST APIs，它处理项目中的认证和项目。现在，在第四部分中，我们将通过构建REST APIs来处理web应用程序的购物车和订单方面，并使用Stripe Checkout来处理支付，从而结束我们的后端部分。</p><p id="6b2d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果你还没有阅读前三部分，这里有前三部分的链接</p><div class="ml mm gp gr mn mo"><a href="https://medium.com/javascript-in-plain-english/build-an-e-commerce-website-with-mern-stack-part-1-setting-up-the-project-eecd710e2696" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">第1部分:设置项目</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ll mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://medium.com/javascript-in-plain-english/build-an-e-commerce-website-with-mern-stack-part-2-designing-the-models-e231b2454aba" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">第2部分:设计模型</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">medium.com</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc ll mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://medium.com/javascript-in-plain-english/lets-build-a-mern-stack-e-commerce-web-app-d619f3374d73" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">第3部分:构建身份验证和项目路由和控制器</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">medium.com</p></div></div><div class="mx l"><div class="ne l mz na nb mx nc ll mo"/></div></div></a></div><p id="ed9a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，正如我们在上一部分中看到的，我们在根目录中创建了名为<em class="nf"> routes </em>和<em class="nf"> controllers </em>的文件夹。</p><p id="d95b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我们还在这两个文件夹中创建了四个文件——分别代表<strong class="lu ir">授权、商品、购物车</strong>和<strong class="lu ir">订单、</strong>。</p><p id="3963" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated"><strong class="lu ir"> <em class="nf">注</em> </strong> <em class="nf">:我们将在本教程中只处理与购物车和订单相关的路线和控制器，因为我们已经在前面的教程中处理了认证和项目。</em></p><h1 id="961b" class="ng kg iq bd kh nh ni nj kk nk nl nm kn jw nn jx kr jz no ka kv kc np kd kz nq bi translated">路线</h1><h2 id="c96c" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">购物车路线</h2><p id="4356" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">该文件处理与我们的应用程序中的购物车相关的所有路线。它有三条路线——获取购物车商品、向购物车添加商品和从购物车中删除商品。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Cart Routes</figcaption></figure><p id="453e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，让我们逐一处理每一条路线</p><ol class=""><li id="7b28" class="ny nz iq lu b lv lw ly lz ko oa ks ob kw oc mk od oe of og bi translated"><strong class="lu ir"> get_cart_items </strong> —这个路由发出一个<em class="nf"> get </em>请求，获取特定用户购物车中的所有商品。请求购物车的用户id作为参数传递。因此，我们找到用户的购物车并返回所有购物车商品。</li><li id="b64b" class="ny nz iq lu b lv oh ly oi ko oj ks ok kw ol mk od oe of og bi translated"><strong class="lu ir"> add_cart_item </strong> —这个路由发出一个<em class="nf"> post </em>请求，向购物车中添加一个商品。它还有一个param <em class="nf"> id </em>来标识哪个用户正在将商品添加到购物车中，因此我们可以找到他的购物车，并将商品添加到购物车中，或者为他创建一个新的购物车。</li><li id="6805" class="ny nz iq lu b lv oh ly oi ko oj ks ok kw ol mk od oe of og bi translated"><strong class="lu ir"> delete_item </strong> —这是一个<em class="nf">删除</em>请求，它从购物车中删除一个商品。它接受两个参数——userId和itemId。userId用于获取特定用户的购物车，itemId用于搜索该商品并将其从购物车中删除。</li></ol><h2 id="106a" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">订购路线</h2><p id="5040" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">这个文件将处理我们处理订单所需的所有路线。它有两条路线——获取我们所有的订单和下订单(结账)。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="34ef" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">所以，让我们逐一检查这两条路线</p><ol class=""><li id="4401" class="ny nz iq lu b lv lw ly lz ko oa ks ob kw oc mk od oe of og bi translated"><strong class="lu ir"> get_orders </strong> —这是一个<em class="nf"> get </em>请求，获取我们的应用程序中到目前为止所有的订单。它接受一个参数<em class="nf"> id </em>，这是帮助我们返回正确的用户订单的用户id。</li><li id="7b6e" class="ny nz iq lu b lv oh ly oi ko oj ks ok kw ol mk od oe of og bi translated"><strong class="lu ir"> checkout </strong> —这是一个<em class="nf"> post </em>请求，它还有一个用于查找用户的参数<em class="nf"> id </em>。它的功能是创造一种新的秩序。这条路线处理所有的付款部分。我们将在它的控制器中看到这些。</li></ol></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="0f67" class="ng kg iq bd kh nh ot nj kk nk ou nm kn jw ov jx kr jz ow ka kv kc ox kd kz nq bi translated">控制器</h1><h2 id="8188" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">推车控制器</h2><p id="d69c" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">这个控制器文件将处理购物车的所有逻辑。它将处理向购物车中添加商品，从购物车中删除商品，并使购物车商品与总费用一起显示。</p><p id="1166" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">这将由三个函数组成，每个函数对应我们拥有的三条路线，每条路线处理一个特定的目的。</p><p id="289d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，我们将详细讨论这三个功能。但是在此之前，我们需要这个文件中的购物车和商品模型。</p><pre class="lc ld le lf gt oy oz pa bn pb pc bi"><span id="8bdd" class="pd kg iq oz b be pe pf l pg ph">const Cart = require('../models/Cart');<br/>const Item = require('../models/Item');</span></pre><p id="1681" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我们的第一个任务是创建一个函数来获取购物车中的所有商品，并显示在应用程序的前端。</p><p id="c105" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我们将获得想要访问其购物车的用户的用户id。接下来，我们将尝试搜索具有该用户名的购物车。如果我们找到一个具有该用户名的购物车，并且购物车中有非零商品，<em class="nf">即</em>购物车非空，那么我们将返回购物车；否则，我们将返回null。</p><p id="21e1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated"><em class="nf">如果我们发送一个空值，我们也将在前端通过检查并通知用户购物车是空的来处理同样的问题。</em></p><pre class="lc ld le lf gt oy oz pa bn pb pc bi"><span id="c1e6" class="pd kg iq oz b be pe pf l pg ph">module.exports.get_cart_items = async (req,res) =&gt; {<br/>    const userId = req.params.id;<br/>    try{<br/>        let cart = await Cart.findOne({userId});<br/>        if(cart &amp;&amp; cart.items.length&gt;0){<br/>            res.send(cart);<br/>        }<br/>        else{<br/>            res.send(null);<br/>        }<br/>    }<br/>    catch(err){<br/>        console.log(err);<br/>        res.status(500).send("Something went wrong");<br/>    }<br/>}</span></pre><p id="2461" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">接下来，我们将处理向购物车添加商品。由于我们需要处理不止一个场景，这可能会更复杂一些。</p><p id="9fe5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在这个函数中，我们通过params接收userId，还通过请求体接收productId和quantity。这里，我们需要userId来访问相应用户的购物车，我们需要productId来查找要添加到购物车中的商品。</p><p id="d66a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，我们将首先尝试使用我们获得的用户Id来查找购物车。现在，有两种情况——用户可能有购物车，也可能没有。</p><p id="ccd5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">此外，我们在收到的productId的帮助下找到商品。如果找不到该项目，我们会发送一个声明相同的响应。</p><p id="b0cf" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果用户已经有一个购物车，那么我们搜索需要添加到购物车的商品中的商品，<em class="nf">，即</em>，如果该商品已经存在于购物车中。在这种情况下，我们从购物车中取出商品，按照我们收到的数量增加其数量，然后将更新后的商品分配给购物车。</p><p id="4f01" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果商品不在购物车中，我们将它推入购物车的商品数组中。然后，我们在两种情况下更新购物车的账单，然后保存购物车。然后我们发送购物车作为响应。</p><p id="15cd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在第二种情况下，如果用户还没有购物车，我们为用户创建一个新的购物车，包含用户Id、需要添加的商品和账单。然后我们返回新的购物车作为响应。</p><pre class="lc ld le lf gt oy oz pa bn pb pc bi"><span id="4ca9" class="pd kg iq oz b be pe pf l pg ph">module.exports.add_cart_item = async (req,res) =&gt; {<br/>    const userId = req.params.id;<br/>    const { productId, quantity } = req.body;<br/><br/>    try{<br/>        let cart = await Cart.findOne({userId});<br/>        let item = await Item.findOne({_id: productId});<br/>        if(!item){<br/>            res.status(404).send('Item not found!')<br/>        }<br/>        const price = item.price;<br/>        const name = item.title;<br/>        <br/>        if(cart){<br/>            // if cart exists for the user<br/>            let itemIndex = cart.items.findIndex(p =&gt; p.productId == productId);<br/><br/>            // Check if product exists or not<br/>            if(itemIndex &gt; -1)<br/>            {<br/>                let productItem = cart.items[itemIndex];<br/>                productItem.quantity += quantity;<br/>                cart.items[itemIndex] = productItem;<br/>            }<br/>            else {<br/>                cart.items.push({ productId, name, quantity, price });<br/>            }<br/>            cart.bill += quantity*price;<br/>            cart = await cart.save();<br/>            return res.status(201).send(cart);<br/>        }<br/>        else{<br/>            // no cart exists, create one<br/>            const newCart = await Cart.create({<br/>                userId,<br/>                items: [{ productId, name, quantity, price }],<br/>                bill: quantity*price<br/>            });<br/>            return res.status(201).send(newCart);<br/>        }       <br/>    }<br/>    catch (err) {<br/>        console.log(err);<br/>        res.status(500).send("Something went wrong");<br/>    }<br/>}</span></pre><p id="f525" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">最后，我们转到与购物车相关的最后一个功能——从购物车中删除商品。</p><p id="7e01" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在这里，我们接收两个参数——userId和productId。我们尝试使用用户Id搜索购物车。我们还使用收到的productId搜索商品。</p><p id="cd71" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果购物车中有商品，我们从购物车中取出该商品，并根据其价格和数量相应地减少账单。然后我们使用<em class="nf"> splice() </em>函数从购物车中删除该商品。</p><p id="1c1a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">接下来，我们保存购物车并将购物车作为响应返回给用户。</p><pre class="lc ld le lf gt oy oz pa bn pb pc bi"><span id="3589" class="pd kg iq oz b be pe pf l pg ph">module.exports.delete_item = async (req,res) =&gt; {<br/>    const userId = req.params.userId;<br/>    const productId = req.params.itemId;<br/>    try{<br/>        let cart = await Cart.findOne({userId});<br/>        let itemIndex = cart.items.findIndex(p =&gt; p.productId == productId);<br/>        if(itemIndex &gt; -1)<br/>        {<br/>            let productItem = cart.items[itemIndex];<br/>            cart.bill -= productItem.quantity*productItem.price;<br/>            cart.items.splice(itemIndex,1);<br/>        }<br/>        cart = await cart.save();<br/>        return res.status(201).send(cart);<br/>    }<br/>    catch (err) {<br/>        console.log(err);<br/>        res.status(500).send("Something went wrong");<br/>    }<br/>}</span></pre><p id="f574" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，最后，我们已经构建了购物车路线所需的所有功能。我们已经准备好处理所有与购物车相关的请求。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Cart Controller</figcaption></figure><h2 id="e435" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">订单控制器</h2><p id="1ef5" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">这个控制器文件将处理订单的所有逻辑。它将处理查看我们所有的订单，也将允许我们从我们的购物车中的项目下一个新订单，我们将通过条纹结帐处理付款。</p><p id="50fd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">这将由两个功能组成，一个用于我们拥有的两条路线，每个处理一个特定的目的。</p><p id="a2a1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在继续之前，我们需要将条带库安装到我们的应用程序中。</p><p id="7539" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，为此，我们将使用<code class="fe pi pj pk oz b">npm install stripe</code>来安装stripe。它会将它作为一个依赖项保存在我们的<em class="nf"> package.json </em>文件中。</p><p id="7177" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">此外，我们需要在配置文件中添加<em class="nf"> StripeAPIKey </em>。因此，config文件夹中更新后的<em class="nf"> default.json </em>文件应该是:</p><pre class="lc ld le lf gt oy oz pa bn pb pc bi"><span id="eb58" class="pd kg iq oz b be pe pf l pg ph">{<br/>    "dbURI": "YOUR DB URI",<br/>    "jwtsecret": "your jwt secret",<br/>    "StripeAPIKey": "YOUR STRIPE SECRET API KEY"<br/>}</span></pre><p id="26b1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">现在，我们需要在orderControllers文件中添加一些。我们需要导入订单、购物车和用户模型。我们还需要配置包来访问条带密钥。我们还需要在我们的函数中加入Stripe，它将处理支付。</p><pre class="lc ld le lf gt oy oz pa bn pb pc bi"><span id="30fb" class="pd kg iq oz b be pe pf l pg ph">const Order = require('../models/order');<br/>const Cart = require('../models/Cart');<br/>const User = require('../models/User');<br/>const config = require('config');<br/>const stripe = require('stripe')(config.get('StripeAPIKey'));</span></pre><p id="9679" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，我们将从获取特定用户的所有订单所需的函数开始。这相当简单，我们需要使用参数提供的userId来查找订单。我们按照订购日期对它们进行降序排序，然后在JSON中将订单作为响应返回。</p><pre class="lc ld le lf gt oy oz pa bn pb pc bi"><span id="695b" class="pd kg iq oz b be pe pf l pg ph">module.exports.get_orders = async (req,res) =&gt; {<br/>    const userId = req.params.id;<br/>    Order.find({userId}).sort({date:-1}).then(orders =&gt; res.json(orders));<br/>}</span></pre><p id="4ee4" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">接下来，我们有结帐功能。我们接收用户Id作为这个请求的参数。我们还从前端接收一个<em class="nf">源</em>作为请求体。这是通过Stripe处理支付。</p><p id="5043" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">现在，我们通过使用提供的userId找到购物车和用户。我们得到用户的电子邮件。</p><p id="2d37" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">然后，我们检查购物车是否存在。如果没有购物车，我们发送一个响应，声明购物车是空的。</p><p id="892e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">现在，我们使用条带创建一个<em class="nf">电荷</em>。我们传入金额、接收付款的货币、从前端接收的源对象和receipt_email。</p><p id="5470" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果费用没有成功创建，我们会抛出一个错误，说明支付失败。</p><p id="e330" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果收费成功，我们将创建一个新的订单userId、使用购物车的商品的商品和使用购物车的账单的账单。</p><p id="fa8c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">然后，我们使用购物车的id删除购物车，然后将订单作为响应发送给前端。</p><pre class="lc ld le lf gt oy oz pa bn pb pc bi"><span id="9b33" class="pd kg iq oz b be pe pf l pg ph">module.exports.checkout = async (req,res) =&gt; {<br/>    try{<br/>        const userId = req.params.id;<br/>        const {source} = req.body;<br/>        let cart = await Cart.findOne({userId});<br/>        let user = await User.findOne({_id: userId});<br/>        const email = user.email;<br/>        if(cart){<br/>            const charge = await stripe.charges.create({<br/>                amount: cart.bill,<br/>                currency: 'inr',<br/>                source: source,<br/>                receipt_email: email<br/>            })<br/>            if(!charge) throw Error('Payment failed');<br/>            if(charge){<br/>                const order = await Order.create({<br/>                    userId,<br/>                    items: cart.items,<br/>                    bill: cart.bill<br/>                });<br/>                const data = await Cart.findByIdAndDelete({_id:cart.id});<br/>                return res.status(201).send(order);<br/>            }<br/>        }<br/>        else{<br/>            res.status(500).send("You do not have items in cart");<br/>        }<br/>    }<br/>    catch(err){<br/>        console.log(err);<br/>        res.status(500).send("Something went wrong");<br/>    }<br/>}</span></pre><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Order Controller</figcaption></figure><h1 id="aba8" class="ng kg iq bd kh nh ni nj kk nk nl nm kn jw nn jx kr jz no ka kv kc np kd kz nq bi translated">结论</h1><p id="e06b" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">这就是第四部分的全部内容。我们最终总结了本系列的后端部分，现在将从下一篇教程开始，继续讨论客户端，即React和Redux代码。</p><div class="ml mm gp gr mn mo"><a rel="noopener  ugc nofollow" target="_blank" href="/lets-build-a-mern-stack-e-commerce-web-app-444082ae81bd"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">第5部分:设置客户机和Redux</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mx l"><div class="pl l mz na nb mx nc ll mo"/></div></div></a></div><p id="2ac9" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果你想访问这个项目的完整代码，请访问这个项目的<a class="ae lr" href="https://github.com/shubham1710/MERN-E-Commerce" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="978c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我希望你今天学到了新的令人兴奋的东西。我希望你现在对深入研究项目的客户端部分感到兴奋。</p><p id="c717" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">完成本系列后，还有更多的文章可供阅读:</p><div class="ml mm gp gr mn mo"><a href="https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-overview-part-1-1f847d53753f" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">使用Django Rest框架构建博客网站——概述(第1部分)</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">让我们使用Django Rest框架构建一个简单的博客网站，以了解DRF和REST APIs是如何工作的，以及我们如何添加…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="pm l mz na nb mx nc ll mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://towardsdatascience.com/build-a-job-search-portal-with-django-overview-part-1-bec74d3b6f4e" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">用Django构建求职门户——概述(第1部分)</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">让我们使用Django建立一个工作搜索门户，它允许招聘人员发布工作并接受候选人，同时…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="pn l mz na nb mx nc ll mo"/></div></div></a></div></div></div>    
</body>
</html>