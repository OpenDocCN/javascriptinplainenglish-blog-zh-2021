# 探索长轮询、SSE 和 WebSockets

> 原文：<https://javascript.plainenglish.io/exploring-long-polling-sse-and-websockets-4a0988a3432e?source=collection_archive---------3----------------------->

## 我们来看看在一个简单的通知系统中使用 Node.js 和 React 进行实时通信的不同方法

![](img/8fa051f103578e5d2f7901e3752b68f7.png)

# 概观

这篇文章是为那些想在应用程序中添加实时特性，但不需要 Firebase 这样的无服务器平台或 socket.io 这样的库的完整功能的人准备的。长轮询、SSE(服务器发送的事件)和 WebSockets 提供了一个更简单、更轻量级的替代方案，内置于所有现代 web 浏览器中。

# 设置

客户端生成唯一标识其自身的密钥。该密钥用于对包含通知消息的服务器的请求中。

内部消息传递系统用于将消息传递给适当的端点，端点再将消息发送回客户端。我建议使用类似于 Postman 的工具来发送请求。

因此，出于演示的目的，我们将手动发送请求。但是，您可以将此操作视为模仿另一个试图向特定客户端发送实时数据的客户端或后端服务。

# 长轮询

首先，让我们谈谈什么是轮询。轮询的一个例子是以特定的时间间隔向服务器发送 HTTP 请求。

换句话说，就是*我们到了吗？*消息传递解决方案。

这种方法有几个明显的问题:

1.  它不是实时的，因为如果我们决定每 5 分钟轮询一次，消息可能已经在那里停留了 4 分 59 秒。
2.  它不是*高效*或*可扩展的。*您不断地向服务器发送新的不必要的请求(但可能不会对每个请求都打开和关闭 TCP 连接，这会导致更多的开销——下面会详细介绍。)

轮询的一个更好的替代方案是所谓的*长轮询*。客户端代码如下。

工作流程如下:

1.  客户端向服务器发送请求
2.  在消息可用之前，服务器不会发送响应
3.  消息变得可用，并且响应被发送
4.  客户端在收到响应后会立即调用同一个端点

通过这种方式，连接尽可能长时间地挂起或保持打开，然后在收到响应时重新连接。

我只想说，在我们继续之前，我把这些基本的例子放在一起作为一个工作演示。没有错误处理设置，这是您在生产环境中需要的。

这很重要，因为尽管 HTTP/1.1 和 HTTP/2 连接在默认情况下是持久的(不需要*连接:keep-alive* 头)。

持久连接意味着连接不会在每次请求和响应后关闭。但是，浏览器、服务器或某些中介(代理)可能会使请求超时。

# 同ＳＯＵＴＨ-ＳＯＵＴＨ-ＥＡＳＴ

SSE(服务器发送的事件)也使用 HTTP 协议，但是通过开放的连接将数据以块的形式发送给客户端。

使用这种方法，我们需要跟踪所有打开的连接。

为了简单起见，我只使用一个对象，但是您也可以使用像 Redis 这样的内存存储。

首先，我创建了一些中间件，负责设置必要的头以及添加和删除客户端连接(响应对象)。

*Content-Type:text/event-stream*通知客户端正在使用 SSE，所以这个头是必需的。

如前所述，*连接:keep-alive* 应该是默认的，但我还是把它留了下来。我相信 *Cache-Control: no-cache* 是谨慎的，以防任何可能缓存响应的代理。

这也是生产的需要。 *flushHeaders* 方法用于将报头立即发送到客户端，因为这在第一次写入之前会被缓冲。

在客户端，我们简单地创建一个新的 *EventSource* 对象来订阅通知通道。

这里有几种不同的方法；假设您有通知，但也有视频流(和/或任何其他实时功能)。

然后，您可以为每个事件侦听器设置不同的通道名称。

只要确保在书面回复中包含事件字段(必须在数据之前)。

SSE 也有一些不错的能力，你应该知道并且可以阅读。例如，客户端将自动重新连接(设置响应中的*重试*字段以更改默认值)。

此外，您可以在响应中设置 *id* 字段(添加 Last-Event-ID 头)。当客户端重新连接时，它会包含它收到的最后一个 id。

有了这些信息，您就可以在服务器中创建一些逻辑来确定哪些消息需要重新发送。

# WebSockets

WebSocket 连接首先通过对服务器的 HTTP 请求建立，然后是响应。如果成功，则使用自己的 WebSocket 协议在客户端和服务器之间建立 WebSocket 连接。

所有现代浏览器都支持该协议。关于 WebSockets 重要的一点是，与使用 HTTP 的长轮询和 SSE 不同，WebSockets 是*全双工的，*这意味着客户机和服务器都可以发送和接收消息。

尽管通知系统并不需要这一功能，但您可能希望构建其他可以使用它的功能。

首先，创建一个新的 web socket 服务器，并允许它监听连接。客户端是初始化连接的一方。一旦客户端消息到达，我们就把它发送给客户端。

与 SSE 的设置方式类似，您可以使用不同的消息传递渠道，使用上的*进行订阅，使用*发出*进行发布。*

# 结论

希望这能让您对 web 应用程序中实时通信的一些可用选项有一个很好的了解。

对于简单的特性，比如通知示例，我认为 SSE 是一个不错的选择。它相当健壮，并为您提供了可用于错误处理的有用属性。

缺点是，对于这样一个小功能，您需要更多的后端逻辑。如果您觉得后端逻辑是不必要的或者可能变得太复杂，那么就使用长轮询。

尽管在这个简单的例子中，WebSockets 可能看起来有些多余，但是它并没有使用很多代码，并且很容易理解。如果你打算增加更复杂的实时功能，比如聊天，WebSockets 是你想要使用的技术类型。

也就是说，您可能会遇到与代理和负载平衡器相关的问题。Socket.io(一个基于 WebSockets 构建的库),它抽象了许多挑战，并通过回退选项(到长轮询)增加了健壮性。

您可以在此处找到演示的回购:

[](https://github.com/MikeZ77/notifications-demo) [## Mike z77/通知-演示

### 这个演示的应用程序是一个使用 React 和 Node.js/Express 服务器的简单通知系统。使用独特的…

github.com](https://github.com/MikeZ77/notifications-demo) 

*更多内容看*[***plain English . io***](http://plainenglish.io)