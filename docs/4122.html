<html>
<head>
<title>Code Splitting with React.lazy()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.lazy()进行代码拆分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/code-splitting-with-react-lazy-6c6b534c8028?source=collection_archive---------22-----------------------#2021-08-16">https://javascript.plainenglish.io/code-splitting-with-react-lazy-6c6b534c8028?source=collection_archive---------22-----------------------#2021-08-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1942aa03393b784c5071f53d0fc0af43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YAFD4j-Pu8w6OQj3"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lautaro Andreani</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bf26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我使用React已经两年多了，每天我都学到很多东西。我已经为大型项目——有太多事情正在进行的项目——和小型项目——使用了React，小型项目的功能数量有限，需要担心的事情较少。</p><p id="6211" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我决定建立我的投资组合时，React是我的第一选择。我的作品集也变成了一个沙箱，用来尝试和实验我在React中学到的新东西。这个想法过去是，现在仍然是，学习新概念→在投资组合中使用它们(通过一些重构)。如果它能正常工作，没有任何问题，那么它就会被部署。如果没有，那么就撤销所有的改变，学习更多更好的知识。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/cc25c52bd9b5bec1c6490fbc23d8aa4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ybVCZVGaLLdVQ6VSbV34XQ.png"/></div></div></figure><p id="0dc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，我想到在我的文件夹中实现代码分割的概念，使用React库中可用的<code class="fe ld le lf lg b">lazy()</code>函数。在开始讨论它的作用之前，让我快速地讨论一下捆绑。</p><blockquote class="lh li lj"><p id="ae7d" class="ka kb lk kc b kd ke kf kg kh ki kj kk ll km kn ko lm kq kr ks ln ku kv kw kx ig bi translated">捆绑是跟随导入的文件并将它们合并成单个文件的过程:一个“捆绑包”。然后，这个包可以包含在网页上，一次加载整个应用程序。React官方网站。</p></blockquote><p id="2fa9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，捆绑就是获取项目的所有代码并从中生成一个文件。这意味着项目越大，包的大小就越大，这会增加网站/web应用程序的下载/加载时间。这就是代码分割的用武之地。</p><p id="bf3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们使用<code class="fe ld le lf lg b">lazy()</code>在React应用程序中动态导入组件，在构建/捆绑过程中，不是创建单个捆绑文件，而是创建多个更小的文件或块。现在，当我们访问页面时，完整的包并没有立即下载，这最终使得我们的应用程序的加载时间更快。这并不意味着我们编写更少的代码，而是我们的网站/网络应用程序为我们(或公众)提供服务的方式发生了永久性的改变。</p><p id="316b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，有几件事情一起工作，为了这个工作。用<code class="fe ld le lf lg b">lazy()</code>函数导入的组件需要用<code class="fe ld le lf lg b">&lt;Suspense&gt;</code>标签包装，并指定<code class="fe ld le lf lg b">fallback</code>属性。</p><p id="9967" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我们通常在React中导入组件的方式，对吗？</p><pre class="kz la lb lc gt lo lg lp lq aw lr bi"><span id="802e" class="ls lt in lg b gy lu lv l lw lx">import React from 'react</span><span id="6cd4" class="ls lt in lg b gy ly lv l lw lx">import ComponentA from './components/ComponentA'<br/>import ComponentB from './misc/ComponentB'</span></pre><p id="ea13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，这就是我们如何使用<code class="fe ld le lf lg b">lazy()</code>动态导入组件——也就是说，组件只在需要的时候才被加载(或者从完整的包中下载相应的代码块)。</p><pre class="kz la lb lc gt lo lg lp lq aw lr bi"><span id="6bbd" class="ls lt in lg b gy lu lv l lw lx">import React, { Suspense, lazy } from 'react'</span><span id="27ac" class="ls lt in lg b gy ly lv l lw lx">const ComponentA = lazy(() =&gt; import('./components/ComponentA'))<br/>const ComponentB = lazy(() =&gt; import('./misc/ComponentB'))</span></pre><p id="bc96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了让它现在工作，我们需要将ComponentA和ComponentB包装在一个<code class="fe ld le lf lg b">&lt;Suspense&gt;</code>标签中，并在<code class="fe ld le lf lg b">fallback</code>属性中提到一个后备UI。后备UI /组件是当我们的组件被下载时将显示的内容，它可以是另一个React组件或者像<code class="fe ld le lf lg b">&lt;div&gt;Loading…&lt;/div&gt;</code>一样简单的东西。如果您选择使用react组件，请记住不要动态导入它，否则它会违背作为后备的目的。</p><pre class="kz la lb lc gt lo lg lp lq aw lr bi"><span id="05f7" class="ls lt in lg b gy lu lv l lw lx">const Homepage = () =&gt; {<br/>    return (<br/>        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}<br/>            &lt;ComponentA /&gt;<br/>        &lt;/Suspense&gt;</span><span id="016c" class="ls lt in lg b gy ly lv l lw lx">        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}<br/>            &lt;ComponentB /&gt;<br/>        &lt;/Suspense&gt;<br/>    )<br/>}</span></pre><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/63d5584fed796400bbb50f275220124d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGfRJSvtwLiSnfVvVp5Bzg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">I am using a Spinner component as the fallback, which is why it is not dynamically imported.</figcaption></figure><p id="b001" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，我们成功地将我们的代码分割成更小的块，这些块将在应用程序/网站使用<code class="fe ld le lf lg b">npm run build</code>脚本捆绑后创建。对于较小的应用程序来说，加载组件所花的时间甚至可能很短，以至于回退UI永远不会出现。但是对于更大的应用程序，它肯定会出现。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f6a12d286a800211e07b630461eaf662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*jjVaLl8cCYYKI6Br6Mu-5A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">More the number of dynamic imports, more will be the chunks created at the end.</figcaption></figure><p id="b932" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章对你有帮助。我很感谢你的来访。如果我错过/搞砸了什么，请留下评论，我会尽快纠正。</p><p id="f177" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">干杯！</p><p id="ef49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">#我们一起学习#发展</p><p id="ffa4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lk">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lk">说白了就是</em> </strong> </a> <em class="lk">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。在我们的</em> <a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lk">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>