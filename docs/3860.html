<html>
<head>
<title>Why Axios is Preferable to Fetch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Axios更适合获取</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-switch-to-axios-instead-of-fetch-d80c3fe2f156?source=collection_archive---------5-----------------------#2021-08-03">https://javascript.plainenglish.io/why-switch-to-axios-instead-of-fetch-d80c3fe2f156?source=collection_archive---------5-----------------------#2021-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="48a8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Axios和Fetch之间的区别以及应该使用哪一个？</h2></div><p id="ec76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Axios是一个JavaScript库，用于从Node.js发出HTTP请求，或者从浏览器发出XMLHttpRequests，它支持JavaScript ES6自带的Promise API。它的另一个特点是。fetch()的优势在于它执行JSON数据的自动转换。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/9ee94c280755e6ff751d836fb2c82f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/0*jIu-EwDm6D3xWYOb.png"/></div></figure><h2 id="0996" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated"><strong class="ak"> Fetch() </strong></h2><p id="8fd3" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated"><code class="fe mh mi mj mk b">Fetch()</code>是获取API中JavaScript窗口对象方法的一部分。它是内置的。<code class="fe mh mi mj mk b">Fetch()</code>允许我们从API异步获取数据，无需安装任何额外的外部库。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/da2c7569cec0ab4f484614706d6113af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*wZwRr86qxF6ON53m.jpeg"/></div></figure><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="d755" class="lj lk iq mk b gy mq mr l ms mt">fetch(url)  <br/>.then((res) =&gt; {    <br/>  // handle response  <br/>})  <br/>.catch((error) =&gt; {    <br/>  // handle error  <br/>});</span></pre><p id="95fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">Fetch()</code>有几个参数</p><ul class=""><li id="8b47" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la mz na nb nc bi translated"><strong class="kh ir">网址— ( <em class="nd">必填</em> ) </strong></li><li id="cbfb" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><strong class="kh ir">选项— ( <em class="nd">可选</em> ) </strong></li></ul><p id="d0e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您的请求类型，您可以发送几个选项</p><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="8f3a" class="lj lk iq mk b gy mq mr l ms mt">- <strong class="mk ir">method</strong> - request type like POST, GET etc<br/>- <strong class="mk ir">headers</strong> - request headers<br/>- <strong class="mk ir">body </strong>-<strong class="mk ir"> </strong>any payload you want to pass for POST/PUT requests</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="ab gu cl nj"><img src="../Images/2f79ee6a8c44f0555093b85d54d896c0.png" data-original-src="https://miro.medium.com/v2/format:webp/0*IvpXD3PWZKqI2x54.jpeg"/></div></figure><p id="064e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe mh mi mj mk b">Fetch()</code>没有将数据转换成类型，所以有几种方法可以根据预期的数据类型来处理响应。</p><ul class=""><li id="1dc9" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la mz na nb nc bi translated"><code class="fe mh mi mj mk b">response.json()</code>——<em class="nd">最常见的</em></li><li id="c9a1" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">response.text()</code></li><li id="30c6" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">response.blob()</code></li><li id="774c" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">response.formData()</code></li><li id="e038" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">response.arrayBuffer()</code></li></ul><p id="bbc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的例子</p><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="7f52" class="lj lk iq mk b gy mq mr l ms mt">const url = "http://api.com"<br/>const data = { <br/>    firstName: "Sumeet", <br/>    lastName:"Bhalla", <br/>    age: 30 <br/>  }</span><span id="09c9" class="lj lk iq mk b gy nk mr l ms mt">fetch(url, {  <br/>  method: "POST",  <br/>  headers: {    "Content-Type": "application/json",  },  <br/>  body: JSON.stringify(data),<br/>})  <br/>.then((response) =&gt; response.json())<br/>.then((data) =&gt; console.log(data))<br/>.catch((error) =&gt; console.log(error));</span></pre><h2 id="e832" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated"><strong class="ak"> Axios </strong></h2><p id="a590" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated"><code class="fe mh mi mj mk b">Axios</code>是一个JavaScript库，用于从Node或XMLHttpRequest或浏览器发出HTTP请求。作为一个现代化的库，它基于Promise API。</p><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="eae7" class="lj lk iq mk b gy mq mr l ms mt">axios.get(url)  <br/>.then((response) =&gt; console.log(response))  <br/>.catch((error) =&gt; console.log(error));</span></pre><p id="aa97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">Axios</code>也有几个参数(<a class="ae nl" href="https://github.com/axios/axios#request-config" rel="noopener ugc nofollow" target="_blank">更多细节</a>)—</p><ul class=""><li id="c1d2" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la mz na nb nc bi translated"><code class="fe mh mi mj mk b">url — </code> <strong class="kh ir"> ( <em class="nd">强制</em> ) </strong></li><li id="816c" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">baseUrl</code></li><li id="801c" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">params</code></li><li id="b846" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">auth</code></li><li id="f5a5" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">headers</code></li><li id="dbb9" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">responseType</code></li><li id="ab75" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">data</code></li></ul><p id="379f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为响应，Axios返回一个承诺，该承诺将通过响应对象或错误对象来解决。在响应对象中，有以下值:</p><ul class=""><li id="1772" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la mz na nb nc bi translated"><code class="fe mh mi mj mk b">data</code> : <strong class="kh ir"> </strong>实际响应体</li><li id="9d1b" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">status</code>:呼叫的HTTP状态码，如<code class="fe mh mi mj mk b">200</code>或<code class="fe mh mi mj mk b">404</code></li><li id="64f3" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">statusText</code> : HTTP状态为文本消息</li><li id="f486" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">headers</code>:与请求中相同</li><li id="1a61" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">config</code>:请求配置</li><li id="5df5" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated"><code class="fe mh mi mj mk b">request</code> : XMLHttpRequest (XHR)对象</li></ul><p id="c6d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下示例</p><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="4781" class="lj lk iq mk b gy mq mr l ms mt">axios({  <br/>  url: "http://api.com",  <br/>  method: "POST",  <br/>  header: {    <br/>    "Content-Type": "application/json",  <br/>  },  <br/>  data: { <br/>    firstName: "Sumeet", <br/>    lastName:"Bhalla", <br/>    age: 30 <br/>  },<br/>});</span></pre><h2 id="9fc8" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated"><strong class="ak"> Axios vs Fetch() </strong></h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/55479ff6e6bca1d1ad325e044fe1378c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Bzv6w8ZEZfs9efo0.jpg"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk"><a class="ae nl" href="https://blog.openreplay.com/fetch-vs-axios-which-is-the-best-library-for-making-http-requests" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><p id="3910" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 1 — </strong> <strong class="kh ir">简洁的代码</strong> —因为<code class="fe mh mi mj mk b">Fetch()</code>使用了响应的body属性，并且响应数据是字符串化的，所以你需要2个承诺来将数据转换成JSON或其他类型，然后才能使用它。<code class="fe mh mi mj mk b">Axios</code>默认情况下这样做，并在单个响应中返回JSON中的数据。</p><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="e3ca" class="lj lk iq mk b gy mq mr l ms mt">fetch(url)  <br/>.then((response) =&gt; response.json())<br/>.then((data) =&gt; console.log(data))<br/>.catch((error) =&gt; console.log(error));</span><span id="0f5f" class="lj lk iq mk b gy nk mr l ms mt">==== vs ====</span><span id="bf69" class="lj lk iq mk b gy nk mr l ms mt">axios.get(url)    <br/>.then((response)=&gt;console.log(response))    .catch((error)=&gt;console.log(error))</span></pre><p id="0246" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2 —在<code class="fe mh mi mj mk b">Fetch()</code>中，您将URL作为参数传递，而在<code class="fe mh mi mj mk b">Axios</code>中，您将它作为选项传递。</p><p id="47a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 3 —错误处理</strong> = &gt;在<code class="fe mh mi mj mk b">Fetch()</code>中，您将需要检查响应状态，而不管响应类型如何，因为只有当请求以某种方式被拒绝时，Fetch()承诺才会被拒绝，否则您需要验证响应类型，然后从那时起抛出错误。它不会抛出网络错误等，所以你需要手动检查。</p><p id="2028" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mh mi mj mk b">Axios</code>中，处理错误非常容易，因为Axios会抛出网络错误。如果出现类似<code class="fe mh mi mj mk b">404</code>的不良响应，承诺将被拒绝，并返回一个错误，可以很容易地检查该错误，以确定错误的类型。</p><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="73b0" class="lj lk iq mk b gy mq mr l ms mt">fetch('url')    <br/>.then((response)=&gt;{        <br/>  if(!response.ok){            <br/>    throw Error (response.statusText);        <br/>  }        <br/>  return response.json();    <br/>})    <br/>.then((data)=&gt;console.log(data))    .catch((error)=&gt;console.log(error))</span><span id="2097" class="lj lk iq mk b gy nk mr l ms mt">==== vs ====</span><span id="de3e" class="lj lk iq mk b gy nk mr l ms mt">axios.get('url')    <br/>.then((response)=&gt; console.log(response))    <br/>.catch((error)=&gt;{        <br/>  if(error.response){        <br/>      console.log(error.response.data);    //not in 2xx range     <br/>  } else if (error.request){                 <br/>    console.log(error.request);        //no response received<br/>  } else {                  <br/>    console.log(error.message);      // Any other Error  <br/>  }    <br/>})</span></pre><p id="c5b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4 — <code class="fe mh mi mj mk b">Axios</code>又能保护你了<a class="ae nl" href="https://www.netsparker.com/blog/web-security/csrf-cross-site-request-forgery/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">跨站请求伪造(CSRF) </strong> </a></p><p id="b874" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 5 —超时</strong> —在<code class="fe mh mi mj mk b">Fetch()</code>请求中设置超时稍微麻烦一些，因为您需要显式标识<em class="nd"> AbortController </em>接口，然后使用signal属性来处理它。</p><p id="5e9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而在<code class="fe mh mi mj mk b">Axios</code>中，您可以直接使用config对象中的timeout属性。</p><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="fd83" class="lj lk iq mk b gy mq mr l ms mt">const controller = new AbortController();<br/>const signal = controller.signal;<br/>const options = {  method: 'GET',  signal: signal};  <br/>const timeoutId = setTimeout(() =&gt; controller.abort(), 3000); </span><span id="beae" class="lj lk iq mk b gy nk mr l ms mt">fetch('/userData', options)  <br/>.then((response) =&gt; response.json())<br/>.then((data) =&gt; console.log(data))<br/>.catch(error =&gt; console.error('timeout exceeded'));</span><span id="914a" class="lj lk iq mk b gy nk mr l ms mt">==== vs ====</span><span id="8347" class="lj lk iq mk b gy nk mr l ms mt">axios.get({<br/>  method: 'get',    <br/>  url: '/userData',    <br/>  timeout: 3000,    // 3 seconds timeout    <br/>})    <br/>.then((response)=&gt; console.log(response))    <br/>.catch((error)=&gt;{                    <br/>    console.error('timeout exceeded')<br/>  }    <br/>})</span></pre><p id="ebd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 6 — </strong> <strong class="kh ir">并发请求</strong> —如果您想使用<code class="fe mh mi mj mk b">Fetch()</code>并行运行多个请求，您可以使用Promise.all()。类似地，<code class="fe mh mi mj mk b">Axios</code>提供了一种方法，使用Axios.all用更少的代码行做同样的事情，然后使用spread操作符将响应分割成单独的对象。</p><pre class="lc ld le lf gt mm mk mn mo aw mp bi"><span id="cf3d" class="lj lk iq mk b gy mq mr l ms mt">Promise.all([    <br/>  fetch('https://mywebsite.com/user/getInfo'),   <br/>  fetch('https://mywebsite.com/user/getFriendList')])<br/>.then(async([res1, res2]) =&gt; {  <br/>  const userInfo= await res1.json();  <br/>  const userFriendList= await res2.json();  <br/>  console.log(userInfo);  <br/>  console.log(userFriendList);<br/>})<br/>.catch(error =&gt; {  console.log(error);});</span><span id="bc0c" class="lj lk iq mk b gy nk mr l ms mt">==== vs ====</span><span id="65ab" class="lj lk iq mk b gy nk mr l ms mt">axios.all([  <br/>  axios.get('https://mywebsite.com/user/getInfo'),   <br/>  axios.get('https://mywebsite.com/user/getFriendList')])<br/>.then(axios.spread((obj1, obj2) =&gt; {  <br/>  // Both requests are now complete  <br/>  console.log(obj1.data);  <br/>  console.log(obj2.data);<br/>}));</span></pre><p id="1784" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 7 —上传和下载进度</strong> — <code class="fe mh mi mj mk b">Fetch()</code>允许您使用<code class="fe mh mi mj mk b">response.body</code>属性中的一个<code class="fe mh mi mj mk b">ReadableStream</code>对象来监控下载进度。它逐块提供主体数据，并允许您及时计算消耗了多少数据。然而，<code class="fe mh mi mj mk b">Fetch()</code>没有给你任何方法来监控你的上传。！！</p><p id="1eac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">Axios</code>另一方面，提供了一种监控上传和下载的方式。您可以使用<a class="ae nl" href="https://github.com/rikmms/progress-bar-4-axios/" rel="noopener ugc nofollow" target="_blank"> Axios进度条</a>来监控下载，使用<em class="nd">onuploadpress</em>config属性来监控上传状态。</p><p id="5610" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 8—向后兼容</strong> — <code class="fe mh mi mj mk b">Fetch()</code>仅支持Chrome 42+，Safari 10.1+，Firefox 39+，Edge 14+。甚至像IE11这样的老浏览器也可以毫无问题地运行<code class="fe mh mi mj mk b">Axios</code>。如果您正在创建一个需要更广泛兼容性的应用程序，这可能很重要。</p><h2 id="2173" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated"><strong class="ak">结论</strong></h2><p id="03bd" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">希望这能给你一些指导，告诉你为什么应该尝试并尽可能切换到Axios，以及如何利用它的所有特性。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e2eba51a2cc5f4bfae8548335cb11f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*cATzr0lDmYkgfgme.jpg"/></div></figure><h2 id="e122" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated"><strong class="ak">伟大的阅读</strong></h2><ul class=""><li id="addc" class="mu mv iq kh b ki mc kl md ko nw ks nx kw ny la mz na nb nc bi translated">https://better programming . pub/why-JavaScript-developers-should-prefere-axios-over-fetch-294 b28 a 96 e2c</li><li id="60b8" class="mu mv iq kh b ki ne kl nf ko ng ks nh kw ni la mz na nb nc bi translated">https://medium . com/@ the Jason file/fetch-vs-axios-js-for-making-http-requests-2b 261 CD D3 af 5</li></ul></div></div>    
</body>
</html>