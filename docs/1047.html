<html>
<head>
<title>Exploring Dynamic Imports in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Next.js中的动态导入</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/exploring-next-js-dynamic-import-ccb28a03e7f9?source=collection_archive---------2-----------------------#2021-03-05">https://javascript.plainenglish.io/exploring-next-js-dynamic-import-ccb28a03e7f9?source=collection_archive---------2-----------------------#2021-03-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8d0d869de912d195db35e2348d90638f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*3m2GEa8GVeQ2q7Y1itVBZg.png"/></div></div></figure><h1 id="419d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为什么要做动态导入</h1><p id="b95e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">现在我们使用像webpack这样的工具来捆绑我们的JavaScript，它把我们所有的JavaScript放到一个bundle.js文件中。它节省了我们许多工作。但问题是，随着现代网站变得越来越复杂，这个文件可能会很大。当浏览器处理这个巨大的bundle.js文件时，加载时间可能会长到足以赶走用户。当用户对一个网站来说就是一切的时候，我们绝对不希望这样的事情发生。</p><p id="60d4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为了避免这种情况发生，我们希望单独加载模块。当页面第一次渲染时，所有的模块同时被加载，不管是否需要。现在，我们希望在实际需要的时候加载模块。这叫做代码分解。通过动态导入，我们可以很容易地将代码分割应用到我们的项目中。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="992c" class="jv jw in bd jx jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks bi translated">JavaScript解决方案</h1><p id="57d6" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">一般来说，我们导入如下模块:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f8c3" class="mr jw in mn b gy ms mt l mu mv">Import Sample from ‘./Sample’</span></pre><p id="0a8b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这是静态导入。然而，从ES6开始，关键字“import”开始通过调用返回承诺的函数来支持动态导入。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="dc47" class="mr jw in mn b gy ms mt l mu mv">import(‘./Sample’).then(( Sample )=&gt;{ });</span></pre><p id="4ed3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">它还支持关键字await。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4d06" class="mr jw in mn b gy ms mt l mu mv">let Sample = await import(‘./Sample’);</span></pre><p id="63e4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果您正在使用Create React App或Next.js，该功能将立即可用。但对于那些配置了自己的项目的人来说却不是这样。他们必须按照webpack的官方指南配置更多的东西。</p><div class="mw mx gp gr my mz"><a href="https://webpack.js.org/guides/code-splitting/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">代码分割| webpack</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">提示本指南扩展了入门指南中提供的示例。请确保您至少熟悉…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">webpack.js.org</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jt mz"/></div></div></a></div></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="51a9" class="jv jw in bd jx jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks bi translated">反应溶液</h1><p id="b1e2" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">由于这个功能不够强大，React为我们提供了其他的解决方案:React.lazy和悬念。挺好学的。首先，我们在React.lazy()中调用一个函数，并在其中进行动态导入。然后我们将React.lazy()赋给一个变量。就这样，组件已经导入并准备好进行渲染了。那么这就是我们需要悬念的时候了。我们用悬念来包装这个组件。它提供了一个后备道具。我们传递给fallback prop的内容将在等待组件导入时呈现。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">React.lazy and Suspense</figcaption></figure><p id="34c0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这些都是很棒特性，但是SSR(服务器端渲染)不具备。React官方推荐可加载组件作为SSR(服务器端渲染)解决方案。你可以在GitHub上查一下。</p><div class="mw mx gp gr my mz"><a href="https://github.com/gregberge/loadable-components" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">gregberge/可加载组件</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">React代码分割变得简单。在没有压力的情况下减少你的包裹尺寸，✂️ ✨.npm install @loadable/component参见…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nu l nk nl nm ni nn jt mz"/></div></div></a></div></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="1ebb" class="jv jw in bd jx jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks bi translated">Next.js解决方案</h1><p id="0f43" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们终于说到重点了。Next.js为我们提供了“next/dynamic ”,解决了我们上面提到的所有问题。它甚至可以做得更多。</p><p id="4b32" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">基本用法就像我们对import()所做的那样。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">next/dynamic</figcaption></figure><p id="cd1f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">它还提供了一个类似我们刚刚在上面介绍的React悬念的功能。将“加载”组件添加到dynamic()中。当加载组件时，它呈现消息。把你想展示的东西传到‘加载’里就行了。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">next/dynamic with loading</figcaption></figure><p id="e0f7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这些都是用SSR(服务器端渲染)完成的。太棒了，省了我们很多工作。但是如果我们不想用SSR(服务器端渲染)做动态导入呢？其实这种情况经常发生。当我们想使用来自npm的包时。我们首先下载它，然后我们必须从这个包中导入模块到我们的组件中。您可能会得到一个错误:“窗口未定义”，如下所示:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ffa55d2c049dc99524bfbdceef6acc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*gz2Li5jUgPd-3NMGhvrO8Q.png"/></div></figure><p id="bcb3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这是因为窗口对象只在浏览器中可用。它不存在于服务器端。并且有很多包使用了window对象。为了避免这个错误，我们不应该使用SSR(服务器端渲染)进行动态导入。要关闭它，我们所要做的就是在dynamic()中添加一个简单的对象。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">next/dynamic without ssr</figcaption></figure><p id="5758" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">顺便说一下，Next.js支持JavaScript的import()。你可以像我们不使用Next.js一样使用它。不同的是在Next.js中，它也可以使用SSR(服务器端渲染)。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="5cab" class="jv jw in bd jx jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks bi translated">结论</h1><p id="dcd6" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">有了“next/dynamic ”,我们可以在所有情况下处理动态导入。如果您正在React项目中使用Next.js，并且还不知道它，那么您最好跟上！</p></div></div>    
</body>
</html>