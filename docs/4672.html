<html>
<head>
<title>The Saga of Async JavaScript: Thunks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JavaScript的传奇:Thunks</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-saga-of-async-javascript-thunks-3606f7de0123?source=collection_archive---------10-----------------------#2021-09-17">https://javascript.plainenglish.io/the-saga-of-async-javascript-thunks-3606f7de0123?source=collection_archive---------10-----------------------#2021-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0995a27251d9b01f48994fe4aeed385c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4JE7RqExp8bhOYjQPnmpg.jpeg"/></div></div></figure><h1 id="6dd5" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="5b4e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">上次我们谈到了<a class="ae lr" href="https://medium.com/@romansarder/the-saga-of-async-javascript-callbacks-6f56b3490f4d" rel="noopener">回调</a>——一种看似容易理解的模式。我们今天要讨论的概念是进化的下一步，自然会扩展回调的能力。它还为我们带来了一个有趣的异步编程解决方案，最重要的是，它改变了我们的思维模式，迫使我们从不同的角度看待事物。这一次我想为你提供一个关于什么是<strong class="kv io">思维方式</strong>的全面解释，以及它们如何帮助你更好地组织我们的代码。</p><h1 id="44f3" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">那是什么鬼东西？</h1><p id="4269" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">说真的，我希望知道为什么有人会用这个名字。但是玩笑归玩笑，thunks在某些时候让我想知道我是如何在不知道JavaScript有多强大的情况下走了这么远。从同步的角度来看，thunk本质上是一个<strong class="kv io">函数</strong>,它可以返回一些值，并且不需要额外的输入。就这么简单。许多使用React的人可能知道一个非常棒的简单的库，叫做<a class="ae lr" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>，顾名思义，它是基于thunks的。但稍后会详细介绍。现在，让我们看一个同步thunk的简单例子:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="65bf" class="mb jw in lx b gy mc md l me mf">function superCalculation() {<br/>    return 9999 + 9999<br/>}</span><span id="8126" class="mb jw in lx b gy mg md l me mf">const outFirstThunk = function () {<br/>    return superCalculation()<br/>}</span><span id="b592" class="mb jw in lx b gy mg md l me mf">const sum = thunk() // 19998</span></pre><p id="937b" class="pw-post-body-paragraph kt ku in kv b kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq ig bi translated">这里我们有一个名为<code class="fe mm mn mo lx b">ourFirstThunk</code>的thunk，它的值是一个<strong class="kv io">函数</strong>，当它被调用时，它总是返回相同的值——out<code class="fe mm mn mo lx b">superCalculation</code>的结果。</p><h1 id="3039" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">我们关心的部分</h1><p id="cd1a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">重要的是，这个thunk已经成为某个特定状态的包装器。在这种情况下，这是一个潜在的昂贵操作的结果。想象自己在老式胶片上拍摄一个美丽的瞬间。电影本身就是你的思维，被捕捉的瞬间是被包裹的状态。我们现在可以在我们的应用程序中传递这个“电影”,当我们想要提取状态时，我们只需通过调用thunk来“开发电影”并获取值。我们传递的不是状态本身，而是值的一个<strong class="kv io">表示</strong>。模式允许我们方便地隐藏底层计算的细节，并提供一个公共接口。我们还设法<strong class="kv io">延迟</strong>计算，直到我们真正需要它，现在有可能将这个操作注入到我们代码的不同部分。这也就是所谓的<strong class="kv io">懒铛</strong>。</p><h1 id="b9bb" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">进行异步</h1><p id="b7e2" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">当您考虑异步应用程序时，事情开始变得非常有趣。那么，如何描述异步thunk呢？在很大程度上，是一样的。这个函数不需要任何参数来完成它的任务<strong class="kv io">，除了回调的</strong>。有趣的是，尽管回调模式有很多缺陷，但它还是在这里找到了用武之地。标准的同步实现没有考虑时间因素，我们已经看到回调能够很好地处理“未来值处理”。为什么不在这里也使用它呢？让我们将前面的例子扩展到异步thunk:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="637a" class="mb jw in lx b gy mc md l me mf">function superCalculationAsync (callback) {<br/>    setTimeout(() =&gt; {<br/>        callback(9999 + 9999)<br/>    }, 1000)<br/>}</span><span id="9c82" class="mb jw in lx b gy mg md l me mf">const thunk = function (callback) {<br/>    superCalculationAsync(callback)<br/>}</span><span id="64b3" class="mb jw in lx b gy mg md l me mf">thunk((result) =&gt; {<br/>    console.log(result) // 19998<br/>})</span></pre><p id="0e0a" class="pw-post-body-paragraph kt ku in kv b kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq ig bi translated">我们现在有了一个<code class="fe mm mn mo lx b">superCalculationAsync</code>函数，它通过使用<code class="fe mm mn mo lx b">setTimeout</code>实用程序来模拟异步行为。然后我们创建一个<code class="fe mm mn mo lx b">thunk</code>，它是一个接受回调的函数。这个回调被传递给<code class="fe mm mn mo lx b">superCalculationAsync</code>函数来处理操作的结果。总体概念保持不变，除了回调开始帮助我们处理事情。尽管如此，我们最终还是得到了一个方便的容器，只要我们传递回调，就可以在应用程序的任何地方使用它。</p><h1 id="bdf4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">懒惰vs渴望</h1><p id="c625" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们设法将我们的同步thunk转换成异步thunk。你会注意到我们的<code class="fe mm mn mo lx b">superCalculationAsync</code>本身并没有马上执行。这是一个<strong class="kv io">懒thunk </strong>。在提供回调之前，不会进行任何计算。让我们试着把这个例子再玩一会儿，想办法把它重写为<strong class="kv io">eager thunk</strong>——它会尝试提前运行计算，并尝试立即给你返回结果。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c50b" class="mb jw in lx b gy mc md l me mf">const thunk = (function () {<br/>    let thunkResult;<br/>    let handleResult;<br/>    superCalculationAsync(function (result) {<br/>        if (handleResult) {<br/>            handleResult(thunkResult) // result is not ready<br/>        } else {<br/>            thunkResult = result // result is ready<br/>        }<br/>    })</span><span id="49ea" class="mb jw in lx b gy mg md l me mf">    return function runThunk (callback) {<br/>        if (thunkResult) {<br/>            callback(thunkResult) // result is ready<br/>        } else {<br/>            handleResult = callback // result is not ready<br/>        }<br/>    }<br/>})()</span></pre><p id="12dd" class="pw-post-body-paragraph kt ku in kv b kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq ig bi translated">在开发一个热切的思维时，你偶然发现了两种可能的情况，你需要处理。第一种情况是在内部操作完成后调用【thunk，我们可以安全地返回结果。这是比较容易的部分，和我们到目前为止所做的没有什么不同。第二种情况需要考虑——调用了thunk，但操作仍在进行。我们必须以某种方式连接我们程序的这两个分支。所提供的解决方案绝不是性能最好和最优雅的，但它完成了工作。这里，我们以两个互为镜像的<code class="fe mm mn mo lx b">if</code>语句结束。如果底层计算已经完成，我们就用底层计算的结果调用用户的回调。如果没有，我们就直接注入提供的回调。客户端代码甚至不知道thunk可能需要时间来完成。</p><h1 id="5b33" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">权力来自抽象</h1><p id="4709" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">重点是——我们可以用回调重写同步示例，然后统一处理异步和同步thunk。通过这样做，我们可以通过这种规范化有效地将自己从处理代码中的时间因素中解放出来。我们不必知道或关心价值是如何传递给我们的。我们第一次调用thunk并传递回调时，它可能会做大量的工作来获得预期的响应。这可能是一个AJAX请求，一个CPU密集型任务，或者任何其他可能需要一段时间的疯狂的事情。但是当我们第二次调用它的时候，它可能会决定记住返回值，然后马上给我们。使用我们的thunks的客户端代码不需要担心内部实现，只要它能够以相同的方式处理同步和异步代码。这是一大进步。我们已经制作了一个独立于时间的数据包装器。我们知道时间可能是我们的应用程序中最复杂的事情。</p><h1 id="a713" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">真实世界的例子</h1><p id="f677" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我已经提到过<strong class="kv io">redux-thunk</strong>——redux维护者自己推荐用来处理redux应用中副作用的库。它为我们提供了一个中间件，该中间件期望一个thunk或一个简单的动作对象，并相应地处理它们。它非常简单，创建中间件的主要函数只有9行代码。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="7f26" class="mb jw in lx b gy mc md l me mf">function createThunkMiddleware(extraArgument) {<br/>  return ({ dispatch, getState }) =&gt; (next) =&gt; (action) =&gt; {<br/>    if (typeof action === 'function') {<br/>      return action(dispatch, getState, extraArgument);<br/>    }</span><span id="5b37" class="mb jw in lx b gy mg md l me mf">    return next(action);<br/>  };<br/>}</span></pre><p id="871c" class="pw-post-body-paragraph kt ku in kv b kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq ig bi translated">代码非常简单，很可能根本不需要任何解释。这在概念上与我们上面讨论的thunk是一样的。唯一的区别是传递给我们的thunk的几个额外的参数— <code class="fe mm mn mo lx b">dispatch</code>和<code class="fe mm mn mo lx b">getState</code>，其中<code class="fe mm mn mo lx b">dispatch</code>起到了回调的作用。</p><h1 id="8008" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">简单</h1><p id="a148" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">thunks的伟大之处在于这只是纯JavaScript代码。不涉及任何库或框架。通过采用一种不同的思维方式，我们成功地消除了一种令人困惑和难以处理的东西——时间。让它沉一会儿。精神负担消失了，取而代之的是一个代表我们价值的公共界面。另外，我们能够毫无问题地在代码中重用这些表示。但是有一个新发现。</p><h1 id="0daa" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">可怕的控制反转问题</h1><p id="e206" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我将立即发表这一声明——thunks不是为解决控制反转问题而创建的。在异步编程的世界里，这并不是什么灵丹妙药。在上面的例子中，<strong class="kv io"> redux-thunk </strong>库没有办法确保它们的<code class="fe mm mn mo lx b">dispatch</code>函数会被适当地调用。我们的例子也是如此。thunks有效地做的是，他们正在为<strong class="kv io">承诺</strong>打下基础。如果你对承诺很熟悉，我敢肯定你们大多数人都很熟悉，你会注意到thunks本质上是没有花哨API的承诺。是的，我们得到了统一处理、可重用性和封装计算细节的良好包装的好处，但控制反转问题仍有待解决。此外，因为thunks仍然在幕后使用回调，所以您很容易得到与<strong class="kv io">回调地狱</strong>非常相似的东西。如果我们试图表达几个相互之间有时间依赖关系的操作，这就变得很清楚了。假设我们有一个<code class="fe mm mn mo lx b">makeThunk</code>实用程序，它接受一个函数和一个传递给它的参数列表。为了简单起见，我不会提供任何实现细节，你可以在互联网上找到很多。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="d020" class="mb jw in lx b gy mc md l me mf">const readFirst = makeThunk(readFile, 'first file');<br/>const readSecond = makeThunk(readFile, 'second file');<br/>const readThird = makeThunk(readFile, 'third file');</span><span id="aa46" class="mb jw in lx b gy mg md l me mf">readFirst((firstFileContents) =&gt; {<br/>    console.log('first file contents', firstFileContents);<br/>    readSecond((secondFileContents) =&gt; {<br/>        console.log('second file contents', secondFileContents)<br/>        readThird((thirdFileContents) =&gt; {<br/>            console.log('third file contents', thirdFileContents)<br/>        })<br/>    })<br/>})</span></pre><p id="f730" class="pw-post-body-paragraph kt ku in kv b kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq ig bi translated">我们首先预先创建三个thunks供以后使用。理解<code class="fe mm mn mo lx b">readFile</code>直到我们通过回调才被执行是很重要的。在接下来的几行中，我们嵌套了thunks执行以获得正确的操作顺序。规则<strong class="kv io">时态依赖===嵌套</strong>在这里也适用。</p><h1 id="6dc7" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结尾部分</h1><p id="21fd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Thunks对改进我们的JavaScript代码大有帮助。与回调相比，这种模式带来了几个重要的好处，并且仍然设法做到了轻量级和简单。最棒的是，这一切都可以通过函数的操作来实现。</p><p id="f2b1" class="pw-post-body-paragraph kt ku in kv b kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq ig bi translated">正如我们在redux-thunk库示例中看到的，thunk仅用9行代码就可以在Redux a childsplay中处理副作用。经过一些实践，您可以想象这种模式的功能远远超出了React &amp; Redux应用程序的范围。Thunks在意识形态上领先于<strong class="kv io"> Promise </strong>模式，这两者非常相似。虽然thunks没有成功解决控制反转的问题，但是我们将看到这个模式的概念核心是如何通过添加新的API最终成功的。感谢您的阅读，请关注更新，下次我们将讨论<a class="ae lr" href="https://medium.com/@romansarder/the-saga-of-async-javascript-promises-8ddef2477c24" rel="noopener">承诺</a>。</p><p id="345d" class="pw-post-body-paragraph kt ku in kv b kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq ig bi translated"><em class="mp">更多内容看</em> <a class="ae lr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mp">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>