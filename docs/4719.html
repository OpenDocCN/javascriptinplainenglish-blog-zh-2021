<html>
<head>
<title>Demystifying Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开JavaScript中函数的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-functions-in-javascript-791d7d66e72f?source=collection_archive---------13-----------------------#2021-09-20">https://javascript.plainenglish.io/demystifying-functions-in-javascript-791d7d66e72f?source=collection_archive---------13-----------------------#2021-09-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/86eaf468553695a4ea2508b4caa4e5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Pl10Gz3MGuxjC__ofIu4g.png"/></div></div></figure><p id="2a7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数本身就是小程序，有助于提高代码的可读性和可重用性。函数有自己的执行上下文，函数中的所有代码都在上下文中执行。与全局执行上下文类似，函数执行上下文也由两个阶段组成——创建阶段和执行阶段。创建阶段是将创建arguments对象的阶段，该变量被声明并引用到全局对象，最后创建函数中的所有其他变量并将其存储到内存堆中。执行阶段是将所有变量分配给它们的实际值并执行函数的阶段。现在让我们试着借助一个例子深入挖掘一下。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="41cb" class="lc ld in ky b gy le lf l lg lh"><br/>function printIcecreamFlavour(flavour) {<br/> console.log(`Icecream ${flavour}:`);<br/>}<br/>function calculateCost(price, numberOfIcecreams) {<br/> return price * numberOfIcecreams;<br/>}<br/>printIcecreamFlavour(“Vanilla”);<br/>var price = calculateCost(10, 5);<br/>console.log(price);</span></pre><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/b88570009db61b05eec2ae135e934fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ncyun1v8_mMqhS4PnaK6RQ.jpeg"/></div></div></figure><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/929deea441e75b5ca7ef335364928fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQ607rbzeEPhR6PzY7FgGg.jpeg"/></div></div></figure><p id="8bbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当Javascript引擎运行上述代码时，首先它会创建一个全局执行上下文。全局执行上下文包含两部分——一部分包含整个代码，另一部分是存储变量和函数的地方。创建执行上下文之后，创建阶段就开始了。在此阶段，函数<strong class="jx io"> printIcecreamFlavour </strong>和<strong class="jx io"> calculateCost </strong>以各自的函数代码作为其值存储在内存中，而变量<strong class="jx io"> price </strong>将以<strong class="jx io"> undefined </strong>作为其默认值存储在内存中。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/3000ec74ffe8bc4abb89d932ea3b31dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LakkOcxFdPfYbpU08kY9ng.jpeg"/></div></div></figure><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ll"><img src="../Images/bc5cd98a5a5719750c9c46147eed8ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eolHDbw8Ho04niW0oEdvOA.jpeg"/></div></div></figure><p id="6bb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在创建阶段之后不久，执行阶段就开始了。在这个阶段，JS引擎逐行执行代码。一旦遇到第8行，它就检查这个标识符是否存在于本地内存中，如果存在，它将获取值，在本例中是整个函数代码，并执行它。JS引擎一执行该函数，就会将该函数推送到调用堆栈，并为函数<strong class="jx io"> printIcecreamFlavour </strong>创建一个新的执行上下文。这个执行上下文将包含两个部分——一部分是函数代码所在的位置，另一部分是所有变量和函数的存储位置。在创建执行上下文后不久，创建阶段就开始了。在这个阶段，将创建arguments对象，包含传递给函数的值。因为没有更多的声明语句，所以它进入执行阶段。在这个阶段，当它遇到<strong class="jx io">console . log(` icecream $ { flavor } `)</strong>时，它将首先检查本地内存中是否存在一个名为console的标识符。因为它不在本地内存中，所以它将移动到全局执行上下文并检查其内存。这基于Javascript中定义的范围规则。如果你很难理解JS中scope是如何工作的，你可以查看一下<a class="ae lm" href="https://themallu.dev/demystifying-scopes" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">这个</strong> </a>。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/9b57686a9320d687d9d2f4967b279dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dz-PvVkQL0_8KeOWnsoXBA.jpeg"/></div></div></figure><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/09201edbc018cc137617ff65fcf79cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34Q3p_hILKYZLkI6-yKYKQ.jpeg"/></div></div></figure><p id="5d16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当它找到对象<strong class="jx io">控制台</strong>时，它将搜索该对象中定义的方法<strong class="jx io">日志</strong>，并以类似的方式执行<strong class="jx io">日志</strong>函数，其中日志函数被推送到调用堆栈，并为<strong class="jx io">日志</strong>函数创建一个新的执行上下文。执行该功能时，<strong class="jx io">冰淇淋香草</strong>将打印在控制台上。执行后不久，<strong class="jx io">日志</strong>的执行上下文将被删除并从调用堆栈中弹出。由于<strong class="jx io">printicecreamflavor</strong>函数中已经没有要执行的语句，因此<strong class="jx io">printicecreamflavor</strong>的执行上下文将被删除并从调用堆栈中弹出。现在，当前执行上下文将成为全局执行上下文，JS引擎将继续执行下一条语句。当它遇到语句<strong class="jx io">var price = calculated cost(10，5) </strong>时，它将首先检查标识符<strong class="jx io"> price </strong>。当它存在时，它将指定<strong class="jx io">计算成本</strong>的值。由于<strong class="jx io">计算成本</strong>是一个函数，在<strong class="jx io">计算成本</strong>函数完成后，价格将只被赋值。当<strong class="jx io"> calculateCost </strong>被执行时，该函数将被推送到调用栈，并为<strong class="jx io"> calculateCost </strong>创建一个新的执行上下文。与前面的功能相似，首先开始创建阶段。在这个阶段，将创建arguments对象，它将包含作为参数传递给函数的price和<strong class="jx io"> numberOfIcecreams </strong>的值。由于不再有声明语句，它开始执行阶段。在这个阶段，JS引擎开始逐行执行代码。一旦遇到语句<strong class="jx io">return price * numberOfIcecreams</strong>，它将从内存中获取<strong class="jx io"> price </strong>和<strong class="jx io"> numbeOfIcecreams </strong>的值，对表达式<strong class="jx io">price * numberOfIcecreams</strong>求值并返回该值，然后将该值赋给变量<strong class="jx io"> price </strong>。</p><p id="6848" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于函数中不再有要执行的语句，函数执行上下文将被销毁，并且<strong class="jx io"> calculateCost </strong>函数将从调用堆栈中弹出，其中全局执行上下文将是当前执行上下文。现在JS引擎继续下一条语句，这条语句将是<strong class="jx io"> console.log(price) </strong>。在执行此操作时，它将从内存中获取<strong class="jx io">价格</strong>的值，并将其打印到控制台。由于没有更多要执行的语句，JS引擎将销毁全局执行上下文，并从调用堆栈中弹出它。</p><p id="7b22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么函数表达式呢？？？。好吧，我很快会在我的下一篇博客《坚持住》中对此进行详细报道。在那之前，如果你觉得这篇文章有用，请展示你的爱，并通过你的社交媒体与你的同伴分享，他们可以最大限度地利用这篇文章。随时联系我在<a class="ae lm" href="https://twitter.com/ajojm" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Twitter </strong> </a>，<a class="ae lm" href="https://www.linkedin.com/in/ajojohn/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> LinkedIn </strong> </a>或者邮箱。</p><p id="7a78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">直到我们再次见面，<strong class="jx io">Mallu Dev</strong>结束👋干杯！🥂</p><p id="51b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lo">更多内容请看</em><a class="ae lm" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lo">plain English . io</em></strong></a></p></div></div>    
</body>
</html>