<html>
<head>
<title>Unit Test Vue Apps with Vue Test Utils — Transitions and Plugin Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue测试工具对Vue应用进行单元测试——过渡和插件测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-test-vue-apps-with-vue-test-utils-transitions-and-plugin-tests-4875f50aa810?source=collection_archive---------13-----------------------#2021-01-20">https://javascript.plainenglish.io/unit-test-vue-apps-with-vue-test-utils-transitions-and-plugin-tests-4875f50aa810?source=collection_archive---------13-----------------------#2021-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0139b03ddf45d3ac41d1d08edfc5c2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*haiNc4mOwfu1omBs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@craftedbygc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Green Chameleon</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="efe8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了Vue Test Utils库，我们可以轻松地为Vue应用编写和运行单元测试。</p><p id="0eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用Vue Test Utils库编写单元测试。</p><h1 id="3155" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模仿过渡</h1><p id="17ad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以像测试其他组件一样测试带有转换的组件。</p><p id="bb13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所要做的就是将反应属性设置为我们想要的值。</p><p id="3378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="19b0" class="mn lc iq mj b gy mo mp l mq mr">import { mount } from '@vue/test-utils'</span><span id="09e9" class="mn lc iq mj b gy ms mp l mq mr">const Foo = {<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;transition&gt;<br/>        &lt;p v-if="show"&gt;Foo&lt;/p&gt;<br/>      &lt;/transition&gt;<br/>    &lt;/div&gt;<br/>  `,<br/>  data() {<br/>    return {<br/>      show: true<br/>    }<br/>  }<br/>}</span><span id="2518" class="mn lc iq mj b gy ms mp l mq mr">describe('Foo', () =&gt; {<br/>  it('renders bar for foo prop', async () =&gt; {<br/>    const wrapper = mount(Foo)<br/>    expect(wrapper.text()).toMatch(/Foo/)<br/>    await wrapper.setData({<br/>      show: false<br/>    })<br/>    expect(wrapper.text()).not.toMatch(/Foo/)<br/>  })<br/>})</span></pre><p id="5aa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe mt mu mv mj b">mount</code>来安装<code class="fe mt mu mv mj b">Foo</code>组件。</p><p id="fef8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们检查在将<code class="fe mt mu mv mj b">show</code>反应属性设置为<code class="fe mt mu mv mj b">false</code>之前显示了什么。</p><p id="de2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe mt mu mv mj b">setData</code>将<code class="fe mt mu mv mj b">show</code>设置为<code class="fe mt mu mv mj b">false</code>。</p><p id="cfe6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们检查显示内容的模式，用<code class="fe mt mu mv mj b">text</code>方法返回呈现的文本，用<code class="fe mt mu mv mj b">toMatch</code>方法检查内容是否匹配给定的正则表达式模式。</p><p id="444e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用<code class="fe mt mu mv mj b">transitionStub</code>助手来存根化转换:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="07e7" class="mn lc iq mj b gy mo mp l mq mr">import { mount } from '@vue/test-utils'</span><span id="8618" class="mn lc iq mj b gy ms mp l mq mr">const Foo = {<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;transition&gt;<br/>        &lt;p v-if="show"&gt;Foo&lt;/p&gt;<br/>      &lt;/transition&gt;<br/>    &lt;/div&gt;<br/>  `,<br/>  data() {<br/>    return {<br/>      show: true<br/>    }<br/>  }<br/>}</span><span id="a16c" class="mn lc iq mj b gy ms mp l mq mr">const transitionStub = () =&gt; ({<br/>  render(h) {<br/>    return this.$options._renderChildren<br/>  }<br/>})</span><span id="7767" class="mn lc iq mj b gy ms mp l mq mr">describe('Foo', () =&gt; {<br/>  it('renders bar for foo prop', async () =&gt; {<br/>    const wrapper = mount(Foo, {<br/>      stubs: {<br/>        transition: transitionStub()<br/>      }<br/>    })<br/>    expect(wrapper.text()).toMatch(/Foo/)<br/>    await wrapper.setData({<br/>      show: false<br/>    })<br/>    expect(wrapper.text()).not.toMatch(/Foo/)<br/>  })<br/>})</span></pre><p id="5bb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">transitionStub</code>只是一个用<code class="fe mt mu mv mj b">render</code>方法返回一个对象来模拟渲染过渡的函数。</p><p id="d82c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们安装组件并在安装时设置电抗属性值，我们也可以避免使用<code class="fe mt mu mv mj b">setData</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="64ef" class="mn lc iq mj b gy mo mp l mq mr">import { mount } from '@vue/test-utils'</span><span id="56e2" class="mn lc iq mj b gy ms mp l mq mr">const Foo = {<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;transition&gt;<br/>        &lt;p v-if="show"&gt;Foo&lt;/p&gt;<br/>      &lt;/transition&gt;<br/>    &lt;/div&gt;<br/>  `,<br/>  data() {<br/>    return {<br/>      show: true<br/>    }<br/>  }<br/>}</span><span id="fe8a" class="mn lc iq mj b gy ms mp l mq mr">test('should render Foo', async () =&gt; {<br/>  const wrapper = mount(Foo, {<br/>    data() {<br/>      return {<br/>        show: true<br/>      }<br/>    }<br/>  })</span><span id="d1f2" class="mn lc iq mj b gy ms mp l mq mr">  expect(wrapper.text()).toMatch(/Foo/)<br/>})</span><span id="4edd" class="mn lc iq mj b gy ms mp l mq mr">test('should not render Foo', async () =&gt; {<br/>  const wrapper = mount(Foo, {<br/>    data() {<br/>      return {<br/>        show: false<br/>      }<br/>    }<br/>  })</span><span id="d7a1" class="mn lc iq mj b gy ms mp l mq mr">  expect(wrapper.text()).not.toMatch(/Foo/)<br/>})</span></pre><h1 id="1cbf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">应用全局插件和混合插件</h1><p id="4d9c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们想要应用全局插件，那么我们必须使用<code class="fe mt mu mv mj b">createLocalVue</code>来返回一个<code class="fe mt mu mv mj b">Vue</code>构造函数的模拟版本。</p><p id="527d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以控制何时应用全局插件。</p><p id="47cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="201e" class="mn lc iq mj b gy mo mp l mq mr">import { createLocalVue, mount } from '@vue/test-utils'</span><span id="0809" class="mn lc iq mj b gy ms mp l mq mr">const localVue = createLocalVue()</span><span id="a3e3" class="mn lc iq mj b gy ms mp l mq mr">const MyPlugin = {};<br/>MyPlugin.install = function (Vue, options) {<br/>  Vue.prototype.fooMethod = function () {<br/>    this.foo = 'bar';<br/>  }<br/>}</span><span id="1a11" class="mn lc iq mj b gy ms mp l mq mr">localVue.use(MyPlugin);<br/>const Foo = {<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;p&gt;{{foo}}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  `,<br/>  data() {<br/>    return {<br/>      foo: ''<br/>    }<br/>  }<br/>}</span><span id="46ac" class="mn lc iq mj b gy ms mp l mq mr">test('should render bar', async () =&gt; {<br/>  const wrapper = mount(Foo, {<br/>    localVue<br/>  })<br/>  await wrapper.vm.fooMethod();<br/>  expect(wrapper.text()).toContain('bar')<br/>})</span></pre><p id="6c2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe mt mu mv mj b">createLocalVue</code>函数来创建<code class="fe mt mu mv mj b">Vue</code>构造函数的模拟版本。</p><p id="d026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过定义<code class="fe mt mu mv mj b">MyPlugin</code>对象并将<code class="fe mt mu mv mj b">fooMethod</code>实例方法添加到插件中来创建插件。</p><p id="4991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们调用<code class="fe mt mu mv mj b">localVue.use(MyPlugin)</code>，这样我们就可以用<code class="fe mt mu mv mj b">mount</code>组件<code class="fe mt mu mv mj b">Foo</code>添加我们的插件。</p><p id="4135" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的测试中，我们在第二个参数<code class="fe mt mu mv mj b">mount</code>的对象中设置了<code class="fe mt mu mv mj b">localVue</code>属性。</p><p id="cf90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用我们的<code class="fe mt mu mv mj b">fooMethod</code>来运行测试。</p><p id="327e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们检查文本是否被渲染。</p><h1 id="2650" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="39d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以模仿过渡和插件，这样我们就可以用插件做测试。</p><p id="7e90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>