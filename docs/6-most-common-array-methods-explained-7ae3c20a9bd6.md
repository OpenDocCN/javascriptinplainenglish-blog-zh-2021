# 解释了 6 种最常见的数组方法

> 原文：<https://javascript.plainenglish.io/6-most-common-array-methods-explained-7ae3c20a9bd6?source=collection_archive---------12----------------------->

![](img/6777aee5ff78616e55fe8f2066c80141.png)

Photo by [Todd Quackenbush](https://unsplash.com/@toddquackenbush?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

数组是 Javascript 中一些最常用的数据结构。为了使用它们，语言提供了许多不同的方法来以更简单的方式转换、提炼和确定数组。

为正确的工作选择正确的方法并不容易，尤其是当你刚刚开始编码的时候。本指南指出了 6 种最常用的方法，并试图帮助您了解应该为您指明哪种数组方法可以最有效地帮助您解决当前问题的模式。

# 数组。地图

这是目前为止我最常用的数组方法。当您有一个条目列表，并且您想要的结果是一个新列表，其长度与先前的列表相同，只应用了一些转换，或者只返回了一些值时，可以使用这种方法。

这个方法将为我们遍历一个数组，并用数组中当前正在迭代的索引处的值调用我们的回调函数。当映射完成时，此函数调用返回的将是当前索引位置的最终值。

一个非常常见的例子，将两个属性链接在一起，在一个数组中的所有对象上创建一个属性。假设您有一些从后端获取的用户数据，并且需要将这些数据提供给某个 UI 框架/库中的一个组件，该组件需要对象上的一个`name`属性。这个属性实际上并不存储在后端，而是存储在名字和姓氏中。我们可以使用 map 快速遍历数组中的每一项，并添加 name 属性，它是另外两个属性的集合:

在前面的例子中，我们关心的是向原始数据添加一些东西。不要以为这是`Array.Map`唯一的工作方式。记住，无论你返回什么，都将成为那个索引位置的新值。假设我们有一个需求，我们需要来自用户的所有年龄的列表:

这里需要注意的一点是。在这两个例子中，我们将结果赋给一个变量。使用`Array.Map`操作不到位。换句话说，原始数组根本没有改变。这其实大部分时候都是好事。一般来说，最好不要改变 Javascript 中对象的原始引用，创建新引用有很多好处。如果您确实需要在原始参考上就地操作呢？这就引出了我们的下一个方法。

# 数组。为每一个

`Array.ForEach`可能是紧随其后的我发现自己使用的最常用的数组方法。对我来说，这非常类似于替换一个常规 for 循环。

本质上，你只是在一个数组上循环并调用一些回调函数。就像`Array.Map`一样，我们的回调是用数组中当前索引处的值来调用的。这里最大的区别是，如果我们操作一个传递给回调函数的对象(不总是对象，而是存储在数组中那个索引位置的任何对象)，我们就改变了原始引用。

我发现自己使用这种方法的情况是有意想要改变原始数组的引用或者模仿传统的 for 循环。在这种情况下，尽管使用索引值(作为第二个参数传递，可选地在回调函数中使用)并引用原始数组的`Array.Map`是可能的，但这将是一种反模式，我希望用`Array.ForEach`来代替。

在这里，我们有意想改变原来的参考。在过去我可能选择 for-of 循环或传统风格的 for-loop 时，我通常会使用这种方法。也就是说，有理由选择常规的传统 for 循环而不是`Array.ForEach`，所以不要认为一个优于另一个。需要指出的一个通常被忽视的区别是，你不能像传统的 for 循环一样跳出`Array.ForEach`。

# 数组。一些

`Array.Some`方法也非常有用。当您需要在数组中找到至少一个满足某些条件的项时，可以使用此方法。如果出现这种情况，即使只有一次，它也将返回 true。但是，如果该方法遍历数组中的所有项，并且没有满足给定条件的项，那么它将返回 false。

这个有很多用途，但是我想在这里强调一个。例如，假设我们有一个用户正在向 UI 输入数据。我们正在管理输入的值，以及它是否出错。我们可以使用`Array.Some`快速遍历数据，检查是否有错误。

现在你可以看到这个`hasErrors`函数是如何决定表单的保存按钮的禁用或启用状态的。

# 数组。每个

`Array.Every`就像是`Array.Some`的姊妹方法。当使用这个方法时，它将遍历你的数组，并调用你的回调函数，将数组中存储的值传入当前被遍历的索引处。不过，在这个方法中，只有当数组中的所有项都从回调函数返回 true 时，它才会返回 true。如果有一个返回 false，那么方法 as 将返回 false。我们可以用上面的例子来重写，用`Array.Every`为我们做同样的事情。

# 数组。过滤器

`Array.Filter`也是很常见的阵法。就像我们之前的所有方法一样，它将一个回调作为第一个参数，这个回调被调用并从当前正在迭代的数组中传递项目。根据此回调返回 true 还是 false，从最终返回的数组中保留或丢弃该项。False 将丢弃该项，true 将保留该项。

这是一个非可变的方法，它返回一个新的数组引用，而原始的数组引用保持不变。这就像上面提到的`Array.Map`，总的来说，是一件好事。这是知道何时使用的最明显的方法。当您当前拥有的阵列需要根据某种限定条件缩短长度时，就会出现这种情况。例如，如下所示，一个用户列表，我们只想使用当前客户端的列表。

这很简单但是很有效，我经常使用这种方法。

# 数组。减少

`Array.Reduce`是数组方法中最容易被误解和误用的一种。在我看来，这种方法应该谨慎使用，并且只在特定条件下使用。

很多次，我看到了这种误用，如果同样的操作可以用其他链接在一起的数组方法来完成，或者仅仅是其他数组方法，那么就应该使用它们。这样做的理由是`Array.Reduce`比一些更直接的迭代方法更难使用，更容易导致错误。您考虑使用`Array.Reduce`的全部原因是，您有一个数组，并且您希望遍历该数组并创建一个完全不同的数据结构。

两个常见的例子应该被称为是`Array.Reduce`的好例子，它们是从一个数组中创建一个数据的引用图，以防止不断地搜索对象，以及将一个数组中的数字相加为一个值。让我们看一下第一个例子:

现在我们可以调用 userMap[SOME_ID]并在常量时间内获取我们的用户对象。这是 reduce 的一个很好的用例。注意回调是如何被调用的。传递给回调函数的第一个参数实际上是由传递给`Array.Reduce`调用的第二个参数决定的。如果提供了第二个参数，就像这里一样，那么这将是传递给回调的第一个参数的起始值。这被称为累加器，在每次函数调用时，它必须被返回。这是`Array.Reduce`中最常见的 bug 来源。

如果没有提供第二个参数，那么累加器实际上将被设置为数组的第一个值，而不是从索引位置 0 开始，而是从索引位置 1 开始。对我的大脑来说，这不仅仅是预期的行为，直到你学会它。我实际上在没有这方面知识的情况下使用了`Array.Reduce`一段时间，但它实际上在对一组数字求和时非常有用，如下所示:

这段代码的关键是，`baseNumber`默认情况下没有使用`Array.Reduce`调用中的第二个参数进行设置，因此，第一个值(1)就是`baseNumber`的起始值，第一个函数调用实际上将从索引 1 开始。对一个数组求和来说，这是一个非常有用的技术。我们已经看到了两个关于`Array.Reduce`的好例子。我只想重申，这种方法存在一些潜在的混淆，我个人尽可能避免这种情况。很多时候我看到类似下面的东西:

这通常在两种情况下完成。在第一种情况下，开发人员看到最终解决方案是一个数组，所以他们从`Array.Map`开始，然后很快意识到最终结果不会有相同的长度，因此，我们必须转到`Array.Reduce`，因为我们没有包括所有结果，在最终列表中只包括当前客户端。这可以通过将两个数组方法(array。地图和数组。过滤器)。

如下所示，您可以简单地(顺序无关紧要)使用`Array.Map`迭代数组并应用名称转换。然后使用`Array.Filter`遍历数组并删除任何不是当前客户端的。代码实现见下文，但首先，让我们讨论高度相关的第二种情况。第二种情况实际上是看到上述解决方案的人，他认为在一个循环中的 reduce 中执行此操作有某种优化。我们必须记住 O 符号是如何度量的。

O(N)和 O(2N)之间是否存在某种性能优化？当然，2N 比 N 大，但是因为我们在讨论大 O 符号时去掉了常数，所以这里没有真正的区别。当执行一个循环来映射和一个循环来过滤和一个循环来减少时，最终，我们仍然在讨论 O(N)。这也是为什么一般情况下`Array.Reduce`没有太多不能通过结合其他方法简化的用例。如果是这种情况，我会考虑进行重构来移除 reduce，如下所示。

# 结论

到目前为止，您应该对在何种情况下使用哪种数组方法有了更好的了解。有时需要反复试验，对于特定的问题，哪一个是正确的并不是很明显。

这篇文章旨在给你一些提示，告诉你哪些情况应该是显而易见的选择。值得一提的是，除了 reduce 之外，许多函数都有相同的 API，它们接受一个回调函数，传入正在迭代的当前值，因此快速尝试许多不同的函数是一项简单的任务。关于运行时的复杂性和数组方法的使用，需要注意一点。在计算运行时复杂性时，很容易看到如下内容并出错。

请记住，所有这些数组方法都是 for 循环之上的抽象，嵌套它们与嵌套两个 for 循环没有什么不同。上面的代码运行时复杂度为 O(N ),但是在复杂的函数中这有时会被忽略。

*更多内容看*[*plain English . io*](http://plainenglish.io/)