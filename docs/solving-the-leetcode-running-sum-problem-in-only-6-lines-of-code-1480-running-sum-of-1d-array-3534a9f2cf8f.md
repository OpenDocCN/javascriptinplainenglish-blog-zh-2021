# 用 6 行代码解决累计和问题

> 原文：<https://javascript.plainenglish.io/solving-the-leetcode-running-sum-problem-in-only-6-lines-of-code-1480-running-sum-of-1d-array-3534a9f2cf8f?source=collection_archive---------3----------------------->

## Leetcode 1480。一维数组的运行总和

![](img/630b1cd27c39a5bcfc3fe7dc5da7cdb2.png)

本周我将重点介绍的算法是，在给定的数组中，当一个数字在另一个数字的顶部堆积时，创建一个数字的和。我什么意思？我们可以这样想:

这是我们的样本数组。我们称之为 nums: nums = [1，2，3，4]

我们希望算法的输出是[1，3，6，10]。

所发生的是，对于列出的每一个数字，它之前的数字被加到当前的数字，当然除了第一个数字保持不变。例如，1+2+3 等于 6。我将用 JavaScript 解决这个问题。

# 代码

首先，我们将使用 function 关键字并传入 nums，这是 Leetcode 要求我们使用的数组的名称。

```
function(nums) {
```

接下来，我们需要某种方法将我们的加法逻辑应用到我们的每个数字上，以给出我们最终输出数组中每个新数字的运行总和。为此，我们将使用 for 循环。但是要记住的关键是，我们要从第二个数字开始 for 循环，它是 1 的索引(假设 i = 1 ),因为数组中的第一个数字保持不变。在我们上面的例子中，整数 1 在最终答案中没有变化。

```
function(nums) {
    for(let i = 1 ; i < nums.length ; i++) {
```

要应用的逻辑将只使用下一行。这一行表示的是，对于数组中的每一个位置，用 nums[i]表示，该值将被赋给自身加上原始数组本身中的前一个数字。随着循环的进行，数字逐渐变大，直到循环修改完所有的数字。迷茫？下面我举个例子。

```
function(nums) {
    for(let i = 1 ; i < nums.length ; i++) {
      nums[i] = nums[i] + nums[i-1];
```

对于循环中的第一轮，nums[i]是 2，使用我们一开始的例子。它将被赋值给自身(= nums[1])，后面加一个空格，这就是减去索引的原因。在这种情况下，nums[i-1]的值是 1，因为 nums[i-1]将是 nums[0]。所以 2 + 1 是 3，它将代表数组中新的第二个值。现在我们的数组已经改变了，如下所示:nums = [1，3，3，4]。

在我们的循环中，下一轮的唯一区别是我们每次都从下一个数字开始。在下一轮比赛中，

```
nums[i] = nums[i] + nums[i-1]; 
```

会变成

```
3 = 3 + 3
```

这就给了我们 6 个变量来使我们的数组变成[1，3，6，4]。

总的来说，我们将下面的最后几行添加到前面的几行中，得到算法的其余部分。我们用 for 循环中的逻辑来改变我们的原始数组，所以在最后返回原始数组是有意义的；nums。

```
function(nums) {
    for(let i = 1 ; i < nums.length ; i++) {
      nums[i] = nums[i] + nums[i-1];
    }
     return nums;
}
```

这个算法简单地解释了我所能做的。希望这能带来一些清晰，帮助一些人。