<html>
<head>
<title>Advanced Type Composition with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带打字稿的高级排版</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-type-composition-with-typescript-c1f980c4239e?source=collection_archive---------5-----------------------#2021-06-06">https://javascript.plainenglish.io/advanced-type-composition-with-typescript-c1f980c4239e?source=collection_archive---------5-----------------------#2021-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7e16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用泛型扩展TypeScript类型很容易，这是非常动态的，但是它是不可重用的，并且我们经常以代码重复而告终。让我们探索如何用TypeScript动态扩展类型来避免这种情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63a252732751deb92bc58679bf556164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlHNeRpB-Y9AeHSx2TB_eA.jpeg"/></div></div></figure><p id="b3b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们先定义一些实体及其关系。</p><p id="1717" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有一个令牌实体，它有一个要约实体数组，要约实体有一个出价实体数组。</p><p id="6d86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以让我们为它们创建类型:</p><p id="df25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">// <em class="ku"> Token.ts </em></p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="68a9" class="la lb in kw b gy lc ld l le lf"><em class="ku">import </em>{ TokenStatus } <em class="ku">from </em>'../enums/TokenStatus';<br/><br/><em class="ku">export type Token </em>= {<br/>  id: <em class="ku">string</em>;<br/>  name: <em class="ku">string</em>;<br/>  amount: <em class="ku">string</em>;<br/>  metadata: <em class="ku">Record</em>&lt;<em class="ku">string</em>, <em class="ku">string</em>&gt;;<br/>  status: TokenStatus;<br/>  created_at: <em class="ku">string</em>;<br/>};</span></pre><p id="2184" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">// <em class="ku"> Offer.ts </em></p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="d372" class="la lb in kw b gy lc ld l le lf"><em class="ku">export type Offer </em>= {<br/>  id: <em class="ku">string</em>;<br/>  is_active: <em class="ku">boolean</em>;<br/>  ends_at: <em class="ku">string</em>;<br/>  created_at: <em class="ku">string</em>;<br/>  is_auction: <em class="ku">boolean</em>;<br/>};</span></pre><p id="4ade" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">// <em class="ku">投标文件</em></p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="2d51" class="la lb in kw b gy lc ld l le lf"><em class="ku">export type Bid </em>= {<br/>  id: <em class="ku">string</em>;<br/>  bided_on: <em class="ku">string</em>;<br/>  amount: number;<br/>  refunded: <em class="ku">boolean</em>;<br/>  bid_is_highest: <em class="ku">boolean</em>;<br/>};</span></pre><p id="1898" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将它们分开的原因是为了保持代码的整洁，但也是必要的，因为如果我们创建一个令牌，例如，该类型不包含offers，一般来说，作为复杂类型的offers不应该是令牌实体的基本类型的一部分。</p><h1 id="8ac2" class="lg lb in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">从基本类型中省略属性</strong></h1><p id="8a30" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">例如，如果我们想在代码中创建一个CreateTokenPayload类型，我们知道该类型没有令牌类型的<em class="ku"> id </em>和<em class="ku"> created_at </em>属性。所以姑且将<strong class="jm io"> <em class="ku">省略</em> </strong> <em class="ku"> </em>它们<em class="ku">。</em></p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="afbe" class="la lb in kw b gy lc ld l le lf"><em class="ku">export type </em>CreateTokenPayload<em class="ku"> </em>= Omit&lt;Token, 'id'|'created_at'&gt;</span></pre><p id="c573" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样。🚀</p><h1 id="8775" class="lg lb in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从基本类型中选取属性</h1><p id="0e6b" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">现在，如果创建令牌调用的响应只有<em class="ku"> id </em>和<em class="ku">状态</em>字段，那也很容易，让我们只需<strong class="jm io">选择</strong>字段。</p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="7632" class="la lb in kw b gy lc ld l le lf"><em class="ku">export type </em>CreateTokenResponse<em class="ku"> </em>= Omit&lt;Token, 'id'|'status'&gt;</span></pre><p id="b330" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样。🚀</p><p id="02a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但这不是这篇文章要讲的🤷‍♂️，这只是为了解释为什么我们要分开装箱。所以，让我们深入到作文。</p><p id="8531" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了向令牌类型添加“优惠”,我们需要扩展令牌类型。</p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="7d9e" class="la lb in kw b gy lc ld l le lf">export type TokenWithOffers = Token &amp; { offers: Offer[] }</span></pre><p id="ce19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单，但是…我们还需要报价类型中的“出价”。</p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="a38b" class="la lb in kw b gy lc ld l le lf">export type OfferWithBids = Offer &amp; { bids: Bid[] }<br/>export type TokenWithOffers = Token &amp; { offers: OfferWithBids[] }</span></pre><p id="868a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单，但是…有了这三种类型的事件，你可以注意到我们逻辑中的重复，它毕竟不是那么动态的。</p><h1 id="83f9" class="lg lb in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用输入类型组合util — <em class="mi"/></h1><p id="c5f8" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">目标是使接受<strong class="jm io">类型的<strong class="jm io"> util类型</strong>扩展，属性名</strong>保存添加的类型，组合<strong class="jm io">类型。</strong></p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="569a" class="la lb in kw b gy lc ld l le lf"><em class="ku">export type With</em>&lt;BaseType, ObjectKey <em class="ku">extends string</em>, ComposedType&gt; = BaseType &amp; { [k <em class="ku">in </em>ObjectKey]: ComposedType };</span></pre><p id="8442" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单又好。😌</p><p id="b958" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们来探索如何改善我们的<code class="fe mj mk ml kw b">TokenWithOffers</code>类型。</p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="c6ca" class="la lb in kw b gy lc ld l le lf"><em class="ku">export type TokenWithOffers </em>=<br/>  <em class="ku">With</em>&lt;<em class="ku">Token</em>, 'offers', <em class="ku">With</em>&lt;<em class="ku">Offer</em>, 'bids', <em class="ku">Bid</em>&gt;[]&gt;[]; // 😳 </span></pre><p id="d9d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它的伟大之处在于它可以用于多种用例。假设我们想在使用<code class="fe mj mk ml kw b">TokenWithOffers</code>类型时只给<code class="fe mj mk ml kw b">Token</code>类型添加一个名为<code class="fe mj mk ml kw b">isActive</code>的道具。</p><pre class="kj kk kl km gt kv kw kx ky aw kz bi"><span id="b713" class="la lb in kw b gy lc ld l le lf"><em class="ku">export type TokenWithOffers </em>=<br/>  <em class="ku">With</em>&lt;<br/>    With&lt;<em class="ku">Token, 'isActive', boolean&gt;</em>,<br/>    'offers', <br/>    <em class="ku">With</em>&lt;<em class="ku">Offer</em>, 'bids', <em class="ku">Bid</em>&gt;[]<br/>  &gt;[]; // 🤩 </span></pre><p id="f787" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，正如你所注意到的，我们使我们的代码可伸缩，并准备在未来扩展。👏</p><p id="7612" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku">快乐编码！</em></p><p id="b6a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku">更多内容请看</em><a class="ae mm" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ku">plain English . io</em></a></p></div></div>    
</body>
</html>