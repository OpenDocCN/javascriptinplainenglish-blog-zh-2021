<html>
<head>
<title>Copying Complex Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中复制复杂对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/copying-complex-objects-in-javascript-6f15aa6e0c17?source=collection_archive---------10-----------------------#2021-01-07">https://javascript.plainenglish.io/copying-complex-objects-in-javascript-6f15aa6e0c17?source=collection_archive---------10-----------------------#2021-01-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="aa09" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">克隆类实例和其他复杂类型</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d73c8d8b44f9818af8866b5d53f62872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUeL07gz4DbXxDTEeo-6-Q.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@tomma5588?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Francesco Tommasini</a> on <a class="ae ks" href="https://unsplash.com/s/photos/relfection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="e252" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">TL；博士；医生</h2><p id="bf85" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">使用<code class="fe mi mj mk ml b">Object.getOwnPropertyDescriptor</code>并遍历原型链。</p><p id="2aba" class="pw-post-body-paragraph lp lq in lr b ls mm jo lu lv mn jr lx lc mo lz ma lg mp mc md lk mq mf mg mh ig bi translated">有许多关于如何克隆对象的文章。今天，使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>通常是复制简单对象的首选方式。理解spread语法有一些限制是很重要的。</p><p id="511d" class="pw-post-body-paragraph lp lq in lr b ls mm jo lu lv mn jr lx lc mo lz ma lg mp mc md lk mq mf mg mh ig bi translated">主要缺点是不能复制访问器方法。<code class="fe mi mj mk ml b">Object.assign</code>也有同样的问题。在使用访问器方法的系统中，这不是可选的。第二个问题是方法不能被复制。为了创建类实例和其他复杂对象的深层副本，我们需要另一个解决方案。我创建了一个简单的复制方法来遍历继承链，你可以在这里查看<a class="ae ks" href="https://jsfiddle.net/bz3wh7nv/4/" rel="noopener ugc nofollow" target="_blank"/>。源代码如下。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1670" class="pw-post-body-paragraph lp lq in lr b ls mm jo lu lv mn jr lx lc mo lz ma lg mp mc md lk mq mf mg mh ig bi translated">在这个例子中，我使用<code class="fe mi mj mk ml b">Object.getOwnPropertyDescriptor</code>来获取所有属性，包括那些<strong class="lr io">而不是</strong> <a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" rel="noopener ugc nofollow" target="_blank">枚举</a>的属性。然后我们遍历继承链，重复这个过程。我们使用<code class="fe mi mj mk ml b">Object.defineProperty</code>添加特殊处理来克隆我们的访问器方法。这捕获了所有的变量、访问器和方法，产生了原始文件的完美副本！</p><blockquote class="mt mu mv"><p id="1bfe" class="lp lq mw lr b ls mm jo lu lv mn jr lx mx mo lz ma my mp mc md mz mq mf mg mh ig bi translated">注意:TypeScript不枚举访问器方法！</p></blockquote><p id="96e8" class="pw-post-body-paragraph lp lq in lr b ls mm jo lu lv mn jr lx lc mo lz ma lg mp mc md lk mq mf mg mh ig bi translated">在较新版本的TypeScript中，所有的访问器方法都是<a class="ae ks" href="https://github.com/microsoft/TypeScript/issues/38587" rel="noopener ugc nofollow" target="_blank">而不是</a>枚举的。这导致许多开发人员创建decorators作为临时的解决方法。它还破坏了几个依赖于能够自省对象的代码库，包括我的。当您想要获取一个对象的所有属性，甚至是那些没有被枚举的属性时，这种解决方案也是有用的。</p></div></div>    
</body>
</html>