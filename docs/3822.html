<html>
<head>
<title>Arrays vs LinkedList in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的数组与链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/arrays-vs-linkedlist-in-javascript-8c9e38578537?source=collection_archive---------3-----------------------#2021-08-01">https://javascript.plainenglish.io/arrays-vs-linkedlist-in-javascript-8c9e38578537?source=collection_archive---------3-----------------------#2021-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5b46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">处理元素列表是编程中很常见的问题。我们如何解决问题可能会产生影响，这取决于我们选择的解决方案。</p><p id="4768" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们将看到处理元素列表的两种不同的解决方案及其优缺点，以及我们在这两者之间进行选择时应该注意的要求(总是考虑JavaScript实现)</p><p id="ee8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先让我们了解每个解决方案。</p><h2 id="1e0a" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">数组</strong></h2><ul class=""><li id="dc01" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated">在JavaScript中，数组<em class="lm">总是动态的</em>，不管我们用固定的大小或元素初始化它们，我们总是会可以添加更多的元素并且大小会增加</li><li id="8bdd" class="lb lc in jm b jn ln jr lo jv lp jz lq kd lr kh li lj lk ll bi translated">每次数组大小改变时，内存中用于保存的空间可能需要改变，并且因为所有信息都应该保存在一起(内存中的连续插槽)，所以可能需要找到所有数组数据并将其移动到另一个空闲内存插槽中(如果这种情况发生得太频繁，可能会出现性能问题)</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/ee5a6adb73445b6d0ca6ed18f6550aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQrrUIG1YBIe0pObwUqHSA.png"/></div></div></figure><ul class=""><li id="204b" class="lb lc in jm b jn jo jr js jv me jz mf kd mg kh li lj lk ll bi translated">数组是用javascript构建的it数据结构，有很多有用的方法，并且易于处理</li><li id="93d6" class="lb lc in jm b jn ln jr lo jv lp jz lq kd lr kh li lj lk ll bi translated">直接访问数组的任何位置都很简单快捷</li><li id="c18a" class="lb lc in jm b jn ln jr lo jv lp jz lq kd lr kh li lj lk ll bi translated">从其中读取添加新元素的元素更“便宜”(因为前面提到的内存分配)</li></ul><h2 id="3359" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">链表</strong></h2><ul class=""><li id="bba3" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated">链表只是一个具有固定结构的对象，它允许对象相互链接</li><li id="88f3" class="lb lc in jm b jn ln jr lo jv lp jz lq kd lr kh li lj lk ll bi translated">JavaScript中没有内置的链表，但是有很多例子</li><li id="77e0" class="lb lc in jm b jn ln jr lo jv lp jz lq kd lr kh li lj lk ll bi translated">在内存中，每个对象保存在可用内存的不同部分，对象之间通过指针关联。对于单链表，链接是从一个元素到另一个元素，而在双链表中，两个元素都有指向彼此的指针</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mh"><img src="../Images/c940480debc2c0e4c2ac9b70fb3e0952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ya21x78otGPuBYkz2kYZQ.png"/></div></div></figure><ul class=""><li id="3c1d" class="lb lc in jm b jn jo jr js jv me jz mf kd mg kh li lj lk ll bi translated">添加读取元素的新元素更便宜。不可能直接访问一个元素，总是需要在列表中循环搜索想要的元素</li></ul><p id="a7de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，要决定哪种结构使用最重要的功能，我们需要考虑:</p><ul class=""><li id="2358" class="lb lc in jm b jn jo jr js jv me jz mf kd mg kh li lj lk ll bi translated">元素添加的频率是多少</li><li id="0eae" class="lb lc in jm b jn ln jr lo jv lp jz lq kd lr kh li lj lk ll bi translated">我们怎样才能接触到这些元素？总是最后/第一？总是所有元素？或者我们是否需要过于频繁地访问具体的元素？</li></ul><p id="97a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想向你们展示用一个数组和一个链表解决的同样的问题。栈的经典问题(队列在这个例子中也是有效的)。</p><p id="3198" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是使用数组保存数据的解决方案:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a883" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是使用对象链表的解决方案:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="fdf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一个更容易实现，更容易阅读，也许更容易理解。我们需要明确的是，如果堆栈增加太多太频繁，我们可能会面临性能问题，甚至一些内存问题。</p><p id="a2a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总的来说，我们总是在顶部添加和删除元素，链表似乎更适合这个问题。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><p id="271c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有其他结构，如映射或集合，也可以用来保存数据，而不是数组来解决不同类型的问题。内部实现将是从性能角度决定它们是否对我们的问题有效的关键。</p><p id="0ac6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你觉得这个话题怎么样？有什么需要改进或补充的吗？请随时在评论中告诉我！</p><p id="3e00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lm">更多内容看</em><a class="ae mr" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>