<html>
<head>
<title>Create a CSS Pixel Art Generator with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript创建CSS像素艺术生成器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-css-pixel-art-generator-with-javascript-584889a221bf?source=collection_archive---------12-----------------------#2021-11-23">https://javascript.plainenglish.io/create-a-css-pixel-art-generator-with-javascript-584889a221bf?source=collection_archive---------12-----------------------#2021-11-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/eef89d2de34cd8d4af6eee0e4b53e543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoSHjQA2Y3U1hi-ncWYCpA.png"/></div></div></figure><p id="b348" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我<a class="ae kt" href="https://pokecoder.hashnode.dev/making-pixel-art-with-pure-css" rel="noopener ugc nofollow" target="_blank">读了一篇文章</a>概述了如何创建<strong class="jx io"> CSS像素艺术</strong>与框阴影。我认为这是一个非常酷的想法——我认为用JavaScript制作一个生成器让你使用这种效果从浏览器创建可导出的像素艺术会很有趣。<strong class="jx io"> </strong> <a class="ae kt" href="https://fjolt.com/article/css-pixel-art-generator" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">在Codepen demo </strong> </a> <strong class="jx io"> </strong>(如下图)中，你可以画出你的像素作品，然后点击“生成CSS”得到你的CSS中的像素艺术，你可以将它复制到你的网页中。</p><h1 id="b4ca" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">它是如何工作的</h1><p id="a7f2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">如文章中的<a class="ae kt" href="https://pokecoder.hashnode.dev/making-pixel-art-with-pure-css" rel="noopener ugc nofollow" target="_blank">所述，我们使用放大的方框阴影作为屏幕上的像素。我们可以将这些放大或缩小，使我们的像素艺术更大或更小。</a></p><p id="9634" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于每个方框阴影都是1px乘以1px，我们可以创建一个像素艺术作品，其中每个“像素”都是1x1。如果我们希望每个像素为20x20，我们只需使用<code class="fe lx ly lz ma b">transform</code>将其缩放20x:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="a6be" class="mj kv in ma b gy mk ml l mm mn">transform: scale(20);</span></pre><p id="786c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了达到我们想要的效果，我们使用Javascript创建一个UI，让我们画出我们的像素艺术作品。<a class="ae kt" href="https://codepen.io/smpnjn/pen/OJjGgPM" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">UI的代码可以在codepen这里</strong> </a>找到，或者如果你喜欢，可以在下面找到:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="02c6" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">JavaScript概述</h1><p id="ec40" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了让这一切工作，我们必须使用JavaScript。第一步是使用一个简单的循环生成像素网格:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="a139" class="mj kv in ma b gy mk ml l mm mn">let config = {<br/>    width: 40,<br/>    height: 40,<br/>    color: 'white',<br/>    drawing: true,<br/>    eraser: false<br/>}</span><span id="a92e" class="mj kv in ma b gy mq ml l mm mn">let events = {<br/>    mousedown: false<br/>}</span><span id="3e62" class="mj kv in ma b gy mq ml l mm mn">document.getElementById('pixel-art-area').style.width = `calc(${(0.825 * config.width)}rem + ${(config.height * 2)}px)`;<br/>document.getElementById('pixel-art-area').style.height = `calc(${(0.825 * config.height)}rem + ${(config.width * 2)}px)`;<br/>document.getElementById('pixel-art-options').style.width = `calc(${(0.825 * config.width)}rem + ${(config.height * 2)}px)`;</span><span id="2e4f" class="mj kv in ma b gy mq ml l mm mn">for(let i = 0; i &lt; config.width; ++i) {<br/>    for(let j = 0; j &lt; config.height; ++j) {<br/>        let createEl = document.createElement('div');<br/>        createEl.classList.add('pixel');<br/>        createEl.setAttribute('data-x-coordinate', j);<br/>        createEl.setAttribute('data-y-coordinate', i);<br/>        document.getElementById('pixel-art-area').appendChild(createEl);<br/>    }<br/>}</span></pre><p id="2b87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这最终创建了大约40x40像素，或1600个新的HTML元素。对于更大的实验，你可以很容易地放大它，但是40x40也可以。</p><h1 id="289b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">跟踪用户的鼠标移动</h1><p id="2b97" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">然后，我们可以用三个事件来跟踪用户的鼠标移动:<strong class="jx io"> pointerdown </strong>、<strong class="jx io"> pointermove </strong>和<strong class="jx io"> pointerup </strong>。<strong class="jx io">因为我们必须将此应用于所有像素</strong>，我们使用一个循环来循环每个像素以添加事件。</p><p id="16e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，如果用户继续按住，我们可以使用<strong class="jx io"> e.target </strong>来跟踪他们正在哪个像素上，这将返回当前悬停在<strong class="jx io"> pointermove </strong>上的HTML实体。如果他们使用橡皮擦，我们可以在这里考虑。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="167c" class="mj kv in ma b gy mk ml l mm mn">document.querySelectorAll('.pixel').forEach(function(item) {<br/>    item.addEventListener('pointerdown', function(e) {<br/>        if(config.eraser === true) {<br/>            item.setAttribute('data-color', null);<br/>            item.style.background = `#101532`;<br/>        } else {<br/>            item.setAttribute('data-color', config.color);<br/>            item.style.background = `${config.color}`;<br/>        }<br/>        events.mousedown = true;<br/>    });<br/>});</span><span id="364f" class="mj kv in ma b gy mq ml l mm mn">document.getElementById('pixel-art-area').addEventListener('pointermove', function(e) {<br/>    if(config.drawing === true &amp;&amp; events.mousedown === true || config.eraser === true &amp;&amp; events.mousedown === true) {<br/>        if(e.target.matches('.pixel')) {<br/>            if(config.eraser === true) {<br/>                e.target.setAttribute('data-color', null);<br/>                e.target.style.background = `#101532`;<br/>            } else {<br/>                e.target.setAttribute('data-color', config.color);<br/>                e.target.style.background = `${config.color}`;<br/>            }<br/>        }<br/>    }<br/>});</span><span id="e2f3" class="mj kv in ma b gy mq ml l mm mn">document.body.addEventListener('pointerup', function(e) {<br/>    events.mousedown = false;<br/>});</span></pre><p id="6bb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们在颜色和橡皮擦上设置了一些事件，这样我们就可以跟踪选择了什么工具和颜色:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="c842" class="mj kv in ma b gy mk ml l mm mn">[ 'click', 'input' ].forEach(function(item) {<br/>    document.querySelector('.color-picker').addEventListener(item, function() {<br/>        config.color = this.value;<br/>        document.querySelectorAll('.colors &gt; div').forEach(function(i) {<br/>            i.classList.remove('current');<br/>        });<br/>        this.classList.add('current');<br/>        config.eraser = false;<br/>        document.querySelector('.eraser').classList.remove('current');<br/>    });<br/>});<br/><br/>document.querySelectorAll('.colors &gt; div').forEach(function(item) {<br/>    item.addEventListener('click', function(e) {<br/>        document.querySelector('.color-picker').classList.remove('current');<br/>        document.querySelectorAll('.colors &gt; div').forEach(function(i) {<br/>            i.classList.remove('current');<br/>        })<br/>        item.classList.add('current');<br/>        config.eraser = false;<br/>        config.color = `${item.getAttribute('data-color')}`;<br/>        document.querySelector('.eraser').classList.remove('current');<br/>    })<br/>});</span></pre><h1 id="8bb1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="dc20" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当我看到最初的文章时，我认为只用CSS创建像素艺术真的很酷——但创建一种导出像素艺术创作的方法会更酷——而且只用一点点JavaScript也没那么难。以下是一些有用的源代码链接:</p><ul class=""><li id="0108" class="mr ms in jx b jy jz kc kd kg mt kk mu ko mv ks mw mx my mz bi translated"><a class="ae kt" href="https://pokecoder.hashnode.dev/making-pixel-art-with-pure-css" rel="noopener ugc nofollow" target="_blank">关于CSS像素艺术的文章</a></li><li id="89ec" class="mr ms in jx b jy na kc nb kg nc kk nd ko ne ks mw mx my mz bi translated"><a class="ae kt" href="https://codepen.io/smpnjn/pen/OJjGgPM" rel="noopener ugc nofollow" target="_blank">代码笔上的源代码</a></li><li id="78f5" class="mr ms in jx b jy na kc nb kg nc kk nd ko ne ks mw mx my mz bi translated"><a class="ae kt" href="https://github.com/smpnjn/CSS-Pixel-Art" rel="noopener ugc nofollow" target="_blank">Github上的源代码</a></li></ul><p id="1b1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nf">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nf">plain English . io</em></a><em class="nf">。在这里注册我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">免费周报</em> </a> <em class="nf">。</em></p></div></div>    
</body>
</html>