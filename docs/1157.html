<html>
<head>
<title>7 Concepts You Should Know As a JavaScript Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript开发人员应该知道的7个概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-concepts-you-should-know-as-a-javascript-developer-f406597319ab?source=collection_archive---------0-----------------------#2021-03-11">https://javascript.plainenglish.io/7-concepts-you-should-know-as-a-javascript-developer-f406597319ab?source=collection_archive---------0-----------------------#2021-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3957" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在下一个JavaScript项目中使用的基本概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a643ebccd9c050b61acf43c12af389a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHfxF1pr4LCuR928nnnBVA.png"/></div></div></figure><h2 id="92ec" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.设计模式</h2><blockquote class="ln"><p id="27d7" class="lo lp iq bd lq lr ls lt lu lv lw lx dk translated">模式是一种可重用的解决方案，可以应用于软件工程中常见的问题</p></blockquote><p id="bb02" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg la mh mi mj le mk ml mm li mn mo mp lx ij bi translated">使用好的设计模式可以防止你的代码库变得异常庞大。尤其是在团队工作的情况下，每个人都必须熟悉一个设计模式，因为它可以在以良好的方式处理项目的同时带来更好的沟通。在JavaScript中，有很多设计模式，但是你不需要学习所有的模式就能成为一个精通的人。</p><p id="bf1a" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><strong class="ma ir"> <em class="mv">下面是JavaScript中一些已知的设计模式</em> </strong></p><ul class=""><li id="3fb9" class="mw mx iq ma b mb mq me mr la my le mz li na lx nb nc nd ne bi translated"><strong class="ma ir">构造器模式:</strong>在使用<strong class="ma ir"> </strong> <em class="mv">面向对象设计时非常有用的模式</em> <strong class="ma ir"> <em class="mv">，</em> </strong>这种设计的一个主要缺点是它不支持继承，因为不同对象之间的属性总是重复的。</li><li id="a7d7" class="mw mx iq ma b mb nf me ng la nh le ni li nj lx nb nc nd ne bi translated"><strong class="ma ir">原型模式:</strong>由于我们在对象集中有一个属性要在<em class="mv">构造器模式中重新定义，</em>为了解决这个问题，我们在<strong class="ma ir">原型模式中的原型函数内部创建了一个函数。但是这也有它的缺点，因为你无法控制财产是<strong class="ma ir">私有</strong>还是<strong class="ma ir">公有</strong>。</strong></li><li id="a141" class="mw mx iq ma b mb nf me ng la nh le ni li nj lx nb nc nd ne bi translated"><strong class="ma ir">模块模式:</strong>对<em class="mv">原型模式</em>的改进，这里我们可以设置不同类型的修饰符，具有公开重命名功能的灵活性。缺点是您无法从外部环境覆盖创建的函数。</li><li id="3509" class="mw mx iq ma b mb nf me ng la nh le ni li nj lx nb nc nd ne bi translated">单体模式:一种非常实用的设计模式，用于构建可靠的应用程序。<em class="mv">例如，</em>假设您的应用程序必须建立到数据库的连接，而您不想在已经创建数据库实例的情况下创建它&amp;您只需要在另一个实例关闭或停止正在进行的实例时创建一个新实例。<strong class="ma ir">这种模式确保了实例只被创建一次&amp;，唯一的缺点是难以测试</strong>。</li></ul></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="4f8b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.JavaScript引擎</h2><p id="9739" class="pw-post-body-paragraph ly lz iq ma b mb nr jr md me ns ju mg la nt mi mj le nu ml mm li nv mo mp lx ij bi translated">作为一名JavaScript开发人员，您总是希望从您的代码中获得尽可能好的结果，对JavaScript引擎的良好理解将总是导致您更好地决定如何编写代码，而不是进行随机操作。</p><p id="e235" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated">如果你在想为什么我们需要学习一些在幕后运行良好的东西？</p><p id="e80b" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><em class="mv">这里有一个例子</em>，假设你有几个存储一些值的对象，现在如果我们试图在一个函数中返回这些值大约10亿次，在一个高端处理器上，它将花费近<strong class="ma ir"> 1.5秒</strong>的执行时间，但是如果我们只是将存储在我们对象中的属性加倍，那么执行时间将接近<strong class="ma ir"> 10秒</strong>。当您使用真实世界的JavaScript应用程序时，这是非常不同的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/6305fb574bc7e753ea7451c154921d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3_qtX3zDmt3o2l4X-K2hw.png"/></div></div></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="5e4e" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">3.双倍等于和三倍等于</h2><p id="955e" class="pw-post-body-paragraph ly lz iq ma b mb nr jr md me ns ju mg la nt mi mj le nu ml mm li nv mo mp lx ij bi translated">在JavaScript中，我们有两种视觉上相似的方法来测试相等性。我们有<code class="fe nx ny nz oa b">==</code> &amp; <code class="fe nx ny nz oa b">===.</code></p><ul class=""><li id="48a5" class="mw mx iq ma b mb mq me mr la my le mz li na lx nb nc nd ne bi translated"><strong class="ma ir"> Double Equals: </strong>我们正在测试松散的相等性&amp;它还执行<strong class="ma ir"> <em class="mv">类型强制</em> </strong>，这意味着只有在尝试将两个值转换为公共类型之后，才会对它们进行比较。</li></ul><p id="773a" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><strong class="ma ir"> <em class="mv">例如:</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d992686878224627fffffeffebb08282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*OoAxFRK4PL5fyBh65Xhjyw.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk"><strong class="bd og">Double Equals</strong></figcaption></figure><blockquote class="ln"><p id="b9bc" class="lo lp iq bd lq lr oh oi oj ok ol lx dk translated">在这种情况下，JavaScript将我们的值转换成like类型</p></blockquote><ul class=""><li id="946e" class="mw mx iq ma b mb mc me mf la om le on li oo lx nb nc nd ne bi translated"><strong class="ma ir">三重相等:</strong>我们正在测试严格相等，这意味着在比较时，<strong class="ma ir">类型</strong>和<strong class="ma ir">值</strong>必须相同。</li></ul><p id="6048" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><strong class="ma ir"> <em class="mv">例如:</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/dc791a1bf5e4231f586f0253338cfce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-HYlPto_Clno6-iQoLeog.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk"><strong class="bd og">Triple Equals</strong></figcaption></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="d891" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">4.数字正射影像图</h2><p id="631b" class="pw-post-body-paragraph ly lz iq ma b mb nr jr md me ns ju mg la nt mi mj le nu ml mm li nv mo mp lx ij bi translated">DOM为创建奇妙和创新的应用程序提供了重要的API，对DOM基础知识的良好理解是一些开发人员能够构建令人难以置信的东西的关键因素。DOM ( <strong class="ma ir">文档对象模型)</strong>是一个表示浏览器如何读取HTML和XML文档的接口&amp;当浏览器读取HTML文档时，它会创建一个表示树。</p><p id="0919" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><em class="mv">你能用DOM和你的创造力做什么:</em></p><ul class=""><li id="c7bd" class="mw mx iq ma b mb mq me mr la my le mz li na lx nb nc nd ne bi translated"><strong class="ma ir">构建可由用户操作定制的应用程序，例如页面布局的改变而无需刷新。</strong></li></ul></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="20f0" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">5.调用栈</h2><p id="3b1b" class="pw-post-body-paragraph ly lz iq ma b mb nr jr md me ns ju mg la nt mi mj le nu ml mm li nv mo mp lx ij bi translated">简而言之，调用堆栈是一种数据结构，它使用<strong class="ma ir">后进先出</strong>原则来临时存储函数调用。</p><p id="84e6" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><strong class="ma ir"> <em class="mv">例如:</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/1bb82846d3806e7b1a432940198937aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cy--k0_cEs2nviQb8S6utw.png"/></div></div></figure><ul class=""><li id="c17d" class="mw mx iq ma b mb mq me mr la my le mz li na lx nb nc nd ne bi translated">当函数<strong class="ma ir"> <em class="mv"> second() </em> </strong>被执行时，一个空的堆栈框架被创建，它是程序的主入口点。</li><li id="90d6" class="mw mx iq ma b mb nf me ng la nh le ni li nj lx nb nc nd ne bi translated">函数<strong class="ma ir"> <em class="mv"> second() </em> </strong>执行后，调用函数<strong class="ma ir"> <em class="mv"> first() </em> </strong>推入堆栈，返回并打印<strong class="ma ir">【执行的第一个函数】</strong>到控制台<strong class="ma ir"> </strong> &amp;弹出堆栈。</li><li id="9da3" class="mw mx iq ma b mb nf me ng la nh le ni li nj lx nb nc nd ne bi translated">然后执行移动到函数<strong class="ma ir"> <em class="mv"> second() </em> </strong>返回并打印<strong class="ma ir">‘第二个执行的函数’</strong>到控制台，执行后在清空内存的同时弹出堆栈。</li></ul></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="a22e" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">6.范围</h2><p id="e842" class="pw-post-body-paragraph ly lz iq ma b mb nr jr md me ns ju mg la nt mi mj le nu ml mm li nv mo mp lx ij bi translated">你可以说作用域是一个盒子，它有自己的变量、函数和对象的边界。默认情况下，你总是在<em class="mv">根</em>范围内，这里的边界决定了你是否可以访问变量。</p><p id="9158" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><em class="mv">范围可以用两种方式定义:</em></p><ul class=""><li id="3edf" class="mw mx iq ma b mb mq me mr la my le mz li na lx nb nc nd ne bi translated"><strong class="ma ir">局部范围:</strong>边界内一切都是允许的。</li><li id="65be" class="mw mx iq ma b mb nf me ng la nh le ni li nj lx nb nc nd ne bi translated"><strong class="ma ir">全局作用域:</strong>在全局作用域的情况下，你不能访问在<strong class="ma ir">局部作用域</strong>中定义的变量，因为它与外部环境是封闭的，除非你返回它。</li></ul><p id="39f7" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><strong class="ma ir"> <em class="mv">例如:</em> </strong></p><ul class=""><li id="3ad2" class="mw mx iq ma b mb mq me mr la my le mz li na lx nb nc nd ne bi translated">如果我们尝试运行下面给定的JavaScript代码，您将在控制台中得到一个<strong class="ma ir"> <em class="mv">未定义的</em> </strong>错误，因为变量名是在函数中定义的，这意味着我们不能在此函数<strong class="ma ir">(局部范围)</strong>之外访问它。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/b023e71c3074cfea6cef7a214a3558b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4hdNnPYiuyeSiRh6N6hqg.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk"><strong class="bd og">Local Scope</strong></figcaption></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="cb26" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">7.提升</h2><p id="c8f1" class="pw-post-body-paragraph ly lz iq ma b mb nr jr md me ns ju mg la nt mi mj le nu ml mm li nv mo mp lx ij bi translated">有很多时候很多<strong class="ma ir"> <em class="mv"> JavaScript </em> </strong>开发者对<strong class="ma ir"> <em class="mv">提升</em> </strong>及其工作原理有误解。通过这个概念，你可以处理许多错误&amp;你可以在定义函数之前调用它，以避免类似<strong class="ma ir">‘UncaughtReferenceError’的错误。</strong>在提升中，JavaScript解释器总是在执行前将变量和函数移动到当前作用域的顶部。</p><p id="33ef" class="pw-post-body-paragraph ly lz iq ma b mb mq jr md me mr ju mg la ms mi mj le mt ml mm li mu mo mp lx ij bi translated"><strong class="ma ir"> <em class="mv">例如:</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/593262e24be5b29c0314a16f051bf8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilMqhpmlae8wGnuUuRMDSA.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk"><strong class="bd og">Hoisting</strong></figcaption></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt or"><a rel="noopener  ugc nofollow" target="_blank" href="/ultimate-web-developer-roadmap-for-2021-6758edd0bd3f"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">2021年终极网络开发者路线图</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">从基础到部署可伸缩的Web应用程序</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf kp or"/></div></div></a></div><div class="pg ph gp gr pi or"><a rel="noopener  ugc nofollow" target="_blank" href="/9-data-structures-algorithms-you-should-know-as-a-developer-5e10946c95a0"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">作为开发人员，你应该知道的9种数据结构和算法</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">让你成为更好的开发者的数据结构和算法</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pa l"><div class="pj l pc pd pe pa pf kp or"/></div></div></a></div></div></div>    
</body>
</html>