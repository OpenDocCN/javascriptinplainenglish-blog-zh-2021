<html>
<head>
<title>How to Measure the Similarity of 2 Histograms, with an Application to Find Similar Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测量两个直方图的相似性，并应用于查找相似图像</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/measuring-the-similarity-of-two-histograms-with-an-application-to-find-similar-images-8eaeba35c914?source=collection_archive---------10-----------------------#2021-10-21">https://javascript.plainenglish.io/measuring-the-similarity-of-two-histograms-with-an-application-to-find-similar-images-8eaeba35c914?source=collection_archive---------10-----------------------#2021-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/060346c5887bb57a90bfa752a4834702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIt-7dBmOuv0HutbQkPrMg.png"/></div></div></figure><p id="96fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">毫无疑问，直方图是数据分析的主要对象之一。直方图表示某个随机变量的值的分布。</p><p id="22b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果直方图被归一化为1，即值(条)的总和为1，那么它们表示某个离散随机变量的<strong class="ka ir">密度函数</strong>。在这种情况下，条形的值是随机变量将相应条形的标签作为值的概率。</p><p id="d8a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个经常出现的问题是两个直方图彼此偏离多少。例如:</p><ul class=""><li id="2040" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">比较几个期间的财务数据分布</li><li id="46d9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">比较图像数据的颜色分布</li></ul><p id="bd60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个故事中，我们将着眼于直方图距离的精确定义，并给出一个测量两幅图像相似性的示例实现。特别地，这可以用于自动检测相似的图像。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h2 id="53f2" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">相交方法:</h2><p id="1faa" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">首先，通常密度函数的距离定义非常复杂且难以计算。我们要看一个比较容易理解和计算的。</p><p id="4e1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看它的定义和主要性质。如果你对概率论一点都不熟悉，这些定义可能看起来有点难懂。但是请注意，您会惊讶于它的实际实现是多么容易。为此，请跳到下一节。</p><p id="dd59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(如果嵌入的PDF显示为空白，您可以在此访问它<a class="ae mp" href="https://applied-math-coding.github.io/article-snippets/histogram-intersection/definition-and-properties.pdf" rel="noopener ugc nofollow" target="_blank"/></p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h2 id="a29b" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">实施:</h2><p id="fa0a" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">直方图距离的计算非常简单。</p><p id="d75e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设给我们一个离散分布的概率密度<code class="fe mw mx my mz b">f, g</code>。或者，我们可以说，<code class="fe mw mx my mz b">f</code>和<code class="fe mw mx my mz b">g</code>是归一化直方图的数据阵列。然后可以用JavaScript/TypeScript计算距离，如下所示:</p><pre class="mq mr ms mt gt na mz nb nc aw nd bi"><span id="95f5" class="lr ls iq mz b gy ne nf l ng nh">({ f, g }: { f: number[], g: number[] }): number =&gt;<br/>    <strong class="mz ir">1 - f.reduce((prev, e, idx) =&gt; prev + Math.min(e, g[idx]), 0); </strong> </span></pre><p id="6d6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以本质上我们简单地把<code class="fe mw mx my mz b">min(f[idx], g[idx])</code>的值相加，然后从<code class="fe mw mx my mz b">1</code>中减去它。这都适用于归一化直方图，或者换句话说，其中<code class="fe mw mx my mz b">f</code>的值分别为。<code class="fe mw mx my mz b">g</code>做总结到<code class="fe mw mx my mz b">1</code>。</p><p id="e4a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以将这个总和视为标题直方图中红色和蓝色条的所有交叉点的总和。由此可见，该总和越接近<code class="fe mw mx my mz b">0</code>，直方图的差异就越大。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h2 id="1b9d" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">图像应用:</h2><p id="a433" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">现在，让我们看看如何使用这种简单的技术来检测相似的图像。为此，我创建了一个简单的网页，它交叉计算给定图像列表的距离。你可以在这里看到它<a class="ae mp" href="https://applied-math-coding.github.io/histogram-distance/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="261a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，对于每个图像，计算每个通道‘r’、‘g’、‘b’的颜色分布。这意味着，每个图像由三个直方图表示。</p><p id="5d9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了计算两幅图像的距离，将相应的‘r’-、‘g’-、‘b’-直方图的距离相加。因此，本质上，我们通过使用l1范数来计算两个三元组的距离，这同样可以被显示为构成度量。</p><p id="9d7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中一幅图像只是另一幅的灰度。这些图像之间的距离被计算为<code class="fe mw mx my mz b">0.68</code>。这表明该方法不能很好地恢复形状。</p><p id="7576" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过执行以下操作来摆弄底层代码:</p><pre class="mq mr ms mt gt na mz nb nc aw nd bi"><span id="d487" class="lr ls iq mz b gy ne nf l ng nh">git clone <a class="ae mp" href="https://github.com/applied-math-coding/histogram-distance.git" rel="noopener ugc nofollow" target="_blank">https://github.com/applied-math-coding/histogram-distance.git</a></span><span id="cbdb" class="lr ls iq mz b gy ni nf l ng nh">npm i</span><span id="1ab2" class="lr ls iq mz b gy ni nf l ng nh">npm start</span></pre><p id="0a10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是使用TypeScript的Vue应用程序。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h2 id="3c58" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">最后注意:</h2><p id="d363" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">对我来说，相交方法第一次出现是在必须解决一个问题的时候，在这个问题中，摄像机只有在认为图像发生显著变化时才开始通知服务器。因此，树叶被风吹动不会引发事件，但突然的龙卷风卷走这些树应该会引发事件。正如已经提到的，对于检测形状，这种方法根本不适合，但是对于可以由颜色确定的任何事物，这种方法提供了很好的支持。</p><p id="f497" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p><p id="9e43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nj">更多内容尽在</em><a class="ae mp" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>