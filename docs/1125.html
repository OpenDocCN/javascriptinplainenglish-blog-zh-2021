<html>
<head>
<title>How To Implement Client-Side Authentication in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中实现客户端认证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-client-side-authentication-in-angular-d6dc30920f98?source=collection_archive---------8-----------------------#2021-03-09">https://javascript.plainenglish.io/how-to-implement-client-side-authentication-in-angular-d6dc30920f98?source=collection_archive---------8-----------------------#2021-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dcc2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">采用行业标准的最佳实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/646e7629df4232c82acf0b47064dd8c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kq4c3TL3bC1paiPZ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@nicoli_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chepe Nicoli</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e772" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，区分客户端和服务器端身份验证是很重要的，并注意生产就绪的应用程序必须同时包含这两者。</p><p id="f078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器端身份验证控制谁有权访问单个API端点，进而控制应用程序数据的范围。</p><p id="ac30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序的安全性依赖于服务器，而不是客户端。服务器是将数据发送到客户端的最后一道防线。请记住，用户可以在没有用户界面的情况下访问服务器。</p><p id="0f76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端身份验证在保护应用程序方面没有什么分量。它在保护用户不访问他们不应该访问的路线或组件方面确实举足轻重。</p><p id="6c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括地说，服务器端身份验证主要提高安全性，客户端身份验证主要改善用户体验。说到这里，让我们开始吧。</p><h1 id="c29c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">安装</h1><p id="3e51" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们用routing初始化一个Angular项目。这个演示项目将被称为“认证”</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9ef3" class="mu lt iq mq b gy mv mw l mx my">ng new auth --routing</span></pre><p id="44cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们服务应用程序，看看我们的变化。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0306" class="mu lt iq mq b gy mv mw l mx my">ng serve -o</span></pre><h1 id="9042" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">组件</h1><p id="3584" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们生成两个组件:未经身份验证的用户的登录页面和经过身份验证的用户的主页。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="544c" class="mu lt iq mq b gy mv mw l mx my">ng generate component components/login<br/>ng generate component components/home</span></pre><h1 id="6cd1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">路线</h1><p id="7862" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们用下面的内容替换<strong class="ky ir">app.component.html</strong>的内容。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6c13" class="mu lt iq mq b gy mv mw l mx my">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre><p id="353b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">登录页面和主页将分别与路线<strong class="ky ir">/登录</strong>和<strong class="ky ir">/主页</strong>相关联。我们还希望将基本URL重定向到主页。让我们将这些路线及其各自的组件添加到<strong class="ky ir"> app-routing.module.ts </strong>中。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9db2" class="mu lt iq mq b gy mv mw l mx my">const routes: Routes = [<br/>  {<br/>    path: ‘login’,<br/>    component: LoginComponent,<br/>  },<br/>  {<br/>    path: ‘home’,<br/>    component: HomeComponent,<br/>  },<br/>  {<br/>    path: ‘’,<br/>    pathMatch: 'full',<br/>    redirectTo: 'home',<br/>  },<br/>];</span></pre><p id="71c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<strong class="ky ir"> /login </strong>显示登录组件，<strong class="ky ir"> /home </strong>显示home组件。基础URL <strong class="ky ir">重定向到<strong class="ky ir"> /home </strong>。</strong></p><h1 id="80ec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">服务</h1><p id="5cc9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们生成一个服务来检索当前用户和用户的模型。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d013" class="mu lt iq mq b gy mv mw l mx my">ng generate services/auth</span><span id="71d9" class="mu lt iq mq b gy mz mw l mx my">ng generate interface models/User model</span></pre><p id="1a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将修改<strong class="ky ir"> user.model.ts </strong>如下:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c061" class="mu lt iq mq b gy mv mw l mx my"><em class="na">export</em> interface User {<br/>  name: string;<br/>}</span></pre><p id="7270" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir"> auth.service.ts </strong>中，我们添加一个getter函数来检索当前用户。如果用户已经登录，该函数将返回一个<strong class="ky ir">用户</strong>对象，否则返回null。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1fcb" class="mu lt iq mq b gy mv mw l mx my">get user$(): Observable&lt;User | null&gt; {<br/>  return of({<br/>    name: 'Bob',<br/>  });<br/>}</span></pre><h1 id="d31d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">警卫</h1><p id="91e3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，我们需要一个路线守卫。Angular提供了一个接口，<a class="ae kv" href="https://angular.io/api/router/CanActivate" rel="noopener ugc nofollow" target="_blank"> CanActivate </a>，决定用户是否可以激活一条路线。警卫将与认证服务通信以确定用户是否被认证。那么，有三种可能的结果:</p><ol class=""><li id="3428" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">用户通过了身份验证，但被导航到登录页面。在这种情况下，守卫会将用户重定向到主页。</li><li id="f78b" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">该用户未经身份验证，但导航到了主页。在这种情况下，守卫会将用户重定向到登录页面。</li><li id="628c" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">用户通过身份验证并导航到主页，或者用户未经身份验证并导航到登录页面。在任何一种情况下，警卫都会允许进入该路线。</li></ol><p id="183c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们生成这个守卫。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6c11" class="mu lt iq mq b gy mv mw l mx my">ng generate guard guards/auth<br/># select CanActivate</span></pre><p id="4506" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将从我们的服务中观察到的<strong class="ky ir">用户$ </strong>引入<strong class="ky ir"> auth.guard.ts </strong>。我们还可以引入Angular router服务来为用户导航正确的路线。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b909" class="mu lt iq mq b gy mv mw l mx my">user$: Observable&lt;User&gt;;</span><span id="cbf0" class="mu lt iq mq b gy mz mw l mx my">constructor(authService: AuthService, private router: Router) {<br/>  this.user$ = authService.user$;<br/>}</span></pre><p id="1d35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望通过RxJS地图操作符运行可观察的<strong class="ky ir">用户$ </strong>。我们将把用户对象转换成布尔值，并检查当前路由是否是登录路由。有了这些信息，我们就可以决定用户是否有权访问该路线。</p><p id="fdee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户试图访问他们无权访问的路线，我们将返回一个URL树。在Angular中，这告诉路由器用户无权访问路由，并相应地重定向他们。</p><p id="3cbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir"> canActivate </strong>函数中，我们添加以下代码。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9f06" class="mu lt iq mq b gy mv mw l mx my"><em class="na">return</em> <em class="na">this</em>.user$.pipe(<br/>  map((user) =&gt; {<br/>    const isAuthorized = !!user;<br/>    const isLoginRoute = state.url.includes('login');<br/>    const hasAccess = isLoginRoute ? !isAuthorized : isAuthorized;<br/>    const redirect = isLoginRoute<br/>      ? <em class="na">this</em>.router.createUrlTree([''])<br/>      : <em class="na">this</em>.router.createUrlTree(['login']);<br/>    <em class="na">return</em> hasAccess ? true : redirect;<br/>  })<br/>);</span></pre><p id="60bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们认证逻辑的核心。</p><p id="7546" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在<strong class="ky ir"> app-routing.module.ts </strong>中通过向数组中的两个route对象添加键值对<code class="fe np nq nr mq b">canActivate: [AuthGuard]</code>来为两个route添加保护，如下所示。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e678" class="mu lt iq mq b gy mv mw l mx my">  {<br/>    path: ‘login’,<br/>    component: LoginComponent,<br/>    canActivate: [AuthGuard],</span><span id="3885" class="mu lt iq mq b gy mz mw l mx my">  },<br/>  {<br/>    path: ‘home’,<br/>    component: HomeComponent,<br/>    canActivate: [AuthGuard],<br/>  },</span></pre><p id="dea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们转到位于<strong class="ky ir"> /login </strong>的登录组件时，我们将被重定向到位于<strong class="ky ir"> /home </strong>的home组件。如果我们去<strong class="ky ir">/家</strong>，我们就呆在那里。</p><p id="aa44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在<strong class="ky ir"> auth.service.ts </strong>中更改我们的认证服务，以返回一个空用户来表示该用户已注销。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4bb6" class="mu lt iq mq b gy mv mw l mx my">get user$(): Observable&lt;User | null&gt; {<br/>  return of(null);<br/>}</span></pre><p id="0cc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们转到位于<strong class="ky ir"> /home </strong>的home组件时，我们将被重定向到位于<strong class="ky ir"> /login </strong>的login组件。如果我们路由到<strong class="ky ir">/登录</strong>，我们就呆在那里。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="e821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Angular总结了我们的客户端身份验证指南。您可以在这里找到这个演示的代码。</p><div class="nz oa gp gr ob oc"><a href="https://github.com/charlielevine/angular-auth" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">charlielevine/angular-auth</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">此项目是使用Angular CLI版本11.1.4生成的。为开发服务器运行ng serve。导航到…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kp oc"/></div></div></a></div><p id="a445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您觉得这很有用，请在Medium ( <a class="or os ep" href="https://medium.com/u/6da6b651e31a?source=post_page-----d6dc30920f98--------------------------------" rel="noopener" target="_blank"> Charlie Levine </a>)上关注我，我每周都会在这里发布角度、编程和技术相关的文章。非常感谢您的支持，一如既往，非常感谢您的阅读！</p></div></div>    
</body>
</html>