<html>
<head>
<title>Unit Testing Challenges with Modular JavaScript Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模块化JavaScript模式的单元测试挑战</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-testing-challenges-with-modular-javascript-patterns-22cc22397362?source=collection_archive---------5-----------------------#2021-05-25">https://javascript.plainenglish.io/unit-testing-challenges-with-modular-javascript-patterns-22cc22397362?source=collection_archive---------5-----------------------#2021-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8892e69744dd38fcf6d95a307194385d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DaWhCO72-JNq4nkVHNAS_g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A modular synthesizer Photo by <a class="ae jz" href="https://unsplash.com/@trommelkopf?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steve Harvey</a> on <a class="ae jz" href="https://unsplash.com/s/photos/modular?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="735e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模块化JavaScript正处于CommonJS和ES模块之间一个有趣的十字路口。虽然ES模块语法很常见，但它通常符合<a class="ae jz" href="https://en.wikipedia.org/wiki/CommonJS" rel="noopener ugc nofollow" target="_blank"> CommonJS </a>，这可能会给单元测试带来一些挑战。此外，当使用<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noopener ugc nofollow" target="_blank">本地的ES模块</a>时，我们在编写测试时需要注意一些特性。本文探讨了这两种模式中存根和间谍的具体问题，并提供了一系列解决方案。</p><p id="849a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个问题是，使用ES6的<em class="ky"> export </em>语法来共享单个函数，但是编译到CommonJS时，不可能对同一<em class="ky"/>模块中另一个调用的函数进行存根或监视。第二个是，当使用本机ES模块时，您不能从任何<em class="ky">模块中截取或监视命名导入。</em></p><h1 id="402e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">对同一模块出口进行窃听或监视</h1><p id="752b" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">请考虑以下代码:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9dbe" class="ml la in mh b gy mm mn l mo mp">export function bar(str) {<br/>  return str;<br/>}<br/><br/>export function foo() {<br/>  bar('test');<br/>}</span></pre><p id="8a2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我的应用程序运行时，一切似乎都很好。但是，当我对<em class="ky"> foo </em>进行测试并为<em class="ky">条</em>创建间谍时，它没有为<em class="ky">条</em>记录任何数据:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6351" class="ml la in mh b gy mm mn l mo mp">expected spy to have been called at least once, but it was never called</span></pre><p id="a6d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在探索这个问题的解决方案时，我遇到了很多令人困惑的信息，所以让我先澄清一些事情。</p><h2 id="c409" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated">这个问题适用于任何JavaScript嘲笑框架，而不仅仅是Jest或Sinon</h2><p id="52a0" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">让我们从消除最大的误区开始:测试框架不应该受到任何指责。测试框架根本无法读取正确的对象。</p><h2 id="3281" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated">这不是巴别塔的问题</h2><p id="7ae6" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">我也看到有人认为这个问题是由于<a class="ae jz" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>如何编译JavaScript造成的。默认情况下，它会将您导出的函数分配给<em class="ky">导出的</em>对象。下一节将解释为什么这会影响相同的模块存根和间谍。</p><p id="780e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的是，巴贝尔确实支持es模块，您可以在您的目标<a class="ae jz" href="https://babeljs.io/docs/en/babel-preset-env#targetsesmodules" rel="noopener ugc nofollow" target="_blank">中指定，如本文</a>所述。如果这样做，您将需要确保您的所有目标环境都支持es模块，并克服我在下面“使用ES模块的存根和间谍”一节中解释的问题。</p><h2 id="4864" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated">当以一种模式书写，然后转换成另一种模式时，这是一个问题</h2><p id="bb1d" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">当通过<a class="ae jz" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>或<a class="ae jz" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>运行你的单元测试套件时，他们将使用<a class="ae jz" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>环境。默认情况下，Node使用CommonJS语法，不会理解您的<em class="ky">导入/导出</em>语法，所以当您运行程序时，您可能会得到类似于<code class="fe nc nd ne mh b">Unexpected token ‘export’</code>的错误。这就是Babel等工具介入的地方——它们将您的ES6模块编译成CommonJS，以便您的目标可以理解它们。</p><p id="47d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以我们的开放代码为例，将它<a class="ae jz" href="https://babeljs.io/repl" rel="noopener ugc nofollow" target="_blank">粘贴到Repl </a>中，并注意结果。编译后的代码如下所示</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c03e" class="ml la in mh b gy mm mn l mo mp">Object.defineProperty(exports, "__esModule", {<br/>  value: true<br/>});<br/>exports.bar = bar;<br/>exports.foo = foo;</span><span id="05c6" class="ml la in mh b gy nf mn l mo mp">function bar(str) {<br/>  return str;<br/>}</span><span id="b440" class="ml la in mh b gy nf mn l mo mp">function foo() {<br/>  bar('test');<br/>}</span></pre><p id="fc31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您尝试存根/窥探bar时，它将使用引用<em class="ky"> exports.bar </em>，这与foo中使用的引用不同。引用一位提出这个问题的Sinon贡献者<a class="ae jz" href="https://github.com/sinonjs/sinon/issues/1684" rel="noopener ugc nofollow" target="_blank"/>的话:“通过存根化bar导出，你覆盖了导出的符号，但不是被foo中的闭包绑定的内部函数引用”。</p><p id="f8ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Node现在支持es模块，这对每个人来说都是一个好消息，但这带来了一些新的挑战，所以让我们深入了解第二个难点。</p><h1 id="454a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">带有es模块的存根和间谍</h1><p id="4905" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">既然我们已经讨论了ES6 &gt; CommonJS的一个常见挑战，那么让我们来看看本机ES模块。这里我们不需要工具来将我们的模块从一种模式转换到另一种模式，我们只需要告诉我们的<a class="ae jz" href="https://nodejs.org/api/esm.html#esm_enabling" rel="noopener ugc nofollow" target="_blank">环境我们正在使用什么类型的模块</a>。当您运行您的测试套件时，您可能会遇到的问题是，不可能对来自任何模块的<em class="ky">命名导入</em>使用存根或间谍。如果您尝试这样做，您会得到如下错误:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e2ae" class="ml la in mh b gy mm mn l mo mp">ES Modules cannot be stubbed</span></pre><p id="e7e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用本机ES模块，您不能存根或窥探通过简单命名的<em class="ky">导出/导入</em>方法可用的导出函数，因为ES6模块的导入是导出实体上的<a class="ae jz" href="https://exploringjs.com/es6/ch_modules.html#_imports-are-read-only-views-on-exports" rel="noopener ugc nofollow" target="_blank">只读视图。这实际上是使它们如此伟大的原因，因为“到模块体内声明的变量的连接仍然是活动的。”</a></p><h2 id="0ca4" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated">存根和间谍在引擎盖下做什么？</h2><p id="c50d" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">在我们探索任何解决方案之前，让我们先探索一下间谍在幕后做了什么，这样我们才能更好地理解根本原因。间谍使用对象和方法。spy临时存储对原始函数的引用，但会像这样覆盖该值:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b173" class="ml la in mh b gy mm mn l mo mp">obj[method] = function() {<br/>//spy logic here<br/>}</span></pre><p id="8976" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着当spy或stub函数试图在运行时覆盖原始函数时，它将会失败。如果我们在上面的语句周围放一个<em class="ky"> try/catch </em>，我们会得到这个错误:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="71d1" class="ml la in mh b gy mm mn l mo mp">Cannot assign to read only property 'foo' of object '[object Module]</span></pre><p id="639e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要亲眼看到这一点，请在这里下载<a class="ae jz" href="https://github.com/rjbultitude/mocks-stubs-and-spies-commonJS-or-ESM" rel="noopener ugc nofollow" target="_blank">我的演示报告</a>，在这里你可以运行一套单元测试，演示问题和一些解决方案。此外，看看这个关于<a class="ae jz" href="https://abdulapopoola.com/2016/04/11/how-function-spies-work-in-javascript/" rel="noopener ugc nofollow" target="_blank">间谍如何在这里工作的更深入的解释</a>。</p><h2 id="2034" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated">有多种解决方案，每一种都有其优缺点</h2><p id="3645" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">下面是对我在本文中提到的两个问题都有效的所有解决方案的列表。你选择哪一个将取决于给定你的代码库和它的上下文，你觉得什么样的妥协是可接受的。</p><h2 id="ea3c" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated"><strong class="ak"> 1)作为对象存储和导出函数</strong></h2><p id="0ab8" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">这本质上是一个命名空间解决方案。其思想是导出一个引用所有模块公共函数的对象，然后在模块中引用该对象。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="cbe8" class="ml la in mh b gy mm mn l mo mp">export function bar(str) {<br/>  return str;<br/>}<br/><br/>export function foo() {<br/>  <strong class="mh io">utils.bar</strong>('some text');<br/>}<br/><br/>export const utils = {<br/>    foo,<br/>    bar,<br/>};</span></pre><p id="7485" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这类似于流行的<a class="ae jz" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript" rel="noopener ugc nofollow" target="_blank">揭示模块模式</a>，它通过一个对象促进公共方法的导出，并使用一个<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">生命</a>将该对象返回给外部模块。</p><p id="4e1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">请注意</strong>，您不<em class="ky">而</em>需要将此对象导出为默认导出<a class="ae jz" href="https://medium.com/@qjli/how-to-mock-specific-module-function-in-jest-715e39a391f4" rel="noopener">，因为有时会假定</a>。对象是否是默认导出并不重要；重要的是一个<em class="ky">对象</em>被导出。</p><p id="97df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点</strong></p><ul class=""><li id="b3dd" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">如果您已经在使用import all *别名，只需对测试进行最小的更改</li><li id="6839" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">不需要额外的依赖</li></ul><p id="dc1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点</strong></p><ul class=""><li id="9bbd" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">需要更改应用程序代码</li><li id="ce0f" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">涉及潜在的不必要的命名空间</li></ul><h2 id="ebf1" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated">把你的函数放在一个类里</h2><p id="5971" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">与上面的方法类似，这将允许您将函数作为方法来引用。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="eec1" class="ml la in mh b gy mm mn l mo mp">export class MyModule {<br/>  bar() {<br/>    return 'bar';<br/>  }<br/><br/>  foo() {<br/>    <strong class="mh io">this.</strong>bar();<br/>  }<br/>}</span></pre><p id="4d3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点</strong></p><ul class=""><li id="98f2" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">如果你已经在使用类了，那就没什么可做的了</li><li id="fe8c" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">不需要额外的依赖</li></ul><p id="f1c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点</strong></p><ul class=""><li id="5b86" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">将类引入现有代码将是一个重大的重构</li></ul><h2 id="fa90" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated"><strong class="ak"> 3)依赖注入</strong></h2><p id="87e1" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">这里我们给函数添加了一个新的参数，默认为依赖关系。在我们的测试中，我们可以用回调覆盖缺省值并监视它。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="45fe" class="ml la in mh b gy mm mn l mo mp">export function bar () {<br/>    return 'bar';<br/>}<br/><br/>export function foo (_bar = bar) {<br/>    _bar();<br/>}</span></pre><p id="c0ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点</strong></p><ul class=""><li id="3870" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">不涉及导出命名空间</li><li id="3155" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">没有新的依赖项需要配置或维护</li></ul><p id="4118" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点</strong></p><ul class=""><li id="2fa9" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">职能范围可能不必要的变化</li></ul><h2 id="3170" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated"><strong class="ak"> 4)使用第三方工具</strong></h2><p id="93a0" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">有一些工具可以拦截模块引用导出数据的方式。我所知道的两个是<a class="ae jz" href="https://www.npmjs.com/package/rewire" rel="noopener ugc nofollow" target="_blank"> Rewire </a>和<a class="ae jz" href="https://github.com/thlorenz/proxyquire" rel="noopener ugc nofollow" target="_blank"> ProxyRequire </a>(只是常见的)。顾名思义，Rewire允许我们完全覆盖数据引用。</p><p id="ee22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Rewire的一种方法是在他们的文档中描述的<a class="ae jz" href="https://github.com/speedskater/babel-plugin-rewire#named-and-top-level-function-rewiring" rel="noopener ugc nofollow" target="_blank"/>，尽管这里有一个更简洁的片段可以帮助你:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0524" class="ml la in mh b gy mm mn l mo mp">import __RewireAPI__, * as module from '../module';<br/><br/>describe('foo', () =&gt; {<br/>  it('calls bar', () =&gt; {<br/>    const barMock = jest.fn();<br/>    __RewireAPI__.__Rewire__('bar', barMock);<br/>    <br/>    module.foo();<br/><br/>    expect(bar).toHaveBeenCalledTimes(1);<br/>  });<br/>});</span></pre><p id="8cba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当使用Babel时，你必须添加Rewire作为插件。请注意，当使用Rewire导入模块时，它将改变所有依赖项的导入方式，并可能破坏现有的测试代码。</p><p id="b01f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点</strong></p><ul class=""><li id="2449" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">不需要更改应用程序代码</li></ul><p id="2f3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点</strong></p><ul class=""><li id="f7f6" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">需要对现有测试代码进行更改</li><li id="5bae" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">要维护的新依赖项</li><li id="f74c" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">要学习的新API</li><li id="0c47" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">可能会破坏现有的测试</li></ul><h2 id="ed0d" class="ml la in bd lb mq mr dn lf ms mt dp lj kl mu mv ln kp mw mx lr kt my mz lv na bi translated">其他解决方案</h2><p id="c2b8" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">还有另外两种解决方案值得一提。首先，你可以将一个模块导入到它自身中(如MostafaR所描述的<a class="ae jz" href="https://stackoverflow.com/questions/45111198/how-to-mock-functions-in-the-same-module-using-jest" rel="noopener ugc nofollow" target="_blank">，然后引用你导出的函数，就像它们是外部依赖一样。</a></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6961" class="ml la in mh b gy mm mn l mo mp">import * as thisModule from './module';</span><span id="62b4" class="ml la in mh b gy nf mn l mo mp">export function bar () {<br/>    return 'bar';<br/>}</span><span id="c6f2" class="ml la in mh b gy nf mn l mo mp">export function foo () {<br/>    <strong class="mh io">thisModule.</strong>bar();<br/>}</span></pre><p id="f932" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管这是一个很好的解决方案，但是它不能用于ES模块，并且它引入了循环依赖，这使得代码更难推理。</p><p id="5447" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，还有旧的“将依赖项转移到外部模块”解决方案，在我看来这不是一个解决方案，因为它没有解决最初的问题陈述。我不希望每个可能有相同模块依赖的函数都有一个单独的模块。</p><h1 id="b81a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="fc4e" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">记住，无论你使用什么解决方案，你的测试库都可能希望stubs和spies引用一个方法，所以一定要使用<em class="ky"> all </em>别名导入你的模块:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="75d4" class="ml la in mh b gy mm mn l mo mp">import * as myModule from './myModule';</span><span id="f3b0" class="ml la in mh b gy nf mn l mo mp">const mySpy = sinon.spy(myModule, 'myFn');</span></pre><p id="48d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，要注意您使用的是哪个版本的Node。我在旧版本上遇到过问题。</p><p id="6a7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，您应该已经掌握了更好地理解问题所需的所有信息，并且有了适合您的情况的解决方案。</p><p id="23e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不想安装任何新的依赖项，并且没有重大的重构任务，那么使用类、命名空间或依赖项注入都是很好的解决方案。相反，使用第三方工具来改变导入在测试中的工作方式将意味着没有应用程序重构，但会使测试代码更难推理，并将增加(又一个)需要维护的依赖项集，这些依赖项可能会被放弃或否决。</p><p id="917d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想亲自看看问题和解决方案，<a class="ae jz" href="https://github.com/rjbultitude/mocks-stubs-and-spies-commonJS-or-ESM" rel="noopener ugc nofollow" target="_blank">在这里下载我的演示报告</a>。</p><p id="3fcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎评论、问题和建议。</p><p id="5259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>