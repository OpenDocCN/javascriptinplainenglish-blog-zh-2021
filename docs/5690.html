<html>
<head>
<title>Build a Polymorphic Component in React and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React和TypeScript中构建多态组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-polymorphic-component-in-react-and-typescript-d9f236950af4?source=collection_archive---------0-----------------------#2021-12-01">https://javascript.plainenglish.io/building-a-polymorphic-component-in-react-and-typescript-d9f236950af4?source=collection_archive---------0-----------------------#2021-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/63271b744e33d00130cddc3f539fd54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0lEgRP5R-ahe3I6aH_uvQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae jz" href="https://unsplash.com/s/photos/Lego?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="ka kb kc"><p id="0b48" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">“多态组件是一种可以根据其实例化方式以多种方式运行的组件”。</p></blockquote><p id="6848" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我目前正在开发一个<a class="ae jz" href="https://github.com/watife/dorai-ui" rel="noopener ugc nofollow" target="_blank">组件库</a>，我想要支持的特性之一是这个库的用户能够改变我最初设置的组件类型。</p><p id="cfdb" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">让我们为一个可访问的模式对话框构建一个标题组件。</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="a8cf" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">上面的代码表示一个简单的标题组件，但是如果模型的消费者希望标题是一个链接或者其他HTML元素呢？我们如何支持多种类型的HTML元素？。我们可以很容易地做到这一点。</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="lj lk l"/></div></figure><blockquote class="ka kb kc"><p id="9848" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated"><strong class="kg io">注意:</strong>组件必须大写，否则jsx会将其视为HTML标签&lt;组件&gt;。</p></blockquote><p id="06db" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">该类型的名称已经更改为<em class="kf"> "TitleOwnProps，"</em>，它代表我们自己定义的道具，并且它接收一个<em class="kf">"作为"</em>道具，这是类型"<em class="kf"> React。ElementType </em>(应该是HTML元素)。此外，我正在传播其余的道具，但这不会有多大帮助，因为我们传递到标题中的<em class="kf"> "href" </em>不被识别为有效的道具，而且，组件的类型仍然是类型<em class="kf"> "any。"</em>我们可以用不同的方式解决上述问题，但是我将使用<a class="ae jz" href="https://ts.chibicode.com/generics" rel="noopener ugc nofollow" target="_blank">泛型</a>进行演示。</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="773b" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">"<em class="kf"> TitleOwnProps </em>"现在需要泛型类型，而<em class="kf"> "as" </em>属性被设置为传递的类型。泛型扩展了<em class="kf">“React。</em>element type；因此，它不是类型<em class="kf"> "any" </em>而是一个HTML元素。</p><p id="ac68" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我们还需要创建一个“<em class="kf"> TitleProps </em>”，它将选择所有的通用类型Props，如果它们存在于我们的类型中，就用我们传递的唯一类型覆盖它们。</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="43ed" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">由于<a class="ae jz" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys" rel="noopener ugc nofollow" target="_blank">省略了</a>，我仔细挑选了所有的React。类型的ComponentProps传递并移除了我们的TitleOwnProps键，因为我们将自己传递它并将所有内容合并到一个道具类型"<em class="kf"> TitleProps </em>"现在我们的标题组件可以接收这个新道具了。</p><p id="d1e4" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">现在我们可以有一个通用组件，如下所示:</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="4457" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">标题组件接收类属；类型默认为<em class="kf">【H2】</em>标签。这意味着我们的TitleProps默认为h2，但是typescript可以<a class="ae jz" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#higher-order-type-inference-from-generic-functions" rel="noopener ugc nofollow" target="_blank">推断出</a>通用函数类型。这使我们能够将HTML元素传递给“as ”,并为我们提供一个功能正常的动态组件。</p><p id="25d5" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><em class="kf">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kg io"> <em class="kf">说白了就是</em> </strong> </a> <strong class="kg io"> <em class="kf">。</em> </strong> <em class="kf">报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kg io"> <em class="kf">免费每周简讯点击这里</em> </strong> </a> <strong class="kg io"> <em class="kf">。</em> </strong></p></div></div>    
</body>
</html>