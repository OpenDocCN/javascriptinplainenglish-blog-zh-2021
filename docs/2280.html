<html>
<head>
<title>Create a Shipping Label via SMS Using the ShipEngine API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ShipEngine API通过SMS创建运输标签</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-shipping-label-via-sms-837de3f8522e?source=collection_archive---------8-----------------------#2021-05-12">https://javascript.plainenglish.io/create-a-shipping-label-via-sms-837de3f8522e?source=collection_archive---------8-----------------------#2021-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9965b96472d6c97f928e5038376e0b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABLryQZF9IYSozTuS8aMDA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by Matt-Ridley via Unsplash</figcaption></figure><p id="51fd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是我非常喜欢的一个项目的概述，我很高兴分享一些我在这个过程中学到的很酷的东西。</p><p id="c1f2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这不像你在我的其他博客文章中可能会发现的那样是一步一步的走，堆栈太大了，每一步都值得更多的关注，而不是我一次阅读就能带来的。相反，我将触及一些亮点和我在构建期间学到的经验教训。</p><p id="92a2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你有问题，发现一个错误，或者只是想说声嗨，请在评论中告诉我，我很乐意收到你的来信。</p><p id="0eb6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">尽情享受吧！</p><p id="b09e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">想自己试试吗？随意在</em><a class="ae ky" href="https://github.com/Josh-Gotro/ShipE" rel="noopener ugc nofollow" target="_blank"><em class="kx">GitHub</em></a><em class="kx">上克隆项目。</em></p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="178f" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">它是做什么的？</h2><p id="ded9" class="pw-post-body-paragraph jz ka in kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw ig bi translated">用例非常简单。用户发送包含一些地址信息的SMS。该应用程序为该地址创建一个运输标签，并通过短信回复一个链接和一个跟踪号码。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi me"><img src="../Images/bdd9e989956b5f79b45655b436f11b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/1*ZtUiXSNiFv4arMZc7JgVTA.gif"/></div></figure><h2 id="2b6b" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">堆栈:</h2><ul class=""><li id="7165" class="mj mk in kb b kc lz kg ma kk ml ko mm ks mn kw mo mp mq mr bi translated">节点. js</li><li id="db5c" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">表达</li><li id="8d0a" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">MongoDB</li><li id="452f" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">猫鼬</li></ul><p id="ce7b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">奖励:</em></p><ul class=""><li id="2cd5" class="mj mk in kb b kc kd kg kh kk mx ko my ks mz kw mo mp mq mr bi translated">反应/阿波罗</li></ul><h2 id="a44f" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">API:</h2><ul class=""><li id="0132" class="mj mk in kb b kc lz kg ma kk ml ko mm ks mn kw mo mp mq mr bi translated"><a class="ae ky" href="https://www.shipengine.com/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">船舶引擎</a></li><li id="1931" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated"><a class="ae ky" href="https://www.plivo.com/docs/sms/api/overview/" rel="noopener ugc nofollow" target="_blank">普利沃</a></li></ul></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="420b" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">工作流程</h2><p id="8e91" class="pw-post-body-paragraph jz ka in kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw ig bi translated">让我们一步步来看一个成功的工作流程:</p><p id="97c8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，用户向与该应用相关联的号码发送短信。<a class="ae ky" href="https://www.plivo.com/docs/sms/use-cases/receive-sms/node#api-create-a-express-server-for-incoming-sms" rel="noopener ugc nofollow" target="_blank"> Plivo的webhook </a>将其传递到<code class="fe na nb nc nd b">/sms</code>端点，在这里<code class="fe na nb nc nd b">text</code>和<code class="fe na nb nc nd b">from-number</code>被保存到变量中。</p><p id="4e88" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将<code class="fe na nb nc nd b">text</code>发送到<a class="ae ky" href="https://www.shipengine.com/docs/addresses/parse/" rel="noopener ugc nofollow" target="_blank"> ShipEngine的</a> <code class="fe na nb nc nd b"><a class="ae ky" href="https://www.shipengine.com/docs/addresses/parse/" rel="noopener ugc nofollow" target="_blank">/recognize</a></code>自然语言解析器，解析器识别地址并将其格式化为一个漂亮的对象返回。</p><p id="5627" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，地址对象被发送到<a class="ae ky" href="https://www.shipengine.com/docs/addresses/validation/" rel="noopener ugc nofollow" target="_blank"> ShipEngine的</a> <code class="fe na nb nc nd b"><a class="ae ky" href="https://www.shipengine.com/docs/addresses/validation/" rel="noopener ugc nofollow" target="_blank">/validate</a></code>，它会填充任何缺失的数据，将其规范化并作为对象返回。这个经过*验证的地址被发送到MongoDB，MongoDB返回一个保存到变量中的<code class="fe na nb nc nd b">Address ID</code>。</p><p id="42bc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还将经过验证的地址发送到<a class="ae ky" href="https://www.shipengine.com/docs/labels/create-a-label/" rel="noopener ugc nofollow" target="_blank"> ShipEngine的</a> <code class="fe na nb nc nd b"><a class="ae ky" href="https://www.shipengine.com/docs/labels/create-a-label/" rel="noopener ugc nofollow" target="_blank">/labels</a></code>以及一些* *硬编码的信息，以创建一个运输标签，该标签作为一个对象返回。来自<code class="fe na nb nc nd b">label</code>对象的关键变量和<code class="fe na nb nc nd b">Address ID</code>一起被发送到MongoDB。</p><p id="a603" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，从对象中提取标签pdf URL和跟踪号，并使用Plivo SDK通过SMS返回给客户</p><p id="db90" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="kx">维奥拉！</em>T15】</strong></p><p id="e351" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">/*如果地址未通过验证，将向用户发送回复，让他们知道并分享一些错误细节。</em></p><p id="6d0a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">/* *送货地址、包裹尺寸/重量详细信息和承运人信息都是硬编码的。</em></p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="866e" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">承诺处理</h2><p id="aa42" class="pw-post-body-paragraph jz ka in kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw ig bi translated">这个应用程序需要连续发出几个HTTP请求，每个请求都依赖于前一个请求返回的数据。JavaScript是同步的，但是在这种情况下，我们需要它是异步的。</p><p id="5cd3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输入承诺处理。</p><p id="3043" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我学会了一种处理承诺的模式，这种模式让我更容易理解和使用。</p><p id="a672" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里我们可以看到两个链接的函数，每个都是一个HTTP请求:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c063" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe na nb nc nd b">validateAddress</code>依赖来自<code class="fe na nb nc nd b">parseAddress</code>的结果，后者返回下一个函数需要的结果，依此类推…</p><p id="4e34" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过向父函数添加<code class="fe na nb nc nd b">async</code>，我们告诉JavaScript异步运行这个函数。一旦我们将<code class="fe na nb nc nd b">await</code>添加到任何内部函数调用中，它们将在移动到下一行之前完全解析。</p><p id="89c4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">多酷啊！</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="4736" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">文本的转换:</strong></p><p id="a2b5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们知道了如何将所有这些请求链接在一起，让我们更仔细地看看SMS文本在通过ShipEngine的端点时是如何转换的。</p><p id="a464" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们从一条自然语言短信开始，我们将它分离成一个字符串并保存到一个变量中。我们将它传递给ShipEngine <code class="fe na nb nc nd b">/recognize</code>端点进行解析。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/61bb42a087a79169df64254f38322e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*Tyx42g_YIIWLS4A4OBud4A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">SMS Text sent to ShipEngine’s language parser, <code class="fe na nb nc nd b">/recognize</code>.</figcaption></figure><p id="cf80" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">作为回报，我们收到这个格式化的地址。我们将这个对象保存到一个变量中，并将其发送到ShipEngine的<code class="fe na nb nc nd b">/validate</code>端点。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Ship Engine returns a nicely formatted object.</figcaption></figure><p id="3bdd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">作为回报，我们得到两个地址。<code class="fe na nb nc nd b">original_address</code>保持输入的地址，尽管有一些修正。例如，如果输入的文本不包含邮政编码，但包含地址的其余部分，那么它会很聪明地为我们添加邮政编码。</p><p id="043a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了一致性，<code class="fe na nb nc nd b">matched_address</code>对字段进行标准化。例如，“Street”变成了“ST ”,邮政编码更新为完整的九位数字。这减少了错误，使其成为真正的增值。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">/validate returns an Original and Matched object for verified addresses.</figcaption></figure><p id="d76b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这也很好，因为最终结果返回的对象在保存到数据库之前几乎不需要修改。我可以花更少的时间编写重复的规范化函数。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="6c23" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">使用GraphQL</h2><p id="de5a" class="pw-post-body-paragraph jz ka in kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw ig bi translated">这是我第一次为数据库创建非REST API，所以我非常依赖于官方的GraphQL文档，比如<a class="ae ky" href="https://graphql.org/graphql-js/running-an-express-graphql-server/" rel="noopener ugc nofollow" target="_blank"> Express </a>和<a class="ae ky" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> React </a>。请务必查看任何其他指南的出版日期，GraphQL自2012年就已问世！</p><p id="abcd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我的外卖…？GraphQL既强大又有趣。</p><p id="8d75" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">以下是我喜欢的:</p><ul class=""><li id="1eaf" class="mj mk in kb b kc kd kg kh kk mx ko my ks mz kw mo mp mq mr bi translated">所有请求都发送到您选择的同一个端点。</li><li id="bb93" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">你只要求你需要的信息。</li><li id="f70a" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">请求和变异的格式类似于对象。</li><li id="553a" class="mj mk in kb b kc ms kg mt kk mu ko mv ks mw kw mo mp mq mr bi translated">GraphiQL让测试变得异常简单。</li></ul><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/a3e961112d94241db2752c86567dfe91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*vyxrsl2-oQHf6hMGT_cU2w.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">GraphiQL in action</figcaption></figure><p id="e470" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意左边正在构建的请求。注意到输入变量时的自动完成功能了吗？🎸注意到通过红色小曲线的IDE风格的错误处理了吗？😎查看右边的完整结果。我喜欢它。</p><p id="b6af" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我在GraphiQL中测试了我所有的请求和变化，然后将它们直接复制/粘贴到我的代码中。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="027a" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">船舶引擎API</h2><p id="643e" class="pw-post-body-paragraph jz ka in kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw ig bi translated"><a class="ae ky" href="https://www.shipengine.com/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> ShipEngine的文档</a>让人印象深刻。它们是开发人员友好的，在简单解释概念的同时保持简洁和可读性之间找到了一个很好的平衡。</p><p id="9e03" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">沙盒API可以免费使用，设置也很快。你可以从Github获取<a class="ae ky" href="https://github.com/ShipEngine/code-samples" rel="noopener ugc nofollow" target="_blank">代码样本</a>，并在你自己的环境中练习。</p><p id="bb64" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我最喜欢的部分是<a class="ae ky" href="https://www.shipengine.com/docs/postman/" rel="noopener ugc nofollow" target="_blank">邮差系列</a>。他们所有的API调用都是用Postman预先编写好的，随时可以测试。你所要做的就是输入你的测试API密匙。试试吧，以后谢我。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/44b923f66fc8b8d3e1f5493e716ec231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*_BPaHaQgyYP5ssuJw08pAw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Postman bundled walkthrough</figcaption></figure><p id="d6b7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所有这些意味着在我的代码中实现ShipEngine很容易。我发现错误处理很有帮助，只是遇到一个不明确的错误。端点很快回复了我的请求。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="11d0" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">普利沃API</h2><p id="b8cb" class="pw-post-body-paragraph jz ka in kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw ig bi translated">坦白说，我很了解普利沃的文件，因为我为他们工作。这意味着我知道它们是详细的和维护的。另外，有大量的指南可以帮助你开始使用<a class="ae ky" href="https://www.plivo.com/docs/sms/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>，以及<a class="ae ky" href="https://www.plivo.com/docs/sms/use-cases/send-an-sms/node/" rel="noopener ugc nofollow" target="_blank">发送</a>和<a class="ae ky" href="https://www.plivo.com/docs/sms/use-cases/receive-sms/node#api-outline" rel="noopener ugc nofollow" target="_blank">接收</a>短信。</p><p id="0480" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注册需要一个公司电子邮件地址，在您购买点数之前，您只能向可以接收身份验证短信的号码发送短信。试用帐户是免费的，包括一些测试信用。</p><p id="9177" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦你在Plivo的网站上设置好了，在你的项目中实现SMS再简单不过了。这是发送短信的样子:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="f4f1" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">React应用？</h2><p id="1cad" class="pw-post-body-paragraph jz ka in kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw ig bi translated">你可能已经注意到我在堆栈中包含了一个React应用程序，但是我直到这篇博文的最后才提到它。</p><p id="0cef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然这个用例没有要求，但我觉得为了更全面地理解GraphQL，构建是很重要的。所以，React和Apollo都完全实现了。(Apollo帮助React管理本地和远程数据)</p><p id="54a1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在其当前状态下，前端简单地列出数据库中的所有标签，并带有查看其相应地址的选项。除了这些查询之外，我还添加了一些用于添加新地址和标签的查询。</p><p id="645a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我甚至对它们进行了测试，确保结果在DOM中更新，而无需刷新。这意味着这个应用程序只需一个表单就可以从数据库中添加或删除项目。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="b1ba" class="lg lh in bd li lj lk dn ll lm ln dp lo kk lp lq lr ko ls lt lu ks lv lw lx ly bi translated">下一步是什么？</h2><p id="3b71" class="pw-post-body-paragraph jz ka in kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw ig bi translated">这种概念验证已经准备好成长。</p><p id="5599" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">也许它会变成一个完整的聊天机器人，处理更详细的请求。</p><p id="75d2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">也许在React应用程序中，SMS会实时填充，以便您可以实时回复客户，回答开箱即用的问题。</p><p id="6c72" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">从<a class="ae ky" href="https://github.com/Josh-Gotro/ShipE" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的存储库中克隆项目，然后进行破解。请在评论中分享其他想法。我很想收到你的来信！</p><p id="292c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">谢谢大家！</p><p id="3cfc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">查看我的其他一些故事； <a class="ae ky" href="https://medium.com/swlh/use-ngrok-in-your-rails-project-398004195110" rel="noopener"> <em class="kx">在你的Rails项目中使用Ngrok</em></a><em class="kx">，或者</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-guide-to-creating-a-react-app-without-create-react-app-5337c5ac2ea0"> <em class="kx">创建React App而不创建-react-app </em> </a> <em class="kx">。在joshuagauthreaux@gmail.com或通过</em><a class="ae ky" href="https://www.joshgotro.com/" rel="noopener ugc nofollow" target="_blank"><em class="kx">joshgotro.com</em></a><em class="kx">联系我。</em></p><p id="62c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kx">plain English . io</em></a></p><p id="f529" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">**编辑:更新了承诺处理部分以使用最新模式，并更新了工作流部分以使其更加清晰。</p></div></div>    
</body>
</html>