<html>
<head>
<title>Introduction to Functional Testing in React Using React Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React测试库介绍React中的功能测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-functional-testing-in-react-using-react-testing-library-e83ab616e5b5?source=collection_archive---------9-----------------------#2021-05-25">https://javascript.plainenglish.io/introduction-to-functional-testing-in-react-using-react-testing-library-e83ab616e5b5?source=collection_archive---------9-----------------------#2021-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1989" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我们经历了一个简单的向购物车添加商品的工作流程</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/937b439efaafc0e6061d04ffd07330da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*77J4ZHpD5ENRicIP"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1e7d" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">什么是功能测试？</h1><p id="644a" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">你可能听说过三种常见的软件测试类型:单元测试、集成测试和端到端(e2e)测试。但是，您可能不熟悉术语<em class="mh">功能</em>测试。功能测试负责从<em class="mh">用户</em>的角度测试你的软件的<em class="mh">行为</em>。在某种程度上，单元和集成测试是功能测试的子集。我举个例子解释一下。</p><p id="cf28" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">单元:我有一个组件，它是一个表单中的单个输入，用于检查输入文本的有效性。然后，通过模拟可能的输入并验证输出来隔离测试该组件。</p><p id="a5cd" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated"><strong class="ln io">集成:</strong>表单内有两个阶段或组件。当一个阶段完成时，状态更新，第二个阶段变为使能。我们验证这两个组件一起工作。</p><p id="e33d" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated"><strong class="ln io">功能性:</strong>我们测试的是行为，而不是代码。从用户的角度来看，我们关心提交表单的功能，而不是单个组件的内部。</p><p id="85aa" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">总的来说，我们进行测试是因为我们希望对我们的软件按照我们期望的方式运行有高度的信心。我们还想让它对重构具有弹性，否则会破坏一些相关的功能。</p><h1 id="17ff" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><strong class="ak">什么是React测试库？</strong></h1><p id="ba91" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> React测试库</a> (RTL)是一个测试工具，允许我们测试React组件。实际的测试是使用一个<em class="mh">测试运行器</em>来执行的，它是一个实际执行我们的断言的库。我相信大多数测试库，如Mocha或Jasmine，都可以作为RTL的运行程序，但是在文档中使用的和最流行的似乎是Jest。</p><p id="f760" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">与专注于测试状态(内部)的<a class="ae ks" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>不同，RTL使用自己的虚拟DOM基于DOM进行测试。这对于功能测试来说是有意义的，因为我们最关心的是用户实际看到的和能够访问的内容。你可以在这里阅读更多关于RTL测试哲学的内容。</p><h1 id="f038" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">功能需求</h1><p id="0813" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我设置了一个小的演示程序，模拟用户向购物车添加商品。我认为这是一个有用的例子，因为这是一个你将在许多其他应用程序中看到的工作流。回购可在<a class="ae ks" href="https://github.com/MikeZ77/functional-testing-demo" rel="noopener ugc nofollow" target="_blank">这里</a>进行。稍后，我计划通过检查购物车中的商品来添加到这个演示中。这将允许我演示更多的测试模式，并展示RTL渲染的组件如何使用全局状态。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/15e1329290030d075c734d907dd26443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJ2Ir0y9AX0uMlA1A-tcqA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Store demo</figcaption></figure><p id="30f2" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">用户点击其中一个商品的<em class="mh">添加到购物车</em>按钮:</p><ul class=""><li id="84d6" class="mo mp in ln b lo mi lr mj lu mq ly mr mc ms mg mt mu mv mw bi translated">按钮图标<em class="mh">应该</em>显示从购物车中移除的图像。</li><li id="5394" class="mo mp in ln b lo mx lr my lu mz ly na mc nb mg mt mu mv mw bi translated">应该会出现一个绿色的toast<em class="mh"/>,通知用户该商品已经添加到他们的购物车中。</li><li id="cdab" class="mo mp in ln b lo mx lr my lu mz ly na mc nb mg mt mu mv mw bi translated">导航条<em class="mh">中的购物车图标</em>应该增加1。</li></ul><p id="949c" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">用户点击同一商品的<em class="mh">从购物车中移除</em>按钮:</p><ul class=""><li id="d9f2" class="mo mp in ln b lo mi lr mj lu mq ly mr mc ms mg mt mu mv mw bi translated">按钮图标<em class="mh">应</em>显示添加到购物车图像。</li><li id="bbb7" class="mo mp in ln b lo mx lr my lu mz ly na mc nb mg mt mu mv mw bi translated">一个红色的toast <em class="mh">应该会出现</em>，通知用户该商品已经从购物车中移除。</li><li id="6d14" class="mo mp in ln b lo mx lr my lu mz ly na mc nb mg mt mu mv mw bi translated">导航栏中的购物车图标<em class="mh">应该</em>减一。</li></ul><h1 id="7115" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><strong class="ak">测试</strong></h1><h2 id="3bf7" class="nc ku in bd kv nd ne dn kz nf ng dp ld lu nh ni lf ly nj nk lh mc nl nm lj nn bi translated">RTL基础</h2><p id="8ace" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在我们深入演示测试之前，您应该了解构建测试套件所需的基础知识。</p><ol class=""><li id="c469" class="mo mp in ln b lo mi lr mj lu mq ly mr mc ms mg no mu mv mw bi translated"><code class="fe np nq nr ns b">screen</code>对象表示我们的虚拟DOM，它包含一些供访问器查询的方法。<code class="fe np nq nr ns b">userEvent</code>对象包含与虚拟DOM中的元素交互的方法(比如用户点击)。</li><li id="fb15" class="mo mp in ln b lo mx lr my lu mz ly na mc nb mg no mu mv mw bi translated">为了从虚拟DOM中查询元素，我们需要一个访问器。最优选的是通过<strong class="ln io">角色</strong>访问，最不优选的是通过<strong class="ln io">测试id </strong>访问。<em class="mh">为什么？ARIA角色被构建到DOM中，并表示该元素的行为。test-id必须手动添加，并且不反映在DOM中。你可以在这里阅读更多关于这个<a class="ae ks" href="https://testing-library.com/docs/queries/about/#priority" rel="noopener ugc nofollow" target="_blank">的内容。</a></em></li><li id="4815" class="mo mp in ln b lo mx lr my lu mz ly na mc nb mg no mu mv mw bi translated">理解不同的查询及其细微差别非常重要。以<em class="mh"> find </em>开始的查询，例如<code class="fe np nq nr ns b">findBy</code>和<code class="fe np nq nr ns b">findAllBy</code> <strong class="ln io">等待</strong>异步操作。以<em class="mh">开头的查询得到</em>，例如<code class="fe np nq nr ns b">getBy</code>和<code class="fe np nq nr ns b">getAllBy</code> <strong class="ln io">如果没有找到元素，就会抛出</strong>错误。以<em class="mh">查询</em>开始的查询，例如<code class="fe np nq nr ns b">queryBy</code>和<code class="fe np nq nr ns b">queryAllBy</code>返回<strong class="ln io">空</strong>并且不抛出错误。你可以在这里 阅读更多关于这个<a class="ae ks" href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries" rel="noopener ugc nofollow" target="_blank"> <em class="mh">的内容。</em></a></li></ol><h2 id="6f1a" class="nc ku in bd kv nd ne dn kz nf ng dp ld lu nh ni lf ly nj nk lh mc nl nm lj nn bi translated">RTL设置</h2><p id="a9f2" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">因为设置相当简单，所以最好按照文档来做，因为我不需要添加太多东西。所涉及的大部分内容是安装必要的软件包。如果您使用<a class="ae ks" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建您的项目，那么大部分的包都已经设置好了，您只需要执行<code class="fe np nq nr ns b">yarn test</code>来运行您的测试。</p><h2 id="75d5" class="nc ku in bd kv nd ne dn kz nf ng dp ld lu nh ni lf ly nj nk lh mc nl nm lj nn bi translated">模拟服务人员</h2><p id="25d3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">模拟服务工作器(MSW)充当代理，拦截我们的请求并返回一些设置测试条件的预定义数据。使用模拟对于功能测试是必不可少的，因为这区别于e2e测试。功能测试忽略后端，并假设服务器和数据库按预期工作。</p><p id="2db7" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">参见MSW的<a class="ae ks" href="https://mswjs.io/docs/getting-started/install" rel="noopener ugc nofollow" target="_blank">设置</a>，这非常简单。在演示中，<code class="fe np nq nr ns b">mocks/server.js</code>将我们的REST API处理程序从<code class="fe np nq nr ns b">mocks/handlers.js</code>导入到服务器中。<code class="fe np nq nr ns b">setupTests.js</code>使用Jest的<code class="fe np nq nr ns b">beforeAll</code>、<code class="fe np nq nr ns b">afterEach</code>和<code class="fe np nq nr ns b">afterAll</code>在每次测试后创建和拆除模拟服务器。</p><h2 id="5f88" class="nc ku in bd kv nd ne dn kz nf ng dp ld lu nh ni lf ly nj nk lh mc nl nm lj nn bi translated">测试结构</h2><p id="6ddd" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">组件的结构使得<code class="fe np nq nr ns b">Store</code>是父组件，它包含并传递道具给三个子组件:<code class="fe np nq nr ns b">Message</code>、<code class="fe np nq nr ns b">Navbar</code>和<code class="fe np nq nr ns b">ProductList</code>。<code class="fe np nq nr ns b">Store</code>包含组件之间的所有逻辑(状态)。因此，创建一个单一的测试文件<code class="fe np nq nr ns b">Store.test.js</code>是最有意义的，它贯穿整个工作流程，只呈现<code class="fe np nq nr ns b">Store</code>组件。</p><p id="6027" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">现在，考虑另一个更加模块化的组件结构，其中<code class="fe np nq nr ns b">Message</code>、<code class="fe np nq nr ns b">Navbar</code>和<code class="fe np nq nr ns b">ProductList</code>使用它们自己的状态。也许每个组件都有自己的请求(我们会为每个组件提供MSW处理程序)。现在，通过创建<code class="fe np nq nr ns b">tests/Navbar.test.js</code>、<code class="fe np nq nr ns b">tests/Message.test.js</code>和<code class="fe np nq nr ns b">tests/ProductList.test.js</code>来分别渲染和测试这些组件是有意义的。点击<a class="ae ks" href="https://github.com/testing-library/react-testing-library/issues/167" rel="noopener ugc nofollow" target="_blank">此处</a>查看与此相关的有趣讨论以及<a class="ae ks" href="https://kentcdodds.com/" rel="noopener ugc nofollow" target="_blank"> Kent C. Dodd </a>的回应。</p><h2 id="9711" class="nc ku in bd kv nd ne dn kz nf ng dp ld lu nh ni lf ly nj nk lh mc nl nm lj nn bi translated">商店.测试. js</h2><p id="3dea" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">就实际的测试文件而言，因为Jest语法可读性很强，所以我将只指出几个更有趣的断言。jest-dom文档可从<a class="ae ks" href="https://github.com/testing-library/jest-dom" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="acd0" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated"><code class="fe np nq nr ns b">test</code>中的第一个参数是描述测试内容的字符串。第二个参数(回调)是异步的，因为我们执行了一个异步事件(调用https://random-data-api.com/api/coffee/random_coffee的<a class="ae ks" href="https://random-data-api.com/api/coffee/random_coffee" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="d8ed" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">正如《RTL优先》中所讨论的，我尽可能地尝试使用<strong class="ln io">角色</strong>。但是线<code class="fe np nq nr ns b">const cartCount = screen.getByTestId('cart-count')</code>使用<strong class="ln io">测试id </strong>。根据文档，当文本是动态的时，使用test-id是可以接受的。</p><p id="c769" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">查询<code class="fe np nq nr ns b">screen.getByRole(‘button’, { pressed: true })</code>通过来自<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/button_role" rel="noopener ugc nofollow" target="_blank">按钮角色</a>的ARIA属性进行搜索。包含ARIA属性的对象的例子可以在<a class="ae ks" href="https://testing-library.com/docs/queries/byrole" rel="noopener ugc nofollow" target="_blank">这里</a>找到。出于测试目的，<code class="fe np nq nr ns b">pressed: true</code>表示该项目已添加，<code class="fe np nq nr ns b">pressed: false</code>表示该项目未添加。我认为这里的<em class="mh">复选框</em>角色更适合这个功能，尽管这个元素是一个按钮。</p><p id="360e" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">当我们期望<code class="fe np nq nr ns b">screen.queryByRole(‘button’, { pressed: true })</code>不在文档中时，注意我们使用<code class="fe np nq nr ns b">queryByRole</code>而不是<code class="fe np nq nr ns b">findByRole</code>。原因是<code class="fe np nq nr ns b">findByRole</code>会抛出一个错误，并在那时破坏我们的测试。</p><p id="93e4" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">提醒toast在DOM中变得可见和不可见。如果您运行演示程序，您会注意到当前的toast关闭了，在新的toast打开之前还有一段时间。使用<code class="fe np nq nr ns b">waitFor</code>连续查询DOM，直到找到元素(在我们的例子中，最终应该找到)。</p><h2 id="d669" class="nc ku in bd kv nd ne dn kz nf ng dp ld lu nh ni lf ly nj nk lh mc nl nm lj nn bi translated">关于测试驱动开发的一点注记</h2><p id="00c7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">测试驱动开发(TDD)就是在编写代码之前编写测试的过程。举例来说，我们不是从<code class="fe np nq nr ns b">Store.js</code>开始，而是开始用<code class="fe np nq nr ns b">Store.test.js</code>编写测试。这里的目标是最终让您在<code class="fe np nq nr ns b">Store.test.js</code>中的所有测试都通过。我喜欢这个想法，这也是我的目标。也就是说，在实践中很难执行，因为:</p><ul class=""><li id="acb8" class="mo mp in ln b lo mi lr mj lu mq ly mr mc ms mg mt mu mv mw bi translated">您需要能够轻松地编写测试，并对库有所了解。如果您不是，那么您可能会在特性实现后通过修改测试来完成双倍的工作(编写测试的方式可能需要完全改变)。</li><li id="c995" class="mo mp in ln b lo mx lr my lu mz ly na mc nb mg mt mu mv mw bi translated">在实现该特性之前，您真的必须考虑并概述它的确切需求。这显然是一个好处，但在开始时可能会很耗时。</li></ul><p id="f802" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">总的来说，我认为TDD使编写测试变得不那么乏味。通过在工作中集成测试，您可以避免花费大量时间编写测试套件。</p><h1 id="fa3f" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">结论</h1><p id="3da8" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">希望这些信息可以作为测试您自己的React应用程序的良好起点。这些测试也可以很容易地集成到您的CI/CD管道中。实践也是很好的，因为这表明你有能力编写高质量的代码。</p><p id="f587" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">我喜欢功能测试，因为在我看来，它消除了执行e2e测试的需要。e2e测试框架的一个例子是带有Selenium web驱动程序的Jest。从我的经验来看，我发现编写e2e测试更加耗时且脆弱。您还需要任何相关的后端服务设置和任何填充了模拟数据的数据库。一种常见设置是用填充的shell脚本编写docker-compose。</p><p id="c59e" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">请随时留下任何意见或建议。</p><div class="nv nw gp gr nx ny"><a href="https://github.com/MikeZ77/functional-testing-demo" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd io gy z fp od fr fs oe fu fw im bi translated">Mike z77/功能测试演示</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">在GitHub上创建一个帐户，为Mike z77/功能测试演示开发做贡献。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om km ny"/></div></div></a></div><p id="3118" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated"><em class="mh">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="mh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>