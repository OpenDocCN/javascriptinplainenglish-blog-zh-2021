<html>
<head>
<title>Master React With Ease: Understand Event Bubbling Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大师轻松应对:像专家一样理解事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/master-react-with-ease-understand-event-bubbling-like-a-pro-part-2-62870b0ac1a2?source=collection_archive---------15-----------------------#2021-08-30">https://javascript.plainenglish.io/master-react-with-ease-understand-event-bubbling-like-a-pro-part-2-62870b0ac1a2?source=collection_archive---------15-----------------------#2021-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1775" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分——了解更多关于事件冒泡的知识以及一个特殊的边缘案例！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8e965e1ed2044bb63b8b9e43cd6ea96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4z_omNjd1nSngguUrJIHg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image by <a class="ae ks" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank">PixaBay</a></figcaption></figure><p id="811f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">欢迎来到《轻松应对大师》</strong>，这是一个<strong class="kv io"> </strong>系列节目，旨在帮助你以一种超级清晰易懂的方式理解《❤》</p><p id="3523" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<strong class="kv io">像专家一样理解事件冒泡的第1部分中，</strong>您学习了<strong class="kv io">所有您需要知道的关于<strong class="kv io">事件冒泡</strong>的知识，以便立即开始在您的项目中应用它！</strong></p><p id="890a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在第2部分<strong class="kv io">像专家一样理解事件冒泡</strong>中，我将分享更多的提示和技巧，以及如何处理下一个React应用中很可能出现的边缘情况！让我们开始吧！</p><p id="b6ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天，您将了解:</p><ul class=""><li id="0705" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io"> ✨ </strong> <a class="ae ks" href="#dfc9" rel="noopener ugc nofollow"> <strong class="kv io">事件.目标vs事件.当前目标</strong> </a></li><li id="0750" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io"> ✨ </strong> <a class="ae ks" href="#1601" rel="noopener ugc nofollow"> <strong class="kv io">实际更新的事件触发顺序和JavaScript中的useCapture参数</strong> </a></li><li id="1e0b" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io"> ✨ </strong> <a class="ae ks" href="#cd10" rel="noopener ugc nofollow"> <strong class="kv io">哪些事件没有泡沫，是如何处理的？</strong> </a></li><li id="90ae" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io"> ✨ </strong> <a class="ae ks" href="#d399" rel="noopener ugc nofollow"> <strong class="kv io">事件监听器在React版本16及之前VS版本17+ </strong> </a></li><li id="83ae" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io"> ✨ </strong>T46】</li></ul></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="dfc9" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">事件.目标vs事件.当前目标</strong></h1><p id="044b" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">理解<code class="fe nh ni nj nk b">Event</code>对象上这两个目标属性之间的区别真的可以让你以后不再头疼。</p><p id="5369" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">记住:</strong><strong class="kv io"/><strong class="kv io">触发事件</strong>的 <strong class="kv io">元素与附加了事件监听器的<strong class="kv io">元素并不总是</strong>相同。</strong></p><p id="0f91" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">🤔迷茫？别担心，让我和他们一起度过这一关。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://media.giphy.com/media/lT9Y1nrHdZWX9QoSH0/giphy.gif" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="011a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们以前面第1部分中的例子<strong class="kv io">为例，像专业的</strong>和<code class="fe nh ni nj nk b">console.log</code>一样理解父div事件处理程序中的<code class="fe nh ni nj nk b">event.target</code>和<code class="fe nh ni nj nk b">event.currentTarget</code>事件冒泡。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn nm l"/></div></figure><p id="903a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，当我们点击<code class="fe nh ni nj nk b">Cook Eggs</code>按钮时，我们会看到什么？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/8f5132249a4c705a31b9ad1aa2005a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsa9G6YzGb_Zk01VpvrDZw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image by Mariya Diminsky(me)</figcaption></figure><p id="74f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意父div的事件处理程序知道<strong class="kv io">预期的</strong> <code class="fe nh ni nj nk b">target</code> <strong class="kv io">是</strong> <strong class="kv io">按钮</strong>。</p><p id="5256" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">但是</strong> —因为我们正在检查父事件处理程序中的<strong class="kv io">，我们看到父div是<code class="fe nh ni nj nk b">currentTarget</code>。</strong></p><p id="7891" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好吧，让我们深入研究一下。</p><p id="0fc1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们使用相同的<code class="fe nh ni nj nk b">console.log</code>并在实际的<strong class="kv io">按钮的事件处理程序</strong>中进行检查会怎么样？</p><p id="7f3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">🤔我们现在会看到什么？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn nm l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/33cbec790bf09c14e937887de7681df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IV3uK_XIDvRvRqJYC8j4QQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image by Mariya Diminsky(me)</figcaption></figure><p id="0ef7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，由于我们现在正在检查<strong class="kv io">按钮的事件处理程序</strong>内部，我们看到<code class="fe nh ni nj nk b">currentTarget</code> <strong class="kv io">已经变成了按钮</strong>。</p><p id="f14a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，由于我们正在点击按钮，我们已经知道<code class="fe nh ni nj nk b">target</code>将再次成为<code class="fe nh ni nj nk b">button</code>。</p><p id="3742" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑到您刚刚学到的内容，现在您知道:</p><p id="6298" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nh ni nj nk b">ℹ️ event.target</code>是导致事件的<strong class="kv io">嵌套最深的元素。</strong></p><p id="9673" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nh ni nj nk b">ℹ️ event.currentTarget</code>是 <strong class="kv io">监听事件</strong>的<strong class="kv io">元素(事件监听器附加于此)。</strong></p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="1601" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">实际更新的事件触发顺序和JavaScript中的useCapture参数</strong></h1><p id="58ba" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">在JavaScript中,<code class="fe nh ni nj nk b">EventTarget.addEventListener</code>将用于为事件添加一个处理程序。</p><p id="dff4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们看一下<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>时，我们看到您可以在<code class="fe nh ni nj nk b">options</code>对象中可选地设置<code class="fe nh ni nj nk b">capture</code>，或者通过<code class="fe nh ni nj nk b">useCapture</code>参数(现在也是可选的)，这做同样的事情。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn nm l"/></div></figure><p id="af49" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">⚠️这是因为除非你特别设置，否则捕获阶段将被忽略，取而代之的是，<strong class="kv io">只有冒泡阶段(在目标阶段之后)会在JavaScript中被本地触发</strong>。MDN也解释了这一点:</p><blockquote class="nq"><p id="f5ef" class="nr ns in bd nt nu nv nw nx ny nz lo dk translated">对于附加到事件目标的事件侦听器，事件处于目标阶段，而不是捕获和冒泡阶段。“捕获”阶段的事件侦听器在任何非捕获阶段的事件侦听器之前被调用。</p></blockquote><p id="9775" class="pw-post-body-paragraph kt ku in kv b kw oa jo ky kz ob jr lb lc oc le lf lg od li lj lk oe lm ln lo ig bi translated"><em class="of">请注意:</em> <code class="fe nh ni nj nk b"><em class="of">useCapture</em></code> <em class="of">参数在旧版浏览器中并不总是可选的。确保在实施之前检查</em><a class="ae ks" href="https://caniuse.com/?search=usecapture" rel="noopener ugc nofollow" target="_blank"><em class="of">【caniuse.com】</em></a><em class="of">。</em></p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="cd10" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">哪些事件不冒泡，如何处理？</strong></h1><p id="de33" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">虽然大多数事件都是泡沫化的，但你知道有几个不是吗？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="og nm l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://giphy.com/gifs/no-nope-bounce-T5QOxf0IRjzYQ" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="86f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这里有一些本地JavaScript的例子:</strong></p><ul class=""><li id="a978" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event" rel="noopener ugc nofollow" target="_blank">模糊</a> ( <a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/focusout_event" rel="noopener ugc nofollow" target="_blank">聚焦</a>是一样的，但实际上是冒泡)。</li><li id="a68a" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/focus_event" rel="noopener ugc nofollow" target="_blank">focus</a>(<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/focusin_event" rel="noopener ugc nofollow" target="_blank">focus in</a>是一样的，但它实际上是冒泡的)。</li><li id="0f58" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event" rel="noopener ugc nofollow" target="_blank">mouse leave</a>(<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event" rel="noopener ugc nofollow" target="_blank">mouse out</a>是一样的但是实际上是冒泡的)。</li><li id="3ffd" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event" rel="noopener ugc nofollow" target="_blank">鼠标进入</a> ( <a class="ae ks" href="https://transang.me/everything-about-event-bubbling/mouseover" rel="noopener ugc nofollow" target="_blank">鼠标悬停</a>是相同的，但它实际上冒泡)。</li><li id="1764" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event" rel="noopener ugc nofollow" target="_blank">加载</a>，<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event" rel="noopener ugc nofollow" target="_blank">卸载</a>，<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/abort_event" rel="noopener ugc nofollow" target="_blank">中止</a>，<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/error_event" rel="noopener ugc nofollow" target="_blank">错误</a>，<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event" rel="noopener ugc nofollow" target="_blank">卸载前</a>。</li></ul><p id="8a4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">⚠️:当 <code class="fe nh ni nj nk b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event" rel="noopener ugc nofollow" target="_blank">Event</a></code> <a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event" rel="noopener ugc nofollow" target="_blank">被创建</a>时，确实冒泡的事件在<code class="fe nh ni nj nk b">bubbles</code>选项<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event" rel="noopener ugc nofollow" target="_blank">上设置了<code class="fe nh ni nj nk b">true</code>——尽管它们仍然经过捕获阶段。</a></p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="d399" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">React版本16和VS版本17+之前版本中的事件侦听器</strong></h1><p id="dfa1" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">正如您在第1部分<strong class="kv io">中了解到的，像专业人员一样理解事件冒泡——React的</strong> <strong class="kv io">合成事件并不总是像它们的本地JavaScript对等物一样工作。</strong></p><p id="b41a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们了解一下这些差异以及React版本之间的变化。</p><h2 id="da1a" class="oh ml in bd mm oi oj dn mq ok ol dp mu lc om on mw lg oo op my lk oq or na os bi translated">ℹ️事件你不会料到泡泡会有什么反应</h2><p id="fe45" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">例如，你可能会认为React的<code class="fe nh ni nj nk b">onBlur</code>和<code class="fe nh ni nj nk b">onFocus</code>不会冒泡，因为JavaScript的本地等价物不会冒泡，对吗？然而React故意让这些事件继续冒泡。</p><p id="588c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">⚠️虽然React版本17对某些事件做了一些改变，比如T5不再冒泡，但大多数事件仍然继续冒泡。</p><p id="67d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">参见<a class="ae ks" href="https://stackoverflow.com/questions/34926910/onfocus-bubble-in-react" rel="noopener ugc nofollow" target="_blank">这个答案</a>和<a class="ae ks" href="https://www.quirksmode.org/blog/archives/2008/04/delegating_the.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>了解更多关于这个话题的细节。</p><h2 id="61ac" class="oh ml in bd mm oi oj dn mq ok ol dp mu lc om on mw lg oo op my lk oq or na os bi translated"><code class="fe nh ni nj nk b">ℹ️ event.target.value</code>曾经在异步函数中无效</h2><p id="e76e" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">在React版本17之前，<strong class="kv io">如果你试图访问一个异步函数中的事件，你会注意到它是未定义的</strong>。</p><p id="3517" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为React的<strong class="kv io">合成事件</strong>对象被池化了——这意味着在事件处理程序被调用后，<strong class="kv io">您将不再能够访问它们，因为它们将被重置并放回池中。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot nm l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://giphy.com/gifs/NsZbrSS0miha0/links" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ou"><img src="../Images/7975cc938340ba4502e15ece6d47c111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idSC3MkrCThhVajbe-kBEQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image from <a class="ae ks" href="https://reactjs.org/docs/legacy-event-pooling.html" rel="noopener ugc nofollow" target="_blank">React</a></figcaption></figure><p id="f601" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">显然，这给需要在稍后时间访问该事件中的信息<strong class="kv io">的<strong class="kv io">异步函数</strong>带来了问题。</strong></p><p id="a41e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">⚠️在异步函数中保存这些信息的唯一方法是调用<code class="fe nh ni nj nk b">event.persist()</code>:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/f55122df561f208240748c1fee640ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWGxsyRyPvoZ0qFUZam9cQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image from <a class="ae ks" href="https://reactjs.org/docs/legacy-event-pooling.html" rel="noopener ugc nofollow" target="_blank">React</a></figcaption></figure><p id="02e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样做的<strong class="kv io">意图</strong>是为了<strong class="kv io">提高性能</strong>，但是经过更仔细的检查，React的团队发现这只是<strong class="kv io">迷惑了开发者</strong>而<strong class="kv io">实际上</strong> <strong class="kv io">并没有真正提高性能</strong>所以它完全被废弃了。</p><p id="5519" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">随着<strong class="kv io"> React版本17 </strong>的发布，<strong class="kv io"> React不再池化合成事件对象，所以你可以期望在你的异步函数</strong>中接收预期的 <code class="fe nh ni nj nk b"><strong class="kv io">event.target.value</strong></code> <strong class="kv io">，而不需要<code class="fe nh ni nj nk b">event.persist()</code>。</strong></p><p id="4469" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请务必在这里阅读更多关于本次更新<a class="ae ks" href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling" rel="noopener ugc nofollow" target="_blank">的信息。</a></p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="977b" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated"><strong class="ak">特殊边缘案例:如果你也需要一个外亲来火呢？</strong></h1><p id="1f44" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">让我们利用你在第1部分学到的一切，像专家一样理解事件冒泡，在你的下一个React应用中修复一个特殊的边缘情况！</p><p id="5a9b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">🤔假设我们希望在我们的应用程序中有这两个工作:</strong></p><ol class=""><li id="fdd5" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo ow lv lw lx bi translated">当用户点击内部div/按钮等时。元素，我们希望只触发该事件(或者在下面的例子中，在电视上换频道)。</li><li id="2442" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo ow lv lw lx bi translated">当用户单击外部父div时，将触发该父div的事件。(这可能对弹出模式有用。当用户在模式外单击时，您希望弹出窗口关闭——或者在下面的例子中，电视重新打开。</li></ol><p id="a0e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">目前，您知道如果您单击父/子元素，React的<strong class="kv io">合成事件</strong>系统将触发冒泡。</p><p id="d919" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你也知道要阻止这一切我们可以使用<code class="fe nh ni nj nk b">event.stopPropagation()</code>。</p><p id="16cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是我们现在进退两难。</p><p id="f7c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您希望一个事件处理程序在一种情况下触发(我们的#1)，而另一个事件处理程序在另一种情况下触发(#2)，该怎么办？</p><p id="b295" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">⚠️:如果我们使用<code class="fe nh ni nj nk b">event.stopPropagation()</code>，它将阻止一个事件处理程序触发，但这样你将永远无法在另一种情况下调用另一个事件处理程序。我们如何解决这个问题？</p><p id="9d51" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了解决这个问题，让我们利用React的状态模式！</p><p id="83ac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="of">请注意:我在这里使用了箭头函数，所以</em> <code class="fe nh ni nj nk b"><em class="of">bind</em></code> <em class="of"> ing状态是不必要的。如果你不确定这意味着什么，请随意阅读我写的关于这个话题的另一篇文章</em> <a class="ae ks" href="https://medium.com/free-code-camp/learn-es6-the-dope-way-part-ii-arrow-functions-and-the-this-keyword-381ac7a32881" rel="noopener"> <em class="of">这里</em> </a> <em class="of">。</em></p><p id="7e95" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> ℹ️下面我已经包括了一个React类组件版本和一个React钩子版本——你喜欢哪个就用哪个。请务必仔细阅读评论:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn nm l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Example written as a Component Class</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn nm l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Example written as a Functional Component utilizing React Hooks</figcaption></figure><p id="1571" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">🤔下面是我们运行代码时发生的情况:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ox nm l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://giphy.com/gifs/WsHmCK3B52FzQkl80s" rel="noopener ugc nofollow" target="_blank">Mariya Diminsky</a></figcaption></figure><ol class=""><li id="77be" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo ow lv lw lx bi translated">当我们点击<code class="fe nh ni nj nk b">Change Channel</code>时，频道增加。请注意，其他两个事件处理程序不运行。</li><li id="940a" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo ow lv lw lx bi translated">当我们单击<code class="fe nh ni nj nk b">Turn Off TV</code>时，UI会改变，如果我们试图单击父div之外的任何地方，其他两个事件处理程序不会运行。</li><li id="bacc" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo ow lv lw lx bi translated">当我们在电视关闭的情况下单击外部父div时，只有一个事件处理程序在运行。</li></ol><p id="44bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="of">请注意:在我上面的例子中，我使用的是</em> <code class="fe nh ni nj nk b"><em class="of">state = {}</em></code> <em class="of">而不是</em> <code class="fe nh ni nj nk b"><em class="of">constructor(){...}</em></code> <em class="of">，因为当</em> <code class="fe nh ni nj nk b"><em class="of">Babel</em></code> <em class="of">(一个JavaScript编译器)转换你的React代码时，它会吐出一个</em> <code class="fe nh ni nj nk b"><em class="of">constructor</em></code> <em class="of">以及里面的所有内容。如果你知道这一点，可以随意跳过下图:</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/38580b127a1696e2d174351b3748a233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWNs-VNV5Z4cY-bv95HspQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot by Mariya Diminsky taken from <a class="ae ks" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">Babel</a></figcaption></figure><h2 id="9572" class="oh ml in bd mm oi oj dn mq ok ol dp mu lc om on mw lg oo op my lk oq or na os bi translated">更简单的修复方法！</h2><p id="b5bd" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">这是解决问题的一种方法，但是还有一个更简单的方法！</p><p id="0ee0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">只需检查事件处理程序内部的<code class="fe nh ni nj nk b">target</code>(点击的内容)是否与<code class="fe nh ni nj nk b">eventTarget</code>(监听事件的事件处理程序)相同。</p><p id="f48d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果是一样的，那你就直接叫<code class="fe nh ni nj nk b">stopPropagation</code>好了！下面是一个简单的例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn nm l"/></div></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="4297" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你已经完成了<strong class="kv io">的第2部分，像<strong class="kv io">大师轻松应对</strong>系列中的专家</strong>一样理解事件冒泡！耶！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oz nm l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://media.giphy.com/media/SVs0cQ0nLRsLNUadmn/giphy.gif" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="cd87" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在你知道了:</p><ul class=""><li id="e01c" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io"/><code class="fe nh ni nj nk b">Event.target</code><strong class="kv io">和</strong> <code class="fe nh ni nj nk b">Event.currentTarget</code> <strong class="kv io">的区别以及被触发的事件并不总是与附加了事件监听器的事件相同。</strong></li><li id="45bf" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">事件传播在现代JavaScript中是如何发生的，如果需要使用捕获阶段，如何使用</strong> <code class="fe nh ni nj nk b">useCapture</code> <strong class="kv io">参数。</strong></li><li id="ad5b" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">你知道了不是所有的事件都会在本地JavaScript中冒泡，它们的一些别名也会冒泡。</strong></li><li id="1c6f" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">您还了解到，几乎所有React的合成事件(除了React版本17中的一些更新)都会冒泡。</strong></li><li id="0b3c" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><strong class="kv io">最后，您现在更好地理解了如何利用React state来处理外部父类需要触发而不停止其他事件处理程序的边缘情况。</strong></li></ul></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="ae48" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">更多资源/延伸阅读:</strong></p><ul class=""><li id="71a0" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">https://www.youtube.com/watch?v=Q6HAJ6bz7bY<a class="ae ks" href="https://www.youtube.com/watch?v=Q6HAJ6bz7bY" rel="noopener ugc nofollow" target="_blank"/></li><li id="1d4c" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">【https://javascript.info/bubbling-and-capturing T4】</li><li id="1f64" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://www.w3.org/TR/uievents/" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/TR/uievents/</a></li><li id="31d0" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://chrisrng.svbtle.com/event-propagation-and-event-delegation" rel="noopener ugc nofollow" target="_blank">https://Chris RNG . svbtle . com/event-propagation-and-event-delegation</a></li><li id="ed35" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated"><a class="ae ks" href="https://jsbin.com/hilome/edit?js,output" rel="noopener ugc nofollow" target="_blank">https://jsbin.com/hilome/edit?js,output</a></li></ul></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="f915" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> ✨🥰如果您喜欢这篇文章，并且想了解更多关于React主题的信息，请关注以获取最新更新🎉</strong></p><p id="ab80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="of">更多内容看</em> <a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="of">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>