<html>
<head>
<title>How to Fail with Style: Error Boundaries in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在风格上失败:React中的错误界限</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-fail-with-style-error-boundaries-in-react-402d8a8f53de?source=collection_archive---------10-----------------------#2021-01-18">https://javascript.plainenglish.io/how-to-fail-with-style-error-boundaries-in-react-402d8a8f53de?source=collection_archive---------10-----------------------#2021-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b39b8d306dfebde4794d3ea13b1d1112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Yy0i3pUhLvSXGVLNPlQlw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@heatherbarnes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Heather Barnes</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="0af5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构建用户界面的过程中，处理意外行为与处理预期行为同样重要。即使有世界上所有的测试，有人，在某个地方，<em class="lb">会</em>(意外地)找出如何破解你的应用。即使是最可靠的网络也会在某个时候出现故障。</p><p id="b761" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然预测和回避每一种可能性是不可能的，但我们可以承认广义上它会发生。</p><p id="573b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对这些事件的优雅处理对于积极的用户体验是必不可少的。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="325c" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">未处理的JavaScript错误</h1><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/fe3aff59777562db6c5e9e72a85a63e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJ1oPS6pvdOhMsX6M-FwrA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@kylejglenn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kyle Glenn</a> on <a class="ae jd" href="https://unsplash.com/s/photos/unknown?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ffd6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果任其自生自灭，JavaScript基本上可以将你的整个应用从一个简单、可怕的<code class="fe mm mn mo mp b">cannot read property &lt;property_name&gt; of undefined</code>中分离出来。好消息是，每年我们都有更多的工具来帮助避免这些错误。例如，引入可选链接有助于避免这个问题。坏消息是，如果不加处理，这些工具最多也只会让你的应用处于不稳定状态。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="e8aa" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">反应误差边界</h1><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/6e6b4e6feaa02ec5af1e7b8b32502786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKn87JnWeooNb0Qxy85x3g.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jd" href="https://unsplash.com/s/photos/restricted?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e2d6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，React保护了我们。React 16引入了错误边界的概念。正如<a class="ae jd" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">文档</a>所解释的:</p><blockquote class="mr"><p id="a680" class="ms mt jg bd mu mv mw mx my mz na la dk translated">错误边界是React组件，<strong class="ak">捕捉子组件树中任何地方的JavaScript错误，记录这些错误，并显示一个回退UI </strong>，而不是崩溃的组件树。</p></blockquote><p id="220c" class="pw-post-body-paragraph kd ke jg kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">本质上，错误边界允许您将错误的负面影响限制在发生错误的特定组件中。不过，需要注意的是，错误边界<strong class="kf jh">不会捕捉事件处理程序内部发生的错误。</strong>即使有这样的限制，解决方案也比整个DOM变成一个带有堆栈跟踪的错误消息更好，对吗？</p><p id="e642" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">快速注释</em> : <em class="lb">在撰写本文时，还没有我们将使用的生命周期方法的钩子等价物，所以我们将引用经典的</em> <code class="fe mm mn mo mp b"><em class="lb">React.Component</em></code> <em class="lb">而不是功能组件。</em></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="5058" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">建立边界</h1><p id="0e4b" class="pw-post-body-paragraph kd ke jg kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">错误边界不是添加到现有组件中的代码，而是用于包装其他组件的单独组件。误差边界分量有四个主要特征:</p><ol class=""><li id="ddaf" class="nl nm jg kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">在状态中维护布尔错误状态</li><li id="f3a7" class="nl nm jg kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">使用<code class="fe mm mn mo mp b">componentDidCatch()</code></li><li id="865a" class="nl nm jg kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated"><code class="fe mm mn mo mp b">static getDerivedStateFromError()</code>的使用</li><li id="8e73" class="nl nm jg kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">要呈现的自定义回退用户界面</li></ol><p id="84b1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要求您同时使用<code class="fe mm mn mo mp b">componentDidCatch()</code>和<code class="fe mm mn mo mp b">static getDerivedStateFromError()</code>，但是它们的用途完全不同，因此我们将在这里同时介绍它们。</p><h2 id="3ccb" class="nz lk jg bd ll oa ob dn lp oc od dp lt ko oe of lx ks og oh mb kw oi oj mf ok bi translated">componentDidCatch()</h2><blockquote class="mr"><p id="2f9c" class="ms mt jg bd mu mv mw mx my mz na la dk translated">这个生命周期是在子代组件抛出错误后调用的。</p></blockquote><p id="f433" class="pw-post-body-paragraph kd ke jg kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">以上来自<a class="ae jd" href="https://reactjs.org/docs/react-component.html#componentdidcatch" rel="noopener ugc nofollow" target="_blank"> React文档</a>。<code class="fe mm mn mo mp b">componentDidCatch()</code>的操作类似于你可能熟悉的标准<code class="fe mm mn mo mp b">catch</code>模块。它在子体内部抛出错误时被触发，并允许您对实际的错误信息做一些事情，比如记录它。</p><p id="da9e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该方法接受两个参数，即错误对象和堆栈跟踪，这两个参数都有助于调试。</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/4417e5cfd28dc3184251f5fb12d853d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOm8PqJhlx7EkhfCPrIi9g.png"/></div></div></figure><h2 id="4632" class="nz lk jg bd ll oa ob dn lp oc od dp lt ko oe of lx ks og oh mb kw oi oj mf ok bi translated">静态getDerivedStateFromError()</h2><blockquote class="mr"><p id="a652" class="ms mt jg bd mu mv mw mx my mz na la dk translated">这个生命周期是在子代组件抛出错误后调用的。它接收作为参数抛出的错误，并应该返回值以更新状态。</p></blockquote><p id="065c" class="pw-post-body-paragraph kd ke jg kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">以上也是由<a class="ae jd" href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromerror" rel="noopener ugc nofollow" target="_blank">官方文件</a>提供的。<code class="fe mm mn mo mp b">componentDidCatch()</code>是开发者的朋友，但<code class="fe mm mn mo mp b">static getDerivedStateFromError()</code>是用户的朋友。这种生命周期方法是我们创建优雅处理的地方，而且非常简单。</p><p id="e34e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个生命周期方法中，我们所要做的就是将维护的错误状态设置为<code class="fe mm mn mo mp b">true</code>。</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi om"><img src="../Images/a805475f13f213ba4ad65b4ba409a304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GN7AZqr-JqYjbszaXJvfXw.png"/></div></div></figure><h2 id="9b90" class="nz lk jg bd ll oa ob dn lp oc od dp lt ko oe of lx ks og oh mb kw oi oj mf ok bi translated">误差边界组件</h2><p id="e54e" class="pw-post-body-paragraph kd ke jg kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">ErrorBoundary组件将包括错误的状态以及上述两种生命周期方法，并将有条件地呈现回退UI或错误边界组件的子组件。让我们把这些放在一起:</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/a1eeab490be83350068f6278eacea263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwgJCNBoJfHn1P4ZaSAUzA.png"/></div></div></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="3c64" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">实现边界</h1><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/8a8f0ee1a19fb81b7b339361f17c6acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkthbJPzkww3Yrl6_HO3Mw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@nynnes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nynne Schrøder</a> on <a class="ae jd" href="https://unsplash.com/s/photos/wrapped?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bf1a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的错误边界组件现在可以用来整齐地包装您想要在其上创建边界的其他组件:</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/7188c1fcc1af0ca65663117f678ea6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RPRinCtK0KXYL1tYcHH1RA.png"/></div></div></figure><p id="1539" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，您可以利用<a class="ae jd" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>使您的<code class="fe mm mn mo mp b">ErrorBoundary</code>组件更加动态，并根据被包装的组件接受不同的回退UI:</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi op"><img src="../Images/f5ea2e0d6cbcb4135c91aa28a6c2c762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZEwF5mdvdLBzzIIoKnmwQ.png"/></div></div></figure><p id="43b0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">决定包装哪些组件很大程度上取决于应用程序。在某些情况下，您可能希望包装较低级别的单个组件，导致在出现错误时，部分UI被回退UI所替换。在其他情况下，您可能希望包装更高级别的组件，并为正在访问的页面使用更通用的回退UI。</p><p id="7b58" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这两种情况下，边界将捕获来自包装组件的所有后代的错误。一种方法并不比另一种更好，您选择哪种方法在很大程度上取决于上下文、组件树中的依赖关系、逻辑、优先级、用户体验和个人偏好。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="e9c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以使用React的<a class="ae jd" href="https://codepen.io/gaearon/pen/wqvxGa?editors=0010" rel="noopener ugc nofollow" target="_blank"> CodePen </a>来寻找错误边界，并查看<a class="ae jd" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">文档</a>来了解更多信息。</p></div></div>    
</body>
</html>