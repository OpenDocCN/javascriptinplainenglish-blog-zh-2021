<html>
<head>
<title>React Hooks: The Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks:完全指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hooks-the-complete-guide-5c176ca825f6?source=collection_archive---------0-----------------------#2021-08-21">https://javascript.plainenglish.io/react-hooks-the-complete-guide-5c176ca825f6?source=collection_archive---------0-----------------------#2021-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1ea5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是React挂钩，React面临的挑战，挂钩API参考，React挂钩的优势</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/60d547d355419db662741fc37368e407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3d0jsQppieVP5XL6KGK6YA.png"/></div></div></figure><h1 id="28da" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">什么是React钩子？</h1><p id="0086" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React Hooks随着React v16.8投入生产，它完全改变了我们思考和使用React的方式。React Hooks使我们能够使用函数方法而不是面向对象(类)的方法来构建组件。</p><blockquote class="mc"><p id="a030" class="md me in bd mf mg mh mi mj mk ml mb dk translated">" React挂钩让你不用写类就可以使用状态和其他React特性."— React文档</p></blockquote><p id="7aa7" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">React钩子允许我们获取无状态的功能组件，并对它们应用状态和生命周期方法。因此，这就使得<strong class="li io"> </strong>类组件变得多余。然而，类组件仍然可以使用，因为16.8是向后兼容的，但是钩子不能在类组件内部使用。</p><p id="400c" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">下面的示例呈现了一个计数器。当您单击该按钮时，它会增加该值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/a90757f4cf17a0d15052999310ff4c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1oObVSUpIvkWgrjFVSW3w.png"/></div></div></figure><p id="b24f" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">这里，<code class="fe mx my mz na b">useState</code>是一个<em class="nb">钩子。</em>我们在函数组件内部调用它，给它添加一些本地状态。React将在重新渲染之间保持这种状态。</p><p id="df8a" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">但是在我们讨论React钩子实际上是什么之前，理解React当前面临的挑战以及钩子如何帮助我们解决这些挑战是非常重要的。</p><h1 id="e144" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">React中的挑战</h1><h2 id="c2b7" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">挑战1 —难以在不同组件之间重用有状态逻辑</h2><ul class=""><li id="9925" class="no np in li b lj lk lm ln lp nq lt nr lx ns mb nt nu nv nw bi translated">为了理解钩子，我们需要退一步考虑代码重用。今天，在React应用程序中有很多方法可以重用逻辑。我们可以编写简单的函数，调用它们来计算一些东西。我们也可以编写组件(组件本身可以是函数或类)。组件功能更强大，但是要渲染一些UI。这使得它们不便于共享非可视化逻辑。这就是我们如何结束复杂的模式，如<strong class="li io">渲染道具</strong>和<strong class="li io">高阶组件</strong>。但是这些模式要求您在使用组件时重构组件，这可能很麻烦，并且使代码更难理解。如果您在React DevTools中查看一个典型的React应用程序，您可能会发现一个由提供者、消费者、高阶组件、渲染道具和其他抽象层包围的组件“包装地狱”。如果只有一种通用的重用代码的方式而不是这么多，反应不是更简单吗？</li><li id="2a1a" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">函数似乎是代码重用的完美机制。在功能之间移动逻辑最省力。然而，函数内部不能有局部反应状态。如果不重组代码或引入Observables这样的抽象，就无法从类组件中提取出“观察窗口大小并更新状态”或“随时间动画化一个值”这样的行为。这两种方法都伤害了我们喜欢的React的简单性。</li><li id="e53f" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">使用钩子，你可以从一个组件中提取有状态的逻辑，这样它就可以被独立地测试和重用。<strong class="li io">钩子允许你在不改变组件层次的情况下重用有状态逻辑。</strong>这使得在许多组件之间或者与社区共享钩子变得容易。</li></ul><h2 id="ba1b" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">挑战2—复杂的组件更难理解</h2><ul class=""><li id="9624" class="no np in li b lj lk lm ln lp nq lt nr lx ns mb nt nu nv nw bi translated">我们在React中看到的另一个挑战是复杂的组件变得难以理解。每种生命周期方法通常都包含一些不相关的逻辑。因此，相互关联的代码被这些生命周期方法分割开来，而完全不相关的代码最终被组合在一个方法中，这使得引入bug和不一致性变得太容易了。</li><li id="4fe2" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">在许多情况下，也不可能将这些组件分解成更小的组件，因为有状态逻辑无处不在，这使得测试它们变得很困难。</li><li id="7855" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated"><strong class="li io"> React Hooks允许您根据相关的部分将一个组件拆分成更小的功能(例如设置订阅或获取数据)</strong>，而不是根据生命周期方法强制拆分。因此，我们可以根据逻辑和它们所属的生命周期方法来分离应用程序关注点。</li></ul><h2 id="c2ec" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">挑战3——类混淆了人和机器。</h2><ul class=""><li id="f5d4" class="no np in li b lj lk lm ln lp nq lt nr lx ns mb nt nu nv nw bi translated">除了使代码重用和代码组织更加困难之外，我们还发现类可能是学习React的一大障碍。你必须了解<code class="fe mx my mz na b">this</code>在JavaScript中的工作方式，这与它在大多数语言中的工作方式有很大不同。你必须记住绑定事件处理程序。如果没有不稳定的语法建议，代码会非常冗长。人们可以很好地理解道具、状态和自顶向下的数据流，但仍然与类斗争。</li><li id="ddbc" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">另一方面，机器确实会混淆函数和类。例如，缩小器/取消器很难处理类。</li><li id="d8d9" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">此外，根据文档，React团队一直在试验提前编译和拥有组件折叠等特性，但已经意识到类组件可能会鼓励无意的模式，使这些优化退回到更慢的路径。</li></ul><h1 id="70f4" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">钩子API参考</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oc"><img src="../Images/1bc514b28280923dd2f7f0d77d712ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rLrdzMCsdQZS7D9Zoe4iA.jpeg"/></div></div></figure><h1 id="1c87" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">状态挂钩—使用状态()</h1><p id="1b75" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在React的早期版本中，功能组件没有状态。现在，从React 16.8开始，通过使用<strong class="li io"> useState() </strong>方法，功能组件也可以在钩子的帮助下拥有状态。</p><p id="eea6" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">下面是在功能组件中声明状态变量的语法</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="43b6" class="nc kp in na b gy oh oi l oj ok">const [state, setState] = useState(initialState);</span></pre><p id="9bd5" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">返回一个有状态的值和一个更新它的函数。在初始呈现期间，返回的状态(<code class="fe mx my mz na b">state</code>)与作为第一个参数传递的值(<code class="fe mx my mz na b">initialState</code>)相同。</p><p id="a84b" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">setState</code>函数用于更新状态。它接受一个新的状态值，并对组件的重新呈现进行排队。我们可以从组件中的任何地方调用这个函数来更新值。该函数与在类组件中使用<strong class="li io"> this.setState() </strong>方法相同，只是它没有将新旧状态合并在一起。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="81d4" class="nc kp in na b gy oh oi l oj ok">setState(newState);</span></pre><p id="ffe7" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">在随后的重新渲染过程中，<code class="fe mx my mz na b">useState</code>返回的第一个值将始终是应用更新后的最新状态。</p><h2 id="f3c1" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">声明多个状态变量</h2><p id="bd3d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">我们可以在一个组件中多次使用React钩子。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="2b79" class="nc kp in na b gy oh oi l oj ok">function declaringMultipleStateWithHooks () {</span><span id="e2a0" class="nc kp in na b gy ol oi l oj ok"> // Declare multiple state variables<br/>  const [name, setName] = useState('Ayush');<br/>  const [mobile, setMobile] = useState(8888999989);<br/>  const [address, setAddress] = useState({ <br/>               street: '#1234, 14th Main Road, 7th Cross Road,           <br/>               city: 'Bangalore', country: 'India'<br/>  });</span><span id="719c" class="nc kp in na b gy ol oi l oj ok">// ...... (other code of component)</span><span id="ab94" class="nc kp in na b gy ol oi l oj ok">}</span></pre><p id="bded" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">更新功能组件中的状态变量。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="c7a4" class="nc kp in na b gy oh oi l oj ok">handleName = () =&gt; {<br/>  setName('Ayush Verma')<br/>}</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="423c" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">功能更新— </strong>如果新状态是使用之前的状态计算出来的，您可以将一个功能传递给<code class="fe mx my mz na b">setState</code>。该函数将接收以前的值，并返回更新后的值。下面是一个使用两种形式的<code class="fe mx my mz na b">setState</code>的计数器组件的例子:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="0453" class="nc kp in na b gy oh oi l oj ok">function Counter({initialCount}) {<br/>  const [count, setCount] = useState(initialCount);<br/>  return (<br/>    &lt;&gt;<br/>      Count: {count}<br/>      &lt;button onClick={() =&gt; setCount(initialCount)}&gt;Reset&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;<br/>       - &lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;<br/>       + &lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="4545" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">“+”和“-”按钮使用函数形式，因为更新的值是基于以前的值。但是“Reset”按钮使用的是标准形式，因为它总是将计数设置回初始值。</p><p id="e249" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">惰性初始状态—</strong><code class="fe mx my mz na b">initialState</code>参数是初始渲染时使用的状态。在后续渲染中，它将被忽略。如果初始状态是开销很大的计算的结果，您可以提供一个函数，该函数将仅在初始渲染时执行:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="465f" class="nc kp in na b gy oh oi l oj ok">const [state, setState] = useState(() =&gt; {<br/>  const initialState = someExpensiveComputation(props);<br/>  return initialState;<br/>});</span></pre><p id="f8e6" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">退出状态更新— </strong>如果将状态挂钩更新为与当前状态相同的值，React将退出，而不渲染子对象或触发效果。(React使用<code class="fe mx my mz na b">Object.is</code>比较算法。)</p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="2dd9" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">效果挂钩— useEffect()</h1><p id="e61f" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在React组件中从API获取数据、设置订阅和手动更改DOM等操作被称为“<strong class="li io">副作用</strong>”或简称为效果，因为它们会影响其他组件，并且不能在渲染前完成。</p><p id="27b4" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">效果挂钩<strong class="li io"> useEffect </strong>，增加了从功能组件执行副作用的能力。</p><p id="a2b5" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">它与React类中的<strong class="li io">componentid mount</strong>、<strong class="li io">componentid update</strong>和<strong class="li io">componentid unmount</strong>的作用相同。效果是在组件内部声明的，因此它们可以访问其属性和状态。就像使用<code class="fe mx my mz na b">useState</code>一样，你可以在一个组件中使用多个效果。</p><p id="278b" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io"/><code class="fe mx my mz na b"><strong class="li io">useEffect</strong></code><strong class="li io">是做什么的？</strong>通过使用这个钩子，你告诉React你的组件需要在渲染后做一些事情。React将记住您传递的函数(我们称之为“效果”)，并在执行DOM更新后调用它。</p><p id="f6bb" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io"/><code class="fe mx my mz na b"><strong class="li io">useEffect</strong></code><strong class="li io">是否每次渲染后都运行？</strong>是的！默认情况下，它会在第一次渲染<em class="nb">和每次更新</em>后运行。不要从“安装”和“更新”的角度考虑，你可能会发现“渲染后”产生效果更容易。React保证DOM在运行效果时已经更新。每次我们重新渲染的时候，我们都会安排一个不同的<em class="nb">效果，替换之前的那个。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="a441" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated"><strong class="ak">使用useEffect作为类生命周期方法:</strong></h2><p id="fdf5" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">1)默认情况下，useEffect在每次成功渲染后运行。现在，useEffect方法的行为类似于<strong class="li io"> componentDidUpdate </strong>方法。我们可以把何时调用effect作为条件。我们可以将一个数组作为第二个参数传递给useEffect。这个数组告诉React，只要数组中的字段发生变化，就调用useEffect。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f635" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">只有当name的值改变时，它才会调用effect。</p><p id="96c1" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">2)我们还可以通过将一个空数组作为第二个参数传递给useEffect，使useEffect的行为类似于<strong class="li io"> componentDidMount </strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="cb0d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">如果你传递一个空数组(<code class="fe mx my mz na b">[]</code>)，效果里面的道具和状态都会有初始值。虽然通过<code class="fe mx my mz na b">[]</code>作为第二个参数更接近熟悉的<code class="fe mx my mz na b">componentDidMount</code>和<code class="fe mx my mz na b">componentWillUnmount</code>心智模型，但通常有更好的解决方案来避免过于频繁地重新运行效果。另外，不要忘记React将运行<code class="fe mx my mz na b">useEffect</code>推迟到浏览器绘制完成之后，所以做额外的工作不是问题。</p><p id="d180" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">3)我们也可以使用Effect来像<strong class="li io"> componentWillUnmount </strong>方法一样工作。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="10d3" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">清除功能在组件从UI中移除之前运行，以防止内存泄漏。此外，如果一个组件渲染多次(通常都是这样)，在执行下一个效果之前会清理掉前一个效果。</p><h2 id="c10f" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">效果的时间</h2><p id="dda6" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">与<code class="fe mx my mz na b">componentDidMount</code>和<code class="fe mx my mz na b">componentDidUpdate</code>不同，在延迟事件期间，传递给<code class="fe mx my mz na b">useEffect</code>的函数在布局和绘制之后触发<strong class="li io">。这使得它适用于许多常见的副作用，如设置订阅和事件处理程序，因为大多数类型的工作不应该阻止浏览器更新屏幕。</strong></p><p id="32e1" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">然而，并不是所有的影响都可以推迟。例如，用户可见的DOM突变必须在下一次绘制之前同步触发，这样用户就不会感觉到视觉上的不一致。(这种区别在概念上类似于被动和主动事件侦听器。)对于这些类型的效果，React提供了一个名为<code class="fe mx my mz na b">useLayoutEffect</code>的附加钩子。它和<code class="fe mx my mz na b">useEffect</code>有着相同的签名，唯一不同的是何时开火。</p><p id="af5f" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">虽然<code class="fe mx my mz na b">useEffect</code>被推迟到浏览器完成绘制之后，但它肯定会在任何新的渲染之前触发。React将总是在开始新的更新之前刷新以前的渲染效果。</p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="6006" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">useRef()</h1><p id="610f" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><code class="fe mx my mz na b">useRef</code>钩子是一个返回可变ref对象的函数，该对象的<code class="fe mx my mz na b">.current</code>属性用传递的参数(<code class="fe mx my mz na b">initialValue</code>)初始化。返回的对象将在组件的整个生存期内保持不变。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="4201" class="nc kp in na b gy oh oi l oj ok">const refContainer = useRef(initialValue);</span></pre><p id="eb12" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">下面几节将解释<code class="fe mx my mz na b">useRef</code>的两个主要用途:保存一个可变变量和访问DOM节点或React元素。</p><h2 id="f1bf" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">可变值</h2><p id="e783" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><code class="fe mx my mz na b">useRef(initialValue)</code>是一个内置的React钩子，它接受一个参数作为初始值，并返回一个<em class="nb">引用</em>(又名<em class="nb"> ref </em>)。引用是具有特殊属性<code class="fe mx my mz na b">current</code>的对象。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="5b95" class="nc kp in na b gy oh oi l oj ok">import { useRef } from 'react';</span><span id="2732" class="nc kp in na b gy ol oi l oj ok">function MyComponent() {<br/>  const reference = useRef(initialValue);<br/>  const someHandler = () =&gt; {<br/>    <br/>    // Access reference value:<br/>    const value = reference.current;<br/>    // Update reference value:<br/>    reference.current = newValue;  <br/>  <br/>  };</span><span id="6ab1" class="nc kp in na b gy ol oi l oj ok">  // ...<br/>}</span></pre><p id="7273" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">reference.current</code>访问参考值，<code class="fe mx my mz na b">reference.current = newValue</code>更新参考值。很简单。</p><p id="c60e" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">关于推荐人，有两条规则需要记住:</p><ol class=""><li id="c630" class="no np in li b lj mr lm ms lp pa lt pb lx pc mb pd nu nv nw bi translated">在组件重新渲染之间，引用的值是<em class="nb">持久化的</em>(保持不变)；</li><li id="ed39" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb pd nu nv nw bi translated">更新引用<em class="nb">不会触发组件重新渲染</em>。</li></ol><p id="8a52" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">现在，让我们看看如何在实践中使用<code class="fe mx my mz na b">useRef()</code>。</p><p id="a2ed" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io"> <em class="nb">用例:记录按钮点击次数<br/> </em> </strong>组件<code class="fe mx my mz na b">LogButtonClicks</code>使用一个引用来存储按钮的点击次数:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="9974" class="nc kp in na b gy oh oi l oj ok">import { useRef } from 'react';</span><span id="203b" class="nc kp in na b gy ol oi l oj ok">function LogButtonClicks() {</span><span id="d9cb" class="nc kp in na b gy ol oi l oj ok">  const countRef = useRef(0);  <br/>  const handle = () =&gt; {<br/>    countRef.current++;    <br/>    console.log(`Clicked ${countRef.current} times`);<br/>  };</span><span id="c4f4" class="nc kp in na b gy ol oi l oj ok">  console.log('I rendered!');</span><span id="769e" class="nc kp in na b gy ol oi l oj ok">  return &lt;button onClick={handle}&gt;Click me&lt;/button&gt;;<br/>}</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="425d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">const countRef = useRef(0)</code>创建一个用<code class="fe mx my mz na b">0</code>初始化的引用<code class="fe mx my mz na b">countRef</code>。点击按钮，调用<code class="fe mx my mz na b">handle</code>功能，参考值递增:<code class="fe mx my mz na b">countRef.current++</code>。参考值被记录到控制台。</p><p id="397f" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">更新参考值<code class="fe mx my mz na b">countRef.current++</code>不会触发组件重新渲染。这可以从以下事实得到证明:在初始渲染时，<code class="fe mx my mz na b">'I rendered!'</code>只被记录到控制台一次，当引用被更新时，不会发生重新渲染。</p><p id="db46" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">现在一个合理的问题:引用和状态的主要区别是什么？</p><p id="34dd" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">引用和状态差异— </strong>让我们重用上一节中的组件<code class="fe mx my mz na b">LogButtonClicks</code>，但是这次使用<code class="fe mx my mz na b">useState()</code>钩子来计算按钮点击的次数:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="47e2" class="nc kp in na b gy oh oi l oj ok">import { useState } from 'react';</span><span id="e9e4" class="nc kp in na b gy ol oi l oj ok">function LogButtonClicks() {<br/>  const [count, setCount] = useState(0);  <br/>  const handle = () =&gt; {<br/>    const updatedCount = count + 1;<br/>    console.log(`Clicked ${updatedCount} times`);<br/>    setCount(updatedCount);  <br/> };</span><span id="fc8d" class="nc kp in na b gy ol oi l oj ok">  console.log('I rendered!');</span><span id="d137" class="nc kp in na b gy ol oi l oj ok">  return &lt;button onClick={handle}&gt;Click me&lt;/button&gt;;<br/>}</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="d7b2" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">每次单击，您都会在控制台中看到消息<code class="fe mx my mz na b">'I rendered!'</code>——这意味着每次更新状态时，组件都会重新呈现。</p><p id="791a" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">因此，引用和状态之间的两个主要区别是:</p><ol class=""><li id="ec86" class="no np in li b lj mr lm ms lp pa lt pb lx pc mb pd nu nv nw bi translated">更新引用不会触发重新渲染，而更新状态会使组件重新渲染；</li><li id="818d" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb pd nu nv nw bi translated">参考更新是同步的(更新的参考值马上可用)，而状态更新是异步的(状态变量在重新渲染后更新)。</li></ol><p id="3f37" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">从更高的角度来看，引用存储副作用的基础结构数据，而状态存储直接呈现在屏幕上的信息。</p><p id="548a" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io"> <em class="nb">用例:实现一个秒表<br/> </em> </strong>你可以在里面存储一个引用基础设施数据的副作用。例如，你可以存储引用指针:定时器id，套接字id，等等。</p><p id="1af0" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">组件<code class="fe mx my mz na b">Stopwatch</code>使用<code class="fe mx my mz na b">setInterval(callback, time)</code>定时器功能来增加秒表的每秒计数。定时器id被存储在参考<code class="fe mx my mz na b">timerIdRef</code>中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="bca2" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">startHandler()</code>函数，当点击<em class="nb">启动</em>按钮时调用，启动定时器并将定时器id保存在引用<code class="fe mx my mz na b">timerIdRef.current = setInterval(...)</code>中。</p><p id="f79e" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">要停止秒表，用户点击<em class="nb">停止</em>按钮。<em class="nb">停止</em>按钮处理器<code class="fe mx my mz na b">stopHandler()</code>从参考中获取计时器id并停止计时器<code class="fe mx my mz na b">clearInterval(timerIdRef.current)</code>。</p><p id="e7f7" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">此外，如果组件在秒表激活的情况下卸载，那么<code class="fe mx my mz na b">useEffect()</code>的清除功能也会停止计时器。</p><p id="e92f" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">在秒表示例中，引用用于存储基础设施数据——活动计时器id。</p><h2 id="ead4" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">访问DOM元素</h2><p id="9f5c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><code class="fe mx my mz na b">useRef()</code>钩子的另一个有用的应用是访问DOM元素。这分3步进行:</p><ol class=""><li id="d0df" class="no np in li b lj mr lm ms lp pa lt pb lx pc mb pd nu nv nw bi translated">定义访问元素<code class="fe mx my mz na b">const elementRef = useRef()</code>的引用；</li><li id="feb2" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb pd nu nv nw bi translated">将引用赋给元素的<code class="fe mx my mz na b">ref</code>属性:<code class="fe mx my mz na b">&lt;div ref={elementRef}&gt;&lt;/div&gt;</code>；</li><li id="dacf" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb pd nu nv nw bi translated">挂载后，<code class="fe mx my mz na b">elementRef.current</code>指向DOM元素。</li></ol><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="27b3" class="nc kp in na b gy oh oi l oj ok">import { useRef, useEffect } from 'react';</span><span id="a0d5" class="nc kp in na b gy ol oi l oj ok">function AccessingElement() {<br/>  const elementRef = useRef();</span><span id="baf5" class="nc kp in na b gy ol oi l oj ok">   useEffect(() =&gt; {<br/>    const divElement = elementRef.current; <br/>    console.log(divElement); <br/>     // logs &lt;div&gt;I'm an element&lt;/div&gt;<br/>  }, []);</span><span id="ca42" class="nc kp in na b gy ol oi l oj ok">  return (<br/>    &lt;div ref={elementRef}&gt; I'm an element &lt;/div&gt;<br/>  );<br/>}</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="39f9" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io"> <em class="nb">用例:聚焦一个输入<br/> </em> </strong>例如，当组件挂载时，你需要访问DOM元素来聚焦输入字段。</p><p id="664d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">为了让它工作，你需要创建一个对输入的引用，将引用分配给标签的<code class="fe mx my mz na b">ref</code>属性，并在挂载后调用元素上的特殊方法<code class="fe mx my mz na b">element.focus()</code>。</p><p id="317b" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">下面是<code class="fe mx my mz na b">&lt;InputFocus&gt;</code>组件的一个可能实现:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="a3a6" class="nc kp in na b gy oh oi l oj ok">import { useRef, useEffect } from 'react';</span><span id="3fd2" class="nc kp in na b gy ol oi l oj ok">function InputFocus() {<br/>  const inputRef = useRef();</span><span id="0889" class="nc kp in na b gy ol oi l oj ok">  useEffect(() =&gt; {<br/>    inputRef.current.focus();  <br/>  }, []);</span><span id="f16d" class="nc kp in na b gy ol oi l oj ok">  return (<br/>    &lt;input <br/>      ref={inputRef} <br/>      type="text" <br/>    /&gt;<br/>  );<br/>}</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="ee33" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">const inputRef = useRef()</code>创建一个引用来保存输入元素。</p><p id="f918" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">然后将<code class="fe mx my mz na b">inputRef</code>赋给输入字段<code class="fe mx my mz na b">&lt;input ref={inputRef} type="text" /&gt;</code>的<code class="fe mx my mz na b">ref</code>属性。</p><p id="05f6" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">安装后，将<code class="fe mx my mz na b">inputRef.current</code>设置为输入元件。现在您可以通过编程将焦点设置到输入:<code class="fe mx my mz na b">inputRef.current.focus()</code>。</p><p id="1df5" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io"> Ref在初始渲染时为空<br/> </strong>在初始渲染时，应该保存DOM元素的引用为空:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="913e" class="nc kp in na b gy oh oi l oj ok">import { useRef, useEffect } from 'react';</span><span id="a3f2" class="nc kp in na b gy ol oi l oj ok">function InputFocus() {<br/>  const inputRef = useRef();</span><span id="e25d" class="nc kp in na b gy ol oi l oj ok">  useEffect(() =&gt; {<br/>    // Logs `HTMLInputElement` <br/>    console.log(inputRef.current);<br/>    inputRef.current.focus();<br/>  }, []);</span><span id="ed7d" class="nc kp in na b gy ol oi l oj ok">  // Logs `undefined` during initial rendering<br/>  console.log(inputRef.current);<br/>  return &lt;input ref={inputRef} type="text" /&gt;;<br/>}</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="b08b" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">在初始渲染期间，React仍然决定组件的输出，所以还没有创建DOM结构。这就是为什么在初始渲染时<code class="fe mx my mz na b">inputRef.current</code>计算为<code class="fe mx my mz na b">undefined</code>。</p><p id="e50d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">useEffect(callback, [])</code>当输入元素已经在DOM中创建时，hook在挂载后立即调用回调。</p><p id="3064" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">useEffect(callback, [])</code>的<code class="fe mx my mz na b">callback</code>函数是访问<code class="fe mx my mz na b">inputRef.current</code>的正确位置，因为它保证了DOM的构造。</p><h2 id="88c0" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">更新引用限制</h2><p id="83d4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">功能组件的功能范围应该计算输出或者调用钩子。</p><p id="7916" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">这就是为什么更新引用(以及更新状态)不应该在组件函数的直接作用域内执行。</p><p id="eb53" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">必须在<code class="fe mx my mz na b">useEffect()</code>回调或处理程序(事件处理程序、定时器处理程序等)内部更新引用。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="e07a" class="nc kp in na b gy oh oi l oj ok">import { useRef, useEffect } from 'react';</span><span id="d940" class="nc kp in na b gy ol oi l oj ok">function MyComponent({ prop }) {<br/>  const myRef = useRef(0);</span><span id="1513" class="nc kp in na b gy ol oi l oj ok">  useEffect(() =&gt; {<br/>    myRef.current++;   // Good!<br/>    setTimeout(() =&gt; {<br/>      myRef.current++; // Good!    <br/>    }, 1000);<br/>  }, []);</span><span id="b1ac" class="nc kp in na b gy ol oi l oj ok">  const handler = () =&gt; {<br/>    myRef.current++;  // Good!  <br/>  };</span><span id="b30a" class="nc kp in na b gy ol oi l oj ok">  myRef.current++;    // Bad!<br/>  if (prop) {<br/>    myRef.current++;  // Bad!  <br/>  }</span><span id="213c" class="nc kp in na b gy ol oi l oj ok">  return &lt;button onClick={handler}&gt;My button&lt;/button&gt;<br/>}</span></pre><p id="8179" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">useRef</code>钩子让我们在功能组件内部创建可变变量。使用<code class="fe mx my mz na b">useRef</code>挂钩时，有三个要点你应该牢记在心:</p><ul class=""><li id="b38b" class="no np in li b lj mr lm ms lp pa lt pb lx pc mb nt nu nv nw bi translated">使用<code class="fe mx my mz na b">useRef</code>创建的ref只有在组件已经安装并保存了整个生命周期后才会被创建。</li><li id="4dfc" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">Refs可用于访问DOM节点或React元素，以及存储可变变量(就像类组件中的实例变量一样)。</li><li id="f7ab" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">更新ref是一个副作用，所以应该只在<code class="fe mx my mz na b">useEffect</code>(或<code class="fe mx my mz na b">useLayoutEffect</code>)或事件处理程序中完成。</li></ul></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="f227" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">useContext()</h1><p id="77fc" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React的useContext钩子使得在整个应用中传递数据变得容易，而不需要手动地沿着树向下传递属性。<code class="fe mx my mz na b">useContext()</code>方法是钻透组件树的替代方法，它创建一个内部全局状态来传递数据。</p><p id="3369" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">它构成了React的上下文API的一部分(其他部分是提供者和消费者组件，我们将在下面看到示例)。当您的数据很简单或者您的应用程序很小时，Context可以成为Redux的一个很好的简单替代方案。</p><p id="f107" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">大多数React挂钩都赋予了功能组件以前没有的功能。挂钩有点不同:它只是让事情变得更好。</p><h2 id="9d30" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">使用情境与消费者:首先，艰难的方式</h2><p id="cc22" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">对于<code class="fe mx my mz na b">Consumer</code>组件，使用上下文API的典型方式如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="2afb" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">首先，我们创建一个新的上下文，并将其存储在<code class="fe mx my mz na b">NumberContext</code>中。这是一个具有两个属性的对象:<code class="fe mx my mz na b">Provider</code>和<code class="fe mx my mz na b">Consumer</code>。他们是匹配的一对，他们生来就知道如何相互交流(但不知道如何与其他环境交流)。</p><p id="560d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">然后，我们用一些内容渲染<code class="fe mx my mz na b">NumberContext.Provider</code>，并传递一个<code class="fe mx my mz na b">value</code>道具给它。它将使该值对其所有后代及其后代可用。整个子树将能够使用消费者(或useContext)来读出值。</p><p id="4e80" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">最后，我们读取<code class="fe mx my mz na b">Display</code>组件中消费者的值。</p><p id="e0eb" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">析构上下文是可选的— </strong>在创建时析构上下文是很常见的，就像这样:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="8301" class="nc kp in na b gy oh oi l oj ok">const { Provider, Consumer } = React.createContext();</span></pre><p id="a144" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">我们在这里没有这样做，而是显式地访问属性为<code class="fe mx my mz na b">NumberContext.Provider</code>和<code class="fe mx my mz na b">NumberContext.Consumer</code>，但是我想向您展示一下，以防您在附近看到它。</p><p id="e52d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">消费者添加额外的嵌套— </strong>看看我们如何读取<code class="fe mx my mz na b">Display</code>组件中的<code class="fe mx my mz na b">value</code>:我们必须将我们的内容包装在<code class="fe mx my mz na b">NumberContext.Consumer</code>中，并使用render props模式——传递一个函数作为子函数——来检索值并显示它。</p><p id="d155" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">这工作得很好，并且“渲染道具”可以是传递动态数据的一个很好的模式，但是它确实引入了一些额外的嵌套和认知开销(特别是如果您不习惯的话)，并且它看起来有点奇怪。</p><h2 id="44ee" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">useContext允许您在没有消费者的情况下“使用”上下文</h2><p id="b642" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">让我们用<code class="fe mx my mz na b">useContext</code>钩子重写<code class="fe mx my mz na b">Display</code>组件:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="8e7e" class="nc kp in na b gy oh oi l oj ok">// import useContext (or we could write React.useContext)<br/>import React, { useContext } from 'react';</span><span id="1ebb" class="nc kp in na b gy ol oi l oj ok">// ...</span><span id="2451" class="nc kp in na b gy ol oi l oj ok">function Display() {<br/>  const value = useContext(NumberContext);<br/>  return &lt;div&gt;The answer is {value}.&lt;/div&gt;;<br/>}</span></pre><p id="e7a6" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">调用<code class="fe mx my mz na b">useContext</code>，传入从<code class="fe mx my mz na b">React.createContext</code>得到的上下文对象，弹出值。这就是全部了！更容易阅读，对吗？</p><p id="1922" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">唯一需要注意的是，您必须将整个<em class="nb">上下文对象传递给<code class="fe mx my mz na b">useContext</code>——而不仅仅是消费者！</em></p><p id="71de" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">嵌套消费者vs. useContext — </strong>您可能会遇到这样的情况，您的组件需要从<em class="nb">多个</em>父上下文中接收数据，从而产生如下代码:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="1b58" class="nc kp in na b gy oh oi l oj ok">function HeaderBar() {<br/>  return (<br/>    &lt;CurrentUser.Consumer&gt;<br/>      {user =&gt;<br/>        &lt;Notifications.Consumer&gt;<br/>          {notifications =&gt;<br/>            &lt;header&gt;<br/>              Welcome back, {user.name}!<br/>              You have {notifications.length} notifications.<br/>            &lt;/header&gt;<br/>          }<br/>        &lt;/Notifications.Consumer&gt;<br/>      }<br/>    &lt;/CurrentUser.Consumer&gt;<br/>  );<br/>}</span></pre><p id="8fb4" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">仅仅为了接收两个值，就需要进行大量的嵌套。下面是使用<code class="fe mx my mz na b">useContext</code>时的样子:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="170a" class="nc kp in na b gy oh oi l oj ok">function HeaderBar() {<br/>  const user = useContext(CurrentUser);<br/>  const notifications = useContext(Notifications);</span><span id="606e" class="nc kp in na b gy ol oi l oj ok">  return (<br/>    &lt;header&gt;<br/>      Welcome back, {user.name}!<br/>      You have {notifications.length} notifications.<br/>    &lt;/header&gt;<br/>  );<br/>}</span></pre><p id="9ee2" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><em class="nb">更容易阅读。</em></p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="5eda" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">useCallback()</h1><p id="24b7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><code class="fe mx my mz na b">useCallback</code>钩子有一个主要的和特殊的功能:避免代码中不必要的重新渲染，使你的应用程序更快更有效。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="60a2" class="nc kp in na b gy oh oi l oj ok">useCallback(() =&gt; {<br/> myCallbackFunction()<br/>}, [dependencies]);</span></pre><p id="fe95" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">传递内联回调和依赖项数组。<code class="fe mx my mz na b">useCallback</code>将返回回调的记忆化版本，该版本仅在其中一个依赖关系发生变化时才会发生变化。这在向依赖引用相等的优化子组件传递回调以防止不必要的渲染时很有用(例如<code class="fe mx my mz na b">shouldComponentUpdate</code>)。</p><p id="dbcc" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">您还可以传递一个空的依赖项数组。这将只执行该函数一次。如果没有传递数组，那么每次调用都会返回一个新值。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="1c6b" class="nc kp in na b gy oh oi l oj ok">useCallback(() =&gt; {<br/> myCallbackFunction()<br/>}, []);</span></pre><p id="4992" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">当您有一个子组件经常重新呈现，并且您向它传递了一个回调时，这个钩子很有用:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="6044" class="nc kp in na b gy oh oi l oj ok">import React, { useState, useCallback } from 'react'<br/><br/>const Counter = () =&gt; {<br/>  const [count, setCount] = useState(0)<br/>  const [otherCounter, setOtherCounter] = useState(0)<br/><br/>  const increment = () =&gt; {<br/>    setCount(count + 1)<br/>  }<br/>  const decrement = () =&gt; {<br/>    setCount(count - 1)<br/>  }<br/>  const incrementOtherCounter = () =&gt; {<br/>    setOtherCounter(otherCounter + 1)<br/>  }<br/><br/>  return (<br/>    &lt;&gt;<br/>      Count: {count}<br/>      &lt;button onClick={increment}&gt;+&lt;/button&gt;<br/>      &lt;button onClick={decrement}&gt;-&lt;/button&gt;<br/>      &lt;button onClick={incrementOtherCounter}&gt;incrementOtherCounter&lt;/button&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>ReactDOM.render(&lt;Counter /&gt;, document.getElementById('app'))</span></pre><p id="0c50" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">这里的问题是，每当计数器被更新时，所有3个函数都被再次重新创建。</p><p id="7c0f" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">您可以通过实例化一个集合数据结构并向其中添加每个函数来实现这一点。为什么设置？因为它只存储唯一的元素，在我们的例子中，这意味着不同的(唯一实例化的)函数。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="60df" class="nc kp in na b gy oh oi l oj ok">import React, { useState, useCallback } from 'react'<br/><br/>const functionsCounter = new Set()<br/><br/>const Counter = () =&gt; {<br/>  const [count, setCount] = useState(0)<br/>  const [otherCounter, setOtherCounter] = useState(0)<br/><br/>  const increment = () =&gt; {<br/>    setCount(count + 1)<br/>  }<br/>  const decrement = () =&gt; {<br/>    setCount(count - 1)<br/>  }<br/>  const incrementOtherCounter = () =&gt; {<br/>    setOtherCounter(otherCounter + 1)<br/>  }<br/><br/>  functionsCounter.add(increment)<br/>  functionsCounter.add(decrement)<br/>  functionsCounter.add(incrementOtherCounter)<br/><br/> <!-- --> console.log(functionsCounter.size);</span><span id="bf19" class="nc kp in na b gy ol oi l oj ok">  return (<br/>    &lt;&gt;<br/>      Count: {count}<br/>      &lt;button onClick={increment}&gt;+&lt;/button&gt;<br/>      &lt;button onClick={decrement}&gt;-&lt;/button&gt;<br/>      &lt;button onClick={incrementOtherCounter}&gt;incrementOtherCounter&lt;/button&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>ReactDOM.render(&lt;Counter /&gt;, document.getElementById('app'))</span></pre><p id="d79f" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">相反应该发生的是，如果你增加一个计数器，所有与该计数器相关的函数都应该被重新实例化。</p><p id="b299" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">如果另一个状态值不变，则不应该触摸它。</p><p id="a18b" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">现在，在大多数情况下，这不是一个大问题，除非你传递许多不同的函数，都在改变不相关的数据，这被证明是你的应用程序性能的一大成本。</p><p id="370d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">如果这是一个问题，你可以使用<code class="fe mx my mz na b">useCallback</code>。</p><p id="bc5e" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">这是我们的做法。而不是:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="4555" class="nc kp in na b gy oh oi l oj ok">const increment = (() =&gt; {<br/>  setCount(count + 1)<br/>})<br/>const decrement = (() =&gt; {<br/>  setCount(count - 1)<br/>})<br/>const incrementOtherCounter = (() =&gt; {<br/>  setOtherCounter(otherCounter + 1)<br/>})</span></pre><p id="d8d4" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">你把所有的电话都包起来:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="65cf" class="nc kp in na b gy oh oi l oj ok">const increment = useCallback(() =&gt; {<br/>  setCount(count + 1)<br/>}, [count])<br/>const decrement = useCallback(() =&gt; {<br/>  setCount(count - 1)<br/>}, [count])<br/>const incrementOtherCounter = useCallback(() =&gt; {<br/>  setOtherCounter(otherCounter + 1)<br/>}, [otherCounter])</span></pre><p id="2f5e" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">确保将该数组作为第二个参数添加到带有所需状态的<code class="fe mx my mz na b">useCallback()</code>。</p><p id="3be2" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">现在，如果您尝试单击其中一个计数器，只有与更改的状态相关的函数将被重新实例化。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><h2 id="bed7" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">useCallback不记忆函数结果</h2><p id="6a18" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">值得注意的是，应用<code class="fe mx my mz na b">useCallback</code>不会记住函数调用的<em class="nb">结果</em>。相反，它记忆了函数对象本身。</p><p id="c2d9" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">请考虑以下情况:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="3f69" class="nc kp in na b gy oh oi l oj ok">function ParentComponent() {<br/>    const onHandleClick = useCallback(() =&gt; {<br/>        const special = calculatePi();<br/>    });</span><span id="0abc" class="nc kp in na b gy ol oi l oj ok">    return (<br/>        &lt;SubComponent<br/>            handleClick={onHandleClick}<br/>        /&gt;<br/>    );<br/>}</span></pre><p id="04e7" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">在这个例子中，每次<code class="fe mx my mz na b">&lt;SubComponent&gt;</code>通过它的<code class="fe mx my mz na b">handleClick</code> prop触发<code class="fe mx my mz na b">onHandleClick</code>回调时(大概很贵！)<code class="fe mx my mz na b">calculatePi()</code>就会被触发。箭头函数的结果不被记忆，只有<em class="nb">引用</em>。</p><p id="957e" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">如果我们想避免在每个<code class="fe mx my mz na b">handleClick</code>上重新计算圆周率，我们最好通过<code class="fe mx my mz na b">useMemo()</code>直接记住<code class="fe mx my mz na b">calculatePi</code>:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="e25e" class="nc kp in na b gy oh oi l oj ok">const memoizedPi = useMemo( calculatePii() );</span></pre></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="299b" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">使用备忘录()</h1><ul class=""><li id="a20e" class="no np in li b lj lk lm ln lp nq lt nr lx ns mb nt nu nv nw bi translated">useMemo是react的函数组件中使用的一个钩子，它返回一个被记忆的值。在计算机科学中，记忆化是一个常用的概念，当我们下次返回缓存的结果时，不需要用给定的参数重新计算函数。</li><li id="8d93" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">记忆函数能记住一组给定输入的输出结果。例如，如果有一个函数将两个数字相加，我们第一次给定参数1和2，该函数将把这两个数字相加并返回3，但是如果相同的输入再次出现，我们将返回缓存的值，即3，并且不再使用add函数进行计算。在react中，我们也使用这个概念，只要在React组件中，状态和属性没有改变组件，组件没有重新呈现，它就显示相同的输出。useMemo挂钩用于提高React应用程序的性能。</li></ul><p id="1335" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">useMemo()</code>是一个内置的React钩子，它接受两个参数——一个计算结果的函数<code class="fe mx my mz na b">compute</code>和一个<code class="fe mx my mz na b">depedencies</code>数组:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="fdb0" class="nc kp in na b gy oh oi l oj ok">const memoizedResult = useMemo(compute, dependencies);</span></pre><p id="378d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">初始渲染时，<code class="fe mx my mz na b">useMemo(compute, dependencies)</code>调用<code class="fe mx my mz na b">compute</code>，记忆计算结果，并返回给组件。</p><p id="0707" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">如果在下一次渲染过程中依赖关系没有改变，那么<code class="fe mx my mz na b">useMemo()</code> <em class="nb">不会调用</em> <code class="fe mx my mz na b">compute</code>而是返回记忆值。</p><p id="3b7e" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">但是，如果在重新渲染期间依赖关系发生变化，那么<code class="fe mx my mz na b">useMemo()</code> <em class="nb">调用</em> <code class="fe mx my mz na b">compute</code>，记忆新值，并将其返回。</p><p id="dbd0" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">这就是<code class="fe mx my mz na b">useMemo()</code>钩子的精髓。</p><p id="37a0" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">如果您的计算回调使用属性或状态值，那么请确保将这些值指示为依赖项:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="5df7" class="nc kp in na b gy oh oi l oj ok">const memoizedResult = useMemo(() =&gt; {<br/>  return expensiveFunction(propA, propB);<br/>}, [propA, propB]);</span></pre><p id="ffec" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">现在让我们看看<code class="fe mx my mz na b">useMemo()</code>在一个例子中是如何工作的。</p><p id="bae0" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">组件<code class="fe mx my mz na b">&lt;CalculateFactorial /&gt;</code>计算输入字段中引入的数字的阶乘。</p><p id="a5a0" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">下面是<code class="fe mx my mz na b">&lt;CalculateFactorial /&gt;</code>组件的一个可能实现:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="2c38" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">每次更改输入值时，都会计算阶乘<code class="fe mx my mz na b">factorialOf(n)</code>并将<code class="fe mx my mz na b">'factorialOf(n) called!'</code>记录到控制台。</p><p id="a89a" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">另一方面，每次点击<em class="nb">重新渲染</em>按钮，<code class="fe mx my mz na b">inc</code>状态值都会更新。更新<code class="fe mx my mz na b">inc</code>状态值触发<code class="fe mx my mz na b">&lt;CalculateFactorial /&gt;</code>重新渲染。但是，第二个影响是，在重新渲染期间，阶乘再次被重新计算— <code class="fe mx my mz na b">'factorialOf(n) called!'</code>被记录到控制台。</p><p id="baf6" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">当组件重新渲染时，如何记忆阶乘计算？欢迎<code class="fe mx my mz na b">useMemo()</code>上钩！</p><p id="db5b" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">通过使用<code class="fe mx my mz na b">useMemo(() =&gt; factorialOf(number), [number])</code>代替简单的<code class="fe mx my mz na b">factorialOf(number)</code>，React实现了阶乘计算。</p><p id="dc3e" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">让我们改进<code class="fe mx my mz na b">&lt;CalculateFactorial /&gt;</code>并记住阶乘计算:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="pe on l"/></div></figure><p id="6f29" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">每次更改数值时，<code class="fe mx my mz na b">'factorialOf(n) called!'</code>会被记录到控制台。这是意料之中的。</p><p id="03f5" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">然而，如果你点击<em class="nb">重新渲染</em>按钮，<code class="fe mx my mz na b">'factorialOf(n) called!'</code>不会被记录到控制台，因为<code class="fe mx my mz na b">useMemo(() =&gt; factorialOf(number), [number])</code>返回记忆化阶乘计算。</p><h2 id="ee36" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">useMemo()与useCallback()</h2><p id="4f57" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><code class="fe mx my mz na b">useMemo</code> hook与useCallback非常相似，不同的是<code class="fe mx my mz na b">useCallback</code>返回一个内存化的回调函数，而<code class="fe mx my mz na b">useMemo</code>返回一个内存化的值，这是函数调用的结果。用例也是不同的。<code class="fe mx my mz na b">useCallback</code>用于传递给子组件的回调。</p><p id="f996" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">useCallback(fn, deps)</code>相当于<code class="fe mx my mz na b">useMemo(() =&gt; fn, deps)</code>。</p><p id="33cb" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">与<code class="fe mx my mz na b">useMemo()</code>相比，<code class="fe mx my mz na b">useCallback()</code>是一个更专门的钩子，用于记忆回调:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="6210" class="nc kp in na b gy oh oi l oj ok">import { useCallback } from 'react';</span><span id="a152" class="nc kp in na b gy ol oi l oj ok">function MyComponent({ prop }) {<br/>  const callback = () =&gt; {<br/>    return 'Result';<br/>  };<br/>  const memoizedCallback = useCallback(callback, [prop]);  <br/>  return &lt;ChildComponent callback={memoizedCallback} /&gt;;<br/>}</span></pre><p id="8c4c" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">在上面的例子中，只要<code class="fe mx my mz na b">prop</code>的依赖关系相同，<code class="fe mx my mz na b">useCallback(() =&gt; {...}, [prop])</code>就会返回相同的函数实例。</p><p id="a171" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">你可以用同样的方式用<code class="fe mx my mz na b">useMemo()</code>来记忆回调:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="d88a" class="nc kp in na b gy oh oi l oj ok">import { useMemo } from 'react';</span><span id="d105" class="nc kp in na b gy ol oi l oj ok">function MyComponent({ prop }) {<br/>  const callback = () =&gt; {<br/>    return 'Result';<br/>  };<br/>  const memoizedCallback = useMemo(() =&gt; callback, [prop]);  <br/>  return &lt;ChildComponent callback={memoizedCallback} /&gt;;<br/>}</span></pre><p id="21b0" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">小心使用记忆- </strong>虽然<code class="fe mx my mz na b">useMemo()</code>可以提高组件的性能，但您必须确保在使用和不使用挂钩的情况下分析组件。只有在那之后才能做出记忆是否值得的结论。当内存化使用不当时，可能会损害性能。</p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="3c82" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">useReducer()</h1><ul class=""><li id="33ee" class="no np in li b lj lk lm ln lp nq lt nr lx ns mb nt nu nv nw bi translated"><code class="fe mx my mz na b">useReducer</code>用于存储和更新状态，就像<code class="fe mx my mz na b">useState</code>钩子一样。它接受一个<code class="fe mx my mz na b">reducer</code>函数作为第一个参数，初始状态作为第二个参数。</li><li id="555a" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated"><code class="fe mx my mz na b">useReducer</code>返回一个保存当前状态值的数组和一个<code class="fe mx my mz na b">dispatch</code>函数，您可以向其传递一个动作并在以后调用。这类似于Redux使用的模式，但有一些不同。例如，<code class="fe mx my mz na b">useReducer</code>功能与特定的减速器紧密耦合。我们只将动作对象分派给reducer，而在Redux中，dispatch函数将动作对象发送给存储。在分派时，组件不需要知道将处理动作的缩减器。</li></ul><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="2f70" class="nc kp in na b gy oh oi l oj ok">const [state, dispatch] = useReducer(reducer, initialArg, init);</span></pre><p id="807c" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">下面是来自<code class="fe mx my mz na b">useState</code>部分的反例，改写后使用了减速器:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="3e85" class="nc kp in na b gy oh oi l oj ok">const initialState = {count: 0};</span><span id="5ad9" class="nc kp in na b gy ol oi l oj ok">function reducer(state, action) {<br/>  switch (action.type) {<br/>    case 'increment':<br/>      return {count: state.count + 1};<br/>    case 'decrement':<br/>      return {count: state.count - 1};<br/>    default:<br/>      throw new Error();<br/>  }<br/>}</span><span id="dd64" class="nc kp in na b gy ol oi l oj ok">function Counter() {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/>  return (<br/>    &lt;&gt;<br/>      Count: {state.count}<br/>      &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="7a41" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">指定初始状态- </strong>有两种不同的方式来初始化<code class="fe mx my mz na b">useReducer</code>状态。您可以根据使用情况选择其中之一。最简单的方法是将初始状态作为第二个参数传递:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="2a83" class="nc kp in na b gy oh oi l oj ok">const [state, dispatch] = useReducer(<br/>    reducer,<br/>    {count: initialCount}  <br/>);</span></pre><p id="6929" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">惰性初始化- </strong>你也可以惰性地创建初始状态。为此，您可以传递一个<code class="fe mx my mz na b">init</code>函数作为第三个参数。初始状态将被设置为<code class="fe mx my mz na b">init(initialArg)</code>。</p><p id="a23c" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">它允许您提取逻辑来计算减速器外部的初始状态。这对于稍后响应动作时重置状态也很方便:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="0468" class="nc kp in na b gy oh oi l oj ok">function init(initialCount) {  return {count: initialCount};}<br/>function reducer(state, action) {<br/>  switch (action.type) {<br/>    case 'increment':<br/>      return {count: state.count + 1};<br/>    case 'decrement':<br/>      return {count: state.count - 1};<br/>    case 'reset':      return init(action.payload);    default:<br/>      throw new Error();<br/>  }<br/>}</span><span id="d0fa" class="nc kp in na b gy ol oi l oj ok">function Counter({initialCount}) {<br/>  const [state, dispatch] = useReducer(reducer, initialCount, init);  return (<br/>    &lt;&gt;<br/>      Count: {state.count}<br/>      &lt;button<br/>        onClick={() =&gt; dispatch({type: 'reset', payload: initialCount})}&gt;        Reset<br/>      &lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="c3ee" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">退出调度</strong> —如果你从一个Reducer钩子返回与当前状态相同的值，React将退出而不渲染子对象或触发效果。(React使用<code class="fe mx my mz na b">Object.is</code>比较算法。)</p><h2 id="3341" class="nc kp in bd kq nd ne dn ku nf ng dp ky lp nh ni la lt nj nk lc lx nl nm le nn bi translated">useState与useReducer</h2><p id="a4e7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">虽然<code class="fe mx my mz na b">useState</code>是管理简单状态转换的基本钩子，而<code class="fe mx my mz na b">useReducer</code>是管理更复杂状态逻辑的附加钩子，但是值得注意的是<code class="fe mx my mz na b">useState</code>在内部使用了<code class="fe mx my mz na b">useReducer</code>。这意味着你可以用<code class="fe mx my mz na b">useReducer</code>做任何你可以用<code class="fe mx my mz na b">useState</code>做的事情。</p><p id="ff90" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">然而，这两个挂钩之间有一些主要的区别。<code class="fe mx my mz na b">useReducer</code>允许您避免通过组件的不同级别传递回调，而是允许您传递一个提供的<code class="fe mx my mz na b">dispatch</code>函数，这反过来将提高触发深度更新的组件的性能。</p><p id="edef" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">这并不意味着在每次渲染时会重新调用<code class="fe mx my mz na b">useState</code>更新函数。它的意思是，当你有一个复杂的逻辑来更新状态时，你根本不会直接使用setter来更新状态；相反，您将编写一个复杂的函数，该函数将调用具有更新状态的setter。</p><p id="2c8d" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">因此，建议使用<code class="fe mx my mz na b">useReducer</code>，它返回一个在重新渲染之间不会改变的<code class="fe mx my mz na b">dispatch</code>方法，并且您可以在reducers中拥有操作逻辑。</p><p id="09a8" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">同样值得注意的是，在<code class="fe mx my mz na b">useState</code>中，调用状态更新器函数来更新状态，但是在<code class="fe mx my mz na b">useReducer</code>中，调用的是<code class="fe mx my mz na b">dispatch</code>函数，并且至少有一个类型的动作被传递给它。</p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="9255" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">useImperativeHandle()</h1><p id="0fa6" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><code class="fe mx my mz na b">useImperativeHandle</code>允许您使用<code class="fe mx my mz na b">ref</code>将值和函数从<strong class="li io">子</strong>组件传递回<strong class="li io">父</strong>。从那里，<strong class="li io">父</strong>可以自己使用它，也可以将它传递给另一个<strong class="li io">子</strong>。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="7018" class="nc kp in na b gy oh oi l oj ok">useImperativeHandle(ref, createHandle, [deps])</span></pre><p id="4372" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">请注意，您只能将ref作为道具传递给在<code class="fe mx my mz na b">forwardRef</code>中包装其组件的子组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="93f0" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">在上面的代码中，我们初始化了<strong class="li io">父</strong>中的<code class="fe mx my mz na b">ref</code>，然后将它作为道具传递给两个<strong class="li io">子</strong>。两个孩子都将返回值包装在<code class="fe mx my mz na b">forwardRef</code>中，这样他们就可以接受一个ref作为道具。注意，<code class="fe mx my mz na b">forwardRef</code>接受的第一个参数是常规的<code class="fe mx my mz na b">props</code>，第二个参数是<code class="fe mx my mz na b">ref</code>。</p><p id="69b1" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">现在，<strong class="li io"> ChildOne </strong>有了自己的内部状态，用<code class="fe mx my mz na b">useState</code>钩子来管理，它有一个<code class="fe mx my mz na b">updateCount</code>方法来递增<code class="fe mx my mz na b">count</code>。</p><p id="43b2" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">然后它通过使用<code class="fe mx my mz na b">useImperativeHandle</code>钩子使<code class="fe mx my mz na b">count</code>值对父对象可用，钩子将<code class="fe mx my mz na b">ref</code>作为一个参数，并返回一个带有<code class="fe mx my mz na b">count</code>变量的对象。</p><p id="91ff" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">父</strong>现在可以访问<code class="fe mx my mz na b">count</code>，并将其作为道具传递给<strong class="li io">子二</strong>，当点击时，会将<code class="fe mx my mz na b">ref.current.count</code>记录到控制台。</p><p id="96f7" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">因此，在这里你可以看到一个将值或方法传递回<strong class="li io">父</strong>然后传递到另一个<strong class="li io">子</strong>的工作示例。还要注意，因为我们使用了<code class="fe mx my mz na b">useRef</code>，所以在<strong class="li io">父</strong>中没有重新渲染。</p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="c6bc" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">useLayoutEffect()</h1><p id="921e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><code class="fe mx my mz na b">useLayoutEffect</code>在之后<strong class="li io">渲染</strong>生命周期已经完成，并且就在 <strong class="li io">使用效果</strong>执行之前<em class="nb">触发<em class="nb">。这对于同步重新呈现DOM以及从DOM中读取布局非常有用。但是为了防止阻塞页面加载，我们应该总是使用useEffect钩子。它的语法与<code class="fe mx my mz na b">useEffect</code>相同。</em></em></p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="bc4c" class="nc kp in na b gy oh oi l oj ok">import React, { useLayoutEffect, useState } from 'react';<br/><br/>const App = () =&gt; {<br/>   const [name, setName] = useState('Ayush');<br/><br/>   useLayoutEffect(() =&gt; {<br/>      if (name === 'Ayush') {<br/>         setName('Akash');<br/>      }<br/>   }, [name]);</span><span id="5450" class="nc kp in na b gy ol oi l oj ok">   return &lt;div&gt; {name} has email id of ayush@medium.com &lt;/div&gt;;<br/>};<br/>export default App;</span></pre><p id="8c01" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">更具体地说，就在DOM有机会绘制 之前<code class="fe mx my mz na b">useLayoutEffect</code>被触发<strong class="li io"> <em class="nb">。如果您想执行以下任何操作，这是运行功能的好地方:</em></strong></p><ul class=""><li id="9753" class="no np in li b lj mr lm ms lp pa lt pb lx pc mb nt nu nv nw bi translated">管理焦点</li><li id="c30f" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">管理文本选择</li><li id="05dc" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">触发动画</li><li id="af55" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">与第三方DOM库集成</li></ul><p id="1e5c" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">React文档建议您首先尝试使用<code class="fe mx my mz na b">useEffect</code>，如果您仍然遇到UI问题，那么使用<code class="fe mx my mz na b">useLayoutEffect</code>。</p><p id="8cf3" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">如果你使用的是像<a class="ae pf" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>这样的框架，需要注意的是:因为Next在<strong class="li io">服务器</strong>上生成HTML，当它看到<code class="fe mx my mz na b">useLayoutEffect</code>时会感到不安并发出警告，因为它实际上应该只在<strong class="li io">客户端</strong>上运行。</p><blockquote class="pg ph pi"><p id="21cb" class="lg lh nb li b lj mr jo ll lm ms jr lo pj mt lr ls pk mu lv lw pl mv lz ma mb ig bi translated"><em class="in">警告:useLayoutEffect在服务器上不起作用，因为它的效果不能被编码成服务器渲染器的输出格式。这将导致初始的非水合UI和预期的UI之间的不匹配。为了避免这种情况，useLayoutEffect只应在专门在客户端呈现的组件中使用。</em></p></blockquote><p id="8973" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">有一个非常简单的方法可以解决这个问题——你需要确保<code class="fe mx my mz na b">useLayoutEffect</code>只在<strong class="li io">客户端</strong>上运行。以下是实现这一目标的一些技巧:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="6113" class="nc kp in na b gy oh oi l oj ok">if (typeof window !== "undefined")<br/>  useLayoutEffect(() =&gt; console.log("I only run on the Client!")</span></pre><p id="6eb9" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">或者，您也可以使用:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="1926" class="nc kp in na b gy oh oi l oj ok">if (browser.process)<br/>  useLayoutEffect(() =&gt; console.log("I only run on the Client!")</span></pre><p id="b4d7" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">一个特例- </strong>另一个你可能想要使用<code class="fe mx my mz na b">useLayoutEffect</code>而不是<code class="fe mx my mz na b">useEffect</code>的情况是，如果你正在更新一个值(比如一个<code class="fe mx my mz na b">ref</code>)，并且你想要在任何其他代码运行之前确保它是最新的。例如:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="a909" class="nc kp in na b gy oh oi l oj ok">const ref = React.useRef()</span><span id="c37e" class="nc kp in na b gy ol oi l oj ok">React.useEffect(() =&gt; {<br/>  ref.current = 'some value'<br/>})</span><span id="599d" class="nc kp in na b gy ol oi l oj ok"><em class="nb">// then, later in another hook or something</em></span><span id="c0c6" class="nc kp in na b gy ol oi l oj ok">React.useLayoutEffect(() =&gt; {<br/>  console.log(ref.current) <br/>  <em class="nb">// &lt;-- this logs an old value because this runs first!<br/></em>})</span></pre><p id="a9cd" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">所以在这种情况下，解决方案是<code class="fe mx my mz na b">useLayoutEffect</code>。</p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="cde8" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">useDebugValue()</h1><p id="73de" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这个钩子为定制钩子提供了定制标签，从而使调试过程更加容易和高效。它仅在React开发人员工具打开时调用。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="1631" class="nc kp in na b gy oh oi l oj ok">useDebugValue(value)</span></pre><p id="0ac6" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><code class="fe mx my mz na b">useDebugValue</code>可用于在React DevTools中显示自定义挂钩的标签。</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="a01d" class="nc kp in na b gy oh oi l oj ok">function useCustomHook(val) {<br/>   const [value, setValue] = useState(null);<br/>   useDebugValue(value ? Not Empty : Empty);<br/>   return value;<br/>}</span></pre><p id="4937" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">它将在React开发者工具中的<strong class="li io"> useCustomHook </strong>旁边显示标签。例如，如果值状态为“空”，则标签的值为“空”。</p><p id="a763" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">延迟格式化调试值- </strong>在某些情况下，格式化显示值可能是一项开销很大的操作。这也是不必要的，除非一个钩子被真正检查。</p><p id="f898" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">因此，<code class="fe mx my mz na b">useDebugValue</code>接受一个格式化函数作为可选的第二个参数。只有当钩子被检查时，这个函数才会被调用。它接收调试值作为参数，并且应该返回格式化的显示值。</p><p id="b685" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">例如，返回一个<code class="fe mx my mz na b">Date</code>值的自定义钩子可以通过传递下面的格式化程序来避免不必要的调用<code class="fe mx my mz na b">toDateString</code>函数:</p><pre class="kd ke kf kg gt od na oe of aw og bi"><span id="605c" class="nc kp in na b gy oh oi l oj ok">useDebugValue(date, date =&gt; date.toDateString());</span></pre></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="3def" class="ko kp in bd kq kr ov kt ku kv ow kx ky jt ox ju la jw oy jx lc jz oz ka le lf bi translated">钩子的两个重要规则</h1><p id="299d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在我们创建自己的钩子之前，让我们回顾一下我们必须始终遵循的一些主要规则。</p><ol class=""><li id="73bf" class="no np in li b lj mr lm ms lp pa lt pb lx pc mb pd nu nv nw bi translated">只在组件的顶层调用钩子。不要从循环、条件或嵌套函数中调用钩子。</li></ol><ul class=""><li id="6922" class="no np in li b lj mr lm ms lp pa lt pb lx pc mb nt nu nv nw bi translated">相反，在任何早期返回之前，总是在React函数的顶层使用钩子。通过遵循这条规则，您可以确保每次组件呈现时都以相同的顺序调用钩子。这使得React能够正确地保存多个<code class="fe mx my mz na b">useState</code>和<code class="fe mx my mz na b">useEffect</code>调用之间的钩子状态。</li></ul><p id="83fa" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">2.仅从React功能组件调用挂钩。不要从普通的JavaScript函数中调用钩子。</p><ul class=""><li id="6e32" class="no np in li b lj mr lm ms lp pa lt pb lx pc mb nt nu nv nw bi translated">钩子可以调用其他的钩子，比如自定义钩子。</li></ul><p id="1bd4" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">通过遵循这些规则，您可以确保组件中的所有有状态逻辑从其源代码中清晰可见。</p><h1 id="3a3d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated"><strong class="ak">定制挂钩</strong></h1><p id="f5a8" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">定制钩子是钩子设计的自然结果，而不是React特性。</p><p id="3287" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">我必须以“ <code class="fe mx my mz na b"><strong class="li io">use</strong></code> <strong class="li io">”开头来命名我的定制钩子吗？</strong>请便。这个惯例非常重要。没有它，我们就不能自动检查钩子规则的违反情况，因为我们不能判断某个函数是否包含对钩子的调用。</p><p id="2cdf" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">使用相同钩子的两个组件共享状态吗？</strong>不可以，自定义钩子是一种重用<em class="nb">有状态逻辑</em>的机制(比如设置订阅，记住当前值)，但是每次使用自定义钩子，里面的所有状态和效果都是完全隔离的。</p><p id="9119" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><strong class="li io">自定义钩子如何获得隔离状态？</strong>每一个<em class="nb">调用</em>到一个钩子就会得到隔离状态。</p><p id="840c" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">定制钩子提供了共享逻辑的灵活性，这在以前的React组件中是不可能的。你可以编写自定义的钩子来覆盖各种各样的用例，比如表单处理、动画、声明性订阅、定时器，可能还有很多我们没有考虑到的。</p><h1 id="3c2a" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">React挂钩的优势</h1><ul class=""><li id="3121" class="no np in li b lj lk lm ln lp nq lt nr lx ns mb nt nu nv nw bi translated">钩子<strong class="li io">更容易使用和测试</strong> ( <strong class="li io">，因为它们是从React组件</strong>中分离出来的函数)并使代码看起来更整洁，<strong class="li io">更容易阅读</strong> — <strong class="li io">相关的逻辑可以紧密耦合在一个定制的钩子</strong>中。</li><li id="b1b3" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">钩子很容易使代码更具可重用性/可组合性(而且<strong class="li io">它们不像HOCs那样在DOM中创建另一个元素</strong>)——使用HOCs，我们将不相关的状态逻辑分离到不同的函数中，并将它们作为道具注入到主组件中，尽管使用钩子，我们可以像HOCs一样解决这个问题，但没有包装器地狱。</li><li id="e6a2" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">我们可以定义几个独立的生命周期方法，而不是把所有的都放在一个方法中(这样你就可以轻松地拆分<code class="fe mx my mz na b">componentDidMount</code>逻辑)。</li><li id="2be2" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">钩子<strong class="li io">将会让</strong>在未来的React优化中工作得更好<strong class="li io">(比如提前编译和组件折叠)——组件折叠可能在未来成为可能，这意味着在编译时消除死代码(下载更少的JS代码，执行更少)</strong></li><li id="d7ed" class="no np in li b lj nx lm ny lp nz lt oa lx ob mb nt nu nv nw bi translated">即使是现在，JavaScript中函数的缩小也比JavaScript类的缩小好得多。例如，缩小JS类的方法名是不可能的，因为每个方法都可以是私有的或公共的，所以我们不知道它何时在类外被使用。下载、处理和执行更少的代码对最终用户有积极的影响。检查比较:</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pm"><img src="../Images/00db050d3e86c3ffb363a4582f0150ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J54oTtSNTHDcnMWpohZdcg.png"/></div></div></figure><h1 id="6d2e" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">结论</h1><p id="9b89" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React钩子的引入引起了巨大的轰动。它的浪潮已经超越了React社区，进入了JavaScript世界。这是因为钩子是一个新概念，可以让整个JavaScript生态系统受益。事实上，Vue.js团队最近发布了类似的东西，叫做<a class="ae pf" href="https://composition-api.vuejs.org/" rel="noopener ugc nofollow" target="_blank">复合API </a>。</p><p id="a7d9" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">还有人说React Hooks和Context API会把Redux从状态管理的宝座上拉下来。显然，钩子使得编码变得更加简单，并且改变了我们编写新代码的方式。</p><p id="f67f" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated">我希望你今天学到了新东西。感谢阅读！:)</p><p id="1d89" class="pw-post-body-paragraph lg lh in li b lj mr jo ll lm ms jr lo lp mt lr ls lt mu lv lw lx mv lz ma mb ig bi translated"><em class="nb">更多内容请看</em><a class="ae pf" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="nb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>