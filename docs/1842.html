<html>
<head>
<title>Here are the TypeScript Enums I Actually Want to Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是我实际想要使用的类型脚本枚举</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-enums-i-want-to-actually-use-3ec989ea1158?source=collection_archive---------15-----------------------#2021-04-18">https://javascript.plainenglish.io/typescript-enums-i-want-to-actually-use-3ec989ea1158?source=collection_archive---------15-----------------------#2021-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/37635c6cf1280fc63d393f3b41d6ee39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDugl1SnxKosRS7mEk5KGQ.jpeg"/></div></div></figure><div class=""/><p id="a26e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自从我第一次了解TypeScript，我就知道有一件事我会一直讨厌:<em class="kw">枚举</em>。如此不优雅，如此老派，如此为什么你污染我的运行时间。</p><p id="21b3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我错了。我现在用枚举。至少是其中的一部分。</p><p id="92d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我展示给你看。</p><h1 id="0784" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是TypeScript中的枚举？</h1><p id="bffa" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">首先，让我们快速地谈谈什么是枚举器，或简称枚举器。</p><p id="481d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript中的枚举是有限数量的事例的明确集合。也就是说，我们写下所有的可能性，不允许其他的。</p><p id="3dbb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">枚举的意义在于，在代码中你只需要处理这几种情况，并且你可以确保处理所有的情况。如果您忘记处理一个或多个。</p><p id="b51a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一些常见的枚举示例，可以让您更好地理解:</p><ul class=""><li id="1918" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">方向:<code class="fe mj mk ml mm b">North</code>、<code class="fe mj mk ml mm b">South</code>、<code class="fe mj mk ml mm b">East</code>、<code class="fe mj mk ml mm b">West</code></li><li id="c891" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">卡位:<code class="fe mj mk ml mm b">Ace</code>、<code class="fe mj mk ml mm b">King</code>、<code class="fe mj mk ml mm b">Queen</code>、<code class="fe mj mk ml mm b">Jack</code>、<code class="fe mj mk ml mm b">10</code>、<code class="fe mj mk ml mm b">9</code>、<code class="fe mj mk ml mm b">8</code>、<code class="fe mj mk ml mm b">7</code>、<code class="fe mj mk ml mm b">6</code>、<code class="fe mj mk ml mm b">5</code>、<code class="fe mj mk ml mm b">4</code>、<code class="fe mj mk ml mm b">3</code>、<code class="fe mj mk ml mm b">2</code></li><li id="b515" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">日期格式:<code class="fe mj mk ml mm b">Unix</code>、<code class="fe mj mk ml mm b">ISO</code>、<code class="fe mj mk ml mm b">Email</code></li></ul><p id="8947" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将使用我的应用程序支持的国家作为例子。这是在TypeScript中编写枚举的方式:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="796e" class="na ky jb mm b gy nb nc l nd ne">enum Country {<br/>  Germany,<br/>  Sweden,<br/>  USA,<br/>}</span></pre><p id="264b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它几乎就像一个简单的物体。注意没有等号，这不是赋值。该定义看起来类似于接口的定义。</p><p id="75be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">枚举有一个有趣的特性:它定义了类型和值。在这里看到一些用途:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="ae6c" class="na ky jb mm b gy nb nc l nd ne">enum Country {<br/>  Germany,<br/>  Sweden,<br/>  USA,<br/>}</span><span id="874a" class="na ky jb mm b gy nf nc l nd ne">const setActiveCountry = (country: Country) =&gt; {<br/>  //                               ^^^ this is a type</span><span id="f25b" class="na ky jb mm b gy nf nc l nd ne">  // do something<br/>}</span><span id="c313" class="na ky jb mm b gy nf nc l nd ne">setActiveCountry(Country.Sweden)<br/>//               ^^^ this is a value</span><span id="82f6" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry('SE')</span></pre><p id="2fc3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://www.typescriptlang.org/play?#code/KYOwrgtgBAwg9mEAXATgTygbwFBSgcWBQgEMQ0AaXKAZQHdgATUKvAVRoEEqBfavAYLzYAxnBABnJFAnAknEUgCWAN2DxEqDAF4oACjGb0ALlgJk6AJRRtAPizUA9I6Gu37oQD1vUJAAslCShAqBJfNAAHYGonF0Y4GTgIOQCQAHNsPmxZeUVVdXMtPQ0LNAA6eiZQS1iPQW9PXwCgkLCVEgAbMGjsZygAASQJAFpgAA8oxVGUFDgUbLkFZTUSooByGgBRNcsgA" rel="noopener ugc nofollow" target="_blank">游乐场链接</a></p><blockquote class="nh ni nj"><p id="86d2" class="jy jz kw ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated">注意<em class="jb">:我在代码示例中用</em> <code class="fe mj mk ml mm b"><em class="jb">@ts-expect-error</em></code> <em class="jb">来标记下一行有打字错误。这也抑制了错误，所以你不会在操场上看到它。删除该行以查看报告的错误。</em></p></blockquote><h1 id="78a9" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Enums怎么了？</h1><p id="52bd" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对，听起来不错，有什么问题吗？</p><p id="4e7a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有三个要点，我从第一天起就反对Enums。</p><h2 id="59af" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">1.枚举引入了(丑陋的)运行时代码</h2><p id="750e" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果您希望有一个可用的值，这意味着该值必须在运行时存在。这意味着枚举是极少数(也可能是唯一经常使用的)类型脚本构造之一，可以在生成的JavaScript中生成一些代码。</p><p id="de85" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，当目标是当前ECMAScript时，所有类型定义和注释都将被删除。这是因为JavaScript中的所有其他结构(如对象文字、函数或类)都与TypeScript中的相同。</p><p id="8caa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看上面定义的<code class="fe mj mk ml mm b">Country</code>枚举是如何结束的:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="f755" class="na ky jb mm b gy nb nc l nd ne">var Country;<br/>(function (Country) {<br/>    Country[Country["Germany"] = 0] = "Germany";<br/>    Country[Country["Sweden"] = 1] = "Sweden";<br/>    Country[Country["USA"] = 2] = "USA";<br/>})(Country || (Country = {}));</span></pre><h2 id="8f37" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">2.默认情况下，枚举是基于数字的</h2><p id="e221" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">你看到那个代码了吗？你看到那些数字0，1和2了吗？</p><p id="6198" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是分配给国家的实际值。所以当你使用好听的名字时，它们会被转换成数字。</p><p id="2dfd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成的代码实际上相当于下面的dictionary对象。</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="2612" class="na ky jb mm b gy nb nc l nd ne">const Country = {<br/>  Germany: 0,<br/>  Sweden: 1,<br/>  USA: 2,<br/>};</span></pre><p id="91fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以当你想调试你的代码并记录你的函数接收到的国家时，你会得到一个神秘的数字。然后，您需要去查看TypeScript中源代码的相关版本，从顶部开始数那个数字，然后您就有了您最初实际想要的名称。啊，真糟糕。</p><p id="9534" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个问题是，你可以在期望<code class="fe mj mk ml mm b">Country</code>类型的地方传递一个数字。一个令人头疼的维护问题即将自行出现。但是，您实际上可以传递任何数给<em class="kw">，不管它是否在Enum中定义。这两个调用<a class="ae ng" href="https://www.typescriptlang.org/play?target=99&amp;strict=true#code/KYOwrgtgBAwg9mEAXATgTygbwFBSgcWBQgEMQ0AaXKAZQHdgATUKvAVRoEEqBfbbAMZwQAZyRQRwJJwFIAlgDdg8RKgwBeKAAohq9AC5YCZOgCUUdQD4s1APS2ojOBLgQpACzkgA5tj7ZJaVlFZWM1LQBGUwCpGXklFRM0SIAGFNMgA" rel="noopener ugc nofollow" target="_blank">都将通过类型检查</a>:</em></p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="3f0b" class="na ky jb mm b gy nb nc l nd ne">setActiveCountry(1)   // 1 for Sweden<br/>setActiveCountry(100) // 100 for ???</span></pre><p id="a4cd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，枚举应该是唯一的值。开发人员不应该关心运行时值，而应该将枚举视为不透明的。然而，对数字的整体翻译感觉非常老派，提醒人们记忆是昂贵的，数字被用作节省记忆的手段。</p><p id="da53" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道有一个字符串枚举的解决方案(我们稍后会谈到)。然而，我不明白为什么这些值不能等同于已经是唯一的标签。或者，当目标是ES2015+时，值可以是符号，在创建它们的地方使用它们。</p><h2 id="b5e2" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">3.TypeScript中不需要枚举</h2><p id="9d74" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在TypeScript中必须使用枚举吗？</p><p id="cc1b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不，还有其他方法来键入有限数量的案例。</p><p id="ad59" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我看到人们用许多方法避免枚举。不管是有意还是出于习惯。当然，你不需要<em class="kw">他们来编写好的代码。</em></p><p id="389d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我向您展示我现在如何使用Enums以便对它们感到舒适之前，让我们探索这些常见的替代方法并讨论它们的优缺点。</p><h1 id="7154" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">枚举的替代</h1><h2 id="48ab" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">文字类型的不相交并集</h2><p id="dc35" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一个相当简单的选择是定义一个由所有允许的实际字符串(或其他值)组成的类型。这被称为不相交或有区别的联合；参见打字稿文档中的<a class="ae ng" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions" rel="noopener ugc nofollow" target="_blank">区别工会</a>。</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="f17e" class="na ky jb mm b gy nb nc l nd ne">type Country = 'DE' | 'SE' | 'US'</span><span id="1d98" class="na ky jb mm b gy nf nc l nd ne">const setActiveCountry = (country: Country) =&gt; {<br/>  // do something<br/>}</span><span id="a275" class="na ky jb mm b gy nf nc l nd ne">setActiveCountry('SE')</span><span id="0061" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry('CZ')</span></pre><p id="b413" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAwg9gVwHbAE4igXigcgCICiOUAPrgMpGm4Cq5OAUFMy6ywwMZxIDOwUPCMACCHYAEsAbhHjI0GbAAouc9AC5YiFOgCUWAHxQA3kygB6M1AAmcAXAC2QgBbikAcwYBfBg0EixUjJa8oo4lDg6PhZQAALAPAC0EAAekGJJqKhwqL5CohLSstogoTAAWhFAA" rel="noopener ugc nofollow" target="_blank">游乐场链接</a></p><p id="f234" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，这种方法可以正确地键入函数。问题是到处都是“魔法”线。当然，对于我的例子，字符串实际上有点不言自明。但是让我们想象一下，我们将使用<a class="ae ng" href="https://en.wikipedia.org/wiki/ISO_3166-1_numeric" rel="noopener ugc nofollow" target="_blank">ISO 3166–1数字</a>国家代码来代替<a class="ae ng" href="https://en.wikipedia.org/wiki/ISO_3166-1" rel="noopener ugc nofollow" target="_blank">ISO 3166–1</a>两个字母的国家代码:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="3c60" class="na ky jb mm b gy nb nc l nd ne">type Country = '276' | '752' | '840'</span><span id="aadc" class="na ky jb mm b gy nf nc l nd ne">const setActiveCountry = (country: Country) =&gt; {<br/>  // do something<br/>}</span><span id="b81a" class="na ky jb mm b gy nf nc l nd ne">setActiveCountry('752')</span><span id="7bcc" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry('203')</span></pre><p id="48f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAwg9gVwHbAE4igXigcgEwDsAbDlAD64ECsepFOAHACwAMOAUFF9z9+wMZwkAZ2BRhEYAEF+wAJYA3CPGRoM2ABSDV6AFyxEKdAEosAPigBvTlAD0tqABM44uAFtJACzlIA5uwBfdnYJaVlFZUM1DRxqWmNg+ygAAWBhAFoIAA9IWUzUVDhUEMkZeSUVIxAYvBYAZhxjIA" rel="noopener ugc nofollow" target="_blank">游乐场链接</a></p><p id="6639" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然在技术上与之前的版本相当，但现在完全不可读且容易出错。</p><h2 id="64ff" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">常数项类型的不相交并集</h2><p id="08a4" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们能做些什么来移除那些“魔法”线？让我们将这些值保存为常数:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="dc2d" class="na ky jb mm b gy nb nc l nd ne">const GERMANY = '276'<br/>const SWEDEN = '752'<br/>const USA = '840'<br/>const CZECHIA = '203'</span><span id="87f3" class="na ky jb mm b gy nf nc l nd ne">type Country = '276' | '752' | '840'</span><span id="ce0c" class="na ky jb mm b gy nf nc l nd ne">const setActiveCountry = (country: Country) =&gt; {<br/>  // do something<br/>}</span><span id="80d4" class="na ky jb mm b gy nf nc l nd ne">setActiveCountry(SWEDEN)</span><span id="6960" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry(CZECHIA)</span></pre><p id="952c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBA4gUQEoFkCCA5AmjAvDAcgCYB2ANgIChRJYBlAdQQBEEM9CSBWIqm6GAFU6aDgQAcAFgAMfcAIDCALQQKAEgElR+YtIDMVSlACeABwCmMBSACuYKACdjY0hRgAfTjwIfCU2ZQwQcEhwdTysBDmUGjAUACWAG7m1naOzvgAFKBpTgBcVrb2TgCUeAB8MADegTAA9HUwACYgMBAgALbRABbxYADmlAC+lJRRMXFJKUXpmYwsbCWjDTAAAlAQALTmAB4WcdsODiAOY9GxCcmpxcaZyqqaaCVAA" rel="noopener ugc nofollow" target="_blank">操场链接</a></p><p id="4b11" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这肯定更好。常量的名称告诉开发人员他们使用的是什么。</p><p id="b974" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，这是Redux社区中流行的一种Redux动作方式(或者，我应该说<a class="ae ng" href="https://phryneas.de/redux-typescript-no-discriminating-union" rel="noopener ugc nofollow" target="_blank">很流行</a>？).</p><p id="5907" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，我们还是能发现问题。首先，没有什么强迫你使用这些常数。因此，如果它逃过了通常一丝不苟的审查者的眼睛，您可能会得到一种混合的方法:常数和神奇的字符串。第二，代码不是很优雅，我们要么必须在类型定义中重复值，要么使用看起来很奇怪的<code class="fe mj mk ml mm b">typeof</code>操作符。无论哪种方式，增加或删除都意味着两个地方的变化。</p><h2 id="1b06" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">常数字典</h2><p id="c595" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">嗯，也许有一种方法可以把它们合二为一。当我们查看为Enum生成的代码时，我们可能会想:我们可以首先使用那个字典吗？</p><p id="d686" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个管用。它非常接近Enum:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="e895" class="na ky jb mm b gy nb nc l nd ne">const Country = {<br/>  Germany: 'DE',<br/>  Sweden: 'SE',<br/>  USA: 'US',<br/>} as const</span><span id="c778" class="na ky jb mm b gy nf nc l nd ne">type Country = typeof Country[keyof typeof Country];</span><span id="94e3" class="na ky jb mm b gy nf nc l nd ne">const setActiveCountry = (country: Country) =&gt; {<br/>  // do something<br/>}</span><span id="d399" class="na ky jb mm b gy nf nc l nd ne">setActiveCountry(Country.Sweden)</span><span id="6d09" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry('CZ')</span></pre><p id="7f8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://www.typescriptlang.org/play?ssl=16&amp;ssc=23&amp;pln=1&amp;pc=1#code/MYewdgzgLgBAwiArmKAnAnjAvDA3gKBhgHEBTVAWwEMx0AuGAcgBEBRRgGkJgGUB3UgBNSYBox7suRAKo8AgmNmd8AXxhUIMUJCj58UdAAdS8JCgzYYB4yABmp5GnQBtANal0dq0dJeEjjABdAG5uInCIonxtaBgIUig5YCgASwA3Un9zTBwAClAA+gdsgEpsAD48bgB6aphBEDiQCgSACxSwAHNVPXjE5PTMsydcrKcAOn4hERK9WpgAASgIAFpSAA9jZLXUVBBUfD6k1IyxjFzGOAAtRhKgA" rel="noopener ugc nofollow" target="_blank">游乐场链接</a></p><p id="e82d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Weel，这并不可怕。但是也不是很棒。</p><p id="ffcc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我回顾一下需要记住的几点。</p><ol class=""><li id="00e0" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv ny mg mh mi bi translated">字典必须声明为<code class="fe mj mk ml mm b"><a class="ae ng" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions" rel="noopener ugc nofollow" target="_blank">as const</a></code>。这防止了类型引擎将类型推断为通用字典<code class="fe mj mk ml mm b">Record&lt;string, string&gt;</code>。这是可以的。</li><li id="2120" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv ny mg mh mi bi translated"><code class="fe mj mk ml mm b">Country</code>字典是一个值而不是类型。我们需要单独定义类型。这是一个神秘的命令，我总是不得不谷歌一下——不太好。幸运的是，类型可以和字典一样命名，所以从现在开始它就和Enum一样了，对吗？嗯，没有。</li><li id="545c" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv ny mg mh mi bi translated">与前一种情况一样，没有任何东西真正将字典与函数参数联系起来。调用<code class="fe mj mk ml mm b">setActiveCountry('SE')</code>不会产生错误。最终,<code class="fe mj mk ml mm b">Country</code>类型只是另一个不相交的iteral类型的并集。好处是只在一个地方做改变。这是Boo(或者至少是Meh)。</li></ol><h1 id="39be" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">枚举正确的方式我的方式</h1><p id="0c7f" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">多年来，我一直使用以前的技术来避免枚举。</p><p id="fafa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后有一天，一位公关人员问:“为什么？”。</p><p id="aaa8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我正在回答的时候，我决定核实一些事实，然后……我发现我错了。枚举有两个重要的属性，这使得它们比其他任何东西都优越。即使对于那些担心有一天会回到普通JavaScript的人来说。</p><h2 id="6d5d" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">字符串枚举</h2><p id="7d55" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">不用依赖源代码顺序来定义枚举中选项的值，您可以自己定义它。</p><p id="5d81" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的代码非常接近上面的字典示例，只是更简洁。</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="3d7a" class="na ky jb mm b gy nb nc l nd ne">enum Country {<br/>  Germany = 'DE',<br/>  Sweden = 'SE',<br/>  USA = 'US',<br/>}</span><span id="c2c3" class="na ky jb mm b gy nf nc l nd ne">const setActiveCountry = (country: Country) =&gt; {<br/>  // do something<br/>}</span><span id="46ae" class="na ky jb mm b gy nf nc l nd ne">setActiveCountry(Country.Sweden)</span><span id="050f" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry('CZ')</span><span id="0160" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry('SE')</span></pre><p id="676c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://www.typescriptlang.org/play?ssl=1&amp;ssc=1&amp;pln=18&amp;pc=1#code/KYOwrgtgBAwg9mEAXATgTygbwFBSgcWBQgEMQMBeKAcgBEBRagGlygGUB3YAE1CiuptGLPAFU2AQX41xzbAF9WeZSrzYAxnBABnJFG3AkE9UgCWAN2DxEqSlAAUmm+gBcsBMnQBKfgD4srAD0gVDccPpwEIYAFqYgAOYK2NgGRiYWVh629taeaAB0nDygXsnBUAACSNoAtMAAHgAOwCZ1KChwKCmGxmaWudnUMABa1KXY5VW1Dc2tRB1dqb0ZA+j2goylQA" rel="noopener ugc nofollow" target="_blank">游乐场链接</a></p><p id="effe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，让我们讨论一些或多或少显而易见的观察结果:</p><ol class=""><li id="d4a4" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv ny mg mh mi bi translated">它使用相等的符号，而不是冒号。不要问我为什么。尽管如此，它非常接近于对象字面量。</li><li id="c286" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv ny mg mh mi bi translated">这些值必须都是字符串。不支持其他值。(技术上可以用数字，但是没有带来优势。坚持弦乐。)</li><li id="96f0" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv ny mg mh mi bi translated">你必须在任何需要枚举值的地方使用枚举值(例如<code class="fe mj mk ml mm b">Country.Sweden</code>)。传递同一个字符串是不行的(比如<code class="fe mj mk ml mm b">'SE'</code>)。这使得重构成为一个轻松的过程。并且您的代码库保持一致。</li><li id="5176" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv ny mg mh mi bi translated">不过，也不全是独角兽和彩虹。生成的代码a)仍然存在，b)仍然(有点)难看。</li></ol><p id="16f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“你到底想怎么改进，罗宾，”你可能会问</p><p id="7f83" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会享受到一顿美餐。</p><h2 id="a8f7" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">常量，字符串枚举</h2><p id="48c1" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">第二个帮助我跨越枚举卢比孔河的改进(“类型是强制转换的！”，不好意思，不好意思，我只好)是constant Enum或者简称<a class="ae ng" href="https://www.typescriptlang.org/docs/handbook/enums.html#const-enums" rel="noopener ugc nofollow" target="_blank"> const Enum </a>。</p><p id="b901" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它看起来怎么样？</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="f394" class="na ky jb mm b gy nb nc l nd ne">const enum Country {<br/>  Germany = 'DE',<br/>  Sweden = 'SE',<br/>  USA = 'US',<br/>}</span><span id="b548" class="na ky jb mm b gy nf nc l nd ne">const setActiveCountry = (country: Country) =&gt; {<br/>  // do something<br/>}</span><span id="91d7" class="na ky jb mm b gy nf nc l nd ne">setActiveCountry(Country.Sweden)</span><span id="3e80" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry('CZ')</span><span id="1cc3" class="na ky jb mm b gy nf nc l nd ne">// @ts-expect-error<br/>setActiveCountry('SE')</span></pre><p id="c376" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBApmArgWxgYRIsUBOBPGAbwCgYYBxOHZAQzAIF4YByAEQFFmAaUmAZQDucACYIYTZn048yAVT4BBcS3ndiAX15ltOssVCRYEOFAXAoASwBucDFlyMYAClD38ALnSZs+AJTiAPiJeAHoQmGEQGAgQZBMACwswAHMNYmJjU3NrW28HJzsfPAA6QREEX3SwmAABKAgAWjgADwAHOHMmnBwQHAyTM0sbQvzmNAAtZkriarrGlvbOqh6+zMGckfwnSU5fIA" rel="noopener ugc nofollow" target="_blank">游乐场链接</a></p><p id="dc80" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等等，等等，我没有骗你。</p><p id="4396" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了在<code class="fe mj mk ml mm b">enum</code>前面增加了<code class="fe mj mk ml mm b">const</code>之外，它是前面代码的完全复制。</p><p id="ed89" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">功能也完全相同。看上面的列表项:1。是一样的，2。是一样的，3。是一样的，4。就是……不一样！</p><p id="1c8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有为const枚举生成代码。这是前面代码的输出:</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="183f" class="na ky jb mm b gy nb nc l nd ne">const setActiveCountry = (country) =&gt; {<br/>    // do something<br/>}</span><span id="1a17" class="na ky jb mm b gy nf nc l nd ne">setActiveCountry('SE' /* Sweden */)</span></pre><p id="c9b4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，现在所有的值都在使用的地方内联了。没有线索表明曾经有过枚举。也许除了有用的评论。</p><p id="9ef8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，结果与我们讨论的第一种选择相同:文字类型的分离联合。然而，它更容易使用，在各方面都更安全。</p><p id="78fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总而言之，使用常量字符串枚举，您可以获得字符串枚举的所有好处(类型检查、可调试、不可由字符串替换)以及直接编写它的好处(无需额外的代码)。</p><h2 id="1222" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">不断枚举是一条单行道</h2><p id="6179" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在我们继续之前，我需要提醒你注意常量。他们不是每次都是顺带替换的。</p><p id="0fa3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有什么问题？没有办法获得一个值的标签。你看，没有字典，根本没有生成代码。因此，如果您有值，比如说<code class="fe mj mk ml mm b">'SE'</code>，并且您想要它的标签用于日志记录，在本例中是<code class="fe mj mk ml mm b">Sweden</code>，您将不能。</p><p id="6c23" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个小小的不便，你应该记住。</p><p id="447e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，如果您需要访问日志以外的标签，这可能意味着Enum不适合您。枚举标签应该只对开发人员有意义。</p><h2 id="870c" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">常量枚举可能很大</h2><p id="17c2" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我发现常量枚举的一个很好的用例是，你不关心一个枚举中的项数。可能有一个世界上所有国家的const string枚举，如果你只在那里使用，那么只有这三个会进入生产代码。其余的就会消失。代码自动完成仍然没有问题。</p><p id="4f6c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的服务代码中，我们现在有一个包含所有现有HTTP响应代码的共享常量字符串枚举(摘录):</p><pre class="ms mt mu mv gt mw mm mx my aw mz bi"><span id="144e" class="na ky jb mm b gy nb nc l nd ne">export const enum Success {<br/>  OK = '200',<br/>  Created = '201',<br/>  // …<br/>}</span><span id="f689" class="na ky jb mm b gy nf nc l nd ne">export const enum ClientError {<br/>  BadRequest = '400',<br/>  Unauthorized = '401',<br/>  PaymentRequired = '402',<br/>  Forbidden = '403',<br/>  NotFound = '404',<br/>  // …<br/>}</span><span id="3bf5" class="na ky jb mm b gy nf nc l nd ne">// …</span><span id="7257" class="na ky jb mm b gy nf nc l nd ne">export type HttpStatusCode =<br/>  | InformationalResponse<br/>  | Success<br/>  | Redirection<br/>  | ClientError<br/>  | ServerError</span></pre><h1 id="eeff" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是伟大的枚举？</h1><p id="bcc6" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">常量字符串枚举。</p><p id="3439" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。</p><p id="0444" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我现在到处使用的东西。</p><p id="b623" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在提交之前，我确保每个枚举满足以下两个条件:</p><ol class=""><li id="a86d" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv ny mg mh mi bi translated">所有枚举选项都有一个定义的自定义字符串值。</li><li id="d281" class="ma mb jb ka b kb mn kf mo kj mp kn mq kr mr kv ny mg mh mi bi translated">枚举被声明为<code class="fe mj mk ml mm b">const</code>。</li></ol><p id="5df7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为这结合了TypeScript的好处和纯JavaScript的雄辩。对结果几乎没有影响的卓越开发人员体验。</p><h2 id="ff70" class="na ky jb bd kz nn no dn ld np nq dp lh kj nr ns ll kn nt nu lp kr nv nw lt nx bi translated">结论</h2><p id="a729" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">感谢您的阅读。我希望你已经发现这是有用的。你在代码中使用枚举吗？你会避免ECMAScript没有考虑的语言特性吗？请务必在评论中让我们知道。</p><p id="8866" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">更多内容尽在</em><a class="ae ng" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="kw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>