<html>
<head>
<title>Create Tetris using React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React创建俄罗斯方块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-tetris-using-react-8d3fc28329d3?source=collection_archive---------2-----------------------#2021-11-07">https://javascript.plainenglish.io/create-tetris-using-react-8d3fc28329d3?source=collection_archive---------2-----------------------#2021-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e40" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用React创建简单的俄罗斯方块游戏</h2></div><p id="e9c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说到复古游戏，俄罗斯方块被认为是经典。对于一款1984年推出的游戏来说，它仍然能够独挡一面。它的销量已经超过1.5亿份，成为有史以来最畅销的游戏之一。在本文中，我们将尝试制作自己的俄罗斯方块游戏，以帮助我们理解和欣赏内在机制。作为参考，可以参考GitHub <a class="ae lb" href="https://github.com/umangshrestha/tetris" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/4ee73e223073cd8982a2831dec3b5137.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*NYw_4BzRlyAuU4GQ6z7OnQ.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Tetris using React</figcaption></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="1494" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">装置</h1><p id="6aa0" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们将从使用npx创建包开始。</p><pre class="ld le lf lg gt ms mt mu mv aw mw bi"><span id="572b" class="mx lw iq mt b gy my mz l na nb">$ npx create-react-app tetris<br/>$ cd tetris<br/>$ npm start</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="277d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">创建电路板</h1><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c2d21577b4ca3959489297539b821650.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*LkClLavzzT9DgqlKrXZ-WQ.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">grid matching corresponding position in board array</figcaption></figure><p id="b47f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的板子会是一维数组，数组大小等于<code class="fe nd ne nf mt b"><em class="ng">ROW_SIZE</em></code> <em class="ng"> </em>和<code class="fe nd ne nf mt b"><em class="ng">COL_SIZE</em></code>。该数组将用默认值-1初始化，此后称为<code class="fe nd ne nf mt b">DEFAULT_VALUE</code>。</p><p id="32cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用二维数组会使代码简单很多。但我最终选择了一维数组。</p><p id="b625" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">棋盘上的每个数值将由一个正方形表示。这是我们游戏中不连续的单元。方块的颜色将由棋盘上相应位置的值来表示。</p><p id="d617" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">棋盘上的数值会改变相应方块的颜色。我将它映射如下:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">value to color mapping</figcaption></figure><p id="fb64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在下一节回到形状。</p><h2 id="a106" class="mx lw iq bd lx nj nk dn mb nl nm dp mf ko nn no mh ks np nq mj kw nr ns ml nt bi translated">一.广场</h2><p id="1ad5" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">让我们从创建一个组件文件夹开始。</p><pre class="ld le lf lg gt ms mt mu mv aw mw bi"><span id="fc45" class="mx lw iq mt b gy my mz l na nb">$ mkdir src/components</span></pre><p id="d88b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的正方形将是一个简单的正方形div，它接受一个整数参数<code class="fe nd ne nf mt b">color</code>，基于这个参数我们从<code class="fe nd ne nf mt b">COLOR_MAP</code>中选择颜色。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">square.jsx</figcaption></figure><p id="ebbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们必须组合成一个正方形。</p><h2 id="115d" class="mx lw iq bd lx nj nk dn mb nl nm dp mf ko nn no mh ks np nq mj kw nr ns ml nt bi translated">二。板</h2><p id="dc3a" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">正如我们所说的，我们将用<code class="fe nd ne nf mt b">DEFAULT_VALUE</code>初始化一个大小为<code class="fe nd ne nf mt b">ROW_SIZE * COL_SIZE</code>的1D数组。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">creating empty board</figcaption></figure><p id="ff98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们编辑<code class="fe nd ne nf mt b"><strong class="kh ir">app.js</strong></code>文件，这样我们可以看到我们到目前为止做了什么。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">app.js</figcaption></figure><p id="c893" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了给它一个网格形状，我使用了样式:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">style for board</figcaption></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="beb1" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">创建形状</h1><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/01807a3ef1d84af7ad6b0a1b17f2d14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*WZ3TlH2YLP5fAcwgX6XJtQ.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Tetrominos</figcaption></figure><p id="6181" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们之前已经用颜色绘制了形状。现在我们需要标出位置。我们将对该形状及其所有可能的旋转进行硬编码。</p><p id="c1f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">俄罗斯方块有多个几何形状，称为<a class="ae lb" href="https://en.wikipedia.org/wiki/Tetromino" rel="noopener ugc nofollow" target="_blank">俄罗斯方块</a>，从顶部向下排列。这是一个4平方的正交方块。为了简单起见，从现在开始我将称它们为形状或块。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/68497aff9d108f2076ddee74e789d454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCvlC9ji80vdvKXHLH-3QQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">visualizing grid as array</figcaption></figure><p id="8046" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，可以对所有其他形状进行上述过程。我们可以用一个4*4的矩阵来表示任何形状。在上图中，我保留了5* 5作为填充。在我的代码中，我最初打算只保留4*4，但后来决定不添加任何超出我需要的东西。因此，我选择了紧凑但低效的数组，如下所示。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">shape representation</figcaption></figure><p id="14b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要一种方法来塑造形体。由此，我将使用以下指针:</p><pre class="ld le lf lg gt ms mt mu mv aw mw bi"><span id="8f35" class="mx lw iq mt b gy my mz l na nb"><strong class="mt ir">shapePos</strong> : pointers to show which type of shape we are using<br/><strong class="mt ir">rotatePos</strong>:pointer to represent which rotation of shape we are using<br/><strong class="mt ir">xPos</strong>     : position of current shape in x direction (top left)<br/><strong class="mt ir">yPos</strong>     : postion of current shape in y direction (top left)</span></pre><p id="e6fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据以上参数，我们可以得到当前形状的准确位置，如下所示:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">get shape</figcaption></figure><p id="4f67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在游戏中随机选择形状。为了实现它，我们将使用数学库中的random返回我们<code class="fe nd ne nf mt b">shapePos</code>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">getting random shape</figcaption></figure><p id="c1d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据用户输入，我们需要旋转形状。我们可以实现另一个简单的函数来返回我们<code class="fe nd ne nf mt b">randomPos</code>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">rotating the shape</figcaption></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="ce4b" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">状态</h1><p id="9f94" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们已经讨论了一些状态，如<code class="fe nd ne nf mt b">board</code>、<code class="fe nd ne nf mt b">shapePos</code>、<code class="fe nd ne nf mt b">xPos</code>等。现在我们将正式列出我们将使用的所有形状。注意，我们可以根据需要添加更多的状态变量。我使它成为最低限度，并将只使用下面的状态。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c9a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当形状下降时，我们希望它从最上面的角落一次下降一个街区。由于形状的最大尺寸可以是3，我们将保持<code class="fe nd ne nf mt b">yPos</code>的初始值为-3。我们将从列的中间开始块，这就是为什么<code class="fe nd ne nf mt b">xPos</code>是行大小的一半。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="5b82" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">按键绑定</h1><p id="20cd" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们将使用键盘与游戏互动。我们需要做的几件事是左右移动积木。顺时针和逆时针旋转该块。我们还可以添加命令来更快地放下方块或暂停游戏。这是留给用户的一个练习。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">key binding</figcaption></figure><p id="46dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将讨论与键绑定相关的函数</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="895f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">一、更新板</strong></p><p id="8253" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只为当前形状更新纸板。在我们更新之前，我们需要通过检查值是否不等于<code class="fe nd ne nf mt b">DEFAULT_VALUE</code>来确保值是形状的一部分。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">update</figcaption></figure><p id="9ad5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想要清除形状时，我们可以使用<code class="fe nd ne nf mt b">this.updateBoard({shapePos: DEFAULT_VALUE})</code>。</p><p id="a5ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">二。向左或向右移动块</strong></p><p id="7f4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们转变之前，我们需要验证以下几点:</p><pre class="ld le lf lg gt ms mt mu mv aw mw bi"><span id="7c47" class="mx lw iq mt b gy my mz l na nb">1. Verify the shape is not going out of the edge. <br/>2. Verify the shape is not going to overlap another shape.</span></pre><p id="fc97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当我们确保没有冲突时，我们才能移动区块。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">shift left</figcaption></figure><p id="edf0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">三。旋转形状</strong></p><p id="e6b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用同样的逻辑，我们也可以实现旋转。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">rotating</figcaption></figure><p id="203f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要走下街区。砖块会下降，直到接触到边界。之后，我们需要检查游戏是否结束，并开始下一个区块。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">decending block</figcaption></figure><p id="b1d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经将下降持续时间硬编码为500。我们可以实现另一种状态，随着阻塞的继续减少持续时间。这是留给读者的一个练习。现在我们将实现与降序相关的函数。</p><h2 id="9286" class="mx lw iq bd lx nj nk dn mb nl nm dp mf ko nn no mh ks np nq mj kw nr ns ml nt bi translated">动词 （verb的缩写）放下形状</h2><p id="329f" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">降档时，我们需要检查:</p><pre class="ld le lf lg gt ms mt mu mv aw mw bi"><span id="23b4" class="mx lw iq mt b gy my mz l na nb">* Verify the shape is not touching the edge,<br/>* Verify the shape is not touching a block below.<br/>* Verify game is not over</span></pre><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">shift down</figcaption></figure><p id="500e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果游戏结束了，我们将重置游戏。如果游戏没有结束，我们将检查填充的行并删除它们。然后上面的块被向下拖动。最后，我们将创建一个新块</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="d611" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">额外的</h1><ul class=""><li id="dd1c" class="oa ob iq kh b ki mn kl mo ko oc ks od kw oe la of og oh oi bi translated"><em class="ng">当我们给</em> <code class="fe nd ne nf mt b"><em class="ng">componentDidMount</em></code> <em class="ng">添加降档功能时，当您使用</em> <code class="fe nd ne nf mt b"><em class="ng">keyCode</em></code> <em class="ng">和</em> <code class="fe nd ne nf mt b"><em class="ng">setInterval</em></code> <em class="ng">更新来改变状态时，将会有一个竞态条件，要移除它，您可能需要使用</em> <code class="fe nd ne nf mt b"><em class="ng">mutex</em></code> <em class="ng">。在我的代码中，我使用了</em><code class="fe nd ne nf mt b"><a class="ae lb" href="https://www.npmjs.com/package/await-mutex" rel="noopener ugc nofollow" target="_blank"><em class="ng">await-mutex</em></a></code><a class="ae lb" href="https://www.npmjs.com/package/await-mutex" rel="noopener ugc nofollow" target="_blank"><em class="ng"/></a><em class="ng">作为同步的依赖项。要安装它:</em>T5】</li><li id="18aa" class="oa ob iq kh b ki oj kl ok ko ol ks om kw on la of og oh oi bi translated"><em class="ng"> bug#1:触摸右边缘时形状不旋转。如果边缘情况被删除，块重叠另一个形状。</em></li><li id="051e" class="oa ob iq kh b ki oj kl ok ko ol ks om kw on la of og oh oi bi translated">谈到CSS，我一点技巧都没有。所以，如果你对我糟糕的设计选择感到厌恶，请原谅我。</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="bce1" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">参考</h1><ol class=""><li id="0c8f" class="oa ob iq kh b ki mn kl mo ko oc ks od kw oe la oo og oh oi bi translated"><a class="ae lb" href="https://github.com/umangshrestha/tetris" rel="noopener ugc nofollow" target="_blank">源代码</a></li><li id="019c" class="oa ob iq kh b ki oj kl ok ko ol ks om kw on la oo og oh oi bi translated"><a class="ae lb" href="https://umangshrestha.github.io/tetris/" rel="noopener ugc nofollow" target="_blank">演示</a></li><li id="9499" class="oa ob iq kh b ki oj kl ok ko ol ks om kw on la oo og oh oi bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/create-snake-game-in-react-10d7ddbff52f">在React中创建贪吃蛇游戏</a></li><li id="e721" class="oa ob iq kh b ki oj kl ok ko ol ks om kw on la oo og oh oi bi translated"><a class="ae lb" href="https://medium.com/geekculture/create-tic-tac-toe-in-react-js-and-host-it-in-github-bb0bbec4867b" rel="noopener">在反应中创建井字游戏</a></li></ol><p id="eb59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ng">更多内容请看</em><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="ng">plain English . io</em></strong></a></p></div></div>    
</body>
</html>