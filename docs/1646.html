<html>
<head>
<title>You Can Now Export React Components as Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您现在可以将反应组件导出为图像</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/export-react-components-as-images-15168b73b0eb?source=collection_archive---------2-----------------------#2021-04-09">https://javascript.plainenglish.io/export-react-components-as-images-15168b73b0eb?source=collection_archive---------2-----------------------#2021-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2f33" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用html2canvas</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0d46ea614e679c951310e8cc73d882bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RVPRxqz2VUuY7NGXSXzmtw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kmuza?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Carlos Muza</a> on <a class="ae kv" href="https://unsplash.com/s/photos/web-app?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近的任务是实现逻辑，用网页上的数据可视化来捕获反应组件，并将其导出为图像。其他数据可视化库(如<a class="ae kv" href="https://www.highcharts.com/" rel="noopener ugc nofollow" target="_blank">高级图表</a>)允许将图形导出为图像。然而，我们需要一个来同时导出一页上的多个图表。</p><p id="cc72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是<a class="ae kv" href="https://www.npmjs.com/package/html2canvas" rel="noopener ugc nofollow" target="_blank"> html2canvas </a>派上用场的地方。</p><p id="c835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个包通过读取DOM元素及其样式，然后根据这些数据生成一个画布图像，来生成一个“屏幕截图”。它完全在客户端运行，所以您不必担心任何请求/服务器支持。</p><p id="73b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，安装npm包。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ee06" class="lx ly iq lt b gy lz ma l mb mc">npm i html2canvas</span></pre><p id="2426" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经安装了它，我们可以导入我们的组件了。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="777d" class="lx ly iq lt b gy lz ma l mb mc">import <em class="md">html2canvas </em>from "html2canvas";</span></pre><p id="bc86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以像这样使用<code class="fe me mf mg lt b">html2canvas</code>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="78c3" class="lx ly iq lt b gy lz ma l mb mc">const capture <!-- -->= () =&gt; {<br/>  <!-- -->html2canvas(document.body).then(function(canvas) {<br/>    document.body.appendChild(canvas);<br/>  });<br/>}</span></pre><p id="9e9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，<code class="fe me mf mg lt b">html2canvas</code>将一个DOM元素作为参数，从中生成一个画布图像，然后返回一个包含画布元素的<code class="fe me mf mg lt b">Promise</code>。我们可以使用<code class="fe me mf mg lt b">Promise</code>履行处理程序(<code class="fe me mf mg lt b">.then()</code>)访问它，然后用它做我们想做的任何事情。在我的例子中，我需要生成一个图像并为用户下载。</p><p id="9da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个库对我的用例来说很棒，除了一个警告。</p><p id="b964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果存在<em class="md">任何水平溢出</em>，它将只捕获可见的内容。被溢出滚动隐藏的DOM元素的任何部分都被切断了。</p><p id="99d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我需要补偿页面调整大小时隐藏的任何数据可视化效果。我可以垂直堆叠可视化效果，但是这可能很复杂。</p><h2 id="1129" class="lx ly iq bd mh mi mj dn mk ml mm dp mn lf mo mp mq lj mr ms mt ln mu mv mw mx bi translated">1.项目管理期望</h2><p id="3717" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在sprint过程中对商定的规格进行更改通常是不理想的(除非绝对没有办法在给定的时间框架内满足要求)。因为这个问题已经达成一致，改变布局会破坏开发过程，并且需要与产品团队和设计师进行更多的讨论(更多的会议，更多的时间)。</p><h2 id="dc60" class="lx ly iq bd mh mi mj dn mk ml mm dp mn lf mo mp mq lj mr ms mt ln mu mv mw mx bi translated">2.用户体验</h2><p id="2664" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">最初设计并接受最初的用户界面是有充分理由的。当您有多个可视化效果、附带表格等时，纯垂直布局并不理想。当应用程序不是移动的时候。并排比较更加困难，并且导出的图像最终会非常高，因此并不总是PowerPoint演示文稿的最佳布局。</p><p id="93f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我如何能够保持现有的UI不变，同时捕获所有相关的数据(即使它暂时被隐藏)？我的解决方案有点非正统(有点反react模式)，但是我从关于<a class="ae kv" href="https://stackoverflow.com/questions/59159579/html2canvas-jspdf-cut-off-image" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>的一个问题中获得了灵感。</p><p id="8db1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我需要做的是暂时使<code class="fe me mf mg lt b">html</code>和<code class="fe me mf mg lt b">body</code>标签足够大，以容纳数据可视化，而容器不会隐藏任何数据。一旦足够大，捕获数据，生成画布图像，然后将<code class="fe me mf mg lt b">html</code>和<code class="fe me mf mg lt b">body</code>标签设置回它们的原始大小。</p><p id="96bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大小需要是动态的，而不仅仅是设置足够大的静态宽度来适应大多数情况(如果我只有两个项目要可视化，我不需要我的容器是10，000像素宽)。在某些情况下，容器根本不需要调整大小。那么，我该如何适应需要可视化的一个、两个、十个或更多项目的宽度呢？</p><p id="d52a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的函数。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6b3f" class="lx ly iq lt b gy lz ma l mb mc">const exportAsPicture = () =&gt; {</span><span id="1143" class="lx ly iq lt b gy nd ma l mb mc">  var html = document.getElementsByTagName('HTML')[0]<br/>  var body =  document.getElementsByTagName('BODY')[0]<br/>  var htmlWidth = html.clientWidth;<br/>  var bodyWidth = body.clientWidth;<br/>  var data = document.getElementById('exportContainer')<br/>  var newWidth = data.scrollWidth - data.clientWidth</span><span id="f08d" class="lx ly iq lt b gy nd ma l mb mc">  if (newWidth &gt; data.clientWidth){<br/>    htmlWidth += newWidth<br/>    bodyWidth += newWidth<br/>  }</span><span id="d16d" class="lx ly iq lt b gy nd ma l mb mc">  html.style.width = htmlWidth + 'px'<br/>  body.style.width = bodyWidth + 'px'</span><span id="1d69" class="lx ly iq lt b gy nd ma l mb mc">  html2canvas(data).then((canvas)=&gt;{<br/>    var image = canvas.toDataURL('image/png', 1.0);<br/>    var fileName = currentExport.split("Export")[0] + '.png'<br/>    saveAs(image, fileName)<br/>  })<br/>}</span></pre><p id="bc0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我得到了<code class="fe me mf mg lt b">html</code>和<code class="fe me mf mg lt b">body</code>的宽度。我需要这些来决定我的起始宽度。然后我捕获容器的<code class="fe me mf mg lt b">clientWidth</code>和<code class="fe me mf mg lt b">scrollWidth</code>。<code class="fe me mf mg lt b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth" rel="noopener ugc nofollow" target="_blank">clientWidth</a></code>是元素的内部宽度，以像素为单位。它包括填充，但不包括边框、边距和滚动条。</p><p id="7f1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe me mf mg lt b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollWidth" rel="noopener ugc nofollow" target="_blank">scrollWidth</a></code>该值是否等于元素在不使用水平滚动条的情况下适合视窗中所有内容所需的最小宽度(即，如果没有溢出，则为我的容器的宽度)。</p><p id="7156" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么我们需要这两种价值观呢？因为我希望宽度变化是动态的(相对于需要可视化的项目数量)，所以我想比较一下<code class="fe me mf mg lt b">clientWidth</code>和<code class="fe me mf mg lt b">scrollWidth</code>，看看我是否需要改变宽度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d249df4522ba912cf29ef25c48612c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*hYsLKakc5zA6jPVtsbyLtg.gif"/></div></figure><p id="257c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe me mf mg lt b">clientWidth</code> <em class="md">是</em> <em class="md">而不是</em>小于<code class="fe me mf mg lt b">scrollWidth</code>(容器中没有溢出/隐藏的部分)，那么我就保持<code class="fe me mf mg lt b">html</code>和<code class="fe me mf mg lt b">body</code>的宽度不变。如果<code class="fe me mf mg lt b">clientWidth</code> <em class="md">比<code class="fe me mf mg lt b">scrollWidth</code>小</em>(这里<em class="md">是</em>容器的一部分被隐藏了)我需要把<code class="fe me mf mg lt b">scrollWidth</code>和<code class="fe me mf mg lt b">clientWidth</code>的差值加到<code class="fe me mf mg lt b">html</code>和<code class="fe me mf mg lt b">body</code>的宽度上。</p><p id="250c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦宽度足够大，我就使用<code class="fe me mf mg lt b">html2canvas</code>来捕获容器中的DOM元素，生成一个canvas元素，然后通过<code class="fe me mf mg lt b">canvas.toDataURL(‘image/png’, 1.0).</code>从canvas元素创建一个DataURL</p><p id="ba9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe me mf mg lt b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL" rel="noopener ugc nofollow" target="_blank">canvasToDataURL</a></code>返回一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" rel="noopener ugc nofollow" target="_blank">数据URI </a>，包含由<code class="fe me mf mg lt b">type</code>参数指定格式的图像表示(默认为<a class="ae kv" href="https://en.wikipedia.org/wiki/Portable_Network_Graphics" rel="noopener ugc nofollow" target="_blank"> PNG </a>)。返回的图像分辨率为96 dpi。我添加的<code class="fe me mf mg lt b">1.0</code>是一个编码器选项，用于确定图像质量(在0和1之间)。从<code class="fe me mf mg lt b">canvasToDataURL</code>返回的值将如下所示。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="fc7a" class="lx ly iq lt b gy lz ma l mb mc">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABPMAAAXSCAYAAAB956qJAAAgAElEQVR4XuydB7QkRfWHi7jknDNIFgQEJAclCgiSRRABJSNBcpYcVCQoUaLkj...</span></pre><p id="0a32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了这个，我们可以在我们的第一个<code class="fe me mf mg lt b">Promise</code>处理程序中返回它，在那里我们将新生成的图像传递给<code class="fe me mf mg lt b">saveAs</code>。参见下面的<code class="fe me mf mg lt b">saveAs</code>代码。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="a75b" class="lx ly iq lt b gy lz ma l mb mc">const saveAs = (blob, fileName) =&gt;{<br/>  var elem = <em class="md">window</em>.document.createElement('a');<br/>  elem.href = blob<br/>  elem.download = fileName;<br/>  elem.style = 'display:none;';<br/>  (<em class="md">document</em>.body || <em class="md">document</em>.documentElement).appendChild(elem);<br/>  if (typeof elem.click === 'function') {<br/>    elem.click();<br/>  } else {<br/>    elem.target = '_blank';<br/>    elem.dispatchEvent(new <em class="md">MouseEvent</em>('click', {<br/>      view: <em class="md">window</em>,<br/>      bubbles: true,<br/>      cancelable: true<br/>    }));<br/>  }<br/>  <em class="md">URL</em>.revokeObjectURL(elem.href);<br/>  elem.remove()<br/>}</span></pre><p id="fe21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然看起来这个函数有很多功能，但它基本上只是创建了一个<code class="fe me mf mg lt b">a</code>标签，将图像数据指定为<code class="fe me mf mg lt b">href</code>，然后将<code class="fe me mf mg lt b">a</code>标签作为下载链接。我们模拟一个点击事件，触发下载，然后我们在下载完成后移除<code class="fe me mf mg lt b">a</code>标签，以免将其永久添加到DOM中。</p><p id="c81b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你知道了。您现在可以使用<code class="fe me mf mg lt b">html2canvas</code>和上面的代码开始下载React组件作为图像。这篇文章的代码可以在<a class="ae kv" href="https://github.com/macro6461/html2canvas-demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="377d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://matt-croak.medium.com/membership" rel="noopener"> <em class="md">在这里将你的免费中级会员升级为付费会员</em> </a> <em class="md">，每月只需5美元，你就可以获得数千位作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="2e10" class="nm ly iq bd mh nn no np mk nq nr ns mn jw nt jx mq jz nu ka mt kc nv kd mw nw bi translated">参考</h1><div class="nx ny gp gr nz oa"><a href="https://github.com/macro6461/html2canvas-demo" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">macro 6461/html 2 can vas-演示</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">通过在GitHub上创建帐户，为macro6461/html2canvas-demo开发做出贡献。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://www.npmjs.com/package/html2canvas" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">html2canvas</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">JavaScript截图</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">www.npmjs.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://stackoverflow.com/questions/59159579/html2canvas-jspdf-cut-off-image" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">Html2canvas / jspdf截图</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">我想为我的项目中的一个元素制作一个pdf，但是图像一直在右边被截断。我使用jspdf和…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">stackoverflow.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">Element.clientWidth</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">对于内联元素和没有CSS的元素，Element.clientWidth属性为零；否则就是内宽…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">developer.mozilla.org</p></div></div><div class="oj l"><div class="or l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollWidth" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">Element.scrollWidth</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">Element.scrollWidth只读属性是元素内容宽度的度量值，包括不包含内容的内容</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">developer.mozilla.org</p></div></div><div class="oj l"><div class="os l ol om on oj oo kp oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">HTMLCanvasElement.toDataURL()</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">HTMLCanvasElement.toDataURL()方法返回一个数据URI，其中包含格式为…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">developer.mozilla.org</p></div></div><div class="oj l"><div class="ot l ol om on oj oo kp oa"/></div></div></a></div><p id="78dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="md">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="md">plain English . io</em></strong></a></p></div></div>    
</body>
</html>