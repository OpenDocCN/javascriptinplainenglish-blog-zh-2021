<html>
<head>
<title>Let’s Build a MERN Stack E-Commerce Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们建立一个MERN堆栈电子商务网络应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-f26613a344e1?source=collection_archive---------3-----------------------#2021-02-19">https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-f26613a344e1?source=collection_archive---------3-----------------------#2021-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f031" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第6部分:构建Redux Reducers并处理Auth组件</h2></div><p id="66d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第六部分中，我们将通过构建所有reducers文件来完成Redux设置。我们还将处理React应用程序中与身份验证相关的组件。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/28a468350c94a4d08347ac3219f46246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bbtPdB4GzOrovW3P"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@robertocortese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roberto Cortese</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6221" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">朋友们好！这是MERN堆栈系列的第六部分。在前四部分中，我们详细讨论了应用程序的后端部分——从设置路线到通过stripe接受支付；我们在这四个部分做了所有的后台工作。然后在第五部分，我们开始构建我们的前端，设置Redux动作和存储。</p><p id="de95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你还没有阅读前五部分，我把它们链接在这里给你</p><div class="ls lt gp gr lu lv"><a href="https://js.plainenglish.io/build-an-e-commerce-website-with-mern-stack-part-1-setting-up-the-project-eecd710e2696" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第1部分:设置项目</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">js .平原英语. io</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://js.plainenglish.io/build-an-e-commerce-website-with-mern-stack-part-2-designing-the-models-e231b2454aba" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第2部分:设计模型</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">js .平原英语. io</p></div></div><div class="me l"><div class="mk l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://js.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-d619f3374d73" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第3部分:构建身份验证和项目路由和控制器</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">js .平原英语. io</p></div></div><div class="me l"><div class="ml l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://js.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-accb4c14ce71" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第4部分:构建购物车并订购路线和控制器</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">js .平原英语. io</p></div></div><div class="me l"><div class="mm l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://js.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-444082ae81bd" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第5部分:设置客户机和Redux</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">js .平原英语. io</p></div></div><div class="me l"><div class="mn l mg mh mi me mj ll lv"/></div></div></a></div><p id="d791" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在第六部分，我们将通过构建Redux文件来完成Redux设置，并且我们将开始处理一些组件。</p><p id="e340" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，让我们首先开始构建reducer文件。我们将在<em class="mo">客户端</em>文件夹中创建一个文件夹，我们将其命名为<em class="mo"> reducers。</em>在这个文件夹中，我们将创建六个文件——index、authReducer、itemReducer、errorReducer、cartReducer和orderReducer。</p><h2 id="0355" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">自动减速器</h2><p id="4f21" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">所以，首先是auth reducer文件。顾名思义，这个文件用于身份验证。</p><p id="299b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先从<em class="mo"> actions </em>文件夹的<em class="mo"> types </em>文件中导入认证所需的所有类型。</p><p id="0230" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们设置一个初始状态，从本地存储中检索令牌。我们还将<em class="mo"> isAuthenticated </em>设置为null，将<em class="mo"> isLoading </em>设置为false。我们还将<em class="mo">用户</em>字段设置为false。</p><p id="b345" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们开始检查每种行动类型，并进行适当的更改。</p><ol class=""><li id="a261" class="nn no iq kh b ki kj kl km ko np ks nq kw nr la ns nt nu nv bi translated"><strong class="kh ir"> USER_LOADING </strong> —如果是这种类型，我们可以说用户正在被加载，因此我们将<em class="mo"> isLoading </em>设置为true。</li><li id="78fd" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> USER_LOADED — </strong>在这种情况下，我们将<em class="mo"> isLoading </em>设置为false，将<em class="mo"> isAuthenticated </em>设置为true。我们还将用户<em class="mo">设置为我们从动作文件中接收到的有效负载。</em></li><li id="b52a" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> LOGIN_SUCCESS，REGISTER_SUCCESS </strong> —在这两个场景中，我们将<em class="mo"> isAuthenticated </em>设置为true，并且我们还设置了在本地存储中接收的令牌。</li><li id="569e" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> AUTH_ERROR、LOGIN_FAIL、LOGOUT_SUCCESS、REGISTER_FAIL </strong> —在所有这四种情况下，我们都从本地存储中删除令牌。我们将令牌和用户设置为<em class="mo"> null。</em>我们还将<em class="mo"> isAuthenticated </em>和<em class="mo"> isLoading </em>设为false。</li></ol><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="93b5" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">itemReducer</h2><p id="bc8b" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">现在，我们将处理itemReducer文件，它将处理与该应用程序中的项目相关的所有任务。我们将首先导入与项目相关的所有类型。</p><p id="ff3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们设置了一个初始状态，其中我们将<em class="mo">项</em>设置为空数组，并将<em class="mo">加载</em>设置为假。</p><p id="5192" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们开始检查每种行动类型，并进行适当的更改。</p><ol class=""><li id="6ee1" class="nn no iq kh b ki kj kl km ko np ks nq kw nr la ns nt nu nv bi translated"><strong class="kh ir">获取_物品</strong> —这是获取物品的缩减器。在这种情况下，我们将把items数组设置为从actions接收的有效负载。我们还将loading设置为false，以表示项目已经被加载。</li><li id="fd1e" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> ADD_ITEM </strong> —在这种情况下，我们使用spread操作符调用我们的状态，然后将从有效负载接收的新项添加到items数组中。</li><li id="d851" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> DELETE_ITEM </strong> —在这种情况下，我们通过有效负载获取被删除项目的id。因此，我们获取items数组，并通过过滤移除id匹配的项。</li><li id="2543" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> UPDATE_ITEM — </strong>在这种情况下，我们从有效负载中获取id和更新的项目。然后，我们使用id从items数组中找到该项，然后用新项更新它。</li><li id="a935" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> ITEMS_LOADING — </strong>我们将LOADING设置为true，表示正在加载项目。</li></ol><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="5fa0" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">误差缩减器</h2><p id="c545" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">在这个缩减器中，我们将管理应用程序的错误部分。我们导入两种与错误相关的类型。</p><p id="2e85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们定义一个初始状态，将<em class="mo">消息</em>设置为空对象，<em class="mo">状态</em>设置为空，并且<em class="mo"> id </em>也设置为空。</p><p id="5655" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两个案子要处理。第一种情况处理获取错误，第二种情况处理清除错误。</p><ol class=""><li id="e119" class="nn no iq kh b ki kj kl km ko np ks nq kw nr la ns nt nu nv bi translated"><strong class="kh ir"> GET_ERRORS — </strong>我们设置从动作的有效负载中收到的消息、状态和id。</li><li id="86e2" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> CLEAR_ERRORS </strong> —在这种情况下，我们只需重置一切。我们将消息设置为一个空对象，并将状态和id设置为null。</li></ol><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="b444" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">卡式减速器</h2><p id="f81b" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">在这个文件中，我们将处理与用户购物车相关的减速器。我们从actions文件夹中定义的<em class="mo">类型</em>文件中导入与购物车相关的类型。</p><p id="d28d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将初始状态定义为购物车设置为空，装载设置为假。</p><ol class=""><li id="183c" class="nn no iq kh b ki kj kl km ko np ks nq kw nr la ns nt nu nv bi translated"><strong class="kh ir">GET _ CART</strong>—在这种情况下，我们通过来自actions文件的有效负载接收购物车，并将其设置为我们在初始状态中定义的购物车。我们还将loading设置为false。</li><li id="baeb" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> ADD_TO_CART，DELETE_FROM_CART— </strong>在这两种情况下，我们都获取更新后的购物车，并将购物车设置为从操作接收到的有效负载。</li><li id="ea07" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> CART_LOADING </strong> —在这种情况下，我们将LOADING设置为true。</li></ol><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="14af" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">订单缩减器</h2><p id="0f99" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">在这个文件中，我们将处理与我们的应用程序中的订单相关的减速器。我们首先导入订单的所有相关类型。</p><p id="cbc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们定义一个初始状态，在该状态下，我们将订单定义为一个空数组，还定义了loading并将其设置为false。</p><ol class=""><li id="7965" class="nn no iq kh b ki kj kl km ko np ks nq kw nr la ns nt nu nv bi translated"><strong class="kh ir"> GET_ORDERS — </strong>在本例中，我们将ORDERS数组设置为从actions文件接收的有效负载。我们还将loading设置为false。</li><li id="7930" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir"> CHECKOUT </strong> —在这种情况下，我们从有效负载接收新订单，并将其添加到订单数组中。</li><li id="5332" class="nn no iq kh b ki nw kl nx ko ny ks nz kw oa la ns nt nu nv bi translated"><strong class="kh ir">订单_装载— </strong>我们将装载设置为true。</li></ol><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="35a1" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">索引(组合减速器)</h2><p id="9a89" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">在这个文件中，我们从所有不同的文件导入所有的reducer——items、cart、order、auth和error，然后使用从redux获得的<em class="mo"> combineReducers </em>函数将它们组合起来。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b07a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们已经完成了所有的冗余工作。现在，我们可以专注于为我们的应用程序构建组件。</p><blockquote class="od oe of"><p id="6114" class="kf kg mo kh b ki kj jr kk kl km ju kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated">注意:在这个应用程序中，我们将有一个非常糟糕的设计。我们不关注CSS和动画。我们只是关心React，所以如何以一种更好的方式设计它们取决于你。</p></blockquote><p id="da86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将在这一部分讨论身份验证所需的组件，并在本系列的下一部分讨论所有其他组件。</p><p id="e8d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将在客户端文件夹中创建一个名为<em class="mo"> components </em>的文件夹。因为我们将所有的认证组件与我们的其他组件分开，所以将在<em class="mo">组件</em>文件夹中创建另一个名为<em class="mo"> auth </em>的文件夹。</p><p id="44fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的登录和注册将是基于模态的，这将显示在导航栏中。</p><h2 id="3a0b" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">loginModal</h2><p id="5ac1" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">因此，我们将在这个文件中构建我们的登录组件。我们将从React导入<em class="mo">组件</em>。我们从Reactstrap导入各种东西，我们将使用它们来制作我们的组件。我们还从react-redux导入了<em class="mo">连接</em>。</p><p id="247b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还导入了PropTypes来定义我们将在这个文件中使用的所有prop类型。此外，我们导入登录和清除错误操作。</p><p id="0ca1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义了一个状态，将email和name设置为空字符串。我们还将modal设置为false，msg设置为null。</p><p id="b451" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们定义我们所有道具类型。然后，我们将设置<em class="mo"> componentDidUpdate </em>，并将之前的道具作为参数。然后我们检查当前的错误对象是否等于前一个错误。如果不是，那么我们检查错误是否来自LOGIN_FAIL，如果是，我们将msg设置为错误的msg；否则，我们将msg设置为空。</p><p id="722c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还检查我们是否被认证；如果是，我们关闭模态。</p><p id="1f8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们设置一个切换函数来切换模态的状态。我们还设置了一个onChange函数，当我们在表单字段中键入时，它会更新电子邮件和密码的值。</p><p id="989b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们设置一个onSubmit函数，它从状态中获取电子邮件和密码，并将它们传递给登录操作。</p><p id="5f51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们用JSX代码来显示我们的模态和模态中的表单。在表单中，我们有两个输入字段，电子邮件和密码。我们还有一个提交按钮。</p><p id="7960" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我们定义一个<em class="mo"> mapStateToProps </em>，并从我们在reducer文件中设置的状态中获取<em class="mo"> isAuthenticated </em>和<em class="mo"> error </em>。最后，我们将LoginModal连接到这些状态和动作函数，并将其导出。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="06bc" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">注册模式</h2><p id="3f4b" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">这将处理我们网站上的注册。这将与登录模式非常相似，因此我们不会详细讨论。只有一些不同——比如我们使用了<em class="mo">注册</em>动作，而不是<em class="mo">登录</em>动作。这次我们有三个字段—姓名、电子邮件和密码。因此，我们的表单将有三个输入字段。</p><p id="df03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其余大部分保持不变。当提交表单时，我们调用register动作，并将三个值传递给它。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="8b1f" class="mp mq iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">注销</h2><p id="2669" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">这个很简单。它只是使用了一个导航链接和一个显示注销的按钮。单击时，它调用注销操作。我们将它与注销操作连接起来，然后将其导出。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c9a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，这就是这部分的全部内容。我们已经完成了Redux部分，还构建了认证所需的组件。</p><p id="dc8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一部分，也是最后一部分，我们将构建其余的组件，并结束这个系列。</p><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/lets-build-a-mern-stack-e-commerce-web-app-8b0ef902d25e"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第7部分:完成项目</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="me l"><div class="oj l mg mh mi me mj ll lv"/></div></div></a></div><p id="8438" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想访问这个项目的完整代码，请访问这个项目的<a class="ae lr" href="https://github.com/shubham1710/MERN-E-Commerce" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="8232" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望它能帮助你学到一些东西，并让你感到兴奋。完成本系列后，您还可以阅读更多此类文章:</p><div class="ls lt gp gr lu lv"><a href="https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-overview-part-1-1f847d53753f" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用Django Rest框架构建博客网站——概述(第1部分)</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">让我们使用Django Rest框架构建一个简单的博客网站，以了解DRF和REST APIs是如何工作的，以及我们如何添加…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="or l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://towardsdatascience.com/build-a-job-search-portal-with-django-overview-part-1-bec74d3b6f4e" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">用Django构建求职门户——概述(第1部分)</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">让我们使用Django建立一个工作搜索门户，它允许招聘人员发布工作并接受候选人，同时…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="os l mg mh mi me mj ll lv"/></div></div></a></div></div></div>    
</body>
</html>