# 依赖注入的 JavaScript 模块进化

> 原文：<https://javascript.plainenglish.io/evolution-of-modules-in-javascript-with-dependency-injection-5c51a3f6442e?source=collection_archive---------7----------------------->

## 在 ES5 中用词法作用域和闭包定义单个模块，并使用容器模块模式(控制反转)来维护多个模块之间的依赖关系。

![](img/fbfbd5d76f63b054da9f50394880db0b.png)

A BNSF train hauls containers. Image: Flickr/Clay Gilliland

在 [EcmaScript 规范版本 6(2015)](https://262.ecma-international.org/6.0/) 出现之前，JavaScript 是一种完全不同的语言，它与 Scheme (甚至 Lisp)有着非常接近的[相似性，并且没有类似于传统面向对象编程的`class`语法。](https://medium.com/thinking-with-computers/javascript-is-not-scheme-7a84889e9b3c)

在本文中，我们将使用与 [EcmaScript 规范第 5 版(2009)](https://262.ecma-international.org/5.1/) 兼容的设计模式，并展示通过依赖管理和依赖注入实现模块化的方法，而没有 `[class](https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4)`的[陷阱。](https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4)

# 模块

在我们剖析 JavaScript 的原生功能并根据我们的设计模式扩展它们以使系统更加模块化之前，我们必须先退后一步，问自己是什么使代码模块化？

最核心的是，术语**模块**被*牛津词典*定义为“*一组标准化部件或独立单元中的每一个，它们可用于构建更复杂的结构，如一件家具或一栋建筑*。”

如果我们将这种思想融入计算机科学，确切地说，融入软件工程，我们可以说*一个模块是程序的一部分，程序是由一个或多个独立开发的模块组成的，这些模块直到程序链接起来才组合在一起。单个模块可以包含一个或多个例程*。

在 JavaScript 中，在 EcmaScript 6 之前，将函数拆分成单独的*模块*(或*类*，我们在这里将互换使用这些术语)的标准方式是使用所谓的 [***(揭示)*** ***模块模式***](http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html) 来完成的。下面的代码片段展示了模块名为*的电影*的模式。

这就创建了一个封装的 *Movie* 模块的实现，它接受两个参数— *name* 和 *director —* 进行实例化，并提供三个成员函数与之交互，即 *getDirector* 、 *getName、*和 *toString* 。考虑下面的例子来更好地理解它的工作原理:

但这种实现的问题是，成员字段 *(name，director)* 与*实例*(或*对象*，可互换)绑定。因此，解封装这些值甚至覆盖它们并不费力。

# 私有成员变量

是的，你可以在 JavaScript 中拥有一个私有成员字段，尽管有些冷嘲热讽。虽然实现起来有点复杂，但肯定不是不可能的。此外，有一个 [RFC](https://github.com/tc39/proposal-class-fields#private-fields) 有效地使该功能成为浏览器和 Node.js 的本地功能。首先考虑下面的例子，然后我们可以更深入地解释:

[*WeakMap*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) 保存使用 [*映射*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) 定义的每个实例的状态引用。根据规范， *WeakMap* 的键必须是非原始的，这样它们才能被垃圾回收。

就其本质而言，一旦键不再被引用，它在映射中指向的值也将可用于垃圾收集，从而保持内存足迹的干净。这里要注意的是，只有在除了键之外没有对该内存位置的引用时，才会对该值进行垃圾收集。

由于 JavaScript 的闭包属性， *WeakMap* 实例只能在 Movie 的成员函数中访问，因此不能从外部访问。所以，我们的内部状态在每个实例中都是安全的。因此，如果我们再次运行相同的示例，输出将会不同:

# 模块间的关系

既然我们对什么是模块有了一个清晰的概念，让我们关注下一部分，即模块和通信技术之间的关系。

假设有另一个叫做*艺术家*的模块，我们很快就会看到它的实现。现在为了简单起见，让我们从一个简单的单向关系开始，也就是说，要么*电影*知道*艺术家*，要么相反。

先拿*电影*独立于*艺人*而*艺人*依赖于*电影*的情况来说。用外行人的话来说，当谈论电影时，我们不能告诉任何关于艺术家为谁工作的信息，但是当谈论每个艺术家时，我们总是知道他们为哪部电影工作。正因为如此，我们必须先实例化电影，然后艺术家对象才能使用它们。

这里应用了相同的技术来封装实例的内部状态。通过运行下面的例子，我们系统的知识缺口变得非常清晰:

另一种说法是，所有的电影都必须了解艺术家，但是我们可以接受艺术家缺乏关于电影的信息。所以，我们稍微修改了一下电影的实现。

用法如下所示:

这个实现也是不完整的，因为我们无法在*组合关系*中双向获取信息。我们可以将一个带有额外成员函数 *(* `*addMovie*` *)* 的变通方法放入 *Artist* 模块中，以便在初始化*(关联关系)*期间将*电影*添加回每个 *Artist* 对象。但是这只会增加固有的复杂性，同时损害可读性。我们会看到有一种更简单的方法来处理这个问题。

# 模块工厂模式

我们可以做的一个简单的改进是将模块包装在工厂函数中，以便从一个对象早期引用另一个对象。通过这种方式，我们可以确保单个实体只有一个实例，并提供另一种消费对象的方式，而不必直接引用它们。

并且该实现可以进一步如下使用:

系统的局限性在于，即使你可以从*电影*对象中懒引用*艺术家*对象，但之前还是需要实例化。我们可以交换模块的位置，但问题仍然存在。

# 依赖注入模式

*工厂模式*的限制是，因为我们在编写模块时试图绑定它们。依赖注入是实现这一点的一种方式，但只能在运行时实现。实现几乎是相似的，除了一些细微的差别，这使得访问另一个的实例变得很容易。

并且可以用作:

这修复了前面提到的模式的所有问题。现在，所有对象都可以随时实例化，并可以在显式引用它们之前设置为消费。请记住，这个实现使用*映射*来保存对它们的 [*主键*](https://docs.microsoft.com/en-us/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver15) 的引用，这些主键恰好是原始值，一旦引用不再被使用，就应该清除它们以避免内存泄漏。

您可能已经意识到这种方法的一个问题是可伸缩性问题。随着系统中模块的增多，管理它们之间的依赖关系将变得单调乏味且容易出错。即使你能成功做到这一点，系统的认知复杂性也会成倍增加。

# 容器模块模式

避免依赖注入模式的这些警告的一个方法是为所有的依赖维护一个单一的事实来源。我们将那个*容器*和其中的每个依赖项称为*容器模块*。在这种模式中，每个依赖项或*容器模块*都使用一个唯一的标识符进行标记，这个标识符用于在运行时取回那些依赖项。为了更好地理解这个概念，请考虑下面的实现:

现在，我们可以将我们的依赖项，即*电影*和*艺术家*绑定到这个*容器*中，稍后从同一个容器中访问它们。

现在到了关键时刻，我们通过运行以下示例来测试这些实现:

请注意`miachelCaine`是如何被引用的，但数据却保存在其中。这种模式可以让你完全解耦模块实现，然后将它们绑定到一个单独的*容器*中，让事情正常进行。

# 开放源码

有许多开源项目致力于通过实现这样的模式让开发人员的生活变得更容易，同时保持 API 的简单。其中一个项目是 [*反演*](https://github.com/inversify/InversifyJS) ，Eclipse 社区在他们的 Web IDE 项目 [*【忒伊亚】*](https://github.com/eclipse-theia/theia) 中使用了这个项目。另一个流行的项目是 [*Typedi*](https://github.com/typestack/typedi) ，它有非常棒的绑定工具，有 [*Express*](https://github.com/expressjs/express) 和*typeform*，这是 Node.js 后端解决方案的流行框架。人们总是建议使用这样的工具，而不是自己制作，尤其是如果您想要运行一个生产应用程序。

# 结论

1.  模块是大规模软件工程的组成部分。
2.  模块可以用 JavaScript 创建，即使没有任何*类*语法。
3.  私有属性可以添加到 ES5 JavaScript 模块中，尽管有点复杂。
4.  多个模块之间的交互更容易，尽管有一个工厂方法围绕着它们。
5.  我们应该通过将前面提到的工厂方法作为依赖传递来反转实例化的控制。
6.  如果系统增长，数量模块将增加，它们之间的依赖关系也将增加，从而产生所谓的 [*依赖地狱*](https://en.wikipedia.org/wiki/Dependency_hell) 。
7.  我们可以使用*容器模块模式*来保持依赖之间的健全性，并且为所有人提供一个单一的真理来源。

*更内容见于* [*中*](http://plainenglish.io/)