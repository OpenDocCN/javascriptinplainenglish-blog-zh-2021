<html>
<head>
<title>A Beginner’s Guide To JavaScript Under The Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下的JavaScript初学者指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-beginners-guide-to-javascript-under-the-hood-bc60fc352163?source=collection_archive---------2-----------------------#2021-02-11">https://javascript.plainenglish.io/a-beginners-guide-to-javascript-under-the-hood-bc60fc352163?source=collection_archive---------2-----------------------#2021-02-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a500" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript是一种解释语言，这意味着我们不必在将它发送到浏览器之前进行编译。解释器获取原始代码并为您运行。</p><p id="c054" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常情况下，一个基本的JavaScript引擎会包含一个编译器，它的工作是将JavaScript源代码编译成一个中间表示<em class="ki"> (IR) </em>，这个中间表示通常被称为字节码，这个字节码被提供给解释器。</p><p id="36e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编译器的基本工作是尽可能快地编译代码，并为解释器提供优化程度较低的字节码。现在，由于解释器必须处理未优化的代码，当应用程序高度动态和交互时，会有一些副作用。</p><p id="d8a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以通过谷歌Chrome浏览器在网络上显示谷歌地图时遇到的问题来理解。他们需要找到提高JavaScript性能的方法。所以在谷歌V8引擎的最初几天，他们做了两件事来优化JavaScript性能。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/79dcbdbbc6543684d08e943acd32de1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzhgMmlWU8UKeB0uT2sJ9A.png"/></div></div></figure><p id="570e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> V8 </strong> JavaScript引擎的<strong class="jm io"> 2010版本</strong>中，<strong class="jm io">全代码生成</strong>是<strong class="jm io">基线编译器</strong>，它的工作是尽可能快地吐出未优化的机器代码，以实现更快的应用引导。</p><p id="a6fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当应用程序运行时，<strong class="jm io">曲轴</strong>编译器将会启动并优化源代码，并将替换编译器生成的那部分机器代码。随着更多优化代码的生成，这将带来更好的性能。</p><p id="5693" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您所看到的，上面的模型没有解释器。这是一个JIT <em class="ki"> (Just-In-Time) </em>编译模型，因为代码被动态编译成机器码，随后被优化<em class="ki">。</em></p><p id="2df6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">后来，他们做了一些优化来提高JavaScript的性能。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h1 id="4b4c" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">JavaScript中的代码实际上是如何运行的？</h1><p id="885d" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">JavaScript很容易理解，是前端开发必不可少的部分。</p><p id="7cdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是有一点将它与当前场景中的许多其他语言区分开来，那就是单线程。这意味着它一次只能执行一个代码。这意味着代码的任何部分需要更长的时间或像永远一样去执行，这将阻塞所有需要在那之后执行的东西。</p><p id="cfc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一行代码就可以阻塞整个应用程序。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/1711ead498a3a43d815a57b8646636da.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*OfW_c6mUrLSlNpEWyH_43g.png"/></div></figure><p id="6c8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你打开一个浏览器时，这个单线程负责网页上发生的所有事情。滚动、点击事件和监听DOM中的其他事件。</p><p id="8d81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果执行被阻止，浏览器将停止做任何事情，它将冻结或只是没有反应。</p><p id="727d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现这一点的简单代码是永无止境的while循环或永不退出的递归。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7437" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在此之后的任何代码都不会被执行，因为其余的代码将变得无法访问，因为它将永远不会结束，浏览器将继续处理永恒的while循环。</p><p id="5cf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢现代浏览器，因为不是所有打开的浏览器标签都依赖于单个JavaScript线程。相反，他们为每个标签或每个域使用单独的JavaScript <strong class="jm io">线程。</strong></p><p id="a1f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们深入了解JavaScript运行时，以及一切是如何结合在一起实现这一奇迹的。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="d720" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript的一切都发生在全局执行上下文中。</p><p id="9af0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">全局执行上下文由两部分组成:</p><ol class=""><li id="2310" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated">记忆创造阶段</li><li id="b9b1" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">代码执行阶段</li></ol><p id="b92a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在内存创建阶段，JavaScript为变量和函数分配内存。在变量的情况下，undefined被指定为占位符，而在函数的情况下，函数的整个代码被存储。</p><p id="c1ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在代码执行阶段，代码逐行执行。在这里，undefined被变量的值所代替。</p><p id="48ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你现在已经明白了，你就能回答<em class="ki">为什么我们能够在</em> <em class="ki">初始化</em>之前调用函数了。</p><p id="0b61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">答案是因为在内存创建阶段，首先执行的是将内存分配给函数，并像存储其他变量一样存储它。类似于为什么在变量初始化之前调用变量会显示undefined而不是未定义。</em></p><p id="a003" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到我们的代码示例，代码内部发生的是我们的函数<strong class="jm io">第三个</strong>调用我们的函数<strong class="jm io">第二个</strong>调用函数<strong class="jm io">第一个</strong>登录我们的控制台。</p><p id="512a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦内存分配部分完成。</p><p id="5b6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们运行这个程序时，首先是函数<strong class="jm io">第三个</strong>一直运行到控制台记录语句。但是在后台，每当一个函数被调用时，它就被推入堆栈<em class="ki">(LIFO last-in-first-out)</em>，并且只有当整个函数被执行时才被弹出。</p><p id="98a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以在我们的例子中，函数<strong class="jm io">第三个</strong>被按下，然后函数<strong class="jm io">第二个</strong>，然后函数<strong class="jm io">第三个。</strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d29d2cf77d78400c04094c47a2063ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fwyhwZrAmsLIvCRNFKL6A.png"/></div></figure><p id="cd5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第三个功能是读取，并且<em class="ki"> hello </em>正在我们的控制台中记录。一旦完成，函数内部就没有要执行的东西了，它就被弹出来了。第二和第三个函数也是如此。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mx"><img src="../Images/2bce1d6e6f657d60584d8e4222afdd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oUd-4h3ipwZeLymVB-bFdA.gif"/></div></div></figure><p id="082c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆是一个空闲的内存存储单元，你可以在其中随机存储内存。堆由JavaScript运行时管理，并由垃圾收集器清理。</p><p id="e6d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以在浏览器中看到这一点，方法是将调试器设置在第二行，并检查源代码选项卡下的调用堆栈开发工具。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/2b12ccee8b94237afb8b4bf938f39d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_A6NFFuQcwOYeExWH1WDjw.png"/></div></figure><p id="b7fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为JavaScript是单线程的，所以每个进程只有一个栈和一个堆。因此，如果任何其他程序想要执行某个东西，它必须等到前一个程序完全执行完。该线程俗称<strong class="jm io">主线程</strong>或<strong class="jm io">主执行线程</strong>。</p><p id="5551" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们想一个场景。如果浏览器发送一个HTTP请求，请求通过网络加载一些数据，或者加载一个图像以显示在网页上，该怎么办？浏览器会冻结直到请求被解决吗？如果是的话，那么对用户体验非常不好。</p><p id="b43f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">已经比我想要的时间长了。关于这方面的更多信息，第2部分将会发布，敬请期待。</p><p id="90b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读和下面的任何反馈意见。</p><p id="5f97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更新:刚刚写了</em> <strong class="jm io"> <em class="ki">第二部</em> </strong> <em class="ki">看看</em> <a class="ae my" href="https://medium.com/javascript-in-plain-english/a-beginners-guide-to-javascript-under-the-hood-part-2-89d34a6a09e1" rel="noopener"> <strong class="jm io"> <em class="ki">这里</em> </strong> </a> <strong class="jm io"> <em class="ki">。</em> </strong></p></div></div>    
</body>
</html>