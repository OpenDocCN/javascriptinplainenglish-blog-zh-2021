<html>
<head>
<title>The Ultimate Guide To Writing Self-Documenting Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自文档化代码的终极指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-ultimate-guide-to-writing-self-documenting-code-998ea9a38bd3?source=collection_archive---------0-----------------------#2021-03-23">https://javascript.plainenglish.io/the-ultimate-guide-to-writing-self-documenting-code-998ea9a38bd3?source=collection_archive---------0-----------------------#2021-03-23</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="7aef" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">厌倦了在代码中写注释吗？我们停止这样做，而是编写自文档化的代码</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/3c8d79cc2f4a021cf74f268bcbbff20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ThArU-cdoeTHwIOg"/></div></div></figure><p id="30b1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">关于在代码中添加注释的讨论由来已久，一个人说你必须添加注释，另一个人说只是偶尔添加，但是一般来说，你应该在代码中添加注释，以使代码可读。</p><p id="e06d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我在这里告诉你那是错误的。</p><p id="f041" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">相反，您的代码应该是自文档化的。除非当然不应该。给你的代码添加注释是有正当理由的，但是这应该是<em class="lo">为什么</em>事情是这样做的，而不是<em class="lo">它正在做什么。</em></p><div class="lp lq gq gs lr ls"><a rel="noopener  ugc nofollow" target="_blank" href="/when-self-documenting-code-is-not-enough-a964da7e74e"><div class="lt ab fp"><div class="lu ab lv cl cj lw"><h2 class="bd is gz z fq lx fs ft ly fv fx iq bi translated">当自文档化代码还不够时</h2><div class="lz l"><h3 class="bd b gz z fq lx fs ft ly fv fx dk translated">自记录代码很好，但是什么时候不行呢？什么时候代码中有注释会让你受益？</h3></div><div class="ma l"><p class="bd b dl z fq lx fs ft ly fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="mb l"><div class="mc l md me mf mb mg kq ls"/></div></div></a></div><p id="dce6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但是让我们更深入地研究一下自文档化代码。</p><p id="bc9b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">先关？什么是自文档化代码？</strong></p><p id="5639" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">自文档化代码，顾名思义，是对自身进行文档化。这并不意味着您可以轻松地从中生成文档，而是使您的代码可读性更好，您不需要文档或注释。</p><h1 id="c766" class="mh mi ir bd mj mk ml mm mn mo mp mq mr jx ms jy mt ka mu kb mv kd mw ke mx my bi translated">命名功能</h1><p id="78cd" class="pw-post-body-paragraph ks kt ir ku b kv mz js kx ky na jv la lb nb ld le lf nc lh li lj nd ll lm ln ik bi translated">首先让我们看看函数名。你能通过看调用者告诉我这个函数是做什么的吗？</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="4189" class="nj mi ir nf b gz nk nl l nm nn">getUserId()</span></pre><p id="41aa" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可能回答了，<em class="lo">“嗯，它得到了用户ID”</em>。这在技术上是正确的(最好的正确方式？).但是它留下了下面的问题:“它从哪里得到ID？”</p><p id="827d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">那么什么会是更好的名字呢？嗯，那要看上下文，这就是为什么你需要一个更好的名字。</p><p id="dddd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果<code class="fe no np nq nf b">UserId</code>来自曲奇呢？那你的名字应该是<code class="fe no np nq nf b">getUserIdFromCookie()</code>。</p><p id="cffa" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果<code class="fe no np nq nf b">UserId</code>来自某种持久存储呢？那么这个名字应该是类似于<code class="fe no np nq nf b">getUserIdFromStorage()</code>的东西。</p><p id="51f3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果它返回的<code class="fe no np nq nf b">UserId</code>来自你发送给那个函数的属性呢？然后函数名应该描述你要发送给它什么，一些例子</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="b778" class="nj mi ir nf b gz nk nl l nm nn">getUserIdFromBlogpost(blogpostdata);<br/>getUserIdFromChat(chatObject);<br/>getUserIdFromFriend(friendObject);</span></pre><p id="3539" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">或者，如果您需要基于与该用户相关联的特定其他属性来获取<code class="fe no np nq nf b">UserId</code>该怎么办？</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="f01e" class="nj mi ir nf b gz nk nl l nm nn">getUserIdWithEmail(email);<br/>getUserIdWithIP(ip); // this is bad, but, you know, an example</span></pre><p id="b4c0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">正如你在第一个例子中看到的，我使用了<code class="fe no np nq nf b">from</code>，而在第二个例子中，我使用了<code class="fe no np nq nf b">with</code>。这种区别很重要，我们将在下一节(命名约定)中讨论。</p><p id="6da6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">一旦你清楚地定义了一个好的函数名，你总是能够立即知道你的代码做了什么。未来你会幸福的！</p><p id="086f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你的任何同事，无论是现在的还是未来的，都会感谢你确保你的命名惯例是正确的。</p><h1 id="1d95" class="mh mi ir bd mj mk ml mm mn mo mp mq mr jx ms jy mt ka mu kb mv kd mw ke mx my bi translated">命名变量</h1><p id="888f" class="pw-post-body-paragraph ks kt ir ku b kv mz js kx ky na jv la lb nb ld le lf nc lh li lj nd ll lm ln ik bi translated">命名变量和命名函数同样重要。我通常看到的最糟糕的罪犯之一是这样的:</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="d0bf" class="nj mi ir nf b gz nk nl l nm nn">var a = "John";<br/>var b = 65;<br/>var c = 20;</span></pre><p id="389f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从这些属性中，你可能会得出结论，这是关于一个人。<code class="fe no np nq nf b">a</code>明明是用户的名字。但是……什么是<code class="fe no np nq nf b">b</code>和<code class="fe no np nq nf b">c</code>？<code class="fe no np nq nf b">b</code>可能是用户的年龄吗？体重？朋友数量？他开车的次数？他去过的国家？然后<code class="fe no np nq nf b">c</code>又是什么鬼？</p><p id="d9d7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">也许您可以从更多的代码中提取出它可能是什么，但是这已经太远了。你不应该看到更多的代码来理解这一点。应该是这样的:</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="9d1b" class="nj mi ir nf b gz nk nl l nm nn">var userFirstName = "John"<br/>var userWeightInKG = 65;<br/>var userBMI = 20;</span></pre><p id="0422" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你猜对属性了吗？你希望身体质量指数成为这里的财产吗？你认为约翰会是65岁还是20岁？我很确定你猜错了，如果你没有我祝贺你，你猜对了，但你不知道会是什么，你只是运气好。</p><p id="919e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">运气不应该成为阅读代码的一个因素。</p><p id="6288" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">奇怪的是，由于变量命名的特殊性，你总能立即理解代码，而不必猜测。这也将防止变量碰撞。</p><p id="960a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这将防止这一点:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nr"><img src="../Images/1a1a67caa99fb254ee75fd95d65c2b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*9eCJB24Xj96LeIIuNI76NQ.png"/></div><figcaption class="ns nt gk gi gj nu nv bd b be z dk"><a class="ae nw" href="https://xkcd.com/1700/" rel="noopener ugc nofollow" target="_blank">XKCD 1700</a></figcaption></figure><div class="lp lq gq gs lr ls"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-prevent-unexpected-variable-mutation-in-javascript-2612b898732c"><div class="lt ab fp"><div class="lu ab lv cl cj lw"><h2 class="bd is gz z fq lx fs ft ly fv fx iq bi translated">如何防止JavaScript中意外的变量突变</h2><div class="lz l"><h3 class="bd b gz z fq lx fs ft ly fv fx dk translated">所以当你使用JavaScript时，你可以灵活地用任何东西覆盖任何变量。你怎么…</h3></div><div class="ma l"><p class="bd b dl z fq lx fs ft ly fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="mb l"><div class="nx l md me mf mb mg kq ls"/></div></div></a></div><h1 id="8a1d" class="mh mi ir bd mj mk ml mm mn mo mp mq mr jx ms jy mt ka mu kb mv kd mw ke mx my bi translated">命名规格</h1><p id="cbb7" class="pw-post-body-paragraph ks kt ir ku b kv mz js kx ky na jv la lb nb ld le lf nc lh li lj nd ll lm ln ik bi translated">遵循变量、函数和文件的命名惯例是很重要的。我在“命名函数”一节中提到过，我将<code class="fe no np nq nf b">from</code>和<code class="fe no np nq nf b">with</code>定义为命名方法，这也是您可以为自己的项目定义的。然后坚持下去！</p><p id="7616" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">那么什么是命名约定呢？</strong></p><p id="14cb" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">好吧，让我们从简单的开始。命名约定可以是，就像我前面定义的“<code class="fe no np nq nf b">from</code>”和“<code class="fe no np nq nf b">with</code>”。</p><ul class=""><li id="2c5f" class="ny nz ir ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated"><code class="fe no np nq nf b">from</code>在函数名定义中，你应该提供一个对象，函数可以从该对象返回函数的第一部分。</li></ul><p id="6d39" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">一些例子</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="e72e" class="nj mi ir nf b gz nk nl l nm nn">var userId = getUserIdFromBlog(blog)<br/>var url = getUrlFromBlog(blog)<br/>var numberOfWords = getNumberOfWordsFromBlog(blog)</span></pre><p id="f4b8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">正如你所看到的，函数名定义了你从它那里得到了什么，它定义了为了让你得到你想要的，它需要什么。我们在这里使用单词<code class="fe no np nq nf b">from</code>,这样我们就知道函数从提供的数据中获取信息<em class="lo">。</em></p><p id="6a89" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以userId可能是嵌入在blog对象中的某个地方，但是我们希望有一个建设性的、单一的点来提取它。如果我们以后进行重构，这会使代码更易于维护，并且增加了对相同数据的不同情况的支持。就像Twitter有转发一样，一条推文的userId是什么？原帖还是转发者？这取决于具体情况，可以在这些特定功能中进行配置。</p><ul class=""><li id="7cec" class="ny nz ir ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated"><code class="fe no np nq nf b">with</code>在函数名中，定义了函数将能够根据你给定的信息从另一个源获取数据。</li></ul><p id="baef" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">一些例子</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="6aa2" class="nj mi ir nf b gz nk nl l nm nn">var userId = getUserIdWithEmail(email)<br/>var blog = getBlogWithDateStamp(date)<br/>var user = getUserWithUserId(userId);</span></pre><p id="286b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">正如您所看到的，<code class="fe no np nq nf b">with</code>返回信息，但是我们得到的信息是在没有外部来源的情况下我们不可能知道的。这个外部来源可以是一个数据库，它可以进行API调用，它可以已经在内存中，谁知道呢，但你不必。</p><p id="05d6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">这如何帮助我提高代码可读性？</strong></p><p id="c44f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这很容易，如果你知道什么时候在你的函数命名中使用T2或T3，你的同事也知道，那么你就不需要在函数上加注释来解释它是如何工作的</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="203a" class="nj mi ir nf b gz nk nl l nm nn">// provide email address to get a userId back<br/>function getUserId(email) {</span><span id="cad7" class="nj mi ir nf b gz oh nl l nm nn">}</span></pre><p id="ccfb" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后在调用者代码中:</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="c980" class="nj mi ir nf b gz nk nl l nm nn">var user = getUserId();</span></pre><p id="7d8d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后你会想。</p><p id="d629" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><em class="lo">“我还需要提供什么？是电子邮件吗？是用户名吗？好的，让我检查一下这个功能，看看它需要什么。”</em></p><p id="27f6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">那么你刚才浪费了多少时间？1分钟？两分钟？一个同事会浪费多少时间去理解你两年前写的函数？</p><h1 id="4c8c" class="mh mi ir bd mj mk ml mm mn mo mp mq mr jx ms jy mt ka mu kb mv kd mw ke mx my bi translated">文件名的命名约定</h1><p id="fe78" class="pw-post-body-paragraph ks kt ir ku b kv mz js kx ky na jv la lb nb ld le lf nc lh li lj nd ll lm ln ik bi translated">对于文件名，完全相同的规则很重要。请确保您的文件结构，并确保您的文件名称正确。更重要的是，不要让你的文件变得太大，不要害怕在不同的组件之间分割。</p><p id="b1c0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">例如，我经常有一个<code class="fe no np nq nf b">user</code>目录，而不是一个用户文件。</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="8ad1" class="nj mi ir nf b gz nk nl l nm nn">/user<br/>  api.js<br/>  properties.js<br/>  friends.js<br/>  blogs.js</span></pre><p id="1552" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当涉及一对多的关系时，你会自然而然地看到我总是用复数，但当涉及一对一的关系时就不会了。<code class="fe no np nq nf b">user</code>只是一个，我希望我在那个目录中调用的任何东西都是关于一个用户的，但是有了<code class="fe no np nq nf b">user/friends</code>我希望能够与那个用户的多个朋友<em class="lo">互动。</em></p><p id="751f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">如果我需要处理多个用户怎么办？</strong></p><p id="e9bd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">嗯，新目录时间！</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="692a" class="nj mi ir nf b gz nk nl l nm nn">/users<br/>  leaderboard.js<br/>  search.js<br/>  statistics.js</span></pre><p id="8040" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">同样，<code class="fe no np nq nf b">leaderboard</code>是单数，因为关于<code class="fe no np nq nf b">users</code>只有一个排行榜，但关于统计数据是复数，因为我有不止一个关于用户的统计数据。</p><p id="fa78" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">重要的是，只要看一眼代码，你就能知道你期望从代码中得到什么。</p><p id="cc79" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在同一行中，您必须知道在查看目录结构时会发生什么。</p><p id="5d20" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果我的统计文件是一个很长的文件，该怎么办？</p><p id="19a0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">嗯，新目录时间！</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="a553" class="nj mi ir nf b gz nk nl l nm nn">/users<br/>  leaderboard.js<br/>  search.js<br/>  /statistics<br/>    count.js<br/>    friendrelations.js<br/>    usage.js</span></pre><p id="fd3c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">是的，添加更多的文件，添加更多的目录。</p><h1 id="8ec5" class="mh mi ir bd mj mk ml mm mn mo mp mq mr jx ms jy mt ka mu kb mv kd mw ke mx my bi translated">变量命名约定</h1><p id="e216" class="pw-post-body-paragraph ks kt ir ku b kv mz js kx ky na jv la lb nb ld le lf nc lh li lj nd ll lm ln ik bi translated">现在让我们看看变量和它们的命名约定。对于变量，使用非描述性的名字更容易，但是你仍然应该知道会发生什么。</p><p id="588e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">例如，让我们有变量名<code class="fe no np nq nf b">user</code>。这是什么？</p><p id="420a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">可能是</p><ul class=""><li id="85ee" class="ny nz ir ku b kv kw ky kz lb oa lf ob lj oc ln od oe of og bi translated">用户对象</li><li id="5a97" class="ny nz ir ku b kv oi ky oj lb ok lf ol lj om ln od oe of og bi translated">用户标识</li><li id="bdc5" class="ny nz ir ku b kv oi ky oj lb ok lf ol lj om ln od oe of og bi translated">用户电子邮件</li></ul><p id="7af0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当然应该是用户对象。将变量改为<code class="fe no np nq nf b">userObject</code>是处理它的一种方法，我强烈推荐这种方法。然而，这不是唯一的解决方案。</p><p id="7a18" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你也可以使用一般定义<code class="fe no np nq nf b">user</code>应该包含用户对象，无论何时在你的代码中使用变量名<code class="fe no np nq nf b">user</code>，你都应该能够对它做<code class="fe no np nq nf b">user.id</code>。</p><p id="815d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">不要在广泛的应用中混合使用一个变量，这样可以防止经典错误<code class="fe no np nq nf b">user is not an object</code>。</p><p id="a1c4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后，每当你处理与用户对象无关的事情时，使用正确的命名。所以<code class="fe no np nq nf b">userEmail</code>还是<code class="fe no np nq nf b">userId</code>。</p><h2 id="05bb" class="nj mi ir bd mj on oo dn mn op oq dp mr lb or os mt lf ot ou mv lj ov ow mx ox bi translated">布尔运算</h2><p id="9e3b" class="pw-post-body-paragraph ks kt ir ku b kv mz js kx ky na jv la lb nb ld le lf nc lh li lj nd ll lm ln ik bi translated">布尔也很经典，我可以直截了当地说，根据上下文明智地命名它们。</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="620c" class="nj mi ir nf b gz nk nl l nm nn">hasSessionId<br/>userIsLoggedIn<br/>userAllowedGPS<br/>passwordHasExpired</span></pre><p id="08b2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">明白了，就用短句。让他们描述他们是什么，这样你就可以做出完全有意义且可以作为一个句子来阅读的if语句。</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="e09b" class="nj mi ir nf b gz nk nl l nm nn">if (userIsLoggedIn &amp;&amp; userAllowedGPS)</span></pre><p id="27c9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">尤其是当您将这些类型的变量名与逻辑命名的函数结合在一起时</p><pre class="kh ki kj kk gu ne nf ng nh aw ni bi"><span id="4c60" class="nj mi ir nf b gz nk nl l nm nn">if (userIsLoggedIn &amp;&amp; userAllowedGPS) {<br/>   var currentCoordinates = getCurrentUserCoordinates();<br/>}</span></pre><p id="507c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">没有必要在这段代码上面添加注释来描述发生了什么，代码本身已经解释得很清楚了。而那个<strong class="ku is">就是</strong>自文档化代码是什么。</p><p id="70f8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当然这些都是简单的例子，但是要确保你为你的代码定义了你自己的规则，每个人都能理解，然后坚持下去。</p><h1 id="f6fd" class="mh mi ir bd mj mk ml mm mn mo mp mq mr jx ms jy mt ka mu kb mv kd mw ke mx my bi translated">代码是一个故事</h1><p id="6b9c" class="pw-post-body-paragraph ks kt ir ku b kv mz js kx ky na jv la lb nb ld le lf nc lh li lj nd ll lm ln ik bi translated">因此，一旦你理解了应该如何命名事物，应该遵循什么规则，以及如何避免添加注释，你的代码应该读起来像一个故事。</p><p id="f866" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果代码读起来像一个故事，并且你保持你的文件和函数紧凑，没有人会有阅读你的代码的困难。</p><p id="ea23" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你应该如何保持你的函数简短？你如何改进它们？我强烈推荐我之前写的一篇关于这个主题的文章。</p><div class="lp lq gq gs lr ls"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-improve-your-functions-in-javascript-fea32984122e"><div class="lt ab fp"><div class="lu ab lv cl cj lw"><h2 class="bd is gz z fq lx fs ft ly fv fx iq bi translated">提高JavaScript功能的5种方法</h2><div class="lz l"><h3 class="bd b gz z fq lx fs ft ly fv fx dk translated">通过将这些方法应用到您的函数中，让您的JavaScript生活变得更加简单</h3></div><div class="ma l"><p class="bd b dl z fq lx fs ft ly fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="mb l"><div class="oy l md me mf mb mg kq ls"/></div></div></a></div><p id="0c57" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但至少现在，你的代码应该是可读的，你可以停止注释你的代码，至少在大部分情况下。有些评论确实有道理，尤其是关于<em class="lo">为什么</em>事情是这样做的，而不是如何做的解释。</p><p id="89d2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在你知道了如何避免写评论，不要忘记在真正需要的时候添加评论！</p><div class="lp lq gq gs lr ls"><a rel="noopener  ugc nofollow" target="_blank" href="/when-self-documenting-code-is-not-enough-a964da7e74e"><div class="lt ab fp"><div class="lu ab lv cl cj lw"><h2 class="bd is gz z fq lx fs ft ly fv fx iq bi translated">当自文档化代码还不够时</h2><div class="lz l"><h3 class="bd b gz z fq lx fs ft ly fv fx dk translated">自记录代码很好，但是什么时候不行呢？什么时候代码中有注释会让你受益？</h3></div><div class="ma l"><p class="bd b dl z fq lx fs ft ly fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="mb l"><div class="mc l md me mf mb mg kq ls"/></div></div></a></div><h2 id="e14c" class="nj mi ir bd mj on oo dn mn op oq dp mr lb or os mt lf ot ou mv lj ov ow mx ox bi translated">进一步阅读</h2><div class="lp lq gq gs lr ls"><a rel="noopener  ugc nofollow" target="_blank" href="/5-dev-tools-for-documenting-react-code-like-a-pro-b9bb70420a9d"><div class="lt ab fp"><div class="lu ab lv cl cj lw"><h2 class="bd is gz z fq lx fs ft ly fv fx iq bi translated">像专家一样记录React代码的5个开发工具</h2><div class="lz l"><h3 class="bd b gz z fq lx fs ft ly fv fx dk translated">游泳，合流，咕噜，组队堆栈溢出，平板。这些是你应该在2023年尝试的顶级React doc工具</h3></div><div class="ma l"><p class="bd b dl z fq lx fs ft ly fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="mb l"><div class="oz l md me mf mb mg kq ls"/></div></div></a></div><p id="4ba9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><em class="lo">更内容于</em> <a class="ae nw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku is"> <em class="lo">普通英语</em> </strong> </a> <em class="lo">。报名参加我们的</em> <a class="ae nw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku is"> <em class="lo">免费周报</em> </strong> </a> <em class="lo">。</em> <a class="ae nw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ku is"> <em class="lo">推特</em></strong></a><a class="ae nw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ku is"><em class="lo">LinkedIn</em></strong></a><em class="lo"/><a class="ae nw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ku is"><em class="lo">YouTube</em></strong></a><em class="lo">以及</em><a class="ae nw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ku is">T42不和</strong></a><strong class="ku is"><em class="lo">。</em> </strong></p><p id="90e3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is"> <em class="lo">对扩展你的软件启动感兴趣</em> </strong> <em class="lo">？查看</em> <a class="ae nw" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="ku is"> <em class="lo">电路</em> </strong> </a> <em class="lo">。</em></p></div></div>    
</body>
</html>