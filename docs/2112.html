<html>
<head>
<title>5 Simple Rules to Master ‘this’ in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中掌握“这个”的5个简单规则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-simple-rules-to-master-this-in-javascript-2b5d8df31fc4?source=collection_archive---------4-----------------------#2021-05-04">https://javascript.plainenglish.io/5-simple-rules-to-master-this-in-javascript-2b5d8df31fc4?source=collection_archive---------4-----------------------#2021-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f363" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">您需要阅读的唯一一篇文章就是了解JavaScript中的“<strong class="jq ir"/>”关键词。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ad4454575e80e258a033ec950c91a6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QX3OwFWRti8A5U93e37-AQ.png"/></div></div></figure><p id="9462" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在本文中，我们涵盖了JavaScript中至关重要但又令人困惑的话题，即“<strong class="jq ir"> <em class="ky">这个</em> </strong>关键词。</p><h2 id="6eb3" class="kz la iq bd lb lc ld dn le lf lg dp lh jz li lj lk kd ll lm ln kh lo lp lq lr bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="05f7" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">如果<em class="ky">这个</em>吓到你了，不要担心！我们将学习如何使用五个简单的规则来确定“<em class="ky">”这个</em>”关键词的值。</p><p id="3d3f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这五个简单的规则如下:</p><ul class=""><li id="bae0" class="lx ly iq jq b jr js jv jw jz lz kd ma kh mb kl mc md me mf bi translated"><em class="ky">常规绑定— </em> <strong class="jq ir">默认绑定</strong></li><li id="8878" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated"><em class="ky">物体内部的功能</em> — <strong class="jq ir">隐含结合</strong></li><li id="c987" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated"><em class="ky">功能借用</em> — <strong class="jq ir">显式绑定</strong></li><li id="ecbd" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated"><em class="ky">使用函数创建对象</em> — <strong class="jq ir">新绑定</strong></li><li id="ad66" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated"><em class="ky">Arrow函数与常规函数有何区别— </em> <strong class="jq ir">词汇绑定</strong></li></ul><p id="e53d" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">不用担心这些可怕的名字。计算机科学的人喜欢给术语命名，这样它们听起来就像外星人。在幕后，它们只是普通的概念，任何有意愿的人都能理解。</p><p id="6266" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><em class="ky">这个“</em>变量对应于你如何调用一个函数。这些规则帮助我们在各种场景下确定<em class="ky">这个</em>的值。</p><p id="193c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">一旦你理解了这些规则，你就不会再害怕它们了。</p><p id="19eb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在我们开始之前，<a class="ae ml" rel="noopener ugc nofollow" target="_blank" href="/why-do-developers-fear-this-fb7497f95570?sk=7c1a7d83bd97af7ce9a9cd97fc8abda2">请通读本文</a>以了解<em class="ky">这个</em>是如何工作的。</p><h1 id="3bde" class="mm la iq bd lb mn mo mp le mq mr ms lh mt mu mv lk mw mx my ln mz na nb lq nc bi translated">简而言之，什么是“这个”</h1><p id="febf" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">在JavaScript中，每当调用一个函数时，JavaScript引擎就会创建一个新的执行上下文。该执行上下文一直存在，直到函数完成执行。每个执行上下文都包含一个名为“this”的变量。</p><h1 id="f67d" class="mm la iq bd lb mn mo mp le mq mr ms lh mt mu mv lk mw mx my ln mz na nb lq nc bi translated">#规则1。默认绑定</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nd"><img src="../Images/67d7ae2e83bf48bec3099cd8b2aafc77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xc7asnogg5WscyrC.png"/></div></div></figure><p id="70b3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当以上面所示的标准方式调用一个函数时，“<em class="ky">这个</em>实际上会引用全局对象！</p><p id="755a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在浏览器中，全局对象是指窗口对象。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ne"><img src="../Images/967dd98551a1b97b1c1ed64cfc94dbf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BkSOWChHCrsTt2V5.png"/></div></div></figure><p id="d837" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">需要记住的一个例外是，当启用严格模式时。通过编写“use-strict”，您可以防止在全局对象上声明任何内容。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/4a092e531cd703ed89d4857ce627c85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MDVIyQlMzbnDv4Kf.jpeg"/></div></div></figure><h1 id="48ec" class="mm la iq bd lb mn mo mp le mq mr ms lh mt mu mv lk mw mx my ln mz na nb lq nc bi translated">#规则2。<strong class="ak">隐性约束</strong></h1><p id="a820" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">如果函数包含在一个对象中，那么该对象将被“this”引用。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ng"><img src="../Images/2deb0a89c940a2b1b472dd5f8874e81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKrRTgSIiLQ5dJRIyTk-Qg.png"/></div></div></figure><p id="64f8" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">对于上面的内容，<code class="fe nh ni nj nk b">this</code>关键字将指向<code class="fe nh ni nj nk b">personObj</code></p><h1 id="c3d4" class="mm la iq bd lb mn mo mp le mq mr ms lh mt mu mv lk mw mx my ln mz na nb lq nc bi translated">#规则3。<strong class="ak">显式结合</strong></h1><p id="ce32" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">我们看到了<code class="fe nh ni nj nk b">this</code>如何指向全局对象，在另一种情况下，它指向包含它的对象。当函数被调用时，能够控制这个变量的最终状态不是很好吗？</p><p id="a758" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">像<em class="ky">调用</em>、<em class="ky">应用</em>、<em class="ky">绑定</em>这样的词通常会让新开发者感到恐惧。实际上都是可以用来<em class="ky">显式</em>设置“this”的值的函数。</p><h2 id="99df" class="kz la iq bd lb lc ld dn le lf lg dp lh jz li lj lk kd ll lm ln kh lo lp lq lr bi translated">让我们用一个例子来理解一下。</h2><p id="d3f7" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">假设我们有两个对象，比如说<code class="fe nh ni nj nk b">personObj</code>和<code class="fe nh ni nj nk b">readerObj</code></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nl"><img src="../Images/abe5f537b63388a7da49d80d228d6db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1FOex7gNulGnwVEb6Mf6w.png"/></div></div></figure><p id="40af" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这两个对象都有一个名称属性。<code class="fe nh ni nj nk b">personObj</code>有打印<code class="fe nh ni nj nk b">name</code>内部数值的功能，但是<code class="fe nh ni nj nk b">readerObj</code>没有这个功能！</p><p id="76c7" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这里我们可以使用三种方法之一— <code class="fe nh ni nj nk b">call</code>、<code class="fe nh ni nj nk b">apply</code>或<code class="fe nh ni nj nk b">bind</code>。</p><p id="9648" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这个过程叫做函数借用。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nm"><img src="../Images/c6c188c485c6322e1767ae700f5ac7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Di_MsxdvDTqd0DkEBr3YfQ.png"/></div></div></figure><p id="f548" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们为<code class="fe nh ni nj nk b">readerObj.</code>借用了<code class="fe nh ni nj nk b">sayName</code>方法</p><p id="d646" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在我们可以打印出<code class="fe nh ni nj nk b">readerObj</code>中的name属性</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nn"><img src="../Images/eba64afad1b2fd37a71fb4defe766fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmRaS-zUJgG_QkrCS-FUIQ.png"/></div></div></figure><p id="eddf" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们从<code class="fe nh ni nj nk b">personObj</code>调用<code class="fe nh ni nj nk b">sayName</code>方法，但同时，我们指示JavaScript引擎<code class="fe nh ni nj nk b">sayName</code>方法中的‘this’变量应该指向<code class="fe nh ni nj nk b">readerObj</code>。</p><p id="7d6b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">所以当JavaScript引擎执行代码时，<code class="fe nh ni nj nk b">sayName</code>函数中的<strong class="jq ir"> <em class="ky">这个</em> </strong>变量不是指向<code class="fe nh ni nj nk b">personObj</code>而是指向<code class="fe nh ni nj nk b">readerObj</code>。</p><p id="4654" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这有意义吗？</p><p id="5d98" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">不仅如此，当我们使用<code class="fe nh ni nj nk b">call</code>函数时，我们还可以传递一些参数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi no"><img src="../Images/0f528494f10928634aa4893b1afcd378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQtSBG6fv5pp_L_lfpNKmg.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">We passed Namaste as an argument</figcaption></figure><p id="1fa9" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们可以利用<code class="fe nh ni nj nk b">sayName</code>方法中的参数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/f2dbf902b0439769e76f1504dfb5c6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*URmM8Vf09inNezYtA2TvMA.png"/></div></figure><p id="f88a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当我们执行代码时，我们将获得输出以及传递的参数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nu"><img src="../Images/9781162c970de86791174079000c432d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RcaHst9aMECBaFntGO_9nA.png"/></div></div></figure><p id="1aba" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">apply方法以同样的方式工作，但是它不是使用常规参数，而是使用一个数组作为参数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nv"><img src="../Images/0315c7bfc1b7b441cbbb45508fa38db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olLUIkdy373Jhrw3-i3mwg.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/c38330c653c1378af1bd66eda0d9456a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2IhX_eA_J2F-29dnExflQ.png"/></div></div></figure><p id="50de" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">bind方法也以同样的方式工作—它可以接受一个常规参数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nx"><img src="../Images/114bf5286ad83f78125b07f2f5e5f132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvootgY_bLF7xy7k_mKcGg.png"/></div></div></figure><p id="a454" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">但是不像<em class="ky">调用</em> <strong class="jq ir"> <em class="ky"> </em> </strong>和<em class="ky">应用——</em><strong class="jq ir"><em class="ky">绑定</em> </strong>返回一个函数——那个函数可以存储在一个变量中，以后可以执行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ny"><img src="../Images/39b24ff41b956062b1db5e4098a16851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7USlXrakqraX9w7ntLtwA.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nz"><img src="../Images/eecf522112b667c13f0872acb8c9a5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kvl7us01wuPUlEpn-KJ3g.png"/></div></div></figure><p id="3a2f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们可以看到bind在函数currying中的使用——这是我们将在以后讨论的主题。</p><h1 id="5909" class="mm la iq bd lb mn mo mp le mq mr ms lh mt mu mv lk mw mx my ln mz na nb lq nc bi translated">#规则<strong class="ak"> 4。新绑定</strong></h1><p id="fcd7" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">我们使用<strong class="jq ir"> <em class="ky"> new </em> </strong>关键字来创建一个对象的实例或副本。<strong class="jq ir">新</strong>关键字的作用是:</p><ul class=""><li id="aded" class="lx ly iq jq b jr js jv jw jz lz kd ma kh mb kl mc md me mf bi translated">它创建一个<strong class="jq ir">空对象</strong>，然后指示关键字<strong class="jq ir"> this </strong>指向那个空对象。</li><li id="7dca" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated">然后，它将一个<code class="fe nh ni nj nk b">return this</code>语句添加到该函数的末尾。</li></ul><p id="e06d" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">记住，当使用<em class="ky"> new </em>关键字创建一个对象的实例时，“<strong class="jq ir"> <em class="ky"> this </em> </strong>”总是指向那个新创建的实例。</p><h2 id="c89d" class="kz la iq bd lb lc ld dn le lf lg dp lh jz li lj lk kd ll lm ln kh lo lp lq lr bi translated">让我们用一个例子来理解这一点。</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oa"><img src="../Images/ccefabdfb67482dd39e94cb93d0bb268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdIo3Y77Y054oibfUKFLXg.png"/></div></div></figure><p id="0a62" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当我们运行这段代码时，我们应该得到什么？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ob"><img src="../Images/ed9f13a30b95cb76f2f4fb921a9dd597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0ealF7SmoQwwUbFX3CsGA.png"/></div></div></figure><p id="f318" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">正如我们所说——一个空的物体！</p><p id="e2db" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">引擎盖下发生的事情是</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oc"><img src="../Images/2127e0b3fbcebd8a8f132fbb7b913ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjlTUBtzshIO2lToU4b_zQ.png"/></div></div></figure><p id="7faf" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">什么？我们要调用这个函数吗？</p><p id="c4cf" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">是啊！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi od"><img src="../Images/c3fe9aa5c8d8cf4d00c393dc4435b1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7jkc1tuK7hNbx25EVcxvLQ.gif"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">See, I told you it is getting invoked.</figcaption></figure><p id="22a6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">让我们看看整个事情。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oc"><img src="../Images/8202fb0a4ac2dbe9579ebc9c1f9a2736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dw9PlvHl5SXw94wwiFZFTg.png"/></div></div></figure><p id="7642" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果我们在函数中放入一些值，它会把这些值放入新创建的对象中，然后返回！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oe"><img src="../Images/714f492ba910368355ea52641b6f3cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByTa5ihFcU6xzningnM3eg.png"/></div></div></figure><p id="de81" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当我们<code class="fe nh ni nj nk b">console.log(newPersonObj)</code></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi of"><img src="../Images/d529cbf2f7a5285d279d7300a758ccdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeOXSqQdt8Zi8qJmpbQFRg.png"/></div></div></figure><p id="ea5a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">让我们用一个动画来完成这个概念。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/4b8592ecc0a3ea4d6efd10301895e16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0wJYjMQ9uwVEYzBj89oL4A.gif"/></div></div></figure><p id="7792" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在上面的例子中，我们使用一个函数来创建一个对象。</p><p id="b2ba" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这种类型的函数被称为函数构造函数。</p><p id="ac84" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">记住，在<code class="fe nh ni nj nk b">newPersonObj</code>中，存储了<code class="fe nh ni nj nk b">personObj</code>的副本——“this”变量指向空的<code class="fe nh ni nj nk b">personObj</code></p><p id="84de" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在有意义吗？</p><p id="fee6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">很好！现在让我们理解最后一条规则。</p><h1 id="8f9e" class="mm la iq bd lb mn mo mp le mq mr ms lh mt mu mv lk mw mx my ln mz na nb lq nc bi translated">#规则<strong class="ak"> 5。词汇绑定</strong></h1><p id="a300" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">随着ES6的出现，我们有了箭头功能。具有超精简语法的Arrow函数是传统匿名函数的自然替代品。</p><p id="85ea" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">要显式调用箭头函数，就像使用常规匿名函数一样，首先要将它赋给一个变量:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi og"><img src="../Images/07bd61aa159835cd469d4e18bb213a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MEaHjDB5yTXm_T6tDO_HwA.png"/></div></div></figure><p id="271a" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">箭头函数就像普通的匿名函数一样，只有一个主要的例外——函数内部对象的行为。</p><p id="33f0" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在常规函数中，“<code class="fe nh ni nj nk b">this</code>”的值是基于上下文的——调用链接内部的函数，“<code class="fe nh ni nj nk b">this</code>”指向链接的对象；在一个类似<code class="fe nh ni nj nk b">setInterval()</code>的函数中调用它，然后“<code class="fe nh ni nj nk b">this</code>指向全局窗口对象。</p><p id="e172" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">例如，下面的示例尝试调用自定义对象的<code class="fe nh ni nj nk b">start()</code>方法，每秒钟将其counter属性递增1，尽管由于“<code class="fe nh ni nj nk b">this</code>”对象引用计数器的错误假设而失败。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oh"><img src="../Images/f0e7676a16d13954d69ff588477cc019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hoYm0GaVU-9eIG431Vs1wg.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oi"><img src="../Images/1994ecb20cde9369ccb064a974b60600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JJvXhLyOOGZfSstSj2sS4A.gif"/></div></div></figure><p id="d61e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在上面的例子中，<code class="fe nh ni nj nk b">this.counter</code>未能正确引用<code class="fe nh ni nj nk b">countup</code>对象的counter属性，尽管这个错误可能不那么明显。人们可能会错误地或粗心地认为“<code class="fe nh ni nj nk b">this</code>指向了<code class="fe nh ni nj nk b">countup</code>对象，而实际上由于上下文“<code class="fe nh ni nj nk b">this</code>”在全局窗口方法<code class="fe nh ni nj nk b">setInterval()</code>内被调用，它指向了全局<code class="fe nh ni nj nk b">window</code>对象。</p><p id="0ddc" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">结果是对一个不存在的<code class="fe nh ni nj nk b">window.counter</code>属性的引用，当我们试图增加它时，这个属性将重复返回<code class="fe nh ni nj nk b">NaN</code>。为了正确地引用匿名函数中的<code class="fe nh ni nj nk b">countup</code>对象，我们应该在上下文变为不同的对象之前缓存对正确的“<code class="fe nh ni nj nk b">this</code>”对象的引用:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/fb5f0f09d0c0743d55285c4ae83cb20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ecuxy27FcjFnlfPRKVZLg.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ok"><img src="../Images/6d9426707b867304f38d740585981bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Qd4QDX0XnfXBcnkjdQUVgw.gif"/></div></div></figure><p id="bfd6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">arrow函数中的“<code class="fe nh ni nj nk b">this</code>”对象是词汇绑定的，这只是一种奇特的说法，即它的值是静态的，由定义“<code class="fe nh ni nj nk b">this</code>”关键字的位置决定。</p><p id="f5a9" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">相比之下，常规函数中的“<code class="fe nh ni nj nk b">this</code>”是动态的，基于上下文调用，而不考虑定义“<code class="fe nh ni nj nk b">this</code>”时的作用域。</p><p id="070e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">让我们以之前给我们带来麻烦的例子为例，看看改用箭头函数如何直观地解决问题:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ol"><img src="../Images/471a74783f1285578eeb4989baa51f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rxgs1sNx3TXP7cvNe-PsoA.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ok"><img src="../Images/6d9426707b867304f38d740585981bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Qd4QDX0XnfXBcnkjdQUVgw.gif"/></div></div></figure><p id="d20b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们通过使用一个箭头函数解决了这个问题。</p><h1 id="876d" class="mm la iq bd lb mn mo mp le mq mr ms lh mt mu mv lk mw mx my ln mz na nb lq nc bi translated">结论</h1><p id="d537" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">如果你理解了所有的规则，那就拍拍自己的背——这是你应得的！现在，您不再害怕JavaScript最令人困惑的概念——“<em class="ky">this</em>”关键字。</p><p id="7f6f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在本文中，我们了解到:</p><ul class=""><li id="5c93" class="lx ly iq jq b jr js jv jw jz lz kd ma kh mb kl mc md me mf bi translated">当以上面所示的标准方式调用一个<strong class="jq ir"> <em class="ky">函数</em> </strong>时，<em class="ky">这个</em>实际上会引用全局对象！</li><li id="0ac8" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated">如果函数包含在一个<strong class="jq ir"><em class="ky"/></strong>对象中，那么<strong class="jq ir"> <em class="ky">这个</em> </strong>将指向那个对象。</li><li id="2f65" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated"><strong class="jq ir"> <em class="ky">调用</em> </strong>、<strong class="jq ir"> <em class="ky">应用</em> </strong>和<strong class="jq ir"> <em class="ky">绑定</em> </strong>是我们可以通过JavaScript来改变程序中<strong class="jq ir"> <em class="ky">这个</em> </strong>的行为的函数。</li><li id="2e6a" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated"><strong class="jq ir"> <em class="ky"> new </em> </strong>关键字或运算符在使用时会使一个空对象，然后指示<strong class="jq ir"><em class="ky">this</em></strong>指向那个新创建的对象</li><li id="99f8" class="lx ly iq jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated">Arrow函数使我们能够在程序中对“<strong class="jq ir"> <em class="ky">这个</em> </strong>”关键字进行词汇绑定，这意味着它的值是静态的，由定义“<code class="fe nh ni nj nk b">this</code>”关键字的地方决定。</li></ul><h1 id="e1d3" class="mm la iq bd lb mn mo mp le mq mr ms lh mt mu mv lk mw mx my ln mz na nb lq nc bi translated">感谢信</h1><p id="809d" class="pw-post-body-paragraph jo jp iq jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl ij bi translated">我想利用这最后的机会说声谢谢。</p><p id="ef34" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">感谢您的光临！没有像你这样的人，我不可能做我现在做的事情。</p><p id="3b26" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我希望你能<a class="ae ml" href="https://twitter.com/tweetsbysoma" rel="noopener ugc nofollow" target="_blank"> <strong class="jq ir">和我一起</strong> </a>发表<a class="ae ml" href="https://polymathsomnath.medium.com/" rel="noopener"> <strong class="jq ir">我未来的博文</strong> </a>并留下来，因为我认为我们这里有一些很棒的东西。我希望在未来的许多年里，我能在你的职业生涯中帮助你！</p><p id="8228" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">下次见。再见！</p><p id="4502" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><a class="ae ml" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>