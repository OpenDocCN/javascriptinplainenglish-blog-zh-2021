<html>
<head>
<title>Data Structures: Binary Search Trees (BST)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构:二分搜索法树(BST)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-structures-binary-search-trees-870395f8a74b?source=collection_archive---------14-----------------------#2021-01-09">https://javascript.plainenglish.io/data-structures-binary-search-trees-870395f8a74b?source=collection_archive---------14-----------------------#2021-01-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8ae2d310d7115e8b051c8daa0424dd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwrTjqM1mjT17Z7TAdjQ0w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jeremybishop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jeremy Bishop</a> on <a class="ae jz" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f317" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数据结构是算法的基石。为了编写和运行高效的代码，您必须对数据结构有深刻的理解。一旦您很好地掌握了不同的数据结构以及它们是如何工作的，您就可以开始识别特定数据结构的优缺点，然后就何时何地应该实现它们做出明智的决定。</p><p id="7730" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二叉查找树(通常简称为BST)是一种允许以有序方式高效存储整数的数据结构。二分搜索法树由一个<strong class="kc io">根</strong>节点(树中的第一个节点)和它的任何子节点组成。这些子节点被命名为<strong class="kc io">左节点</strong>和<strong class="kc io">右节点</strong>。二分搜索法树如此命名是因为每个节点最多可以有两个子节点。没有任何子节点的节点被称为<strong class="kc io">叶</strong>，两个不同节点之间的连接被称为<strong class="kc io">边</strong>。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/7ef9d25237e970153c06068d7f511bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtlP4Ulsj9NKVNOWv9p1Gw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Src: <a class="ae jz" href="https://www.educative.io/edpresso/what-is-a-binary-search-tree" rel="noopener ugc nofollow" target="_blank">Educative.io</a></figcaption></figure><p id="0d16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了说明术语，我们来看看上面的<a class="ae jz" href="https://www.educative.io/edpresso/what-is-a-binary-search-tree" rel="noopener ugc nofollow" target="_blank"> Educative.io </a>图。在图中，包含值6的圆圈代表我们的根节点。然后根节点分支成两个独立的节点，包含值3的圆(左侧节点)和包含值9的圆(右侧节点)。这两个节点是根节点的子节点。根节点的每个子节点都有自己的子节点——由分支到另外两个节点来表示。图表最底部的这些节点(包含值1、5、7、11的圆圈)是叶节点。</p><p id="092e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使二叉查找树区别于普通二叉树的是所谓的<strong class="kc io"> BST属性</strong>。为了被认为是二叉查找树，树必须满足以下条件:</p><ul class=""><li id="cb56" class="ld le in kc b kd ke kh ki kl lf kp lg kt lh kx li lj lk ll bi translated">左子树的所有节点的值都小于根</li><li id="cfdc" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated">右侧子树的所有节点的值都大于根节点的值</li></ul><p id="0ed4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在每个节点上，其左侧子节点将小于父节点，而其右侧子节点将大于父节点。因此在整个树中，每个节点本身就是一个二叉查找树。</p><p id="ea4b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看下面的图，你能解释为什么右边的树不是BST吗？</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/2b8f786656cecce1cd21fe6d2ab91820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nLjmfaHgaPibzdrNWPBdg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Src: <a class="ae jz" href="https://www.programiz.com/dsa/binary-search-tree" rel="noopener ugc nofollow" target="_blank">Programiz</a></figcaption></figure><p id="55f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">右边的树不是BST，因为如果我们看一下左边的子树(即由值为3的节点及其后代节点组成的树)，它不满足BST属性。该子树包含右侧的一个节点(值为2的节点),该节点的值小于该子树最顶层的节点。如果它是一个BST，值为2的节点必须是值为1的节点的右边子节点。</p><h2 id="fd43" class="lt lu in bd lv lw lx dn ly lz ma dp mb kl mc md me kp mf mg mh kt mi mj mk ml bi translated"><strong class="ak">BST的用例</strong></h2><p id="d0e8" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">现在我们对二叉查找树的结构有了基本的了解，让我们来讨论一下BST的优点。这种有序的结构使其成为搜索特定元素/值的有效方法。给定一个值，我们可以快速确定BST是否包含该值，如果包含，它在树中的位置。</p><p id="0157" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从根节点开始，我们首先检查它是否包含我们要寻找的值。如果不是，我们就问自己，我们要寻找的值是小于还是大于根节点。如果它更小，我们知道如果它在树中，它一定是左子树的一部分。相反，如果它更大，我们知道它一定是右边子树的一部分。在每一个节点，我们都经历相同的过程，直到我们得到我们想要的值。因此，在这个过程的每一步，我们可以消除大约一半的剩余数据结构，直到我们得到一个答案。</p><p id="b06e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一般情况下，二叉查找树结构允许我们以O(log(n))的时间和空间复杂度执行搜索功能。如果我们将相同的概念应用于插入函数，我们可以确定二叉查找树中的插入函数也涉及O(log(n))时间和空间复杂度。</p><p id="ec61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在对二叉查找树及其力量有了一个可行的理解。在下一篇博文中，我将讲述如何用代码实现二叉查找树。敬请期待！</p></div></div>    
</body>
</html>