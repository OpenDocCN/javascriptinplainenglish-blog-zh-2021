<html>
<head>
<title>React Hook: UseCallback</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩:使用回调</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hook-usecallback-82efba1ab4a9?source=collection_archive---------9-----------------------#2021-05-17">https://javascript.plainenglish.io/react-hook-usecallback-82efba1ab4a9?source=collection_archive---------9-----------------------#2021-05-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="95a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你还不熟悉useState和useEffect挂钩，我强烈推荐你去看看。它们是最常用的钩子，本质上是React now管理(过去被认为是“无状态的”)功能组件中的状态的方式。</p><p id="8821" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最近的一次采访中，我被要求将我的一个类组件重构为一个功能组件。当我开始构建功能组件，用useState挂钩设置状态，并将componentDidMount改为useEffect挂钩时，我遇到了一个新问题。如何防止我的useEffect过度重渲染？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b75de964646c4033450f7284d98fc981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4vpCQT5-SSNPGnLKZLFYg.png"/></div></div></figure><p id="ccf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据useCallback挂钩的<a class="ae ku" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> React文档，挂钩本身:</a></p><p id="4673" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kv">"返回一个</em><a class="ae ku" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank"><em class="kv"/></a><em class="kv">回调。</em></p><p id="0238" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kv">传递一个内联回调和一个依赖数组。</em> <code class="fe kw kx ky kz b"><em class="kv">useCallback</em></code> <em class="kv">将返回回调的记忆版本，仅当其中一个依赖关系发生变化时才会发生变化。这在向依赖引用相等的优化子组件传递回调以防止不必要的渲染时很有用(例如</em> <code class="fe kw kx ky kz b"><em class="kv">shouldComponentUpdate</em></code> <em class="kv">)。”</em></p><pre class="kj kk kl km gt la kz lb lc aw ld bi"><span id="63ad" class="le lf in kz b gy lg lh l li lj">const memoizedCallback = useCallback(<br/>  () =&gt; {<br/>    doSomething(a, b);<br/>  },<br/>  [a, b],<br/>);</span></pre><p id="d43f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以本质上，这为我们提供了一种防止不必要的重新渲染的方法。</p><p id="c6d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的例子中，我正在重写一个组件，该组件获取歌曲数据并将其分配给该组件的状态。</p><p id="0b01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的初始类组件在挂载时获取一个数据列表，并将歌曲列表设置为“歌曲”的组件状态。这看起来像:</p><pre class="kj kk kl km gt la kz lb lc aw ld bi"><span id="099e" class="le lf in kz b gy lg lh l li lj">export default class MySongs extends Component {</span><span id="0d39" class="le lf in kz b gy lk lh l li lj">  state = {<br/>       songs: []<br/>  }</span><span id="c6dc" class="le lf in kz b gy lk lh l li lj">     componentDidMount() {<br/>        fetch(songsURL)<br/>          .then((<em class="kv">response</em>) <em class="kv">=&gt;</em> <em class="kv">response</em>.json())<br/>          .then((<em class="kv">songs</em>) <em class="kv">=&gt;</em> this.setState({ songs: <em class="kv">songs</em> }));</span><span id="72bc" class="le lf in kz b gy lk lh l li lj">     }</span><span id="3031" class="le lf in kz b gy lk lh l li lj">  render(){<br/>     return(...)<br/>  }<br/>}</span></pre><p id="dc92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，作为一个功能组件，我们将使用useEffect钩子来模仿上面的componentDidMount()函数，然而，React docs声明<em class="kv">"传递给</em> <code class="fe kw kx ky kz b"><em class="kv">useEffect</em></code> <em class="kv">的函数将在渲染提交到屏幕后运行。将效果视为从React的纯功能世界进入命令世界的出口。默认情况下，效果会在每次完成渲染后运行，但您可以选择仅在某些值</em>  <em class="kv">发生变化时启动它们</em> <a class="ae ku" href="https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect" rel="noopener ugc nofollow" target="_blank"> <em class="kv">。”</em></a></p><p id="aa97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一句引用了依赖数组，它可以作为第二个参数传递给useEffect钩子。当依赖数组中的值发生变化时，将再次调用useEffect。</p><p id="3661" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kv">那么让我给你展示一下我从哪里开始，以及</em> </strong> <a class="ae ku" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kv">使用回调</em> </strong> </a> <strong class="jm io"> <em class="kv">来解决问题的地方。</em>T13】</strong></p><p id="a2df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我开始将它改写成一个功能组件时，我想到了这里:</p><pre class="kj kk kl km gt la kz lb lc aw ld bi"><span id="ce04" class="le lf in kz b gy lg lh l li lj">export default <em class="kv">function</em> MySongs() {<br/>   <em class="kv">const</em> [songs, setSongs] = useState([]);</span><span id="e664" class="le lf in kz b gy lk lh l li lj"><em class="kv">   const</em> fetchSongs = () <em class="kv">=&gt;</em> {<br/>      fetch(songsURL)<br/>        .then((<em class="kv">response</em>) <em class="kv">=&gt;</em> <em class="kv">response</em>.json())<br/>        .then((<em class="kv">songs</em>) <em class="kv">=&gt;</em> setSongs(<em class="kv">songs</em>));<br/>    }</span><span id="b22c" class="le lf in kz b gy lk lh l li lj">   useEffect(() =&gt; {<br/>      fetchSongs()<br/>   }, [])</span><span id="7172" class="le lf in kz b gy lk lh l li lj">...</span></pre><p id="2a30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在这里看到的，在我的useEffect钩子中，我包含了一个空的依赖数组来避免无数次的重渲染。虽然这确实可以防止重新渲染，但React会抛出错误:</p><p id="9eb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kv">“React Hook use effect缺少依赖项:“fetchSongs”。要么包含它，要么删除依赖数组react-hooks/exhaustive-deps”。</em></p><p id="e3bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着fetchSongs是我们的useEffect钩子中的一个必需的依赖项，但是如果你把它包含在依赖数组中，我们就会陷入一个重复的重新渲染循环。</p><p id="6385" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">修复出奇的简单:<strong class="jm io">在我们的fetchSongs函数上使用Callback！</strong></p><p id="bc1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，您将看到与上面基本相同的代码，但是现在在我们的useEffect中利用了所需的依赖关系，并且在我们的fetchSongs函数上实现了useCallback钩子以防止重新呈现。</p><pre class="kj kk kl km gt la kz lb lc aw ld bi"><span id="ba93" class="le lf in kz b gy lg lh l li lj">export default <em class="kv">function</em> MySongs() {<br/>   <em class="kv">const</em> [songs, setSongs] = useState([]);</span><span id="182f" class="le lf in kz b gy lk lh l li lj"><em class="kv">   const</em> fetchSongs = <strong class="kz io">useCallback(()</strong> <em class="kv">=&gt;</em> {<br/>      fetch(songsURL)<br/>        .then((<em class="kv">response</em>) <em class="kv">=&gt;</em> <em class="kv">response</em>.json())<br/>        .then((<em class="kv">songs</em>) <em class="kv">=&gt;</em> setSongs(<em class="kv">songs</em>));<br/>    }, [setSongs])</span><span id="8e05" class="le lf in kz b gy lk lh l li lj">useEffect(() =&gt; {<br/>      fetchSongs()<br/>   }, [fetchSongs])</span><span id="71f7" class="le lf in kz b gy lk lh l li lj">...</span></pre><p id="6774" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们的useEffect挂钩可以正常工作了，这样我们的功能组件就可以在挂载时获取歌曲数据，而不会过多地重新呈现或抛出错误。</p><p id="b8a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢收听，我们很快会再见的。</p><p id="02d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kv">干杯！</em> </strong></p><p id="31eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kv">更多内容请看</em><a class="ae ku" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kv">plain English . io</em></a></p></div></div>    
</body>
</html>