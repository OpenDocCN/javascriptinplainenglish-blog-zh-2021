<html>
<head>
<title>How to Set Up Firebase Authentication in React from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中从头开始设置Firebase身份验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-set-up-firebase-authentication-in-react-from-scratch-363b123484b7?source=collection_archive---------6-----------------------#2021-05-25">https://javascript.plainenglish.io/how-to-set-up-firebase-authentication-in-react-from-scratch-363b123484b7?source=collection_archive---------6-----------------------#2021-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c08359dd9c1cac53ad0dfa030b0f06c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgIBPaFxc3qQFGBKZFR0Fg.jpeg"/></div></div></figure><h1 id="f870" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">概述:</h1><p id="03ca" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果你正在建立一个像社交媒体应用程序一样存储一些用户私人数据的平台，用户认证是必须的。同时，实现起来有点棘手。在本文中，我们将讨论如何使用Firebase来创建一个功能齐全且安全的用户身份验证。</p><h1 id="b3f2" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">议程:</h1><p id="73b7" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">下面是我们将在本文后面构建的特性列表。</p><ul class=""><li id="706d" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated">签约雇用</li><li id="8bf8" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">登录</li><li id="56ff" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">仪表盘</li><li id="da3e" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">注销</li><li id="9d9b" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">忘记密码</li><li id="fb69" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">受保护的路线</li></ul><h1 id="c30d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">先决条件:</h1><ul class=""><li id="31cd" class="lr ls in kv b kw kx la lb le mh li mi lm mj lq ly lz ma mb bi translated">熟悉React环境。</li><li id="3430" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated"><strong class="kv io"> <em class="mk">上下文API基础知识。</em> </strong></li><li id="e783" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">React中路由的基本知识。</li></ul><h1 id="7a5c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">让我们顺其自然吧</h1><p id="8d92" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">所以首先，我们需要创建一个React应用程序。导航到终端内的<code class="fe ml mm mn mo b">Desktop</code>文件夹，输入<code class="fe ml mm mn mo b">npx create-react-app &lt;give any name&gt;</code>。在<code class="fe ml mm mn mo b">src</code>文件夹中，只保留<code class="fe ml mm mn mo b">index.js</code>和<code class="fe ml mm mn mo b">App.js</code>，删除其余的——我们不需要它们。</p><h2 id="2f81" class="mp jw in bd jx mq mr dn kb ms mt dp kf le mu mv kj li mw mx kn lm my mz kr na bi translated">设置Firebase:</h2><p id="fc4c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">好了，现在，访问<a class="ae nb" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> firebase </a>，点击<strong class="kv io"> <em class="mk">进入控制台；</em> </strong>在那里，你点击<strong class="kv io"> <em class="mk">添加项目</em> </strong>并给它起任何你想要的名字。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/c6be64504cdbffb8e14329e89863535b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QiI9yz4Ldoo4insfJDEOnQ.png"/></div></div></figure><p id="b494" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">点击<strong class="kv io"> <em class="mk">继续</em> </strong>并禁用<strong class="kv io"> <em class="mk">谷歌分析，</em> </strong>再次点击<strong class="kv io"> <em class="mk">继续。这需要一些时间来处理，完成后，我们的Firebase应用程序就准备好了。</em></strong></p><p id="02bd" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">现在，我们需要将它与我们的React web应用程序集成。点击<strong class="kv io"> <em class="mk">网页图标</em> </strong> <em class="mk">。</em> <strong class="kv io"> <em class="mk"> </em> </strong>然后，它会要求您输入另一个项目名称进行集成。别担心，它可以是你想要的任何名字。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/3802b948bfa24b93db13f71029159f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zf7CDw4Qhs9DCpKy4HzEZg.png"/></div></div></figure><p id="b5ed" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">点击<strong class="kv io"> <em class="mk">注册app。</em> </strong>现在，Firebase会给你一些键和其他配置设置，以便你可以将你的React app与Firebase服务连接起来。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/1a27667f1f4e10db60a47daa04e63018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icOce1RO98Bc5rHPrgIokA.png"/></div></div></figure><blockquote class="nl nm nn"><p id="e5f1" class="kt ku mk kv b kw lt ky kz la lu lc ld no nh lg lh np ni lk ll nq nj lo lp lq ig bi translated">您的配置文件会有所不同。还有，不要用上面的键。<strong class="kv io"> <em class="in">这篇文章后会删除这个演示app。</em>T48】</strong></p></blockquote><p id="32d3" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">我们稍后会用到它们。现在，让我们设置认证<strong class="kv io"> <em class="mk">。</em> </strong>导航至firebase应用程序的主页，点击<strong class="kv io"> <em class="mk">认证。</em> </strong>然后，点击<strong class="kv io"> <em class="mk">开始。它将向你展示一些你可以用来创建用户认证的方法。在本文中，我们将使用<strong class="kv io">电子邮件/密码</strong>方法。所以，点击它。然后点击<strong class="kv io"> <em class="mk">仅针对第一个选项启用</em> </strong>并点击<strong class="kv io"> <em class="mk">保存。</em> </strong></em></strong></p><p id="cfc6" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">太好了！现在我们有了一个认证方法和一个连接应用程序的配置文件。让我们去我们最喜欢的代码编辑器开始编码吧！</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="167c" class="jv jw in bd jx jy ny ka kb kc nz ke kf kg oa ki kj kk ob km kn ko oc kq kr ks bi translated">危险！代码提前</h1><p id="e993" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先，我们将创建一个<code class="fe ml mm mn mo b">.env.local</code>文件来存储我们的Firebase配置细节。将它们赤裸裸地公开放在你的代码中会让黑客很容易访问你的Firebase应用。在我们的react-app中，创建一个<code class="fe ml mm mn mo b">.env.local</code>文件，只存储变量<strong class="kv io"><em class="mk">firebaseConfig</em></strong>中的键和值，如下所示:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/c74e6991a075942c8885f0efac534328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNfkjllmyCotyEUgBNiTXQ.png"/></div></div></figure><blockquote class="nl nm nn"><p id="5c1f" class="kt ku mk kv b kw lt ky kz la lu lc ld no nh lg lh np ni lk ll nq nj lo lp lq ig bi translated">在React中，<strong class="kv io"> <em class="in">环境变量</em> </strong>的命名以<strong class="kv io"> <em class="in"> REACT_APP </em> </strong>开始</p></blockquote><p id="81a8" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">太好了！现在，是时候连接它了。为此，我们将使用<strong class="kv io"> firebase </strong>模块。下面是我们将在整个项目中使用的所有模块的列表。</p><ul class=""><li id="92e4" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated"><code class="fe ml mm mn mo b">react-router-dom</code>用于处理不同的路线。</li><li id="ab93" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated"><code class="fe ml mm mn mo b">bootstrap</code>用于造型</li><li id="d715" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated"><code class="fe ml mm mn mo b">react-bootstrap</code>对于预建的样式组件</li><li id="88e1" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated"><code class="fe ml mm mn mo b">firebase</code>用于使用Firebase</li></ul><p id="dbde" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">因此，继续使用命令:<code class="fe ml mm mn mo b">npm i react-router-dom bootstrap react-bootstrap firebase</code>一次性安装它们。</p><p id="5431" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">在react-app中，创建一个文件<code class="fe ml mm mn mo b">firebase.js</code>，用于与Firebase建立连接。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/2b1162a8252b71fcaef40f06282af040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVJpO7a1a30GR_ZIOZ5GFQ.png"/></div></div></figure><p id="ba12" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">如果您观察敏锐，那么这个文件与Firebase提供给我们的用于创建连接的文件非常相似。是的，我们只是使用了<code class="fe ml mm mn mo b">firebase</code>模块，而不是外部JavaScript脚本。我们用存储在<code class="fe ml mm mn mo b">.env.local</code>文件中的环境变量初始化应用程序，而<code class="fe ml mm mn mo b">app.auth()</code>存储在<code class="fe ml mm mn mo b">auth</code>中，它将负责调用几个方法，如<strong class="kv io">登录、注册、注销等。</strong></p><p id="0aeb" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">很好。现在，是时候设置<strong class="kv io">上下文API </strong>了，这样我们就可以在一个文件中定义我们的认证方法，并在相关的组件中访问它们。在<code class="fe ml mm mn mo b">src</code>文件夹中，创建另一个名为<strong class="kv io">上下文</strong>的文件夹，并在其中创建一个文件<code class="fe ml mm mn mo b">authContext.js</code>，如下所示。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/4270a798bd253a5fa6d2889db2da60e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5u3hOYV1VRt4NrxroehK8w.png"/></div></div></figure><p id="7de9" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">先决条件中提到了<strong class="kv io">上下文API </strong>的基础知识。不过，我还是要解释一下。上面，你可以看到上下文JavaScript文件的基本结构。首先，我们使用<code class="fe ml mm mn mo b">React.createContext()</code>创建一个上下文。它给了我们两样东西——提供者和消费者。现在，我们只关心能够让我们传递值并在任何组件中使用它们的提供者。</p><p id="38ea" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">组件<code class="fe ml mm mn mo b">AuthProvider</code>返回带有<code class="fe ml mm mn mo b">value</code>属性的<code class="fe ml mm mn mo b">&lt;AuthContext.Provider&gt;</code>组件，该属性包含我们想要传递的值，<code class="fe ml mm mn mo b">{children}</code>引用将由<strong class="kv io">提供者包装的根组件。最后，我们创建了一个定制的钩子<code class="fe ml mm mn mo b">useAuth()</code>，它直接给你所有传递的值。</strong></p><p id="430a" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">现在，让我们开始在<strong class="kv io"> authContext.js </strong>中创建我们的认证方法，并将它们传递给<strong class="kv io"> Provider。</strong>用下面几行替换上面代码中的注释。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/70d3ea46202273a9fac3414d1e1a7bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ayqn1YWGf0JMhTVqqb0Grg.png"/></div></div></figure><p id="2c27" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">您可以看到，首先，我们创建了两个状态来存储包含登录用户信息的<code class="fe ml mm mn mo b">currentUser</code>和设置为false后显示<code class="fe ml mm mn mo b">{children}</code>的<code class="fe ml mm mn mo b">loading</code>。所以，不要简单的把<code class="fe ml mm mn mo b">{children}</code>渲染在<code class="fe ml mm mn mo b">&lt;AuthContext.Provider&gt;</code>里面，改成<code class="fe ml mm mn mo b">{!loading &amp;&amp; children}</code>。</p><p id="1387" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">如前所述，所有的认证方法都将存储在<strong class="kv io"> firebase.js </strong>的<code class="fe ml mm mn mo b">auth</code>中。因此，我们使用<code class="fe ml mm mn mo b">auth</code>来调用不同的方法，并将它们存储在各自的函数中，以便在需要时可以调用它们。<code class="fe ml mm mn mo b">useEffect()</code>包含一个事件处理程序，它持续监听用户登录和注销时的身份验证状态。据此，将<code class="fe ml mm mn mo b">currentUser</code>状态设置为登录用户或<code class="fe ml mm mn mo b">undefined</code>。</p><p id="a268" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated"><code class="fe ml mm mn mo b">auth.onAuthStateChanged()</code>是事件处理程序。每当组件加载时，<code class="fe ml mm mn mo b">useEffect()</code>设置该处理程序多次使用。这可能会导致内存泄漏，并使您的应用程序变慢。为了处理这个问题，<code class="fe ml mm mn mo b">auth.onAuthStateChanged()</code>返回了一个<code class="fe ml mm mn mo b">unsubscribe</code>方法，它可以在组件卸载时让你从事件处理程序中取消订阅。</p><p id="9f68" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">之后，我们只需将所有方法和状态传递给<strong class="kv io"> Provider内部的values prop。</strong></p><p id="d722" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">现在，我们需要用<code class="fe ml mm mn mo b">AuthProvider</code>组件包装我们的根组件。在这个应用程序中，我们将包装我们的<code class="fe ml mm mn mo b">App</code>组件。因此，打开<strong class="kv io"> index.js </strong>并执行以下操作:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/e0cc9542fa002fd92dcb75747f475cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQqScyLvcTZttgAqBA1pDQ.png"/></div></div></figure><p id="f484" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">现在我们的<code class="fe ml mm mn mo b">&lt;App /&gt;</code>将为<code class="fe ml mm mn mo b">&lt;AuthProvider&gt;</code>做<code class="fe ml mm mn mo b">{children}</code>。你可以看到我还导入了一个引导CSS文件，为我们的每个组件赋予风格。但是如果您愿意，您可以创建自己的自定义样式表。在本文中，我们只关注功能。</p><p id="f2a8" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">到目前为止，我们一直在处理功能设置。所以，是时候为每个方法创建组件了。在<code class="fe ml mm mn mo b">src</code>文件夹中创建一个文件夹，名称为<code class="fe ml mm mn mo b">components</code>。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="6495" class="jv jw in bd jx jy ny ka kb kc nz ke kf kg oa ki kj kk ob km kn ko oc kq kr ks bi translated">注册组件:</h1><p id="f83a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先，我们将处理注册组件。因此，在<code class="fe ml mm mn mo b">components</code>文件夹中，创建一个名为<strong class="kv io"> signup.js </strong>的文件。</p><p id="a95e" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">我们将创建一个具有三个字段的表单— <strong class="kv io">电子邮件、密码、确认密码、</strong>并检查<strong class="kv io">确认密码是否与密码匹配。</strong>只有这样，我们才会从<strong class="kv io"> authContext.js中调用注册方法。</strong>如果注册成功，我们会将用户重定向到<strong class="kv io"> <em class="mk">仪表板</em> </strong>组件(稍后将创建该组件)。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oi"><img src="../Images/d34907f2939dc142492e91e5f84a08c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0yK7qVjP-5v2mWpf2H3IA.png"/></div></div></figure><p id="efc9" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">正如我在文章前面提到的，我们的定制钩子<code class="fe ml mm mn mo b">useAuth()</code>将用于接收上下文中传递的值，在这个组件中，我们使用在<strong class="kv io"> authContext.js中创建的<strong class="kv io"> signup </strong>方法。</strong> <code class="fe ml mm mn mo b">Link</code>用于将用户带到<strong class="kv io">登录</strong>页面(如果他们已经有一个帐户),而<code class="fe ml mm mn mo b">useHistory</code>挂钩用于在成功注册后重定向用户。</p><p id="cae4" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated"><code class="fe ml mm mn mo b">emailRef</code>、<code class="fe ml mm mn mo b">passwordRef</code>和<code class="fe ml mm mn mo b">passwordConfirmRef</code>被用作各自输入字段的引用，稍后我们从<code class="fe ml mm mn mo b">useAuth</code>钩子中析构<strong class="kv io">注册</strong>方法。</p><p id="a013" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">现在，看一下<code class="fe ml mm mn mo b">handleSubmit</code>的功能。这是一个<code class="fe ml mm mn mo b">async</code>函数，因为来自Firebase的认证方法返回一个<strong class="kv io">承诺。</strong>所以，我们用<code class="fe ml mm mn mo b">async / await</code>来处理它。这里，我们首先检查密码和确认密码是否相同。然后，在<code class="fe ml mm mn mo b">try / catch</code>块中，我们通过传递用户输入的<strong class="kv io">电子邮件</strong>和<strong class="kv io">密码</strong>来调用<strong class="kv io">注册</strong>函数。</p><p id="6add" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">这是我们的<strong class="kv io">注册功能。</strong>现在，在return中，让我们创建表单和其他ui。我们使用<strong class="kv io">自举卡</strong>和<strong class="kv io">形式</strong>用于造型目的。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oj"><img src="../Images/25051ffb5fd2d44efbd3704c7835daf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IR9iRTBj_HAy9TZCLwHgqQ.png"/></div></div></figure><p id="6316" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">一行一行来就行了。代码非常简单。我们所做的就是使用<strong class="kv io"> bootstrap </strong>组件并创建表单。最后，如果用户已经有了帐户，我们创建了一个到<strong class="kv io">登录</strong>组件的链接。就是这样。我们的<strong class="kv io">注册</strong>组件准备好了。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="ed22" class="jv jw in bd jx jy ny ka kb kc nz ke kf kg oa ki kj kk ob km kn ko oc kq kr ks bi translated">登录组件:</h1><p id="bb83" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在<strong class="kv io">组件</strong>文件夹中创建一个文件，命名为<strong class="kv io"> login.js. </strong></p><p id="cd8a" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">这个组件将与<strong class="kv io">注册</strong>组件非常相似。唯一的区别是我们调用了<strong class="kv io">登录</strong>函数，而不是<strong class="kv io">注册。我们不需要在这里有确认密码字段。两个组件中的其余代码是相同的。</strong></p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ok"><img src="../Images/cb0cd5013a5b9fca557810138c58972e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiD-PirHRBm-iKAgn2Vf6Q.png"/></div></div></figure><p id="30a9" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">我们返回的内容也非常类似于<strong class="kv io">注册。</strong>除了不创建到<strong class="kv io">登录的链接，</strong>我们询问他们是否未注册，然后带他们到<strong class="kv io"/><strong class="kv io">注册</strong>组件<strong class="kv io">。</strong></p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ol"><img src="../Images/2f69f545019b29366c0d2b53d2d6932b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5LPQU75leZnHzkIBKAUyg.png"/></div></div></figure><p id="aa5d" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">我们允许用户通过创建一个到<strong class="kv io">遗忘密码</strong>组件的链接来重置他们的密码。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="90c0" class="jv jw in bd jx jy ny ka kb kc nz ke kf kg oa ki kj kk ob km kn ko oc kq kr ks bi translated">忘记密码组件:</h1><p id="5f00" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Firebase密码重置的工作方式是，当用户点击它时，他们会向注册的电子邮件地址发送一封电子邮件，其中包含进一步的说明和重置密码的链接。</p><p id="071e" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">最酷的是，代码与上面的组件非常相似，这里我们调用了<code class="fe ml mm mn mo b">resetpassword</code>方法。继续创建一个名为<strong class="kv io"> forgetpassword.js </strong>的文件，看看下面的内容。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi om"><img src="../Images/e35f6c542638fe15a80c9e851fee6255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EbvMs6UPrjtC0INQpZL8Aw.png"/></div></div></figure><p id="6e4a" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">正如你所看到的，我们正在从自定义<code class="fe ml mm mn mo b">useAuth()</code>钩子中析构<code class="fe ml mm mn mo b">resetPassword</code>，并且在成功调用<code class="fe ml mm mn mo b">resetPassword</code>函数后，有一个额外的状态来存储消息，比如<strong class="kv io"> <em class="mk">检查你的收件箱等等等等… </em> </strong>。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ol"><img src="../Images/5630395cf601a747afbc41ad98d60f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLwhZXsn1Wag2GU1Cwq08g.png"/></div></div></figure><p id="6e56" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">没什么新鲜的。我们已经熟悉了这种类型的代码——我们的<strong class="kv io">重置密码</strong>组件已经准备好了。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="669b" class="jv jw in bd jx jy ny ka kb kc nz ke kf kg oa ki kj kk ob km kn ko oc kq kr ks bi translated">仪表板:</h1><p id="dd21" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">目前，我们的仪表板只显示了<code class="fe ml mm mn mo b">currentUser</code>的电子邮件，还包含一个用于注销用户的<code class="fe ml mm mn mo b">logout</code>按钮。您可以根据您的自定义项目添加更多功能。</p><p id="5edd" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">继续在<strong class="kv io">组件</strong>文件夹中创建一个名为<strong class="kv io"> dashboard.js </strong>的文件。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi on"><img src="../Images/49b16e0bca7a8317f022da274bd8d43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AutWayNXYixF8EhR2nFDvw.png"/></div></div></figure><p id="64c6" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">需要注意的是，这里我们分别析构了<code class="fe ml mm mn mo b">logout</code>和<code class="fe ml mm mn mo b">currentUser</code>来处理注销和显示登录用户的邮件。当用户成功注销时，我们使用<code class="fe ml mm mn mo b">useHistory()</code>钩子将他/她重定向到<strong class="kv io">登录</strong>组件。<strong class="kv io">仪表板</strong>组件准备就绪。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="61ec" class="jv jw in bd jx jy ny ka kb kc nz ke kf kg oa ki kj kk ob km kn ko oc kq kr ks bi translated">为组件设置路线:</h1><p id="21ba" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们完成了所有的组件。现在让我们使用<code class="fe ml mm mn mo b">react-router-dom</code>在<strong class="kv io"> App.js </strong>中设置他们的每条路线。打开<strong class="kv io"> App.js </strong>并执行以下操作。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oo"><img src="../Images/5dfacd041ef9a75694756f15ec94a3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LJhqhLiSvjnt5_1Vev23Q.png"/></div></div></figure><p id="7679" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">我们导出了<code class="fe ml mm mn mo b">BrowserRouter</code>和<code class="fe ml mm mn mo b">Route</code>来为每个不同的组件设置路径，导出了<code class="fe ml mm mn mo b">Switch</code>来一次加载一个组件。</p><p id="a1e0" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">现在，如果您通过运行<code class="fe ml mm mn mo b">npm start</code>启动应用程序，那么您会看到一个空白屏幕，因为主页现在是空的。要查看不同的组件，请访问它们各自的URL。比如:<a class="ae nb" href="http://localhost:3000/signup" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mk">http://localhost:3000/sign up</em></strong></a><strong class="kv io"><em class="mk"/></strong>会带你去:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/e278530b78e1ccaf47709bf1544bf592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6IjBorcM2lUrXvAQq-h1Q.png"/></div></div></figure><p id="cef2" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">当您输入您的详细信息并点击<strong class="kv io"> <em class="mk">注册</em> </strong>按钮时，您将被重定向到<strong class="kv io">仪表板</strong>组件</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oq"><img src="../Images/0697205b1b651a2713086350ac578a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfpTQ09uXuyG0ZYiKlS2OQ.png"/></div></div></figure><p id="8978" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">现在，您可以一个接一个地检查其他组件。现在我们已经成功地实现了认证。您可以在Firebase控制台的authentication部分看到注册用户的列表。还缺少一些东西…..T19】</p><h1 id="c15c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">保护敏感路线:</h1><p id="53ee" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们的应用程序运行良好，用户认证也很好，但仍然缺少一些东西，我们忘记了一些东西。你能猜到是什么吗？</p><p id="3cd6" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">嗯，如果你注销用户，并试图进入<strong class="kv io">仪表板</strong>…嘣！你仍然可以访问它，这是不好的。我们不希望任何来宾用户轻松访问我们的仪表板。虽然它现在不包含任何内容，但在您的项目中可能不成立。我们仍然需要保护它，以便只有注册用户才能访问他们的仪表板。</p><p id="707d" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">我们可以这样做的方法是创建另一个组件。基本上是来自<code class="fe ml mm mn mo b">react-router-dom</code>的<code class="fe ml mm mn mo b">Route</code>组件的修改版本，它将检查是否有人登录。如果为真，那么它将呈现<strong class="kv io">仪表板，</strong>否则，只需重定向到<strong class="kv io">登录</strong>组件。</p><p id="0d9c" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">在<strong class="kv io"> components </strong>文件夹中创建一个名为<strong class="kv io"> privateRoute.js </strong>的文件，看看它将包含什么。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi or"><img src="../Images/f5b000f01e9e1230a8c3c1000f8e7510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxwK7ML6nZ0Qm_7diuU-Og.png"/></div></div></figure><p id="7b74" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">让我们明白我们在做什么。正如我所说的，<strong class="kv io"> PrivateRoute </strong>是<code class="fe ml mm mn mo b">Route</code>组件的修改版本，它在建立任何路由之前检查<code class="fe ml mm mn mo b">currentUser</code>。在这里，我们先来了解一下<code class="fe ml mm mn mo b">useAuth()</code>的<code class="fe ml mm mn mo b">currentUser</code>。</p><p id="6802" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">然后，我们返回带有普通<code class="fe ml mm mn mo b">&lt;Route&gt;</code>组件所需的所有道具的<code class="fe ml mm mn mo b">&lt;Route&gt;</code>组件，如<code class="fe ml mm mn mo b">path</code>、<code class="fe ml mm mn mo b">exact</code>等。然后检查<code class="fe ml mm mn mo b">currentUser</code>。如果为真，则渲染<strong class="kv io">仪表板；</strong>否则，重定向到<strong class="kv io">登录。这里，我们将使用来自<code class="fe ml mm mn mo b">react-router-dom</code>的<code class="fe ml mm mn mo b">&lt;Redirect&gt;</code>组件，而不是使用<code class="fe ml mm mn mo b">useHistory()</code>进行重定向，因为如果<code class="fe ml mm mn mo b">currentUser</code>没有登录，我们需要渲染一些东西。</strong></p><p id="c2e4" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">现在，在<strong class="kv io"> App.js中，</strong>导入该组件，并将为<strong class="kv io">仪表板</strong>设置路线的代码行替换为:</p><p id="07f0" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated"><code class="fe ml mm mn mo b">&lt;PrivateRoute exact path=”/dashboard” component={Dashboard} /&gt;</code></p><p id="682a" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated">我们完了。现在，如果您试图以访客身份访问<strong class="kv io">仪表板</strong>，您将被重定向到<strong class="kv io">登录</strong>组件。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><h1 id="107c" class="jv jw in bd jx jy ny ka kb kc nz ke kf kg oa ki kj kk ob km kn ko oc kq kr ks bi translated">结论:</h1><p id="715f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">就是这样。我们成功地创建了用户身份验证所需的所有基本功能。你可以用你想要的方式升级它，或者不使用<strong class="kv io">上下文，</strong>你可以使用<strong class="kv io"> Redux。Firebase有很多很酷的功能，比如Firestore、实时数据库等等。在设计大型项目时，它真的很方便。我们将在以后的文章中讨论更多关于Firestore的内容。在那之前，保持健康，继续编码。</strong></p><blockquote class="nl nm nn"><p id="253c" class="kt ku mk kv b kw lt ky kz la lu lc ld no nh lg lh np ni lk ll nq nj lo lp lq ig bi translated">如果您想要项目的完整代码文件，请从这里的 <a class="ae nb" href="https://github.com/practice404/react-components/tree/main/firebase-react-auth" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">获取。</strong></a></p></blockquote><p id="3542" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le nh lg lh li ni lk ll lm nj lo lp lq ig bi translated"><em class="mk">更多内容请看</em><a class="ae nb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mk">plain English . io</em></a></p></div></div>    
</body>
</html>