<html>
<head>
<title>Evolution of Modules in JavaScript with Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入的JavaScript模块进化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/evolution-of-modules-in-javascript-with-dependency-injection-5c51a3f6442e?source=collection_archive---------7-----------------------#2021-05-19">https://javascript.plainenglish.io/evolution-of-modules-in-javascript-with-dependency-injection-5c51a3f6442e?source=collection_archive---------7-----------------------#2021-05-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3d3b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在ES5中用词法作用域和闭包定义单个模块，并使用容器模块模式(控制反转)来维护多个模块之间的依赖关系。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fbfbd5d76f63b054da9f50394880db0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7IJtNUnja0QlOtPSULetQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A BNSF train hauls containers. Image: Flickr/Clay Gilliland</figcaption></figure><p id="62f0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在<a class="ae lo" href="https://262.ecma-international.org/6.0/" rel="noopener ugc nofollow" target="_blank"> EcmaScript规范版本6(2015) </a>出现之前，JavaScript是一种完全不同的语言，它与Scheme (甚至Lisp)有着非常接近的<a class="ae lo" href="https://medium.com/thinking-with-computers/javascript-is-not-scheme-7a84889e9b3c" rel="noopener">相似性，并且没有类似于传统面向对象编程的<code class="fe lp lq lr ls b">class</code>语法。</a></p><p id="2aaa" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本文中，我们将使用与<a class="ae lo" href="https://262.ecma-international.org/5.1/" rel="noopener ugc nofollow" target="_blank"> EcmaScript规范第5版(2009) </a>兼容的设计模式，并展示通过依赖管理和依赖注入实现模块化的方法，而没有 <code class="fe lp lq lr ls b"><a class="ae lo" href="https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4" rel="noopener">class</a></code>的<a class="ae lo" href="https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4" rel="noopener">陷阱。</a></p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="77fa" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">模块</h1><p id="4837" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">在我们剖析JavaScript的原生功能并根据我们的设计模式扩展它们以使系统更加模块化之前，我们必须先退后一步，问自己是什么使代码模块化？</p><p id="c09e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最核心的是，术语<strong class="ku io">模块</strong>被<em class="mx">牛津词典</em>定义为“<em class="mx">一组标准化部件或独立单元中的每一个，它们可用于构建更复杂的结构，如一件家具或一栋建筑</em>。”</p><p id="15c3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果我们将这种思想融入计算机科学，确切地说，融入软件工程，我们可以说<em class="mx">一个模块是程序的一部分，程序是由一个或多个独立开发的模块组成的，这些模块直到程序链接起来才组合在一起。单个模块可以包含一个或多个例程</em>。</p><p id="3681" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在JavaScript中，在EcmaScript 6之前，将函数拆分成单独的<em class="mx">模块</em>(或<em class="mx">类</em>，我们在这里将互换使用这些术语)的标准方式是使用所谓的<a class="ae lo" href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="mx">(揭示)</em> </strong> <strong class="ku io"> <em class="mx">模块模式</em> </strong> </a>来完成的。下面的代码片段展示了模块名为<em class="mx">的电影</em>的模式。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cd6d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这就创建了一个封装的<em class="mx"> Movie </em>模块的实现，它接受两个参数— <em class="mx"> name </em>和<em class="mx"> director — </em>进行实例化，并提供三个成员函数与之交互，即<em class="mx"> getDirector </em>、<em class="mx"> getName、</em>和<em class="mx"> toString </em>。考虑下面的例子来更好地理解它的工作原理:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="79f5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但这种实现的问题是，成员字段<em class="mx"> (name，director) </em>与<em class="mx">实例</em>(或<em class="mx">对象</em>，可互换)绑定。因此，解封装这些值甚至覆盖它们并不费力。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="c370" class="ma mb in bd mc md na mf mg mh nb mj mk jt nc ju mm jw nd jx mo jz ne ka mq mr bi translated">私有成员变量</h1><p id="919d" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">是的，你可以在JavaScript中拥有一个私有成员字段，尽管有些冷嘲热讽。虽然实现起来有点复杂，但肯定不是不可能的。此外，有一个<a class="ae lo" href="https://github.com/tc39/proposal-class-fields#private-fields" rel="noopener ugc nofollow" target="_blank"> RFC </a>有效地使该功能成为浏览器和Node.js的本地功能。首先考虑下面的例子，然后我们可以更深入地解释:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2e5c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> WeakMap </em> </a>保存使用<a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> <em class="mx">映射</em> </a>定义的每个实例的状态引用。根据规范，<em class="mx"> WeakMap </em>的键必须是非原始的，这样它们才能被垃圾回收。</p><p id="6441" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就其本质而言，一旦键不再被引用，它在映射中指向的值也将可用于垃圾收集，从而保持内存足迹的干净。这里要注意的是，只有在除了键之外没有对该内存位置的引用时，才会对该值进行垃圾收集。</p><p id="dff3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">由于JavaScript的闭包属性，<em class="mx"> WeakMap </em>实例只能在Movie的成员函数中访问，因此不能从外部访问。所以，我们的内部状态在每个实例中都是安全的。因此，如果我们再次运行相同的示例，输出将会不同:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="6156" class="ma mb in bd mc md na mf mg mh nb mj mk jt nc ju mm jw nd jx mo jz ne ka mq mr bi translated">模块间的关系</h1><p id="90b0" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">既然我们对什么是模块有了一个清晰的概念，让我们关注下一部分，即模块和通信技术之间的关系。</p><p id="b5e4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">假设有另一个叫做<em class="mx">艺术家</em>的模块，我们很快就会看到它的实现。现在为了简单起见，让我们从一个简单的单向关系开始，也就是说，要么<em class="mx">电影</em>知道<em class="mx">艺术家</em>，要么相反。</p><p id="ccd4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">先拿<em class="mx">电影</em>独立于<em class="mx">艺人</em>而<em class="mx">艺人</em>依赖于<em class="mx">电影</em>的情况来说。用外行人的话来说，当谈论电影时，我们不能告诉任何关于艺术家为谁工作的信息，但是当谈论每个艺术家时，我们总是知道他们为哪部电影工作。正因为如此，我们必须先实例化电影，然后艺术家对象才能使用它们。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="11b4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里应用了相同的技术来封装实例的内部状态。通过运行下面的例子，我们系统的知识缺口变得非常清晰:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9837" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">另一种说法是，所有的电影都必须了解艺术家，但是我们可以接受艺术家缺乏关于电影的信息。所以，我们稍微修改了一下电影的实现。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8953" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">用法如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f257" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个实现也是不完整的，因为我们无法在<em class="mx">组合关系</em>中双向获取信息。我们可以将一个带有额外成员函数<em class="mx"> ( </em> <code class="fe lp lq lr ls b"><em class="mx">addMovie</em></code> <em class="mx"> ) </em>的变通方法放入<em class="mx"> Artist </em>模块中，以便在初始化<em class="mx">(关联关系)</em>期间将<em class="mx">电影</em>添加回每个<em class="mx"> Artist </em>对象。但是这只会增加固有的复杂性，同时损害可读性。我们会看到有一种更简单的方法来处理这个问题。</p><h1 id="513c" class="ma mb in bd mc md na mf mg mh nb mj mk jt nc ju mm jw nd jx mo jz ne ka mq mr bi translated">模块工厂模式</h1><p id="eee0" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">我们可以做的一个简单的改进是将模块包装在工厂函数中，以便从一个对象早期引用另一个对象。通过这种方式，我们可以确保单个实体只有一个实例，并提供另一种消费对象的方式，而不必直接引用它们。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9de0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">并且该实现可以进一步如下使用:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6d80" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">系统的局限性在于，即使你可以从<em class="mx">电影</em>对象中懒引用<em class="mx">艺术家</em>对象，但之前还是需要实例化。我们可以交换模块的位置，但问题仍然存在。</p><h1 id="7210" class="ma mb in bd mc md na mf mg mh nb mj mk jt nc ju mm jw nd jx mo jz ne ka mq mr bi translated">依赖注入模式</h1><p id="19d6" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated"><em class="mx">工厂模式</em>的限制是<em class="mx"> </em>，因为我们在编写模块时试图绑定它们。依赖注入是实现这一点的一种方式，但只能在运行时实现。实现几乎是相似的，除了一些细微的差别，这使得访问另一个的实例变得很容易。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="675a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">并且可以用作:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="51e9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这修复了前面提到的模式的所有问题。现在，所有对象都可以随时实例化，并可以在显式引用它们之前设置为消费。请记住，这个实现使用<em class="mx">映射</em>来保存对它们的<a class="ae lo" href="https://docs.microsoft.com/en-us/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> <em class="mx">主键</em> </a>的引用，这些主键恰好是原始值，一旦引用不再被使用，就应该清除它们以避免内存泄漏。</p><p id="c658" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">您可能已经意识到这种方法的一个问题是可伸缩性问题。随着系统中模块的增多，管理它们之间的依赖关系将变得单调乏味且容易出错。即使你能成功做到这一点，系统的认知复杂性也会成倍增加。</p><h1 id="a715" class="ma mb in bd mc md na mf mg mh nb mj mk jt nc ju mm jw nd jx mo jz ne ka mq mr bi translated">容器模块模式</h1><p id="ccf6" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">避免依赖注入模式的这些警告的一个方法是为所有的依赖维护一个单一的事实来源。我们将那个<em class="mx">容器</em>和其中的每个依赖项称为<em class="mx">容器模块</em>。在这种模式中，每个依赖项或<em class="mx">容器模块</em>都使用一个唯一的标识符进行标记，这个标识符用于在运行时取回那些依赖项。为了更好地理解这个概念，请考虑下面的实现:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ac56" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我们可以将我们的依赖项，即<em class="mx">电影</em>和<em class="mx">艺术家</em>绑定到这个<em class="mx">容器</em>中，稍后从同一个容器中访问它们。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="67f1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在到了关键时刻，我们通过运行以下示例来测试这些实现:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="be2b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">请注意<code class="fe lp lq lr ls b">miachelCaine</code>是如何被引用的，但数据却保存在其中。这种模式可以让你完全解耦模块实现，然后将它们绑定到一个单独的<em class="mx">容器</em>中，让事情正常进行。</p><h1 id="7ce6" class="ma mb in bd mc md na mf mg mh nb mj mk jt nc ju mm jw nd jx mo jz ne ka mq mr bi translated">开放源码</h1><p id="e019" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">有许多开源项目致力于通过实现这样的模式让开发人员的生活变得更容易，同时保持API的简单。其中一个项目是<a class="ae lo" href="https://github.com/inversify/InversifyJS" rel="noopener ugc nofollow" target="_blank"> <em class="mx">反演</em> </a>，Eclipse社区在他们的Web IDE项目<a class="ae lo" href="https://github.com/eclipse-theia/theia" rel="noopener ugc nofollow" target="_blank"> <em class="mx">【忒伊亚】</em> </a>中使用了这个项目。另一个流行的项目是<a class="ae lo" href="https://github.com/typestack/typedi" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> Typedi </em> </a>，它有非常棒的绑定工具，有<a class="ae lo" href="https://github.com/expressjs/express" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> Express </em> </a>和<em class="mx">typeform</em>，这是Node.js后端解决方案的流行框架。人们总是建议使用这样的工具，而不是自己制作，尤其是如果您想要运行一个生产应用程序。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="9ec9" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">结论</h1><ol class=""><li id="3a80" class="nf ng in ku b kv ms ky mt lb nh lf ni lj nj ln nk nl nm nn bi translated">模块是大规模软件工程的组成部分。</li><li id="a97d" class="nf ng in ku b kv no ky np lb nq lf nr lj ns ln nk nl nm nn bi translated">模块可以用JavaScript创建，即使没有任何<em class="mx">类</em>语法。</li><li id="c4e9" class="nf ng in ku b kv no ky np lb nq lf nr lj ns ln nk nl nm nn bi translated">私有属性可以添加到ES5 JavaScript模块中，尽管有点复杂。</li><li id="93ec" class="nf ng in ku b kv no ky np lb nq lf nr lj ns ln nk nl nm nn bi translated">多个模块之间的交互更容易，尽管有一个工厂方法围绕着它们。</li><li id="e6f0" class="nf ng in ku b kv no ky np lb nq lf nr lj ns ln nk nl nm nn bi translated">我们应该通过将前面提到的工厂方法作为依赖传递来反转实例化的控制。</li><li id="69f1" class="nf ng in ku b kv no ky np lb nq lf nr lj ns ln nk nl nm nn bi translated">如果系统增长，数量模块将增加，它们之间的依赖关系也将增加，从而产生所谓的<a class="ae lo" href="https://en.wikipedia.org/wiki/Dependency_hell" rel="noopener ugc nofollow" target="_blank"> <em class="mx">依赖地狱</em> </a>。</li><li id="85cf" class="nf ng in ku b kv no ky np lb nq lf nr lj ns ln nk nl nm nn bi translated">我们可以使用<em class="mx">容器模块模式</em>来保持依赖之间的健全性，并且为所有人提供一个单一的真理来源。</li></ol><p id="8b4d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="mx">更内容见于</em> <a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">中</em></a></p></div></div>    
</body>
</html>