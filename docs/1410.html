<html>
<head>
<title>Solving 8 Puzzle: Exploring Search Options</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决8个难题:探索搜索选项</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solving-8-puzzle-exploring-search-options-2e446e29d21?source=collection_archive---------2-----------------------#2021-03-25">https://javascript.plainenglish.io/solving-8-puzzle-exploring-search-options-2e446e29d21?source=collection_archive---------2-----------------------#2021-03-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bcd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我之前的文章中，我提出了八个难题的问题。</p><div class="ki kj gp gr kk kl"><a href="https://medium.com/nerd-for-tech/solving-8-puzzle-with-search-e17c71000780" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">用搜索解决8个难题</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">我开始了我的人工智能之旅，似乎对搜索的研究是这个领域的首要条件。最初的…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div><p id="0feb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我想从利用搜索技术的起点来研究如何找到一个解决方案。提醒一下，解决方案空间是难题状态的图表，并移动到后续状态，例如:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/38a441dab8f9e6af5b3b064ca46ed72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H5kmz2wzgAT58J_a.png"/></div></div></figure><p id="8803" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每种状态都是一对ID(或键)和它的值，它们是一个数组，表示哪个拼图块在哪个拼图块上。该图包含362，880个节点和967，680条边。强力搜索是可行的，但并不是最佳技术。更明智的方法是更有效的选择，但需要更多的工作。</p><h1 id="a09b" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">广度优先</h1><p id="cc08" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">广度优先搜索(BFS)从检查第一个节点开始，一次扩展一层，例如，所有节点从第一个节点“一跳”；一旦用尽，它就从第一个节点“两跳”前进到所有节点，依此类推。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mp"><img src="../Images/1ecbe9da447501e19a08f24a3da9ca81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qehek3NQPrtMRL8F8sRW4w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">BFS pattern of stepping through the graph one layer at a time.</figcaption></figure><p id="a8bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了完成这一壮举，BFS实现了一个队列(先进先出)。“一级之外”的节点列表通常称为边界:</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="f331" class="mz ln in mv b gy na nb l nc nd">const BFS = function (startNode, isGoal) { </span><span id="6d59" class="mz ln in mv b gy ne nb l nc nd">    const frontier = [startNode]</span><span id="e164" class="mz ln in mv b gy ne nb l nc nd">    while(startNode.length &gt; 0) {</span><span id="c426" class="mz ln in mv b gy ne nb l nc nd">       const currentNode = frontier.shift()</span><span id="f793" class="mz ln in mv b gy ne nb l nc nd">       if(isGoal(currentNode)) {<br/>          return Solution(currentNode)<br/>       }</span><span id="baf2" class="mz ln in mv b gy ne nb l nc nd">       for(child of currentNode.children) {<br/>          frontier.push(child)<br/>       }<br/>    }</span><span id="dabf" class="mz ln in mv b gy ne nb l nc nd"><strong class="mv io">    </strong>return NotFound()<br/>}</span></pre><p id="7285" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该算法将开始节点推到边界上，然后继续从边界上取下一个节点，看它是否解决了目标，如果它没有将它的子节点添加到边界上。如果边界到达一个空的状态，那么目标和搜索空间就不匹配了。</p><p id="b377" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">BFS是一个完整的解决方案(如果存在，将找到符合目标的节点)，并且在空间很小或解决方案/目标很浅(接近startNode)时做得很好。它也面临着记忆和时间的挑战。</p><p id="cf66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是在解决八个难题时遇到的问题。我当然可以重写图表以提高效率，但总的来说，这不会对性能产生有意义的改变。</p><h1 id="a583" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">深度优先</h1><p id="c24e" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">深度优先搜索(DFS)从一个节点开始，沿着最左边的节点向下搜索，直到到达一个叶子。然后，它备份到叶子的父节点，并检查它的下一个最左边的节点，依此类推。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nf"><img src="../Images/589859db867a39c158357b2bf761facb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XwZW108ecaiNihHD_W-TA.png"/></div></div></figure><p id="8f06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">DFS也是一个完整的解决方案，如果目标存在，它将最终找到目标，但它是递归实现的。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="39d3" class="mz ln in mv b gy na nb l nc nd">const DFS = function (node, isGoal) {</span><span id="c44d" class="mz ln in mv b gy ne nb l nc nd">      if (isGoal(node)) {<br/>        return Solution(node)<br/>      }<br/> <br/>      for (child of node.children.reverse) {</span><span id="df3d" class="mz ln in mv b gy ne nb l nc nd">         if (notVisited(child)) {</span><span id="abc7" class="mz ln in mv b gy ne nb l nc nd">            const resultOfRecursion = BFS(child, isGoal)</span><span id="8982" class="mz ln in mv b gy ne nb l nc nd">            if (resultOfRecursion instanceof Solution) {<br/>                return resultOfRecursion<br/>            }</span><span id="8deb" class="mz ln in mv b gy ne nb l nc nd">         }<br/>      }</span><span id="29b9" class="mz ln in mv b gy ne nb l nc nd">      return NotFound()<br/>}</span></pre><p id="fe86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应该注意的是，搜索图形与搜索树是不同的挑战。有了树，你可以确定你的搜索不会进入任何循环(loops)，但是在图中，节点可以循环回到自身，这是一个问题。为了防止这种情况，您只需跟踪一个节点是否被访问过(这非常简单)。</p><p id="d0c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果目标位于图中最左边的一个分支中，则DFS表现出色。然而，如果目标位于最右边的一个分支，可能需要一些时间才能到达那里。所以对这个算法做了一个修改，增加了一些运行时间，但是相对来说数量不大。这就是所谓的迭代深化DFS。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="11df" class="mz ln in mv b gy na nb l nc nd">const DFS = function (node, isGoal, depth) {</span><span id="cbb1" class="mz ln in mv b gy ne nb l nc nd">    if (depth == 0) {      <br/>       return SearchLimitExhausted()<br/>    }</span><span id="87d8" class="mz ln in mv b gy ne nb l nc nd">    /* same as above */</span><span id="529d" class="mz ln in mv b gy ne nb l nc nd">           const resultOfRecursion = BFS(child, isGoal, depth -1)</span><span id="963e" class="mz ln in mv b gy ne nb l nc nd">    /* same as above */</span><span id="d0e6" class="mz ln in mv b gy ne nb l nc nd">}</span></pre><p id="d98f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每一次递归调用都将深度减一，当你到达零时，你已经穷尽了你的搜索。用尽你的搜索不同于一个不存在的解决方案，所以用这种方式标记它是有用的。</p><p id="f641" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">深度受限并不保证完整(目标可能比阈值更深)，但您可以通过重复加深您正在搜索的图形量来恢复完整性:</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="7948" class="mz ln in mv b gy na nb l nc nd">const dfs_deepening = function (node, isGoal, limit) {<br/>    for (let i = 1; i &lt;= limit; i++) {<br/><br/>        const resultOfDFS = DFS(node, isGoal, i)</span><span id="a9c3" class="mz ln in mv b gy ne nb l nc nd">        if (resultOfDFS instanceof Solution) {<br/>            return resultOfDFS<br/>        } else if (resultOfDFS instanceof NotFound) {<br/>            return resultOfDFS<br/>        }<br/>    }<br/><br/>    return SearchLimitExhausted()<br/>}</span></pre><p id="ef9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">缺点是您总是在开始节点重新开始，并且您在重复工作。</p><blockquote class="ng nh ni"><p id="f4fa" class="jk jl nj jm b jn jo jp jq jr js jt ju nk jw jx jy nl ka kb kc nm ke kf kg kh ig bi translated">由于迭代深化多次访问状态，这看起来很浪费，但事实证明成本并不高，因为树中的大多数节点都在底层，所以如果上层被多次访问也没什么关系[1]</p></blockquote><h1 id="b047" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">启发式搜索</h1><p id="befe" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">BFS和DFS按照预先确定的顺序推进图表。它们是简单的算法，用于小搜索空间。然而，它们可以通过提供一些洞察力来改进，我们称之为启发式函数。启发式函数估计任何给定节点达到目标状态的剩余工作量。该算法的工作原理是计算每个节点子节点的启发式算法，然后选择最接近解决方案的子节点。我将描述的搜索，<strong class="jm io">递归最佳优先搜索</strong>，有一点复杂。在讨论算法之前，我们应该讨论一下启发式函数。</p><p id="e7e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们如何开发一个启发式函数？给定BFS/DFS示例中的图表，可以创建一个达到某个字母的目标。启发式函数的一个例子可能是:当前字母和目标字母之间的ASCII值的差异。为了直观显示这一点，我们可以使用图表，查看ASCII值，然后查看与目标的差异，遵循最小启发法(绿色表示遍历的路径):</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nn"><img src="../Images/93afc4177fe7b6481d28ca7961aaaf47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPhaBAh7kove-z8qFgKZnQ.png"/></div></div></figure><p id="a2c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，这是可行的，因为“I”节点是“d”的子节点，最小的启发式算法是可行的。但是，如果“I”节点碰巧位于其他地方，我们要么必须定义一个更好的启发式算法，接受一个不完整的搜索算法(没有找到“I”)，要么构建一个更好的搜索算法(这就是我们将要做的)。但是在开始搜索之前，让我们先来看看八个谜题的一些启发。</p><p id="cf22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择:</p><ul class=""><li id="31d9" class="no np in jm b jn jo jr js jv nq jz nr kd ns kh nt nu nv nw bi translated">正确位置的牌的总和</li><li id="7e2c" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated">每个图块在正确位置之间的欧几里德距离之和</li><li id="87ae" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated">每个图块在正确位置之间的曼哈顿距离之和</li><li id="3b6e" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated">曼哈顿距离加反转惩罚搜索[2]</li></ul><p id="9b9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">右槽中的瓷砖数量有点误导，因为它没有考虑剩余的工作量。欧几里德距离公式考虑了对角线移动(一个点之外)的值为1.4，其中至少需要移动2次才能到达那里。曼哈顿距离是根据到达所需位置的水平和垂直步数计算的。有机会观察更复杂的情况，如两个并排的瓷砖在相反的位置(但如果它们被颠倒，将是正确的):</p><blockquote class="ng nh ni"><p id="e074" class="jk jl nj jm b jn jo jp jq jr js jt ju nk jw jx jy nl ka kb kc nm ke kf kg kh ig bi translated">通过为直接反转的瓦片添加惩罚，在信息量方面进行了额外的改进。这是由于这样一个事实，即颠倒的瓷砖更难处理，因为一个必须“绕过”另一个。当处理非平凡的情况时，这种启发式方法仅在曼哈顿距离上就提供了大约16%的信息增益。在提出的最困难的问题中(输出总结中每个问题的最后一种情况)，为找到最佳解决方案而检查的状态数量从10804减少到9176，增加了约18% [2]</p></blockquote><p id="a41d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了简单起见，让我们看看曼哈顿距离:</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="93ae" class="mz ln in mv b gy na nb l nc nd">const equals = x =&gt; y =&gt; <em class="nj">x </em>== y</span><span id="b3f0" class="mz ln in mv b gy ne nb l nc nd">// destination: is the goal state<br/>// current: is the current state<br/>const manhattanDistance = (destination) =&gt; (current) =&gt; {</span><span id="b315" class="mz ln in mv b gy ne nb l nc nd">    // for each tile in the current<br/>    return current.reduce((totalDistance, cVal, cIdx) =&gt; {</span><span id="8983" class="mz ln in mv b gy ne nb l nc nd">        // find where it should be in the destination<br/>        const dIdx = destination.findIndex(equals(cVal))</span><span id="df2f" class="mz ln in mv b gy ne nb l nc nd">        // determine row/col in destination<br/>        const dRow = <em class="nj">Math</em>.ceil((dIdx + 1) * 3 / 9)<br/>        const dCol = (dIdx % 3) + 1</span><span id="b3e1" class="mz ln in mv b gy ne nb l nc nd">        // determine row/col in current<br/>        const cRow = <em class="nj">Math</em>.ceil((cIdx + 1) * 3 / 9)<br/>        const cCol = (cIdx % 3) + 1</span><span id="760f" class="mz ln in mv b gy ne nb l nc nd">        // calculate the distance and add to to<br/>        const cellDistance = <br/>              <em class="nj">Math</em>.abs(dRow - cRow) + <br/>              <em class="nj">Math</em>.abs(dCol - cCol)</span><span id="f7fa" class="mz ln in mv b gy ne nb l nc nd">        return totalDistance + cellDistance</span><span id="b72d" class="mz ln in mv b gy ne nb l nc nd">    }, 0)<br/>}</span></pre><h2 id="3e8e" class="mz ln in bd lo oc od dn ls oe of dp lw jv og oh ma jz oi oj me kd ok ol mi om bi translated">递归最佳优先搜索</h2><p id="39c4" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">还记得如果“我”不在最短的预期路径上会发生什么吗？如果不进行修改，我们将无法实现目标——递归最佳优先搜索(RBFS)所做的是确定到达目标的前两条路径。它沿着最佳路径前进，同时跟踪下一个最佳路径。如果最佳路径找不到解决方案，或者看起来比下一个最佳路径更远，那么它会原路返回，在那个空间中穿行…这样RBFS就变成了一个完整的算法(如果存在的话，会找到解决方案):</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="e2f5" class="mz ln in mv b gy na nb l nc nd"><strong class="mv io">const </strong>rbfs_recursive = (node, heuristic, isGoal, hLimit) =&gt; {</span><span id="4334" class="mz ln in mv b gy ne nb l nc nd">      if (isGoal(node)) {<br/>        return Solution(node)<br/>      }</span><span id="93ce" class="mz ln in mv b gy ne nb l nc nd">      if (node.children.length == 0) {<br/>         return <em class="nj">SearchLimitExhausted</em>(<em class="nj">Number</em>.POSITIVE_INFINITY)<br/>      }</span><span id="d8a4" class="mz ln in mv b gy ne nb l nc nd">      for (child of node.children) {<br/>         child.h = heuristic(child)<br/>      }</span><span id="9e61" class="mz ln in mv b gy ne nb l nc nd">      while (true) {      </span><span id="8af1" class="mz ln in mv b gy ne nb l nc nd">          // out of all children, pick the two with the lowest "h"<br/>          const best = node.children[<br/>             indexOfSmallest(node.children)]</span><span id="0ee4" class="mz ln in mv b gy ne nb l nc nd">          const alt = node.children[<br/>             indexOfSmallest(node.children, best)]</span><span id="ff80" class="mz ln in mv b gy ne nb l nc nd"><strong class="mv io">          </strong>// if the heuristic on the current node is higher than<br/>          //   previous best (from the parent), we need to backtrack<strong class="mv io"><br/>          </strong>if (best.h &gt; hLimit) {<br/>             return <em class="nj">SearchLimitExhausted</em>(best.h)<br/>          }</span><span id="20b8" class="mz ln in mv b gy ne nb l nc nd">          // best alternate h is either the 2nd best sibling or<br/>          //  2nd best sibling of the parent<br/><strong class="mv io">         </strong>const bestAlternateH = min(hLimit, alt.h)</span><span id="868e" class="mz ln in mv b gy ne nb l nc nd">          // recurse down best path, knowing what the best Alt is<br/>          const result = rbfs_recursive(<br/>             best, heuristic, isGoal, bestAlternateH)<br/><br/>          if (result instanceof <em class="nj">Solution</em>) {<br/>             return result<br/>          } else if (result instanceof <em class="nj">SearchLimitExhausted</em>) {</span><span id="85f0" class="mz ln in mv b gy ne nb l nc nd">            // if we hit a limit (heuristic increases down the path)<br/>            //  then extract that value and update the h value of <br/>            //  this node (best) with the new information<br/>            best.h = result[extract]()<br/>          }<br/>     }<br/>}</span></pre><p id="41ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有几件事，当我们达到一个极限(超过上限启发式得分)时，我们需要向上传递，以便我们认为(或预期)具有最便宜路径的节点用已知信息更新其值。如果我们到达一片叶子，而这不是一个答案，我们需要用一个值(无穷大)来告诉上游节点这不是一个解决方案的路径。</p><p id="72fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">找到最好和第二好的兄弟姐妹并不太复杂:</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="78b3" class="mz ln in mv b gy na nb l nc nd">const indexOfSmallest = (array, notThisNode) =&gt; {</span><span id="775d" class="mz ln in mv b gy ne nb l nc nd">    // essentially reduce the array looking for the min,<br/>    //  the one gotcha is ignoring the "notThisNode"<br/>    return array.reduce(function (lowest, next, index) {</span><span id="678f" class="mz ln in mv b gy ne nb l nc nd">        if (notThisNode &amp;&amp; next != notThisNode) {<br/>            return lowest<br/>        }<br/>        else {<br/>            return next.h &lt; array[lowest].h ? index : lowest;<br/>        }</span><span id="2ea8" class="mz ln in mv b gy ne nb l nc nd">    }, {"h": <em class="nj">Number</em>.POSITIVE_INFINITY});<br/>}</span></pre><p id="9c7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提供的代码示例“足够接近”，以使解释尽可能简单。你将需要制定一些细节(例如，<code class="fe on oo op mv b">next != notThisNode</code>可能会或可能不会为你工作)，并添加一些支持功能。或者你可以在GitHub上挖掘我的代码，但那是我的沙箱。</p><h2 id="0824" class="mz ln in bd lo oc od dn ls oe of dp lw jv og oh ma jz oi oj me kd ok ol mi om bi translated">参考</h2><ol class=""><li id="d4c9" class="no np in jm b jn mk jr ml jv oq jz or kd os kh ot nu nv nw bi translated"><a class="ae ou" href="https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Iterative _ deeping _ depth-first _ search</a></li><li id="620c" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh ot nu nv nw bi translated"><a class="ae ou" href="https://web.mit.edu/6.034/wwwbob/EightPuzzle.pdf" rel="noopener ugc nofollow" target="_blank">https://web.mit.edu/6.034/wwwbob/EightPuzzle.pdf</a></li></ol><h2 id="5474" class="mz ln in bd lo oc od dn ls oe of dp lw jv og oh ma jz oi oj me kd ok ol mi om bi translated">密码</h2><ul class=""><li id="1ac0" class="no np in jm b jn mk jr ml jv oq jz or kd os kh nt nu nv nw bi translated"><a class="ae ou" href="https://github.com/tb01923/aima-js/blob/main/search/eight-puzzle/eight-puzzle.js" rel="noopener ugc nofollow" target="_blank">https://github . com/TB 01923/艾玛-js/blob/main/search/eight-puzzle/eight-puzzle . js</a></li><li id="1865" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated"><a class="ae ou" href="https://github.com/tb01923/aima-js/blob/main/search/known-deterministic-observable/informed/recursive-best-first-search.js" rel="noopener ugc nofollow" target="_blank">https://github . com/TB 01923/艾玛-js/blob/main/search/known-deterministic-observable/informed/recursive-best-first-search . js</a></li></ul><h2 id="28c7" class="mz ln in bd lo oc od dn ls oe of dp lw jv og oh ma jz oi oj me kd ok ol mi om bi translated">关于我</h2><div class="ki kj gp gr kk kl"><a href="https://www.linkedin.com/in/tb02118/" rel="noopener  ugc nofollow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">Todd Brown——副总裁&amp;创新和敏捷工程高级总监——Liberty…</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">Todd在软件行业有20多年的经验，专注于架构、安全和…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">www.linkedin.com</p></div></div><div class="ku l"><div class="ov l kw kx ky ku kz la kl"/></div></div></a></div><p id="a84f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ou" href="https://javascript.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nj">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>