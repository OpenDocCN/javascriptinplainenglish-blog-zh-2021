<html>
<head>
<title>What is an Abstract Syntax Tree (AST)?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是抽象语法树(AST)？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/abstract-syntax-tree-ast-f075b190e631?source=collection_archive---------12-----------------------#2021-01-08">https://javascript.plainenglish.io/abstract-syntax-tree-ast-f075b190e631?source=collection_archive---------12-----------------------#2021-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7600" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">深入探究ASTs，用三种不同的编程语言举例说明</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2455b7b29f8506e0ef6362b6a3cad996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvFA63LVBxtgqfbKkmcdsA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">AST for a simple Java class</figcaption></figure><p id="c44b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们编写的大部分代码在开发工作流程中的某个时候会变成一个<strong class="ku io">抽象语法树(AST) </strong>。通常AST被认为是编译器的一部分，但是有很多地方和用例可以使用它。虽然编译器设计书籍可能会区分语法和语义树表示，但下图是一个简单的模型。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lo"><img src="../Images/a3e81a5b2effb99ca75d5ff11cbe5342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kWRiwbG1t32tXGgM7zogw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Simplified compilation flow</figcaption></figure><h2 id="30d1" class="lp lq in bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">这是什么？</h2><p id="ce28" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">ASTs是用高级编程语言编写的源代码的树形表示。当一段代码在被转换成机器码或其他中间表示(IR)之前被编写时，它会经历以下过程</p><ul class=""><li id="bdd0" class="mn mo in ku b kv kw ky kz lb mp lf mq lj mr ln ms mt mu mv bi translated"><em class="mw">词法分析</em>是将字符流转化为记号的过程<em class="mw"> </em>，这些记号可用于语法分析。这通常在单个源文件上执行。</li><li id="cbfb" class="mn mo in ku b kv mx ky my lb mz lf na lj nb ln ms mt mu mv bi translated"><em class="mw">语法分析</em>是将令牌转换成数据结构(AST)的过程，该数据结构可用于执行各种分析和转换。</li><li id="1f74" class="mn mo in ku b kv mx ky my lb mz lf na lj nb ln ms mt mu mv bi translated"><em class="mw">代码生成</em>是对AST进行进一步优化并生成目标代码的步骤。对于TypeScript编译器，这可能是机器码、JVM字节码或JavaScript。</li></ul><p id="832f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看一个TypeScript中的例子。下面是一个简单的函数，让我们试着在AST中寻找相同的函数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/57bc98bba2f9468e482d5efc726d3f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlMue8Y7aP7YYUNUEwynTw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Simple function</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/5e654cd1ee3252412017b18f3f8e6c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zlp8XNZ66dEDZQcHz7A2Yg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">AST for the simple function</figcaption></figure><p id="61cd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">从截图中可以看出，源代码已经被解析，树型结构已经建立。这是通过使用TypeScript编译器API解析源文件来完成的(参见下图)。一旦构建了AST，就可以在其上编写转换，或者输出到另一种目标语言，或者实现横切关注点等。在下一节中，我们将研究一些ASTs的用例。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/0f25e0137d5bfa58ecdb279475a0489f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rjk8bRXpRBP1lA-8uPBvMw.png"/></div></div></figure></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><h2 id="500c" class="lp lq in bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">代码质量检查</h2><p id="c36d" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">我们用一个例子来理解这个。假设您想要对Java代码库执行离线分析，并识别出哪些地方有空的catch块(有一些代码分析工具，如<a class="ae nm" href="https://pmd.github.io/" rel="noopener ugc nofollow" target="_blank"> PMD </a>或<a class="ae nm" href="https://github.com/checkstyle/checkstyle" rel="noopener ugc nofollow" target="_blank"> Checkstyle </a>可以即时完成这项工作)。但是为了理解幕后发生的事情，让我们使用<a class="ae nm" href="https://javaparser.org/" rel="noopener ugc nofollow" target="_blank"> javaparser </a>库来做这件事。下面的代码解析一个Java源文件并构建一个AST，然后识别空的catch块。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3c04" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果有一个像下面这样的测试类，</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3e1e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们应该能够识别空的catch块并打印出行号。如果我们编写一个简单的main方法并运行它，您应该会在控制台中看到如下内容。(本文开头的图片是SimpleClass的点格式AST)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/b208b02a5e366b66da13b88c480eb74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMF3OjAFK6rHyxw1P6smsA.png"/></div></div></figure><h2 id="7305" class="lp lq in bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">代码转换</h2><p id="4370" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">Groovy是一种基于JVM的编程语言，它提供了一个很好的API来挂钩编译器生命周期并转换AST。在下面的例子中，我们将看到如何使用Groovy的编译时元编程能力。</p><p id="20cd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">假设您想要在一些POJO中公开一个方法，该方法将返回该类的所有属性及其数据类型<em class="mw">。</em>这可以通过使用Groovy的本地转换并创建一个可以在POJO上使用的注释来实现。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9298" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">要查看它的运行情况，让我们编写一个简单的POJO，</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/a05719466f9a37215866f1f31c3d91a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqs9NEWSYNahEMpUenpZcw.png"/></div></div></figure><p id="9102" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">并调用它，</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/9137ab48933eace3d60dc29c3d7b488c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2AhKs1pfLeKJqMHOhWiUQ.png"/></div></div></figure><p id="02f6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当执行时，您应该看到下面的内容，在这里您可以获得属性名及其类型。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/ac2c1280ff34894c089b35f18602811f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiJ3b2CE1bN-tnSwuo-wtg.png"/></div></div></figure><h2 id="c7fd" class="lp lq in bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">林挺</h2><blockquote class="ns nt nu"><p id="e7f7" class="ks kt mw ku b kv kw jo kx ky kz jr la nv lc ld le nw lg lh li nx lk ll lm ln ig bi translated"><strong class="ku io"> lint </strong>或<strong class="ku io"> linter </strong>，是一个<a class="ae nm" href="https://en.wikipedia.org/wiki/Static_program_analysis" rel="noopener ugc nofollow" target="_blank">静态代码分析</a>工具，用于标记编程错误、<a class="ae nm" href="https://en.wikipedia.org/wiki/Software_bug" rel="noopener ugc nofollow" target="_blank">bug</a>、风格错误和可疑构造。— <a class="ae nm" href="https://en.wikipedia.org/wiki/Lint_(software)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="33ec" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">JavaScript最流行的linters之一是<a class="ae nm" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>，它利用AST对JavaScript源代码进行检查。ESLint利用Espree解析源代码，然后在AST上应用规则。</p><p id="a428" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">运输工具</strong></p><p id="aa37" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">Transpilers做源到源的翻译编译。例如<a class="ae nm" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>是一个帮助我们在源代码中利用新的JavaScript语言特性的工具，但最终会为旧版本生成代码。这样做的原因可能是为了支持旧的浏览器等。Babel基本上遵循了前面提到的步骤，将源代码翻译成特定的语言版本。</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="141e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">总之，理解您所使用的编程语言的AST可能是开发人员工具包中的一个强大工具。还有更多AST有用的用例。</p><h2 id="9d2a" class="lp lq in bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">参考</h2><div class="ny nz gp gr oa ob"><a href="https://astexplorer.net/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">AST浏览器</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">在线AST浏览器。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">astexplorer.net</p></div></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://blog.scottlogic.com/2017/05/02/typescript-compiler-api-revisited.html" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">重新审视类型脚本编译器API</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">两年前，我写过关于TypeScript编译器API的文章。那项调查，以及围绕那篇博文的讨论…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">blog.scottlogic.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op km ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://basarat.gitbook.io/typescript/overview/ast" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">大西洋时间</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">SyntaxKind，它在AST中标识它的类型，以及它的，当实例化到…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">basarat.gitbook.io</p></div></div><div class="ok l"><div class="oq l om on oo ok op km ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://javaparser.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">JavaParser - Home</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">当选择开源技术时，知道你的选择会得到持续的回报是很重要的…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">javaparser.org</p></div></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://groovy-lang.org/metaprogramming.html#_code_generation_transformations" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">运行时和编译时元编程</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">这类转换包括AST转换，它有助于删除样板代码。这是典型的…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">groovy-lang.org</p></div></div></div></a></div></div></div>    
</body>
</html>