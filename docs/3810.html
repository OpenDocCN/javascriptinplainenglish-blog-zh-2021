<html>
<head>
<title>General Theory of Svelte Reactivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苗条反应性的一般理论</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/general-theory-of-svelte-reactivity-3e7ea51e0364?source=collection_archive---------3-----------------------#2021-07-31">https://javascript.plainenglish.io/general-theory-of-svelte-reactivity-3e7ea51e0364?source=collection_archive---------3-----------------------#2021-07-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/26eb9403abfb24507e2ae4b29cb39593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clq37fLu3BMKKzd8gixTFA.png"/></div></div></figure><p id="2c69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">苗条使增加组件的反应几乎毫不费力。它提供了一个易于使用的语法，抽象了很多复杂性。在这篇文章中，我们将通过几个例子来讨论一些你在苗条时可能会遇到的陷阱。我们不深入研究，但主要关注实用的技巧和指针。</p><p id="a936" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要想快速入门，我们就用Svelte团队提供的启动器吧。转到您的终端，运行下面的命令。打开你的浏览器，进入<code class="fe kt ku kv kw b"><a class="ae kx" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank">http://localhost:5000</a></code>，你应该会在屏幕上看到“HELLO WORLD”。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="9d7f" class="lg lh in kw b gy li lj l lk ll">npx degit <a class="ae kx" href="https://github.com/sveltejs/template" rel="noopener ugc nofollow" target="_blank">sveltejs/template</a> my-svelte-project<br/>cd my-svelte-project<br/>npm install<br/>npm run dev</span></pre><p id="b305" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，导航到<code class="fe kt ku kv kw b">src/App.svelte</code>并删除除了<code class="fe kt ku kv kw b">&lt;main&gt;</code>标签之外的所有内容。保存后，服务器应该会自动更新页面，您现在应该会看到一个空白页。现在，我们准备好了！</p><h1 id="8b2b" class="lm lh in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">默认情况下，分配的变量是被动的</h1><p id="3312" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">首先，让我们创建一个带有递增和递减控件的简单计数器。</p><p id="e499" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">src</code>目录中，创建一个名为<code class="fe kt ku kv kw b">components</code>的新目录，并在这个目录中创建一个名为<code class="fe kt ku kv kw b">Counter.svelte</code>的新文件。<code class="fe kt ku kv kw b">Counter.svelte</code>的代码如下所示。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3268" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将<code class="fe kt ku kv kw b">Counter</code>组件导入到<code class="fe kt ku kv kw b">App.svelte</code>并实例化它以查看结果。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="cd7d" class="lg lh in kw b gy li lj l lk ll">&lt;script&gt;<br/>  import Counter from './components/Counter.svelte';<br/>&lt;/script&gt;</span><span id="c48c" class="lg lh in kw b gy mq lj l lk ll">&lt;main&gt;<br/>  &lt;Counter /&gt;<br/>&lt;/main&gt;</span></pre><p id="7c84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它应该看起来像这样。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/f38ba1e5f3bf6be29dd84a5145d24049.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*9S_MQK_oxowG1QIkK0IZ8w.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Counter.svelte rendered on screen</figcaption></figure><p id="4125" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单击增量或减量按钮会立即导致更新。在底层，Svelte保持DOM与应用程序状态同步，并在变量的值改变时更新组件的值。</p><blockquote class="mw mx my"><p id="d4b6" class="jv jw mz jx b jy jz ka kb kc kd ke kf na kh ki kj nb kl km kn nc kp kq kr ks ig bi translated">通常，对于赋值变量，您不需要任何额外的设置来使它们反应。直接更改变量值将自动导致更新。值得注意的是，这些必须是顶级变量(想想那些特定的瘦组件的“全局”范围的变量)。</p></blockquote><h1 id="86a6" class="lm lh in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结合反应性</h1><p id="6eda" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">在前面的示例中，我们通过使用click事件来更改变量的值，从而触发了一次更新。同样的技术可以用来触发输入元素的更新。然而，Svelte提供了一个更符合习惯的选择。对于大多数输入元素，我们可以使用Svelte的<code class="fe kt ku kv kw b">bind</code>指令将输入的值绑定到变量。每当输入值发生变化时，这有效地更新了变量的状态。</p><p id="8e88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个简单的例子。在<code class="fe kt ku kv kw b">src/components</code>中创建名为<code class="fe kt ku kv kw b">Input.svelte</code>的新组件。该组件的代码片段可以在下面找到。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ee64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似于我们如何实现<strong class="jx io">计数器</strong>组件，在<code class="fe kt ku kv kw b">App.svelte</code>中导入<strong class="jx io">输入</strong>组件并实例化它。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="c033" class="lg lh in kw b gy li lj l lk ll">&lt;script&gt;<br/>  import Counter from './components/Counter.svelte';<br/>  import Input from './components/Input.svelte';<br/>&lt;/script&gt;</span><span id="c9fb" class="lg lh in kw b gy mq lj l lk ll">&lt;main&gt;<em class="mz"><br/>  </em>&lt;Input /&gt;<br/>&lt;/main&gt;</span></pre><p id="8e42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">输出应该如下所示。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f52065e25a23b5bb44b4484d5612f8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*8vZMJrzoukXTYNEVAj3gNA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Input.svelte rendered on screen</figcaption></figure><p id="66d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经注意到，我们还添加了一些操作<code class="fe kt ku kv kw b">textValue</code>的字符串方法。每当<code class="fe kt ku kv kw b">textValue</code>的值改变时，作用于它的方法也会被调用。</p><blockquote class="mw mx my"><p id="6030" class="jv jw mz jx b jy jz ka kb kc kd ke kf na kh ki kj nb kl km kn nc kp kq kr ks ig bi translated">当处理输入元素时，Svelte的<code class="fe kt ku kv kw b">bind</code>指令使得将变量绑定到输入值变得很容易。对输入的任何更改都会自动更新变量，反之亦然。</p></blockquote><p id="2de2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为下一节的介绍，让我们打破<strong class="jx io">输入</strong>组件。将以下更改添加到<strong class="jx io"> Input.svelte </strong>中。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="9dd6" class="lg lh in kw b gy li lj l lk ll">// Within the &lt;script&gt; section add the following.</span><span id="542b" class="lg lh in kw b gy mq lj l lk ll">let charCount = textValue.length;</span><span id="1a87" class="lg lh in kw b gy mq lj l lk ll">// Replace Characters: {textValue.length} with</span><span id="ca9b" class="lg lh in kw b gy mq lj l lk ll">Characters: {charCount}</span></pre><p id="3a86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">再次测试应用程序。请注意，字符数不再更新。怎么回事？<code class="fe kt ku kv kw b">charCount</code>不是应该自动更新到等于<code class="fe kt ku kv kw b">textValue</code>的长度吗？当把一个变量赋给另一个变量时，反应性似乎不会传播。不过不要担心，Svelte给了我们一种方法来实现这一点，我们将在下一节讨论这一点。</p><h1 id="cab6" class="lm lh in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">被动声明</h1><p id="7337" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">在一个坚果壳中，<strong class="jx io">反应声明</strong>，允许你声明变量，当一个值或它们引用的另一个变量改变时，这些变量将自动更新。</p><p id="6e3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们通过修复前面的坏例子来看看这一点。简单的把<code class="fe kt ku kv kw b">let</code>改成<code class="fe kt ku kv kw b">$:</code>，这是声明一个反应变量的语句。再次测试组件以检查其是否工作。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="63fd" class="lg lh in kw b gy li lj l lk ll">$: charCount = textValue.length;</span></pre><p id="0687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">$:</code>是由Svelte提供的一个抽象，使得实现值和逻辑的自动重新计算更加容易。因为Svelte编译成JavaScript，所以性能几乎不会下降。</p><p id="694f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">反应声明</strong>在处理依赖于其他变量的变量的计算时非常有用。为了说明这一点，让我们实现一个简单的计算器，它基于一组数字计算<em class="mz">相对标准偏差</em>。<em class="mz">相对标准偏差</em>通常用于测量数据的分散或扩散。它基本上是标准差(sd)与平均值(mean)的比值；你可以在这里找到更多信息<a class="ae kx" href="https://www.khanacademy.org/math/statistics-probability/summarizing-quantitative-data/variance-standard-deviation-sample/a/population-and-sample-standard-deviation-review" rel="noopener ugc nofollow" target="_blank"/>。<em class="mz">标准差(sd) </em>和<em class="mz">相对标准差(rsd) </em>的公式如下所示。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/88b76ce367063d5facb82f3f41eb4876.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/1*u6gNC3QMP3BesjlBaSIGJg.gif"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">standard deviation formula</figcaption></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0cf3ea31dd501e84e0e9d1509bb9ef8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:192/1*3oEieBR2pxDSIX_dqFiyIg.gif"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">relative standard deviation formula</figcaption></figure><p id="d190" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">src/components</code>中创建一个名为<code class="fe kt ku kv kw b">RelativeStandardDeviation.svelte</code>的新组件，并复制下面的代码。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6317" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完成后，将其导入<code class="fe kt ku kv kw b">App.svelte</code>并实例化。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="f907" class="lg lh in kw b gy li lj l lk ll">&lt;script&gt;<br/>  import RelativeStandardDeviation from './components/RelativeStandardDeviation.svelte';<br/>&lt;/script&gt;</span><span id="ee4f" class="lg lh in kw b gy mq lj l lk ll">&lt;main&gt;<br/>  &lt;RelativeStandardDeviation /&gt;<br/>&lt;/main&gt;</span></pre><p id="74ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">输出应该如下所示。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/5df5dd8e5d65a6e169b7d06d4b74f425.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*asHmBNr9LnDQkSDEv6Aw1w.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">RelativeStandardDeviation.svelte rendered on screen</figcaption></figure><p id="8eef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是时候简单解释一下了。我们创建两个函数，一个用于计算平均值<em class="mz">和一个用于计算标准偏差</em>。接下来，我们创建一个文本输入，它接受一串逗号分隔的数字。因为输入的值是一个字符串，我们需要把它转换成一个数字数组。我们通过将字符串拆分成一个数组并映射到每个值上，将每个值转换成一个数字来实现这一点。这个数组是用来执行计算的。可以通过限制输入只接受逗号分隔的数字来改进该组件，但这超出了本例的范围。</p><p id="74ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们实际看到反应性声明的部分如下所示。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="c938" class="lg lh in kw b gy li lj l lk ll">$: mean = getMean(numericArray);  <br/>$: stdev = getStandardDeviation(numericArray);  <br/>$: relstdev = stdev / mean;</span></pre><p id="3a91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">mean</code>和<code class="fe kt ku kv kw b">stdev</code>都依赖于<code class="fe kt ku kv kw b">numericArray</code>，T5是从字符串转换成数字数组的数字输入。每当<code class="fe kt ku kv kw b">numericArray</code>改变时，<code class="fe kt ku kv kw b">mean</code>和<code class="fe kt ku kv kw b">stdev</code>会自动重新计算。此外，因为<code class="fe kt ku kv kw b">relstdev</code>也依赖于<code class="fe kt ku kv kw b">mean</code>和<code class="fe kt ku kv kw b">stdev</code>，其值也自动更新。</p><blockquote class="mw mx my"><p id="749d" class="jv jw mz jx b jy jz ka kb kc kd ke kf na kh ki kj nb kl km kn nc kp kq kr ks ig bi translated">当您需要使声明具有反应性，并且每次它引用的变量值改变时都需要更新它的值时，请使用<code class="fe kt ku kv kw b">$:</code>。</p></blockquote><p id="e4b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在前面的段落中，我明确说明了“声明”而不是“变量”。这是因为<strong class="jx io">反应声明</strong>不仅仅处理变量，它们也处理语句。如果需要，您可以激活<code class="fe kt ku kv kw b">console.log</code>或<code class="fe kt ku kv kw b">if</code>模块。在这方面，它们比<code class="fe kt ku kv kw b">let</code>更通用，尽管<code class="fe kt ku kv kw b">let</code>也给了你某种形式的反应能力。</p><p id="1ee1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果是这样的话，那么什么时候应该使用<code class="fe kt ku kv kw b">let</code>，什么时候应该使用<strong class="jx io">反应声明</strong>？以我个人的经验，你大概可以用<strong class="jx io">反应式声明</strong>代替<code class="fe kt ku kv kw b">let</code>。我经常发现自己从<code class="fe kt ku kv kw b">let</code>开始，如果那不起作用，我就转而使用<strong class="jx io">反应声明</strong>。</p><h1 id="136e" class="lm lh in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">增加阵列的反应性</h1><p id="852d" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">向阵列添加反应性可能与我们到目前为止讨论的略有不同。让我们创建一个简单的例子来说明这一点。</p><p id="2b56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">src/components</code>中创建一个名为<code class="fe kt ku kv kw b">NumberArray.svelte</code>的新组件，复制下面的代码。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2da1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完成后，将其导入到<code class="fe kt ku kv kw b">App.svelte</code>并实例化。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="4941" class="lg lh in kw b gy li lj l lk ll">&lt;script&gt;<br/>  import NumberArray from './components/NumberArray.svelte';&lt;/script&gt;</span><span id="83f2" class="lg lh in kw b gy mq lj l lk ll">&lt;main&gt;<br/>    &lt;NumberArray /&gt;<br/>&lt;/main&gt;</span></pre><p id="dd14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果应该是这样的。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ba23bc6114458f41799c1c9105ca7a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*QVpVPZcoP5EdfcxVgzC-Vw.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">NumberArray.svelte rendered on screen</figcaption></figure><p id="c8d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">试着点击“添加一个数字”按钮，观察它没有做任何事情；至少屏幕上没有。</p><p id="6886" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据文档，Svelte的反应是由赋值触发的，这意味着使用像<code class="fe kt ku kv kw b">push</code>或<code class="fe kt ku kv kw b">pop</code>这样的数组方法不会导致自动更新，即使它们在内部改变了数据。您可以通过检查控制台来验证这一点，以查看阵列是否确实被填充。当组件的底层数组数据发生变化时，有几种方法可以使组件更新，下面我们将讨论其中的一些方法。</p><p id="4380" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">重新分配给自己</strong></p><p id="3210" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一种方法是将数组重新分配给它自己，尽管这种方法有些多余。编辑前面的示例，使其看起来像下面的代码。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3e23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前所述，反应性是由分配触发的，因此基本上是将数组重新分配给它自己来更新组件。</p><p id="2615" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用扩展运算符</strong></p><p id="f8cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以使用spread操作符(…)来实现同样的目的，但方式更为惯用。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7e2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">试一试，你会得到和之前一样的结果。</p><p id="8a42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">阵列的反应性也遵循一般规则，即引用的变量必须是顶级变量。换句话说，我们在更新状态的函数调用中触发了副作用。有太多的副作用会使代码难以维护。幸运的是，Svelte通过对每个组件的状态进行限定，使得这一点易于管理，如果您需要共享状态，您可以随时使用<code class="fe kt ku kv kw b">stores</code>。</p><p id="9062" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们结束这一部分之前，我想讨论一个你可能会遇到的常见的footgun。在某些情况下，您可能希望将参数传递给用于更新状态的函数。您可以通过在匿名函数中调用update函数来实现这一点。让我们用当前的例子来证明这一点。</p><p id="00d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">src/components</code>中创建一个名为<code class="fe kt ku kv kw b">NumberArrayAsParameter.svelte</code>的新组件，并复制下面的代码。将此导入到<code class="fe kt ku kv kw b">App.svelte</code>并实例化组件。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c809" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果应该类似于前面的例子。您可能希望这样做，查看浏览器控制台，可以看到我们确实在更新阵列。那么，为什么我们没有看到更新呢？</p><p id="5450" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript中，传递给函数的数组是通过“引用”来传递的，更准确地说，它们是作为“引用的副本”来传递的，这一微小的区别造成了巨大的差异。因为我们得到了数组的一个副本，所以我们得到了值，并可以在函数范围内随意改变它。但是，这不会影响原始数组，因为原始数组保持不变。</p><p id="c4d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过在功能块中包含重新分配来轻松解决这个问题。编辑<code class="fe kt ku kv kw b">addNumber</code>函数，看起来像下面的代码。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="0af0" class="lg lh in kw b gy li lj l lk ll">const addNumber = (<em class="mz">arr</em>) =&gt; {<br/>  arr.push(arr.length + 1);<br/>  console.log(arr);<br/>  numbers = numbers;<br/>}</span></pre><p id="8343" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您遇到这类问题时，这种问题可能在您跟踪大量状态时发生，一种简单的故障排除方法是添加一个反应性的<code class="fe kt ku kv kw b">console.log</code>语句来跟踪对原始数组的更改。对于我们当前的例子，您可以尝试将它添加到数组声明的正下方。只有当<code class="fe kt ku kv kw b">numbers</code>的值改变时，该函数才会被调用。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="4585" class="lg lh in kw b gy li lj l lk ll">$: console.log(numbers);</span></pre><p id="7141" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">重新渲染组件</strong></p><p id="7a0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种强制数组更新的方法是重新渲染数组。实现这一点的最简单的方法之一是暂时从DOM中删除组件，然后在以后的某个时间返回它。在下面的例子中，我们添加了一个名为<code class="fe kt ku kv kw b">isVisible</code>的布尔值，它在短暂的延迟后从<code class="fe kt ku kv kw b">false</code>切换回<code class="fe kt ku kv kw b">true</code>。这足以使组件使用新值重新呈现。</p><p id="ce4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了测试它，在<code class="fe kt ku kv kw b">src</code>中创建一个名为<code class="fe kt ku kv kw b">NumberArrayRerender.svelte</code>的新组件，并复制下面的代码。将组件导入到<code class="fe kt ku kv kw b">App.svelte</code>，并实例化它以查看输出。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b2ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它应该看起来像这样。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/892f54620180030feb13e09fffafac10.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*X5FTXwScf4Xnk743VU4ZKg.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">NumberArrayRerender.svelte rendered on screen</figcaption></figure><p id="760f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您不想在每次点击时自动更新状态，并希望推迟更新，这可能会很有用。</p><blockquote class="mw mx my"><p id="b2b9" class="jv jw mz jx b jy jz ka kb kc kd ke kf na kh ki kj nb kl km kn nc kp kq kr ks ig bi translated">综上所述，在处理数组(或对象)时，直接对数组进行变异会改变值，但不会更新组件。要触发更新，您需要执行分配/重新分配。</p></blockquote><h1 id="ca97" class="lm lh in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">反应越快，责任越大</h1><p id="7936" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">苗条使增加组件的反应变得非常简单。因为它有时太容易了，很容易忘记基础知识并遇到问题。在这篇文章中，我们讨论了一些在苗条身材中实现反应的方法，以及如何推理它们。虽然我们在这篇文章中讨论了很多话题，但主要思想可以总结为下面的陈述。</p><blockquote class="mw mx my"><p id="ffd7" class="jv jw mz jx b jy jz ka kb kc kd ke kf na kh ki kj nb kl km kn nc kp kq kr ks ig bi translated">顶级变量的赋值和突变是理解Svelte反应模型的核心。为了触发更新，您可以直接更改顶级变量的值，或者在数组或对象的情况下，在更改它们的值后执行重新分配。Svelte还提供了其他易于使用的抽象，如<strong class="jx io"> bind </strong> <strong class="jx io"> directive </strong>和<strong class="jx io"> reactive declarations </strong>，为您同步组件和应用程序状态。</p></blockquote><p id="c043" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读，并希望您在您的苗条之旅中度过愉快的时光。</p><p id="e34f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在https://github.com/kinxiel/general_theory_svelte_reactivity<a class="ae kx" href="https://github.com/kinxiel/general_theory_svelte_reactivity" rel="noopener ugc nofollow" target="_blank">找到例子的源代码。</a></p><p id="42e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mz">更多内容请看</em><a class="ae kx" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>