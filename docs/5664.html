<html>
<head>
<title>3 Ways To Write Function Overloads With JSDoc &amp; TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JSDoc &amp; TypeScript编写函数重载的3种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-ways-to-write-function-overloads-with-jsdoc-typescript-e57f46f3286c?source=collection_archive---------5-----------------------#2021-11-27">https://javascript.plainenglish.io/3-ways-to-write-function-overloads-with-jsdoc-typescript-e57f46f3286c?source=collection_archive---------5-----------------------#2021-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/689ecace3745655ffa612c1c0923c621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kff3qN6wChzSl1xm.jpg"/></div></div></figure><p id="34fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢<a class="ae kw" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>，但是我更喜欢用<a class="ae kw" href="https://jsdoc.app/" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>语法来编写它。如果你读过我的任何一篇<a class="ae kw" href="https://austingil.com/category/javascript/" rel="noopener ugc nofollow" target="_blank"> JavaScript文章</a>，尤其是<a class="ae kw" href="https://austingil.com/typescript-the-easy-way/" rel="noopener ugc nofollow" target="_blank">以简单的方式开始使用TypeScript</a>，这应该是显而易见的。</p><p id="2393" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我还没有遇到过无法使用JSDoc实现与TypeScript相同的功能的情况。</p><p id="e374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">直到我需要实现JavaScript <a class="ae kw" href="https://docs.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-160" rel="noopener ugc nofollow" target="_blank">函数重载</a>的类型定义时，我才开始认真地质疑这一点。</p><h1 id="69c4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是函数重载？</h1><p id="cd7b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果你已经知道，可以跳过这一步，但是如果你不知道，让我们先了解什么是函数重载。</p><p id="1081" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数重载是指为了获取不同的功能而多次定义同一个函数。</p><p id="6953" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个人为的例子。假设我们想要创建一个名为<code class="fe ma mb mc md b">double</code>的函数。它需要一个参数。如果参数是一个数字，它将乘以2并返回结果。如果它是一个字符串，它会将该字符串连接到自身并返回它。</p><p id="f48a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个愚蠢的例子，但它可能看起来像这样:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f445" class="mm ky iq md b gy mn mo l mp mq">function double(input) {<br/>  return input * 2<br/>}<br/>function double(input) {<br/>  return input + input<br/>}</span></pre><p id="6893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">漂亮！</p><p id="021b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有一个问题。JavaScript不支持函数重载。相反，我们必须这样做:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ec22" class="mm ky iq md b gy mn mo l mp mq">function double(input) {<br/>  if (typeof input === 'number') {<br/>    return input * 2<br/>  }<br/>  return input + input<br/>}</span></pre><h1 id="b90c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">天真的解决方法</h1><p id="144b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果我们要写这个函数的类型定义，就有点复杂了。我们知道输入可以是一个<code class="fe ma mb mc md b">string</code>或者一个<code class="fe ma mb mc md b">number</code>，输出也差不多。</p><p id="65b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以用一个<a class="ae kw" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types" rel="noopener ugc nofollow" target="_blank">“联合”类型</a>来完成。联合允许我们将类型定义为“这个”或“那个”。在我们的例子中，不是一辆<code class="fe ma mb mc md b">string</code>就是一辆<code class="fe ma mb mc md b">number</code>。</p><p id="b9e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们将使用JSDoc的and关键字将输入和输出分配给一个<code class="fe ma mb mc md b">string</code>和<code class="fe ma mb mc md b">number</code>的并集。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9d6e" class="mm ky iq md b gy mn mo l mp mq">/**<br/> * @param {string | number} input <br/> * @returns {string | number}<br/> */<br/>function double(input) {<br/>  if (typeof input === 'number') {<br/>    return input * 2<br/>  }<br/>  return input + input<br/>}</span></pre><p id="de1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的问题是，无论如何，当我们调用我们的函数时，我们总是会得到一个联合。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/2e9df265a1977bdb4742a122845f6f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gZv9Nmm-6n1E040u.png"/></div></div></figure><p id="f22e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们真正想要的是根据输入的内容返回一个特定的类型。这就是函数重载的由来。</p><h1 id="a0f7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在JSDoc中定义函数重载</h1><p id="a2bb" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">TypeScript已经有了专用于函数重载的<a class="ae kw" href="https://www.tutorialsteacher.com/typescript/function-overloading" rel="noopener ugc nofollow" target="_blank">文档。在他们的例子中，他们展示了如何记录一个简单的函数:</a></p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0357" class="mm ky iq md b gy mn mo l mp mq">function add(a:string, b:string):string;<br/><br/>function add(a:number, b:number): number;<br/><br/>function add(a: any, b:any): any {<br/>  return a + b;<br/>}<br/><br/>add("Hello ", "Steve"); // returns "Hello Steve" <br/>add(10, 20); // returns 30</span></pre><p id="9eec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意同一个函数是如何被定义三次的。两次用于类型定义，一次用于功能。</p><p id="5b32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，JSDoc却不是这样。</p><p id="0ab1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过大量的搜索，我终于找到了一个似乎足够好的解决方案。我们可以定义一个变量，它的值是一个匿名函数。就在这个变量定义之上，我们可以使用JSDocs关键字来定义这个变量的类型，在这个类型定义中，我们可以描述我们的函数重载。</p><p id="de0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们想要描述两个箭头函数。一个接受类型为<code class="fe ma mb mc md b">number</code>的输入，其返回类型为<code class="fe ma mb mc md b">number</code>，一个接受类型为<code class="fe ma mb mc md b">string</code>的输入，其返回类型为<code class="fe ma mb mc md b">string</code>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="14b4" class="mm ky iq md b gy mn mo l mp mq">/**<br/> * @type {{<br/> * (input: number) =&gt; number;<br/> * (input: string) =&gt; string;<br/> * }}<br/> */<br/>const double = (input) =&gt; {<br/>  if (typeof input === 'number') {<br/>    return input * 2<br/>  }<br/>  return input + input<br/>}</span></pre><p id="f340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的例子使用了一个<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>。这可能不适合关注<a class="ae kw" href="https://www.w3schools.com/js/js_scope.asp" rel="noopener ugc nofollow" target="_blank">范围</a>的场景。幸运的是，我们可以用一个<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function" rel="noopener ugc nofollow" target="_blank">函数表达式</a>完成同样的工作:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="971d" class="mm ky iq md b gy mn mo l mp mq">/**<br/> * @type {{<br/> * (input:number) =&gt; number;<br/> * (input:string) =&gt; string;<br/> * }}<br/> */<br/>const double = function(input) {<br/>  if (typeof input === 'number') {<br/>    return input * 2<br/>  }<br/>  return input + input<br/>}</span></pre><p id="5db3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，根据输入是数字还是字符串，我们将看到函数的不同类型定义。</p><p id="caf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们的输入是一个数字时，我们函数的类型定义显示它返回一个数字。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/c670bd3933a36ec33b0073e739daa76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UsUSsfhuHCs9x2tt.png"/></div></div></figure><p id="c94d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们的输入是一个字符串时，我们的函数的类型定义显示它返回一个字符串。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/21cd0ce440663ca52d2220177bfb6981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rum_8ug5PaX-L_Rj.png"/></div></div></figure><p id="b2b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更重要的是，我们得到了变量类型定义的预期结果。当输入是一个数字时，我们的变量是一个数字。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/ae2d05d9b95a2643586ff2109cf58550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/0*WGu8aFGrXIo0uTO9.png"/></div></figure><p id="d893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当输入是一个字符串时，我们的变量是一个字符串。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9bfbe32dea1dfc8bf61f509f1fcac4ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/0*6fVG0ow26uDhzyWq.png"/></div></figure><p id="d145" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义函数重载的语法有点奇怪，但是在实践中足够好。我发现的唯一警告是，它依赖于将函数赋给变量。它不适用于<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function" rel="noopener ugc nofollow" target="_blank">函数声明</a>(即<code class="fe ma mb mc md b">function double(input) { /* ... */ }</code>)。</p><p id="8419" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老实说，我想不出你<strong class="ka ir">必须</strong>使用函数声明而不能使用函数表达式的场景，但是如果你真的需要一个解决方案，有一个变通办法。</p><p id="4c02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript还提供了<a class="ae kw" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>，您可以将这些泛型与<a class="ae kw" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">条件类型</a>相结合，以确定输入类型，并根据输入内容有条件地返回特定类型。多亏了关键字<code class="fe ma mb mc md b">@template</code>(没有很好的文档记录)，所有这些甚至可以与JSDoc一起工作。</p><p id="011a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将它应用到我们上面的例子中会是这样的:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5d01" class="mm ky iq md b gy mn mo l mp mq">/**<br/> * @template numOrStr<br/> * @param {numOrStr} input<br/> * @returns {numOrStr extends number ? number : string}<br/> */<br/>function double(input) {<br/>  if (typeof input === 'number') {<br/>    return input * 2<br/>  }<br/>  return input + input<br/>}</span></pre><p id="8d7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将泛型定义为<code class="fe ma mb mc md b">numOrString</code>，将其作为输入类型，然后在返回类型中，我们检查输入类型是否扩展了数字类型。如果是，返回值是一个数字类型。如果不是，就是字符串类型。</p><h1 id="9322" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关闭</h1><p id="40de" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">TypeScript很棒，JSDoc也很棒，但是偶尔复杂事物的文档很稀疏。</p><p id="d5cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我写这篇文章是因为我确信我将来需要寻找如何做这件事，我不想再经历整个寻宝过程。相反，它可以生活在这里的一个地方，也许可以帮助像你这样的人。</p><p id="f059" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们讨论了许多复杂的类型脚本，比如联合、重载、泛型和动态类型。我希望我能够清楚地解释它们。如果你是TypeScript新手，我建议你去读一下<a class="ae kw" href="https://austingil.com/typescript-the-easy-way/" rel="noopener ugc nofollow" target="_blank">我的初学者指南</a>。</p><p id="e5c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常感谢您的阅读。如果你喜欢这篇文章，<a class="ae kw" href="https://twitter.com/share?via=Stegosource" rel="noopener ugc nofollow" target="_blank">请分享它</a>，如果你想知道我何时发表更多文章，<a class="ae kw" href="https://austingil.com/newsletter/" rel="noopener ugc nofollow" target="_blank">注册我的简讯</a>或<a class="ae kw" href="https://twitter.com/Stegosource" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a>。干杯！</p><p id="f7eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mv">原载于</em><a class="ae kw" href="https://austingil.com/typescript-function-overloads-with-jsdoc/" rel="noopener ugc nofollow" target="_blank"><em class="mv">austingil.com</em></a><em class="mv">。</em></p></div></div>    
</body>
</html>