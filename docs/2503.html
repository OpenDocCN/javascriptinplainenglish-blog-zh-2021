<html>
<head>
<title>Programming Principles Every Programmer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个程序员都应该知道的编程原则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/programming-principles-every-programmer-should-know-65d768a31ef7?source=collection_archive---------8-----------------------#2021-05-23">https://javascript.plainenglish.io/programming-principles-every-programmer-should-know-65d768a31ef7?source=collection_archive---------8-----------------------#2021-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3301" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">因为这将在未来拯救你</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/01cacf777fc7524352e52d7df35eb34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1d4A1-g7CV4a-QOJ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@charlesdeluvio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Charles Deluvio</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="57b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要成为更好的程序员，没有什么秘密窍门或秘密公式。相反，每个程序员都有自己的原则来保持代码的整洁和可读性。</p><p id="8429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，并不是所有的程序员都遵循这些原则，尤其是那些新程序员，他们基本上只想学习如何逐字逐句地编程，甚至不去研究那些肯定会变得得心应手的编程实践。</p><p id="1d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看你可以学习的最有用的编程原则。</p><h1 id="d516" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.接吻——保持简单，笨蛋</h1><p id="8fee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这一原则提倡简单，不幸的是并不经常得到尊重。相反，在使用最新技术和/或语言框架的借口下，代码往往是不必要的复杂。</p><p id="20ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于不同的原因，例如，当我们处于软件的alpha测试阶段时，我们重新编写代码来处理数百个并发连接或大型数据流。</p><p id="b724" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尊重接吻原则意味着总是试图找到一个给定问题的最简单的解决方案。退出重新发明轮子或使用外部库来做简单的事情。</p><p id="9ec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，KISS原则希望你用简单的架构产生简单的代码。</p><h2 id="7a14" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">为什么这很重要？</h2><p id="9cf9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">很简单，因为人类无法同时处理他头脑中太多复杂的事情，此外，有人会跟在你后面修改你的代码，他会说谢谢你。</p><p id="e6a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">复杂的代码会产生错误，给维护带来困难。另一方面，简单的代码通常易于理解和维护，因此容易发现bug。</p><h1 id="5d17" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.YAGNI——你不会需要它的</h1><p id="e33a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这一原则与KISS原则一致:它指出除非你需要，否则不应该给软件添加功能。添加新功能包括文档、测试和与软件的其余部分接口。对于我们现在不需要的东西来说，这是一个很大的工作量！</p><p id="2e5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一原则在项目开始时尤其重要，因为软件架构在创建的第一阶段可能会快速改变几次。</p><h2 id="c71a" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">结果</h2><p id="9423" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">特性越多，架构中的每一个变化就有越多的代码需要返工，这使得开发变得更加缓慢。</p><p id="0661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，在一个项目的开始，我们保持灵活性，并快速编码，以了解“我们要去哪里”一旦我们大致了解了最终代码应该是什么样子，软件架构就需要什么。我们可以多问自己一点，花时间做一个干净的架构和TDD。</p><h1 id="eb0e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.不要重复自己的话</h1><p id="6ba2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你的代码重复出现，你绝对要考虑它。否则，您可以肯定，在应该保持不变的代码片段之间，您将会有时间不同步。</p><h2 id="3cc4" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">结果</h2><p id="0ad2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您在一个部分修复了一个bug，那么也必须在代码重复的其他地方修复它，这意味着两倍的工作量，甚至N倍的工作量，这取决于代码重复的次数N！</p><p id="4422" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将最终在一个地方得到错误修复，而不是在其他地方。它不仅消耗更多的资源来同时在几个地方进行纠正，而且最重要的是，它为您认为已经修复的冗余错误打开了大门，但在某些特定情况下，这些错误可能会回来，特别是当尚未修复的重复代码正在运行时。</p><p id="c2c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该只需要修复一个地方的错误。否则，您必须检查您的代码并将其分解。这也可能是一个软件架构问题，在这种情况下，您必须审查架构，以分解它可能是什么。</p><p id="4020" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你因为某些原因不能考虑代码，那么在软件执行之前，将代码的复制委托给一个脚本或一个自动程序，它将在你的工作流程中运行。这样，您可以确保代码始终保持同步。请注意，这种解决方案并不理想，因为它涉及到自动脚本的维护成本和更复杂的工作流。</p><h1 id="63aa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.测试驱动开发</h1><p id="92fa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">更严重的是，测试驱动开发是一个好的实践，但是在商业环境中不容易实现。</p><p id="58d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TDD的原则是在编写功能代码之前创建单元测试。你编码了一个测试，它没有通过(通常，你还没有编码功能)。然后，编写必要的代码让它通过并重新开始。</p><h2 id="efd7" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">几个优点</h2><ul class=""><li id="83e4" class="nb nc iq ky b kz mk lc ml lf nd lj ne ln nf lr ng nh ni nj bi translated">它迫使你从规范的角度去思考:也就是说，当这种或那种特殊情况出现时，我的功能应该做什么？这产生了处理更多特殊情况的更健壮的代码。</li><li id="8db7" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">它迫使你编写可测试的代码，也就是说，设计成可以应用单元测试。所以你对你的代码更有信心，你也可以更容易地在其他软件中重用它。</li><li id="189c" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">您的代码马上就有了有效的单元测试。因此，你的测试覆盖率将是100%。</li></ul><p id="9559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:拥有100%的测试覆盖率并不能保证代码没有错误。它只是确保测试人员至少执行你所有的源代码一次。</p><p id="1676" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是在短期内做TDD比在没有安全网的牛仔模式下编码要花更长的时间。但是从长远来看，节省了很多时间。</p><p id="d9cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了单元测试，你就能确保同样的错误不会出现两次。这样一来，你以后的维护和bug修复时间会大大减少。</p><p id="523b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，你对你发布的软件新版本的信心会比没有测试时高得多(在发布期间避免心血管疾病和焦虑是有好处的！).</p><p id="7d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最大的问题是，即使你明确表示这些测试将在未来节省时间，也很难让一个必须在上游投入额外时间来编写测试的经理接受这个建议。</p><p id="bd57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正确的编码方式是进行TDD。不幸的是，在实践中，投入到短期测试中的时间对于大多数项目的经理来说都是太沉重的负担。此外，在商业中，要遵守的截止日期通常优先考虑软件编程工作的整洁性。</p><p id="381e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很可悲，但事实就是如此。</p><p id="62a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="np">更多内容看</em><a class="ae kv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="np">plain English . io</em></strong></a></p></div></div>    
</body>
</html>