<html>
<head>
<title>How to Implement JavaScript Memoization from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从头开始实现JavaScript记忆化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implement-memoization-method-from-scratch-2800ce6bc257?source=collection_archive---------16-----------------------#2021-05-20">https://javascript.plainenglish.io/implement-memoization-method-from-scratch-2800ce6bc257?source=collection_archive---------16-----------------------#2021-05-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1ca83e4c9b7b920afb351ec74e2d86d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UwY0pCvfvXVGoqMc"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@piscesdave?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">david hebert</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8d23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们谈论记忆化之前，让我们先了解计算机中的值是如何转换的。</p><p id="44b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个将两个数相加的函数。如果我们有一个程序用相同的输入调用这个函数50次，我们将会做很多不必要的计算。</p><p id="2c8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">进入记忆化。</p><p id="ae36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记忆化是一种优化技术，用于通过存储函数调用的结果来加速计算机程序，而无需重新计算(假设进行函数调用的参数和变量是相同的)。</p><p id="d1b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面我们来看看:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="42e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意,“计算结果”仅在结果未被记忆时计算。如果memoize函数按预期工作，那么addFunc将只被调用一次，此后对memoizedFn的任何调用都将返回一个已经存储在内存中的结果。</p><p id="48c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看memoizedFn的实现:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="478b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我知道这有点冗长，但我们可以这样看。我们有一个memoizedResults来缓存所有已经计算的结果。</p><p id="9c9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果我们在用户调用memoized函数时将addNumber作为参数传入，它首先检查memoizedResults中的函数定义是否可用。如果是，我们通过引用memoizedResults[func].result获取缓存的结果。</p><p id="544c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们已经缓存了结果。我们仍然需要检查论点是否改变了。想象一下，如果我们调用addNumber(1，2，3)。这很好，我们将把addNumber作为一个键存储在memoizedResult中，结果字段为6，args包含1，2，3。如果我们调用addNumber(3，4，5)呢？当然，我们已经存储了memoizedResult的结果，但是如果我们使用缓存的结果，那么addNumber(3，4，5)将不会返回正确的结果。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi le"><img src="../Images/612b0149daf5f32575ba2686e03b8f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bVixGLa5Mt2blwZU"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jontyson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jon Tyson</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7f2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，我们如何确保正确使用缓存的结果，以及何时根据需要重新计算结果？</p><p id="cae0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比方说，如果我们第一次将memoizedFn设置为addNumber，并调用memoizedFn(1，2，3)一次。第一次，我们将args和func名称一起存储到映射中。当我们调用memoizedFn(3，4，5)时，我们调用getArgKeysFromMemoized和getArgValsFromMemoized来检查我们记忆的参数是否与最近一次函数调用中传递的参数相同。在这种情况下，如果它们不相同，我们重新计算结果，并再次将它们存储到我们的地图中。最后，我们简单地从地图返回结果。</p><p id="ae9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们问自己这个问题:为什么记忆化？早些时候，我们确实说过要获取某个数据50次，但这真的是个问题吗？</p><p id="f585" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，可以。</p><p id="3cfa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这些数据包含数百万、数十亿行数据，该怎么办？如果我们记住了它，那么除非需要，否则我们不必检索这些数据。想象一下，有一个应用程序调用api来获取一百万行项目，并将它们存储在本地内存中。如果我们实现了一个强大的记忆机制，我们可以在获取最新数据之前检查这些数据是否发生了变化。</p><p id="ed74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，保存api的每个操作都是我们不需要的每一百万个数据。在某些情况下，这可能就是拥有一个快速高效的应用程序与一个由于要检索的数据量而无法正常运行的应用程序之间的区别。</p><p id="e171" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lf">更多内容看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lf">plain English . io</em></strong></a></p></div></div>    
</body>
</html>