<html>
<head>
<title>Build Tetris with Modern JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用现代JavaScript构建俄罗斯方块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-tetris-with-modern-javascript-d631de657b9e?source=collection_archive---------14-----------------------#2021-05-15">https://javascript.plainenglish.io/build-tetris-with-modern-javascript-d631de657b9e?source=collection_archive---------14-----------------------#2021-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/54a77938395bdc9d82f4ae62a51e80a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vf3Qk0XMjkcS742w0pvhg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image Source: Author</figcaption></figure><p id="b58a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">学习一门新的编程语言很难，而且不是每个人都以同样的方式学习。对许多人来说，项目实践探索或互动教程是持久学习的关键。</p><p id="81e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">特别是对于像JavaScript这样的直观语言，构建项目有助于为如何以及为什么在不同的应用程序中使用基本概念提供上下文。这也有助于建立你的简历，因为你可以向招聘人员展示一系列了不起的项目，展示你的干劲和开发技能。</p><p id="480b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">今天，我们将帮助您开始一个JavaScript游戏开发项目来构建俄罗斯方块。到本文结束时，您将拥有自己继续构建所需的所有基础知识。</p><p id="5e79" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">下面是我们今天要讲的内容:</strong></p><ul class=""><li id="701d" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">什么是俄罗斯方块？</li><li id="2559" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">设计游戏</li><li id="cd52" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">设计电路板</li><li id="c4dc" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">创建画布</li><li id="362a" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">游戏的后续步骤</li></ul><h1 id="569f" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">什么是俄罗斯方块？</h1><p id="5a1d" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">俄罗斯方块是一款经典的街机游戏，由阿莱克西·帕杰诺夫于1984年创作。该游戏要求玩家旋转和移动落下的俄罗斯方块。玩家通过完成没有空单元格的水平行块来清除线。如果棋子到达顶部，游戏结束。</p><p id="ffef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">俄罗斯方块是一个受欢迎的项目，它让有抱负的游戏开发者在一个简单的环境中练习他们的技能。例如，您将获得基本游戏设计概念的实践，如游戏循环设计，以及实现常见的游戏机制，如用户控制、分数跟踪和碰撞检测。与更复杂的游戏不同，俄罗斯方块的行为和视觉效果非常简单。这可以让你练习在游戏开发中应用JavaScript基础知识，而不是弄清楚动画或复杂的玩家行为流程图。</p><p id="2655" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于这个例子，我们将从使用最简单的工具开始，到最后构建复杂性。</p><p id="b212" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要制作俄罗斯方块，你需要知道:</p><ul class=""><li id="b46a" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">HTML/CSS样式</li><li id="0b7c" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">JavaScript类、变量和范围</li><li id="9088" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">箭头功能</li><li id="7728" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">模板文字</li><li id="b5ce" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">展开与静止</li><li id="6f32" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">解构</li></ul><h1 id="881a" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">设计游戏</h1><p id="4d9c" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">首先，让我们设置基本的UI元素:播放区域、开始按钮和跟踪分数、线和水平的读数。我们将使用<a class="ae mo" href="https://www.educative.io/blog/css-flexbox" rel="noopener ugc nofollow" target="_blank"> Flexbox </a>和<a class="ae mo" href="https://www.educative.io/blog/complete-guide-css-positions" rel="noopener ugc nofollow" target="_blank"> CSS网格</a>来正确定位元素。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="88e1" class="my lm in mu b gy mz na l nb nc">&lt;!-- index.html --&gt;<br/>&lt;div class="grid"&gt;<br/>  &lt;canvas id="board" class="game-board"&gt;&lt;/canvas&gt;<br/>  &lt;div class="right-column"&gt;<br/>    &lt;div&gt;<br/>      &lt;h1&gt;TETRIS&lt;/h1&gt;<br/>      &lt;p&gt;Score: &lt;span id="score"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>      &lt;p&gt;Lines: &lt;span id="lines"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>      &lt;p&gt;Level: &lt;span id="level"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>      &lt;canvas id="next" class="next"&gt;&lt;/canvas&gt;<br/>    &lt;/div&gt;<br/>    &lt;button onclick="play()" class="play-button"&gt;Play&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span><span id="0b01" class="my lm in mu b gy nd na l nb nc">// styles.css<br/>.grid {<br/>  display: grid;<br/>  grid-template-columns: 320px 200px;<br/>}</span><span id="65b2" class="my lm in mu b gy nd na l nb nc">.right-column {<br/>  display: flex;<br/>  flex-direction: column;<br/>  justify-content: space-between;<br/>}</span><span id="9e4f" class="my lm in mu b gy nd na l nb nc">.game-board {<br/>  border: solid 2px;<br/>}</span><span id="f940" class="my lm in mu b gy nd na l nb nc">.play-button {<br/>  background-color: #4caf50;<br/>  font-size: 16px;<br/>  padding: 15px 30px;<br/>  cursor: pointer;<br/>}</span></pre><p id="44ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">80年代游戏的一个基本部分是高度可识别的位图字体。<strong class="kb io">按下开始2P </strong>是谷歌的免费字体，我们可以用它来模拟这种感觉。</p><p id="c35f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要添加字体，我们需要在HTML文档的<code class="fe ne nf ng mu b">&lt;head&gt;</code>部分链接到它，并在CSS样式表中将它设置为我们想要的字体。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e7d2" class="my lm in mu b gy mz na l nb nc">&lt;!--index.html--&gt;<br/>&lt;link<br/>  href="https://fonts.googleapis.com/css?family=Press+Start+2P"<br/>  rel="stylesheet"<br/>/&gt;</span><span id="80e9" class="my lm in mu b gy nd na l nb nc">// styles.css<br/>* {<br/>  font-family: 'Press Start 2P', cursive;<br/>}</span></pre><p id="723b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，使用JavaScript编写游戏板的基础结构。<br/>您需要在我们的HTML文档末尾添加<code class="fe ne nf ng mu b">&lt;script&gt;</code>元素来导入我们的JavaScript。</p><p id="da2c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">HTML文档的底部应该是这样的:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a046" class="my lm in mu b gy mz na l nb nc">&lt;script type="text/javascript" src="constants.js"&gt;&lt;/script&gt;<br/>    &lt;script type="text/javascript" src="board.js"&gt;&lt;/script&gt;<br/>    &lt;script type="text/javascript" src="piece.js"&gt;&lt;/script&gt;<br/>    &lt;script type="text/javascript" src="main.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7abc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">将包含我们静态playboard的代码。无论玩家如何操作，这些值都不会改变。播放板将由10列和20行组成，块大小为30。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b62b" class="my lm in mu b gy mz na l nb nc">//constants.js<br/>const COLS = 10;<br/>const ROWS = 20;<br/>const BLOCK_SIZE = 30;</span></pre><p id="c17c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，在<code class="fe ne nf ng mu b">main.js</code>文件中，我们将包含一些操作文档的代码，它为HTML文档提供了一个可编程的接口。这种类型的文档称为<strong class="kb io">文档对象模型(DOM) </strong>。</p><p id="a635" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以使用DOM调用<code class="fe ne nf ng mu b">getElementByID</code>,让我们瞄准特定的元素，并自动缩放游戏以匹配用户浏览器窗口的大小。这使用了HTML5新增的<code class="fe ne nf ng mu b">canvas</code>元素，它允许我们轻松地创建和使用2D形状。</p><p id="0bfc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe ne nf ng mu b">main.js</code>文件应该是这样的:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="54d3" class="my lm in mu b gy mz na l nb nc">//main.js<br/>const canvas = document.getElementById('board');<br/>const ctx = canvas.getContext('2d');</span><span id="e078" class="my lm in mu b gy nd na l nb nc">// Calculate size of canvas from constants.<br/>ctx.canvas.width = COLS * BLOCK_SIZE;<br/>ctx.canvas.height = ROWS * BLOCK_SIZE;</span><span id="eba5" class="my lm in mu b gy nd na l nb nc">// Scale blocks<br/>ctx.scale(BLOCK_SIZE, BLOCK_SIZE);</span></pre><p id="4628" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，您将拥有以下文件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a6ec" class="my lm in mu b gy mz na l nb nc">&lt;!--index.html--&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;link<br/>href="https://fonts.googleapis.com/css?family=Press+Start+2P"<br/>rel="stylesheet"<br/>/&gt;<br/>&lt;/head&gt;</span><span id="6670" class="my lm in mu b gy nd na l nb nc">&lt;body&gt;</span><span id="0fb6" class="my lm in mu b gy nd na l nb nc">  &lt;div class="grid"&gt;<br/>    &lt;canvas id="board" class="game-board"&gt;&lt;/canvas&gt;<br/>    &lt;div class="right-column"&gt;<br/>      &lt;div&gt;<br/>        &lt;h1&gt;TETRIS&lt;/h1&gt;<br/>        &lt;p&gt;Score: &lt;span id="score"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>        &lt;p&gt;Lines: &lt;span id="lines"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>        &lt;p&gt;Level: &lt;span id="level"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>        &lt;canvas id="next" class="next"&gt;&lt;/canvas&gt;<br/>      &lt;/div&gt;<br/>      &lt;button onclick="play()" class="play-button"&gt;Play&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;</span><span id="3d93" class="my lm in mu b gy nd na l nb nc">&lt;/body&gt;</span><span id="5e88" class="my lm in mu b gy nd na l nb nc">//main.js<br/>const canvas = document.getElementById('board');<br/>const ctx = canvas.getContext('2d');</span><span id="2267" class="my lm in mu b gy nd na l nb nc">// Calculate size of canvas from constants.<br/>ctx.canvas.width = COLS * BLOCK_SIZE;<br/>ctx.canvas.height = ROWS * BLOCK_SIZE;</span><span id="341e" class="my lm in mu b gy nd na l nb nc">// Scale blocks<br/>ctx.scale(BLOCK_SIZE, BLOCK_SIZE);</span><span id="7092" class="my lm in mu b gy nd na l nb nc">//constants.js<br/>const COLS = 10;<br/>const ROWS = 20;<br/>const BLOCK_SIZE = 30;</span><span id="ebed" class="my lm in mu b gy nd na l nb nc">//styles.css<br/>* {<br/>  font-family: 'Press Start 2P', cursive;<br/>}</span><span id="6d48" class="my lm in mu b gy nd na l nb nc">.grid {<br/>  display: grid;<br/>  grid-template-columns: 320px 200px;<br/>}</span><span id="b26f" class="my lm in mu b gy nd na l nb nc">.right-column {<br/>  display: flex;<br/>  flex-direction: column;<br/>  justify-content: space-between;<br/>}</span><span id="50b9" class="my lm in mu b gy nd na l nb nc">.game-board {<br/>  border: solid 2px;<br/>}</span><span id="c3ce" class="my lm in mu b gy nd na l nb nc">.play-button {<br/>  background-color: #4caf50;<br/>  font-size: 16px;<br/>  padding: 15px 30px;<br/>  cursor: pointer;<br/>}</span></pre><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/ec2c16f9291561045abcbb40107e75eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5mMcbN0Jhmfjzk1Q.PNG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image Source: Author</figcaption></figure><h1 id="f012" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">设计电路板</h1><p id="0304" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">现在我们已经为我们的游戏创建了一个容器，是时候开始编码逻辑了。首先，我们需要棋盘能够画出下落的棋子并跟踪游戏状态。</p><p id="e144" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">棋盘和棋子都是类的很好的候选者。我们可以在开始一个新游戏时创建一个新的<code class="fe ne nf ng mu b">Board</code>实例，并在每次新棋子进入游戏时创建一个新的<code class="fe ne nf ng mu b">Piece</code>实例。</p><p id="61e6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于<code class="fe ne nf ng mu b">Board</code>类，我们将创建一个新的<code class="fe ne nf ng mu b">board.js</code>文件。我们希望每次游戏开始时棋盘都引用画布，所以我们将在<code class="fe ne nf ng mu b">Board</code>构造函数中包含<code class="fe ne nf ng mu b">ctx</code>。我们还将包含关键字<code class="fe ne nf ng mu b">this</code>，让我们在<code class="fe ne nf ng mu b">ctx</code>中设置和访问属性。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d8b5" class="my lm in mu b gy mz na l nb nc">//board.js<br/>class Board { <br/>  constructor(ctx) {<br/>    this.ctx = ctx;    <br/>  } <br/>}</span></pre><p id="2a33" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">俄罗斯方块棋盘由许多单独的单元组成，这些单元要么是空的，要么是被占用的。我们将用<code class="fe ne nf ng mu b">0</code>表示空的单元格，用整数<code class="fe ne nf ng mu b">1-7</code>表示被占用的单元格来表示颜色。</p><p id="ecd9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了表示棋盘的行和列，我们将使用2D数组(一个矩阵)。我们用整数数组代表一行，用行数组代表整个棋盘。</p><p id="d9d7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为所有的游戏都是从一个空棋盘开始的，所以我们需要一个返回空棋盘的方法。我们可以使用内置的<code class="fe ne nf ng mu b">fill()</code>数组方法将每一行的所有元素填充到<code class="fe ne nf ng mu b">0</code>。构造函数将调用这个方法，所以所有的游戏都是空的。</p><p id="e385" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的<code class="fe ne nf ng mu b">board.js</code>文件现在看起来像这样:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="09c6" class="my lm in mu b gy mz na l nb nc">//board.js<br/>class Board { <br/>  constructor(ctx) {<br/>    this.ctx = ctx;<br/>    this.grid = this.getEmptyBoard();<br/>  }</span><span id="853d" class="my lm in mu b gy nd na l nb nc">  getEmptyBoard() {<br/>    return Array.from(<br/>      {length: ROWS}, () =&gt; Array(COLS).fill(0)<br/>    );<br/>  }<br/>}</span></pre><p id="0fa1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我们将返回到<code class="fe ne nf ng mu b">main.js</code>向播放按钮添加这个新的游戏功能。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9e01" class="my lm in mu b gy mz na l nb nc">function play() {<br/>  board = new Board(ctx);<br/>  console.table(board.grid);<br/>}</span></pre><p id="db84" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们的游戏板设置好了！你可以使用<code class="fe ne nf ng mu b">console.table()</code>来查看控制棋盘的矩阵。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/2768e91f1131fb94864e9a580c041c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5VfyzSokNI46leJ6.PNG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image Source: Author</figcaption></figure><h1 id="fe1d" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建画布</h1><p id="d78b" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">现在我们将确保我们的<code class="fe ne nf ng mu b">canvas</code>元素已经准备好使用。画布为我们的游戏提供了一块空白的画布。</p><p id="e0fa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还可以在画布上添加2D绘图上下文，用于绘制形状、文本、图像和其他对象。它的工作原理类似于MS Paint这样的程序，你可以选择你的笔刷类型和颜色，然后使用代码进行绘制。</p><p id="11b4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，我们要确保画布大小合适。默认情况下，它是300x150像素，但我们希望它使用我们上面添加的代码进行缩放。</p><p id="5b31" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，我们向我们的<code class="fe ne nf ng mu b">index.html</code>添加了一个<code class="fe ne nf ng mu b">canvas</code>元素:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="df48" class="my lm in mu b gy mz na l nb nc">&lt;canvas id="canvas"&gt;&lt;/canvas&gt;</span></pre><p id="cdbe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后使用<code class="fe ne nf ng mu b">getElementById</code>方法在DOM(文档对象模型)中添加对HTML <code class="fe ne nf ng mu b">&lt;canvas&gt;</code>元素的引用。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a8a6" class="my lm in mu b gy mz na l nb nc">let canvas = document.getElementById('canvas');</span></pre><p id="ee39" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们将使用canvas上下文来呈现一些片段。</p><p id="65a6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以使用<code class="fe ne nf ng mu b">HTMLCanvasElement.getContext()</code>方法来获取我们渲染图形的画布上下文。这个方法需要一个参数，所以我们将通过<code class="fe ne nf ng mu b">'2d'</code>来获取2D渲染上下文。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9e02" class="my lm in mu b gy mz na l nb nc">let ctx = canvas.getContext('2d');</span></pre><p id="a669" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我们画画之前，我们必须使用<code class="fe ne nf ng mu b">fillStyle()</code>方法选择一种颜色。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="84e6" class="my lm in mu b gy mz na l nb nc">ctx.fillStyle = 'red';</span></pre><p id="544c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，我们可以使用上下文API中的<code class="fe ne nf ng mu b">fillRect()</code>方法绘制一个简单的矩形，用我们选择的红色填充。<code class="fe ne nf ng mu b">fillRect()</code>接受4个参数:形状应该开始的x和y坐标以及矩形的宽度/高度。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="bafb" class="my lm in mu b gy mz na l nb nc">ctx.fillRect(x, y, width, height);</span></pre><p id="3dcc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为所有的俄罗斯方块都是方块的集合，我们可以对所有的方块使用这种单一的抽取方法！</p><h1 id="aca4" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">动画片</h1><p id="6d4e" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">现在我们有了绘制图形的工具，我们必须能够移动它们。</p><p id="ddc1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Canvas使用<strong class="kb io">即时渲染</strong>:绘制的形状会立即渲染到屏幕上，但不会存储为形状对象。相反，canvas只将形状识别为填充的像素，这意味着我们不能整体移动形状。</p><p id="c3a2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了显示移动的形状，我们必须使用<code class="fe ne nf ng mu b">clearRect()</code>删除旧的形状，并使用<code class="fe ne nf ng mu b">fillRect()</code>在新的位置重新绘制。画布动画本质上类似于定格动画，因为它们在每一帧中都移动了一点。</p><p id="a6ee" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看一下这个例子:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3aa9" class="my lm in mu b gy mz na l nb nc">const {width, height} = this.ctx.canvas;<br/>ctx.fillStyle = 'blue';<br/>ctx.fillRect(0, 0, 10, 10);<br/>ctx.clearRect(0, 0, width, height);<br/>ctx.fillRect(1, 1, 10, 10);</span></pre><p id="f14b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里，我们选择蓝色作为我们的颜色，然后在点<code class="fe ne nf ng mu b">0,0</code>填充一个矩形。然后我们使用<code class="fe ne nf ng mu b">clearRect()</code>清除整个画布，并传递整个画布的宽度和高度。最后，我们在<code class="fe ne nf ng mu b">1,1</code>绘制一个同样大小和颜色的新矩形。</p><p id="1a02" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">从用户的角度来看，矩形在屏幕上向右下方移动。</p><p id="e38e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在你已经设置好了画布和绘图工具，你已经拥有了开始编写游戏代码和收集游戏碎片所需的所有工具！</p><h1 id="3347" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">游戏的后续步骤</h1><p id="f6df" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">这是你下一个作品集项目的良好开端。现在你已经建立了游戏的基础，你的下一步是创建对象，用自己的颜色绘制每个独特的俄罗斯方块游戏。</p><p id="ab84" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">每个棋子类型将由一个3x3矩阵表示，其中棋子是填充的单元格，周围的空白空间有助于围绕中心单元格旋转。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f01d" class="my lm in mu b gy mz na l nb nc">[2, 0, 0],  <br/>[2, 2, 2],  <br/>[0, 0, 0];</span></pre><p id="5273" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最好的方法是使用一个<code class="fe ne nf ng mu b">Piece</code>类。</p><p id="ecf2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您还必须添加键盘支持，以便用户可以控制这些部分。最好的方法是使用现代浏览器内置的键盘事件支持。您可以使用<code class="fe ne nf ng mu b">addEventListener()</code>方法将程序设置为在文档级别监听键盘事件，如<code class="fe ne nf ng mu b">keydown</code>、<code class="fe ne nf ng mu b">keyup</code>等。</p><p id="4d3f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完成这些步骤后，您将继续添加更多高级功能，如:</p><ul class=""><li id="3cb2" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">添加碰撞检测和块随机发生器</li><li id="555b" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">如果填充了一行，则添加行清除</li><li id="cead" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">跟踪分数、级别和过去的高分</li><li id="c7f3" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">通过异步JavaScript提高响应能力</li></ul><p id="67b5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="nj">快乐学习！</em></p><p id="4163" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="nj">更多内容请看</em><a class="ae mo" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="nj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>