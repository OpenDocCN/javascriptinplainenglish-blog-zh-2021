<html>
<head>
<title>Data Modeling with Prisma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Prisma进行数据建模</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-modeling-with-prisma-5c4c37f31d8c?source=collection_archive---------1-----------------------#2021-08-29">https://javascript.plainenglish.io/data-modeling-with-prisma-5c4c37f31d8c?source=collection_archive---------1-----------------------#2021-08-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4713b20a607a36cee426a620a552f887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFPXzXFdnJTretkN0kVSUA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@charlesdeluvio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Charles Deluvio</a> on <a class="ae jz" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ca69" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是Prisma系列介绍文章的第三部分。如果你还没有看过以前的文章，你可以在下面找到它们。</p><ul class=""><li id="fc21" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/simplifying-backend-development-with-prisma-564200f31943">使用Prisma简化后端开发</a></li><li id="dcf2" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/diving-into-prisma-schema-b278e92dff8b">深入探究Prisma模式</a></li></ul><p id="23a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经考虑了一个简单博客场景的数据库逻辑，其中有两个数据库实体。用户和帖子。</p><p id="e2f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我们将采取一种实用的方法来调节这些实体。我们将关注可能发生的不同类型的数据库实体映射Prisma schema如何帮助您在这样的场景中摆脱沉重的负担。</p><p id="6f02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们在这篇文章中涉及的范围很广，所以我们不会考虑如何根据我们所做的改变来创建CRUD操作。但是你可以在我们之前使用的的<a class="ae jz" href="https://github.com/Pasi-D/Prisma-Starter" rel="noopener ugc nofollow" target="_blank">资源库中找到相关的分支代码。</a></p><p id="bf7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文末尾的分支如下所示。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/ee2cdcef26c635b2563d76eee2369845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLOcZLCTfZ1JErkIqjEqdA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd lr">If you’re seeing these branch names in comments of code segments used in this article that means you’ve reached up-to that point in the same git repository branch.</strong></figcaption></figure><p id="c379" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据基数<a class="ae jz" href="https://en.wikipedia.org/wiki/Cardinality_(data_modeling)" rel="noopener ugc nofollow" target="_blank">和基数</a>的不同，可以有3种关系</p><ol class=""><li id="26c1" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ls le lf lg bi translated">一对一(1-1)</li><li id="5cd4" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">一对多(1米)</li><li id="051d" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">多对多(多对多)</li></ol><p id="0a41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将考虑这些关系类型中的每一种，并添加相关的修改。</p><h1 id="913f" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">一对一(一对一)关系</h1><p id="5f39" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在修改中，我们将使用户和配置文件实体遵循一对一的映射。在这个过程中，我们也将改变用户实体中的一些属性。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/cbc08c5741e3d6df5098a37a0dfa91ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhQW_PV0tu5jhw5H9NcLzw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">user-profile one to one mapping introduced to current ERD</figcaption></figure><p id="6a3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个用户记录可以有零到一个配置文件记录。配置文件记录必须有用户，否则无法创建。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">user to profile 1–1 mapping</figcaption></figure><p id="2e03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者，您可以通过@relation属性命名添加的外键约束。在这种情况下，两个模型都需要更新。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Optionally you can provide name to added foreign key constraint</figcaption></figure><p id="1257" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们运行迁移&amp;看看SQL查询是如何生成的。</p><pre class="ln lo lp lq gt mz na nb nc aw nd bi"><span id="a08e" class="ne lu in na b gy nf ng l nh ni">npx prisma migrate dev --name “UserToProfile”</span></pre><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/90a7eb46acb18efb1b6499857917f98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCNomxlzmLIMoH99ihcsZg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">SQL queries generated for the user-profile migration</figcaption></figure><p id="897a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据需要，为了创建用户，可以强制配置文件。</p><p id="a573" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们试图删除可选的类型修饰符，它将是无效的。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/29b04a6871d3e2e3da40bf4a46ba39a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwNGk28p9AX2My4oyp8X8g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Removing optional modifier does not make the relationship mandatory</figcaption></figure><p id="8950" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要从数据库级别做到这一点，我们需要在用户表中保留一个外键字段，如<strong class="kc io"> <em class="nl"> profileId </em> </strong>。</p><p id="9afe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们将在用户模型中添加一个标量字段<strong class="kc io"><em class="nl">profile id</em></strong><em class="nl"/>，该字段可以在<strong class="kc io"> <em class="nl"> profile </em> </strong>关系字段&amp;中引用。之前在Profile中添加的标量字段应被删除，使用户映射成为可选的。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">User(optional) to Profile(Mandatory) 1–1 mapping</figcaption></figure><p id="6756" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尝试进行此迁移时，系统会提示您一条警告。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/df292f1bdbde1b1236c4fe3623517492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOtAUrkDYdb6wJ41wmkZ3g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">On attempting to run a migration, a warning is prompted to safeguard existing data</figcaption></figure><p id="4a8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">万一我们需要忽略以上任何一个条件。即独立地创建用户或简档记录&amp;保持关系可选。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">User(optional) to Profile(optional) 1–1 mapping</figcaption></figure><blockquote class="nm nn no"><p id="6fbc" class="ka kb nl kc b kd ke kf kg kh ki kj kk np km kn ko nq kq kr ks nr ku kv kw kx ig bi translated">D <!-- -->选择实体以一对一映射的方式存储外键标量字段取决于您。</p></blockquote><h2 id="fa85" class="ne lu in bd lv ns nt dn lz nu nv dp md kl nw nx mh kp ny nz ml kt oa ob mp oc bi translated">一对一的自我关系</h2><p id="15a9" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">比方说，在《疫情时报》上，你决定为博客平台推出一个提名功能。您可以提名一个用户；万一你去世了，他/她可以接管。</p><p id="717e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，</p><ul class=""><li id="fff2" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">一个用户可以有一个或零个提名者。</li><li id="83cc" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">一个用户可以有一个或零个被提名人。</li></ul><p id="58af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我们必须向引用自身的用户模型添加一个关系字段。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="230c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成的迁移文件如下所示。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/7fc322af433e19e09e3315c203f98939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJhYJfATVazsnPQjJcLkug.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">User-to-User one to one self relation migration SQL</figcaption></figure><h1 id="fce9" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">一对多(一对多)关系</h1><p id="063f" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们到目前为止建立的用户-帖子关系是一对多的关系。相应地，我们可以</p><ul class=""><li id="c696" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">创建一个拥有零个或多个帖子的用户</li><li id="a782" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">创建一个始终与用户相关的帖子</li></ul><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">User(Mandatory) to Post (Optional) 1-m mapping</figcaption></figure><p id="d909" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与前面的一对一映射类似，我们可以将发布到用户映射设置为可选。即一个帖子可以有零到一个用户</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">User(optional) to Post(optional) 1-m mapping</figcaption></figure><p id="ac17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我在用户表中使用复合主键而不是当前id字段，会发生什么情况？我需要如何在Prisma模式中反映这一点？</p><p id="d8a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于这种情况，需要进行以下修改。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Adding composite primary key in User replacing id needs to be reflected in other related models</figcaption></figure><p id="ee3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们看看与此相关的迁移变化。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/ba45caaba3e1a8609726a79559068cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O10jsc4bX9F8ktg4SPXdFA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Migration SQL generated after adding a composite PK for User</figcaption></figure><h2 id="6bae" class="ne lu in bd lv ns nt dn lz nu nv dp md kl nw nx mh kp ny nz ml kt oa ob mp oc bi translated"><em class="of">一对多自我关系</em></h2><p id="7f8e" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">现在，如果你决定加入一个博客经理的职位，你将如何修改你的用户实体？</p><p id="21a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一种方法是向用户模型添加几个字段</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">User manage User 1-m self relation</figcaption></figure><p id="d475" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样一来，</p><ul class=""><li id="c440" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">一个用户(或博客成员用户)可以有零个或一个管理员</li><li id="6692" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">一个经理可以有零到多个成员</li></ul><p id="c7d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成的迁移文件如下所示。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/bc4ff8c62bd24979b2698f513b57832f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1F6VObF5-6jiJljgl0cgeQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Migration SQL generated for User manage User one to many relationship</figcaption></figure><h1 id="e41a" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">多对多(m-n)关系</h1><p id="114e" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在关系数据库的m-n型关系中，我们创建了一个名为<em class="nl">关系表</em>的中间表(其他术语如<em class="nl">关联表</em>、<em class="nl">组合表</em>、<em class="nl">连接表</em>或<em class="nl">透视表</em>也有同样的含义。)</p><p id="dfed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了更好地理解这一点，让我们给我们的Post模型添加标签。一篇文章可以有零到多个标签，反之亦然。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/bc55b01d6dc806ebf24c94fb54cd0619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53akcEgr0mbGgVmdfLE-0g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Tags to Post is a m-n relationship ERD. TagsOnPosts entity is the relation table</figcaption></figure><p id="8576" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据关系表，有两种方法可以定义Prisma模式中的多对多关系。</p><ol class=""><li id="f12c" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ls le lf lg bi translated">显式多对多关系</li><li id="9231" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ls le lf lg bi translated">隐式多对多关系</li></ol><h2 id="568f" class="ne lu in bd lv ns nt dn lz nu nv dp md kl nw nx mh kp ny nz ml kt oa ob mp oc bi translated"><em class="of">显式多对多关系</em></h2><p id="2f7f" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在显式m-n关系中，中间关系表被表示为Prisma模式中的模型。</p><p id="7092" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与隐式m-n关系不同，您将管理关系表。所以，你可以遵循一个最适合的约定。</p><p id="6834" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以在关系表中包含额外的元数据，例如创建日期标记(<strong class="kc io"><em class="nl"/></strong>)、分配人(<strong class="kc io"> <em class="nl">)分配人(</em> </strong>)。</p><p id="2128" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于每个模型必须至少有一个唯一的标准，该标准只有必填字段，我们将添加一个带有<code class="fe oi oj ok na b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#id-1" rel="noopener ugc nofollow" target="_blank">@@id</a></code>属性的多字段ID。(即一个复合主键)如果你认为这是数据方面的，同一篇文章不能有相同的标签超过一次。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Tag to Post m-n explicit relation</figcaption></figure><p id="1df0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">针对这一更改运行迁移时，我们会得到以下SQL查询。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ol"><img src="../Images/ab26b1be99d8e43016cba25874e731ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SGQXsXUB2Vcwod8H_douA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Tag to Post many to many explicit relation migration</figcaption></figure><h2 id="81d2" class="ne lu in bd lv ns nt dn lz nu nv dp md kl nw nx mh kp ny nz ml kt oa ob mp oc bi translated"><em class="of">隐含的多对多关系</em></h2><p id="487c" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在隐式m-n关系中，关系字段被定义为两个模型上的列表。尽管关系表存在于底层数据库中，但它是由Prisma管理的，并不在Prisma模式中显示。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Tag to Post m-n implicit relation</figcaption></figure><p id="aacd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成的迁移SQL查询如下。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi om"><img src="../Images/367a2aaa1b559f466f5f2deabf9a37eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqZ3YFQu0yI1YIHbVd4voQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Tag to Post implicit m-n relation migration SQL query</figcaption></figure><p id="3a1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">隐式m-n关系中自动生成的关系表遵循特定的约定。</p><p id="75cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了遵循隐含的m-n关系，两个模型都应该具有单个字段ID ( <code class="fe oi oj ok na b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#id" rel="noopener ugc nofollow" target="_blank">@id</a></code>)</p><h2 id="0b0e" class="ne lu in bd lv ns nt dn lz nu nv dp md kl nw nx mh kp ny nz ml kt oa ob mp oc bi translated">多对多自我关系</h2><p id="ceb7" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">一个多对多的自我关系总是隐含的。一个简单的例子是向用户模型添加追随者。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">User follow User m-n self relation is always implicit</figcaption></figure><p id="0881" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迁移生成的SQL如下所示。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi on"><img src="../Images/6f75248e41dcea4a73935dff3132b538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aje8qmZAVPFpRUiHrmWUSg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">SQL migration generated in User follow User m-n self relation</figcaption></figure><p id="925c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了不能添加额外的元数据之外，你不能在隐式的m-n关系中调节<a class="ae jz" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions" rel="noopener ugc nofollow" target="_blank">引用动作</a>。</p><h1 id="7636" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="fd64" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们已经通过简单的博客场景介绍了大多数的关系类型。</p><p id="a879" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望这篇文章能帮助你理解如何使用Prisma在关系数据库中管理不同的实体映射。</p><p id="68ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一篇文章中，我们将看看在Prisma中工作的实体映射中缺少的一个重要部分:<a class="ae jz" href="https://en.wikipedia.org/wiki/Foreign_key#Referential_actions" rel="noopener ugc nofollow" target="_blank">引用动作</a></p><p id="caeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nl">plain English . io</em></strong></a></p></div></div>    
</body>
</html>