<html>
<head>
<title>Why Next.js Has Better SEO Than Plain React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Next.js比Plain React有更好的SEO</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-next-js-has-better-seo-than-plain-react-6f6646d776e8?source=collection_archive---------6-----------------------#2021-03-10">https://javascript.plainenglish.io/why-next-js-has-better-seo-than-plain-react-6f6646d776e8?source=collection_archive---------6-----------------------#2021-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c04b1a6d2067bb06f520ddc65e2cd48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGwYl3egRhAh974mV4g0vg.png"/></div></div></figure><p id="d46f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用plain React，要呈现的HTML是在客户端生成的，因此搜索引擎必须执行JavaScript代码来获取HTML。js有一个预渲染特性，即应该渲染的HTML在服务器端生成，然后发送到客户端。这种预渲染特性为Next.js应用程序提供了改进的<a class="ae kt" href="https://circuit.ooo/blog/seo-for-beginners" rel="noopener ugc nofollow" target="_blank"> SEO </a>，因为搜索引擎将直接从服务器获取HTML，而不需要在爬行时生成HTML。</p><h2 id="7520" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">预渲染类型</h2><ul class=""><li id="c692" class="ln lo in jx b jy lp kc lq kg lr kk ls ko lt ks lu lv lw lx bi translated">静态生成:HTML只在构建时生成。</li><li id="0dbd" class="ln lo in jx b jy ly kc lz kg ma kk mb ko mc ks lu lv lw lx bi translated">服务器端呈现:每个请求都会生成HTML。</li></ul><h2 id="dc5a" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">静态生成</h2><figure class="me mf mg mh gt jo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/5493cac7f5e4a5010a8d7b720cf7adeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*pcMqv4aiU9bxwXO21u4gjQ.png"/></div></figure><p id="62ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在静态生成中，HTML是在构建时生成的，用户的每个请求都会重用这个HTML。如果网页可以在用户请求之前预先呈现，静态生成是一个更好的选择。由于HTML仅在构建期间生成，因此静态生成比服务器端呈现要快得多。像FAQ和About Us这样的页面可以考虑静态生成，因为它们不需要用户参与渲染。</p><h2 id="854f" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">服务器端渲染</strong></h2><figure class="me mf mg mh gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/a256adfa58aa1412b45cfdba43c59a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*ScWOdacg_ivsvqb4-0QuRQ.png"/></div></figure><p id="0f1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时页面只能在用户请求后呈现；服务器端渲染实现了这种情况下的预渲染。这里考虑一个电子商务站点的购物车页面，我们使用服务器端呈现，因为它需要用户请求来决定所有需要呈现的内容，它不像FAQ页面那样是静态的。</p><h2 id="25ab" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">弈静代</strong></h2><p id="e51b" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">为了在页面上实现静态生成，您必须导出一个名为getStaticProps的异步函数。这个函数将告诉Next.js使用静态生成预先呈现页面。下面附加的代码演示了如何在特定页面上初始化静态生成预呈现。</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="d44b" class="ku kv in mn b gy mr ms l mt mu">/* <br/> * Path: pages/blog.js<br/> * Description: Page pre-rendering using SG<br/> */</span><span id="61bf" class="ku kv in mn b gy mv ms l mt mu">function Blog({ posts }) {<br/>    return (<br/>       &lt;ul&gt;<br/>         {posts.map((post) =&gt; (<br/>            &lt;li&gt;{post.name}&lt;/li&gt;<br/>          ))}<br/>       &lt;/ul&gt;<br/>    );<br/> }</span><span id="87a0" class="ku kv in mn b gy mv ms l mt mu">export async function getStaticProps() {<br/>   const res = <br/>       await fetch("https://jsonplaceholder.typicode.com/comments");<br/>   const posts = await res.json();</span><span id="685c" class="ku kv in mn b gy mv ms l mt mu">   return {<br/>     props: {<br/>        posts,<br/>     },<br/>   };<br/> }</span><span id="234d" class="ku kv in mn b gy mv ms l mt mu">export default Blog;</span></pre><h2 id="66dd" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">实现服务器端渲染</strong></h2><p id="fc6f" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">为了在页面上实现服务器端呈现，您必须导出一个名为getServerSideProps的异步函数。这个函数将告诉Next.js使用服务器端呈现来预呈现页面。下面附加的代码演示了如何初始化特定页面上的服务器端呈现。</p><pre class="me mf mg mh gt mm mn mo mp aw mq bi"><span id="fef7" class="ku kv in mn b gy mr ms l mt mu">/* <br/> * Path: pages/blog.js<br/> * Description: Page pre-rendering using SSR<br/> */</span><span id="d622" class="ku kv in mn b gy mv ms l mt mu">function Blog({ posts }) {<br/>    return (<br/>       &lt;ul&gt;<br/>         {posts.map((post) =&gt; (<br/>            &lt;li&gt;{post.name}&lt;/li&gt;<br/>          ))}<br/>       &lt;/ul&gt;<br/>    );<br/> }</span><span id="55a9" class="ku kv in mn b gy mv ms l mt mu">export async function <!-- -->getServerSideProps<!-- -->() {<br/>   const res = <br/>       await fetch("https://jsonplaceholder.typicode.com/comments");<br/>   const posts = await res.json();</span><span id="b0d9" class="ku kv in mn b gy mv ms l mt mu">return {<br/>     props: {<br/>        posts,<br/>     },<br/>   };<br/> }</span><span id="7b80" class="ku kv in mn b gy mv ms l mt mu">export default Blog;</span></pre><h2 id="0af0" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">结论</h2><p id="cb3b" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">预渲染功能使Next.js应用程序具有更好的站点性能和SEO。js提供了一个混合特性，静态生成和服务器端呈现都可以应用于同一个应用程序。如果要呈现的页面对所有用户都一样，那么就实现静态生成；否则，使用服务器端呈现。</p></div></div>    
</body>
</html>