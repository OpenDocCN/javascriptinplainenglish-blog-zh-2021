# 引擎盖下:反应虚拟 DOM

> 原文：<https://javascript.plainenglish.io/under-the-hood-react-virtual-dom-99a76f0d5493?source=collection_archive---------8----------------------->

![](img/b2df63ec84608d236adc9817cf92a0df.png)

Photo by [Nate Grant](https://unsplash.com/@nateggrant?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/coding?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

# React 的虚拟 DOM 是什么？

React 的官方文档说:

> 虚拟 DOM (VDOM)是一个编程概念，其中 UI 的理想或“虚拟”表示保存在内存中，并通过 ReactDOM 等库与“真实”DOM 同步。这个过程叫做和解。

实际上，虚拟 DOM 只是 React 元素(普通对象)的一个有组织的集合，它以一种更容易维护和更新的方式模仿浏览器 DOM。

让我们后退一步，看看 React 元素的例子。

JSX 负责将熟悉的 HTML 语法转换成 React 元素。没有 JSX，这只是:

下面是在引擎盖下创建的 React 元素。

你看，它真的只是一个普通的物体。进一步理解这个概念，我们看一个简单的函数组件。

下面是没有 JSX 的同一个按钮组件:

当按钮组件被评估时…

React 元素只是底层组件实例的描述。它们不是真正的组件。

我相信你可以想象一个成熟的 React 应用程序的 React 元素对象可以有多大。

## 为什么这很重要？

理解这个概念很重要，因为这就是虚拟 DOM 的样子 React 元素的虚拟树。每次应用程序更新时，都会重新创建虚拟树，并与之前的树进行比较。如果对应用程序的更改(即状态更改)需要每次都渲染 *real* DOM，这将非常耗费性能。但是有了虚拟 DOM，React 可以计算出发生了什么变化，并且只更新发生了变化的内容。这种区分算法是 React 的支柱，它被称为*协调*。

# 调和与渲染

协调和渲染是两个独立的过程。和解几乎是虚拟 DOM 的全部内容。当一个新的虚拟元素树生成时，它被传递到一个渲染环境，这取决于应用程序的目标。如果目标是浏览器 web 应用程序，那么呈现环境就是 DOM，因此虚拟树通过 React DOM 呈现为 DOM 节点。对于本机应用程序(iOS 或 Android)，虚拟树通过 React Native 呈现为本机视图。

协调算法处理差异过程，并计算出所需的最小更改，而渲染器利用这些信息来实际渲染应用程序。

这也是 React 如此强大的原因之一。React DOM、React Native 和任何其他渲染引擎都能够使用相同的协调器，同时能够生活在自己单独的域中，以他们想要的方式消费虚拟 DOM 树。

# 和解是如何进行的？

当您的一个组件获得其 props 的更新或其状态改变时，协调器触发。这为该组件(“根”元素)及其所有子组件触发了一个`render`,生成了一个新的 React 元素虚拟树。然后，从两棵树的根开始，将旧树与新树进行区分/比较。根据根元素的类型，行为会有所不同。

## 不同类型的元素

当协调器发现这两个根元素不同时，它会从头开始重新创建整个树。

让我们看看下面的例子。

如果它更新到以下内容:

调解器将拆掉整棵树，重建一切。根组件及其所有子组件将被卸载。此外，所有状态都将在此过程中丢失。

## 相同类型的元素

当区分相同类型的元素时，React 足够聪明，知道只有元素的属性发生了变化。

假设我们将`.active`类添加到`<ul>`中，以便在需要时显示它。

React 将保留呈现的 DOM 元素，只更新节点的 class 属性。对元素的样式属性的更新也是如此。

## 子元素、列表和键

一旦根元素被区分，协调器就沿着树向下遍历到子元素。React 遍历子列表，检查是否有任何更改，如果有，就更新虚拟 DOM。

然而，React 遇到了相同类型的子元素的问题，这通常发生在列表中。以下面这个为例:

如果我们将列表更改为以下内容:

React 将无法意识到它可以保留`<li>Banana</li>`和`<li>Orange</li>`，而只是将`<li>Apple</li>`添加到这个列表中，从而导致糟糕的性能。这也是为什么当未能在控制台中为相同类型的每个子级添加一个键时，您会看到此警告消息:

> 警告:数组或迭代器中的每个子元素都应该有一个唯一的“key”属性。

这就是*键*的用武之地。

键允许 React 将以前树中的子元素匹配到新树中。因此，如果我们将上面的示例转换为使用键:

它更改为以下内容:

React 知道添加了一个带有键`apple`的新子元素，它可以保留带有`banana`和`orange`的元素。

理想情况下，子元素应该有唯一且永不改变的键。不，我不是说仅仅使用索引。事实上，**你应该负责任地使用索引作为键，否则你可能会搬起石头砸自己的脚。你可以有很多选择。模型的 ID 和对象中某个属性的散列值是用作键的非常好的候选对象。**

## 用索引做键有什么问题？

为了更好地理解这个问题，这里有一个例子:

从上面我们可以看到，我们使用`.map()`遍历产品，并使用索引`i`作为每个孩子的键。生成的 DOM 树将是:

当新产品被添加到产品系列中时…

接下来会发生什么:

没问题吧？但是如果新产品被**加在**前面会怎么样呢？

发生的事情并不完全是 React 想要的。

你看，带有关键字`0`的`<li>`元素突然将其子元素从`Croissant — €1.99`更改为`Ciabatta — €2.99`，协调器会将其视为一个完全不同的元素，因此卸载旧元素并挂载一个新元素。同样的事情也发生在列表中的其他项目上，导致了糟糕的性能。

一个简单的改变就能解决这个问题。我们不使用迭代器的索引作为键，而是使用产品的 ID。

对于原始产品数组，生成的 DOM 树如下所示:

当`Ciabatta`被添加到产品数组中时，React 现在知道它可以保留带有键`1154`和`1155`的`<li>`元素，并且在列表的开头添加了一个新元素，因此只创建了一个新元素。

## 负责任地使用索引作为键

我不是说不能用索引做键，事实上也有一些例外。以下是一些关于何时可以在列表中使用索引作为键的有用指南:

*   当你完全确定你的列表项目没有任何变化时；
*   列表未被筛选或重新排序；
*   最后，当列表项没有自己的 id 时。

# 结论

理解虚拟 DOM 和协调过程可以帮助您构建快速且健壮的用户界面。虚拟 DOM 和协调算法隐藏了 React 应用程序每次更新时发生的大量复杂性，同时仍然保持 React 的目标，即允许开发人员编写快速和高性能的应用程序。

# 相关阅读

*   [反应中的对账](https://reactjs.org/docs/reconciliation.html)
*   [反应组件、元素和实例](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)
*   [反应纤维架构](https://github.com/acdlite/react-fiber-architecture)
*   [索引作为一个键是一个反模式](https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318)

请不要忘记**鼓掌**如果你发现这是有用的，并**关注**我更多这样的文章。

![](img/82627e1cd7a59167ac47977cf30550b5.png)

*更多内容请看*[*plain English . io*](http://plainenglish.io/)