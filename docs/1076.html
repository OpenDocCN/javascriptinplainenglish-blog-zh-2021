<html>
<head>
<title>Functional JavaScript Fundamentals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能JavaScript基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-javascript-fundamentals-469859265014?source=collection_archive---------10-----------------------#2021-03-06">https://javascript.plainenglish.io/functional-javascript-fundamentals-469859265014?source=collection_archive---------10-----------------------#2021-03-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8f46" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">函数式编程的基础，同时主要涉及它们在JavaScript中的应用</h2></div><h1 id="62fc" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">介绍</h1><p id="fa72" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="lq">函数式编程</em>是利用<em class="lq">函数</em>的代码风格吗？要是有那么简单就好了！函数确实是<em class="lq">函数式编程</em>的核心，但是这是我们<em class="lq">如何使用</em>那些函数来使我们的实现<em class="lq">起作用</em>。</p><p id="c2d2" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">本文旨在奠定<em class="lq">函数式编程</em>的一些基础，同时主要涉及它们在<code class="fe lw lx ly lz b">JavaScript</code>中的应用，这将帮助您理解:</p><ol class=""><li id="a0f2" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp mf mg mh mi bi translated"><strong class="kw io">功能</strong>是什么？</li><li id="7f23" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><strong class="kw io">功能</strong><em class="lq">vs</em><strong class="kw io">程序</strong></li><li id="4e37" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><strong class="kw io">说明性</strong><em class="lq">vs</em><strong class="kw io">命令性</strong>编程</li><li id="1727" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">理解功能<strong class="kw io">输入</strong>和<strong class="kw io">输出</strong></li></ol><p id="b541" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">这些基础将极大地帮助你掌握<em class="lq">函数式JavaScript </em>的更多概念，如果这有帮助的话，将在以后的文章中涉及。</p><p id="98b7" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">下一篇文章将涉及:</p><ol class=""><li id="80f7" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp mf mg mh mi bi translated"><strong class="kw io">函数纯度</strong>(纯<em class="lq">对</em>不纯函数)</li><li id="dca1" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><strong class="kw io">副作用</strong></li><li id="9f5b" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">提取并容纳<strong class="kw io">杂质</strong></li><li id="1bb5" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">所有这些如何共同定义<em class="lq">什么是</em> <strong class="kw io">功能编程</strong>，以及<em class="lq">为什么使用</em></li><li id="60e1" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><code class="fe lw lx ly lz b">JavaScript</code>是不是一种<em class="lq">函数式编程</em>语言？</li><li id="c3fe" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">为什么为你的代码考虑<strong class="kw io"> <em class="lq">函数式编程</em> </strong>风格？</li></ol><p id="8260" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">敬请期待！</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="844c" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">1.什么是功能？</h1><p id="1c76" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">嗯，就像任何介绍性编程类会告诉你的那样，函数是一段<em class="lq">可重用的代码，它在执行时执行一些任务</em>。虽然这个定义是合理的，但是它忽略了一个重要的观点，这个观点是函数应用于函数式编程的核心。</p><p id="73ad" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">让我们以非常基础的数学为例，试着更完整地理解<strong class="kw io">函数</strong>。</p><p id="ffc6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">你可能记得在学校里读到过<code class="fe lw lx ly lz b">f(x)</code>，或者方程式<code class="fe lw lx ly lz b">y = f(x)</code>。让我们假设等式<code class="fe lw lx ly lz b">f(x) = x2- 1</code>。那是什么意思？把那个方程画成图是什么意思？这是图表:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c520941fcdb4ee9ca8077782b718870e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*IVOR4LegBClOn03T"/></div></figure><p id="d88b" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">这相当于:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ba44" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">你可以注意到，对于<code class="fe lw lx ly lz b">x</code>的任意值，比如说<code class="fe lw lx ly lz b">1</code>，如果你把它代入方程，你会得到<code class="fe lw lx ly lz b">0</code>。然而什么是<code class="fe lw lx ly lz b">0</code>？它是<code class="fe lw lx ly lz b">f(x)</code>函数的返回值，我们之前说过它代表一个<code class="fe lw lx ly lz b">y</code>值。</p><p id="b1b6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">在数学中，函数总是接受输入，并且总是给出输出。围绕FP你会经常听到的一个术语是“态射”；这是一种描述映射到另一组值的一组值的奇特方式，就像一个函数的输入与该函数的输出相关。</p><p id="3632" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">然而，在我们的代码中，我们可以定义具有各种输入和输出的函数，即使它们很少被解释为图形上直观绘制的曲线。</p><p id="d39f" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">因此，更完整的函数定义应该是:</p><blockquote class="nk nl nm"><p id="5e7a" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><strong class="kw io">函数是输入和计算输出之间的语义关系。</strong></p><p id="2223" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><em class="in">还要注意</em> <code class="fe lw lx ly lz b"><em class="in">function</em></code> <em class="in">和</em>函数<em class="in">在本文中的用法。而</em>功能<em class="in">是我们正在讨论的概念，</em> <code class="fe lw lx ly lz b"><em class="in">function</em></code> <em class="in">只是</em> <code class="fe lw lx ly lz b"><em class="in">JavaScript keyword</em></code> <em class="in">。</em></p></blockquote><p id="b0b6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">从本质上来说，<em class="lq">函数式编程</em>是关于在这个数学意义上包含使用<code class="fe lw lx ly lz b">functions</code>作为<em class="lq">函数。</em></p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="502c" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">2.功能vs程序？</h1><p id="5625" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">术语<strong class="kw io">功能</strong>和<strong class="kw io">程序</strong>经常互换使用，但它们实际上指的是不同的东西。</p><p id="7265" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated"><strong class="kw io">程序</strong>是功能的任意集合。它可能有输入，也可能没有。它可能有输出(作为一个<code class="fe lw lx ly lz b">return</code>值)，也可能没有。</p><p id="fb53" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">然而，<strong class="kw io">函数</strong>接受输入，并且肯定总是有一个<code class="fe lw lx ly lz b">return</code>值。</p><p id="6119" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">对于<strong class="kw io">功能编程</strong>，我们尽可能使用<em class="lq">功能</em>，尽可能避免<em class="lq">程序</em>。你所有的<em class="lq">函数</em>应该接受输入并返回输出。</p><p id="98f1" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">基于这些知识，让我们考虑下面的例子:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="006c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">试评估<code class="fe lw lx ly lz b">function</code>和<code class="fe lw lx ly lz b">addPokémon</code>是<em class="lq">功能</em>还是<em class="lq">程序</em>？</p><p id="95d4" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">以下是一些基本观察结果:</p><ol class=""><li id="f494" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp mf mg mh mi bi translated"><code class="fe lw lx ly lz b">addPokémon</code>有定义的输入，但没有由<code class="fe lw lx ly lz b">return</code>指定的输出。应该是一个<em class="lq">程序</em>。</li><li id="1b07" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><code class="fe lw lx ly lz b">countPokémon</code>有定义的输入和定义的<code class="fe lw lx ly lz b">return</code>，所以应该是<em class="lq">函数</em>？</li></ol><p id="57e4" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">我们关于<code class="fe lw lx ly lz b">addPokémon</code>是一个<em class="lq">过程</em>的说法是正确的，但是<code class="fe lw lx ly lz b">countPokémon</code>也是一个<em class="lq">过程</em>，而不是一个<em class="lq">函数</em>，因为它在自身内部调用了一个<em class="lq">过程</em>。</p><p id="e5cb" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">总而言之:</p><blockquote class="nk nl nm"><p id="8e83" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><em class="in">注意，一个</em> <code class="fe lw lx ly lz b"><em class="in">function</em></code> <em class="in">在自身内部调用一个</em>过程<em class="in">，也是一个</em>过程<em class="in">。一个</em>程序<em class="in">的</em> <strong class="kw io"> <em class="in">【杂质】</em> </strong> <em class="in">，这是一个要进一步往下解释的概念，涓滴而下，“污染”所有直接或间接称呼它的人。</em></p></blockquote><p id="1ac6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">现在，我们可能想知道如何将最后一个例子的<em class="lq">过程</em>转换成<em class="lq">函数</em>？</p><p id="5bfe" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">基于上一节提到的<em class="lq">函数</em>的更完整定义，在寻找许多可能的解决方案之前，尝试对最后一个例子进行修改。对于这个例子，它应该非常简单。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="77bd" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">让我们再看一个区分<em class="lq">程序</em>和<em class="lq">功能</em>的例子。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7028" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">这个片段有效地返回了一个神奇宝贝的近邻的pokédex ID，给出了它自己的ID。</p><p id="59a2" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">显然，<code class="fe lw lx ly lz b">neighbouringPokémonID</code>是一个<em class="lq">函数</em>，因为它有一个输入，而<code class="fe lw lx ly lz b">return</code>是基于它的一个输出。</p><p id="9def" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">另外，<code class="fe lw lx ly lz b">generateNeighboursForTeam</code>是一个<em class="lq">程序</em>，因为它不<code class="fe lw lx ly lz b">return</code>任何东西。</p><p id="70f3" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">同样，我们可以修改这个例子，使两者都是<em class="lq">函数</em>。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="0262" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">3.声明式编程还是命令式编程？</h1><p id="5015" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">另一个要熟悉的基本概念是，<strong class="kw io">声明式</strong>和<strong class="kw io">命令式</strong>编码风格之间的区别，老实说，这在它的意义上是相对的。</p><p id="09bd" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">没有绝对<strong class="kw io">陈述性</strong>或绝对<strong class="kw io">命令性</strong>的风格。<em class="lq">本身就是一个谱。</em></p><p id="a49b" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">也就是说，让我们介绍一个常见的简单定义。</p><blockquote class="nk nl nm"><p id="2855" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><em class="in">“</em>命令式<em class="in">编程就像</em>你如何<em class="in">做某事，而</em>声明式<em class="in">编程更像</em>你做什么<em class="in">。”</em></p></blockquote><p id="8f37" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">有点模棱两可，开放式，就举个小例子吧。</p><p id="facb" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">假设，你正试图帮助你的小弟弟学习最新的神奇宝贝游戏的基础知识。具体来说，关于抓野生神奇宝贝。</p><blockquote class="nk nl nm"><p id="82a9" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated">宣示性<em class="in">:在神奇宝贝虚弱的时候扔一个神奇球。</em>(做什么)</p><p id="f910" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated">命令式<em class="in">:当神奇宝贝的生命值低于30%时，按X键投掷一个神奇宝贝球。</em>(具体怎么做)</p></blockquote><p id="0f62" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">一般来说，明确地逐一列出所有步骤是<strong class="kw io">必须的</strong>。理解起来相当机械，需要一行一行地浏览。</p><p id="bb88" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">并且利用某种程度的抽象和可信助手功能，以仅呈现基本思想的方式列出步骤，是<strong class="kw io">声明性的</strong>。这很容易理解，因为我们不需要关心事情是如何发生的，而是关心事情是如何发生的。</p><p id="d00c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">正如<strong class="kw io"> <em class="lq">什么</em> </strong>和<strong class="kw io"> <em class="lq">如何</em> </strong>可以相当主观，我们不能围绕什么是<em class="lq">陈述性</em>或<em class="lq">命令性</em>画出一个硬性的界限。</p><p id="ff3e" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">例如，对于一个用机器语言编程的人来说，这是非常必要的，Java看起来更像是声明性的。或者对于一个从事纯函数式语言工作的人来说，比如Haskell或Clojure，甚至JavaScript中的函数式实现也会感觉相当必要。</p><p id="bacb" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">我们目前关心的是为<strong class="kw io">函数式编程</strong>和<strong class="kw io">函数式JavaScript </strong>奠定基础，我们需要明白，我们应该通过利用<strong class="kw io"> <em class="lq">函数</em> </strong>，尽可能使我们的代码成为<strong class="kw io">声明式</strong>。</p><p id="9fe6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">继续，让我们多了解一点关于<strong class="kw io"> <em class="lq">功能输入和输出</em> </strong>。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="c332" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">4.功能输入</h1><p id="4c55" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">本节涵盖了<em class="lq">功能输入</em>的更多方面，主要是:</p><ul class=""><li id="6a97" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp nq mg mh mi bi translated">自变量和参数</li><li id="1876" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">默认参数</li><li id="0c52" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">计数输入</li><li id="cbfa" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">参数数组</li><li id="f75c" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">参数析构</li><li id="fe18" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">声明式风格的好处</li><li id="ef7f" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">命名参数</li><li id="f29d" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">无序参数</li></ul><p id="cc8d" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">让我们开始吧。</p><h1 id="ac91" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">a.自变量和参数</h1><p id="0e8c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">关于<strong class="kw io">参数</strong>和<strong class="kw io">参数</strong>之间的区别，经常会有一点混淆。</p><p id="163f" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">简单地说，<strong class="kw io">参数</strong>是您传递给<code class="fe lw lx ly lz b">function</code>的值，而<strong class="kw io">参数</strong>是接收这些值的<code class="fe lw lx ly lz b">function</code>内部的命名变量。</p><blockquote class="nk nl nm"><p id="9716" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><em class="in">注意:在JavaScript中，</em>实参的数量不需要和<em class="in">形参的数量相匹配。如果您传递的参数比您声明用来接收它们的参数要多，那么这些值就可以很好地传入。</em></p><p id="d6f8" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><em class="in">这些额外的参数可以通过几种方式访问，包括</em> <code class="fe lw lx ly lz b"><em class="in">args</em></code> <em class="in">对象。如果传递的参数较少，那么每个不匹配的参数都被赋值为</em> <code class="fe lw lx ly lz b"><em class="in">undefined</em></code> <em class="in">。</em></p></blockquote></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="343a" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">b.默认参数</h1><p id="4648" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">参数可以声明默认值。如果该参数的参数没有被传递，或者已经传递了值<code class="fe lw lx ly lz b">undefined</code>，那么默认的赋值表达式将被替换。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bb3a" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">考虑任何有助于函数可用性的默认情况总是一个好习惯。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="0075" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">c.Arity，即输入计数</h1><p id="20b3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">a <code class="fe lw lx ly lz b">function</code>“期望”的参数数量由声明的参数数量决定。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="deee" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated"><code class="fe lw lx ly lz b">f(..)</code>需要<code class="fe lw lx ly lz b">4</code>个参数，因为它有<code class="fe lw lx ly lz b">4</code>个声明的参数。这个计数有一个特殊术语:<strong class="kw io"> Arity </strong>，它是一个<code class="fe lw lx ly lz b">function</code>声明中参数的数量。<code class="fe lw lx ly lz b">f(..)</code>的<strong class="kw io">号</strong>是<code class="fe lw lx ly lz b">4</code>。</p><p id="cc88" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">此外，一个具有<strong class="kw io"> arity </strong> 1的<code class="fe lw lx ly lz b">function</code>也称为<strong class="kw io">一元</strong>，一个具有<strong class="kw io"> arity </strong> 2的<code class="fe lw lx ly lz b">function</code>也称为<strong class="kw io">二元</strong>，一个具有<strong class="kw io"> arity </strong> 3或更高的<code class="fe lw lx ly lz b">function</code>称为<strong class="kw io"> n元</strong>。</p><p id="fb45" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">那个<code class="fe lw lx ly lz b">function</code>引用的<code class="fe lw lx ly lz b">length</code>属性返回它的<strong class="kw io"> arity </strong>。</p><p id="0c90" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">虽然这听起来很简单，但意义深远。</p><p id="2848" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">在执行期间确定<strong class="kw io"> arity </strong>的一个原因是，如果一段代码从多个源接收到函数引用，并且必须根据每个源的<strong class="kw io"> arity </strong>发送不同的值。</p><p id="adb0" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">例如，假设一个<code class="fe lw lx ly lz b">fn</code>函数引用可以有一个、两个或三个参数，但是你总是想在最后一个位置传递一个变量<code class="fe lw lx ly lz b">x</code>:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="c7e5" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><strong class="kw io"> <em class="in">提示:</em> </strong> <em class="in">函数的</em> <code class="fe lw lx ly lz b"><em class="in">length</em></code> <em class="in">属性是只读的，它是在声明函数时确定的。它本质上应该被认为是一段元数据，描述了函数的预期用途。</em></p><p id="360a" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><em class="in">需要注意的一个问题是，某些类型的参数列表变化会使函数的</em> <code class="fe lw lx ly lz b"><em class="in">length</em></code> <em class="in">属性报告与您预期的不同:</em></p></blockquote><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="126c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">计算当前函数调用收到的参数数量怎么样？这曾经是微不足道的，但现在情况稍微复杂一些。每个函数都有一个可用的<code class="fe lw lx ly lz b">arguments</code>对象(类似数组),它保存了对每个传入参数的引用。然后，您可以检查<code class="fe lw lx ly lz b">arguments</code>的<code class="fe lw lx ly lz b">length</code>属性，以计算出实际通过了多少:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="df5c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">从ES5开始(特别是严格模式)，<code class="fe lw lx ly lz b">arguments</code>被一些人认为是过时的；许多人尽可能避免使用它。然而，<code class="fe lw lx ly lz b">arguments.length</code>，也只有它，可以继续用于那些需要关心传递的参数数量的情况。</p><blockquote class="nk nl nm"><p id="cca3" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><em class="in">接受不确定数量参数的函数签名被称为</em> <strong class="kw io">变量</strong> <em class="in">函数。</em></p></blockquote><p id="15fc" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">假设您确实需要以类似位置数组的方式访问参数，可能是因为您访问的参数在那个位置没有形参。我们怎么做呢？</p><p id="5cde" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">ES6来救援了！让我们用<code class="fe lw lx ly lz b">...</code>操作符来声明我们的函数，称为“spread”、“rest”或“gather”:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c4a0" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">参数列表中的<code class="fe lw lx ly lz b">...args</code>是一个ES6声明形式，它告诉引擎收集所有未分配给命名参数的剩余参数(如果有)，并将它们放入名为<code class="fe lw lx ly lz b">args</code>的真实数组中。永远是一个数组，即使它是空的。但是它<strong class="kw io">不会</strong>包括分配给<code class="fe lw lx ly lz b">x</code>、<code class="fe lw lx ly lz b">y</code>和<code class="fe lw lx ly lz b">z</code>参数的值，只包括除了前三个值之外传入的任何其他值。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="20fc" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">所以，如果你想设计一个函数，可以考虑任意数量的参数，使用<code class="fe lw lx ly lz b">...args</code>。</p><p id="b12c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">即使没有声明其他形式参数，也可以在参数列表中使用<code class="fe lw lx ly lz b">...</code>操作符。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="dae6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated"><code class="fe lw lx ly lz b">args</code>现在将是参数的完整数组，不管它们是什么，并且您可以使用<code class="fe lw lx ly lz b">args.length</code>来精确地知道有多少个参数被传入。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="7562" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">d.参数数组</h1><p id="5cf9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果您想将一组值作为函数调用的参数传递，该怎么办呢？</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0539" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">我们的新朋友，这里使用了<code class="fe lw lx ly lz b">...</code>操作符，但现在不仅仅是在参数列表中；它也用在调用点的参数列表中。</p><p id="5862" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">它在这个上下文中有相反的行为。在一个参数列表中，我们说它<em class="lq">将</em>个参数聚集在一起。在一个参数列表中，它<em class="lq">展开</em>它们。因此，<code class="fe lw lx ly lz b">arr</code>的内容实际上是作为<code class="fe lw lx ly lz b">f(..)</code>调用的单独参数展开的。</p><p id="4bb4" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">此外，多个值和<code class="fe lw lx ly lz b">...</code>扩展可以根据需要进行交织:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="nk nl nm"><p id="3381" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><em class="in">在这种对称的意义上考虑</em> <code class="fe lw lx ly lz b"><em class="in">...</em></code> <em class="in">:在值列表位置，它</em>展开<em class="in">。在赋值位置——像一个参数列表，因为实参把</em>赋值给<em class="in">形参——它</em>聚集<em class="in">。</em></p><p id="7f5b" class="ku kv lq kw b kx lr jo kz la ls jr lc nn lt lf lg no lu lj lk np lv ln lo lp ig bi translated"><code class="fe lw lx ly lz b"><em class="in">...</em></code> <em class="in">使得处理参数数组变得更加容易。</em></p></blockquote></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="0fcd" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">e.参数析构</h1><p id="98d5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">考虑上一节的变量<code class="fe lw lx ly lz b">f(..)</code>:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7134" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">如果我们想改变这种交互，让函数的调用者传入一组值，而不是单个的参数值，会怎么样呢？只需去掉两个<code class="fe lw lx ly lz b">...</code>用法:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c209" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">很简单。但是，如果现在我们想给传入数组中的前两个值都指定一个参数名，会怎么样呢？我们不再声明单独的参数，所以看起来我们失去了这种能力。</p><p id="8c73" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">谢天谢地，ES6 <strong class="kw io">析构</strong>就是答案。<strong class="kw io">析构</strong>是为某种结构(对象、数组等)声明<em class="lq">模式</em>的一种方式。)以及如何分解(分配)它的各个部分。</p><p id="0ce9" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">考虑:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="38b8" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">你现在发现参数列表周围的<code class="fe lw lx ly lz b">[ .. ]</code>括号了吗？这被称为<strong class="kw io">数组参数析构</strong>。</p><p id="7178" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">在这个例子中，析构告诉引擎在这个赋值位置应该有一个数组(又名参数)。该模式要求将数组的第一个值赋给一个名为<code class="fe lw lx ly lz b">x</code>的局部参数变量，第二个值赋给<code class="fe lw lx ly lz b">y</code>，剩下的值由<em class="lq">收集</em>到<code class="fe lw lx ly lz b">args</code>。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="6711" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">f.声明式风格的好处</h1><p id="d03b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">考虑到我们刚刚看到的析构的<code class="fe lw lx ly lz b">f(..)</code>，我们可以手动处理参数:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e190" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">但是这里我们强调一个原则，即<strong class="kw io">声明性</strong>代码比<strong class="kw io">命令性</strong>代码更有效地沟通。</p><p id="493c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated"><strong class="kw io">声明性</strong>代码(例如，前面的<code class="fe lw lx ly lz b">f(..)</code>片段中的<strong class="kw io">析构</strong>，或者<code class="fe lw lx ly lz b">...</code>操作符用法)关注的是一段代码的结果应该是什么。</p><p id="bdb2" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated"><strong class="kw io">命令式</strong>代码(比如后面代码片段中的手动赋值)更关注如何获得结果。结果是<em class="lq">编码</em>在那里，但它并不清楚，因为它被<em class="lq">如何</em>我们到达那里的细节所充斥。</p><p id="ee0a" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">早期的<code class="fe lw lx ly lz b">f(..)</code>被认为更具可读性，因为<strong class="kw io">析构</strong>隐藏了<em class="lq">如何</em>管理参数输入的不必要细节。</p><p id="e3b2" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">只要有可能，我们应该努力编写声明性的、自我解释的代码。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="532f" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">g.命名参数</h1><p id="9132" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">正如我们可以析构数组参数一样，我们也可以析构对象参数:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f43c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">我们传入一个对象作为单个参数，它被析构成两个独立的参数变量<code class="fe lw lx ly lz b">x</code>和<code class="fe lw lx ly lz b">y</code>，它们被赋予来自传入对象的相应属性名的值。属性不在对象上也没关系；正如你所料，它只是以一个带<code class="fe lw lx ly lz b">undefined</code>的变量结束。</p><p id="9c70" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">对于像<code class="fe lw lx ly lz b">f(undefined,3)</code>、<strong class="kw io">这样的普通调用点，位置</strong>用于从实参映射到形参；我们将<code class="fe lw lx ly lz b">3</code>放在第二个位置，将其分配给一个<code class="fe lw lx ly lz b">y</code>参数。</p><p id="cf45" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">但是在这个涉及参数析构的调用点，一个简单的<strong class="kw io">对象属性</strong>指示实参值<code class="fe lw lx ly lz b">3</code>应该赋给哪个参数(<code class="fe lw lx ly lz b">y</code>)。</p><p id="767b" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">有些语言对此有一个明确的特性:<strong class="kw io"> <em class="lq">命名参数</em> </strong>。换句话说，在调用点，标记一个输入值来指示它映射到哪个参数。JavaScript没有命名参数，但是参数对象析构是下一个最好的方法。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="42ea" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">h.无序参数</h1><p id="9316" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">另一个重要的好处是，命名参数由于被指定为对象属性，所以基本上不是有序的。这意味着我们可以按照我们想要的任何顺序指定输入:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="febf" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">调用点不再被像<code class="fe lw lx ly lz b">undefined</code>这样的有序占位符弄得乱七八糟，以跳过一个参数。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="055c" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">功能输出</h1><p id="0924" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">本节涵盖了<em class="lq">功能输出</em>的更多方面。</p><p id="2341" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">在JavaScript中，<code class="fe lw lx ly lz b">functions</code>总是<code class="fe lw lx ly lz b">return</code>一个值。这三个函数都有相同的<code class="fe lw lx ly lz b">return</code>行为:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f8a0" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">如果没有<code class="fe lw lx ly lz b">return</code>或者只有一个空的<code class="fe lw lx ly lz b">return;</code>，那么<code class="fe lw lx ly lz b">undefined</code>值就是隐含的<code class="fe lw lx ly lz b">returned</code>。</p><p id="fb00" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">但是尽可能保持<strong class="kw io">函数式编程函数</strong>定义的精神——使用函数而不是过程——我们的函数应该总是有输出，这意味着它们应该显式地<code class="fe lw lx ly lz b">return</code>一个值，通常不是<code class="fe lw lx ly lz b">undefined</code>。</p><p id="9da3" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">一个<code class="fe lw lx ly lz b">return</code>语句只能返回一个值。因此，如果您的函数需要返回多个值，您唯一可行的选择是将它们收集到一个复合值中，如数组或对象:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="33f6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">然后，我们将从从<code class="fe lw lx ly lz b">f()</code>返回的数组中的两个项目中分别分配<code class="fe lw lx ly lz b">x</code>和<code class="fe lw lx ly lz b">y</code>:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c352" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">将多个值收集到要返回的数组(或对象)中，然后将这些值析构回不同的赋值，这是一种透明地表示函数的多个输出的方法。</p><p id="ed46" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">让我们介绍一些与<em class="lq">功能输出</em>相关的概念，主要是:</p><ul class=""><li id="cfdf" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp nq mg mh mi bi translated">早期回报</li><li id="9b11" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">未编辑的输出</li><li id="5c6c" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">高阶函数(HOFs或函数的函数)</li></ul></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="7ce8" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">a.早期回报</h1><p id="9789" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe lw lx ly lz b">return</code>语句不只是从<code class="fe lw lx ly lz b">function</code>返回一个值。这也是一个流量控制结构；它在该点结束<code class="fe lw lx ly lz b">function</code>的执行。</p><p id="ffe4" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">具有多个<code class="fe lw lx ly lz b">return</code>语句的<code class="fe lw lx ly lz b">function</code>因此有多个可能的出口点，这意味着如果有许多路径可以产生输出，那么阅读一个函数来理解它的输出行为可能会更加困难。</p><p id="3479" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">考虑:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4a7c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">首先，<code class="fe lw lx ly lz b">f(x)</code>很难读懂，也很难理解。在你的头脑中预演这个是非常乏味的。这是因为我们使用<code class="fe lw lx ly lz b">return</code>不仅仅是为了返回不同的值，也是为了在某些情况下作为一个流控制结构提前退出函数的执行。</p><p id="f2a6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">考虑这个版本的代码:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b2fe" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">这个版本无疑更加冗长。但是它遵循的逻辑稍微简单一些，因为每一个<code class="fe lw lx ly lz b">retValue</code>可以被置位的分支都由条件<em class="lq">保护</em>，条件检查它是否已经被置位。</p><p id="d919" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">我们使用正常的流程控制(<code class="fe lw lx ly lz b">if</code>逻辑)来确定<code class="fe lw lx ly lz b">retValue</code>的赋值，而不是提前从函数中退出。最后，我们简单地称之为<code class="fe lw lx ly lz b">return retValue</code>。</p><p id="e27f" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">总之，结尾只有一个<code class="fe lw lx ly lz b">return</code>更具可读性。尝试找出最明确的方式来表达逻辑。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="7777" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">b.未激活的输出</h1><p id="1291" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">您可能在自己编写的大部分代码中使用过一个技术，可能甚至没有考虑太多，就是通过简单地改变函数外部的变量，让函数输出它的部分或全部值。</p><p id="277d" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">还记得我们之前的函数吗？我们可以在JS中这样定义它:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bb80" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">我们可以很容易地用<code class="fe lw lx ly lz b">return</code> d值，而不是从函数内部将它设置为<code class="fe lw lx ly lz b">y</code>:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c65c" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">两个函数完成相同的任务，那么我们有理由选择一个版本而不是另一个吗？</p><p id="984d" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">解释差异的一种方式是，后一版本中的<code class="fe lw lx ly lz b">return</code>表示一个<strong class="kw io">显式输出</strong>，而前一版本中的<code class="fe lw lx ly lz b">y</code>赋值是一个<strong class="kw io">隐式输出</strong>。</p><p id="337b" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">但是在外部作用域中改变变量，就像我们在<code class="fe lw lx ly lz b">f(..)</code>内部对<code class="fe lw lx ly lz b">y</code>赋值一样，只是实现隐式输出的一种方式。一个更微妙的例子是通过引用修改非本地值。</p><p id="1755" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">考虑:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="265d" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">这个函数最明显的输出是sum <code class="fe lw lx ly lz b">124</code>，我们明确地对其进行了<code class="fe lw lx ly lz b">return</code>运算。但是位置<code class="fe lw lx ly lz b">4</code>中没有<code class="fe lw lx ly lz b">undefined</code>空槽值，现在有了一个<code class="fe lw lx ly lz b">0</code>。</p><p id="b2ce" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">看起来无害的<code class="fe lw lx ly lz b">list[i] = 0</code>操作最终影响了外部的数组值，即使我们操作的是一个局部<code class="fe lw lx ly lz b">list</code>参数变量。</p><p id="10fb" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">为什么？因为<code class="fe lw lx ly lz b">list</code>保存的是<code class="fe lw lx ly lz b">nums</code>引用的引用副本，而不是<code class="fe lw lx ly lz b">[1,3,9,..]</code>数组值的值副本。JavaScript使用数组、对象和函数的引用和引用副本，所以我们很容易从函数中创建一个意外的输出。</p><p id="5587" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">这种隐函数输出在FP界有个特别的名字:<strong class="kw io">副作用</strong>。而一个<em class="lq">没有副作用</em>的函数也有一个特殊的名字:<strong class="kw io">纯函数</strong>。这两个概念将在下一篇文章中讨论。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="a1c7" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">c.高阶函数(HOFs或函数的函数)</h1><p id="00ee" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">函数可以接收和返回任何类型的值。接收或返回一个或多个其他函数值的函数有一个特殊的名字:<strong class="kw io"> <em class="lq">高阶函数</em> </strong>。</p><p id="8ebd" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">考虑:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="77ad" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated"><code class="fe lw lx ly lz b">forEach(..)</code>是高阶函数，因为它接收一个函数作为参数。</p><p id="a472" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">高阶函数也可以输出另一个函数，比如:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f9af" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated"><code class="fe lw lx ly lz b">return</code>不是“输出”一个内部函数的唯一方式:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="32c6" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">将其他函数视为值的函数根据定义是<strong class="kw io">高阶函数</strong>。这些对于函数式编程都是非常关键的！</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="cd8d" class="kc kd in bd ke kf mv kh ki kj mw kl km jt mx ju ko jw my jx kq jz mz ka ks kt bi translated">摘要</h1><p id="8f78" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们在本文中介绍了以下概念:</p><ol class=""><li id="075b" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp mf mg mh mi bi translated"><strong class="kw io">功能</strong>是什么？</li><li id="54e2" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><strong class="kw io">声明式</strong> <em class="lq">与</em> <strong class="kw io">命令式</strong>编程</li><li id="1de1" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">功能<strong class="kw io">输入</strong></li></ol><ul class=""><li id="52f2" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp nq mg mh mi bi translated">自变量和参数</li><li id="62b1" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">默认参数</li><li id="7149" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">计数输入</li><li id="f928" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">参数数组</li><li id="96fb" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">参数析构</li><li id="7763" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">声明式风格的好处</li><li id="6272" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">命名参数</li><li id="6d59" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">无序参数</li></ul><p id="119a" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">4.功能<strong class="kw io">输出</strong></p><ul class=""><li id="100d" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp nq mg mh mi bi translated">早期回报</li><li id="0f08" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">联合国<code class="fe lw lx ly lz b">return</code>的产出</li><li id="6c83" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp nq mg mh mi bi translated">高阶函数(HOFs或函数的函数)</li></ul><p id="d601" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">下一篇文章将涉及:</p><ol class=""><li id="1ce5" class="ma mb in kw b kx lr la ls ld mc lh md ll me lp mf mg mh mi bi translated"><strong class="kw io">函数纯度</strong>(纯<em class="lq">对</em>不纯函数)</li><li id="204a" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><strong class="kw io">副作用</strong></li><li id="ada2" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">提取并容纳<strong class="kw io">杂质</strong></li><li id="c6ec" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">所有这些如何共同定义<em class="lq">什么是</em> <strong class="kw io">功能编程</strong>，以及<em class="lq">为什么使用</em></li><li id="f08d" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><code class="fe lw lx ly lz b">JavaScript</code>是不是一种<em class="lq">函数式编程</em>语言？</li><li id="c44a" class="ma mb in kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">为什么要为你的代码考虑<strong class="kw io"> <em class="lq">函数式编程</em> </strong>风格？</li></ol><h1 id="98a0" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">非常感谢你的阅读！❤️</h1><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/69de7dfd6d7ae507fb8e53a83d9d62b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/0*S7_i-yw43gdDyGjw"/></div></figure></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="034f" class="pw-post-body-paragraph ku kv in kw b kx lr jo kz la ls jr lc ld lt lf lg lh lu lj lk ll lv ln lo lp ig bi translated">【https://anmshpndy.com/functional-javascript-fundamentals】最初发表于:<a class="ae ns" href="https://anmshpndy.com/functional-javascript-fundamentals" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>