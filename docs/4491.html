<html>
<head>
<title>6 React Mistakes I Saw a Junior Developer Make (And How to Avoid Them)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6对我看到的初级开发人员犯的错误做出反应(以及如何避免它们)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/6-react-mistakes-i-saw-a-junior-developer-make-and-how-to-avoid-them-ed137b148f5a?source=collection_archive---------7-----------------------#2021-09-07">https://javascript.plainenglish.io/6-react-mistakes-i-saw-a-junior-developer-make-and-how-to-avoid-them-ed137b148f5a?source=collection_archive---------7-----------------------#2021-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1961" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我开始觉得我一定是个糟糕的老师</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/84aa1e9540df90b63742db7be85ca2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wsq-tNGiklKS8Zzl4EmPGQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@katlove?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kat Love</a> on <a class="ae ks" href="https://unsplash.com/s/photos/despair?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8f13" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">作为一名有几年开发经验的经理，我经常有初级开发人员或实习生来找我，试图理解为什么他们的代码没有像他们期望的那样运行。在React中编码时，这通常源于对useState的行为方式缺乏理解。这里是我在开发人员理解<code class="fe lp lq lr ls b">useState</code>如何工作的过程中看到的六个错误。</p><h1 id="5a94" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">状态不够</h1><p id="76b8" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">这是一个(非常)初级开发人员犯的第一个错误，他还不明白什么时候调用React组件函数。他在一个<code class="fe lp lq lr ls b">onClick</code>回调中改变了一个变量，然后想知道为什么这个改变没有在屏幕上显示出来。通常，应用程序外部的任何东西<em class="mq">都应该存储在某个地方，无论是用户点击的内容还是API调用的返回结果。“你需要在状态中存储这个”，我告诉他“否则它不会在帧之间被记住”。</em></p><h1 id="8da6" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">太多的状态</h1><p id="f608" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">下一个错误是上一个错误的升级(由同一个人犯的),钟摆向另一个方向摆动。他如此专注于确保所有的数据都被安全地存储，以至于他还包括了其他状态的计算值。当然，如果只是代码混乱的问题，他可能不会寻求帮助。但是他每点击一次，显示屏就会更新一次。浏览代码时，我看到他在做这样的事情:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="dbf3" class="mv lu in ls b gy mw mx l my mz">if (condition) setScore(score +1);</span><span id="24cf" class="mv lu in ls b gy na mx l my mz">if (score &gt; 0) setButtonActive(true);</span></pre><p id="a686" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的代码中，<code class="fe lp lq lr ls b">score</code>在两行之间没有改变(因为我们在同一个渲染帧中)，此外，第二行存储了一些可以简单地从状态变量中推断出来的东西，这就是为什么显示没有被更新。“你不需要存储所有的东西”，我告诉他，“你可以从其他状态变量推断出的逻辑不需要存储”。</p><h1 id="9284" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">多次更新相同的状态</h1><p id="9956" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">在他的代码中的另一个地方，我的朋友写了类似这样的东西:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="bc60" class="mv lu in ls b gy mw mx l my mz">if (condition) setScore(score +1);<br/>// and then a few lines later<br/>if (condition2) setScore(score +1);</span></pre><p id="73e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，同样的问题正在发生，两者之间的状态没有更新，这导致了其他问题。解决这个问题的一种方法可能是创建一个代理变量，我们只在最后更新它，但是，状态更新函数允许我们传递一个函数，这个函数允许我们用它的未来值来操作状态(因为状态更新是异步批处理的)。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="81de" class="mv lu in ls b gy mw mx l my mz">if (condition) setScore((previous) =&gt; previous +1);<br/>// and then a few lines later<br/>if (condition2) setScore((previous) =&gt; previous +1);</span></pre><p id="f7ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有一点我没有向他提出，因为他还没有完全明白，那就是当状态有需要以协调或重要的方式更新的相互依赖的变量时，最好是调用<code class="fe lp lq lr ls b">useReducer</code>。但是他不在那里。还没有。</p><h1 id="ab9d" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">在渲染中重新定义太多</h1><p id="bd03" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">几天后，他回来了。他有一个表单，他确信自己做的一切都是正确的，但是每次他在HTML表单中输入数据时，状态都会被重新初始化。现在，在这一点上，我想说清楚，这是一个既非常聪明又非常好的人。然而，他刚刚开始学习React，所以他几乎犯了所有可能犯的错误，我开始怀疑让他使用React开发是否明智。但那是实习，他是来学习的。经验通常只是过去错误的总和，所以按照这个标准……一切都进行得很好<em class="mq"/>。</p><p id="e1f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">他认真考虑了我关于重新计算不需要存储的数据的建议。但是他对这一切有点太热情了。对话大概是这样的:</p><p id="29a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">—等等，这个组件从哪里开始？</p><p id="384f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">––就在文件的顶部，这里。</p><p id="b858" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">––它在哪里结束？我找不到尽头。</p><p id="a1b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">—在文件的底部。</p><p id="0e39" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">—这中间是什么？</p><p id="e307" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">—它是我定义的函数和常量，以及HTML表单的组件。因为我需要这个组件中的状态与主组件共享。</p><p id="9643" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但愿他没有看到我脸上绝望的表情，我很确定那一定是我的表情。</p><p id="aa32" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“所有的常量和函数，只要提供逻辑而不操纵状态，都可以从组件中移出，放到一个单独的文件中。您可以导入您的入口点并使用它们。”我告诉他了。“在主组件中重新定义了表单组件……你在每一帧中都完全重新定义了它，所以你实际上在每次更新时都显示了一个新组件。”</p><p id="80a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们最终对那段代码做了大量的重构。</p><h1 id="5730" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">仅仅依靠初始道具来定义状态</h1><p id="61a3" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">这一次，我必须承认，我个人犯了罪。我创建了一个组件，它基本上显示了一个基于我传递给它的道具的圆形进度条。所以它像这样存储它的状态:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="03f1" class="mv lu in ls b gy mw mx l my mz">const [progress, setProgress] = useState(props.init);</span></pre><p id="4959" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，这样做的问题是，一旦第一次初始化完成，道具的任何改变都不会影响状态。</p><p id="db68" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有两种可能的解决方案，这取决于组件中到底在做什么。如果组件没有任何更新状态的内部逻辑，您实际上不需要存储状态。但是在我的具体例子中，我确实需要状态，所以我使用了<code class="fe lp lq lr ls b">useEffect</code>:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="3bd7" class="mv lu in ls b gy mw mx l my mz">const [progress, setProgress] = useState(props.init);</span><span id="0eda" class="mv lu in ls b gy na mx l my mz">useEffect(()=&gt; { <br/>  setProgress(props.init);<br/>}, [props.init]); </span></pre><h1 id="ec4b" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">用变异的对象更新状态</h1><p id="a33c" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">这是一个典型的错误，源于对对象在JavaScript中如何工作缺乏理解，更具体地说，是对对象进行变异不会触发React的变化检测。这是因为对象的赋值是通过引用的，也就是说，当你把一个对象赋给一个变量时，你实际上只是把指向这个对象的指针存储在你的变量中，所以两个变量可以指向同一个对象。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="4a53" class="mv lu in ls b gy mw mx l my mz">let a = {name:"Bob"};<br/>let b = a;<br/>b.name = "Alice";<br/>// here a==b and a.name == "Alice";</span></pre><p id="ca5b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用React术语来说，这意味着这样做不会更新显示，因为状态变量的值不会改变，它总是指向同一个对象:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="e194" class="mv lu in ls b gy mw mx l my mz">const [state, setState]=useState({score:0});<br/>const onClick =() =&gt; {<br/>  state.score += 1;<br/>  setState(state);<br/>}</span></pre><p id="5dbe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，解决方案(除了在上面的例子中使用标量，但是请原谅我)是创建状态的副本，例如使用spread操作符或者通过声明一个新的对象:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="0467" class="mv lu in ls b gy mw mx l my mz">const [state, setState]=useState({score:0});<br/>const onClick =() =&gt; {<br/>   setState({..state, score: state.score+1});<br/>}</span></pre><h1 id="89c8" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">不要评判</h1><p id="6d1a" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">虽然这是一条崎岖不平的道路，但我的同事在学习React的过程中获得了乐趣。我很确定我犯的错误至少和他一样多，当我看到我的旧代码时，我有时会退缩。老实说，我从这次经历中获益良多。解释事物是如何工作的是一种保持学习的好方法，也是一种令人满意的经历。</p><p id="a430" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mq">更多内容看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>