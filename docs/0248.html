<html>
<head>
<title>Create Redux-like Middleware for useReducer in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中为useReducer创建类似Redux的中间件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-redux-like-middleware-for-usereducer-in-react-786a0a28545c?source=collection_archive---------6-----------------------#2021-01-14">https://javascript.plainenglish.io/create-redux-like-middleware-for-usereducer-in-react-786a0a28545c?source=collection_archive---------6-----------------------#2021-01-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b27a2fb2921b3345a4f2793e57db8428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ezomQWdaUGJYyHOX.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="dcf3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果你以前用过Redux，你会知道中间件的概念。既然useReducer已经成为一个常用的react钩子，我们可能也想为useReducer钩子复制中间件的思想。</p><p id="a34a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果您不了解中间件，中间件是在reducer发生状态转换之前或之后运行的函数。它使我们能够选择日志记录、崩溃报告、异步API请求等功能。</p><p id="a77e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在本帖中，我们将为useReducer react hook创建一个中间件。如果你想了解更多关于钩子和减速器的信息，请参考我们之前关于<a class="ae la" href="https://www.wisdomgeek.com/development/web-development/react/understanding-the-usereducer-hook-in-react/" rel="noopener ugc nofollow" target="_blank"> useReducer React钩子</a>的帖子。</p><h1 id="9bb7" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为用户创建中间件的可能方法</h1><p id="d89b" class="pw-post-body-paragraph kc kd in ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ig bi translated">我们可以用两种方式之一来实现中间件功能:</p><p id="3302" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">1.写一个类似redux的applyMiddleware函数。这个函数将第一个参数作为缩减器，我们将中间件作为数组传递给第二个参数。<br/>这看起来像这样:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a9c7" class="mn lc in mj b gy mo mp l mq mr">const useMyReducer = applyMiddleware(useReducer, [logging, thunks, ...]);</span></pre><p id="d029" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">你可以在本期GitHub<a class="ae la" href="https://github.com/streamich/react-use/issues/164" rel="noopener ugc nofollow" target="_blank">T4中读到更多关于这种方法的内容。最终实现可以在</a><a class="ae la" href="https://github.com/streamich/react-use/blob/master/src/createReducer.ts" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="593c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">2.我们可以创建一个<a class="ae la" href="https://www.wisdomgeek.com/development/web-development/react/how-to-write-your-own-custom-react-hooks/" rel="noopener ugc nofollow" target="_blank">自定义的react钩子</a>，它在内部实现useReducer，并为我们提供作为参数传入中间件的功能。</p><p id="9b78" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们将在这篇博文中讨论第二种方法。第一种方法也是可以接受的。但是我的观点是，如果我们从钩子的角度来考虑，我们应该在钩子方面向前迈进，而不是抓住重复模式不放。</p><h1 id="e46e" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">面向用户的单一中间件用户</h1><p id="21cf" class="pw-post-body-paragraph kc kd in ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ig bi translated">让我们首先定义我们将要构建的这个自定义react挂钩的外观。我们将从单个中间件开始。稍后，我们将通过使我们的实现通用化来逐步实现多个中间件。</p><p id="1895" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的useReducer中间件将接受一个Reducer作为参数，以及初始状态。它还将中间件作为另一个参数。因此，我们的钩子将具有如下形式:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5358" class="mn lc in mj b gy mo mp l mq mr">const useReducerWithMiddleware = (reducer,<br/>  initialState,<br/>  middleware,<br/>) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/>  // TODO: middleware logic <br/>  return [state, dispatch];<br/>};</span></pre><p id="22cc" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">对于中间件函数的调用，在useReducer声明之后在钩子内部调用它是不够的。我们希望每次调用dispatch时都调用中间件函数。所以我们需要返回一个修改过的函数，而不是直接返回dispatch。</p><p id="c6f3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们可以用高阶函数来解决这个问题。我们将通过围绕它创建一个高阶函数来增强调度函数。然后我们将从钩子返回高阶函数。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1ca5" class="mn lc in mj b gy mo mp l mq mr">const useReducerWithMiddleware = (reducer,<br/>  initialState,<br/>  middleware,<br/>) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/>  <strong class="mj io">const dispatchUsingMiddleware = (action) =&gt; {<br/>    middleware(action);<br/>    dispatch(action);<br/>  }</strong><br/>  return [state, dispatchUsingMiddleware];<br/>};</span></pre><p id="c19d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">因为我们从我们的定制钩子返回扩展的分派函数，所以我们确保每当调用者为useReducer钩子调用我们的定制中间件时，中间件都会被调用。</p><p id="74df" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们甚至可以将状态等其他信息添加到中间件调用中。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f835" class="mn lc in mj b gy mo mp l mq mr">const useReducerWithMiddleware = (reducer,<br/>  initialState,<br/>  middleware,<br/>) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/>  const dispatchUsingMiddleware = (action) =&gt; {<br/>   <strong class="mj io"> middleware(action, state);</strong><br/>    dispatch(action);<br/>  }<br/>  return [state, dispatchUsingMiddleware];<br/>};</span></pre><h1 id="5969" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用户的多个中间件</h1><p id="4a4b" class="pw-post-body-paragraph kc kd in ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ig bi translated">让我们扩展一下我们之前为useReducer实现的中间件，以接受多个中间件功能作为一个数组。</p><p id="f439" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">因为所有的中间件功能都应该在调用dispatch之前被调用，所以我们将遍历它们。然后，我们会呼叫调度。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1106" class="mn lc in mj b gy mo mp l mq mr">const useReducerWithMiddleware = (reducer,<br/>  initialState,<br/>  middlewares,<br/>) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/>  const dispatchUsingMiddleware = (action) =&gt; {<br/>    <strong class="mj io">middlewares.map((middleware) =&gt; middleware(action, state));</strong><br/>    dispatch(action);<br/>  }<br/>  return [state, dispatchUsingMiddleware];<br/>};</span></pre><p id="42f6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果我们在做一些异步中间件，我们必须修改这个逻辑来使用async/await。但是我们将这部分排除在这篇文章的讨论范围之外。</p><p id="e03f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">但是，如果我们希望中间件在状态转换之后执行，也就是在调度调用之后执行，该怎么办呢？</p><h1 id="af51" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">状态改变后的中间件</h1><p id="e18c" class="pw-post-body-paragraph kc kd in ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ig bi translated">如果您认为我们会为中间件创建另一个输入数组以便在分派后执行，那么您绝对是正确的！</p><p id="dcf0" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">但是，如果您考虑在调度调用后立即调用这些函数，比如:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e79f" class="mn lc in mj b gy mo mp l mq mr">const useReducerWithMiddleware = (reducer,<br/>  initialState,<br/>  middlewares,<br/>  afterDispatchMiddleWares<br/>) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/>  const dispatchUsingMiddleware = (action) =&gt; {<br/>    middlewares.map((middleware) =&gt; middleware(action, state));<br/>    dispatch(action);<br/>    afterDispatchMiddleWares.map((middleware) =&gt; middleware(action, state));<br/>  }<br/>  return [state, dispatchUsingMiddleware];<br/>};</span></pre><p id="27eb" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">不幸的是，这是行不通的。</p><p id="7d5f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">你能想出原因吗？</p><p id="7a1a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这是因为调度异步更新状态。</p><p id="56e1" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">可以做些什么来代替呢？</p><p id="7f24" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们可以等待状态更新，然后用回调函数来处理这个问题。我们可以使用<a class="ae la" href="https://www.wisdomgeek.com/development/web-development/react/react-hooks-and-local-storage-lets-build-a-todo-app/" rel="noopener ugc nofollow" target="_blank"> useEffect钩子</a>来实现这一点。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1199" class="mn lc in mj b gy mo mp l mq mr">const useReducerWithMiddleware = (reducer,<br/>  initialState,<br/>  middlewares,<br/>  afterDispatchMiddleWares<br/>) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/> <strong class="mj io"> useEffect(() =&gt; {<br/>    afterDispatchMiddleWares.map((middleware) =&gt; middleware(action, state));<br/>  }, [afterDispatchMiddleWares]);</strong></span><span id="0083" class="mn lc in mj b gy ms mp l mq mr">  const dispatchUsingMiddleware = (action) =&gt; {<br/>    middlewares.map((middleware) =&gt; middleware(action, state));<br/>    dispatch(action);<br/>  }<br/>  return [state, dispatchUsingMiddleware];<br/>};</span></pre><p id="0d24" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">但是我们再也不能访问useEffect中的动作了。因此，我们需要通过使用useRef钩子来使用ref实例变量。在调用dispatch之前，我们将把动作的值写入ref变量。然后它的值将在效果中对我们可用。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1d8d" class="mn lc in mj b gy mo mp l mq mr">const useReducerWithMiddleware = (reducer,<br/>  initialState,<br/>  middlewares,<br/>  afterDispatchMiddleWares<br/>) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/>  <strong class="mj io">const currentRef = React.useRef();</strong><br/>  <strong class="mj io">useEffect(() =&gt; {<br/>    if (!currentRef.current) return;<br/>    afterDispatchMiddleWares.map((middleware) =&gt; middleware(currentRef.current, state));<br/>  }, [afterDispatchMiddleWares, state]);</strong></span><span id="4987" class="mn lc in mj b gy ms mp l mq mr">  const dispatchUsingMiddleware = (action) =&gt; {<br/>    middlewares.map((middleware) =&gt; middleware(action, state));<br/>    currentRef.current = action;<br/>    dispatch(action);<br/>  }<br/>  return [state, dispatchUsingMiddleware];<br/>};</span></pre><h1 id="fba7" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="70f8" class="pw-post-body-paragraph kc kd in ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ig bi translated">这就完成了我们使用useReducer应用中间件的实现。我们现在可以在React钩子发生状态转换之前和之后运行中间件。如果你有任何疑问，请在评论中告诉我们。</p><p id="5b82" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><em class="mt">原载于2021年1月14日</em><a class="ae la" href="https://www.wisdomgeek.com/development/web-development/react/use-redux-like-middleware-for-usereducer-in-react/" rel="noopener ugc nofollow" target="_blank"><em class="mt">【https://www.wisdomgeek.com】</em></a><em class="mt">。</em></p></div></div>    
</body>
</html>