<html>
<head>
<title>16 Conceptual React Questions to Stand Out in Your Next Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">16个概念性反应问题，让你在下次面试中脱颖而出</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/16-conceptual-react-questions-to-stand-out-in-your-next-interview-4b0e9c7f8186?source=collection_archive---------4-----------------------#2021-08-23">https://javascript.plainenglish.io/16-conceptual-react-questions-to-stand-out-in-your-next-interview-4b0e9c7f8186?source=collection_archive---------4-----------------------#2021-08-23</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="0f74" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">你能处理这些反应问题吗？让我们来了解一下！</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/6c1c4b4be3014a90c97ad70576d75d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SSGFux5qKW1JmMiZldUwQ.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@rstone_design?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ryan Stone</a> on <a class="ae kw" href="https://unsplash.com/s/photos/weird?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e298" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在面试中回答一个概念性的问题并不意味着你会比工作中的其他人更好，但它肯定意味着你有时间和兴趣去理解一个框架中的深层概念。</p><blockquote class="lt"><p id="4a59" class="lu lv ir bd lw lx ly lz ma mb mc ls dk translated">一个人对文档的理解将一个好的开发人员与一个伟大的开发人员区分开来。</p></blockquote><p id="d085" class="pw-post-body-paragraph kx ky ir kz b la md js lc ld me jv lf lg mf li lj lk mg lm ln lo mh lq lr ls ik bi translated">嗯，今天，我们将探讨一些作为React开发人员可能想知道的概念性问题。如果您正在寻找简单的语法相关问题，那么这篇文章不适合您！</p><p id="9c6a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们开始吧！</p><h1 id="e0dc" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">1.React中渲染劫持是什么？</h1><p id="677d" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated"><a class="ae kw" href="https://stackoverflow.com/questions/48144659/what-is-render-hijacking-in-react" rel="noopener ugc nofollow" target="_blank">正如谷歌先生所说</a>，渲染劫持是</p><blockquote class="nf ng nh"><p id="b2d9" class="kx ky ni kz b la lb js lc ld le jv lf nj lh li lj nk ll lm ln nl lp lq lr ls ik bi translated">“渲染劫持的概念是控制一个组件从另一个组件输出什么的能力”。</p></blockquote><p id="228e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">实际上，您用另一个高阶组件(HOC)包装您的组件。然后，根据需要注入道具，这会导致渲染逻辑发生变化。</p><p id="8936" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">基本上，你所做的就是让组件有不同的行为。</p><h1 id="518f" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">2.如果在构造函数中使用setState()会怎么样？</h1><p id="661f" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">当你使用<code class="fe nm nn no np b">setState()</code> React再次渲染整个组件。因此，如果在构造函数内部调用<code class="fe nm nn no np b">setState()</code>，React会尝试重新呈现不存在的组件，从而产生一个递归问题。</p><p id="8a96" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您会得到类似这样的错误:</p><pre class="kh ki kj kk gu nq np nr ns aw nt bi"><span id="920e" class="nu mj ir np b gz nv nw l nx ny">Can only update a mounted or mounting component.</span></pre><p id="1597" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">所以我们需要使用<code class="fe nm nn no np b">this.state</code>来初始化构造函数内部的变量。像下面这样</p><pre class="kh ki kj kk gu nq np nr ns aw nt bi"><span id="ce8c" class="nu mj ir np b gz nv nw l nx ny">constructor(props) {<br/>    this.state = {<br/>        // anything that you want inside state<br/>    }<br/>}</span></pre><h1 id="ef16" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">3.React中的合成事件是什么？</h1><p id="2128" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">事件是任何浏览器必不可少的部分。像<code class="fe nm nn no np b">onclick</code>、<code class="fe nm nn no np b">onscroll</code>等。但是由于React使用虚拟dom，我们需要一个在不同浏览器上一致工作的包装器。</p><blockquote class="nf ng nh"><p id="34f3" class="kx ky ni kz b la lb js lc ld le jv lf nj lh li lj nk ll lm ln nl lp lq lr ls ik bi translated">React将事件规范化，使它们在不同的浏览器中具有一致的属性。— <a class="ae kw" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank"> React文档</a></p></blockquote><p id="d0bd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，总而言之，合成事件是不同事件的跨浏览器包装器。重要的是要注意:它们与浏览器的本地事件不是一一对应的。</p><h1 id="5d02" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">4.React中的门户是什么？</h1><p id="60ea" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">如果您想将一些子组件呈现到组件树层次结构之外的DOM节点中，那么<a class="ae kw" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank"> React Portal </a>是一个不错的选择。</p><p id="02f4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">其语法是</p><pre class="kh ki kj kk gu nq np nr ns aw nt bi"><span id="e38d" class="nu mj ir np b gz nv nw l nx ny">ReactDOM.createPortal(child, container)</span></pre><p id="03ab" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">第一个参数是任何可呈现的React子元素，如元素、字符串或片段。第二个参数是DOM元素。</p><h1 id="b426" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">5.什么是和解？</h1><p id="5b98" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">当一个组件的道具或状态改变时，我们需要重新渲染这个组件。实际的DOM是否会被更新取决于这两个节点(以前的和当前的)之间的差异。</p><p id="1d7e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是为了比较两个节点，我们需要一个O(n)的复杂度，这在现实生活中是不实际的。这就是React团队决定使用启发式方法的原因。</p><p id="06b2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个过程的名字叫做和解。如果您有兴趣，请参考<a class="ae kw" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="3db3" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">6.为什么React使用className而不是class？</h1><p id="d183" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated"><code class="fe nm nn no np b">class</code>是JavaScript中的关键字，JSX是JavaScript的扩展。这就是React使用className而不是class的主要原因。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">ClassName.jsx</figcaption></figure><p id="1328" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">传递一个字符串作为类名属性。</p><h1 id="b32f" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">7.什么是反应纤维？</h1><p id="8356" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">纤程是React v16中核心算法的新的重新实现。我们已经讨论过协调，新的实现称为React Fiber。</p><p id="eb13" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果您有兴趣理解核心概念，这里的是很好的文档。</p><h1 id="4d8b" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">8.React Fiber的目标是什么？</h1><p id="40c2" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">React Fiber的目标是增加其在动画、布局和手势等领域的适用性。它的主要特点是增量渲染:能够将渲染工作分割成块，并分散到多个帧上。</p><h1 id="28c2" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">9.什么是不受控制的组件？</h1><p id="c334" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">在react组件中存储状态的通常方式是<code class="fe nm nn no np b">useState</code>或<code class="fe nm nn no np b">this.state</code>。但有一个问题是，它们与渲染过程紧密相关。因此，在某些情况下，你会面临一些困难。</p><p id="4b2d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你使用<code class="fe nm nn no np b">ref</code>存储一个组件的状态，那么这个组件被称为非受控组件。它更像传统的HTML</p><p id="f591" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在下面的<code class="fe nm nn no np b">UserProfile</code>组件中，使用ref来访问名称输入。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div></figure><h1 id="8890" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">10.为什么片段比容器div好？</h1><p id="bbd1" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">以下是原因列表，</p><p id="c627" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">1.通过不创建额外的DOM节点，片段速度更快，使用的内存更少。这只对又大又深的树有真正的好处。</p><p id="0eab" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">2.一些CSS机制像Flexbox和CSS Grid有特殊的父子关系，在中间添加div很难保持想要的布局。</p><p id="0efc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">3.DOM检查器不那么杂乱。</p><h1 id="118b" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">11.React的局限性是什么？</h1><p id="fe4a" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">除了这些优点之外，React也有一些限制，</p><ol class=""><li id="cd23" class="ob oc ir kz b la lb ld le lg od lk oe lo of ls og oh oi oj bi translated">React只是一个视图库，不是一个完整的框架。</li><li id="57d4" class="ob oc ir kz b la ok ld ol lg om lk on lo oo ls og oh oi oj bi translated">对于刚接触web开发的初学者来说，有一个学习曲线。</li><li id="3579" class="ob oc ir kz b la ok ld ol lg om lk on lo oo ls og oh oi oj bi translated">将React集成到传统的MVC框架中需要一些额外的配置。</li><li id="bf25" class="ob oc ir kz b la ok ld ol lg om lk on lo oo ls og oh oi oj bi translated">代码复杂性随着内联模板和JSX而增加。</li><li id="0bbb" class="ob oc ir kz b la ok ld ol lg om lk on lo oo ls og oh oi oj bi translated">过多的小部件导致过度设计或锅炉板。</li></ol><h1 id="c787" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">12.如何为HOC组件创建props代理？</h1><p id="2fd6" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">您可以使用props代理模式添加/编辑传递给组件的props，如下所示:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nz oa l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">ProxyProps.jsx</figcaption></figure><h1 id="67ab" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">13.如果在初始状态下使用道具会怎么样？</h1><p id="1ee9" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated"><code class="fe nm nn no np b">constructor</code>函数从不更新组件的当前状态。它只在组件安装前被调用一次。</p><p id="1aea" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，假设我们正在使用props来初始化组件的状态。</p><pre class="kh ki kj kk gu nq np nr ns aw nt bi"><span id="96a8" class="nu mj ir np b gz nv nw l nx ny">function SomeComponent(props){</span><span id="a19d" class="nu mj ir np b gz op nw l nx ny">    const [count , setCount]= useState(props.count);<br/>}</span></pre><p id="f643" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在，如果<code class="fe nm nn no np b">props.count</code>从父节点改变，那么子节点将永远不会被更新，因为<code class="fe nm nn no np b">useState</code>只被调用过一次。所以通过道具来初始化状态并不是一个好主意。</p><h1 id="5008" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">14.钩子会取代渲染道具和高阶组件吗？</h1><p id="8f9b" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">渲染道具和高阶组件都只渲染一个子对象，但在大多数情况下，挂钩是一种更简单的方法，可以减少树中的嵌套。</p><h1 id="3b5c" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">15.可以不调用setState强制组件重新渲染吗？</h1><p id="7592" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">每当你的组件的状态或道具改变，组件将重新渲染。但是如果因为某种原因，我们不得不强制一个组件重新渲染，那么我们可以称之为<code class="fe nm nn no np b">foreUpdate()</code>函数。</p><pre class="kh ki kj kk gu nq np nr ns aw nt bi"><span id="383c" class="nu mj ir np b gz nv nw l nx ny">component.forceUpdate(callback)</span></pre><h1 id="cc66" class="mi mj ir bd mk ml mm mn mo mp mq mr ms jx mt jy mu ka mv kb mw kd mx ke my mz bi translated">16.为什么不能在React里更新道具？</h1><p id="4789" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">React哲学认为道具应该是不可变的，自顶向下的。这意味着父母可以发送任何属性值给孩子，但不能修改收到的属性。</p></div><div class="ab cl oq or hv os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ik il im in io"><p id="2848" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">就是这样。也许你认识他们中的一些人，也许你不认识。我想(也希望)你已经从这篇文章中学到了一些东西。</p><p id="cd3b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">祝您愉快！</p><p id="90a6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is">通过</strong><a class="ae kw" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"><strong class="kz is">LinkedIn</strong></a><strong class="kz is">或我的</strong> <a class="ae kw" href="https://www.mohammadfaisal.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz is">个人网站</strong> </a> <strong class="kz is">与我取得联系。</strong></p><h2 id="1cec" class="nu mj ir bd mk ox oy dn mo oz pa dp ms lg pb pc mu lk pd pe mw lo pf pg my ph bi translated">资源:</h2><p id="a746" class="pw-post-body-paragraph kx ky ir kz b la na js lc ld nb jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated"><strong class="kz is">合成事件:</strong><a class="ae kw" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/events.html</a><br/><strong class="kz is">反应入口:</strong><a class="ae kw" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/portals.html</a><br/><strong class="kz is">反应纤维:</strong><a class="ae kw" href="https://github.com/acdlite/react-fiber-architecture" rel="noopener ugc nofollow" target="_blank">https://github.com/acdlite/react-fiber-architecture</a></p><p id="5073" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> StackOverflow论坛:</strong><a class="ae kw" href="https://stackoverflow.com/questions/48144659/what-is-render-hijacking-in-react" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/48144659/what-is-render-jacking-in-react</a></p><p id="a88d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="ni">更多内容看</em><a class="ae kw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="ni">plain English . io</em></strong></a></p></div></div>    
</body>
</html>