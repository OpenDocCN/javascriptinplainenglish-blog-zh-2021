<html>
<head>
<title>Understanding Hooks Part 1 - Element</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解挂钩第1部分-元素</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hook-myth-from-react-9495aa8ad7af?source=collection_archive---------21-----------------------#2021-05-02">https://javascript.plainenglish.io/hook-myth-from-react-9495aa8ad7af?source=collection_archive---------21-----------------------#2021-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8f21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React里传说中的钩子背后有什么？有时候，我会想。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e42cee1f7d92219ceebab9b4725eb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLKP6AXotB79tG2MHWeheA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Captain Hooks. Find me if you can.</figcaption></figure><p id="ba58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定一个<code class="fe ky kz la lb b">Component</code>，将它传递给一个助手函数<code class="fe ky kz la lb b">component</code>，在那里它生成一个新的<code class="fe ky kz la lb b">Element</code>类供UI系统使用。在这个类中，额外的<code class="fe ky kz la lb b">Hook</code>属性，如<code class="fe ky kz la lb b">states</code>和<code class="fe ky kz la lb b">effects</code>，被分配并为<code class="fe ky kz la lb b">Hooks</code>做好准备。</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="e538" class="lg lh in lb b gy li lj l lk ll"><em class="lm">/* Implementation */<br/></em>function component(<strong class="lb io">renderer</strong>) {<br/>  class Element {<br/>    constructor() {<br/>      this.<strong class="lb io">renderer</strong> = <strong class="lb io">renderer</strong><br/>      this.<strong class="lb io">states</strong> = {}<br/>      this.<strong class="lb io">effects</strong> = {}<br/>      this.<strong class="lb io">queued</strong> = false<br/>    }<br/>    ...<br/>  }<br/>  return Element<br/>}</span><span id="a5a4" class="lg lh in lb b gy ln lj l lk ll"><em class="lm">/* Usage */<br/></em>const Component = () =&gt; &lt;div /&gt;<br/>component(<strong class="lb io">Component</strong>)  // can be transparent to us</span></pre><h2 id="7413" class="lg lh in bd lo lp lq dn lr ls lt dp lu jv lv lw lx jz ly lz ma kd mb mc md me bi translated">钩</h2><p id="f13c" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">将<code class="fe ky kz la lb b">useEffect</code>实现与用法放在一起。注意<code class="fe ky kz la lb b">useEffect</code>通过将<code class="fe ky kz la lb b">callback</code>添加到注册列表<code class="fe ky kz la lb b">effects</code>来注册它。</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="94bb" class="lg lh in lb b gy li lj l lk ll"><em class="lm">/* Implementation */<br/></em>function useEffect(<strong class="lb io">callback</strong>) {<br/>  <em class="lm">const id = notify()</em><br/>  if (!element.<strong class="lb io">effects</strong>[id]) <br/>    element.<strong class="lb io">effects</strong>[id] = <strong class="lb io">callback</strong><br/>}</span><span id="b1d6" class="lg lh in lb b gy ln lj l lk ll"><em class="lm">/* Usage */<br/></em>function <strong class="lb io">Component</strong>() {<br/>  useEffect(() =&gt; { window.title = "ABC" })<br/>}</span></pre><blockquote class="mk ml mm"><p id="548d" class="jk jl lm jm b jn jo jp jq jr js jt ju mn jw jx jy mo ka kb kc mp ke kf kg kh ig bi translated">钩子<code class="fe ky kz la lb b">id</code>根据其在<code class="fe ky kz la lb b">Component</code>内部出现的位置唯一生成。由于这种缓存，它不会在多次渲染中注册两次。</p></blockquote><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="c871" class="lg lh in lb b gy li lj l lk ll">/* Implementation */<br/>function useState(initialState) {<br/><em class="lm">  const id = notify()<br/></em>  <strong class="lb io">element</strong>.<strong class="lb io">states</strong>[id] = initialState</span><span id="62f5" class="lg lh in lb b gy ln lj l lk ll">  const setState = (newState) =&gt; {<br/>    <strong class="lb io">element</strong>.<strong class="lb io">states</strong>[id] = newState<br/>    <strong class="lb io">element</strong>.<strong class="lb io">_update</strong>()<br/>  }</span><span id="d4f7" class="lg lh in lb b gy ln lj l lk ll">  return [<strong class="lb io">state</strong>, <strong class="lb io">setState</strong>]<br/>}</span><span id="f802" class="lg lh in lb b gy ln lj l lk ll"><em class="lm">/* Usage */<br/></em>function <strong class="lb io">Component</strong>() {<br/>  const [<strong class="lb io">count</strong>, <strong class="lb io">setCount</strong>] = useState(0);<br/>}</span></pre><p id="0b7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，<code class="fe ky kz la lb b">useState</code>将<code class="fe ky kz la lb b">state</code>和<code class="fe ky kz la lb b">setState</code>与挂钩<code class="fe ky kz la lb b">id</code>对齐。注意调用<code class="fe ky kz la lb b">setState</code>会触发更新。</p><h2 id="81ae" class="lg lh in bd lo lp lq dn lr ls lt dp lu jv lv lw lx jz ly lz ma kd mb mc md me bi translated">更新</h2><p id="b2f3" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">当进入元素更新周期时，它检查元素是否已经排队等待更新。如果还没有，它将请求渲染它并将结果提交给<code class="fe ky kz la lb b">DOM</code>。</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="92e6" class="lg lh in lb b gy li lj l lk ll">function _update() {<br/>  if (this.<strong class="lb io">queued</strong>) return<br/>  schedule(() =&gt; {<br/>    let result = this.<strong class="lb io">_render</strong>(element)<br/>    schedule(() =&gt; {<br/>      this.<strong class="lb io">_commit</strong>(result)<br/>      for (let e of this.<strong class="lb io">effects</strong>) e.call(this)<br/>    })<br/>    this.<strong class="lb io">queued</strong> = false<br/>  })<br/>  this.<strong class="lb io">queued</strong> = true<br/>}</span></pre><p id="c408" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">渲染函数调用<code class="fe ky kz la lb b">Component</code>从而返回<code class="fe ky kz la lb b">DOM</code>元素。这和定义<code class="fe ky kz la lb b">Hooks</code>的函数是一样的。</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="94dd" class="lg lh in lb b gy li lj l lk ll">function _render() {<br/>  let result = element.<strong class="lb io">apply</strong>(null, this.args)<br/>  return result;<br/>}</span></pre><p id="9462" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在更新期间，<strong class="jm io">不会在</strong>更新之前或之后，<code class="fe ky kz la lb b">Hooks</code>得到注册。此外，更新后，所有注册的<code class="fe ky kz la lb b">effects</code>都有机会被调用。</p><h2 id="4ffe" class="lg lh in bd lo lp lq dn lr ls lt dp lu jv lv lw lx jz ly lz ma kd mb mc md me bi translated"><strong class="ak">TL；博士</strong></h2><p id="7e86" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><strong class="jm io">一个钩子</strong>，通过一个<code class="fe ky kz la lb b">Element</code>类，在第一次更新时被注册，并且可以:</p><ul class=""><li id="2369" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated">渲染后触发<code class="fe ky kz la lb b">effect</code>(<code class="fe ky kz la lb b">useEffect</code>)</li><li id="d775" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">通过<code class="fe ky kz la lb b">state</code>变化(<code class="fe ky kz la lb b">useState</code>)触发渲染</li></ul><h1 id="3141" class="ne lh in bd lo nf ng nh lr ni nj nk lu nl nm nn lx no np nq ma nr ns nt md nu bi translated">索引</h1><ul class=""><li id="7b86" class="mq mr in jm b jn mf jr mg jv nv jz nw kd nx kh mv mw mx my bi translated">第1部分，元素你在这里</li><li id="b8b2" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ny" href="https://windmaomao.medium.com/hooks-part-2-useeffect-2fa1a377c124" rel="noopener">第二部分，使用效果</a></li><li id="4a97" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ny" href="https://windmaomao.medium.com/hooks-part-3-usestate-26a622bbe462" rel="noopener">第3部分，使用状态</a></li><li id="7312" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ny" href="https://windmaomao.medium.com/understanding-hooks-part-4-hook-c7a8c7185f4e" rel="noopener">第四部，钩子</a></li><li id="d4ee" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ny" href="https://windmaomao.medium.com/understanding-hooks-part-5-custom-hook-985b83c8bfea" rel="noopener">第五部分，定制挂钩</a></li><li id="2ef9" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ny" href="https://windmaomao.medium.com/understanding-hooks-part-6-usecontext-7ece0c0818e3" rel="noopener">第6部分，使用上下文</a></li><li id="56f8" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ny" href="https://medium.com/codex/understanding-hooks-part-7-state-management-84ff636834a7" rel="noopener">第七部分，状态管理</a></li><li id="1972" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ny" href="https://windmaomao.medium.com/understanding-hooks-part-8-four-body-problem-8f70b212356d" rel="noopener">第八部，四体问题</a></li></ul><p id="d092" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lm">使用的代码片段大量借鉴并简化自</em> <a class="ae ny" href="https://github.com/matthewp/haunted" rel="noopener ugc nofollow" target="_blank"> <em class="lm">回购</em> </a> <em class="lm"> </em> <code class="fe ky kz la lb b"><em class="lm">Haunted</em></code> <em class="lm">为</em> <code class="fe ky kz la lb b"><em class="lm">lit-element</em></code> <em class="lm">的早期草案。</em></p><p id="52ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lm">更多内容请看</em><a class="ae ny" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lm">plain English . io</em></a></p></div></div>    
</body>
</html>