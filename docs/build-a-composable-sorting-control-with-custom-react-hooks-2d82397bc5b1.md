# 用自定义的 React 钩子构建一个可组合的排序控件

> 原文：<https://javascript.plainenglish.io/build-a-composable-sorting-control-with-custom-react-hooks-2d82397bc5b1?source=collection_archive---------3----------------------->

![](img/438cb64fa8ccacb315d9bf50df1b7a76.png)

sort of unrelated (by the author)

## 使用从视图组件中提取的状态和逻辑对列表进行排序

# 背景

大多数 web 应用程序需要以某种形式的列表显示数据，对数据进行排序是用户友好列表的基本特性之一。使用 [React 钩子](https://reactjs.org/docs/hooks-overview.html)，我们可以很容易地将状态和逻辑从相关的视图组件中分离出来。

自从几年前发布钩子以来，React 库变得(甚至)更容易使用。钩子实现了客户端逻辑的清晰抽象，特别是在 UI 组件状态、渲染生命周期和用户交互等副作用方面。

与早期的反应组件的 OOP 方法相反，在早期的 OOP 方法中，组件逻辑被绑定到类方法，钩子允许代码的抽象和重用，以实现更具功能性的方法。

## 问:很好，但是为什么要开发自己的表库呢，因为您可以使用现有的包含排序和更多功能的万能表库。

## 答:在大多数情况下，你可能应该这样做

数据表或列表库，尤其是那些有活跃贡献者社区的库，比如 [react-table](https://react-table.tanstack.com/) ，通常会公开排序、分页和样式的所有重要属性；允许开发人员快速配置任何列表特性。

## *然而，有足够的理由编写自己的排序实现或任何其他功能

例如:

*   **没有两个用户界面是相同的**:并非所有的数据都能在传统表格中得到最好的显示:虽然大多数数据表库在数据管理以及列、行和单元格呈现器的布局方面提供了灵活性，但您可能*仍然*需要一种更独特的显示方式来满足您的预期用户体验。
*   **包的大小很重要**:在许多项目中，所需的特性集是有限的，最干净的实现并不保证所有的样板代码和一个完整的、全能的库的大小:只编码我们从一个特定的功能中需要的东西允许我们决定到底有多少东西进入我们的应用程序。
*   **成长的烦恼伤害**:一个应用程序，其特性最初可能被第三方库覆盖，但通常(几乎总是*)会扩大范围，导致重复、复合、丑陋的事情，如配置扭曲和特殊特性*，*，直到*最不坏的*解决方案是构建和维护一个定制的脚手架，以满足每一个连续的需求。*
*   ***DIY 让你成为更好的开发人员**:不需要重新发明轮子，但是构建一个自主开发的功能所涉及的试验、错误、汗水、眼泪和咖啡因自然会为精确定制逻辑和 UI/UX 提供更多的自由。此外，从头开始推理，然后实际编写一个特性，可以提供对业务逻辑和代码实现的第一手理解，特别是当一个人厌倦了每晚熬夜，放弃了整个 DIY 策略(通常是因为有问题的项目已经过期)，然后不得不匆忙评估真正的库并确定最合适的库时。*

# *要求*

*记住这些警告，我们将从头开始编写我们自己的排序组件实现。*

*这个例子不会复制一个成熟的库的全部排序特性。相反，我们将通过满足几个基本标准来解决上述要点:*

*   *我们的排序逻辑应该是可重用和可组合的，独立于视图组件而存在。*
*   ***我们的代码应该只处理*给定数据集的排序，而不会产生副作用或干扰数据集的其他逻辑，如过滤或分页。****
*   ***虽然不是必需的，但是我们将通过使用**[**styled-components**](https://styled-components.com/)**和**[**Typescript**](https://www.typescriptlang.org/)**，尽量使我们的视图组件的布局具有可读性和一致性。***

# *示例代码*

*这个例子的核心是排序状态和相关的逻辑，我们将把它们放在一个定制的 React 钩子`useSort.ts`中，以保持它独立于显示组件。这没有太多的逻辑，但是我们将首先分解概念，然后展示整个脚本。*

***内置 React 钩子的局部状态和效果:***

*   *首先，我们用内置的`React.useState`和`React.useEffect`钩子设置本地状态和效果，允许我们跟踪特定于`useSort`的每个实例的变化；这将从可能使用它的任意数量的视图组件中删除状态和效果逻辑。*
*   *为了涵盖排序的基础知识，我们为一个`sortKey`(在下面的`SortingControl`)和一个`sortDirection`(与一个向上/向下图标按钮一起使用)声明了 getters 和 setters。*
*   *`React.useEffect`内置钩子执行`data`数组的实际排序，并在`useSort`钩子的任何依赖关系改变时更新其内部状态值。重要的是，这里还调用了`onSortChange`回调:当钩子更新它的内部`data`值时，这个回调被提供给视图组件以引起它自己的重新呈现或相关效果。
    *更新(2022 年 10 月)*:为了防止不必要的重新渲染，我们在调用`onSortChange`之前，将排序后的数据与传递给钩子的本地值进行比较。*

***UI 回调:***

*   *这些函数是为了在任何使用我们钩子的视图中可用而导出的回调函数。*
*   *`handleSortKeyChange`假设我们的按键出现在下面`SortControl`中的选择控件中*
*   *`handleDirectionToggle`也显示在`SortControl`中，在本例中仅支持升序和降序。*
*   *两者都用来更新钩子的内部状态，这将依次调用上面指定的`onSortChange`，以便随后更新适用的视图。*

***整体使用排序钩***

***类型***

*既然挂钩已经设置好了，在深入研究视图组件之前，我们将设置我们的类型。我通常更喜欢先设置类型，尽管钩子本身是这个例子的关键部分。*

***款式***

*为了将样式包装到组件中以获得简洁的布局，下面是使用`styled-components`声明的 TSX(使用 Typescript 的 JSX)构建块。该示例在 CSS flexbox 布局中使用扩展的`<div>`元素，避免了通过实际的 HTML 表格进行布局的需要。*

***分类控制***

*为了提供一个用于排序操作的用户界面，这里有一个基本的`SortControl`，它包括一个用于选择排序键的 Select，以及一个用于将排序方向从升序切换到降序的基本图标。*

*选择和图标当然是任意的 UI 选择:重要的联系是它们使用排序回调`handleSortKeyChange`和`handleDirectionToggle`，这是我们从自定义的`useSort`钩子导出的。*

*为了完成这个逻辑，`SortControl`在实例化`useSort`钩子时，从它的选择控件传递`data`、`onSortChange`回调和`sortOptions`。*

***功能布局***

*最后，我们将布局我们的特性，包括在 TSX 节点中声明的`SortControl`和我们的列表组件。*

*我们可以迭代`return()`语句中的所有内容，但是`renderHeader()`和`renderList/Item()`函数将视图的不同部分分开，以便于维护。*

# *结论*

*所以这不是很多实际的代码，但是这个练习的原则是我们已经创建了一个定制的钩子来将特性的排序状态和逻辑从视图中分离出来。*

*这允许我们在一个或多个视图组件中独立地使用`useSort`钩子。此外，带有自定义钩子回调的功能视图组件的策略使得我们的排序组件是可组合的，因此它可以很容易地与其他类似设计的特性配对，独立地作用于相同的数据集。*

# *资源*

*   *GitHub 库:
    https://github.com/fauteuil/react-data-sort-component*
*   *codesandbox.io 上的示例应用:[https://code sandbox . io/s/github/fauteuil/react-data-sort-component](https://codesandbox.io/s/github/fauteuil/react-data-sort-component)*

**更多内容请看*[***plain English . io***](http://plainenglish.io/)*