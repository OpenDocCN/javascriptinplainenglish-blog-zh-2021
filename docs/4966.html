<html>
<head>
<title>Mastering the Coding Interview: What Is a Stable Sorting Algorithm?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握编码面试:什么是稳定的排序算法？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stable-sorting-algorithm-b7022863db8d?source=collection_archive---------5-----------------------#2021-10-07">https://javascript.plainenglish.io/stable-sorting-algorithm-b7022863db8d?source=collection_archive---------5-----------------------#2021-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c277" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及为什么这种区别很重要</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/088294aea86f3e559b4e53054fdd131b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOH-xXqMshcIuoadhnqHrg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.pexels.com/@katierainbow?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Katie Rainbow 🏳️‍🌈</a> from <a class="ae kv" href="https://www.pexels.com/photo/art-pattern-purple-texture-9685111/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="3ba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说到排序算法，稳定性是一个重要的概念。</p><p id="2430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可能会帮助你避免不必要的努力。它很好地表明，没有适用于所有情况的排序算法——它总是视情况而定。</p><p id="6560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是什么是稳定和不稳定的排序算法呢？让我们来了解一下！</p><h1 id="fd15" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们所说的稳定是什么</h1><p id="5355" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">用一个例子来理解是最容易的。</p><p id="a78b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设你有一份名单。对于每个人，有这个人的名字，他们的年龄保存。你的目标是按照年龄对列表进行升序排序。最年轻的人是第一项，最年长的人是最后一项。</p><p id="c3be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有一个问题:当前的列表是按照字母顺序排列的(A是第一个字母，Z是姓氏)。虽然您希望按年龄排序，但是您希望字母顺序尽可能保持不变。</p><p id="60b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让事情更直观，下面是我们当前的列表，我们希望按年龄排序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6370" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，这些名字是按字母顺序排列的。因此，您对算法的要求是首先按年龄对<strong class="ky ir">排序，其次按姓名</strong>排序。理想的输出如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0ec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个稳定的排序算法将你的列表转换成的结果。</p><p id="32b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稳定的排序算法将按照相同的顺序对相同的元素进行排序。在我们的例子中，这意味着，对于年龄相同的所有人，算法将保持姓名的字母顺序。</p><p id="d024" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个不稳定的算法不能保证保持这个顺序。<br/>不稳定算法的结果可能是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="860f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，“本”应该在“克拉拉”和“莎拉”之前。还有，“Max”不应该在“Jessica”和“John”之间。</p><p id="8af1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这还不是最好的例子，为什么稳定的排序算法可以比不稳定的更有益。</p><p id="e65f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您有一个网站，展示用户可以购买的笔记本电脑。首先，用户按价格升序订购这些笔记本电脑。然后，利用稳定的排序算法，可以应用另一种排序。</p><h1 id="ea66" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">哪些排序算法比较稳定？</h1><p id="98d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">虽然这听起来很容易回答，但实际答案是:视情况而定。</p><p id="28de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总是要看实现的。例如，通常的选择排序实现是不稳定的，我用它来提供不稳定的例子。然而，为了稳定性，也可以实现这种排序算法。</p><p id="3f67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但没有任何特例，这里是最流行的排序算法，分类如下:</p><h2 id="dd4f" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">稳定的</h2><ul class=""><li id="c2e2" class="nd ne iq ky b kz mk lc ml lf nf lj ng ln nh lr ni nj nk nl bi translated">冒泡排序</li><li id="b027" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">合并排序</li><li id="7e55" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">插入排序</li></ul><h2 id="3069" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">易变的</h2><ul class=""><li id="d41a" class="nd ne iq ky b kz mk lc ml lf nf lj ng ln nh lr ni nj nk nl bi translated">快速排序</li><li id="de9c" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">选择排序</li><li id="33be" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">壳牌肖特</li><li id="83f8" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">堆排序</li></ul><h1 id="d92e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码中的选择排序和冒泡排序</h1><p id="7ef4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，我想为您提供一些实际的代码，以便您可以随意使用。<br/>我准备了两种算法来处理我们上面使用的人的对象。</p><p id="013d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从经典的——气泡排序开始，一个稳定的排序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f03a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">冒泡排序可能是最直观的排序算法。我们循环遍历一个数组，如果下一项比当前项小，我们就交换这两项——至少如果我们想对数组进行升序排序的话。</p><p id="f36d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，这种简单性使得冒泡排序不是很有效，但是很稳定。由于该算法只修复无序数组对，所以它保持具有相同值的项的顺序。</p><p id="d38b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，选择排序是不稳定的——下面是它的工作原理。</p><p id="92e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，选择排序选择一些东西。该算法主要是在数组的剩余无序部分中寻找最小值。这句话的最后一部分可能会令人困惑。我来澄清一下。</p><p id="b278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择排序使数组的左边部分成为有序部分。这部分随着我们添加的剩余最小值而增长。可视化可能会有所帮助:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="c0a8" class="mr lt iq ns b gy nw nx l ny nz">[2, 5, 3, 1, 9, 4, 8, 7]<br/>[<strong class="ns ir">1</strong>, 5, 3, 2, 9, 4, 8, 7]<br/>[<strong class="ns ir">1, 2</strong>, 3, 5, 9, 4, 8, 7]<br/>[<strong class="ns ir">1, 2, 3</strong>, 5, 9, 4, 8, 7]<br/>[<strong class="ns ir">1, 2, 3, 4</strong>, 9, 5, 8, 7]<br/>[<strong class="ns ir">1, 2, 3, 4, 5</strong>, 9, 8, 7]</span></pre><p id="1854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用粗体标记了数组的排序部分——您可以看到它是如何逐步增长的，直到数组完全排序。</p><p id="6537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为选择排序完全颠倒了数组，所以它是不稳定的。</p><p id="ddc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你能谈谈排序算法的稳定性。<br/>感谢您的阅读！</p><p id="3680" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oa">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="oa">plain English . io</em></strong></a></p></div></div>    
</body>
</html>