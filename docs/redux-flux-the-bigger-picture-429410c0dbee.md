# 通过实现理解 Redux 概念

> 原文：<https://javascript.plainenglish.io/redux-flux-the-bigger-picture-429410c0dbee?source=collection_archive---------6----------------------->

## 还原/流动:更大的图景

![](img/2fded4a10d2b0b9ff9a51ced0c9ff412.png)

Photo by [Grant Durr](https://unsplash.com/@blizzard88?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

我最近有点极端主义倾向。我的目标是:

*   不要使用外部图书馆。
*   不使用 transpilation 中间件(所以原生 ES6，没有巴别塔，所有导入路径都是相对路径，放弃对旧浏览器的支持)
*   尽可能保持香草味。有了现代浏览器，你可以毫无障碍地编写现代 JavaScript，所以新的“香草”是 ES6+语法。

这个过程让我找到了一些有趣的项目，包括 [Olive](https://github.com/arlenner/olive) ，一个只有 300 多行代码的 SPA 框架，其中大部分是一个文件。该代码库的一部分是 Redux 的实现，我很高兴地说，它不仅功能不错，而且代码也很小。我想介绍一下创建这样一个组件以便在您自己的代码中使用的过程。我还将简要解释 redux 是什么，何时以及为什么使用它，以及如何使用中间件将您的代码分成纯代码和不纯代码。

## Redux 是什么？

Redux 是一种叫做 Flux 的设计模式的实现。Flux 是一种消息传递系统，最初是由脸书的人开发的，用于帮助管理他们复杂的应用程序状态。Redux 本身是由一个叫丹·阿布拉莫夫的家伙建造的。它为他赢得了大量的曝光，成为国家管理的主要轻量级解决方案。通量设计模式是这样工作的:

1.  名为 Store 的组件保存应用程序的所有中央状态。它不能被修改，除了一个单独的特殊功能。您可以将状态视为通过另一个函数授予我们的副本。这样，如果不依靠一个叫做*减速器*的特殊逻辑，我们永远无法改变商店的状态。
2.  一个叫做 Dispatcher 的组件是可以改变存储状态的“特殊功能”。我们可以打电话`dispatch`要求店家更改。因为存储的状态是完全不可变的，并且在每次成功修改时都会被替换，这将防止诸如陈旧数据和竞争条件之类的问题。
3.  我在第一节中提到的称为 Reducer 的组件处理应用程序状态更改的纯逻辑。当我说*纯*时，我指的是*功能纯*或*幂等*。这意味着你的减压器中的功能可能没有副作用。对于任何给定的输入，函数必须在每个场景中为该输入生成相同的输出。在我们的 reducer 的例子中，我们有一个称为 Action 的组件，我们接受它作为输入，这个 Action 给我们的 reducer 提供产生一个新状态所需的指令。reducer 的产品是新状态本身，它将替换 Store 组件的旧状态。
4.  动作组件由两个关键部分组成:动作的*类型*和*有效载荷*。你的类型本质上是一个标识动作的键。有效载荷是与动作意图相关的一些数据或者没有数据。并非所有动作都需要有效负载。
5.  在 Reducer 产生一个新的状态(或者在无效的情况下不对状态做任何事情)之后，动作可以选择性地传递给一个单独的*中间件*函数。这个函数的目的是隔离代码的副作用部分，这样我们就可以将状态从副作用中分离出来。这个中间件可以可选地返回一个新的要被分派的动作。
6.  最后，我们依赖于某种前端接口，当与它交互时，它会将我们的动作发送到商店，启动整个连锁反应。

这听起来可能很复杂，但是我将向您展示它是如何变得非常简单的。让我们从一段有点幼稚的代码开始，这段代码为我们提供了一个基本的存储工厂。

## 建设商店

我们定义商店的第一次尝试可能是这样的:

看起来不错。我们封装了一个默认状态`model`，并把一个`reducer`函数作为参数。我们通过不将内部的`store`暴露在函数之外来使其成为‘私有的’。我们可以通过调用`state`来获得进入商店的*视图*。`state`只返回内部存储的副本。为了实际修改我们的内部函数`store`，我们使用了`dispatch`函数，我们在返回中公开了这个函数。我们将`store`重新分配给`reducer`的结果。我们只需要知道在这个时间点上，一个 reducer 接受我们的状态和动作的模型，并返回一个新的状态。有时，它有助于我看到写出的函数的签名，所以这里是 Typescript 符号中的缩减器:

```
reducer: (state: State, action: [type: String, data?: any]) => State
```

这也暗示了我们将如何定义我们的行为。我们可以假设`State`采用以下形式:

```
interface State {
 [k: string]: any
}
```

所以本质上任何普通的物体。如果您实际上使用的是 Typescript，而我不是，那么您可以(也应该)利用编译器为您的应用程序定义您自己的状态类型。然而，这家商店有一些问题。

## 传地址

目前，我们接受默认状态参数的对象。当我们将`store`内部变量赋给`model`参数时，我们实际上是通过引用将其赋给*。这意味着参数`model`和私有变量`store`实际上是内存中的同一个对象。那有什么问题呢？考虑这段虚构的代码:*

使用我们当前的实现，对`DEFAULT_STATE`的引用实际上等于私有的`store`变量。也就是说我们仍有机会从外面进入。另外，我们的代码很可能会出错，因为从技术上来说，我们试图在商店代码中重新分配一个`const`。我们下一步可能会做这样的事情:

```
let store = { ...model }
```

这似乎适用于简单的状态。但是，如果我们的状态中有嵌套对象，它将失败。对对象使用扩展语法只会产生浅层副本。为了真正获得我们的状态的副本，我们必须编写一个助手函数:

由于这个递归函数，现在我们可以处理任意数量的嵌套、数组、包含嵌套对象的数组等。它会全部复制。利用这一点，我们可以重构我们的`tinyStore`,使其更加真实:

现在，我们将拥有一个真正私有的内部`store`变量，能够保存复杂的状态。我们的`state`将返回一个定义了嵌套值的有意义的对象。

## 一些基本用法

在我上面虚构的代码片段中，敏锐的读者可能已经掌握了这种模式的一些使用细节。但是这里有一个从代码角度构建我们的商店的基本纲要:

## 更进一步

flux/redux 模式的要点是创建一个功能上纯粹的原子状态，或者一个*单一真实来源*。但是很大一部分应用依赖于副作用。副作用不纯。我们不知道他们做什么，他们可能什么也不返回，他们做了一些我们无法确定的事情或启动了一些我们无法确定的事情。副作用是所有 bug 的源头。但是副作用也是所有与我们的用户，外部服务器，随机数，任何返回承诺或任何返回未定义的交互的来源。副作用无处不在。我们能做的最好的事情就是给这混乱增加秩序。这就是中间件发挥作用的地方。让我们给我们的`dispatch`函数添加几行代码:

我们在函数调用中添加了一个可选参数`mw`。在 dispatch 中，在修改我们的状态之后，我们可以运行一个叫做中间件的功能。它的形式是:

```
mw: (model: State, action: Action) => Action | null
```

如果一个动作被返回，我们递归地调度它。所以我们应该*永远不要返回动作本身*，否则我们将创建一个无限循环。这让我们可以做一些真正有趣的事情。我们有一套全新的模式可以利用。为了向您介绍副作用，让我们编写一个基本的拆分器。假设我们已经编写了在基本用法一节中编写的代码:

现在，当我们单击该按钮时，将会引发一系列新的事件:

1.  事件将在调用我们商店的`dispatch`函数的 DOM 中触发。
2.  该动作将通过减速器传递。因为我们的减速器不处理`TRY_MY_ACTION`类型的动作，所以模型不会改变。
3.  然后动作在效果循环中传递。我们的效果会将我们的“尝试”行为“分割”成两个结果行为之一——成功或失败。如果我的动作已经被调用，那么尝试将会失败，否则尝试将会成功。
4.  效果返回的动作通过 store 的`dispatch`函数放回。我们现在可以运行应用程序的纯结果部分—例如，登录失败将总是将状态设置为未登录。它可能还会显示一个登录页面。一次成功的登录会把你带到你的个人资料或者时间线或者你的应用程序的主视图

您可以看到，像这样利用模式将允许您根据需要隔离应用程序的副作用部分。它将允许您控制混乱，允许有意义的调试消息、有组织的 HTTP 请求、数据库调用的隔离等等。

我们来谈谈另一种效果模式，我称之为步进器。你采取了一系列复杂的行动，并隔离过程中的每一步:

正如您所看到的，我们已经使用这种模式逐步完成了一个复杂的过程，在前端向用户提供了有意义的反馈。下面是一个可用的 codepen 示例:

## 好处

这就是我们如何用不到 30 行代码编写一个非常有特色的类似 Redux 的状态存储。我们可以应用这样的模式来组织任何应用程序。我们不需要用香草。我们可以使用 React 钩子来做同样的事情。如果您想使用 React 的减速器，请查看`useReducer`挂钩。它几乎和我们在这里写的完全一样。Angular 有一个名为`ngrx`的包，它允许你使用 redux 类的存储和独立的副作用，就像我们的架构一样。知道如何有效地使用 Redux 将有助于您编写更有组织性和可重构的代码。我希望这能帮助我的读者理解状态管理的 Flux/Redux 模式背后的总体概念。

下次见，FP 上读者！