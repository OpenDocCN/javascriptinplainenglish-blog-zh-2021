<html>
<head>
<title>5 Lesser Known JavaScript Features That Will Improve Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个鲜为人知的JavaScript特性将改善您的代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-javascript-features-that-you-might-not-know-about-but-will-improve-your-code-80f93d704b62?source=collection_archive---------10-----------------------#2021-02-17">https://javascript.plainenglish.io/5-javascript-features-that-you-might-not-know-about-but-will-improve-your-code-80f93d704b62?source=collection_archive---------10-----------------------#2021-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/699d67ccb0cc6aea4b794b9c82765ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0kUudX4oWHFP5R9GvH01Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by Jonathan Fielding</figcaption></figure><p id="feae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">今天，我想分享一些JavaScript特性，这些特性你应该在日常代码中使用，但是在过去几年中JavaScript的许多更新中可能已经错过了。</p><h1 id="ae99" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.JavaScript字符串填充</h1><p id="2728" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">如果你在2016年从事JavaScript生态系统的工作，你可能会记得<code class="fe md me mf mg b">left-pad</code>事件。</p><p id="2925" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总之，NPM上有一个JavaScript包，可以用来填充字符串和额外的字符，它从NPM被删除了，因为它被许多包所依赖，它引起了多米诺骨牌效应，破坏了全世界的软件构建。</p><p id="6896" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然NPM修复了这个问题，但在TC39上，人们发现很多人更喜欢使用库来填充字符串，而不是自己编写代码，因此作为ES2017的一部分，他们引入了<code class="fe md me mf mg b">.padStart()</code>和<code class="fe md me mf mg b">.padEnd()</code>。</p><p id="f17b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要将0添加到字符串的开头，我们将使用<code class="fe md me mf mg b">.padStart()</code>，传递字符串的目标长度和填充当前字符串的字符串。在下面的例子中，我填充了字符串“1 ”,使其长度为“5”。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="90f8" class="mp lb iq mg b gy mq mr l ms mt">let str = "1";<br/>str = str.<strong class="mg ir">padStart(5,0)</strong>;<br/>console.log(str) // output is <strong class="mg ir">00001</strong></span></pre><p id="7ebb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，我们可能想要填充字符串的末尾，为此我们使用<code class="fe md me mf mg b">.padEnd()</code>。类似地，我们传递字符串的目标长度和用来填充当前字符串的字符串。在下面的例子中，我填充了字符串“1 ”,使其长度为“5”。然而，这一次它将在末尾添加填充。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="9e12" class="mp lb iq mg b gy mq mr l ms mt">let str = "1";<br/>str = str<strong class="mg ir">.padEnd(5,0)</strong>;<br/>console.log(str) // result is 1<strong class="mg ir">0000</strong></span></pre><h1 id="ca41" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.传播算子</h1><p id="c484" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Spread操作符并不是最新最闪亮的JavaScript特性，它在2015年作为ES2015规范的一部分出现，但是它的一些用例经常被忽略。</p><p id="52c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">spread运算符的第一个用例是将一个数组中的项目添加到另一个数组中。在下面的例子中，我有一个包含3个水果的数组，但是我想要第二个包含第四个水果的数组，所以我使用spread操作符来复制原始水果，并添加第四个水果。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="084b" class="mp lb iq mg b gy mq mr l ms mt">const arr1 = ["Apple", "Orange", "Pear"]<br/>const arr2 = [...arr1, "Banana"]<br/>console.log(arr2) // ["Apple", "Orange", "Pear", "Banana"]</span></pre><p id="6808" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以对对象做类似的事情，但是额外的好处是我们可以覆盖原始对象中的值。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="2eae" class="mp lb iq mg b gy mq mr l ms mt">const personA = {<br/>  name: "Jonathan",<br/>  age: 21,<br/>}<br/>const personB = {<br/>  ...personA,<br/>  name: 'Charlie'<br/>}<br/>console.log(personB) // {name: "Charlie", age: 21}</span></pre><h1 id="fdaa" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.休息参数</h1><p id="fab9" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">从Spread操作符开始，我们有了<code class="fe md me mf mg b">Rest</code>参数，有点像它的反义词。<code class="fe md me mf mg b">rest</code>语法收集多个元素并将它们“浓缩”成一个元素。</p><p id="b642" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe md me mf mg b">rest</code>参数的一个很好的用例是当一个数组被析构时将它的剩余元素分组。在下面的例子中，我们销毁了一些水果，所以苹果是独立的，剩下的水果放在水果数组中。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="0539" class="mp lb iq mg b gy mq mr l ms mt">const [apple, ...fruits] = ["apple", "orange", "pear"];<br/>console.log(apple); // output is "apple"<br/>console.log(fruits); // output is ["orange", "pear"]</span></pre><h1 id="870d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.数组.原型.包含</h1><p id="86cd" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我要讲的下一个特性是<code class="fe md me mf mg b">Array.prototype.includes</code>，这个特性允许你发现一个数组是否包含一个项。</p><p id="034f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe md me mf mg b">Array.prototype.includes</code>之前，这可以通过循环数组并在找到项目时将变量设置为true来实现，见下文:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="7d60" class="mp lb iq mg b gy mq mr l ms mt">const fruits = ["Dragonfruit", "Kiwi", "Mango", "Pear", "Starfruit"];<br/>let found = false;</span><span id="2396" class="mp lb iq mg b gy mu mr l ms mt">fruits.forEach(function(fruit) {<br/>  if (fruit === 'Kiwi') {<br/>    found = true;<br/>  }<br/>});</span><span id="88c1" class="mp lb iq mg b gy mu mr l ms mt">console.log(found); // Outputs `true`</span></pre><p id="a6bf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，有了<code class="fe md me mf mg b">Array.prototype.includes</code>，我们可以将这个显著地减少到如下</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="e8c5" class="mp lb iq mg b gy mq mr l ms mt">const fruits = ["Dragonfruit", "Kiwi", "Mango", "Pear", "Starfruit"];<br/>const found = fruits.includes("Kiwi");<br/>console.log(found); // Outputs `true`</span></pre><p id="9e91" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意:作为开发者，我们不需要担心这个搜索是如何实现的，所以浏览器有机会自己优化这个行为。</p><h1 id="40a6" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.可选链接</h1><p id="56d7" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我想说的第五个也是最后一个特性是可选链接。</p><p id="1d42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可选链接允许我们尝试检索对象中嵌套很深的数据，而不必处理数据可能不存在的情况。</p><p id="5030" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看下面的例子，在这个例子中，我们用一些元数据来定义<code class="fe md me mf mg b">Jonathan</code>。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="4abc" class="mp lb iq mg b gy mq mr l ms mt">const jonathan = {<br/>  name: "Jonathan",<br/>  meta: {<br/>    age: 21<br/>  }<br/>}</span><span id="c837" class="mp lb iq mg b gy mu mr l ms mt">const age = jonathan.meta.age;<br/>const gender = jonathan.other.gender; // Will throw error</span><span id="d148" class="mp lb iq mg b gy mu mr l ms mt">console.log(age);<br/>console.log(gender);</span></pre><p id="c8db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们运行这段代码，它会导致一个错误，因为对象的<code class="fe md me mf mg b">other</code>部分不存在。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/722a44a3baee2633cf14a507188bf02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJo-TBoy3Gh55q8etzHIiA.png"/></div></div></figure><p id="48f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用可选链接，我们可以通过这样的方式来防止这个错误:如果一个属性不存在，就不要在对象树中继续操作。我用可选链接更新了下面的代码。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="caba" class="mp lb iq mg b gy mq mr l ms mt">const jonathan = {<br/>  name: "Jonathan",<br/>  meta: {<br/>    age: 21<br/>  }<br/>}</span><span id="4755" class="mp lb iq mg b gy mu mr l ms mt">const age = jonathan?.meta?.age;<br/>const gender = Jonathan?.other?.gender;</span><span id="bd50" class="mp lb iq mg b gy mu mr l ms mt">console.log(age); // outputs 21<br/>console.log(gender); // outputs "undefined"</span></pre><p id="870e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们现在运行这个，将不再有错误，性别将简单地不确定，我们可以单独处理。</p><h1 id="22c2" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包扎</h1><p id="7eb4" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">JavaScript正以前所未有的速度快速发展，每年都有更新，这种语言保持着新鲜感，人们很容易忘记我们可以用仅仅几年前的特性做的所有很酷的事情。</p><p id="dd5f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据我自己的经验，写这篇文章实际上让我对我谈到的每个特性有了更多的了解。帮助我巩固自己的知识。</p><p id="20c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢您抽出时间阅读，如果您想阅读类似的帖子，请在Medium上跟随我。</p></div></div>    
</body>
</html>