<html>
<head>
<title>Tailwind’s Just-In-Time Mode is a Game Changer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">顺风的及时模式是一个游戏改变者</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-tailwind-just-in-time-mode-is-a-game-changer-and-how-to-use-it-right-now-dubois-s%C3%A9bastien-182db2e64e26?source=collection_archive---------5-----------------------#2021-04-03">https://javascript.plainenglish.io/why-tailwind-just-in-time-mode-is-a-game-changer-and-how-to-use-it-right-now-dubois-s%C3%A9bastien-182db2e64e26?source=collection_archive---------5-----------------------#2021-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b465" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及现在如何使用它</h2></div><p id="843e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">了解如何将您的应用程序迁移到<a class="ae lb" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> Tailwind </a> 2.1+，以及如何启用Tailwind的<a class="ae lb" href="https://github.com/tailwindlabs/tailwindcss-jit" rel="noopener ugc nofollow" target="_blank">即时</a>模式。</p><p id="e590" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">更新2021–04–06</strong>:适应了顺风v2.1发布后的内容</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/87f5494eea0eed9170cf68c0d089ba83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-SYtYzIhgPRnmRd8yWH4g.png"/></div></div></figure><p id="796d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大约两周前，亚当·瓦森<a class="ae lb" href="https://blog.tailwindcss.com/just-in-time-the-next-generation-of-tailwind-css" rel="noopener ugc nofollow" target="_blank">宣布了一项新的顺风实验</a> : <a class="ae lb" href="https://github.com/tailwindlabs/tailwindcss-jit" rel="noopener ugc nofollow" target="_blank">准时</a>。从那时起，Tailwind 2.1 <a class="ae lb" href="https://github.com/tailwindlabs/tailwindcss/releases/tag/v2.1.0" rel="noopener ugc nofollow" target="_blank">已经发布</a>，它引入了对这一新特性的官方支持。</p><p id="ea80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将告诉你这是怎么回事，以及你如何利用它。</p><p id="ffda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">警告</strong>:此时顺风的准时制模式还在预览中。我用它来生产我的产品，到目前为止还没有任何问题，但是你永远不知道。</p><h1 id="9a49" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">什么是顺风的即时模式，为什么要关注？</h1><p id="cbc9" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">自从开始用<a class="ae lb" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">顺风</a>之后，就再也没有回头。感觉比老式的CSS更有效率。想要一些空白，一些左边的填充，和圆角？给你:<code class="fe ml mm mn mo b">m-2 px-2 rounded-lg</code>。能够非常简洁地快速表达复杂的CSS规则是Tailwind的关键优势之一。</p><p id="a870" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些人误解了这一点，认为他们必须用大量的顺风指令来填充HTML模板，但这只是一种方法；你也可以使用标准的CSS类，并在其上应用顺风规则，以一种更经典的方式工作。虽然，这篇文章的目标不是说服你使用Tailwind我认为有足够多的文章涉及这一点。在这里，我将把重点放在什么是准时制模式，以及它为什么有趣。</p><p id="c23f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺风的一个主要缺点是它会产生<em class="mp">兆字节</em>的CSS代码。原子CSS类是为项目中的每一个规则和变体生成的。例如，Tailwind包含宽度为的<a class="ae lb" href="https://tailwindcss.com/docs/width" rel="noopener ugc nofollow" target="_blank">实用程序类。正如您在文档中看到的，默认情况下，它包括以下值:<code class="fe ml mm mn mo b">w-0 w-0.5 w-1 w-1.5 w-2 w-2.5 w-3 w-3.5 w-4 w-5 w-6 w-7 w-8 w-9 w-10 w-11 w-12 w-14 w-16 w-18 w-20 w-24 w-28 w-32 w-36 w-40 w-44 w-48 w-52 w-56 w-64 w-1/2 w-1/3</code>，以及更多。此外，您可以使用<code class="fe ml mm mn mo b">tailwind.config.js</code>配置文件定制这些。最小宽度、最大宽度、高度、字体、颜色等等也是如此！</a></p><p id="20b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很多规则也可以组合。例如，您可以使用<code class="fe ml mm mn mo b">text-red-500</code>来获得生动的红色文本，或者使用<code class="fe ml mm mn mo b">bg-red-500</code>来改变背景的颜色。为了支持这一点，Tailwind为每一种可能的规则组合(例如，边框颜色、背景颜色、悬停、焦点等)生成CSS类。</p><p id="857f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以想象，生成的CSS代码非常庞大，随着添加更多的颜色、变体等，情况会成倍恶化。这导致了<em class="mp">巨大的</em>束尺寸。幸运的是，Tailwind包含了对PurgeCSS 的内置支持，允许我们去掉所有未使用的类。</p><p id="13eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PurgeCSS非常适合生产构建，因为它去除了所有未使用的实用程序类，从而产生了最佳的CSS包。不幸的是，在开发过程中，使用它并不是一个真正的选择；只是太花时间了。结果是，随着顺风生成的CSS包变得越来越大，应用程序的构建速度越来越慢，Web浏览器开发工具也因为要接收的CSS数量而变得缓慢。这当然是开发者体验的一个主要问题。大型团队的税收是巨大的。每次您更改全局样式时，顺风“编译器”都需要重新生成整个样式。</p><p id="634d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是准时制(JIT)模式发挥作用的地方。在启用了Tailwind的JIT模式的情况下，Tailwind编译器只会为您真正利用的Tailwind规则生成CSS代码。这真是太棒了！</p><p id="f774" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么？因为这意味着所有的肿胀都消失了！启用JIT后，我们只得到真正需要的CSS类。正因为如此，CSS代码的生成速度更快，从而大大缩短了启动时间。此外，由于CSS更少，浏览器开发工具的响应速度更快。作为一个额外的好处，CSS在开发和生产之间是一样的。光是这些好处就足以激励我启用JIT。但还有更多！</p><p id="84a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以前，许多<a class="ae lb" href="https://tailwindcss.com/docs/configuring-variants" rel="noopener ugc nofollow" target="_blank"> Tailwind变体</a>在默认情况下被禁用，因为它们会导致生成数兆字节的CSS(例如，暗模式、负责、悬停、可见焦点、活动、禁用等)。因为JIT“按需”生成样式，这意味着所有这些变体都可以直接使用，无需配置。</p><p id="657c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JIT模式也带来了新的有趣的特性。其中之一是将多个规则堆叠在一起的可能性。例如，让我们在元素激活时将字体加粗，并停留在中间断点:<code class="fe ml mm mn mo b">sm:focus:hover:active:font-bold</code>。以前，像这样的堆叠规则是不可能的。这打开了一个充满新可能性的世界。</p><p id="ce09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JIT带来的另一个很酷的特性是可以在不改变设计系统配置的情况下，为某些规则使用自定义值。以前，唯一的方法是要么求助于标准CSS，要么定制Tailwind的配置，这会导致更多的CSS膨胀。例如，添加一种颜色意味着因为所有的组合而添加大量的CSS。现在，如果某个地方有您需要的颜色，您可以执行以下操作:<code class="fe ml mm mn mo b">bg-[#a0cdae]</code>。太棒了。</p><p id="180b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不用说，这是Tailwind向前迈出的巨大一步:更少的配置，更多的功能，更好的性能。这是各方面的胜利！</p><p id="df63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然<a class="ae lb" href="https://github.com/tailwindlabs/tailwindcss-jit#known-limitations" rel="noopener ugc nofollow" target="_blank">有一些限制</a>，但没什么太烦人的。</p><p id="2d78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想了解更多信息，请观看简介视频:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3a6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看如何启用JIT！</p><h1 id="4206" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">启用Tailwind的JIT模式</h1><p id="0785" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在这里，我假设您已经在项目中使用了Tailwind和PostCSS。</p><p id="3dc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，您需要升级到Tailwind 2.1，这是第一个包含JIT模式的版本。此外，确保将<code class="fe ml mm mn mo b">autoprefixer</code>更新为最新版本！</p><p id="10dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，修改您的Tailwind配置(即<code class="fe ml mm mn mo b">tailwind.config.js</code>)以启用JIT模式:</p><pre class="ld le lf lg gt ms mo mt mu aw mv bi"><span id="32a0" class="mw lp iq mo b gy mx my l mz na">module.exports = {<br/>  mode: 'jit',<br/>  ...<br/>}</span></pre><p id="81e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，确保<code class="fe ml mm mn mo b">purge</code>选项已启用并正确配置。它应该包括所有包含Tailwind“规则”的文件。以下是我在基于<a class="ae lb" href="https://nx.dev/" rel="noopener ugc nofollow" target="_blank"> Nrwl NX </a>的Angular应用程序中使用的配置:</p><pre class="ld le lf lg gt ms mo mt mu aw mv bi"><span id="176c" class="mw lp iq mo b gy mx my l mz na">// Help Tailwind configure PurgeCSS correctly<br/>// Reference: https://tailwindcss.com/docs/controlling-file-size/#app<br/>purge: {<br/>  content: [<br/>    "./apps/**/*.html",<br/>    "./apps/**/*.ts",<br/>    "./apps/**/*.scss",<br/>    "./libs/**/*.html",<br/>    "./libs/**/*.ts",<br/>    "./libs/**/*.scss",<br/>  ],<br/>  // PurgeCSS options<br/>  // Reference: https://purgecss.com/<br/>  options: {<br/>    rejected: true,<br/>    printRejected: true,<br/>  },<br/>},</span></pre><p id="4108" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样！是的，真的！这有多酷？；-)</p><h1 id="67cf" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">调整现有代码</h1><p id="a32f" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">下一步是调整您现有的代码。在这里，我将强调我必须在我的项目中做出的一些改变。不过，请注意，其中一些可能与Tailwind 2有关，而不是JIT，因为我的项目以前仍然使用Tailwind 1.x。对于每种情况，我将向您展示迁移前后的代码。</p><h2 id="aa80" class="mw lp iq bd lq nb nc dn lu nd ne dp ly ko nf ng ma ks nh ni mc kw nj nk me nl bi translated">不再可能在<code class="fe ml mm mn mo b">@screen</code>中嵌套<code class="fe ml mm mn mo b">@apply ...</code></h2><p id="6a0d" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">之前:</p><pre class="ld le lf lg gt ms mo mt mu aw mv bi"><span id="8ebf" class="mw lp iq mo b gy mx my l mz na">.create-page-body {<br/>  @apply mt-4 flex flex-wrap gap-8 justify-between;<br/><br/>  @screen md {<br/>    @apply mt-10;<br/>  }<br/><br/>  @screen lg {<br/>    @apply justify-around;<br/>  }<br/>}</span></pre><p id="0f55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后:</p><pre class="ld le lf lg gt ms mo mt mu aw mv bi"><span id="0335" class="mw lp iq mo b gy mx my l mz na">.create-page-body {<br/>  @apply mt-4 flex flex-wrap gap-8 justify-between md:mt-10 lg:justify-around;<br/>}</span></pre><p id="7cd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在上面看到的，由于<code class="fe ml mm mn mo b">@screen</code>规则，代码变得不那么杂乱，感觉也更轻松了。当然有利也有弊。也许以后会再次支持旧的语法，我不确定。</p><h2 id="d77c" class="mw lp iq bd lq nb nc dn lu nd ne dp ly ko nf ng ma ks nh ni mc kw nj nk me nl bi translated">再也没有<code class="fe ml mm mn mo b">!important</code>规则了</h2><p id="4405" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">之前:</p><pre class="ld le lf lg gt ms mo mt mu aw mv bi"><span id="e64b" class="mw lp iq mo b gy mx my l mz na">.create-page-user-autocomplete-input-box {<br/>  @apply border-gray-400 !important;<br/>}</span></pre><p id="ea07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后:</p><pre class="ld le lf lg gt ms mo mt mu aw mv bi"><span id="9b9e" class="mw lp iq mo b gy mx my l mz na">.create-page-user-autocomplete-input-box {<br/>  @apply !border-gray-400;<br/>}</span></pre><p id="2867" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些规则现在可以以<code class="fe ml mm mn mo b">!</code>为前缀来执行，以覆盖CSS级联。</p><p id="c7fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">警告</strong>:打破CSS级联是邪恶的，我知道。但有些情况下是必要的。</p><h2 id="86bf" class="mw lp iq bd lq nb nc dn lu nd ne dp ly ko nf ng ma ks nh ni mc kw nj nk me nl bi translated">就是这样！</h2><p id="b490" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">信不信由你，但这些几乎是我在启用JIT的情况下让我的项目在Tailwind 2.1下工作所必须做的唯一改变。精彩！</p><h1 id="a36b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">在故事书中启用JIT</h1><p id="1753" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果你在你的项目中使用<a class="ae lb" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank"> Storybook </a>，那么你可能也想在那里启用JIT。目前这样做需要更多的工作，因为Tailwind的JIT模式只支持PostCSS 8+。幸运的是，最近<a class="ae lb" href="https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-implicit-postcss-loader" rel="noopener ugc nofollow" target="_blank">故事书6.2 </a>引入了对PostCSS 8的支持。</p><p id="daa5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">提示</strong>:故事书6.2包含了对Angular的重大改进。稍后我可能会写一篇关于这个的文章:<a class="ae lb" href="https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#62-angular-overhaul" rel="noopener ugc nofollow" target="_blank">https://github . com/storybook js/storybook/blob/next/migration . MD # 62-angular-overhaul</a></p><p id="8144" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您已经升级到Storybook 6.2+，下面是如何启用JIT。</p><p id="791e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，您需要安装新的<a class="ae lb" href="https://github.com/storybookjs/addon-postcss" rel="noopener ugc nofollow" target="_blank"> PostCSS附加组件</a>:</p><pre class="ld le lf lg gt ms mo mt mu aw mv bi"><span id="b614" class="mw lp iq mo b gy mx my l mz na">npm install -D @storybook/addon-postcss</span></pre><p id="76d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里找到它的文档。安装后，您需要修改Storybook的<code class="fe ml mm mn mo b">main.js</code>配置文件才能启用它:</p><pre class="ld le lf lg gt ms mo mt mu aw mv bi"><span id="e686" class="mw lp iq mo b gy mx my l mz na">{<br/>  name: "@storybook/addon-postcss",<br/>  options: {<br/>    /**<br/>     * Make sure to use the expected PostCSS version<br/>     */<br/>    postcssLoaderOptions: {<br/>      implementation: require("postcss"),<br/>    },<br/>  },<br/>},</span></pre><p id="cdc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个新的Storybook插件的好处是，它使Storybook和应用程序的其余部分保持一致变得轻而易举，并且在任何地方都使用相同的PostCSS版本。</p><p id="5719" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，你也需要修改Storybook的Webpack配置来加载Tailwind。如果你不知道如何给故事书添加顺风，那么看看我之前的文章。</p><h1 id="4b0c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">将来的</h1><p id="77f7" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Tailwind的JIT模式是刚出炉的，但工作起来很有魅力。JIT很可能会成为顺风3的默认模式。我确信它将会<em class="mp">严重</em>影响顺风的未来发展(更好！).</p><h1 id="6293" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="1166" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在本文中，我解释了为什么Tailwind新的即时模式是一个游戏规则改变者，以及如何启用它。</p><p id="5c13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，我的建议是现在就试一试<em class="mp"/>。它非常有效，并且带来了重要的好处。仅仅是性能提升就值得付出这么一点点努力！</p><p id="008f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天到此为止！</p><p id="f0d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PS:如果你想学习大量关于产品/软件/Web开发的其他很酷的东西，那么<a class="ae lb" href="https://dev-concepts.dev" rel="noopener ugc nofollow" target="_blank">看看开发概念系列</a>，<a class="ae lb" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">订阅我的时事通讯</a>，还有<a class="ae lb" href="https://twitter.com/dSebastien" rel="noopener ugc nofollow" target="_blank">来Twitter上打个招呼吧！</a></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="eadc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mp">原载于2021年4月3日https://dsebastien.net</em><a class="ae lb" href="https://dsebastien.net/blog/2021-04-03-migrating-angular-to-tailwind-2-and-jit" rel="noopener ugc nofollow" target="_blank"><em class="mp"/></a><em class="mp">。</em></p></div></div>    
</body>
</html>