<html>
<head>
<title>Introduction to Machine Learning in Plain JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用普通JavaScript介绍机器学习</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-machine-learning-in-plain-javascript-428d28067e8a?source=collection_archive---------11-----------------------#2021-06-16">https://javascript.plainenglish.io/intro-to-machine-learning-in-plain-javascript-428d28067e8a?source=collection_archive---------11-----------------------#2021-06-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/721bc2b1cfc6385fcfd70463f2031d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNkEpGcjgJwRFAOMY7fhIg.png"/></div></div></figure><div class=""/><div class=""><h2 id="025c" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">建立一个简单的感知器算法，有两个输入和一个输出</h2></div><p id="4d09" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在这个例子中，我们将考虑一个简化的情况(上图),我们有一个由两个传感器监控的植物，一个将监控植物是否得到足够的阳光，另一个将监控它是否得到足够的水。</p><p id="4fb2" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">两个传感器将只发送0或1，0代表资源缺失，1代表用资源完美地喂养植物。</p><p id="af43" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们想建立一个感知器(简单的机器学习算法)来计算我们的植物是否得到足够的水和阳光，如果缺少什么，它应该给出输出1，这意味着我们的小机器人需要采取行动，照顾我们的植物。</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/d01cf83479002ac05f3b86b5dfe88b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*CmERnZggakSR1KA4dKHDbQ.png"/></div></figure><p id="bcf9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第一部分，我们用输入来填充我们的算法。</p><p id="8239" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这些对将是两个值[0，0]、[0，1]、[1，0]和[1，1]的数组。</p><p id="10a0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在机器学习中，我们向我们的算法提供数据(通常是大量的数据)，我们的算法从中学习并建立规则，然后我们可以使用这些规则(通常称为模型)来预测看不见的输入的输出。例如，它可以对我们的图像进行分类，并预测图片中是否有猫或狗。</p><p id="f37b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在我们的例子中，这是一个监督算法，因为我们知道输出应该是什么，并将目标值输入到我们的算法中。</p><p id="4202" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在我们非常简单的例子中，我们有一组固定的输入，只有两个结果(类别)。</p><p id="0a48" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在，让我们来看看，当我们说算法学到了一些东西时，这意味着什么。</p><p id="9bfb" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">为了学习一些东西，我们需要可以优化的参数。在上面的第一张图片中，我们的机器人大脑中有一个思维气泡，让我们仔细看看这个气泡中发生了什么。</p><p id="bff9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们的小机器人有一个小的神经元网络，只有一个神经元(蓝色圆圈)作为大脑，因为他目前唯一的责任是照顾我们的植物。</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lo"><img src="../Images/ad51adfc39639f4bccc762b66a320974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyP7QAsugFJi8ar7kAHXrg.png"/></div></div></figure><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/13fea4461ef25c751349f114a4e2e642.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*s__r7AZn8n_VJsm4SmFhjw.png"/></div></figure><p id="268a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">首先，我们的神经元获得输入，假设[1，1]足够的水和太阳，然后算法首先计算<strong class="kp iz"> (1) </strong>的加权和，它对<strong class="kp iz"> w </strong>(权重)和<strong class="kp iz"> x </strong>(输入)的乘积求和，次数与从<strong class="kp iz"> i </strong> = 0开始的<strong class="kp iz"> n </strong>中指定的次数一样多。你可以在左边看到一个例子。</p><p id="c71b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">第二个<strong class="kp iz"> (2) </strong>检查加权和的输出= -1(本例的输出)是否激活神经元。在我们的示例中，我们使用简单的<a class="ae lq" href="https://de.wikipedia.org/wiki/Heaviside-Funktion" rel="noopener ugc nofollow" target="_blank"> Heaviside函数</a>，如果加权和的输出大于0，则返回1，如果小于0，则返回0。这意味着如果加权和大于0，我们的小机器人将采取行动，否则它将等待，给定-1，我们的机器人将等待。</p><p id="6f7b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在让我们用普通的JavaScript来编写代码。</p><p id="f42f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在权重和输入数组中，您不仅会看到水和太阳的两个值，还会在开头看到第三个参数。这就是偏见。</p><blockquote class="lr ls lt"><p id="06ec" class="kn ko lu kp b kq kr jz ks kt ku kc kv lv kx ky kz lw lb lc ld lx lf lg lh li ig bi translated"><strong class="kp iz">偏置值允许您向左或向右移动激活功能。</strong></p></blockquote><p id="af53" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">你可以在这里阅读更多关于偏见的信息<a class="ae lq" href="https://stackoverflow.com/questions/2480650/what-is-the-role-of-the-bias-in-neural-networks" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1c1a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">首先，我们将添加带有空函数的感知器类，以获得结构的清晰图像。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="b49b" class="md me iy lz b gy mf mg l mh mi">class Perceptron {<br/> constructor() {<br/>   // (1) initialization<br/> }</span><span id="328e" class="md me iy lz b gy mj mg l mh mi"> _heaviside(weightedSum) {<br/>   // (2) activation<br/> }</span><span id="aa85" class="md me iy lz b gy mj mg l mh mi"> _calculateWeightedSum(input) {<br/>   // (3) calculates the weighted sum<br/> }</span><span id="c7cf" class="md me iy lz b gy mj mg l mh mi"> predict(input) {<br/>   // (4) prediction<br/> }</span><span id="02ca" class="md me iy lz b gy mj mg l mh mi"> fit(iterations, trainingData) {<br/>   // (5) trains our algorithm and updates our weigths<br/> }</span><span id="b45f" class="md me iy lz b gy mj mg l mh mi"> _updateWeights(error, input, target) {<br/>  // (6) updates our class property weights<br/> }<br/>}</span></pre><p id="cdf9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">(1)我们初始化我们的权重，如果你愿意，你可以选择任何其他数字。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="39aa" class="md me iy lz b gy mf mg l mh mi">constructor() {<br/>  this._weights = [0, 0, 0];<br/>}</span></pre><p id="b321" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">(2)我们增加了激活功能。如果weightedSum大于0，它只返回1，否则返回0。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="d403" class="md me iy lz b gy mf mg l mh mi">_heaviside(weightedSum) {<br/>  return weightedSum &gt;= 0 ? 1 : 0;<br/>}</span></pre><p id="7e1b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">(3)首先，我们检查我们的类属性权重是否与输入具有相同的长度，如果是，我们迭代每个输入并计算加权和。在函数结束时我们返回它，它总是一个数字。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="547a" class="md me iy lz b gy mf mg l mh mi">_calculateWeightedSum(input) {<br/>  let weightedSum = 0;<br/>  if (this._weights.length === input.length) {<br/>    input.forEach((x, i) =&gt; (weightedSum += x * this._weights[i]));<br/>  } else {<br/>    console.error("Length of weights and inputs doesnt match");<br/>  }</span><span id="9121" class="md me iy lz b gy mj mg l mh mi">  return weightedSum;<br/>}</span></pre><p id="4ef5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">(4)我们添加预测函数，该预测函数计算加权和，并利用其结果检查神经元是否应该用Heaviside函数激活。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="7a60" class="md me iy lz b gy mf mg l mh mi">predict(input) {<br/>  const weightedSum = this._calculateWeightedSum(input);<br/>    <br/>  return this._heaviside(weightedSum);<br/>}</span></pre><p id="6099" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">(5)在拟合函数中，我们训练我们的算法。我们有与迭代参数中指定的一样多的学习迭代，作为第二个参数，我们得到准备好的训练数据。</p><p id="946a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们用一个空数组初始化错误，这样我们可以在以后检查我们得到了多少个错误。</p><p id="5345" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们希望获得训练数据的随机输入集，因此我们在randomIndexOfTrainingData中设置了一个随机索引，然后选择该输入。如果您有大型数据集，这一点很重要。</p><p id="2ab7" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">变量selectedTrainingData保存一个具有属性输入的对象，例如[1，1，0]和target 1。我们对该值进行预测，然后计算误差。这只是意味着我们计算target和calculatedTarget之间的差异，并检查我们的预测是否正确。</p><p id="df58" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然后我们更新类属性权重。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="1c51" class="md me iy lz b gy mf mg l mh mi">fit(iterations, trainingData) {<br/>  let errors = [];</span><span id="65c4" class="md me iy lz b gy mj mg l mh mi">  for (let i = 0; i &lt; iterations; i++) {<br/>    const randomIndexOfTrainingData = Math.floor(<br/>      Math.random() * trainingData.length<br/>    );<br/>    const selectedTrainingData = trainingData[randomIndexOfTrainingData];</span><span id="1abe" class="md me iy lz b gy mj mg l mh mi">    const input = selectedTrainingData.input;<br/>    const target = selectedTrainingData.target;</span><span id="a007" class="md me iy lz b gy mj mg l mh mi">    const calculatedTarget = this.predict(input, target);<br/>    const error = target - calculatedTarget;</span><span id="dc20" class="md me iy lz b gy mj mg l mh mi">    this._updateWeights(error, input, target);<br/>      <br/>    errors.push(error);<br/>  }<br/>    <br/>  return {errors, weights: this._weights};<br/>}</span></pre><p id="1ef4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">(6)最后，我们将更新权重函数添加到我们的感知器类中，该感知器类迭代输入，例如[1，1，0]，如果有错误，则更新类属性权重。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="759b" class="md me iy lz b gy mf mg l mh mi">_updateWeights(error, input, target) {<br/>  input.forEach((x, i) =&gt; {<br/>    this._weights[i] = this._weights[i] + error * x;<br/>  })<br/>}</span></pre><p id="176b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在让我们来看看我们的算法在起作用。</p><p id="3f77" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们用输入值和目标值来定义我们的训练数据。第一个值是输入属性中的偏差。第二个和第三个值来自我们的太阳和水传感器。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="f820" class="md me iy lz b gy mf mg l mh mi">const trainingData = [<br/>  {<br/>    input: [1, 0, 0],<br/>    target: 1<br/>  },<br/>  {<br/>    input: [1, 0, 1],<br/>    target: 1<br/>  },<br/>  {<br/>    input: [1, 1, 0],<br/>    target: 1<br/>  },<br/>  {<br/>    input: [1, 1, 1],<br/>    target: 0<br/>  },<br/>];</span></pre><p id="5a6f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们创建了感知器类的一个实例。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="59a7" class="md me iy lz b gy mf mg l mh mi">const perceptron = new Perceptron();</span></pre><p id="7ea6" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">并开始我们的学习过程，我选择了30次迭代并传入我们上面指定的traningData。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="84b4" class="md me iy lz b gy mf mg l mh mi">const result = perceptron.fit(30, trainingData);</span></pre><p id="7ceb" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然后，我们进行一些预测，并将结果记录到控制台。</p><pre class="lk ll lm ln gt ly lz ma mb aw mc bi"><span id="477b" class="md me iy lz b gy mf mg l mh mi">console.log('result', result);</span><span id="e3ba" class="md me iy lz b gy mj mg l mh mi">// parameters, string for identification, prediction, target value<br/>console.log('prediction 1', perceptron.predict([1, 0, 0]), 1);<br/>console.log('prediction 2', perceptron.predict([1, 0, 1]), 1);<br/>console.log('prediction 3', perceptron.predict([1, 1, 0]), 1);<br/>console.log('prediction 4', perceptron.predict([1, 1, 1]), 0);</span></pre><p id="e783" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">你可以在这里看到最终的代码<a class="ae lq" href="https://codepen.io/pguso/pen/RwpvpWj" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e32a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我希望你读它的时候和我准备写这篇文章的时候一样开心。如果有未解决的问题或反馈，我们非常欢迎您发表评论。</p><p id="5118" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><em class="lu">更多内容尽在</em><a class="ae lq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lu">plain English . io</em></a></p></div></div>    
</body>
</html>