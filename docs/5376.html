<html>
<head>
<title>JavaScript: Check if String contains Substring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:检查字符串是否包含子字符串</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-check-if-string-contains-substring-c8a8b581a826?source=collection_archive---------2-----------------------#2021-11-06">https://javascript.plainenglish.io/javascript-check-if-string-contains-substring-c8a8b581a826?source=collection_archive---------2-----------------------#2021-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c7a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能有一段时间，当你搜索字符串这样的功能。包含()。好吧，JavaScript里没有这个特性。因此，实现这一目标的最佳方式是什么？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b5f2244e3443168d089a3dacb16d0f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*To6s1APTtLTHUDKNMiQGug.jpeg"/></div></div></figure><h1 id="2dc8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">EcmaScript-6</h1><p id="e71e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果您使用的是最新版本的JavaScript，对于开发来说，您可以在字符串原型中自由使用<strong class="jp ir"> includes </strong>函数。</p><p id="f686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> ECMAScript 6推出</strong>T0】</p><pre class="km kn ko kp gt mf md mg mh aw mi bi"><span id="13c0" class="mj ky iq md b gy mk ml l mm mn">const string = "foo";<br/>const substring = "oo";<br/><br/>console.log(string.includes(substring)); // true</span></pre><p id="6e5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">includes在字符串上执行<strong class="jp ir">区分大小写的</strong>搜索。</p><p id="004c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为开发人员，您需要注意includes何时被使用。旧的浏览器，尤其是Internet Explorer不支持String.prototype.includes。这意味着，您必须在代码中有一个回退机制来处理这些环境。</p><h1 id="da3d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">EcmaScript-5</h1><p id="d144" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">indexOf可用于判断字符串是否包含子串。如果子字符串不在字符串中，indexOf方法将返回-1。它经常在数组中使用，同样的情况也适用于字符串。</p><pre class="km kn ko kp gt mf md mg mh aw mi bi"><span id="912a" class="mj ky iq md b gy mk ml l mm mn">var string = "foo";<br/>var substring = "oo";<br/><br/>console.log(string.indexOf(substring) !== -1); // true</span></pre><p id="de38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">indexOf对字符串进行区分大小写的搜索。</p><h1 id="1ac6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">时间复杂度</h1><p id="d7cf" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">无论使用includes还是indexOf，这两种简单算法的时间复杂度都是O(m * n)，其中m是父字符串的长度，n是子字符串的长度。</p><p id="daea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的目标是一个时间复杂度更低的解决方案，你需要使用不同的算法。</p><h1 id="aa11" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Knuth-Morris-Pratt算法别名KMP算法</h1><p id="ba00" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">首先，KMP算法的时间复杂度为O(m+n)。这要快得多，也比幼稚的好得多。</p><p id="0889" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KMP算法采用线性方法来检查子串是否存在于字符串中。这是我的KMP算法版本。</p><pre class="km kn ko kp gt mf md mg mh aw mi bi"><span id="ba5d" class="mj ky iq md b gy mk ml l mm mn">function kmpSearch(pattern, text) {<br/>  if (pattern.length == 0)<br/>    return 0; // Immediate match<br/>  var j = 0; // Number of chars matched in pattern<br/>  for (var i = 0; i &lt; text.length; i++) {<br/>    if (text.charAt(i) != pattern.charAt(j)){<br/>      j = 0; // Fall back in the pattern<br/>    }<br/>    if (text.charAt(i) == pattern.charAt(j)) {<br/>      j++; // Next char matched, increment position<br/>      if (j == pattern.length)<br/>        return i - (j - 1);<br/>    }<br/>  }<br/>  return -1; // Not found<br/>}</span></pre><p id="eafe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们上面做的事情很简单。让我们一步一步地解读这个流程:</p><ol class=""><li id="2902" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">如果模式是空字符串，则可以返回true，因为。</li><li id="14f0" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">逐个字符地遍历字符串</li><li id="fd7b" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir">如果文本中的当前字符不等于模式中的当前字符，将模式的指针重置到第0个索引</strong></li><li id="70d0" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">继续遍历文本</li><li id="2598" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir">如果文本中的当前字符等于模式中的当前字符，则增加模式中当前字符的位置</strong></li><li id="3169" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir">如果指针长度和模式长度匹配，返回文本中模式的起始索引</strong></li><li id="6f74" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">如果从未找到该模式，则返回-1</li></ol><p id="3580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在寻找一种线性算法来检查文本中是否存在子字符串，那么KMP算法绝对是您的首选解决方案。</p><h1 id="d157" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="2600" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在，我们已经掌握了如何检查子串是否存在于字符串中。到目前为止，只有这三种传统的、最常用的方法来检查模式是否在字符串中找到。当然，KMP算法并不局限于JavaScript。它可以用任何编程语言实现。它是字符串模式检查的线性算法。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="8dd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢我的话，请跟随并继续学习。</p><p id="83d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nj">更多内容尽在</em><a class="ae me" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>