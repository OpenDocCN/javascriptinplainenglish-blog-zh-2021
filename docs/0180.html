<html>
<head>
<title>Leverage Polymorphic Data Validation With Nest.js and Mongoose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Nest.js和Mongoose进行多态数据验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leverage-polymorphic-data-validation-with-nest-js-and-mongoose-10ae1dcbcf6d?source=collection_archive---------1-----------------------#2021-01-11">https://javascript.plainenglish.io/leverage-polymorphic-data-validation-with-nest-js-and-mongoose-10ae1dcbcf6d?source=collection_archive---------1-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d45f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">验证填充了不同数据模型的文档数组的实践指南</em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/e862d43ad60bf76450ba96fa03bd6cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0JgjflpxOOnWJIc8NIwew.jpeg"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@yogipurnama?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Yogi Purnama</a> on <a class="ae kt" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>, modified by the author</figcaption></figure><p id="c83e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">想象一下:您有一个<code class="fe lq lr ls lt b">customer</code>文档的集合，每个文档都有一个<code class="fe lq lr ls lt b">favouritePaymentMethods</code>数组字段。您需要将它们保存在您的数据库中，但是付款方式的细节可能会有很大的不同。它可能是信用卡或借记卡、礼券或直接借记。它们都是有相似之处的支付方式，但是你可能会存储不同的细节(信用卡的到期日，SEPA借记的银行账号等等。).嗯，您刚刚进入多态数据模型的世界，我们将在本文中讨论如何确保存储的数据是干净的。</p><h2 id="51a1" class="lu lv in bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">先决条件</h2><p id="56ef" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">为了保持这篇文章的重点，我假设你对如何引导NestJS API和使用mongose有基本的了解:如果没有，那么看看<a class="ae kt" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest </a>的文档和<a class="ae kt" href="https://mongoosejs.com/docs/index.html" rel="noopener ugc nofollow" target="_blank">mongose的快速入门指南</a>。不要担心，这篇文章仍然会在那里，供您检查😉。</p><p id="4516" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">另外，如果您不确定为什么首先应该使用NestJS，那么可以看看这篇中肯的文章:</p><div class="ms mt gp gr mu mv"><a href="https://medium.com/javascript-in-plain-english/be-cool-get-started-with-nestjs-a-modern-web-framework-for-node-js-31b25e6348d5" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd io gy z fp na fr fs nb fu fw im bi translated">对于您的节点应用程序，您肯定应该使用NestJS</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">用NestJS超级爽。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">medium.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj kn mv"/></div></div></a></div><h1 id="82c8" class="nk lv in bd lw nl nm nn lz no np nq mc jt nr ju mf jw ns jx mi jz nt ka ml nu bi translated">未经验证的示例API</h1><p id="35f2" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">在这个例子中，我们将考虑一个API，它存储了一个<code class="fe lq lr ls lt b">Forest</code>文档的集合，每个森林都有一个包含森林动物的子文档集合。我相信你已经知道，假设你已经安装了nest的CLI，你可以用<code class="fe lq lr ls lt b">nest new forest-api</code>创建一个新的nest API。请随意查看GitHub 上的<a class="ae kt" href="https://github.com/Marchelune/nestjs-mongoose-discriminator" rel="noopener ugc nofollow" target="_blank">示例代码。我们还需要安装<code class="fe lq lr ls lt b">@nestjs/mongoose</code>包:它允许我们定义一个TypeScript类来生成相应的Mongoose模式，如下所示:</a></p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="77f7" class="lu lv in bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">NestJS控制器设置</h2><p id="1e28" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">既然我们的森林数据库模型已经定义好了，我们只需要创建一个控制器。为了简化这个例子，我们直接在我们的控制器中注入猫鼬层，但是不要在家里这样做！在生产中，我们应该在专用服务中定义我们的领域逻辑。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7190" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们不要忘记在应用程序模块中注册我们的Mongoose连接和模式:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3afa" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们到了。我们可以运行我们API，发布任意多的动物，例如curl:</p><pre class="ke kf kg kh gt nx lt ny nz aw oa bi"><span id="06cd" class="lu lv in lt b gy ob oc l od oe">npm run start;<br/>curl -X PUT "http://localhost:3000/forest/broceliande/animals" -H  "accept: */*" -H  "Content-Type: application/json" -d "{\"type\":\"bear\",\"numberOfLegs\":4}";</span></pre><p id="b819" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">问题是，使用这种方法，我们无法控制进入数据库的内容😱。</p><h1 id="921d" class="nk lv in bd lw nl nm nn lz no np nq mc jt nr ju mf jw ns jx mi jz nt ka ml nu bi translated">创建验证模式</h1><p id="a318" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">我们这里想要的是验证进入我们森林的动物，我们可以区分我们在数据库模型中预期的两大类属性:</p><ol class=""><li id="77c2" class="of og in kw b kx ky la lb ld oh lh oi ll oj lp ok ol om on bi translated">所有动物可能共有的特性(如眼睛的数量、体重等。)</li><li id="1d32" class="of og in kw b kx oo la op ld oq lh or ll os lp ok ol om on bi translated">只有一些动物可能具有的特性(鸟喙的颜色，牙齿的数量等。)</li></ol><p id="b360" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">从那里我们得到了验证公共属性的基础模式的需求，以及验证特定属性所需的模式。然后，我们将使用Mongoose的<a class="ae kt" href="https://mongoosejs.com/docs/discriminators.html" rel="noopener ugc nofollow" target="_blank">鉴别器</a>将基础模型和特定模型链接在一起。</p><blockquote class="ot ou ov"><p id="5b45" class="ku kv ow kw b kx ky jo kz la lb jr lc ox le lf lg oy li lj lk oz lm ln lo lp ig bi translated">鉴别器是一种模式继承机制。它们使您能够在同一个底层MongoDB集合上拥有多个具有重叠模式的模型。</p></blockquote><h2 id="ceda" class="lu lv in bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">限制允许的动物</h2><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi pa"><img src="../Images/b555791f5982f197ffd0de2579289ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fi_cx_6kWHoIef4dRBXJUg.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">In our forest document, we only accept hares, wolves and unicorns. The first validation step will be to rule out any other animal.</figcaption></figure><p id="bb93" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">鉴别器使用一个鉴别器键:Mongoose将查看这个属性来判断一个模型是一种类型还是另一种类型。在我们的例子中，我们想知道数组中有哪种动物，以便应用适当的验证规则。首先，我们将列举我们的森林中允许的动物种类。从那里我们可以创建一个基础<code class="fe lq lr ls lt b">AnimalModel</code>，比如说一个公共的<code class="fe lq lr ls lt b">numberOfLegs</code>属性:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Although we are only interested in the schema here, you can export the class AnimalModel itself of course, to manipulate data when you retrieve it from the database</figcaption></figure><h2 id="4c88" class="lu lv in bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">为每种动物配置特定的属性</h2><p id="61d9" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">我们有我们的基地，检查！这意味着猫鼬将拒绝任何类型不属于<code class="fe lq lr ls lt b">AnimalKind</code>枚举，或者没有<code class="fe lq lr ls lt b">numberOfLegs </code>属性的动物。记下<code class="fe lq lr ls lt b">discriminatorKey</code>模式属性。当然，您可以使用更适合您的域的密钥名。现在我们来看看具体的动物模型:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3409" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们为普通属性定义了一个基本模型，并为每种动物定义了具有特定属性的专用模型。不要让你质疑森林中独角兽的存在，让我们继续来看看让这一切工作的魔术🙂。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi pb"><img src="../Images/4d860d100af88d9e79cfb4226385f45d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-gDVFlrP8TsmcDHzGb0aQ.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">A visual recap of the Mongoose schema above: if we try to insert a wolf, then it must have a canineLengthInCm property that is a number. If we add a unicorn, then it must have a <em class="kc">hornColor</em> string property in order to pass validation.</figcaption></figure><h1 id="aa53" class="nk lv in bd lw nl nm nn lz no np nq mc jt nr ju mf jw ns jx mi jz nt ka ml nu bi translated">注册一个鉴别器</h1><p id="66aa" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">我们需要告诉Mongoose，我们在森林文档中的<code class="fe lq lr ls lt b">animals</code>数组可能包含跟随<code class="fe lq lr ls lt b">AnimalSchema</code>和<code class="fe lq lr ls lt b">UnicornSchema</code>、<code class="fe lq lr ls lt b">HareSchema</code>或<code class="fe lq lr ls lt b">WolfSchema</code>的对象。因此，让我们重新看看森林文档:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ba81" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">不幸的是，在编写本文时，我们不得不手动向TypeScript指出我们模式中的<code class="fe lq lr ls lt b">animals</code>路径是一个<code class="fe lq lr ls lt b">DocumentArray</code>——mongose的类型还不能推断出这一点。因此，我建议我们尽可能保持这种类型假设接近模式定义，并在函数中提取鉴别器的设置。</p><h2 id="5b03" class="lu lv in bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">使用专用函数注册所有模式</h2><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7167" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在上面的代码片段中，我们告诉Mongoose，当<code class="fe lq lr ls lt b">animalArraySchema</code>元素的鉴别器键等于<code class="fe lq lr ls lt b">AnimalKind.Hare</code>时，使用<code class="fe lq lr ls lt b">HareSchema</code>来验证它。同样的还有<code class="fe lq lr ls lt b">Wolf</code>和<code class="fe lq lr ls lt b">Unicorn</code>以及你可能需要的任意多的动物:提取到一个专用函数允许我们在不接触我们的<code class="fe lq lr ls lt b">ForestModel</code>的情况下增加有效条目的列表！有人说过开闭原则吗😃？</p><p id="f1ae" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">按照执行顺序，<code class="fe lq lr ls lt b">registerAnimalSchemaDiscriminator</code>会被调用一次，当Node读取包含ForestModel的模块时。最后一件事:正如<a class="ae kt" href="https://mongoosejs.com/docs/discriminators.html#embedded-discriminators-in-arrays" rel="noopener ugc nofollow" target="_blank">mongose的文档</a>所建议的，如果在特定路径上有pre或post挂钩，那么需要在注册鉴别器之前配置它们。</p><h1 id="637d" class="nk lv in bd lw nl nm nn lz no np nq mc jt nr ju mf jw ns jx mi jz nt ka ml nu bi translated">让我们看看它的实际效果吧！</h1><p id="131c" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">我们现在都准备好了！为了让我们看到验证消息，我在数据库写操作周围添加了一个try/catch，这样任何验证异常都会导致一个错误的请求。让我们尝试通过PUT端点在animals数组中插入一只大象:</p><pre class="ke kf kg kh gt nx lt ny nz aw oa bi"><span id="a152" class="lu lv in lt b gy ob oc l od oe">curl -X PUT "http://localhost:3000/forest/broceliande/animals" -H  "accept: */*" -H  "Content-Type: application/json" -d "{\"kind\":\"elephant\",\"numberOfLegs\":4}";</span></pre><p id="56dc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为此我们将获得:</p><pre class="ke kf kg kh gt nx lt ny nz aw oa bi"><span id="53fa" class="lu lv in lt b gy ob oc l od oe">Bad Request.<br/>ForestModel validation failed: animals.0.kind: `elephant` is not a valid enum value for path `kind`.</span></pre><p id="5bb9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">生效的验证规则是在基本的<code class="fe lq lr ls lt b">AnimalModel</code>级别:Mongoose只允许我们列举的动物种类进入。</p><h2 id="3695" class="lu lv in bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">多态验证</h2><p id="3dec" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">不让大象进入我们的森林是令人钦佩的，但也是…基本的。你不需要歧视！让我们更深入地尝试插入一只没有角颜色的独角兽:</p><pre class="ke kf kg kh gt nx lt ny nz aw oa bi"><span id="768c" class="lu lv in lt b gy ob oc l od oe">curl -X PUT “http://localhost:3000/forest/broceliande/animals" -H “accept: */*” -H “Content-Type: application/json” -d “{\”kind\”:\”unicorn\”,\”numberOfLegs\”:4}”</span></pre><p id="a14d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这导致:</p><pre class="ke kf kg kh gt nx lt ny nz aw oa bi"><span id="d02f" class="lu lv in lt b gy ob oc l od oe">Bad Request.<br/>ForestModel validation failed: animals.0.hornColor: Path `hornColor` is required.</span></pre><p id="7567" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">看，多态验证的力量🦄！猫鼬拒绝这只独角兽，因为我们明确说过独角兽必须有角的颜色。当然，如果我们使用正确的喇叭颜色字符串运行请求，我们的API将返回200代码。整洁不是吗？</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/d35713042ec09f13d6f3cb5b0f497e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/1*ZN5sipnTlMyNOV8c9u0KIQ.gif"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">If you don’t like CLI commands, here is a Swagger UI version of our Rest API</figcaption></figure></div><div class="ab cl pd pe hr pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="ig ih ii ij ik"><h1 id="8b7d" class="nk lv in bd lw nl pk nn lz no pl nq mc jt pm ju mf jw pn jx mi jz po ka ml nu bi translated">包扎</h1><p id="35b7" class="pw-post-body-paragraph ku kv in kw b kx mn jo kz la mo jr lc ld mp lf lg lh mq lj lk ll mr ln lo lp ig bi translated">让我们总结一下本文中所涉及的内容:</p><ol class=""><li id="c337" class="of og in kw b kx ky la lb ld oh lh oi ll oj lp ok ol om on bi translated">我们创建了一个基础模式，子文档数组的所有元素都将根据该模式进行验证。</li><li id="3bcb" class="of og in kw b kx oo la op ld oq lh or ll os lp ok ol om on bi translated">我们为数组中接受的每种元素创建了特定的模式。所有这些模式类型名称都列在一个字符串枚举中。</li><li id="1030" class="of og in kw b kx oo la op ld oq lh or ll os lp ok ol om on bi translated">我们使用Mongoose的鉴别器在数组的模式上注册了每个特定的模式。</li></ol><p id="6d33" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">请注意，鉴别器也可以用于单个子文档(一个属性是多态的)，用于整个文档(集合是多态的)，甚至是嵌套的鉴别器。如果你想知道更多关于这些场景的信息，请在评论中告诉我！</p><p id="2b66" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我希望你能从那篇文章中学到一些东西，谢谢你的阅读🙏！</p><h2 id="4afc" class="lu lv in bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">资源</h2><ul class=""><li id="3846" class="of og in kw b kx mn la mo ld pp lh pq ll pr lp ps ol om on bi translated">NestJS的猫鼬指南:<a class="ae kt" href="https://docs.nestjs.com/techniques/mongodb" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/techniques/mongodb</a></li><li id="9ed3" class="of og in kw b kx oo la op ld oq lh or ll os lp ps ol om on bi translated">猫鼬的歧视者博士:<a class="ae kt" href="https://mongoosejs.com/docs/discriminators" rel="noopener ugc nofollow" target="_blank">https://mongoosejs.com/docs/discriminators</a></li><li id="b5b9" class="of og in kw b kx oo la op ld oq lh or ll os lp ps ol om on bi translated">那篇文章的全部代码，打包了一个内存中的数据库和swagger接口，以便您可以轻松地进行自我测试😉:【https://github.com/Marchelune/nestjs-mongoose-discriminator T2】</li></ul></div></div>    
</body>
</html>