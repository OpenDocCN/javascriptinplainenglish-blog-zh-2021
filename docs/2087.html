<html>
<head>
<title>You Have to Know Closures to be a (Good) React Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你必须知道闭包是一个(好的)反应开发者</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-have-to-know-closures-to-be-a-good-react-developer-104fc2f6cd70?source=collection_archive---------0-----------------------#2021-05-03">https://javascript.plainenglish.io/you-have-to-know-closures-to-be-a-good-react-developer-104fc2f6cd70?source=collection_archive---------0-----------------------#2021-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a24a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">为什么你需要知道闭包才能成为一个比普通的React开发者</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/15bcd8c8113f166c3ba3c9b1ae3f990d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e5DuF8VS87GddyIk"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0d4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我经常听到这样的误解:作为一名React开发者并不意味着你必须对JavaScript的工作原理有深刻的理解。毕竟，这是有意义的——一般的React开发者在大多数时间里只使用三进制表达式和一些数组函数(map、filter等)。)，对吗？</p><p id="ea97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好吧，事实证明，如果你想成为一个比普通的React开发人员更优秀的开发人员，你需要对JavaScript在幕后是如何工作的有一个扎实的掌握——闭包、原型和引用/基元值类型，这些只是你必须掌握的一些概念。</p><p id="75c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我将向您展示，理解闭包如何提高您的反应技能。本文不是要解释闭包是如何工作的。我将展示一个简单的例子，但是如果你想理解闭包，我建议你搜索另一个资源<a class="ae ks" href="https://dmitripavlutin.com/simple-explanation-of-javascript-closures/" rel="noopener ugc nofollow" target="_blank">(像这样)</a>。兴奋吗？我们走吧！</p><h1 id="1610" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">什么是结束？</h1><p id="22f2" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">让我们看看<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> MDN对</a>闭包有什么看法:</p><blockquote class="mm mn mo"><p id="dc0a" class="kt ku mp kv b kw kx jo ky kz la jr lb mq ld le lf mr lh li lj ms ll lm ln lo ig bi translated">闭包是捆绑在一起的函数与对其周围状态(词汇环境)的引用的组合。换句话说，闭包让您可以从内部函数访问外部函数的范围。在JavaScript中，每次创建函数时都会在函数创建时创建闭包。</p></blockquote><p id="0683" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好的，这是官方定义。听起来有点吓人？简单地说:Closure意味着，当JavaScript运行您的代码时，它会查找您的函数中的所有变量，如果它看到一个函数中没有声明(- let，const)的变量，但是在一个外部作用域(函数嵌套在其中)中，它会“锁定”给定函数中该变量的值。</p><p id="2ed9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你还困惑吗？考虑以下代码片段:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="1ffa" class="my lq in mu b gy mz na l nb nc">const myOuterFunction = () =&gt; {<br/>  let variableInOuterFunction = 'Hello World';<br/></span><span id="888a" class="my lq in mu b gy nd na l nb nc">  const myNestedFunction = () =&gt; {<br/>    console.log(variableInOuterFunction);<br/>  };<br/></span><span id="96d2" class="my lq in mu b gy nd na l nb nc">  myNestedFunction();<br/>};<br/></span><span id="0a57" class="my lq in mu b gy nd na l nb nc">myOuterFunction();</span></pre><p id="e183" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，我们如何在“myNestedFunction”中使用“variableInOuterFunction”(在myOuterFunction中声明)。结束了。值“Hello World”现在在嵌套函数中被“关闭”(锁定)。听起来很简单，对吧？让我们看看理解它如何帮助我们做出反应。</p><h1 id="e00d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">反应中的闭包</h1><p id="e565" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">所以，让我们看看闭包在reactor中是如何工作的。</p><p id="6766" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑以下代码片段:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="ba8c" class="my lq in mu b gy mz na l nb nc">import React, { useEffect, useState } from 'react';</span><span id="88c0" class="my lq in mu b gy nd na l nb nc">const ClosuresInReact = () =&gt; {<br/>  const [count, setCount] = useState('1');<br/></span><span id="8d60" class="my lq in mu b gy nd na l nb nc">  const incrementCount = () =&gt; {<br/>    setCount(prevCount =&gt; +prevCount + 1);<br/>  };<br/></span><span id="383e" class="my lq in mu b gy nd na l nb nc">  useEffect(() =&gt; {<br/>    const timer = setTimeout(() =&gt; {<br/>      incrementCount();<br/>    }, 1000);<br/>    return () =&gt; {<br/>      clearTimeout(timer);<br/>    };<br/>  }, [incrementCount]);<br/>  return &lt;div&gt;{`Timer started: ${count}`}&lt;/div&gt;;<br/>};<br/></span><span id="02f4" class="my lq in mu b gy nd na l nb nc">export default ClosuresInReact;</span></pre><p id="75ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么，我们这里有什么？</p><p id="202a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它是一个简单的反应组件，在屏幕上打印一个计时器，每秒钟递增一次。我们使用useState钩子来跟踪计数变量的变化，然后使用setCount函数来增加计数变量的增量计数函数，最后，我们使用useEffect钩子来负责使用内置的JavaScript函数setTimeout每秒触发增量计数函数。</p><p id="4810" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有经验的React开发人员可能已经注意到，在useEffect钩子的依赖数组中有incrementCount函数。实际上，可能没有必要在这里包含它，但是总是用useEffect钩子中使用的所有变量(和函数)填充依赖数组被认为是一个好的实践。</p><p id="b44f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们有另一个问题。使用incrementCount函数作为useEffect hook中的依赖项，我的IDE横向对我大喊:</p><p id="7c94" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">添加替代文本</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/31d4f3b79c2074662e347c0439eb91f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PREeT83wIpZ1Aq0-"/></div></div></figure><p id="85a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们不会深究为什么现在会发生这种情况，我只会说这与函数是引用类型这一事实有关，如果我们不将它移动到useEffect钩子内或用useCallback钩子包装它，我们会导致无限循环。无论如何，对我们来说，现在重要的是IDE的建议——要么将incrementCount移到useEffect内部，要么用useCallback钩子将它包装起来。让我们选择第二个选项。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="373a" class="my lq in mu b gy mz na l nb nc">import React, { useCallback, useEffect, useState } from 'react';</span><span id="8169" class="my lq in mu b gy nd na l nb nc">const ClosuresInReact = () =&gt; {<br/>  const [count, setCount] = useState('1');<br/></span><span id="3924" class="my lq in mu b gy nd na l nb nc">  const incrementCount = useCallback(() =&gt; {<br/>    setCount(prevCount =&gt; +prevCount + 1);<br/>  }, []);<br/></span><span id="6f7f" class="my lq in mu b gy nd na l nb nc">  useEffect(() =&gt; {<br/>    const timer = setTimeout(() =&gt; {<br/>      incrementCount();<br/>    }, 1000);<br/>    return () =&gt; {<br/>      clearTimeout(timer);<br/>    };<br/>  }, [incrementCount]);<br/>  return &lt;div&gt;{`Timer started: ${count}`}&lt;/div&gt;;<br/>};<br/></span><span id="d7be" class="my lq in mu b gy nd na l nb nc">export default ClosuresInReact;</span></pre><p id="b52f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太好了！现在一切都正常了，对吗？我的意思是，甚至我的IDE现在也平静下来了，让我们运行代码吧！</p><p id="379f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们看到计时器开始计时:1，2，然后…发生了什么？计时器刚刚停在2？为什么会这样呢？</p><p id="f131" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">添加替代文本</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/2cd27f9424cc8d2898a76b418af38782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nV-6DJ3niuj_nmRD"/></div></div></figure><p id="3c7a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">原因是——你猜对了——闭包！如果我们仔细观察，我们会发现在incrementCount函数中实际上有一个闭包。这一点很难注意到，但是当我们使用setCount函数时，我们也依赖于Count变量，我们也可以这样写:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="cb91" class="my lq in mu b gy mz na l nb nc">setCount(+count + 1)</span></pre><p id="5248" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编写更长版本的原因是，当我们依赖以前的状态时，我们应该采用最新的状态，这样做是一个好的做法(尽管在我们的示例中不一定需要)。</p><p id="658a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">无论如何，回到闭包——正如我们在例子中看到的，在外部函数ClosuresInReact中声明的变量count的值现在被“锁定”在函数incrementCount中。更准确地说，我们在setCount函数中所做的增量被锁定在incrementCount函数中，这就是为什么我们在屏幕上看到1、2和… stop。</p><h1 id="1229" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">如何修复React中的关闭问题</h1><p id="3d5e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">因此，让我们简化这里发生的过程:</p><p id="113c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React:我有一个将incrementCount作为依赖项的useEffect钩子。这意味着我应该只在incrementCount改变时重新渲染。</p><p id="5605" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React:我用useCallback钩子包装了incrementCount。这意味着我应该记住它的第一个闭包(当它第一次运行时)，即使发生了重新呈现，我也不应该在刷新的环境中运行函数(当count现在是2时)，而是使用我捕获的它的良好的旧的第一个闭包(当count是1时)。</p><p id="148d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React: useEffect告诉我incrementCount没有变化，所以我不应该触发新的渲染。</p><p id="bce3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你明白了。那么我们该怎么办呢？解决办法很简单。我们需要将count变量作为依赖项传递给useCallback钩子。这样，我们告诉React，即使我们希望保留incrementCount函数的第一个闭包，React也应该跟踪并用Count变量的最新值更新闭包。通过这样做，我们还导致了useEffect钩子调用屏幕上的重新呈现，因为incrementCount每秒都在变化。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="826a" class="my lq in mu b gy mz na l nb nc">import React, { useCallback, useEffect, useState } from 'react';<br/></span><span id="c693" class="my lq in mu b gy nd na l nb nc">const ClosuresInReact = () =&gt; {<br/>  const [count, setCount] = useState('1');<br/></span><span id="001d" class="my lq in mu b gy nd na l nb nc">  const incrementCount = useCallback(() =&gt; {<br/>    setCount(prevCount =&gt; +prevCount + 1);<br/>  }, [count]);<br/></span><span id="cb4e" class="my lq in mu b gy nd na l nb nc">  useEffect(() =&gt; {<br/>    console.log('useEffect');<br/>    const timer = setTimeout(() =&gt; {<br/>      incrementCount();<br/>    }, 1000);<br/>    return () =&gt; {<br/>      clearTimeout(timer);<br/>    };<br/>  }, [incrementCount]);<br/>  return &lt;div&gt;{`Timer started: ${count}`}&lt;/div&gt;;<br/>};<br/></span><span id="9323" class="my lq in mu b gy nd na l nb nc">export default ClosuresInReact;</span></pre><p id="793c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在一切都在按预期运行。有趣的是，我的IDE现在仍然对我大喊:</p><p id="08af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">添加替代文本</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/870c546ce9849df47b23fc8f22f404d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xsoaeAu953l6oFrp"/></div></div></figure><p id="ecba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它告诉我从依赖数组中移除计数。这当然是一个错误，发生这种情况是因为我们实际上并没有在setCount函数中使用count变量，但这只是再次向我们展示了理解闭包对于一个好的React开发人员来说是多么重要，因为没有它我们无法解决问题。</p><h1 id="f2e4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="9943" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">JavaScript中的闭包是一个至关重要的概念，当涉及到反应时，理解幕后发生的事情可能变得更加重要。React本身，尤其是React钩子，在很多地方都使用了闭包。</p><p id="af77" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">掌握闭包的概念，以及JavaScript的其他核心概念(原型、引用和原始类型，等等)会使您成为更好的React开发人员，并帮助您以更高效、更优雅的方式解决问题。</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><h1 id="5317" class="lp lq in bd lr ls nm lu lv lw nn ly lz jt no ju mb jw np jx md jz nq ka mf mg bi translated">用组件构建微前端</h1><p id="2d4d" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">微前端是加速和扩展应用程序开发的好方法，具有独立的部署、解耦的代码库和自治的团队。</p><p id="154a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">位为构建组件驱动的微前端提供了很好的开发体验。构建组件、协作和组合可扩展的应用程序。<a class="ae ks" href="https://github.com/teambit/bit" rel="noopener ugc nofollow" target="_blank">我们的GitHub有超过14.5k颗星星！</a></p><p id="8b43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">试一试→ </strong> </a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/974fac3b1ac310e3d805735bbe3a102d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7OCJ5MkhAaNsAxCe.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">An independently source-controlled and shared “card” component (on the right, its dependency graph, auto-generated by Bit)</figcaption></figure><h2 id="6e5f" class="my lq in bd lr ns nt dn lv nu nv dp lz lc nw nx mb lg ny nz md lk oa ob mf oc bi translated">了解更多信息</h2><div class="od oe gp gr of og"><a href="https://blog.bitsrc.io/building-a-react-component-library-d92a2da8eab9" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">构建React组件库——正确的方法</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">创建一个超级模块化的React组件库:可伸缩、可维护、安装速度极快。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">blog.bitsrc.io</p></div></div><div class="op l"><div class="oq l or os ot op ou km og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://blog.bitsrc.io/microservices-are-dead-long-live-miniservices-40e4ccf4741" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">微服务已死——微服务万岁</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">你真的在为你的应用使用微服务吗？再想想。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">blog.bitsrc.io</p></div></div><div class="op l"><div class="ov l or os ot op ou km og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://blog.bitsrc.io/7-tools-for-faster-frontend-development-in-2022-43b6f663c607" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">2022年加快前端开发的7种工具</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">您应该知道的工具，可以更快地构建现代前端应用程序，并获得更多乐趣。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">blog.bitsrc.io</p></div></div><div class="op l"><div class="ow l or os ot op ou km og"/></div></div></a></div></div></div>    
</body>
</html>