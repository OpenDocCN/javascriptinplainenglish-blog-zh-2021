<html>
<head>
<title>Storybook with React, Redux, and Material UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React、Redux和材质UI的故事书</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/storybook-with-react-redux-and-material-ui-eeacd04bee26?source=collection_archive---------2-----------------------#2021-01-28">https://javascript.plainenglish.io/storybook-with-react-redux-and-material-ui-eeacd04bee26?source=collection_archive---------2-----------------------#2021-01-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/771af0821c19a8ec2f28f67d2cea2824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GTpFgOrMzr4BRwjr"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@alexblock?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Block</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aeb1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用React CRA、Redux、材质UI主题化、代理和路由导航故事书的复杂性可能会很棘手。</p><p id="9c72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank"> Storybook </a>对于独立开发和测试UI组件来说是无价的，它支持快速原型开发，同时迫使你对组件和容器的API进行批判性思考。</p><h1 id="457f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">初始设置</h1><p id="2e61" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">使用<code class="fe mb mc md me b">npx sb init</code>命令设置React故事书很简单。例如，要用Storybook搭建一个<a class="ae jz" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> Create React App </a>，只需执行以下命令:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="375e" class="mn kz in me b gy mo mp l mq mr">npx create-react-app my-app<br/>cd my-app<br/>npx sb init</span></pre><p id="bc79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">故事书和CRA最近出现了一些问题——你可能在执行<code class="fe mb mc md me b">npx sb init</code>后遇到了巴别塔错误，例如:</p><blockquote class="ms mt mu"><p id="bc45" class="ka kb mv kc b kd ke kf kg kh ki kj kk mw km kn ko mx kq kr ks my ku kv kw kx ig bi translated">错误:找不到模块“babel-loader”</p></blockquote><p id="921b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者，在添加babel loader后:</p><blockquote class="ms mt mu"><p id="8c91" class="ka kb mv kc b kd ke kf kg kh ki kj kk mw km kn ko mx kq kr ks my ku kv kw kx ig bi translated">中的错误。/.story book/story book-init-framework-entry . js<br/>模块未找到:错误:您试图导入项目src/目录之外的…/my-app/node _ modules/@ pmmmwh/react-refresh-web pack-plugin/lib/runtime/refresh utils . js。不支持src/之外的相对导入。<br/>您可以将它移动到src/中，或者从项目的node_modules/中添加一个符号链接。</p></blockquote><p id="a7c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢天谢地，故事书团队已经解决了这些问题。</p><p id="3438" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要尝试最新功能，请安装为:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="ce9a" class="mn kz in me b gy mo mp l mq mr">npx sb@next init</span></pre><p id="f178" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成后，Storybook将在以下位置搭建配置和一组示例故事:</p><ul class=""><li id="682e" class="mz na in kc b kd ke kh ki kl nb kp nc kt nd kx ne nf ng nh bi translated"><code class="fe mb mc md me b">.storybook/</code> —故事书的配置</li><li id="8005" class="mz na in kc b kd ni kh nj kl nk kp nl kt nm kx ne nf ng nh bi translated"><code class="fe mb mc md me b">src/stories/</code> —示例故事</li></ul><p id="cc8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要启动Storybook，请执行:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="89e7" class="mn kz in me b gy mo mp l mq mr">yarn storybook</span></pre><p id="bb90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，导航到<a class="ae jz" href="http://localhost:6006/" rel="noopener ugc nofollow" target="_blank"> http://localhost:6006/ </a>查看界面:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/8538f46ef70dfe5782eb230cc3202042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nz5h_7yoACqFQv5Y-FX_GA.png"/></div></div></figure><h1 id="5663" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建故事书文档</h1><p id="9303" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Storybook使用MDX来创建<a class="ae jz" href="https://storybook.js.org/docs/react/writing-docs/introduction" rel="noopener ugc nofollow" target="_blank"> Storybook文档</a>——这是记录组件的好方法。</p><p id="c76d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mb mc md me b">src/stories</code>文件夹下，通过创建一个名为<code class="fe mb mc md me b">[topic].stories.mdx</code>的新文件并在<code class="fe mb mc md me b">&lt;Meta tile="section/topic]" /&gt;</code>元块中指定标题来创建任意数量的MDX文档。</p><p id="d135" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个示例introduction.stories.mdx文件:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b280" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子结合了markdown和样式化的HTML，将会在Storybook UI中产生下面的页面:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/d5312c2c6d248fb52f5b4ba20b5662ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzCe-nOch8CkYzxboCsrtw.png"/></div></div></figure><h1 id="7c7b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创造一个故事</h1><p id="7929" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Storybook自动搭建一些示例故事，其中示例组件定义在<code class="fe mb mc md me b">src/stories</code>文件夹中。当然，您可以像往常一样从<code class="fe mb mc md me b">src/</code>访问您的组件——这些只是为了演示的目的。事实上，你可以删除stories文件夹中的所有内容，重新开始。</p><p id="0574" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mb mc md me b">src/stories</code>文件夹下，通过添加名为<code class="fe mb mc md me b">[topic].stories.js</code>的新文件来分组组件集合，从而创建任意数量的故事。</p><p id="2846" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在每个故事中，加载故事的React和组件，导出标题、参数类型和组件以加载到Storybook中:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="aebb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子显示了一个具有以下参数类型的<code class="fe mb mc md me b">Button</code>组件:</p><ul class=""><li id="2cef" class="mz na in kc b kd ke kh ki kl nb kp nc kt nd kx ne nf ng nh bi translated">背景颜色，使用颜色控件</li><li id="f3d6" class="mz na in kc b kd ni kh nj kl nk kp nl kt nm kx ne nf ng nh bi translated">主要，使用布尔拨动开关</li><li id="5f73" class="mz na in kc b kd ni kh nj kl nk kp nl kt nm kx ne nf ng nh bi translated">标签，使用字符串文本输入</li><li id="9a8c" class="mz na in kc b kd ni kh nj kl nk kp nl kt nm kx ne nf ng nh bi translated">大小，使用单选控件显示可能选项的枚举</li></ul><p id="5668" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，通过向组件传递参数，组件将默认为使用标签“<em class="mv">primary Button”</em>启用的Primary。</p><p id="4ebb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Storybook将按如下方式加载这个故事:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/fda9c5743392f259096e56b28272a1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5shT2Yy1R6L1_MoSvJc2g.png"/></div></div></figure><p id="c8bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Storybook的<a class="ae jz" href="https://storybook.js.org/docs/react/essentials/controls" rel="noopener ugc nofollow" target="_blank">基本控件</a>文档中定义了各种各样的内置控件。包括数组、布尔值、数字、范围、文本、颜色、日期、单选、复选和选择。</p><h1 id="0263" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">代理端点和Web套接字</h1><p id="271b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果您的开发环境包含多个通过其他后端服务器提供流数据、静态资产和API的服务器，您可能需要实现中间件来代理请求。</p><p id="7a02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果您的React应用程序实现了利用<code class="fe mb mc md me b">http-proxy-middleware</code>的代理，您可以通过在<code class="fe mb mc md me b">.storybook/</code>文件夹下创建一个名为<code class="fe mb mc md me b">middleware.js</code>的文件来将相同的功能与Storybook合并，该文件包括:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="453c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面，web socket请求被代理到localhost端口4002，<code class="fe mb mc md me b">/photos</code>和<code class="fe mb mc md me b">/api</code>的两个端点被代理到localhost端口3001。</p><h1 id="e5bf" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">还原、主题化和路由</h1><p id="d257" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">三个额外的主题在这里被分组，因为它们都与Storybook的预览装饰器相关。</p><ul class=""><li id="3aaa" class="mz na in kc b kd ke kh ki kl nb kp nc kt nd kx ne nf ng nh bi translated">合并一家Redux商店</li><li id="ed29" class="mz na in kc b kd ni kh nj kl nk kp nl kt nm kx ne nf ng nh bi translated">与材质UI主题提供程序集成</li><li id="9b78" class="mz na in kc b kd ni kh nj kl nk kp nl kt nm kx ne nf ng nh bi translated">用React路由器处理路由问题</li></ul><p id="3351" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过在名为<code class="fe mb mc md me b">preview.js</code>的<code class="fe mb mc md me b">.storybook/</code>文件夹下创建一个包含以下内容的文件，所有的故事都可以实现一个全局装饰器来提供这个功能:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="02c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将围绕Storybook呈现的故事包装功能。</p><h2 id="fdc8" class="mn kz in bd la nq nr dn le ns nt dp li kl nu nv lm kp nw nx lq kt ny nz lu oa bi translated">Redux</h2><p id="74ac" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Storybook更倾向于组件和属性，而不是管理存储状态的容器。</p><p id="e4e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，在你的故事中加入一个提供者可能是必要的，特别是对于生命周期很长的大型项目。</p><p id="0322" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样做，可能有助于暴露和鼓励逻辑和表示的分离；或者，如果您的组件与Redux存储紧密集成，只需防止错误。</p><p id="b768" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在预览装饰器中，添加Redux提供程序并存储。</p><h2 id="c8a5" class="mn kz in bd la nq nr dn le ns nt dp li kl nu nv lm kp nw nx lq kt ny nz lu oa bi translated">材质UI主题化</h2><p id="22a9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果你的解决方案包含了主题化，比如Material UI的主题化系统，那么用你的主题提供者来查看你的组件是最理想的。</p><p id="675c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在预览装饰器中，添加您的主题提供者和主题定义。</p><h2 id="fe73" class="mn kz in bd la nq nr dn le ns nt dp li kl nu nv lm kp nw nx lq kt ny nz lu oa bi translated">反应路由器</h2><p id="d6be" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">路由在故事书里一般意义不大；但是，如果您的组件包含诸如React Router DOM中的<code class="fe mb mc md me b">useLocation</code> hook之类的功能，它们将抛出一个错误，除非实现了某种路由器。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="f96b" class="mn kz in me b gy mo mp l mq mr">import { useLocation } from "react-router-dom";</span><span id="6f3a" class="mn kz in me b gy ob mp l mq mr">const MyComponent = () =&gt; {<br/>  const location = useLocation();<br/><br/>  useEffect(() =&gt; {<br/>    // something happens...<br/>  }, [location]);</span></pre><p id="bf59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了弥补这一点，在预览装饰器中包含一个路由器，比如React Router的<code class="fe mb mc md me b">MemoryRouter</code>。</p></div></div>    
</body>
</html>