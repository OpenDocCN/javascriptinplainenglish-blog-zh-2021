<html>
<head>
<title>Can React useMemo be used to skip a child render?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React useMemo可以用来跳过子渲染吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/can-usememo-skip-a-child-render-94e61f5ad981?source=collection_archive---------4-----------------------#2021-08-27">https://javascript.plainenglish.io/can-usememo-skip-a-child-render-94e61f5ad981?source=collection_archive---------4-----------------------#2021-08-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8141" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它不能，除非你知道什么是<code class="fe ki kj kk kl b">useMemo</code>。</p><p id="9aa8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React提供了一个开箱即用的优化引擎，只要它认为合适，就可以应用救助途径。而且大部分路径都是在幕后构建的，开发者都是口头知道的。有时我们会对使用某些功能产生错误的想法。</p><p id="7da2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">什么是useMemo？</strong></p><p id="a0cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“memo”这个词给我们的感觉是使用了某种记忆模式。但是相反，如果你把一个任务叫做备忘录，那么编程本身就是一个巨大的备忘录引擎，这违背了使用这个词的目的。这样的话，React也可以被称为一个巨大的备忘录，就像fiberMemoizedReact，无论什么:)</p><p id="8d0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开个玩笑，<code class="fe ki kj kk kl b">useMemo</code>与任何经典记忆都没有关系，事实上它只是为了逃避一项任务。(检查文章，<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/react-usememo-is-not-a-classical-memorization-432a21d28431"> React useMemo不是经典的识记</a>)如果非要叫它Memo，它存储的是之前的值。该死，任何变量不都是这样吗？</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="2605" class="kv kw in kl b gy kx ky l kz la">const a = useMemo(() =&gt; { return ... }, [a, b])</span></pre><p id="af00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<code class="fe ki kj kk kl b">useMemo</code>是一个单一的赋值语句替换，只在<code class="fe ki kj kk kl b">a</code>或<code class="fe ki kj kk kl b">b</code>改变时执行赋值。所以它可以用来跳过一些赋值。</p><h2 id="477c" class="kv kw in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated"><strong class="ak">救助一个孩子，失败了</strong></h2><p id="05a1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">让我们看看这是如何相信它可以跳过一个子渲染。</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="03d4" class="kv kw in kl b gy kx ky l kz la">const Title = () =&gt; { <br/>  const a = useMemo(() =&gt; {<br/>    return "Hello World"<br/>  }, [])</span><span id="5d5b" class="kv kw in kl b gy lx ky l kz la">  return &lt;Child a={a} /&gt;<br/>}</span></pre><p id="8a36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">挂载后会创建一个变量<code class="fe ki kj kk kl b">a</code>，之后会存储一个原始的字符串值“Hello World”，所以从Child的角度来看，由于<code class="fe ki kj kk kl b">a</code>不再改变，因此Child一直被保释。</p><p id="7165" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是真的吗？只有渲染父标题才能测试出来，不是吗？</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="d101" class="kv kw in kl b gy kx ky l kz la">const Title = () =&gt; {<br/>  const [count, dispatch] = useState(0)<br/>  const onClick = () =&gt; { dispatch(v =&gt; v + 1) }</span><span id="8bc5" class="kv kw in kl b gy lx ky l kz la">  const a = useMemo(() =&gt; {<br/>    return "Hello World"<br/>  }, [])</span><span id="0909" class="kv kw in kl b gy lx ky l kz la">  return (<br/>    &lt;&gt;<br/>      &lt;Child a={a} /&gt;<br/>      &lt;div onClick={onClick}&gt;{count}&lt;/div&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="23b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们添加了一个新的状态<code class="fe ki kj kk kl b">count</code>和dispatch，这样我们就可以在点击数字后触发渲染。</p><p id="2c60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在这个例子完成了，你真的认为这个孩子可以救助吗？</p><figure class="kn ko kp kq gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ly"><img src="../Images/29d68bb91e519b7aac549f08073738c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZjEdVzM_buRCvJWo-reRQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Child renders without a bailout with useMemo</figcaption></figure><p id="eefd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的轮廓图确认了子渲染以及它下面的一切。您可能认为这有问题，但是这是React的默认设计。不仅如此，React始终如一地做到这一点。</p><p id="0234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所发生的是，当标题在渲染后更新时，它协调所有的子元素，因此为子元素创建一对新的<code class="fe ki kj kk kl b">props</code>。这将触发子渲染，而不管个人道具<code class="fe ki kj kk kl b">a</code>是否改变。(查看文章，【React如何基于变化进行渲染？)</p><p id="ddf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那为什么大家会用<code class="fe ki kj kk kl b">useMemo</code> for呢？哈哈，这是用来跳过作业的，因为某个作业很重。在我们的例子中，我们只返回一个“Hello World ”,但它可能是一个搜索功能，可能需要500毫秒才能完成。如果我们能够限制赋值，我们可以节省相当多的时间，类似于throttle的想法，但是基于依赖关系的变化。</p><h2 id="7c89" class="kv kw in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">救助一个孩子，成功</h2><p id="2a30" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这是不是意味着，我们不能用<code class="fe ki kj kk kl b">useMemo</code>来救助一个孩子？有办法，但不是通过道具。请记住<code class="fe ki kj kk kl b">useMemo</code>的设计目的，跳过任何格式的值的赋值。</p><p id="4b23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们稍微修改一下救市法案。</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="2f7c" class="kv kw in kl b gy kx ky l kz la">const Title = () =&gt; {<br/>  ...</span><span id="f849" class="kv kw in kl b gy lx ky l kz la">  const child = useMemo(() =&gt; {<br/>    return &lt;Child a={"Hello World"} /&gt;<br/>  }, [])</span><span id="2aa0" class="kv kw in kl b gy lx ky l kz la">return (<br/>    &lt;&gt;<br/>      &lt;div onClick={onClick}&gt;{count}&lt;/div&gt;<br/>      {child}<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="912e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们创建了一个新变量<code class="fe ki kj kk kl b">child</code>。它不是跳过道具的指定，而是跳过渲染的指定。</p><p id="675f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是<code class="fe ki kj kk kl b">{child}</code>？</p><p id="b576" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个道具，不。</p><p id="6b25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一种元素，是的。</p><p id="81a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">父<code class="fe ki kj kk kl b">&lt;&gt;</code>的一个<code class="fe ki kj kk kl b">children</code>道具里面的一个元素，是的。</p><p id="dacd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设<code class="fe ki kj kk kl b">&lt;&gt;</code>的<code class="fe ki kj kk kl b">children</code>是一个元素数组，第一个是<code class="fe ki kj kk kl b">div</code>，第二个是<code class="fe ki kj kk kl b">Child</code>。上面的代码使第二个元素在挂载后保持与渲染相同的引用。</p><figure class="kn ko kp kq gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mk"><img src="../Images/5a0171bb2a7d9fdebdc0c4298020730a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGVwzl6YwhR7X1_c50CLrg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Child bails out with useMemo</figcaption></figure><p id="bbb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你可以看到这个孩子做了紧急救助，由浅色阴影区域以及它下面的每一根纤维表示。可以修正孩子拿更多道具，让它更实用。</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="9f4a" class="kv kw in kl b gy kx ky l kz la">  const [d, ] = useState("Hello World")</span><span id="750e" class="kv kw in kl b gy lx ky l kz la">  const child = useMemo(() =&gt; {<br/>    return &lt;Child a={d} /&gt;<br/>  }, [d])</span></pre><p id="7513" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是这种方法的优点。我们能否救助一个孩子的控制权来自父母的决定。对于一个功能组件来说，一旦孩子开始渲染就为时已晚了，就像在<code class="fe ki kj kk kl b">React.memo</code>中一样。</p><h2 id="3d0e" class="kv kw in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">摘要</h2><p id="25ec" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe ki kj kk kl b">useMemo</code>一般情况下不能救助任何东西，它只能跳过赋值。因此，为了使用它跳过渲染，它需要应用于渲染元素而不是道具。</p><p id="fdaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">附录</strong></p><p id="a8f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">似乎可以根据依赖数组创建一个组件<code class="fe ki kj kk kl b">Memo</code>来模拟救助。<code class="fe ki kj kk kl b">Memo</code>是由<code class="fe ki kj kk kl b">React.memo</code>根据对<code class="fe ki kj kk kl b">useMemo</code>的理解做出的。</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="1b39" class="kv kw in kl b gy kx ky l kz la">const Memo = React.memo(({ children, value }) =&gt; {<br/>  return children<br/>}, (prev, next) =&gt; prev.value === next.value)</span></pre><p id="ab60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以这样使用它，</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="f968" class="kv kw in kl b gy kx ky l kz la">const Title = () =&gt; {<br/>  ...<br/>  return (<br/>    &lt;Memo value={a}&gt;<br/>      &lt;Child a={a} /&gt;<br/>    &lt;/Memo&gt;<br/>  )<br/>}</span></pre><p id="5905" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果<code class="fe ki kj kk kl b">a</code>改变，子渲染，否则将子保释出来。</p><figure class="kn ko kp kq gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ml"><img src="../Images/25f24105dd8a0ce63e0253e8571559bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xp00QdpGy9c8LLryud9JvQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Child bails out with Memo component</figcaption></figure><p id="e2cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有趣的是，依赖项内部的元素，比如<code class="fe ki kj kk kl b">a</code>，会出现多次。但这是可以理解的，因为一个是在父节点指定的，一个是子节点需要的。</p><h2 id="67dc" class="kv kw in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">记忆孩子</h2><p id="5090" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果这种方法有效，我们可以在更高阶的组件中将其一般化，以跳过对<code class="fe ki kj kk kl b">children</code>道具的任何更改，同时响应所有其他道具。</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="f007" class="kv kw in kl b gy kx ky l kz la">import { memo } from 'react'</span><span id="f38c" class="kv kw in kl b gy lx ky l kz la">const equalWithoutChildren = (prev, next) =&gt; {<br/>  for (let k in prev) {<br/>    if (k === 'children') continue<br/>    if (prev[k] !== next[k]) return false<br/>  }<br/>  return true<br/>}</span><span id="d284" class="kv kw in kl b gy lx ky l kz la">const memoChild = (Component) =&gt; {<br/>  const Memo = memo(({ children, ...props }) =&gt; {<br/>    return &lt;Component children={children} {...props} /&gt;<br/>  }, equalWithoutChildren)</span><span id="b501" class="kv kw in kl b gy lx ky l kz la">  return Memo<br/>}</span><span id="b8dd" class="kv kw in kl b gy lx ky l kz la">export default memoChild</span></pre><p id="1c59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那我们就可以用了。</p><pre class="kn ko kp kq gt kr kl ks kt aw ku bi"><span id="4aac" class="kv kw in kl b gy kx ky l kz la">const Child_ = memoChild(Child)</span><span id="00a7" class="kv kw in kl b gy lx ky l kz la">const Title = () =&gt; {<br/>  return (<br/>    &lt;Child_ a={a}&gt;<br/>      &lt;Others b={b} /&gt;<br/>    &lt;/Child_&gt;<br/>  )<br/>}</span></pre><p id="15c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在如果<code class="fe ki kj kk kl b">a</code>改变了，子组件得到一个渲染，独立于<code class="fe ki kj kk kl b">b</code>或其他。</p><p id="84ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mm">更多内容尽在</em><a class="ae km" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>