<html>
<head>
<title>Super-DRY React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超干反应组分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/super-dry-react-components-d27174003d78?source=collection_archive---------10-----------------------#2021-12-23">https://javascript.plainenglish.io/super-dry-react-components-d27174003d78?source=collection_archive---------10-----------------------#2021-12-23</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/99dbe85462df7b3f27fd9bde717b9fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x918xVSwK1G6mCsOemE4uw.png"/></div></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk">Super-dry out here, just like your code should be. Photo by the author.</figcaption></figure><div class=""/><div class=""><h2 id="d972" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">使用可组合包装器将横切关注点应用于功能性React组件</h2></div><p id="948f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">你有多少次发现自己编写了这样的组件:</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="b3e2" class="ma mb jg lw b gz mc md l me mf">const Item =&gt; ({ id, title, summary }) =&gt; id ? (<br/>  &lt;section&gt;<br/>    {title &amp;&amp; &lt;header&gt;<br/>      &lt;h1&gt;<br/>        &lt;a href={`/items/${id}`}&gt;{title}&lt;/a&gt;<br/>      &lt;/h1&gt;<br/>    &lt;/header&gt;}<br/>    &lt;p&gt;{summary}&lt;/p&gt;<br/>  &lt;/section&gt;<br/>) : null</span></pre><p id="dd90" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">在渲染之前检查<code class="fe mg mh mi lw b">prop</code>的存在。</p><p id="bf71" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">如果只有几个组件，这没什么，但是在更大的项目中，这就成了一个负担。</p><p id="36f7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">您可以使用<code class="fe mg mh mi lw b">wrapper</code>功能轻松擦干。</p><h1 id="476d" class="mj mb jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">封装器</h1><p id="762f" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ik bi translated">让我们重写<code class="fe mg mh mi lw b">Item</code>组件，使用一个我们称之为<code class="fe mg mh mi lw b">hasId</code>的<code class="fe mg mh mi lw b">wrapper</code>，它拦截对<code class="fe mg mh mi lw b">Item</code>的调用，并插入一些公共逻辑。</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="9124" class="ma mb jg lw b gz mc md l me mf">const hasId = Component =&gt;<br/>  props =&gt; props.id<br/>    ? &lt;Component {...props} /&gt;<br/>    : null</span></pre><p id="9c60" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">现在<code class="fe mg mh mi lw b">Item</code>可以简化为</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="c6be" class="ma mb jg lw b gz mc md l me mf">import { hasId } from 'wrappers' // wherever you put them</span><span id="5afa" class="ma mb jg lw b gz nf md l me mf">const Item =&gt; ({ id, title, summary }) =&gt; (<br/>  &lt;section&gt;<br/>    {title &amp;&amp; &lt;header&gt;<br/>      &lt;h2&gt;<br/>        &lt;a href={`/items/${id}`}&gt;{title}&lt;/a&gt;<br/>      &lt;/h2&gt;<br/>    &lt;/header&gt;}<br/>    &lt;p&gt;{summary}&lt;/p&gt;<br/>  &lt;/section&gt;<br/>)</span><span id="a3e9" class="ma mb jg lw b gz nf md l me mf">export default hasId(Item)</span></pre><p id="0c27" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">这对于单个组件来说有点过分了，但是如果你想对许多不同的组件应用相同的<code class="fe mg mh mi lw b">id</code>检查，这就太棒了。</p><p id="74b8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">让我们重写一些<code class="fe mg mh mi lw b">Item</code>来清理<code class="fe mg mh mi lw b">header</code>。</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="8fb2" class="ma mb jg lw b gz mc md l me mf">const Header = ({ id, title }) =&gt; (<br/>  &lt;header&gt;<br/>    &lt;h2&gt;<br/>      &lt;a href={`/items/${id}`}&gt;{title}&lt;/a&gt;<br/>    &lt;/h2&gt;<br/>  &lt;/header&gt;<br/>)</span></pre><p id="8da8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">我们知道<code class="fe mg mh mi lw b">id</code>将一直存在，因为<code class="fe mg mh mi lw b">Header</code>被设计用于<code class="fe mg mh mi lw b">Item</code>内部，但作为一个独立的组件，我们不能保证这一点。</p><p id="2e86" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">同样，我们需要检查<code class="fe mg mh mi lw b">title</code>是否存在。我们可以让我们的<code class="fe mg mh mi lw b">hasId</code>包装器更加灵活。</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="4acc" class="ma mb jg lw b gz mc md l me mf">const hasProp = name<br/>  =&gt; Component<br/>    =&gt; props<br/>      =&gt; props[name] <br/>        ? &lt;Component {...props} /&gt;<br/>        : null</span></pre><p id="8385" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">所以现在我们可以在导出之前<em class="ng">包装</em>我们的<code class="fe mg mh mi lw b">Header</code>:</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="79c9" class="ma mb jg lw b gz mc md l me mf">export default hasProp('title')(Header)</span></pre><p id="1ea6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">并重写了<code class="fe mg mh mi lw b">Item</code>:</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="8a57" class="ma mb jg lw b gz mc md l me mf">import { hasProp } from 'wrappers'</span><span id="9968" class="ma mb jg lw b gz nf md l me mf">const Item =&gt; ({ id, title, summary }) =&gt; (<br/>  &lt;section&gt;<br/>    &lt;Header id={id} title={title} /&gt;<br/>    &lt;p&gt;{summary}&lt;/p&gt;<br/>  &lt;/section&gt;<br/>)</span><span id="cd41" class="ma mb jg lw b gz nf md l me mf">export default hasProp('id')(Item)</span></pre><p id="97d8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">假设我们希望<code class="fe mg mh mi lw b">Header</code>超级安全，所以如果没有<code class="fe mg mh mi lw b">id</code>或<code class="fe mg mh mi lw b">title</code>就根本不用渲染。使用一个接受一个<code class="fe mg mh mi lw b">names</code>数组的<code class="fe mg mh mi lw b">hasProps</code>包装器。</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="66ff" class="ma mb jg lw b gz mc md l me mf">const hasProps = (...names)<br/>  =&gt; Component<br/>    =&gt; props<br/>      =&gt; !names.find(n =&gt; !props[n])<br/>        ? &lt;Component {...props} /&gt;<br/>        : null</span></pre><p id="e1cf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">然后</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="bb47" class="ma mb jg lw b gz mc md l me mf">export default hasProps('id', 'title')(Header)</span></pre><p id="25fd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">如果道具的数量很少，这没问题，并且您应用的包装器只是简单地检查是否定义了一个<code class="fe mg mh mi lw b">prop</code>。很快您就会想要一种简单的方法来使用任意包装器的整个列表。这就是函数组合派上用场的地方。以下是更多相关信息。</p><h1 id="3df4" class="mj mb jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">这不是高阶元件，而是功能性反应元件吗？</h1><p id="125d" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ik bi translated">绝对是的。HOCs作为一种将功能组合到基于类的React组件上的干净方式出现，但是当功能组件和钩子流行起来后就不再受欢迎了。但是尽管<a class="ae nh" href="https://itnext.io/hooked-on-react-10affe4cca3c" rel="noopener ugc nofollow" target="_blank">钩子在巩固逻辑方面很棒</a>，以一种基于类的组件永远无法做到的方式，它们仍然不需要一种方法来组合横切行为。</p><p id="1d2a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">我描述的包装器比以前的hoc简单了几个数量级。而包装器，因为它们返回组件，甚至可以自己使用钩子。</p><h1 id="ef08" class="mj mb jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">带挂钩的包装纸</h1><p id="e66e" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ik bi translated">下面的模式并不少见，其中的文件夹结构如下:</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="6242" class="ma mb jg lw b gz mc md l me mf">components/<br/>  Hero/<br/>    index.js<br/>    Hero.js</span></pre><p id="913b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">其中<code class="fe mg mh mi lw b">index.js</code>是:</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="5232" class="ma mb jg lw b gz mc md l me mf">import { usePreloader } from ‘features/heroes/hooks’<br/>import PureHero from './Hero'</span><span id="e0ee" class="ma mb jg lw b gz nf md l me mf">const Hero = ({ id }) =&gt; (<br/>  &lt;PureHero {...usePreloader(id)} /&gt;<br/>)</span></pre><p id="d02e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">其中<code class="fe mg mh mi lw b">usePreloader</code>返回一个对象，如</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="c717" class="ma mb jg lw b gz mc md l me mf">{<br/>  isLoading,<br/>  error,<br/>  ...heroData<br/>}</span></pre><p id="0089" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">要支持这种模式，请编写如下包装器:</p><p id="36fe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated"><code class="fe mg mh mi lw b">withPreloader</code>，</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="4b68" class="ma mb jg lw b gz mc md l me mf">import { usePreloader } from ‘hooks’</span><span id="876a" class="ma mb jg lw b gz nf md l me mf">const withPreloader = Component<br/>  =&gt; ({ id })<br/>    =&gt; &lt;Component {...usePreloader(id)} /&gt;</span></pre><p id="c38b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated"><code class="fe mg mh mi lw b">withLoading</code>，</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="053a" class="ma mb jg lw b gz mc md l me mf">const withLoading = Component<br/>  =&gt; ({ isLoading, ...props }) =&gt; isLoading<br/>    ? &lt;Loading /&gt;<br/>    : &lt;Component {...props} /&gt;</span></pre><p id="1d9c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">还有<code class="fe mg mh mi lw b">withError</code></p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="f6eb" class="ma mb jg lw b gz mc md l me mf">const withError = Component<br/>  =&gt; ({ error, ...props }) =&gt; error<br/>    ? &lt;Error error={error} /&gt;<br/>    : &lt;Component {...props} /&gt;</span></pre><p id="0f30" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">现在我们只需要一种简单的方法来用所有这些包装器包装<code class="fe mg mh mi lw b">Hero.js</code>的内容。</p><h1 id="ca3d" class="mj mb jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">构成包装</h1><p id="aefa" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ik bi translated">函数编辑器只是一个函数，它接受一组函数，并使用前面的函数作为输入，依次运行它们。</p><p id="06c9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">因此，给定函数<code class="fe mg mh mi lw b">a</code>和<code class="fe mg mh mi lw b">b</code>，两者都接受<code class="fe mg mh mi lw b">c</code>作为参数，并返回<code class="fe mg mh mi lw b">c</code>的修改版本，那么<code class="fe mg mh mi lw b">compose(a, b)(c)</code>与运行<code class="fe mg mh mi lw b">a(b(c))</code>相同。</p><p id="529c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">因为React组件只是函数，而包装器只是接受和返回React组件的函数，所以您可以编写一个简单的composer，如下所示:</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="f9d5" class="ma mb jg lw b gz mc md l me mf">const compose = (...wrappers) =&gt;<br/>  Component =&gt; wrappers.<em class="ng">reduceRight</em>(<br/>    (acc, wrapper) =&gt; wrapper(acc),<br/>    Component<br/>  )</span></pre><p id="8df1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">或者，如果您正在使用<a class="ae nh" href="https://redux.js.org/api/compose/" rel="noopener ugc nofollow" target="_blank"> Redux </a>，您可以:</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="2c00" class="ma mb jg lw b gz mc md l me mf">import { compose } from 'redux'</span></pre><p id="2358" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">它做了几乎相同的事情，但有一些可爱的优化。</p><p id="a8c7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">使用<code class="fe mg mh mi lw b">compose</code>功能，<code class="fe mg mh mi lw b">Hero</code>可以简单地导出为:</p><pre class="lr ls lt lu gu lv lw lx ly aw lz bi"><span id="f66f" class="ma mb jg lw b gz mc md l me mf">export default compose(<br/>  withPreloader,<br/>  withLoading,<br/>  withError<br/>)(Hero)</span></pre><p id="bd78" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">首先<code class="fe mg mh mi lw b">Hero</code>将尝试加载数据，然后它将在加载时显示一个<code class="fe mg mh mi lw b">Loading</code>组件，如果有错误，它将显示一个<code class="fe mg mh mi lw b">Error</code>。否则，您将获得包含所有数据的<code class="fe mg mh mi lw b">Hero</code>组件。强大的是，你的核心<code class="fe mg mh mi lw b">Hero</code>组件很有可能变成一个可记忆的纯组件，它被所需的逻辑所包裹，使其成为一个自我管理的组件。两全其美！</p><p id="f8a8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">这种组合可重用逻辑块的能力极大地简化了核心组件，使它们更容易推理和测试。</p><h1 id="93a2" class="mj mb jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">结论</h1><p id="2508" class="pw-post-body-paragraph kv kw jg kx b ky na kh la lb nb kk ld le nc lg lh li nd lk ll lm ne lo lp lq ik bi translated">当您的组件有许多横切关注点时，您可以通过使用包装器函数来处理这些关注点，从而简化每个单独的组件。简单的包装器函数可以组合成更复杂的包装器，以提供可重用的行为。</p><p id="2c4e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">我倾向于使用的常见包装器包括</p><ul class=""><li id="47a4" class="ni nj jg kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><code class="fe mg mh mi lw b">hasProp(name, shape)</code> —如果缺少命名的<code class="fe mg mh mi lw b">prop</code>，则返回<code class="fe mg mh mi lw b">null</code>，</li><li id="198e" class="ni nj jg kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><code class="fe mg mh mi lw b">arrayNotEmpty(name, shape, message)</code> —如果命名数组为空，则返回一个带有<code class="fe mg mh mi lw b">message</code>的<code class="fe mg mh mi lw b">Empty</code>组件，如果没有<code class="fe mg mh mi lw b">message</code>，则返回<code class="fe mg mh mi lw b">null</code>，</li><li id="c79b" class="ni nj jg kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><code class="fe mg mh mi lw b">withLoading(isScene)</code> —返回一个<code class="fe mg mh mi lw b">Loading</code>组件(或者是一个<em class="ng">场景</em>关卡或者是<em class="ng">组件</em>关卡加载器，取决于<code class="fe mg mh mi lw b">isScene</code>)</li><li id="6fd4" class="ni nj jg kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><code class="fe mg mh mi lw b">withError(message, retry, retryLabel)</code> —返回一个带有可选<code class="fe mg mh mi lw b">retry</code>功能的<code class="fe mg mh mi lw b">Error</code>组件(如果有一个<code class="fe mg mh mi lw b">retry</code>功能，它会显示一个重试按钮)</li><li id="5099" class="ni nj jg kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><code class="fe mg mh mi lw b">withPreloader(hook)</code> —使用提供的钩子作为<code class="fe mg mh mi lw b">usePreloader</code>来预载一些数据</li></ul><p id="2a08" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">其中大多数不到5行，易于隔离测试。</p><h1 id="090b" class="mj mb jg bd mk ml mm mn mo mp mq mr ms km mt kn mu kp mv kq mw ks mx kt my mz bi translated">链接</h1><ul class=""><li id="fc4a" class="ni nj jg kx b ky na lb nb le nw li nx lm ny lq nn no np nq bi translated"><a class="ae nh" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/higher-order-components.html</a></li><li id="a75f" class="ni nj jg kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae nh" href="https://itnext.io/hooked-on-react-10affe4cca3c" rel="noopener ugc nofollow" target="_blank">https://itnext.io/hooked-on-react-10affe4cca3c</a></li><li id="38ff" class="ni nj jg kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae nh" href="https://redux.js.org/api/compose/" rel="noopener ugc nofollow" target="_blank">https://redux.js.org/api/compose/</a></li><li id="1658" class="ni nj jg kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><a class="ae nh" href="https://itnext.io/tame-large-react-projects-by-consistently-applying-these-patterns-and-rules-b7c70baf5105" rel="noopener ugc nofollow" target="_blank">https://it next . io/tame-large-react-projects-by-consistently-applying-these-patterns-and-rules-b7c 70 BAF 5105</a></li></ul><p id="c328" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi">—</p><p id="2a75" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated">像这样但不是订户？您可以通过davesag.medium.com<a class="ae nh" href="https://davesag.medium.com/membership" rel="noopener">加入来支持作者。</a></p><p id="a23c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ik bi translated"><em class="ng">更多内容请看</em><a class="ae nh" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ng">plain English . io</em></a><em class="ng">。报名参加我们的</em> <a class="ae nh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ng">免费周报</em> </a> <em class="ng">。在我们的</em> <a class="ae nh" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="ng">社区获得独家写作机会和建议</em> </a> <em class="ng">。</em></p></div></div>    
</body>
</html>