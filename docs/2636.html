<html>
<head>
<title>A Simple Counter App to Learn React Hooks and React-Redux Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个简单的计数器应用程序，学习React钩子和React-Redux钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-simple-counter-app-to-learn-react-hooks-and-react-redux-hooks-4fc4f4fb4f40?source=collection_archive---------5-----------------------#2021-05-31">https://javascript.plainenglish.io/a-simple-counter-app-to-learn-react-hooks-and-react-redux-hooks-4fc4f4fb4f40?source=collection_archive---------5-----------------------#2021-05-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/44ec7371c3ac0736b0c02ce4d31e4bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*vCIa18Iomsxpcd1eNQUaMQ.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">React &amp; Redux… and Hooks!</figcaption></figure><p id="0f62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">人们说<strong class="jx io"> <em class="kt">钩子</em> </strong>是反应过来的未来，我同意！它们简单、干净、轻便。在这篇博客中，我将简要介绍它们与以前创建React组件的方式有何不同。此外，我还将展示几个React-Redux挂钩，它们将帮助许多程序员有效地清理他们的代码。</p><p id="57c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将制作一个简单的反作用应用程序，所以请一起编码。首先，让我们使用下一行代码创建一个React应用程序:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="2d62" class="ld le in kz b gy lf lg l lh li">npx create-react-app counter-with-hooks</span></pre><p id="f4b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且，抓紧了，因为冒险可能会有点长！！！</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/e88bd7f5754cf90d37994a1f2482bc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*OZMdBxycflxunt0PhPEIYA.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Our Expectation~^^~</figcaption></figure><h1 id="a7ac" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">1.反应没有钩子，没有冗余</h1><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/cc776ff71a3903b85d9eb03db31bf8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*9R7bHgrODKqN6bKlyBRafQ.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">index.js, App.js &amp; some basic components + one css file</figcaption></figure><p id="a374" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要做的第一件事是用简单的经典React创建计数器应用程序，没有钩子和Redux！为此，我们将准备一些具有上述文件夹结构的文件。我们的<code class="fe mi mj mk kz b">App.js</code>文件将如下所示:</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="00d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它调用<code class="fe mi mj mk kz b">ReactDOM.render</code>方法，将<code class="fe mi mj mk kz b">&lt;App /&gt;</code>组件作为第一个参数，将<code class="fe mi mj mk kz b">document.getElementById('root')</code>作为第二个参数。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">1 constructor, 3 event handlers, and 1 render method</figcaption></figure><p id="2f37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">App</code>组件用一个<code class="fe mi mj mk kz b">css</code>文件导入2个子组件(<code class="fe mi mj mk kz b">Counter.js</code> &amp; <code class="fe mi mj mk kz b">Reset.js</code>)。在其<code class="fe mi mj mk kz b">constructor</code>中，有一个<code class="fe mi mj mk kz b">count</code>的<code class="fe mi mj mk kz b">state</code>，设置为初始值<code class="fe mi mj mk kz b">0</code>。</p><p id="462f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">Counter.js</code>将负责显示计数并控制计数。于是，它将1个显示属性(<code class="fe mi mj mk kz b">count</code>)和2个控制方法(<code class="fe mi mj mk kz b">handleMinusBtnClick</code> &amp; <code class="fe mi mj mk kz b">handlePlusBtnClick</code>)作为道具传了下来。每种方法都会将count的状态值增加或减少1。</p><p id="bc20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">Reset.js</code>将计数器复位到0。在click事件中，它将调用一个名为<code class="fe mi mj mk kz b">handleResetBtnClick</code>的方法，使用<code class="fe mi mj mk kz b">setState</code>方法将count的应用状态值更改为0。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e3b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">Counter.js</code>文件显示计数器的当前值，并将控制功能委托给其子组件<code class="fe mi mj mk kz b">Controllers.js</code>。在<code class="fe mi mj mk kz b">h1</code>标签中，显示了<code class="fe mi mj mk kz b">count</code>道具，双手道具方法将作为道具再次传递给子组件<code class="fe mi mj mk kz b">Controllers</code>。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a79c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">Controllers.js</code>文件有两个按钮:一个用于减少计数器值，另一个用于增加计数器值。当一个特定的点击事件发生时，这两个传下来的正确方法将被调用。因此，这些正确的方法将改变<code class="fe mi mj mk kz b">App.js</code>文件中的计数状态值。并且，该状态改变将导致计数器重新呈现为减小/增大的值。</p><p id="36b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">handleBtnClick</code>此文件的方法使用<strong class="jx io"> <em class="kt">计算属性名称</em> </strong>来为每种情况调用正确的方法。为此，每个按钮都有一个<code class="fe mi mj mk kz b">name</code>属性。<code class="fe mi mj mk kz b">e.target.name</code>将化为方法名并完成其预期功能。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e7a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">Reset.js</code>文件控制应用的复位功能。它从其父组件(<code class="fe mi mj mk kz b">App.js</code>)采用<code class="fe mi mj mk kz b">handleResetBtnClick</code>方法。点击，该方法会将<code class="fe mi mj mk kz b">App.js</code>中的<code class="fe mi mj mk kz b">count</code>状态更改回0，如果不是。</p><p id="8a6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仅供参考，所有<code class="fe mi mj mk kz b">className</code>和<code class="fe mi mj mk kz b">id</code>属性都已分配给简单的<code class="fe mi mj mk kz b">css</code>化妆。你可以在我的报告中找到链接在本文末尾的<code class="fe mi mj mk kz b">css</code>文件。</p><h1 id="0397" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2.与钩子反应，无需Redux</h1><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/6f70bf5f80577c0ea897c5847653754e.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*ew_R_JoYFl2CLhtddTXEwQ.png"/></div></figure><p id="8418" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您可能注意到的，到目前为止，我们只使用了类组件。在第二阶段，我们将使用React钩子将所有这些类组件转换成功能组件。下面是将3个无状态类组件转换成功能性组件的一些变化:</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a770" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">变化并不是很困难。只需注意，在功能组件中，不需要使用<code class="fe mi mj mk kz b">render</code>方法。<code class="fe mi mj mk kz b">props</code>也是作为论据传下来的，所以我们做<strong class="jx io"> <em class="kt">不是</em> </strong>把它们当作<code class="fe mi mj mk kz b">this.props</code>，而是当作<code class="fe mi mj mk kz b">props</code>。最后一点，我们不再需要从React导入<code class="fe mi mj mk kz b">Component</code>。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="dce0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们在这里遇到我们的第一个反应钩:<strong class="jx io"> <em class="kt">状态钩</em> </strong>。众所周知，功能组件没有构造函数，因此我们无法设置<code class="fe mi mj mk kz b">state</code>，这对于我们跟踪数据来说是一个很大的问题。但是，通过使用<code class="fe mi mj mk kz b">useState()</code>，现在我们可以在功能组件中跟踪我们的数据。</p><p id="acb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">怎么用？首先，我们从React库中导入它，并将其返回值指定为2个变量。<code class="fe mi mj mk kz b">useState()</code>方法返回一个包含2个元素的数组:初始值及其设置(=写入)方法。人们通常使用ES6析构语法来分配它们(见第5行)。值和方法的命名取决于您，这意味着您可以随意命名它们。但是，按照惯例，该方法的名称是<code class="fe mi mj mk kz b">set<strong class="jx io"><em class="kt">YourVriable</em></strong></code>。(这里，状态变量被命名为<code class="fe mi mj mk kz b">count</code>，设置器被命名为<code class="fe mi mj mk kz b">setCount</code>)。</p><p id="df5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你认可，有一个新的文件导入:<code class="fe mi mj mk kz b">ClickedTime.js</code>。添加这个文件是为了展示React钩子的另一个例子:<strong class="jx io"> <em class="kt">效果钩子</em> </strong>。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e9a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该组件的作用是显示最后点击的日期和时间，可以是计数器<strong class="jx io"> <em class="kt">组件第一次挂载</em> </strong>的初始时间，也可以是<strong class="jx io"> <em class="kt">组件通过点击更新</em> </strong>的时间。对于React类组件，这些功能分别由React生命周期方法执行，如<code class="fe mi mj mk kz b">componentDidMount</code>和<code class="fe mi mj mk kz b">componentDidUpdate</code>。不过，对于功能组件，这些可以通过使用名为<code class="fe mi mj mk kz b">useEffect()</code>的钩子来完成。</p><p id="b817" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，我们首先从React库中导入这个钩子，并把它作为一个方法放在功能组件中。然后，每当组件被(重新)渲染时，它将完成指定的工作。第7行和第8行以随机的十六进制格式设置组件的颜色。而且，每当计数器改变时，就会触发这种颜色变化。状态更改和组件重新呈现。多么好用，多么干净的代码，多么好看~</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/e5600cee6b38018d2f2eec0ea039d139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9O04x2CKZ0VRXJtk6RIFg.png"/></div></div></figure><h1 id="2e9b" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">3.用钩子反应，用Redux</h1><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/958eac425a1c2d401088d42efa17e13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*OpqJhv-_xpSWO5p2uajTrg.png"/></div></figure><p id="2883" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是时候将我们的React应用程序链接到Redux了！首先，让我们为两个新包运行<code class="fe mi mj mk kz b">npm install</code>，一个用于Redux本身，另一个用于React-Redux连接:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="79af" class="ld le in kz b gy lf lg l lh li">npm install redux react-redux --save</span></pre><p id="0630" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，要使用Redux全局存储，我们必须创建它，通常在<code class="fe mi mj mk kz b">index.js</code>文件中:</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="266d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为Redux只有<code class="fe mi mj mk kz b">state</code>的一个全局<code class="fe mi mj mk kz b">store</code>，所以当组件或其父组件被<code class="fe mi mj mk kz b">Provider</code>(一个reactor-Redux类)包装并赋予<code class="fe mi mj mk kz b">store</code>道具时，通过<code class="fe mi mj mk kz b">createStore()</code>方法新创建的<code class="fe mi mj mk kz b">store</code>将可以从任何需要特定数据信息的组件中访问。在我们的案例中，<code class="fe mi mj mk kz b">App</code>组件及其所有子组件都可以访问这个Redux全局<code class="fe mi mj mk kz b">store</code>。</p><p id="dd21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了处理与<code class="fe mi mj mk kz b">store</code>相关的事件(无论是<code class="fe mi mj mk kz b">onClick</code>或<code class="fe mi mj mk kz b">onSubmit</code>或任何其他事件)，该<code class="fe mi mj mk kz b">store</code>与处理事件的<code class="fe mi mj mk kz b">reducer</code>相连(在我们的例子中为<code class="fe mi mj mk kz b">click</code> s)。在谈论这款减压器之前，我想先介绍一下更加干净的<code class="fe mi mj mk kz b">App.js</code>，因为它不用再把任何<code class="fe mi mj mk kz b">props</code>传给它的孩子了。每一个都能分别接近<code class="fe mi mj mk kz b">store</code>。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="fb73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看<code class="fe mi mj mk kz b">App</code>的子组件是如何处理它们访问Redux <code class="fe mi mj mk kz b">store</code>的需求的。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="52bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是使用Redux <code class="fe mi mj mk kz b">store</code>对<code class="fe mi mj mk kz b">Counter.js</code>进行的修改部分。你能说出发生了什么变化吗？我们首先要认识到的是<code class="fe mi mj mk kz b">import</code>正在使用一种叫做<code class="fe mi mj mk kz b">connect</code>的反应还原法。<strong class="jx io">此法字面意思为<em class="kt">连接</em> </strong> s a <strong class="jx io"> <em class="kt">反应成分</em> </strong>至<strong class="jx io"> <em class="kt"> Redux store </em> </strong>。</p><p id="725d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第19行，利用自定义方法返回的对象参数调用<code class="fe mi mj mk kz b">connect</code>方法，访问<code class="fe mi mj mk kz b">state</code>的全局<code class="fe mi mj mk kz b">store</code>，并返回另一个新函数，以<code class="fe mi mj mk kz b">Counter</code>组件作为参数。最终，这将返回<code class="fe mi mj mk kz b">export</code>一个可以访问<code class="fe mi mj mk kz b">store</code>的升级的<code class="fe mi mj mk kz b">Counter</code>组件。</p><p id="272c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要使用全局<code class="fe mi mj mk kz b">state</code>，这个功能组件<code class="fe mi mj mk kz b">Counter</code>必须带<code class="fe mi mj mk kz b">props</code>参数(名称可以自己选择，虽然<code class="fe mi mj mk kz b">props</code>是约定)，它可以被<code class="fe mi mj mk kz b">props.<strong class="jx io"><em class="kt">propName</em></strong></code>使用(我们这里是<code class="fe mi mj mk kz b">props.count</code>)。</p><p id="e3f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们可以看到<code class="fe mi mj mk kz b">Counter</code>有它的孩子<code class="fe mi mj mk kz b">Controllers</code>，没有传递任何道具，因为<code class="fe mi mj mk kz b">Controllers</code>组件现在有它自己的对<code class="fe mi mj mk kz b">store</code>的访问。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6c84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">Controllers</code>组件有<code class="fe mi mj mk kz b">store</code>的2个用例。当它监听来自按钮的增加/减少事件时，它需要帮助。以前，帮助是作为来自其父组件<code class="fe mi mj mk kz b">Counter</code>的两个prop方法给出的，并且它自己的<code class="fe mi mj mk kz b">handleBtnClick</code>方法相应地处理每个事件。</p><p id="7526" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是现在没有从父组件传递任何<code class="fe mi mj mk kz b">props</code>。更确切地说，这些按钮是<code class="fe mi mj mk kz b">connect</code> ed到Redux <code class="fe mi mj mk kz b">dispatch</code>函数，该函数接受动作创建者(<code class="fe mi mj mk kz b">decreaseCount</code> &amp; <code class="fe mi mj mk kz b">increaseCount</code>)到<code class="fe mi mj mk kz b">handleBtnClick</code>的返回值。当一个<code class="fe mi mj mk kz b">dispatch</code>方法以动作对象作为参数被调用时，它调用<code class="fe mi mj mk kz b">reducer</code>文件，根据它的动作类型，存储<code class="fe mi mj mk kz b">state</code>被更新，相关组件被重新呈现。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3dfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，这个reducer文件(<code class="fe mi mj mk kz b">actions/index.js</code>)也处理来自<code class="fe mi mj mk kz b">Reset</code>组件的<code class="fe mi mj mk kz b">count</code>复位事件。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9315" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当点击按钮时，<code class="fe mi mj mk kz b">Reset</code>组件也被<code class="fe mi mj mk kz b">connect</code>固定到减速器上，与<code class="fe mi mj mk kz b">RESET_COUNT</code>外壳配合。这一次，因为<code class="fe mi mj mk kz b">resetCount</code> action creator是使用ES6析构语法作为对象直接传入的，<code class="fe mi mj mk kz b">dispatch</code>方法没有明显地出现，而是使用Redux magic在幕后工作(注意，使用<code class="fe mi mj mk kz b">mapDispatchToProps</code>【如在<code class="fe mi mj mk kz b">Controllers</code>组件中】和直接传递action creator的对象返回值【如在<code class="fe mi mj mk kz b">Reset</code>组件中】工作方式完全相同)。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d504" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为<code class="fe mi mj mk kz b">ClickedTime</code>组件用<code class="fe mi mj mk kz b">count</code>状态响应，所以它也需要用<code class="fe mi mj mk kz b">store</code>响应<code class="fe mi mj mk kz b">connect</code>。并且，<code class="fe mi mj mk kz b">useEffect()</code>钩子的第二个参数作为一个数组给出，只在呈现的状态改变时触发这个方法<em class="kt">(换句话说，只有当商店的<code class="fe mi mj mk kz b">count</code>状态更新时，点击时间的颜色才会发生变化)。</em></p><h1 id="f68d" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">4.用钩子反应，用Redux &amp; React-Redux钩子</h1><p id="639c" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">React-Redux也有自己的钩子。在这最后的阶段，我想分享如何使用其中的一些。它们以更清晰的方式链接React和Redux。这里主要是使用<code class="fe mi mj mk kz b">connect</code>方法的组件将被重构。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e501" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是<code class="fe mi mj mk kz b">ClickedTime.js</code>文件的最终版本，使用了一个<strong class="jx io"> <em class="kt"> React钩子</em> </strong>和一个<strong class="jx io"> <em class="kt"> React-Redux钩子</em> </strong>。正如我们所看到的，没有其他的方法了。相反，我们正在使用一个名为<code class="fe mi mj mk kz b">useSelector()</code>的React-Redux钩子。</p><p id="fb62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第7行是如何使用这个钩子。在我们的回调函数(<code class="fe mi mj mk kz b">state =&gt; state.count</code>)中，我们从<code class="fe mi mj mk kz b">store</code>返回<code class="fe mi mj mk kz b">count</code>状态，并将其赋给一个名为<code class="fe mi mj mk kz b">count</code>的变量，然后将其作为普通变量使用。简单！并且，我们不使用<code class="fe mi mj mk kz b">connect</code>创建和<code class="fe mi mj mk kz b">export</code>新组件。我们只是<code class="fe mi mj mk kz b">export</code>这个简单正常的<code class="fe mi mj mk kz b">ClickedTime</code>组件。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ab26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组件的最终版本也使用了与T2组件相同的方法。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0312" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe mi mj mk kz b">Controllers</code>组件的最终版本中，我们可以找到另一种React-Redux钩子:<code class="fe mi mj mk kz b">useDispatch()</code>。我们首先从<code class="fe mi mj mk kz b">react-redux</code>库中<code class="fe mi mj mk kz b">import</code>这个方法。然后，方法的调用值被赋给一个变量(这里是<code class="fe mi mj mk kz b">dispatch</code>，但是名字并不重要)。</p><p id="5fcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当事件需要真正的<code class="fe mi mj mk kz b">dispatch</code> ing(在我们的例子中是<code class="fe mi mj mk kz b">onClick</code>)时，它成为回调箭头函数的返回值，通过action creator result的参数调用(即<code class="fe mi mj mk kz b">dispatch(decreaseCount(count))</code> / <code class="fe mi mj mk kz b">dispatch(increaseCount(count))</code>)。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="bc2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mi mj mk kz b">Reset</code>组件的最终版本也使用<code class="fe mi mj mk kz b">useDispatch()</code>，其使用方式与<code class="fe mi mj mk kz b">Controllers</code>组件相同。其他文件(<code class="fe mi mj mk kz b">index.js</code>、<code class="fe mi mj mk kz b">App.js</code>、动作创建者<code class="fe mi mj mk kz b">index.js</code>、缩减者<code class="fe mi mj mk kz b">index.js</code>等)保持不变。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="3607" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React很牛逼，Redux也有很多粉丝。钩子的引入是为了帮助程序员享受更干净、更简单的代码。</p><p id="2c1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我试图展示如何根据我们现有的反应知识来理解这些。我强烈建议你熟悉这些相对较新的技能，因为它们在很多方面都很有帮助。这个小项目的全部最终代码，请访问<a class="ae ng" href="https://github.com/jinook929/counter-wit-hooks" rel="noopener ugc nofollow" target="_blank">我的回购</a>。</p><p id="417a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开心编码~</p><p id="38f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容请看</em><a class="ae ng" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kt">plain English . io</em></a></p></div></div>    
</body>
</html>