<html>
<head>
<title>How to Convert a React App to Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将React应用转换为Vue.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/convert-a-react-app-to-vue-js-4b69ea503fed?source=collection_archive---------9-----------------------#2021-03-16">https://javascript.plainenglish.io/convert-a-react-app-to-vue-js-4b69ea503fed?source=collection_archive---------9-----------------------#2021-03-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4fff" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:概述</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/71492f2804e8d18669e381c2ac73ee24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrjVCrlD-y0iKcXtBvIOoA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Vue &amp; React logos NOT fighting each other</figcaption></figure><ol class=""><li id="6750" class="ks kt in ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">介绍</li><li id="76d4" class="ks kt in ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">基本概述</li><li id="d46d" class="ks kt in ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">单列组件</li></ol><h1 id="e2af" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">介绍</h1><p id="dd7f" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">我最近参加了一家公司的面试，这家公司几乎完全用VueJS构建他们的前端应用程序。来自一个主要是普通的JavaScript和React背景，自然我非常好奇。让我未来的老板建议:</p><blockquote class="mx my mz"><p id="8982" class="mh mi na ku b kv kw jo mk kx ky jr mm nb nc mo mp nd ne mr ms nf ng mu mv lf ig bi translated">“你应该调查Vue——这不是一项任务或任何事情。”</p><p id="8a20" class="mh mi na ku b kv kw jo mk kx ky jr mm nb nc mo mp nd ne mr ms nf ng mu mv lf ig bi translated">—也许是未来的老板</p></blockquote><p id="6a99" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">这是一个很好的借口去深入<a class="ae mw" href="https://vuejs.org/v2/guide/" rel="noopener ugc nofollow" target="_blank">文档</a>，查看一些我<a class="ae mw" href="https://youtu.be/Wy9q22isx3U?t=39" rel="noopener ugc nofollow" target="_blank">最喜欢的教程制作人</a>，并构建我自己的<a class="ae mw" href="https://github.com/d-otis/rate-your-landlord-vue" rel="noopener ugc nofollow" target="_blank">前端Vue应用</a>。与其尝试重新发明轮子，陷入全新领域和后端API的困境，我决定采用我为你的房东(<em class="na"> RYL </em> )  app之前用React表达的<strong class="ku io"> Rate创建的现有Ruby on Rails API。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/e2d866065b6a9bfc50da2b00626f9e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32NAP8ZdV9shPfhmMTDDZg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screencap of React front end hosted on Heroku</figcaption></figure><p id="4715" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">通过这种方式，我可以真正专注于前端，并使用我为React前端制作的现有解决方案，让这些解决方案为我的Vue实施之旅增添色彩。也就是说，我不会谈论我的API实现的细节，但你可以在下面的链接中搜索我的源代码。</p><p id="bf19" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">这是目前正在进行的工作，但这里有一些链接:</p><ul class=""><li id="7e01" class="ks kt in ku b kv kw kx ky kz la lb lc ld le lf ni lh li lj bi translated"><a class="ae mw" href="https://www.github.com/d-otis/rate-your-landlord-backend" rel="noopener ugc nofollow" target="_blank">GitHub上的Ruby on Rails API</a></li><li id="971a" class="ks kt in ku b kv lk kx ll kz lm lb ln ld lo lf ni lh li lj bi translated"><a class="ae mw" href="https://github.com/d-otis/rate-your-landlord-react-frontend" rel="noopener ugc nofollow" target="_blank">在GitHub上反应前端</a></li><li id="793c" class="ks kt in ku b kv lk kx ll kz lm lb ln ld lo lf ni lh li lj bi translated"><a class="ae mw" href="https://github.com/d-otis/rate-your-landlord-vue" rel="noopener ugc nofollow" target="_blank">GitHub上的Vue前端</a></li><li id="a9de" class="ks kt in ku b kv lk kx ll kz lm lb ln ld lo lf ni lh li lj bi translated">React实现的Heroku上的现场演示(警告:服务器需要一两分钟才能唤醒)</li></ul><h1 id="ac92" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">基本概述</h1><h2 id="a993" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">Vue是什么？</h2><blockquote class="mx my mz"><p id="c52a" class="mh mi na ku b kv kw jo mk kx ky jr mm nb nc mo mp nd ne mr ms nf ng mu mv lf ig bi translated">Vue(读作/vjuː/，类似视图)是一个用于构建用户界面的渐进式框架。与其他整体框架不同，Vue从一开始就被设计成可增量采用的。核心库只关注视图层，很容易获取并与其他库或现有项目集成。另一方面，当与<a class="ae mw" href="https://vuejs.org/v2/guide/single-file-components.html" rel="noopener ugc nofollow" target="_blank">现代工具</a>和<a class="ae mw" href="https://github.com/vuejs/awesome-vue#components--libraries" rel="noopener ugc nofollow" target="_blank">支持库</a>结合使用时，Vue也完全能够支持复杂的单页面应用程序。—来自马嘴，又名Vue docs</p></blockquote><p id="d193" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">在一些短视频中，Vue网站上的人们通过将脚本嵌入到HTML页面中来快速制作示例，并且您在HTML文档中的脚本标签中构建所有内容，但是我发现这通常过于简单，并且最终会令人困惑，因为我希望鸟瞰组件文件的模块化，而不是从一个生态系统“增量过渡”到下一个生态系统。</p><h2 id="7b62" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">Vue vs React</h2><p id="668d" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">显然语法是一个很大的区别，但大部分的反应性和渲染概念是相同的。(这个不要@我！)这两个生态系统中都使用了虚拟DOM。两者都有可选的客户端路由——对于Vue，你可以选择使用<a class="ae mw" href="https://router.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue路由器</a>。并且两者都允许创建模块化的、可重用的组件，这些组件位于它们自己的目录中，从而便于组织和阅读。单页应用程序(SPA)就是由这两者创建的！</p><h2 id="80b8" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">Vue CLI</h2><p id="d6ce" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">Vue有一个方便的应用程序生成工具，名为<a class="ae mw" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue CLI </a>，你可以通过<code class="fe nv nw nx ny b">npm</code>或<code class="fe nv nw nx ny b">yarn</code>在全球范围内安装，还有一个别致的项目管理类型的UI，你可以在那里管理依赖关系、插件和查看有用的指标，如加载时间等。</p><h2 id="4a85" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">Vue路由器</h2><p id="d7fe" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">有了Vue Router，我可以将我的路线放入不同的目录和文件中，而只需在主App.vue文件中放置一个<code class="fe nv nw nx ny b">&lt;router-view /&gt;</code>标签，类似于Ruby on Rails在<code class="fe nv nw nx ny b">layout.erb</code>等ERB文件中的<code class="fe nv nw nx ny b">&lt;%= yield %&gt;</code>标签。</p><h2 id="8b3e" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">Vuex</h2><p id="81b8" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">Vue的状态管理库，<a class="ae mw" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>，在我看来比Redux更容易理解，它们采用了一些惯例，防止你在目录间跳跃，跟踪getters、actions、mutations的序列，并看到你的初始状态。React中一个流行的惯例是为一个资源的reducers和dispatch actions创建两个单独的文件。对于Vue，它们的约定是所有东西都在一个文件中:状态、getters、动作和突变。因为这些元素之间有很多相互作用，所以当所有这些概念都“在同一个房间里”时，就容易多了，至少对我的大脑来说是这样</p><h2 id="de7d" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">Nuxt.js</h2><p id="3669" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">像在React中使用Next.js一样，Vue也有自己的配套框架，名为<a class="ae mw" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt.js </a>，让你的工作更轻松，并为新员工提供更多入职内容💁‍♂️</p><p id="175d" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">我最近在使用<a class="ae mw" href="https://bootstrap-vue.org/" rel="noopener ugc nofollow" target="_blank"> BootstrapVue </a>时发现的最后一个金块，一种利用引导CSS库易用性的方法。与<a class="ae mw" href="https://react-bootstrap.github.io/" rel="noopener ugc nofollow" target="_blank"> ReactBootstrap </a>不同，我不必将单独的引导组件导入到每个使用它们的组件中。你只需要导入根JS文件，通常是<code class="fe nv nw nx ny b">main.js</code>然后是<code class="fe nv nw nx ny b">Vue.use()</code>除了导入引导发行版CSS之外的库。</p><h1 id="74f2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">单文件组件—例如:App.vue</h1><p id="c328" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">好了，废话少说——让我们看看组件文件实际上是什么样子的！万岁，<a class="ae mw" href="https://vuejs.org/v2/guide/single-file-components.html" rel="noopener ugc nofollow" target="_blank">单列组件</a>！！</p><p id="295c" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">请注意，这个App.vue文件分为3个部分:</p><ol class=""><li id="0cab" class="ks kt in ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">模板</li><li id="4e62" class="ks kt in ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">脚本</li><li id="0145" class="ks kt in ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/8d33978e7cd79365603ff155ca5d8051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvV-dZFRc7sstw9ckN2JUg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">My App.vue root component for the front end of RYL app.</figcaption></figure><h2 id="9c6e" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">模板</h2><p id="0e70" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">位于<code class="fe nv nw nx ny b">&lt;template&gt;&lt;/template&gt;</code>标签之间的内容与使用JSX的React组件的<code class="fe nv nw nx ny b">render()</code>或<code class="fe nv nw nx ny b">return</code>非常相似。像React一样，这里出现的必须是单个返回的组件或HTML元素，或者如果呈现了许多项，它们必须包含在父元素中，在本例中是一个<code class="fe nv nw nx ny b">div</code>。</p><p id="f254" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">注意，我已经在模板视图中挂载了一个<code class="fe nv nw nx ny b">&lt;Navigation /&gt;</code>组件，它包含了来自另一个文件“Navigation.vue”的导航栏。<code class="fe nv nw nx ny b">&lt;b-container&gt;&lt;/b-container&gt;</code>其实就是前面提到的BootstrapVue组件。第6行中最重要的<code class="fe nv nw nx ny b">&lt;router-view/&gt;</code>是门户，通过它，我所有的动态内容将根据我在路由器文件中设置的配置呈现出来。</p><h2 id="61d2" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">脚本</h2><p id="1a1c" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">这一部分是这些组件文件中最具JavaScript特色的部分。在这里，我们导入必要的组件、我们定制的外部帮助器，或者由Vuex提供的帮助器。你可以看到这是我通过一个<code class="fe nv nw nx ny b">import</code>语句引入我的<code class="fe nv nw nx ny b">Navigation</code>组件的地方，类似于你在React中可能做的事情。</p><p id="f4ec" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated"><code class="fe nv nw nx ny b">export default</code>部分导出你的<strong class="ku io">模板</strong>部分需要做的所有事情的对象。在这里，在我的<code class="fe nv nw nx ny b">export</code>语句的<code class="fe nv nw nx ny b">methods</code>属性下，我使用一个<code class="fe nv nw nx ny b">spread</code>操作符，通过来自Vuex和我的商店的<code class="fe nv nw nx ny b">mapActions</code>助手函数来填充这个部分。<code class="fe nv nw nx ny b">[“fetchLandlords”, “fetchProperties”, “fetchReviews”]</code>都是在<code class="fe nv nw nx ny b">landlords</code>存储模块中定义的，我们将在本系列的后面看到。</p><p id="1c91" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">请注意，除了从项目中导入外部组件模块，您还必须在<code class="fe nv nw nx ny b">components</code>属性中声明它们以及组件名称的字符串表示形式，在本例中<code class="fe nv nw nx ny b">“App.”</code>这有助于调试错误消息，并且它们确实依赖于Vue中的<em class="na">硬</em>。</p><p id="8819" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">您还可以在我们的<code class="fe nv nw nx ny b">export</code>部分中指定<code class="fe nv nw nx ny b">props</code>和propTypes，并通过函数计算属性。如果您正在构建一个表单，或者需要跟踪UI切换状态，您还可以定义一个将返回本地状态的<code class="fe nv nw nx ny b">data()</code>函数。</p><h2 id="9175" class="nj lq in bd lr nk nl dn lv nm nn dp lz kz no np mb lb nq nr md ld ns nt mf nu bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h2><p id="cdfb" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">最后，我们来到Vue组件中最简单、最容易理解的部分。在这里，我们可以指定样式，并通过第31行的<code class="fe nv nw nx ny b">scoped</code>布尔值选择将它们限定在当前组件的范围内。</p><h1 id="3a95" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">接下来是什么</h1><p id="9820" class="pw-post-body-paragraph mh mi in ku b kv mj jo mk kx ml jr mm kz mn mo mp lb mq mr ms ld mt mu mv lf ig bi translated">到目前为止，我们已经对Vue进行了鸟瞰。这是一个很好的选择，包括Urban Outfitters、阿里巴巴、埃森哲、Trivago、GitLab等等。接下来，我将详细介绍应用架构、路由、商店和Vue指令！</p><p id="450e" class="pw-post-body-paragraph mh mi in ku b kv kw jo mk kx ky jr mm kz nc mo mp lb ne mr ms ld ng mu mv lf ig bi translated">在<a class="ae mw" href="http://twitter.com/_dan_foley_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae mw" href="https://github.com/d-otis" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我！</p></div></div>    
</body>
</html>