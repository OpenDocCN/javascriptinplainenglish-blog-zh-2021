<html>
<head>
<title>Safe Class Fields: JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全类字段:JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/safe-class-fields-c2ab0e499d59?source=collection_archive---------16-----------------------#2021-12-01">https://javascript.plainenglish.io/safe-class-fields-c2ab0e499d59?source=collection_archive---------16-----------------------#2021-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/24ec8084b5427fbb9800cb6d11c7b19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*ofgQqCUXVXB_i2zHUQdcTQ.png"/></div></figure><p id="0798" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">今年早些时候，班级领域的提议达到了第四阶段，这意味着不管是好是坏，我们都会坚持下去。作为一个强烈反对该设计的开发人员，我决定不使用它。然而，我务实的一面慢慢消磨了我的决心，直到我最终决定寻找一种方法来绕过提案中最大的缺点。</p><h2 id="355c" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">疣1:公有领域不尊重继承！</h2><p id="8d13" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">公共字段与其说是“类字段”，不如说是“实例字段”。他们没有在原型上设置不可替代的默认值(由于与对象相关的footgun问题)，而是选择通过在实例上放置数据成员来消除这种风险。不错，但也不算好。然后，出于静态可预测性的考虑(即，使引擎开发人员更容易优化，而不是更容易适应开发人员的使用范例)，他们决定在创建时使用“定义”语义，而不是“设置”语义(本质上是“object . define property”vs“=”)。我不会去探究所有不好的方面。我已经写过了。但是提醒一下，这将破坏原型上的任何访问器属性，不管访问器是在包含该字段的类的基类上，还是在从包含该字段的类派生的类上。这是对继承的纯粹侵犯，但被TC39一笔勾销。</p><h2 id="25e5" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">疣1解决方案:不要用它们！</h2><p id="3722" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">那么我们如何解决这个问题呢？简单。仅使用私有字段。然后，对于每个公共数据成员，使用访问器。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Avoiding public field problems</figcaption></figure><p id="afbc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">符合人体工程学吗？不，但是你可以感谢TC39，他们的选择使得这种方法成为必要。幸运的话，decorators的提议将引入一个新的特性来改善这一点:自动访问器。有时间就去看看。</p><p id="a15c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">额外打字的回报是什么？</p><ul class=""><li id="fd02" class="ly lz in jt b ju jv jy jz kc ma kg mb kk mc ko md me mf mg bi translated">更好地控制您的公共数据。</li><li id="c4ed" class="ly lz in jt b ju mh jy mi kc mj kg mk kk ml ko md me mf mg bi translated">确定第三方逻辑添加了哪些实例成员的清晰方法</li><li id="6c5f" class="ly lz in jt b ju mh jy mi kc mj kg mk kk ml ko md me mf mg bi translated">保证您的代码不太可能由于继承问题而破坏第三方代码。</li></ul><p id="a61d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">另外，还有第二种可能的解决方案:完全禁止使用访问器。然而，我不认为这是一个可行的解决方案，因为你永远不知道什么时候你想使用和继承的库会依赖于访问器。所以对我来说，这充其量只是部分解决方案。</p><h2 id="4427" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">疣2:私有字段破坏代理！</h2><p id="c9ba" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">想创建一个类并把它或它的实例传递给一个使用代理的库吗？祝你处理bug好运！出于我之前在另一篇文章中提到的原因，代理不能很好地处理包含私有字段的类实例，除非该代理完全被构造为一个膜。如果代理更多地被设置为观察者，那么当使用访问私有字段的函数时，它就不能工作。</p><h2 id="d82a" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">疣2解决方案:拯救你的“自我”！</h2><p id="fd05" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">如果您希望您的类在保持代理安全的同时使用私有字段，那么您需要保存您的“自我”。也就是说，您需要使用类的构造函数将实例的副本保存在实例上，或者该实例可以访问的其他地方。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Saving your “self” on the instance and constructor.</figcaption></figure><p id="7ea4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里真正的技巧是在唯一的一段时间内保存“this”的值，在这段时间内，除了知道私有字段存在的对象之外，它不可能有任何值。那是在施工期间。您可以在静态构造函数和实例构造函数中捕获它。之后，任何时候你想引用私人的东西，就用“this.self”而不是只用“this”。这将保证即使“这个”是一个代理，它也不会妨碍你，因为“自我”总是实例。</p><p id="54d7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">解决了这两个问题(以一些样板文件为代价)，您应该能够安全地编写包含类字段的代码，这些字段不会自动中断，直到有人试图将您的代码与使用不当的类字段结合使用(即默认方式)。</p><h2 id="537f" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">缺点3:完全缺乏对“受保护”成员的支持</h2><p id="4b70" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">尽管我很讨厌TC39继续这个提议，但它实际上并不全是坏事。事实证明，作为他们在实施这一建议时所做的糟糕选择的副作用，他们仍然设法为实施“受保护的领域”的相对简单的方法开辟了可能性。我肯定他们可能并不想这样。然而，对于我们这些了解使用“受保护”的价值的人来说，我将向您展示如何手工操作。</p><h2 id="44a5" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">疣3解决方案:自己卷就好！</h2><p id="4489" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">还记得疣1吗？这实际上是解决问题的关键。公共字段放在实例上，在从“super”返回之后，但在任何类的构造函数中的第一行post-super代码之前。这意味着在构造函数运行之前，它们不会出现在任何地方。那么如果构造函数删除它们会发生什么呢？好吧，那就没人能再见到他们了。</p><p id="dd9a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通过这样做，您可以在类中定义一个公共字段，它的生存期只在实例构造期间。这种能力正是我们所需要的，因为它允许我们在构造函数之间传递数据，而构造函数链之外的任何东西都不会看到。这是传递我们受保护数据的工具。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Inherited field passing function</figcaption></figure><p id="feed" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是受保护字段初始值设定项的一个版本。实际上，称它为继承字段初始化器可能更好。它的工作方式是创建一个新的对象，用基类定义的访问器属性初始化。它清理了基类，这样这些属性就不会在构造之外泄露。这个函数对于派生类和基类都是一样的。它也可以用于构造函数上的静态受保护成员。然而，我一直有点怀疑静态受保护成员的实际用途。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ef22" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里我们有一个如何设置受保护成员的例子。我使用一个符号作为存储受保护成员访问器的字段的名称。受保护成员实际上只是我们希望与派生类共享的私有成员，所以我定义了派生类将使用的访问器。</p><p id="4fab" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我还创建了一个容器，将受保护的成员访问器作为私有字段保存。这确保了不会有来自同级类的窥探。在构造函数中，我将受保护的容器分配给来自initProt的响应，就这样。清洗、漂洗、重复派生类，受保护的成员将几乎无缝地传递下去。</p><p id="dc59" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是最有效的方法吗？当然不是。我还在努力寻找更干净的方法。然而，通过上面的代码片段，将受保护的字段包含到您自己的代码中是多么简单应该是相当清楚的了。</p><p id="a39f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="mm">更多内容看</em> <strong class="jt io"> <em class="mm"> </em> </strong> <a class="ae lx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="mm">说白了. io </em> </strong> </a> <strong class="jt io"> <em class="mm">。</em> </strong> <em class="mm">报名参加我们的</em><strong class="jt io"><em class="mm"/></strong><a class="ae lx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="mm">免费每周简讯这里</em> </strong> </a> <strong class="jt io"> <em class="mm">。</em> </strong></p></div></div>    
</body>
</html>