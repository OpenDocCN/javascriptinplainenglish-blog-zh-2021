<html>
<head>
<title>React and TypeScript: The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应和打字稿:基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-and-typescript-the-basics-a7bb6625282c?source=collection_archive---------4-----------------------#2021-06-06">https://javascript.plainenglish.io/react-and-typescript-the-basics-a7bb6625282c?source=collection_archive---------4-----------------------#2021-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3638" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">通过设置一个习惯跟踪应用程序，了解如何使用React实现脚本语言。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/1d06aad0a9dd6c87d39a4f699383c841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wUJoYKgUuZ-o4dV5"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@prophsee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Prophsee Journals</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="88a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在了解到2020年第二大最受欢迎的编程语言是TypeScript之后，很自然地，对于像我一样发现TypeScript的许多早期JavaScript开发人员来说，这个问题本身就是<em class="ki">工程师是否以及</em>如何将它与第二大最受欢迎的<a class="ae kz" href="https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted" rel="noopener ugc nofollow" target="_blank">JavaScript框架/库(又名React)一起使用。</a></p><p id="20bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">社区中的许多人认为这两者可以很好地结合在一起；一个开发者给出了一个<a class="ae kz" href="https://fettblog.eu/typescript-react/" rel="noopener ugc nofollow" target="_blank">解释</a>为什么:</p><blockquote class="la lb lc"><p id="7dc8" class="jk jl ki jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated">JSX是句法糖。你打开并传递属性的每个JSX元素，只不过是React(或Preact或Vue或Dojo…你能想到的)中的一个函数调用。这给了我们TypeScript一个很大的优势:JavaScript可以被解析、理解和评估。这意味着您可以获得TypeScript提供的所有工具和编译优势。缺少必需的属性？TypeScript会告诉你！在某处有一个错别字:你会发现。不知道您需要哪些属性？自动完成拯救！</p></blockquote><p id="3819" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了得到一个更实用的方法，我决定制作一个迷你习惯跟踪器应用程序(Rails在后端，React在前端)来感受一下这种集成是如何进行的。</p><h1 id="52e7" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">基础知识</h1><p id="cf76" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我通常使用Create React App来启动并运行一个新的React项目，事实证明，CRA <a class="ae kz" href="https://create-react-app.dev/docs/adding-typescript/" rel="noopener ugc nofollow" target="_blank">文档</a>提供了对TypeScript的支持。</p><h2 id="c1b1" class="mj lh in bd li mk ml dn lm mm mn dp lq jv mo mp lu jz mq mr ly kd ms mt mc mu bi translated"><strong class="ak">用类型脚本启动一个新的react应用:</strong></h2><pre class="kk kl km kn gt mv mw mx my aw mz bi"><span id="2405" class="mj lh in mw b gy na nb l nc nd">npx create-react-app my-app --template typescript</span><span id="ccb3" class="mj lh in mw b gy ne nb l nc nd"># or</span><span id="0689" class="mj lh in mw b gy ne nb l nc nd">yarn create react-app my-app --template typescript</span></pre><p id="7085" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">确保将<code class="fe nf ng nh mw b">my-app</code>替换为您的应用程序/前端文件夹的预期名称。</p><p id="9ca0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(<a class="ae kz" href="https://www.gatsbyjs.com/docs/how-to/custom-configuration/typescript/" rel="noopener ugc nofollow" target="_blank"> Gatsby </a>和<a class="ae kz" href="https://nextjs.org/learn/excel/typescript" rel="noopener ugc nofollow" target="_blank"> NextJS </a>也为静态站点app提供了类型脚本的支持。)</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c31a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我的React应用程序编译完成，在我的<code class="fe nf ng nh mw b">App</code>组件中，我开始使用一个<code class="fe nf ng nh mw b">useEffect</code>钩子和一个获取API来加载我想要呈现到页面的数据(来自我后端的日常习惯)，并使用<code class="fe nf ng nh mw b">useState</code>钩子将我的获取响应设置为等于<code class="fe nf ng nh mw b">habits</code>的状态。</p><p id="6ad7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我将这个状态作为一个名为<code class="fe nf ng nh mw b">dailyHabits</code>的道具传递给我的<code class="fe nf ng nh mw b">Main</code>子组件。</p><h2 id="66dd" class="mj lh in bd li mk ml dn lm mm mn dp lq jv mo mp lu jz mq mr ly kd ms mt mc mu bi translated">正确类型和功能组件</h2><p id="bd97" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">对于接受props的函数组件，创建一个<strong class="jm io"> <em class="ki">类型别名</em> </strong>或<strong class="jm io"> <em class="ki">接口</em> </strong>，描述子组件正在接收的属性的形状。</p><p id="15a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">* *类型别名和接口之间的区别是微妙的，但是来自TypeScript和React <a class="ae kz" href="https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example" rel="noopener ugc nofollow" target="_blank"> cheatsheet </a>的这个片段提供了一个经验法则:</p><blockquote class="la lb lc"><p id="ea5e" class="jk jl ki jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated">创作库或第三方环境类型定义时，始终使用<code class="fe nf ng nh mw b"><em class="in">interface</em></code>作为公共API的定义，因为这允许消费者在缺少某些定义时通过<strong class="jm io"> <em class="in">声明合并</em> </strong>来扩展它们。</p><p id="819b" class="jk jl ki jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated">考虑使用<code class="fe nf ng nh mw b"><em class="in">type</em></code>作为你的React组件属性和状态，为了一致性，因为它更受约束。</p></blockquote><p id="3416" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(接口允许声明合并，即稍后添加属性，而类型别名不允许)。</p><p id="b98c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的<code class="fe nf ng nh mw b">Main</code>子组件中，我首先如下定义属性:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="185b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为<code class="fe nf ng nh mw b">dailyHabits</code>是一个对象数组，注意我们在结尾<code class="fe nf ng nh mw b">}</code>后使用<code class="fe nf ng nh mw b">[]</code>来表示。</p><p id="332e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"><em class="ki">* *常见的道具类型</em> </strong>在React和TypeScript <a class="ae kz" href="https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example" rel="noopener ugc nofollow" target="_blank"> cheatsheet </a>中列出，但是作为道具传递的React/TypeScript应用程序的其他常见类型包括函数(例如onClick或onChange)，可以定义如下:</p><pre class="kk kl km kn gt mv mw mx my aw mz bi"><span id="7127" class="mj lh in mw b gy na nb l nc nd"><em class="ki">// function that doesn't take or return anything (VERY COMMON) </em></span><span id="b3c9" class="mj lh in mw b gy ne nb l nc nd">onClick: () =&gt; <em class="ki">void</em>;</span><span id="dd62" class="mj lh in mw b gy ne nb l nc nd"><em class="ki">//function with named prop (VERY COMMON)</em></span><span id="0d58" class="mj lh in mw b gy ne nb l nc nd">onChange: (id: number) =&gt; <em class="ki">void</em>;</span></pre><p id="f69e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">声明函数组件最简单的方法是将props作为一个参数，并在后面加上一个冒号和已经定义的类型别名或接口，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ca39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后推断出返回类型。在这个阶段，<code class="fe nf ng nh mw b">React.FunctionComponent</code>或<code class="fe nf ng nh mw b">React.FC</code>经常出现在代码库中，但是一般<a class="ae kz" href="https://github.com/facebook/create-react-app/pull/8177" rel="noopener ugc nofollow" target="_blank">不鼓励</a>使用，应该避免使用。</p><p id="bf97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于类组件来说，这个过程有点不同cheatsheet再次为声明类型提供了清晰性。</p><h2 id="0678" class="mj lh in bd li mk ml dn lm mm mn dp lq jv mo mp lu jz mq mr ly kd ms mt mc mu bi translated">通过道具映射</h2><p id="2478" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">接下来，我想映射我的<code class="fe nf ng nh mw b">dailyHabits</code>道具，并将每个对象元素向下传递给一个<code class="fe nf ng nh mw b">Habit</code>子组件，但是需要先对数组中的每个子组件进行类型检查。由于每个子对象都是一个对象本身(而不是一个对象数组)，它的形状与<code class="fe nf ng nh mw b">dailyHabits</code>不同，所以我们必须首先声明类型别名:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0d2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从那里，类似于声明一个函数组件，我们用类型别名隐式定义每个子元素:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5987" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nf ng nh mw b"><em class="ki">{…h}</em></code> <em class="ki">这里是分配道具的简写——类似于写</em> <code class="fe nf ng nh mw b"><em class="ki">key=h.id</em></code> <em class="ki"> </em> <code class="fe nf ng nh mw b"><em class="ki">name=h.habit.name</em></code> <em class="ki">等等(每个属性都通过</em> <code class="fe nf ng nh mw b"><em class="ki">props</em></code> <em class="ki">传递和访问)。</em></p><p id="1826" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的<code class="fe nf ng nh mw b">Habit</code>组件中，因为我接受了那个道具，所以我也需要在那里声明形状，首先分配一个类型别名，这将是用于在map函数中对每个孩子进行类型检查的同一个别名:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bc9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在两个组件中编写相同的类型别名有点重复——相反，一种选择是将其包含在一个单独的文件中，将其作为变量导入，并在父映射函数和子函数组件声明中引用该变量。</p><p id="faa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个日常习惯现在都可以成功地呈现在屏幕上，然而，这个应用程序缺少一些基本的功能，比如检查一天的习惯或添加一个全新的习惯。</p><p id="aa60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的下一篇博客中，我将(试图)为初学者演示如何处理这些类型的事件和类型检查。</p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><h2 id="8ddf" class="mj lh in bd li mk ml dn lm mm mn dp lq jv mo mp lu jz mq mr ly kd ms mt mc mu bi translated">更多资源:</h2><ul class=""><li id="6b74" class="nr ns in jm b jn me jr mf jv nt jz nu kd nv kh nw nx ny nz bi translated"><a class="ae kz" href="https://react-typescript-cheatsheet.netlify.app/" rel="noopener ugc nofollow" target="_blank">打字稿备忘单</a></li><li id="cceb" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated"><a class="ae kz" href="https://fettblog.eu/typescript-react/" rel="noopener ugc nofollow" target="_blank">打字稿和反应指南</a></li></ul><p id="59c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容尽在</em><a class="ae kz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ki">plain English . io</em></a></p></div></div>    
</body>
</html>