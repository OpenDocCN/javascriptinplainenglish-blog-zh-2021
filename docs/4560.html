<html>
<head>
<title>React: All About Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:关于组件的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-all-about-components-35650a02ff50?source=collection_archive---------2-----------------------#2021-09-11">https://javascript.plainenglish.io/react-all-about-components-35650a02ff50?source=collection_archive---------2-----------------------#2021-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="775a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">哑分量、智能分量、纯分量、高阶分量、受控和非受控分量</h2></div><p id="797c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个<strong class="ke io">组件</strong>是React的核心构建块之一。换句话说，我们可以说，您将在React中开发的每个应用程序都将由称为组件的部分组成。组件使得构建ui的任务更加容易。</p><blockquote class="ky"><p id="cdbc" class="kz la in bd lb lc ld le lf lg lh kx dk translated">"组件可以让你把用户界面分割成独立的、可重用的部分，并且独立地考虑每一部分."</p></blockquote><figure class="lj lk ll lm ln lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi li"><img src="../Images/6a7ca86a76009b40f5a42ab0d14e29fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U25ZZmTZ3vgfT7i45suzrw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Four components</figcaption></figure><p id="c5e9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们可以看到一个UI被分解成多个单独的部分，称为组件，独立地处理它们，并将它们合并到一个父组件中，这将是您的最终UI。</p><p id="100e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们研究一下React中不同类型的组件:</p><h1 id="ed9f" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">哑/无状态/表示组件</h1><p id="4f23" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated"><strong class="ke io">🦄哑组件关注的是事物的外观。</strong></p><ul class=""><li id="deaf" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nb nc nd ne bi translated">哑组件也被称为“表示性”组件，因为它们唯一的职责是<strong class="ke io">向DOM </strong>呈现一些东西。一旦完成，组件就完成了。</li><li id="c90f" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">在这个组件中没有任何逻辑，因此它被称为哑组件。因为哑组件<strong class="ke io">只关注表示(UI组件)，</strong>是最理想的<strong class="ke io">可重用组件。</strong></li><li id="77d1" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">这个组件通常只是Javascript函数，并且只有一个render()方法。它也没有任何状态或生命周期挂钩。但是，它仍然可以通过props接收来自父母的一些数据和功能。</li></ul><p id="191d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">哑元件的共同特征:</strong></p><ol class=""><li id="1eda" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nk nc nd ne bi translated"><strong class="ke io">关注UI: </strong>几乎所有的基本UI组件都应该被认为是哑组件。示例包括加载器、模态、按钮、输入等。</li><li id="a4cd" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nk nc nd ne bi translated"><strong class="ke io">接受道具:</strong>哑组件接受道具以允许它们是动态的和可重用的。例如，您可以从父组件发送props中的一个按钮的标题，以允许它有一个唯一的名称。</li></ol><ul class=""><li id="bfee" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nb nc nd ne bi translated"><strong class="ke io">不需要app依赖:</strong>除了UI包，像<code class="fe nl nm nn no b">Reactstrap</code>一样，哑组件不需要依赖。</li><li id="b2a4" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated"><strong class="ke io">很少包含状态:</strong>哑组件拥有状态的唯一实例是用于操作UI本身，而不是应用程序数据。哑组件可能具有状态的一些例子是按钮组、选项卡、开关和其他不影响数据的UI元素，只影响UI。</li></ul><figure class="np nq nr ns gt lo"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="678a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一下我们的登录表单示例。几乎每个组件都可以是可重用的哑组件，包括容器、标题、输入和按钮。</p><figure class="np nq nr ns gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nv"><img src="../Images/94910a796c824a506b3da5bcb02483ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xr8H4n0DncLrWyMz2rn2Q.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Highlighted Dumb Component</figcaption></figure><h1 id="52c5" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">智能/有状态/容器组件</h1><p id="576a" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">🤓<strong class="ke io">智能组件关注事物如何工作。</strong></p><ul class=""><li id="e2cc" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nb nc nd ne bi translated">另一方面，智能组件(或容器组件)有不同的职责。因为他们肩负着保持聪明的重任，所以他们是跟踪状态并关心应用程序如何工作的人。使用容器设计模式，容器组件从表现组件中分离出来，每个组件处理自己的事情。容器组件完成繁重的工作，并将数据作为道具向下传递给表示组件。</li><li id="5eea" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">容器组件模式是基于类的组件，具有constructor()函数。我们通常在构造函数内部初始化状态，尽管你可以移除构造函数而仍然有一个状态。</li></ul><p id="3512" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">智能组件的共同特征包括:</strong></p><ol class=""><li id="3992" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nk nc nd ne bi translated"><strong class="ke io">操纵数据:</strong>智能组件可以获取、捕捉变化并传递应用数据。</li><li id="2702" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nk nc nd ne bi translated"><strong class="ke io">调用Redux、生命周期方法、API、库等:</strong>这些组件被称为智能是有原因的！他们负责调用库和功能。</li><li id="d7f0" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nk nc nd ne bi translated"><strong class="ke io">管理状态:</strong>智能组件负责管理状态，知道什么时候重新渲染一个组件。</li><li id="a3bd" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nk nc nd ne bi translated"><strong class="ke io">很少包含样式:</strong>因为哑组件关注于样式，所以它允许智能组件关注于功能而没有杂乱的样式。</li></ol><figure class="np nq nr ns gt lo"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="3b33" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">纯成分</h1><ul class=""><li id="6e3f" class="mw mx in ke b kf mr ki ms kl nw kp nx kt ny kx nb nc nd ne bi translated">纯组件是优化React应用程序的最重要的方法之一。</li><li id="db72" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">纯组件的使用大大提高了性能，因为它减少了应用程序中渲染操作的数量。</li></ul><figure class="np nq nr ns gt lo"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="268c" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nb nc nd ne bi translated">所以上面有一个非常简单的<strong class="ke io"> Welcome纯组件</strong>的例子。当您在您的父组件中使用它时，您会看到无论父组件何时重新渲染，欢迎组件都不会重新渲染</li><li id="1753" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">这是因为PureComponent改变了生命周期方法<strong class="ke io"> shouldComponentUpdate </strong>，并添加了一些逻辑来自动检查组件是否需要重新渲染。这使得PureComponent只有在检测到状态或属性的变化时才能调用render方法。</li></ul><h1 id="e522" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">高阶分量</h1><ul class=""><li id="fc34" class="mw mx in ke b kf mr ki ms kl nw kp nx kt ny kx nb nc nd ne bi translated">React中的高阶组件是一种模式，用于<strong class="ke io">在组件之间共享公共功能，而无需重复代码。</strong>高阶分量实际上不是分量，<strong class="ke io">它是函数</strong>。特殊函数将组件作为参数，并返回一个组件。它将一个组件转换成另一个组件，并添加额外的数据或功能。简而言之:</li></ul><pre class="np nq nr ns gt nz no oa ob aw oc bi"><span id="2671" class="od ma in no b gy oe of l og oh">const NewComponent = (BaseComponent) =&gt; {<br/>  // ... create new component from old one and update<br/>  return UpdatedComponent<br/>}</span></pre><ul class=""><li id="1311" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nb nc nd ne bi translated">React生态系统中您可能熟悉的两个HOC实现是Redux 的<code class="fe nl nm nn no b"><strong class="ke io">connect</strong></code>、React路由器的<code class="fe nl nm nn no b"><strong class="ke io">withRouter</strong></code> <strong class="ke io">。</strong>Redux的<code class="fe nl nm nn no b">connect</code>函数用于让组件访问Redux存储中的全局状态，并将这些值作为道具传递给组件。<code class="fe nl nm nn no b">withRouter</code>函数将路由器信息和功能注入到组件中，使开发人员能够访问或更改路由。</li><li id="157f" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">高阶分量是以分量作为自变量并返回分量的函数。这意味着特设将始终具有类似于以下内容的形式:</li></ul><figure class="np nq nr ns gt lo"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="8686" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nb nc nd ne bi translated"><code class="fe nl nm nn no b">higherOrderComponent</code>是一个将名为<code class="fe nl nm nn no b">WrappedComponent</code>的组件作为参数的函数。我们创建了一个名为<code class="fe nl nm nn no b">HOC</code>的新组件，它从其<code class="fe nl nm nn no b">render</code>函数中返回<code class="fe nl nm nn no b">&lt;WrappedComponent/&gt;</code>。虽然在这个简单的例子中，这实际上没有增加任何功能，但是它描述了每个特设函数都将遵循的通用模式。我们可以如下调用特设:</li></ul><pre class="np nq nr ns gt nz no oa ob aw oc bi"><span id="9244" class="od ma in no b gy oe of l og oh">const SimpleHOC = higherOrderComponent(MyComponent);</span></pre><p id="d0f2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一个简单的例子来容易地理解这个概念是如何工作的。<strong class="ke io"> MyHOC </strong>是一个高阶函数，仅用于向<strong class="ke io"> MyComponent </strong>传递数据。该函数获取<strong class="ke io"> MyComponent </strong>，用<strong class="ke io"> newData </strong>对其进行增强，并返回将在屏幕上呈现的增强组件。</p><figure class="np nq nr ns gt lo"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7558" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们运行这个应用程序，我们会看到数据被传递给了<strong class="ke io"> MyComponent </strong>。</p><figure class="np nq nr ns gt lo gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/49e874465f625105d23e531ea13edee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*_Tt7IahmbCLf2krf.jpg"/></div></figure><h2 id="786a" class="od ma in bd mb oj ok dn mf ol om dp mj kl on oo ml kp op oq mn kt or os mp ot bi translated">高阶元件考虑因素</h2><ul class=""><li id="0fd7" class="mw mx in ke b kf mr ki ms kl nw kp nx kt ny kx nb nc nd ne bi translated">特设应该是一个没有副作用的纯功能。它不应该做任何修改，而只是通过将原始组件包装在另一个组件中来组合它。</li><li id="c5a9" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">不要在组件的render方法中使用HOC。在组件定义之外访问特设。</li><li id="3c2c" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">静态方法必须被复制才能访问它们。一个简单的方法是使用<code class="fe nl nm nn no b">hoist-non-react-statics</code>包。</li><li id="c672" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">引用不通过。</li></ul><h1 id="24a6" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">受控组件</h1><ul class=""><li id="0bc7" class="mw mx in ke b kf mr ki ms kl nw kp nx kt ny kx nb nc nd ne bi translated">一个受控组件被绑定到一个值，它的变化将通过使用<strong class="ke io">基于事件的回调</strong>在代码中处理。这里，输入表单元素是由react本身而不是DOM处理的<strong class="ke io">。</strong>在这里，可变状态保存在state属性中，并且只使用setState()方法更新。组件内的状态充当由组件呈现的输入元素的<em class="ou">“真实的单一来源】</em>。</li><li id="41cc" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">受控组件具有控制每次发生<strong class="ke io"> onChange </strong>事件时传递给它们的数据的功能。然后将这些数据保存到state中，并用setState()方法进行更新。它使组件能够更好地控制表单元素和数据。</li></ul><p id="cd88" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我用一个简单的例子来解释一下:</p><figure class="np nq nr ns gt lo"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="53ac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该组件非常简单，但它证明了一点:React负责控制何时以及如何基于<code class="fe nl nm nn no b">setState</code>方法的内部逻辑来呈现它。我们不需要担心其他任何事情。</p><p id="845b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是编写组件的推荐方式(无论是使用类还是功能组件，只要确保它们是受控组件即可)，主要是因为框架的所有好处都适用于它们。您在DOM之上获得了一个抽象层，让您可以与元素进行反应和交互，而不必担心底层的DOM API方法。</p><h1 id="6868" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">非受控组件</h1><ul class=""><li id="af85" class="mw mx in ke b kf mr ki ms kl nw kp nx kt ny kx nb nc nd ne bi translated">它类似于传统的HTML表单输入。这里，<strong class="ke io">表单数据由DOM本身</strong>处理。它保持自己的状态，并将在输入值改变时更新。</li><li id="ec8f" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">要编写一个不受控制的组件，不需要为每个状态更新编写一个事件处理程序，您可以使用ref从DOM中访问表单的值。</li></ul><p id="cd3e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我用一个简单的例子来解释一下:</p><figure class="np nq nr ns gt lo"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="969f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的组件做的和前面的例子完全一样，当你，用户，在一个<code class="fe nl nm nn no b">input</code>框中输入时，它更新一个<code class="fe nl nm nn no b">p</code>元素的内容。没什么特别的，但是你可以看到为了达到同样的结果，我们不得不编写直接访问DOM的API的代码(例如，我们不得不直接设置目标元素的<code class="fe nl nm nn no b">innerHTML</code>属性)。如果你想做的事情需要更多的逻辑，这可能会变得更加复杂，但是你明白了。</p><blockquote class="ky"><p id="c0d4" class="kz la in bd lb lc ld le lf lg lh kx dk translated">在大多数情况下，我们建议使用<a class="ae ov" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">受控组件</a>来实现表单。在受控组件中，表单数据由React组件处理。另一种方法是不受控制的组件，表单数据由DOM本身处理。</p></blockquote><h2 id="81ed" class="od ma in bd mb oj ow dn mf ol ox dp mj kl oy oo ml kp oz oq mn kt pa os mp ot bi translated">受控组件和非受控组件之间的差异表</h2><figure class="np nq nr ns gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi pb"><img src="../Images/50eb535b25870641467d9d905791303c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGKxUctlDkpU9HYqgvxfGg.png"/></div></div></figure><h2 id="f621" class="od ma in bd mb oj ok dn mf ol om dp mj kl on oo ml kp op oq mn kt or os mp ot bi translated">什么时候应该使用受控组件，什么时候应该使用非受控组件？</h2><p id="aff1" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">基本上，这取决于你和你的用例，例如— <strong class="ke io">你可以在创建:</strong>时使用受控组件</p><ul class=""><li id="c19f" class="mw mx in ke b kf kg ki kj kl my kp mz kt na kx nb nc nd ne bi translated"><strong class="ke io">表单验证</strong>所以你总是需要在输入时知道输入的值，以检查它是否是一个有效的字符。</li><li id="5424" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated"><strong class="ke io">除非所有字段都有有效数据，否则禁用提交按钮</strong></li><li id="f2c3" class="mw mx in ke b kf nf ki ng kl nh kp ni kt nj kx nb nc nd ne bi translated">如果您有特定的格式，如信用卡输入</li></ul><p id="0c83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果你不需要这些，并且认为不受控制对你来说会更简单，那就去做吧。</p><p id="21d6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！</p><p id="600b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你今天学到了新东西。感谢阅读！:)</p></div><div class="ab cl pc pd hr pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ig ih ii ij ik"><h2 id="0bf4" class="od ma in bd mb oj ok dn mf ol om dp mj kl on oo ml kp op oq mn kt or os mp ot bi translated">进一步阅读</h2><div class="pj pk gp gr pl pm"><a href="https://bit.cloud/blog/composable-link-component-that-works-in-any-react-meta-framework-l7i3qgmw" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd io gy z fp pr fr fs ps fu fw im bi translated">可在任何React元框架中工作的可组合链接组件</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">Bit的链接组件是一个与运行环境无关的组件。您可以将此链接用于…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">比特云</p></div></div><div class="pv l"><div class="pw l px py pz pv qa lt pm"/></div></div></a></div></div><div class="ab cl pc pd hr pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ig ih ii ij ik"><p id="5fb7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ou">更多内容看</em> <a class="ae ov" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ou">说白了就是io </em> </strong> </a> <em class="ou">。报名参加我们的</em> <a class="ae ov" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ou">免费周报</em> </strong> </a> <em class="ou">。关注我们关于</em> <a class="ae ov" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ou">推特</em> </strong> </a>，<a class="ae ov" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ou">领英</em> </strong> </a> <em class="ou">，</em><a class="ae ov" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ou">YouTube</em></strong></a><em class="ou"/><a class="ae ov" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ou">不和</em> </strong> </a> <em class="ou">。对增长黑客感兴趣？检查</em> <a class="ae ov" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="ou">电路</em> </strong> </a> <em class="ou">。</em></p></div></div>    
</body>
</html>