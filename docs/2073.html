<html>
<head>
<title>Using Hooks to Create a Live Search Feature in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用钩子在React中创建一个实时搜索特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-hooks-to-create-a-live-search-feature-in-react-c667fe9bbc9e?source=collection_archive---------10-----------------------#2021-05-02">https://javascript.plainenglish.io/using-hooks-to-create-a-live-search-feature-in-react-c667fe9bbc9e?source=collection_archive---------10-----------------------#2021-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cece1d565478f2bde649d7745eeb5906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0We63yjjXOQS98iG5jYpXQ.png"/></div></div></figure><p id="113c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谁不喜欢漂亮的实时/即时搜索功能呢？它们为用户省去输入完整查询的麻烦，并且在试图从已经填充的列表中查找内容时特别有用。</p><p id="fd9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将为我们的朋友列表设置一个live search，以便用户可以更容易地找到特定的朋友。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/0bc9fba091f1b93f5a601a5c19bf2944.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*LrZbECy57Zz4Im5qDrza_Q.png"/></div></figure><p id="4d8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们成功地获取了我们的朋友，并且能够向用户显示这些朋友。现在，我们想让用户能够搜索这些朋友，而不必发送另一个获取请求并等待我们后端的另一个响应。让我们从创建一个受控输入开始。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/3deb117f5b9d12177202dbd8e89a41a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNk33uUw3BjGUXY9vSnD6w.png"/></div></div></figure><p id="cda9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要创建一个受控输入，首先我们要设置状态。因为我们使用的是功能组件，所以我们必须使用钩子来完成这个任务。在这个例子中，我们将使用<code class="fe kz la lb lc b">useReducer</code>钩子。我们希望在初始状态下创建一个状态变量来保存我们的搜索查询。在这里，我将状态变量命名为“search ”,并将其设置为一个空字符串。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/53c64f46a7e8175e3e1d14b1e5c6976a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*g6IKtB_waEqiUxDSC4ndYg.png"/></div></figure><p id="0820" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以添加我们的输入。将输入的值设置为等于状态变量“search”是很重要的。这样，用户在搜索栏中看到的内容反映了我们的状态变量中包含的内容。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi le"><img src="../Images/3396360630a0a1e0d8db4ee11755312e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOrnK-2cqlRuW7fJiu4DUw.png"/></div></div></figure><p id="da23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了让状态变量以及搜索栏随着每次击键而更新，我们将使用<code class="fe kz la lb lc b">onChange</code>事件监听器。这将在输入改变时触发我们的<code class="fe kz la lb lc b">handleChange</code>函数。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/4896d909271289ee1caf2833452b335b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*zUWtuBdRCI-U1K39rLbe6A.png"/></div></figure><p id="eb61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">handleChange函数用来自<code class="fe kz la lb lc b">onChange</code>事件的输入信息更新我们的状态变量。请记住，当我们更新状态时，它会触发组件的重新呈现。因此，每次击键时，搜索栏中的信息都会用更新后的信息重新呈现。在这里，您可以看到它将使用事件目标的名称(事件是变更，目标是我们的输入)，即“search”。它会将名为“search”的变量的值设置为事件目标的值(触发onChange事件侦听器的击键)。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/6057eb4392f70ffac079dd4d85ca2b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*gWECpmEvlYhav9KDLptEEA.png"/></div></figure><p id="bc50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当用户输入他们的查询时，我们存储这些信息并显示给用户。有了这些信息，我们可以过滤我们的朋友列表，只向用户显示名字中包含状态变量中的字符串的朋友。为了实现这一点，让我们创建一个<code class="fe kz la lb lc b">filterFriendsList</code>函数。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/6a6117de558d531c8b590dd9fbd6ec48.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*lcn51uw803opLbVTalE7LA.png"/></div></figure><p id="83d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">和过滤后的朋友变量。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi li"><img src="../Images/3669fc6bcfe58cf6ac70b9ad0e04c042.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*u844Zg2zUP6NW3n9rejXqA.png"/></div></figure><p id="2c1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们用<code class="fe kz la lb lc b">filterFriendsList</code>函数获取一个朋友，并检查我们朋友的名字是否包含我们存储在state中的字符串。如果是的话，让我们把它添加到我们的<code class="fe kz la lb lc b">filteredFriends</code>数组中。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/6fde55c56b7f1e41cdb3240d61a66394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OOOQFRYs9usx3i_V_9hRw.png"/></div></div></figure><p id="9c13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太棒了。现在我们只需要给这个函数传递一些信息，渲染我们的朋友。由于我们所有朋友的名字都应该被推送到<code class="fe kz la lb lc b">filtedFriends</code>数组，在我们的状态变量中给定一个空字符串，我们应该能够正常地呈现我们的朋友列表，只需要一行额外的代码来处理朋友的过滤。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/b82c3ce6b2c48f6646a87330bd9b71ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*8u_NPhf726ah_bk7_txgUw.png"/></div></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/0783eeae0a747512fe9880749ba6aae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*52X-PMwJvSNbFQTT_7B0hQ.png"/></div></figure><p id="f9b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将通过<code class="fe kz la lb lc b">filterFriendsList</code>函数把每个朋友，符合标准的朋友推到一个数组(所有的朋友给一个空字符串)，并使用该数组创建我们的朋友列表。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/9b33bc6e0f0b3937cab8ad836ed17678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sAjP_1m2T0y1MdyfjrWYxQ.gif"/></div></div></figure><p id="0ac1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！通过一个简单的受控输入，我们可以使用我们收集的信息来过滤用户的朋友列表，而不必再次调用我们的后端。这种逻辑同样适用于各种问题。开心快乐编码！</p><p id="935b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lo">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>