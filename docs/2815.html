<html>
<head>
<title>360° View of Web Cache Solution — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web缓存解决方案的360度视图—第1部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/360-view-of-web-cache-solution-part-1-2210cb3024b4?source=collection_archive---------19-----------------------#2021-06-08">https://javascript.plainenglish.io/360-view-of-web-cache-solution-part-1-2210cb3024b4?source=collection_archive---------19-----------------------#2021-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4cae3e6e5dc6b8bcd8dd2e9db27983fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aW0VVqTBXztGWbVfkIf_g.png"/></div></div></figure><p id="3527" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">必须根据内容的种类、更改频率以及与完成的事务相关的用户体验/期望来选择缓存策略。</p><p id="b7eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">缓存任何数据的好处应根据以下标准进行评定</p><ol class=""><li id="c884" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">防止不必要的网络呼叫</li><li id="571f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">防止后端服务器(Web/API服务器、数据库服务器和任何其他第三方系统)出现不必要的负载</li><li id="52e3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">防止不必要的数据传输</li></ol><p id="ebf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">TL；博士</strong></p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/a0d927724fb5a5484b07a63174d246d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u75zYjBECvKyUEQyQoFCOQ.png"/></div></div></figure><ul class=""><li id="a87c" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated"><em class="ln"> Partial 1 —每次刷新时，浏览器进行网络调用并传递ETag。网络调用已经发生，只有当ETag与</em>  <em class="ln">不同时，</em> <strong class="jx io"> <em class="ln">数据才会被传输，因此浏览器得到部分好处。</em></strong></li><li id="7979" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated"><em class="ln"> Partial 2 —在每次调用时，Web/API服务器需要</em> <strong class="jx io"> <em class="ln">构建响应</em> </strong> <em class="ln">并计算ETag。网络调用已经发生，只有当ETag不同时，数据才被传输，因此Web/API服务器部分受益。</em></li></ul><p id="856f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了获得更好的响应时间，实现ETag并选择一个好的max-age (expiration)。如果您的目标是降低DB服务器或第三方系统的负担，那么在环境中包含一个缓存服务器。缓存服务器为你节省了一些钱，也提高了你的应用声誉。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="86f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Web应用程序涉及以下几种内容</p><ul class=""><li id="fe1f" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated"><strong class="jx io">静态资产</strong>如JS、CSS、图片、字体等。通常在新版本中会发生变化。更改频率取决于您的发布周期。这些资产可以被缓存几天甚至几年。</li><li id="c89a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated">像HTML(服务器端)和API响应这样的动态内容会经常改变。主数据是变化缓慢的实体，可以缓存几分钟。事务实体必须同步到分钟或秒钟。</li></ul><p id="608e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">浏览器和中间缓存(CDN或代理服务器)使用以下HTTP头来实现更好的缓存管理。</p><ul class=""><li id="7715" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated"><strong class="jx io">缓存控制</strong> —无存储、无缓存、公共/私有、必须重新验证和最大年龄(过期)</li><li id="9e8c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated"><strong class="jx io">缓存验证头</strong> — ETag(如果不匹配)和Last-Modified(如果修改-自)</li></ul><div class="lv lw gp gr lx ly"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd io gy z fp md fr fs me fu fw im bi translated">HTTP缓存- HTTP | MDN</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">通过重用以前获取的资源，网站和应用程序的性能可以显著提高…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">developer.mozilla.org</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm jt ly"/></div></div></a></div></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="e048" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">(任何单页应用程序的)静态资产</strong></p><p id="19c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Webpack帮助为每个包创建一个内容散列，并将它们包含在包文件名中。这些<strong class="jx io">版本化的资源</strong>可以被缓存一年，而不用担心过时的问题。资源名称及其公共路径都包含在HTML文件中。</p><p id="fee0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了避免在重新生成包文件的过程中出现不必要的变化，我们需要识别并分割包。例如，特定于供应商的块、特定于路由(lazyload)的块等，应该作为一个单独的包来创建。，有关更多详细信息，请参考<a class="ae mn" href="https://webpack.js.org/guides/caching/" rel="noopener ugc nofollow" target="_blank">网络包指南</a></p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/da4b9bd7d833a7828644187b60d126c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-BjUIMOzcV5Vai9McVICw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Vue CLI build output for production based on the default configuration</figcaption></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="8d85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">网络服务器</strong></p><p id="0fdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了简单起见，让我们使用<strong class="jx io">快速服务器</strong>托管捆绑的资源。这些概念适用于Nginx和任何其他web服务器。</p><pre class="li lj lk ll gt mt mu mv mw aw mx bi"><span id="8fb4" class="my mz in mu b gy na nb l nc nd">const<em class="ln"> express </em>=<em class="ln"> require</em>('express');<br/>const<em class="ln"> app </em>=<em class="ln"> express</em>();<br/>const<em class="ln"> port </em>=<em class="ln"> </em>3000;</span><span id="b8b8" class="my mz in mu b gy ne nb l nc nd"><em class="ln">app.use</em>(<em class="ln">express.static</em>('dist'));</span><span id="2684" class="my mz in mu b gy ne nb l nc nd"><em class="ln">app.listen</em>(port, () =&gt; {<br/><em class="ln">console.log</em>(`Example app listening at <a class="ae mn" href="http://localhost:${port}`);" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`);</a><br/>});</span></pre><p id="9999" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们访问主页时，将在Chrome浏览器中观察到以下行为。</p><ul class=""><li id="7054" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated">第一次访问主页时，将下载所有静态资源</li><li id="c0ef" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated">在随后的访问中，浏览器使用ETag检查Web服务器上的内容是否发生了变化。</li></ul><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/62ccb1b5207d2ede58d1f88ac1faa6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQ_ms_WUCeXsKYTxKg1BFA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Chrome browser network flow</figcaption></figure><p id="2d49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">快递服务器(默认)</strong></p><ul class=""><li id="f406" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated">为所有HTTP响应自动生成弱<a class="ae mn" href="https://www.npmjs.com/package/etag" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> ETag </strong> </a></li><li id="c204" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated">在HTTP响应中发送所有静态资产的<a class="ae mn" href="https://github.com/pillarjs/send/blob/master/index.js" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"/></a><strong class="jx io"/></li></ul><p id="b190" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Chrome浏览器</strong></p><ul class=""><li id="1a80" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated">每当<strong class="jx io">最后修改的</strong>在缓存的响应中可用时，发送<strong class="jx io"> If-Modified-Since </strong></li><li id="6f10" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated">每当<strong class="jx io"> ETag </strong>在缓存响应中可用时，发送<strong class="jx io"> If-None-Match </strong></li></ul><p id="7bf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终用户将不会从这种方法中获益，除非响应涉及几兆字节或更多。相反，防止不必要的网络调用可以提供更大的好处。</p><p id="29c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为除HTML文件之外的所有资产设置maxAge</strong></p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Express Server for Static Assets</figcaption></figure><p id="c276" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于给定的等于1年的maxAge，浏览器将开始缓存并阻止网络调用。版本化的资源URL避免了过时问题。</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/218355517ebb306febb964c40ddee42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPhwWGkI0iJgmsYQY3GOrA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Browser picks the response from the memory cache</figcaption></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="b9ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> API服务器</strong></p><p id="c14c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了简单起见，我们用<strong class="jx io"> Express Server </strong>来发布API。这个概念适用于SpringBoot、PHP或任何其他框架/语言。</p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Sample Router — Cities</figcaption></figure><pre class="li lj lk ll gt mt mu mv mw aw mx bi"><span id="8e8f" class="my mz in mu b gy na nb l nc nd"><strong class="mu io"><em class="ln">// Vue code fragment</em></strong><em class="ln"><br/>created</em>() {<br/>  <em class="ln">axios.get</em>("/api/cities")<em class="ln">.then</em>((resp) =&gt; {<br/>    <em class="ln">console.log</em>(`Response recieved: ${<em class="ln">resp.</em>status}`, resp);<br/>    this<em class="ln">.cities.push</em>(<em class="ln">resp.</em>data);<br/>  });<br/>},</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/41a03d85febe132c7f9fe2a10f6241e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBW068CztF0DBBF77A9s9w.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Chrome browser network flow</figcaption></figure><p id="ee9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">快递服务器(默认)</strong></p><ul class=""><li id="5788" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated">为所有HTTP响应自动生成弱<a class="ae mn" href="https://www.npmjs.com/package/etag" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> ETag </strong> </a></li><li id="1fcb" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated">除非生成了响应有效负载，否则Express服务器不会自动生成ETag。在生产场景中，只有在进行数据库或第三方系统调用后，有效负载才可用。</li></ul><p id="cbc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Chrome浏览器</strong></p><ul class=""><li id="4f79" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated">每当<strong class="jx io"> ETag </strong>在缓存响应中可用时，发送【如果不匹配则T42】消息</li><li id="8563" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated"><strong class="jx io"> If-None-Match </strong>没有在Axios调用中明确添加，而是默认情况下浏览器发送额外的头</li><li id="5ab7" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated">即使浏览器收到HTTP 304作为响应，Axios调用也会收到HTTP 200以及从浏览器缓存中选取的有效负载</li></ul><p id="2e4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总的来说，这个流程为Web服务器和最终用户提供了有限的好处。对数据库服务器/第三方系统没有任何好处。</p><p id="eced" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要根据陈旧性的接受程度引入<strong class="jx io"> maxAge </strong>(没有一刀切)。这个设置可以减轻后端服务器的负担。</p><pre class="li lj lk ll gt mt mu mv mw aw mx bi"><span id="5105" class="my mz in mu b gy na nb l nc nd"><em class="ln">// sample code <br/>router.get</em>('/cities', (_, res) =&gt; {<br/>  <em class="ln">res.set</em>('Cache-control', 'public, <strong class="mu io">max-age=300</strong>');<br/>  <em class="ln">res.json</em>(cities);<br/>});</span></pre><blockquote class="nk nl nm"><p id="77e4" class="jv jw ln jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated"><strong class="jx io">缓存控制</strong> : <strong class="jx io">无缓存</strong>对于那些在每次使用前都需要服务器重新验证的资源。<br/> <strong class="jx io"> Cache-Control:不存储</strong>不应该缓存的资源。<br/> <strong class="jx io">和ETag或Last-Modified头</strong>可以帮助您更有效地重新验证过期的缓存资源。</p><p id="3825" class="jv jw ln jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated"><strong class="jx io">来源:</strong> <a class="ae mn" href="https://web.dev/http-cache/" rel="noopener ugc nofollow" target="_blank">用HTTP缓存防止不必要的网络请求</a></p></blockquote></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="dffa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">结论</strong></p><p id="d6b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从应用程序开发的一开始，缓存策略就应该包含在您的架构和设计考虑中。当实施适合您的时间和预算时，可以进行实施。希望分享的信息提供一个视角。通过评论分享你的想法或建议。</p><p id="557b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢这个想法，我将在第2部分分享我关于缓存服务器和服务工作者的想法，直到快乐编码。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="2b22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">延伸阅读</strong></p><ul class=""><li id="3e77" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lm kz la lb bi translated"><a class="ae mn" href="https://web.dev/http-cache/" rel="noopener ugc nofollow" target="_blank">“使用HTTP缓存防止不必要的网络请求”，作者杰夫·波斯尼克和伊利亚·格里戈利克</a></li><li id="19cd" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated"><a class="ae mn" href="https://jakearchibald.com/2016/caching-best-practices/" rel="noopener ugc nofollow" target="_blank">“缓存最佳实践”，作者杰克·阿奇博尔德</a></li><li id="5d49" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lm kz la lb bi translated"><a class="ae mn" href="https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching" rel="noopener ugc nofollow" target="_blank">“利用长期缓存”作者Ivan Akulov </a></li></ul><p id="3477" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ln">更多内容请看</em><a class="ae mn" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ln">plain English . io</em></a></p></div></div>    
</body>
</html>