<html>
<head>
<title>LeetCode Algorithm Series: Pascal’s Triangle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法系列:帕斯卡三角</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-series-pascals-triangle-253856454598?source=collection_archive---------7-----------------------#2021-09-10">https://javascript.plainenglish.io/leetcode-algorithm-series-pascals-triangle-253856454598?source=collection_archive---------7-----------------------#2021-09-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cc958ac1f007cfdc942b2ef3b4fa0380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_BegdVVxmkS6Df-ZeIb8w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@pankajpatel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pankaj Patel</a> on <a class="ae jz" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5194" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哈罗。今天的问题来自Leetcode的《顶级采访问题——其他人很容易》T2一章。</p><p id="96ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io">帕斯卡三角</strong>:</p><blockquote class="kz la lb"><p id="043d" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">给定一个整数<code class="fe lf lg lh li b">numRows</code>，返回<strong class="kc io">帕斯卡三角形</strong>的前几个数值。</p><p id="b6a4" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">在<strong class="kc io">帕斯卡三角</strong>中，每个数字都是其正上方的两个数字之和，如下图所示:</p></blockquote><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/d0d4cdee5ca0427eb492ee36ef9668a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/0*xqskgpWKfibuVdcO.gif"/></div></figure><p id="efb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="lk ll lm ln gt lo li lp lq aw lr bi"><span id="25cc" class="ls lt in li b gy lu lv l lw lx"><strong class="li io">Input:</strong> numRows = 5<br/><strong class="li io">Output:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><span id="e305" class="ls lt in li b gy ly lv l lw lx"><strong class="li io">Input:</strong> numRows = 1<br/><strong class="li io">Output:</strong> [[1]]</span></pre><p id="ef13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从这些示例中可以看出，我将返回一个数组数组。每个数组代表三角形中的一行，每个后续数组在前一个数组的基础上生成。我意识到我需要在<strong class="kc io"> for-loop </strong>内部有一个<strong class="kc io"> for-loop </strong>，因为我需要根据需要创建的行的数量来迭代一组次数，并且我需要再次迭代代表一行的数组，以便生成下一行。</p><p id="751f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是每一行的计算方法。因为第一个数字和最后一个数字始终是1，所以我使用零来确保在转到下一行时加到1的数字。</p><pre class="lk ll lm ln gt lo li lp lq aw lr bi"><span id="6e5b" class="ls lt in li b gy lu lv l lw lx">row1: 0 1 0 =&gt; 0 + 1, 1 + 0<br/>row2: 0 1 1 0 =&gt; 0 + 1, 1 + 1, 1 + 0<br/>row3: 0 1 2 1 0 =&gt; 0 + 1, 1 + 2, 2 + 1, 1 + 0<br/>row4: 0 1 3 3 1 0 =&gt; 0 + 1, 1 + 3, 3 + 3, 3 + 1, 1 + 0<br/>row5: 0 1 4 6 4 1 0</span></pre><p id="993f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我有了这个模式下来，它只是一个简单的过程，写如何条件逻辑取决于什么元素的数组我是在。首先，我需要建立一个结果数组。由于存在numRows总是大于或等于1的约束，因此我可以自动将结果数组中的[[1]]作为第一行。知道还需要添加多少行后，这就开始了我的第一个<strong class="kc io"> for-loop </strong>，numRows -1是我的限制，因为我的计数器从0开始计数。在第一个循环中，我建立了另一个名为<strong class="kc io">行</strong>的数组，这将是所创建的新行，然后将该行推入我的最终结果数组。创建新行将使用第二个<strong class="kc io"> for-loop </strong>通过访问结果数组当前行中的数字来完成。这也是为什么我需要我的第一个<strong class="kc io"> for-loop </strong>计数器从0开始，因为数组是零索引的。</p><p id="f4bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了创建一个新行，我基本上检查了，如果我所在的元素之前的元素是未定义的，那么这就是数组的起始元素，我会向其中添加0，并将总和推入到我的新行中。同样，如果计数器与当前行的最后一个索引匹配，这意味着我在数组中的最后一个元素上，我将向其中添加0，并将总和推入新行。对于中间的任何元素，我只需将它与以下元素值相加，然后将总和推入新数组。</p><p id="cf3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我必须添加的唯一额外的条件逻辑是，如果数组的当前行中只有1个元素，其中前一个和后一个元素都没有定义，那么我会将它的值+ 0推两次。回想起来，在进入for循环之前，我可能设置了两个不同的条件语句，如果numRows = 1，则返回[[1]]，如果numRows = 2，则返回[[1]，[1，1]]。这将允许我消除对条件逻辑语句的需求。</p><p id="640f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是我完成的代码:</p><pre class="lk ll lm ln gt lo li lp lq aw lr bi"><span id="66ba" class="ls lt in li b gy lu lv l lw lx">var generate = function(numRows) {<br/>  let result = [[1]]</span><span id="1724" class="ls lt in li b gy ly lv l lw lx">  for (let i = 0; i &lt; numRows-1; i++) {<br/>    row = [];<br/>        <br/>    for(let j = 0; j &lt; result[i].length; j++) {<br/>      if (result[i][j-1] === undefined &amp;&amp; result[i][j+1] === undefined) {<br/>          row.push(0 + result[i][j])<br/>          row.push(result[i][j] + 0)<br/>      } else if (result[i][j-1] === undefined) {<br/>          row.push(0 + result[i][j])<br/>          row.push(result[i][j] + result[i][j+1])<br/>      } else if (j === result[i].length - 1) {<br/>          row.push(0 + result[i][j])<br/>      } else {<br/>          row.push(result[i][j] + result[i][j+1])<br/>      }<br/>    }<br/>        <br/>    result.push(row)<br/>  }<br/>    <br/>  return result<br/>};</span></pre><p id="bd0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样做的时间复杂度是O(n ),因为我有一个for循环在另一个for循环中运行。<strong class="kc io"> </strong>在LeetCode上运行这个，运行时间是<strong class="kc io"> 72ms </strong>，比提交的<strong class="kc io"> 70.73% </strong>要好。</p><p id="6342" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有一个不同的方法来解决这个问题，或者你是如何解决这个算法的，我很乐意听到我的代码如何改进。如果你正在与它斗争，我希望这有助于澄清它！</p><p id="11ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请关注未来更多的LeetCode解决方案！</p><p id="9060" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">LeetCode系列:</p><blockquote class="kz la lb"><p id="c22e" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">1.<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复的</a> <br/> 2。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca" rel="noopener">合并排序后的数组</a> <br/> 3。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-height-checker-2cb703879529" rel="noopener">高度检查器</a> <br/> 4。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-palindrome-3cd94c4b00cc" rel="noopener">有效回文</a> <br/> 5。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-happy-number-1bdea90dde7" rel="noopener">快乐数字</a> <br/> 6。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7" rel="noopener">最长常用前缀</a>7<br/>。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-climbing-stairs-c308255dcb9e" rel="noopener">爬楼梯</a> <br/> 8。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7" rel="noopener">有效括号</a> <br/> 9。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-pascals-triangle-253856454598" rel="noopener">帕斯卡三角形</a> <br/> 10。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-maximum-subarray-776252f61ea0" rel="noopener">最大子阵列</a></p></blockquote><p id="b751" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>