<html>
<head>
<title>Build Your Own React-like Library From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始构建自己的类似React的库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-react-like-lib-from-scrach-b54878a12c3d?source=collection_archive---------5-----------------------#2021-04-14">https://javascript.plainenglish.io/build-a-react-like-lib-from-scrach-b54878a12c3d?source=collection_archive---------5-----------------------#2021-04-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f5ce5482f67da6cc32d56d2cb6614bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UhTH5KGa1DmSVRkI.jpeg"/></div></div></figure><h2 id="9a0d" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">反应</h2><p id="4f38" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">几乎每个软件开发者或多或少都知道React。甚至一些后端开发者或者机器学习开发者——甚至一些非开发者。是的，很好的图书馆，优雅，有前途。每一个前端开发者都在谈论它的API，它的优化，它的内部机制。</p><h2 id="f01b" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">内在机制</h2><p id="4fbc" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">内部机制是最重要的部分，但如何理解它们呢？阅读React源代码当然是一个选择，但可能会感到力不从心。那么，我们是否会从一个读过所有源代码的人那里读到一些摘要呢？我想知道我们要读多少文摘才能完全理解。所以，我的建议是自己建立React！</p><h2 id="d783" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">建立你自己的反应</h2><p id="3ca7" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">听起来很疯狂？可能就一点点。我们只需要编写一些必要的部分，就可以让一个微小的程序工作——仅此而已。你可以尝试自己打造自己感兴趣的部分。如果你不知道React是如何工作的，也不知道如何构建一个React，你可以跟我来。我的源代码可以在这里找到:</p><div class="lm ln gp gr lo lp"><a href="https://github.com/postor/build-react-like-lib-from-scrach" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd io gy z fp lu fr fs lv fu fw im bi translated">post or/build-react-like-lib-from-scrach</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk">手撸 react 框架 | build react-like from scrach lib 目录下一共 200 行代码，功能不多，旨在方便大家理解视图框架的机制 | 200 line of codes under lib folder…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">github.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md jt lp"/></div></div></a></div><h2 id="4a63" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">第一步。渲染组件</h2><p id="1315" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">假设我们有这样一个组件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="076c" class="jv jw in mj b gy mn mo l mp mq">&lt;p&gt;hello world<br/>  &lt;span style={{color:'red'}}&gt;!&lt;/span&gt;<br/>&lt;/p&gt;</span></pre><p id="d983" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">它是JSX格式的，所以在React中，代码应该是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="01d0" class="jv jw in mj b gy mn mo l mp mq">React.createElement('p',null,'hello world',<br/>  React.createElement('span',{style:{color:'red'}},'!')<br/>)</span></pre><p id="e4f7" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">我不方便。我只是用了一个D类来代替，所以我需要使用<code class="fe mw mx my mj b">new</code>关键字。而且我用固定键<code class="fe mw mx my mj b">children</code>把孩子换成道具参数。因此，组件的定义和用法应该是这样的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d7f4" class="jv jw in mj b gy mn mo l mp mq">import { D, render } from '../lib'</span><span id="918d" class="jv jw in mj b gy mz mo l mp mq">let el = document.createElement('div')<br/>document.body.append(el)</span><span id="e54f" class="jv jw in mj b gy mz mo l mp mq">render(el, new D('p', {<br/>  children: [<br/>    'hello world',<br/>    new D('span', {<br/>      children: '!',<br/>      style: { color: 'red' }<br/>    })<br/>  ]<br/>}))</span></pre><p id="7b28" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">我们预计它会这样呈现:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d4ad07010a4233e54e8dbf712df52f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*BHPLGAb6CWH1eJMnBFyuKw.png"/></div></figure><p id="3c41" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">所以，我们只需要递归地将D实例转换成元素，并将它们附加到DOM树中。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="19d9" class="jv jw in mj b gy mn mo l mp mq">// lib/d.js</span><span id="89a6" class="jv jw in mj b gy mz mo l mp mq">export class D {<br/>  ...<br/>  init(parent) {<br/>    this.parent = parent<br/>    if (!this.component) {<br/>      // text<br/>      this.el = document.createTextNode(this.props.children)<br/>    } else if (typeof this.component == 'string') {<br/>      // html element <br/>      this.el = document.createElement(this.component)<br/>      let { children, ...rest } = this.props<br/>      assignProps(this.el, rest)<br/>      this.children = normalizeDArr(children)<br/>    } else {<br/>      // component<br/>      setREACT_LIKE_CUR_COMPONENT(this)<br/>      setREACT_LIKE_CUR_COMPONENT_STATEI(0)<br/>      this.children = normalizeDArr(this.component(this.props))<br/>    }<br/>    // append to DOM tree<br/>    if (this.el) this.parent.append(this.el)<br/>    // init children recursively<br/>    this.children.forEach(x =&gt; x.init(this.el || this.parent))<br/>  }<br/>  ...<br/>}</span></pre><p id="4d14" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">如果您检查我的代码并运行<code class="fe mw mx my mj b">npm run dev1</code>，您可以得到以下结果:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/32bd345849b69f71482789d44caaa604.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/0*nxQ4yMxg2U87NMLP.jpg"/></div></figure><p id="e350" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">这在某种程度上代表了虚拟DOM，每个HTML元素都绑定了一个D实例。</p><h2 id="d120" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">第二步。用状态渲染</h2><p id="7c00" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们现在逐字地或者用包含相同值的变量来呈现<code class="fe mw mx my mj b">hello world</code>。然后，我们唯一需要做的就是存储它。<code class="fe mw mx my mj b">useState</code>在数组中存储数据。</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/ffbbc3d9f653e74d752e9964daecdc5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ic1YyI9UWZ6V8I7O.png"/></div></div></figure><p id="bac9" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">当调用<code class="fe mw mx my mj b">useState</code>和状态数组的相应索引时，你需要知道哪个组件正在渲染。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ac6c" class="jv jw in mj b gy mn mo l mp mq">// lib/hooks.js<br/>export function useState(initalValue) {<br/>  let d = getREACT_LIKE_CUR_COMPONENT() // <strong class="mj io">get component</strong><br/>  let i = getREACT_LIKE_CUR_COMPONENT_STATEI() // <strong class="mj io">get index</strong><br/>  if (d.states[i] === undefined) d.states[i] = initalValue<br/>  let v = d.states[i]<br/>  setREACT_LIKE_CUR_COMPONENT_STATEI(i + 1)</span><span id="d0d4" class="jv jw in mj b gy mz mo l mp mq">  return [v, v1 =&gt; {<br/>    d.states[i] = v1<br/>    d.updateState()<br/>  }]<br/>}</span></pre><p id="ac1b" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated"><code class="fe mw mx my mj b">useState</code>在<code class="fe mw mx my mj b">App</code>组件内部被调用。所以在调用<code class="fe mw mx my mj b">App</code>组件之前，我们需要存储<code class="fe mw mx my mj b">component</code>并将状态数组<code class="fe mw mx my mj b">index</code>重置为<code class="fe mw mx my mj b">0</code>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3ef9" class="jv jw in mj b gy mn mo l mp mq">// lib/d.js<br/>export class D {<br/>  constructor(component, props = {}) {<br/>    ...<br/>    this.states = []<br/>    ...<br/>  }</span><span id="6c19" class="jv jw in mj b gy mz mo l mp mq">  init(parent) {<br/>    ...<br/>      // render component<br/>      setREACT_LIKE_CUR_COMPONENT(this)<br/>      setREACT_LIKE_CUR_COMPONENT_STATEI(0)<br/>      this.children = normalizeDArr(this.component(this.props))<br/>    ...<br/>  }<br/>}</span></pre><p id="b4fc" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">现在，您可以使用<code class="fe mw mx my mj b">useState</code>并在render中使用该状态。</p><h2 id="6bf2" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">第三步。处理事件</h2><p id="0af9" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">React事件是全局管理的，因此我们用委托来模拟它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="63a2" class="jv jw in mj b gy mn mo l mp mq">// lib/event.js<br/>const EVENT_TYPES = ['click']<br/>// <strong class="mj io">delegate from mount point</strong><br/>export function listen(el) {<br/>  return EVENT_TYPES.map(eventType =&gt; {<br/>    let listener = e =&gt; {<br/>      let key = 'on' + capitalize(eventType)<br/>      bubble(e.target, e, key)<br/>    }<br/>    el.addEventListener(eventType, listener)<br/>  })<br/>}</span><span id="1c9d" class="jv jw in mj b gy mz mo l mp mq">// <strong class="mj io">bubble event until it's handled</strong><br/>function bubble(el, e, key) {<br/>  if (!el) return<br/>  if (el[key]) return el[key](e)<br/>  bubble(el.parentElement, e, key)<br/>}</span></pre><p id="ad54" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">然后将<code class="fe mw mx my mj b">onClick</code>道具添加到按钮:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2a96" class="jv jw in mj b gy mn mo l mp mq">// step2/App.js</span><span id="5eb2" class="jv jw in mj b gy mz mo l mp mq">import { D, useState } from "../lib"</span><span id="e07f" class="jv jw in mj b gy mz mo l mp mq">const App = () =&gt; {<br/>  let [i, setI] = useState(0)<br/>  let [str, setStr] = useState('hello counter!')<br/>  return [<br/>    str,<br/>    new D('div', {<br/>      children: [<br/>        new D('button', {<br/>          children: '-',<br/>          // <strong class="mj io">onClick assigned to element as prop</strong><br/>          onClick: () =&gt; setI(i - 1)<br/>        }),<br/>        i + '',<br/>        new D('button', {<br/>          children: '+',<br/>          // <strong class="mj io">onClick assigned to element as prop</strong><br/>          onClick: () =&gt; setI(i + 1)<br/>        })<br/>      ]<br/>    })<br/>  ]<br/>}</span><span id="d435" class="jv jw in mj b gy mz mo l mp mq">export default App</span></pre><p id="c5af" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">React与其说是一个反应器，不如说是一个调度器，那么它如何合并状态/属性变化并同时处理它们呢？这里我用了<code class="fe mw mx my mj b">Promise.resolve</code>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c4c3" class="jv jw in mj b gy mn mo l mp mq">// lib/d.js<br/>export class D {<br/>  ...<br/>  updateState() {<br/>    this.stateChangeCount++<br/>    // <strong class="mj io">wait for changes to merge</strong><br/>    Promise.resolve().then(() =&gt; {<br/>      if (!this.stateChangeCount) return<br/>      this.stateChangeCount = 0<br/>      if (this.el) {<br/>        let { children, ...rest } = this.props<br/>        assignProps(this.el, rest)<br/>        if (!this.component) {<br/>          return this.el.data = children<br/>        }<br/>      }<br/>      let children = this.getChildren(this.props)<br/>      ...<br/>  }<br/>  ...<br/>}</span></pre><p id="af7f" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated">这不是一个很难的问题，对不对？如果你用我的代码运行<code class="fe mw mx my mj b">npm run dev</code>，你会得到这个结果。试着点击按钮。</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8d631715b202049bd06c5b7094b59a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*M7fXsRpuxAnkYnZ12DvUJQ.png"/></div></figure><h2 id="1bc0" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">重要的一点</h2><p id="dbc0" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">React可以做更多的事情。例如，如果某些渲染花费太多时间，React可以将渲染延迟到下一帧，这样就不会出现无响应的站点。它还可以进行列表比较、转换、暂停等等。但是你不能指望200行代码做这么多。这只是一个制作类似React的库的指南和底层React机制的简单解释。</p><p id="cc38" class="pw-post-body-paragraph kr ks in kt b ku mr kw kx ky ms la lb ke mt ld le ki mu lg lh km mv lj lk ll ig bi translated"><em class="ne">更多内容尽在</em><a class="ae nf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>