<html>
<head>
<title>How to add Unit Testing to Express using Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Jest来表达单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-unit-testing-to-express-using-jest-6f7746f66c65?source=collection_archive---------10-----------------------#2021-09-01">https://javascript.plainenglish.io/how-to-add-unit-testing-to-express-using-jest-6f7746f66c65?source=collection_archive---------10-----------------------#2021-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2c1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向您的Express应用程序添加单元测试比您想象的要容易</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/09875ee8454ea37a1dec946ae50fd436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5JQTv-h6NbMNugjp.jpg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo Illustration by David Fekke</figcaption></figure><p id="905c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lb">原发布于</em><a class="ae lc" href="https://fek.io/blog/how-to-add-unit-testing-to-express-using-jest/" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://fek . io</em></a><em class="lb">。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="a7c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论你是在做测试驱动开发(TDD ),还是只是在寻找一种方法将自动化测试添加到你的<a class="ae lc" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> express </a>应用程序中，使用许多不同的单元测试框架都可以很容易地完成。对于Node.js，我使用了许多不同的测试框架。Node的一个好处是在测试时不缺少选项。</p><p id="6300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我更喜欢使用的测试框架是<a class="ae lc" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>，但它不是对express应用程序进行单元测试的要求。Jest非常受React开发人员的欢迎，但是它可以用于任何JavaScript应用程序。</p><p id="098e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢使用Jest，因为除了拥有运行单元测试所需的所有工具之外，它还可以检查代码覆盖率。</p><h1 id="2943" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">编写可测试的代码</h1><p id="d6a3" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">TDD的好处之一是帮助开发人员编写更松散耦合的代码，这不仅使代码更容易测试，而且使代码更可重用。</p><p id="d3f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Express遵循基于路由签名响应请求的基本结构，即:</p><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="b9ac" class="mn lg iq mj b gy mo mp l mq mr">app.get('/users/report', function(req, res) {<br/>    res.render('userreport', { title: 'Users Report' });<br/>});</span></pre><p id="e27a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将处理程序代码分解成它自己的函数，然后在路由中使用该处理程序，这是一个很好的做法。</p><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="78a3" class="mn lg iq mj b gy mo mp l mq mr">function userReportHandler(req, res) {<br/>    res.render('userreport', { title: 'Users Report' });<br/>}<br/><br/>app.get('/users/report', userReportHandler);</span></pre><p id="d549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不仅使express代码更加有组织，现在我们只测试处理程序，而不必运行express。</p><h1 id="288b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加笑话</h1><p id="e594" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">要将Jest添加到您的应用程序中，我们可以在应用程序目录的根目录下运行以下命令；</p><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="5737" class="mn lg iq mj b gy mo mp l mq mr">&gt; npm i jest --save-dev</span></pre><p id="99be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将把Jest工具安装到我们的node_modules文件夹中。现在jest已经安装好了，让我们修改我们的<code class="fe ms mt mu mj b">package.json</code>文件的<code class="fe ms mt mu mj b">scripts</code>部分，在<code class="fe ms mt mu mj b">test</code>属性中运行Jest。在我们的<code class="fe ms mt mu mj b">scripts</code>部分，它应该看起来像下面这样；</p><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="9a60" class="mn lg iq mj b gy mo mp l mq mr">"scripts": {<br/>    "test": "node --experimental-vm-modules node_modules/.bin/jest --coverage",<br/>    "start": "node &lt;name_of_mainjs_file&gt;"<br/>},</span></pre><p id="1c1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们快速看一下这个命令在做什么。我们告诉<code class="fe ms mt mu mj b">Node</code>在<code class="fe ms mt mu mj b">node_modules/.bin/jest</code>位置运行jest命令。这进而运行jest-cli。我们还运行了一个标志<code class="fe ms mt mu mj b">--experimental-vm-modules</code>,允许我们运行ESModule导入/导出语法。我们还使用jest的<code class="fe ms mt mu mj b">--coverage</code>标志来获取代码覆盖率报告，让我们知道单元测试覆盖了我们代码的多少百分比。</p><h1 id="30ae" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">快速应用示例</h1><p id="8d45" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">出于这个例子的目的，我将创建一个简单的Express应用程序，它有两条路线。一个作为主页运行，有一个路由<code class="fe ms mt mu mj b">/</code>，另一个有一个路由<code class="fe ms mt mu mj b">/hello</code>，有一个输入参数<code class="fe ms mt mu mj b">:name</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv le l"/></div></figure><p id="61fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以将一个名为<code class="fe ms mt mu mj b">__tests__</code>的文件夹添加到我们的项目中。Jest会自动查找这个目录中的任何JavaScript或TypeScript文件。</p><p id="93d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们创建第一个测试之前，让我们使用下面的命令将<code class="fe ms mt mu mj b">supertest</code>添加到我们的项目中；</p><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="6ea6" class="mn lg iq mj b gy mo mp l mq mr">npm i supertest --save-dev</span></pre><p id="760f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Supertest用于模拟我们的Express服务器，因此我们不必运行HTTP服务器来测试我们的路由。</p><h1 id="5700" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">单元测试</h1><p id="c5a7" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">让我们创建一个单元测试来测试我们的路由处理器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv le l"/></div></figure><p id="8ebe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的两个路由处理程序都在<code class="fe ms mt mu mj b">res</code>对象上使用send函数，所以我创建了一个简单的模拟响应对象，它复制了Express response对象在实际应用程序中使用它时会做的事情。在这种情况下，<code class="fe ms mt mu mj b">send</code>只是回显我们传入到<code class="fe ms mt mu mj b">text</code>属性中的任何内容。</p><p id="fa01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的两个单元测试中，我使用Jest的<code class="fe ms mt mu mj b">expect</code>函数来比较我们在<code class="fe ms mt mu mj b">toEqual</code>函数中的预期结果。如果匹配，两个测试都将通过。</p><p id="17d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用<code class="fe ms mt mu mj b">supertest</code>添加另一个测试套件来测试路由。我们将创建一个名为<code class="fe ms mt mu mj b">routes.t.js</code>的新文件来测试实际路线。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv le l"/></div></figure><p id="281e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe ms mt mu mj b">supertest</code>，我们可以看到这些测试比我们的Express应用程序所做的更彻底、更准确。在上面的测试套件中，我们使用<code class="fe ms mt mu mj b">supertest</code>来运行特定的路线。我们还可以查看特定的express属性，以确保应用程序返回预期的结果。</p><p id="f421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在所有三个单元测试中，我们使用<code class="fe ms mt mu mj b">expect</code>来检查我们是否有正确的标题结果、statusCode和text。</p><h1 id="3711" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">运行我们的测试</h1><p id="370d" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了测试我们的单元测试，我们所要做的就是在我们的命令行中运行<code class="fe ms mt mu mj b">npm test</code>。</p><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="2fd2" class="mn lg iq mj b gy mo mp l mq mr">&gt; npm test<br/><br/>&gt; expresstest@1.0.0 test<br/>&gt; node --experimental-vm-modules node_modules/.bin/jest --coverage<br/><br/>(node:56591) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time<br/>(Use `node --trace-warnings ...` to show where the warning was created)<br/> PASS  __tests__/routes.t.js<br/> PASS  __tests__/handlers.t.js<br/>------------|---------|----------|---------|---------|-------------------<br/>File        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s<br/>------------|---------|----------|---------|---------|-------------------<br/>All files   |     100 |       50 |     100 |     100 |<br/> default.js |     100 |       50 |     100 |     100 | 7<br/> main.js    |     100 |      100 |     100 |     100 |<br/>------------|---------|----------|---------|---------|-------------------<br/><br/>Test Suites: 2 passed, 2 total<br/>Tests:       5 passed, 5 total<br/>Snapshots:   0 total<br/>Time:        0.782 s, estimated 1 s</span></pre><h1 id="c1a1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="0dcc" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">从上面的例子中你可以看到，向你的express应用程序添加单元测试实际上是非常容易的。</p><p id="d03f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的一个前同事在他的隔间里有下面的标语；测试，测试，测试，一旦你认为你完成了，再测试一次。单元测试只是代码质量保证的一个小方面，但是如果与CI/CD一起正确使用，它将帮助您在bug进入测试环境之前就发现它们。</p><div class="mw mx gp gr my mz"><a href="https://github.com/davidfekke/expresstest" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">GitHub - davidfekke/expresstest</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">在GitHub上创建一个帐户，为davidfekke/expresstest开发做贡献。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kv mz"/></div></div></a></div><p id="1776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lb">更多内容看</em><a class="ae lc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="lb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>