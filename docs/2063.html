<html>
<head>
<title>Role Based Access Control using express-session in a Node.js app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js应用程序中使用快速会话的基于角色的访问控制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/role-based-access-control-using-express-session-in-a-node-js-app-7b91dd303269?source=collection_archive---------0-----------------------#2021-05-02">https://javascript.plainenglish.io/role-based-access-control-using-express-session-in-a-node-js-app-7b91dd303269?source=collection_archive---------0-----------------------#2021-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e0759ba432af2a9f488900e8ca8d2b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9J7hVHHnPeQyJovmQ64duw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">This picture is free for commercial use from <a class="ae jz" href="https://pixabay.com/de/photos/tastatur-h%c3%a4nde-hacker-hacken-4356763/" rel="noopener ugc nofollow" target="_blank">pixabay</a></figcaption></figure><p id="a6ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我提到了几个月前创建的一个应用程序。</p><p id="180e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个预约系统，玩家可以在不同的地点预约冰球训练，教练可以确认参加训练课程，俱乐部经理可以组织训练课程，并向玩家收取预约训练的费用。</p><p id="4f78" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在我的<a class="ae jz" href="https://github.com/prottlaender/bookingsystem" rel="noopener ugc nofollow" target="_blank"> GitHub账号</a>上看到代码，并在我的博客<a class="ae jz" href="https://digitaldocblog.com/singleblog?article=9" rel="noopener ugc nofollow" target="_blank"> Digitaldocblog </a>上以用户手册的方式阅读详细的应用描述。</p><p id="f72f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的预订系统中，我在我的应用程序中给用户不同的角色，根据他们的角色，用户有不同的授权。例如<em class="ky">管理员</em>比普通的<em class="ky">玩家</em>或<em class="ky">教练</em>能够访问更敏感的数据和功能。因此，我的应用程序必须知道用户的角色，才能为特定用户分配不同的授权。</p><p id="1590" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">客户端，通常是浏览器，向应用程序发送请求。该应用程序会对请求做出回应，并全权负责确保客户端只能访问为其准备的数据。这个请求和响应游戏是基于HTTP协议的。HTTP是一种无状态的网络协议，请求不能相互关联。每个请求都是孤立的，与以前的请求无关，服务器没有机会识别客户端，因此不知道它们的角色。</p><p id="214d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题可以通过会话和cookies来解决，这意味着会话管理必须在应用程序中实现。应用程序创建会话并存储会话数据，例如请求者在该会话中的角色。会话有一个唯一的标识，应用程序只在cookie中保存该标识。cookie被传输到浏览器并存储在本地。</p><p id="50e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从现在起，浏览器总是将这个cookie与HTTP请求一起发送，从而向应用程序标识自己。应用程序可以检查请求者在存储的会话数据中的角色，并控制适当的访问。</p><h2 id="db64" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">服务器的基本设置</h2><p id="5c95" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">首先，我们需要一个有效的服务器操作系统。我在生产中运行Linux Ubuntu，并在我的博客网站<a class="ae jz" href="https://digitaldocblog.com/home?currpage=1" rel="noopener ugc nofollow" target="_blank"> Digitaldocblog </a>上写了一篇关于生产Linux服务器的<a class="ae jz" href="https://digitaldocblog.com/singleblog?article=10" rel="noopener ugc nofollow" target="_blank">基本设置的文章。因为我要将会话存储在MongoDB中，所以MongoDB必须安装在Linux服务器上。我使用<em class="ky"> MongoDB社区版</em>，但是你也可以安装或升级到<em class="ky"> MongoDB企业版</em>服务器版本。在文章的下半部分，你可以找到如何在你的Linux系统上安装和设置你的<em class="ky"> MongoDB社区版</em>的说明。如果您想阅读原始文档，请访问MongoDB网站，阅读如何为您的操作系统安装</a><a class="ae jz" href="https://docs.mongodb.com/manual/administration/install-community/" rel="noopener ugc nofollow" target="_blank"> MongoDB社区版</a>。</p><p id="ac48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的express应用程序中，我使用了许多外部模块或依赖项，为了使应用程序运行，必须为应用程序安装这些模块或依赖项。在我的<a class="ae jz" href="https://github.com/prottlaender" rel="noopener ugc nofollow" target="_blank"> GitHub账户</a>上的<a class="ae jz" href="https://github.com/prottlaender/bookingsystem" rel="noopener ugc nofollow" target="_blank"> bookingsystem </a>的存储库中，你可以找到<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/package.json" rel="noopener ugc nofollow" target="_blank"> package.json </a>文件，其中包含了所有必要的依赖项。原则上，如果您将这个<em class="ky"> package.json </em>文件放在您的应用程序主目录中，并使用<code class="fe lx ly lz ma b">npm install</code>安装所有依赖项，这就足够了。</p><p id="e0f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，所有模块也可以单独安装</p><p id="8ec7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lx ly lz ma b">npm install &lt;module&gt; --save</code></p><h2 id="d57e" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">会话管理</h2><p id="3276" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我在第一部分讨论了我的应用程序主文件<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>中不同的代码片段。这里的目标是让您了解会话管理基本上是如何实现的。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="96bd" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/><br/>// Load express module and create app<br/>const express = require('express');<br/>const app = express();<br/>// Trust the first Proxy<br/>app.set('trust proxy', 1);<br/>// Load HTTP response header security module<br/>const helmet = require('helmet');<br/>// use secure HTTP headers using helmet with every request<br/>app.use(<br/>  helmet({<br/>      frameguard: {<br/>        action: "deny",<br/>      },<br/>      referrerPolicy: {<br/>        policy: "no-referrer",<br/>    },<br/>    })<br/>  );<br/>// Load envy module to manage environment variables<br/>const envy = require('envy');<br/>const env = envy();<br/><br/>// Set environment variables<br/>const port = env.port<br/>const host = env.host<br/>const mongodbpath = env.mongodbpath<br/>const sessionsecret = env.sessionsecret<br/>const sessioncookiename = env.sessioncookiename<br/>const sessioncookiecollection = env.sessioncookiecollection<br/><br/>// Load server side session and cookie module<br/>const session = require('express-session');<br/>// Load mongodb session storage module<br/>const connectMdbSession = require('connect-mongodb-session');<br/>// Create MongoDB session store object<br/>const MongoDBStore = connectMdbSession(session)<br/>// Create new session store in mongodb<br/>const store = new MongoDBStore({<br/>  uri: mongodbpath,<br/>  collection: sessioncookiecollection<br/>});<br/>// Catch errors in case session store creation fails<br/>store.on('error', function(error) {<br/>  console.log(`error store session in session store: ${error.message}`);<br/>});<br/>// Use session to create session and session cookie<br/>app.use(session({<br/>  secret: sessionsecret,<br/>  name: sessioncookiename,<br/>  store: store,<br/>  resave: false,<br/>  saveUninitialized: false,<br/>  // set cookie to 1 week maxAge<br/>  cookie: {<br/>    maxAge: 1000 * 60 * 60 * 24 * 7,<br/>    sameSite: true<br/>  },<br/>}));<br/><br/>... //further code not taken into account at this point</span></pre><p id="4113" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我使用<a class="ae jz" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> Express-js </a> Web应用程序框架创建一个服务器应用程序。因此，我用<code class="fe lx ly lz ma b">require()</code>函数加载Express-js模块，并将<code class="fe lx ly lz ma b">express()</code>函数存储在常量<em class="ky"> app </em>中。因为我的应用程序运行在反向代理服务器后面，所以我将应用程序设置为信任第一个代理服务器。然后我加载<a class="ae jz" href="https://www.npmjs.com/package/helmet" rel="noopener ugc nofollow" target="_blank">头盔模块</a>以在我的应用程序中使用安全响应头。我配置所有的浏览器都应该拒绝iFrames，并且我的应用程序不会在响应头中设置referrer。</p><p id="bd5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在应用程序中使用<a class="ae jz" href="https://www.npmjs.com/package/envy" rel="noopener ugc nofollow" target="_blank"> envy模块</a>来管理环境变量。因此，我用<code class="fe lx ly lz ma b">require()</code>加载模块，并将<code class="fe lx ly lz ma b">envy()</code>函数存储在常量<em class="ky"> env </em>中。有了envy，你可以在你的<em class="ky">中定义你的环境变量。env </em>和<em class="ky">env . example</em>文件。这些文件必须存储在envy文档中解释的应用程序主目录中。</p><p id="292f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我的预订应用程序是一个运行在生产中的web服务器上的真正的web应用程序，出于安全原因，我不能讨论真正的环境变量。因此，让我们看看这是如何工作的，并做一个例子<em class="ky">。env </em>文件。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="7727" class="kz la in ma b gy mj mk l ml mm">// .env<br/><br/>port=myport<br/>host=myhost<br/>mongodbpath=myexamplemongodbpath<br/>sessionsecret=myexamplesecret<br/>sessioncookiename=booking<br/>sessioncookiecollection=col_sessions</span></pre><p id="09d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些变量在我的<em class="ky">中有不同的值。env </em>文件。在上面的<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>文件中，我用<code class="fe lx ly lz ma b">env = envy()</code>为envy函数定义了常量<em class="ky"> env </em>。然后我可以访问我的<em class="ky">中定义的环境变量。env </em>文件与<em class="ky"> env。&lt;变量&gt;变量</em>。我为每个变量定义了常数，并从。带<code class="fe lx ly lz ma b">env.&lt;variable&gt;</code>的env文件。这些常量现在可以用作代码中的值。</p><p id="6eed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我用<code class="fe lx ly lz ma b">require()</code>函数加载了<a class="ae jz" href="https://www.npmjs.com/package/express-session" rel="noopener ugc nofollow" target="_blank"> express-session </a>模块和<a class="ae jz" href="https://www.npmjs.com/package/connect-mongodb-session" rel="noopener ugc nofollow" target="_blank">connect-MongoDB-session</a>模块。存储在常量<em class="ky">会话</em>中的会话模块接管会话和cookie管理的全部控制。</p><p id="0235" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">常量<em class="ky"> connectMdbSession </em>模块中存储的<em class="ky">connect-MongoDB-session</em>基本负责在数据库中存储会话。这就是为什么我们在代码中将<em class="ky"> session </em>作为参数传递，并为常量<em class="ky"> MongoDBstore </em>赋值。</p><p id="e9df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lx ly lz ma b">const MongoDBstore = connectMdbSession(session)</code></p><p id="bcf8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我用<code class="fe lx ly lz ma b">new MongoDBStore</code>创建了一个新的商店对象。在这里，我传递了mongodb路径的uri和应该存储会话的集合T21。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="9604" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/>...<br/><br/>const store = new MongoDBStore({<br/>  uri: mongodbpath,<br/>  collection: sessioncookiecollection<br/>});<br/><br/>...</span></pre><p id="81a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以这种方式初始化的store对象包含了在我的MongoDB数据库中成功存储会话对象所需的所有参数。</p><p id="ed5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们定义了会话对象的存储之后，我们负责会话对象本身。</p><p id="29e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用<code class="fe lx ly lz ma b">app.use(session( {... cookie: {...} }))</code>我创建了一个带有各种选项的会话对象。会话对象将随每个请求一起创建，并且还包含一个cookie对象。我传递<code class="fe lx ly lz ma b">cookie: {...}</code>的值，然后传递其他选项，如<code class="fe lx ly lz ma b">secret: sessionsecret</code>，用<code class="fe lx ly lz ma b">name: sessioncookiename</code>传递会话对象名，用<code class="fe lx ly lz ma b">store: store</code>传递会话对象应该存储的位置。此外，会话对象具有选项<code class="fe lx ly lz ma b">saveUninitialized: false</code>和<code class="fe lx ly lz ma b">resave: false</code>。</p><p id="f689" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当<em class="ky">保存未初始化</em>选项设置为<em class="ky">假</em>时，只要会话<strong class="kc io">未初始化</strong>，会话对象就<em class="ky">不存储</em>到存储器中。选项<code class="fe lx ly lz ma b">resave: false</code>强制会话不会<em class="ky">保存回</em>存储器，即使会话已经<strong class="kc io">初始化</strong>。所以我们必须明白<em class="ky">初始化</em>和<em class="ky">未初始化</em>是什么意思。这个必须解释。</p><p id="6775" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">浏览器向应用程序发送请求。更准确地说，浏览器将请求发送到应用程序中定义的端点。端点在应用程序中定义了一个路径，该路径对HTTP请求做出反应并执行代码。根据HTTP方法GET或POST，端点期望请求者要求文档返回(GET)或者请求者想要向应用程序发送数据(POST)。</p><p id="b671" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的例子中，浏览器应该发送一个GET请求来获取<em class="ky"> home </em>端点。端点呈现HTML模板<em class="ky">索引</em>并将HTML发送回浏览器。那么请求就完成了。所以这个从<em class="ky">请求</em>开始到<em class="ky">响应</em>结束的过程就是请求的<em class="ky">运行时间。</em></p><p id="7e88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的代码片段中，您可以看到在<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>文件中有两个GET端点，一个用于<em class="ky"> home </em>路线，另一个用于<em class="ky"> register </em>路线。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="7029" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/><br/>... //further code not taken into account at this point<br/><br/>// GET home route only for anonym users. Authenticated users redirected to dashboard<br/>app.get('/', redirectDashboard, (req, res) =&gt; {<br/>	<br/>  console.log(req.url);<br/>  console.log(req.session.id);<br/>  console.log(req.session);<br/><br/>  res.render('index', {<br/>      title: 'User Login Page',<br/>    });<br/><br/>});<br/><br/>// GET register route only for anonym users. Authenticated users redirected to dashboard<br/>app.get('/register', redirectDashboard, (req, res) =&gt; {<br/>  <br/>  console.log(req.url);<br/>  console.log(req.session.id);<br/>  console.log(req.session);<br/><br/>  res.render('register', {<br/>      title: 'User Registration Page',<br/>    });<br/>});<br/><br/>... //further code not taken into account at this point</span></pre><p id="eba8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>文件中带有<code class="fe lx ly lz ma b">app.use (session({ ... }))</code>的代码确保每次请求都会生成一个会话对象。只要会话对象在请求运行时没有改变，就会为每个请求创建一个单独的会话，并且有自己的会话ID。选项<code class="fe lx ly lz ma b">saveUninitialized: false</code>确保会话对象不会被存储到数据库中。以这种方式创建的每个会话对象都是未初始化的。</p><p id="e89e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们在控制台上记录每条路线的<em class="ky">路径</em>、<em class="ky">会话ID </em>和<em class="ky">会话对象</em>时，您可以在控制台上看到<em class="ky">起始</em>路线和<em class="ky">寄存器</em>路线的以下输出。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="9103" class="kz la in ma b gy mj mk l ml mm">/<br/>BmbE8RVoTRcPP9nUnBm5JLE1w1mQiNyt<br/>Session {<br/>  cookie: {<br/>    path: '/',<br/>    _expires: 2021-04-24T04:27:04.265Z,<br/>    originalMaxAge: 604800000,<br/>    httpOnly: true,<br/>    sameSite: true<br/>  }<br/>}<br/><br/>/register<br/>awlPO-KpyVM51Gp6UAoeXGGmRWo-QFtP<br/>Session {<br/>  cookie: {<br/>    path: '/',<br/>    _expires: 2021-04-24T05:54:57.439Z,<br/>    originalMaxAge: 604800000,<br/>    httpOnly: true,<br/>    sameSite: true<br/>  }<br/>}</span></pre><p id="5dd4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用户成功登录时，我的应用程序的代码通过添加数据对象在请求运行时更改会话对象。我将在下一章详细解释这些代码，但是现在知道这些就足够了。因此，我们通过一个用户的登录如下。</p><p id="cd65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所述，浏览器向<em class="ky"> home </em> route发送GET请求，然后呈现<em class="ky"> index </em>模板，并将带有登录表单的HTML页面发送回浏览器。在这个GET请求的运行期间，创建了一个会话对象，但是会话对象没有改变。我们在上面已经看到了这一点。</p><p id="6044" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后用户在登录表单中输入<em class="ky">邮箱</em>和<em class="ky">密码</em>，点击提交。通过这个提交，浏览器向POST端点<em class="ky"> /loginusers </em>发送一个POST请求，并且再次为这个POST请求生成一个会话对象。在POST请求的运行期间，代码检查传输的凭证是否正确。如果凭证正确，则生成具有用户数据的数据对象，并将其附加到会话对象。这里，会话对象在POST请求的运行期间被更改。用POST请求创建的现有会话现在在那个时刻被初始化。由于选项<code class="fe lx ly lz ma b">saveUninitialized: false</code>，该会话对象被存储到数据库存储中。当我们使用工具<a class="ae jz" href="https://www.mongodb.com/products/compass" rel="noopener ugc nofollow" target="_blank"> MongoDB Compass </a>查看数据库存储时，我们看到整个会话对象已经保存到了<em class="ky"> colsessions </em>集合中，其中包括包含用户所需数据的数据对象。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="ab gu cl mn"><img src="../Images/35e396a3882508ef1ea49cb1eed9dc4d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oFgdwhgJgCFZ8DLnTEsA8Q.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Session Object stored in the Database</figcaption></figure><p id="42b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在会话初始化之后，由POST端点调用的代码重定向请求并将一个新的GET请求发送到<em class="ky"> /dashboard </em>路由。带有<code class="fe lx ly lz ma b">app.use(session({ ... }))</code>的代码被再次调用，但是现在存储中存在一个初始化的会话。由于选项<code class="fe lx ly lz ma b">resave: false</code>，现有的会话对象将不会随着每个进一步的请求而被更新和拖动。</p><p id="3961" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们在控制台上记录每条路由的<em class="ky">路径</em>、<em class="ky">会话ID </em>和<em class="ky">会话对象</em>时，您会在控制台的输出中看到这一点。当GET请求被发送到<em class="ky"> home </em> route时，控制台上的第一个输出被创建。然后，在用户单击submit POST route<em class="ky">/loginusers</em>之后，调用第二个输出，并创建一个新的会话对象。您可以从不同的会话id中看到这一点。在这个POST请求的运行期间，数据对象被添加到初始化会话的会话对象中。然后，调用第三个输出，GET route <em class="ky"> /dashboard </em>，我们看到相同的会话对象ID，但是会话对象现在包含带有用户数据的数据对象。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="f125" class="kz la in ma b gy mj mk l ml mm">/<br/>TEAZITdX7nLWBDc8uOk2HhXIiMZO7W-4<br/>Session {<br/>  cookie: {<br/>    path: '/',<br/>    _expires: 2021-05-02T07:21:13.236Z,<br/>    originalMaxAge: 604800000,<br/>    httpOnly: true,<br/>    sameSite: true<br/>  }<br/>}<br/><br/>/loginusers<br/>gVlKut3bdEMiDHnK455FGjCi6YbPTBuZ<br/>Session {<br/>  cookie: {<br/>    path: '/',<br/>    _expires: 2021-05-02T07:21:35.202Z,<br/>    originalMaxAge: 604800000,<br/>    httpOnly: true,<br/>    sameSite: true<br/>  }<br/>}<br/><br/>/dashboard<br/>gVlKut3bdEMiDHnK455FGjCi6YbPTBuZ<br/>Session {<br/>  cookie: {<br/>    path: '/',<br/>    _expires: 2021-05-02T07:21:35.468Z,<br/>    originalMaxAge: 604800000,<br/>    httpOnly: true,<br/>    secure: null,<br/>    domain: null,<br/>    sameSite: true<br/>  },<br/>  data: {<br/>    userId: 5f716b7439777365c18639f1,<br/>    status: 'active',<br/>    name: 'Oskar David',<br/>    lastname: 'Rottländer',<br/>    email: 'oskar@test.com',<br/>    role: 'player',<br/>    age: 17,<br/>    cat: 'youth'<br/>  }<br/>}</span></pre><p id="bd8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之，会话管理的工作方式如下:每个请求都将创建一个会话对象，只有当用户登录时，会话对象才会保存在数据库中(<em class="ky">save initialized:false</em>)。只要用户登录，会话对象就不会改变，数据库中的会话对象数据也不会更新(<em class="ky"> resave: false </em>)。</p><p id="e7ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是饼干会怎么样呢？这将在下一章解释。</p><h2 id="d133" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">用户登录</h2><p id="b4fd" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">当会话被初始化时，包含会话ID的cookie被存储在请求者的浏览器中。对于每个请求，浏览器都会提供cookie来验证请求者。为了验证请求者，调用代码<code class="fe lx ly lz ma b">app.use(session({...}))</code>并将浏览器发送的会话ID与会话存储中存储的会话ID进行比较。如果会话ID匹配，则包括数据对象的会话对象被附加到请求对象，以使应用程序能够访问数据对象。在应用程序中，我们现在可以访问带有<em class="ky"> req.session.data. &lt;属性&gt; </em>的数据对象的任何属性。因此，我们现在可以通过使用<em class="ky"> req.session.data.role </em>访问请求者的角色来实现基于角色的授权，并在代码的条件中使用该信息来根据请求者的角色控制访问。</p><p id="d5de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是让我们从请求者或用户的登录开始，因为从现在开始我称之为请求者。为了让用户能够登录，他或她必须首先调用<strong class="kc io">登录页面</strong>，该页面可以通过调用家庭端点来显示。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="ae95" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/><br/>... // Code not discussed here<br/><br/>// Redirect GET requests from authenticated users to dashboard<br/>const redirectDashboard = (req, res, next) =&gt; {<br/>  if (req.session.data) {<br/>    res.redirect('/dashboard')<br/><br/>  } else {<br/>    next()<br/><br/>  }<br/>}<br/><br/>... // Code not discussed here<br/><br/>// GET home route only for anonym users. Authenticated users redirected to dashboard<br/><br/>app.get('/', redirectDashboard, (req, res) =&gt; {<br/><br/>  res.render('index', {<br/>      title: 'User Login Page',<br/>    });<br/><br/>});<br/><br/>... // Code not discussed here</span></pre><p id="4e9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你在上面的代码中看到的，我首先定义了中间件函数<em class="ky"> redirectDashboard </em>。该中间件确保只有未登录的用户才能看到登录页面。如果我们查看中间件函数的代码，我们可以看到在If条件中使用了<em class="ky"> req.session.data </em>来检查数据对象是否附加到当前会话对象。在<strong class="kc io"> if-condition为真</strong>的情况下，用户登录并且请求被重定向到仪表板，但是在<strong class="kc io"> if-condition为假</strong>的情况下，用户不登录并且调用<em class="ky"> next() </em>函数。</p><p id="da1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GET端点具有到归属路由的<em class="ky">路由路径</em>。当用户访问我的预订应用程序的主页时，GET HTTP请求要求home <em class="ky"> routingPath </em>。中间件函数<em class="ky"> redirectDashboard </em>放在<em class="ky"> routingHandler </em>函数的前面。如果用户没有登录<em class="ky"> routingHandler </em>函数，呈现HTML模板<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/views/index.pug" rel="noopener ugc nofollow" target="_blank"> index.pug </a>并将HTML发送回用户，或者更准确地说，发送到用户的浏览器。</p><p id="b999" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止一切顺利。我们现在想象一个未登录的用户，看到他或她面前的索引页面，现在想要使用他或她的<em class="ky">电子邮件</em>和<em class="ky">密码</em>登录。</p><p id="1b9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所述，索引页面只不过是一个用于输入电子邮件地址和密码的登录表单。当我们查看<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/views/index.pug" rel="noopener ugc nofollow" target="_blank"> index.pug </a>文件时，我们看到表单动作属性定义了当点击提交按钮时，表单数据<code class="fe lx ly lz ma b">email</code>和<code class="fe lx ly lz ma b">password</code>将使用POST方法发送到表单处理程序<code class="fe lx ly lz ma b">/loginusers</code>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="1255" class="kz la in ma b gy mj mk l ml mm">...<br/><br/>form#loginForm.col.s12(<br/>		method='post', <br/>		action='/loginusers'<br/>		)<br/><br/>		input.validate(<br/>			type='email', <br/>			name='email', <br/>			autocomplete='username' <br/>			required<br/>			)<br/>		...<br/><br/>		input.validate(<br/>			type='password', <br/>			name='password', <br/>			autocomplete='current-password' <br/>			required<br/>			)<br/>		...<br/><br/>button.btn.waves-effect.waves-light(<br/>		type='submit', <br/>		form='loginForm'<br/>		)<br/>...</span></pre><p id="6338" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意</strong>:为了理解输入标签的<em class="ky">自动完成</em>属性，我推荐阅读<a class="ae jz" href="https://www.chromium.org/developers/design-documents/form-styles-that-chromium-understands" rel="noopener ugc nofollow" target="_blank"> Chromium项目</a>的文档。大多数浏览器都有密码管理功能，并在您提供主密码来解锁本地密码存储后自动填写凭据。通过在登录表单以及用户注册表单或更改密码表单中使用这些自动完成属性，您可以使用这些<em class="ky">自动完成</em>功能来帮助浏览器更好地识别这些表单。</p><p id="637d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用户在HTML表单中输入他或她的<em class="ky">电子邮件</em>和<em class="ky">密码</em>并点击提交按钮后，<strong class="kc io">请求体</strong>包含<em class="ky">表单数据</em>属性<em class="ky">电子邮件</em>和<em class="ky">密码</em>。然后，通过HTTPS向我的<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>文件中定义的POST端点<code class="fe lx ly lz ma b">/loginusers</code>发送一个POST HTTP请求(见上文)。</p><p id="f2ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下图中，你可以看到chrome浏览器的开发者工具中网络分析的输出。这里你可以看到<em class="ky">表单数据</em>在<strong class="kc io">浏览器端</strong>没有加密，但是你也可以看到POST请求URL <code class="fe lx ly lz ma b">/loginusers</code>是HTTPS。这意味着当浏览器向服务器发送POST请求时，这些数据在从浏览器传输到服务器的过程中会使用SSL/TLS进行加密。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="ab gu cl mn"><img src="../Images/badb9acfbbffb0cf4288854f008d463f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0FLMFuwSWD9hhF5pkMWxXA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">POST request and Form Data</figcaption></figure><p id="e558" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io">服务器端</strong>我们有一个代理服务器后面的web应用程序，它监听发往POST端点<code class="fe lx ly lz ma b">/loginusers</code>的HTTP请求。这个POST端点是一个匿名的POST路由，这意味着<em class="ky"> routingHandler </em>控制器功能仅限于未登录的用户。这是有意义的，因为已经登录的用户不能使用登录功能。因此已经登录的用户不能向这个POST端点发送数据。该检查由中间件函数<em class="ky"> verifyAnonym </em>控制，该函数位于<em class="ky"> routingHandler </em>之前。</p><p id="48ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以让我们看看<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>中的相关代码片段。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="7c62" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/><br/>...<br/><br/>// Load db controllers and db models<br/>const userController = require('./database/controllers/userC');<br/><br/>...<br/><br/>// Verify POST requests only for anonym users<br/>const verifyAnonym = (req, res, next) =&gt; {<br/><br/>  if (req.session.data) {<br/>    var message = 'You are not authorized to perform this request because you are already logged-in !';<br/>    res.status(400).redirect('/400badRequest?message='+message);<br/><br/>  } else {<br/>    next()<br/><br/>  }<br/>}<br/><br/>...<br/><br/>// Anonym POST Route<br/>// Login user available for anonym only<br/>app.post('/loginusers', verifyAnonym, userController.loginUser)<br/><br/>...<br/><br/>// GET bad request route render 400badRequest<br/>app.get('/400badRequest', (req, res) =&gt; {<br/> <br/>  res.status(400).render('400badRequest', {<br/>    title: 'Bad Request',<br/>    code: 400,<br/>    status: 'Bad Request',<br/>    message: req.query.message,<br/>  })<br/>})<br/><br/>...</span></pre><p id="8c9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在代码的开头，我使用<code class="fe lx ly lz ma b">require</code>方法将常量<em class="ky"> userController </em>引用到用户控制器文件<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/controllers/userC.js" rel="noopener ugc nofollow" target="_blank"> userC.js </a>。在<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/controllers/userC.js" rel="noopener ugc nofollow" target="_blank"> userC.js </a>中，定义了所有的用户功能来控制用户相关的操作。</p><p id="7495" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意</strong>:当你查看<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/controllers/userC.js" rel="noopener ugc nofollow" target="_blank"> userC.js </a>文件时，你会看到我们使用<code class="fe lx ly lz ma b">module.exports = {...}</code>导出模块。使用这个指令，我们实际上导出了一个具有各种属性的对象，这些属性的值就是函数。所以用<code class="fe lx ly lz ma b">module.exports = { loginUser: function(...) ...}</code>我们导出包含属性<em class="ky"> loginUser </em>的对象，该属性包含一个函数作为值。因此，当我们使用<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>文件中的<code class="fe lx ly lz ma b">require()</code>函数引用常量<em class="ky"> userController </em>时，我们将完整的导出对象及其所有属性存储到<em class="ky"> userController </em>常量中。现在我们可以使用<em class="ky"> userController从<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/controllers/userC.js" rel="noopener ugc nofollow" target="_blank"> userC.js </a>文件中访问导出对象的任何属性。&lt;属性&gt;属性</em>。因为属性实际上是函数，所以我们用这个语句来调用这些函数。</p><p id="fd29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<em class="ky">中，verifyAnonym </em>函数<em class="ky"> req.session.data </em>在if-condition中用于检查数据对象是否附加到当前会话对象。在<strong class="kc io"> if-condition为真</strong>的情况下，用户已经登录并被重定向到Bad Request GET端点<code class="fe lx ly lz ma b">/400badRequest</code>，这是我的应用程序中向用户显示出错的标准路径。用户可以使用请求参数<code class="fe lx ly lz ma b">?message=+message</code>从附加到请求的消息中看到哪里出错了。如果<strong class="kc io">的if条件为假</strong>，则用户未登录，<em class="ky"> next() </em>函数将请求转发给<em class="ky"> routingHandler </em>控制器函数，后者使用<em class="ky">user controller . loginuser</em>调用<code class="fe lx ly lz ma b">loginUser</code>函数。该函数可以访问<strong class="kc io">请求体</strong>的属性<em class="ky"> email </em>和<em class="ky"> password </em>以及<em class="ky"> req.body.email </em>和<em class="ky"> req.body.password </em>。</p><p id="6adf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么我们来看看<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/controllers/userC.js" rel="noopener ugc nofollow" target="_blank"> userC.js </a>文件中的相关代码片段。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="2e0c" class="kz la in ma b gy mj mk l ml mm">// database/controllers/userC.js<br/><br/>// load the bcryptjs module<br/>const bcrypt = require('bcryptjs');<br/>// define hash saltrounds for password hashing<br/>const saltRounds = 10;<br/>// load the relevant Prototype Objects (exported from the models)<br/>...<br/><br/>const User = require('../models/userM');<br/><br/>...<br/><br/>loginUser: function (req, res) {<br/><br/>    const inputemail = req.body.email<br/>    const email = inputemail.toLowerCase()<br/><br/>    console.log(req.url);<br/>    console.log(req.session.id);<br/>    console.log(req.session);<br/><br/>    try {<br/><br/>      User.findOne({ email: email }, async function(error, user) {<br/>        if (!user) {<br/>          var message = 'User not found. Login not possible';<br/>          res.status(400).redirect('/400badRequest?message='+message);<br/><br/>        } else {<br/>          if (user._status !== 'active') {<br/>            var message = 'Login not possible. Await User to be activated';<br/>            res.status(400).redirect('/400badRequest?message='+message);<br/><br/>          } else {<br/>              if (bcrypt.compareSync(req.body.password, user.password)) {<br/><br/>                var yearInMs = 3.15576e+10;<br/>                var currentDate = new Date ()<br/>                var currentDateMs = currentDate.getTime()<br/>                var birthDateMs = user.birthdate.getTime()<br/>                var age = Math.floor((currentDateMs - birthDateMs) / yearInMs)<br/><br/>                if (age &lt; 18) {<br/>                  var cat = 'youth'<br/>                } else {<br/>                  var cat = 'adult'<br/>                };<br/><br/>                var userData = {<br/>                  userId: user._id,<br/>                  status: user._status,<br/>                  name: user.name,<br/>                  lastname: user.lastname,<br/>                  email: user.email,<br/>                  role: user.role,<br/>                  age: age,<br/>                  cat: cat,<br/>                }<br/><br/>                req.session.data = userData<br/><br/>                res.status(200).redirect('/dashboard')<br/><br/>              } else {<br/>                var message = 'Login not possible. Wrong User password';<br/>                res.status(400).redirect('/400badRequest?message='+message);<br/>              }<br/>          }<br/>        }<br/>      })<br/><br/>    } catch (error) {<br/>      // if user query fail call default error function<br/>      next(error)<br/><br/>    }<br/>  // End Module<br/>  },<br/><br/>...</span></pre><p id="46be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了对用户进行身份验证，<em class="ky">登录用户</em>函数必须在用户数据库中找到一个用户，该用户的电子邮件地址与浏览器发送并由应用程序附加到请求正文的电子邮件地址相同。</p><p id="29b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果通过电子邮件找到用户，该功能必须检查传输的密码是否与数据库中存储的该用户的密码相匹配。</p><p id="fa06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果电子邮件和密码匹配，则用户通过身份验证，登录成功；否则，登录失败。</p><p id="7c7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">密码从不以纯文本保存。因此我使用<a class="ae jz" href="https://www.npmjs.com/package/bcryptjs" rel="noopener ugc nofollow" target="_blank"> bcryptjs模块</a>来散列密码。bcryptjs模块通过<code class="fe lx ly lz ma b">require()</code>函数加载到代码中，并分配给常量<em class="ky"> bcrypt </em>。我们将常量<em class="ky"> saltRounds </em>设置为值10。这是bcrypt散列函数中所谓的成本因子，它控制bcrypt计算一个bcrypt散列需要多少时间。将成本系数增加1会使时间加倍，并且bycrypt需要散列的时间越多，暴力破解存储的密码就越困难。</p><p id="666a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我使用<code class="fe lx ly lz ma b">require()</code>函数从<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/models/userM.js" rel="noopener ugc nofollow" target="_blank"> userM.js </a>加载用户模型，并给常量<em class="ky"> User </em>赋值。说到这里，我必须解释一下背景。为此，我们还需要查看一下<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/models/userM.js" rel="noopener ugc nofollow" target="_blank"> userM.js </a>文件。</p><p id="8789" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注</strong>:我用MongoDB做数据库，用Mongoose做数据建模。如果您查看文件<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/models/userM.js" rel="noopener ugc nofollow" target="_blank"> userM.js </a>，您会看到一个用户对象是用函数<em class="ky"> new Schema() </em>创建的，并保存在变量<em class="ky"> userSchema </em>中。这个<em class="ky"> userSchema </em>对象描述了一个用户及其所有属性。</p><p id="c833" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在文件的最后，<em class="ky">mongose . model()</em>函数用于将<em class="ky"> userSchema </em>引用到my MongoDB中的集合<em class="ky"> colusers </em>。该引用被分配给变量<em class="ky">用户</em>，并使用函数<em class="ky"> module.exports() </em>导出。使用<em class="ky">用户</em>，我可以访问用户模型，这意味着我的数据库中的所有用户对象和属性都存储在<em class="ky"> colusers </em>集合中。为了让我可以在我的<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/controllers/userC.js" rel="noopener ugc nofollow" target="_blank"> userC.js </a>文件的代码中使用这个访问，我用<code class="fe lx ly lz ma b">require()</code>函数加载了<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/database/models/userM.js" rel="noopener ugc nofollow" target="_blank"> userM.js </a>，并给常量<em class="ky"> User </em>赋值。</p><p id="1b50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，我现在可以使用Mongoose函数从我的<em class="ky"> colusers </em>集合中查询用户数据。当我们试图用某个电子邮件查找用户时，这正是我们用<em class="ky"> User.findOne() </em>所做的事情。</p><p id="fd24" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实际的<strong class="kc io">用户认证</strong>现在发生在<em class="ky"> userFindOne() </em>函数中。</p><p id="30bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们运行<em class="ky"> User.findOne() </em>时，我们检查没有导致成功认证的标准。</p><ol class=""><li id="6b54" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx mt mu mv mw bi translated"><strong class="kc io">未找到用户</strong>:我们正在寻找与已提交的电子邮件相匹配的用户对象。如果在该电子邮件中找不到用户对象，或者找到的用户不活动，请求将被重定向到400badRequest路由。如果我们已经找到了一个活动用户，那么提交的密码字符串将使用bcrypt进行哈希处理，并与保存的密码进行比较。</li><li id="288d" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">密码错误</strong>:如果密码比对不成功，则提交的密码错误，请求也被重定向到400badRequest路由。</li></ol><p id="24f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意</strong> : <em class="ky"> User.findOne() </em>有一个查询对象<code class="fe lx ly lz ma b">{email: email}</code>和一个回调函数<code class="fe lx ly lz ma b">async function(error, user {...})</code>作为参数。当异步函数在数据库中找到一个具有该电子邮件的用户时，该异步函数返回一个具有所有用户属性的用户对象，并将该对象存储到<em class="ky">用户</em>参数中。在异步函数的范围内，我现在可以使用<em class="ky"> user访问用户属性。&lt;属性&gt; </em>。</p><p id="e4ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只有在找到具有电子邮件的用户并且提交的密码正确的情况下，认证才是成功的。</p><p id="0520" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果用户成功通过身份验证，则根据当前日期和用户的出生日期计算用户的类别。然后创建一个<em class="ky">用户数据</em>对象，其中存储了各种用户属性。然后将用户数据对象的数据附加到会话中。更准确地说，对象<em class="ky">数据</em>被附加到具有<em class="ky"> req.session.data </em>的会话，并且值<em class="ky"> userData </em>被赋值。现在会话已经初始化，会话对象存储在MongoDB的<em class="ky"> colsessions </em>集合中。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="ab gu cl mn"><img src="../Images/35e396a3882508ef1ea49cb1eed9dc4d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oFgdwhgJgCFZ8DLnTEsA8Q.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Session object stored in the Database</figcaption></figure><p id="aab2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后将<strong class="kc io">响应</strong>发送回浏览器。</p><p id="f3b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个响应中，浏览器被指示调用一个GET请求到GET端点<code class="fe lx ly lz ma b">/dashboard</code>。使用<code class="fe lx ly lz ma b">res.status(200).redirect('/dashboard')</code>发送响应。在响应头中，您可以看到使用<code class="fe lx ly lz ma b">set-cookie</code>指令在用户浏览器中设置了名为<em class="ky"> booking </em>的cookie。cookie只包含已经用我们在<code class="fe lx ly lz ma b">app.use(session( {... cookie: {...} }))</code>中提供的<em class="ky">秘密</em>签名和加密的会话ID。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="ab gu cl mn"><img src="../Images/b832d74e27382be7e9af619762bce317.png" data-original-src="https://miro.medium.com/v2/format:webp/1*MQM5skWfk9xumvUNq7PJHA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Response HTTP Header with set-cookie</figcaption></figure><p id="5b0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后浏览器向端点发送GET请求<code class="fe lx ly lz ma b">/dashboard</code>。让我们再看一下<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>文件。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="0fa0" class="kz la in ma b gy mj mk l ml mm">// booking.js <br/><br/>...<br/><br/>// Redirect GET requests from not authenticated users to login<br/>const redirectLogin = (req, res, next) =&gt; {<br/>  if (!req.session.data) {<br/>    res.redirect('/')<br/><br/>  } else {<br/>    next()<br/><br/>  }<br/>}<br/><br/>...<br/><br/>// GET dashboard route only for authenticated users. Anonym users redirected to home<br/>app.get('/dashboard', redirectLogin, async (req, res) =&gt; {<br/><br/>  // Check admin authorization and render admin_dashboard<br/>  if (req.session.data.role == 'admin') {<br/><br/>    const user_query = User.find( {} ).sort({lastname: 1, name: 1});<br/>    var users = await user_query.exec();<br/><br/>    const training_query = Training.find( {} ).sort({date: 'desc'});<br/>    var trainings = await training_query.exec();<br/><br/>    const location_query = Location.find( {} ).sort({location: 'desc'});<br/>    var locations = await location_query.exec();<br/><br/>    const booking_query = Booking.find( {} ).sort({_booktrainingdate: 'desc'});<br/>    var bookings = await booking_query.exec();<br/><br/>    const invoice_query = Invoice.find( {} ).sort({invoicedate: 'desc'});<br/>    var invoices = await invoice_query.exec();<br/><br/>    res.status(200).render('admin_dashboard', {<br/>      title: 'Admin Dashboard Page',<br/>      name: req.session.data.name,<br/>      lastname: req.session.data.lastname,<br/>      role: req.session.data.role,<br/>      data_users: users,<br/>      data_trainings: trainings,<br/>      data_locations: locations,<br/>      data_bookings: bookings,<br/>      data_invoices: invoices,<br/><br/>      });<br/><br/>  // Check player authorization and render player_dashboard<br/>  } else if (req.session.data.role == 'player') {<br/><br/>    var currentDate = new Date();<br/>    console.log('current date: ' +currentDate);<br/><br/>    const availabletraining_query = Training.find( { _status: 'active', date: { $gte: currentDate } } ).sort({ date: 'desc' });<br/>    var availabletrainings = await availabletraining_query.exec();<br/><br/>    const booking_query = Booking.find( { _bookuseremail: req.session.data.email, _bookparticipation: { $ne: 'invoice' } } ).sort({ _booktrainingdate: 'desc' });<br/>    var bookings = await booking_query.exec();<br/><br/>    const myuser_query = User.findOne( { email: req.session.data.email } );<br/>    var myuser = await myuser_query.exec();<br/><br/>    const invoice_query = Invoice.find( {invoiceemail: req.session.data.email} ).sort({invoicedate: 'desc'});<br/>    var invoices = await invoice_query .exec();<br/><br/>    res.status(200).render('player_dashboard', {<br/>      title: 'Player Dashboard Page',<br/>      name: req.session.data.name,<br/>      lastname: req.session.data.lastname,<br/>      role: req.session.data.role,<br/>      email: req.session.data.email,<br/>      data_availabletrainings: availabletrainings,<br/>      data_bookings: bookings,<br/>      data_myuser: myuser,<br/>      data_myinvoices: invoices,<br/>      });<br/><br/>  // Check coach authorization and render coach_dashboard<br/>  } else if (req.session.data.role == 'coach') {<br/>   <br/>    var currentDate = new Date().setHours(00, 00, 00);<br/>    console.log('currentDate: ' +currentDate);<br/><br/>    const training_query = Training.find( { _status: 'active', date: { $gte: currentDate } } ).sort({ date: 'asc' });<br/>    var trainings = await training_query.exec();<br/><br/>    res.status(200).render('coach_dashboard', {<br/>      title: 'Coach Dashboard Page',<br/>      name: req.session.data.name,<br/>      lastname: req.session.data.lastname,<br/>      role: req.session.data.role,<br/>      data_trainings: trainings,<br/>      });<br/><br/>  } else {<br/>    // if user not authorized as admin, player or coach end request and send response<br/>    var message = 'You are not authorized. Access prohibited';<br/>    res.status(400).redirect('/400badRequest?message='+message);<br/>  }<br/><br/>});<br/><br/>...</span></pre><p id="d813" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你在上面的代码中看到的，我们首先定义了中间件函数<em class="ky"> redirectLogin </em>。该中间件确保只有登录的用户才能看到仪表板页面。在<strong class="kc io"> if-condition为真</strong>的情况下，用户不登录并且请求被重定向到归属路由，但是在<strong class="kc io"> if-condition为假</strong>的情况下，用户登录并且调用<em class="ky"> next() </em>函数。</p><p id="a49b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GET HTTP请求要求仪表板<em class="ky">路由路径</em>。中间件函数<em class="ky"> redirectLogin </em>放在<em class="ky"> routingHandler </em>函数的前面。如果用户没有登录到<em class="ky">重定向登录</em>中间件，则将请求重定向到本地路由。在用户登录的情况下，使用请求对象和响应对象作为参数调用<em class="ky"> routingHandler </em>函数。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="6e7c" class="kz la in ma b gy mj mk l ml mm">app.get('/dashboard', redirectLogin, async (req, res) =&gt; {...})</span></pre><p id="f8b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们在浏览器中查看这个新的GET请求的请求头，我们可以看到cookie与GET请求一起被拖动到端点<code class="fe lx ly lz ma b">/dashboard</code>。从现在开始，每个请求都会发生这种情况，直到会话过期或用户注销。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="ab gu cl mn"><img src="../Images/2a6cab2b74ee6499f143b0c469c8cf0b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*w3cd0sWezlsGbN7XvuMN-A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Request Header GET request with cookie</figcaption></figure><p id="9de8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，在<em class="ky"> routingHandler </em>函数中，我们执行<strong class="kc io">用户授权</strong>检查。if条件使用<em class="ky"> req.session.data.role </em>检查用户角色。根据用户的角色，呈现不同的<em class="ky"> &lt;角色&gt;仪表板</em> HTML模板，并且对于每个角色，不同的HTML被发送回用户的浏览器。</p><p id="5828" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">预先执行各种查询，因为我们需要每个<em class="ky"> &lt;角色&gt;仪表板</em> HTML模板中的角色特定数据。不同查询<code class="fe lx ly lz ma b">find()</code>和<code class="fe lx ly lz ma b">findOne()</code>的返回值仅在其中一个if条件为真的情况下执行。</p><p id="4cdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，在每种情况下，查询的返回值都存储在变量中。如果所有if条件都为假，意味着我们无法在数据库中找到角色类似于<em class="ky">管理员</em>、<em class="ky">玩家</em>或<em class="ky">教练</em>的用户，由于某种原因，请求被重定向到错误请求获取端点<code class="fe lx ly lz ma b">/400badRequest</code>，使用该消息作为该用户未被授权的请求参数。</p><p id="2b51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在每个if条件中，对于每个角色<em class="ky"> admin </em>、<em class="ky"> player </em>或<em class="ky"> coach </em>，我们首先将HTTP status设置为值200，然后使用render方法来呈现各自的HTML模板，从而创建响应对象。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="c70e" class="kz la in ma b gy mj mk l ml mm">res.status(200).render('&lt;role&gt;_dashboard', {...})</span></pre><p id="d0ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在render方法中，我们现在可以选择将具有不同属性的数据对象传输到HTML模板。稍后，我们可以在各自的HTML模板中访问这些数据，并在HTML模板中使用它们。这是如何工作的不是本文的一部分。当然，你可以仔细看看我的GitHub存储库中的模板<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/views/admin_dashboard.pug" rel="noopener ugc nofollow" target="_blank">管理仪表板</a>、<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/views/player_dashboard.pug" rel="noopener ugc nofollow" target="_blank">球员仪表板</a>和<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/views/coach_dashboard.pug" rel="noopener ugc nofollow" target="_blank">教练仪表板</a>，你会立即看到这是如何工作的。</p><h2 id="1a86" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">创建授权</h2><p id="031b" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">正如我在上一部分已经展示的，我使用中间件函数来控制对我的应用程序中的GET和POST端点的访问。因此，这些中间件功能就是授权，你可以在我的<a class="ae jz" href="https://github.com/prottlaender/bookingsystem/blob/master/booking.js" rel="noopener ugc nofollow" target="_blank"> booking.js </a>文件的代码中找到它们。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="4d08" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/><br/>...<br/><br/>// Authorizations<br/>// Redirect GET requests from not authenticated users to login<br/>const redirectLogin = (req, res, next) =&gt; {<br/>  if (!req.session.data) {<br/>    res.redirect('/')<br/><br/>  } else {<br/>    next()<br/><br/>  }<br/>}<br/><br/>// Redirect GET requests from authenticated users to dashboard<br/>const redirectDashboard = (req, res, next) =&gt; {<br/>  if (req.session.data) {<br/>    res.redirect('/dashboard')<br/><br/>  } else {<br/>    next()<br/><br/>  }<br/>}<br/><br/>// Authorize POST requests only for not authenticated users<br/>const verifyAnonym = (req, res, next) =&gt; {<br/>  if (!req.session.data) {<br/>    next()<br/><br/>  } else {<br/>    var message = 'You are already logged-in. You are not authorized to perform this request !';<br/>    res.status(400).redirect('/400badRequest?message='+message);<br/><br/>  }<br/>}<br/><br/>// Authorize POST requests only for anonym and admin users<br/>const verifyAnonymAndAdmin = (req, res, next) =&gt; {<br/>  if (!req.session.data) {<br/>    next()<br/><br/>  } else {<br/><br/>    if (req.session.data.role == 'admin') {<br/>      next()<br/><br/>    } else {<br/>      var message = 'You are no Admin. You are not authorized to perform this request !';<br/>      res.status(400).redirect('/400badRequest?message='+message);<br/><br/>    }<br/><br/>  }<br/>}<br/><br/>// Authorize POST requests only for admin and player users<br/>const verifyAdminAndPlayer = (req, res, next) =&gt; {<br/>  if (req.session.data) {<br/>    if (req.session.data.role == 'admin') {<br/>      next()<br/><br/>    } else if (req.session.data.role == 'player') {<br/>      next()<br/><br/>    } else {<br/>      var message = 'You are no Admin, no Player. You are not authorized to perform this request !';<br/>      res.status(400).redirect('/400badRequest?message='+message);<br/>    }<br/><br/>  } else {<br/>    var message = 'You are not logged-in. You are not authorized to perform this request !';<br/>    res.status(400).redirect('/400badRequest?message='+message);<br/>  }<br/><br/>}<br/><br/>// Authorize POST requests only for admin users<br/>const verifyAdmin = (req, res, next) =&gt; {<br/>  if (req.session.data) {<br/>    if (req.session.data.role == 'admin') {<br/>      next()<br/><br/>    } else {<br/>      var message = 'You are no Admin. You are not authorized to perform this request !';<br/>      res.status(400).redirect('/400badRequest?message='+message);<br/>    }<br/><br/>  } else {<br/>    var message = 'You are not logged-in. You are not authorized to perform this request !';<br/>    res.status(400).redirect('/400badRequest?message='+message);<br/><br/>  }<br/>}<br/><br/>// Authorize POST requests only for player users<br/>const verifyPlayer = (req, res, next) =&gt; {<br/>  if (req.session.data) {<br/>    if (req.session.data.role == 'player') {<br/>      next()<br/><br/>    } else {<br/>      var message = 'You are no Player. You are not authorized to perform this request !';<br/>      res.status(400).redirect('/400badRequest?message='+message);<br/>    }<br/><br/>  } else {<br/>    var message = 'You are not logged-in. You are not authorized to perform this request !';<br/>    res.status(400).redirect('/400badRequest?message='+message);<br/><br/>  }<br/>}<br/><br/>// Authorize POST requests only for coach users<br/>const verifyCoach = (req, res, next) =&gt; {<br/>  if (req.session.data) {<br/>    if (req.session.data.role == 'coach') {<br/>      next()<br/><br/>    } else {<br/>      var message = 'You are no Coach. You are not authorized to perform this request !';<br/>      res.status(400).redirect('/400badRequest?message='+message);<br/><br/>    }<br/><br/>  } else {<br/>    var message = 'You are not logged-in. You are not authorized to perform this request !';<br/>    res.status(400).redirect('/400badRequest?message='+message);<br/><br/>  }<br/>}<br/><br/>...</span></pre><p id="3c4c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我上面已经解释过的，我使用<strong class="kc io">重定向函数</strong>作为中间件来控制对<strong class="kc io">获取端点</strong> <em class="ky"> home </em>、<em class="ky">寄存器</em>和<em class="ky">仪表板</em>的访问。这些中间件功能基本上基于用户是否登录来控制访问。重定向功能<em class="ky"> redirectDashboard </em>仅允许未登录的用户访问<em class="ky"> home </em>端点和<em class="ky"> register </em>端点，而已经登录的用户没有访问权限，如果他们试图访问此处，将被直接重定向到<em class="ky"> dashboard </em>路由。<em class="ky">重定向登录</em>中间件功能仅允许登录用户访问<em class="ky">仪表板</em>路线，而未登录用户被重定向至登录或更好的<em class="ky">主页</em>端点。</p><p id="6a0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了<em class="ky">重定向函数</em>之外，我还使用<strong class="kc io">验证函数</strong>作为中间件来控制对<strong class="kc io">发布端点</strong>的访问。在POST请求的帮助下，数据通过POST端点发送到应用程序。这就是为什么控制允许谁发送数据和不允许谁发送数据尤为重要。我基本上使用5种类型的POST端点。</p><p id="2f44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">匿名帖子结束点</strong>。我这里只有一个终点。<em class="ky"> loginusers </em>端点只能由未登录的用户调用。因此<em class="ky">验证匿名</em>中间件设置在<em class="ky">路由处理程序</em>功能之前，以验证用户是否没有登录。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="01c5" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/>...<br/><br/>// Anonym POST endpoint<br/>// Login user available for anonym only<br/>app.post('/loginusers', verifyAnonym, userController.loginUser)<br/><br/>...</span></pre><p id="bb83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">共享开机自检终点</strong>。非登录用户和管理用户可以调用<em class="ky"> createusers </em>端点。<em class="ky"> verifyAnonymAndAdmin </em>中间件设置在<em class="ky"> routingHandler </em>功能之前，用于验证用户是否未登录，或者登录的用户是否具有<em class="ky"> admin </em>角色。<em class="ky"> updateuseremail </em>和<em class="ky"> setnewuserpassword </em>端点只能由管理员和玩家用户调用。因此<em class="ky">verify adminand layer</em>中间件设置在<em class="ky"> routingHandler </em>功能之前，验证用户是否登录，用户角色是<em class="ky"> admin </em>还是<em class="ky"> player </em>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="0dee" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/>...<br/><br/>// Shared POST endpoints<br/>// Create Users available for anonym and admin<br/>app.post('/createusers', verifyAnonymAndAdmin, birthdateFormatValidation, userController.createUser)<br/><br/>// Update User-Email available for admin and player<br/>app.post('/updateuseremail', verifyAdminAndPlayer, userController.updateUserEmail)<br/><br/>// Update User-Password available for admin and player<br/>app.post('/setnewuserpassword', verifyAdminAndPlayer, userController.setNewUserPassword)<br/><br/>...</span></pre><p id="4a59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">管理开机自检终点</strong>。我这里有19个端点，每个端点只能由管理员用户调用。<em class="ky">验证管理</em>中间件设置在<em class="ky">路由处理程序</em>功能之前，验证用户是否登录，用户角色是否为<em class="ky">管理</em>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="4d09" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/>...<br/><br/>// Admin POST endpoints<br/>// Admin User Management<br/>app.post('/callupdateusers', verifyAdmin, userController.callUpdateUsers)<br/><br/>app.post('/updateuser', verifyAdmin, birthdateFormatValidation, userController.updateUser)<br/><br/>app.post('/terminateusers', verifyAdmin, userController.terminateUser)<br/><br/>app.post('/activateusers', verifyAdmin, userController.activateUser)<br/><br/>app.post('/removeusers', verifyAdmin, userController.removeUser)<br/><br/>// Admin Update Training<br/>app.post('/callupdatetrainings', verifyAdmin, trainingController.callUpdateTrainings)<br/><br/>app.post('/updatetraining', verifyAdmin, trainingController.updateTraining)<br/><br/>// Admin Location Management<br/>app.post('/createlocations', verifyAdmin, locationController.createLocation)<br/><br/>app.post('/callupdatelocations', verifyAdmin, locationController.callUpdateLocations)<br/><br/>app.post('/updatelocation', verifyAdmin, locationController.updateLocation)<br/><br/>app.post('/callcreatetrainings', verifyAdmin, trainingController.callCreateTrainings)<br/><br/>app.post('/createtraining', verifyAdmin, trainingController.createTraining)<br/><br/>// Admin Invoice Management<br/>app.post('/createinvoice', verifyAdmin, invoiceController.createInvoiceUser)<br/><br/>app.post('/callcancelinvoice', verifyAdmin, invoiceController.callCancelInvoice)<br/><br/>app.post('/cancelinvoice', verifyAdmin, invoiceController.cancelInvoice)<br/><br/>app.post('/callpayinvoice', verifyAdmin, invoiceController.callPayInvoice)<br/><br/>app.post('/payinvoice', verifyAdmin, invoiceController.payInvoice)<br/><br/>app.post('/callrepayinvoice', verifyAdmin, invoiceController.callRePayInvoice)<br/><br/>app.post('/repayinvoice', verifyAdmin, invoiceController.rePayInvoice)<br/><br/>...</span></pre><p id="fb2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">玩家发帖结束</strong>。我这里有7个端点，每个端点只能由玩家用户调用。<em class="ky">验证播放器</em>中间件设置在<em class="ky">路由处理程序</em>功能之前，验证用户是否登录，用户角色是否为<em class="ky">播放器</em>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="d143" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/>...<br/><br/>// Player POST endpoints<br/>// Player Booking Management<br/>app.post('/callbooktrainings', verifyPlayer, bookingController.callBookTrainings)<br/><br/>app.post('/booktrainings', verifyPlayer, bookingController.bookTraining)<br/><br/>app.post('/bookingreactivate', verifyPlayer, bookingController.bookingReactivate)<br/><br/>app.post('/callcancelbookings', verifyPlayer, bookingController.callCancelBooking)<br/><br/>app.post('/cancelbookings', verifyPlayer, bookingController.cancelBooking)<br/><br/>// Player User Management<br/>app.post('/callupdatemyuserdata', verifyPlayer, userController.callUpdateMyUserData)<br/><br/>app.post('/updatemyuserdata', verifyPlayer, birthdateFormatValidation, userController.updateMyUserData)<br/><br/>...</span></pre><p id="483e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">蔻驰邮报终点</strong>。我这里有2个端点，每个端点只能由蔻驰用户调用。在<em class="ky"> routingHandler </em>功能之前设置<em class="ky"> verifyCoach </em>中间件，验证用户是否登录，用户角色是否为<em class="ky"> coach </em>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="2fcc" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/>...<br/><br/>// Coach POST endpoints<br/>// Coach Confirmation Management<br/>app.post('/callparticipants', verifyCoach, bookingController.callParticipants)<br/><br/>app.post('/callconfirmpatricipants', verifyCoach, bookingController.callConfirmPatricipants)<br/><br/>...</span></pre><h2 id="ed92" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">用户注销</h2><p id="65bd" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">用户通过点击应用导航中的注销链接，自己发起<strong class="kc io">注销</strong>。这会向应用程序的<code class="fe lx ly lz ma b">/logout</code>端点发送一个GET请求。在此路由定义中，首先使用<code class="fe lx ly lz ma b">req.session.destroy()</code>从数据库中删除会话，然后从浏览器中删除cookie，并使用<code class="fe lx ly lz ma b">res.status(200).clearCookie('booking').redirect()</code>将用户重定向到<em class="ky">200成功站点</em>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="38f3" class="kz la in ma b gy mj mk l ml mm">// booking.js<br/><br/>...<br/><br/>// GET logout route only for authenticated users. Anonym users redirected to home<br/>app.get('/logout', redirectLogin, (req, res) =&gt; {<br/>  req.session.destroy(function(err) {<br/>    if (err) {<br/>      res.send('An err occured: ' +err.message);<br/>    } else {<br/>      var message = 'You have been successfully logged out';<br/>      res.status(200).clearCookie('booking').redirect('/200success?message='+message)<br/>    }<br/>  });<br/>})<br/><br/>...</span></pre><p id="5110" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们找到了。如何在web应用程序中设置基于角色的访问？我希望你已经发现这很有用。谢谢你的阅读。</p><p id="839b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>