<html>
<head>
<title>How to Dispatch an Action to Update a Sibling in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何调度操作来更新React中的同级</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dispatch-an-action-to-update-a-sibling-within-react-e98f5b5041f3?source=collection_archive---------3-----------------------#2021-08-17">https://javascript.plainenglish.io/dispatch-an-action-to-update-a-sibling-within-react-e98f5b5041f3?source=collection_archive---------3-----------------------#2021-08-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e825" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当React收到一个分派时，它会渲染纤程，然后根据属性和状态将更改提交给DOM。</p><p id="7969" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们有一个状态和一个动作位置时，这是非常简单的。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="c4ea" class="kr ks in kn b gy kt ku l kv kw">const Title = () =&gt; {<br/>  cont [count, setCount] = useState(0)<br/>  const onClick = () =&gt; { setCount(1) }<br/>  <br/>  return &lt;div onClick={onClick}&gt;{count}&lt;/div&gt;<br/>}</span></pre><p id="bc6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们的组件树如下所示，并且我们在红点处安装了组件标题。</p><figure class="ki kj kk kl gt ky gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/71ef678ab875dfa4c90451015dbff655.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/format:webp/1*i8haICs-u1LyBRGr_xjYZQ.png"/></div></figure><p id="aef5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然React必须通过根来找出整个渲染的拓扑结构，但上面的调度的效果几乎做到了这一点。</p><h2 id="430d" class="kr ks in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">兄弟姐妹的问题</h2><p id="3fe4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当标题中有一个兄弟姐妹时，或者只是不在同一个分支中时，问题就出现了。你想改变兄弟姐妹的状态。在我们的例子中，我们想从某个地方调用标题中的<code class="fe lx ly lz kn b">setCount</code>。相信我，有时候你想拥有它，即使兄弟姐妹不想分享任何东西:)</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="0836" class="kr ks in kn b gy kt ku l kv kw">const Somewhere = () =&gt; {<br/>  const onClick = () =&gt; { setCount(1) }<br/>  <br/>  return &lt;div onClick={onClick}&gt;{count}&lt;/div&gt;<br/>}</span></pre><ol class=""><li id="a7b2" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">如果某处是Title的孩子，我们会把<code class="fe lx ly lz kn b">setCount</code>作为道具传过去。</li></ol><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="0902" class="kr ks in kn b gy kt ku l kv kw">&lt;Title setCount={setCount} /&gt;</span></pre><p id="2243" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.如果某个地方是Title的父级，或者在Title的兄弟分支中，我们将不能通过<code class="fe lx ly lz kn b">setCount</code>,除非我们能首先从某个地方和Title中找到一个共同的祖先。这就是我们通常所说的提升。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="92f1" class="kr ks in kn b gy kt ku l kv kw">const App = () =&gt; {<br/>  cont [count, setCount] = useState(0)<br/>  const onClick = () =&gt; { setCount(1) }<br/>  <br/>  return (<br/>    &lt;&gt;<br/>      &lt;Title count={count} /&gt;<br/>      &lt;Somewhere setCount={setCount} /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="e645" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本质上，我们现在在App中定义<code class="fe lx ly lz kn b">count</code>，而不是在Title中。</p><p id="3290" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.我们可以把状态存储到一个全局存储器中，然后一切又变得美好起来。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="4e4f" class="kr ks in kn b gy kt ku l kv kw">const Somewhere = () =&gt; {<br/>  const { dispatchCount } = useRedux(...)<br/>}</span></pre><p id="9fa5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我对redux语法不太熟悉，在此致歉。但是实际上，您重新定位了状态，并将其分派到React之外的上下文中。这个世界并不像我想象的那么美好。因为全局策略太危险，无意冒犯，React在内部使用了太多的全局变量。但是这个全球战略，对我来说，首先就违背了拥有道具的整个目的。</p><h2 id="f2eb" class="kr ks in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">与兄弟姐妹交谈的练习</h2><p id="a27a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">好了，我们来看看其他选项。其中常见的一件事就是用一个<code class="fe lx ly lz kn b">useContext</code>来分享国家。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="0f1b" class="kr ks in kn b gy kt ku l kv kw">const App = () =&gt; {<br/>  const [count, setCount] = useState()<br/>  return (<br/>    &lt;Context.Provider value={{count, setCount}}&gt;<br/>      &lt;Title /&gt;<br/>      &lt;Somewhere /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="5e0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，当任何一个孩子调用<code class="fe lx ly lz kn b">setCount</code>时，它应该更新<code class="fe lx ly lz kn b">count</code>，这又会触发对所有孩子使用<code class="fe lx ly lz kn b">useContext</code>的更新浪潮。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="ae64" class="kr ks in kn b gy kt ku l kv kw">const Somewhere = () =&gt; {<br/>  const { setCount } = useContext(Context)<br/>  const onClick = () =&gt; { setCount(1) }<br/>}</span></pre><p id="e5d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这似乎可行。这种方法的唯一问题是成本。</p><figure class="ki kj kk kl gt ky gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/44f8ecf2d753b605c4fce9c1bf02dd54.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*gK3Ozacq-v9p54IhxgK_pA.png"/></div></figure><p id="ca32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象有组件使用这个<code class="fe lx ly lz kn b">Context</code>。最有可能的情况是，当<code class="fe lx ly lz kn b">setCount</code>被触发时，我们得到上面的图片来通知三个位置(如React <code class="fe lx ly lz kn b">propagateContextChange</code>源代码)。</p><p id="04f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我大部分时间想做的就是让一切都保持在原来的位置，但是触发原始组件标题中的<code class="fe lx ly lz kn b">setCount</code>。不是父母，不是我自己，不是全球池。</p><p id="0fb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，React的设计方式是来自<code class="fe lx ly lz kn b">useState</code>的<code class="fe lx ly lz kn b">setCount</code>也绑定到定义它的组件(如React <code class="fe lx ly lz kn b">dispatchAction</code>源代码)。因此，理论上，将<code class="fe lx ly lz kn b">useState</code>转移到其他地方只会让事情变得复杂。</p><h2 id="d6da" class="kr ks in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">提议的解决方案</h2><p id="6ab2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">所以我不想改变<code class="fe lx ly lz kn b">context</code>的值，我只想用它注册一个来自另一个组件的调度函数。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="111c" class="kr ks in kn b gy kt ku l kv kw">const fns = {}<br/>const add = (name, fn) =&gt; { fns[name] = fn }<br/>const dispatch = (name, n) =&gt; { fns[name] &amp;&amp; fns[name](n) }<br/>const RefContext = createContext({ add, dispatch })</span><span id="fafa" class="kr ks in kn b gy mk ku l kv kw">export default RefContext</span></pre><p id="17ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<code class="fe lx ly lz kn b">RefContext</code>被创建，它的任务是保持调度功能。所以你可以在任何地方做下面两条语句。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="4aef" class="kr ks in kn b gy kt ku l kv kw">add('setCount', setCount)<br/>dispatch('setCount', n)</span></pre><p id="de69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了<code class="fe lx ly lz kn b">RefContext</code>，让我们把它用在任何一个孩子身上。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="5bc0" class="kr ks in kn b gy kt ku l kv kw">const Somewhere = () =&gt; {<br/>  const { dispatch } = useContext(RefContext)<br/>  const onClick = () =&gt; { dispatch('setCount', 10) }<br/>  return &lt;div onClick={onClick}&gt;+&lt;/div&gt;<br/>}</span></pre><p id="7a05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在某个地方，我们可以通过定制的<code class="fe lx ly lz kn b">dispatch</code>函数访问<code class="fe lx ly lz kn b">setCount</code>。它不漂亮，但我们可以<code class="fe lx ly lz kn b">setCount</code>到另一个组件。</p><p id="bfa9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还需要源组件来提供调度功能。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="1156" class="kr ks in kn b gy kt ku l kv kw">const Title = () =&gt; {<br/>  cont [count, setCount] = useState(0)<br/>  const { add } = useContext(RefContext)<br/>  useEffect(() =&gt; { add('setCount', setCount) }, []) </span><span id="4a05" class="kr ks in kn b gy mk ku l kv kw">  const onClick = () =&gt; { setCount(1) }<br/>  return &lt;div onClick={onClick}&gt;{count}&lt;/div&gt;<br/>}</span></pre><p id="ed61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向原来的标题组件添加两行，这样我们就可以向池中添加调度函数<code class="fe lx ly lz kn b">setCount</code>。</p><p id="21a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果您转到同级的某个地方，并单击按钮，您可以将标题<code class="fe lx ly lz kn b">count</code>设置为<code class="fe lx ly lz kn b">10</code>。哇哦。这不是很疯狂吗？</p><p id="fe15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您担心内存泄漏，我们可以在设置<code class="fe lx ly lz kn b">setCount</code>时调整<code class="fe lx ly lz kn b">useEffect</code>。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="d383" class="kr ks in kn b gy kt ku l kv kw">useEffect(() =&gt; { <br/>  add('setCount', setCount)<br/>  return () =&gt; {<br/>    add('setCount', null)<br/>  } <br/>}, [])</span></pre><p id="f39e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一些观察结果。</p><p id="e9c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个是上下文值没有改变，你可以把它当作一个引用。不知何故，当我玩这个的时候，我甚至没有添加一个提供者，似乎React可以默认抓取根提供者。</p><p id="afb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个是<code class="fe lx ly lz kn b">useState</code>必须在原来的位置，这正是我想要的:)为什么我要把它放在原来的位置？因为否则它会改变渲染的拓扑结构，就像上面的两个树形图一样。</p><p id="11e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后但同样重要的是，使用这种方法，兄弟可以在树中的任何位置。</p><h2 id="69f4" class="kr ks in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">摘要</h2><p id="fc72" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">背景很重要，我们都知道。但是我们不必把可变的状态存储到它里面，相反，我们可以把它作为一个容器来承载功能，而不需要任何状态变化。如果我们这样做，我们似乎得到了两个世界的最佳选择，用<code class="fe lx ly lz kn b">useContext</code>的广泛覆盖和用<code class="fe lx ly lz kn b">useState</code>的瑞士刀。</p><p id="d4bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">附录—挂钩</strong></p><p id="5848" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也许如果我们把上面的想法变成钩子。我们可以为源<code class="fe lx ly lz kn b">useSharedSource</code>准备一个，在这里它接受<code class="fe lx ly lz kn b">Context</code>，并存储状态和调度函数。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="5544" class="kr ks in kn b gy kt ku l kv kw">const <!-- -->useSharedSource<!-- --> = (initialState, RefContext) =&gt; {<br/>  const [state, dispatch] = useState(initialState)<br/>  const { current } = useContext(RefContext)<br/>  current.state = state<br/>  current.dispatch = dispatch<br/>}</span></pre><p id="eb1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以为消费者设置另一个<code class="fe lx ly lz kn b">useSharedState</code>。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="9ead" class="kr ks in kn b gy kt ku l kv kw">const useSharedState = (RefContext) =&gt; {<br/>  const { current } = useContext(RefContext)<br/>  return [current.state, current.dispatch]<br/>}</span></pre><p id="eef0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是背景。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="2b5d" class="kr ks in kn b gy kt ku l kv kw">const RefContext = createContext({ current: null })</span></pre><p id="c3bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也许这能导致多功能的<code class="fe lx ly lz kn b">useState</code>。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="173c" class="kr ks in kn b gy kt ku l kv kw">const useState = (initialState, RefContext) =&gt; {<br/>  const [state, dispatch] = useState(initialState)<br/>  if (RefContext === undefined) return [state, dispatch]<br/>  <br/>  const { current } = useContext(Context)<br/>  return [current.state, current.dispatch]<br/>}</span></pre><p id="bccb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果给定了一个<code class="fe lx ly lz kn b">RefContext</code>，它就使用代理版本，否则就恢复到经典的<code class="fe lx ly lz kn b">useState</code>。这里我打破了在两个钩子之间有一个<code class="fe lx ly lz kn b">if</code>的规则，但是我认为<code class="fe lx ly lz kn b">useContext</code>是例外的，因为它只读取内存。</p><p id="bf90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ml">更多内容请看</em><a class="ae mm" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ml">plain English . io</em></strong></a></p></div></div>    
</body>
</html>