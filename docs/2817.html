<html>
<head>
<title>The Guide to Kickstarting Backend TypeScript Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后端类型脚本开发入门指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-guide-to-kickstarting-backend-typescript-development-e2656c2f5d17?source=collection_archive---------21-----------------------#2021-06-08">https://javascript.plainenglish.io/the-guide-to-kickstarting-backend-typescript-development-e2656c2f5d17?source=collection_archive---------21-----------------------#2021-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/645959af15440c1f6f8b04d52d1969ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*igDm8VkbIbAH938I"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@oskaryil?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Oskar Yildiz</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7c90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文要求您至少具备一些类型脚本知识。主题包括<code class="fe ky kz la lb b">ReturnType</code>、<code class="fe ky kz la lb b">Partial</code>、泛型<code class="fe ky kz la lb b">&lt;T&gt;</code>、交集、如何修改全局名称空间以及<code class="fe ky kz la lb b">tsc</code>命令行。同时专注于使用TypeScript提供的安全类型。</p><p id="3750" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从建立几件事情的基线开始。</p><h1 id="c6b3" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">跑步与发展</h1><p id="18df" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在开始学习TypeScript时，我希望有人能更具体地说明这一点。<em class="mf">编写</em>代码和<em class="mf">运行</em>代码是两码事。TypeScript <em class="mf">在开发时只有</em>存在，而真正运行的<em class="mf">是普通的JavaScript。这使得调试更加困难，并且在运行时无法使用类型(除了普通JavaScript支持的类型)。</em></p><h1 id="d6c4" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">tsconfig.json建议</h1><p id="7a06" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">尽可能保持设置紧凑，让TypeScript熠熠生辉。这个<em class="mf">尤其是</em>包括<code class="fe ky kz la lb b">noImplicitAny: true</code>和<code class="fe ky kz la lb b">strictNullChecks: true</code>。保持严格的设置有时看起来很烦人，但从长远来看，这是一个成功的概念。更少的错误，更好的智能感知，重构变成了公园里的散步。</p><h2 id="2cb2" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">目标</h2><p id="4cb0" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在https://www.typescriptlang.org/tsconfig/#target<a class="ae jz" href="https://www.typescriptlang.org/tsconfig/#target" rel="noopener ugc nofollow" target="_blank"/>的<code class="fe ky kz la lb b">target</code>和se文档中有许多变化。对于后端开发，不需要考虑浏览器兼容性。用最新最棒的功能就好。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="a1b5" class="mg ld in lb b gy na nb l nc nd">{<br/>  "compilerOptions": {<br/>    "target": "ES2020", <br/>    "module": "commonjs", /*  'commonjs', 'es2020', or 'ESNext'.  */<br/>    "outDir": "./out",<br/>    "rootDir": "./src", <br/>    "strict": true, <br/>    "esModuleInterop": false,<br/>    "skipLibCheck": true,<br/>    "forceConsistentCasingInFileNames": true, <br/>    "allowUnreachableCode": true,<br/>   <strong class="lb io"> "noImplicitAny": true,<br/>    "strictNullChecks": true,</strong><br/>    "strictPropertyInitialization": true,<br/>    "alwaysStrict": true,<br/>    "noImplicitThis": true,<br/>    "strictBindCallApply": true,<br/>    "experimentalDecorators": true,<br/>    "incremental": true,<br/>    "noUncheckedIndexedAccess": true<br/>  }<br/>}</span></pre><h1 id="a721" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">定义简单类型</h1><p id="4474" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在深入有趣的细节之前，让我们先简要地看一下如何定义一个简单类型:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="9a54" class="mg ld in lb b gy na nb l nc nd">type User = {<br/>    Name: string,<br/>    AccessLevel: "NewUser" | "User" | "Admin"<br/>}</span></pre><p id="dac8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要使用它，只需引用名为<code class="fe ky kz la lb b">User</code>的类型，如下所示:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="b1e0" class="mg ld in lb b gy na nb l nc nd">function Login(userName: string, pw: string) : User | undefined {</span><span id="638f" class="mg ld in lb b gy ne nb l nc nd">    let theUser: User | undefined = undefined;</span><span id="909c" class="mg ld in lb b gy ne nb l nc nd">    if (userName === "root" &amp;&amp; pw=== "root")<br/>        theUser = { Name: "Root", AccessLevel: "Admin" };</span><span id="a723" class="mg ld in lb b gy ne nb l nc nd">     return theUser;<br/>}</span></pre><p id="bb9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，说完了，让我们进入正题。</p><h1 id="8014" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">已知类型vs“任何”vs“未知”</h1><h2 id="e528" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">任何的</h2><p id="4de3" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">定义为any的对象可以被认为是一个“JavaScript对象”。本质上，所有的操作都是允许和不允许的(赋值、删除值等等)。就当是程序员决定说“我对这个变量一无所知，不用任何类型检查就可以访问、删除、修改上面的任何值”。</p><p id="2eef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">any</code>在从JavaScript迁移到TypeScript时确实很有用，但是尽量避开它。如果必须这样做，则更改<code class="fe ky kz la lb b">tsconfig.json</code>，将<code class="fe ky kz la lb b">noImplicitAny</code>设置为假以减少错误数量。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="3aaa" class="mg ld in lb b gy na nb l nc nd">let a: <strong class="lb io">any </strong>= {<br/>    Foo: "1"<br/>};</span><span id="1350" class="mg ld in lb b gy ne nb l nc nd">a = { Foo: "100", Fruit: "Banana" };   // No problem</span><span id="5809" class="mg ld in lb b gy ne nb l nc nd">a.Bar = "2";         // No problem<br/>delete a.Foo;        // No problem</span><span id="7a25" class="mg ld in lb b gy ne nb l nc nd">console.log(a.Foo);  // Returns undefined</span></pre><h2 id="132c" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">未知的</h2><p id="9165" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">未知类型有些不同。可以随意赋值(就像<code class="fe ky kz la lb b">any</code>一样)，但是试图访问/修改这些值会出错。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="aae8" class="mg ld in lb b gy na nb l nc nd">let a: <strong class="lb io">unknown </strong>= {<br/>    Foo: "1"<br/>};</span><span id="c87d" class="mg ld in lb b gy ne nb l nc nd">a = { Foo: "100", Fruit: "Banana" };   // No problem</span><span id="df5d" class="mg ld in lb b gy ne nb l nc nd">a.Bar = "2";         // Returns error<br/>delete a.Foo;        // Returns error</span><span id="b0a7" class="mg ld in lb b gy ne nb l nc nd">console.log(a.Foo);  // Returns error</span></pre><h2 id="cc8e" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">从不</h2><p id="908d" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><code class="fe ky kz la lb b">never</code>不会出现在好的书面类型脚本中，但是在从JavaScript转换到类型脚本时可能会出现。考虑以下场景:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="94c8" class="mg ld in lb b gy na nb l nc nd">const Order = {<br/>    OrderID: "1234",<br/>    OrderRows: []<br/>};</span><span id="9743" class="mg ld in lb b gy ne nb l nc nd">Order.OrderRows.push({ ArticleID: 123 });</span></pre><p id="fc05" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于在<code class="fe ky kz la lb b">Order</code>对象上没有定义类型，TypeScript将试图找出该对象的样子。不幸的是，<code class="fe ky kz la lb b">OrderRows</code>只是一个数组，但它的类型无法确定。因此，类型将被设置为<code class="fe ky kz la lb b">never</code>。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/f68324215a5ea20d424b96eb9648f6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkNGwWSWdl8KtViFHg3XCQ.png"/></div></div></figure><p id="d91f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解决这个问题很简单，只需指定对象的类型:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="5247" class="mg ld in lb b gy na nb l nc nd">const Order : { OrderID: string, OrderRows: {ArticleID: number}[] }= {<br/>    OrderID: "1234",<br/>    OrderRows: []<br/>};</span><span id="f1bb" class="mg ld in lb b gy ne nb l nc nd">Order.OrderRows.push({ ArticleID: 123 });</span></pre><h1 id="0ca7" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">进入类型…</h1><p id="7bf5" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">现在理论上所有的对象都被很好的定义了，类型也是已知的。实际上，大多数(所有？)从磁盘加载或远程获取的对象则不是。作为一名开发人员，这带来了一个挑战，因为(例如)一个获取数据的<code class="fe ky kz la lb b">get</code>请求会返回某种需要适应TypeScript的对象。</p><p id="3fcd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(至少)有四种方法可以将类型分配给对象:</p><h2 id="1967" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">方法1:类型断言(如果您喜欢c#语法，也可以使用强制转换)</h2><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="7b06" class="mg ld in lb b gy na nb l nc nd">const myObject = <strong class="lb io">&lt;TheTargetType&gt;</strong>request("http://...");</span><span id="bd25" class="mg ld in lb b gy ne nb l nc nd">// or</span><span id="a7b7" class="mg ld in lb b gy ne nb l nc nd">const myObject = request("http://...") <strong class="lb io">as TheTargetType</strong></span></pre><h2 id="5a97" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">方法2:声明一个特定类型的变量</h2><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="d50d" class="mg ld in lb b gy na nb l nc nd">const myObject : <strong class="lb io">TheTargetType </strong>= request("http://...");</span></pre><h2 id="d1dd" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">方法3:使用用户定义的类型保护</h2><p id="497e" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">用户定义的类型保护是检查一个对象的函数，如果它通过了设定的要求，它就被认为是某种类型。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="67fd" class="mg ld in lb b gy na nb l nc nd">// The type<br/>type Person = { Name: string, Age: string }</span><span id="1879" class="mg ld in lb b gy ne nb l nc nd">// User Defined Type Guard<br/>function isPerson(object: unknown): <strong class="lb io"><em class="mf">object is Person</em></strong> {<br/>    // Rules: Name and Age must exist in in the object.<br/>    const keys = Object.keys(data);<br/>    return (["Name", "Age"].every(v =&gt; keys.includes(v)));<br/>}</span><span id="adef" class="mg ld in lb b gy ne nb l nc nd">// The unknown data (gotten from somewhere)<br/>const rawData = `{"Name":"Sarah","Age":30}`;<br/>const data = JSON.parse(rawData);         // type is "any"</span><span id="81a3" class="mg ld in lb b gy ne nb l nc nd">// Using the type guard<br/>if (isPerson(data)) {<br/>    // data is of type Person (inside this closure)<br/>    console.log(`name: ${data.Name}, age ${data.Age}`);<br/>}</span></pre><h2 id="392c" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">方法4:泛型</h2><p id="f96f" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">当从一个网站加载远程数据时，泛型特别有用。因为泛型非常强大，所以下面有专门的一章。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="fb15" class="mg ld in lb b gy na nb l nc nd">async function FetchRemoteSite&lt;T&gt;(url: string): Promise&lt;T&gt; {<br/>  const result = await axios.get(`<a class="ae jz" href="https://remotesite.com/api/${url}`" rel="noopener ugc nofollow" target="_blank">https://site.com/api/${url}`</a>);<br/>  return result.data as T;<br/>}</span></pre><h1 id="29df" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">类型of</h1><p id="09b5" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">传统JavaScript中的typeof用于获取对象或原语的类型名称(即“对象”、“字符串”、“数字”等等)</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="cdb5" class="mg ld in lb b gy na nb l nc nd">const a = { Foo: "Bar" };<br/>const b = "Bar";<br/>console.log(typeof a);   // Returns "object"<br/>console.log(typeof b);   // Returns "string"</span></pre><p id="482f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用typeof获取<em class="mf"> TypeScript </em>类型是不可能的，因为所有运行代码的<em class="mf">都是JavaScript，类型不存在。</em></p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="f3a9" class="mg ld in lb b gy na nb l nc nd">type FooType = { Name: string, Age: number };<br/>const foo: FooType = { Name: "A", Age: 1 };<br/>console.log(typeof foo);  //"FooType"? No! returns "object"</span></pre><p id="bb5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么TypeScript中的typeof可以用来做什么呢？它可以复制其他对象和函数的现有类型。例如，这是有效的代码:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="9ae5" class="mg ld in lb b gy na nb l nc nd">let x: { id: number };</span><span id="44ca" class="mg ld in lb b gy ne nb l nc nd">const y: typeof x = { id: 7 };</span></pre><p id="b2f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个更大的例子是:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="19c7" class="mg ld in lb b gy na nb l nc nd">const DefaultConfig = {Foo: 1, Bar: 44 };</span><span id="a178" class="mg ld in lb b gy ne nb l nc nd">function LoadFromDisk(): typeof DefaultConfig {</span><span id="c033" class="mg ld in lb b gy ne nb l nc nd">    // Copy the type<br/>    let result: typeof DefaultConfig | undefined = undefined;</span><span id="2df8" class="mg ld in lb b gy ne nb l nc nd">     result = fs.existsSync("config.json")<br/>        ? JSON.parse(fs.readFileSync("config.json", "utf-8"))<br/>        : DefaultConfig;</span><span id="f6aa" class="mg ld in lb b gy ne nb l nc nd">     return result!;<br/>}</span></pre><h1 id="c789" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">ReturnType</h1><p id="a764" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">考虑下面的代码。<code class="fe ky kz la lb b">DoWork</code>的返回是<code class="fe ky kz la lb b">{ a: string, b: string} | undefined</code>，函数必须以某种方式构建结果。这可能导致再次声明同一个对象(见第3行)</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="eac9" class="mg ld in lb b gy na nb l nc nd">function DoWork():<strong class="lb io"> { a: string, b: string } | undefined </strong>{</span><span id="e465" class="mg ld in lb b gy ne nb l nc nd">const result: <strong class="lb io"><em class="mf">{ a: string, b: string } | undefined</em></strong> = undefined;<br/>    /* ... additional code here */<br/>    return result;</span><span id="9766" class="mg ld in lb b gy ne nb l nc nd">}</span></pre><p id="a8db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有几种方法可以解决这个问题，最明显的方法是声明一个单独的类型:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="44d6" class="mg ld in lb b gy na nb l nc nd">type WorkResult = { a: string, b: string };</span><span id="00b4" class="mg ld in lb b gy ne nb l nc nd">function DoWork(): WorkResult | undefined {<br/>    const result: WorkResult | undefined = undefined;<br/>    /* ... additional code here */<br/>    return result;<br/>}</span></pre><p id="1c7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是还有其他方法。</p><h2 id="961a" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">远离函数的返回值</h2><p id="2353" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">从函数行中删除返回信息，让TypeScript施展它的魔法。当鼠标悬停在<code class="fe ky kz la lb b">DoWork</code>上时，TypeScript知道返回类型。不幸的是，这降低了可读性，而且有时，TypeScript不能产生足够清晰(甚至正确)的ReturnType。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/acc31e82bfc6ec4ec5b70e1c682ff81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*YnpphCfsYfDES2IDtmhfyQ.png"/></div></figure><h2 id="5f20" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">使用ReturnType</h2><p id="2ef6" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">使用<code class="fe ky kz la lb b">ReturnType</code>，可以引用一个函数并提取它返回的类型。</p><p id="6172" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例1: </strong></p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="e6c1" class="mg ld in lb b gy na nb l nc nd">function DoWork(): { a: string, b: string} | undefined {</span><span id="900a" class="mg ld in lb b gy ne nb l nc nd">    let result: ReturnType&lt;typeof DoWork&gt; = undefined;</span><span id="c1ae" class="mg ld in lb b gy ne nb l nc nd">    /* Code that populates the result variable */<br/>    result = { a: "a", b: "b" }</span><span id="f9ca" class="mg ld in lb b gy ne nb l nc nd">    return result;</span><span id="f66f" class="mg ld in lb b gy ne nb l nc nd">}</span><span id="4ccf" class="mg ld in lb b gy ne nb l nc nd">DoWork();</span></pre><p id="3cb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例2: </strong></p><p id="97b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想从不受您控制的模块中获得一个类型，这可能会更有用。考虑一个编码糟糕的数据库实现的依赖性。这样可以保证返回的类型与被引用模块的类型相同。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="9e6f" class="mg ld in lb b gy na nb l nc nd">import { LoadDatabaseEntry } from './badlycoded';</span><span id="b38e" class="mg ld in lb b gy ne nb l nc nd">function Trimname(): ReturnType&lt;typeof LoadDatabaseEntry&gt; {</span><span id="5e68" class="mg ld in lb b gy ne nb l nc nd">    const entry = LoadDatabaseEntry();<br/>    entry.Name = entry.Name.trim();<br/>    return entry;</span><span id="7486" class="mg ld in lb b gy ne nb l nc nd">}</span></pre><p id="f729" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将<code class="fe ky kz la lb b">ReturnType</code>与<code class="fe ky kz la lb b">Omit</code>或<code class="fe ky kz la lb b">Pick</code>结合在一起可以提供更多的控制:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="0f34" class="mg ld in lb b gy na nb l nc nd">import { LoadDatabaseEntry } from './badlycoded';<br/>function Trimname(): <strong class="lb io">Pick&lt;</strong><em class="mf">ReturnType&lt;typeof LoadDatabaseEntry&gt;</em>, <strong class="lb io">"Name" | "Age"&gt;</strong> {<br/>    const entry = LoadDatabaseEntry();<br/>    entry.Name = entry.Name.trim();<br/>    return entry;<br/>}</span><span id="f80b" class="mg ld in lb b gy ne nb l nc nd">Trimname()  // Contains only "Name" and "Age"</span></pre><h1 id="2b77" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">多个返回类型(联合)</h1><p id="3e22" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">例如，可以返回一个带有相关数据的对象(成功时)或一个错误对象(带有相关错误数据)，如下所示:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="5f3f" class="mg ld in lb b gy na nb l nc nd">function LoadData(): <strong class="lb io">{ Name: string, Age: number }</strong> | {<strong class="lb io"> Error: string }</strong> {<br/>     // Simulate a call that succeeds 90% of the time<br/>     if (Math.random() &gt; 0.1)<br/>         return { Name: "John", Age: 27 };</span><span id="5667" class="mg ld in lb b gy ne nb l nc nd">      return { Error: "Could not load data." };</span><span id="a129" class="mg ld in lb b gy ne nb l nc nd">}</span></pre><h2 id="7eee" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">返回关于成功和失败的不同数据—更详细:</h2><p id="dd84" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">这个功能有好有坏。它会提高代码的可读性，同时也会降低可读性。继续读下去。:)</p><p id="2cb4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑一下这个。在<code class="fe ky kz la lb b">Success: true</code>上，返回相关数据。在<code class="fe ky kz la lb b">Success: false</code>时，没有数据返回:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="405b" class="mg ld in lb b gy na nb l nc nd">function LoadData() {</span><span id="e12b" class="mg ld in lb b gy ne nb l nc nd">      // Simulate a call that succeeds 90% of the time<br/>      if (Math.random() &gt; 0.1)<br/>        return { <strong class="lb io">Success: true,</strong> Name: "John", Age: 27 };</span><span id="85af" class="mg ld in lb b gy ne nb l nc nd">      return { <strong class="lb io">Success: false </strong>};<br/>}</span></pre><p id="5631" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将鼠标悬停在该函数上，可以发现TypeScript已经构建了正确的返回类型:</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6f97c082154ab0ffdb864bb2d210cfd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*et--ZDSgFbHgnearNcswaw.png"/></div></figure><p id="fcc0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们换成这样:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="3509" class="mg ld in lb b gy na nb l nc nd">function LoadData() : { <strong class="lb io">Success: true</strong>, Name: string, Age: number} | { <strong class="lb io">Success: false</strong>} {<br/>...<br/>}</span></pre><p id="af57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">已指示TypeScript注意返回的数据中有一个<em class="mf">差异</em>(取决于<code class="fe ky kz la lb b">Success</code>的结果)。现在悬停显示:</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/96166090c22c9e0042cedc834cd3c2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*P9TqfT7xU0JOWz27Vs1Z6w.png"/></div></figure><p id="8c1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">带智能感知；既然我已经检查了<code class="fe ky kz la lb b">data.Success</code>为真，那么我就可以访问年龄和姓名值(而<strong class="kc io"> <em class="mf">只有</em> </strong>)。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6743a053633c087bb7ebe7bfada18163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/1*SjCNZSaCCqt4IjHCRGfOJg.gif"/></div></figure><p id="b015" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么这种方法有什么不好呢？嗯，只是这样。在下面的例子中，没有检查Success是否为真，因为TypeScript不能<em class="mf">完美地</em>决定显示什么，所以姓名和年龄值被隐藏。这对开发人员隐藏了重要的信息。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3369919ddc3a3eda02ca2a92415be930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*94f2EcaoHwBwz2KYYTdjiQ.png"/></div></figure><h1 id="8164" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">返回多个值</h1><p id="eeff" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">这不是一件打字稿的事情，但是知道这一点是有好处的。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="60c4" class="mg ld in lb b gy na nb l nc nd">function MultipleReturns1() {<br/>    return { Foo: "Yes", Bar: "No" };<br/>}</span><span id="118a" class="mg ld in lb b gy ne nb l nc nd">const { Foo, Bar } = MultipleReturns1(); // Destructuring<br/>console.log(`Foo=${Foo}, Bar=${Bar}`);   // Prints "Foo=Yes, Bar=No"</span></pre><p id="7229" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于数组:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="4033" class="mg ld in lb b gy na nb l nc nd">function MultipleReturns2() {<br/>    return ["Yes", "No"];<br/>}</span><span id="7940" class="mg ld in lb b gy ne nb l nc nd">const [a, b] = MultipleReturns2();<br/>console.log(`${a} ${b}`);              // Prints "Yes No"</span></pre><h1 id="cbc1" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">交叉点/“合并”类型</h1><p id="e13c" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">将两种类型“合并”成一种新类型是可能的。在TypeScript中，这被描述为“通过交集扩展类型”。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="89c8" class="mg ld in lb b gy na nb l nc nd">type User = { Name: string, Age: number }</span><span id="5224" class="mg ld in lb b gy ne nb l nc nd">function LoadData(): <strong class="lb io">User &amp; { IsNewUser: boolean }</strong> {</span><span id="90a4" class="mg ld in lb b gy ne nb l nc nd">   const n = Math.random() &gt; 0.2;<br/>   return { Name: "John", Age: 27, IsNewUser: n};</span><span id="96be" class="mg ld in lb b gy ne nb l nc nd">}</span><span id="4525" class="mg ld in lb b gy ne nb l nc nd">const data = LoadData();<br/>console.log(data.IsNewUser);   // OK!</span></pre><h1 id="817a" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">仿制药<t/></h1><p id="6679" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">泛型由类型参数标识，通常用单个字母T标识，如<code class="fe ky kz la lb b">function LoadData<strong class="kc io"><em class="mf">&lt;T&gt;</em></strong>() { ... }.</code></p><p id="24e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最简单的解释是:不是函数决定要返回的类型(例如，“如果你调用这个函数，它将返回一个用户对象”)，而是<em class="mf">调用者</em>决定要返回的对象。基本上，类型是函数的一个参数。</p><p id="0849" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当谈到为从磁盘、数据库或远程(http://…)加载数据而编写的函数时，泛型是最有可能考虑的。</p><p id="db1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例如:</strong></p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="3040" class="mg ld in lb b gy na nb l nc nd">type User = { Name: string, Age: number }</span><span id="447f" class="mg ld in lb b gy ne nb l nc nd">async function LoadData<strong class="lb io">&lt;T&gt;</strong>(url: string): Promise&lt;T&gt; {<br/>    const result = await axios.get(`<a class="ae jz" href="https://remotesite.com/api/${url}`" rel="noopener ugc nofollow" target="_blank">https://site.com/api/${url}`</a>);<br/>    return result.data as T;<br/>}</span><span id="42e6" class="mg ld in lb b gy ne nb l nc nd">async function Main() {</span><span id="1b4c" class="mg ld in lb b gy ne nb l nc nd">   const u1 = await LoadData("users");          // u1 is unknown :(<br/>   const u2 = await LoadData&lt;User[]&gt;("users");  // u2 is User[]</span><span id="7376" class="mg ld in lb b gy ne nb l nc nd">}</span></pre><p id="fd3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据功能的不同，类型参数可以省略:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="6304" class="mg ld in lb b gy na nb l nc nd">function Reverse&lt;T&gt;(data: T[]): T[] {<br/>    // For the sake of demo only<br/>    return data.reverse();<br/>}</span><span id="b2bd" class="mg ld in lb b gy ne nb l nc nd">const sourceData = ["A", "B", "C"];<br/>console.log(Reverse(sourceData));   // Output = [ 'C', 'B', 'A' ]</span></pre><h1 id="d934" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">enums</h1><p id="58bd" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">最基本形式的枚举声明如下:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="34af" class="mg ld in lb b gy na nb l nc nd">enum FileAccess {<br/>    Read,    // Will become the number 0<br/>    Write    // Will become the number 1<br/>}</span><span id="a0ca" class="mg ld in lb b gy ne nb l nc nd">const p: FileAccess = FileAccess.Read;</span></pre><p id="4ca6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将存储在数据库或类似数据库中的枚举需要在应用程序的生命周期内永久固定。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="2824" class="mg ld in lb b gy na nb l nc nd">// Declare the enum<br/>enum eFileAccess {<br/>    Read = "ACCESS_READ",<br/>    Write = "ACCESS_WRITE"<br/>}</span><span id="bc07" class="mg ld in lb b gy ne nb l nc nd">// Use it<br/>const p: eFileAccess = eFileAccess.Read;</span><span id="9c13" class="mg ld in lb b gy ne nb l nc nd">if (p === eFileAccess.Read)<br/>    console.log("Read access graned");</span><span id="3480" class="mg ld in lb b gy ne nb l nc nd">console.log(p);  // Returns "ACCESS_READ"</span><span id="61d5" class="mg ld in lb b gy ne nb l nc nd">// Convert from string to enum<br/>const f = &lt;eFileAccess&gt;"ACCESS_WRITE";<br/>if (f === eFileAccess.Write)<br/>    console.log("Write access granted");</span></pre><h2 id="cb29" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">按位枚举/标志(来自c#)</h2><p id="f765" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">标志并未真正得到支持，但可以通过一些按位运算轻松修复。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="adad" class="mg ld in lb b gy na nb l nc nd">enum eFileAccess {<br/>    Read = 1 &lt;&lt; 0,            // 0001 = 1<br/>    Write = 1 &lt;&lt; 1,           // 0010 = 2<br/>    ReadWrite = Read | Write  // 0011 = 3<br/>}</span><span id="3d0f" class="mg ld in lb b gy ne nb l nc nd">const p: eFileAccess = eFileAccess.ReadWrite;</span><span id="879a" class="mg ld in lb b gy ne nb l nc nd">if (p &amp; eFileAccess.Write) // Bitwise and<br/>    console.log("Write access graned");</span></pre><h1 id="180f" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">只读！</h1><p id="9941" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">有多种方法可以做到这一点。</p><p id="a864" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">方法1: </strong>定义使用<code class="fe ky kz la lb b">readonly</code>的类型:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="0a88" class="mg ld in lb b gy na nb l nc nd">type Position = {<br/>    readonly x: number;<br/>    readonly y: number;<br/>}</span><span id="0eb0" class="mg ld in lb b gy ne nb l nc nd">const a: Position = { x: 1, y: 5 };<br/>a.x = 10;   // Error</span></pre><p id="47a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">方法2: </strong>将现有类型变为只读。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="2cb8" class="mg ld in lb b gy na nb l nc nd">type Position = {<br/>    x: number;<br/>    y: number;<br/>}</span><span id="8c61" class="mg ld in lb b gy ne nb l nc nd">function GetPosition(): Readonly&lt;Position&gt; {  // Returns readonly</span><span id="dbb8" class="mg ld in lb b gy ne nb l nc nd">const result: Position = { x: 0, y: 0 };<br/>    result.x = 10;  // Writable<br/>    result.y = 20;<br/>    return result;</span><span id="c06e" class="mg ld in lb b gy ne nb l nc nd">}</span><span id="8253" class="mg ld in lb b gy ne nb l nc nd">let a = GetPosition();<br/>a.x = 10;  // Error</span></pre><h1 id="9ec4" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">索引签名/好的任意/键值对</h1><p id="5464" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><code class="fe ky kz la lb b">any</code>应该尽量避免，但有时需要将数据存储在“键”和“值”对中。索引签名允许这种情况。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="1023" class="mg ld in lb b gy na nb l nc nd">const kv: { <strong class="lb io">[key: string]: string | number</strong> } = {};<br/>kv.Name = "Sarah";<br/>kv.Age = 47;</span><span id="077a" class="mg ld in lb b gy ne nb l nc nd">console.log(JSON.stringify(kv)); // {"Name":"Sarah","Age":47}</span></pre><p id="690c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">循环具有类型安全性的索引签名就像:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="765d" class="mg ld in lb b gy na nb l nc nd">for (const [key, value] of Object.entries(kv))<br/>    console.log(`key=${key}, value=${value}`);</span></pre><p id="fe62" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，如果索引签名应为只读，请执行以下操作:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="21b0" class="mg ld in lb b gy na nb l nc nd">type rokv = { <strong class="lb io">readonly </strong>[x: string]: number; }</span><span id="7492" class="mg ld in lb b gy ne nb l nc nd">const foo: rokv = { "Hour": 3, "Minute": 29 };</span><span id="8206" class="mg ld in lb b gy ne nb l nc nd">console.log(foo.Hour);   // Returns 999</span><span id="931c" class="mg ld in lb b gy ne nb l nc nd">foo.Minute = 12;         // Not allowed, is read only</span></pre><p id="ab4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，在IntelliSense中，有可能将对象作为值。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9f9f2698d4a52528b876623987b2341f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*g2R0Epcc2PGYCEpEmBmn8Q.png"/></div></figure><h1 id="a410" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">接口？还是类型？</h1><p id="9bc3" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">它们几乎完全相同，无论是在使用方式还是书写方式上。这是一种个人喜好，几乎没有例外。用一些空格来对齐它们，它们可以比较为:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="d3fa" class="mg ld in lb b gy na nb l nc nd">interface Person   { Name: string, Age: number }<br/>     type Person = { Name: string, Age: number }</span></pre><p id="fefc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">扩展两种类型都是可能的，但是语法不同。更多信息请访问<a class="ae jz" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces" rel="noopener ugc nofollow" target="_blank">https://www . typescripttlang . org/docs/manual/2/day-types . html #类型别名和接口之间的区别</a></p><p id="a383" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个显著的区别是同名接口被<em class="mf">合并了</em>！当需要修改已经存在的接口时，这一点尤其重要(请继续参见下面的“修改全局命名空间”)。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="66d0" class="mg ld in lb b gy na nb l nc nd">interface Person { Name: string }<br/>interface Person { Age: number }<br/>const newUser: Person = { Name: "Linda", Age: 80 };   // OK!</span></pre><h1 id="97e1" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">修改全局命名空间(global.name)</h1><p id="4050" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">有时，需要在整个Node.js项目中有一个全局变量。它可以是常数、函数或记录器。</p><p id="437e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Globals在<strong class="kc io"> .d.ts </strong>文件中定义，与本文件<code class="fe ky kz la lb b">declarations.d.ts</code>相同。将其置于“src”下。</p><p id="b245" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">重要！</strong>将环境变量<code class="fe ky kz la lb b">TS_NODE_FILES</code>设为“真”。这将启用<code class="fe ky kz la lb b">tsconfig.json</code>中的<code class="fe ky kz la lb b">include</code> / <code class="fe ky kz la lb b">exlude</code>配置设置</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="4b9c" class="mg ld in lb b gy na nb l nc nd">declare global {<br/>   namespace NodeJS {<br/>    interface Global {<br/>       LicenseKey: string<br/>    }<br/>  }<br/>}</span><span id="36ba" class="mg ld in lb b gy ne nb l nc nd">export { };  // Don't forget this </span></pre><p id="b94e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">:!:得到“与自定义类型脚本模块和名称空间相比，ES2015模块语法更可取”？不要使用<code class="fe ky kz la lb b">.ts</code>命名，使用<code class="fe ky kz la lb b">.d.ts</code>。</p><p id="9d94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要访问全局变量、函数或对象，您只需要:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="7886" class="mg ld in lb b gy na nb l nc nd">function Main() {<br/>   global.LicenseKey = "ABC123";<br/>}</span></pre><p id="aef8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以在根上声明变量。一个例子是全局拥有一个<code class="fe ky kz la lb b">logger</code>对象，这个对象不需要包含在每个文件中就可以访问。对于这种情况，有几件事情需要考虑:</p><p id="f7d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">申报单</strong></p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="93b9" class="mg ld in lb b gy na nb l nc nd">type Logger = {<br/>    debug: (p: string) =&gt; void<br/>}</span><span id="b53d" class="mg ld in lb b gy ne nb l nc nd">declare global {</span><span id="ae43" class="mg ld in lb b gy ne nb l nc nd">    // eslint-disable-next-line no-var<br/>    declare var logger: Logger;<br/>}</span><span id="8393" class="mg ld in lb b gy ne nb l nc nd">export { };</span></pre><p id="651d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像这个<code class="fe ky kz la lb b">logger</code>这样的全局对象的最大挑战是它需要超级早的初始化。制作一个<code class="fe ky kz la lb b">index.ts</code>来初始化需要的全局变量，并且<em class="mf">只初始化</em>。这个文件又包含一个<em class="mf">单个</em>文件，像<code class="fe ky kz la lb b">main.ts</code>一样，init的其余部分在这里运行。做对了，<code class="fe ky kz la lb b">index.ts</code>将能够在之前运行它的代码<em class="mf">，包括main.ts文件。</em></p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="1915" class="mg ld in lb b gy na nb l nc nd"># Init my (fake) global logger (note: without global-prefix)<br/>logger.debug = (iData: string) =&gt; { console.log(iData); };</span><span id="49ea" class="mg ld in lb b gy ne nb l nc nd"># Use it<br/>logger.debug("Logger initialized, booting system.");</span></pre><h1 id="8811" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">环境变量和全局名称空间</h1><p id="e74e" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">最后，让我们研究一下如何修改全局名称空间来对环境变量进行类型检查。<code class="fe ky kz la lb b">process.env.VARIABLENAME</code>可以配置为:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="3b91" class="mg ld in lb b gy na nb l nc nd">declare global {<br/>    namespace NodeJS {<br/>        interface ProcessEnv {<br/>            NODE_ENV: "production" | "development",<br/>            VARIABLENAME: string | undefined,<br/>        }<br/>    }<br/>}<br/>export { };</span></pre><p id="a22d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用法:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="1e99" class="mg ld in lb b gy na nb l nc nd">if (process.env.NODE_ENV === "development")<br/>   console.log(`VARIABLENAME=${process.env.VARIABLENAME}`);</span></pre><h1 id="1aa5" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">修改Express命名空间</h1><h1 id="954b" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于使用全局变量的更多信息</h1><p id="61ce" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">我写了一篇关于此事的附加文章，在这里阅读。</p><h1 id="7865" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">修改Express命名空间</h1><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="eb01" class="mg ld in lb b gy na nb l nc nd">import "express"; // Modifies global namespace, so include it!</span><span id="77a6" class="mg ld in lb b gy ne nb l nc nd">declare global {</span><span id="365f" class="mg ld in lb b gy ne nb l nc nd">namespace Express {<br/>        interface Request {<br/>            token: string,<br/>            userId: string<br/>        }<br/>    }<br/>}</span><span id="3347" class="mg ld in lb b gy ne nb l nc nd">export { };</span></pre><p id="bdd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">添加中间件来解码我们的用户(来自bearer、cookie或类似的内容),并将经过验证的用户存储在<code class="fe ky kz la lb b">req</code>对象中。可以只存储用户的ID，也可以存储包含更多数据的实际对象。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="8ba2" class="mg ld in lb b gy na nb l nc nd">import * as Express from "express";</span><span id="4919" class="mg ld in lb b gy ne nb l nc nd">app.use((req: Express.Request, res: Express.Response, next: Express.NextFunction) =&gt; {</span><span id="0260" class="mg ld in lb b gy ne nb l nc nd">    // Do work to decode req.headers.authorization here<br/>    req.token = "thetoken";<br/>    req.userId = "usr00001";</span><span id="15e1" class="mg ld in lb b gy ne nb l nc nd">    next();</span><span id="b519" class="mg ld in lb b gy ne nb l nc nd">});</span></pre><p id="6420" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在您的路线中，非常简单:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="f2a0" class="mg ld in lb b gy na nb l nc nd">app.get(`/test`, async function (req: Express.Request, res: Express.Response) {</span><span id="a5e0" class="mg ld in lb b gy ne nb l nc nd">   if (!req.userId)<br/>    // ... Not authenticated<br/>    res.status(401).json({ Success: false });<br/>   else<br/>    // ...All ok<br/>    res.json({ Success: true });<br/>  });</span></pre><h1 id="7452" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">承诺vs异步</h1><p id="b446" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">让我们首先确定，对于大多数用例来说，它们可以被认为是相同的。下面是两个函数，一个返回一个<code class="fe ky kz la lb b">new Promise</code>，另一个使用<code class="fe ky kz la lb b">async</code>(带类型安全)。这两个函数有四种不同的调用方式。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="7ccc" class="mg ld in lb b gy na nb l nc nd">// Two different implementations doing the same thing</span><span id="6f3a" class="mg ld in lb b gy ne nb l nc nd">async function DoSomething(): Promise&lt;number&gt; {<br/>  return Math.random();<br/>}</span><span id="e562" class="mg ld in lb b gy ne nb l nc nd">function DoSomething2() {<br/> return <strong class="lb io">new Promise&lt;number&gt;</strong>((<em class="mf">resolve: (result: number) =&gt; void</em>) =&gt; {<br/>    resolve(Math.random());<br/> });</span><span id="2b6b" class="mg ld in lb b gy ne nb l nc nd">}</span><span id="d0e6" class="mg ld in lb b gy ne nb l nc nd">// Test function</span><span id="66b5" class="mg ld in lb b gy ne nb l nc nd">async function TestThemAll() {</span><span id="06ab" class="mg ld in lb b gy ne nb l nc nd">// Test both using ".then" syntax</span><span id="97b2" class="mg ld in lb b gy ne nb l nc nd">DoSomething().then(result =&gt; {<br/>        console.log(`DoSomething returned: ${result}`);<br/>    });</span><span id="cb0e" class="mg ld in lb b gy ne nb l nc nd">DoSomething2().then(result =&gt; {<br/>        console.log(`DoSomething2 returned: ${result}`);<br/>    });</span><span id="030e" class="mg ld in lb b gy ne nb l nc nd">// Test them both using "await" syntax</span><span id="1ee3" class="mg ld in lb b gy ne nb l nc nd">console.log(`DoSomething returned: ${await DoSomething()}`);<br/>    console.log(`DoSomething2 returned: ${await DoSomething2()}`);</span><span id="7269" class="mg ld in lb b gy ne nb l nc nd">}</span><span id="c8e4" class="mg ld in lb b gy ne nb l nc nd">TestThemAll();</span></pre><p id="f4f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…但是复试呢？请吧。号码</p><h1 id="29e6" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">按原样启动TypeScript项目</h1><p id="e8ac" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">不需要将文件传输到out并从那里运行代码，它可以动态完成(即使有断点并单步执行VSCode)。</p><p id="3ffa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从命令行启动TypeScript项目:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="fd85" class="mg ld in lb b gy na nb l nc nd">set TS_NODE_FILES=true &amp; node -r ts-node/register src/index.ts</span></pre><p id="5b34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在VSCode中，需要有一个<code class="fe ky kz la lb b">.vscode\launch.json</code>文件。添加添加以下内容，然后按F5运行。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="f2d9" class="mg ld in lb b gy na nb l nc nd">{<br/> "version": "0.2.0",<br/> "configurations": [<br/>  {<br/>   "name": "Debug typescript",<br/>   "type": "node",<br/>   "request": "launch",<br/>   "smartStep": false,<br/>   "sourceMaps": true,<br/>   "args": ["${workspaceRoot}/<strong class="lb io">src/index.ts</strong>"],<br/>   "runtimeArgs": [<br/>            "-r",<br/>            "ts-node/register/transpile-only"<br/>   ],<br/>   "cwd": "${workspaceRoot}",<br/>   "protocol": "inspector",<br/>   "internalConsoleOptions": "openOnSessionStart",<br/>   "env": {<br/>    "TS_NODE_IGNORE": "false",<br/>   <strong class="lb io"> "TS_NODE_FILES": "true", // Respect include/exclude in tsconfig.json =&gt; will read declaration files</strong><br/>    "NODE_ENV": "development"<br/>   },<br/>   "skipFiles": [<br/>    "&lt;node_internals&gt;/*",<br/>    "&lt;node_internals&gt;/**",<br/>    "&lt;node_internals&gt;/**/*",<br/>    "${workspaceRoot}/node_modules/**",<br/>    "${workspaceRoot}/node_modules/**/*"<br/>   ],<br/>   "stopOnEntry": false,<br/>   "outputCapture": "std",<br/>  },<br/> ]<br/>}</span></pre><p id="c698" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想更改按F5时运行的内容，请打开vscode命令面板(ctrl-shift-p)并搜索<code class="fe ky kz la lb b">Debug: Select and start debugging</code>。</p><h1 id="9b91" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">一些工具提示！</h1><p id="3076" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">终于到了最后。让我们总结一些杂项工具提示。</p><h2 id="0a52" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">ThermalStressCracking热应力龟裂</h2><p id="33a0" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在开发过程中运行<code class="fe ky kz la lb b">tsc</code>将有助于跟踪项目层面的错误。结合<code class="fe ky kz la lb b">eslint</code>和<a class="ae jz" href="https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens" rel="noopener ugc nofollow" target="_blank">错误镜头</a>插件的VSCode将显示本地错误。</p><p id="80d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">建筑一次</strong></p><p id="35ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开一个终端，键入<code class="fe ky kz la lb b">tsc -b -v</code>一次性构建项目(打开verbose)。当前工作目录应该和<code class="fe ky kz la lb b">tsconfig.json.</code>在同一个文件夹</p><p id="f963" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">连续构建(观察&amp;增量)</strong></p><p id="7a56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更好的方法是打开监视文件变化的<code class="fe ky kz la lb b">-w</code>，并使用增量<code class="fe ky kz la lb b">-i</code>来加快传输速度。总而言之使用:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="8c1e" class="mg ld in lb b gy na nb l nc nd">tsc -b -v -i -w</span></pre><h2 id="512c" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">类型同步</h2><p id="6bd5" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">并非npmjs.com上的所有模块都有内置类型。<a class="ae jz" href="https://www.npmjs.com/package/typesync" rel="noopener ugc nofollow" target="_blank">类型同步</a>扫描项目并尝试找到所需的类型:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="1039" class="mg ld in lb b gy na nb l nc nd">📦 project1 — package.json (1 new typings added, 0 unused typings removed)<br/>└─ + <a class="ae jz" href="http://twitter.com/types/express" rel="noopener ugc nofollow" target="_blank">@types/express</a></span></pre><p id="d307" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果模块本身不存在类型，或者没有单独的类型，那么您只能靠自己了。手动编写定义或使用<code class="fe ky kz la lb b">declare module</code>将模块设置为<code class="fe ky kz la lb b">any</code>。对于后者，创建一个包含以下内容的<code class="fe ky kz la lb b">definition.d.ts</code>:</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="a5e6" class="mg ld in lb b gy na nb l nc nd">declare module '&lt;module name here&gt;';</span><span id="18d4" class="mg ld in lb b gy ne nb l nc nd">// Example:<br/>declare module 'rfc822-validate';</span></pre><h2 id="0399" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">NPM-检查</h2><p id="701b" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">使用<a class="ae jz" href="https://www.npmjs.com/package/npm-check" rel="noopener ugc nofollow" target="_blank"> npm-check </a>工具升级您的依赖项。用<code class="fe ky kz la lb b">npm-check -d</code>或<code class="fe ky kz la lb b">npm-check -d -g</code>运行</p><h2 id="30e1" class="mg ld in bd le mh mi dn li mj mk dp lm kl ml mm lq kp mn mo lu kt mp mq ly mr bi translated">死文件</h2><p id="36af" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">找到未使用的文件有点棘手，因为有很多方法可以使用文件。<a class="ae jz" href="https://www.npmjs.com/package/deadfile" rel="noopener ugc nofollow" target="_blank"> deadfile </a>干得不错。</p><pre class="ms mt mu mv gt mw lb mx my aw mz bi"><span id="df42" class="mg ld in lb b gy na nb l nc nd">deadfile .\\src\\index.ts --exclude out --exclude log</span></pre><h1 id="050f" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">享受:)</h1><p id="793c" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><em class="mf">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mf">plain English . io</em></a></p></div></div>    
</body>
</html>