<html>
<head>
<title>JavaScript: How to Deep Clone an Object?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:如何深度克隆一个对象？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-how-to-deep-clone-an-object-daa1ec29d216?source=collection_archive---------1-----------------------#2021-10-31">https://javascript.plainenglish.io/javascript-how-to-deep-clone-an-object-daa1ec29d216?source=collection_archive---------1-----------------------#2021-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4f68" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中对象的浅层克隆和深层克隆。此外，学习如何用JavaScript为Object.assign特征编写聚合填充。</h2></div><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="7ec1" class="ko kp iq kk b gy kq kr l ks kt"><strong class="kk ir">newObject = JSON.parse(JSON.stringify(oldObject));</strong> </span></pre><p id="f26e" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是JavaScript中克隆对象的唯一方法吗？</p><p id="643b" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们来看看…</p><figure class="kf kg kh ki gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lq"><img src="../Images/129a3609514dc99c5a69ef7e93135978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S63KpP4lr2Lp4PIQsRShmw.jpeg"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Clone an object in Javascript</figcaption></figure><p id="0a5a" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">用JavaScript克隆对象总是一件棘手的事情。主要是因为对象通常由用户定制，具有任意集合。这使得任何人都很难想出一个现成的克隆对象的解决方案。</p><p id="2bce" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">还有，JSON的使用并不是在任何地方都是可取的。为什么？JSON往往会丢失代码中使用的JavaScript数据类型。这意味着，在JSON中没有与null/NaN/undefined or函数等价的函数。</p><p id="b1a5" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">因此，</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="aa3b" class="ko kp iq kk b gy kq kr l ks kt">JSON.parse(JSON.stringify({a:null,b:NaN,c:Infinity,d:undefined,e:function(){},f:Number,g:false}))</span></pre><p id="1d69" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">最终会回来，</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="94de" class="ko kp iq kk b gy kq kr l ks kt">{a: null, b: null, c: null, g: false}</span></pre><p id="2e77" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">虽然使用JSON.parse和JSON.stringify是最快的克隆方式，但它会丢失数据。只有在不使用类型化数组、稀疏数组、blobs、set、map、regExps、FileLists、ImageDatas、undefined、NULL、Infinity或Date函数的情况下，才可以使用它。</p><p id="4e73" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">作为一名开发人员，您需要始终关注那些不会重复发明轮子的方法。而且，许多库确实考虑到对象必须被克隆的事实。这意味着，你需要好好看看你正在使用的库。看看您是否有克隆对象的简单方法——首先！</p><p id="2532" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在JavaScript中，克隆可以分为两种类型:浅层克隆和深层克隆。让我们试着去理解每一个类别。</p><h1 id="6c52" class="mc kp iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">浅层克隆</h1><p id="f246" class="pw-post-body-paragraph ku kv iq kw b kx mt jr kz la mu ju lc ld mv lf lg lh mw lj lk ll mx ln lo lp ij bi translated"><strong class="kw ir"> Object.assign </strong>用于创建JavaScript中任何对象的浅层克隆。根据定义，Object.assign()方法用于将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。</p><p id="dac7" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">例如，如果您有一个对象，如下所示:</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="adf0" class="ko kp iq kk b gy kq kr l ks kt">var parent = {a:1,b:{c:1,d:1}}<br/>var shallow_clone = Object.assign({}, parent);</span><span id="adb8" class="ko kp iq kk b gy my kr l ks kt">//console shallow_clone<br/>{a:1,b:{c:1,d:1}}</span></pre><p id="ae18" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">以上是父对象的浅层克隆。浅层克隆表示父对象的按位副本。子对象中的任何字段都是对父对象的引用。这意味着，子对象和父对象将共享相同的内存地址。因此，更改浅层克隆的值将会更改父克隆的值。</p><p id="3fa2" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们试试下面的方法:</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="392a" class="ko kp iq kk b gy kq kr l ks kt">shallow_clone.d = 5<br/>//executing the above line would change parent.d as well.</span></pre><p id="f51e" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这就是为什么Object.assign被认为是创建对象浅层副本的一行程序。</p><h1 id="7e87" class="mc kp iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">Object.assign的聚合填充</h1><p id="2028" class="pw-post-body-paragraph ku kv iq kw b kx mt jr kz la mu ju lc ld mv lf lg lh mw lj lk ll mx ln lo lp ij bi translated">以防您的浏览器不支持对象。赋值，您可以使用下面的代码片段来帮助您在代码中重新创建该功能。</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="ccfe" class="ko kp iq kk b gy kq kr l ks kt">Object.defineProperty(Object, '<strong class="kk ir">assign</strong>', {<br/>    enumerable: false,<br/>    configurable: true,<br/>    writable: true,<br/>    value: function(target) {<br/>      'use strict';<br/>      if (target === undefined || target === null) {<br/>        throw new TypeError('First argument is empty');<br/>      }<br/><br/>      var to = Object(target);<br/>      for (var i = 1; i &lt; arguments.length; i++) {<br/>        var nextSource = arguments[i];<br/>        if (nextSource === undefined || nextSource === null) {<br/>          continue;<br/>        }<br/>        nextSource = Object(nextSource);<br/><br/>        var keysArray = Object.keys(nextSource);<br/>        for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {<br/>          var nextKey = keysArray[nextIndex];<br/>          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);<br/>          if (desc !== undefined &amp;&amp; desc.enumerable) {<br/>            to[nextKey] = nextSource[nextKey];<br/>          }<br/>        }<br/>      }<br/>      return to;<br/>    }<br/>  });</span></pre><h2 id="1acc" class="ko kp iq bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">传播算子</h2><p id="b4cc" class="pw-post-body-paragraph ku kv iq kw b kx mt jr kz la mu ju lc ld mv lf lg lh mw lj lk ll mx ln lo lp ij bi translated">如果您使用的是最新版本的JavaScript库，可以使用spread运算符进行深度克隆。spread operator刚推出的时候，很神奇。它似乎解决了JavaScript开发人员面临的许多问题。然而，随着时间的推移，使用spread操作符的缺陷逐渐显现。如果对象不是嵌套的，则展开操作符会创建一个深度克隆。但是，当您有嵌套对象时，spread运算符会创建第一个级别的深层克隆，以及更深层别的浅层克隆。让我们用一个例子来理解这一点:</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="e33d" class="ko kp iq kk b gy kq kr l ks kt">var parent =  [1,2,[3,[4,5]]]<br/>var lets_clone = [...parent]<br/>lets_clone[0] = 3 //works fine<br/>lets_clone[2][1] = 3 //here the spread operator fails</span></pre></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="3c51" class="mc kp iq bd md me nr mg mh mi ns mk ml jw nt jx mn jz nu ka mp kc nv kd mr ms bi translated">深层克隆</h1><p id="8087" class="pw-post-body-paragraph ku kv iq kw b kx mt jr kz la mu ju lc ld mv lf lg lh mw lj lk ll mx ln lo lp ij bi translated">接下来是深度克隆。<strong class="kw ir">深度克隆的工作原理是为对象中的每个元素创建新的内存地址。</strong>这意味着，新元素将独立于父元素。并且，改变一个不会影响另一个。</p><h2 id="2952" class="ko kp iq bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">自定义功能</h2><p id="17f0" class="pw-post-body-paragraph ku kv iq kw b kx mt jr kz la mu ju lc ld mv lf lg lh mw lj lk ll mx ln lo lp ij bi translated">下面是我用JavaScript深度克隆一个对象的版本。</p><pre class="kf kg kh ki gt kj kk kl km aw kn bi"><span id="6fa7" class="ko kp iq kk b gy kq kr l ks kt">var object_create = Object.create;<br/>if (typeof object_create !== 'function') {<br/>    object_create = function(o) {<br/>        function F() {}<br/>        F.prototype = o;<br/>        return new F();<br/>    };<br/>}</span><span id="d9f5" class="ko kp iq kk b gy my kr l ks kt">function <strong class="kk ir">deepClone</strong>(src) {<br/>    if(src === null || typeof(src) !== 'object'){<br/>        return src;<br/>    }<br/><br/>    //Honor native/custom clone methods<br/>    if(typeof src.clone == 'function'){<br/>        return src.clone(true);<br/>    }<br/><br/>    //Special cases:<br/>    //Date<br/>    if(src instanceof Date){<br/>        return new Date(src.getTime());<br/>    }<br/>    //RegExp<br/>    if(src instanceof RegExp){<br/>        return new RegExp(src);<br/>    }<br/>    //DOM Element<br/>    if(src.nodeType &amp;&amp; typeof src.cloneNode == 'function'){<br/>        return src.cloneNode(true);<br/>    }<br/><br/>    //Array<br/>    if (Object.prototype.toString.call(src) == '[object Array]') {<br/>        //[].slice() by itself would soft clone<br/>        var ret = src.slice();<br/><br/>        var i = ret.length;<br/>        while (i--) {<br/>            ret[i] = deepCopy(ret[i]);<br/>        }<br/>        return ret;<br/>    }<br/><br/>    //If we've reached here, we have a regular object</span><span id="a2f5" class="ko kp iq kk b gy my kr l ks kt">var proto = (Object.getPrototypeOf ? Object.getPrototypeOf(src): src.__proto__);<!-- -->    <br/>var dest = object_create(proto);<br/>    for (var key in src) {<br/>        //Note: this does NOT preserve ES5 property attributes like 'writable', 'enumerable', etc.<br/>        dest[key] = deepCopy(src[key]);<br/>    }<br/>    return dest;<br/>}<br/></span></pre><p id="6f52" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在上面的<code class="fe nw nx ny kk b">deepClone</code>函数中，我们支持多个场景。</p><ol class=""><li id="19e4" class="nz oa iq kw b kx ky la lb ld ob lh oc ll od lp oe of og oh bi translated">我们确保库的定制克隆功能不会被省略。</li><li id="4e58" class="nz oa iq kw b kx oi la oj ld ok lh ol ll om lp oe of og oh bi translated">我们首先检查要克隆的父对象是否是一个对象。</li><li id="5631" class="nz oa iq kw b kx oi la oj ld ok lh ol ll om lp oe of og oh bi translated">我们检查功能。</li><li id="26c2" class="nz oa iq kw b kx oi la oj ld ok lh ol ll om lp oe of og oh bi translated">我们也检查数组。</li><li id="f815" class="nz oa iq kw b kx oi la oj ld ok lh ol ll om lp oe of og oh bi translated">我们还会处理像“约会”这样的特殊情况。</li></ol><p id="2ebe" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">与递归解决方案(在JavaScript中通常很昂贵)相比，上述函数被证明更平滑、更简洁。</p><h1 id="51a8" class="mc kp iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="31dc" class="pw-post-body-paragraph ku kv iq kw b kx mt jr kz la mu ju lc ld mv lf lg lh mw lj lk ll mx ln lo lp ij bi translated">不管是不是JavaScript——在任何编程语言中，开发人员都需要对变量的处理方式有信心。在克隆的情况下，这是程序员常用的功能，确保每个变量都存储在唯一的内存位置是很重要的。这时，创建副本和保持数据完整变得简单多了。</p><p id="d08d" class="pw-post-body-paragraph ku kv iq kw b kx ky jr kz la lb ju lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="on">更多内容尽在</em><a class="ae oo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir"><em class="on">plain English . io</em></strong></a></p></div></div>    
</body>
</html>