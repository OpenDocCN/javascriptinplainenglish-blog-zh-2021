<html>
<head>
<title>How to Drill Into a JavaScript Object Safely With Optional Chaining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用可选链接安全地钻取JavaScript对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-drill-into-a-javascript-object-safely-with-optional-chaining-522ff3b94a46?source=collection_archive---------7-----------------------#2021-09-09">https://javascript.plainenglish.io/how-to-drill-into-a-javascript-object-safely-with-optional-chaining-522ff3b94a46?source=collection_archive---------7-----------------------#2021-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5972" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用最少的代码以无错的方式探索不确定的对象</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7767a2bb399910949f4c74530cb9da78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmB5sgzEmmLJisptp2KmIA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kv" href="https://unsplash.com/s/photos/chain-links?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="770b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://betterprogramming.pub/how-to-check-for-javascript-properties-without-mid-function-returns-46f39d09975b" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中，我写了如何在不使用中间函数返回的情况下检查可能不存在的深度嵌套的对象属性。下面是我们检查的对象类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A sample teacher object.</figcaption></figure><p id="c0ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们用不同的方法处理相同的场景。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="b118" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">场景</h1><p id="e621" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">以前，我们想要获得一个教师对象的第一个类的第一个学生。但是并不是所有的教师对象看起来都像上面的那样——或者甚至不存在。即使对象被证明是有效的，类中的<code class="fe my mz na nb b">pupils</code>属性——就此而言，还有<code class="fe my mz na nb b">classes</code>和<code class="fe my mz na nb b">data</code>属性——可能不存在。那么我们如何安全地检查第一个小学生呢？</p><p id="6fc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在上一篇文章中最终使用的<code class="fe my mz na nb b">getFirstPupil</code>函数，如下所示，使用了<code class="fe my mz na nb b">&amp;&amp;</code> (AND)操作符来递增地检查越来越深的属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Here we use the AND operator to incrementally drill into an object.</figcaption></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="656d" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">新方法</h1><p id="7c5c" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">虽然上面的函数是有效的，但实际上有一种更紧凑的方法来安全地检查深度嵌套的属性，使用一种称为<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a>的技术。使用<code class="fe my mz na nb b">?.</code>操作符，您可以检查对象中的属性，而不必验证属性链中的每个“链接”是否存在。下面是一个使用可选链接的<code class="fe my mz na nb b">getFirstPupil</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Drilling into the teacher object using optional chaining.</figcaption></figure><p id="09b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来分析一下这里发生了什么。</p><ul class=""><li id="3355" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">我们不知道<code class="fe my mz na nb b">teacher</code>是否存在，所以我们使用<code class="fe my mz na nb b">teacher?.</code></li><li id="7b25" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">假设我们得到一个<code class="fe my mz na nb b">teacher</code>对象，如果<code class="fe my mz na nb b">data</code>不存在，我们不想出错，所以我们使用<code class="fe my mz na nb b">data?.</code></li><li id="3a07" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">现在<code class="fe my mz na nb b">data</code>可能存在，但是它的<code class="fe my mz na nb b">classes</code>可能不存在，所以我们用<code class="fe my mz na nb b">classes?.</code></li><li id="3316" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">假设我们找到一个<code class="fe my mz na nb b">classes</code>数组，我们不知道它是否有任何元素，所以我们使用<code class="fe my mz na nb b">[0]?.</code>以防在索引<code class="fe my mz na nb b">0</code>处没有类。</li><li id="06c9" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">假设我们找到了一个类。如果<code class="fe my mz na nb b">pupils</code>数组不存在，我们使用<code class="fe my mz na nb b">pupils?.[0]</code>，它将给出一个<code class="fe my mz na nb b">undefined</code>值而不会抛出错误。</li><li id="495c" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">如果我们不希望在最坏的情况下有一个<code class="fe my mz na nb b">undefined</code>值，我们使用nullish合并(<code class="fe my mz na nb b">??</code>)操作符，它允许我们使用一个缺省值—在本例中是<code class="fe my mz na nb b">null</code>。</li></ul><h1 id="3c5b" class="mb mc iq bd md me nq mg mh mi nr mk ml jw ns jx mn jz nt ka mp kc nu kd mr ms bi translated">箭头功能</h1><p id="15d1" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">如果我们想用一种更简洁的方式来写它，我们可以使用一个箭头函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Using an arrow function to make this less compact.</figcaption></figure><p id="5ffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们真的只需要一行代码，我们可以去掉括号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Drilling into an object safely with a one-line function.</figcaption></figure><p id="bce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望<code class="fe my mz na nb b">getFirstPupil</code>在更大的功能中扮演助手的角色，箭头功能方法可能是理想的。</p><p id="3e99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个代码笔，它将向您展示这个一行程序的实际应用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv lt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Finding the first pupil in a teacher’s first class using optional chaining.</figcaption></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="dd3a" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">何时不使用可选链接</h1><p id="f41c" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">当思考可选链接的潜在缺点时，有两个特别引起了我的注意:掩盖您想知道的重要错误，以及关于浏览器兼容性的限制。</p><h2 id="fe08" class="nw mc iq bd md nx ny dn mh nz oa dp ml lf ob oc mn lj od oe mp ln of og mr oh bi translated">错误沉默</h2><p id="172e" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">请记住，如果某个对象或其属性确实应该存在，您可能希望代码引发错误。例如，如果一个<code class="fe my mz na nb b">teacher</code>对象和它的<code class="fe my mz na nb b">data</code>属性应该总是存在，你可能不想使用可选链接。在下面的例子中，我们只使用了<code class="fe my mz na nb b">?.</code>操作符来索引<code class="fe my mz na nb b">classes</code>数组，它可能存在也可能不存在。</p><pre class="kg kh ki kj gt oi nb oj ok aw ol bi"><span id="bfeb" class="nw mc iq nb b gy om on l oo op">let firstClass = teacher.data.classes?.[0];</span></pre><p id="6433" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果想标记不存在的<code class="fe my mz na nb b">teacher</code>或<code class="fe my mz na nb b">data</code>对象而不抛出实际错误，可以使用<code class="fe my mz na nb b">try / catch</code>块。</p><pre class="kg kh ki kj gt oi nb oj ok aw ol bi"><span id="9e95" class="nw mc iq nb b gy om on l oo op">let firstClass = null;</span><span id="1436" class="nw mc iq nb b gy oq on l oo op">try {<br/>  firstClass = teacher.data.classes?.[0];<br/>}<br/>catch (e) {<br/>   alert('Handling error here: ' + e);<br/>}</span></pre><h2 id="ac72" class="nw mc iq bd md nx ny dn mh nz oa dp ml lf ob oc mn lj od oe mp ln of og mr oh bi translated">浏览器兼容性</h2><p id="503f" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">由于可选链接是ECMAScript 2020的一部分，所以它是一个相当新的特性，并不兼容所有浏览器。下面是来自c<a class="ae kv" href="https://caniuse.com/?search=optional%20chaining" rel="noopener ugc nofollow" target="_blank">aniuse.com</a>的兼容性快照。请注意对IE的明显缺乏支持，以及对旧浏览器的有限支持。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/4e450265cfd214eb9344576eff095eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Vtyj20yuRNPjtVe7g0A_g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Optional chaining operator from caniuse.com. Data captured on 9/9/2021.</figcaption></figure><p id="6411" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自从零化聚结(？？)运算符也是ES2020的一个特性，它有<a class="ae kv" href="https://caniuse.com/?search=null%20coalescing" rel="noopener ugc nofollow" target="_blank">类似的兼容性统计数据</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/912993b23c38aac851d6ab80f7afda21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clRnigb7eigMNkn8E2agYA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Nullish coelescing operator from caniuse.com. Data captured on 9/9/2021.</figcaption></figure><p id="c112" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，如何在不破坏浏览器的情况下使用这些酷操作符呢？我推荐尝试一下<a class="ae kv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel插件</a>，它可以将前沿的JavaScript代码移植到更老的、支持更好的代码上，这些代码将得到更广泛的支持。Chetan Raj写了一篇<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/the-optional-chaining-operator-in-javascript-e151ecafcbd8">很棒的文章</a>,讲述了如何使用带有可选链接和无效合并操作符的Babel插件。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="ba28" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">对不确定的方法使用可选链接</h1><p id="a58f" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">假设我们获得了<code class="fe my mz na nb b">firstClass</code>，我们想调用一个<code class="fe my mz na nb b">getClassName()</code>方法，这个方法可能存在也可能不存在。我们还可以使用可选链接来尝试调用此方法，同时再次使用nullish合并操作符来提供默认值。</p><pre class="kg kh ki kj gt oi nb oj ok aw ol bi"><span id="7364" class="nw mc iq nb b gy om on l oo op">let firstName = firstClass.getClassName?.() ?? 'No name';</span></pre><p id="d483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，<code class="fe my mz na nb b">?.</code>操作符只允许您在前面的对象存在的情况下继续钻取，而如果您空手而归，nullish合并(<code class="fe my mz na nb b">??</code>)操作符会提供默认值。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="9fef" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">比较性能</h1><p id="b2e1" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">我很好奇我的AND运算符函数和可选的chaining函数是否有明显的性能差异，所以我测量了运行每个版本的<code class="fe my mz na nb b">getFirstPupil</code>函数一百万次需要多长时间。为了测试这一点，我为每个函数设置了一个<code class="fe my mz na nb b">for</code>循环，并使用<code class="fe my mz na nb b">performance.now()</code>获得每个循环运行前后的时间。</p><p id="9cfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在刷新后的第一次测试中，我并没有看到显著的性能差异，这通常需要更长的时间来运行。在所有后续测试中，AND操作符函数的运行速度稍快。下面是一个示例测试:</p><pre class="kg kh ki kj gt oi nb oj ok aw ol bi"><span id="fdd8" class="nw mc iq nb b gy om on l oo op">Optional chaining performance: 23.3 ms</span><span id="20a2" class="nw mc iq nb b gy oq on l oo op">AND operator performance: 16.5 ms</span></pre><p id="ca9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大多数情况下，这可能不是一个很大的区别，鉴于我只在一台机器上运行这些测试，结果绝不是决定性的。也就是说，有趣的是，更紧凑的链接方法似乎效率稍低。你可以在这个<a class="ae kv" href="https://codepen.io/nevkatz/pen/WNOpRvq" rel="noopener ugc nofollow" target="_blank">代码笔</a>上运行这些测试。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="b5eb" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">后续步骤</h1><ul class=""><li id="17bc" class="nc nd iq ky b kz mt lc mu lf ot lj ou ln ov lr nh ni nj nk bi translated">创建您自己的JavaScript对象进行检查。</li><li id="50a1" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">尝试每种方法，看看哪一种更适合你。</li><li id="1b14" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">尝试性能测试，并考虑编写自己的测试。</li><li id="4ff2" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">下载<a class="ae kv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>并考虑与这些新操作符一起使用。</li><li id="eae0" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">请看一下上一篇文章，了解更多的背景知识。</li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt ow"><a href="https://betterprogramming.pub/how-to-check-for-javascript-properties-without-mid-function-returns-46f39d09975b" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ir gy z fp pb fr fs pc fu fw ip bi translated">如何编写安全的JavaScript并避免函数中途返回</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">假设积极的一面，同时抓住灾难</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">better编程. pub</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk kp ow"/></div></div></a></div><p id="8c87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢Scotty Jamison，他在我的上一篇文章中指出了这种技术。</p><h2 id="5315" class="nw mc iq bd md nx ny dn mh nz oa dp ml lf ob oc mn lj od oe mp ln of og mr oh bi translated">参考</h2><p id="e2e4" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank"> MDN:可选链接</a></p><p id="7eab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pl">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pl">plain English . io</em></strong></a></p></div></div>    
</body>
</html>