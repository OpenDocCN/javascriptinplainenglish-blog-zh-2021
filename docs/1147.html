<html>
<head>
<title>3 MongoDB/Mongoose Schema Optimisation Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3蒙古数据库/蒙古模式优化技术</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mongodb-mongoose-schema-optimisation-ed06b3382099?source=collection_archive---------9-----------------------#2021-03-10">https://javascript.plainenglish.io/mongodb-mongoose-schema-optimisation-ed06b3382099?source=collection_archive---------9-----------------------#2021-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1044" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将介绍在创建猫鼬模式以提高应用程序查询性能时需要考虑的三件事。</p><h1 id="8056" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">1.嵌入与参考</h1><p id="fbeb" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">决定模式将对应用程序的性能有很大的影响，因为它会影响我们可以进行的查询。就我个人而言，我来自一个SQL背景，我已经习惯了对象之间的关系。</p><p id="5841" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，一只狗属于一个人，我们可以使用一个外键来建立这个关系。</p><p id="be9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">猫鼬以“参考”的形式提供类似的东西。但是，仅仅因为它在那里并不意味着它应该被使用和滥用。</p><p id="a90e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，假设您有一个显示用户详细信息的应用程序。这里有两种表示模式的可能方式:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/8902fde785bf511f339a706eb4b82e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YefyZBCu7ZW7aa9t5P-pcQ.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Option 1: Referencing similar to how it would be with SQL</figcaption></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mb"><img src="../Images/3ff09ec0ee4dabab1c589e25bd396420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gYiVupMtqj-ULp8eMpDQUg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Option 2: Embedding documents</figcaption></figure><p id="c0eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二个选项是展示如何嵌入文档。如果您来自SQL背景，您可能更熟悉第一种方法，但这需要您每次想查看每个用户的图像细节时都调用<code class="fe mc md me mf b">.populate()</code>。</p><h2 id="1b50" class="mg kj in bd kk mh mi dn ko mj mk dp ks jv ml mm kw jz mn mo la kd mp mq le mr bi translated">何时嵌入或引用</h2><ul class=""><li id="67d6" class="ms mt in jm b jn lg jr lh jv mu jz mv kd mw kh mx my mz na bi translated">当嵌入的文档不可能单独使用时，嵌入是可预先提供的。例如，如果您的应用程序将有一个显示数据库中所有照片的页面，并且不需要拥有照片的用户的任何信息，那么嵌入将不是最有效的选择。</li><li id="7e9a" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated">如果您希望嵌入的数据经常更新，嵌入是<strong class="jm io">而不是</strong>的理想选择。</li></ul><p id="af77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，当你试图用蒙古语表达感情时，请记住这些要点。</p><h1 id="be00" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak"> 2 .分度</strong></h1><p id="92ec" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Mongo文档的主索引为<code class="fe mc md me mf b">_id</code>。如果有一个您经常查询的属性，您可以向模型中添加更多的索引。例如，如果我们经常需要按用户名搜索用户，我们可以为其创建一个索引。</p><pre class="lm ln lo lp gt ng mf nh ni aw nj bi"><span id="fe00" class="mg kj in mf b gy nk nl l nm nn">personSchema.index({ name: 1 })</span></pre><p id="5d34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将为名称属性创建一个索引，文档按升序排序。</p><p id="1ad8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们经常被要求通过名字<strong class="jm io">和</strong>电子邮件查询一个人，我们也可以创建一个复合索引。</p><pre class="lm ln lo lp gt ng mf nh ni aw nj bi"><span id="759c" class="mg kj in mf b gy nk nl l nm nn">personSchema.index({ name: 1, email: 1 })</span></pre><h2 id="2d86" class="mg kj in bd kk mh mi dn ko mj mk dp ks jv ml mm kw jz mn mo la kd mp mq le mr bi translated">适度指数</h2><p id="e9f9" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">但是，需要注意的是，您不应该为曾经搜索过的每个属性添加索引。</p><p id="43a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">索引确实需要维护(每次有CRUD操作)，而且它们会占用空间。因此，添加太多可能会导致开销大于好处。</p><h1 id="953b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">3.虚拟填充</h1><p id="3506" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">假设人和博客之间存在一对一的关系。一个人可以写很多博客，但是一个博客只能有一个作者。</p><p id="1987" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们在Blog的模式中引用作者(非常类似于SQL中的外键)。</p><pre class="lm ln lo lp gt ng mf nh ni aw nj bi"><span id="bc13" class="mg kj in mf b gy nk nl l nm nn">const blogSchema = ({<br/>    title: String,<br/>    tags: [{<br/>        type: String<br/>    }],<br/>    author: {<br/>        type: Schema.Types.ObjectId,<br/>        ref: 'Person'<br/>    }<br/>})</span></pre><p id="ac90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在假设我们想找出一个人写的所有博客。实现这一点的一种方法是在Person模型中创建一个博客参考列表。</p><pre class="lm ln lo lp gt ng mf nh ni aw nj bi"><span id="361e" class="mg kj in mf b gy nk nl l nm nn">const personSchema = ({<br/>    name: String,<br/>    blogs: [{<br/>        type: Schema.Types.ObjectId,<br/>        ref: 'Blog'<br/>    }]<br/>})</span></pre><p id="30e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">建模的问题在于博客阵列会变得无限大。相反，我们可以虚拟填充！</p><pre class="lm ln lo lp gt ng mf nh ni aw nj bi"><span id="4671" class="mg kj in mf b gy nk nl l nm nn">const personSchema = ({<br/>    name: String<br/>})</span><span id="f28f" class="mg kj in mf b gy no nl l nm nn">personSchema.virtual('blogs', {<br/>    ref: 'Blog',<br/>    localField: '_id',<br/>    foreignField: 'author'<br/>})</span></pre><p id="20cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在来查找由一个叫<code class="fe mc md me mf b">personId</code>的人写的所有博客:</p><pre class="lm ln lo lp gt ng mf nh ni aw nj bi"><span id="64af" class="mg kj in mf b gy nk nl l nm nn">const blogs = await Person.findById(personId).populate('blogs')</span></pre></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="9d6f" class="mg kj in bd kk mh mi dn ko mj mk dp ks jv ml mm kw jz mn mo la kd mp mq le mr bi translated">结论</h2><p id="d39d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这些只是改进你的模型的一些方法。我希望这篇文章对您设计mongoose数据模型有所帮助！</p></div></div>    
</body>
</html>