<html>
<head>
<title>‘Build Us an Upload Form in React They Said, It Will be Fun They Said’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中为我们建立一个上传表单，他们说，这将是有趣的，他们说</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simple-file-uploading-with-react-hooks-fe89c225db57?source=collection_archive---------10-----------------------#2021-07-12">https://javascript.plainenglish.io/simple-file-uploading-with-react-hooks-fe89c225db57?source=collection_archive---------10-----------------------#2021-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8297" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何以简单的方式使用React钩子上传文件？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dc2c36f39a88da5ca2f223b556d45985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dnjMk0PxStgLhs8-ikiHQ.jpeg"/></div></div></figure><p id="4810" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你以前用JavaScript处理过文件上传，你可能会遇到一些小问题。尽管实现起来并不难，但是处理文件仍然需要你对Web API有一些基本的了解，特别是对<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener ugc nofollow" target="_blank">文件</a>和<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/FileList" rel="noopener ugc nofollow" target="_blank">文件列表</a>对象。本文旨在通过以一种易于理解的方式解释文件附件过程来缓解您可能有的任何问题。</p><p id="f228" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了介绍基础知识，我还将介绍一些巧妙的技巧，这些技巧增加了浏览器不提供的额外功能。我将介绍的两个特性如下。</p><p id="5f7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">附:如果你喜欢这个故事，可以在https://danielzuzevich.io/blog<a class="ae ln" href="https://danielzuzevich.io/blog" rel="noopener ugc nofollow" target="_blank">的我自己的网站上查看我的一些文章。</a></p><p id="0ca9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想找JavaScript导师/导师？在https://danielzuzevich.io/contact<a class="ae ln" href="https://danielzuzevich.io/contact" rel="noopener ugc nofollow" target="_blank">联系我</a></p><h2 id="a92c" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">删除</h2><p id="df0a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">默认情况下，除了附加新文件或刷新浏览器之外，没有其他方法可以删除已附加的文件。</p><h2 id="4ddf" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">附加</h2><p id="7b48" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">默认情况下，每当您附加文件时，以前附加的文件都会被删除。我们将构建一个选项来保留以前附加的文件，同时添加新的文件。</p><p id="199a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将通过绕过浏览器创建的<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/FileList" rel="noopener ugc nofollow" target="_blank">文件列表</a>对象，并使用我们自己的自定义<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">数组</a>来实现这两个特性。但是在我们掉进兔子洞之前，让我们先看看我们正在建造什么。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="726f" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">我们正在建造的东西</h1><p id="a29c" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们将建立一个表单，允许用户通过按下按钮，或通过拖放附加文件。一旦附加了任何文件，我们将在页面左侧的列表中显示它们。每个文件将显示在它自己的一行，也可以通过一个“x”图标删除。请快速浏览下面的截图，让自己适应一下，然后让我们开始吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/19bfe7a31a9fdf044eb208c296630356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1hU9Q8yHJUCScoBXlpTIg.jpeg"/></div></div></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="4389" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">设置骨骼</h1><p id="eca9" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了简洁起见，我们将使用已经包含的所有样式来定义组件的框架。这样做可以让我们更关注React代码，而不是CSS，这不是本教程的重点。在下面的代码片段中，你会注意到一些HTML元素的样式还没有包含在我们的JSX代码中。不要担心，我们将在本教程的过程中添加这些元素。</p><p id="12f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CSS相对容易理解，所以请不要让它阻止你阅读教程的其余部分。你会学到很多东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="da2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望在看到上面的截图和代码片段后，事情现在开始有意义了。现在我们的框架已经就绪，我们可以开始处理文件附件过程了。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="6e5e" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">通过点击附加文件</h1><p id="71fb" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了通过点击接受文件附件，我们必须在代码中包含HTML元素<code class="fe ni nj nk nl b">&lt;input type="file" /&gt;</code>。默认情况下，此<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file" rel="noopener ugc nofollow" target="_blank">输入元素</a>附带零样式。为了确保这个元素不会干扰我们当前的UI，我们将使用一些基本的CSS来隐藏它。即使元素将被隐藏，<strong class="kt ir">我们仍然必须与它进行交互</strong>。</p><p id="f933" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，浏览器没有公开类似于<code class="fe ni nj nk nl b">openFileAttachmentWindow</code> ( <em class="mm">这将是很棒的</em>)的神奇功能来处理文件附件，动作仍然需要由<code class="fe ni nj nk nl b">&lt;input type="file" /&gt;</code>元素触发。幸运的是，有一种简单的方法可以通过使用<code class="fe ni nj nk nl b">useRef</code> React钩子来控制元素。通过将ref附加到隐藏的input元素，我们可以从我们自己的<strong class="kt ir">按钮手动触发对它的点击，这将显示文件附件窗口。</strong></p><p id="c360" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果这没有意义，检查下面的代码来消除任何困惑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7a09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了添加一个ref，您会注意到我们还创建了一个<code class="fe ni nj nk nl b">handleClick</code>函数，并将其附加到按钮上的一个<code class="fe ni nj nk nl b">onClick</code>监听器。现在任何时候点击这个按钮，都会触发我们隐藏的输入元素，并打开文件附件窗口。</p><p id="d628" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在可以通过单击访问附件窗口，让我们为拖放配置表单。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="55cf" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">拖放</h1><p id="3fc9" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">与通过click接受文件附件不同，我们不需要依赖<code class="fe ni nj nk nl b">&lt;input type="file" /&gt;</code>元素。我们需要做的就是在我们选择的div上设置一些道具(<em class="mm">我们将使用类名为。表格</em>)，我们应该准备好了。让我们来分解一下我们需要做的事情:</p><ul class=""><li id="a0cc" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">创建一个<code class="fe ni nj nk nl b">preventBubbling</code>函数。我将很快提供更多的细节。</li><li id="316b" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">将此函数附加到类名为的div的<code class="fe ni nj nk nl b">onDragEnter</code>、<code class="fe ni nj nk nl b">onDragOver</code>和<code class="fe ni nj nk nl b">onDrop</code>道具上。形式</li></ul><p id="7827" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先快速浏览一下代码，然后我们将介绍正在发生的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="48e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你以前用过<code class="fe ni nj nk nl b">event.preventDefault()</code>，那么<code class="fe ni nj nk nl b">preventBubbling</code>功能对你来说应该很熟悉。这里没有什么疯狂的事情发生，我们只是告诉浏览器我们想自己处理拖动事件，让我们单独呆着(<em class="mm"> lol </em>)。</p><p id="b902" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你会看到我们将<code class="fe ni nj nk nl b">preventBubbling</code>直接连接到<code class="fe ni nj nk nl b">onDragEnter</code>和<code class="fe ni nj nk nl b">onDragOver</code>，但是为<code class="fe ni nj nk nl b">onDrop</code>做的事情略有不同。原因是<code class="fe ni nj nk nl b">onDrop</code>事件是所有神奇事情发生的地方，也是我们最终访问文件的地方。</p><p id="3e59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管我们现在有了点击和拖放设置的基础，<em class="mm">我们的表单仍然不是很有用</em>。我们仍然需要编写任何可以存储文件并与之交互的逻辑。让我们在下一节继续讨论这个问题。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="45f6" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">存储文件并与之交互</h1><p id="b9f8" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">尽管我们已经成功地配置了两种附加文件的方式，但是我们仍然没有编写能够处理这些文件的逻辑。为此，我们可以利用<code class="fe ni nj nk nl b">useState</code> React钩子。我已经分解了我们下一步需要做的事情:</p><ul class=""><li id="c9ba" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">创建一个名为<code class="fe ni nj nk nl b">files</code>的状态，并将其初始状态设置为null。</li><li id="4223" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">使用useState提供的setter函数将文件存储在State中。我们将把setter函数命名为<code class="fe ni nj nk nl b">setFiles</code>。</li></ul><p id="479b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">剩下要做的就是在输入元素的<code class="fe ni nj nk nl b">onDrop</code>监听器和<code class="fe ni nj nk nl b">onChange</code>监听器中使用<code class="fe ni nj nk nl b">setFiles</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="930a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好极了，我们现在可以把我们的文件保存在州政府了。让我们附加一些文件，然后console.log它们，看看我们在处理什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/4c7193feb548388d0d889577d92dcd15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZgC64yEFm3PJ4idcLFQlw.png"/></div></div></figure><p id="1373" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像你一样，我可能期待一个<em class="mm">数组文件</em>。然而，事实并非如此。浏览器被设置为返回给我们一个名为<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/FileList" rel="noopener ugc nofollow" target="_blank">文件列表</a>的<strong class="kt ir">只读</strong>数据结构。只读部分应该马上跳出来，因为它与我们希望包含在表单中的删除和附加特性直接冲突。因此，文件列表对我们来说不是一个合适的数据结构。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="aa3f" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">处理文件列表对象</h1><p id="e66a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了能够执行添加和删除，更合适的解决方案是将我们的文件列表转换为数组。为此，我们可以使用方便的<code class="fe ni nj nk nl b">Array.from</code>方法来转换它。检查下面的代码，看看我们在调用<code class="fe ni nj nk nl b">setFiles</code>的地方做了什么改变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6629" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这些，我们就成功地绕过了文件列表问题，可以开始开发我们提到的特性了。在我们开始删除和追加之前，让我们先显示列表中的文件名。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="36a6" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">显示文件名</h1><p id="296c" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">每个文件对象都有几个属性，但是我们现在只关心一个。我已经附加了一些文件，并将它们记录到控制台，这样您就可以看到一个完整的文件对象是什么样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/e409bcde6f7a93f0c24836080607ae97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJt-OdhN6MmfwOFaKKSzQw.jpeg"/></div></div></figure><p id="4b24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对我来说，<code class="fe ni nj nk nl b">name</code>地产看起来是我们用例的完美候选。为了显示名称，所需要做的就是映射到<code class="fe ni nj nk nl b">ul</code>元素内部的<code class="fe ni nj nk nl b">files</code>数组。查看下面的代码，看看它是如何做到的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1cbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，在显示列表之前，我们还检查了<code class="fe ni nj nk nl b">files</code>是否存在。这是因为我们最初将<code class="fe ni nj nk nl b">files</code>设置为空。这样一来，我们现在可以开始处理从阵列中删除文件了。</p><h1 id="832b" class="mu lp iq bd lq mv oc mx lt my od na lw jw oe jx lz jz of ka mc kc og kd mf ne bi translated">删除文件</h1><p id="7c0c" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">随着我们的文件列表的显示，我们所需要的只是一些小的添加来支持删除。我们需要做的是:</p><ul class=""><li id="af97" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">在每个文件名旁边添加一个“x”图标。</li><li id="d723" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">创建一个处理删除逻辑的函数。我们将这个函数称为<code class="fe ni nj nk nl b">removeFile</code>。</li><li id="e1de" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">将<code class="fe ni nj nk nl b">removeFile</code>连接到<code class="fe ni nj nk nl b">&lt;li&gt;</code>元件中的<code class="fe ni nj nk nl b">&lt;span&gt;</code>。</li></ul><p id="1562" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ni nj nk nl b">removeFile</code>内部，删除逻辑很简单。当我们的x图标被点击时，它将该文件的名称传递给<code class="fe ni nj nk nl b">removeFile</code>，并从数组中过滤该文件。从那里开始，我们需要做的就是把新过滤的数组设置为新的状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="7e9c" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">附加文件</h1><p id="b3b6" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">默认情况下，每当您附加新文件时，浏览器都会删除以前附加的文件。在许多用例中，这并不理想，用户体验也很差。通过重构我们的代码，我们可以纠正这个问题。</p><p id="815a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了支持附加文件，我们将为组件添加一个名为<code class="fe ni nj nk nl b">handleFiles</code>的新函数。该函数将接受两个参数:</p><ul class=""><li id="d295" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">文件列表对象</li><li id="be11" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">一串<code class="fe ni nj nk nl b">w</code>或者<code class="fe ni nj nk nl b">a</code>。w ( <em class="mm"> w将是默认参数</em>)将代表“写”，这意味着我们告诉<code class="fe ni nj nk nl b">handleFiles</code>函数在任何时候附加新文件时覆盖当前文件。相反，a代表“append ”,它会告诉<code class="fe ni nj nk nl b">handleFiles</code>保留之前附加的文件。</li></ul><p id="f13d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看一下代码，特别是新的<code class="fe ni nj nk nl b">handleFiles</code>函数，以及我们在<code class="fe ni nj nk nl b">onDrop</code>和<code class="fe ni nj nk nl b">onChange</code>监听器中调用它的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="08bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你已经密切注意，你会知道' w '参数是默认设置。如果您想重构上面的代码以不支持附加文件，您只需从调用<code class="fe ni nj nk nl b">handleFiles</code>的地方删除‘a ’,并且只使用FileList对象调用它。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="88db" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">发送文件</h1><p id="f965" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">发送文件是拼图的最后一块。要发送我们的文件，我们将使用axios库来完成。让我们在页面底部添加一个按钮，并为一个名为<code class="fe ni nj nk nl b">handleSubmit</code>的函数设置一个onClick监听器，这个函数我们还没有创建。</p><p id="a436" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，让我们定义<code class="fe ni nj nk nl b">handleSubmit</code>函数，并添加一些简单的逻辑，允许我们将文件发送到API。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9b03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中的关键部分是创建一个新的<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank"> FormData </a>对象，并将我们的文件添加到其中。一旦我们的文件被附加到FormData对象，我们需要做的就是发出一个POST请求，请求中包含标题为<code class="fe ni nj nk nl b">Conten-Type: multipart/form-data</code>的文件。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="1e72" class="mu lp iq bd lq mv mw mx lt my mz na lw jw nb jx lz jz nc ka mc kc nd kd mf ne bi translated">摘要</h1><p id="deb4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">万岁，我们的上传表格现在完成了。如果你有任何问题，请在评论区留言，我会尽快回复你。如果你喜欢这篇文章，请关注我的GitHub！</p><p id="8371" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果有人真的读了这篇文章，并想继续学习如何在服务器上接收文件，请告诉我。</p><div class="oh oi gp gr oj ok"><a href="https://github.com/DZuz14" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">DZuz14 -概述</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">阻止或报告7月8月9月10月11月12月1月2月3月4月5月6月7日周一周三Fri在1个存储库中创建了1个提交您…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kp ok"/></div></div></a></div><p id="ad3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mm">更多内容请看</em><a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>