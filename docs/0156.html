<html>
<head>
<title>3 Memes That Explain Important JavaScript Concepts You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个迷因解释了你应该知道的重要JavaScript概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-memes-c45c547c570f?source=collection_archive---------5-----------------------#2021-01-09">https://javascript.plainenglish.io/javascript-memes-c45c547c570f?source=collection_archive---------5-----------------------#2021-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7067" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以异步代码、强制和this关键字为特色</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/007c2a0b1cbd406793fd035fde4e5797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WhZeuaV4fiGEbXRX"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@bwl667?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brian Lundquist</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道——程序员的笑话没那么好笑。</p><p id="1623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，它们可以帮助传达概念。这里有3个JavaScript迷因，阐述了重要的概念！</p><h1 id="6105" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.JavaScript中的“this”</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/d403948aa36f4fd253f39a0d79f71e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcMVXB6Ai6WpEOpzFILFQA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://www.reddit.com/r/ProgrammerHumor/comments/b252lc/javascript_pain/" rel="noopener ugc nofollow" target="_blank">reddit</a></figcaption></figure><p id="1dcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个-关键字存在于所有面向对象的编程语言中。在JavaScript中，我们可以面向对象编程——但是‘this’有时表现得有点不寻常。这里有一个例子:</p><p id="e8b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个类，在这个类中，我们希望输出我们汽车的品牌。<br/>构造器确保属性“<em class="ml">品牌</em>在类中可用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="166c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们像这样运行代码，一切都正常。但是现在我们想在输出之前等待一秒钟—这并不困难，只需在<em class="ml"> nameBrand() </em> —方法中放入一个<em class="ml"> setTimeout </em>。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="8a66" class="mt lt iq mp b gy mu mv l mw mx">nameBrand() {<br/>  setTimeout(function() {<br/>    console.log(<em class="ml">this</em>.brand)<br/>  }, 1000)<br/>}</span></pre><p id="1514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错误。如果我们像这样运行代码，<em class="ml"> this.brand </em>是未定义的。</p><p id="2a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">为什么？</strong>因为我们用作回调的经典函数将“this”绑定到setTimeout。正确，对于经典的JS函数来说是这样的——但对于Arrow函数来说不是！</p><p id="66cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们只对<em class="ml"> nameBrand() </em>方法进行最小程度的修改，一切都会按预期运行:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="eeb3" class="mt lt iq mp b gy mu mv l mw mx">nameBrand() {<br/>  setTimeout(() =&gt; {<br/>    console.log(<em class="ml">this</em>.brand)<br/>  }, 1000)<br/>}</span></pre><p id="3608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">普通函数和箭头函数处理'<em class="ml">这个</em>'的方式不同。对于许多程序员来说，只有两种类型的函数是不寻常的。</p><blockquote class="my mz na"><p id="a9f6" class="kw kx ml ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated"><em class="iq">在箭头函数中，</em>这个<em class="iq">总是代表定义箭头函数的对象，因此</em>这个<em class="iq">具有封闭上下文的原始含义。</em> <br/> - <a class="ae kv" href="https://medium.com/javascript-in-plain-english/this-javascript-bca2b028e5ac" rel="noopener">我的关于JavaScript中‘this’的整篇文章</a></p></blockquote><div class="ne nf gp gr ng nh"><a href="https://medium.com/javascript-in-plain-english/this-javascript-bca2b028e5ac" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">关于JavaScript中的“this ”,你需要知道什么</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">常见问题&amp;一个ES6的例外</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div><p id="1b33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是处理“这个”时可能出现的令人困惑的情况之一。</p><h1 id="47f0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.同步还是异步？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/e92663971a763e4f3f3106e3842316e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WnsVz6cEDJxtWgxEOh3zmQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://steemit.com/busy/@felixxx/python-vs-js" rel="noopener ugc nofollow" target="_blank">steemit</a></figcaption></figure><p id="1931" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准确地说，JavaScript是一种同步编程语言。但是这到底意味着什么呢？</p><p id="6779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同步程序是逐步执行的。计算机一次只承担一项任务。只有当任务完成后，执行才会继续。</p><p id="5029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步程序也是逐步执行的——但它不一定要等待。对于要执行的任务B，任务A不必完成，而是继续在后台处理B。</p><p id="bf19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以JavaScript实际上是同步的——这种模式在执行过程中非常容易理解。但是它也有一个很大的缺点:我们程序中的流程被阻塞了，而这通常是我们不希望的。然而，在JS中，一些回调允许异步代码——例如，<em class="ml"> setTimeout </em>，而这恰恰会导致没收。</p><p id="a173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要做到这一点，让我们看看如何在Python中计时程序的执行:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="6791" class="mt lt iq mp b gy mu mv l mw mx"><em class="ml">import</em> time</span><span id="7f27" class="mt lt iq mp b gy nx mv l mw mx">time.sleep(1)</span><span id="7220" class="mt lt iq mp b gy nx mv l mw mx">print("after 1 second")</span><span id="deca" class="mt lt iq mp b gy nx mv l mw mx">print("Hello!")</span></pre><p id="59df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制台上的结果:<em class="ml">1秒后，你好！</em> <br/>前两者都是输出，但是，后一秒就过去了。所以<em class="ml"> time.sleep </em>函数中断了执行。</p><p id="7d8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想用JS实现同样的代码，首先想到的可能是这个:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="ae7e" class="mt lt iq mp b gy mu mv l mw mx">setTimeout(() =&gt; {<br/>  console.log("after 1 sec")<br/>}, 1000)</span><span id="6785" class="mt lt iq mp b gy nx mv l mw mx">console.log("Hello!")</span></pre><p id="86a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这里发生的事情是这样的:<em class="ml">你好！1秒钟后。</em></p><p id="da47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正确，<em class="ml"> setTimeout </em>不会中断程序的整个执行。这里发生的是<strong class="ky ir">异步</strong>。计算机会识别setTimeout函数，但会转到console.log —上面的代码在后台执行。</p><p id="b990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能非常令人困惑——尤其是对于来自Python这样的语言的人来说。</p><h1 id="00ed" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.强迫</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/4553363efe2a9397876949540561e133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nchuy0wCFHYnq3Vle-Ex0Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://www.instagram.com/p/B1oKoLBAosu/" rel="noopener ugc nofollow" target="_blank">redcoders</a></figcaption></figure><p id="dddc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript被认为是相当随机的——但当然不是。所有奇怪的行为背后都有一个逻辑。</p><p id="42e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网络语言是弱类型的。这意味着数据类型可以任意地相互转换，即使我们没有执行一个函数来转换它们——这是可能发生的。在像Java这样的其他语言中，这会给出一个错误。</p><p id="848e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型强制，即转换为另一种类型，可以是隐式的，也可以是显式的。如果我们有意识地想要使用cast函数转换一个类型，这就叫做显式强制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/44114438e582898fdf4aaea1bdcfdbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1ZnhNgnil411bzNkseJlw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Explicit coercion. Source: the author</figcaption></figure><p id="d1ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几乎所有的编程语言都使用类型的有意识转换。只有隐式强制是相当不寻常的——这意味着我们可以在没有传统强制转换的情况下转换数据类型，并相互进行操作。这里有一个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/e8109fe90132b46c7004e7127124be5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21sRnNtrH0kRlllgMSiLyg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Implicit coercion. Source: the author</figcaption></figure><p id="1fc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">隐式强制有许多规则，重要的是理解它的存在。来自低级语言的程序员通常很难理解这个概念。强制会导致无意的错误。</p><p id="2915" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个更复杂的关于强制的个人规则的文章。</p><p id="bec6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p><h2 id="756e" class="mt lt iq bd lu oa ob dn ly oc od dp mc lf oe of me lj og oh mg ln oi oj mi ok bi translated"><a class="ae kv" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank">加入我的简讯，了解最新消息</a></h2></div></div>    
</body>
</html>