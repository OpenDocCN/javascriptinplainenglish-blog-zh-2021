<html>
<head>
<title>“promise.any” and “promise.race” in JavaScript ES2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript ES2021中的“promise.any”和“promise.race”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/promise-any-and-promise-race-in-es2021-3250733b48eb?source=collection_archive---------7-----------------------#2021-02-13">https://javascript.plainenglish.io/promise-any-and-promise-race-in-es2021-3250733b48eb?source=collection_archive---------7-----------------------#2021-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e6fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">ES2021中的新诺言功能— <strong class="ak">《诺言.竞赛》</strong>和<strong class="ak">《诺言.任何》</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5e407ce4f49e6c4e5459125d565f1e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuABwsaULIX7bLh-_M12OQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Working with Promise Any and Race (promise.any and promise.race)</figcaption></figure><p id="2d84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">TechnoFunnel发表了另一篇关于ES2021中新的Promise特性的文章。我们将展示在您的应用程序中使用这些新函数的用法和好处。让我们创建一些承诺，并引入“<strong class="kx ir"> promise.any </strong>”和“<strong class="kx ir"> promise.race </strong>”关键字使其相同。</p><p id="364b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用JavaScript创造承诺:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/2223d8b21191db1e21428115d61366ee" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/2223d8b21191db1e21428115d61366ee</a></figcaption></figure><p id="5ab2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我们使用“<strong class="kx ir"> new promise </strong>”关键字创建了一个简单的Promise，它将“resolve”和“reject”作为参数。一旦承诺被解析，我们可以进一步给承诺附加一个回调函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/797cb54fda86145714d485a54dd773fd" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/797cb54fda86145714d485a54dd773fd</a></figcaption></figure><p id="2e31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，一旦承诺在3秒内被解决，回调函数就被触发。附加到resolve关键字的数据可供回调函数进一步处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/a24ab73ed4702c145f02611b439fe66b" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/a24ab73ed4702c145f02611b439fe66b</a></figcaption></figure><h1 id="6b90" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">拒绝承诺</h1><p id="5d31" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">类似于“解析”承诺，我们也可以拒绝承诺，并为其附加一个回调函数。当出现拒绝场景时，将调用传递给“then”关键字的第二个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/a24ab73ed4702c145f02611b439fe66b" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/a24ab73ed4702c145f02611b439fe66b</a></figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://codesandbox.io/s/currying-brook-9dd62?file=/src/index.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/currying-brook-9dd62?file=/src/index.js</a></figcaption></figure><h1 id="4a39" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">与多个承诺一起工作</h1><p id="885e" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">让我们在代码中添加多个承诺，并尝试在不同的时间间隔解析这些承诺。我们将添加4个承诺，分别在间隔3500、800、300和1000后解决。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/35aca3941f20a326e13832032ecba4d2" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/35aca3941f20a326e13832032ecba4d2</a></figcaption></figure><p id="2582" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面给出了添加到代码中的多个承诺。现在让我们看看“<strong class="kx ir"> Promise.any </strong>”和“<strong class="kx ir"> Promise.race </strong>”的用例场景。</p><h1 id="1c5a" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">使用“promise.any”</h1><p id="ad92" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">在这一节中，我们将看看使用“promise.any”的用例场景。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/f5284b5fa57c8045833b2e37ec4139d5" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/f5284b5fa57c8045833b2e37ec4139d5</a></figcaption></figure><p id="0598" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我们创建了4个不同的承诺，它们在不同的时间间隔后被解析。使用“<strong class="kx ir"> promise.any </strong>”，如果任何一个承诺被解决，回调函数被调用。回调函数等待第一个承诺被解析，并使用从列表中第一个解析的承诺接收的数据调用回调函数。</p><p id="22b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的承诺列表来看，“thirdPromise”是最先解决的承诺。一旦“第三承诺”将在300毫秒内解决，与“承诺.任何”相关联的回调函数将被调用，并且回调函数将包含由承诺三解决的数据。</p><p id="77d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之，“<strong class="kx ir"> promise.any </strong>”从数组中提到的承诺列表中查找首先解决的承诺。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://codesandbox.io/s/ancient-frog-o9po7?file=/src/index.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/ancient-frog-o9po7?file=/src/index.js</a></figcaption></figure><h1 id="84d9" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">Promise.any for Reject场景</h1><p id="f870" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">让我们看看300毫秒后会发生的拒绝场景，这是提到的承诺列表中最快的解决或拒绝。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/1c3b4d7f24635455cbc01f3f1bf936be" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/1c3b4d7f24635455cbc01f3f1bf936be</a></figcaption></figure><p id="e9d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我们可以看到有一个承诺在300ms后被拒绝。在上述情况下，将为800毫秒后解析的“secondPromise”调用“promise.any”函数回调，而不是为列表中被拒绝的承诺调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://codesandbox.io/s/fervent-water-qn0wc?file=/src/index.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/fervent-water-qn0wc?file=/src/index.js</a></figcaption></figure><h1 id="c206" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">使用“promise.race”</h1><p id="f3c1" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">类似于“<strong class="kx ir"> promise.any </strong>”，其中回调函数在成功解析或拒绝列表中的任何一个承诺时被调用。"<strong class="kx ir"> promise.race </strong>"从承诺列表中寻找第一个解决或拒绝的承诺。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/7a35e62f904ce1fed4c68be735100033" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/7a35e62f904ce1fed4c68be735100033</a></figcaption></figure><p id="e948" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我们可以看到，在任何承诺得到解决或被拒绝之前，其中一个承诺被拒绝。一旦收到拒绝，就调用回调函数。“第三次承诺”被拒绝300毫秒后，将立即调用“<strong class="kx ir"> promise.race </strong>”回调。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu ls l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae lt" href="https://codesandbox.io/s/practical-greider-pmizl?file=/src/index.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/practical-greider-pmizl?file=/src/index.js</a></figcaption></figure><h1 id="8b73" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="adf4" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">“any”和“race”之间的基本区别在于，race对已解析和已拒绝的承诺执行回调函数，而“any”函数在列表中第一次成功解析承诺时执行。</p><p id="deb0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ms">更多内容请看</em><a class="ae lt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ms">plain English . io</em></a></p></div></div>    
</body>
</html>