<html>
<head>
<title>I created the exact same app in React and Vue. Here are the differences. [2021 Edition]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2021版]</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2021-edition-a7ebfc19a9d?source=collection_archive---------0-----------------------#2021-09-05">https://javascript.plainenglish.io/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2021-edition-a7ebfc19a9d?source=collection_archive---------0-----------------------#2021-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f951" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React vs Vue。Vue和React的并列代码对比！🎉</h2></div><h1 id="0c7d" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">React vs Vue:传奇继续</h1><p id="9e51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">几年前，我决定尝试在React和Vue中构建一个相当标准的Do App。这两个应用程序都是使用默认cli构建的(react使用create-react-app，vue使用vue-cli)。我的目标是写一些不偏不倚的东西，并简单地提供如何使用这两种技术执行某些任务的快照。</p><p id="7898" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这篇文章的第一版于2018年发布，在Medium上获得了超过100万次观看和超过10万次鼓掌——这真是太疯狂了！从那以后，我每年都会跟进这篇文章，根据React和Vue中的任何新变化进行更新。</p><p id="7934" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这里是2021版！</p><h1 id="a733" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">让我们快速看一下这两款应用的外观:</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/a5bb3a63e2deb33ded7b00e4c4d10be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__8zRI5qNm6kZDtpxHmwDw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk"><strong class="bd mo">Left</strong>: React To Do 2021. <strong class="bd mo">Right</strong>: Vue To Do 2021</figcaption></figure><p id="cddf" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">两个应用程序的CSS代码完全相同，但是它们的位置不同。记住这一点，接下来让我们看看这两个应用程序的文件结构:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mp"><img src="../Images/1940f052eefac7937dc39622b119cd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8T8EcGzHjUWSNLLlseH6Q.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk"><strong class="bd mo">Left</strong>: React To Do 2021. <strong class="bd mo">Right</strong>: Vue To Do 2021</figcaption></figure><p id="c301" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">你会发现它们的结构也很相似。到目前为止，关键的区别是React应用程序有两个CSS文件，而Vue应用程序没有。这样做的原因是因为create-react-app创建其默认react组件，并为其样式创建单独的CSS文件，而Vue CLI创建包含其默认Vue组件的HTML、CSS和JavaScript的单个文件。</p><p id="fb25" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">最终，它们都实现了同样的事情，没有什么可以说你不能继续在React或Vue中以不同的方式构建你的文件。真的归结为个人喜好。您将会听到来自开发社区的关于CSS应该如何构建的大量讨论，特别是关于React，因为有许多CSS-in-JS解决方案，如styled-components和emotion。顺便说一下，CSS-in-JS就是字面上的意思。虽然这些都很有用，但现在，我们将只遵循两个CLI中的结构。</p><p id="e46b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">但是在我们继续之前，让我们快速看一下典型的Vue和React组件是什么样子的:</p><p id="9f76" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">典型的React文件:</strong></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mq"><img src="../Images/72f6bf39ae1a0ac776e2050e5a1a5c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KTs8UJ8boene3ZBt.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">A typical React component file</figcaption></figure><p id="0d68" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">一个典型的Vue文件:</strong></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="ab gu cl mr"><img src="../Images/64f606ac0f3c51796f323acc02541e0c.png" data-original-src="https://miro.medium.com/v2/format:webp/0*52L97-pYZAdcQ01K.png"/></div></figure><p id="b02b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，让我们进入本质的细节！</p><h1 id="6b3a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">我们如何改变数据？</h1><p id="0cfe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是首先，我们所说的“变异数据”是什么意思？听起来有点专业，不是吗？它基本上只是意味着改变我们已经存储的数据。所以，如果我们想把一个人的名字从约翰改成马克，我们就要“改变数据”。所以这就是React和Vue的关键区别所在。Vue本质上创建了一个数据对象，其中的数据可以自由更新，而React通过所谓的状态挂钩来处理这个问题。</p><p id="13a0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们看看下图中两者的设置，然后我们将解释接下来会发生什么:</p><p id="b320" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">反应状态:</strong></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ms"><img src="../Images/64dd2d6c6fbde46f49f049871e874838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1PtTX-imVV7_rgOk.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">React state</figcaption></figure><p id="6e1c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir"> Vue状态:</strong></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mt"><img src="../Images/a1f5954e46d76fc0bd21f31637c702c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHBt51NZponq3lPsYwlGJQ.png"/></div></div></figure><p id="cd43" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因此，您可以看到，我们将相同的数据传递给了两者，但结构略有不同。</p><p id="239f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">使用React——或者至少从2019年开始——我们通常会通过一系列挂钩来处理状态。如果你以前没有见过这种类型的概念，这些可能看起来有点奇怪。基本上，它的工作方式如下:</p><p id="d33e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">假设我们想要创建一个待办事项列表。我们可能需要创建一个名为list的变量，它可能需要一个字符串或者对象的数组(如果我们想给每个todo字符串一个ID或者一些其他的东西。我们可以通过写<code class="fe mu mv mw mx b">const [list, setList] = useState([])</code>来设置它。这里我们使用了React称之为钩子的东西——称为<code class="fe mu mv mw mx b">useState</code>。这基本上让我们在组件中保持本地状态。</p><p id="f324" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">另外，你可能已经注意到我们在<code class="fe mu mv mw mx b">useState()</code>中传递了一个空数组<code class="fe mu mv mw mx b">[]</code>。我们在里面放的是我们希望list最初被设置的值，在我们的例子中，我们希望它是一个空数组。然而，你会从上面的图片中看到，我们在数组内部传递了一些数据，这些数据最终成为list的初始化数据。想知道<code class="fe mu mv mw mx b">setList</code>是做什么的？稍后会有更多关于这个的内容！</p><p id="8c66" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Vue 3提供了两个关于如何设置数据的新变化(都使用Vue组合API)。第一种选择通常是将组件的所有可变数据放在一个<code class="fe mu mv mw mx b">setup()</code>函数中，该函数返回一个包含您想要公开的数据和函数的对象(这基本上意味着您希望能够在您的应用程序中使用的东西)。您会注意到，我们应用程序中的每个状态数据(也就是我们希望能够变异的数据)都被包装在一个<code class="fe mu mv mw mx b">ref()</code>函数中。这个<code class="fe mu mv mw mx b">ref()</code>函数是我们从Vue导入的，它使得我们的应用程序可以在任何数据发生变化/更新时进行更新。简而言之，如果想在Vue中创建可变数据，可以给<code class="fe mu mv mw mx b">ref()</code>函数分配一个变量，并将任何默认数据放入其中。</p><p id="fc13" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">最近的一个选项允许你写<code class="fe mu mv mw mx b">&lt;script setup&gt;</code>而不是写<code class="fe mu mv mw mx b">&lt;script&gt;</code>然后使用里面的<code class="fe mu mv mw mx b">setup()</code>函数。如果你走第二条路，你不需要在你的<code class="fe mu mv mw mx b">&lt;script&gt;</code>标签中包装任何类型的函数。您可以像下面的截图一样简单地保留所有内容:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mt"><img src="../Images/85b2cd35001d87c5e2b1d827df11d6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKc3B1fU8kBDe2AgvdmOMw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">A typical Vue component when using &lt;script setup&gt;</figcaption></figure><p id="f4fb" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir"> <em class="my">注:</em> </strong> <em class="my">用于Vue ToDo的GitHub repo在一个文件中使用</em> <code class="fe mu mv mw mx b"><em class="my">setup()</em></code> <em class="my">，在另一个文件中使用</em> <code class="fe mu mv mw mx b"><em class="my">&lt;script setup&gt;</em></code> <em class="my">。我们可能会在适当的时候更新这个，以便在两个文件中都使用</em> <code class="fe mu mv mw mx b"><em class="my">&lt;script setup&gt;</em></code> <em class="my">(因为这是两种方法中较新的一种)，但是现在我很乐意演示这两个选项。</em></p><h1 id="4dd1" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">那么，我们如何在应用程序中引用可变数据呢？</h1><p id="40e7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好吧，假设我们有一些名为name的数据，它被赋予了一个值<code class="fe mu mv mw mx b">Sunil</code>。</p><p id="1e26" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在React中，由于我们有了用<code class="fe mu mv mw mx b">useState()</code>创建的更小的国家，很可能我们会按照<code class="fe mu mv mw mx b">const [name, setName] = useState('Sunil')</code>的思路创建一些东西。在我们的应用程序中，我们可以通过简单地调用名字来引用相同的数据。现在，这里的关键区别是，我们不能简单地编写<code class="fe mu mv mw mx b">name = 'John'</code>，因为React有适当的限制来防止这种简单、随意的变异。所以在React中，我们会写<code class="fe mu mv mw mx b">setName('John')</code>。这就是setName位发挥作用的地方。基本上，在<code class="fe mu mv mw mx b">const [name, setName] = useState('Sunil')</code>中，它创建了两个变量，一个变成了<code class="fe mu mv mw mx b">const name = 'Sunil'</code>，而第二个<code class="fe mu mv mw mx b">const setName</code>被赋予了一个函数，使得name可以用一个新值重新创建。</p><p id="a86f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在Vue中，这将位于<code class="fe mu mv mw mx b">setup()</code>函数内部，并被称为<code class="fe mu mv mw mx b">const name = ref(‘Sunil')</code>。在我们的应用程序中，我们将通过调用<code class="fe mu mv mw mx b">name.value</code>来引用它。使用Vue，如果我们想使用在<code class="fe mu mv mw mx b">ref()</code>函数中创建的值，我们在变量上寻找<code class="fe mu mv mw mx b">.value</code>，而不是简单地调用变量。换句话说，如果我们想要保存状态的变量的值，我们寻找<code class="fe mu mv mw mx b">name.value</code>，<em class="my">而不是</em> <code class="fe mu mv mw mx b">name</code>。如果你想更新<code class="fe mu mv mw mx b">name</code>的值，你可以通过更新<code class="fe mu mv mw mx b">name.value</code>来实现。比如说，我想把我的名字从Sunil改成John。我会通过写<code class="fe mu mv mw mx b">name.value = "John"</code>来做到这一点。我不确定我被叫做约翰是什么感觉，但是嘿，事情发生了！😅</p><p id="344c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Effectively React和Vue在这里做着同样的事情，那就是创建可以更新的数据。默认情况下，每当封装在<code class="fe mu mv mw mx b">ref()</code>函数中的一段数据被更新时，Vue本质上都会组合自己的name和setName版本。React要求您用内部的值调用<code class="fe mu mv mw mx b">setName()</code>来更新状态，Vue假设如果您曾经试图更新数据对象内部的值，您会想要这样做。那么，为什么React还要费心把值从函数中分离出来，为什么还需要<code class="fe mu mv mw mx b">useState()</code>？本质上，React希望能够在状态改变时重新运行某些生命周期挂钩。在我们的例子中，如果调用了<code class="fe mu mv mw mx b">setName()</code>，React将知道某些状态已经改变，因此可以运行那些生命周期挂钩。如果您直接改变状态，React将不得不做更多的工作来跟踪变化以及运行什么生命周期挂钩等等。</p><p id="3443" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在我们已经有了一些变化，让我们看看如何在我们的待办事项应用程序中添加新的项目，从而进入本质。</p><h1 id="e863" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">我们如何创建新的待办事项？</h1><h2 id="8967" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">反应</h2><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="2025" class="mz kg iq mx b gy np nq l nr ns">const createNewToDoItem = () =&gt; {<br/>    const newId = generateId();<br/>    const newToDo = { id: newId, text: toDo };<br/>    setList([...list, newToDo]);<br/>    setToDo("");<br/>};</span></pre><h2 id="7132" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">React是怎么做到的？</h2><p id="0358" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在React中，我们的输入字段有一个名为<strong class="kz ir"> value的属性。</strong>每当这个值通过所谓的<strong class="kz ir"> onChange事件监听器</strong>发生变化时，这个值就会自动更新。JSX(基本上是HTML的一种变体)如下所示:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="e7b3" class="mz kg iq mx b gy np nq l nr ns">&lt;input<br/>    type="text"<br/>    placeholder="I need to..."<br/>    value={toDo}<br/>    onChange={handleInput}<br/>    onKeyPress={handleKeyPress}<br/>/&gt;</span></pre><p id="14fc" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">所以每次值改变时，它更新状态。handleInput函数如下所示:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="bcf6" class="mz kg iq mx b gy np nq l nr ns">const handleInput = (e) =&gt; {<br/>    setToDo(e.target.value);<br/>};</span></pre><p id="3a85" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，每当用户按下页面上的<strong class="kz ir"> + </strong>按钮来添加新项目时，就会触发<strong class="kz ir">createnewdoitem</strong>功能。让我们再来看一下这个函数，以分解正在发生的事情:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="2f8a" class="mz kg iq mx b gy np nq l nr ns">const createNewToDoItem = () =&gt; {<br/>    const newId = generateId();<br/>    const newToDo = { id: newId, text: toDo };<br/>    setList([...list, newToDo]);<br/>    setToDo("");<br/>};</span></pre><p id="8088" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">本质上，<code class="fe mu mv mw mx b">newId</code>函数基本上是创建一个新的ID，我们将赋予新的<code class="fe mu mv mw mx b">toDo</code>项目。<code class="fe mu mv mw mx b">newToDo</code>变量是一个对象，它具有一个id键，该键的值来自newId。它还有一个<code class="fe mu mv mw mx b">text</code>键，将来自<code class="fe mu mv mw mx b">toDo</code>的值作为它的值。这与输入值改变时更新的<code class="fe mu mv mw mx b">toDo</code>相同。</p><p id="462a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然后我们运行setList函数，并传入一个数组，该数组包含我们的整个<code class="fe mu mv mw mx b">list</code>以及新创建的<code class="fe mu mv mw mx b">newToDo</code>。</p><p id="6262" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果<code class="fe mu mv mw mx b">...list</code>，位看起来很奇怪，那么开头的三个点就是所谓的spread运算符，它基本上传递来自<code class="fe mu mv mw mx b">list</code>的所有值，但作为单独的项，而不是简单地将整个项数组作为数组传递。迷茫？如果是这样，我强烈推荐阅读spread，因为它很棒！</p><p id="8a67" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">总之，最后我们运行<code class="fe mu mv mw mx b">setToDo()</code>，传入一个空字符串。这使得我们的输入值为空，准备好输入新的toDos。</p><h2 id="b001" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">某视频剪辑软件</h2><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="bde6" class="mz kg iq mx b gy np nq l nr ns">function createNewToDoItem() {<br/>    const newId = generateId();<br/>    list.value.push({ id: newId, text: todo.value });<br/>    todo.value = "";<br/>}</span></pre><h2 id="0b23" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">Vue是怎么做到的？</h2><p id="c3ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在Vue中，我们的<strong class="kz ir">输入</strong>字段上有一个名为<strong class="kz ir"> v-model </strong>的句柄。这允许我们做一些被称为双向绑定的事情。让我们快速查看一下我们的输入字段，然后我们将解释这是怎么回事:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="b5b3" class="mz kg iq mx b gy np nq l nr ns">&lt;input<br/>    type="text"<br/>    placeholder="I need to..."<br/>    v-model="todo"<br/>    v-on:keyup.enter="createNewToDoItem"<br/>/&gt;</span></pre><p id="2f65" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">V-Model将该字段的输入与我们在<code class="fe mu mv mw mx b">setup()</code>函数顶部创建的一个变量联系起来，然后在我们返回的对象内部公开为一个键。到目前为止，我们还没有涉及从对象返回的内容，所以为了您的信息，这里是我们从<strong class="kz ir"> ToDo.vue </strong>中的<code class="fe mu mv mw mx b">setup()</code>函数返回的内容:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="692c" class="mz kg iq mx b gy np nq l nr ns">return {<br/>    list,<br/>    todo,<br/>    showError,<br/>    generateId,<br/>    createNewToDoItem,<br/>    onDeleteItem,<br/>    displayError<br/>};</span></pre><p id="6509" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在这里，<code class="fe mu mv mw mx b">list</code>、<code class="fe mu mv mw mx b">todo</code>和<code class="fe mu mv mw mx b">showError</code>是我们的有状态值，而其他的都是我们希望能够在应用程序的其他地方调用的函数。好了，从我们的切线回来，当页面加载时，我们将<code class="fe mu mv mw mx b">todo</code>设置为空字符串，如下:<code class="fe mu mv mw mx b">const todo = ref("")</code>。如果这里已经有一些数据，比如<code class="fe mu mv mw mx b">const todo = ref("add some text here"):</code>,我们的输入字段将加载已经在输入字段中的<code class="fe mu mv mw mx b"><em class="my">add some text here</em></code>。无论如何，回到空字符串，我们在输入域中输入的任何文本都会被绑定到<code class="fe mu mv mw mx b">todo.value</code>。这实际上是双向绑定——输入字段可以更新<code class="fe mu mv mw mx b">ref()</code>值，而<code class="fe mu mv mw mx b">ref()</code>值可以更新输入字段。</p><p id="b33e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">所以回头看看前面的<code class="fe mu mv mw mx b">createNewToDoItem()</code>代码块，我们看到我们将<code class="fe mu mv mw mx b">todo.value</code>的内容推入<code class="fe mu mv mw mx b">list</code>数组——通过将<code class="fe mu mv mw mx b">todo.value</code>推入<code class="fe mu mv mw mx b">list.value</code>——然后将<code class="fe mu mv mw mx b">todo.value</code>更新为一个空字符串。</p><p id="805e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们还使用了React示例中使用的相同的<code class="fe mu mv mw mx b">newId()</code>函数。</p><h1 id="ab3c" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">我们如何从列表中删除？</h1><h2 id="c60f" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">反应</h2><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="4583" class="mz kg iq mx b gy np nq l nr ns">const deleteItem = (id) =&gt; {<br/>    setList(list.filter((item) =&gt; item.id !== id));<br/>};</span></pre><h2 id="622b" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">React是怎么做到的？</h2><p id="e473" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，虽然<code class="fe mu mv mw mx b">deleteItem()</code>函数位于<strong class="kz ir"> ToDo.js </strong>中，但我可以很容易地在<strong class="kz ir"> ToDoItem.js </strong>中引用它，首先，将<code class="fe mu mv mw mx b"><strong class="kz ir">deleteItem()</strong></code> <strong class="kz ir"> </strong>函数作为一个属性传递:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="9b6a" class="mz kg iq mx b gy np nq l nr ns">&lt;ToDoItem key={item.id} item={item} deleteItem={deleteItem} /&gt;</span></pre><p id="7aca" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这首先将功能向下传递，使孩子可以访问它。然后，在<strong class="kz ir"> ToDoItem </strong>组件中，我们执行以下操作:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="a0b6" class="mz kg iq mx b gy np nq l nr ns">&lt;button className="ToDoItem-Delete" onClick={() =&gt; deleteItem(item.id)}&gt;<br/>    -<br/>&lt;/button&gt;</span></pre><p id="fe47" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">要引用父组件中的函数，我只需引用<code class="fe mu mv mw mx b">props.deleteItem</code>。现在你可能已经注意到了，在代码示例中，我们只是写了deleteItem而不是props.deleteItem。这是因为我们使用了一种称为<strong class="kz ir">的技术来析构</strong>，这允许我们获取部分<code class="fe mu mv mw mx b">props</code>对象并将它们赋给变量。因此，在我们的<strong class="kz ir"> ToDoItem.js </strong>文件中，我们有以下内容:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="0bdb" class="mz kg iq mx b gy np nq l nr ns">const ToDoItem = (props) =&gt; {<br/>    const { item, deleteItem } = props;<br/>}</span></pre><p id="9c3c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这为我们创建了两个变量，一个叫做item，它被赋予与<code class="fe mu mv mw mx b">props.item</code>相同的值，另一个叫做<code class="fe mu mv mw mx b">deleteItem</code>，它被赋予来自<code class="fe mu mv mw mx b">props.deleteItem</code>的值。我们可以通过简单地使用<code class="fe mu mv mw mx b">props.item</code>和<code class="fe mu mv mw mx b">props.deleteItem</code>来避免整个析构过程，但是我认为这值得一提！</p><h2 id="cb90" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">某视频剪辑软件</h2><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="e5a7" class="mz kg iq mx b gy np nq l nr ns">function onDeleteItem(id) {<br/>    list.value = list.value.filter(item =&gt; item.id !== id);<br/>}</span></pre><h2 id="3b1b" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">Vue是怎么做到的？</h2><p id="dab7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在Vue中需要一种稍微不同的方法。我们必须做三件事:</p><p id="ba9d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">首先，在我们想要调用函数的元素上:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="4b21" class="mz kg iq mx b gy np nq l nr ns">&lt;button class="ToDoItem-Delete" @click="deleteItem(item.id)"&gt;<br/>    -<br/>&lt;/button&gt;</span></pre><p id="13fb" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然后我们必须创建一个emit函数作为子组件内部的方法(在本例中是<strong class="kz ir"> ToDoItem.vue </strong>)，如下所示:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="9034" class="mz kg iq mx b gy np nq l nr ns">function deleteItem(id) {<br/>    emit("delete", id);<br/>}</span></pre><p id="48d0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">与此同时，你会注意到当我们在<strong class="kz ir"> ToDo.vue </strong>内添加<strong class="kz ir"> ToDoItem.vue </strong>时，我们实际上引用了一个<strong class="kz ir">函数</strong>:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="7b1d" class="mz kg iq mx b gy np nq l nr ns">&lt;ToDoItem v-for="item in list" :item="item" @delete="onDeleteItem" :key="item.id" /&gt;</span></pre><p id="d46a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这就是所谓的自定义事件侦听器。它监听任何使用字符串<code class="fe mu mv mw mx b">‘delete’</code>触发发射的情况。如果它听到这个消息，就会触发一个名为<strong class="kz ir"> onDeleteItem </strong>的函数。该函数位于<strong class="kz ir"> ToDo.vue </strong>中，而不是<strong class="kz ir"> ToDoItem.vue </strong>中。如前所述，这个函数只是从<code class="fe mu mv mw mx b">list.value</code>数组中过滤出<code class="fe mu mv mw mx b">id</code>。</p><p id="f873" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这里值得注意的是，在Vue示例中，我可以简单地在<code class="fe mu mv mw mx b">@click</code>侦听器中编写<code class="fe mu mv mw mx b">$emit</code>部分，如下所示:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="748d" class="mz kg iq mx b gy np nq l nr ns">&lt;button class="ToDoItem-Delete" @click="emit("delete", item.id)"&gt;<br/>    -<br/>&lt;/button&gt;</span></pre><p id="565e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这会将步骤数从3个减少到2个，这完全取决于个人偏好。</p><p id="b3d6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">简而言之，React中的子组件将通过<strong class="kz ir"> props </strong>访问父函数(假设你正在向下传递props，这是相当标准的做法，你会在其他React示例中遇到这种情况)，而在Vue中，你必须从子组件发出事件，这些事件通常会在父组件中收集。</p><h1 id="7e05" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">我们如何传递事件侦听器？</h1><h2 id="6eb9" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">反应</h2><p id="42df" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">诸如点击事件等简单事件的事件侦听器是直接的。以下是我们如何为创建新ToDo项目的按钮创建click事件的示例:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="a2e9" class="mz kg iq mx b gy np nq l nr ns">&lt;button className="ToDo-Add" onClick={createNewToDoItem}&gt;<br/>    +<br/>&lt;/button&gt;</span></pre><p id="eccf" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这里非常简单，看起来很像我们用普通JS处理内嵌onClick的方式。正如在Vue一节中提到的，每当按下enter按钮时，设置一个事件监听器来处理它要花一点时间。这实际上要求输入标记处理onKeyPress事件，如下所示:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="faf6" class="mz kg iq mx b gy np nq l nr ns">&lt;input<br/>    type="text"<br/>    placeholder="I need to..."<br/>    value={toDo}<br/>    onChange={handleInput}<br/>    onKeyPress={handleKeyPress}<br/>/&gt;</span></pre><p id="2f31" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">每当该函数识别出“enter”键被按下时，就会触发<strong class="kz ir">createnewdoitem</strong>函数，如下所示:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="a4d1" class="mz kg iq mx b gy np nq l nr ns">const handleKeyPress = (e) =&gt; {<br/>    if (e.key === "Enter") {<br/>    createNewToDoItem();<br/>    }<br/>};</span></pre><h2 id="bcbb" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">某视频剪辑软件</h2><p id="353f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在Vue中，这是非常直接的。我们简单地使用<code class="fe mu mv mw mx b">@</code>符号，然后是我们想要做的事件监听器的类型。例如，要添加一个点击事件监听器，我们可以编写如下代码:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="8831" class="mz kg iq mx b gy np nq l nr ns">&lt;button class="ToDo-Add" @click="createNewToDoItem"&gt;<br/>    +<br/>&lt;/button&gt;</span></pre><p id="73c6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">注:<code class="fe mu mv mw mx b">@click</code>其实是<code class="fe mu mv mw mx b">v-on:click</code>的简写。Vue事件侦听器最酷的一点是，您还可以将许多东西链接到它们上面，比如。once防止事件侦听器被触发多次。在编写处理击键的特定事件侦听器时，也有许多快捷方式。我发现，每当按下enter按钮时，在React中创建一个事件侦听器来创建新的ToDo项会花费相当长的时间。在Vue中，我可以简单地写下:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="51b3" class="mz kg iq mx b gy np nq l nr ns">&lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&gt;</span></pre><h1 id="9ba8" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">我们如何将数据传递给子组件？</h1><h2 id="6c01" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">反应</h2><p id="f5f4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在React中，我们在创建子组件时将道具传递给子组件。比如:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="98aa" class="mz kg iq mx b gy np nq l nr ns">&lt;ToDoItem key={item.id} item={item} deleteItem={deleteItem} /&gt;;</span></pre><p id="c429" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这里我们看到两个道具被传递给了<strong class="kz ir"> ToDoItem </strong>组件。从这一点开始，我们现在可以通过this.props在子组件中引用它们。你可能已经注意到还有一个<code class="fe mu mv mw mx b">key</code>道具(所以从技术上来说，我们实际上传递了三个道具)。这主要是针对React的内部，因为它使得在同一组件的多个版本之间进行更新和跟踪更改变得更加容易(我们在这里这样做是因为每个<strong class="kz ir"> todo </strong>都是<code class="fe mu mv mw mx b">ToDoItem</code>组件的副本)。确保您的组件有惟一的键也很重要，否则React会在控制台中警告您。</p><h2 id="e350" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">某视频剪辑软件</h2><p id="b944" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在Vue中，我们在创建子组件时将道具传递给子组件。比如:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="9f24" class="mz kg iq mx b gy np nq l nr ns">&lt;ToDoItem v-for="item in list" :item="item" @delete="onDeleteItem" :key="item.id" /&gt;</span></pre><p id="9bbd" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">完成后，我们将它们传递给子组件中的props数组，如下:<code class="fe mu mv mw mx b">props: [ "todo" ]</code>。然后可以在子节点中通过它们的名字引用它们——所以在我们的例子中是<code class="fe mu mv mw mx b">todo</code>。如果您不确定在哪里放置那个<code class="fe mu mv mw mx b">prop</code>键，下面是整个<code class="fe mu mv mw mx b">export default</code>对象在我们的子组件中的样子:</p><pre class="lz ma mb mc gt nl mx nm nn aw no bi"><span id="a15a" class="mz kg iq mx b gy np nq l nr ns">export default {<br/>    name: "ToDoItem",<br/>    props: ["item"],<br/>    setup(props, { emit }) {<br/>        function deleteItem(id) {<br/>        emit("delete", id);<br/>        }<br/>        return {<br/>        deleteItem,<br/>        };<br/>    },<br/>};</span></pre><p id="6785" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><em class="my">有一点你可能已经注意到了，当在Vue中循环数据时，我们实际上只是循环了</em> <code class="fe mu mv mw mx b"><em class="my">list</em></code> <em class="my">而不是</em> <code class="fe mu mv mw mx b"><em class="my">list.value</em></code> <em class="my">。试图通过</em> <code class="fe mu mv mw mx b"><em class="my">list.value</em></code> <em class="my">循环在这里行不通</em></p><h1 id="aff7" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">我们如何将数据发送回父组件？</h1><h2 id="70e8" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">反应</h2><p id="eaca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们首先将函数传递给子组件，在调用子组件的地方将它作为一个道具进行引用。然后我们通过引用<strong class="kz ir">props . whateverthefunction被称为</strong>——或者<strong class="kz ir">whateverthefunction被称为</strong>(如果我们使用了析构的话),通过任何方式在子节点上添加函数调用，比如<strong class="kz ir"> onClick </strong>。这将触发父组件中的函数。我们可以在“如何从列表中删除”一节中看到整个过程的示例。</p><h2 id="d013" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">某视频剪辑软件</h2><p id="ad64" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我们的子组件中，我们只需编写一个函数，将值发送回父函数。在我们的父组件中，我们编写了一个函数来监听何时发出该值，然后触发一个函数调用。我们可以在<em class="my">“如何从列表中删除”一节中看到整个过程的示例。</em></p><h1 id="5705" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">我们做到了！🎉</h1><p id="9859" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们已经了解了如何添加、删除和更改数据，如何以props的形式将数据从父节点传递到子节点，以及如何以事件侦听器的形式将数据从子节点发送到父节点。当然，React和Vue之间还有许多其他的小差异和怪癖，但是希望本文的内容有助于为理解这两个框架如何处理东西提供一点基础。</p><p id="a3d8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果您对本文中使用的样式感兴趣，并想制作您自己的等效作品，请随时这样做！👍</p><h1 id="c31a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Github链接到两个应用程序:</h1><p id="b4a9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">https://github.com/sunil-sandhu/vue-todo-2021</p><p id="c536" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">https://github.com/sunil-sandhu/react-todo-2021<a class="ae nt" href="https://github.com/sunil-sandhu/react-todo-2021" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h2 id="cda2" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">本文的2020版本</h2><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2020-edition-36657f5aafdc"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2020版]</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">现在用React Hooks vs Vue 3 +合成API！</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="oo l op oq or on os mi oe"/></div></div></a></div><h2 id="dfe5" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">本文2019版</h2><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2019-edition-42ba2cab9e56"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2019版]</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">React vs Vue。最后是Vue和React的并列代码对比！🎉[2019年更新:现在与React…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="ot l op oq or on os mi oe"/></div></div></a></div><h2 id="0766" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">本文2018版</h2><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">React vs Vue。最后是Vue和React的并列代码对比！🎉</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="ou l op oq or on os mi oe"/></div></div></a></div><p id="3a44" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><em class="my">如果你想把这篇文章翻译成另一种语言，请继续这样做——当它完成时让我知道，以便我可以把它添加到上面的翻译列表中。</em></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="6ad3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><em class="my">更多内容请看</em><a class="ae nt" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir"><em class="my">plain English . io</em></strong></a></p></div></div>    
</body>
</html>