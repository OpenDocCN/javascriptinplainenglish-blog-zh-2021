# 使用 SVG 以角度构建范围滑块

> 原文：<https://javascript.plainenglish.io/building-a-range-slider-with-svgs-in-angular-f67fde71d161?source=collection_archive---------3----------------------->

![](img/e74f364186251c1168955ecb9d4a78ac.png)

又是在办公室的一天，我被困在一个任务上，我们的客户要求一个特定的功能(一个范围滑块)。

> "它必须有过多的特定选项和定制."顾客问道。

在旧版本的应用程序中，这似乎是由古时候的开发人员使用的库来处理的，但是现在不再支持了。这也会带来更多的痛苦而不是快乐。所以我转向研究，花一些时间试图理解我们如何扩展一个通用的范围滑块。在花了几个小时翻阅不同的文章和书籍后，我偶然发现了一种方法，其中 **SVGs** 将在浏览器 **DOM** 中呈现，以创建**定制元素**。增强我发现的带有浏览器事件的蓝图，你能够控制这些元素的每一个方面。

> TLDR:你可以在这里找到最终解决方案

现在，让我通过构建我们自己的范围滑块来分享我收集的知识，在这里，我们将经历基本的 SVG 操作，然后使用浏览器事件处理创建的元素。

> 浏览器中的 SVG 是什么，我们如何渲染它们？

如果你看一下 [MDN](https://developer.mozilla.org/en-US/docs/Web/SVG) docs，你会发现有很多你可以渲染的元素。

这一切都从一个简单的 **< SVG >** 标签开始。我们应该定义一个高度和宽度(你可以像在示例代码中那样内联定义，或者你也可以把它放在你的 CSS 文件的类中，并用指定的类标记 SVG。这会使溶液更干净；) )

在这个 SVG 标签中，我们可以放入任何我们想要的元素，但是让我们从一个普通的元素开始，比如一个矩形。像前面一样，定义宽度、高度、填充
(用于填充矩形的颜色)、rx(也称为 border-radius)和 y(垂直偏移，从顶部开始)。
但是不要误以为所有这些属性都可以插入 CSS 中，因为有些是 SVG 属性，在文件中不会被识别。 **Chrome** 作为浏览器对它还是挺仁慈的，但是其他浏览器比如 **Mozzila** 就不喜欢；)

我在它上面添加了另一个矩形，这样它可以显示选择。这一个将有一个预定义的宽度 200px，它将在稍后被绑定到组件中的一个变量。

现在让我们添加我们的**拇指** ( **指针**、**选择器、**或任何其他你想叫它的方式)，我们将**拖动**来设置**范围滑块**的值。
为了填充这个角色，我们将选择**椭圆**。
我们可以使用 **cx** 和 **cy** 设置 **x** 和 **y** 位置，使用 **rx** 和 **ry** 属性设置**宽度**和**高度**。如果我想让拇指稳稳地坐在彩色线的末端，我会选择 **200px** 作为我对 **cx** 的输入。对于 **cy** ，我会选择 **7.5** 。

**为什么？**因为要在线的中间，我必须考虑 y 偏移的 5 个点，5px 线的中心是 2.5，**所以 7.5 就是**:)

作为最后的收尾工作，我们可以在滑块上添加百分比标签。为此，我们需要使用 **<文本>** 标记。

但是在我接触 **HTML** 之前，让我给 **component.ts，**添加一个标签的**数组，然后我可以在 **HTML 模板**中迭代它。**

现在我可以使用 Angular magic 为使用**NGF 生成文本标签。我将使用来自 **ngFor，**的索引来获取文本元素的 x 位置。**

如你所见，我还在文本中添加了一些**样式**。
这些确保文本的**锚在**中心**而不是在左边缘。**

> 为了设置 X 位置，我使用了[]括号，但是我还需要将**属性**作为前缀，以便能够操作 **SVG 属性**。

在这里，我插入我的自定义函数，它将获得标签的位置。

> (我用 i + 1 划分宽度，因为我想让宽度被**3**3**标签**分成 **4 段**。然后我将它乘以 i + 1，因为我希望第一个标签偏移段宽度)。

我现在不得不添加一个模拟宽度，因为我们没有真正的屏幕宽度，但我们将在一秒钟内到达。

现在让我们得到组件的实际宽度，这样我们可以做一些适当的操作。我不太喜欢从组件内部查询元素的方法，但这确实符合它的目的，那就是为我们提供所请求的元素属性。

最好是利用**包装器的 **ID** (不是**类**)，或者 SVG 本身**，因为它们在页面中必须是唯一的。您应该在初始化时为元素生成 ID(ngOnInit)。
可以利用 **this.constructor.name** 和 **lodash uniqueId()** ，生成唯一的**element id**；).

一旦有了 **ID** ，就可以在函数中查询它，或者直接在 **ngOnInit** 中查询，然后将元素引用存储在本地属性中:)

现在你可以改变 getLabelXPosition 中的参数( **width** 为 **getTotalWidth()** )

瞧，我们应该看到标签在正确的位置。

很好，我们已经建立了 SVG 的基础。
现在尝试调整浏览器窗口的大小。你应该看到线条随着它的宽度而变化，但是拇指和填充的线条保持不变。如果你把窗口做得足够小，它们就会移出框架。

那么我们能做些什么呢？

正如你所知，我们已经在填充线的**宽度和拇指**的 **x 位置中放置了一个**静态值**，所以我们需要提供一个可以动态变化的值。所以让我们把现有的值换成函数**getline width()**&**getThumbPosition()**。**

由于我们希望滑块从**0–100**(因此标签为 25、50、75)移动，我们可以只使用**0–1**之间的值来确定拇指位置(滑块上的百分比位置)。之后，我们只需要将它乘以滑块的宽度，就可以得到实际的 x 位置。灌装线也是如此。

在这一点上，我们有自我调整 **SVG** 似乎没有掉线，耶！:)

所以让我们增加一点互动性。

我们将使用 **@HostListener** 注释来监听浏览器事件。特别是**鼠标按下**，我们将用它作为**拖动**以及**重新定位**拇指的起点。
我已经创建了一个公共函数 **updateThumbPosition()** ，我们稍后也可以将它用于触发运动的其他事件。

如你所见，我们已经设置了一个布尔变量 **isDragStarted** ，稍后我们将使用它来确定用户是否在拖动。

> 你可能会问为什么？

因为我们将监听**鼠标移动**，每当鼠标移动到 **SVG 上时，该事件就会被触发。**
但是你可以想象，我们希望它只在用户点击**时被触发。**

因此，让我们将 3 个缺少的事件添加到**中，允许拇指可拖动**，而不仅仅是**可点击** ( **mousemove、mouseup、mouseleave** )。

**Mousemove** ，将处理**拖动**，但是就像我之前说的，它在任何鼠标在 **SVG** 上移动时被触发，所以它需要被修补。因此，只有当用户已经点击了鼠标( **mousedown** )时，我们才会触发拇指位置的更新。
事件 **mouseup** 和 **mouseleave** 将**成为我们拖拽**的结束者。所以每当用户释放鼠标按钮，或者简单地离开 SVG 区域，**我们将释放拖拽**。

我们还需要**阻止 **mousemove 事件**的默认**并停止传播，因为当你拖动滑块时，你可以选择标签，这将影响拖动。

还有一件事。

就像我一开始说的，你需要处理所有可能发生的行为和副作用。因此，在这里再添加一个事件侦听器可能是值得的，我们可以禁用它。
**拖动启动**也可能**导致不必要的行为**，通过阻止它，我们可以消除可能的问题(比如用拇指拖动标签……)

> 很好，所以我们有了一个全功能的 SVG 滑块。

我为我们感到骄傲！当然，我们遗漏了一个关键的东西。

**移动支持！**

怎么了？怎么会？

嗯，你可以想象**鼠标点击只支持台式机**，**在手机上我们需要实现‘触摸’事件** ( **触摸开始，触摸移动，触摸结束**)；)对我们来说 **touchmove** 应该涵盖所有移动和触摸的情况，因此这是我们唯一需要做的添加。无论如何，我想在这里再做一件事，那就是，用另一个 div 包装我们现有的代码，这将有一个 40px 的边缘。

**为什么？嗯，因为我想让你观察一件事。
那么让我们应用代码更改，看一看。**

> 当您在浏览器中单击并拖动滑块时，它的行为是正确的，对吗？

但是让我们打开**开发者工具**，如果在 **chrome** 上工作，默认情况下应该会把你的鼠标换成**点击模拟器**。

现在尝试点击并拖动滑块。

注意到什么奇怪的事了吗？是吗？它与你的触摸指针不对齐？

这正是我想给你看的。
现在想象一个场景，你想在应用程序中的任何地方使用这个组件，你试着点击滑块，但是拇指在任何地方跳动，但是你的手指却落在那里。

> 这不是我们想要的行为。那么我们可以用这个做什么呢？

实际上，触摸的位置被元素偏移量所抵消。我们能做的是得到 SVG 元素的**左界，然后**从 touch clientX** 中减去它。
这样我们就能得到实际的触摸位置。但是在我们这样做之前，让我们稍微重构一下代码。**

我们可以**移除包装器 div** ，并且**将 id 直接添加到 SVG** (那里并不真正需要 div)。然后我们可以**将 svgElement 变量**添加到组件中，我们**将在 Init** 上初始化它，然后我们应该能够在应用程序中访问它。

因此，我们也可以在 getTotalWidth 函数中替换它(不再需要在这里查询元素)。

最后，让我们使用**this . SVG element . getboundingclientrect()减去元素的左边界。左侧**。

仅此而已。现在，当您尝试移动滑块时，它应该牢牢地定位在您的指针上，即使是点击:)

> 本文到此结束:)

我们仍然可以实现一些东西，比如绑定 thumb(这样它就不会移出屏幕)，在 **mousemove、mousedown、touchmove 事件**之后添加输出事件，这样它们就可以被父元素捕获，等等…

但是如果你真的需要的话，我会把这些都留给你去玩:)

下次见！:)