<html>
<head>
<title>Create a React Project from scratch with TypeScript &amp; Parcel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript &amp; Parcel从头开始创建React项目</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-project-from-scratch-with-typescript-parceljs-952667a24706?source=collection_archive---------15-----------------------#2021-01-04">https://javascript.plainenglish.io/react-project-from-scratch-with-typescript-parceljs-952667a24706?source=collection_archive---------15-----------------------#2021-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1729f59dfa14b5d0cdf42b6c770ce82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dbn9cYAZwrt7pe0x.png"/></div></div></figure><p id="23a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我将解释如何从零开始设置一个react项目，而不使用流行的<code class="fe kt ku kv kw b">create-react-app</code>方法。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="733f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要为我们的项目文件创建一个目录。根据您的操作系统，打开您的终端或命令提示符，运行以下命令创建一个目录并导航到该目录。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="dd69" class="lm ln in kw b gy lo lp l lq lr">mkdir awesome-react-project &amp;&amp; cd awesome-react-project</span></pre><p id="4ada" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要创建一个新的Node.js项目。我打算用npm来做这个，但是如果你喜欢的话，也可以随意用yarn。以下命令将在先前创建的目录中创建一个package.json文件。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="3967" class="lm ln in kw b gy lo lp l lq lr">npm init -y</span></pre><p id="551f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于这是一个React web应用程序项目，我们需要两个主要的依赖项。第一个是React的核心<code class="fe kt ku kv kw b">react</code>，因为我们在浏览器中处理<strong class="jx io"> <em class="ls"> DOM </em> </strong>，我们需要另一个名为<code class="fe kt ku kv kw b">react-dom</code>的包。以下命令将安装这两个包。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="2576" class="lm ln in kw b gy lo lp l lq lr">npm install react react-dom</span></pre><p id="7f98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要的下一个主要依赖项是Typescript。但是这里要注意的一点是，这是一个开发依赖。这意味着我们只需要它来进行开发。当我们部署我们的web应用程序时，它将包含普通的JavaScript，因为web浏览器不能直接运行Typescript。</p><p id="01b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用以下命令将Typescript作为开发依赖项安装到我们的项目中。<code class="fe kt ku kv kw b">-D</code> flag这里是告诉<strong class="jx io"><em class="ls">NPM</em></strong><em class="ls"/>这是一个开发依赖。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="e562" class="lm ln in kw b gy lo lp l lq lr">npm install -D typescript</span></pre><p id="36b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们几乎拥有了开始工作所需的一切。但是，在此之前，因为我们使用的是Typescript，所以我们需要上述包和节点的类型。这些包将提供类型定义，同样，这些只在我们的开发环境中需要。您可以使用以下命令安装它们。如果你对这些类型定义的来源感到好奇，看看GitHub上的<a class="ae lt" href="https://github.com/DefinitelyTyped/DefinitelyTyped" rel="noopener ugc nofollow" target="_blank"> DefinitelyTyped </a>项目。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="01c6" class="lm ln in kw b gy lo lp l lq lr">npm install -D @types/node @types/react @types/react-dom </span></pre><p id="d01f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来我们需要做的是创建一个名为<code class="fe kt ku kv kw b">tsconfig.json</code>的配置文件。这将指导Typescript编译器如何编译我们的代码。我们可以手动创建这个文件，或者使用Typescript编译器为我们生成一个。</p><p id="7e3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您想手动创建这个文件，只需在我们上面创建的目录中创建一个名为<code class="fe kt ku kv kw b">tsconfig.josn</code>的文件。创建之后，目录结构应该如下所示。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="944d" class="lm ln in kw b gy lo lp l lq lr">└── awesome-react-project<br/>    ├── node_modules<br/>    ├── package.json<br/>    ├── package-lock.json<br/>    └── tsconfig.json</span></pre><p id="9514" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果您想使用Typescript编译器生成这个文件，请参考下面的部分。</p><p id="823e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们回想一下我们做了什么，我们在开始项目时安装了Typescript作为开发依赖项。Typescript包自带<code class="fe kt ku kv kw b">tsc</code> (Typescript编译器)。到目前为止，我们安装的每个包都被安装到了<code class="fe kt ku kv kw b">node_modules</code>目录中。这意味着如果我们想使用<code class="fe kt ku kv kw b">tsc</code>，我们需要从<code class="fe kt ku kv kw b">node_modules</code>目录运行它。</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lu"><img src="../Images/777d5a330b8c764dc52e0bf429721a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8sIaYt-oIfHW1vd_IjUiA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">typescript directory can be found inside the node_modules directory</figcaption></figure><p id="0b2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们仔细观察，我们可以看到<code class="fe kt ku kv kw b">tsc</code>位于<code class="fe kt ku kv kw b">node_modules/typescript/bin</code>目录中。我们可以运行这个命令并生成一个<code class="fe kt ku kv kw b">tsconfig.json.</code>，以便在我们创建的<code class="fe kt ku kv kw b">awesome-react-project</code>目录中打开您的终端并运行下面的命令。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="fbbc" class="lm ln in kw b gy lo lp l lq lr">./node_modules/typescript/bin/tsc --init</span></pre><p id="2f6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的<code class="fe kt ku kv kw b">--init</code>标志指示<code class="fe kt ku kv kw b">tsc</code>初始化一个Typescript项目并创建一个tsconfig.json文件。这和我们之前用<code class="fe kt ku kv kw b">npm --init</code>做的很像。</p><p id="3011" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建tsconfig.json文件后，用文本编辑器打开它，并按如下方式更改其内容。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="a7e7" class="lm ln in kw b gy lo lp l lq lr">{</span><span id="5899" class="lm ln in kw b gy lz lp l lq lr">   "compilerOptions": {<br/>      "target": "es5",<br/>      "module": "commonjs",<br/>      "jsx": "react",<br/>      "outDir": "./out",<br/>      "rootDir": "./src",<br/>      "strict": true,<br/>      "esModuleInterop": true,<br/>      "skipLibCheck": true,<br/>      "forceConsistentCasingInFileNames": true,<br/>      "lib": [<br/>           "es2018",<br/>           "dom"<br/>       ]   <br/>    }<br/>}</span></pre><p id="78d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们来看一下上面的配置选项。如你所见，我们正在设置编译器要使用的选项。</p><ul class=""><li id="6d75" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated">目标:指定我们的源代码应该被编译成哪个版本的ECMA脚本。这对于浏览器的可比性非常重要。</li><li id="0435" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">module:为我们的程序设置模块系统。对于节点项目，CommonJs是最常用的选择。</li><li id="e993" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">jsx:控制我们的源<code class="fe kt ku kv kw b">jsx</code>文件将如何在编译后的代码中表示。<code class="fe kt ku kv kw b">react</code>选项将把我们的源<code class="fe kt ku kv kw b">jsx</code>编译成<code class="fe kt ku kv kw b">React.createElement</code>调用。</li><li id="4053" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">outDir:为编译后的代码或者Javascript设置输出目录。</li><li id="930d" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">rootDir:设置包含源代码的目录。在这个项目中，我们将很快创建一个<code class="fe kt ku kv kw b">src</code>目录。</li><li id="e9da" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">strict:这启用了强类型检查，允许我们提前发现代码中的许多问题。</li><li id="cc00" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">esModuleInterop:这修复了一个模块导入的问题。更多信息请参考<a class="ae lt" href="https://www.typescriptlang.org/tsconfig/#esModuleInterop" rel="noopener ugc nofollow" target="_blank">文档</a>。</li><li id="c772" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">forceConsistentCasingInFileNames:当我们试图导入与磁盘上不同大小写的文件时，会抛出一个错误。</li><li id="8c73" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">lib:这些是供Typescript使用的库。您可以在<a class="ae lt" href="https://www.typescriptlang.org/tsconfig#lib" rel="noopener ugc nofollow" target="_blank">文档</a>中看到完整的解释列表。</li></ul><p id="4281" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里需要注意的一点是，Typescript有数百个配置选项。您可以参考<a class="ae lt" href="https://www.typescriptlang.org/tsconfig" rel="noopener ugc nofollow" target="_blank">类型脚本文档</a>根据您的需要进行更改，其中包含所有可用选项并附有解释。</p><p id="11bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们为源代码创建一个目录。在<code class="fe kt ku kv kw b">awesome-react-app</code>目录中，创建一个名为<code class="fe kt ku kv kw b">src</code>的新目录。然后，我们需要在那个<code class="fe kt ku kv kw b">src </code>目录下创建两个文件，分别命名为<code class="fe kt ku kv kw b">App.tsx</code>和<code class="fe kt ku kv kw b">index.tsx</code>。之后，我们需要在<code class="fe kt ku kv kw b">src</code>目录中创建另一个名为<code class="fe kt ku kv kw b">public</code>的目录。</p><p id="ec52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">index.tsx</code>将是我们应用程序的入口点(起点),而<code class="fe kt ku kv kw b">App.tsx</code>将包含一个包含所有其他组件的组件。简单来说，它会是我们的app。</p><p id="6259" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在这个<code class="fe kt ku kv kw b">public</code>目录是我们用来存储<code class="fe kt ku kv kw b">html</code>文件的目录。接下来，我们需要在<code class="fe kt ku kv kw b">public</code>目录中创建一个名为<code class="fe kt ku kv kw b">index.html</code>的文件。这将在后面进一步解释。</p><p id="8e24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终的目录结构应该是这样的，</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="bf57" class="lm ln in kw b gy lo lp l lq lr">└── awesome-react-project<br/>    ├── node_modules<br/>    ├── package.json<br/>    ├── package-lock.json<br/>    ├── src<br/>    │   ├── App.tsx<br/>    │   ├── index.tsx<br/>    │   └── public<br/>    │       └── index.html<br/>    └── tsconfig.json</span></pre><p id="8f5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要做的下一件事是在这些文件中编写一些代码。让我们从<code class="fe kt ku kv kw b">App.tsx</code>文件开始。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="d495" class="lm ln in kw b gy lo lp l lq lr">import React from "react"</span><span id="a2f3" class="lm ln in kw b gy lz lp l lq lr">export function App() {<br/>    return (<br/>       &lt;div&gt;<br/>          &lt;h1&gt;Hello!&lt;/h1&gt;<br/>       &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="c58b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在这个文件包含一个非常简单的组件，名为<code class="fe kt ku kv kw b">App</code>。如果您查看代码，可以看到它只返回一个包装在<code class="fe kt ku kv kw b">div</code>中的标题。我们将使用它作为我们的应用程序。此外，除了<code class="fe kt ku kv kw b">React</code>之外，这里没有其他依赖项。</p><p id="e5be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将处理我们的<code class="fe kt ku kv kw b">index.tsx</code>文件。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="6f62" class="lm ln in kw b gy lo lp l lq lr">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { App } from "./App";</span><span id="4b2d" class="lm ln in kw b gy lz lp l lq lr">ReactDOM.render(<br/> &lt;React.StrictMode&gt;<br/>  &lt;App /&gt;<br/> &lt;/React.StrictMode&gt;,<br/> document.getElementById("root")<br/>);</span></pre><p id="108c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，您可以看到我们导入了之前创建的<code class="fe kt ku kv kw b">App</code>组件。除此之外，我们还进口<code class="fe kt ku kv kw b">React</code>和<code class="fe kt ku kv kw b">ReactDOM</code>。我们需要这个<code class="fe kt ku kv kw b">ReactDOM</code>模块在web浏览器中呈现(显示)我们的应用程序。我在这里使用的是一个检测React代码中问题的工具。我们可以将主要组件包装在其中，并识别潜在的问题。可以在这里了解更多:<a class="ae lt" href="https://reactjs.org/docs/strict-mode.html" rel="noopener ugc nofollow" target="_blank">严格模式</a>。</p><p id="7a57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以看到，我们在这里使用的<code class="fe kt ku kv kw b">ReactDOM.render</code>方法有两个参数。第一个是我们的主要组成部分。这种情况下，就是我们的<code class="fe kt ku kv kw b">App</code>。接下来，引用了一个id为<code class="fe kt ku kv kw b">root</code>的元素。现在这不一定是一个<code class="fe kt ku kv kw b">getElementById</code>。你也可以使用像<code class="fe kt ku kv kw b">querySelector</code>这样的词。这里的要点是<strong class="jx io">这应该是对我们的html文件</strong>中的一个元素的引用。我们的应用程序组件将在这个引用的元素中呈现。所以，如果你弄错了，浏览器中什么也不会显示。</p><p id="3604" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们可以处理我们的<code class="fe kt ku kv kw b">index.html</code>文件，并把这些放在一起。如下所示编写您的<code class="fe kt ku kv kw b">index.html</code>文件。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="857e" class="lm ln in kw b gy lo lp l lq lr">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;</span><span id="3e59" class="lm ln in kw b gy lz lp l lq lr">&lt;head&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>  &lt;title&gt;Awesome React App&lt;/title&gt;<br/>&lt;/head&gt;</span><span id="e6e7" class="lm ln in kw b gy lz lp l lq lr">&lt;body&gt;<br/>  &lt;div id="root"&gt;&lt;/div&gt;</span><span id="e61b" class="lm ln in kw b gy lz lp l lq lr">  &lt;script src="./../index.tsx"&gt;&lt;/script&gt;<br/>&lt;/body&gt;</span><span id="a2bc" class="lm ln in kw b gy lz lp l lq lr">&lt;/html&gt;</span></pre><p id="fac9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果查看上面的代码，可以看到一个id为<code class="fe kt ku kv kw b">root</code>的div元素。这是我们在<code class="fe kt ku kv kw b">index.jsx</code>中提到的。React将在这个div中呈现我们的<code class="fe kt ku kv kw b">App</code>。</p><p id="5ada" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想接下来的部分会让你们很多人感到困惑。因为我们使用常规脚本标签直接链接我们的<code class="fe kt ku kv kw b">index.tsx</code>文件。(我们在路径中使用<code class="fe kt ku kv kw b">./../</code>，因为它位于公共目录之外)。据我们所知，我们不能在我们的浏览器中目录运行这些<code class="fe kt ku kv kw b">tsx</code>文件。那么，这是如何工作的呢？。</p><p id="1f22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是模块捆绑器发挥作用的地方。其中最受欢迎的一个是WebPack，你们很多人应该已经很熟悉了。是<code class="fe kt ku kv kw b"> create-react-app</code>中包含的捆绑器。</p><p id="a0a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单地说，捆绑器的任务是查看我们的源代码，找出我们使用的所有东西，包括样式表、模块、图像..等等。把它们压缩成一堆和我们的目标兼容的文件。在我们的例子中，它将是网络浏览器。通常，这些捆绑器依赖于一个配置文件来找出如何做到这一点。请看下图。</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/2495dc7d93e1ea3136c2bf35619dc919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*galbFgeGX3uKpWvr.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Source: <a class="ae lt" href="http://webpack.github.io/" rel="noopener ugc nofollow" target="_blank">http://webpack.github.io/</a></figcaption></figure><p id="ff2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于我们的项目，我们将使用一个名为ParcelJs的网络捆绑器。选择它的原因是因为它几乎不需要任何配置，而且与大多数其他捆扎机相比速度非常快。此外，我相信如果您想开始了解捆扎机，这是一个很好的起点。</p><p id="9fea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，让我们开始把它安装到我们的项目中。这也将是一个开发依赖。在<code class="fe kt ku kv kw b">awesome-react-app</code>目录中打开您的终端并运行以下命令。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="cef7" class="lm ln in kw b gy lo lp l lq lr">npm install -D parceljs</span></pre><p id="a4c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要做的下一件事是向我们的<code class="fe kt ku kv kw b">package.json</code>文件添加两个脚本。打开package.json文件，修改脚本，如下所示。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="89a0" class="lm ln in kw b gy lo lp l lq lr">{<br/>  "name": "awesome-react-project",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "dev": "parcel src/public/index.html",<br/>    "build": "parcel build src/public/index.html"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "react": "^17.0.1",<br/>    "react-dom": "^17.0.1"<br/>  },<br/>  "devDependencies": {<br/>    "<a class="ae lt" href="http://twitter.com/types/node" rel="noopener ugc nofollow" target="_blank">@types/node</a>": "^14.14.19",<br/>    "<a class="ae lt" href="http://twitter.com/types/react" rel="noopener ugc nofollow" target="_blank">@types/react</a>": "^17.0.0",<br/>    "<a class="ae lt" href="http://twitter.com/types/react-dom" rel="noopener ugc nofollow" target="_blank">@types/react-dom</a>": "^17.0.0",<br/>    "parcel-bundler": "^1.12.4",<br/>    "typescript": "^4.1.3"<br/>  }<br/>}</span></pre><p id="40bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ls">注意:您可以在这里删除</em> <code class="fe kt ku kv kw b">“main”: “index.js”</code> <em class="ls">行，因为在使用ParcelJs时我们不需要它。</em></p><p id="30f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看我们在这里做了什么。我们添加的第一个脚本叫做<code class="fe kt ku kv kw b">dev</code>。ParcelJs的好处在于它内置了一个开发服务器。这意味着在进行更改时，它将重建您的文件并更新您的网络浏览器，而无需您手动刷新。<code class="fe kt ku kv kw b">dev</code>告知包裹观看我们的<code class="fe kt ku kv kw b">index.html </code>文件。您可以通过打开您的终端并运行如下脚本来测试这一点。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="ffe7" class="lm ln in kw b gy lo lp l lq lr">npm run dev</span></pre><p id="b819" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它会输出类似这样的东西，</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="8ee9" class="lm ln in kw b gy lo lp l lq lr">Server running at <a class="ae lt" href="http://localhost:1234" rel="noopener ugc nofollow" target="_blank">http://localhost:1234</a> <br/>✨  Built in 3.21s.</span></pre><p id="8658" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们在浏览器中转到这个网址，我们可以看到渲染前创建的<code class="fe kt ku kv kw b">App</code>。</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/15bac4a13d7392fee743aac745aa572c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVp2N0VqYqUUByMXMKydXw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">ParcelJS development server</figcaption></figure><p id="a563" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尝试对代码进行更改，您将看到上面的输出自动更新。<code class="fe kt ku kv kw b">dev</code>命令负责启动开发服务器。您可以通过在您的终端中按<code class="fe kt ku kv kw b">Ctrl+C</code>来结束这个开发服务器。</p><p id="ec10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们添加的下一个命令是<code class="fe kt ku kv kw b">build</code>。这告诉package构建我们应用程序的生产就绪版本。您可以通过在您的终端中运行下面的命令来测试这一点，</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="f588" class="lm ln in kw b gy lo lp l lq lr">npm run build</span></pre><p id="e567" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行该命令后，package将在我们的<code class="fe kt ku kv kw b">awesome-react-app </code>目录中建立一个名为<code class="fe kt ku kv kw b">dist</code>的目录。这将包含您的生产就绪代码。</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/2665d03ae9374e5fb0970952edd98a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*tys7nL8yHlVuM1VQ8PjX2w.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Outputs of Parcel build command</figcaption></figure><p id="79f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，package从我们的源创建了一个<code class="fe kt ku kv kw b">index.html </code>文件和一个js文件。这些包含了运行我们的web应用程序所需的一切。</p><p id="e637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还记得我们之前在<code class="fe kt ku kv kw b">index.html</code>里面链接的<code class="fe kt ku kv kw b">index.tsx</code>文件吗？。package看到了它，并把它和所有相关的东西打包到一个普通的老JavaScript文件中，网络浏览器可以理解这个文件。</p></div></div>    
</body>
</html>