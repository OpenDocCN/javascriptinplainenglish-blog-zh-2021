<html>
<head>
<title>An Overview of React Query</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React查询概述</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-overview-of-react-query-88935faadcd7?source=collection_archive---------3-----------------------#2021-03-31">https://javascript.plainenglish.io/an-overview-of-react-query-88935faadcd7?source=collection_archive---------3-----------------------#2021-03-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1ae0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">缺少服务器状态管理库</h2></div><p id="777f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">状态管理一直是前端应用中讨论的话题。现有的解决方案，如Redux、Mobx等，都是面向客户端状态管理的。然而，在本文中，我们将集中于有效地管理从服务器获取的状态。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/d2d608bf3120bb771846fddf96cefc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHKpcRldk-cUeosTGGr9Sw.jpeg"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@alirexa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Alireza Khatami</a> on <a class="ae lo" href="https://unsplash.com/s/photos/server-rack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9dae" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">服务器状态实际上意味着什么？</h1><p id="9917" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">从服务器获取的任何数据都可以称为服务器状态。例如，您订阅的出版物、您为之鼓掌的故事、您撰写的故事都是服务器状态。客户端状态的一个例子可以是用户的主题偏好(亮或暗)。</p><p id="0cc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">控制存储在远程服务器上的信息会变得很棘手。此外，服务器数据带来了缓存、获取、更新以及将应用程序状态与服务器状态同步的固有挑战。</p><p id="19c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看react query如何帮助解决这些问题。</p><h1 id="660b" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">获取数据</h1><p id="6d99" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">获取数据具体指的是向服务器上的端点发出GET请求。react query允许我们与服务器交互的方式是通过提供钩子。它提供了<a class="ae lo" href="https://react-query.tanstack.com/reference/useQuery" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> useQuery </strong> </a> <em class="mm"> </em>钩子从服务器获取数据。</p><p id="f877" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">useQuery挂钩有两个必需的参数。</p><p id="ba96" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个参数是实际发出GET请求的函数(与API交互)，称为<a class="ae lo" href="https://react-query.tanstack.com/guides/query-functions" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">查询函数</strong> </a>。该函数可以选择任何方法与服务器交互。它可以使用本机fetch API或任何其他库，如Axios。唯一的要求是函数应该返回一个承诺，要么解析数据，要么抛出一个错误。</p><p id="e639" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意下面的查询函数是如何查询第3行的特定端点/users/1的。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">A function used for fetching data from the API.</figcaption></figure><p id="9fa4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个参数叫做<a class="ae lo" href="https://react-query.tanstack.com/guides/query-keys" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">查询键</strong> </a>。react query使用它来管理缓存。字符串、数组和对象是有效的查询关键字。查询键应该是可序列化的，并且对于查询是唯一的。以下是一些有效的查询关键字示例。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Examples of valid Query Keys in React Query.</figcaption></figure><p id="b99d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意上面的useQuery钩子是如何提供两个参数的，查询键和查询函数(fetchUser)。</p><p id="e343" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React query在内部将查询键传递给查询函数。让我们修改上面的查询函数来获取任何用户的信息，而不是硬编码的用户(users/1端点)。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">A Query Function in React Query.</figcaption></figure><p id="fb90" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们能够从服务器获取信息，那么让我们创建一个组件来向用户显示信息。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Displaying the data fetched from the API to the user.</figcaption></figure><p id="99c4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意useQuery钩子如何返回<em class="mm"> isLoading、isError、data、</em>和<em class="mm"> error </em>(第4行)。这些只是钩子返回的几个值。</p><pre class="kz la lb lc gt mp mq mr ms aw mt bi"><span id="11a6" class="mu lq in mq b gy mv mw l mx my">The list of all the variables returned by the useQuery hook has been <a class="ae lo" href="https://react-query.tanstack.com/reference/useQuery" rel="noopener ugc nofollow" target="_blank">discussed here</a>.</span></pre><ul class=""><li id="f181" class="mz na in ke b kf kg ki kj kl nb kp nc kt nd kx ne nf ng nh bi translated"><em class="mm"> isLoading </em>是一个布尔值，当数据被提取时为真。这可能会导致错误或成功的请求。</li><li id="ddf1" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated"><em class="mm">如果提取数据时出现错误，isError </em>为真。还记得useQuery期望查询函数返回一个承诺，要么解析数据，要么抛出一个错误。在查询函数抛出错误的情况下，<em class="mm"> isError </em>标志被设置为真，相应的错误在<em class="mm"> error </em>变量中可用。</li><li id="dad4" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated"><em class="mm">数据</em>包含成功请求时您期望的实际数据。</li></ul><p id="a232" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React query确实简化了应用程序的样板文件，并为我们提供了从服务器获取数据的标准方式。</p><h1 id="547e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">缓存数据</h1><p id="40ee" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">React query为所有GET请求维护一个全局缓存。缓存就像一个字典，根据称为查询键的键来存储获取的数据。从服务器获取数据后，react query会跟踪缓存时间等方面。</p><p id="531b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React query提供了一个<a class="ae lo" href="https://react-query.tanstack.com/devtools" rel="noopener ugc nofollow" target="_blank">调试工具</a>来跟踪应用程序中的所有查询。</p><p id="7ac6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下图显示了根据查询关键字[“user”，1]存储的数据(还记得我们在上一节中获取并显示的数据)。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nn"><img src="../Images/45b739c807430489cfb277587da0846c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMlIYyS-pAn7XMTCa76vmw.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Devtools provided by React Query (Notice the Data on the right hand side).</figcaption></figure><p id="18fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看下图中查询资源管理器下的cacheTime、queryKey和queryHash的值。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi no"><img src="../Images/e92bf277b262068487ff9635506e6f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ILVCXzv-ZMoAJhirP8n1w.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Devtools provided by React Query (Notice the Query on the right hand side).</figcaption></figure><p id="f828" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React query为开发人员做了维护缓存的必要工作。它还更新缓存，以便数据与服务器的状态同步。</p><h1 id="85ab" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">同步数据</h1><p id="a78e" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">在继续之前，让我们了解一下<strong class="ke io">活动</strong>和<strong class="ke io">非活动</strong>查询的概念。在react query的上下文中，活动查询是当前安装在应用程序中的查询。例如，假设您有两条路线/用户和/故事。前一个路由具有访问具有关键字[“用户”，1]的查询的组件，而后一个路由访问具有关键字[“故事”，1]的查询。在这种情况下，每当有人访问/user时,[“user”，1]查询将变为活动(已安装),而[“story”，1]查询将变为非活动。</p><p id="b140" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，每个查询都有一个与之关联的<strong class="ke io">陈旧</strong>时间。您可以全局或逐个修改所有查询的失效时间。默认失效时间为零。它只是意味着与查询相关联的数据在相对于最近一次读取0毫秒后被认为是陈旧的。这意味着react query将尽快重新获取数据(记住失效时间是0毫秒)。考虑这样一个场景，其中一个查询[“likes”，1]有一个5分钟的过时时间。此外，让我们假设最后一次获取查询是在1800小时。这仅仅意味着react query直到1805小时才会重新提取查询，因为在那之前查询是<strong class="ke io">新鲜的</strong>。在这个场景中，react query只是提供存储在缓存中的数据，而不是进行外部API调用。</p><p id="d83a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了不活动、新鲜和陈旧之外，查询还可以处于<strong class="ke io">获取</strong>状态。从服务器提取的查询处于提取状态。这种查询可以返回有效的响应，也可以导致错误。</p><p id="2023" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们看看react query如何帮助同步服务器和应用程序之间的状态。</p><ul class=""><li id="067b" class="mz na in ke b kf kg ki kj kl nb kp nc kt nd kx ne nf ng nh bi translated">所有过时的查询在激活时都会被重新提取。</li><li id="30a2" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated">当您重新聚焦一个窗口时(尝试在react query项目中切换选项卡并检查network选项卡)，陈旧的查询也会被重新提取。</li></ul><pre class="kz la lb lc gt mp mq mr ms aw mt bi"><span id="f82f" class="mu lq in mq b gy mv mw l mx my">Read about the <a class="ae lo" href="https://react-query.tanstack.com/guides/important-defaults" rel="noopener ugc nofollow" target="_blank">default behaviour</a> of React Query.</span></pre><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi np"><img src="../Images/4ab2e617091b3ca593e67adfd9e0178d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LCLjPIO_bXtIDtRraJQygw.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">A timeline showing transition of two react queries with query keys — [“user”,1] and [“story”,1].</figcaption></figure><ul class=""><li id="07a3" class="mz na in ke b kf kg ki kj kl nb kp nc kt nd kx ne nf ng nh bi translated">如果在获取数据时出现任何错误，默认情况下，在实际抛出错误之前，查询会尝试三次。</li><li id="c88d" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated">除此之外，您还可以通过<a class="ae lo" href="https://react-query.tanstack.com/guides/query-invalidation" rel="noopener ugc nofollow" target="_blank">使查询无效</a>来强制重新提取查询。查询关键字用于选择要使其无效(标记为过时)的查询。过时的查询在再次激活时会被重新提取。</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Invalidating query in React Query.</figcaption></figure><p id="7e43" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无效查询非常有用。考虑一个场景，其中设置页面修改用户的信息。在这种情况下，配置文件页面必须与设置页面所做的更改保持同步。可以在设置页面更新用户信息，并使你认为需要从服务器接收更新状态的和查询失效(这里[“用户”，1]查询应该失效)。</p><h1 id="02ea" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">更新数据</h1><p id="5a84" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">React query使得使用<a class="ae lo" href="https://react-query.tanstack.com/guides/mutations" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"/></a>突变在服务器上创建/更新/删除数据成为可能。就像useQuery一样，react query提供了一个<a class="ae lo" href="https://react-query.tanstack.com/reference/useMutation" rel="noopener ugc nofollow" target="_blank"><strong class="ke io">use mutation</strong></a><strong class="ke io"/>钩子，用于在服务器上执行突变。useMutation挂钩需要一个名为<strong class="ke io">变异函数</strong>的必需参数。这个函数实际上负责与服务器交互和执行副作用。请注意下面的突变函数与react query有什么特别的关系。这只是一个在服务器上执行变异的简单函数。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">A mutation function used in React Query.</figcaption></figure><p id="6ae5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将这个函数与react query挂钩。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">An example of using the useMutation hook in React Query.</figcaption></figure><p id="f3ee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">useMutation钩子只是指向突变函数(第3行:在这种情况下，modifyUser函数就是突变函数)。当您调用由useMutation钩子返回的mutate函数(第11行)时，实际上调用了mutate函数。传递给mutate函数的对象(第11行)被react query简单地传递给突变函数。</p><p id="bba6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">useMutation钩子返回辅助变量，例如<em class="mm"> isLoading </em>、<em class="mm"> isError </em>、<em class="mm"> error </em>(第3行)等等，这些变量类似于useQuery钩子返回的变量。useMutation钩子也提供了可选的助手。最广泛使用的助手是onSuccess(第4行)和onError。例如，当相应的突变达到onSuccess状态时，您可以使设置页面上的[“user”，1]查询无效。这将确保配置文件页面实际上与服务器同步。同样，您也可以定义onError助手来传达任何错误消息。</p><h1 id="23b7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="0b00" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">我希望您能够对React Query以及它如何解决服务器状态管理问题有一个总体的了解。除了这里讨论的以外，这个库还有很多内容。例如，除了useQuery hook之外，它还为常见UI用例提供了解决方案，如无限滚动或创建分页视图。</p><div class="nq nr gp gr ns nt"><a href="https://react-query.tanstack.com/overview" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd io gy z fp ny fr fs nz fu fw im bi translated">概观</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">React Query经常被描述为React缺少的数据获取库，但是用更专业的术语来说，它使……</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">react-query.tanstack.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh li nt"/></div></div></a></div><p id="917f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mm">更多内容请看</em><a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>