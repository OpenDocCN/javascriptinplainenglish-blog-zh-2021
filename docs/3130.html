<html>
<head>
<title>TypeScript Infer keyword Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript推断关键字解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-infer-keyword-explained-76f4a7208cb0?source=collection_archive---------3-----------------------#2021-06-25">https://javascript.plainenglish.io/typescript-infer-keyword-explained-76f4a7208cb0?source=collection_archive---------3-----------------------#2021-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ba6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是推断关键词？有哪些用例？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/043b01d04c056b2a8f8a9f620e3af795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y212u49cWxzzbpGjSNHPdA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/photos/KFIjzXYg1RM" rel="noopener ugc nofollow" target="_blank">Jeremy Bishop</a> on <a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1f11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键词<code class="fe ls lt lu lv b">Infer </code>可能令人困惑，难以理解。本文旨在对这一概念提供一个清晰明了的解释。</p><p id="ea16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在官方文档中，推断是在<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html" rel="noopener ugc nofollow" target="_blank">条件类型</a> s部分中提到的:</p><blockquote class="lw lx ly"><p id="8c1e" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">在条件类型的<code class="fe ls lt lu lv b">extends</code>子句中，现在可以使用<code class="fe ls lt lu lv b">infer</code>声明来引入要被推断的类型变量。这种推断的类型变量可以在条件类型的true分支中引用。同一类型变量可能有多个<code class="fe ls lt lu lv b">infer</code>位置。</p></blockquote><p id="d6d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果上面的定义对你来说一清二楚，不要担心，你并不孤单。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h2 id="e04b" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">什么是推断关键词？</h2><p id="a7bb" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">infer关键字允许您从条件类型中的另一个类型推导出一个类型。这里有一个例子:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="0ba7" class="mk ml iq lv b gy nm nn l no np"><em class="lz">type</em> UnpackArrayType&lt;T&gt; = T <em class="lz">extends</em> (infer R)[] ? R: T;</span><span id="9b8e" class="mk ml iq lv b gy nq nn l no np"><em class="lz">type</em> t1 = UnpackArrayType&lt;number[]&gt;; // t1 is number</span></pre><p id="6974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">UnpackArrayType</code>是有条件的类型。读作“<em class="lz">如果T是</em> <code class="fe ls lt lu lv b"><em class="lz">(infer R)[]</em></code> <em class="lz">的子类型，返回</em> <code class="fe ls lt lu lv b"><em class="lz">R</em></code> <em class="lz">。否则，返回</em> <code class="fe ls lt lu lv b"><em class="lz">T</em></code>”。</p><p id="2238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于类型别名<code class="fe ls lt lu lv b">t1</code>，因为<code class="fe ls lt lu lv b">number[]</code>与<code class="fe ls lt lu lv b">(infer R)[]</code>匹配，所以<code class="fe ls lt lu lv b">UnpackArrayType</code>中的条件为真。作为推断过程的结果，类型变量<code class="fe ls lt lu lv b">R</code>被推断为<code class="fe ls lt lu lv b">number</code>类型，并从真分支返回。<strong class="ky ir"> Infer是告诉编译器在</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">UnpackArrayType.</strong></code>范围内声明了一个新的类型变量R</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="767e" class="mk ml iq lv b gy nm nn l no np"><em class="lz">type</em> t2 = UnpackArrayType&lt;string&gt;; //t2 is string</span></pre><p id="18b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ls lt lu lv b">t2</code>，<code class="fe ls lt lu lv b">UnpackArrayType</code>中的条件为假，因为字符串类型与<code class="fe ls lt lu lv b">(infer R)[]</code>不匹配，所以返回为<code class="fe ls lt lu lv b">string</code>。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h2 id="e5fa" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">范围</h2><p id="7800" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Infer </code>关键字只在条件类型中起作用。如果试图在条件类型之外使用它，将会出现错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ab77d318b99ae26b1ae2eab9b0a1ebd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*9i0KgLmwk0zC9G80Mb_6oA.png"/></div></figure></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="aa65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有几个<code class="fe ls lt lu lv b">infer </code>关键字用例的例子。</p><h2 id="0320" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">案例1:从承诺中提取类型</h2><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="906e" class="mk ml iq lv b gy nm nn l no np">type unboxFromPromise&lt;T&gt; = T extends Promise&lt;infer R&gt;? R : T;<br/>type t1 = Promise&lt;string[]&gt;;<br/>let promiseType : unboxFromPromise&lt;t1&gt;; // <strong class="lv ir">string[]</strong></span></pre><p id="bf4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们可以从等式<code class="fe ls lt lu lv b"><em class="lz">Promise&lt;string[]&gt; = Promise&lt;infer R&gt;</em></code>推导出<code class="fe ls lt lu lv b">promiseType</code>的结果</p><p id="e0d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此<code class="fe ls lt lu lv b">promiseType</code>是字符串[]。</p><h2 id="2fa8" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">案例2:提取函数返回类型</h2><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="ed30" class="mk ml iq lv b gy nm nn l no np">type functionReturn&lt;T&gt; = T extends (…args: string[]) =&gt; infer R? R: T;<br/>type f1 = (a:string) =&gt; number;<br/>type returnType = functionReturn&lt;f1&gt;; // <strong class="lv ir">number</strong></span></pre><p id="0d15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果传入的类型与函数签名匹配，<code class="fe ls lt lu lv b">functionReturn</code>将返回函数返回类型作为<code class="fe ls lt lu lv b">R</code>类型变量。如果条件为假，则返回<code class="fe ls lt lu lv b">T</code>。</p><h2 id="b582" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">案例3:提取多个候选人</h2><p id="f9ed" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在TypeScript文档中，它说</p><blockquote class="lw lx ly"><p id="8ade" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">在<a class="ae kv" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="noopener ugc nofollow" target="_blank">共变</a>位置中，同一类型变量的多个候选导致联合类型被推断</p></blockquote><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="8976" class="mk ml iq lv b gy nm nn l no np">type unboxFromObject&lt;T&gt; = T extends {a: infer R; b: infer R} ? R: never;<br/>type r1 = unboxFromObject&lt;{a: string; b: number}&gt;; // string | number</span></pre><p id="adeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，当一个类型被推断为几个值时，结果是一个联合类型。在上面的例子中，结果是“<code class="fe ls lt lu lv b">string | number</code>”。</p><blockquote class="lw lx ly"><p id="130f" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">在<a class="ae kv" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="noopener ugc nofollow" target="_blank">反向变量</a>位置中，同一类型变量的多个候选导致一个交集类型被推断。</p></blockquote><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="a0be" class="mk ml iq lv b gy nm nn l no np">type unboxFromObjectFunctions&lt;T&gt; = T extends { a: (x: infer U) =&gt; void; b: (x: infer U) =&gt; void }? U: never;</span><span id="e107" class="mk ml iq lv b gy nq nn l no np">type r2= unboxFromObjectFunctions&lt;{ a: (x: string) =&gt; void; b: (x: number) =&gt; void }&gt;; // string &amp; number</span></pre></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h2 id="663d" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">在递归条件类型中使用推断</h2><p id="2d7f" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">下面的示例是一个更高级的示例，说明如何对递归条件类型使用infer来展平嵌套数组。请注意，只有从TypeScript版本4.1.0开始，才支持递归类型。</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="e45d" class="mk ml iq lv b gy nm nn l no np">type Flatten&lt;T extends readonly unknown[]&gt; = T extends unknown[] ? _Flatten&lt;T&gt;[] : readonly _Flatten&lt;T&gt;[];<br/>type _Flatten&lt;T&gt; = T extends readonly (infer U)[] ? _Flatten&lt;U&gt; : T;</span><span id="7091" class="mk ml iq lv b gy nq nn l no np">declare function flatRecurisve&lt;T extends readonly unknown[]&gt;(xs: T): Flatten&lt;T&gt;;</span><span id="c02a" class="mk ml iq lv b gy nq nn l no np">const t1 = flatRecurisve([‘apple’, [‘orange’, ‘pear’, 100],[[4, [true]]]] as const);<br/>// readonly (true | ‘apple’| ‘orange’, ‘pear’, 100, 4)[]</span></pre><p id="ba0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢上面的例子，因为它展示了如何使用TypeScript类型来编写简洁明了的代码。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h2 id="fa03" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">摘要</h2><p id="cebf" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">Infer关键字不是您每天都需要使用的东西，但是在高级实用程序类型中被广泛使用。理解它将有助于您正确使用实用程序类型。</p><p id="9f65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的“类型脚本”系列的第三篇文章，你可以在下面找到另外两篇文章。</p><div class="ns nt gp gr nu nv"><a href="https://betterprogramming.pub/typescripts-record-type-explained-691372b1a449" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">解释了TypeScript的记录类型</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">您想知道的关于记录实用程序类型的所有信息</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">better编程. pub</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/case-study-a-practical-usage-of-typescript-discriminated-union-type-and-generics-87e75a2717f8"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">TypeScript区分联合类型和泛型的用例</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">我非常喜欢Typescript的一个原因是它的类型系统，它实用且功能丰富。应用右边的类型…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj kp nv"/></div></div></a></div><p id="4c84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你已经发现这是有用的。编程快乐！</p><p id="f28d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">如果您还不是Medium的付费会员，</em> <a class="ae kv" href="https://sunnysun-5694.medium.com/membership" rel="noopener"> <strong class="ky ir"> <em class="lz">您可以访问此链接</em> </strong> </a> <em class="lz">。你可以无限制地阅读媒体上的所有报道。我会收你一部分会员费作为介绍费。</em></p></div></div>    
</body>
</html>