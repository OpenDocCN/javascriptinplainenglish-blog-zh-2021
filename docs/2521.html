<html>
<head>
<title>Batching Fetch Requests in React / Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React / Redux中批处理提取请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/batching-fetch-requests-in-react-redux-98212e3b34bb?source=collection_archive---------8-----------------------#2021-05-24">https://javascript.plainenglish.io/batching-fetch-requests-in-react-redux-98212e3b34bb?source=collection_archive---------8-----------------------#2021-05-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/435e22e13caaacd982bdeb303702ac8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Z6HrwXi1ZrCI_u6"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@nublson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nubelson Fernandes</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="665e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的上一篇文章中，我讲述了我在熨斗学校SE Bootcamp的最后一个项目，这是一个旨在简化餐厅盘点的应用程序。我遇到的一个挑战涉及到实际更新配料的最佳方法。</p><p id="2980" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的第一个想法是在每种成分更新时发送单独的获取请求，但这在几个方面被证明是有缺陷的:首先，为正在进行的每一次更新发送<em class="ky">获取请求是一个费力的过程(对于一个希望简化库存过程的应用程序来说，这是违背直觉的)。第二，没有版本控制:每次更新都会在前端和后端数据库中立即进行，因此如果记录和更新了错误的值，那么还会发送另一个获取请求来用正确的数量更新数据库。</em></p><p id="8c70" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我能想到的最好的解决方案是通过状态提供版本控制，并在单个获取请求中发送更新供后端处理。下面是我如何实现这个新系统的快速演练。</p><p id="b062" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单介绍一下背景:我有两个主要组件来处理组件和更新:IngredientsContainer和IngredientForm。IngredientsContainer遍历所有配料(保存在商店中)，并在页面上显示配料和数量，而IngredientForm是一个切换组件，它将向每种配料添加一个表单字段以更新数量。</p><div class="kz la lb lc gt ab cb"><figure class="ld jo le lf lg lh li paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/5e27fd6aafa8f7a042bf0295a580c278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*G3D01JwyVYklv52k.png"/></div></figure><figure class="ld jo le lf lg lh li paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/77a281a38ac2ee88f41752b1407414e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*7UzNjTo_Fu0IAUiB.png"/></div></figure></div><p id="9ddf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">左边是配料的显示模式，而右边是“编辑库存”，允许用户调整数量。</p><p id="29ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我已经构建好了组件，所以真正需要改变的是存储组件并将其发送到服务器的方法。</p><ol class=""><li id="8a17" class="lj lk in kc b kd ke kh ki kl ll kp lm kt ln kx lo lp lq lr bi translated">从后端开始…因为我们希望在一个获取请求中将所有更新发送到后端，所以这是我们必须循环访问要在数据库中更新的配料数组的地方。但是保持配料#更新方法集中于更新配料的细节(即名称、par、类别等)。)，我定义了一个自定义路由来专门处理这些批量更新:</li></ol><pre class="kz la lb lc gt ls lt lu lv aw lw bi"><span id="ad37" class="lx ly in lt b gy lz ma l mb mc">#config/routes.rbpatch ‘/updateInventory’, to: ‘ingredients#updateInventory’</span></pre><p id="219f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.对于自定义路线，我定义了一个控制器方法来迭代数组并更新数据库中的每种配料:</p><pre class="kz la lb lc gt ls lt lu lv aw lw bi"><span id="b246" class="lx ly in lt b gy lz ma l mb mc">#controllers/ingredients_controller.rbdef updateInventory<br/>   updated_ingredients = {}<br/>   params[:ingredients].each do |ingredient| <br/>      updated_ingredient = Ingredient.find(ingredient[:id]<br/>      updated_quantity = ingredient[:quantity]<br/>      if updated_ingredient.update(quantity: updated_quantity)<br/>         updated_ingredients[<a class="ae jz" href="http://updated_ingredient.id/" rel="noopener ugc nofollow" target="_blank">updated_ingredient.id</a>] = updated_ingredient<br/>      end<br/>   end<br/>   render json: updated_ingredients<br/>end</span></pre><p id="928e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.现在，转到前端，我创建了一个reducer来初始化一个数组，用于redux store中更新的配料。虽然我最后添加了更多的案例以使其更加有用，但现在只需说明将更新的配料发送到商店的第一个案例:</p><pre class="kz la lb lc gt ls lt lu lv aw lw bi"><span id="e362" class="lx ly in lt b gy lz ma l mb mc">//actions/updatedInventoryfunction updatedInventory (state=[], action) {<br/>   switch(action.type){<br/>   <br/>   case ‘UPDATED_INGREDIENT_INVENTORY’:<br/>      return […state, action.ingredient]<br/>   }<br/>   <br/>   default:<br/>      return state<br/>}<br/>export default updatedInventory</span></pre><p id="c4ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.为了让缩减器工作，我添加了一个动作来处理这些更新:</p><pre class="kz la lb lc gt ls lt lu lv aw lw bi"><span id="7ec8" class="lx ly in lt b gy lz ma l mb mc">//reducers/updatedInventoryexport const updatedInventory = ingredient =&gt; {<br/>   return {<br/>      type: ‘UPDATED_INGREDIENT_INVENTORY’,<br/>      ingredient<br/>   }<br/>}</span></pre><p id="e547" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.最后，为了将所有内容链接在一起，我通过添加本地状态来建立动态表单并导入操作，从而更新了处理更新的组件:</p><pre class="kz la lb lc gt ls lt lu lv aw lw bi"><span id="93b9" class="lx ly in lt b gy lz ma l mb mc">//components/IngredientFormimport { updatedInventory } from ‘../../actions/updatedInventory’constructor(props){<br/>   super(props)<br/>   this.state = {<br/>     id: <a class="ae jz" href="http://props.ingredient.id/" rel="noopener ugc nofollow" target="_blank">props.ingredient.id</a>,<br/>     quantity: props.ingredient.quantity,<br/>   }<br/>}handleChange = event =&gt; {<br/>   this.setState({<br/>      quantity: event.target.value<br/>   })<br/>}handleBlur = event =&gt; {<br/>   if(event.target.value != ''){<br/>      const updatedIngredient = this.state<br/>      this.props.updatedInventory(updatedIngredient)<br/>   }<br/>}</span></pre><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/7107ee1ed7a180f94e6d44f11a730f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7qyK29V3qnbf_NZ9.png"/></div></div></figure><p id="6421" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，本地状态从父组件IngredientsContainer继承了配料的id和数量。虽然对表单字段的任何更改都会触发handleChange并将“数量”设置为state，但使用继承的数量进行初始化允许我们在表单字段中提供一个占位符，因此它可以作为一个参考点，我们可以看到金额是否需要调整。另一个需要指出的是handleBlur方法。每当鼠标单击表单域，然后在表单域之外单击时，就会引发这种情况，但是只有当表单域显示输入了值时，逻辑才会运行。正是在这个函数中，我们放置了updatedInventory操作，该操作发送回状态数据(成分id和新数量)。几个成分改变后，商店看起来像这样:</p><p id="e8af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">底部的updatedInventory显示所有已更改的成分，并包含它们的新数量。</p><p id="22aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以现在一切都联系起来了。一旦任何成分值发生变化，一个“更新成分”按钮就会出现在页边空白处，当用户输入所有必要的数据时，就可以点击这个按钮。点击“更新配料”时，将触发handleSubmit功能，如下所示:</p><pre class="kz la lb lc gt ls lt lu lv aw lw bi"><span id="da8e" class="lx ly in lt b gy lz ma l mb mc">//components/IngredientForm<br/>```<br/>handleSubmit = () =&gt; {<br/>   const updateIngredients = {<br/>       ingredients: this.props.updatedInventory<br/>   }<br/>   const reqObj = {<br/>      method: 'PATCH',<br/>      headers: {'Content-Type': 'application/json'},<br/>      body: {JSON.stringify(updateIngredients)}<br/>   }   fetch(`http://localhost:3000/updateInventory`, reqObj)<br/>}</span></pre><p id="f459" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在handleSubmit中，第一步操作是设置一个变量，该变量将通过fetch中的reqObj传输，因此updateIngredients被设置为Redux存储中的updatedInventory数组。然后我们定义reqObj，最后是fetch请求。但是，请记住，我们将fetch请求定向到我们之前定义的自定义路由(步骤1)！因此，现在我们将正在更新的配料数组发送到自定义路线，在这里，所有内容都将在后端迭代，然后在数据库中更新。</p><p id="6776" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是全部了！通过创建自定义路由、该路由的控制器方法、缩减器和动作，我们已经通过减轻前端发送一百万个获取请求的责任并将迭代转移到后端来分离关注点，但是我们还通过Redux的存储引入了版本控制，确保将正确的数据传输到数据库。</p><p id="6878" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这有所帮助——感谢阅读！</p><p id="f396" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ky">plain English . io</em></a></p></div></div>    
</body>
</html>