<html>
<head>
<title>Solving ‘pancakeSort’ in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中解决“pancakeSort”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solving-pancakesort-ba8f8c25dadd?source=collection_archive---------12-----------------------#2021-05-18">https://javascript.plainenglish.io/solving-pancakesort-ba8f8c25dadd?source=collection_archive---------12-----------------------#2021-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/e588bc42e4ad12bdb12988a21bab31d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*reX3LCbJrv1z2m5lhVtHFw.jpeg"/></div></figure><p id="bfa3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在本文中，我将在JavaScript中用几种不同的方法来解决pancakeSort问题。然后我将介绍我解决这个问题的过程，并讨论它的重要性。</p><p id="6e6a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们开始吧！</p><h1 id="9571" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">问题</h1><h2 id="0420" class="ln kq in bd kr lo lp dn kv lq lr dp kz kc ls lt ld kg lu lv lh kk lw lx ll ly bi translated">给定一个整数数组<code class="fe lz ma mb mc b">arr</code>:</h2><ol class=""><li id="65b7" class="md me in jt b ju mf jy mg kc mh kg mi kk mj ko mk ml mm mn bi translated">编写一个函数<code class="fe lz ma mb mc b">flip(arr, k)</code>，它反转数组<code class="fe lz ma mb mc b">arr</code>中第一个<code class="fe lz ma mb mc b">k</code>元素的顺序。</li><li id="827a" class="md me in jt b ju mo jy mp kc mq kg mr kk ms ko mk ml mm mn bi translated">写一个函数<code class="fe lz ma mb mc b">pancakeSort(arr)</code>，排序并返回输入数组。您只允许使用您在第一步中编写的函数<code class="fe lz ma mb mc b">flip</code>来修改数组。</li></ol><p id="f9da" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">示例:</p><ul class=""><li id="913a" class="md me in jt b ju jv jy jz kc mt kg mu kk mv ko mw ml mm mn bi translated">输入:arr = [1，5，4，3，2]</li><li id="ed15" class="md me in jt b ju mo jy mp kc mq kg mr kk ms ko mw ml mm mn bi translated">输出:[1，2，3，4，5]</li></ul><p id="f139" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">注意:</strong>它被称为煎饼分类，因为它类似于用抹刀在盘子上分类煎饼，你只能用抹刀翻动盘子上的一些顶层煎饼。要阅读关于这个问题的更多信息，请参见维基百科页面<a class="ae mx" href="https://en.wikipedia.org/wiki/Pancake_sorting" rel="noopener ugc nofollow" target="_blank">煎饼分类</a>。</p><p id="c9b2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们来分析一下问题。</p><p id="5c0c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们需要创建并使用一个翻转函数来对给我们的数组进行排序——此外，这个翻转函数只能翻转传递给它的数组中的前k个值。</p><p id="76cf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">知道了这一点，我们如何利用这个助手函数来排序我们的数组呢？</p><p id="b903" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">嗯……如果你看了一下纸条，你可能已经猜到了——我们将使用煎饼排序。</p><p id="7a28" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们实现这一点的方法是，确定我们需要翻转数组的哪些部分，以便按照从低到高的顺序放置值。</p><p id="ff73" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在循环中:</p><p id="2a4d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">步骤1:找到数组中最大值的索引</p><p id="d1d7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">步骤2:将数组从索引0翻转到最大值的索引</p><p id="19ef" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">步骤3:将数组从索引0再次翻转到上一个“最大值”之前的索引**如果这是第一次迭代，我们翻转到的索引将是array.length-1，对于下一次迭代，它将是array.length-2，依此类推。</p><p id="2fc7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这听起来很奇怪。让我们实际看看它是如何工作的:</p><ul class=""><li id="2a1f" class="md me in jt b ju jv jy jz kc mt kg mu kk mv ko mw ml mm mn bi translated">要翻转的数组→[ 1，5，4，3，2 ] → maxInd = 1 →从索引0翻转到索引1 →第一次翻转后返回的数组→ [ 5，1，4，3，2 ] →要翻转到的下一个索引是arr.length-1 →两次翻转返回的数组→ [ 2，3，4，1，5 ]</li><li id="a35e" class="md me in jt b ju mo jy mp kc mq kg mr kk ms ko mw ml mm mn bi translated">要翻转的数组→ [ 2，3，4，1，5 ] → maxInd = 2 →从索引0翻转到索引2 →第一次翻转后返回的数组→ [ 4，3，2，1，5 ] →要翻转到的下一个索引是arr.length-2 →两次翻转后返回的数组[ 1，2，3，4，5 ]</li><li id="8e75" class="md me in jt b ju mo jy mp kc mq kg mr kk ms ko mw ml mm mn bi translated">等等。等等。直到我们从右到左接触到每个值</li></ul><p id="6b67" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">数组变化对等迭代:</p><ul class=""><li id="8168" class="md me in jt b ju jv jy jz kc mt kg mu kk mv ko mw ml mm mn bi">[ 1, 5, 4, 3, 2 ] → [ 5, 1, 4, 3, 2 ] → [ 2, 3, 4, 1, 5 ]</li><li id="169e" class="md me in jt b ju mo jy mp kc mq kg mr kk ms ko mw ml mm mn bi">[ 2, 3, 4, 1, 5 ] → [ 4, 3, 2, 1, 5 ] → [ 1, 2, 3, 4, 5 ]</li><li id="d897" class="md me in jt b ju mo jy mp kc mq kg mr kk ms ko mw ml mm mn bi">[ 1, 2, 3, 4, 5 ] → [ 3, 2, 1, 4, 5 ] → [ 1, 2, 3, 4, 5 ]</li><li id="f6aa" class="md me in jt b ju mo jy mp kc mq kg mr kk ms ko mw ml mm mn bi translated">继续，直到i == 0</li></ul><p id="a406" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">希望上面的插图有助于澄清煎饼排序背后的概念。</p><p id="6dd1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果没有，也许一些代码会有所帮助。</p><p id="c8f3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以我们知道我们需要一个函数来翻转0-k的数组。</p><p id="3533" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">它可能看起来像这样:</p><figure class="mz na nb nc gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/154e7f6b56e5047a86fcf4608f663fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*H2JfTj_6stWCf-vVFfo4TQ.png"/></div></figure><p id="7ec4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">该函数从外向内，交换相反索引处的值，直到它们在中心相遇，此时循环将会中断。</p><p id="e09a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好吧。现在，我们需要一种快速简单的方法来找到数组中最大值的索引——但是只能找到一个特定的索引。请记住，我们想知道最大值，不包括我们已经在数组中订购的最大值。</p><p id="6e10" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们将通过创建另一个助手函数来解决这个问题，我们可以将数组和索引传递给它。该函数将搜索数组的最大值，直到我们提供的索引。</p><figure class="mz na nb nc gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/964d6642d1037e7a6c613200b87a7815.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*6dcYt-5F-Rr_s5K4YAOuWg.png"/></div></figure><p id="5dd1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">太棒了。现在我们已经得到了这些，我们只需要为我们之前讨论的过程编写代码！</p><figure class="mz na nb nc gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c2722118049e6cbf747f16e78029d88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*bZzf9CNoXkMBiUIu3SEyvg.png"/></div></figure><p id="19a5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以我们遍历数组→在每次迭代中，我们首先检查找到第23行的maxInd。然后我们使用maxInd并将它和数组一起传递给我们创建的flip()函数。flip函数使数组变异，将maxVal放在数组的前面。然后，我们将变异后的数组传递回flip()函数以及我们正在迭代的索引(记住从数组的后面开始，i = array.length-1 ),将maxVal从数组的前面翻转到数组的末尾。我们一直这样做，直到检查完数组中的每个值。</p><h2 id="4790" class="ln kq in bd kr lo lp dn kv lq lr dp kz kc ls lt ld kg lu lv lh kk lw lx ll ly bi translated">复杂性</h2><p id="49bf" class="pw-post-body-paragraph jr js in jt b ju mf jw jx jy mg ka kb kc nf ke kf kg ng ki kj kk nh km kn ko ig bi translated">有了这个解，我们的时间复杂度为O(n)。因为每次迭代需要2次翻转，每次翻转最多需要O(n)次，并且每次迭代必须找到也是O(n)的maxVal导致运行时间为O(n)。由于该解决方案只启动了几个辅助变量，并且我们改变了提供给我们的原始数组，因此空间复杂度为O(1)。</p><h2 id="19cf" class="ln kq in bd kr lo lp dn kv lq lr dp kz kc ls lt ld kg lu lv lh kk lw lx ll ly bi translated">最后的想法</h2><p id="b1be" class="pw-post-body-paragraph jr js in jt b ju mf jw jx jy mg ka kb kc nf ke kf kg ng ki kj kk nh km kn ko ig bi translated">我花了一分钟才理解这一点，但一旦我看到它的实际应用，我就明白了。如果不清楚pancake排序是如何工作的，请尝试运行代码并在每次突变后控制台记录数组。我希望这有助于你的下一个算法。黑客快乐！</p><p id="afbc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="ni">更多内容尽在</em><a class="ae mx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ni">plain English . io</em></a></p></div></div>    
</body>
</html>