<html>
<head>
<title>These 2 Methodologies Will Make You Rethink Naming Things in CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这两种方法会让你重新思考CSS中的命名</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/these-2-methodologies-will-make-you-rethink-naming-things-in-css-cd15e2e3469c?source=collection_archive---------18-----------------------#2021-07-01">https://javascript.plainenglish.io/these-2-methodologies-will-make-you-rethink-naming-things-in-css-cd15e2e3469c?source=collection_archive---------18-----------------------#2021-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6a5e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">计算机科学只有两个硬东西:缓存失效和事物命名。菲尔·卡尔顿。</em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/6a5c4b3d3717cd8833884d2374812a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRxEl50FaUrVgRYoJmvd_w.jpeg"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo by<strong class="bd kt"> @surface </strong>on: Unsplash.</figcaption></figure><p id="7e09" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">前端开发是IT中最具欺骗性的领域。当你进入它时，一切似乎都很容易，你花一些时间学习HTML，然后你转向CSS，你甚至不理解它的大部分原理，但你转向JavaScript。</p><p id="b694" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">一旦你决定用HTML、CSS和JavaScript构建一个有趣的东西，现实会让你意识到这些东西的复杂性，尤其是CSS。</p><p id="c652" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">CSS是骗人的；它简单的语法隐藏了构建健壮布局和响应界面的复杂性，甚至隐藏了如何在CSS中命名事物的复杂性。</p><p id="04c3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你可能不会认真对待CSS中的命名，但它的重要性揭示了持久开发和如何处理旧项目。</p><h2 id="6066" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">如何在CSS中命名事物</h2><p id="d492" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">在严肃的前端项目中命名东西是很重要的，考虑到其他开发人员甚至将来的你应该理解你的CSS代码如何影响你的标记中的每一个收缩。</p><p id="f2e0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">更好的CSS命名是关于使用类选择器，一个语义类。为什么要使用语义类选择器？</p><p id="2533" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">类选择器具有较低的特异性，这意味着它们很容易在您的项目中重用。如果你不知道特异性到底是什么，你可以看看我的一篇文章，我在那里解释得很清楚。</p><div class="mo mp gp gr mq mr"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-calculate-css-selector-specificity-72aa076c6a18"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd io gy z fp mw fr fs mx fu fw im bi translated">如何计算CSS选择器特异性</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">关于CSS选择器你不知道的是</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="na l"><div class="nb l nc nd ne na nf kn mr"/></div></div></a></div><p id="e1d5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我提到了语义这个词。当我们使用语义这个词时，我们指的是有意义的事物。与语义HTML一样，语义类名意味着类名应该描述它做了什么或者它影响了标记中的哪些内容。</p><p id="52a5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">比如，你不应该使用这几种类名:<code class="fe ng nh ni nj b">red-text</code>、<code class="fe ng nh ni nj b">blue-button</code>、<code class="fe ng nh ni nj b">fontw-900</code>为什么？这与现有的设计有关。考虑到设计可能会改变。</p><p id="f711" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">使用<code class="fe ng nh ni nj b">class="blue-button"</code>作为主要动作按钮很好，但是如果主要按钮变成棕色怎么办？现在我们的类按钮是混乱的，没有意义。更好的选择是使用像<code class="fe ng nh ni nj b">.primary-btn</code>这样的名字。</p><p id="888e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在简单讨论了CSS中的命名之后，让我们看看在CSS中命名事物的两种方法。每一个都有一个独特的用例在开发过程中帮助你。</p><h2 id="2bfd" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated"><strong class="ak">块-元素-修改器(BEM) </strong></h2><p id="16a5" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">Block-Element-Modifier或BEM是一种在CSS中命名事物的方法，由Yandex创建。这种方法的核心思想是把你的网站想象成一个可重用组件块的集合来构建界面，就像React库中的组件一样..</p><p id="1287" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">BEM中的块代表文档中作为页脚、页眉或侧边栏的一个部分。一个<em class="nk">块</em>可以包含其他块，例如，一个节可以包含两篇文章，一个标题可以包含导航和一个徽标，如下图所示。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi nl"><img src="../Images/f56026d9785eb4f0ab5754ba7bea9090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJsBKkys_xtJZ2yjA3pt3g.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo from <a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#element" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">BEM website</strong></a></figcaption></figure><p id="a2fd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">有了BEM，事情不会就此停止。我们可以更深入地研究<em class="nk">元素</em>和<em class="nk">修饰符。</em> E <em class="nk">元件</em>是<em class="nk">块</em>的底层结构。</p><p id="63d5" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">BEM文档将<em class="nk">元素</em>定义为:</p><blockquote class="nn no np"><p id="e72b" class="ku kv nk kw b kx ky jo kz la lb jr lc nq le lf lg nr li lj lk ns lm ln lo lp ig bi translated"><a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#block" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">块</strong> </a> <strong class="kw io"> </strong>的组成部分，不能在它之外使用。例如，菜单项不在菜单块的上下文之外使用，因此它是一个元素。</p></blockquote><p id="beac" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">例如，一个菜单<em class="nk">块</em>包含许多菜单元素(如下图)，BEM方法建议不要在其他元素中使用元素<a class="ae nm" href="https://en.bem.info/methodology/faq/#why-not-create-elements-of-elements-block__elem1__elem2" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/934af3c0abe99c283f0bafb7ece3ff35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*4Oo7l0npbVwwX49UZwjb1A.png"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo from <a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#element" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">BEM website</strong></a></figcaption></figure><p id="81f0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">根据边界元法的规则，<a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#block" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">块</strong> </a>名称在一个项目中必须是唯一的，一个<a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#element" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">元素</strong> </a>名称在一个块中必须是唯一的，对于一个可能根据用户喜好而变化的块外观，使用<a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#modifier" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">修饰符</strong> </a> <strong class="kw io">。</strong> <a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#block" rel="noopener ugc nofollow" target="_blank">块</a>、<a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#element" rel="noopener ugc nofollow" target="_blank">元素</a>和<a class="ae nm" href="https://en.bem.info/methodology/key-concepts/#modifier" rel="noopener ugc nofollow" target="_blank">修改器</a>都称为边界元实体。</p><p id="3d23" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><strong class="kw io">根据边界元法的命名规则:</strong></p><p id="fd96" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe ng nh ni nj b">block-name__elem_name--mod-name--mod-val</code></p><ul class=""><li id="4b8b" class="nu nv in kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">名字是用小写拉丁字母写的。</li><li id="64bb" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">BEM实体名称中的单词由连字符(<code class="fe ng nh ni nj b">-</code>)分隔。<code class="fe ng nh ni nj b">menu-bloc</code></li><li id="52d6" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">元素名和块名之间用双下划线(<code class="fe ng nh ni nj b">__</code>)隔开。<code class="fe ng nh ni nj b">menu__item</code></li><li id="8a7c" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">修饰符名称通过双连字符(<code class="fe ng nh ni nj b">--</code>)与块或元素的名称分开。<code class="fe ng nh ni nj b">menu--theme</code></li><li id="d4a4" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">修饰符的值和它的名字用一个双连字符(<code class="fe ng nh ni nj b">--</code>)分开。<code class="fe ng nh ni nj b">menu--theme--dark</code></li></ul><p id="1807" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">和往常一样，看比解释容易多了。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi oi"><img src="../Images/97788302dc92a5043f880b52baf16421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eUFZd2JNGq4_YJ3F0S8Gg.png"/></div></div></figure><p id="0aa4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在上面的例子中，menu-theme-dark和menu _ _ item-theme-dark是附加的类名，以防我们在菜单上使用了黑暗模式。类选择器是BEM方法中唯一使用的选择器，但是使用子代、后代和类型选择器是安全的。</p><p id="e585" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">边界元法具有以下优点:</p><ul class=""><li id="b2b6" class="nu nv in kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">你可以重用你的CSS。</li><li id="1f69" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">你不会纠结于特异性，因为你用的是低级选择器(类选择器)。</li><li id="b0c4" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">阶级之间没有冲突。</li></ul><p id="b981" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">对于它的缺点</p><ul class=""><li id="75ec" class="nu nv in kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">类名可能会变得有点长且难看</li><li id="7610" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">HTML可以有很多类</li></ul><p id="c563" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">BEM在一开始可能看起来很复杂。一旦你尝试过，你会像我一样喜欢它。关于BEM的更多信息，它的优点和缺点，你可以查看Johan Ronsse 的这篇<a class="ae nm" href="https://mono.company/frontend/learning-to-love-bem/" rel="noopener ugc nofollow" target="_blank">伟大的文章，或者访问</a><a class="ae nm" href="https://en.bem.info/methodology/key-concepts/" rel="noopener ugc nofollow" target="_blank"> BEM的官方网站。</a></p><h2 id="e8bf" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">原子CSS</h2><p id="20a5" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">在CSS中命名事物的另一种方法是原子CSS，由Thierry Koblentz在“<a class="ae nm" href="https://www.smashingmagazine.com/2013/10/challenging-css-best-practices-atomic-approach/" rel="noopener ugc nofollow" target="_blank">挑战CSS最佳实践</a>”中命名和解释。原子CSS使用类选择器作为边界元。</p><p id="8178" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Atomic使用的命名系统非常接近Bootstrap使用的系统(见下文)。原子CSS中的大多数类名都描述了它们的用途，但没有说明它们影响了哪些内容。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi oj"><img src="../Images/5eaf3e24df85a9c3f717a5c5cee22209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWmBM05VnF7b0SYz3TMh9Q.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">An example of using Boostrap classes.</figcaption></figure><p id="3c4f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了说明原子CSS是如何工作的，我们将创建一些CSS代码并在HTML标记中使用它。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi oj"><img src="../Images/302a76b60af493fc1a6d9f099e1e2709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IINKuB40QPkHOhc-vOvxQ.png"/></div></div></figure><p id="ebdf" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在我们有一堆CSS类可以在我们的标记中使用。简而言之，每个类代表一个CSS属性。这就是为什么我们有大量的CSS代码。在我们的标记中的用法如下:</p><p id="3505" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe ng nh ni nj b">&lt;p class="bw-2 bss p-1x sans tc-w br-1x bg-e bc-e"&lt;/p&gt;</code></p><p id="f1cb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们使用的标记将创建一个显示错误的消息框。我们在这里使用了很多类名。但是当你意识到把消息框从错误框变成警告框需要改变一个字母时，这是值得的。</p><p id="457f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe ng nh ni nj b">&lt;p class="bw-2 bss p-1x sans tc-w br-1x bg-w bc-w"&lt;/p&gt;</code></p><p id="2fb3" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如您所见，我们刚刚将<code class="fe ng nh ni nj b">bg-</code>和<code class="fe ng nh ni nj b">bc-</code>中的字母<code class="fe ng nh ni nj b">e</code>改为<code class="fe ng nh ni nj b">w</code>，将错误消息框变为警告消息框。</p><p id="9b17" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">原子CSS有一些优点，例如:</p><ul class=""><li id="011a" class="nu nv in kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">通过使用低特异性选择器来避免冲突。</li><li id="9f82" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">创建高度可重用的类。</li><li id="f2da" class="nu nv in kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">你知道你要改变什么，因为每个类代表一种风格，删除或添加一个类很简单。</li></ul><p id="16fc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">对于它的缺点，原子CSS是一个烂摊子。感觉像是使用了web早期的样式属性。原子CSS的主要问题是将内容与表示分离。</p><p id="1e4a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果<code class="fe ng nh ni nj b">class="gray"</code>将文本颜色改为灰色，如果我们决定将带有<code class="fe ng nh ni nj b">.gray </code>类的所有内容都改为黑色，该怎么办？</p><p id="94e9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们可以删除<code class="fe ng nh ni nj b">.gray </code>并添加另一个类，例如<code class="fe ng nh ni nj b">.black,</code>，但是现在我们改变了我们的HTML，打破了<a class="ae nm" href="https://learn.co/lessons/separation-of-content-and-presentation" rel="noopener ugc nofollow" target="_blank"> <em class="nk">将内容与表示</em> </a>分开的规则。</p><h2 id="fbe9" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">我应该用原子CSS还是BEM？</h2><p id="d3e9" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">很明显，原子CSS适用于那些喜欢编写CSS规则库，然后将它们应用于标记的人，一个开发人员或一个知道每个规则的小团队。</p><p id="a029" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">BEM为大型团队工作。本BEM中的命名系统是描述性的。团队中的大多数开发人员会弄清楚每个类是做什么的，以及它会影响哪种事情。</p><h2 id="f4f4" class="lq lr in bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">最后</h2><p id="7cb8" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld ml lf lg lh mm lj lk ll mn ln lo lp ig bi translated">我们已经走了很长的路来理解如何命名我们的CSS代码。我们可以使用语义类选择器或BEM或原子CSS方法。这些方法中的每一种都有其独特的命名系统。</p><p id="295a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在由您来决定是使用原子CSS、BEM方法，还是都不使用。</p><p id="95f2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="nk">更多内容请看</em><a class="ae nm" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="nk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>