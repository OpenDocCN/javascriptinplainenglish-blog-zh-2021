<html>
<head>
<title>Password Encryption Using bcrypt, Sequelize and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用bcrypt、Sequelize和Node.js进行密码加密</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/password-encryption-using-bcrypt-sequelize-and-nodejs-fb9198634ee7?source=collection_archive---------3-----------------------#2021-04-18">https://javascript.plainenglish.io/password-encryption-using-bcrypt-sequelize-and-nodejs-fb9198634ee7?source=collection_archive---------3-----------------------#2021-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0674" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章讲述了如何使用Sequelize加密用户密码并存储在PostgreSQL中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f9bd1547634a425020a70b8511a8f41b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*RaR_YCuGY-2sg_X-hjI7-Q.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Architecture Diagram ( IMG 1 )</figcaption></figure><h2 id="914b" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">通过NPM安装</h2><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="f88f" class="ku kv in lo b gy ls lt l lu lv">npm install bcrypt<br/>npm install s<!-- -->equelize</span></pre><h2 id="00b6" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">与顺序模型一起使用</h2><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="eada" class="ku kv in lo b gy ls lt l lu lv">const bcrypt = require('bcrypt');</span><span id="5d54" class="ku kv in lo b gy lw lt l lu lv">var userSchema = sequelize.define("users", {<br/> userId: {<br/>  field: 'user_id',<br/>  autoIncrement: true,<br/>  primaryKey: true,<br/>  type: Sequelize.INTEGER<br/>},<br/> password: {<br/>  field: 'user_password',<br/>  type: Sequelize.STRING,<br/>  allowNull: true<br/> },<br/> name: {<br/>  type: Sequelize.STRING,<br/>  field: 'user_name',<br/>  allowNull: false<br/> },<br/> email: {<br/>  type: Sequelize.STRING,<br/>  field: 'user_email',<br/>  allowNull: false<br/> },<br/>},<br/>{<br/> hooks: {<br/>  beforeCreate: async (user) =&gt; {<br/>   if (user.password) {<br/>    const salt = await bcrypt.genSaltSync(10, 'a');<br/>    user.password = bcrypt.hashSync(user.password, salt);<br/>   }<br/>  },<br/>  beforeUpdate:async (user) =&gt; {<br/>   if (user.password) {<br/>    const salt = await bcrypt.genSaltSync(10, 'a');<br/>    user.password = bcrypt.hashSync(user.password, salt);<br/>   }<br/>  }<br/> },<br/> instanceMethods: {<br/>  validPassword: (password) =&gt; {<br/>   return bcrypt.compareSync(password, this.password);<br/>  }<br/> }<br/>});<br/>userSchema.prototype.validPassword = async (password, hash) =&gt; {<br/> return await bcrypt.compareSync(password, hash);<br/>}<br/> return userSchema;<br/>}</span></pre><p id="3cef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">验证密码</em> </strong></p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="3156" class="ku kv in lo b gy ls lt l lu lv">const authenticateUserWithemail = (user) =&gt; {<br/> return new Promise((resolve, reject) =&gt; {<br/>  try {<br/>   usermodel.findOne({<br/>   where: {<br/>    user_email: user.userName // user email<br/>   }<br/>   }).then(async (response) =&gt; {<br/>    if (!response) {<br/>     resolve(false);<br/>    } else {<br/>      if (!response.dataValues.password || <br/>       !await response.validPassword(user.password, <br/>        response.dataValues.password)) {<br/>         resolve(false);<br/>      } else {<br/>       resolve(response.dataValues)<br/>      }<br/>     }<br/>    })<br/>   } catch (error) {<br/>   const response = {<br/>    status: 500,<br/>    data: {},<br/>   error: {<br/>    message: "user match failed"<br/>   }<br/>   };<br/>  reject(response);<br/>  }<br/> })<br/>}</span></pre><h2 id="933e" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">序列模型</h2><p id="8388" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">模型是序列的本质。模型是表示数据库中的表的抽象。在Sequelize中，它是一个扩展<a class="ae md" href="https://sequelize.org/master/class/lib/model.js~Model.html" rel="noopener ugc nofollow" target="_blank">模型</a>的类。</p><p id="3eda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该模型告诉Sequelize关于它所代表的实体的一些事情，例如数据库中的表的名称和它有哪些列(以及它们的数据类型)。</p><p id="6225" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">续集中的一个模特有名字。该名称不必与其在数据库中表示的表名相同。通常，模型有单数名称(如<code class="fe me mf mg lo b">User</code>)，而表格有复数名称(如<code class="fe me mf mg lo b">Users</code>)，尽管这是完全可配置的。</p><h2 id="78e7" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">序列挂钩</h2><p id="b86f" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">钩子(也称为生命周期事件)是在sequelize中的调用执行之前和之后被调用的函数。例如，如果您想在保存模型之前总是设置一个值，您可以添加一个<code class="fe me mf mg lo b">beforeUpdate</code>钩子。</p><p id="606b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong> <em class="lx">不能和实例一起使用钩子。钩子与模型一起使用。</em></p><p id="ee1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">创建前</em> </strong></p><p id="944f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实体创建前初始化。</p><p id="2064" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">更新前</em> </strong></p><p id="435c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实体更新前初始化。</p><p id="768a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">钩子击发顺序</em> </strong></p><p id="f389" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下图显示了最常见钩子的触发顺序。</p><p id="aec4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">注:</em> </strong> <em class="lx">此列表并不详尽。</em></p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="08ff" class="ku kv in lo b gy ls lt l lu lv">(1)<br/>  beforeBulkCreate(instances, options)<br/>  beforeBulkDestroy(options)<br/>  beforeBulkUpdate(options)<br/>(2)<br/>  beforeValidate(instance, options)</span><span id="97d3" class="ku kv in lo b gy lw lt l lu lv">[... validation happens ...]</span><span id="d481" class="ku kv in lo b gy lw lt l lu lv">(3)<br/>  afterValidate(instance, options)<br/>  validationFailed(instance, options, error)<br/>(4)<br/>  beforeCreate(instance, options)<br/>  beforeDestroy(instance, options)<br/>  beforeUpdate(instance, options)<br/>  beforeSave(instance, options)<br/>  beforeUpsert(values, options)</span><span id="76ae" class="ku kv in lo b gy lw lt l lu lv">[... creation/update/destruction happens ...]</span><span id="1b04" class="ku kv in lo b gy lw lt l lu lv">(5)<br/>  afterCreate(instance, options)<br/>  afterDestroy(instance, options)<br/>  afterUpdate(instance, options)<br/>  afterSave(instance, options)<br/>  afterUpsert(created, options)<br/>(6)<br/>  afterBulkCreate(instances, options)<br/>  afterBulkDestroy(options)<br/>  afterBulkUpdate(options)</span></pre><p id="12c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">实例方法</em> </strong></p><p id="e5f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实例方法是在模型的<em class="lx">实例</em>上可用的方法。我们经常写这些来获取信息或者做一些与实例相关的事情。</p><p id="d34e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">定义</em> </strong></p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="2920" class="ku kv in lo b gy ls lt l lu lv"><strong class="lo io">const</strong> Pug = db.define('pugs', {<em class="lx">/* etc*/</em>})</span><span id="3460" class="ku kv in lo b gy lw lt l lu lv"><em class="lx">// instance methods are defined on the model's .prototype</em><br/>Pug.prototype.celebrateBirthday = <strong class="lo io">function</strong> () {<br/>  <em class="lx">// 'this' in an instance method refers to the instance itself</em><br/>  <strong class="lo io">const</strong> birthday = <strong class="lo io">new</strong> Date(<strong class="lo io">this</strong>.birthday)<br/>  <strong class="lo io">const</strong> today = <strong class="lo io">new</strong> Date()<br/>  <strong class="lo io">if</strong> (birthday.getMonth() === today.getMonth() &amp;&amp; today.getDate() === birthday.getDate()) {<br/>    console.log('Happy birthday!')<br/>  }<br/>}</span></pre><p id="37db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">用法</em> </strong></p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="eefd" class="ku kv in lo b gy ls lt l lu lv"><strong class="lo io">const</strong> createdPug = <strong class="lo io">await</strong> Pug.create({name: 'Cody'}) <em class="lx">// let's say `birthday` defaults to today</em><br/><em class="lx">// the instance method is invoked *on the instance*</em><br/>createdPug.celebrateBirthday() <em class="lx">// Happy birthday!</em></span></pre><p id="ae02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">类方法</em> </strong></p><p id="5889" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类方法是在<em class="lx">模型本身</em>(又名<em class="lx">类</em>)上可用的方法。我们经常写这些来获取实例，或者对多个实例做一些事情。</p><p id="fe7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">定义</em> </strong></p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="0b71" class="ku kv in lo b gy ls lt l lu lv"><strong class="lo io">const</strong> Pug = db.define('pugs', {<em class="lx">/* etc*/</em>})</span><span id="6dc4" class="ku kv in lo b gy lw lt l lu lv"><em class="lx">// class methods are defined right on the model</em><br/>Pug.findPuppies = <strong class="lo io">function</strong> () {<br/>  <em class="lx">// 'this' refers directly back to the model (the capital "P" Pug)</em><br/>  <strong class="lo io">return</strong> <strong class="lo io">this</strong>.findAll({ <em class="lx">// could also be Pug.findAll</em><br/>    where: {<br/>      age: {$lte: 1} <em class="lx">// find all pugs where age is less than or equal to 1</em><br/>    }<br/>  })<br/>}</span></pre><p id="6268" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">用法</em> </strong></p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="44cc" class="ku kv in lo b gy ls lt l lu lv"><strong class="lo io">const</strong> foundPuppies = <strong class="lo io">await</strong> Pug.findPuppies()<br/>console.log('Here are the pups: ', foundPuppies)</span></pre><p id="2bf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx"> bcrypt </em> </strong></p><p id="c384" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是由<a class="ae md" href="https://en.wikipedia.org/wiki/Niels_Provos" rel="noopener ugc nofollow" target="_blank">尼尔斯·普罗沃斯</a>和大卫·马齐埃设计的<a class="ae md" href="https://en.wikipedia.org/wiki/Password-hashing_function" rel="noopener ugc nofollow" target="_blank">密码散列函数</a>，基于<a class="ae md" href="https://en.wikipedia.org/wiki/Blowfish_(cipher)" rel="noopener ugc nofollow" target="_blank">河豚</a>密码，并于1999年在<a class="ae md" href="https://en.wikipedia.org/wiki/USENIX" rel="noopener ugc nofollow" target="_blank"> USENIX </a>上展示。除了包含一个<a class="ae md" href="https://en.wikipedia.org/wiki/Salt_(cryptography)" rel="noopener ugc nofollow" target="_blank"> salt </a>来抵御<a class="ae md" href="https://en.wikipedia.org/wiki/Rainbow_table" rel="noopener ugc nofollow" target="_blank"> rainbow table </a>攻击之外，bcrypt还是一个自适应函数:随着时间的推移，迭代次数可以增加以使它变得更慢，因此即使计算能力增加，它仍然可以抵抗<a class="ae md" href="https://en.wikipedia.org/wiki/Brute-force_search" rel="noopener ugc nofollow" target="_blank">暴力搜索</a>攻击。</p><p id="e7c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">bcrypt函数是默认密码<a class="ae md" href="https://en.wikipedia.org/wiki/Hash_algorithm" rel="noopener ugc nofollow" target="_blank">哈希算法</a>用于<a class="ae md" href="https://en.wikipedia.org/wiki/OpenBSD" rel="noopener ugc nofollow" target="_blank"> OpenBSD </a>和其他系统，包括一些<a class="ae md" href="https://en.wikipedia.org/wiki/Linux_distribution" rel="noopener ugc nofollow" target="_blank"> Linux发行版</a>如<a class="ae md" href="https://en.wikipedia.org/wiki/SUSE_Linux" rel="noopener ugc nofollow" target="_blank"> SUSE Linux </a>。</p><p id="4b4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx"> bcrypy API </em> </strong></p><p id="67a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> genSaltSync(rounds，minor) </strong> <br/> <strong class="jm io"> rounds </strong> —【可选】—处理数据的开销。(默认值— 10) <br/> <strong class="jm io">次要版本</strong>—[可选] —要使用的bcrypt的次要版本。(默认— b) <br/> <strong class="jm io"> genSalt(rounds，minor，cb) </strong> <br/> <strong class="jm io"> rounds </strong> —【可选】—处理数据的开销。(默认值— 10) <br/> <strong class="jm io">次要版本</strong>—[可选] —要使用的bcrypt的次要版本。(default-b)<br/><strong class="jm io">CB</strong>—[可选] —一旦生成salt就要触发的回调。使用eio使其异步。如果未指定cb，则在承诺支持可用的情况下返回承诺。<br/> <strong class="jm io"> err </strong> —回调的第一个参数，详细说明任何错误。<br/> <strong class="jm io"> salt </strong> —提供生成的salt的回调的第二个参数。<br/> <strong class="jm io"> hashSync(数据，盐)</strong> <br/> <strong class="jm io">数据</strong> —【必选】—要加密的数据。<br/> <strong class="jm io"> salt </strong> —【必需】—用于散列密码的salt。如果指定为一个数字，那么将生成一个具有指定轮数的盐并使用(参见用法下的示例)。<br/> <strong class="jm io"> hash(data，salt，cb) </strong> <br/> <strong class="jm io"> data </strong> —【必选】—要加密的数据。<br/> <strong class="jm io"> salt </strong> —【必需】—用于散列密码的salt。如果指定为一个数字，那么将生成一个具有指定轮数的盐并使用(参见用法下的示例)。<br/><strong class="jm io">CB</strong>—[可选] —数据加密后将触发的回调。使用eio使其异步。如果未指定cb，则在承诺支持可用的情况下返回承诺。<br/> <strong class="jm io"> err </strong> —回调的第一个参数，详细说明任何错误。<br/> <strong class="jm io">加密</strong> —提供加密形式的回调的第二个参数。<br/> <strong class="jm io"> compareSync </strong>(数据，加密)<br/> <strong class="jm io">数据</strong> —【必需】—要比较的数据。<br/> <strong class="jm io">加密的</strong> —【必需】—要比较的数据。<br/> <strong class="jm io"> compare(data，encrypted，cb) </strong> <br/> <strong class="jm io"> data </strong> —【必选】—要比较的数据。<br/> <strong class="jm io">加密的</strong> —【必需】—要比较的数据。<br/><strong class="jm io">CB</strong>—[可选] —一旦数据被比较，将被触发的回调。使用eio使其异步。如果未指定cb，则在承诺支持可用的情况下返回承诺。<br/> <strong class="jm io"> err </strong> —回调的第一个参数，详细说明任何错误。<br/> <strong class="jm io"> same </strong> —回调的第二个参数，提供数据和加密形式是否匹配[true | false]。<br/><strong class="jm io">get rounds(encrypted)</strong>—返回用于加密给定哈希的轮数<br/> <strong class="jm io"> encrypted </strong> —【必需】—从中提取轮数的哈希。</p><p id="7325" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个帖子到此为止。希望你觉得有帮助，感谢您的阅读。</p><p id="fbbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae md" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lx">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>