<html>
<head>
<title>Custom React Hooks: Why Do We Need a Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义反应钩子:为什么我们需要一个上下文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/custom-react-hooks-why-do-we-need-a-context-653e8a80ef95?source=collection_archive---------17-----------------------#2021-08-17">https://javascript.plainenglish.io/custom-react-hooks-why-do-we-need-a-context-653e8a80ef95?source=collection_archive---------17-----------------------#2021-08-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f5cf8b61b754cfc09f7482ec5a61f3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujpl2C5v4LCDQi96BATuXw.jpeg"/></div></div></figure><p id="8d5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的 <a class="ae ku" href="https://www.justjeb.com/blog" rel="noopener ugc nofollow" target="_blank"> <em class="kt">个人博客</em> </a> <em class="kt">上可以免费获得这篇文章和其他文章。请务必注册以获得最新最棒的！</em></p><p id="7094" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ku" href="#8ba5" rel="noopener ugc nofollow">TL；博士</a></p><p id="db00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自定义React挂钩是封装逻辑和将数据传递到渲染树的一种非常方便的方式。</p><p id="2210" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自定义React挂钩的规则非常简单:</p><blockquote class="kv kw kx"><p id="873d" class="jv jw kt jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">自定义钩子是一个JavaScript函数，名字以“use”开头，可能会调用其他钩子。</em>T15】</strong></p></blockquote><h1 id="616c" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">纯钩子</h1><p id="92c6" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">考虑一下这个非常简单的自定义钩子的实现，它封装了一些共享文档服务的权限映射:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="94d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您所看到的，这个钩子非常简单——它使用了另一个自定义钩子，该钩子返回一个权限数组，并将它映射到一个简单的允许/不允许字典中。这将允许在整个应用程序中更好地重用代码，并帮助我们避免在每个需要这种检查的地方出现代码重复:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="af64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">唯一的问题是，这个逻辑将在每次重新渲染时运行。在小数组的情况下，这可以忽略不计，但如果是大数组，那我们就有麻烦了。添加一个简单的定制钩子可以解决这个问题:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0071" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，只有当<strong class="jx io">权限</strong>数组改变时，权限才会被重新匹配。</p><p id="a635" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">案子解决了。或者是？</p><p id="e7dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">官方React <a class="ae ku" href="https://reactjs.org/docs/hooks-custom.html#using-a-custom-hook" rel="noopener ugc nofollow" target="_blank">文档</a>可以给我们提示这种方法可能有什么问题:</p><blockquote class="kv kw kx"><p id="3945" class="jv jw kt jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">两个组件使用同一个钩子共享状态吗？</em> </strong> <em class="in">不可以，自定义钩子是一种复用</em>有状态逻辑<em class="in">(比如设置订阅，记住当前值)的机制，但是每次使用自定义钩子，里面的所有状态和效果都是完全隔离的。</em></p><p id="e0e9" class="jv jw kt jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">自定义钩子如何获得隔离状态？</em> </strong> <em class="in">各</em>谓<em class="in">为一钩中计的孤立状态。因为我们直接调用useFriendStatus，所以从React的角度来看，我们的组件只调用useState和useEffect。而就像我们前面</em> <a class="ae ku" href="https://reactjs.org/docs/hooks-state.html#tip-using-multiple-state-variables" rel="noopener ugc nofollow" target="_blank"> <em class="in">学到的</em></a><em class="in"/><a class="ae ku" href="https://reactjs.org/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns" rel="noopener ugc nofollow" target="_blank"><em class="in"/></a><em class="in">一样，我们可以在一个组件中多次调用useState和useEffect，它们会完全独立。</em></p></blockquote><p id="d317" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这实际上意味着，如果我们从两个不同的组件调用<strong class="jx io"> useIsPermitted </strong>(或者甚至从同一个组件调用两次)，逻辑将为<strong class="jx io"> useIsPermitted </strong>调用的每个实例执行，即使我们在内部使用了<strong class="jx io"> useMemo </strong>。</p><h1 id="1571" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带有上下文的自定义挂钩</h1><p id="aefa" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">解决这个问题的方法是将自定义挂钩与上下文结合起来。</p><p id="fe1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们修改一下我们的<strong class="jx io"> useIsPermitted </strong>钩子实现:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b764" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，逻辑的作用域是特定的上下文提供者。这意味着，如果我们在应用程序的根中只使用这个提供程序一次，那么逻辑将只执行一次:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8c7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，我们可以决定将提供者放在渲染树的较低位置，以便仅在渲染相关部分时才执行逻辑，但底线是—我们现在对粒度有了更多的控制。</p><h1 id="8ba5" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么时候用什么</h1><p id="9553" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">虽然在性能和内存消耗方面，与上下文挂钩似乎是一个更健壮的解决方案，但这并不意味着您应该总是使用这种方法。</p><p id="db17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两种方法都有用武之地，但是理解每一种方法的含义是很重要的。这里有一个简短的清单，可以帮助你决定正确的方法:</p><p id="57d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用纯钩时:</strong></p><ul class=""><li id="6972" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks mp mq mr ms bi translated">自定义挂钩状态<strong class="jx io">必须</strong>被隔离(每个实例不同)<strong class="jx io">或</strong></li><li id="753f" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">在自定义钩子<strong class="jx io">或</strong>中不执行繁重的计算</li><li id="472b" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">在应用程序中只使用钩子一次(作为一种沿渲染树向下传递数据的方式)</li></ul><p id="1da9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">在下列情况下使用带上下文的钩子:</strong></p><ul class=""><li id="0642" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks mp mq mr ms bi translated">整个子树<strong class="jx io">必须</strong>共享钩子的状态<strong class="jx io">或</strong></li><li id="19e2" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">钩子内部有一个繁重的计算，你希望它尽可能少地运行</li></ul><p id="a70a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢这篇文章，请关注我，在这里发表评论，或者如果你有任何问题，请在<a class="ae ku" href="https://twitter.com/jebbacca" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上给我发短信。</p><p id="2789" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容看</em> <a class="ae ku" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">说白了. io </em> </strong> </a> <strong class="jx io"> <em class="kt">。</em> </strong> <em class="kt">报名参加我们的</em><strong class="jx io"><em class="kt"/></strong><a class="ae ku" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">免费每周简讯这里</em> </strong> </a> <strong class="jx io"> <em class="kt">。</em> </strong></p></div></div>    
</body>
</html>