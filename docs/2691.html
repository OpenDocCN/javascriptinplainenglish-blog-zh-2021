<html>
<head>
<title>A Guide to Nested Promises, Anti-Pattern, and Alternatives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嵌套承诺、反模式和替代方案指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nested-promise-an-anti-pattern-alternative-to-it-a5069923a2ec?source=collection_archive---------2-----------------------#2021-06-03">https://javascript.plainenglish.io/nested-promise-an-anti-pattern-alternative-to-it-a5069923a2ec?source=collection_archive---------2-----------------------#2021-06-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6978658db60996e144794c706cfa0e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t12f2ksV4PJNNV21r8zoqQ.jpeg"/></div></div></figure><p id="169e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript中的Promise是一种流行的设计模式，用于处理Node.js中的异步任务。它可以处理许多任务的并行/串行执行以及它们的链接规则。在我的<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/promise-in-javascript-with-all-the-methods-b7357196a57e">上一篇文章</a>中，我们学习了承诺的基础知识以及常见的承诺实用方法。</p><p id="1bcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我们将学习嵌套承诺和它们的替代品。不要再浪费时间了，让我们跳进嵌套的承诺。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="c855" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">嵌套承诺:</h2><p id="225b" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">承诺为您提供了返回语句和错误抛出，而在延续传递方式下，您会丢失这些语句和错误抛出。嵌套promise是指在内部调用child promise。然后是父母的承诺和这种继续。我们举个例子，一个开发者想先创建一个用户账号，然后是订阅信息，最后是订阅购买历史。这将看起来像这样:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="28bb" class="lb lc in me b gy mi mj l mk ml">return promise1.then(promise1_output=&gt; {<br/> return promise2.then(promise2_output =&gt; {<br/>  return promise3.then(promise3_output =&gt; {<br/>   console.log(promise3_output) // this continue<br/>  })<br/> })<br/>})</span></pre><p id="a253" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，promise2仅在promise1解析时执行&amp; promise3仅在promise2解析时执行。在承诺嵌套中，当您在then方法中返回承诺时，如果返回的承诺已经被解决/拒绝，它将立即调用后续的then/catch方法，否则它将等待。如果承诺不返回，它将并行执行。</p><p id="0cb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些嵌套的承诺将从它们的外部范围访问变量，否则被称为“承诺金字塔”，它将向右增长。如果做得不正确，这个承诺金字塔最终会导致被称为<strong class="jx io"> <em class="mm">的承诺——回调地狱</em> </strong>。</p><p id="3931" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在嵌套过程中，如果您忘记返回嵌套的承诺，将导致反模式，您的解析/拒绝不会冒泡到顶部。可能使承诺变得混乱的核心问题是没有正确地记录返回值，并且没有使用类似<code class="fe mn mo mp me b">Promise.all</code>的东西显式地阻止承诺解析。有了一连串的承诺，你应该考虑用<code class="fe mn mo mp me b">.finally</code>来清理逻辑，以防出错。有时候，嵌套承诺变得不可避免。这将不可避免地导致我们谈到的回调地狱，因此为了解决这个问题，ES7提出了Async/await。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="bc47" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">嵌套承诺的替代方案:</h2><p id="19e7" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">Async/Await是我们在语言中得到支持的承诺的扩展。这个特性基本上充当了承诺之上的语法糖，使得异步代码更容易编写和阅读。它们让异步代码看起来更像老派的同步代码。</p><p id="1d9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> async </strong>关键字，你把它放在函数声明的前面，把它变成一个<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> async函数</a>。调用异步函数返回一个承诺。这是异步函数的特点之一——它们的返回值肯定会被转换成承诺。异步函数的优势只有在与<strong class="jx io"> await </strong>关键字结合使用时才变得明显。<code class="fe mn mo mp me b">await</code>仅适用于常规JavaScript代码中的异步函数。</p><p id="0041" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mn mo mp me b">await</code>放在任何基于异步承诺的函数前面，暂停该行代码，直到承诺实现，然后返回结果值。您可以在调用任何返回承诺的函数时使用<code class="fe mn mo mp me b">await</code>，包括web API函数。</p><p id="5744" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们使用async-await重写嵌套的承诺</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0d4d" class="lb lc in me b gy mi mj l mk ml">async function userInfo() {<br/> const promise1 = await new Promise((resolve, reject) =&gt; {<br/>  resolve('USer account created!');<br/> });<br/> if (promise1) {<br/>  const promise2 = await new Promise((resolve, reject) =&gt; {<br/>   resolve('Subscription created!');<br/>  });<br/>  if (promise2) {<br/>   const promise3 = await new Promise((resolve, reject) =&gt; {<br/>    resolve('Subscription history created!');<br/>   });<br/>  }<br/> }<br/>}</span></pre><p id="669d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不需要在每个基于承诺的方法的末尾链接一个<code class="fe mn mo mp me b">.then()</code>块，只需要在方法调用之前添加一个<code class="fe mn mo mp me b">await</code>关键字，然后将结果赋给一个变量。<code class="fe mn mo mp me b">await</code>关键字使JavaScript运行时暂停执行该行代码，直到异步函数调用返回结果——如果后续代码依赖于该结果，这非常有用！</p><p id="72c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于错误处理，可以使用带有<code class="fe mn mo mp me b">async</code> / <code class="fe mn mo mp me b">await.</code>的同步<code class="fe mn mo mp me b">try...catch</code>结构</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b114" class="lb lc in me b gy mi mj l mk ml">async function userInfo() {<br/> try {<br/>  <!-- -->const promise1 = await new Promise((resolve, reject) =&gt; {<br/>   resolve('USer account created!');<br/>  });<br/>  ...<br/> } catch (err) {<br/>  console.log(err)<br/> }<br/>}</span></pre><p id="b19b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">async/await建立在promises之上，所以它兼容promises提供的所有特性。这包括<code class="fe mn mo mp me b">Promise.all()</code>——您可以等待一个<code class="fe mn mo mp me b">Promise.all()</code>调用，以一种看起来像简单同步代码的方式将所有结果返回到一个变量中。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="dc66" class="lb lc in me b gy mi mj l mk ml">async function promiseAllDemo() {<br/> try {<br/>  const promise1 = Promise.resolve("hello world");<br/>  const promise2 = "Promise 2";<br/>  const promise3 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 100, 'foo');<br/>  });<br/>  const <!-- -->resolvedPromises = await <!-- -->Promise.all([promise1, promise2,  promise3])<br/>} catch (err) {<br/>  console.log(err)<br/> }<br/>}</span></pre></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="75e6" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">结论:</h2><p id="13e0" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">Async/await提供了一种很好的、简化的方式来编写更易于阅读和维护的异步代码。</p><p id="9ab6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mm">感谢阅读。原载于2021年6月2日</em></strong><a class="ae kt" href="https://noob2geek.in/2021/06/02/nested-promise-an-anti-pattern-alternative-to-it/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mm">https://noob 2 geek . in</em></strong></a><strong class="jx io"><em class="mm">。</em> </strong></p><p id="8fb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mm">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mm">plain English . io</em></a></p></div></div>    
</body>
</html>