<html>
<head>
<title>Build Data-Driven Applications with Hypi’s Low Code Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Hypi的低代码后端构建数据驱动的应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-data-driven-applications-with-hypis-low-code-backend-f4e0ac17fb67?source=collection_archive---------8-----------------------#2021-06-15">https://javascript.plainenglish.io/building-data-driven-applications-with-hypis-low-code-backend-f4e0ac17fb67?source=collection_archive---------8-----------------------#2021-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e9cac4c0d53161f963d19b64356940f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPVdTudpkLSBxiMZXHIvuA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Screenshot from <a class="ae jz" href="https://www.youtube.com/watch?v=__qDWbNlHT4&amp;t" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=__qDWbNlHT4&amp;t</a></figcaption></figure><p id="0dab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Hypi的低代码后台是2021年最具<strong class="kc io">特色的平台之一。Hypi为开发者提供了许多特性。本文将详细探讨其中的一些。</strong></p><p id="1abf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们看看什么是<strong class="kc io"> Hypi </strong>，然后我们将通过一些<strong class="kc io"> Hypi的功能</strong>。然后，我们将使用Hypi的低代码平台构建一个快速、可扩展的数据驱动应用程序。</p><h1 id="7f8e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Hypi简介</h1><p id="6212" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在构建应用程序时，开发前端只是冰山一角。后端功能的实现需要时间。对于希望尽快将其应用推向市场的企业来说，时间是至关重要的。<strong class="kc io"> Hypi省时省力</strong>。</p><p id="38cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它提供基础设施和无服务器计算。如果需要，您可以使用企业选件在自己的服务器上运行。<strong class="kc io"> Hypi可满足任何数据量、种类或速度的存储需求。</strong></p><p id="9f2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Hypi遵循干燥原则。它充当了一个<strong class="kc io">可重用组件</strong>并节省了构建常用后端功能的工作量。切换到低代码有助于开发人员避免反复编写相同的代码。</p><p id="6185" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最重要的是，Hypi是与语言和平台无关的。客户端应用可以使用任何语言(PHP、JavaScript、Java、Kotlin、Go、Rust等)或平台(Angular、React、Flutter、Android、iOS等)。它超级兼容编程世界中的大多数技术。</p><p id="26b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Hypi可以作为不同类别的应用程序的后端，如消息应用程序、社交媒体应用程序、支付系统、数据驱动的应用程序(如日历/词典等)。</p><h1 id="f7f4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Hypi的特点</h1><p id="b414" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Hypi提供了各种功能。它充当<strong class="kc io">后端即服务(BaaS)平台</strong>。Hypi提供后端功能，如关系数据库查询、实时订阅T21。Hypi使得执行<strong class="kc io"> CRUD操作、聚合、数学运算</strong>等变得容易。所有这些都可以通过低代码实现。我们可以简单地重用Hypi开发的代码，而不是从头开始编写复杂的代码。</p><p id="e85b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如今，数据安全至关重要，Hypi提供的<strong class="kc io">API高度安全</strong>。成功登录后，将为用户创建基于JWT的授权令牌。需要此令牌来访问Hypi的功能。您可以根据应用程序的安全级别启用/禁用基于授权的访问。授权策略用于控制资源。因此，<strong class="kc io"> Hypi拥有强大的认证和授权功能基础</strong>。</p><p id="1249" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Hypi推广<strong class="kc io">无服务器计算</strong>——简单地用你最喜欢的语言编写你的处理程序，一推就忘！Hypi中的无服务器功能与系统的其余部分紧密集成，因此您可以像使用内置的Hypi功能一样使用它们。</p><p id="5abb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">工作流、触发器、Webhooks、REST APIs、文件上传是Hypi提供的一些高级功能。如果Hypi不能通过它的API实现任何东西，你可以使用Groovy或者Velocity模板(或者当然使用已经提到的无服务器函数)来编写<strong class="kc io">用户定义函数</strong>。</p><h1 id="98e9" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Hypi入门</h1><p id="68e1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><strong class="kc io">一个App是Hypi </strong>的核心积木。你可以用不同的应用程序来实现不同的模块。把一个app想象成一个微服务，自己处理数据和功能。您也可以在提供相同后端功能的不同应用程序开发中重用这些应用程序。<strong class="kc io">一个app封装了一组数据结构和无服务器功能</strong>。</p><p id="e47f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个应用可以有不同的<strong class="kc io">版本</strong>。您可以在每个版本中构建名为<strong class="kc io"> schema </strong>的数据模型。确定实现后端所需的结构化数据。基于该结构生成表/对象。只需使用超级简单的Hypi界面将它们添加到应用程序的模式中。数据模型和API在应用程序的模式中进行配置。</p><p id="2dc3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">数据模型是用GraphQL的SDL </strong>编写的。如果你懂GraphQL，那么建立schema是超级容易的。即使你不懂GraphQL，也没必要写代码做数据模型。如果您可以用GraphQL编写数据模型，那么您可以选择定制。</p><p id="6c6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个应用程序可能依赖于一个或多个应用程序。你可以使用<strong class="kc io">依赖</strong>功能借用其他应用的功能。您还可以添加带有键值对的<strong class="kc io">环境设置，为您的应用程序定义配置选项。</strong></p><p id="a351" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您将一个应用程序视为一个模板，那么一个<strong class="kc io">实例</strong>就是该模板的部署版本。它也是一个app 的<strong class="kc io">孤立副本。这意味着默认情况下，在一个实例中创建的数据不能被另一个实例访问(但是如果两个实例都有权限，就可以访问)。一个版本可能有许多实例，使开发人员只需点击一个按钮就可以在API中获得多租户支持。</strong></p><p id="b2ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个实例都有自己的<strong class="kc io">域</strong>。默认情况下，Hypi生成域。但是，您可以设置一个以<strong class="kc io"> .apps.hypi.app </strong>结尾的唯一名称。域有一组唯一的属性值。<strong class="kc io">该域允许您访问Hypi </strong>提供的API。</p><p id="ed74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Hypi的用户界面非常容易<a class="ae jz" href="https://docs.hypi.app/docs/get-started/?utm_source=plainenglish&amp;utm_campaign=hypi_features&amp;utm_medium=intro&amp;utm_term=get_started" rel="noopener ugc nofollow" target="_blank">入门</a>App开发。一定要去看看！</p><h1 id="9d20" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">API设置</h1><p id="ac5c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Hypi是基于API的低代码平台。在实例上创建的Hypi域允许您访问这些API。我们可以说API是你和Hypi连接的钥匙。</p><p id="1034" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你如何与Hypi的低代码平台上创建的应用程序连接？</p><p id="514b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">应用程序可以被视为npm包或依赖关系</strong>并保存在您的工作区中。或者你通过<strong class="kc io">一个HTTP请求、REST APIs或者WebSockets连接</strong>与Hypi APIs连接。</p><p id="e73c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看如何设置API。</p><h1 id="79ff" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">HTTP标题</h1><p id="1c9d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">建立HTTP连接需要以下三个头。</p><ol class=""><li id="2b48" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">内容类型:'<strong class="kc io">应用程序/json' </strong></li><li id="f95a" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">hypi域名:'<strong class="kc io"> abc.apps.hypi.app </strong></li><li id="8dc2" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">授权:<strong class="kc io">‘实例的授权令牌’</strong></li></ol><p id="b4ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Hypi域是向其发出HTTP请求的实例。授权令牌在登录到帐户后生成。这两个值在用户界面上都可用。</p><h1 id="1704" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">API URLs</h1><p id="e7d0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如前所述，您可以通过三种方式连接Hypi APIs。使用API端点，使用REST APIs，或建立WebSockets，如果您有高性能要求，您可以通过Hypi的Pulsar流集成将高速数据传输到您的应用程序中。为此，下面三个URL是安全的。</p><p id="e99f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">https://api.hypi.app/graphql—这是一个端点，表示Hypi域中的一个对象或对象集合。<strong class="kc io">将您的HTTP客户端指向这个端点，以便与Hypi数据资源进行交互</strong>。您可以在与此API端点连接时执行Hypi APIs。</p><p id="ddc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">https://api.hypi.app/rest——RESTful API是Hypi的重要特性之一。您可以向该URL发送类似REST的请求。</p><p id="9c9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">WSS://API . hypi . app—<strong class="kc io">web socket连接促进了持久连接，并允许在客户端和服务器之间传递消息</strong>。订阅API使用这个WebSocket URL工作。</p><p id="debf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Hypi博客上的这篇文章展示了如何在JavaScript代码和Hypi的底层代码之间建立联系。你会发现理解Hypi的工作模式很有用。</p><h1 id="e702" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用Hypi进行CRUD操作</h1><p id="03a3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><a class="ae jz" href="https://docs.hypi.app/docs/crud/?utm_source=plainenglish&amp;utm_campaign=hypi_features&amp;utm_medium=intro&amp;utm_term=crud" rel="noopener ugc nofollow" target="_blank"> CRUD操作</a>在任何数据驱动的应用中都非常重要。Hypi的CRUD APIs很好地完成了数据处理的工作。简而言之，我将带你经历一次旅程<strong class="kc io">使用Hypi的CRUD API</strong>实现社交媒体帖子。</p><p id="de6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是执行CRUD操作的社交媒体帖子的<strong class="kc io">模式</strong>。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/1d1b67a81e97d6f20a3d92540a2e07cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Ls-arjw-ZFw0h3l"/></div></div></figure><p id="dd3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Post数据类型就像一个表，Post的字段就像列。<code class="fe mu mv mw mx b">postedby</code>是创建Post对象的人的帐户。账户被一个唯一的用户名或电子邮件识别。Account是Hypi中固有的核心数据类型。<code class="fe mu mv mw mx b">@computed</code>是Hypi提供的指令。我们可以用它来运行一个查询，提取创建这篇文章的帐户用户名。<code class="fe mu mv mw mx b">likecount</code>代表帖子上的赞数。<code class="fe mu mv mw mx b">likedby</code>提供喜欢该帖子的账户。<code class="fe mu mv mw mx b">comment</code>编辑帖子上的评论列表。评论被认为和其他文章一样。不同的用户可以对特定帖子发表评论，该评论可能会被其他用户进一步喜欢/评论。</p><p id="330d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们在这个Post表中插入数据时，就会创建行。每行代表一个Post对象，而<strong class="kc io">魔术Hypi对象</strong>成为这个Post对象的一部分。</p><p id="16a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Hypi对象保存诸如<strong class="kc io">唯一Hypi ID </strong>、对象创建日期、创建对象的用户帐户ID、对象创建/更新日期等信息。它还有其他字段，您可以在Hypi提供的<a class="ae jz" href="https://docs.hypi.app/docs/magic-hypi-object/?utm_source=plainenglish&amp;utm_campaign=hypi_features&amp;utm_medium=intro&amp;utm_term=documentation" rel="noopener ugc nofollow" target="_blank">综合文档</a>中查看。因此，每个Post对象都有一个惟一的<code class="fe mu mv mw mx b">hypi.id</code>，它赋予Post对象自己的身份。</p><p id="12a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在CRUD操作中，我们在插入、更新或删除数据时在GraphQL中执行变异。在检索数据时，我们执行查询。</p><h1 id="78a6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建数据</h1><p id="738b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><code class="fe mu mv mw mx b">upsert</code> <strong class="kc io"> </strong>功能用于创建数据或将数据插入对象中的字段。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/b38738a5935a148ae23183084287204e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1YqEnbelOSVh8S5A"/></div></div></figure><p id="063c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的变化创建了Post对象并将文本添加到Post中。发帖人会在<code class="fe mu mv mw mx b">postedby</code>字段中自动更新。</p><p id="3863" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mu mv mw mx b">values</code>参数有你想用<code class="fe mu mv mw mx b">upsert</code>突变创建的对象。您必须在Hypi对象中指定您希望作为响应接收的字段。在这里，只有对象<code class="fe mu mv mw mx b">id</code>被选中，因此只有这个被返回。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/59e3e37e01da65e22e92dae833c68143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YXeIbVPfodudtLnk"/></div></div></figure><h1 id="9b8f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更新数据</h1><p id="df9f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">更新数据也是一种变异，同样的<code class="fe mu mv mw mx b">upsert</code>函数用于更新数据。唯一的区别是，在创建数据时<code class="fe mu mv mw mx b">hypi.id</code>被生成，而在更新数据时<strong class="kc io">需要与数据</strong>一起提供，数据必须为特定对象保存。</p><p id="4709" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设<strong class="kc io">两个人Hypi和CRUD喜欢帖子</strong>，我们想在创建的<strong class="kc io">帖子</strong>对象中更新这个信息。我们必须向<code class="fe mu mv mw mx b">likedby</code>帐户列表提供<strong class="kc io"> Hypi </strong>和<strong class="kc io">CRUD</strong>T29】帐户对象的<code class="fe mu mv mw mx b">hypi.id</code>。必须提供最后一段代码中返回的<code class="fe mu mv mw mx b">hypi.id</code>来更新Post对象。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/965fa1fd367379c01c8f2c67a67a5d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y6Tc7V2b6hY118Cd"/></div></div></figure><p id="b51e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们收到与之前相同的响应/ <code class="fe mu mv mw mx b">hypi.id</code>。</p><p id="7e03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，假设<strong class="kc io">某个用户对帖子</strong>发表了评论，我们想从帖子对象更新评论字段。因此，另一个用户应该有权访问Post对象中的<strong class="kc io">评论</strong>字段。您需要在Hypi的用户界面上启用这些权限。之后，只需将评论更新到之前创建的Post对象。如前所述，传递Post对象的同一个<code class="fe mu mv mw mx b">hypi. id</code>来更新字段。我们得到同样的回应。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/8d86e63c25f3ad6748aa66b8750e6e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5jdCtgryWU_KJ1U9"/></div></div></figure><h1 id="4453" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">读出数据</h1><p id="0699" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">读取数据就像执行查询从表/对象中检索数据。有两个用于检索数据的Hypi APIs<code class="fe mu mv mw mx b">get</code>和<code class="fe mu mv mw mx b">find</code>。</p><p id="dfbe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用户可能希望<strong class="kc io">分享帖子(好消息还是坏消息！)与社交媒体上的其他用户</strong>。您可以<strong class="kc io">使用get功能访问帖子的详细信息</strong>。</p><p id="32b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">必须将类型<strong class="kc io"> </strong>和id <strong class="kc io"> </strong>作为参数提供给<code class="fe mu mv mw mx b">get</code>函数。该函数返回被查询对象的字段。您需要提供对象所需的字段。将只返回那些字段。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/e188c2db592dba44aeac55b3358cc731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oBqcBGevs26yER2O"/></div></div></figure><p id="cde6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回应如下:</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/2f212f439e5ade2f3a6a40bba349cccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qyOsGFIEm07gu0aA"/></div></div></figure><p id="6b96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，你需要<strong class="kc io">显示一个用户在他的时间轴</strong>上的所有帖子。你会怎么做？只需<strong class="kc io">使用find函数访问所有Post对象</strong>。这将检索用户创建的所有帖子的详细信息。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/dbb1790979bc564a9db719e6b7933e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*28UyrYSbFEd7NoDZ"/></div></div></figure><p id="2285" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结果如下:</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/76e55200a2713dda23513143238d3733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*8R0KkcK65mFvq6SL"/></div></figure><p id="9f73" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ng"> * </em> <code class="fe mu mv mw mx b"><em class="ng">find</em></code> <em class="ng">函数将评论字段视为一个单独的帖子对象。</em></p><p id="bc2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以使用<strong class="kc io"> ArcQl查询</strong>来过滤数据，以检索特定的结果。在上面的查询中，我们使用了<code class="fe mu mv mw mx b">*</code>来检索所有的Post对象。</p><h1 id="853a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">删除数据</h1><p id="9a95" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><strong class="kc io">删除</strong>是从表中删除数据的一种变异。您可以<strong class="kc io">执行软删除来临时删除数据</strong>。<code class="fe mu mv mw mx b">trash</code>功能用于执行软删除。垃圾数据“似乎”被删除，但您可以在需要时恢复它。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/df64a99c1a3f59840530add4f196772e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MDgYWh7SbYnrI6_9"/></div></div></figure><p id="fae0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">被丢弃的对象不能用get函数获取。使用查找功能时，需要将<code class="fe mu mv mw mx b">includeTrashed</code>参数设置为<code class="fe mu mv mw mx b">true</code> <strong class="kc io"> </strong>来检索垃圾对象。</p><p id="dfd9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要从无用数据中删除标记，只需使用<code class="fe mu mv mw mx b">untrash</code>功能。使用该函数的格式是相同的。<strong class="kc io"/><code class="fe mu mv mw mx b"><strong class="kc io">trash</strong></code><strong class="kc io">和</strong> <code class="fe mu mv mw mx b"><strong class="kc io">untrash</strong></code> <strong class="kc io">两个函数都返回已丢弃/未丢弃的记录数。</strong></p><p id="7611" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">使用</strong> <code class="fe mu mv mw mx b"><strong class="kc io">delete</strong></code> <strong class="kc io">功能永久删除帖子</strong>。</p><p id="c0e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果不同对象之间存在一对一或一对多的关系，则将<code class="fe mu mv mw mx b">clearArrayReferences</code> <strong class="kc io"> </strong>参数设置为<code class="fe mu mv mw mx b">true</code>。在这里，原始帖子和评论帖子被取消链接，对象被删除。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/18bb4f6c8ed0407ca196b3e0cdb171df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CzK9GOMOBkOQG79F"/></div></div></figure><h1 id="fe41" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用ArcQL过滤器查找数据</h1><p id="87ca" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><strong class="kc io">我们如何使用find函数检索特定数据？Hypi开发了一种强大的类似SQL的查询语言，即ArcQL。使用ArcQL，您可以从表中选择行，然后使用find从这些行中检索数据。</strong></p><p id="289d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有不同类型的ArcQL查询，如<strong class="kc io">短语查询、术语查询、前缀查询、通配符查询、排序查询、范围查询</strong>等。构建查询取决于您希望如何获取数据。<strong class="kc io">布尔逻辑也可以用于带有</strong> <code class="fe mu mv mw mx b"><strong class="kc io">AND</strong></code> <strong class="kc io">和</strong> <code class="fe mu mv mw mx b"><strong class="kc io">OR</strong></code> <strong class="kc io">运算符的各种查询。</strong></p><p id="b432" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">术语查询</strong>:这是一个简单的过滤器，与提供的值完全匹配。它过滤arcql语句中询问的数据。</p><p id="b410" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mu mv mw mx b"><strong class="kc io">arcql:"postedby.username = ‘user2’ OR postedby.username = ‘user1’"</strong></code></p><p id="8064" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以上术语查询通过<code class="fe mu mv mw mx b">user1</code>和<code class="fe mu mv mw mx b">user2</code>搜索帖子。</p><p id="18ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">前缀查询</strong>:该查询返回以查询中提供的前缀开始的记录。</p><p id="e59a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mu mv mw mx b"><strong class="kc io">arcql:"address.city^’P’"</strong></code></p><p id="5a38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将返回居住在以字母<code class="fe mu mv mw mx b">P</code>开头的城市中的用户的数据</p><p id="9323" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">短语查询</strong>:使用语句中提供的单个单词或短语过滤数据。</p><p id="07d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mu mv mw mx b"><strong class="kc io">arcql:"text~’low code’"</strong></code></p><p id="75e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们得到文本中包含短语<code class="fe mu mv mw mx b">low code</code>的帖子。</p><p id="0328" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">排序查询</strong>:您可以像这样对记录进行升序或降序排序。</p><p id="cdb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mu mv mw mx b"><strong class="kc io">arcql:"* SORT text ASC"</strong></code></p><p id="44c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">范围查询:搜索特定范围内的数据。<code class="fe mu mv mw mx b">IN</code>从句用于说明。</p><p id="6854" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mu mv mw mx b"><strong class="kc io">arcql:"date IN (‘2010–01–01’,’2011–01–01')"</strong></code></p><h1 id="163b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="448b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们看到了Hypi作为一个低代码平台所提供的一瞥。我们已经看到了Hypi如何作为BaaS提供商发挥作用。</p><p id="4726" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对常用CRUD操作的简单演示将带您了解Hypi CRUD APIs是如何工作的。我们还研究了简单而强大的ArcQL查询。板上还有很多其他的API和功能，一定要去看看！</p><p id="9b60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我建议尝试一下Hypi。如果你有，一定要在评论中让我们知道你的想法！</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><p id="f5e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ng">多内容于</em> <a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ng">浅显易懂</em> </strong> </a></p></div></div>    
</body>
</html>