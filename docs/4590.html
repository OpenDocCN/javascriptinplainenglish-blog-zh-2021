<html>
<head>
<title>Classes vs. Literal Objects: A Minimalistic “Vanilla JS” Approach to OOP and Serialization in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类与文字对象:JavaScript中面向对象和序列化的极简“香草JS”方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/classes-vs-literal-objects-a-minimalistic-vanillajs-approach-to-oop-and-serialization-in-f08fdbf6157?source=collection_archive---------13-----------------------#2021-09-13">https://javascript.plainenglish.io/classes-vs-literal-objects-a-minimalistic-vanillajs-approach-to-oop-and-serialization-in-f08fdbf6157?source=collection_archive---------13-----------------------#2021-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9c1cc69bc074de5d350151663c6c9c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwQ3ZKff44MesgyrNOoA0w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jefflssantos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jefferson Santos</a> on <a class="ae jz" href="https://unsplash.com/s/photos/programming-language?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ade1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">面向对象编程意味着识别和隔离具有特定属性和方法或功能的“代码工作者”,这些代码工作者相互交互和交换数据。</p><p id="a90f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ECMAScript 2015，也称为ES6，引入了JavaScript类。JavaScript类是JavaScript对象的模板。这意味着引入像<em class="ky">类、静态、扩展</em>这样的关键字。</p><p id="c4fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然使用类对于组织代码非常有用，但是在客户机-服务器环境中编程，尤其是在“web无服务”架构中，首先需要在不同的应用程序或页面之间交换数据(即在浏览器内部运行的javascript客户机应用程序和HTTP服务或API)。换句话说，不同的软件组件必须能够交换组成它们的对象(或者说数据),以便相互交流。这称为对象序列化。</p><h2 id="33fa" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">序列化</h2><p id="a2f8" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在计算中，串行化是<strong class="kc io">将数据结构或对象状态转换成可以存储</strong>(例如，在文件或内存数据缓冲区中)或传输(例如，通过计算机网络)并在以后重建的格式的过程。(【https://en.wikipedia.org/wiki/Serialization】<em class="ky"/>)</p><h2 id="88bc" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">使用Javascript文字对象的简单序列化方法</h2><blockquote class="lx ly lz"><p id="45b2" class="ka kb ky kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">对象文字是花括号内逗号分隔的名称-值对列表。下面是一个例子。</p></blockquote><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="2e82" class="kz la in mi b gy mm mn l mo mp"><strong class="mi io">exports var room = {</strong></span><span id="d416" class="kz la in mi b gy mq mn l mo mp"> <em class="ky">name</em>: 'kitchen',<br/> <em class="ky">floor</em>: 1,<br/> <em class="ky">measure</em>: 12,<br/> <em class="ky">sayHello(){</em><br/>  console.log(`Hello, i'm the ${this.name}`)<br/> <em class="ky">}</em></span><span id="2e3a" class="kz la in mi b gy mq mn l mo mp"><strong class="mi io">}</strong></span></pre><p id="980f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">通过网络共享房间对象或在单页应用程序中路由</strong></p><p id="4fb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我要做的是将数据从方法中分离出来，并使用一个extends(但您可以随意称呼它)方法来设置或获取序列化的room对象。<strong class="kc io">这将使房间对象成为一个具有许多对象数据的静态类。</strong></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0520" class="kz la in mi b gy mm mn l mo mp">export var room = {</span><span id="a24a" class="kz la in mi b gy mq mn l mo mp"><strong class="mi io">extends(data){</strong><br/>  return {<br/>     name: data &amp;&amp; data.name ? data.name : undefined<br/>     floor: data &amp;&amp; data.floor ? data.floor : undefined<br/>     measure: data &amp;&amp; data.measure ? data.measure : undefined<br/>  }</span><span id="e062" class="kz la in mi b gy mq mn l mo mp"><strong class="mi io">},</strong><br/> <br/> sayHello(obj){<br/>  console.log(`Hello, i'm the ${obj.name}`)<br/> }</span><span id="3521" class="kz la in mi b gy mq mn l mo mp">}</span></pre><blockquote class="lx ly lz"><p id="5062" class="ka kb ky kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">请注意，extends方法返回一个新对象(记住，当您创建一个对象<em class="in">时，您给出的是对它的引用，而不是一个值</em>)。</p></blockquote><h2 id="c76a" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">实际例子</h2><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="61ac" class="kz la in mi b gy mm mn l mo mp">let room1 = room.extends({name: 'kitchen'})<br/>let room2 = room.extends({name: 'garage'})</span><span id="4e20" class="kz la in mi b gy mq mn l mo mp">console.log(room.sayHello(room1)) //Hello, i'am the kitchen<br/>console.log(room.sayHello(room2)) //Hello, i'am the garage</span></pre><p id="498b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>