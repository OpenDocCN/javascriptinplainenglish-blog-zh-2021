# Context 比 Redux 好吗？

> 原文：<https://javascript.plainenglish.io/is-context-better-than-redux-a3000e21ced9?source=collection_archive---------0----------------------->

![](img/a87f063d869f40e1a87ca8068ff1d72d.png)

Pictorial Showing the State of Developer Interest in Context

当我第一次学习如何使用 Redux 时，要跟上不同的文件、函数、类型、动作和 reducers 才能使它工作，这有点让人不知所措。在我掌握了它的窍门之后，使用它几乎就像是第二天性——它是高度结构化的，很容易辨别错误来自哪里，并且在构建功能时有一个可重复的模式。但是当我了解到 React Context API 时，我对跨组件管理状态是如此简单感到困惑，我想知道为什么我一直在使用 Redux。

我着手调查 Redux 尽管更加臃肿(对不起老朋友)而且使用起来复杂，但仍然在任何开发人员的工具箱中占有一席之地的原因。

先从定义 Redux 开始。如果你想深入了解，你可以在这里查看文档。简而言之，Redux 通过为应用程序的状态提供单一的真实来源，提供了一种有组织的、稳定的方式来管理 javascript 应用程序中组件的状态。它由以下基本组件组成:

*   **Store:** 包含整个应用程序的状态。
*   **动作:**一个带有类型键的 javascript 对象，本质上描述了应用程序中发生的事情。
*   **Reducer:** 接受当前状态和动作，必要时更新状态，并返回更新后的状态的函数。
*   **订阅:**允许组件只订阅存储中状态的相关部分，防止在对状态的不相关部分进行更改时出现不必要的重新呈现。

Redux 的实际实现有更多的组件，比如 dispatch 和 thunk 中间件，如果你有异步副作用的话，但是我将保持它的简单，这样我们就可以继续比较 Redux 和 Context 了。这里有一张来自文档的有用的 gif 图，它有助于描述如何使用 Redux 更新状态。

![](img/c6f4365f00f922faf01d74202c302e2d.png)

Source: Redux Docs

继续，让我们定义 React 的上下文 API。你可以在这里找到上下文文档。与 Redux 类似，当您希望在组件树中不同级别的许多组件之间共享状态，而不需要将它作为道具传递给每个组件时，可以使用 Context。上下文是 React 的一部分，因此您不需要像 Redux 那样安装第三方库或处理样板文件。为了使用上下文，你需要三个基本要素:

*   **上下文提供者:**将向相关组件提供共享数据。它通常在根组件中声明，这样整个应用程序都可以访问它，或者在嵌套在所有需要访问它的组件周围的组件中声明。
*   **上下文对象:**由上下文提供者提供的数据。对此数据的更改将反映在使用该数据的所有组件中。
*   **上下文消费者:**订阅上下文提供的状态的组件。

乍一看，使用上下文似乎是一个非常好的交易，在许多情况下确实如此！它内置在 React 中，易于学习和使用，与 Redux 相比感觉很轻量级，并且您不必设置所有那些 reducers、actions、types 等等。如果你正在建立一个中型的个人项目，Context 可能真的是你的完美解决方案。

然而，Redux 仍然有一个蓬勃发展的社区围绕着它，这是有原因的。这本身就很方便——很可能有人已经记录并解决了您遇到的冗余问题！如果您在一个拥有大型代码库和多名工程师的企业环境中工作，Redux 看起来会好很多。它迫使你有条理并遵循一定的模式。即使你没有写代码，你也可以跟踪可靠的 Redux 轨迹，从动作到类型，到分派，再到 reducer，并找到 Redux 的代码结构导致的错误。

在调试方面，Redux 比 Context 更有优势，不仅因为可预测的代码结构，还因为像 Redux Devtools 和其他插件这样的工具提供了对状态如何随时间变化的强大洞察力。Redux 还允许使用中间件，它将第三方扩展合并到您的 Redux 流中。因为 Redux 是一个库，所以它的功能更强大，充满了 Context 根本不具备的特性。

当前 Redux 仍然非常可行的最后一个原因，也可能是最重要的一个原因是，不建议在频繁更新的应用程序中使用上下文。Redux 在消除不必要的重新渲染方面非常有效，但如果你的应用程序经常更新，那么开箱即用的上下文可能会变得非常低效，并导致大量不必要的重新渲染。原因是，当上下文对象中的任何值更新时，作为上下文使用者的所有组件都将更新，而不管该更改是否与该组件相关。有解决这个问题的方法，比如使用记忆来记住以前的值以防止重新渲染，但是上下文本身并不能解决这个问题。

当我开始写这篇文章的时候，我并没有想到它会成为一封写给 Redux 的情书，但是我确实对它所能做的一切更加欣赏。重要的是要注意，两者都不是“更好”，它们仅仅是具有不同用例的不同工具，只要您了解您的项目及其需求，就会清楚哪个最适合这项工作。

*更多内容尽在*[*plain English . io*](http://plainenglish.io/)