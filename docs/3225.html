<html>
<head>
<title>How to Implement Binary Search Trees and Tree Traversal in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中实现二分搜索法树和树遍历</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-search-trees-and-tree-traversal-in-javascript-ab7f9cf6b3d2?source=collection_archive---------12-----------------------#2021-07-01">https://javascript.plainenglish.io/binary-search-trees-and-tree-traversal-in-javascript-ab7f9cf6b3d2?source=collection_archive---------12-----------------------#2021-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/59370d9e8cc2d9bad8b134194dfa97cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OJaD7DmFOVdgFfiZ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Labeled Binary Search Tree</figcaption></figure><p id="5db0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">作为用JavaScript实现数据结构系列的继续，我们将创建一个二叉查找树类，并尝试遍历树中的每个节点。</p><p id="6eba" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我再一次强调，柯尔特·斯蒂尔的Udemy课程在整个学习过程中是多么的有帮助。有很多资源，但我对他的教学风格有共鸣，觉得他把这些复杂的科目分解成容易理解的部分。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="938a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">什么是树？树是父/子关系中节点的集合。如果你一直关注这个系列，你会知道链表是节点的集合，其中一个节点由一个值和一个指向下一个节点的指针组成。看看上面的图片，一棵树由一个根(也是一个父节点)、父节点和子节点组成。具有相同父节点的节点称为兄弟节点，没有子节点的节点(实际上是树的端点)称为叶节点。只有一个节点可以被认为是树的“根”,兄弟节点不能相互指向对方。展开后，我们可以看到该图如何显示为自上而下的树形结构，随着更多节点的添加，该结构会向外扩展。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/7c0461f749c6548a0b76fabbdfadaa37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AA1DZ4EJjudNRx1B.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The DOM can be represented in a tree structure. Take a moment to open up your browser's dev tools.</figcaption></figure><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/61fcd47a2f1ba745f9bb27c75a8ec081.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/0*79FmDkLrkJ5_gI9n.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">JSON and Filing systems also take the form of tree structures</figcaption></figure><p id="bb6e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">树数据结构的一些实际例子包括DOM、JSON对象、计算机的文件系统、网络路由等等。我们将处理计算机科学中常见的一种特殊类型的树，二叉查找树。如果你看这篇文章最上面的第一张图片，你会看到一个BST的例子。BST的一个特性是它可以有0个、1个或2个节点，但不能更多。树的父节点可以有多个子节点3、4、5等等，但此时不同的数据结构可能更合适。</p><p id="1c4c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">BST以一种特别的顺序保存，这种顺序有利于搜索。如果你还没有注意到，从根开始，它左边的所有值都小于它本身，而根右边的值都大于它。一般模式是父节点的子节点将小于它的值放在左边，将大于它的值放在右边。这种格式使得在树中搜索变得更加容易，并且将搜索的节点数量减少了大约一半。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="f567" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要实现一个BST类，我们需要节点、一个作为初始值的根，以及两个方法:insert和find。请参见下图，了解插入和查找的实现。你可以在这里找到BST类<a class="ae kx" href="https://github.com/maquino96/Colt-Steele-DSA-Udemy/blob/main/Course/Data%20Structures/binarySearchTree.js" rel="noopener ugc nofollow" target="_blank">的完整实现</a>。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ll"><img src="../Images/abbb1b9f8ee30aee25871a01bf8b5ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWjACEdXsLDqtopeyVoXow.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Inserting a node into a BST</figcaption></figure><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/c85baee7b4194cc547fafac923dc71cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*HjXdlTjp4SrkNAygBKyqzA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A find method, effectively searching through the tree for an input value</figcaption></figure><p id="a036" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你能理解上面图片中的逻辑，我会为你鼓掌，这相当简单，但对于更多的视觉学习者，我建议查看这个网站:<a class="ae kx" href="https://visualgo.net/en/bst" rel="noopener ugc nofollow" target="_blank"> Visualgo </a>。我发现看到树的实际遍历对我理解上面的逻辑很有帮助。</p><h1 id="19b4" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">二分搜索法树的比戈</h1><p id="52c3" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">我们将用BST的时间复杂性分析来结束这篇文章。当涉及到插入和搜索时，BST的BigO是O(log n)。BigO是一个通用的度量，所以对于一般和最坏的情况，在BST中插入和搜索是非常有效的。当我们将输入数(n)增加一倍时，步进数仅增加BST的深度)。如果您需要以有序的方式存储数据，并不断地向集合中添加数据以及从中读取数据，那么BST可能是您的最佳选择。当处理BST时，要小心单边/不平衡的结构，效率会下降到O(n ),因为你基本上创建的是一个链表。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/e5dc38ffb7ffe40e7fb250081dc8e9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BijrPJc5pRsOXYAWx6ZHtw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Balanced and unbalanced BST</figcaption></figure><p id="8307" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请在这里查看我的其他帖子<a class="ae kx" href="https://matthewaquino.medium.com/" rel="noopener"/>。在以后的博客文章中，我们很可能会涉及堆和优先级队列！</p><p id="11ad" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="mr">更多内容尽在</em><a class="ae kx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="mr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>