<html>
<head>
<title>How To Eliminate Render Blocking Resources For Faster Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为更快的Web应用消除渲染阻塞资源</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-eliminate-render-blocking-resources-for-faster-web-apps-f6f72ffe9b12?source=collection_archive---------9-----------------------#2021-01-17">https://javascript.plainenglish.io/how-to-eliminate-render-blocking-resources-for-faster-web-apps-f6f72ffe9b12?source=collection_archive---------9-----------------------#2021-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="93a8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建快速加载的Web应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/401229be0895e8a826b13d554fd44337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z49xu1eHDIEu2kJK.jpg"/></div></div></figure><p id="ee69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在渲染网页的过程中，字体、<strong class="kt ir"> HTML、</strong>、<strong class="kt ir"> CSS、</strong>、<strong class="kt ir"> JavaScript </strong>等静态文件成为一个重要的阻塞资源，在这些关键文件被处理完之前，它停止下载其余的资源。这导致了缓慢的web应用程序，因为整个渲染过程都处于暂停状态。</p><p id="7364" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些关键资源文件对您的web应用程序的性能有很大影响，有几种方法可以消除呈现阻塞资源，我们可以减少呈现阻塞资源的数量，或者我们可以缩短关键呈现路径和减少页面加载时间，以改善用户体验。</p><p id="e2fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">有三种方法可以减少渲染阻塞资源的影响:</strong></p><ul class=""><li id="3ca0" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">通过推迟下载使它们成为非呈现资源。</li><li id="4906" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">减少<strong class="kt ir"> HTTP </strong>请求的数量。</li><li id="911b" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">通过缩小来减少资源的大小- <strong class="kt ir"> <em class="mb">(页面加载的字节数较少)</em> </strong>。</li></ul><h1 id="26af" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">渲染阻塞资源</h1><p id="ec7b" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">每个web应用程序都会处理它在一个<strong class="kt ir"> HTML </strong>页面的<strong class="kt ir"> &lt; head &gt; </strong>部分中找到的所有内容，包括:</p><ul class=""><li id="c58e" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">CSS样式表。</li><li id="c44b" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">在th <strong class="kt ir"> &lt; head &gt; </strong>部分添加的JavaScript文件。</li><li id="445d" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">来自<strong class="kt ir"> CDN </strong>或本地服务器的字体。</li><li id="72f0" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">HTML导入。</li></ul><p id="1107" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">放置在<strong class="kt ir">&lt;&gt;</strong>部分底部的图像、媒体文件和&lt;脚本&gt; 标签都是非渲染资源。</p><p id="6840" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了消除这些资源，这里有一些开发人员用来优化和加速他们的web应用程序的最佳实践。</p><h2 id="c3d1" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">不要使用导入规则添加CSS</h2><ul class=""><li id="d8b0" class="ln lo iq kt b ku mu kx mv la nl le nm li nn lm ls lt lu lv bi translated">使用HTML文件中添加的<strong class="kt ir">&lt;link rel = ' style sheet '&gt;</strong>标签将CSS添加到页面中。</li></ul><p id="68cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="mb">导入</em> </strong>规则可能会使项目更整洁，并且所有的<strong class="kt ir"> CSS </strong>依赖项都在同一个地方，但是考虑到性能，这不是最好的选择。使用<strong class="kt ir">导入</strong>规则允许您从其他样式表导入CSS，但是这种方法会导致浏览器处理<strong class="kt ir"> CSS </strong>文件的速度更慢，因为它还必须下载导入的文件，并且在此之前您的渲染过程将被阻塞。</p><p id="020b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你需要添加一个以上的CSS文件到你的页面，你可以使用<strong class="kt ir"> &lt;链接&gt; <em class="mb"> </em> </strong>标签或者<strong class="kt ir">使用缩小工具连接</strong>文件。</p><p id="0653" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/04d41d65ae32facace08421cda12fffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkBSRG_LMfmAZFLUyMdMMg.png"/></div></div></figure><h2 id="155f" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">对条件CSS使用媒体属性</h2><p id="54fb" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">默认情况下，每个浏览器都将CSS文件视为渲染阻塞资源，但是如果我们将<strong class="kt ir"> media </strong>属性添加到<strong class="kt ir"> <em class="mb"> &lt; link &gt; </em> </strong>标签，那么我们就可以向浏览器指示条件<strong class="kt ir"> CSS </strong>文件的存在。</p><p id="96fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为条件CSS只适用于特定的条件，比如低于或高于视窗大小或在打印页面上。使用media属性，您可以为CSS文件定义特定的媒体条件。<strong class="kt ir"> <em class="mb">(可以使用CSS文件中用于媒体查询的任何值)</em> </strong></p><p id="7495" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/f74e0859a8b4d5ef6bf76ffe36191d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKvKrNyHj6ReF3SS-bkkBg.png"/></div></div></figure><p id="794a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使在这个实现之后，这些文件仍然被下载到所有设备上，如果条件评估为假，它们将成为非渲染阻塞资源。<strong class="kt ir"> mobile.css </strong>样式表将在最大视窗宽度为<strong class="kt ir"> 600px </strong>的移动设备上呈现阻塞，在大于<strong class="kt ir"> 600px的视窗上不呈现阻塞。</strong></p><p id="ed94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，如果您有一个或多个媒体查询的现有<strong class="kt ir"> CSS </strong>文件，您可以使用<strong class="kt ir"> PostCSS </strong>插件提取所有媒体规则，并将其保存在一个单独的文件中。这种做法也被称为<strong class="kt ir">代码分割</strong>，我们也可以分割较大的CSS文件，只在需要时才加载每个文件，以缩短关键渲染路径，减少初始页面加载时间。</p><h2 id="6671" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">延迟和异步属性</h2><p id="d73b" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated"><strong class="kt ir">添加到文档的<strong class="kt ir">&lt;&gt;</strong>节中的JavaScript </strong>文件总是被视为渲染阻塞资源，为了将它们从关键渲染路径中移除，我们可以将它们放置在<strong class="kt ir"> &lt;脚本&gt; </strong>标签中，而不是<strong class="kt ir"> &lt; head &gt; </strong>节中。使用这种技术，他们只在整个<strong class="kt ir"> HTML </strong>之后下载。由于这些脚本的下载开始得较晚，他们加载的元素，如<strong class="kt ir"> ads </strong>或任何<strong class="kt ir">动态函数</strong>可能比前端的其余部分加载得晚，这导致滞后的<strong class="kt ir">ui</strong>和较慢的连接。</p><p id="01c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们可以使用<strong class="kt ir">&lt;&gt;</strong>标签的<strong class="kt ir">延迟</strong>和<strong class="kt ir">异步</strong>属性，这两个属性都是布尔属性，这意味着它们无需任何进一步的配置即可触发。defer属性指示浏览器在后台下载脚本，这样就不会阻止页面的呈现。</p><p id="8990" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mb">延迟脚本执行一次，在</em><strong class="kt ir"><em class="mb">DOM content loaded</em></strong><em class="mb">事件触发之前，DOM </em>  <em class="mb">准备就绪。</em></p><p id="6714" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/7d8157a77755e6122fa09a4f14754282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbVcbFNgID0i4qjNLI6LSg.png"/></div></div></figure><p id="810d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> script01.js </strong>将首先被执行，不管哪个脚本首先被加载，我们不能添加延迟到内联脚本，因为它只适用于用<strong class="kt ir"> src </strong>属性指定脚本位置的外部脚本。</p><p id="d44c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> async </strong>属性告诉浏览器脚本完全独立于页面。因此，它将作为非渲染阻塞资源在后台下载。然而<strong class="kt ir">异步</strong>脚本并不遵循文档顺序，所以它们会在下载完成后立即执行。</p><p id="ce0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们不能确定哪个脚本会先运行，因为这完全取决于哪个下载更快。注意<strong class="kt ir">异步</strong>脚本独立于文档，因此文档顺序不会对它们产生任何影响。</p><ul class=""><li id="5691" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">对于需要DOM的脚本，建议使用<strong class="kt ir"> defer </strong>属性。</li><li id="61c3" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对于独立的第三方脚本，如广告、追踪器和分析脚本，建议使用<strong class="kt ir"> async </strong>属性。</li></ul><h2 id="80f5" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">缩小和捆绑CSS和JavaScript</h2><p id="de6e" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">您可以为使用相同加载规则的文件创建包，并分别缩小每个包。由于<strong class="kt ir">缩小后的</strong>文件更轻，捆绑后在关键渲染路径中生成的文件更少，初始页面渲染将更快完成。</p><p id="5a49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="mb">有很多工具可以用来缩小和捆绑:</em> </strong></p><ul class=""><li id="6bd2" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">缩小。</li><li id="9260" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">CSS迷你化器。</li><li id="c50f" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">缩小代码。</li><li id="dbc9" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">PostCSS。</li></ul><p id="1f3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，像<strong class="kt ir">web pack</strong>&amp;<strong class="kt ir">Parcel</strong>这样的构建工具带有内置的修改和代码分割功能。</p><h2 id="567e" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">正在本地加载自定义字体。</h2><p id="bd78" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">自定义字体是从文档的<strong class="kt ir"> &lt; head &gt; </strong>部分调用的，它们也是渲染阻塞资源。这个问题可以通过在本地添加它们来解决，而不是从谷歌CDN这样的内容交付网络中获取。</p><p id="b602" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谷歌字体为字体附带的所有字符集添加了<strong class="kt ir"> @font-face rules </strong>，比如<strong class="kt ir">拉丁文</strong>、<strong class="kt ir">西里尔文</strong>、<strong class="kt ir">中文</strong>等等。假设我们在<strong class="kt ir"> &lt;链接&gt; </strong>标签中添加的CSS fils包含了七种不同字符集的@font-face规则，我们只需要其中的一种(例如-Latin)。</p><p id="76bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果你在本地添加字体，你也可以缩小字体相关的CSS，并把它和你的CSS捆绑在一起。</p><p id="fcaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我们需要添加<strong class="kt ir"> Lato常规</strong>字体:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/379fbe81a6e1b20ac3710b575c87ebb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78VUB_UyPNfB4_9TH5QkVg.png"/></div></div></figure><p id="0cf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确保在本地加载字体时，现代浏览器的压缩字体格式，如<strong class="kt ir"> WOFF &amp; WOFF2。</strong></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="9a8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mb">要在您的web应用中找到渲染阻塞文件，您可以使用性能工具，如</em> <strong class="kt ir"> <em class="mb"> Lighthouse、web.dev、</em> </strong> <em class="mb">和</em> <strong class="kt ir"> <em class="mb"> GTmetrix。</em>T11】</strong></p></div></div>    
</body>
</html>