<html>
<head>
<title>Proto — a project manager made with Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">proto——用Next.js制作的项目管理器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/proto-a-project-manager-made-with-next-js-da2d82eeee37?source=collection_archive---------3-----------------------#2021-03-29">https://javascript.plainenglish.io/proto-a-project-manager-made-with-next-js-da2d82eeee37?source=collection_archive---------3-----------------------#2021-03-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8b00a7e8d65f3b4280e3463c884a5b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojHyC9I-5O3nWDZcInUNrA.png"/></div></div></figure><p id="a357" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">几年来，我一直在寻找完美的工具来管理我的项目。我用Trello跟踪我的任务，用ideas写笔记，用Milanote组织我的想法。这些奇妙的工具可以在很大程度上完成工作，并保持你的工作效率。</p><p id="8fdf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我在做一个个人项目时，我会创建笔记，并将参考资料存储在idea中，然后我会使用Trello来跟踪我的任务。自从2018年推出ideal以来，我一直在使用这个工作流程。但是从一个工具到另一个工具的方法增加了额外一层不必要的工作。我想要一个单一的工具来处理这些需求。你可以实现Trello的看板，但是我仍然不喜欢用观念来跟踪我的任务。</p><p id="f98d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近我爱上了米拉诺特。这是一个非常简洁的工具，它可以让你记下想法，并把它们转换成图片、待办事项、专栏等板块和节点。但这里并不都是天堂，Milanote并没有为上传到免费层的图片、链接和文件提供足够的配额。如果你想将它用于多个项目和需求，你必须购买付费订阅。如果你像我一样喜欢构建很多项目，你会喜欢Milanote，我建议你尝试一下。还有一些专门用来管理项目的工具，比如Plutio、ClickUp等。如果你和一个团队一起做一个专业项目，这些工具会创造奇迹。但是对于一个小的个人项目来说，它们是多余的。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/0cd3c47795744fd247163f52f1c5679b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PsQ3hrSExhehuk6nlF7JvQ.gif"/></div></div></figure><p id="49a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用真正需要的部分来管理个人项目的想法催生了<strong class="jx io"> Proto。我创建了Proto来管理我的小型个人项目。你可以看看<a class="ae ky" href="https://proto-lilac.vercel.app/" rel="noopener ugc nofollow" target="_blank">这里</a>或者点击<a class="ae ky" href="https://github.com/ayushman-git/project-manager" rel="noopener ugc nofollow" target="_blank">这里</a>进行GitHub回购。</strong></p><h1 id="05f2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">基础</h1><p id="ac56" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">原型的计划非常简单。创建一个工具，让你和谐地跟踪你的项目，不要在你的想法和执行之间增加额外的一层。要管理一个个人项目，你基本上需要三样东西——想法、故事和参考资料。对于Proto，我试图包含这三个元素。Proto有快捷方式(项目所必需的链接，如firebase console、azure、netlify等)，我可能会经常用到。一个scrum板，我可以在那里跟踪我的任务和一个参考网站列表。</p><p id="92e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我主要使用Vue。Js来创建我的前端项目。但是对于Proto，我想改变一下。最近我在探索NextJs &amp; Gatsby，发现它们非常有吸引力。所以我浏览了他们的文档，对他们的工作方式有了一个基本的了解。最后决定用<strong class="jx io"> NextJs </strong>做Proto。除了NextJs，我使用<strong class="jx io"> firebase认证</strong>进行用户认证，<strong class="jx io"> firebase firestore </strong>存储用户数据，<strong class="jx io"> SASS </strong>进行样式化，<strong class="jx io">js-cookie</strong>&amp;<strong class="jx io">nookies</strong>处理cookie，最后，<strong class="jx io"> react-spring </strong>在proto中喷洒样式。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/85dc133b2b6c66f7e4d13ce9e383ce28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqI10HxIDI72tgrXYH1WBg.png"/></div></div></figure><h1 id="8bbb" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">设计和布局</h1><p id="8e73" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated"><strong class="jx io"> Proto </strong>只有三页。首先是一个登陆页面，这是一个裸露的最小页面，让用户使用他们的谷歌或GitHub帐户登录/注册。我还没有花太多时间来设计登陆页面。就在这条路上。接下来的两个主要页面是主页和项目页面。</p><h2 id="f457" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">主页</h2><p id="88ad" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">这是用户登录后显示的页面。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/87f08f6617ba1927fdb34c2e752e741a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBkkorpDDiN5M1SeGuxiKg.jpeg"/></div></div></figure><p id="f910" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在这里从上到下。在最上面，是我们的导航条。它有一个标志，在右边的用户资料。在导航栏下面，有一个显示主项目细节的模块。这个想法是有一个主模块，它将显示用户当前正在进行的项目的细节。基于视觉层次，这个模块将是主导的一个，然后有小模块，包含不活动的项目或未来的项目。</p><p id="42df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显示活动项目的主模块根据显示在右侧的类型排列任务，在中间和左侧有一些统计数据，在项目名称下面有快捷方式和描述。我认为这些是用户可能需要的基本信息。</p><p id="d524" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在主模块下面，多个小模块包含关于用户当前不在工作的项目的信息。在这些模块中，我只显示了项目的名称和截止日期。</p><p id="fb13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于这个骨架，我创作了我的Figma设计。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/09c8a5e72819f7123de424423f25d86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBdl9InDXFRhMNrayet9Ew.png"/></div></div></figure><h2 id="f8e9" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">项目页面</h2><p id="0e9f" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">每当用户点击任何项目时，他/她将被重定向到项目页面。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/afc1274a3fd6e4b54d7c5e7e8f09cd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6r2eyf_AlwN8FADR7mxSOQ.jpeg"/></div></div></figure><p id="19db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">项目页面是<strong class="jx io"> Proto </strong>的面包和黄油。Navbar保持不变，只是左侧有一个后退按钮。在导航栏下面，主模块与主页上的主模块保持一致。我添加了一个按钮，让用户将这个项目标记为活动项目，还添加了一个圆圈，用户可以通过它来更改主题。</p><p id="534c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后是scrum板。scrum板的主要思想是将整个项目转换成故事。这个故事的例子可以是'<em class="ms">用户可以添加项目</em>'。现在，这个故事将有多个可以跟踪的任务。</p><p id="9ce2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以在scrum板里面，有四列— <strong class="jx io">故事，空闲，正在做和已经完成</strong>。最后三个将用于跟踪任务的进度。用户可以点击一个故事，在故事中创建一个任务。然后，任务可以在不同状态之间移动。</p><p id="278e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想在这一页上增加一个部分来处理参考文献。所以用户可以在这里添加网站作为参考。我还不能实现它，但我会很快添加它。</p><p id="4b16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，两个按钮会将项目标记为已完成或删除项目。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/18483a551b2d54709ab90081ecd71d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcrNi2ehxTS8ZXbt9eAdBw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">This is the Figma design I came up with for the project page.</figcaption></figure><h1 id="ae86" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">实施身份验证</h1><p id="3a8c" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">对于认证，我使用firebase auth。Firebase auth很容易设置。但是为NextJs设置身份验证有一点不同，因为NextJs是如何工作的。NextJs是用Node构建的。Js，这允许它执行服务器端呈现或静态站点生成。所以它既是服务器又是客户端。这个想法对我来说有点难以理解。</p><p id="d548" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论如何，这意味着你需要初始化<code class="fe mx my mz na b">firebase-SDK</code>以及firebase客户端。让我们看一下处理认证的三个文件。</p><h2 id="0bbb" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">firebaseClient.js</h2><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/98f302a0c8e3d1a93870e84885a2ace2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAyf0Sm04Ae7VW3wtaAWfQ.png"/></div></div></figure><p id="a094" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个文件是我初始化firebase客户端的地方。我们需要一个可以从firebase控制台提取的配置对象。在这个文件中，我们导出了一个函数，它首先检查firebase中是否有一个现有的应用程序，如果有，那么它什么也不做，否则它使用initializeApp函数初始化firebase客户端。这里我们不需要隐藏客户端的配置。<code class="fe mx my mz na b">FIREBASE_CONFIG</code>对象对用户的可见性不会改变任何事情。</p><h2 id="c146" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">firebaseAdmin.js</h2><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/d33c2dd10fa4adfad797da40e32dda4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ukg03Y1eZun5u9N_uyBHJQ.png"/></div></div></figure><p id="5483" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个文件中，我导出了<code class="fe mx my mz na b">verifyIdToken </code>函数。这个函数将一个令牌作为参数，然后它初始化firebase-SDK，以便我们可以使用服务器端函数。最后，它执行令牌验证来验证用户。</p><p id="93b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在将页面发送给用户之前，我们将在服务器端执行<code class="fe mx my mz na b">verifyIdToken </code>函数。</p><h2 id="e98d" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">认证. js</h2><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/41b7a1ed94c0e4f58c11943ec2dde699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Nd0LzVdcxSLmthXyOavkQ.png"/></div></div></figure><p id="e2fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在auth.js中，在useEffect钩子内部，它将在挂载时执行回调函数。我正在执行<code class="fe mx my mz na b">onIdTokenChanged </code>函数，每次令牌改变时都会执行这个函数。所以每次用户登录或注销时。onIdTokenChanged函数在其回调函数中传递参数用户的信息。因此，如果用户登录，它将包含有关用户的信息，如果用户没有登录，它将为空。</p><p id="1607" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果没有用户，它将删除存储令牌和用户信息的cookie，并将<code class="fe mx my mz na b">user </code>的状态更改为null。但是如果有一个用户，它会用用户的信息设置变量<code class="fe mx my mz na b">user </code>的状态，并设置关于用户信息的cookies。</p><p id="aa1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个函数导出两个东西——一个是值为user的上下文提供者，另一个是使用该上下文的<code class="fe mx my mz na b">userAuth </code>钩子。</p><h2 id="0a0e" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">通过提供商登录</h2><p id="8b20" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">我让用户使用他们的谷歌和GitHub帐户登录/注册。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/2594712d93e39e6d19e4345bcba9fd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnJyulrhKryaHwR8aJ6HJA.png"/></div></div></figure><p id="86b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了实现这一点，我正在使用firebase auth函数创建提供者。然后我将这个提供者作为参数传递给<code class="fe mx my mz na b">signInWithPopup </code>函数。</p><h1 id="0804" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">项目结构</h1><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9267f9cc749e548a2f8483f3b3545470.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*4QHGew9V1-O7iPbRMkPpnA.png"/></div></figure><p id="14d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在组织原型结构时，我试图遵循DRY原则。<strong class="jx io"> assets </strong>文件夹包含导出主题细节的theme.js文件。<strong class="jx io"> auth </strong>文件夹有三个文件— auth.js、firebaseAdmin.js和firebaseClient.js，这三个文件是身份验证所必需的。然后有一个<strong class="jx io"> components </strong>文件夹，其中包含proto中使用的所有组件。<strong class="jx io">钩子</strong>和<strong class="jx io">钩子</strong>用于区分逻辑和组件。页面文件夹负责路由和决定显示哪个页面。<strong class="jx io"> sass </strong>文件夹包含项目的全局样式。</p><h2 id="d625" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">受保护的页面</h2><p id="6a3c" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">让我们看看主页。主页受到保护，因此只有已登录的用户才能访问它。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/98d7dc34d08a8ce10aeca0971fb3792c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfdZXPmAuRYLdQ_URTK33A.png"/></div></div></figure><p id="b399" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Next.js提供了一个<code class="fe mx my mz na b">getServerSideProps </code>函数。它将使用由<code class="fe mx my mz na b">getServerSideProps</code>返回的数据在每个请求上预先呈现这个页面。所以在这个函数中，我们可以检查用户是否可以访问这个页面。这里我访问的是用户第一次登录时存储的cookie。然后我使用从<code class="fe mx my mz na b">firebaseAdmin.js</code> <strong class="jx io"> </strong>导出的<code class="fe mx my mz na b">verifyIdToken </code>函数来检查令牌的有效性。如果它是合法的，它会把用户的信息作为道具转发给我们的客户。但是如果有错误，它会将其重定向到登录页面('/')。</p><p id="0d54" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在客户端，我从firestore获取用户的项目并显示给用户。</p><h1 id="6416" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">造型和动画</h1><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/2d7e343cd1af2d7f378fb20a43a88bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JkVHWp7vkPSh_me3aufZ-g.gif"/></div></div></figure><p id="c9a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于基本的造型，我用SASS。SASS是一个CSS预处理器，这意味着它拥有CSS所拥有的一切，甚至更多。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/545a88c6a78550c792668f1da5ccaf4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*9_C4iTPaEZ4Ytau-4c9fmw.png"/></div></figure><p id="306d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，我有四个sass文件。第一个处理字体——比如改变字体大小、字体系列等。<code class="fe mx my mz na b">_globals.scss</code>处理全局需要的东西——比如改变默认输入、文本区域样式等。<code class="fe mx my mz na b">_vars.scss</code>有变量，可能在很多地方都需要。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/ce17e51e025e7d08027ca186f9a93663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouijdb2hBpKyKZ7LYzaMYw.png"/></div></div></figure><p id="c68d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后是包含所有其他scss文件的<code class="fe mx my mz na b">main.scss</code>文件。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/91b068954b96b106116eb4d6bdb8c1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PW0mFkfIn-yWki5Pku6ncg.png"/></div></div></figure><p id="f975" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于单个组件，我使用的是scss模块，它是开箱即用的。让我们来看看我们的一个组件。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/b39d01f98413f3393914e22c41ea15d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHidu0wQ6qwl41s4ilkNpw.png"/></div></div></figure><p id="1674" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我从<strong class="jx io"> EmptyScreen </strong> scss模块导入样式。然后使用语法<code class="fe mx my mz na b">{styles.&lt;class name&gt;} </code>将其作为类名应用。这将为该类创建一个随机名称，使得它只能被导入到其中的组件访问。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/2049ac7eee46f7047777c7f53bc9487e.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*rG-X7n5-zS3E2pOC68cFBQ.png"/></div></figure><h2 id="ba38" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">反作用弹簧</h2><p id="6971" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">让我们让proto好看。为了添加过渡和动画，我使用了<strong class="jx io">反应弹簧</strong>。这是一个动画库，其操作与典型的动画库略有不同。大多数动画库从A点过渡到B点，有一些曲线在固定的持续时间上。改变曲线决定了动画的流动。但是你不必担心react-spring中的持续时间或曲线。你只需要修改数值，它会根据真实物理计算出持续时间和曲线。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ce95687d93af79a1ae4f0aeec2ea2752.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/1*UaiztkX2asBvPv-K6oau_A.gif"/></div></figure><p id="ee78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你也可以通过改变配置来改变感觉，修改质量，张力，摩擦力等等。更多信息请查阅他们的<a class="ae ky" href="https://www.react-spring.io/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="9e6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看<strong class="jx io"> SecondaryCard </strong>组件，看看react-spring是如何工作的。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/34f6102af9be341a7989a5d0579be74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3QSuH9L4tlEQwM08kDjK9Q.png"/></div></div></figure><p id="8a75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们正在从<code class="fe mx my mz na b">react-spring</code>进口<code class="fe mx my mz na b">useSpring </code>和<code class="fe mx my mz na b">animated </code>。之后，我们创建一个常量<code class="fe mx my mz na b">onMountTransition </code>，它使用了useSpring函数。在useSpring函数内部，我们传递一个对象来确定要转换哪些属性。在该对象中，我们通过添加一个包含初始值的对象的键来定义属性的初始值。在这个对象之外，我们可以确定最终值。</p><p id="43f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们需要使用<code class="fe mx my mz na b">animated </code>前缀将我们想要制作动画的HTML元素转换成一个特殊的react-spring元素。所以在上面的代码中，我用<code class="fe mx my mz na b">&lt;animated.div&gt;</code>转换<code class="fe mx my mz na b">&lt;div&gt;</code>，然后在样式属性中传递<code class="fe mx my mz na b">onMountTransition </code>常量。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/5730fb13e1c2f312e24aaefea5f27b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tUxElE2llWN0EibWvk4Z9A.gif"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Changing scale and opacity</figcaption></figure><h2 id="4173" class="md la in bd lb me mf dn lf mg mh dp lj kg mi mj ln kk mk ml lr ko mm mn lv mo bi translated">添加悬停效果</h2><p id="e2d4" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">我们可以将整个动画封装在一个HOC中，并将该动画添加到其子动画中。这样我们就不用一遍又一遍的创作同一个动画了。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/8069f95cef663b153cea27bce4f4fc36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAjiwJUMJqLO0WYAiKYwbw.png"/></div></div></figure><p id="b6b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个HOC中，我们用另一个<code class="fe mx my mz na b">div</code>封装子组件。这个div是特殊的spring div，因为我们添加了前缀<code class="fe mx my mz na b">animated </code>。</p><p id="1620" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与上次不同，我们用两个值来析构useSpring函数——元素是动画本身，而<code class="fe mx my mz na b">setElement </code>函数用来修改元素的动画，就像useState钩子一样。在useSpring函数中，我像上次一样传递对象来设置动画属性的初始值和结束值。但是这一次我们用函数<code class="fe mx my mz na b">hoverHandler</code>在动画div上添加了<code class="fe mx my mz na b">onMouseEnter </code>和<code class="fe mx my mz na b">onMouseLeave </code>事件。这个函数是用<code class="fe mx my mz na b">setElement </code>函数改变元素的值。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/334faca9fe7551ddb3e7db74adcceb5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/1*i3qNluL75v4hDOBh-o6m3A.gif"/></div></figure><p id="fc9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以每当用户悬停在卡片上时，元素的Y位置将被更改为-3px，从而使其向上移动。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/589bcbb9146d4fc6f97505b114dcf4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_VAU542miLVXXOvtiLFL9Q.gif"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">You can also make something cool like this using react-spring.</figcaption></figure><h1 id="3090" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">部署</h1><p id="a0a7" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">我在维塞尔部署了proto。整个部署过程非常简单。<code class="fe mx my mz na b">Go to vercel.com &gt; login &gt; create a new project &gt; link GitHub &gt; attach the repo &gt; finally add the environment variables in the settings.</code></p><p id="cb74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Vercel还提供了多个URL，一个是您的主URL，其他的可以用于测试新的提交，然后才允许它们访问主URL。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b00ba571bc393aea8e0cb4fdbf4c1c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/1*wGnBz9_2mU_BljHQd_rJ3Q.gif"/></div></figure><h1 id="ba41" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="f10d" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">Proto是我创造完美项目经理的尝试。这是一个有点雄心勃勃的项目，远远不是一个可供消费者使用的成品。我只实现了最初设想的20%。但是这20%让我学到了很多我从来不知道的东西。这个项目让我走出了自己的舒适区，尝试了一些我通常试图远离的事情。</p><p id="d78b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我以前主要使用Vue.js，所以我对React scene还很陌生。但是我每天都在发现关于react的新东西。这个项目帮助我从我的vue心态转变到反应。</p><p id="e822" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个项目也不是一次性的努力，我会回来改进这个项目，增加新的功能和实现新的技术，我会在途中学习。</p></div></div>    
</body>
</html>