<html>
<head>
<title>Why the Prettier Code Formatter is a Big Deal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么漂亮的代码格式化程序很重要</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-the-prettier-code-formatter-is-a-big-deal-6c038ad75ae8?source=collection_archive---------7-----------------------#2021-07-07">https://javascript.plainenglish.io/why-the-prettier-code-formatter-is-a-big-deal-6c038ad75ae8?source=collection_archive---------7-----------------------#2021-07-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/47f15a699499572350ce7f1d40fe9acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zZU3cptbCWb-CnG7"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Possessed Photography</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b394" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更漂亮是一件大事(任何其他健壮的代码格式化程序都是如此)。本文将展示为什么它如此重要，以及如何将它引入现有的代码库。</p><p id="16cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你以前从未听说过自动代码格式化器——这些工具解析你的代码，将其转换成<a class="ae jz" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> AST </a>，然后以一种很好的方式“重新打印”它。这个过程的主要目的是确保你的代码库中的所有代码都遵循相同的风格<a class="ae jz" href="https://standardjs.com/rules.html" rel="noopener ugc nofollow" target="_blank">规则</a>。</p><p id="9c8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，无论您使用多少引号来定义string，或者是否在每一行的末尾使用分号，代码格式化程序对代码的外观都有自己的看法。</p><p id="26c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">乍一看，这似乎是一个缺点——作为代码的作者，您更清楚在哪里放置额外的换行符来强调某些代码段是相关的，或者何时应该在一行中定义一个箭头函数(即使它有300个符号长)。</p><p id="61af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，问题是每个人对代码应该是什么样子都有自己的看法，有时很难从代码样式的角度找到共同点。</p><p id="056d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，当你发送一个拉取请求进行评审时，你的队友留下了一百个挑剔的代码风格的注释，据他所知，这些注释必须被处理(因为否则，代码将是不可读的和“丑陋的”，对吗？)—你在添加分号、在方法之间换行符等等的时候，白白地浪费了时间。</p><p id="f5e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们正面临着2021年，我仍然看到C程序员们没完没了地浏览庞大的专有“C代码样式文档”,试图找到/学习大量的样式规则。当然，这些规则的主要部分与选项卡中空格的数量无关。尽管如此，我花了更多的时间来处理大量的“删除这一行”，“在这里多加一个空格”的评论，这是我不愿意承认的。</p><p id="559f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我曾经是Clearcase中一个巨大(10M LOC)机顶盒项目的C开发人员。我们必须遵循庞大且定义良好的编码标准。主要的问题是我们没有自动执行规则的工具，所以“浏览文档”是我们开发和代码审查过程中不可或缺的一部分。如果我们有一个工具可以自动执行所有这些规则，我们会受益匪浅，但不幸的是，当时没有这样的工具。</p><p id="f0bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，酷孩子不想花时间去学习代码风格的文档(尤其是写它们)，所以现在我们有了工具(比如更漂亮的),可以把代码风格从我们肩上卸下来，让我们专注于更有意义的事情。因此，让我们来看看为什么自动代码格式化是一件好事，以及它到底能为您带来什么。</p><h2 id="059d" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">1.代码风格一致性</h2><p id="2016" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如果我要编制一份清单，列出对代码库质量有重大影响的事情，其中之一就是<strong class="kc io">一致性</strong>。</p><p id="52df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你曾经同时处理过多个包含不同代码风格的项目吗？我敢打赌，你有，你知道这是多么令人沮丧，不得不适应不同的规则和模式，每次你需要做出改变。一致性使代码更容易阅读和使用。</p><p id="43e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从我的经验来看，我知道无论你如何努力，如果没有自动化，你都不太可能拥有代码风格一致的代码库。我见过很多次这样的尝试，结果总是一样的——不一致的更改不可避免地潜入并蔓延到整个代码库。</p><p id="1f85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">真正获得代码风格一致性的唯一可行方法是，每次进行更改时，让一个健壮的代码格式化程序重新设计代码的风格。这样做可以确保代码库的每一行都遵循与所有其他行相同的样式规则。</p><h2 id="07be" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak"> 2。真相的单一来源</strong></h2><p id="e7d7" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">有一次，我和我的一个同事陷入了非常尴尬的境地。我对他的拉请求进行了代码审查，发现了下面两行代码:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="17fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个的长度是<strong class="kc io"> 205个字符，</strong>第二个是<strong class="kc io"> 304 </strong>。我无法相信这两行代码已经通过了代码审查——为什么有人会写一行占据了电脑屏幕三倍宽度的代码呢？弄清楚这段代码完成了什么是非常复杂的。而且，代码行越长，bug越容易潜入，不是吗？所以我的反应是显而易见的——我建议拆分代码行，使代码更具可读性。原来，这两行的作者对此事有完全不同的看法——我们就这个话题进行了相当激烈的讨论，他认为他故意将这两行做得很大，以隐藏初始化逻辑。嗯，这听起来确实有点道理，但是这些行有另一个问题，一旦我们格式化它们，这个问题就变得非常明显。下面是完全相同的代码，但是通过更漂亮的格式:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9b33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">差别是巨大的。当您阅读这样格式的代码时，很明显它很麻烦并且不是最佳的。它一遍又一遍地读取<code class="fe mc md me mf b">start_time</code>变量(虽然它可以被读取一次并存储到一个变量中)，它不必要地创建了<code class="fe mc md me mf b">moment</code>的新实例，最后，它重复自己。在这种情况下，代码格式化不仅使代码可读性更好，还“突出”了缺陷。</p><p id="6f0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我必须承认——进行这样的讨论并不是最愉快的事情。我们都是专业人士，大多数人都热爱我们的工作。我们对自己编写的代码有情感上的依赖，正因为如此，我们变得有偏见。有时，人们有如此不同的观点/大量的经验/背景，以至于几乎不可能找到共同点。除此之外，代码风格是一个品味的问题(至少在某种程度上)，并不总是可行的，例如空格与制表符、一个制表符中两个与四个空格、一个类中方法之间一个与两个新行等等。此外，即使您提出了一个定义良好且全面的代码风格标准，您将如何始终如一地实施它呢？</p><p id="061c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是自动代码格式化的优势所在——无论如何，您总能获得一致的格式化代码库。当然，这也结束了关于造型的永恒争论。每一个代码风格的决定都取决于一台无情的计算机，它能完美地完成自己的工作，最重要的是，始终如一，坚定不移。</p><h2 id="8b2a" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">3.没有语法错误</h2><p id="9820" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">代码格式化程序在执行它的魔法之前读取你的代码(将它转换成<a class="ae jz" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> AST </a>)。如果在这一步遇到了语法错误，这个过程就会失败，您会得到通知。因此，如果你的代码格式被<code class="fe mc md me mf b">pre-push</code> git hook的<code class="fe mc md me mf b">pre-commit</code>触发，你将根本无法推送该代码(这很好，因为你肯定不想成为破坏你的应用构建的人)。</p><h1 id="e8ed" class="mg kz in bd la mh mi mj ld mk ml mm lg mn mo mp lj mq mr ms lm mt mu mv lp mw bi translated">采纳策略</h1><p id="bbf2" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如果您决定将自动代码格式化合并到您的开发过程中，有几种方法可以实现。</p><h2 id="c2aa" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">1.“大爆炸”方法</h2><p id="72e0" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">最简单的方法是立刻重新格式化整个代码库。这些步骤如下:</p><ul class=""><li id="cd73" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">装漂亮点(<code class="fe mc md me mf b">npm install --save-dev --save-exact prettier</code>)</li><li id="5a34" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">配置更漂亮(通过<code class="fe mc md me mf b">.prerttierrc</code>文件或<code class="fe mc md me mf b">package.json</code>文件中的配置)</li><li id="4df1" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">添加<code class="fe mc md me mf b">format</code>命令到你的<code class="fe mc md me mf b">package.json</code> : <code class="fe mc md me mf b">"format": "prettier --write \"src/**/**.ts\" \"test/**/*.ts\" "</code></li><li id="60c3" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">运行<code class="fe mc md me mf b">npm run format</code></li><li id="d4ff" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">按照此处<a class="ae jz" href="https://prettier.io/docs/en/precommit.html" rel="noopener ugc nofollow" target="_blank">所述</a>安装<code class="fe mc md me mf b">pre-commit</code>(以便所有暂存文件在提交前格式化)</li></ul><p id="10f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">瞧——整个代码库将立刻被重新格式化。</p><p id="9fa7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的缺点显而易见:</p><ul class=""><li id="e50f" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">代码库的大部分行将显示为由您创作(我怀疑这可能是处于维护阶段的企业级项目的一个问题)</li><li id="09ec" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">您的同事在重新格式化后拉动主分支时可能会面临挑战(尽管他们可以执行上述相同的步骤来保留他们的增量并避免合并冲突)</li><li id="bbb8" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">可能很难让您的经理相信您的拉取请求(包含数百个重新格式化的文件)不会带来任何问题。</li></ul><p id="1a12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的职业生涯中，我已经在不同规模的项目(从10K到100K LOC)中执行了四次这种方法。四次都相对顺利——我不得不花一些时间说服我的同行，但在合并了更漂亮之后，每个人都很高兴。</p><h2 id="c3b8" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">2.逐文件重新格式化</h2><p id="aaa1" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如果你不能采用“一次全部”的方法，你可以尝试在一个文件接一个文件的基础上重新格式化你的代码库。除了执行<code class="fe mc md me mf b">format</code>命令之外，这些步骤与前面的方法相同。工作流程如下:做出更改，提交它们，让<code class="fe mc md me mf b">pre-commit</code> hook重新格式化所有暂存文件。</p><p id="4e6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管这种方法可能会导致很长的迁移过程，但它有一些优点:</p><ul class=""><li id="24b6" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">这种方法有助于避免回顾方法1带来的大量公关</li><li id="c688" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">如果您不完全信任Prettier，您将有机会在代码审查过程中审查它所做的每一个更改</li></ul><h2 id="c238" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">3.仅格式化更改的行</h2><p id="d8d4" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如果上述两种方法不适合您的用例，如果您不能承受git历史的污染，或者如果您正在寻找破坏性最小的迁移方式，您可以考虑设置一个<code class="fe mc md me mf b">pre-commit</code>挂钩，只格式化更改的代码行。这可以通过设置<a class="ae jz" href="https://github.com/nrwl/precise-commits" rel="noopener ugc nofollow" target="_blank">精确提交</a>来完成，它使用了Prettier的<a class="ae jz" href="https://prettier.io/docs/en/options.html#range" rel="noopener ugc nofollow" target="_blank">范围</a>选项。</p><p id="d17d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的优点如下:</p><ul class=""><li id="6915" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">它避免了git历史的污染(因为只有改变的LOC被格式化)</li><li id="245f" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">它避免了“一次性”方法带来的大量初始公关</li></ul><p id="a2c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">缺点是显而易见的——漫长的迁移过程以及“新格式”和“旧”代码之间的不一致。然而，如果您正在处理企业代码库(或monorepo ),这种方法是完美的，因为git历史很重要。</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="e481" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您阅读这篇文章。欢迎在评论中分享你的想法，祝你编码愉快！</p><p id="5905" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ns">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ns">plain English . io</em></strong></a></p></div></div>    
</body>
</html>