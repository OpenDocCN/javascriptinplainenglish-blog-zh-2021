<html>
<head>
<title>How to Use Type Guards in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在TypeScript中使用类型保护</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-type-guarding-in-typescript-b3bbcd471970?source=collection_archive---------15-----------------------#2021-01-08">https://javascript.plainenglish.io/how-to-use-type-guarding-in-typescript-b3bbcd471970?source=collection_archive---------15-----------------------#2021-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a1b6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">不同的类型保护方式及其工作原理，并附有向导示例。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/631f384640d719756292487553f93620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RscPF2uolclUzU5PO5PwQw.jpeg"/></div></div></figure><p id="3f1a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript规则，我花了几个小时将各种JS(X)文件转换成TS(X)。一路走来，我遇到了不少令人头疼的问题。我最近遇到的一个问题是必须使用<strong class="kq io">类型保护</strong>，它用来“保护”某个代码块不使用错误的类型。这是一个相对简单的概念，但我想我会通过一些常见类型的守卫…使用向导的例子！</p><p id="7866" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设你有一个由冒险者组成的乌合之众团队，他们的任务是摧毁一个古老而邪恶的戒指，所有人的命运都悬而未决。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="b922" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些类中的每一个都继承自一个公共的<code class="fe lm ln lo lp b">Adventurer</code>类，具有像<code class="fe lm ln lo lp b">name</code>、<code class="fe lm ln lo lp b">health</code>等基本属性。，并在其构造函数中接受一个<code class="fe lm ln lo lp b">name</code>参数。此外，每个冒险者都有自己独特的技能和能力，例如<code class="fe lm ln lo lp b">Wizard</code>可以<code class="fe lm ln lo lp b">castSpell</code>而精灵可以<code class="fe lm ln lo lp b">fireArrow</code>。</p><p id="af0a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在他们冒险的一个特别痛苦的阶段，<code class="fe lm ln lo lp b">Wizard</code>必须使用他们神奇的法术能力来抵挡大坏蛋巴洛克，所以我们很自然地找到了拥有<code class="fe lm ln lo lp b">castSpell</code>能力的冒险者:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="20c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lq"> TypeScript编译器错误</em> </strong></p><p id="67d1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">是的，我们得到的TS错误看起来像这样:</p><pre class="kd ke kf kg gt lr lp ls lt aw lu bi"><span id="2591" class="lv lw in lp b gy lx ly l lz ma">Property 'castSpell' does not exist on type 'Hobbit | Human | Dwarf | Wizard | Elf'.</span></pre><p id="060e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">什么给出了打字稿？嗯，当我们最初创建我们的<code class="fe lm ln lo lp b">fellowship</code>数组时，TS看到数组中有5种不同类型的<code class="fe lm ln lo lp b">Adventurer</code>，因此将数组类型化为包含霍比特人、人类、矮人、巫师、<em class="lq">或</em>精灵的<em class="lq">联合</em>数组类型。我们也可以在创建数组时显式设置类型:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="af59" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用TypeScript，我们不能使用类似于<code class="fe lm ln lo lp b">adventurer.castSpell</code>的属性访问器，除非<em class="lq">类型的<em class="lq">联合</em>的所有</em>成员都具有该属性。可恶。我们的友谊开局不利。</p><p id="37ba" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了绕过这一点，我们需要一个<strong class="kq io">型的防护罩。类型保护</strong>“保护”代码块免受不需要的类型的影响。和所有事情一样，有几种方法可以使用类型保护。</p><h2 id="32ca" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">选项1 —类型断言</h2><p id="b014" class="pw-post-body-paragraph ko kp in kq b kr ms jo kt ku mt jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">类型断言类似于其他语言中的“强制转换”。它们是我们告诉TS编译器我们知道的比它多，并“断言”给定实体是某种类型的一种方式。此外，类型断言不做任何额外的工作，只是假设您已经做了功课，并且断言的类型是正确的。因此，类型断言是TS不能完全解决的用例的一种逃生出口。总之，<em class="lq">明智地使用它们</em>。</p><p id="8058" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有两种语法可以用于类型断言，即<code class="fe lm ln lo lp b">as</code>语法和“尖括号”语法。对于我们的向导示例，它们看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="3f10" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lm ln lo lp b">as</code>语法更加直观(imo)，如果你使用最新的<code class="fe lm ln lo lp b">@typescript-eslint</code>，如果你使用尖括号，它甚至会对你大喊大叫。无论如何，回想我们的“明智使用”警告，我们需要绝对<em class="lq">确定</em>这是一个没有TS帮助的巫师。因为我们的<code class="fe lm ln lo lp b">Wizard</code>职业是唯一一个使用<code class="fe lm ln lo lp b">castSpell</code>方法的<em class="lq">职业，我们可以放心，我们抓到了正确的冒险者。</em></p><p id="0a5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，即使添加了断言，如果我们去施展我们的咒语:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="04e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们又遇到了一个打字错误！这是因为我们只将参数<code class="fe lm ln lo lp b">adventurer</code>断言为<code class="fe lm ln lo lp b">Wizard</code>，但是TypeScript无法推断出这意味着<code class="fe lm ln lo lp b">find</code>的返回值必须是<code class="fe lm ln lo lp b">Wizard</code>。在得到我们想要的东西之前，我们必须在返回值上添加一个断言:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="5cef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在实践中，使用类型断言通常不是最好的选择，而且通常有更好的方法来解决这个众所周知的难题。</p><h2 id="7508" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">选项2 —类型谓词函数</h2><p id="ff41" class="pw-post-body-paragraph ko kp in kq b kr ms jo kt ku mt jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">对于向导的担心，另一个可能更可取的解决方案是定义一个返回<strong class="kq io">类型谓词</strong>的函数:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="e80a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里的返回类型是<strong class="kq io">类型谓词</strong>，形式为<code class="fe lm ln lo lp b">parameterName</code> <code class="fe lm ln lo lp b">is</code> <code class="fe lm ln lo lp b">Type</code>。快速查字典告诉我们(是的，我查了字典)，在这个上下文中，谓词被定义为“逻辑中一个命题的主语所肯定或否定的东西”，这是有道理的。我们正在编写一个函数来确认或否认这实际上是一个向导。该函数接受一个<em class="lq">宽的</em>联合类型，在本例中为<code class="fe lm ln lo lp b">Adventurer</code>，而<em class="lq">将</em>缩小为<code class="fe lm ln lo lp b">Wizard</code>(从<code class="fe lm ln lo lp b">Adventurer</code>继承而来)。注意，我们在这里也使用了类型断言。在这种情况下，区别在于我们实际上定义了一个函数，它说“如果它有一个<code class="fe lm ln lo lp b">castSpell</code>属性，它<em class="lq">必须是一个<code class="fe lm ln lo lp b">Wizard</code>，否则它不是没有<code class="fe lm ln lo lp b">Wizard</code>”</em></p><p id="5f13" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，有了我们闪亮的新型防护功能:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="d4bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，一线希望照耀着我们的友谊！</p><p id="c467" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们的<code class="fe lm ln lo lp b">fellowship</code>中有不止一个<code class="fe lm ln lo lp b">Wizard</code>，并且我们想让他们一起对付邪恶的巴洛克，我们可以<code class="fe lm ln lo lp b">filter</code>使用我们新的类型守卫的联合类型数组，给我们一个类型为<code class="fe lm ln lo lp b">Wizard[]</code>的数组。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="70ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个很好的向导！</p><h2 id="87cd" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">选项3 —输入运算符</h2><p id="f4fc" class="pw-post-body-paragraph ko kp in kq b kr ms jo kt ku mt jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">我们可以使用的另一个选项是<code class="fe lm ln lo lp b">in</code>操作符，看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="e45b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在JavaScript中，如果属性存在于对象<em class="lq">或对象的原型链</em>中，则<code class="fe lm ln lo lp b">in</code>操作符返回<code class="fe lm ln lo lp b">true</code>。使用<code class="fe lm ln lo lp b">in</code>操作符，TypeScript将把并集缩小到只有具有给定属性的类型，即<code class="fe lm ln lo lp b">Wizard</code>。此外，如果你添加了一个<code class="fe lm ln lo lp b">else</code>块，TS知道既然<code class="fe lm ln lo lp b">if</code>块必须是一个<code class="fe lm ln lo lp b">Wizard</code>，那么<code class="fe lm ln lo lp b">else</code>块必须是其余块的并集。</p><p id="7720" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="d6c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们所看到的，与使用属性访问器(<code class="fe lm ln lo lp b">wizard.castSpell</code>)不同，TypeScript <em class="lq">允许使用<code class="fe lm ln lo lp b">in</code>操作符来测试属性的存在性，即使联合的所有成员都没有该属性。所以如果你需要测试一个对象的属性，使用<code class="fe lm ln lo lp b">in</code>操作符！</em></p><h2 id="c27d" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">选项4 — <code class="fe lm ln lo lp b">instanceof</code></h2><p id="f6c8" class="pw-post-body-paragraph ko kp in kq b kr ms jo kt ku mt jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">我们还可以使用另一种技术来保护我们无畏的巫师，那就是使用<code class="fe lm ln lo lp b">instanceof</code>。现在，每个人都知道巫师不是唯一拥有施法能力的神话生物，精灵也经常拥有异想天开的力量。假设我们的<code class="fe lm ln lo lp b">Elf</code>类也有一个<code class="fe lm ln lo lp b">castSpell</code>属性。既然两个生物现在可以<code class="fe lm ln lo lp b">castSpell</code>，或者说<code class="fe lm ln lo lp b">if</code> / <code class="fe lm ln lo lp b">else</code>挡住现在的样子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="c43d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是不行的！因为这两个实体现在都有了<code class="fe lm ln lo lp b">castSpell</code>能力，我们得到了<code class="fe lm ln lo lp b">Elf</code>或者<code class="fe lm ln lo lp b">Wizard</code>的联盟，但是只有<code class="fe lm ln lo lp b">Wizard</code>足够强大来阻止可怕的巴洛克。</p><p id="9b99" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">进来的是<code class="fe lm ln lo lp b">instanceof</code>操作符。<code class="fe lm ln lo lp b">instanceof</code>操作符非常简单明了；它确定该对象是否是该类的的实例<em class="lq">。此外，它检查它是否出现在原型链中的任何地方。</em></p><p id="d291" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就像前面的选项一样，使用<code class="fe lm ln lo lp b">instanceof</code>操作符<em class="lq">将<code class="fe lm ln lo lp b">if</code>块中的联合类型缩小到<code class="fe lm ln lo lp b">Wizard</code>:</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="2f67" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">万岁。所以，很简单，我们需要做的就是这个:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h2 id="9c86" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">选项5-ish — <code class="fe lm ln lo lp b">typeof</code></h2><p id="be3a" class="pw-post-body-paragraph ko kp in kq b kr ms jo kt ku mt jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">我说这是第五种选择，因为它并不完全适用于我们的情况，但是如果我没有提到它，那就是我的失职。也可以使用<code class="fe lm ln lo lp b">typeof</code>来缩小联合的类型。这更适用于处理字符串或数字等原语的情况:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h1 id="1d8a" class="my lw in bd mb mz na nb me nc nd ne mh jt nf ju mk jw ng jx mn jz nh ka mq ni bi translated">“真实世界”示例</h1><p id="e358" class="pw-post-body-paragraph ko kp in kq b kr ms jo kt ku mt jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">巫师、领主和指环都很棒，但是你更可能在野外看到的例子呢？这是我最近遇到的一个(不太有趣的)问题，它让我陷入了这种特殊类型的守兔洞:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="9a91" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于<code class="fe lm ln lo lp b">url.searchParams.get</code>的返回类型是<code class="fe lm ln lo lp b">string | null</code>，所以我不能把它赋给<code class="fe lm ln lo lp b">media</code>，它的类型是<code class="fe lm ln lo lp b">'svg' | 'video' | 'image' | 'all'</code>。我们需要确认用户传递的查询参数是(1)一个<code class="fe lm ln lo lp b">string</code>类型而不是<code class="fe lm ln lo lp b">null</code>,( 2)将其类型缩小到<code class="fe lm ln lo lp b">Media</code>。我们可以使用上面概述的任意数量的策略来实现这一点——我选择编写一个快速类型谓词函数:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="6ae1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们只需在分配<code class="fe lm ln lo lp b">mediaParam</code>之前添加一个检查:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h1 id="a10a" class="my lw in bd mb mz na nb me nc nd ne mh jt nf ju mk jw ng jx mn jz nh ka mq ni bi translated">摘要</h1><p id="1849" class="pw-post-body-paragraph ko kp in kq b kr ms jo kt ku mt jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">好吧。下面是我们检查过的保护向导类型的一些选项的快速运行:</p><h2 id="2686" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">类型断言</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h2 id="b5c0" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated">类型谓词函数</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h2 id="e416" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated"><code class="fe lm ln lo lp b">in</code>操作员</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h2 id="bdf9" class="lv lw in bd mb mc md dn me mf mg dp mh kx mi mj mk lb ml mm mn lf mo mp mq mr bi translated"><code class="fe lm ln lo lp b">instanceof</code>操作员</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="808d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">基于简单和准确，使用<code class="fe lm ln lo lp b">instanceof</code>可能是我们帮助<code class="fe lm ln lo lp b">fellowship</code>逃离巴洛克魔爪的最佳选择。当然，不同类型防护装置的使用将取决于问题和环境！</p><p id="aa15" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢你们的阅读，希望你们学到了一些东西！</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="a205" class="my lw in bd mb mz nq nb me nc nr ne mh jt ns ju mk jw nt jx mn jz nu ka mq ni bi translated">资源</h1><ul class=""><li id="9f3b" class="nv nw in kq b kr ms ku mt kx nx lb ny lf nz lj oa ob oc od bi translated"><a class="ae mx" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/advanced-types . html</a></li><li id="cfc9" class="nv nw in kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><a class="ae mx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/instance of</a></li><li id="f589" class="nv nw in kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated"><a class="ae mx" href="https://lotr.fandom.com/wiki/Main_Page" rel="noopener ugc nofollow" target="_blank">https://lotr.fandom.com/wiki/Main_Page</a></li></ul></div></div>    
</body>
</html>