<html>
<head>
<title>How to Retrieve All Data via Paginated API Calls in Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在普通JavaScript中通过分页API调用检索所有数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/this-is-how-you-can-retrieve-all-data-via-paginated-api-calls-in-vanilla-javascript-a8258e208ea0?source=collection_archive---------3-----------------------#2021-10-27">https://javascript.plainenglish.io/this-is-how-you-can-retrieve-all-data-via-paginated-api-calls-in-vanilla-javascript-a8258e208ea0?source=collection_archive---------3-----------------------#2021-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7b55" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">没有插件。两种方法—1 .递归&amp; 2。聚合数据块的迭代。</h2></div><p id="73f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几个月前，当我在构建一个实时网络应用程序来监控🚌公交车到达时间，主要要求之一是<strong class="kh ir">在第一次加载时将所有公交车站渲染到底图上</strong>:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d4e72919fd026752a0152266b664c637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9FlrAl-B-rRvvFU61YlGQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Screenshot by Author | An image of rendered Bus Stops on the <a class="ae lr" href="https://sg-transportation.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">web application</a> | Data was retrieved via a paginated API from transport provider</figcaption></figure><blockquote class="ls"><p id="87ea" class="lt lu iq bd lv lw lx ly lz ma mb la dk translated">总共有5，098个公交车站，交通数据API每页最多返回500个条目。</p></blockquote><p id="3e77" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">为了在第一次加载时呈现所有的公交车站，有必要首先在Node.js后端服务器上聚集所有分页的数据块。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mh"><img src="../Images/c28f5e0b5a96d698c4931cb3a98c103a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXXCFTtXnYNV_smUPmEing.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Illustration by Author | A diagram which represents the above API pagination format and offset</figcaption></figure><p id="f332" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然网上有几个代码示例可供参考，但我遇到的所有代码片段<em class="mi">要么是围绕<strong class="kh ir">的</strong></em>(1)递归 <em class="mi">或</em> <strong class="kh ir"> (2)迭代</strong>算法方法。为了方便起见，这两种方法及其各自的代码片段都包含在本文的以下部分，以供参考。请随意调整并在您的用例中使用它们。</p><h2 id="4ef7" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">(1)递归</h2><p id="d841" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">下面是我实现的聚合所有数据块的递归代码片段:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0aa5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意要点:</strong></p><ul class=""><li id="f02a" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated"><strong class="kh ir">停止条件:</strong>T0】</li></ul><p id="3a89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">解释:</strong>当返回的项数小于500(每页返回的最大项数)时，函数<code class="fe ns nt nu nv b"><strong class="kh ir">callAPIService</strong>(transportation, offset)</code>返回数组<code class="fe ns nt nu nv b"><strong class="kh ir">arr_result</strong></code> <strong class="kh ir">，其中聚集了来自先前API调用的每个块包含500个项的所有数据块。</strong></p><ul class=""><li id="f120" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated"><strong class="kh ir">不满足停止条件时:</strong>递归，即改为执行方法本身来传播递归过程。</li></ul><h2 id="cb20" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">(2)迭代—While-Loop+Async-Await &amp; Promises</h2><p id="6e74" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">或者，也可以使用<strong class="kh ir"> async-await </strong>语法通过<strong class="kh ir">循环</strong>来实现迭代，从而聚合所有数据块。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f412" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">使用Async-Await &amp; Promise: </strong>实现<code class="fe ns nt nu nv b"><strong class="kh ir">async-await</strong></code>语法，<code class="fe ns nt nu nv b"><strong class="kh ir">async</strong></code>必须始终出现在实现<code class="fe ns nt nu nv b"><strong class="kh ir">await</strong></code>的函数中:</p><pre class="lc ld le lf gt nw nv nx bn ny nz bi"><span id="44e8" class="oa mk iq nv b be ob oc l od oe">async function func() {<br/>  let dataObj = await getData();<br/>}</span></pre><p id="447b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">代码逻辑解释:</strong>与递归类似，<code class="fe ns nt nu nv b"><strong class="kh ir">while-loop</strong></code>也有终止条件，即<code class="fe ns nt nu nv b"><strong class="kh ir">if(result.length&lt;PAGE_SIZE)</strong></code></p><ul class=""><li id="3d71" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated"><strong class="kh ir">停止条件满足:</strong><code class="fe ns nt nu nv b"><strong class="kh ir">while-loop</strong></code>停止运行，返回响应。布尔被设置为<code class="fe ns nt nu nv b"><strong class="kh ir">false</strong></code>以停止迭代<code class="fe ns nt nu nv b"><strong class="kh ir">toContinue=false;</strong></code></li><li id="cfb4" class="nj nk iq kh b ki of kl og ko oh ks oi kw oj la no np nq nr bi translated"><strong class="kh ir">否则:</strong> <code class="fe ns nt nu nv b"><strong class="kh ir">while-loop</strong></code>继续运行，更多的数据块被连接到数组<code class="fe ns nt nu nv b"><strong class="kh ir">arr_result</strong></code></li></ul></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h2 id="1d4c" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">递归与迭代的总体思路:</h2><p id="d4c6" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在上面的用例中，公交车的<strong class="kh ir">号停了大约5K </strong>，我个人更喜欢使用递归，因为<strong class="kh ir">比迭代</strong>的代码长度更短。</p><p id="6d5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，在聚合数据数组中返回的总项数未知并且最终项数可能非常大的情况下，更明智的做法是对每个API调用使用迭代方法，比如while-loop。这是因为，在递归算法中，大量的API调用会导致<strong class="kh ir">堆栈溢出，导致你的程序在运行时崩溃</strong>🙃</p><p id="523b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个需要注意的是，递归算法的复杂度O(n)随着API调用的增加而呈指数增长。因此，当检索到的项目数量很大，并且预期的API调用数量也相应很高时，坚持使用迭代方法比递归方法更明智，这样可以避免损害应用程序的性能。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h2 id="83d1" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">非常感谢你坚持到这篇文章的结尾！❤希望你发现上面的两个代码片段很有用，如果你想了解更多与数据分析相关的内容，请随时关注我。会非常感激😀</h2></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="2d54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">参考消息:</strong>如果您对前面提到的公交路线web应用程序感兴趣，请随时查看以下文章。</p><div class="or os gp gr ot ou"><a href="https://towardsdatascience.com/building-a-real-time-web-app-in-nodejs-express-with-socket-io-library-d9b50aded6e6" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">用Socket.io库在NodeJS Express中构建实时web app</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">服务器+客户端代码实现来检索公交车到达时间</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ll ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://towardsdatascience.com/tackling-heroku-h12-timeout-errors-of-node-js-web-apis-handling-long-response-times-8fbafe46cd40" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">解决Node.js Web APIs的Heroku H12超时错误—处理长响应时间</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">带有Redis缓存的混合(服务器+客户机)API分页</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ll ou"/></div></div></a></div></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><div class="lc ld le lf gt ou"><a href="https://geek-cc.medium.com/membership" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">通过我的推荐链接加入灵媒——李思欣·崔</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">获得李思欣·崔和其他作家在媒体上的所有帖子！😃您的会员费直接…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">geek-cc.medium.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ll ou"/></div></div></a></div><p id="df12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mi">更多内容请看</em><a class="ae lr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="mi">plain English . io</em></strong></a></p></div></div>    
</body>
</html>