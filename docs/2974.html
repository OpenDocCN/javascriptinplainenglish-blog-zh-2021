<html>
<head>
<title>What’s new in React 18?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18有什么新功能？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-new-in-react-18-acc168375db0?source=collection_archive---------10-----------------------#2021-06-16">https://javascript.plainenglish.io/whats-new-in-react-18-acc168375db0?source=collection_archive---------10-----------------------#2021-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><div class=""/><p id="6e9d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" rel="noopener ugc nofollow" target="_blank"> React 18 alpha版本刚刚公布</a>。React 18的主题是通过引入开箱即用的功能和由“并发渲染”提供动力的改进来消除janky用户体验，从而使UI更具性能。React 18引入了最小的突破性变化。</p><p id="a05d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来看看React 18的重大更新:</p><h1 id="ea84" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">根API</h1><p id="fd80" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">React 18引入Root API <code class="fe ma mb mc md b">ReactDOM.createRoot</code>。在React 18之前，我们使用<code class="fe ma mb mc md b">ReactDOM.render</code>向页面渲染一个组件。从React 18开始，我们将使用ReactDOM.createRoot创建一个根，然后将这个根传递给render函数。好消息是，你当前使用<code class="fe ma mb mc md b">ReactDOM.render</code>的代码仍然有效，但是，强烈建议开始过渡到<code class="fe ma mb mc md b">createRoot</code>，因为<code class="fe ma mb mc md b">render</code>从18开始将被标记为<code class="fe ma mb mc md b">deprecated</code>。电流<code class="fe ma mb mc md b">ReactDOM.render</code>仅被提供来缓解向反应18的转变。</p><p id="9361" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反应17:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f2c2" class="mm ky jb md b gy mn mo l mp mq">import ReactDOM from 'react-dom';<br/>import App from 'App';</span><span id="ee28" class="mm ky jb md b gy mr mo l mp mq">const container = document.getElementById('app');</span><span id="ce64" class="mm ky jb md b gy mr mo l mp mq">ReactDOM.render(&lt;App /&gt;, container);</span></pre><p id="a6c5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反应18:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5c78" class="mm ky jb md b gy mn mo l mp mq">import ReactDOM from 'react-dom';<br/>import App from 'App';</span><span id="5a2a" class="mm ky jb md b gy mr mo l mp mq">const container = document.getElementById('app');</span><span id="d47e" class="mm ky jb md b gy mr mo l mp mq">// create a root<br/>const root = ReactDOM.createRoot(container);</span><span id="6f25" class="mm ky jb md b gy mr mo l mp mq">//render app to root<br/>root.render(&lt;App /&gt;);</span></pre><h1 id="a9ff" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">自动批处理(开箱即用，可选择退出):</h1><p id="ee65" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">批处理是将多个状态更新组合成一个以防止多次重新呈现的过程。以前，React批处理发生在由React事件系统管理的单个事件回调中的状态更新，但是不批处理发生在事件之外的状态更新。</p><p id="a262" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，使用自动批处理，所有更新，甚至在承诺、设置超时内的更新，都将被批处理。看看这个例子-</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c11f" class="mm ky jb md b gy mn mo l mp mq">function handleClick() {<br/>    console.log("=== click ===");<br/>    setCount((c) =&gt; c + 1); // Does not re-render yet<br/>    setFlag((f) =&gt; !f); // Does not re-render yet<br/>    // React will only re-render once at the end (that's batching!)</span><span id="5d35" class="mm ky jb md b gy mr mo l mp mq">    const timeoutCallback = () =&gt; {<br/>      // Previously, batching didn't work inside timeouts, fetch, promises.<br/>      // These two setStates caused re-render in React 17.<br/>      // With React 18, these are now batched.<br/>      setCount((c) =&gt; c + 1);<br/>      setFlag((f) =&gt; !f);<br/>    };</span><span id="8a80" class="mm ky jb md b gy mr mo l mp mq">    setTimeout(timeoutCallback, 1000);<br/>  }</span></pre><p id="7f16" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://codesandbox.io/s/romantic-pare-efklq?file=/src/index.js:192-695" rel="noopener ugc nofollow" target="_blank">完整示例见codesanbox链接</a></p><p id="2c34" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">退出:</strong>您可以使用<code class="fe ma mb mc md b">flushSync</code>退出自动配料</p><h1 id="fa7c" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">开始过渡(选择加入)</h1><p id="2ae9" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe ma mb mc md b">startTransition</code>可以用来标记不需要紧急资源进行更新的UI更新。例如:当在一个typeahead域中键入时，会发生两件事——一个闪烁的光标显示正在键入的内容的视觉反馈，以及一个在后台搜索所键入数据的搜索功能。</p><p id="a914" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向用户展示视觉反馈很重要，因此也很紧迫。搜索不是很紧急，因此可以标记为非紧急。这就是<code class="fe ma mb mc md b">startTransition</code>发挥作用的地方。</p><p id="c081" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将非紧急的UI更新标记为“过渡”，React将知道哪些更新应该优先，从而更容易优化渲染并消除陈旧的渲染。标记为非紧急<code class="fe ma mb mc md b">startTransition</code>的更新可能会被紧急更新中断，如点击或按键。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2d45" class="mm ky jb md b gy mn mo l mp mq">import { startTransition } from 'react';<br/></span><span id="ce7a" class="mm ky jb md b gy mr mo l mp mq">// Urgent: Show what was typed<br/>setInputValue(input);</span><span id="964e" class="mm ky jb md b gy mr mo l mp mq">// Mark any state updates inside as transitions<br/>startTransition(() =&gt; {<br/>  // Transition: Show the results<br/>  setSearchQuery(input);<br/>});</span></pre><p id="dc1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">与去抖或setTimeout有什么不同？</strong></p><ol class=""><li id="2c9d" class="ms mt jb ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">与setTimeout不同，startTransition会立即执行。setTimeout有保证的延迟，而startTransition的延迟取决于设备的速度和其他紧急渲染。</li><li id="d257" class="ms mt jb ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">与setTimeout不同，startTransition更新可以被中断，并且不会冻结页面。</li><li id="7cf8" class="ms mt jb ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">当用startTransition标记时，React可以为您跟踪挂起状态。</li></ol><h1 id="f230" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何移动反应18？</h1><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ece4" class="mm ky jb md b gy mn mo l mp mq">npm install react@alpha react-dom@alpha</span></pre><p id="2bb5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将React.render更改为React.createRoot</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ac23" class="mm ky jb md b gy mn mo l mp mq">const rootElement = document.getElementById("root");<br/>ReactDOM.createRoot(&lt;App /&gt;, rootElement).render(&lt;App /&gt;);</span></pre></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="f259" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/reactwg/react-18/discussions/categories/announcement" rel="noopener ugc nofollow" target="_blank">查看React工作组GitHub更新的完整列表</a></p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="2126" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://tinyletter.com/shrutikapoor" rel="noopener ugc nofollow" target="_blank">在你的收件箱里收到这样的文章</a></p><p id="90e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nn">更多内容请看</em><a class="ae kw" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="nn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>