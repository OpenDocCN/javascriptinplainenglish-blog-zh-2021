<html>
<head>
<title>Build a Multiscreen Web App with JavaScript and CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript和CSS构建一个多屏Web应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-multiscreen-web-app-with-javascript-and-css-758d9f626de3?source=collection_archive---------4-----------------------#2021-08-28">https://javascript.plainenglish.io/build-a-multiscreen-web-app-with-javascript-and-css-758d9f626de3?source=collection_archive---------4-----------------------#2021-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e4643c63d56262098bab950830ba533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2OC6Jc2W28l_AWzh7jaKQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.freepik.com/vectors/technology" rel="noopener ugc nofollow" target="_blank">Technology vector</a> created by <a class="ae kc" href="https://www.freepik.com/pikisuperstar" rel="noopener ugc nofollow" target="_blank">pikisuperstar</a> — <a class="ae kc" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">www.freepik.com</a></figcaption></figure><p id="6067" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想建立自己的web开发组合，可以考虑的一个项目是单页面web应用程序。与原生应用一样，网络应用通常是为单一目的而构建的，并且是为了在移动设备上良好运行而构建的，但它们都是幕后的网站。和其他网站一样，它们不是下载到你的手机上，而是托管在服务器上，由你的浏览器请求。</p><p id="a305" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果你想搭建一个web app，从哪里入手呢？虽然你可以从Vue、Angular、React、Medium和Ember等<a class="ae kc" href="https://www.toobler.com/blog/frameworks-for-developing-single-page-applications/" rel="noopener ugc nofollow" target="_blank">完整的框架</a>中提取，但你也可以用普通的JavaScript构建你的web应用代码库。如果你是web开发的新手，我推荐你在进入框架之前使用这种普通的JS方法，因为你会在基础方面变得更强。</p><h1 id="9041" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们将建造什么</h1><p id="e313" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本教程中，我们将构建一个简单的库，用于使用CSS和JavaScript创建web应用程序，并使用它创建一个具有三个屏幕的“Hello World”web应用程序。虽然该应用程序只有一个<code class="fe me mf mg mh b">index.html</code>页面，但点击或轻触按钮会带你浏览多个屏幕。</p><p id="0cb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该库将允许我们为每个屏幕编码DOM结构，而无需繁琐的标记，并创建屏幕之间的渐变过渡。最终产品，如下面的代码笔所示，旨在作为您自己工作的一个可扩展的起点。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The project we will finish.</figcaption></figure><p id="c95d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个演示应用有几个关键特性:</p><ul class=""><li id="1689" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">只有初始屏幕是在开始时构建的。</li><li id="f5d5" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">当您导航到一个新屏幕时，它的DOM结构是动态构建的。</li><li id="0fcc" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">用CSS将多个屏幕堆叠在一起。</li></ul><p id="8446" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript代码库也有两个部分:</p><ul class=""><li id="c835" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">一个小型库，旨在跨应用程序重用，处理DOM填充和屏幕过渡。</li><li id="f9bf" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">应用程序内容的特定代码。</li></ul><p id="f113" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们首先来看看我们正在使用的特定于应用程序的代码，这样我们就可以看到这个库应该如何工作。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="4f65" class="lb lc iq bd ld le nj lg lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly bi translated">特定于应用的代码</h1><p id="365b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将首先编写四个特定于应用程序内容的函数。</p><ul class=""><li id="360a" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">列出三个屏幕及其属性的菜单功能。</li><li id="1649" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">一组回调函数——每个屏幕一个。我们希望能够编写特定于应用程序的代码，填充我们应用程序的屏幕，然后在每个屏幕上显示内容。</li></ul><h2 id="72d0" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">菜单功能</h2><p id="0988" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了列出我们所有的应用程序屏幕，上面显示的演示web应用程序使用了一个名为<code class="fe me mf mg mh b">app_menu</code>的函数。让我们把这个编码起来。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The app menu function</figcaption></figure><p id="21ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在该函数中，我们做了几件事:</p><ul class=""><li id="7748" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">我们实例化一个空的<code class="fe me mf mg mh b">items</code>对象。</li></ul><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="f4ca" class="no lc iq mh b gy of og l oh oi">var items = {};</span></pre><ul class=""><li id="d1bd" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">启动<code class="fe me mf mg mh b">items</code>后，我们为应用程序中的每个屏幕添加一个键值对。</li><li id="ee45" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">每个键指向一个有<code class="fe me mf mg mh b">title</code>和<code class="fe me mf mg mh b">page_callback</code>的物体。</li></ul><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="1d3a" class="no lc iq mh b gy of og l oh oi">items.screen_one_path = {                            <br/>     active: true,                               <br/>     title: 'Page 1 title',      <br/>     screen_callback: 'screen_one',  <br/>};</span></pre><ul class=""><li id="164f" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">只有起始屏幕的对象具有设置为<code class="fe me mf mg mh b">true</code>的<code class="fe me mf mg mh b">active</code>属性。</li><li id="1952" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">每个按键，比如<code class="fe me mf mg mh b">screen_one_path</code>，都是一个应用程序按钮将用户带到那个屏幕的路径。</li><li id="03dc" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">函数结束时，返回<code class="fe me mf mg mh b">items</code>。</li></ul><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="ad86" class="no lc iq mh b gy of og l oh oi">return items;</span></pre><h2 id="f35b" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">屏幕回调</h2><p id="e372" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于<code class="fe me mf mg mh b">app_menu</code>中的每个屏幕对象，都有一个<code class="fe me mf mg mh b">screen_callback</code>键指向该屏幕的回调函数的名称。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="1ae0" class="no lc iq mh b gy of og l oh oi">items.screen_two_path = {<br/>      title: 'Screen 2 title',<br/> <strong class="mh ir">     screen_callback: 'screen_two'</strong><br/>};</span></pre><p id="93a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面列出了<code class="fe me mf mg mh b">screen_two</code>回调的所有代码，然后您可以尝试编写另外两个。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A sample screen callback.</figcaption></figure><p id="89eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个回调函数中，我们指定了屏幕上的内容。与菜单函数中的<code class="fe me mf mg mh b">items</code>一样，我们从实例化一个空的<code class="fe me mf mg mh b">content</code>对象开始。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="049c" class="no lc iq mh b gy of og l oh oi">let content = {};</span></pre><p id="7fcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用<code class="fe me mf mg mh b">body</code>和<code class="fe me mf mg mh b">header</code>键为屏幕添加内容。每个键指向一个对象，该对象确定屏幕标记的一部分。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="6b74" class="no lc iq mh b gy of og l oh oi">content.header = {                           <br/>    markup: '&lt;h3&gt;Welcome to Screen 2!&lt;/h3&gt;'                   <br/>};<br/>                         <br/>content.body = {                   <br/>    markup:'&lt;p&gt;Spiffy content here.&lt;/h2&gt;'                    <br/>}</span></pre><p id="eb1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用一个<code class="fe me mf mg mh b">links</code>属性来确定对象的链接。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="a131" class="no lc iq mh b gy of og l oh oi">content.nav = {                           <br/>     className:'nav',                        <br/>     links:[{                           <br/>        text:'screen 1',                          <br/>        href:'#screen_one_path'  <br/>     },                        <br/>     {                             <br/>        text:'screen 3',                            <br/>        href:'#screen_three_path'      <br/>    }]<br/>};</span></pre><p id="3ab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们给两个链接都添加了类名<code class="fe me mf mg mh b">nav</code>。对于每个链接，我们使<code class="fe me mf mg mh b">text</code>对应于可见文本，并使<code class="fe me mf mg mh b">href</code>成为屏幕的路径。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="e517" class="no lc iq mh b gy of og l oh oi">text:'screen 3',                            <br/>href:'#screen_three_path'</span></pre><p id="7639" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们返回<code class="fe me mf mg mh b">content</code>对象。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="f9e1" class="no lc iq mh b gy of og l oh oi">return content;</span></pre><p id="ef4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个应用程序中的所有三个页面具有相同的总体结构。这里的目标是实现一种轻量级的方式来构建内容，而不必为每个屏幕手工编写完整的HTML标记。</p><h2 id="e8f9" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">独立地</h2><p id="5529" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">继续构建另外两个屏幕回调函数。如果你坚持上面例子的格式，你应该没问题。您可以检查CodePen，以便更仔细地比较代码。</p><h2 id="4c3e" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">正在初始化应用程序</h2><p id="1238" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">假设我们有一个包含<code class="fe me mf mg mh b">&lt;head&gt;</code>和<code class="fe me mf mg mh b">&lt;body&gt;</code>部分的<code class="fe me mf mg mh b">index.html</code>页面。在<code class="fe me mf mg mh b">&lt;body&gt;</code>部分，主元素容器有一个<code class="fe me mf mg mh b">app</code>的<code class="fe me mf mg mh b">id</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="64c8" class="no lc iq mh b gy of og l oh oi">&lt;div id="app"&gt;&lt;/div&gt;</span></pre><p id="3fbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果菜单功能和每个屏幕的屏幕回调都已就绪，我们应该能够使用下面的代码启动应用程序:</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="7460" class="no lc iq mh b gy of og l oh oi">utils.init('app',app_menu);</span></pre><p id="4473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来分析一下。</p><ul class=""><li id="91c4" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">主库对象是<code class="fe me mf mg mh b">utils</code>，<code class="fe me mf mg mh b">init</code>是指初始化方法。</li><li id="213a" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">第一个参数<code class="fe me mf mg mh b">app</code>是一个引用上面所示DOM元素的<code class="fe me mf mg mh b">id</code>的字符串。</li><li id="5141" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">第二个参数，<code class="fe me mf mg mh b">app_menu</code>，是我们写的函数。如果您是JavaScript新手，这听起来可能有点奇怪，但是在这里，我们希望将一个函数(<code class="fe me mf mg mh b">app_menu</code>)传递给另一个函数(<code class="fe me mf mg mh b">init</code>)。</li></ul><p id="d78c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你是用CodePen写的，你可能想把你的<code class="fe me mf mg mh b">init</code>行注释掉，直到你写完所有的JavaScript。这将防止您的代码无意中过早运行并出现错误信息。</p><p id="2624" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，您应该有了您的<code class="fe me mf mg mh b">app_menu</code>函数、三个回调函数和您的调用<code class="fe me mf mg mh b">init</code>的行。如果你已经建立了所有这些，干得好！现在让我们创建一个库来实现这些功能。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="7406" class="lb lc iq bd ld le nj lg lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly bi translated">图书馆</h1><p id="8ba3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将从一个名为<code class="fe me mf mg mh b">utils</code>的空对象和一个立即调用的函数表达式(IIFE)开始，我们将通过它。在这个生命包装器中，<code class="fe me mf mg mh b">utils</code>被称为<code class="fe me mf mg mh b">context</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="b603" class="no lc iq mh b gy of og l oh oi">let utils = {};</span><span id="024c" class="no lc iq mh b gy oj og l oh oi">(function(<strong class="mh ir">context</strong>) {</span><span id="34bb" class="no lc iq mh b gy oj og l oh oi">   // code will go here</span><span id="04a5" class="no lc iq mh b gy oj og l oh oi">})(<strong class="mh ir">utils</strong>);</span></pre><h2 id="e68e" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">init函数</h2><p id="9e88" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在包装器中，让我们编写应该能够调用的<code class="fe me mf mg mh b">init</code>方法，并将其附加到<code class="fe me mf mg mh b">context</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="0570" class="no lc iq mh b gy of og l oh oi">utils.init('app',app_menu);</span></pre><p id="e120" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在包装器中构建方法外壳。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="7097" class="no lc iq mh b gy of og l oh oi">(function(context) {</span><span id="68e1" class="no lc iq mh b gy oj og l oh oi">    context.init = function(appId,myMenu) {</span><span id="5200" class="no lc iq mh b gy oj og l oh oi">    }</span><span id="8a8f" class="no lc iq mh b gy oj og l oh oi">})(utils);</span></pre><p id="d2c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的第一个任务是将<code class="fe me mf mg mh b">appId</code>字符串和<code class="fe me mf mg mh b">myMenu</code>函数分配给我们的<code class="fe me mf mg mh b">context</code>对象。这样，我们可以在包装器之外引用它们。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="7292" class="no lc iq mh b gy of og l oh oi">context.init = function(appId,myMenu) {        </span><span id="0d8b" class="no lc iq mh b gy oj og l oh oi">     context.id = appId;                       <br/>     context.menu = myMenu();</span><span id="c935" class="no lc iq mh b gy oj og l oh oi">}</span></pre><p id="79c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们希望找到开始活动屏幕的ID，并只为该屏幕构建DOM。为此，我们将从<code class="fe me mf mg mh b">app_menu</code>函数中获得每个屏幕的路径ID，该函数现在驻留在<code class="fe me mf mg mh b">context.menu</code>中。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="2ec5" class="no lc iq mh b gy of og l oh oi">let path_ids = Object.keys(context.menu);</span><span id="8f1b" class="no lc iq mh b gy oj og l oh oi">// expected result<br/>// ['screen_one_path', 'screen_two_path', 'screen_three_path']</span></pre><p id="c86c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快速回到之前:还记得<code class="fe me mf mg mh b">app_menu</code>中的<code class="fe me mf mg mh b">items</code>关联数组吗，其中每个键值对代表路径和屏幕？在<code class="fe me mf mg mh b">app_menu</code>中只有一个对象的<code class="fe me mf mg mh b">active</code>属性被设置为<code class="fe me mf mg mh b">true</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="306c" class="no lc iq mh b gy of og l oh oi">items.screen_one_path = {                            <br/><strong class="mh ir">     active: true,   </strong>                            <br/>     title: 'Page 1 title',      <br/>     screen_callback: 'screen_one',  <br/>};</span></pre><p id="8e78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着在我们的<code class="fe me mf mg mh b">path_ids</code>数组中只有一个<code class="fe me mf mg mh b">active</code>对象，所以我们可以使用<code class="fe me mf mg mh b">Array.prototype.find()</code>方法提取带有<code class="fe me mf mg mh b">active</code>属性的one screen对象的<code class="fe me mf mg mh b">screenId</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="99cf" class="no lc iq mh b gy of og l oh oi">let screenId = path_ids.find(id =&gt; context.menu[id].active);</span></pre><p id="9129" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要<code class="fe me mf mg mh b">screenId</code>存在，我们就可以用它来获取完整的对象。然后，我们将把它传递给一个新函数，<code class="fe me mf mg mh b">buildScreen</code>，接下来我们将编写这个函数。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="1b10" class="no lc iq mh b gy of og l oh oi">if (screenId) {                        <br/>   screen = <strong class="mh ir">buildScreen(screenId);   </strong>                                                  <br/>}</span></pre><p id="16b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即将到来的<code class="fe me mf mg mh b">buildScreen</code>函数将返回值一个DOM元素，<code class="fe me mf mg mh b">screen</code>，它将作为我们的应用程序主屏幕添加到我们的页面。虽然我们的CSS最终会默认隐藏每个屏幕，但是让我们给这个屏幕一个<code class="fe me mf mg mh b">active</code>类，它会保持它可见。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="4400" class="no lc iq mh b gy of og l oh oi">if (screenId) {                <br/>      screen = buildScreen(screenId); <br/>                                                         <br/><strong class="mh ir">      screen.className += ' active'; </strong><br/>}</span></pre><p id="770b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，我们完成了<code class="fe me mf mg mh b">init</code>方法！下面是完整的代码。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The full init method.</figcaption></figure><h2 id="61c3" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">构建屏幕</h2><p id="c4d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在让我们为<code class="fe me mf mg mh b">buildScreen</code>写代码。您可能已经从我们刚刚使用它的方式中猜到了，这个方法将接受一个参数<code class="fe me mf mg mh b">screenId</code>，并返回一个表示新屏幕的新DOM元素。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="6a06" class="no lc iq mh b gy of og l oh oi">function buildScreen(screenId) {                                                      <br/><br/>}</span></pre><p id="cf27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为第一步，我们使用<code class="fe me mf mg mh b">context.id</code>来获取应用容器DOM元素。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="3e5e" class="no lc iq mh b gy of og l oh oi">function buildScreen(screenId) {  <br/>                                                    <br/>    let app = document.getElementById(context.id);       <strong class="mh ir">     </strong>                <br/>}</span></pre><p id="ae9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">screenId</code>从<code class="fe me mf mg mh b">context.menu</code>获取屏幕对象。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="086c" class="no lc iq mh b gy of og l oh oi">function buildScreen(screenId) {      <br/>                                                <br/>    let app = document.getElementById(context.id);    <strong class="mh ir">        </strong>                <br/><strong class="mh ir">    let obj = context.menu[screenId];<br/></strong>}</span></pre><p id="3a2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">screenId</code>为新屏幕创建一个新的<code class="fe me mf mg mh b">&lt;div&gt;</code>元素。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="6b78" class="no lc iq mh b gy of og l oh oi">function buildScreen(screenId) {  <br/>                                              <br/>    let app = document.getElementById(context.id);                                                      <br/>    let obj = context.menu[screenId];</span><span id="46d3" class="no lc iq mh b gy oj og l oh oi"><strong class="mh ir">    let screen = document.createElement('div');                                                     <br/>    screen.className = 'screen';                             <br/>    screen.id = screenId;</strong><br/>}</span></pre><p id="d681" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个主要的东西需要创建:屏幕标题栏和内容。下面是屏幕标题栏的标记，我们使用OR ( <code class="fe me mf mg mh b">||</code>)操作符来放置一个备份标题。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="59f5" class="no lc iq mh b gy of og l oh oi">let h2 = document.createElement('h2');                           <br/>let title = obj.title || 'Placeholder';                           h2.textContent = title;                                                      screen.appendChild(h2);</span></pre><p id="3885" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是构建内容的逻辑。注意，我们正在调用一个新的函数，<code class="fe me mf mg mh b">addContent</code>，我们接下来将编写这个函数。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="9753" class="no lc iq mh b gy of og l oh oi">let ui = document.createElement('div');   </span><span id="2320" class="no lc iq mh b gy oj og l oh oi">ui.className = 'ui-content';      </span><span id="b2ea" class="no lc iq mh b gy oj og l oh oi">ui = <strong class="mh ir">addContent</strong>(screenId, screen, ui);</span></pre><p id="94eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将内容追加到<code class="fe me mf mg mh b">screen</code>，将<code class="fe me mf mg mh b">screen</code>追加到<code class="fe me mf mg mh b">app</code>，并返回<code class="fe me mf mg mh b">screen</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="77f7" class="no lc iq mh b gy of og l oh oi">  screen.appendChild(ui);   <br/>  app.appendChild(screen);  <br/>  return screen;                 <br/>}</span></pre><p id="f873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">buildScreen</code>的完整代码如下。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div></figure><h2 id="fe11" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">添加内容</h2><p id="22b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在让我们编写在屏幕中添加内容的逻辑。这是我鼓励你扩展以适合你自己目的的方法。虽然我们只是构建文本内容和链接，但是您也可以为其他屏幕元素添加逻辑，比如表单小部件、图像和视频。</p><p id="425d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建屏幕将基于菜单对象，如下所示:</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="7121" class="no lc iq mh b gy of og l oh oi">items.screen_three_path = {                                                      <br/>     title: 'Screen 3 title',      <br/>     screen_callback: 'screen_three',  <br/>};</span></pre><p id="c8a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住上面的<code class="fe me mf mg mh b">items</code>现在等价于下面的<code class="fe me mf mg mh b">context.menu</code>，我们首先检查它以确保我们有一个给定屏幕ID的对象，比如<code class="fe me mf mg mh b">screen_three_path</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="a29c" class="no lc iq mh b gy of og l oh oi">function addContent(id,screen,el) {<br/>   if (context.menu[id]) {</span><span id="639b" class="no lc iq mh b gy oj og l oh oi">   }<br/>}</span></pre><p id="a77e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得那些屏幕回调函数吗？这是我们利用它们的地方。我们首先使用下面的方法获得回调的名称。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="4b87" class="no lc iq mh b gy of og l oh oi">function addContent(id,screen,el) {<br/>   if (context.menu[id]) {</span><span id="d69d" class="no lc iq mh b gy oj og l oh oi"><strong class="mh ir">     let cb = context.menu[id].screen_callback;</strong><br/>  }<br/>}</span></pre><p id="bc63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想要的回调的名字是<code class="fe me mf mg mh b">screen_two()</code>。这个函数被附加到我们的全局<code class="fe me mf mg mh b">window</code>对象，所以我们可以用括号语法和我们的<code class="fe me mf mg mh b">cb</code>变量来访问它——然后用括号<code class="fe me mf mg mh b">()</code>来调用它。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="26eb" class="no lc iq mh b gy of og l oh oi">function addContent(id,screen,el) {<br/>   if (context.menu[id]) {</span><span id="e202" class="no lc iq mh b gy oj og l oh oi">     let cb = context.menu[id].screen_callback;</span><span id="000e" class="no lc iq mh b gy oj og l oh oi">     <strong class="mh ir">let content = window[cb]();</strong><br/>   }<br/>}</span></pre><p id="cf67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在我们有了回调函数返回的<code class="fe me mf mg mh b">content</code>对象。让我们遍历它的所有键，你可能记得包括<code class="fe me mf mg mh b">header</code>、<code class="fe me mf mg mh b">body</code>和<code class="fe me mf mg mh b">nav</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="bc65" class="no lc iq mh b gy of og l oh oi">  let content = window[cb](); </span><span id="cc97" class="no lc iq mh b gy oj og l oh oi">  for (const key in content) {</span><span id="ab11" class="no lc iq mh b gy oj og l oh oi">     let o = content[key];</span><span id="1ee9" class="no lc iq mh b gy oj og l oh oi">  }</span></pre><p id="9c33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个<code class="fe me mf mg mh b">for...in</code>循环中，我们检查两个属性:<code class="fe me mf mg mh b">body</code>或<code class="fe me mf mg mh b">header</code>情况下的<code class="fe me mf mg mh b">markup</code>，以及<code class="fe me mf mg mh b">nav</code>情况下的<code class="fe me mf mg mh b">links</code>。对于<code class="fe me mf mg mh b">markup</code>，我们简单地创建一个新的<code class="fe me mf mg mh b">&lt;div&gt;</code>元素，从回调中添加标记，并将<code class="fe me mf mg mh b">&lt;div&gt;</code>追加到屏幕元素。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="7961" class="no lc iq mh b gy of og l oh oi">if (o.markup) {    <br/>                                                    <br/>    let div = document.createElement('div');                             <br/>    div.innerHTML = o.markup;                             <br/>    el.appendChild(div); <br/>}</span></pre><p id="78db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了添加链接列表，我们首先创建一个新的<code class="fe me mf mg mh b">&lt;ul&gt;</code>元素，并在必要时添加类名。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="4d2c" class="no lc iq mh b gy of og l oh oi">if (o.links) {<br/>   ul = document.createElement('ul'); <br/>   if (o.className) { <br/>       ul.className = o.className;<br/>   }<br/>}</span></pre><p id="3d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用一个<code class="fe me mf mg mh b">for...of</code>循环来遍历数组中的链接。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="0ce1" class="no lc iq mh b gy of og l oh oi">for (link of o.links) {</span><span id="5380" class="no lc iq mh b gy oj og l oh oi">}<br/></span></pre><p id="ce54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是完整的代码，对于每个链接，我们创建一个包含一个具有指定的<code class="fe me mf mg mh b">href</code>和<code class="fe me mf mg mh b">textContent</code>属性的<code class="fe me mf mg mh b">&lt;a&gt;</code>元素的<code class="fe me mf mg mh b">&lt;li&gt;</code>元素。在一些附加之后，我们将一个新函数附加到<code class="fe me mf mg mh b">&lt;a&gt;</code>元素— <code class="fe me mf mg mh b">enableLink</code> —并返回列表。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The logic for adding links/</figcaption></figure><p id="a6c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe me mf mg mh b">addContent</code>的完整代码。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div></figure><h2 id="ea7a" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">更换屏幕</h2><p id="59ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每次点击一个链接，屏幕都应该改变。这就是为什么在我们刚刚编写的代码中调用了<code class="fe me mf mg mh b">enableLink</code>函数。我们现在来写<code class="fe me mf mg mh b">enableLink</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="f8ef" class="no lc iq mh b gy of og l oh oi">function enableLink(link) {<br/>  link.addEventListener('click',function(e) {<br/>     let id = changeScreen(e);        <br/>  }); <br/>}</span></pre><p id="deae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，当点击一个链接时，会调用一个<code class="fe me mf mg mh b">changeScreen</code>函数。现在让我们开始写，从函数外壳开始。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="ccd4" class="no lc iq mh b gy of og l oh oi">function changeScreen(e) {</span><span id="11e0" class="no lc iq mh b gy oj og l oh oi">}</span></pre><h2 id="19d9" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">淘汰旧的</h2><p id="71c3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，让我们准备从我们的输出屏幕中删除<code class="fe me mf mg mh b">active</code>类。我们将使用我们计划移除的类来获取对屏幕元素的引用。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="aeac" class="no lc iq mh b gy of og l oh oi">function changeScreen(e) {</span><span id="8e3d" class="no lc iq mh b gy oj og l oh oi">   let prev = document.querySelector('.screen.active');<br/>}</span></pre><p id="f142" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将使用<code class="fe me mf mg mh b">setTimeout</code>和<code class="fe me mf mg mh b">delay</code>来淡出屏幕，这样我们就可以控制何时开始。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="7b11" class="no lc iq mh b gy of og l oh oi">let prev = document.querySelector('.screen.active');</span><span id="be2f" class="no lc iq mh b gy oj og l oh oi">const delay = 10;<br/>window.setTimeout(function() {<br/>  <br/>},delay);</span></pre><p id="84e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">setTimeout</code>回调中，我们将移除<code class="fe me mf mg mh b">active</code>类，如果它存在的话。稍后您将会看到，这将触发CSS不透明度转换。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="7bab" class="no lc iq mh b gy of og l oh oi">const delay = 10;<br/>window.setTimeout(function() {<br/> <strong class="mh ir">    if (prev &amp;&amp; prev.className.includes('active')) {<br/>          prev.classList.remove('active');<br/>     } </strong> <br/>},delay);</span></pre><h2 id="9313" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">跟上新潮流</h2><p id="917f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们隐藏了输出屏幕，让我们显示输入屏幕。我们将首先获得目标链接的<code class="fe me mf mg mh b">href</code>属性，它以一个标签开始(例如<code class="fe me mf mg mh b">#page_one_path</code>)。我们不想要标签，所以我们将使用<code class="fe me mf mg mh b">String.prototype.split()</code>方法把它取出来。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="eecd" class="no lc iq mh b gy of og l oh oi">let id = e.target.href.<strong class="mh ir">split</strong>('#')[1];</span></pre><p id="c2f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们尝试访问屏幕元素。查看下面的代码:</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="ed05" class="no lc iq mh b gy of og l oh oi">let screen = document.getElementById(id) || buildScreen(id);</span></pre><p id="cc9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们第一次进入这个屏幕，这个屏幕的DOM容器将不存在——但是如果我们再次访问这个屏幕，它就会存在。所以我们首先用<code class="fe me mf mg mh b">document.getElementById</code>检查它是否存在，如果失败，OR ( <code class="fe me mf mg mh b">||</code>)选择器将我们带到我们的备份计划:用<code class="fe me mf mg mh b">buildScreen</code>创建屏幕。</p><p id="65f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管怎样，我们必须淡入这个屏幕，让它看得见。我们通过添加<code class="fe me mf mg mh b">active</code>类来做到这一点，但是为了确保我们只添加它一次，让我们检查一下以确保它不存在。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="7586" class="no lc iq mh b gy of og l oh oi">if (!screen.className.includes('active')) {<br/>     let delay = 50;<br/>      window.setTimeout(function() {<br/>        screen.className += ' active';<br/>      },delay); <br/>}</span></pre><p id="15ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像淡出旧屏幕一样，我们将使用<code class="fe me mf mg mh b">setTimeout</code>,这样我们就可以按照自己的喜好编排节目过渡。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="240d" class="no lc iq mh b gy of og l oh oi">if (!screen.className.includes('active')) {<br/>     let delay = 50;<br/>      window.setTimeout(function() {<br/>        screen.className += ' active';<br/>      },delay); <br/>}</span></pre><p id="6228" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在函数结束时返回屏幕的<code class="fe me mf mg mh b">id</code>。下面是<code class="fe me mf mg mh b">changeScreen</code>的完整代码。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Change Screen</figcaption></figure><p id="e225" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是JavaScript的全部内容！如果你测试你的应用程序，点击“第二页”链接后应该是这样的。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/cc05beec5f7ce8483f80c758ad59b8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*DrKtkOY7WGwwIXUquzYeDw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Alas, the web app styles look a bit quaint without CSS.</figcaption></figure><p id="b9cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">书页没有消失，整个东西看起来像是1995年的，但那是因为我们还没有创造出风格。让我们现在就建立这些。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="2474" class="lb lc iq bd ld le nj lg lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h1><p id="5dc2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们从<code class="fe me mf mg mh b">html</code>和<code class="fe me mf mg mh b">body</code>开始。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="5a11" class="no lc iq mh b gy of og l oh oi">html, body {<br/>  height: 100%;<br/>  padding: 0px;<br/>  margin: 0px;<br/>}</span></pre><h2 id="2d5f" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">应用程序容器</h2><p id="d7f3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">回想一下，在<code class="fe me mf mg mh b">body</code>中，主容器的id是<code class="fe me mf mg mh b">app</code>。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="3d9b" class="no lc iq mh b gy of og l oh oi">&lt;div id="app"&gt;&lt;/div&gt;</span></pre><p id="be80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们对这个容器使用<code class="fe me mf mg mh b">position:relative</code>，这将允许我们使用<code class="fe me mf mg mh b">position:absolute</code>将屏幕元素放置在彼此之上。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div></figure><p id="f18f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">width</code>为100%，因此应用程序容器占据了屏幕的宽度。您可以尝试其他风格。</p><h2 id="2d44" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">屏幕</h2><p id="ecde" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面是屏幕的CSS。使用<code class="fe me mf mg mh b">position: absolute</code>允许它们相互叠加。请注意，<code class="fe me mf mg mh b">opacity</code>是<code class="fe me mf mg mh b">0</code>，而<code class="fe me mf mg mh b">pointer-events</code>是<code class="fe me mf mg mh b">none</code>，以使它们不可见并防止交互。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The screens.</figcaption></figure><p id="dd7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何时候都有一个活动屏幕。对于这个屏幕，让我们将<code class="fe me mf mg mh b">opacity</code>设置为<code class="fe me mf mg mh b">1</code>并将<code class="fe me mf mg mh b">pointer-events</code>设置为<code class="fe me mf mg mh b">auto</code>。这样，活动页面将是可见的和可点击的。我们对活跃和不活跃的风格都使用了过渡来平滑地淡入淡出屏幕。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Web app active screen CSS.</figcaption></figure><p id="5088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个应用程序中，每个屏幕都有一个基于其ID的独特背景颜色。</p><pre class="mi mj mk ml gt ob mh oc od aw oe bi"><span id="07a6" class="no lc iq mh b gy of og l oh oi">#screen_one_path {<br/>  background-color: #B1D4E0;<br/>}<br/>#screen_two_path {<br/>  background-color: #e0bbe4;<br/>}<br/>#screen_three_path {<br/>  background-color: #d7ecd9;<br/>}</span></pre><h2 id="bac2" class="no lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated">屏幕内容</h2><p id="9346" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在每个屏幕中，都有需要进行样式化的内容。每个屏幕上的<code class="fe me mf mg mh b">&lt;h2&gt;</code>元素被设计成顶部蓝色条，带有白色文本。此外还有<code class="fe me mf mg mh b">.ui-content</code>的样式，它将包含屏幕的主要内容。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The styles for the screen elements.</figcaption></figure><p id="9577" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导航链接是用FlexBox设计的，看起来像按钮。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oa mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The CSS for the links</figcaption></figure><p id="70a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！这就是CSS。下面是一个演示供您再次回顾。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f27b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经做到了这一步，祝贺你！您已经为多屏幕web应用程序构建了一个可扩展的库，并且启动了一个漂亮的小演示。花一分钟庆祝你的成就。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/0ac7aad4e791fd94941a5b5e2535a5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjUf51XIJt3mSWEcS-aZzA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.freepik.com/vectors/snow" rel="noopener ugc nofollow" target="_blank">Snow vector</a> created by <a class="ae kc" href="https://www.freepik.com/pch-vector" rel="noopener ugc nofollow" target="_blank">pch-vector </a>— <a class="ae kc" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">www.freepik.com</a></figcaption></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="4c55" class="lb lc iq bd ld le nj lg lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly bi translated">更进一步</h1><p id="bdd4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">扩展这个app的方法有很多，下面是几个建议。</p><ul class=""><li id="9d35" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">除了渐变过渡，尝试添加水平或垂直幻灯片过渡。</li><li id="d8fc" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">使用附加的屏幕回调函数扩展屏幕模板的类型。</li><li id="99c5" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">添加一个选项，以便在进入页面时刷新页面内容。</li><li id="7d63" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">除了<code class="fe me mf mg mh b">markup</code>和<code class="fe me mf mg mh b">nav</code>之外，向回调函数添加一些表单元素，并在库中为它们创建逻辑。例如，您可以添加启动特定功能的按钮。</li><li id="9573" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">使用该库的扩展版本来构建带有介绍、游戏和游戏屏幕的游戏应用程序。</li><li id="284d" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">向页面回调添加异步JSON请求，页面回调将在屏幕加载后向<code class="fe me mf mg mh b">.ui-content</code>注入内容。</li></ul><p id="35a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有兴趣看看我是如何做到以上任何一点的，请在评论中告诉我。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="86c4" class="lb lc iq bd ld le nj lg lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly bi translated">在别处</h1><p id="fba3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">虽然这里构建的库完全不依赖于Drupal，但代码借用了Tyler Frankenstein的Drupal gap 7 API的技术和语法，这是一个为连接Drupal 7网站的应用程序设计的框架。</p><div class="om on gp gr oo op"><a href="http://docs.drupalgap.org/7/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">介绍</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">用于Drupal网站的开源应用程序开发工具包。用一组代码构建定制应用，然后…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">docs.drupalgap.org</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd jw op"/></div></div></a></div><p id="1df1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是另一篇您可能会觉得有用的JavaScript文章。</p><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-closures-and-their-scope-bubbles-a6bef7a4824e"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">JavaScript闭包及其范围气泡</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">它们随处可见，可以帮助您构建大型应用程序。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd jw op"/></div></div></a></div><p id="36f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="pf">更多内容看</em> <a class="ae kc" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pf">说白了. io </em> </strong> </a> <strong class="kf ir"> <em class="pf">。</em> </strong> <em class="pf">为无限制访问我的文章，考虑</em> <a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"> <strong class="kf ir"> <em class="pf">加盟中</em> </strong> </a> <strong class="kf ir"> <em class="pf">。</em> </strong></p></div></div>    
</body>
</html>