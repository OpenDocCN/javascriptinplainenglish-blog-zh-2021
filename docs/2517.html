<html>
<head>
<title>How to Stop Jest Tests from Hanging in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何阻止Jest测试挂在角上</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-stop-jest-tests-from-hanging-in-angular-7302b35ac788?source=collection_archive---------4-----------------------#2021-05-24">https://javascript.plainenglish.io/how-to-stop-jest-tests-from-hanging-in-angular-7302b35ac788?source=collection_archive---------4-----------------------#2021-05-24</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="23bc" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">用模拟服务对组件进行单元测试</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/6cc138a9b9bd769967543d9427cb6524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eeMIwrpAafG8leCm"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maxwell Nelson</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="73fc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在我当前的项目中，我们使用Jenkins运行了许多构建:连续的和手动的。一个必需的步骤是断言在我们的Angular应用程序可以部署到AWS之前，我们所有的Jest单元测试都通过了。这个过程可能需要几分钟，当开始一个构建，去洗手间或喝咖啡休息，然后回到一个失败的构建，甚至更糟糕的是，一个挂起的构建时，这个过程可能会变得令人沮丧。前者通常更直截了当地指出哪里出了问题，但后者却令人沮丧和困惑。</p><h2 id="0f15" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">嘲弄服务</h2><p id="8108" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">组件单元测试的一个关键方面是模拟服务调用。这有助于只隔离出有问题的类的功能。其机制是用测试床配置中的模拟对应物覆盖服务。这是一个尝试从登录服务及其相应的spec测试中检索用户数据的基本组件。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">home.component.ts</figcaption></figure><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">home.component.spec.ts</figcaption></figure><p id="fae8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在spec测试中，LoginService正在被模拟，但是它的getUserDataObservable函数尚未被覆盖。这似乎在Jest中创造了一种奇怪的情况。当运行单元测试时，我们得到这个神秘的错误，并且测试无限期地挂起。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Jest hanging error</figcaption></figure><p id="d116" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">该错误没有指出问题发生在哪里；没有有用的堆栈错误。我求助于试错法，发现一个未锁定的服务方法导致了这个问题。</p><p id="c43d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过向LoginServiceMock中添加一个getUserDataObservable mock函数，这个特殊的spec测试很容易解决。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><p id="7b93" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不幸的是，对于具有几个模拟服务的大型组件来说，忽略了哪个或哪些方法并不明显。当运行多个测试套件时，这个问题变得更加复杂，示例输出如下。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Multiple test suites running</figcaption></figure><p id="ad9b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在运行状态停止切换到通过之前，一切看起来都很好。时间流逝，但没有错误，直到一分钟左右，可怕的圆形对象错误才出现。这个问题的快速谷歌搜索告诉我们，一些对象正在引用自己，但我们甚至不知道这是指什么对象。经过深入研究，我们终于找到了这个谜的答案。</p><h2 id="8e2a" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">Jest选项</h2><p id="9be3" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">可取之处是一个叫做<strong class="kz is"> <em class="mt">的玩笑标志。</em> </strong>如果你在<a class="ae kw" href="https://jestjs.io/docs/cli#--detectopenhandles" rel="noopener ugc nofollow" target="_blank"> Jest文档</a>中查找，你会看到以下描述:</p><blockquote class="mu mv mw"><p id="1278" class="kx ky mt kz b la lb js lc ld le jv lf mx lh li lj my ll lm ln mz lp lq lr ls ik bi translated"><code class="fe na nb nc nd b">--detectOpenHandles</code></p><p id="d808" class="kx ky mt kz b la lb js lc ld le jv lf mx lh li lj my ll lm ln mz lp lq lr ls ik bi translated">尝试收集和打印开放句柄，防止Jest干净地退出。在需要使用<code class="fe na nb nc nd b">--forceExit</code>来让Jest退出以潜在地追踪原因的情况下使用这个。这意味着<code class="fe na nb nc nd b">--runInBand</code>，让测试连续运行。使用<code class="fe na nb nc nd b"><a class="ae kw" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank">async_hooks</a></code>实现。此选项对性能有很大影响，应仅用于调试。</p></blockquote><p id="11f4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">性能警告令人生畏，但值得一试，看看这是否有助于解决我们的问题。某些东西无疑阻止了我们的Jest测试正确退出，为什么不呢？</p><p id="815e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在将它添加到我们的package.json测试脚本之后</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ne"><img src="../Images/c15d68b5f84636dc83771d35ccbca751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKlODRdE8XykwOQgAlKAPQ.png"/></div></div></figure><p id="ead1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">运行之前冻结的相同单元测试，现在显示一个实际上有意义的错误。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Jest undefined function error</figcaption></figure><p id="940b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个错误比我们上次看到的圆形物体有用得多。</p><blockquote class="nf"><p id="48b6" class="ng nh ir bd ni nj nk nl nm nn no ls dk translated">我一生中从未如此高兴地看到堆栈跟踪。</p></blockquote><p id="ae81" class="pw-post-body-paragraph kx ky ir kz b la np js lc ld nq jv lf lg nr li lj lk ns lm ln lo nt lq lr ls ik bi translated">更令人鼓舞的是，我们的单元测试将会完成，我们的Jenkins构建实际上能够提供一个失败的状态。</p><p id="d3ff" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在建议你不要过多的使用这个旗帜，但是我们决定把它留在我们的詹金斯版本中。即使使用我们的<strong class="kz is"> 160个测试套件和近600个测试</strong>，我们也没有发现任何严重的性能下降。错误处理的好处和使用detectOpenHandles节省的时间是值得的。</p><p id="b3a7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个选项肯定可以防止将来浪费编码周期来追踪不正确定义的模拟。当然，如果你勤于嘲讽，并且经常在本地测试，那么你可能永远都不需要使用它。大多数开发人员全神贯注于他们的应用程序代码，单元测试往往会落后。当他们这样做的时候，你就会进入这种悬着的状态，你会感激有这面旗帜在你的支配之下。好在我们没有在这个问题上纠结太久。</p><p id="830b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">希望这有助于把你从我们面临的烦恼中解救出来。</p></div><div class="ab cl nu nv hv nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ik il im in io"><h2 id="9118" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">2021年4月8日更新</h2><p id="5808" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">自从写这篇文章以来，我的项目现在有<strong class="kz is"> 174个测试套件和2813个测试</strong>。我们一直很忙！我相信我们达到了大约1500到2000次测试的性能阈值，其中detectOpenHandles确实产生了很大的影响。下面是一些用于比较的运行时间。</p><pre class="kh ki kj kk gu ob nd oc od aw oe bi"><span id="759c" class="lt lu ir nd b gz of og l oh oi"><strong class="nd is">WITH detectOpenHandles - sequential</strong><br/>Test Suites: 174 passed, 174 total<br/>Tests:       2813 passed, 2813 total<br/>Snapshots:   0 total<br/><strong class="nd is">Time:        1398.452 s</strong></span><span id="b14b" class="lt lu ir nd b gz oj og l oh oi"><strong class="nd is">WITHOUT detectOpenHandles - parallel<br/></strong>Test Suites: 174 passed, 174 total<br/>Tests:       2813 passed, 2813 total<br/>Snapshots:   0 total<br/><strong class="nd is">Time:        489.689s</strong></span></pre><p id="0e83" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">至少他们的文档是准确的。我更新了我们的詹金斯配置，以便能够打开/关闭标志。</p><p id="1a6c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="mt">更多内容请看</em><a class="ae kw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mt">plain English . io</em></a></p></div></div>    
</body>
</html>