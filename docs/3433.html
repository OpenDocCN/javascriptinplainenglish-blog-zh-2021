<html>
<head>
<title>Programming Fundamentals: Basics of Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程基础:堆栈基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stack-basics-f389f06bfbf0?source=collection_archive---------15-----------------------#2021-07-11">https://javascript.plainenglish.io/stack-basics-f389f06bfbf0?source=collection_archive---------15-----------------------#2021-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/97518b7c235cb51b3e6a3926d5ed27ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5vfGNzJEl5QNuWUD.jpg"/></div></div></figure><p id="5ff3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">算法和数据结构是编程的基础部分。知道你将在什么时候使用什么数据结构是很重要的，所以在这篇博客中，我将介绍栈数据结构的基本原理。</p><h2 id="74bf" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">什么是堆栈？🤔</h2><p id="b286" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">栈只是一个有限制的数组。这是一个处理临时数据的优秀工具，它专注于处理数据的顺序。</p><p id="a36f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">堆栈是一种线性数据结构，遵循后进先出(LIFO)或先入后出(FILO)的性能顺序。</p><p id="6d32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以想象的最好的方法是用一些薄煎饼！</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/50b3c5ac43d38a6a50f4fdb14de1a338.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*EQHYfmF6lT8l9duG.gif"/></div></figure><p id="0712" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像小火龙一样，做煎饼时，我们倾向于在上菜前把它们堆成一座塔。不过，先吃哪种煎饼呢？答案很简单——最后做好的煎饼，放在煎饼堆上。换句话说，堆叠的最后一个薄饼是供应的第一个薄饼，制作的第一个薄饼是供应的最后一个薄饼(后进先出或先入后出)。</p><h2 id="b004" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">显现💭</h2><p id="a2ca" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">现在，让我们用一个数组来看这个问题，将堆栈视为垂直数组，如下所示:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/1f61f19680036ee62ef2c5a6b0d2de84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2pQ2BpMjzl5vVVUQ"/></div></div></figure><p id="0981" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们看到从水平到垂直的转换时，很明显数组中的第一项现在是堆栈的底部，而数组中的最后一项现在是顶部。</p><p id="ecc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们通过可视化一个空栈来看看栈的运行，我们如何添加元素以及如何删除它们。</p><h2 id="cf6c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">推到堆栈上🤚🏼</h2><p id="b075" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们将从一个空栈开始，看看我们是如何向它们添加内容的。为了添加到堆栈中，我们<em class="lr">按下</em>，这意味着将值插入到堆栈中，这里我们将5推送到堆栈中:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/9b5c073b0f598e2d354b9296c66c42a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZyX5S25i0WaZclkO"/></div></div></figure><p id="f691" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将插入一个3，然后一个0，就像这样:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/0d279985672294c01821dc92d5de1716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kRsbUKYrZu91oa4j"/></div></div></figure><p id="c3c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次我们添加一个元素，或者<em class="lr">把</em>元素放到堆栈中，我们就把它们放在堆栈的顶部。这意味着，如果我们想在中间或底部添加0，我们不能这样做。</p><h2 id="c218" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">从堆栈中弹出🍾</h2><p id="1d9e" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">当我们从堆栈中移除元素时，我们称之为<em class="lr">从堆栈中弹出</em>。我们将使用前面的例子来显示元素被删除的顺序。</p><p id="e100" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们只能移除顶部的元素，因为堆栈遵循LIFO/FILO原则。因此，我们唯一可以<em class="lr">弹出</em>的元素是0，如下所示:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/5bf41606f4f1d3257bbfacb1a2442985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5ycsenqrFGOuSnJr"/></div></div></figure><p id="91b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们只剩下两个元素，我们唯一可以去掉的是3，就像这样:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/59ced9494f4c669dae8cb69b08fa2f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IIheE75TRNCylk9g"/></div></div></figure><p id="ace1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这能让您很好地理解什么是栈，以及如何在处理临时数据时看到好处。</p></div></div>    
</body>
</html>