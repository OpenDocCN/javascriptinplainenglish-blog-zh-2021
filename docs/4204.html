<html>
<head>
<title>Mastering Asynchronous Code in Javascript: A Guide to Callbacks, Promises, and Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Javascript中的异步代码:回调、承诺和异步/等待指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-callbacks-promises-async-await-3eb835ed76b2?source=collection_archive---------16-----------------------#2021-08-20">https://javascript.plainenglish.io/javascript-callbacks-promises-async-await-3eb835ed76b2?source=collection_archive---------16-----------------------#2021-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript最重要的特性之一是支持异步编程。JavaScript提供了几种处理异步代码的方法，包括回调、承诺和async/await。在本文中，我们将探索这些方法，并学习如何有效地使用它们。</p><h2 id="9d6c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">同步/异步</h2><p id="ec1c" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">在同步编程中，父进程将等待子进程完成后再继续。相反，在异步模式下，父进程不会等待子进程完成。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/0b2412cda9420245c5822be5d9fd339c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*a3OgwgyZfqbYd9AZBZwU7g.gif"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Sync — Async</figcaption></figure><h2 id="01ff" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">异步的优点和缺点</h2><p id="392c" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">异步编程的好处是您可以运行多个进程，而无需相互等待。</p><p id="5c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，也有一个缺点:如果操作之间存在依赖关系，则相关流程可能会在完成相关流程之前运行。</p><p id="cb36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用一个简单的例子来解释一下。假设您需要显示学生的详细信息，这涉及两个操作，</p><ul class=""><li id="a984" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">获取分数(子过程)—它在2秒钟内完成</li><li id="2f13" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">显示学生数据(主流程)—它在1秒钟内完成</li></ul><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="dee8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mp"><img src="../Images/e01e8ffa348123aff48550468f76ed80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cD1RM0VQpnTLo_s06tWw-w.png"/></div></div></figure><p id="a471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mq">成绩</em>显示为<em class="mq">未定义</em>的原因是<strong class="jp ir"> <em class="mq">显示学生数据</em> </strong>在<strong class="jp ir"> <em class="mq">计算成绩</em> </strong>完成之前完成。</p><p id="197a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何解决这个问题？你答对了，答案是<strong class="jp ir">回调</strong></p><h2 id="f349" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">回调</strong></h2><p id="0ea0" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">回调是作为参数传递给另一个函数的函数。当父方法依赖于子方法返回时，回调是控制异步调用的方法。</p><p id="c7ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的例子，<strong class="jp ir"><em class="mq">displayStudentData</em></strong>是<strong class="jp ir"> <em class="mq"> </em> </strong>依赖于<strong class="jp ir"><em class="mq">calculated grade</em></strong>返回。<strong class="jp ir"><em class="mq">displayStudentData</em></strong>可以传递给<strong class="jp ir"><em class="mq">calculate grade</em></strong>作为回调，在成绩计算后调用。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，由于回调，分数细节将按预期显示。</p><p id="e6f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mp"><img src="../Images/8ab5649b616a7da2bb7314c35186e45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY0QEZqbSXiEIw8i0K-lzQ.png"/></div></div></figure><h2 id="a68f" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">回调地狱</h2><p id="7e17" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">当我们有一个异步调用时，回调是好的。但是你不能在函数中停止现实世界中的多个异步调用。当你进行大量的回调时，你的代码会变得混乱和难以阅读。在JavaScript中，当有多个回调<strong class="jp ir">时，我们称之为回调地狱。</strong></p><p id="5857" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何解决这个问题？你答对了，答案是<strong class="jp ir">承诺</strong></p><h2 id="9a44" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">承诺</h2><p id="5310" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">ES6中引入了更优雅地处理异步编程的承诺。</p><p id="ae6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的示例中，我们可以将<strong class="jp ir"> <em class="mq"> calculateGrade </em> </strong>更改为return Promise，并在<strong class="jp ir"> <em class="mq"> calculateGrade被</em> </strong>解析后调用<strong class="jp ir"> displayStudentData </strong>。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e4cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mq">注意:</em> </strong> <em class="mq">为了简单起见，我在上面的代码中没有处理reject。</em></p><p id="97a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mp"><img src="../Images/8ab5649b616a7da2bb7314c35186e45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY0QEZqbSXiEIw8i0K-lzQ.png"/></div></div></figure><h2 id="043b" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">异步/等待</h2><p id="3276" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">Async / Await是处理来自<strong class="jp ir">承诺</strong>的响应的另一种方式。</p><p id="3338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用<em class="mq">等待</em>，该功能应声明为<em class="mq">同步</em>。下面的代码将解释如何使用Async / Await来处理承诺。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0cd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mp"><img src="../Images/8ab5649b616a7da2bb7314c35186e45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY0QEZqbSXiEIw8i0K-lzQ.png"/></div></div></figure><blockquote class="mr ms mt"><p id="d9f0" class="jn jo mq jp b jq jr js jt ju jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj kk ij bi translated">总之，回调、承诺和异步/等待是Javascript开发世界中的三个基本概念。它们各有优缺点，用于以不同的方式处理异步代码。虽然回调是引入的第一个概念，但promises和async/await是显著的改进，使Javascript中的异步代码更易于管理、可读和高效。</p></blockquote><p id="ea06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mq">更多内容请看</em><a class="ae mx" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mq">plain English . io</em></strong></a><em class="mq">。</em></p><p id="3966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mq">报名参加我们的</em> <a class="ae mx" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mq">免费每周简讯</em> </strong> </a> <em class="mq">。关注我们关于</em><a class="ae mx" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mq">Twitter</em></strong></a><a class="ae mx" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mq">LinkedIn</em></strong></a><em class="mq"/><a class="ae mx" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mq">YouTube</em></strong></a><em class="mq">和</em> <a class="ae mx" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mq">不和</em> </strong> </a> <strong class="jp ir">T77】</strong></p><p id="7bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mq">有兴趣缩放你的软件启动</em> </strong> <em class="mq">？检查</em> <a class="ae mx" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mq">电路</em> </strong> </a> <em class="mq">。</em></p></div></div>    
</body>
</html>