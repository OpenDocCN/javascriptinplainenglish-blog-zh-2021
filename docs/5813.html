<html>
<head>
<title>How to Duplicate an Array in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中复制数组？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-duplicate-an-array-in-javascript-446b8777a4ba?source=collection_archive---------1-----------------------#2021-12-11">https://javascript.plainenglish.io/how-to-duplicate-an-array-in-javascript-446b8777a4ba?source=collection_archive---------1-----------------------#2021-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ea88a5c74979c2d6e1c8d4fcfd8040cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rAiI_mYCab__o3uB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joe Green</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8c4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复制数组是我们在JavaScript应用程序中经常要做的事情。</p><p id="e3c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何在JavaScript中复制数组。</p><h1 id="235d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">环</h1><p id="2440" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">复制JavaScript数组的一种方法是使用循环。</p><p id="5dd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来使用for-of循环:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b91e" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = []</span><span id="ec77" class="mn lc iq mj b gy ms mp l mq mr">for (const a of arr) {<br/>  clone.push(a)<br/>}<br/>console.log(clone)</span></pre><p id="bc10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用for-of循环遍历<code class="fe mt mu mv mj b">arr</code>并调用<code class="fe mt mu mv mj b">clone</code>上的<code class="fe mt mu mv mj b">push</code>将条目添加到<code class="fe mt mu mv mj b">clone</code>中。</p><p id="b999" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此<code class="fe mt mu mv mj b">clone</code>应该和<code class="fe mt mu mv mj b">arr</code>有相同的条目。</p><p id="1182" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用while循环来遍历数组。</p><p id="e539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e1fd" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = []</span><span id="1d4d" class="mn lc iq mj b gy ms mp l mq mr">let i = 0;<br/>while (i &lt; arr.length) {<br/>  clone.push(arr[i])<br/>  i++<br/>}<br/>console.log(clone)</span></pre><p id="9f78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过方括号中的索引获取项目，并执行相同的<code class="fe mt mu mv mj b">push</code>操作。</p><p id="65fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们增加<code class="fe mt mu mv mj b">i</code>值，在下一次迭代中移动到下一个元素。</p><p id="2f52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用普通的for循环来做同样的事情:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c019" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = []</span><span id="da6c" class="mn lc iq mj b gy ms mp l mq mr">for (let i = 0; i &lt; arr.length; i++) {<br/>  clone.push(arr[i])<br/>}<br/>console.log(clone)</span></pre><p id="0f69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把改变索引的逻辑全部放在括号里。</p><h1 id="90de" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组.原型.切片</h1><p id="4a58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果没有传入参数，<code class="fe mt mu mv mj b">slice</code>方法将返回我们正在调用的数组的克隆。</p><p id="c618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b027" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = arr.slice()<br/>console.log(clone)</span></pre><p id="1753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了和以前一样的结果。</p><h1 id="7578" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组. from</h1><p id="9577" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">Array.from</code>方法是一个静态数组方法，它允许我们从另一个数组创建一个数组。</p><p id="b843" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以使用它来创建阵列的克隆。</p><p id="4b80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的第一个参数是一个数组或一个类似数组的对象，我们希望从它创建派生数组。</p><p id="11a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是一个函数，它让我们映射第一个参数中的对象或数组的值，并将它们映射到不同的值。</p><p id="6cff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="03c7" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = Array.from(arr, a =&gt; a)<br/>console.log(clone)</span></pre><p id="53ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">arr</code>数组调用<code class="fe mt mu mv mj b">Array.from</code>。</p><p id="8373" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数只是原样返回值。</p><p id="42f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们得到了和上一个例子一样的结果。</p><h1 id="3a35" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组.原型.串联</h1><p id="7bfa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">concat</code> array实例方法也通过将它所调用的数组与我们传递给参数的数组相结合来返回一个数组。</p><p id="6e33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，要使用它来克隆一个数组，我们可以编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8fb8" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = arr.concat([])<br/>console.log(clone)</span></pre><p id="3124" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0092" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = [].concat(arr)<br/>console.log(clone)</span></pre><p id="6d39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺序无关紧要，因为我们只有<code class="fe mt mu mv mj b">arr</code>和一个空数组。</p><p id="aaea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪种方式，我们都会返回一个<code class="fe mt mu mv mj b">arr</code>的克隆。</p><h1 id="dd0a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">传播算子</h1><p id="958c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">spread操作符还允许我们复制一个数组。</p><p id="e66f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c87d" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = [...arr]<br/>console.log(clone)</span></pre><p id="67ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用扩展运算符克隆<code class="fe mt mu mv mj b">arr</code>。</p><p id="32b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们得到了和前面例子一样的结果。</p><h1 id="625a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组.原型.地图</h1><p id="c2ed" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">map</code>方法让我们返回一个数组，该数组包含从原始数组映射而来的值。</p><p id="c223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要返回原始数组的克隆，我们只需传入一个回调函数，该函数按原样返回被迭代的值。</p><p id="8b1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2255" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3]<br/>const clone = arr.map(a =&gt; a)<br/>console.log(clone)</span></pre><p id="01d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用一个调用来调用<code class="fe mt mu mv mj b">map</code>,该调用返回按原样迭代的值。</p><p id="1eb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了和以前一样的结果。</p><h1 id="46b8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d922" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用JavaScript克隆数组有很多方法。</p><p id="81aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最简单的方法是使用spread运算符。</p><p id="1a3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也很快。</p><p id="5947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容看</em> <a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">说白了. io </em> </strong> </a> <strong class="kf ir"> <em class="mw">。</em> </strong> <em class="mw">报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">免费每周简讯这里</em> </strong> </a> <strong class="kf ir"> <em class="mw">。</em>T24】</strong></p></div></div>    
</body>
</html>