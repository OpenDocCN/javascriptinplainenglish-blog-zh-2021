<html>
<head>
<title>How Recursion Interacts with the Call Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归如何与调用堆栈交互</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recursion-call-stack-c7f2d332547f?source=collection_archive---------0-----------------------#2021-04-26">https://javascript.plainenglish.io/recursion-call-stack-c7f2d332547f?source=collection_archive---------0-----------------------#2021-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/39023354443b551f9d319f684ab63d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iGEaoCg215cbL9q9.jpg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by Scanrail</figcaption></figure><p id="766b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">许多人努力理解递归——这是完全自然的，我相信这是由于缺乏对一些关键基础知识的理解。</p><p id="60ef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在本文中，我将从一个更广阔的角度来解释递归:展示递归代码如何工作以及如何与内存交互。</p><h2 id="dca8" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">简介</strong></h2><p id="bd8c" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">首先，让我们看一个关于递归的简单介绍:递归只是一个引用自身的函数。斐波那契数列就是一个例子。注意同一个<strong class="kb io">斐波那契</strong>函数是如何被调用两次<em class="lv">(第4行)</em>:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">code 1 — fibonacci recursive</figcaption></figure><h2 id="ce9f" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">优点</strong></h2><p id="1fd2" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">递归适用于使用分而治之原则的重复性子问题。常见的例子有:遍历树、图、排序、搜索等。</p><p id="aefe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一个优点是递归代码可以更清晰易读<em class="lv">(对某些人来说有争议)</em>。看看斐波那契<em class="lv">(代码2) </em>的迭代方法如何比递归的<em class="lv">(代码1) </em>更加冗长:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">code 2 — fibonacci iterative</figcaption></figure><h2 id="2f70" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">缺点</strong></h2><p id="7e15" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">另一方面，递归代码可能很难理解<em class="lv">(至少最初是这样)</em>。虽然斐波那契递归<em class="lv">(代码1) </em>显然很短，但理解它可能需要一些时间。</p><p id="6a85" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，递归会消耗更多的内存，并可能运行溢出的程序:堆栈溢出错误。</p><p id="02a4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">理解堆栈溢出是理解递归如何工作的关键，所以让我们更详细地看看它。</p><p id="3e55" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意:有一些方法可以减轻这个问题，比如使用记忆化或者尾部递归，这样你就可以在之后深入研究。</p><h2 id="2546" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">堆栈溢出</h2><p id="17de" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">当程序超出内存中的调用堆栈空间时，就会发生堆栈溢出错误，这主要是由递归代码引起的。</p><p id="e1bf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们创建一个强制堆栈溢出的简单程序:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">code 3 — loop</figcaption></figure><p id="1d0a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">函数<strong class="kb io"> <em class="lv">循环</em> </strong>只是不停地调用自己<em class="lv">(第2行)</em>，导致无限循环，直到调用堆栈达到其极限，因此得到堆栈溢出“<strong class="kb io">最大调用堆栈大小超过</strong>”</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/4445bbc96d1d20c23367c6476ae8d540.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*dHHfhZcU1zn3KMYBlQvrvA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image 1— Stack overflow error</figcaption></figure><p id="fa82" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个调用堆栈位于虚拟内存中，为了更好地理解它是什么以及它是如何工作的，我将提供一个关于虚拟内存主要部分的简要说明。</p><h2 id="45bc" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">虚拟内存</strong></h2><p id="3ab0" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">下图显示了一个程序在虚拟内存中的样子:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/b3426a5209b82ae9ac09bb335cece907.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*CtUewVZKEbLZApbG783sPw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image 2 — Memory segment</figcaption></figure><ul class=""><li id="17a7" class="me mf in kb b kc kd kg kh kk mg ko mh ks mi kw mj mk ml mm bi translated"><strong class="kb io">文本</strong>:文本也称为代码，是内存中包含程序可执行指令的部分。</li><li id="77ec" class="me mf in kb b kc mn kg mo kk mp ko mq ks mr kw mj mk ml mm bi translated"><strong class="kb io">数据</strong>:包含全局、静态、环境变量等的段。</li><li id="d615" class="me mf in kb b kc mn kg mo kk mp ko mq ks mr kw mj mk ml mm bi translated"><strong class="kb io"><em class="lv">heap</em></strong><em class="lv">:</em>heap存储动态数据、复杂对象以及你的大部分程序需要的数据。这是通过<em class="lv">系统调用</em>分配的，是内存碎片、泄漏发生的地方，也是垃圾收集器发生的地方。</li><li id="c19c" class="me mf in kb b kc mn kg mo kk mp ko mq ks mr kw mj mk ml mm bi translated"><strong class="kb io">堆栈</strong>:也称为<em class="lv">调用堆栈</em>跟踪程序的执行情况。它的大小非常有限，用于存储局部变量和局部函数。<em class="lv">调用栈</em>使用<strong class="kb io">栈</strong>数据结构，遵循后进先出原则(后进先出)。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/fd4b13d28d1ccc47cc3cbcea0c381818.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*vhsMnJ4vErbnaJ98OCl__g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image 3— Stack data structure</figcaption></figure><h2 id="0516" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">程序执行</strong></h2><p id="8faf" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">是时候看看程序如何使用调用堆栈了。考虑以下代码:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">code 3 — simple program</figcaption></figure><p id="1f1b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是程序执行的方式<em class="lv">(图4) </em>，注意函数是如何在调用堆栈中堆积的:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/a6c8be4b02f680429b310d3b595f36e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*9XraAfSNlIj0jzgz.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image 4 — How program gets executed in call stack</figcaption></figure><p id="0f81" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">程序开始调用<strong class="kb io">"<em class="lv">my functiona</em>"</strong><em class="lv">(第18行)</em>，因此在存储局部变量<strong class="kb io"><em class="lv">" frameA】</em></strong>(<em class="lv">第2行</em>)的调用栈中为该函数创建了一个栈帧。然后，<strong class="kb io"><em class="lv">my functiona</em></strong>调用<strong class="kb io"><em class="lv">my functionb</em></strong><em class="lv">(第3行)</em>。</p><p id="6c2c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">创建了一个新的堆栈帧，它存储了<strong class="kb io"><em class="lv">帧b</em></strong>变量<em class="lv">(第8行)</em>。然后，<strong class="kb io"><em class="lv">my functionb</em></strong>调用<strong class="kb io"><em class="lv">【my functionc】</em></strong><em class="lv">(第9行)</em>。</p><p id="a063" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">再次创建另一个堆栈帧，存储<strong class="kb io"> " <em class="lv"> frameC </em> " </strong>局部变量<em class="lv">(第14行)</em>。现在，在<strong class="kb io">"<em class="lv">my function C</em>"</strong>"<strong class="kb io">"<em class="lv">frameC</em>"</strong>变量中打印出了相应的值<strong class="kb io"><em class="lv">【C】</em></strong><em class="lv">(第15行)</em>。</p><p id="5507" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，<strong class="kb io"><em class="lv">【my functionc】</em></strong>结束，相应的堆栈帧从调用堆栈中删除。此时，执行返回到<strong class="kb io"><em class="lv">【myFunctionB】</em></strong>，打印<strong class="kb io"><em class="lv">【B】</em></strong><em class="lv">(第10行)</em>，然后从堆栈中删除。</p><p id="a4df" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，执行返回打印<strong class="kb io"><em class="lv">【A】</em></strong><em class="lv">(第4行)</em>的<strong class="kb io"><em class="lv">【my functiona】</em></strong>，程序结束。</p><p id="cc94" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="lv">注:这只是一个不考虑编程语言的简化解释。使用C或Java，第一个堆栈框架将是“main()”。</em></p><h2 id="5129" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">递归的基本情况</strong></h2><p id="7006" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">回到递归——每个递归代码都需要一个<strong class="kb io">基础用例</strong>、<strong class="kb io">和</strong>，这基本上意味着一个“停止”条件。否则，递归函数将一直调用自己，直到抛出堆栈溢出错误。</p><p id="1217" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">例如:计算机递归地搜索文件，一个基本情况是:<strong class="kb io">当没有更多子文件夹时停止搜索，或者文件被找到</strong>。</p><ul class=""><li id="85b9" class="me mf in kb b kc kd kg kh kk mg ko mh ks mi kw mj mk ml mm bi translated">递归情况:函数调用自身的情况。</li><li id="4906" class="me mf in kb b kc mn kg mo kk mp ko mq ks mr kw mj mk ml mm bi translated">需要时返回:如果需要，组合不同堆栈帧的结果。</li></ul><h2 id="8d35" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">实施基础案例</strong></h2><p id="9d2f" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">现在，让我们为<strong class="kb io">循环</strong>函数<em class="lv">(代码3) </em>实现一个基础用例，在这里我们有目的地创建了一个堆栈溢出。</p><p id="9466" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以创建一个名为<strong class="kb io"> counter </strong>的变量，如果<strong class="kb io"> counter </strong>大于2，就会返回字符串<strong class="kb io"><em class="lv">“exiting”</em></strong>(基本情况)。否则，它将递增计数器并再次调用<strong class="kb io">循环</strong>。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">code 4 — loop with base case</figcaption></figure><p id="7b9c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">基本情况是基本的，但足以让我们理解递归中基本情况的重要性。<em class="lv">注意:为了简单起见，counter被定义为一个全局变量。通常，在递归中，变量必须作为参数传递。</em></p><p id="8dac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过执行这段代码，我们可以注意到代码显然已经结束，但是我们收到的是<strong class="kb io"> <em class="lv">【未定义】</em> </strong>，而不是<strong class="kb io"> <em class="lv">【正在退出】</em> </strong>。这是为什么呢？</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6e5c18dea4fd3b17fe77b4c67d082803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*GH2Sa3vo9CCQgNpNnpjUCw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image 4— Implementing a base case</figcaption></figure><h2 id="5c8f" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">解释</strong></h2><p id="5fc9" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">让我们分析一下代码的执行情况:</p><p id="df56" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">程序启动并执行第一条指令<strong class="kb io"> <em class="lv"> console.log(loop())。</em> </strong></p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/33e8cd652f30e185c31683e25c83e09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*Rax2chD3JVlHJBkr3WuSxA.gif"/></div></figure><p id="a8e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">S1:堆栈帧S1被创建，<strong class="kb io">计数器</strong>为<strong class="kb io"> 0 </strong>所以它绕过了基本情况(计数器&gt; 2)，计数器递增，循环被调用。</p><p id="cfa9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">S2:堆栈帧S2被创建，<strong class="kb io">计数器</strong>为<strong class="kb io"> 1 </strong>所以它绕过了基本情况(计数器&gt; 2)，计数器递增，循环再次被调用。</p><p id="ac1a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">S3:堆栈帧S3被创建，<strong class="kb io">计数器</strong>为<strong class="kb io"> 2 </strong>所以它绕过了基本情况(计数器&gt; 2)，计数器递增，循环再次被调用。</p><p id="012b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">S4:栈帧S4被创建，<strong class="kb io">计数器</strong>为<strong class="kb io"> 3 </strong>并最终到达基格(计数器&gt; 2)，S4帧最终返回“退出”到S3。</p><p id="189b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">s3:在<strong class="kb io"> <em class="lv"> loop() </em> </strong>行中执行回到S3栈帧，即使S4返回“退出”给S3，S3也不返回任何东西。S3只是调用了<strong class="kb io"> <em class="lv"> loop() </em> </strong>和<strong class="kb io">对结果</strong>没有任何作用。<em class="lv">注意:在JavaScript中，一个不返回任何东西的函数会返回undefined。</em></p><p id="e942" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">s2:执行返回到<strong class="kb io"> <em class="lv"> loop() </em> </strong>行的S2堆栈帧，再次不返回任何内容。</p><p id="f7ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">S1:现在执行在S1堆栈框架，没有任何东西被返回。</p><p id="ffc8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以最后一条指令是一条<strong class="kb io"><em class="lv">console . log()</em></strong>带有S1的响应，其中<strong class="kb io"> <em class="lv">未定义</em> </strong>。</p><p id="8e72" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一种形象化问题的方法是:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/814f3922629e2556c9bdf3dc17095fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*CMELuPQH-iUz0pVU.gif"/></div></figure><h2 id="dd25" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated"><strong class="ak">解决方案</strong></h2><p id="e32c" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">因此，一旦我们到达基本情况，我们希望将<strong class="kb io"><em class="lv"/></strong>字符串向下传播到最末端，就像这样:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/520fe512921fd28e574a449589d5afc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*_I1GFzM9mEEHOvvukk3yBg.png"/></div></figure><p id="7811" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是我们在递归中必须记住的事情，我们通常有基本情况，我们需要确保递归情况<strong class="kb io">返回</strong>，所以我们想要的值会一直冒泡下去。</p><p id="a88e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我们的例子中，我们需要做的就是<strong class="kb io"> <em class="lv">返回循环()。</em> </strong>这样循环将结果<strong class="kb io"> <em class="lv">【退出】</em> </strong>，一直传播到第一个调用。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a584f1fee6bb5aa80dc64c22d0542bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*ALsJ0X2h-ic0yL5II7mP3A.gif"/></div></figure><ul class=""><li id="efb5" class="me mf in kb b kc kd kg kh kk mg ko mh ks mi kw mj mk ml mm bi translated">基本情况:退出递归代码的条件。</li><li id="c765" class="me mf in kb b kc mn kg mo kk mp ko mq ks mr kw mj mk ml mm bi translated">递归情况:函数调用自身的情况。</li><li id="f7a1" class="me mf in kb b kc mn kg mo kk mp ko mq ks mr kw mj mk ml mm bi translated">需要时返回:如果需要，组合不同堆栈帧的结果。</li></ul><p id="b432" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">总而言之，理解调用堆栈对于理解递归的工作原理是必不可少的。</p><p id="01a7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">仅此而已。希望这篇文章能帮助你更好地理解递归、内存和编程。请随时提供任何反馈。</p><p id="308e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae mx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">更多内容尽在plain English . io</em>T43】</a></p></div></div>    
</body>
</html>