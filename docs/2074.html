<html>
<head>
<title>How to Solve the LeetCode Algorithm Challenge: Search Insert Position</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决LeetCode算法的挑战:搜索插入位置</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-challenge-search-insert-position-cb3970fb3271?source=collection_archive---------11-----------------------#2021-05-02">https://javascript.plainenglish.io/leetcode-algorithm-challenge-search-insert-position-cb3970fb3271?source=collection_archive---------11-----------------------#2021-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ea2952d82539babe3cfad34023154459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvWPjN1N7-4IP8CRHWDx7g.png"/></div></div></figure><h1 id="e726" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">LeetCode算法挑战:搜索插入位置</h1><h1 id="cfb8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">问题</h1><p id="4a65" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">给定一个不同整数的排序数组和一个目标值，如果找到目标，则返回索引。如果没有，返回按顺序插入时的索引位置。</p><p id="774a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">实施例1: </strong></p><p id="3449" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">输入:</strong> nums = [1，3，5，6]，target = 5</p><p id="69f4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">产量:</strong> 2</p><p id="8df9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">实施例2: </strong></p><p id="0e52" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">输入:</strong> nums = [1，3，5，6]，target = 2</p><p id="cb07" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">输出:</strong> 1</p><p id="7a26" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">实施例3: </strong></p><p id="21fa" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">输入:</strong> nums = [1，3，5，6]，target = 7</p><p id="6493" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">输出:</strong> 4</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="3457" class="jv jw in bd jx jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks bi translated">挑战</h1><p id="74ef" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这个任务看起来很简单，乍一看，它可以通过indexOf方法来解决。但这种情况让它变得更加棘手——“如果找不到目标，请将索引返回到按顺序插入时的位置。”</p><p id="eeee" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们把它分解一下。</p><ol class=""><li id="6829" class="mi mj in kv b kw lr la ls le mk li ml lm mm lq mn mo mp mq bi translated">将nums阵列的每个元素与目标进行比较</li><li id="c140" class="mi mj in kv b kw mr la ms le mt li mu lm mv lq mn mo mp mq bi translated">如果匹配，则返回匹配元素的索引</li><li id="cd4f" class="mi mj in kv b kw mr la ms le mt li mu lm mv lq mn mo mp mq bi translated">如果元素不匹配，检查下一个元素是否小于目标，如果不匹配，则返回下一个索引位置。</li><li id="5225" class="mi mj in kv b kw mr la ms le mt li mu lm mv lq mn mo mp mq bi translated">检查是否到达数组的末尾并返回位置</li></ol></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="3582" class="jv jw in bd jx jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks bi translated">让我们编码</h1><p id="67f6" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">对于设置，我将需要2个变量:</p><p id="ef41" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">位置—数组元素的位置、索引</p><p id="e19d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">结果—记录最终结果</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="125f" class="nf jw in nb b gy ng nh l ni nj">let pos = 0;</span><span id="f9d3" class="nf jw in nb b gy nk nh l ni nj">let result = 0;</span></pre><p id="2422" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在让我们检查是否需要深入我们的数组，因为如果数组的第一个元素比目标元素多，那么目标元素的索引应该是0。所以我们检查它并返回结果0。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="fa86" class="nf jw in nb b gy ng nh l ni nj">if (nums[0]&lt;target) {</span><span id="7fb2" class="nf jw in nb b gy nk nh l ni nj">  //* further calculations will be here</span><span id="8e74" class="nf jw in nb b gy nk nh l ni nj">}</span><span id="31e9" class="nf jw in nb b gy nk nh l ni nj">return result;</span></pre><p id="2052" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">是时候构建我们的递归函数了，不知何故，我一直在使用它们。我的find函数将接受3个参数:</p><ol class=""><li id="24b0" class="mi mj in kv b kw lr la ls le mk li ml lm mm lq mn mo mp mq bi translated">nums —原始阵列</li><li id="d2d8" class="mi mj in kv b kw mr la ms le mt li mu lm mv lq mn mo mp mq bi translated">目标—原始目标</li><li id="782f" class="mi mj in kv b kw mr la ms le mt li mu lm mv lq mn mo mp mq bi translated">pos —数组元素的索引/位置</li></ol><p id="40b9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">将if语句与以下步骤结合使用。首先，我们将数组的元素与目标进行比较。如果我们找到了匹配项，我们的结果应该等于当前pos。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="95d6" class="nf jw in nb b gy ng nh l ni nj">if (nums[pos]===target) {</span><span id="ed51" class="nf jw in nb b gy nk nh l ni nj">  result = pos;</span><span id="86e4" class="nf jw in nb b gy nk nh l ni nj">}</span></pre><p id="a439" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">否则，我将使用else-如果有或条件。如果数组的下一个元素多于目标，这意味着目标应该占据下一个元素的位置，或者如果我们已经到达数组的末尾并且没有找到匹配的元素，那么目标应该在数组的末尾。因此，这两种情况都会产生相同的结果。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="1cb7" class="nf jw in nb b gy ng nh l ni nj">else if (nums[pos+1]&gt; target || pos+1===nums.length) {</span><span id="8d36" class="nf jw in nb b gy nk nh l ni nj">  result = pos+1;</span><span id="443b" class="nf jw in nb b gy nk nh l ni nj">}</span></pre><p id="8061" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">最后，如果以上条件都不起作用，我们将移动到数组的下一个元素，并使用更新的pos参数执行find。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e709" class="nf jw in nb b gy ng nh l ni nj">else {</span><span id="f9fd" class="nf jw in nb b gy nk nh l ni nj">  pos++;</span><span id="9192" class="nf jw in nb b gy nk nh l ni nj">  find(nums,target,pos)</span><span id="cfa2" class="nf jw in nb b gy nk nh l ni nj">}</span></pre></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><p id="1e53" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这是一个非常有趣的练习，但我找到了一个更快的解决方案。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0489" class="nf jw in nb b gy ng nh l ni nj">var searchInsert = function(nums, target) {</span><span id="2bdb" class="nf jw in nb b gy nk nh l ni nj">  let newArray = […nums, target].sort((a, b) =&gt; {return a — b})</span><span id="7a0f" class="nf jw in nb b gy nk nh l ni nj">  const position = newArray.indexOf(target)</span><span id="a87b" class="nf jw in nb b gy nk nh l ni nj">  return position</span><span id="093a" class="nf jw in nb b gy nk nh l ni nj">};</span></pre><p id="d867" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">哇，那是我的想法。像1，2，3一样简单。</p><ol class=""><li id="7c22" class="mi mj in kv b kw lr la ls le mk li ml lm mm lq mn mo mp mq bi translated">通过向新阵列添加目标来创建新阵列</li><li id="0ce5" class="mi mj in kv b kw mr la ms le mt li mu lm mv lq mn mo mp mq bi translated">对新创建的数组进行排序</li><li id="01b8" class="mi mj in kv b kw mr la ms le mt li mu lm mv lq mn mo mp mq bi translated">我之前提到了indexOf方法，现在我们可以使用它并返回结果。</li></ol></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="4fe6" class="jv jw in bd jx jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks bi translated">密码</h1><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><p id="2c38" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">不知何故，我陷入了递归函数，但有时有更简单的解决方案。将来，我应该试着找到它，而不仅仅是构建一个递归函数。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><p id="7095" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">请在以下社交网络上查看我，我很乐意收到您的来信！——<a class="ae no" href="https://www.linkedin.com/in/nick-solonyy/" rel="noopener ugc nofollow" target="_blank"><em class="nn">LinkedIn</em></a><em class="nn">，</em> <a class="ae no" href="https://github.com/nicksolony" rel="noopener ugc nofollow" target="_blank"> <em class="nn"> GitHub </em> </a>，<a class="ae no" href="https://www.facebook.com/nick.solony" rel="noopener ugc nofollow" target="_blank"> <em class="nn">脸书</em> </a> <em class="nn">。</em></p><p id="6b79" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><a class="ae no" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nn">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>