<html>
<head>
<title>A TypeScript Runtime Data Validators Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript运行时数据验证器比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-typescript-runtime-data-validators-comparison-67cb9abb599b?source=collection_archive---------10-----------------------#2021-03-17">https://javascript.plainenglish.io/a-typescript-runtime-data-validators-comparison-67cb9abb599b?source=collection_archive---------10-----------------------#2021-03-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="58c0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第7部分:上部结构</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9df6ed1e6acca6058c88ac7aeb75b0c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyztHsjC30RJafFKfiUx4g.jpeg"/></div></div></figure><p id="9418" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是基于我的实践经验的运行时数据验证器比较系列报告的第7篇。在继续本系列的其余部分之前，您应该阅读第一篇文章中的介绍，以理解制作该报告所涉及的目标和测试方法。</p><ol class=""><li id="b685" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-50a6abf3c559">简介</a></li><li id="effe" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-eeedc6b0583a"> io-ts </a></li><li id="c4bd" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-c422e431926a"> joi </a></li><li id="dda3" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-15f0ea2e3265">对</a></li><li id="0f65" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-cdbb532f0b89"> ajv </a></li><li id="436f" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">佐德</li><li id="442e" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">建于</li></ol><h1 id="9383" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">介绍</h1><p id="8e9b" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Superstruct是另一个新人，创建于2017年11月。它没有依赖性，压缩后的大小只有3.2 KB，是测试过的验证器中最小的包。后端和前端都可以用。</p><h1 id="0428" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">设计目标的实现</h1><h2 id="8d81" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">1.一个定义，多种用途—已实现</h2><p id="085f" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Superstruct用“结构”定义数据。最简单的结构是那些验证原始值的结构，比如字符串和数字。“细化”，如“大小”、“模式”，接受一个现有的结构，并创建一个新的结构，进一步在其上添加一些额外的验证。下面显示了“Person”模式是如何定义的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/42dc39d4461e4e19af6b014c2c1be813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3kQ-lqfaF8JilO2BsSbtQ.png"/></div></div></figure><p id="1e76" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Superstruct不使用fluent API(方法链)。相反，细化，例如用于定义“name”属性的“pattern”和“size ”,将另一个结构作为第一个参数，然后跟随其他参数。这种嵌套风格的麻烦之处在于嵌套的括号层，对于最外层的调用，例如“name”属性中的“pattern”细化，您需要跳过所有其他内部调用及其参数来找到它的另一个参数，即模式。</p><p id="0a07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">尽管如此，这只是有点烦人，但还不算太糟糕。</p><p id="433e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还要注意“性别”属性定义中的“<code class="fe nj nk nl nm b">as const</code>”，这是为了保留类型推断的文字值。</p><p id="0f1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Superstruct在类型推断方面做得非常出色。以下是车队的推断类型，测试项目中最复杂的数据。它是干净的，正确的，并且运行良好。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3b6004b08fe4539cd64eab90f420c316.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*vryxLTLPf0GXTuQ-eD2sKQ.png"/></div></figure><h2 id="0edb" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">2.可组合和可扩展的模式—已实现</h2><p id="53be" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">如下所示,“Driver”模式是通过扩展“Person”模式定义的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/fd20e612b3a7f1a3f749972c8989cbb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*WT1r03glz1lzkvOMxYdkZg.png"/></div></figure><p id="3944" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“车队”模式是通过组装“驾驶员”和“车辆”模式来定义的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/15a90160fcb96520f2e433a5a486a4a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*NaenUp8nbaTPdFg9YN6B8A.png"/></div></figure><h2 id="60fb" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">3.丰富的功能集—已实现</h2><p id="36cc" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Superstruct提供了丰富的现成功能集。</p><h2 id="42dd" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">4.完成和中止-早期验证-已实现</h2><p id="32b3" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">默认情况下，对于第一次遇到的失败，superstruct会抛出一个错误。error对象提供了一个生成器，然后可以迭代该生成器以检索更多的错误，直到完成完整的验证。这种“随需应变”的方法是非常聪明的设计。</p><p id="68a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是无效车队对象的验证结果的一部分。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/de8e050fa16a784dc340744383477f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6NYLZiIPKXhGl-BSuPbIw.png"/></div></div></figure><h2 id="c0e7" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">5.可组合和可定制—存档</h2><p id="16ba" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">如前所述，Superstruct使用“细化”来组合关键字。嵌套调用方式有点烦人，但还不算太糟糕。</p><p id="2548" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是PersonForm模式定义，带有一个自定义的“refine”来验证重复密码是否与密码相同。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/e6e3c59cf5f4e9135ac11cdf5cd96d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zY-_bVKedwg06xwyq12Ezw.png"/></div></div></figure><h2 id="19bc" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">6.类型强制和默认—已实现</h2><p id="a403" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Superstruct支持强制，即在验证输入数据之前对其进行转换。“默认”功能支持默认值功能。“强制”功能支持自定义强制或转换。它还提供了一个“trim”功能来确保输入字符串被修剪。因此，superstruct不仅适用于数据验证，也适用于数据转换。</p><p id="ec9e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有关定义自定义强制和默认值的示例，请参见上面Person模式中“dob”和“sex”属性的定义。</p><h2 id="09cc" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">7.可遍历模式—已实现</h2><p id="9a8e" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">很容易从结构(模式)中遍历和提取有用的信息。查看<code class="fe nj nk nl nm b">traversable.test.ts</code>测试案例了解更多详情。</p><h2 id="4ecc" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">8.标准—否</h2><h1 id="71c4" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">摘要</h1><p id="b7c8" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">我很高兴我在研究中遇到了Superstruct。它在各个方面都工作得很好。特别是，类型推理产生干净和正确的类型，工作得非常好。文件组织得很好。API设计经过深思熟虑，提供了极大的灵活性。它是用TypeScript写的，非常支持TypeScript。此外，它没有依赖性，大小只有3.2KB。我唯一的抱怨是嵌套调用方式有点烦人，但还不算太糟糕。</p><p id="bf2e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Zod或Superstruct可能是我下一个项目的选择。你的呢？</p></div></div>    
</body>
</html>