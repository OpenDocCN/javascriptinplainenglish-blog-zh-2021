<html>
<head>
<title>Understanding How Databases Store our Data: Introduction to LSM trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解数据库如何存储我们的数据:LSM树介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-how-databases-store-our-data-introduction-to-lsm-trees-ec1c46096570?source=collection_archive---------6-----------------------#2021-06-08">https://javascript.plainenglish.io/understanding-how-databases-store-our-data-introduction-to-lsm-trees-ec1c46096570?source=collection_archive---------6-----------------------#2021-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1e6324fd20c2fe61d22d6c5d3ccd714f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74ggnCxLUK2XVJvVjRimQw.png"/></div></div></figure><p id="fff3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“在当今世界，数据是储存在芯片上的黄金。”</p><p id="f22e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的生活依赖于数据。我们的社会活动，我们的运动，我们生活的每一个方面都被收集并存储在磁盘上。我们每天都在存储更多的数据。</p><p id="5fbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有没有想过，是什么让存储这么多数据变得更容易？显然，这是我们的数据库，但特别是数据库的<strong class="jx io">存储引擎，它在磁盘上存储数据，现在已经被改变，以处理这种巨大的数据流。<strong class="jx io">存储引擎是将数据存储到磁盘和从磁盘读取数据的数据库软件层。</strong></strong></p><p id="9cc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在早期，B+树是用于在磁盘上存储数据的默认数据结构。B+树的写复杂度是O(n log n ),因为在每次插入时，树会自我平衡以保持节点的正确顺序。但是随着数据接收的持续增长，我们遇到了B+树的性能问题。B+树不是写密集型应用程序的理想选择。LSM树<strong class="jx io">来了</strong>。LSM树是在一些数据库中实现的数据结构。像MongoDB，Cassandra等数据库。使用基于LSM树的存储引擎。LSM树是B+树的替代树，B+树用于在写入密集型应用程序中将数据存储在磁盘上。</p><h2 id="aa5a" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">但是，是什么让LSM树能够吸收海量数据呢？</h2><p id="aa63" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><strong class="jx io"> LSM树代表日志结构合并树</strong>。它们的工作原理是，所有要在数据库上执行的写操作都必须首先写在日志文件的底部。由于我们在日志文件的底部追加数据，写操作变得非常非常快，即写复杂度变为O(1 ),而在B+树的情况下是O(n log n)。</p><h2 id="bee5" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">LSM树如何处理数据库上的写操作？</h2><p id="18fc" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">让我们先从编写器开始，看看读写操作是如何在LSM树中执行的。</p><ul class=""><li id="9d1c" class="lr ls in jx b jy jz kc kd kg lt kk lu ko lv ks lw lx ly lz bi translated">每当数据库有东西要写时，我们就把它附加在日志文件的底部。</li></ul><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f84343c04ddd4e8740d6da41590a06e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*x_olRXela4h7-x4kvkKCRA.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">All write operations are appended to a log file</figcaption></figure><ul class=""><li id="4f51" class="lr ls in jx b jy jz kc kd kg lt kk lu ko lv ks lw lx ly lz bi translated">除此之外，我们还将数据放入内存中的数据结构中，称为<strong class="jx io"> MemTables </strong>。<strong class="jx io"> MemTables是内存中排序的数据结构</strong>。</li></ul><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/399e0dedd84924c8f2214b634ff3e24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*h2y9nGCOOawGNHNkDDln8g.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Logfile to MemTable data flow</figcaption></figure><ul class=""><li id="d011" class="lr ls in jx b jy jz kc kd kg lt kk lu ko lv ks lw lx ly lz bi translated">随着我们不断向Memtable写入数据，Memtable的大小不断增长，在达到某个阈值后，我们将所有数据从内存刷新到磁盘存储，称为<strong class="jx io">s tables</strong>。表是存储数据的磁盘数据结构。有多个表存储我们的数据。它们按主键或任何其他索引进行分区。</li></ul><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/7f5a8c6aa76db8b9c4d22044f0a25eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8gBJliD73CeLijPRpicPw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">log file -&gt; MemTable-&gt; SStables</figcaption></figure><p id="0c53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于表是磁盘上的结构，所以在表中搜索非常慢。因此，SSTables还维护内存中的数据结构，称为<strong class="jx io"> Bloom filters </strong>，这有助于我们在读取数据时加快搜索速度。布隆过滤器为我们提供了以下信息:</p><ol class=""><li id="89fb" class="lr ls in jx b jy jz kc kd kg lt kk lu ko lv ks ml lx ly lz bi translated">特定的键在特定的表上肯定是不可用的</li><li id="bfe3" class="lr ls in jx b jy mm kc mn kg mo kk mp ko mq ks ml lx ly lz bi translated">特定的键可以在特定的表中找到</li></ol><p id="952b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">布隆过滤器帮助我们优化跨多个表的数据搜索，因为减少了我们需要扫描的表的数量。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/fb655d7d8c9a9f910198d37fe819c6eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*acA8fI_Olq-trV9-DqqV7w.png"/></div></figure><p id="45e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们继续在SSTables上写数据，SSTables的大小也将继续增加，这将减慢我们的搜索结果。因此，每当一个表的大小超过限制时，我们将多个表合并到另一个新的表中，以删除重复的记录。多个表合并的过程被称为<strong class="jx io">压缩</strong>。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/0c25a2ef4287c593775dc4e298e3dbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*thGRaF25TLDYTm_BHBF4Iw.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Compaction of SSTables</figcaption></figure><p id="a3ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，写操作看起来像这样。</p><p id="15fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将指令追加到日志文件中，并将其写入内存中的数据结构(称为Memtables)。当内存表增长超过某个阈值时，内存表被刷新到表中。表存储在磁盘上，与内存表相比速度较慢。为了加快搜索数据的过程，表包含一个内存数据结构，称为Bloom filters。</p><h2 id="dc84" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">LSM树如何执行搜索查询？</h2><p id="765f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">当我们搜索一个特定的键时，我们首先搜索MemTables。由于Memtables位于内存中，所以查找速度很快，如果我们在Memtables上找到任何数据，我们就将结果返回给客户机。如果Memtables上没有这个键，那么我们就在表中搜索这个键，Bloom filters帮助我们缩小了搜索范围。如果在表中找到了记录，那么我们将该行返回给客户机，否则我们将返回未找到的记录。</p><p id="e489" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是在数据库存储引擎中实现的LSM树的简介。你也可以浏览我试图详细解释LSM树的视频。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1895" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mv">更多内容尽在</em><a class="ae mw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mv">plain English . io</em></a></p></div></div>    
</body>
</html>