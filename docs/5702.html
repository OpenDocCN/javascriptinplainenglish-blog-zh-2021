<html>
<head>
<title>Introduction to Higher-Order Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中高阶函数的介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-higher-order-functions-in-javascript-1ec23a2a28cf?source=collection_archive---------12-----------------------#2021-12-01">https://javascript.plainenglish.io/intro-to-higher-order-functions-in-javascript-1ec23a2a28cf?source=collection_archive---------12-----------------------#2021-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2cf8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用通用数组函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8191abdcb4d4833794c3dc72d44658be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zwIfQkZdkxg90f0L.png"/></div></div></figure><p id="05ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript中最重要的技能之一是理解高阶函数和回调函数是如何工作的。简单地说，高阶函数是这样的函数:</p><ol class=""><li id="9929" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">将不同的函数作为参数<strong class="kt ir">和/或</strong></li><li id="b668" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">返回一个新函数。</li></ol><p id="415e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样。回调函数就是被传入的函数。这些复合词隐藏了简单的概念。例如，这基本上是所有<code class="fe mb mc md me b">forEach</code>做的事情:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="2ea5" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">fakeForEach</strong> = (<strong class="me ir">arr</strong>, <strong class="me ir">callbackFunction</strong>) =&gt; {<br/>  for (let <strong class="me ir">i</strong> = 0; <strong class="me ir">i</strong> &lt; <strong class="me ir">arr</strong>.length; <strong class="me ir">i</strong>++) {<br/>    const <strong class="me ir">value</strong> = <strong class="me ir">arr</strong>[<strong class="me ir">i</strong>]<br/>    const <strong class="me ir">index</strong> = <strong class="me ir">i</strong>;<br/>    const <strong class="me ir">givenArr</strong> = <strong class="me ir">arr</strong>;<br/>    <strong class="me ir">callbackFunction</strong>(<strong class="me ir">value</strong>, <strong class="me ir">index</strong>, <strong class="me ir">givenArr</strong>)<br/>  }<br/>}<br/><br/>const <strong class="me ir">myArr</strong> = [<em class="mp">'a', 'b', 'c'</em>]<br/>const <strong class="me ir">myCallback</strong> = (<strong class="me ir">val</strong>, <strong class="me ir">idx</strong>, <strong class="me ir">arr</strong>) =&gt; {<br/>  <strong class="me ir">console</strong>.log('<em class="mp">Value at index:</em>', <strong class="me ir">val</strong>);<br/>  <strong class="me ir">console</strong>.log('<em class="mp">Current index:</em>', <strong class="me ir">idx</strong>);<br/>  <strong class="me ir">console</strong>.log('<em class="mp">Original array</em>:', <strong class="me ir">arr</strong>);<br/>};<br/><br/><strong class="me ir"><em class="mp">// these will log the same things!</em></strong><br/><strong class="me ir">fakeForEach</strong>(<strong class="me ir">myArr</strong>, <strong class="me ir">myCallback</strong>);<br/><strong class="me ir">myArr.</strong>forEach(<strong class="me ir">myCallback</strong>);</span></pre><p id="1af1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过传入一个函数<em class="mp">但不调用它</em>，我们允许一个更高阶的函数，在这个例子中是<code class="fe mb mc md me b">fakeForEach</code>或<code class="fe mb mc md me b">.forEach</code>在循环的每次迭代中调用回调。现在让我们分解一些JavaScript内置的主要高阶数组函数。</p><p id="1c39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，你也可以内联定义回调函数，但是在下面的例子中，我显式地创建了一个变量，这样就可以<em class="mp">非常</em>清楚回调引用了什么。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="d1aa" class="mj mk iq me b gy ml mm l mn mo"><strong class="me ir"><em class="mp">//</em> <em class="mp">inline</em></strong><br/><strong class="me ir">arr</strong>.forEach((<strong class="me ir">val</strong>) =&gt; {<br/><strong class="me ir">  console</strong>.log(<strong class="me ir">val</strong>)<br/>});<br/><br/><strong class="me ir"><em class="mp">// variable</em></strong><br/>const <strong class="me ir">callback</strong> = (<strong class="me ir">val</strong>) =&gt; {<br/><strong class="me ir">  console</strong>.log(<strong class="me ir">val</strong>)<br/>});<br/><strong class="me ir">arr</strong>.forEach(<strong class="me ir">callback</strong>);<br/><br/>// both are fine!</span></pre><h1 id="17ce" class="mq mk iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">。为每一个</h1><h2 id="2808" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">功能描述</h2><p id="fcb7" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated"><code class="fe mb mc md me b">.forEach</code>遍历数组，不考虑返回值。如果你需要一个基本的循环或者改变一个现有的对象，这就是你的方法。</p><h2 id="b2dc" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">回拨描述</h2><p id="55ed" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">在每次迭代中，<code class="fe mb mc md me b">forEach</code>的回调接受值、索引和原始数组。忽略所提供的回调的返回值。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="f9f1" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">letters</strong> = [<em class="mp">'a', 'b', 'c'</em>];<br/>const <strong class="me ir">callback</strong> = (<strong class="me ir">val</strong>, <strong class="me ir">idx</strong>, <strong class="me ir">arr</strong>) =&gt; {<br/><strong class="me ir">  console.</strong>log('<em class="mp">Value at index:</em>', <strong class="me ir">val</strong>);<br/><strong class="me ir">  console.</strong>log('<em class="mp">Current index:</em>', <strong class="me ir">idx</strong>);<br/><strong class="me ir">  console</strong>.log('<em class="mp">Original array:</em>', <strong class="me ir">arr</strong>);<br/>};<br/><strong class="me ir">letters</strong>.forEach(<strong class="me ir">callback</strong>);<br/><strong class="me ir"><em class="mp">// Value at index: a<br/>// Current index: 0<br/>// Original array: [ 'a', 'b', 'c' ]<br/>// Value at index: b<br/>// Current index: 1<br/>// Original array: [ 'a', 'b', 'c' ]<br/>// Value at index: c<br/>// Current index: 2<br/>// Original array: [ 'a', 'b', 'c' ]</em></strong></span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="1c05" class="mq mk iq bd mr ms oe mu mv mw of my mz jw og jx nb jz oh ka nd kc oi kd nf ng bi translated">。地图</h1><h2 id="63f2" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">功能描述</h2><p id="fa47" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated"><code class="fe mb mc md me b">.map</code>很像<code class="fe mb mc md me b">forEach</code>，除了它构建并返回一个新数组。</p><h2 id="2927" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">回拨描述</h2><p id="2c02" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">像<code class="fe mb mc md me b">forEach</code>一样，提供的回调让您可以访问值、索引和原始数组。回调的每个单独的返回值都保存在新数组中。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="476e" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">numbers</strong> = [10, 20, 30];<br/><br/>const <strong class="me ir">callback</strong> = (<strong class="me ir">val</strong>, <strong class="me ir">idx</strong>, <strong class="me ir">arr</strong>) =&gt; {<br/><strong class="me ir">  console.</strong>log('<em class="mp">Value at index:</em>', <strong class="me ir">val</strong>);<br/><strong class="me ir">  console.</strong>log('<em class="mp">Current index:</em>', <strong class="me ir">idx</strong>);<br/><strong class="me ir">  console.</strong>log('<em class="mp">Original array:</em>', <strong class="me ir">arr</strong>);<br/>  <strong class="me ir"><em class="mp">return</em></strong> <strong class="me ir">val</strong> * 100;<br/>};<br/>const <strong class="me ir">bigNumbers</strong> = <strong class="me ir">numbers</strong>.map(<strong class="me ir">callback</strong>);<br/><br/>console.log('<em class="mp">bigNumbers</em>: ', <strong class="me ir">bigNumbers</strong>);<br/><strong class="me ir"><em class="mp">// bigNumbers:  [ 1000, 2000, 3000 ]</em></strong></span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="25e0" class="mq mk iq bd mr ms oe mu mv mw of my mz jw og jx nb jz oh ka nd kc oi kd nf ng bi translated">。过滤器</h1><h2 id="eec1" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">功能描述</h2><p id="7906" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated"><code class="fe mb mc md me b">filter</code>用于根据通过条件的值返回一个新数组。</p><h2 id="e536" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated"><em class="oj">回调描述</em></h2><p id="65b7" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">回调函数有值、索引和数组，但是有趣的是返回值。如果一次迭代有一个真值返回值，那么该次迭代中数组中的值将被保存到新数组中。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="37dd" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">names</strong> = ['<em class="mp">tom</em>', '<em class="mp">ezekiel</em>', '<em class="mp">robert</em>'];<br/><br/>const <strong class="me ir">callback</strong> = (<strong class="me ir">val</strong>, <strong class="me ir">idx</strong>, <strong class="me ir">arr</strong>) =&gt; {<br/><strong class="me ir">  <em class="mp">return</em> val</strong>.length &gt; 3;<br/>};<br/>const <strong class="me ir">longNames</strong> = <strong class="me ir">names</strong>.filter(<strong class="me ir">callback</strong>);<br/><strong class="me ir">console.</strong>log('<em class="mp">longNames</em>: ', <strong class="me ir">longNames</strong>);<br/><strong class="me ir"><em class="mp">// longNames:  [ 'ezekiel', 'robert' ]</em></strong></span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="a222" class="mq mk iq bd mr ms oe mu mv mw of my mz jw og jx nb jz oh ka nd kc oi kd nf ng bi translated">。一些</h1><h2 id="52ca" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">功能描述</h2><p id="c008" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">如果数组中至少有一个元素满足给定条件，则<code class="fe mb mc md me b">some </code>返回布尔值。</p><h2 id="b436" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">回拨描述</h2><p id="18ea" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">这是一个标准的价值，指数，数组的情况。然而，与目前为止的其他方法不同，一旦回调返回<code class="fe mb mc md me b">true</code>，<code class="fe mb mc md me b">some</code>将停止遍历数组。那是因为没必要继续下去了。记住，<code class="fe mb mc md me b">some</code>只关心是否至少有一个值，如果你想要<em class="mp">精确的</em>真值，你应该使用<code class="fe mb mc md me b">forEach</code>并保留一个<code class="fe mb mc md me b">count</code>变量，或者<code class="fe mb mc md me b">filter</code>然后只使用新数组的长度。<code class="fe mb mc md me b">some</code>遍历整个数组的唯一方式是它永远找不到返回真值的值。此时<code class="fe mb mc md me b">some</code>将返回<code class="fe mb mc md me b">false</code>。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="6c4d" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">numbers</strong> = [1, 4, 9001, 7, 12];<br/>const <strong class="me ir">callback</strong> = (<strong class="me ir">val, idx, arr)</strong> =&gt; {<br/>  console.log('<em class="mp">num</em>: ', <strong class="me ir">val</strong>);<br/>  return num &gt; 9000;<br/>};<br/>const <strong class="me ir">isOver9000</strong> = <strong class="me ir">numbers</strong>.some(<strong class="me ir">callback</strong>);<br/><strong class="me ir"><em class="mp">// num:  1<br/>// num:  4<br/>// num:  9001</em><br/></strong><br/><strong class="me ir">console.</strong>log('<em class="mp">isOver9000</em>: ', <strong class="me ir">isOver9000</strong>);<br/><strong class="me ir"><em class="mp">// isOver9000:  true</em></strong></span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="1d1f" class="mq mk iq bd mr ms oe mu mv mw of my mz jw og jx nb jz oh ka nd kc oi kd nf ng bi translated">。每个</h1><h2 id="6378" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">功能描述</h2><p id="7b5e" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated"><code class="fe mb mc md me b">every</code>返回一个布尔值；<code class="fe mb mc md me b">true</code>如果<em class="mp">数组中的每个</em>值都通过回调的条件，则<code class="fe mb mc md me b">false</code>否则。</p><h2 id="0cf6" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">回拨描述</h2><p id="8380" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">回调函数有值、索引和数组，这是我们所熟悉和喜爱的。它的工作方式与<code class="fe mb mc md me b">some</code>完全一样，将返回值评估为true/falsy。但是，如果单个值返回falsy，它将放弃迭代，这与<code class="fe mb mc md me b">some</code>相反。这有点像<code class="fe mb mc md me b">||</code>对<code class="fe mb mc md me b">&amp;&amp;</code>短路。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="2522" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">numbers</strong> = [9001, 9002, 7, 12];<br/><br/>const <strong class="me ir">callback</strong> = (<strong class="me ir">val, idx, arr</strong>) =&gt; {<br/>  console.log('<em class="mp">num</em>: ', <strong class="me ir">num</strong>);<br/><strong class="me ir">  return</strong> num &gt; 9000;<br/>}<br/>const <strong class="me ir">areAllOver9000</strong> = <strong class="me ir">numbers</strong>.every(<strong class="me ir">callback</strong>)<br/><strong class="me ir"><em class="mp">// num:  9001<br/>// num:  9002</em></strong><br/><br/>console.log('<em class="mp">areAllOver9000</em>: ', <strong class="me ir">areAllOver9000</strong>);<br/><strong class="me ir"><em class="mp">// areAllOver9000:  false</em></strong></span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="cf57" class="mq mk iq bd mr ms oe mu mv mw of my mz jw og jx nb jz oh ka nd kc oi kd nf ng bi translated">更复杂的迭代器</h1><p id="d9d5" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">接下来的方法与回调的<code class="fe mb mc md me b">val, idx, arr</code>模式有些不同，稍微复杂一些。因此，让我们更深入地解释一下。</p><h1 id="0496" class="mq mk iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">。减少(基本使用案例)</h1><p id="97ae" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">该方法将一组值简化为一个值。提供的回调的第一个参数是<code class="fe mb mc md me b">accumulator</code>。第二个参数是<code class="fe mb mc md me b">current value</code>。<code class="fe mb mc md me b">reduce</code>的主要技巧是无论迭代器从一次迭代中返回什么，都将成为下一次迭代的<code class="fe mb mc md me b">accumulator</code>。<code class="fe mb mc md me b">reduce</code>的最终返回值是<code class="fe mb mc md me b">accumulator</code>在最后一次迭代中建立起来的值。</p><h2 id="82e7" class="mj mk iq bd mr nh ni dn mv nj nk dp mz la nl nm nb le nn no nd li np nq nf nr bi translated">第一次迭代呢？</h2><p id="d835" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated"><code class="fe mb mc md me b">reduce</code>有一个可选的但强烈推荐的第二个参数，它为<code class="fe mb mc md me b">accumulator</code>设置了<code class="fe mb mc md me b">initial value</code>。如果没有提供初始值，<code class="fe mb mc md me b">reduce</code>实际上将取数组的第一个值，将其视为<code class="fe mb mc md me b">initial value</code>，将数组中的第二个值视为<code class="fe mb mc md me b">current value</code>。一般来说，你应该总是提供一个<code class="fe mb mc md me b">initial value</code>，因为它会导致更少的错误。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="6865" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">numbers</strong> = [12,8,23,5];<br/>const <strong class="me ir">startingVal</strong> = 0;<br/>const <strong class="me ir">callback</strong> = (<strong class="me ir">accumulator</strong>, <strong class="me ir">currentVal</strong>) =&gt; {<br/>  <strong class="me ir">console</strong>.log('<em class="mp">Accumulator</em>', <strong class="me ir">accumulator</strong>);<br/>  <strong class="me ir">console</strong>.log('<em class="mp">Value at index:</em>', <strong class="me ir">currentVal</strong>);<br/><strong class="me ir"><em class="mp">  // console.log('Current index:', idx);<br/>  // console.log('Original array:', arr);</em></strong><br/> <strong class="me ir"> <em class="mp">return</em> accumulator + currentVal</strong>;<br/>}<br/><br/>const <strong class="me ir">total</strong> = <strong class="me ir">numbers</strong>.reduce(<strong class="me ir">callback</strong>, <strong class="me ir">startingVal</strong>);<br/><strong class="me ir"><em class="mp">// Accumulator 0<br/>// Value at index: 12<br/>// Accumulator 12<br/>// Value at index: 8<br/>// Accumulator 20<br/>// Value at index: 23<br/>// Accumulator 43<br/>// Value at index: 5</em></strong><br/>console.log('total', <strong class="me ir">total</strong>);<br/><strong class="me ir"><em class="mp">// total: 48</em></strong></span></pre><h1 id="5e51" class="mq mk iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">。减少(高级用例)</h1><p id="9cca" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">在一天结束的时候，<code class="fe mb mc md me b">reduce</code>只是把事情加到一个累加器中。但是没人说蓄电池不能...一个物体？？看看如何使用<code class="fe mb mc md me b">reduce</code>来构建一个对象。为了比较，我们做完全相同的事情，但是使用<code class="fe mb mc md me b">.forEach</code>。现在要记住的关键事情是初始值<em class="mp">必须</em>被显式设置为一个对象。同样，在这种情况下我们不需要它们，但是<code class="fe mb mc md me b">idx</code>和<code class="fe mb mc md me b">arr</code>参数仍然可用。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="53f5" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">arr</strong> = [<em class="mp">'x', 'y', 'z', 'z', 'x', 'z'</em>];<br/>const <strong class="me ir">countForEach</strong> = (<strong class="me ir">arr</strong>) =&gt; {<br/>  const <strong class="me ir">result</strong> = {};<br/>  <strong class="me ir">arr.</strong>forEach((<strong class="me ir">letter</strong>) =&gt; {<br/>    <strong class="me ir">result</strong>[<strong class="me ir">letter</strong>] = (<strong class="me ir">result</strong>[<strong class="me ir">letter</strong>]) ? <strong class="me ir">result</strong>[<strong class="me ir">letter</strong>] + 1 : 1;<br/>  });<br/><strong class="me ir"><em class="mp">  return</em></strong> <strong class="me ir">result</strong>;<br/>};<br/><br/>const <strong class="me ir">countReduce</strong> = (<strong class="me ir">arr</strong>) =&gt; <strong class="me ir">arr</strong>.reduce((<strong class="me ir">acc</strong>, <strong class="me ir">letter</strong>) =&gt; {<br/>  <strong class="me ir">acc</strong>[<strong class="me ir">letter</strong>] = <strong class="me ir">acc</strong>[<strong class="me ir">letter</strong>] ? <strong class="me ir">acc</strong>[<strong class="me ir">letter</strong>] + 1 : 1;<br/><strong class="me ir">  return <em class="mp">acc</em></strong>;<br/>}, {});<br/><br/><strong class="me ir">console.</strong>log(<strong class="me ir">countForEach</strong>(<strong class="me ir">arr</strong>));<br/><strong class="me ir"><em class="mp">// { x: 2, y: 1, z: 3 }</em></strong><br/><strong class="me ir">console</strong>.log(<strong class="me ir">countReduce</strong>(<strong class="me ir">arr</strong>));<br/><strong class="me ir"><em class="mp">// { x: 2, y: 1, z: 3 }</em></strong></span></pre><h1 id="b684" class="mq mk iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">。分类</h1><p id="3554" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">默认的<code class="fe mb mc md me b">sort()</code>方法按照字母顺序对<em class="mp">进行排序。这意味着<code class="fe mb mc md me b">[1, 3, 2, 11]</code>将被归入<code class="fe mb mc md me b">[1, 11, 2, 3]</code>。这并不理想。为了正确地对数字进行排序，您需要传入一个<code class="fe mb mc md me b">compare</code>回调函数。<code class="fe mb mc md me b">compare</code>函数需要返回正数、负数或0。然后，JS将使用这些数字来确定值的顺序是否正确。在伪代码中，您会看到一个具有以下条件的函数:</em></p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="56cc" class="mj mk iq me b gy ml mm l mn mo"><em class="mp">const compare = (a, b) =&gt; {<br/>  if (a is less than b by some ordering criterion) {<br/>    return a negative number;<br/>  }<br/>  if (a is greater than b by the ordering criterion) {<br/>    return a positive number;<br/>  }<br/>  // a must be equal to b<br/>  return 0;<br/>}</em></span></pre><p id="c499" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个<em class="mp">非常</em>的手动设置，可能对非数值排序有用。然而，如果你比较的是数值，你可以用一个<em class="mp">非常简单的回调来完成同样的事情:</em></p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="4499" class="mj mk iq me b gy ml mm l mn mo">// sorts smallest to biggest (ascending)<br/>let <strong class="me ir">compare</strong> = (<strong class="me ir">a, b</strong>) =&gt; <strong class="me ir">a - b</strong>;<br/>// sorts biggest to smallest (descending)<br/><strong class="me ir">compare</strong> = (<strong class="me ir">a, b</strong>) =&gt;<strong class="me ir"> b - a</strong>;</span></pre><p id="04b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用于上下文中，<code class="fe mb mc md me b">sort</code>看起来是这样。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="61ac" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">numbers</strong> = [4, 2, 5, 1, 3];<br/><strong class="me ir">numbers</strong>.sort((<strong class="me ir">a, b</strong>) =&gt; <strong class="me ir">a - b</strong>); <br/><strong class="me ir">console</strong>.log('<em class="mp">numbers:</em>', <strong class="me ir">numbers</strong>);<br/><strong class="me ir">// [ 1, 2, 3, 4, 5 ]</strong></span></pre><p id="9048" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">compare函数也可以轻松地处理对象，只需访问所需的任何属性。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="6dcd" class="mj mk iq me b gy ml mm l mn mo">const <strong class="me ir">houses</strong> = [<br/>  { color: <em class="mp">'blue'</em>, price: 350000 },<br/>  { color: '<em class="mp">red</em>', price: 470000 },<br/>  { color: '<em class="mp">pink</em>', price: 280000 },<br/>];<br/><strong class="me ir">houses.</strong>sort((<strong class="me ir">a, b</strong>) =&gt; <strong class="me ir">a</strong>.price - <strong class="me ir">b</strong>.price);<br/><strong class="me ir">console</strong>.log('<em class="mp">houses</em>:', <strong class="me ir">houses</strong>);<br/>// houses [<br/>//   { color: 'pink', price: 280000 },<br/>//   { color: 'blue', price: 350000 },<br/>//   { color: 'red', price: 470000 }<br/>// ]</span></pre><p id="39fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里需要注意的一点是，与这个列表中的其他迭代器函数不同，<code class="fe mb mc md me b"><strong class="kt ir">sort</strong></code> <strong class="kt ir"> <em class="mp">不是纯粹的</em></strong>；它会改变原来的数组，而不是创建一个新的。</p><h1 id="2b92" class="mq mk iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">更多高阶函数在等着您！</h1><p id="355d" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">这只是更高层次的山的基础，关于这个概念还有太多需要探索的地方。但是，您现在应该已经很好地掌握了基础知识，我鼓励您打开一个控制台，摆弄一下这些值，直到它成为您的第二天性。</p><p id="6757" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大家编码快乐，</p><p id="d708" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">麦克风</p><p id="89d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mp">更多内容看</em> <a class="ae ok" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mp">说白了. io </em> </strong> </a> <strong class="kt ir"> <em class="mp">。</em> </strong> <em class="mp">报名参加我们的</em> <a class="ae ok" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mp">免费每周简讯点击这里</em> </strong> </a> <strong class="kt ir"> <em class="mp">。</em> </strong></p></div></div>    
</body>
</html>