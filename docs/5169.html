<html>
<head>
<title>How to implement Memoization in React to improve performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中实现内存化以提高性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-performance-optimization-ft-memoization-61b765c4c619?source=collection_archive---------9-----------------------#2021-10-20">https://javascript.plainenglish.io/react-performance-optimization-ft-memoization-61b765c4c619?source=collection_archive---------9-----------------------#2021-10-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f6dc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用useMemo和useCallback反应性能优化</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/ccbccbf2773f86118590f81c9e55f594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*HhrFfc-4m9n7rscCVdNZhQ.jpeg"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Optimize your react app with ease</figcaption></figure><p id="66ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React优化可能是一件棘手的事情。React本身进行了内部优化，以提高性能。当我们从可读性、维护友好性和可伸缩性的角度考虑组件的复杂性时，添加的优化技术会使前面提到的代码方面发生倒退。在最坏的情况下，旨在优化性能的技术会进一步降低性能。因此，简而言之，所有的优化技术都有成本，应该事先认真考虑。</p><p id="911c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但在某些情况下，React app可能会使用大量数据或昂贵的数据计算，优化可能会成为需求之一。</p><p id="2285" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以，让我们开始吧。</p><p id="710a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React app的性能可以通过减少不必要的API调用来优化，这要简单得多，值得推荐，也可以通过使用memoization来优化。</p><p id="0237" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们将重点讨论React中的记忆技术。</p><p id="b7bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">记忆化是代码的时间复杂度和空间复杂度之间的权衡。通过记忆化，React存储对象、回调函数或props的先前版本，并将它们与下一个即将到来的记忆化对象、回调函数或props的版本进行比较，以确定任何更改。只有在发生变化时，组件才会重新呈现，从而提高应用程序的性能。这里，浏览器内存用于提高性能。</p><p id="e4c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">在应用React函数内存化技术之前，要知道您的代码应该可以在没有这些技术的情况下工作，因为React可能会在内部跳过这些技术来释放浏览器中的内存。</strong></p><p id="e837" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">记忆可应用于:</p><p id="35e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">1.成分</p><p id="d44f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.目标</p><p id="08b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3.回调函数</p><p id="2d29" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React为我们提供了<em class="lk"> React.memo </em>和两个钩子:<em class="lk"> useMemo() </em>和<em class="lk"> useCallback() </em>来应用记忆化技术。</p><p id="c82f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看现在的行动。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Simple Memoized Component Demo</figcaption></figure><h1 id="1a03" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated"><strong class="ak"> 1。应用于组件的记忆化</strong></h1><p id="7b1e" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">如果您的组件使用相同的属性呈现相同的结果，您可以将它包装在对<code class="fe mk ml mm mn b">React.memo</code>的调用中，在某些情况下通过记忆结果来提高性能。这意味着React将跳过组件的渲染，并重用最后一次渲染的结果。</p><p id="d2d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，当重新呈现父组件时，即使子组件不接受来自父组件的任何道具，它的子组件也会被重新呈现。在这种情况下，为了避免子组件不必要的重新呈现，可以使用<code class="fe mk ml mm mn b">React.memo</code>。</p><p id="27c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mk ml mm mn b"><em class="lk">React.memo</em></code>浅浅地比喻道具中的物件。为了定制比较器，可以添加一个可选的定制比较器回调函数作为第二个参数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo lm l"/></div></figure><p id="004c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这可以被想象成React类组件中的<em class="lk"> shouldComponentUpdate() </em>生命周期方法的等价物。</p><blockquote class="mp mq mr"><p id="0bd4" class="ko kp lk kq b kr ks jo kt ku kv jr kw ms ky kz la mt lc ld le mu lg lh li lj ig bi translated">你可能会尝试使用<em class="in"> React。Memo </em> with comparator作为解决方案的一部分来停止子组件的重新渲染，但是<a class="ae mv" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> React文档</a>警告不应该这样做，因为React可能会跳过内存化来为其他一些组件释放空间。</p></blockquote><h1 id="d6fa" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated"><strong class="ak"> 2。应用于对象的记忆化</strong></h1><p id="f776" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated"><em class="lk"> useMemo() </em> hook接受一个要记忆的函数和一个依赖数组。<em class="lk"> useMemo </em>仅当其中一个依赖关系发生变化时，才会重新计算记忆值。这种优化有助于避免每次渲染时进行昂贵的计算。</p><p id="fb3a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">如果没有提供数组，将在每次渲染时计算新值。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo lm l"/></div></figure><h1 id="dc61" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated"><strong class="ak"> 3。应用于props </strong>中回调函数的记忆化</h1><p id="e19c" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx mh kz la lb mi ld le lf mj lh li lj ig bi translated">由于<code class="fe mk ml mm mn b">React.memo</code>对道具做了浅显的比较，道具中的回调函数即使不做任何改动，仍然可能触发重新渲染。为了防止这种不必要的渲染<code class="fe mk ml mm mn b">useCallback()</code>是有用的。</p><p id="a0b3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="lk">如果我们在使用</em> </strong> <code class="fe mk ml mm mn b"><strong class="kq io"><em class="lk">React.memo</em></strong></code> <strong class="kq io"> <em class="lk">，为什么我们还要</em> </strong> <code class="fe mk ml mm mn b"><strong class="kq io"><em class="lk">useCallback()</em></strong></code> <strong class="kq io"> <em class="lk">？</em> </strong></p><p id="c732" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">答</strong>:在每次组件渲染时，React都会创建新的函数副本。新的副本将有新的引用。浅层比较使用引用相等来确定对象中的变化(在JavaScript中函数也是对象)。因此，这些会触发props中带有回调的子组件进行重新渲染。</p><p id="bb50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk"> useCallback() </em>如果所提供的依赖关系没有变化，则简单地跳过每个渲染函数的重新创建。这满足了引用相等性，防止了由于props中的回调函数而导致的重新呈现。</p><p id="1a66" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk"> useCallback() </em>接受一个要记忆的回调和一个可选的依赖数组作为参数。</p><p id="e18e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">如果没有提供数组，将在每次渲染时计算新值。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo lm l"/></div></figure><blockquote class="mp mq mr"><p id="4089" class="ko kp lk kq b kr ks jo kt ku kv jr kw ms ky kz la mt lc ld le mu lg lh li lj ig bi translated"><em class="in"> `useCallback(fn，dependencies)` </em>等价于`<em class="in"> useMemo(() = &gt; fn，dependencies) </em>`。</p></blockquote><p id="d5ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">[ <a class="ae mv" href="https://codesandbox.io/s/react-memoization-igth1?file=/src/components/ParentComp.tsx" rel="noopener ugc nofollow" target="_blank">此处提供代码… </a> ]</p><p id="56ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读！</p><p id="bdcd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容看</em><a class="ae mv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>