<html>
<head>
<title>Create a Realtime Chat Application with Next.js, Vercel and Ably</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Next.js，Vercel和Ably创建一个实时聊天应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/this-post-will-walk-through-the-creation-of-a-realtime-chat-application-with-next-js-361878ad95f4?source=collection_archive---------16-----------------------#2021-03-05">https://javascript.plainenglish.io/this-post-will-walk-through-the-creation-of-a-realtime-chat-application-with-next-js-361878ad95f4?source=collection_archive---------16-----------------------#2021-03-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9187" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用React构建您自己的聊天应用程序</h2></div><p id="8ee7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">这篇文章将教你以下内容:</strong></p><ul class=""><li id="d224" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">创建全新的Next.js应用程序</li><li id="1ae1" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">用Ably添加实时功能</li><li id="b4a6" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">创建一个Next.js Vercel无服务器API</li><li id="e92f" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">巧妙地使用React功能组件和React钩子</li><li id="6d5d" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">在Vercel上托管您的应用</li></ul><p id="024f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">检查一个<a class="ae lm" href="https://next-js-chat-app.vercel.app/" rel="noopener ugc nofollow" target="_blank">运行版本的应用程序</a>。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/fb7f0e22c545db6498087032cf8d58f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DYnSGXmNpfFsU9_8"/></div></div></figure><h1 id="d757" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">Vercel中的WebSockets与Ably</h1><p id="abdc" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">Vercel允许用户部署<a class="ae lm" href="https://vercel.com/docs/serverless-functions/introduction" rel="noopener ugc nofollow" target="_blank">无服务器功能</a>，本质上只是对HTTP请求提供响应的代码块。但是，这些函数有一个最大执行超时，这意味着不可能以这种方式维护WebSocket连接。这就是Ably的用武之地。客户端可以连接到一个<a class="ae lm" href="https://ably.com/documentation/realtime/channels" rel="noopener ugc nofollow" target="_blank">频道</a>并在上面发送和接收消息，通过为你管理WebSocket连接来为你的应用添加实时功能。我们将在本演练中讨论如何构建一个使用实时功能的应用程序，如果愿意，您可以<a class="ae lm" href="https://ably.com/blog/realtime-chat-app-nextjs-vercel?utm_content=156129294&amp;utm_medium=social&amp;utm_source=twitter&amp;hss_channel=tw-610981768#ablyandvercel" rel="noopener ugc nofollow" target="_blank">直接跳到如何巧妙地使用Vercel </a>。</p><blockquote class="mw mx my"><p id="0d0a" class="kc kd mz ke b kf kg jo kh ki kj jr kk na km kn ko nb kq kr ks nc ku kv kw kx ig bi translated"><a class="ae lm" href="https://ably.com/topic/websockets-javascript" rel="noopener ugc nofollow" target="_blank"> <em class="in">看看为JavaScript应用程序实现一个可靠且高性能的客户端WebSocket解决方案的一些挑战。</em>T13】</a></p></blockquote><h1 id="039a" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">我们要建造什么？</h1><p id="8275" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们将构建一个在浏览器中运行的实时聊天应用程序。它将建立在next . js<a class="ae lm" href="https://nextjs.org/docs/api-reference/create-next-app" rel="noopener ugc nofollow" target="_blank">create-next-app</a>模板的基础上，它将包含一个React组件，可以用来发送和接收消息。我们还将编写一个Next.js无服务器函数，用于连接Ably。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0b26631ba59cee05eb48f7dcfb9602b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/0*iw5mrivTJFgt8o8A"/></div></figure><h1 id="8a05" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">属国</h1><p id="4631" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">为了构建此应用程序，您需要:</p><ul class=""><li id="181a" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="ke io">发送消息的Ably账户</strong>:<a class="ae lm" href="https://ably.com/signup" rel="noopener ugc nofollow" target="_blank">免费创建Ably账户</a>。</li><li id="806f" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="ke io">一个Vercel账户</strong>用于制作托管:<a class="ae lm" href="https://vercel.com/signup" rel="noopener ugc nofollow" target="_blank">免费创建一个Vercel账户</a>。</li><li id="3525" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="ke io">节点12 </strong> (LTS)以上:<a class="ae lm" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">安装节点</a>。</li></ul><h1 id="3500" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">本地开发先决条件</h1><p id="c5df" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">您将需要一个来自Ably的API密钥来认证Ably服务。要获得API密钥，一旦你<a class="ae lm" href="https://ably.com/signup" rel="noopener ugc nofollow" target="_blank">创建了一个账户</a>:</p><ol class=""><li id="5ddc" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ne le lf lg bi translated">访问您的<a class="ae lm" href="https://ably.com/accounts" rel="noopener ugc nofollow" target="_blank">应用仪表板</a>并点击“创建新应用”。</li><li id="4bd1" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated">给新应用命名</li><li id="3f92" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated">创建应用程序后，复制私有API密钥。保持它的安全，这是你如何认证Ably服务。</li></ol><p id="93d5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Vercel提供了一些Next.js命令行工具来帮助我们。它们不需要安装在您的系统上，因为它们是使用<code class="fe nf ng nh ni b">npx</code>执行的。</p><h1 id="52b9" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">构建Next.js聊天应用程序</h1><h1 id="49b3" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">要创建初学者应用程序:</h1><ol class=""><li id="e105" class="ky kz in ke b kf mr ki ms kl nj kp nk kt nl kx ne le lf lg bi translated">在您的终端中，键入<code class="fe nf ng nh ni b">npx create-next-app</code>创建一个空的Next.js应用程序。</li><li id="5b94" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated">在根目录下创建一个名为<code class="fe nf ng nh ni b">.env</code>的文件，这是我们放置项目环境变量的地方。</li><li id="9b58" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated">将Ably API密钥添加到。环境文件:</li></ol><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="5ad5" class="nq ma in ni b gy nr ns l nt nu">ABLY_API_KEY=your-ably-api-key:goes-here</span></pre><ol class=""><li id="1966" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ne le lf lg bi translated">导航到Next.js应用程序目录，并在控制台中键入:</li></ol><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="dba1" class="nq ma in ni b gy nr ns l nt nu">npm run dev</span></pre><p id="6c35" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Next.js dev服务器将启动，您将看到一个空的Next。JS入门app。这是我们将在其上构建聊天应用程序的基础。</p><h1 id="ef18" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">实时发布/订阅消息</h1><p id="9f65" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们将构建的聊天应用程序巧妙地使用<a class="ae lm" href="https://ably.com/" rel="noopener ugc nofollow" target="_blank"/>在用户之间进行<a class="ae lm" href="https://ably.com/documentation/core-features/pubsub" rel="noopener ugc nofollow" target="_blank">发布/订阅消息</a>。Pub/Sub代表发布和订阅，是用于实时数据交付的流行模式。该应用程序将能够通过一个<a class="ae lm" href="https://ably.com/pub-sub-messaging" rel="noopener ugc nofollow" target="_blank">通道</a>发送或<code class="fe nf ng nh ni b">publish</code>消息。使用该应用程序的客户端将被<code class="fe nf ng nh ni b">subscribed</code>到频道，并将能够接收消息。我们将构建一个UI来创建要发送的消息，并在收到消息时显示消息。</p><p id="f9e9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae lm" href="https://pages.ably.com/cs/c/?cta_guid=0d5e4729-b3d0-44fc-b892-88a0e85e544b&amp;signature=AAH58kHDaiijUA2ezYd6O20zj7XsyVmbzg&amp;placement_guid=85f436af-7315-44c9-aa12-d764f40b294d&amp;click=e45ad845-2678-49a5-83b8-38848c9114a8&amp;hsutk=2e23ace75e4744214a2aca9d8ea843e1&amp;canon=https%3A%2F%2Fably.com%2Fblog%2Frealtime-chat-app-nextjs-vercel&amp;portal_id=6939709&amp;redirect_url=APefjpEFmN0FrqvvBKaPDIjgItsADRvUqwUVrUlTWRz4jmtbYO835aeTgQrzPCRPR7y4ssDEV5ojI3p95jTlNmWXKZK35EBqplbPeWhYF4iaeOI8Do2IyxO5yltFZySv96tnFlDSoLB6X_6iGYrasLXCCzDuHniczNW-6d5tAA46DEg53-FHesHQ8oh_wQopSvPXt-8A406-NRKZCh54MKZ1q1nJRK7m6ZWzj7UfPyVQg6fBKUy7WrU&amp;__hstc=12655464.2e23ace75e4744214a2aca9d8ea843e1.1610965950917.1614953799619.1614965705856.14&amp;__hssc=12655464.1.1614965705856&amp;__hsfp=1889468195" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">免费试用我们的API</strong></a></p><h1 id="26ee" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">Ably服务的认证</h1><p id="def6" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">Vercel Next.js应用不运行传统的“服务器端代码”，但是，您可以将JavaScript文件添加到<code class="fe nf ng nh ni b">/pages/api/*</code>中，Vercel部署引擎会将每个文件视为一个API端点，并作为无服务器功能来管理它们。</p><p id="a79c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于本地开发，Next.js工具在一个节点服务器中运行这些函数，因此它们在本地开发环境中可以像您所期望的那样工作。我们将在我们之前创建的启动代码中添加一个Next.js / Vercel无服务器函数，以使用Ably认证我们的应用程序，并使通过Ably服务发送和接收消息成为可能。</p><h1 id="7a40" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">编写无服务器函数来连接Ably</h1><p id="bba3" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">你需要安装Ably npm包(为了与Vercel兼容，你必须运行Ably 1.2.5+。</p><p id="4539" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在终端中，在新应用程序的根目录下运行:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="90f0" class="nq ma in ni b gy nr ns l nt nu">npm install ably@1.2.5-beta.1</span></pre><p id="cf5a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，创建一个名为<code class="fe nf ng nh ni b">./pages/api/createTokenRequest.js</code>的文件，在其中添加以下代码:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="36b1" class="nq ma in ni b gy nr ns l nt nu">import Ably from "ably/promises";</span><span id="237c" class="nq ma in ni b gy nv ns l nt nu">export default async function handler(req, res) {<br/>    const client = new Ably.Realtime(process.env.ABLY_API_KEY);<br/>    const tokenRequestData = await client.auth.createTokenRequest({ clientId: 'ably-nextjs-demo' });<br/>    res.status(200).json(tokenRequestData);<br/>};</span></pre><p id="2b16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个无服务器函数使用Ably SDK创建一个带有API密钥的<code class="fe nf ng nh ni b">tokenRequest</code>。稍后将使用这个令牌——它允许您在Next.js应用程序中使用“真正的”API密钥时保持其安全。默认情况下，这个API被配置为在<code class="fe nf ng nh ni b">http://localhost:3000/api/createTokenRequest</code> <br/>上可用。我们将把这个URL提供给客户端中的Ably SDK，以便Ably进行身份验证。</p><h1 id="5dba" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">实时聊天应用架构</h1><p id="317e" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们的Next.js应用程序的拓扑将如下所示:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="611a" class="nq ma in ni b gy nr ns l nt nu">├─ .env<br/>├─ .gitignore<br/>├─ package-lock.json<br/>├─ package.json<br/>├─ README.md   <br/>|    <br/>├─── components<br/>│     ├─ AblyChatComponent.jsx<br/>│     ├─ AblyChatComponent.module.css<br/>│     └─ AblyReactEffect.js<br/>|<br/>├─── pages<br/>│    ├─ index.js<br/>│    │   <br/>│    └─── api<br/>│          └─ createTokenRequest.js<br/>│           <br/>└─── public</span></pre><ul class=""><li id="691b" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><code class="fe nf ng nh ni b">/pages/index.js</code>是主页</li><li id="5ffc" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><code class="fe nf ng nh ni b">/api/createTokenRequest.js</code>是我们巧妙的令牌认证API</li><li id="c757" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><code class="fe nf ng nh ni b">/components/AblyChatComponent.jsx</code>是聊天组件</li><li id="69d3" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><code class="fe nf ng nh ni b">/components/AblyChatComponent.module.css</code>包含聊天组件的样式</li><li id="a455" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><code class="fe nf ng nh ni b">/components/AblyReactEffect.js</code>是巧妙地反应钩。</li></ul><p id="ad84" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看这个应用程序是如何构建的。</p><h1 id="28f4" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">构建组件</h1><p id="9be1" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated"><code class="fe nf ng nh ni b">Next.js</code>中的页面是React组件，因此<code class="fe nf ng nh ni b">pages/index.js</code>主页是包含页面布局的React组件。</p><p id="9354" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是由<code class="fe nf ng nh ni b">create-next-app</code>生成的默认页面，我们将在其中添加我们自己的组件——一个<code class="fe nf ng nh ni b">AblyChatComponent</code>:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="d02d" class="nq ma in ni b gy nr ns l nt nu">import Head from 'next/head'<br/>import dynamic from 'next/dynamic'</span><span id="85e9" class="nq ma in ni b gy nv ns l nt nu">const AblyChatComponent = dynamic(() =&gt; import('../components/AblyChatComponent'), { ssr: false });</span><span id="a7cb" class="nq ma in ni b gy nv ns l nt nu">export default function Home() {<br/>  return (<br/>    &lt;div className="container"&gt;<br/>      &lt;Head&gt;<br/>        &lt;title&gt;Create Next App&lt;/title&gt;<br/>        &lt;link rel="icon" href="/favicon.ico" /&gt;<br/>      &lt;/Head&gt;</span><span id="e13c" class="nq ma in ni b gy nv ns l nt nu">      &lt;main&gt;<br/>        &lt;h1 className="title"&gt;Next.js Chat Demo&lt;/h1&gt;<br/>        &lt;AblyChatComponent /&gt;<br/>      &lt;/main&gt;</span><span id="9307" class="nq ma in ni b gy nv ns l nt nu">      &lt;footer&gt;<br/>        Powered by<br/>        &lt;a href="https://vercel.com" target="_blank" rel="noopener noreferrer"&gt;<br/>          &lt;img src="/vercel.svg" alt="Vercel Logo" className="logo" /&gt;<br/>        &lt;/a&gt;<br/>        and<br/>        &lt;a href="https://ably.com" rel="noopener noreferrer"&gt;<br/>          &lt;img src="/ably-logo.svg" alt="Ably Logo" className="logo ably" /&gt;<br/>        &lt;/a&gt;<br/>      &lt;/footer&gt;</span><span id="a0e5" class="nq ma in ni b gy nv ns l nt nu">      &lt;style jsx&gt;{`<br/>        ...       <br/>      `}&lt;/style&gt;</span><span id="d4b9" class="nq ma in ni b gy nv ns l nt nu">      &lt;style jsx global&gt;{`<br/>        ...        <br/>      `}&lt;/style&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="23bc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您会注意到它看起来不像常规导入，我们是这样包含它的:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="cc46" class="nq ma in ni b gy nr ns l nt nu">const AblyChatComponent = dynamic(() =&gt; import('../components/AblyChatComponent'), { ssr: false });</span></pre><p id="0bea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在像使用任何其他react组件一样使用它之前:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="2d50" class="nq ma in ni b gy nr ns l nt nu">&lt;main&gt;<br/>  &lt;h1 className="title"&gt;Next.js Chat Demo&lt;/h1&gt;<br/>  &lt;AblyChatComponent /&gt;<br/>&lt;/main&gt;</span></pre><p id="d1fc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种不寻常的包含样式是因为<code class="fe nf ng nh ni b">AblyChatComponent</code>只能在用户的浏览器中运行。它使用WebSockets连接，不适合使用Vercel进行服务器端渲染。默认情况下，Next.js试图在服务器端呈现所有内容，所以通过使用<code class="fe nf ng nh ni b">dynamic()</code>调用包含组件，我们可以告诉Next.js不要在构建过程中呈现它，因为它无法连接到它需要运行的API，所以会抛出错误。</p><h1 id="3656" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">编写聊天组件逻辑</h1><p id="f528" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">聊天应用程序逻辑包含在<code class="fe nf ng nh ni b">AblyChatComponent.jsx</code>组件中。</p><p id="df49" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先在文件顶部引用我们需要的导入:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="03c1" class="nq ma in ni b gy nr ns l nt nu">import React, { useEffect, useState } from 'react';<br/>import { useChannel } from "./AblyReactEffect";<br/>import styles from './AblyChatComponent.module.css';</span></pre><p id="fef9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们将定义将作为React功能组件导出的函数。我们需要访问代码中的一些HTML元素，这样我们就可以创建变量来存储它们的引用:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="7d9d" class="nq ma in ni b gy nr ns l nt nu">const AblyChatComponent = () =&gt; {</span><span id="f835" class="nq ma in ni b gy nv ns l nt nu">  let inputBox = null;<br/>  let messageEnd = null;</span></pre><p id="0810" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，设置我们将在组件中使用的状态属性:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="20e9" class="nq ma in ni b gy nr ns l nt nu">const [messageText, setMessageText] = useState("");<br/>  const [receivedMessages, setMessages] = useState([]);<br/>  const messageTextIsEmpty = messageText.trim().length === 0;</span></pre><ul class=""><li id="b82b" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="ke io"> messageText </strong>将被绑定到可以输入消息的textarea元素</li><li id="c951" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="ke io">接收消息</strong>至屏幕聊天记录</li><li id="1913" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="ke io"> messageTextIsEmpty </strong>用于在文本区为空时禁用发送按钮</li></ul><p id="6076" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们将使用我们之前导入的<code class="fe nf ng nh ni b">useChannel</code>钩子。</p><p id="5157" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nf ng nh ni b">useChannel</code>是一个<a class="ae lm" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> react-hook </a>风格的API，用于订阅来自Ably通道的消息。您为它提供一个通道名和一个回调，以便在收到消息时调用。</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="e886" class="nq ma in ni b gy nr ns l nt nu">const [channel, ably] = useChannel("chat-demo", (message) =&gt; {<br/>    // Here we're computing the state that'll be drawn into the message history<br/>    // We do that by slicing the last 199 messages from the receivedMessages buffer</span><span id="ba27" class="nq ma in ni b gy nv ns l nt nu">    const history = receivedMessages.slice(-199);<br/>    setMessages([...history, message]);</span><span id="04d1" class="nq ma in ni b gy nv ns l nt nu">    // Then finally, we take the message history, and combine it with the new message<br/>    // This means we'll always have up to 199 message + 1 new message, stored using the<br/>    // setMessages react useState hook<br/>  });</span></pre><p id="e897" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们需要通过定义一些函数来处理UI交互。</p><p id="23ff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先是<code class="fe nf ng nh ni b">sendChatMessage</code>，负责发布新消息。<br/>它使用由<code class="fe nf ng nh ni b">useChannel</code>钩子返回的Ably通道，清除输入，并聚焦于文本区域，以便用户可以键入更多的消息:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="65e4" class="nq ma in ni b gy nr ns l nt nu">const sendChatMessage = (messageText) =&gt; {<br/>    channel.publish({ name: "chat-message", data: messageText });<br/>    setMessageText("");<br/>    inputBox.focus();<br/>  }</span></pre><p id="ff37" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后是<code class="fe nf ng nh ni b">handleFormSubmission</code>，当<code class="fe nf ng nh ni b">submit</code>按钮被点击时触发，调用<code class="fe nf ng nh ni b">sendChatMessage</code>，同时阻止页面重新加载:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="a1a2" class="nq ma in ni b gy nr ns l nt nu">const handleFormSubmission = (event) =&gt; {<br/>    event.preventDefault();<br/>    sendChatMessage(messageText);<br/>  }</span></pre><p id="7942" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，<code class="fe nf ng nh ni b">handleKeyPress</code>事件被连接起来，以确保当文本区中有文本时，如果用户按下<code class="fe nf ng nh ni b">enter</code>键，就会触发<code class="fe nf ng nh ni b">sendChatMessage</code>功能。</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="64d8" class="nq ma in ni b gy nr ns l nt nu">const handleKeyPress = (event) =&gt; {<br/>    if (e.charCode !== 13 || messageTextIsEmpty) {<br/>      return;<br/>    }<br/>    sendChatMessage(messageText);<br/>    event.preventDefault();<br/>  }</span></pre><p id="e95d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们需要构造UI元素来显示消息。为此，我们将把收到的消息映射到HTML span元素中:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="63e8" class="nq ma in ni b gy nr ns l nt nu">const messages = receivedMessages.map((message, index) =&gt; {<br/>    const author = message.connectionId === ably.connection.id ? "me" : "other";<br/>    return &lt;span key={index} className={styles.message} data-author={author}&gt;{message.data}&lt;/span&gt;;<br/>  });</span></pre><p id="c3ff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了保持消息框滚动到最近的消息(底部的消息),我们需要在消息容器中添加一个空的div元素，每当组件重新呈现时，它就会滚动到视图中。这是我们稍后将添加到UI中的元素:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="3403" class="nq ma in ni b gy nr ns l nt nu">&lt;div ref={(element) =&gt; { messageEnd = element; }}&gt;&lt;/div&gt;</span></pre><p id="95c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当组件呈现时，我们使用一个<code class="fe nf ng nh ni b">useEffect</code>钩子和<code class="fe nf ng nh ni b"><a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView" rel="noopener ugc nofollow" target="_blank">scrollIntoView()</a></code>将消息历史滚动到底部。</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="9802" class="nq ma in ni b gy nr ns l nt nu">useEffect(() =&gt; {<br/>    messageEnd.scrollIntoView({ behaviour: "smooth" });<br/>  });</span></pre><p id="4288" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们将编写React组件标记，所有事件处理程序都绑定到JSX的<code class="fe nf ng nh ni b">onChange</code>和<code class="fe nf ng nh ni b">onKeyPress</code>事件。</p><p id="d52a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">标记本身只是几个div元素和一个带有供用户输入的文本区域的表单。</p><p id="f819" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有两个对react <code class="fe nf ng nh ni b">ref</code>函数的调用，它允许我们在呈现元素时捕获对元素的引用，以便我们可以用JavaScript与它们进行交互。</p><p id="ed33" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回的标记将如下所示:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="e3a9" class="nq ma in ni b gy nr ns l nt nu">return (<br/>    &lt;div className={styles.chatHolder}&gt;<br/>      &lt;div className={styles.chatText}&gt;<br/>        {messages}<br/>        &lt;div ref={(element) =&gt; { messageEnd = element; }}&gt;&lt;/div&gt; // empty element to control scroll to bottom<br/>      &lt;/div&gt;<br/>      &lt;form onSubmit={handleFormSubmission} className={styles.form}&gt;<br/>        &lt;textarea<br/>          ref={(element) =&gt; { inputBox = element; }}<br/>          value={messageText}<br/>          placeholder="Type a message..."<br/>          onChange={e =&gt; setMessageText(e.target.value)}<br/>          onKeyPress={handleKeyPress}<br/>          className={styles.textarea}<br/>        &gt;&lt;/textarea&gt;<br/>        &lt;button type="submit" className={styles.button} disabled={messageTextIsEmpty}&gt;Send&lt;/button&gt;<br/>      &lt;/form&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="13ba" class="nq ma in ni b gy nv ns l nt nu">export default AblyChatComponent;</span></pre><p id="5b18" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就在文件的底部，该函数被导出为<code class="fe nf ng nh ni b">AblyChatComponent</code>，这样我们在开始时创建的Next.js页面就可以引用它。</p><h1 id="98ab" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">巧妙正确地使用反应元件</h1><p id="49c7" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">将Ably与React功能组件一起使用的一个更棘手的部分是知道何时何地创建SDK的实例，以及何时何地连接到您的通道。当组件被渲染时，你应该避免实例化SDK，因为这可能会产生多个连接并烧穿你的Ably帐户限制。</p><p id="614c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了确保应用程序正确地处理组件重绘、安装和卸载— <code class="fe nf ng nh ni b">AblyReactEffect</code>导出一个<a class="ae lm" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>来与Ably SDK交互。</p><p id="ab5e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React钩子在你第一次使用的时候看起来有点不寻常。挂钩是一种功能，它:</p><ul class=""><li id="e1b5" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">执行我们期望<code class="fe nf ng nh ni b">componentDidMount</code>运行的功能</li><li id="960c" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">返回<em class="mz">另一个</em>函数，该函数将由调用<code class="fe nf ng nh ni b">componentDidUnmount</code>的框架执行</li><li id="6432" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">执行它需要的任何其他行为</li></ul><p id="cf0a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个反应钩子是基于<code class="fe nf ng nh ni b">useEffect</code>建造的。当被引用时，它创建Ably SDK的一个实例(它只做一次),该实例被配置为使用您的无服务器函数的<code class="fe nf ng nh ni b">URL</code>对<code class="fe nf ng nh ni b">createTokenRequest</code>进行认证:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="498c" class="nq ma in ni b gy nr ns l nt nu">import Ably from "ably/promises";<br/>import { useEffect } from 'react'</span><span id="a380" class="nq ma in ni b gy nv ns l nt nu">const ably = new Ably.Realtime.Promise({ authUrl: '/api/createTokenRequest' });</span></pre><p id="83ef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在组件范围之外实例化Ably库意味着它只被创建一次，这将降低你的使用限制。</p><p id="f456" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们需要创建将要导出的函数——我们的钩子，这样我们就可以在我们的组件中使用它。<br/>我们称之为<code class="fe nf ng nh ni b">useChannel</code>，它需要通道名和一个回调作为参数。每次调用<code class="fe nf ng nh ni b">useChannel</code>时，我们从Ably-JS SDK中<code class="fe nf ng nh ni b"><a class="ae lm" href="https://ably.com/documentation/realtime/channels#obtaining-channel" rel="noopener ugc nofollow" target="_blank">get</a></code> <a class="ae lm" href="https://ably.com/documentation/realtime/channels#obtaining-channel" rel="noopener ugc nofollow" target="_blank">请求的通道</a>并准备钩子函数。</p><ul class=""><li id="a5c8" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="ke io"> onMount </strong>是每次渲染组件时运行的代码。在onMount内部，我们将订阅指定的通道，每当接收到消息时就触发<code class="fe nf ng nh ni b">callbackOnMessage</code>。</li><li id="92c5" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="ke io"> onUnmount </strong>是在组件被重新呈现之前卸载组件时运行的代码。在这里，我们将取消订阅频道，这将停止意外的多次连接，再次节省我们的帐户限制。</li><li id="ce25" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="ke io">useeffecthhook</strong>是一个正确调用这些函数的函数，返回onUnmount供React使用。</li></ul><p id="b148" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nf ng nh ni b">AblyReactEffect.js</code>中导出的钩子将如下所示:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="0ce7" class="nq ma in ni b gy nr ns l nt nu">export function useChannel(channelName, callbackOnMessage) {<br/>    const channel = ably.channels.get(channelName);</span><span id="f2ff" class="nq ma in ni b gy nv ns l nt nu">    const onMount = () =&gt; {<br/>        channel.subscribe(msg =&gt; { callbackOnMessage(msg); });<br/>    }</span><span id="7b1b" class="nq ma in ni b gy nv ns l nt nu">    const onUnmount = () =&gt; {<br/>        channel.unsubscribe();<br/>    }</span><span id="e1b4" class="nq ma in ni b gy nv ns l nt nu">    const useEffectHook = () =&gt; {<br/>        onMount();<br/>        return () =&gt; { onUnmount(); };<br/>    };</span><span id="76e1" class="nq ma in ni b gy nv ns l nt nu">    useEffect(useEffectHook);</span><span id="859d" class="nq ma in ni b gy nv ns l nt nu">    return [channel, ably];<br/>}</span></pre><p id="48ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nf ng nh ni b">useChannel</code>钩子返回当前Ably通道和Ably SDK，供调用代码用来发送消息。这个钩子在一个地方巧妙地封装了React功能组件的pub/sub，所以我们不需要在其他地方担心它，使用它的代码可以只处理它接收到的消息。</p><h1 id="9800" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">用CSS模块让一切看起来漂亮— <code class="fe nf ng nh ni b">AblyChatComponent.module.css</code></h1><p id="25db" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">您可能已经注意到，在编写聊天组件时，<code class="fe nf ng nh ni b">Next.js</code>有一些编译器强制的约定，规定了您保存CSS的位置以及如何导入它。<br/>对于这个应用程序，我们将创建一个与<code class="fe nf ng nh ni b">.jsx</code>文件同名的CSS文件，只是扩展名为<code class="fe nf ng nh ni b">.module.css</code>。我们这样做是为了使组件的管理更容易，如果将来我们想删除这个组件，也可以简单地删除它的CSS。创建后，可以将其导入到组件中:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="9a92" class="nq ma in ni b gy nr ns l nt nu">import styles from './AblyChatComponent.module.css';</span></pre><p id="0abe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JSX元素上创建CSS类时，我们在元素上使用以下语法:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="2e21" class="nq ma in ni b gy nr ns l nt nu">className={styles.yourClassName}</span></pre><p id="473b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">附带的css将如下所示:</p><pre class="lo lp lq lr gt nm ni nn no aw np bi"><span id="250f" class="nq ma in ni b gy nr ns l nt nu">.yourClassName {<br/>  styles: gohere;<br/>}</span></pre><p id="337f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个应用程序是用<a class="ae lm" href="https://css-tricks.com/snippets/css/complete-guide-grid/" rel="noopener ugc nofollow" target="_blank"> CSS Grid </a>来创建应用程序布局的，当然欢迎你使用这个项目提供的CSS或者自己编写或者使用框架。</p><h1 id="8ab3" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">在Vercel上托管</h1><p id="1f98" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们使用<code class="fe nf ng nh ni b">Vercel</code>作为我们的开发服务器和构建管道。</p><blockquote class="mw mx my"><p id="0940" class="kc kd mz ke b kf kg jo kh ki kj jr kk na km kn ko nb kq kr ks nc ku kv kw kx ig bi translated"><em class="in">将Next.js部署到生产的最简单方法是使用Next.js的创建者提供的Vercel平台。Vercel是一个一体化平台，具有支持静态&amp; Jamstack部署和无服务器功能的全局CDN。<br/>—</em><a class="ae lm" href="https://nextjs.org/docs/deployment" rel="noopener ugc nofollow" target="_blank"><em class="in">next . js文档</em> </a></p></blockquote><p id="e0a1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了将新的聊天应用程序部署到Vercel，您需要:</p><ol class=""><li id="07c8" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ne le lf lg bi translated">创建一个<a class="ae lm" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub账户</a>(如果你还没有的话)</li><li id="f505" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated"><a class="ae lm" href="https://docs.github.com/en/free-pro-team@latest/github/creating-cloning-and-archiving-repositories/creating-a-new-repository" rel="noopener ugc nofollow" target="_blank">将你的应用推送到GitHub库</a></li><li id="f4c3" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated"><a class="ae lm" href="https://vercel.com/signup" rel="noopener ugc nofollow" target="_blank">创建一个Vercel账户</a></li><li id="9c95" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated">创建一个新的Vercel应用程序，并从GitHub存储库中导入您的应用程序。(这将要求您授权Vercel使用您的GitHub帐户)</li><li id="ef2c" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated">添加您的<code class="fe nf ng nh ni b">ABLY_API_KEY</code>作为环境变量</li><li id="17d0" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated">观看您的应用部署</li><li id="cc0f" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ne le lf lg bi translated">在浏览器中访问新创建的URL！</li></ol><h1 id="5673" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">让它成为你自己的</h1><p id="f3fe" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">有几种方法可以扩展这个例子:</p><h1 id="5f76" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">添加消息历史记录</h1><p id="38c9" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">此演示中目前没有聊天记录，您将只能看到加入聊天后收到的消息。你可以通过使用<a class="ae lm" href="https://ably.com/documentation/realtime/history" rel="noopener ugc nofollow" target="_blank"> Ably的倒带功能</a>来扩展这个演示，免费播放长达两分钟的历史，或者使用付费帐户，长达48小时。</p><h1 id="1e12" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">添加用户名</h1><p id="6365" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">聊天信息中没有发送任何用户名。这个演示可以扩展为引入一个用户名输入框，并在消息发送时添加当前用户名。</p><p id="d749" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该演示使用随机生成的Ably客户端Id作为唯一标识符——这是它如何检测发送消息的是“我”还是“其他人”。</p><h1 id="7114" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">结论</h1><p id="0d01" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">如果这篇教程有帮助，或者你在你的项目中使用了Next.js，我们很乐意听听。在推特上给我们留言<a class="ae lm" href="https://twitter.com/ablyrealtime" rel="noopener ugc nofollow" target="_blank">或者发邮件给我们</a><a class="ae lm" href="mailto:devrel@ably.io" rel="noopener ugc nofollow" target="_blank"> devrel@ably.io </a>。</p></div></div>    
</body>
</html>