<html>
<head>
<title>The Front-end Developer’s Guide to Back-end Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后端开发的前端开发人员指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-front-end-developers-guide-to-back-end-development-4ffb1cc55449?source=collection_archive---------5-----------------------#2021-06-03">https://javascript.plainenglish.io/the-front-end-developers-guide-to-back-end-development-4ffb1cc55449?source=collection_archive---------5-----------------------#2021-06-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d90c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为前端JavaScript开发人员如何入门一个简单的Node.js后端？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae3e35b5b0b6d8194ece128a7b4b734a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LBw11Nx7uClwdW1d"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@sickhews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Wes Hicks</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f37a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你开始做前端开发人员时，后端方面的事情往往看起来过于复杂，学习曲线看起来相当陡峭。许多后端教程将使用Python或其他外语，您可能认为您需要学习如何管理服务器、编写路由规则、维护数据库——这个列表是无穷无尽的。</p><p id="45c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，在这个现代世界中，根本没有必要考虑或学习后端的大部分复杂性。也没有任何理由不开始用JavaScript编写。🚀</p><p id="4562" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我们将使用Node.js和Express在Google云平台上设置一个简单安全的后端API服务。</p><h2 id="3957" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">为什么需要后端？</h2><p id="d3f7" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">一些应用程序从来不需要一行后端代码。如果你的应用程序是一个在线的ToDo应用程序，只是在本地主机中存储数据，那么后端就毫无意义。有时后端是完全抽象的——例如，如果您使用Google Firebase进行身份验证，并从前端直接与Google Firestore交互，那么您可能永远不需要自己编写的后端服务。</p><p id="c9c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，作为开发人员，在某些时候，您很可能需要在后端发生一些事情。这样做的主要好处是<strong class="jm io">代码不在用户手中</strong>——不在他们的浏览器中。这意味着您可以在后端做一些从前端做起来不安全的事情，例如，使用API密钥调用昂贵的第三方API，或者向用户帐户添加点数。请记住，前端的所有代码都是可读的，并且能够被恶意用户操纵。</p><p id="68af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">拥有后端的另一个原因是接收异步数据。假设您有一个使用Stripe进行支付的订阅服务。你可以(以某种令人费解的方式)让用户注册你的应用，并通过stripe进行初步支付，让他们通过前端的付费墙，但下个月当用户的卡下降时会发生什么？Stripe将向您发送一个webhook，您需要一个始终可用的服务来接收数据并对您的应用程序状态进行更改。</p><p id="6777" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于这两种情况(以及许多其他情况),一个简单的Node.js API服务是完美的工具。</p><h1 id="b01e" class="lx la in bd lb ly lz ma le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn bi translated">HTTP API服务的基础</h1><p id="7aad" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">让我们先回顾一些基本概念…</p><h2 id="3541" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">请求和回应</h2><p id="48f0" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">用最简单的话来说，您将处理<strong class="jm io">请求</strong> ( <em class="mo">请求</em>)和<strong class="jm io">响应</strong> ( <em class="mo">请求</em>)。如果您曾经在前端使用fetch或Axios从第三方API获取数据，您会对这些术语很熟悉。</p><p id="f3a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在前端工作时，你<em class="mo">向后端<strong class="jm io"> </strong>发送</em>一个<strong class="jm io">请求</strong>以获取一些数据，并且(如果一切顺利的话)你将<em class="mo">收到</em>一个<strong class="jm io">响应</strong>以及你所请求的数据。</p><p id="c992" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，当在后端工作时，你将<em class="mo">接收</em>一个<strong class="jm io">请求</strong>，进行某种计算，然后<em class="mo">向</em>发回一个<strong class="jm io">响应</strong>。</p><p id="8612" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个小图表中的概念:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/1701f09457299f2728b6ebbb1635e75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ck9GOCh_6kKqPIvuva6vw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">It really couldn’t be simpler. Front-end sends a request, back-end receives a request. Back-end sends a response, front-end receives a response.</figcaption></figure><h2 id="9519" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">路线</h2><p id="ae9a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">接下来要考虑的是后端在哪里接收请求。因为我们是通过HTTP(希望是HTTPS)进行通信的，所以我们能够通过路由来分离我们的API逻辑。你可以把它想象成一个前端网站的页面。每个页面在一个域中有不同的路由，每个页面有不同的用途。假设你在https://your-website.com/contact.有一个联系页面，这里的域名是“your-website.com”，路径是“/contact”。</p><p id="32f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">后端以类似的格式拆分。您可以在“api.your-website.com”域中使用API服务，并且在该服务上，您可以有一个将提交的联系表单保存到数据库“/contact-form-submissions”的路径。在这个例子中，你的前端将发送一些数据到<a class="ae ky" href="https://api.your-website.com/contact-form-submission." rel="noopener ugc nofollow" target="_blank">https://api.your-website.com/contact-form-submissions.</a>你的后端将从<strong class="jm io">路由</strong> (/contact-form-submissions)知道它应该如何处理这个<strong class="jm io">请求</strong>——它将做一些计算，例如将数据保存到数据库，可能给管理员发送一封关于它的电子邮件，最后它将向前端发送一个响应。</p><p id="9d71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">需要注意的是，在这种情况下，即使前端不需要任何数据返回，后端仍然必须发送一个<strong class="jm io">响应</strong>。每个HTTP通信都有一个<strong class="jm io">请求</strong>和一个<strong class="jm io">响应</strong>。发送回一个<strong class="jm io">响应</strong>允许前端知道后端已经完成了它需要做的事情，并向用户提供一些反馈。如果您没有从后端发回任何响应，前端就会挂起并等待响应，直到超时。</p><h2 id="d071" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">HTTP方法</h2><p id="d0de" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">与前端的页面不同，后端的路线可以分成不同的方法。您将使用的最常见的是:</p><ul class=""><li id="6909" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated">得到</li><li id="e4e4" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">邮政</li><li id="0d71" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">放</li><li id="36ef" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">删除</li></ul><p id="fc9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">理解后端API服务中的<strong class="jm io">一个路由</strong>可以有<strong class="jm io">多个方法</strong>做完全不同的事情是很重要的。</p><p id="a6b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们以/contact-form-submissions路线为例:</p><p id="91da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以向该路由发送一个<strong class="jm io"> GET </strong>请求，您的后端可以发送回一个包含所有联系人表单提交的数组。</p><p id="d5f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以向该路由发送一个带有一些数据的<strong class="jm io"> POST </strong>请求，您的后端可以将数据保存到数据库中。</p><p id="1ed6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以发送一个带有一些数据的<strong class="jm io"> PUT </strong>请求到该路由，后端可以更新数据库中的提交。</p><p id="bb23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以向该路由发送一个<strong class="jm io"> DELETE </strong>请求，您的后端可以从数据库中删除所有提交。</p><p id="6ac9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">围绕这些方法有一些标准，可以帮助您实现API服务的最佳实践。一般来说，<strong class="jm io"> GET </strong>请求用于获取数据，<strong class="jm io"> POST </strong>请求用于发送数据，<strong class="jm io"> PUT </strong>请求用于更新数据，<strong class="jm io"> DELETE </strong>请求用于删除数据。然而，这些只是最佳实践，实际上您可以做您想做的任何事情，尽管使用正确的方法确实有它的优点——例如，GET请求可以通过简单地使用头来轻松缓存(我们稍后将讨论头)。</p><p id="7852" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您会发现有些服务的所有路由都是POST方法(比如GQL服务器)，但是对于最基本和高性能的API，您可以只使用GET请求来获取数据，而POST请求用于其他任何事情。我倾向于将此与描述性的路线名称结合起来，以使服务易于交互。对我来说，更容易理解的是对“/ all-contact-form-submission”的GET请求将返回所有联系人表单提交，而对“/new-contact-form-submission”的POST请求将保存一个新的联系人表单提交。</p><p id="43e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需要接收数据时使用GET，需要发送一些数据时使用POST。保持简单。</p><h2 id="d560" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">数据</h2><p id="c518" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">那么数据是如何来回发送的呢？在<strong class="jm io">请求</strong>和<strong class="jm io">响应</strong>里面当然有！</p><p id="a85c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最常见和最简单的数据传输方式是在请求体中使用JSON格式。如果您使用JavaScript已经有一段时间了，那么您一定会遇到JSON。这是一种将JavaScript对象表示为字符串的格式，并通过一些方便的方法内置到JavaScript语言中:<br/>-JSON . stringify(obj)-将js对象转换为JSON字符串<br/>-JSON . parse(string)-将JSON字符串转换为JavaScript对象</p><p id="c9b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个代码示例:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="9b2a" class="kz la in nf b gy nj nk l nl nm">const someObject = {<br/>  name: 'Jamie',<br/>  likes: ['coding', 'surfing', 'potatoes']<br/>}</span><span id="7279" class="kz la in nf b gy nn nk l nl nm">const jsonVersion = JSON.stringify(someObject)<br/>console.log(jsonVersion)<br/>// {"name":"Jamie","likes":["coding","surfing","potatoes"]}</span><span id="1d72" class="kz la in nf b gy nn nk l nl nm">const parsedJsonVersion = JSON.parse(jsonVersion)<br/>console.log(parsedJsonVersion)<br/>//  {<br/>//    name: 'Jamie',<br/>//    likes: ['coding', 'surfing', 'potatoes']<br/>//  }</span></pre><p id="ab41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数情况下，当您的前端向后端发送一些数据时，这些数据将被格式化为JSON，当您的后端接收到这些数据时，这些数据将被从JSON解析回JavaScript对象。另一方面，当您的后端向前端发送一些数据时，这些数据将被格式化为JSON，当您的前端接收到这些数据时，这些数据将被从JSON解析回JavaScript对象。</p><p id="26ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">幸运的是，我们在JavaScript中使用的框架，如前端的Axios和后端的Express，可以为我们做到这一点，所以我们基本上只使用JavaScript对象——奢侈！</p><h2 id="b991" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">头球</h2><p id="d820" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">对于我们的基本后端API服务，需要理解的另一部分是头。每个方法的每个请求都可以有头，这些头是附加到请求或响应中的额外的小块数据，存在于主体数据之外。头用于元数据，如认证令牌、发送的数据类型(在我们的例子中，主要是application/JSON)和缓存设置。</p><p id="7cd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数时候，我们不需要太担心头文件，除非我们有一个复杂的API，我们只是覆盖了基础。</p><p id="73e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您的应用程序包含某种身份验证，让后端知道是什么用户发出请求的一个选项是身份验证令牌的形式。这些有不同的格式，但最常见的是“不记名”令牌。这是一个在登录时获得的令牌，然后添加到后端的所有请求中指定的“<code class="fe no np nq nf b">Authorization</code>”标头中，格式如下:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="fb84" class="kz la in nf b gy nj nk l nl nm">Authorization<!-- -->: `Bearer ${token}`</span></pre><p id="65c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您的后端服务可以很容易地检查这些头，并且您可以基于它们做您需要做的事情。</p><h2 id="3de2" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">响应代码</h2><p id="d217" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">谜题的最后一块是响应代码。这些信息与来自后端的响应一起发送，基本上是关于被发送回的响应类型的元信息。所有响应代码都是数字，并且这些数字在为不同目的设计的范围内:</p><ul class=""><li id="609e" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated">100–199 =信息响应</li><li id="36b5" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">200–299 =成功回答</li><li id="58ca" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">300–399 =重定向</li><li id="7e3d" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">400–499 =客户端错误</li><li id="4314" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">500–599 =服务器错误</li></ul><p id="9560" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您会发现最常见的响应代码是:</p><ul class=""><li id="d03e" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated">200 = OK成功。<br/>表示请求已经成功。</li><li id="560b" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">400 =错误的请求。<br/>表示前端发送了坏的/意外的数据</li><li id="1177" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">401 =未授权。<br/>表示发送请求的客户端未被认证或授权访问端点。</li><li id="3f51" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">404 =未找到。<br/>表示没有找到请求的资源。</li><li id="2222" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">500 =服务器错误。<br/>表示您的后端代码出了问题，出现了意外/未处理的错误。</li></ul><p id="a73b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您在前端工作时，由您来处理这些不同的响应代码，如果返回的不是成功的(100-299)状态代码，Axios之类的库就会抛出一个错误。</p><p id="3cb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您在后端<strong class="jm io">工作时，由您来发送响应</strong>的相关状态代码。如果前端发送一个未找到的数据请求，您应该发回一个404状态代码。如果一切正常，您应该发回一个200状态代码。您将所有代码包装在try/catch中，并在发生意外错误时将500代码发送回客户端。</p><p id="a67a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发回错误的错误代码可能会使前端编码人员非常困惑，并且前端逻辑可能会根据响应代码提供不同的用户体验。想象一下，如果返回401响应代码，前端应用程序会将用户重定向到登录页面。如果您不小心发送了401代码而不是404(未找到)代码，这可能会在前端导致一些令人困惑的错误！</p><p id="99c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">幸运的是，作为一个后端开发人员，所有可能的响应代码都有很好的文档记录，你可以在这里找到它们的列表:<br/>【https://developer.mozilla.org/en-US/docs/Web/HTTP/Status】T4</p><h1 id="47b5" class="lx la in bd lb ly lz ma le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn bi translated">让我们开始编码吧！</h1><p id="e36c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">好了，说够了。让我们写一些代码。对于这个例子，我们将在一个文件中编写一些非常简洁和现代的JavaScript，它将在我们的API中公开几个路由。写后端代码的一个好处是你不需要担心浏览器。我们设置我们想要的环境，所以我们可以写非常现代的JS，而不用担心兼容性。</p><p id="6b9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从做一个新项目开始。打开你最喜欢的终端，创建一个新的节点项目。(我将使用纱线，但如果你喜欢，也可以使用NPM)。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ab08" class="kz la in nf b gy nj nk l nl nm">$ mkdir my-first-api &amp;&amp; cd my-first-api &amp;&amp; yarn init</span></pre><p id="0aa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行交互式yarn会话，为您的项目创建基本的package.json。(回车回车回车)。</p><p id="7562" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们将安装Express，这是最常见且非常易于使用的节点包，用于处理HTTP请求和响应。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="f058" class="kz la in nf b gy nj nk l nl nm">yarn add express</span></pre><p id="6c95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要使用的另一个方便的包是<code class="fe no np nq nf b">cors</code>。CORS代表跨源资源共享，说白了就是你的后端将允许来自不同域的前端的请求。如果您的API服务位于像api.your-website.com这样的子域中，这将非常有用。如果您不在后端启用CORS，您的前端将无法发送任何请求。CORS可能很复杂，所以对于我们的基本示例，我们将允许来自所有来源或域的请求。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="e99a" class="kz la in nf b gy nj nk l nl nm">yarn add cors</span></pre><p id="e182" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个对任何API服务都有用的包<code class="fe no np nq nf b">cookie-parser</code>是一个很小的库，它将把请求中的cookies解析成JavaScript对象，这样我们就可以轻松地读取它们。我们现在可能不需要这个，但是知道这个很好。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="486e" class="kz la in nf b gy nj nk l nl nm">yarn add cookie-parser</span></pre><p id="f99c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我们目前所需要的，所以让我们创建一个index.js文件来开始编写代码:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="34f7" class="kz la in nf b gy nj nk l nl nm">touch index.js</span></pre><p id="5f63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在您最喜欢的编辑器中打开该文件，并导入我们安装的软件包:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="2903" class="kz la in nf b gy nj nk l nl nm">import express from 'express'<br/>import cors from 'cors'<br/>import cookieParser from 'cookie-parser'</span></pre><p id="e9af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将通过作为函数调用Express并将其结果存储在const中来创建Express的实例。做这件事的标准快捷方式是打电话给警察<code class="fe no np nq nf b">app</code>:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3f5d" class="kz la in nf b gy nj nk l nl nm">const app = express()</span></pre><p id="b479" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们将告诉Express实例(<code class="fe no np nq nf b">app</code>)使用<code class="fe no np nq nf b">cors</code>和<code class="fe no np nq nf b">cookie-parser</code>。Express是基于插件和可扩展的，所以我们需要做的就是调用<code class="fe no np nq nf b">use()</code>函数并传入相关的库:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="bb53" class="kz la in nf b gy nj nk l nl nm">app.use(cors())<br/>app.use(cookieParser())</span></pre><p id="e47b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以做的另一件事是告诉Express，这将是一个主要基于JSON的API，它应该自动尝试和解析任何请求中的JSON。这样我们就不用这么做了，并且将在请求中的一个名为<code class="fe no np nq nf b">body</code>的对象中公开数据，我们稍后将会了解这个内容。我们将把一个对象作为参数传递给JSON插件，这将把JSON有效负载的大小限制提高到50MB，但是可以根据需要设置。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d121" class="kz la in nf b gy nj nk l nl nm">app.use(express.json({ limit: '50mb' }))</span></pre><p id="7db9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是设置，所以让我们写我们的第一条路线！我们将编写一个简单的GET请求路由，它只使用一个字符串进行响应。我们将能够在我们的浏览器中点击这条路线，我们应该看到我们的字符串返回。快速应用程序为每种请求方法提供了一种功能:</p><ul class=""><li id="242d" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated">GET = <code class="fe no np nq nf b">app.get()</code></li><li id="f9a6" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">POST = <code class="fe no np nq nf b">app.post()</code></li><li id="21e2" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">PUT = <code class="fe no np nq nf b">app.put()</code></li><li id="fdc9" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">删除= <code class="fe no np nq nf b">app.delete()</code></li><li id="ce4f" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">诸如此类…</li></ul><p id="805c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在每个函数中，第一个参数总是相对格式的路线。省去协议和域部分。在我们的例子中，我们将选择路线<code class="fe no np nq nf b">/hello-api</code>。下一个参数是一个处理函数，它传递一个请求和响应对象，并进行一些计算。它看起来有点像这样:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="eb74" class="kz la in nf b gy nj nk l nl nm">app.get('/hello-api', (req, res) =&gt; {<br/>  // do some stuff<br/>})</span></pre><p id="e2cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">API中的所有路由都将遵循相同的格式。随着API服务变得越来越大越来越复杂，你可以使用许多不同的方法来拆分代码，使其更易于维护，但它将始终遵循这种基本格式。</p><p id="7167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还记得本文前面的请求和响应概念吗？让我们把它们派上用场吧！request对象可作为处理函数的第一个参数(<code class="fe no np nq nf b">req</code>)，response对象可作为第二个参数(<code class="fe no np nq nf b">res</code>)。每个对象都有一些有用的属性，有些是数据，有些是函数。<code class="fe no np nq nf b">req.body</code>将存储任何请求数据，而<code class="fe no np nq nf b">res.json()</code>函数对于将对象作为JSON发送回前端非常有用。</p><p id="e7fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们的<code class="fe no np nq nf b">/hello-api</code>路由，我们不期望任何数据与请求一起发送(毕竟，这是一个get请求路由)，我们将只发送一个200响应代码和一个字符串。为此，我们将在处理函数中添加一行代码:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="66da" class="kz la in nf b gy nj nk l nl nm">app.get('/hello-api', (req, res) =&gt; {<br/>  // do some stuff<br/>  return res.status(200).send('Hello front-end!')<br/>})</span></pre><p id="c95f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们创建的第一条后端路线！</p><p id="ac45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意如何在响应对象上链接函数。这样写起来超级简单。</p><p id="fcf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要做的最后一件事是实际运行API服务，并让它监听本地端口上的请求。当您实际上在Google Cloud Run这样的地方托管API服务时，标准的做法是注入一个端口环境变量。因此，我们将告诉我们的应用程序检查一个env变量，并默认为端口3001。这意味着当我们在本地运行应用程序时，它将在<a class="ae ky" href="http://localhost:3001" rel="noopener ugc nofollow" target="_blank"> http://localhost:3001 </a>上可用。我们还将设置一个函数，以便在服务器启动运行并准备好接受请求时记录到控制台:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="e167" class="kz la in nf b gy nj nk l nl nm">const port = process.env.PORT || 3001<br/>app.listen(port, () =&gt; {<br/>  console.log(`Server listening on port ${port}...`)<br/>})</span></pre><p id="f8f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的整个后端应用程序目前看起来像这样:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="e9f9" class="kz la in nf b gy nj nk l nl nm">import express from 'express'<br/>import cors from 'cors'<br/>import cookieParser from 'cookie-parser'</span><span id="6d8d" class="kz la in nf b gy nn nk l nl nm">const app = express()</span><span id="5faa" class="kz la in nf b gy nn nk l nl nm">app.use(cors())<br/>app.use(cookieParser())</span><span id="3179" class="kz la in nf b gy nn nk l nl nm">app.use(express.json({ limit: '50mb' }))</span><span id="78b8" class="kz la in nf b gy nn nk l nl nm">app.get('/hello-api', (req, res) =&gt; {<br/>  // do some stuff<br/>  return res.status(200).send('Hello front-end!')<br/>})</span><span id="0931" class="kz la in nf b gy nn nk l nl nm">const port = process.env.PORT || 3001<br/>app.listen(port, () =&gt; {<br/>  console.log(`Server listening on port ${port}...`)<br/>})</span></pre><p id="fed6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多么简洁！</p><p id="1c1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们运行应用程序。对于热重装，我们也可以使用<code class="fe no np nq nf b">nodemon</code>。让我们将它添加到我们的开发依赖项中:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ea80" class="kz la in nf b gy nj nk l nl nm">$ yarn add nodemon -D</span></pre><p id="d177" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，nodemon不理解模块，所以我们将它与<code class="fe no np nq nf b">esm</code>包一起使用:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a29e" class="kz la in nf b gy nj nk l nl nm">$ yarn add esm -D</span></pre><p id="a403" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们将添加一个<code class="fe no np nq nf b">dev</code>脚本到我们的package.json中，它将运行<code class="fe no np nq nf b">nodemon -r esm index.js</code>。package.json将如下所示:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="f990" class="kz la in nf b gy nj nk l nl nm">{<br/>  "name": "my-first-api",<br/>  "version": "1.0.0",<br/>  "main": "index.js",<br/>  "license": "MIT",<br/>  "scripts": {<br/>    "dev": "nodemon -r esm index.js"<br/>  },<br/>  "dependencies": {<br/>    "cookie-parser": "^1.4.5",<br/>    "cors": "^2.8.5",<br/>    "express": "^4.17.1"<br/>  },<br/>  "devDependencies": {<br/>    "esm": "^3.2.25",<br/>    "nodemon": "^2.0.7"<br/>  }<br/>}</span></pre><p id="d71e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在应该能够运行该脚本，并且应该看到我们的console.log消息<code class="fe no np nq nf b">Server listening on port 3001...</code></p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="35a0" class="kz la in nf b gy nj nk l nl nm">$ yarn dev</span></pre><p id="8d5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在打开你的浏览器，进入<a class="ae ky" href="http://localhost:3000/hello-api." rel="noopener ugc nofollow" target="_blank">http://localhost:3001/hello-API。</a>您应该会看到您的消息出现<code class="fe no np nq nf b">Hello front-end</code>。</p><p id="1cef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那里发生了什么？当我们从浏览器点击一个URL时，它总是会发出一个GET请求。因此，我们向api服务的/hello-api路由发出GET请求。我们的Express应用程序查看是否有为/hello-api路径上的GET方法定义的处理程序函数——确实有——并在处理程序中运行JavaScript代码。该代码的一部分发送回一个带有200代码和文本<code class="fe no np nq nf b">Hello front-end</code>的响应。我们的浏览器得到响应，看到这是一个200状态，并试图呈现响应中返回的任何内容，即我们的文本。</p><p id="6ddf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个发送回一些JSON数据的路由。在/hello-api处理程序的上面或下面添加这个新的路由处理程序。重要的是，所有的路线处理程序都发生在Express应用程序设置之后，但在<code class="fe no np nq nf b">app.listen()</code>功能之前。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6bd0" class="kz la in nf b gy nj nk l nl nm">app.get('/give-me-json', (req, res) =&gt; {<br/>  const someData = {<br/>    name: 'Jamie',<br/>    likes: ['coding', 'surfing', 'potatoes']<br/>  }</span><span id="a763" class="kz la in nf b gy nn nk l nl nm">  return res.status(200).json(someData)<br/>})</span></pre><p id="42a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的整个index.js现在看起来像这样:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d4f6" class="kz la in nf b gy nj nk l nl nm">import express from 'express'<br/>import cors from 'cors'<br/>import cookieParser from 'cookie-parser'</span><span id="9041" class="kz la in nf b gy nn nk l nl nm">const app = express()</span><span id="8977" class="kz la in nf b gy nn nk l nl nm">app.use(cors())<br/>app.use(cookieParser())</span><span id="ccf7" class="kz la in nf b gy nn nk l nl nm">app.use(express.json({ limit: '50mb' }))</span><span id="2bc6" class="kz la in nf b gy nn nk l nl nm">app.get('/hello-api', (req, res) =&gt; {<br/>  // do some stuff<br/>  return res.status(200).send('Hello front-end!')<br/>})</span><span id="80b0" class="kz la in nf b gy nn nk l nl nm">app.get('/give-me-json', (req, res) =&gt; {<br/>  const someData = {<br/>    name: 'Jamie',<br/>    likes: ['coding', 'surfing', 'potatoes']<br/>  }</span><span id="1162" class="kz la in nf b gy nn nk l nl nm">return res.status(200).json(someData)<br/>})</span><span id="8e25" class="kz la in nf b gy nn nk l nl nm">const port = process.env.PORT || 3001<br/>app.listen(port, () =&gt; {<br/>  console.log(`Server listening on port ${port}...`)<br/>})</span></pre><p id="f05f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保存它，确保nodemon重新启动，然后打开浏览器并进入<a class="ae ky" href="http://localhost:3001/give-me-json." rel="noopener ugc nofollow" target="_blank">http://localhost:3001/give-me-JSON。</a>您应该看到浏览器中显示了表示为JSON的<code class="fe no np nq nf b">someData</code>对象。简单！</p><p id="bbd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们尝试向API服务发送一个POST请求。最简单的方法是用我为你做的一个小笔:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="06bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将允许您点击本地主机上的任何路由。确保为任何post请求输入有效的JSON！响应数据显示在请求按钮下方。</p><p id="318a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们的第一个POST请求，我们将在应用程序中创建一个简单的js对象状态。将此添加到您的文件中:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="8b9a" class="kz la in nf b gy nj nk l nl nm">const database = {<br/>  users: []<br/>}</span></pre><p id="189d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在那个对象中存储内容。注意，每次nodemon重新加载后，它都是空的。</p><p id="31f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们将创建一个简单的post路由，将用户保存在数据库对象的用户数组中。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="1da2" class="kz la in nf b gy nj nk l nl nm">app.post('/add-user', (req, res) =&gt; {</span><span id="28df" class="kz la in nf b gy nn nk l nl nm">})</span></pre><p id="d87b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个路由的处理程序将从请求对象<code class="fe no np nq nf b">req</code>中获取我们从前端发送的数据。因为我们使用的是<code class="fe no np nq nf b">express.json()</code>插件，我们不需要担心JSON的转换——它只是作为一个对象在<code class="fe no np nq nf b">req.body</code>中可用。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a6c4" class="kz la in nf b gy nj nk l nl nm">app.post('/add-user', (req, res) =&gt; {<br/>  // get the data out of the request<br/>  const newUser = req.body<br/>})</span></pre><p id="7a3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将进行一点验证，如果验证失败，将返回一个400状态(记住400意味着坏数据/客户端错误)。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="5c1f" class="kz la in nf b gy nj nk l nl nm">app.post('/add-user', (req, res) =&gt; {<br/>  // get the data out of the request<br/>  const newUser = req.body</span><span id="2fb0" class="kz la in nf b gy nn nk l nl nm">  // validate the user has a firstName<br/>  // and a lastName<br/>  if (!newUser || !newUser.firstName || !newUser.lastName) {<br/>    return res<br/>      .status(400)<br/>      .send('Make sure the user has a firstName and lastName')<br/>  }<br/>})</span></pre><p id="b2d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们将增强发送给我们的数据，为用户添加一个时间戳，并给用户一个id(只是在数组中的位置)。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d9fb" class="kz la in nf b gy nj nk l nl nm">app.post('/add-user', (req, res) =&gt; {<br/>  // get the data out of the request<br/>  const newUser = req.body</span><span id="16e4" class="kz la in nf b gy nn nk l nl nm">  // validate the user has a firstName<br/>  // and a lastName<br/>  if (!newUser || !newUser.firstName || !newUser.lastName) {<br/>    return res<br/>      .status(400)<br/>      .send('Make sure the user has a firstName and lastName')<br/>  }</span><span id="9689" class="kz la in nf b gy nn nk l nl nm">  // add a timestamp and give the user an id<br/>  newUser.timeStamp = new Date().toISOString()<br/>  newUser.id = database.users.length<br/>})</span></pre><p id="a7a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们将数据添加到我们的用户数组，并将增强的用户对象发送回前端</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ddf3" class="kz la in nf b gy nj nk l nl nm">app.post('/add-user', (req, res) =&gt; {<br/>  // get the data out of the request<br/>  const newUser = req.body</span><span id="d9fc" class="kz la in nf b gy nn nk l nl nm">  // validate the user has a firstName<br/>  // and a lastName<br/>  if (!newUser || !newUser.firstName || !newUser.lastName) {<br/>    return res<br/>      .status(400)<br/>      .send('Make sure the user has a firstName and lastName')<br/>  }</span><span id="b820" class="kz la in nf b gy nn nk l nl nm">  // add a timestamp and give the user an id<br/>  newUser.timeStamp = new Date().toISOString()<br/>  newUser.id = database.users.length</span><span id="ec7c" class="kz la in nf b gy nn nk l nl nm">  // add the user to the database<br/>  database.users.push(newUser)<br/>  <br/>  // return the new user in the response<br/>  return res.status(200).json(newUser)<br/>})</span></pre><p id="0830" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保存您的文件，确保nodemon重新加载并测试新路线。确保点击了<code class="fe no np nq nf b">/add-user</code>端点，并将方法设置为<code class="fe no np nq nf b">post</code>，下面是一些要发送的JSON:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="948a" class="kz la in nf b gy nj nk l nl nm">{<br/>  "firstName": "Bilbo",<br/>  "lastName": "Baggins"<br/>}</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="30ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">几次点击该路径，您应该会看到时间戳和id发生了变化，如果您决定更改的话，还会看到名字和姓氏。</p><p id="3334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">厉害！</p><p id="9c61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用Express可以做的另一件事是使用URL参数。这些是路由的可变部分，便于向get请求添加上下文。例如，让我们制作另一个GET route处理程序，通过用户id获取用户数据。我们将使用URL参数<code class="fe no np nq nf b">:id</code>(注意表示路线动态部分的<code class="fe no np nq nf b">:</code>)，它将在<code class="fe no np nq nf b">req.params.id</code>的请求对象上可用。路由将是<code class="fe no np nq nf b">/user/:id</code>，当我们从前端请求它时，我们将用用户的实际id<code class="fe no np nq nf b">/user/1</code>替换<code class="fe no np nq nf b">:id</code>。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3622" class="kz la in nf b gy nj nk l nl nm">app.get('/user/:id', (req, res) =&gt; {<br/>  // get the user id out of the request params<br/>  const userId = req.params.id<br/>})</span></pre><p id="ba58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们可以在我们的<code class="fe no np nq nf b">database.users</code>数组中查找该用户:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="4c20" class="kz la in nf b gy nj nk l nl nm">app.get('/user/:id', (req, res) =&gt; {<br/>  // get the user id out of the request params<br/>  const userId = req.params.id</span><span id="5a9f" class="kz la in nf b gy nn nk l nl nm">  // look for the user in the data store<br/>  const user = database.users.find(x =&gt; `${x.id}` === userId)<br/>})</span></pre><p id="81f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果没有找到用户，我们将返回404(未找到)状态</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="4b04" class="kz la in nf b gy nj nk l nl nm">app.get('/user/:id', (req, res) =&gt; {<br/>  // get the user id out of the request params<br/>  const userId = req.params.id</span><span id="f7d1" class="kz la in nf b gy nn nk l nl nm">  // look for the user in the data store<br/>  const user = database.users.find(x =&gt; `${x.id}` === userId)</span><span id="b4c5" class="kz la in nf b gy nn nk l nl nm">  // send a 404 if user not found<br/>  if (!user) {<br/>    return res<br/>      .status(404)<br/>      .send(`No user with id: ${userId} found in database`)<br/>  }<br/>})</span></pre><p id="4b2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，如果发现带有200(成功)状态代码的用户数据，则以JSON的形式发送回用户数据:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="9f12" class="kz la in nf b gy nj nk l nl nm">app.get('/user/:id', (req, res) =&gt; {<br/>  // get the user id out of the request params<br/>  const userId = req.params.id</span><span id="65b7" class="kz la in nf b gy nn nk l nl nm">  // look for the user in the data store<br/>  const user = database.users.find(x =&gt; `${x.id}` === userId)</span><span id="a921" class="kz la in nf b gy nn nk l nl nm">  // send a 404 if user not found<br/>  if (!user) {<br/>    return res<br/>      .status(404)<br/>      .send(`No user with id: ${userId} found in database`)<br/>  } else {<br/>    return res.status(200).json(user)<br/>  }<br/>})</span></pre><p id="dcfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此时，您的完整index.js将如下所示:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="9c32" class="kz la in nf b gy nj nk l nl nm">import express from 'express'<br/>import cors from 'cors'<br/>import cookieParser from 'cookie-parser'</span><span id="dcf3" class="kz la in nf b gy nn nk l nl nm">const app = express()</span><span id="8264" class="kz la in nf b gy nn nk l nl nm">app.use(cors())<br/>app.use(cookieParser())</span><span id="173a" class="kz la in nf b gy nn nk l nl nm">app.use(express.json({ limit: '50mb' }))</span><span id="bbdc" class="kz la in nf b gy nn nk l nl nm">app.get('/hello-api', (req, res) =&gt; {<br/>  // do some stuff<br/>  return res.status(200).send('Hello front-end!')<br/>})</span><span id="c6d4" class="kz la in nf b gy nn nk l nl nm">app.get('/give-me-json', (req, res) =&gt; {<br/>  const someData = {<br/>    name: 'Jamie',<br/>    likes: ['coding', 'surfing', 'potatoes']<br/>  }</span><span id="8e63" class="kz la in nf b gy nn nk l nl nm">  return res.status(200).json(someData)<br/>})</span><span id="5313" class="kz la in nf b gy nn nk l nl nm">const database = {<br/>  users: []<br/>}</span><span id="672a" class="kz la in nf b gy nn nk l nl nm">app.post('/add-user', (req, res) =&gt; {<br/>  // get the data out of the request<br/>  const newUser = req.body</span><span id="8fad" class="kz la in nf b gy nn nk l nl nm">  // validate the user has a firstName<br/>  // and a lastName<br/>  if (!newUser || !newUser.firstName || !newUser.lastName) {<br/>    return res<br/>      .status(400)<br/>      .send('Make sure the user has a firstName and lastName')<br/>  }</span><span id="ad9e" class="kz la in nf b gy nn nk l nl nm">  // add a timestamp and give the user an id<br/>  newUser.timeStamp = new Date().toISOString()<br/>  newUser.id = database.users.length</span><span id="d873" class="kz la in nf b gy nn nk l nl nm">  // add the user to the database<br/>  database.users.push(newUser)</span><span id="4b1c" class="kz la in nf b gy nn nk l nl nm">  // return the new user in the response<br/>  return res.status(200).json(newUser)<br/>})</span><span id="1095" class="kz la in nf b gy nn nk l nl nm">app.get('/user/:id', (req, res) =&gt; {<br/>  // get the user id out of the request params<br/>  const userId = req.params.id</span><span id="010c" class="kz la in nf b gy nn nk l nl nm">  // look for the user in the data store<br/>  const user = database.users.find(x =&gt; `${x.id}` === userId)</span><span id="07c0" class="kz la in nf b gy nn nk l nl nm">  // send a 404 if user not found<br/>  if (!user) {<br/>    return res<br/>      .status(404)<br/>      .send(`No user with id: ${userId} found in database`)<br/>  } else {<br/>    return res.status(200).json(user)<br/>  }<br/>})</span><span id="18a4" class="kz la in nf b gy nn nk l nl nm">const port = process.env.PORT || 3001<br/>app.listen(port, () =&gt; {<br/>  console.log(`Server listening on port ${port}...`)<br/>})</span></pre><p id="6dbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保存文件，确保nodemon重新加载，通过点击<code class="fe no np nq nf b">/add-user</code>路径再次将用户添加到数据库，然后通过点击<code class="fe no np nq nf b">/user/0</code>路径尝试将该用户从数据库中取出。也许可以再添加一些用户，并尝试再次获取他们的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0d04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哇，我们已经涵盖了很多东西。我希望这能在你掌握后端的道路上帮助你！有很多东西需要学习，但是你现在应该已经掌握了基础知识，剩下的就是JavaScript了！:D</p><p id="602a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编码快乐！</p><h1 id="c636" class="lx la in bd lb ly lz ma le mb mc md lh me mf mg lk mh mi mj ln mk ml mm lq mn bi translated">支持你的创作者！</h1><p id="3086" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果你觉得这个故事有用，并希望我继续写有用的内容，请考虑在<a class="ae ky" href="https://www.patreon.com/jamiecurnow" rel="noopener ugc nofollow" target="_blank"> Patreon </a>上支持我🤗</p><div class="nt nu gp gr nv nw"><a href="https://www.patreon.com/jamiecurnow" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">Jamie Curnow正在开发软件| Patreon</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">今天就成为Jamie Curnow的赞助人:在世界上最大的…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">www.patreon.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div><p id="c8b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mo">更多内容尽在</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mo">plain English . io</em></a></p></div></div>    
</body>
</html>