<html>
<head>
<title>How to Execute Raw PostgreSQL Queries in NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在NestJS中执行原始PostgreSQL查询</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-execute-raw-postgresql-queries-in-nestjs-1967a0cb950b?source=collection_archive---------1-----------------------#2021-03-21">https://javascript.plainenglish.io/how-to-execute-raw-postgresql-queries-in-nestjs-1967a0cb950b?source=collection_archive---------1-----------------------#2021-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ff755726e98754f2ff5e657b5fff5e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a2T_Y_CuW1aXi9M9"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Caspar Camille Rubin</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7ffc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://docs.nestjs.com/techniques/database" rel="noopener ugc nofollow" target="_blank">正式的NestJS文档</a>有很多例子展示了如何使用ORM框架，比如<a class="ae jz" href="https://typeorm.io/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>与数据库集成。但是，如果您不想使用ORM，而是希望在没有ORM开销的情况下对数据库执行原始查询，该怎么办？</p><p id="f8cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本教程将为您提供一个如何做到这一点的示例。在本教程中，我们将编写一个模块，负责在PostgreSQL数据库上执行SQL查询。</p><h1 id="6399" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">所需依赖项</h1><p id="b872" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为此，我们需要安装一个库，它将允许我们与PostgreSQL数据库接口。<a class="ae jz" href="https://node-postgres.com/" rel="noopener ugc nofollow" target="_blank"> node-postgres </a>是事实上的标准库，所以让我们安装它:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7569" class="mk kz in mg b gy ml mm l mn mo">npm install pg</span></pre><p id="2f37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于NestJS使用TypeScript，我们还可以为节点后缀安装TypeScript定义:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e875" class="mk kz in mg b gy ml mm l mn mo">npm install @types/pg --save-dev</span></pre><h1 id="aec7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">配置文件</h1><p id="b9e5" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">数据库配置通常存储在外部配置文件中，对于不同的环境，您通常会有不同的文件。出于本教程的目的，我们将把我们的数据库设置存储在一个简单的<code class="fe mp mq mr mg b">.env</code>文件中:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Sample .env file</figcaption></figure><p id="87b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们使用NestJS的内置<code class="fe mp mq mr mg b">ConfigModule</code>的话，读取这个文件应该不成问题。我们将在我们的<code class="fe mp mq mr mg b">AppModule</code>导入该模块，并使其全球化:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Configuration of the ConfigModule in the root AppModule. Note the <em class="mu">isGlobal </em>and <em class="mu">envFilePath </em>properties.</figcaption></figure><p id="91ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://docs.nestjs.com/modules#global-modules" rel="noopener ugc nofollow" target="_blank">使模块全局化</a>并不常见，除非您真的计划在大多数应用程序模块中使用它们。阅读配置是一项常见任务，因此使<code class="fe mp mq mr mg b">ConfigModule</code>全球化是有意义的。这样，我们不必在每个应用程序模块中显式导入它。另一个配置属性<code class="fe mp mq mr mg b">envFilePath</code>，是我们的<code class="fe mp mq mr mg b">.env</code>文件的路径。</p><p id="db4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">配置并导入<code class="fe mp mq mr mg b">ConfigModule</code>后，我们现在可以在整个应用程序中使用<code class="fe mp mq mr mg b">ConfigService</code>从我们的配置文件中检索值。例如，在我们的情况下，<code class="fe mp mq mr mg b">configService.get('POSTGRES_USER')</code>将返回<code class="fe mp mq mr mg b">my-user</code>。</p><h1 id="e2d0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数据库模块</h1><p id="2165" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在，让我们创建一个专用模块，它将是我们数据库集成功能的容器。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Empty DatabaseModule</figcaption></figure><p id="2de3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该模块的目的是连接到数据库，并公开一个在数据库上执行查询的服务。</p><p id="db19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从NestJS应用程序连接到数据库的推荐方式是通过<a class="ae jz" href="https://node-postgres.com/features/pooling" rel="noopener ugc nofollow" target="_blank">数据库池</a>。数据库池只是一个node-postgres对象，负责管理到PostgreSQL数据库的连接。</p><p id="40c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们将把这个池注入到我们的数据库服务中，我们可以使用一个<a class="ae jz" href="https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory" rel="noopener ugc nofollow" target="_blank">工厂提供者</a>来创建它。工厂提供者允许我们使用依赖注入来注入其他提供者，比如<code class="fe mp mq mr mg b">ConfigService</code>。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Creating a Pool instance using a factory provider</figcaption></figure><p id="e2ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，我们在模块的<code class="fe mp mq mr mg b">providers</code>数组中定义了我们的提供者，将其命名为<code class="fe mp mq mr mg b">DATABASE_POOL</code>，并告诉NestJS向我们的工厂注入一个<code class="fe mp mq mr mg b">ConfigService</code>实例，这样我们就可以用来自<code class="fe mp mq mr mg b">.env</code>文件的配置来初始化池对象。</p><p id="5642" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们创建一个用于执行查询的数据库服务。<code class="fe mp mq mr mg b">executeQuery</code>方法现在是空白的，我们将名为<code class="fe mp mq mr mg b">DATABASE_POOL</code>的池对象注入到服务中。我们还创建了一个<a class="ae jz" href="https://docs.nestjs.com/techniques/logger#using-the-logger-for-application-logging" rel="noopener ugc nofollow" target="_blank"> NestJS logger </a>的实例，这样我们就可以在数据库查询发生时记录它们。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Injecting database pool to our DatabaseService</figcaption></figure><p id="82fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们需要从我们的<code class="fe mp mq mr mg b">DatabaseModule</code>中导出这个<code class="fe mp mq mr mg b">DatabaseService</code>，这样其他应用程序模块就可以使用它:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Exporting DatabaseService</figcaption></figure><p id="b525" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在可以完成<code class="fe mp mq mr mg b">executeQuery</code>方法，该方法将调用<code class="fe mp mq mr mg b">pool.query()</code>在数据库上执行查询:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Implementing the executeQuery method</figcaption></figure><p id="5acf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该方法很简单:它接受查询文本、可选参数，并返回结果行集。</p><h1 id="3c94" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后:清理</h1><p id="232c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在执行第一个查询之前，我们在<code class="fe mp mq mr mg b">DatabaseModule</code>中初始化的数据库池不会进行任何连接。发生这种情况时，会创建一个新的连接客户端，并在池处于活动状态时保存在池中。如果应用程序关闭，该池会突然关闭，而不会进行任何清理。</p><p id="dd5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，我们可以使用NestJS生命周期挂钩并对终止信号做出反应。监听终止信号<a class="ae jz" href="https://docs.nestjs.com/fundamentals/lifecycle-events#application-shutdown" rel="noopener ugc nofollow" target="_blank">确实会消耗更多的资源</a>，所以这是NestJS的一个可选特性。可以使用应用程序实例的<code class="fe mp mq mr mg b">enableShutdownHooks()</code>方法来启用它。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Enabling shutdown hooks</figcaption></figure><p id="a891" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">启用关闭挂钩后，我们可以在<code class="fe mp mq mr mg b">DatabaseModule</code>中写入实际的关闭挂钩。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Implementing shutdown hook</figcaption></figure><p id="6672" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用一个<a class="ae jz" href="https://docs.nestjs.com/fundamentals/module-ref" rel="noopener ugc nofollow" target="_blank">模块引用</a>从模块上下文中检索我们的池对象的实例，然后调用它的<code class="fe mp mq mr mg b">end()</code>方法来断开所有活动客户端。由于该方法返回一个承诺，NestJS将在关闭序列中等待，直到承诺被解析或拒绝。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h1 id="c62d" class="ky kz in bd la lb nc ld le lf nd lh li lj ne ll lm ln nf lp lq lr ng lt lu lv bi translated">包扎</h1><p id="9750" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">感谢阅读。我希望这个教程对你有用。在NestJS中，直接与数据库交互可能不是很常见的用例，但是当您希望对执行的查询有更多的控制时，它有时会很有用。如果你遇到任何问题，请在评论中告诉我。</p></div></div>    
</body>
</html>