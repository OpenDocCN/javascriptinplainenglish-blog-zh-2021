<html>
<head>
<title>Unit Test your Mongoose Model using Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jest对你的Mongoose模型进行单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-test-your-mongoose-model-using-jest-2daf2303c4bf?source=collection_archive---------1-----------------------#2021-08-23">https://javascript.plainenglish.io/unit-test-your-mongoose-model-using-jest-2daf2303c4bf?source=collection_archive---------1-----------------------#2021-08-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f8ae9978bafc154e087981db471b93de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uvhqjn9sDObKO9iq"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sigmund</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cae8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，我们创建mongoose模型，启动我们的服务器，却从来不去测试这些模型是否像它们应该的那样独立于服务器工作。</p><blockquote class="ky kz la"><p id="8609" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">本文将展示如何使用Jest对您的Mongoose模型进行单元测试。</p></blockquote><h1 id="d8ca" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">安装依赖项</h1><p id="dd72" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们将建立一个包含模型和测试文件的基本项目。我们初始化一个节点项目并安装所有必要的依赖项。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ab14" class="mr lg in mn b gy ms mt l mu mv">npm init -y<br/>npm i mongoose crypto jest mongodb-memory-server</span></pre><p id="58ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么我们这里有什么？</p><p id="f6da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">mongose:我们将使用<a class="ae jz" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>与我们的mongo数据库接口。</p><p id="e85c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> crypto </strong>:我们用它来散列我们的密码，你会在教程的后面看到它的用法。</p><p id="cfce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Jest :我们将要使用的测试库。如果你想了解更多关于jest的信息，看看它的特性，请查看<a class="ae jz" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="7559" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> mongodb-memory-server </strong>:这是我们将使用的mongo数据库的内存版本。这将我们从必须建立一个真正的mongo数据库的压力中解救出来。这也连接到<em class="lb">设备的主存储器，而不是物理存储在磁盘上，因此测试起来更快更好。</em>你可以在这里阅读更多关于这个包的信息<a class="ae jz" href="https://github.com/nodkz/mongodb-memory-server" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="a684" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">项目结构</h1><p id="f5ea" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">接下来，我们继续创建我们的代码结构。由于我们只关注于测试mongoose模型，我们将创建我们的模型和其中的一些方法。</p><p id="fa78" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于这个例子，我们将只创建一个模型:用户模型。</p><p id="5ce8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建一个名为<strong class="kc io"> models的新文件夹；</strong>然后在它下面创建一个名为<strong class="kc io"> <em class="lb"> user.js. </em> </strong>的文件，你的代码结构应该看起来像这样:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/30974539af921697772217872284e453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vSwsk3DhDKGNab6MFEFvg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Project structure</figcaption></figure><h1 id="252f" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用户模式</h1><p id="14a2" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在新创建的<strong class="kc io"> <em class="lb"> user.js </em> </strong>文件中，我们添加以下代码:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8c6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，我们在mongoose中设置了一个用户模式，并创建了两个方法:<strong class="kc io"> <em class="lb"> setPassword </em> </strong>和<strong class="kc io"><em class="lb">validate password</em></strong>。我们分别使用这些方法来生成散列用户密码和验证用户密码。</p><h1 id="575d" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置测试环境</h1><p id="4d1c" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在编写测试之前，我们需要将mongo内存服务器集成到我们的项目中。为此，我们在项目的基础上创建一个名为<strong class="kc io"> <em class="lb"> db </em> </strong>的新文件夹，然后在该文件夹中创建一个名为<strong class="kc io"> <em class="lb"> setup.js. </em> </strong>的新文件</p><p id="74e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的新代码结构应该如下所示:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/bc4b35cd8188972fec9387167d999b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pfn-IMdcKHYjW5GTthQEVA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">project structure with db.js</figcaption></figure><p id="4e8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，打开db.js并添加这段代码。我会很快解释这里发生了什么:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="b065" class="mr lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated"><strong class="ak">解说</strong></h2><p id="f0f6" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们首先导入两个依赖项，分别是<strong class="kc io"><em class="lb">mongose</em></strong>和<strong class="kc io"><em class="lb">MongoMemoryServer</em></strong>。</p><p id="8234" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们创建3个方法，分别是<strong class="kc io"> <em class="lb">设置</em> </strong>、<strong class="kc io"> <em class="lb"> dropDatabase、</em> </strong>和<strong class="kc io"><em class="lb">drop collections</em></strong>。</p><p id="9263" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io"> <em class="lb">设置</em> </strong>方法中，我们使用MongoMemoryServer包连接到数据库。</p><p id="99a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"><em class="lb">drop database</em></strong><em class="lb">方法用于完全删除数据库，关闭并停止连接。</em></p><p id="ff83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"><em class="lb">drop collections</em></strong>方法用于从我们的db中删除所有集合。</p><p id="b832" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们导出这3个方法，因为我们在测试文件中需要它们。</p><h1 id="08e2" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">编写我们的测试</h1><blockquote class="nl"><p id="f4b6" class="nm nn in bd no np nq nr ns nt nu kx dk translated">我们期待已久的时刻终于到来了。我们要写一些测试！</p></blockquote><p id="9f13" class="pw-post-body-paragraph ka kb in kc b kd nv kf kg kh nw kj kk kl nx kn ko kp ny kr ks kt nz kv kw kx ig bi translated">我个人喜欢把我的测试和要测试的文件放在同一个文件夹里，这是我个人的选择，不是强制性的。</p><p id="dc71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，我们将在保存有<strong class="kc io"> <em class="lb"> user.js </em> </strong>文件的同一个文件夹中创建一个名为<strong class="kc io"> <em class="lb"> user.test.js </em> </strong>的新文件。</p><p id="f0b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的新项目结构现在应该是:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/4802d8f0b79e4e443dd6a0a8955168cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2KmZNNgP2YDfvqvnFfaIw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Project structure with user.test.js</figcaption></figure><p id="b2e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在将下面的代码添加到新创建的<strong class="kc io"> <em class="lb"> user.test.js </em> </strong>文件中。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="5dfa" class="mr lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">说明</h2><p id="66f8" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">看起来很多，对吗？好吧，让我们开始吧。</p><p id="c6fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一部分中，我们导入我们的db安装文件、用户模型和mongoose。</p><p id="1844" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们创建虚拟数据并将其存储在userData中，我们将在该文件的后面使用它来执行我们的测试。</p><p id="aa5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们添加三个方法，即beforeAll、afterEach、afterAll，这些方法在笑话中是允许的。</p><p id="184d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有 之前的<strong class="kc io"> <em class="lb">将在我们的测试套件运行之前执行。在这种情况下，我们只有一个描述块。在这个方法中，我们调用<strong class="kc io"> <em class="lb"> db.setUp </em> </strong>来设置我们的db连接。</em></strong></p><p id="bfa1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个 之后的<strong class="kc io"> <em class="lb">在每个测试套件之后运行。如果我们有多个describe块，我们将使用这个方法来防止每个suite影响另一个suite的结果。发生这种情况是因为我们调用了<strong class="kc io"><em class="lb">db . drop collection</em></strong>，它从db中删除了所有集合。</em></strong></p><p id="44ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有测试套件完成后的<strong class="kc io"> <em class="lb"> afterAll </em> </strong>。这是我们删除数据库并使用<strong class="kc io"><em class="lb">db . drop database</em></strong>方法关闭连接的地方。</p><p id="a6fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们创建了一个测试套件，并在其中编写了三个测试。</p><p id="8e03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第一个测试块</strong> : <em class="lb">创建&amp;保存用户成功，</em>我们创建一个新用户，然后检查是否确实创建了一个用户。如果您还记得在我们的模式中，用户有email、phone和salt属性，那么我们检查这些属性是否存在于返回的用户数据中，对于phone和email，检查返回的内容是否确实是我们保存的内容！。此外，由于mongoose将一个_id属性附加到一个模式，我们检查它是否同样存在。</p><p id="04de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第二个测试块</strong> : <em class="lb">成功插入用户，但是模式中没有定义的字段应该是未定义的，</em>我们创建了一个新用户，但是这次我们传递了一个模式中不存在的属性。我们期望创建用户，但是没有添加这个属性，因此我们测试以确保它不在返回的数据中，期望它是未定义的。</p><p id="3d00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第三个测试块</strong> : <em class="lb">创建没有必填字段的用户应该失败</em>，我们创建了一个新用户作为之前的测试，但是这一次我们没有传递email属性，因为它在我们的模式中是必需的，mongoose不应该创建那个特定的用户。我们将save方法包装在一个try和catch中，检查得到的错误是否确实是一个mongoose验证错误，并进一步检查这个验证错误是否是由缺少email属性引起的。</p><h1 id="01bc" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">运行测试</h1><p id="44d4" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">要运行我们的测试，我们需要更新我们的package.json文件，并向脚本部分添加单个脚本命令。这个脚本告诉jest如何运行我们的测试以及在哪里可以找到我们的测试文件。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="941b" class="mr lg in mn b gy ms mt l mu mv">"scripts": {</span><span id="da08" class="mr lg in mn b gy oa mt l mu mv">"test": "jest --runInBand ./models"</span><span id="271e" class="mr lg in mn b gy oa mt l mu mv">},</span></pre><p id="cc6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> runInBand </strong>标志只是告诉<strong class="kc io"> <em class="lb"> jest </em> </strong>在当前进程中连续运行我们所有的测试，而不是创建子进程的工作池。对调试非常有用。</p><p id="157c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">。/models </strong>简单地告诉<strong class="kc io"> <em class="lb"> jest </em> </strong>运行在models文件夹中找到的所有测试文件。</p><p id="039d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">点击查看Jest CLI文档<a class="ae jz" href="https://jestjs.io/docs/cli" rel="noopener ugc nofollow" target="_blank">，查看更多可用选项。</a></p><p id="7114" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了运行我们的测试，我们运行package.json文件中的测试脚本:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="53dd" class="mr lg in mn b gy ms mt l mu mv">npm run test</span></pre><p id="df5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您按照正确的步骤操作，您应该会看到这些可爱的绿色记号，终端显示如下:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/e007701cf49e0812b7c42f072bdb6f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9B64uY0qQzguMAEwem-MbA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Test success</figcaption></figure><p id="3df7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">沃拉。你刚刚做了测试，他们都通过了！</p><p id="f67b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我迫不及待地想看看你构建和测试了什么！去抓你猫鼬模型里的虫子吧。</p><p id="3c81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整的代码可以在这里找到<a class="ae jz" href="https://github.com/chyke007/mongoose-jest-tutorial" rel="noopener ugc nofollow" target="_blank">。玩得开心点！</a></p><p id="9b67" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>