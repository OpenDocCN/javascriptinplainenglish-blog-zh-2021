<html>
<head>
<title>Using the Delegation Pattern over Inheritance in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用继承委托模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-delegation-pattern-over-inheritance-in-javascript-e11ec72b2b82?source=collection_archive---------6-----------------------#2021-05-10">https://javascript.plainenglish.io/using-the-delegation-pattern-over-inheritance-in-javascript-e11ec72b2b82?source=collection_archive---------6-----------------------#2021-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/376f4706bddc505a5e54273edf6d306f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WerYRDPQtMcMcaZmgiS6g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo Illustration by David Fekke</figcaption></figure><p id="20ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">原发布于</em><a class="ae lb" href="https://fek.io/blog/using-the-delegation-pattern-over-inheritance-in-java-script/" rel="noopener ugc nofollow" target="_blank"><em class="la">https://fek . io</em></a><em class="la">。</em></p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="28ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">实际上，有时您希望在应用程序中使用对象继承。我见过很多通过对象继承来扩展生命周期API的应用程序。</p><p id="6f44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继承是软件开发人员扩展现有功能和向现有基类或对象添加属性的一种方式。将数据建模为对象时，创建对象图是很常见的，其中一个对象可能是基本对象的孙或曾孙。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/4e3658c1c2d3f747cd7347217978ecba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q__zTKdkN7VMWBt9.png"/></div></div></figure><p id="6ced" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">举个例子，我们可能有一个<code class="fe lj lk ll lm b">Person</code>对象，它是一个父对象。我们可以创建扩展了<code class="fe lj lk ll lm b">Person</code>对象的<code class="fe lj lk ll lm b">User</code>对象。我们可能还有一个扩展了<code class="fe lj lk ll lm b">User</code>对象的<code class="fe lj lk ll lm b">AdminUser</code>对象。我对<code class="fe lj lk ll lm b">Person</code>对象所做的任何更改都将被<code class="fe lj lk ll lm b">User</code>和<code class="fe lj lk ll lm b">AdminUser</code>对象自动继承。</p><p id="e234" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继承的副作用之一是，如果我们对基本对象的定义进行了更改，它现在就与整个对象链紧密耦合。这可能会产生所谓的脆弱基类问题。另一个问题是，如果我们试图使用继承给我们的对象添加功能，在大多数通用语言中，我们只能从一个对象继承。C++是少数允许开发人员进行多重继承的语言之一。C#、Objective-C、Java、Swift等语言只允许单一继承。</p><h1 id="96e8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">委托模式</h1><p id="8929" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">当我开始学习Objective-C时，我接触到的一种模式是委托模式，这种模式在苹果的很多API中都很常见。这类似于四人帮设计模式一书中提到的观察者模式。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ad59fd72df86271fab746c6602c03fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*PmQZt2ITgZjxrR86.png"/></div></figure><p id="3e4b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Objective-C是一种由Next Computer流行起来的语言，Next Computer是史蒂夫·乔布斯离开苹果时创办的公司，他在1996年将该公司卖回给了苹果。Next采用Objective-C作为他们的默认语言，因为它可以用来创建面向对象的应用程序和框架，但它也允许开发人员使用现有的C代码。</p><p id="d7fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为Objective-C只允许单一继承，苹果开发了很多API来利用委托模式。这个想法很简单。如果开发人员在程序中编写一个类，并且他们需要消耗网络或数据库服务器资源，他们可以创建API类的实例，并使他们的类成为该对象的委托。如果您在单线程上等待响应，进行网络调用可能是一个阻塞过程。通过将线程封装到API中，苹果能够抽象出许多进行网络调用的复杂性。消费者所要做的就是在他们的类上实现某些方法来使用来自网络API的结果，并将他们的类设置为网络类的<code class="fe lj lk ll lm b">delegate</code>。</p><p id="24e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">今天，苹果有很多现代的API，它们使用闭包和块以非阻塞的方式处理网络请求，但是委托模式仍然在它们的很多API中使用。</p><h1 id="fe43" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">继承JavaScript中的功能</h1><p id="ceb2" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">假设我们有一个正在创建的对象，它需要将一些工作卸载给另一个对象，然后需要在另一个对象完成任务后调用一个函数。一种方法是从父对象继承该功能。在这个例子中，我们创建了两个对象，一个叫做<code class="fe lj lk ll lm b">parent</code>，另一个叫做<code class="fe lj lk ll lm b">child</code>。<code class="fe lj lk ll lm b">child</code>将把它的一些工作卸载给<code class="fe lj lk ll lm b">parent</code>对象。<code class="fe lj lk ll lm b">parent</code>对象将具有名为<code class="fe lj lk ll lm b">doWorkForChild</code>、<code class="fe lj lk ll lm b">setStatus</code>和<code class="fe lj lk ll lm b">sayHelloToMe</code>的函数。</p><p id="aa0d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lj lk ll lm b">child</code>对象将继承<code class="fe lj lk ll lm b">parent</code>对象的方法，但是我们将覆盖<code class="fe lj lk ll lm b">setStatus</code>函数的功能，并为<code class="fe lj lk ll lm b">start</code>和<code class="fe lj lk ll lm b">print</code>添加函数。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mr lh l"/></div></figure><p id="8f84" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们将把<code class="fe lj lk ll lm b">child</code>的原型设置为<code class="fe lj lk ll lm b">parent</code>，这样我们就可以继承<code class="fe lj lk ll lm b">parent</code>的功能。</p><pre class="lc ld le lf gt ms lm mt mu aw mv bi"><span id="7cc3" class="mw lo iq lm b gy mx my l mz na">child.prototype = Object.create(parent.prototype);</span></pre><p id="87bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以为每个对象定义函数了。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mr lh l"/></div></figure><p id="bb58" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从上面的例子中我们可以看到，我们已经覆盖了子对象上的<code class="fe lj lk ll lm b">setStatus</code>函数，因此它使用<code class="fe lj lk ll lm b">console.log</code>打印<code class="fe lj lk ll lm b">status</code>参数。</p><p id="e8c6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了运行这个例子，我们需要创建一个<code class="fe lj lk ll lm b">child</code>对象的新实例，并在这个实例上调用<code class="fe lj lk ll lm b">start</code>函数。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mr lh l"/></div></figure><h1 id="4c7b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用委托模式解耦对象</h1><p id="c8c0" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">让我们将<code class="fe lj lk ll lm b">parent</code>对象中的功能放入一个名为“worker”的新工厂函数中。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mr lh l"/></div></figure><p id="0818" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你所看到的，这个函数创建了一个对象，其功能与我们之前在<code class="fe lj lk ll lm b">parent</code>对象中创建的相同。这里的主要区别是我们有一个名为<code class="fe lj lk ll lm b">delegate</code>的变量，我们用它来存储对委托对象的引用。现在我们需要创建一个对象来观察从<code class="fe lj lk ll lm b">worker</code>对象发出的调用。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mr lh l"/></div></figure><p id="a1c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你在上面的例子中看到的，我们正在创建一个委托对象的实例变量。然后，我们将这个委托实例分配给worker对象中的delegate属性。一旦工作者有了这个引用，它现在就可以调用委托对象上的函数。</p><p id="2214" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们所要做的就是启动代理对象，开始观察来自worker对象的响应。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mr lh l"/></div></figure><h1 id="da9b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">替代方法</h1><p id="b03f" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">JavaScript的奇妙之处在于有多种方法可以达到相同的结果。我们可以通过使用回调或事件监听器来做上面做的事情。很多现代的JavaScript APIs你可以结合使用<code class="fe lj lk ll lm b">Promises</code>和<code class="fe lj lk ll lm b">async/await</code>来达到同样的效果。</p><h1 id="a5ad" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="35db" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">委托模式是从基本对象继承功能的一个很好的选择，它允许开发人员同时观察多个对象。如果您需要将许多不同的生命周期事件连接到一个API，而不需要使用实际的事件监听器，这也是一个很好的模式。</p><div class="nb nc gp gr nd ne"><a href="https://github.com/davidfekke/delegateexample" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">davidfekke/delegate示例</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">要运行这些示例，请确保安装了Node.js 14或更高版本。若要运行继承示例，请使用…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div></div></a></div></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="ced7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">更多内容请看</em><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="la">plain English . io</em></a></p></div></div>    
</body>
</html>