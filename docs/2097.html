<html>
<head>
<title>Problems When Switching to a Headless CMS in Live WordPress Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Live WordPress项目中切换到无头CMS时出现的问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-problem-tou-will-face-when-switching-to-headless-wordpress-20e8fb7d7005?source=collection_archive---------10-----------------------#2021-05-03">https://javascript.plainenglish.io/5-problem-tou-will-face-when-switching-to-headless-wordpress-20e8fb7d7005?source=collection_archive---------10-----------------------#2021-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cca9765e9e5bf84e25cf95ffcc955832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNBjCmkQe4O-s_8THH7Wvg.jpeg"/></div></div></figure><p id="b074" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数关于无头WordPress(以及一般的无头CMS)的教程和文章都会引导你完成设置的基础，几乎从一个全新的CMS安装开始，有一些基本的文章和页面。但是当你开始做一个真正的项目时会发生什么呢？</p><p id="de0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的最新项目中，一个客户(根据我们的建议)想从一个单一的WordPress转换到一个无头的React前端。他们经营着一家杂志——自2012年以来一直在线——有数千篇已经发表的文章，他们在搜索引擎优化方面很有名气，他们有一群作者不能(或不想)学习新的编辑界面或新的编辑指南，他们想提高网站的性能，但仍然保持实际的(单一的)界面(有一些改进)，他们想无缝迁移分析(他们用谷歌标签管理器处理高级分析)和广告(他们的主要收入渠道)。</p><p id="538f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一大堆你在网上找到的指南中通常没有考虑到的要求，这些指南通常解释了如何连接到CMS，获取内容，以及生成一个静态网站(使用框架)。</p><p id="9304" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们开始制定项目时，我们就开始着手解决问题，做出决定，并指明方向。我们决定列出我们发现的5个主要问题以及我们如何解决它们，记住我们提供的解决方案实际上是依赖于项目的，可能有数百种方法来解决这些问题。</p><h1 id="0441" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">1.选择框架</h1><p id="ebf4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这是我们的第一项任务，它将指导我们所有其他的决定，所以在决定之前，您应该非常清楚接下来会发生什么，如果所选择的框架将与所有东西兼容，等等。</p><p id="b138" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们在reaction工作，并且我们精通<a class="ae lz" href="https://www.gatsbyjs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a><strong class="ka ir"/>和<a class="ae lz" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Next </strong> </a>这两个被认为是从CMS构建静态网站的标准，我们必须在这两者之间做出选择。</p><p id="b3a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">盖茨比为几乎所有人提供了一个广泛的插件(我们真的很喜欢新的<a class="ae lz" href="https://www.gatsbyjs.com/plugins/gatsby-plugin-image" rel="noopener ugc nofollow" target="_blank">盖茨比插件图像</a>)，而Next有一个更窄的生态系统，但是我们认为在构建什么和什么时候构建方面更灵活(一个稍后会出现的问题)，我们真的很喜欢<a class="ae lz" href="https://nextjs.org/docs/routing/dynamic-routes" rel="noopener ugc nofollow" target="_blank"> <em class="ma">动态路由</em> </a>处理(另一个即将出现的问题)。</p><p id="22a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们决定牺牲很多很酷的前端功能(包括图像处理和页面转换)，专注于后端和构建的性能和灵活性，出于这些原因，我们选择了Next.js</p><h1 id="0fda" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 2。决定构建什么和何时构建</strong></h1><p id="c8dd" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们选择Next最有价值的特性之一是增量静态再生，即不仅在构建时，而且在运行时创建静态页面并在运行时重新生成它们的能力。</p><p id="c374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于该网站已经填充了超过3000篇文章，每天都有文章添加和修改，我们认为完整的构建(即使后续的构建是增量的)将花费太多时间(并且可能永远不会成功)。</p><p id="f7ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们选择了这样的构建模式:</p><ul class=""><li id="1b6c" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">我们在构建时生成主页，主页中链接的所有文章(大约20篇)，每个类别档案的前两页(我们有3个类别，每个档案页面有24篇文章)。</li><li id="90df" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">我们还列出了访问量最大(最老)的页面；所以，最多，在构建时，我们生成不到200个静态页面；</li><li id="e8e7" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">当用户请求时，其余的页面在运行时被构建和服务器化。在最后一种情况下，我们使用了true的后备策略。请注意，一旦页面根据要求生成，所有未来的请求都将是生成的内容。</li><li id="f7f4" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">我们还计划增加构建时生成的页面数量(根据测试，我们可以在一分钟的构建时间内生成大约800页)，并实施<em class="ma">重新验证</em>政策，以提高效率，避免在新帖子上进行重建。</li></ul><h1 id="d900" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">3.永久链接</h1><p id="56d7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当从一个平台移动到另一个平台时，永久链接是另一个重要方面。如果处理不当，人们会失去他们的书签，但更糟糕的搜索引擎优化可以被摧毁。处理永久链接通常有两种方法:简单的一种是建立一个新的舒适的永久链接结构并创建一个重定向地图(这需要非常精确),而(可能)困难的一种是在新网站上镜像永久链接结构。</p><p id="2609" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们选择了更难的一个，因为我们认为依赖重定向结构来处理大量的页面太冒险了，而且我们发现这个解决方案更加优雅。</p><p id="bdf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">做出决定后，我们对当前的永久链接结构进行了布局，大致如下:</p><ul class=""><li id="986e" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><a class="ae lz" href="https://www.oursite.com/" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://www.oursite.com/</em></a>&gt;首页</li><li id="9af1" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae lz" href="https://www.oursite.com/" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://www.oursite.com/</em></a><em class="ma">我的范畴</em> &gt;第一页的范畴档案</li><li id="4375" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae lz" href="https://www.oursite.com/" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://www.oursite.com/</em></a><em class="ma">my category/page/2</em>&gt;第二页类目档案</li><li id="2de0" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae lz" href="https://www.oursite.com/" rel="noopener ugc nofollow" target="_blank"><em class="ma"/></a><em class="ma">my category/article-title</em>&gt;单篇文章</li><li id="5971" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae lz" href="https://www.oursite.com/" rel="noopener ugc nofollow" target="_blank"><em class="ma"/></a><em class="ma">my category/subcategory</em>&gt;子类别档案首页(与其他档案和文章页面的类别结构相同</li><li id="52bc" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae lz" href="https://www.oursite.com/" rel="noopener ugc nofollow" target="_blank"><em class="ma"/></a><em class="ma">作者/ </em> &gt;存档作者</li><li id="561f" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae lz" href="https://www.oursite.com/" rel="noopener ugc nofollow" target="_blank">【https://www.oursite.com/】</a><em class="ma">作者/作者姓名</em> &gt;作者页面</li></ul><p id="da49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Next.js中，动态路由用文件夹和文件的特殊名称(在方括号中)来处理，如:<code class="fe mp mq mr ms b">blog/[page].js</code>。</p><p id="72ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是由于类别档案和单篇文章在同一个文件夹下，这将导致路径冲突。为了解决这个问题，我们使用WordPress路由思想来处理这个结构，并且我们还利用了Next动态路由的一个不太为人所知的功能:可选的捕获所有路由。</p><p id="be16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在页面文件夹中创建了以下路径/文件结构:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="80f5" class="nb kx iq ms b gy nc nd l ne nf">pages/[category]/[[...slug]].js</span></pre><p id="324d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文件名前的三个点是catch all扩展名，带有双方括号，使其可选，以便路径与几乎任何参数组合相匹配，如:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="6b59" class="nb kx iq ms b gy nc nd l ne nf">/magazine/<br/>/magazine/article-title<br/>/magazine/food/article-title<br/>/magazine/page/2<br/>...<br/>and so on</span></pre><p id="bcdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，所有的路由逻辑都放置在<code class="fe mp mq mr ms b">[[..slug]].js</code>页面组件内部；根据收到的参数，我们能够决定执行哪个查询，并将结果传递给适当的组件(我们为归档创建了一个组件，为单个页面创建了一组组件，基于类别等等)。其他页面(如about、contact等)很简单，因为它们有自己的页面模板。</p><h1 id="890a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">4.内容处理</h1><p id="35ae" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">尽管许多指南使这个任务变得简单，但是一旦你加载了你的内容，你不能简单地把它放在一个div中，就像这样:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="c4fd" class="nb kx iq ms b gy nc nd l ne nf">&lt;div dangerouslySetInnerHTML={{ __html: post.content}} /&gt;;</span></pre><p id="7739" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅仅是因为它不会像你预期的那样工作，在99%的情况下，内容被保存以与WordPress模板一起工作，它是用Gutenberg编写的，依赖于WordPress CSS(用于样式)，有时依赖于WordPress JavaScript(例如，如果有图像曾经点击打开一个lightbox)。我们发现这个任务是最耗时和最复杂的，我们尝试了不同的方法才最终确定下来。</p><p id="3630" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一开始，我们认为从WordPress中抓取CSS并将其添加到React中是可行的，而且几乎可行，但我们最终得到了一个“肮脏”的CSS，需要进行许多调整才能按预期工作，此外，许多功能都丢失了(例如视频嵌入或文章内广告)，有时格式也会变得奇怪。</p><p id="e896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们停了一会儿，我们也放弃了修改帖子以使它们在我们的界面中工作的想法(它们太多了，而且编辑者也需要对新格式进行培训)，我们开始分析一堆随机的帖子以寻找模式，事实上，我们发现了一个模式，大多数(如果不是全部)帖子基本上是由文本组成的(包含在<code class="fe mp mq mr ms b">&lt;p&gt;</code>标签中)， 在文本之间有古腾堡画廊区块(在<code class="fe mp mq mr ms b">&lt;figure&gt;</code>标签中),点击后图片在lightbox上打开，有时是视频嵌入(仍在<code class="fe mp mq mr ms b">&lt;figure&gt;</code>标签中),在第二个<code class="fe mp mq mr ms b">&lt;p&gt;</code>之后是广告。</p><p id="91f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们分析的所有帖子都遵循这个模式:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="aa9b" class="nb kx iq ms b gy nc nd l ne nf">&lt;p&gt;Some text&lt;/p&gt;<br/>  &lt;p&gt;Some more text&lt;/p&gt;<br/> &lt;figure class=..."&gt;<br/>     &lt;ul class="..."&gt;<br/>       &lt;li class="..."&gt;<br/>         &lt;figure&gt;<br/>           &lt;a href=".."&gt;<br/>             &lt;img src=""&gt;<br/>           &lt;/a&gt;<br/>         &lt;/figure&gt;<br/>       &lt;/li&gt;<br/>       ...      <br/>       &lt;li class="..."&gt;<br/>         &lt;figure&gt;<br/>           &lt;a href=".."&gt;<br/>             &lt;img src=""&gt;<br/>           &lt;/a&gt;<br/>         &lt;/figure&gt;<br/>      &lt;/li&gt;<br/>     &lt;/ul&gt;<br/>  &lt;/figure&gt;<br/>  &lt;p&gt;More text&lt;/p&gt;<br/>  &lt;figure&gt;....&lt;/figure&gt;<br/>  &lt;p&gt;And so on&lt;/p&gt;</span></pre><p id="0566" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们决定“分解”这个HTML，转换成一个对象，并把它放回JSX。我们使用了<a class="ae lz" href="https://www.npmjs.com/package/xmldom" rel="noopener ugc nofollow" target="_blank"> xmldom </a>来完成这项任务，它是dom的JavaScript实现，支持React应用程序中的DOMParser接口:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="71ae" class="nb kx iq ms b gy nc nd l ne nf">const { DOMParser } = require('xmldom');</span><span id="0118" class="nb kx iq ms b gy ng nd l ne nf">let parser = new DOMParser();</span><span id="d0ec" class="nb kx iq ms b gy ng nd l ne nf">let doc = parser.parseFromString(post.content, 'text/html');</span></pre><p id="3532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们遍历文档，访问节点，并将结果放入将构建我们的对象的数组中，获得如下内容:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="49a6" class="nb kx iq ms b gy nc nd l ne nf">[{type:'p', content:'Some text'}, {type:'gallery' content:['img_1_url', 'img_2_url', ...]}, ... ]</span></pre><p id="4d3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在我们的JSX中，我们可以映射得到的数组，根据数组的类型，我们可以有条件地呈现一个文本、一个图库(这是我们遗憾没有像Gatsby那样强大的图像插件的地方)、一个视频或一个adv单元；所有这些使我们的CSS保持整洁。</p><p id="ad14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可能理解的那样，完成这项工作没有单一的方法，它几乎取决于内容的外观、可以牺牲多少功能等等；请在参与这种任务之前做一个深入的分析，许多编辑使用Gutenberg块，这可能是一个痛苦的转换，或者得到了一些他们不想丢失的格式等等。</p><h1 id="4f07" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">5.整合谷歌服务</h1><p id="e116" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">接下来提供一个<a class="ae lz" href="https://nextjs.org/docs/advanced-features/custom-document" rel="noopener ugc nofollow" target="_blank">定制文档实现</a>，这对于在<code class="fe mp mq mr ms b">&lt;header&gt;</code>和整个网站中包含脚本非常有用。对于广告，我们在<code class="fe mp mq mr ms b">&lt;header&gt;</code>中包含了提供的谷歌脚本:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="bec2" class="nb kx iq ms b gy nc nd l ne nf">&lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXX" crossorigin="anonymous"&gt;&lt;/script&gt;</span></pre><p id="27a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们创建了几个广告组件(一个用于文章，一个用于标题横幅，等等),放在广告单元应该出现的地方，例如:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="dfa6" class="nb kx iq ms b gy nc nd l ne nf">import React, { useEffect } from "react";<br/><br/>const inArticle= () =&gt; {<br/>  useEffect(() =&gt; {<br/>    try {<br/>      (window.adsbygoogle = window.adsbygoogle || []).push({});<br/>    }<br/>  }, []); //this part is usally in script on the provided coded<br/><br/>  return (<br/>  &lt;ins className="adsbygoogle"<br/>     style={{display:"block", textAlign:"center"}}<br/>     data-ad-layout="in-article"<br/>     data-ad-format="fluid"<br/>     data-ad-client="ca-pub-XXXXX"<br/>     data-ad-slot="xxxx"&gt;<br/>  &lt;/ins&gt;<br/>  );<br/>};<br/><br/>export default inArticle;</span></pre><p id="195f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在本地主机上开发，广告不会出现。</p><p id="ea71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标签管理器的工作方式几乎相同，通过向<strong class="ka ir"> _document.js </strong>添加代码，他们提供了两个代码片段，一个在<code class="fe mp mq mr ms b">&lt;header&gt;</code>之后，一个在<code class="fe mp mq mr ms b">&lt;body&gt;</code>之后，我们将这样插入代码:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="86fa" class="nb kx iq ms b gy nc nd l ne nf">&lt;script dangerouslySetInnerHTML={{ __html: `(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':<br/>new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],<br/>j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);<br/>})(window,document,'script','dataLayer','GTM-YOURCODE');`}}&gt;&lt;/script&gt;</span></pre><p id="f83e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="7515" class="nb kx iq ms b gy nc nd l ne nf">&lt;noscript dangerouslySetInnerHTML={{ __html: `&lt;frame src="https://www.googletagmanager.com/ns.html?id=GTM-YOURCODE"<br/>height="0" width="0" style="display:none;visibility:hidden"&gt;&lt;/iframe&gt;`}}&gt;&lt;/noscript&gt;</span></pre><p id="d1f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用标签管理器进行测试对于检查一切是否正常非常有用，我们发现使用“所有页面”作为Google Analytics的激活器并不总是正常工作，所以我们使用“历史更改”来更改“所有页面”,并且我们能够跟踪访问。</p><h1 id="f28c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">其他需要考虑的事情</h1><p id="30a9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在一个大规模的真实项目中工作与在一个测试/指导环境中工作是不同的，有许多变量需要跟踪，许多问题需要解决，还有一堆东西需要艰难地学习。通常，已发布的CMS使用插件来实现不应该丢失的功能(例如共享插件、图库、滑块)，有时你会发现一些现成的npm模块可以完成这项工作，有时编写自己的模块和组件最有效。</p><p id="9fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，迁移到一个分离的发布系统确实提高了性能和安全性，有时您可以用它来换取一些奇特的前端功能。</p><p id="215b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ma">更多内容尽在</em><a class="ae lz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ma">plain English . io</em></strong></a></p></div></div>    
</body>
</html>