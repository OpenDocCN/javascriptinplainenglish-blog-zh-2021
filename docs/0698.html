<html>
<head>
<title>Debugging JavaScript Performance with NDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NDB调试JavaScript性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/debugging-javascript-performance-with-ndb-3c1816c6a09c?source=collection_archive---------15-----------------------#2021-02-12">https://javascript.plainenglish.io/debugging-javascript-performance-with-ndb-3c1816c6a09c?source=collection_archive---------15-----------------------#2021-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="io ip gp gr iq ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/51f49466405b83c52cd420c99a8941a3.png" data-original-src="https://miro.medium.com/v2/0*4gYk-aq1_DuHcgCq"/></div></figure><div class=""/><p id="4943" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://github.com/GoogleChromeLabs/ndb" rel="noopener ugc nofollow" target="_blank"> ndb </a>将自己描述为“由Chrome DevTools实现的Node.js的改进调试体验”。</p><p id="4136" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它使Chrome DevTools的一些最佳功能在调试Nodejs应用程序时成为盟友。</p><p id="f43d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在之前的博文中，我们通过VSCode进行了调试。在本文中，我将展示ndb的分析器如何帮助您识别和解决可能的瓶颈。</p><h2 id="bfc6" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">入门指南</h2><p id="9c88" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">全局安装ndb，初始化一个新项目，并为示例创建一个新文件:</p><figure class="lr ls lt lu gt ir"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="54d2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe lx ly lz ma b">package.json</code>中，更新脚本以包含一个<code class="fe lx ly lz ma b">start</code>脚本:</p><figure class="lr ls lt lu gt ir"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="8cf4" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">我们的第一个例子</h2><p id="69f0" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">我们将计算<a class="ae ks" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波纳契数</a>并以一种花费<code class="fe lx ly lz ma b">2^n</code>的方式对其进行编码，其中计算时间加倍，我们需要递归调用该数的次数越多(不包括基本情况)。</p><p id="1a08" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe lx ly lz ma b">ndb-example.js</code>内，添加以下内容:</p><figure class="lr ls lt lu gt ir"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0098" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将运行相同的计算来获得40的斐波那契数(102334155)。为此，在控制台的基本目录下运行<code class="fe lx ly lz ma b">ndb .</code>来启动ndb。您应该面对以下情况:</p><figure class="lr ls lt lu gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/a4bd1910ae3cba7f9f42d36dc405484a.png" data-original-src="https://miro.medium.com/v2/0*xPk8cQoc8kG2zilt"/></div></figure><p id="5f7e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在左侧面板的<code class="fe lx ly lz ma b">NPM Scripts</code>下，您会看到我们的<code class="fe lx ly lz ma b">start</code>脚本可用。悬停在它上面，我们可以看到按钮高亮显示，使我们能够“播放”或“录制”脚本。假设我们的<code class="fe lx ly lz ma b">start</code>脚本将在<code class="fe lx ly lz ma b">ndb-example.js</code>文件中运行，我们可以点击record来查看执行过程中发生了什么:</p><figure class="lr ls lt lu gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/5584f87fd32ee25f658e7c1c8c498bd5.png" data-original-src="https://miro.medium.com/v2/0*fhFLPi4tKhPlYMeV"/></div></figure><p id="7d6d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在分析器上，它向我们显示了<code class="fe lx ly lz ma b">calcFibonacci40</code>下的两个不同的调用栈，最大的两个<code class="fe lx ly lz ma b">expensiveCalc</code>直接位于下面，是我们从<code class="fe lx ly lz ma b">calcFibonacci40</code>发出的两个调用。两个都花了我1.49秒在这个硬件上！事实上，目前我们的代码是，如果我们不断地调用<code class="fe lx ly lz ma b">calcFibonacci40</code>，那昂贵的计算将总是被重新计算！</p><p id="1843" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么我们能做什么呢？我们将记住这个函数。</p><h2 id="c8c3" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">记忆功能</h2><p id="2427" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">记忆该函数将“缓存”我们以前的结果，并使用相同的参数进行任何调用，返回存储在缓存中的内容，而不是重新计算那个昂贵的计算。</p><p id="75d1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们通过更新代码来实现这一点:</p><figure class="lr ls lt lu gt ir"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="dd7c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们添加了一个简单的memoisation函数，它本质上使用闭包来“维护”一个缓存，并使用传递的参数返回原始函数。我不会对记忆说太多，但是更多的信息可以在这个<a class="ae ks" href="https://scotch.io/tutorials/understanding-memoization-in-javascript" rel="noopener ugc nofollow" target="_blank">博客</a>上找到。</p><p id="fecf" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们用函数的记忆版本替换昂贵的函数。</p><p id="0f60" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了增加戏剧性的效果，我们现在要迭代这个函数100次。在我目前的机器上，我预计这个函数在没有记忆的情况下运行大约需要2分钟！</p><p id="2242" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们重新录制表演，看看会发生什么。</p><figure class="lr ls lt lu gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/c171fde7ef50d72f350864c73727817f.png" data-original-src="https://miro.medium.com/v2/0*n5cXjtyPu9OmGlR1"/></div></figure><p id="a44b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">分析性能，我们看到我们仍然进行了昂贵的计算(仍然花费了1.49秒)，但是我们也在控制台上看到我们记录了100次答案？发生了什么事？</p><p id="0ac5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们放大到最末端，我们会看到在调用的末端,<code class="fe lx ly lz ma b">calcFibonacci40</code>有一个直接的子调用<code class="fe lx ly lz ma b">console.log</code>!</p><figure class="lr ls lt lu gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/4a2e6a12319d8287a0ee4f946c5772a4.png" data-original-src="https://miro.medium.com/v2/0*TPdTPZuoWb55uVoD"/></div></figure><p id="31c2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是我们工作中的回忆！因为我们不断地传递相同的参数，我们的缓存会发现这一点，我们不再调用<code class="fe lx ly lz ma b">expensiveCalc</code>来获取答案！</p><p id="ebf7" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们实际上可以看到，第一次调用用了1.49秒，其余99次调用总共用了14.69毫秒！就性能而言，这是一个巨大的成功！</p><h2 id="3a45" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">摘要</h2><p id="ec23" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">在今天的帖子中，我们安装了ndb，用于帮助分析和精确定位昂贵的计算。</p><p id="a03f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们通过记忆功能和直观地看到我们的改进来结束！</p><p id="d3c1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">ndb是一个很好的调试工具，尤其是在调试性能和内存问题时。</p><h2 id="20d4" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">资源和进一步阅读</h2><ol class=""><li id="1204" class="mb mc ix jw b jx lm kb ln kf md kj me kn mf kr mg mh mi mj bi translated"><a class="ae ks" href="https://github.com/GoogleChromeLabs/ndb" rel="noopener ugc nofollow" target="_blank"> ndb — Github </a></li><li id="a379" class="mb mc ix jw b jx mk kb ml kf mm kj mn kn mo kr mg mh mi mj bi translated"><a class="ae ks" href="https://scotch.io/tutorials/understanding-memoization-in-javascript" rel="noopener ugc nofollow" target="_blank">JavaScript中的记忆化</a></li></ol><p id="ae4c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mp">图片来源:</em> <a class="ae ks" href="https://unsplash.com/@sigmund" rel="noopener ugc nofollow" target="_blank"> <em class="mp">西格蒙德</em> </a></p><p id="f012" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mp">原贴于我的</em> <a class="ae ks" href="https://blog.dennisokeeffe.com/blog/2021-02-12-debugging-performance-with-ndb/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">博客</em> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>