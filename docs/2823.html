<html>
<head>
<title>Array Destructuring in JavaScript: A Comprehensive Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的数组析构:初学者综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/array-destructuring-in-javascript-a-comprehensive-beginners-guide-77a710166ca9?source=collection_archive---------1-----------------------#2021-06-09">https://javascript.plainenglish.io/array-destructuring-in-javascript-a-comprehensive-beginners-guide-77a710166ca9?source=collection_archive---------1-----------------------#2021-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1d86962d51090d969a677b7965f9f9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*REe9c16drM_85fnt4sKtwg.png"/></div></div></figure><p id="25ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据官方MDN <a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">文档</a>，析构赋值语法<em class="ku">“是一个JavaScript表达式，它可以将数组中的值或对象中的属性解包到不同的变量中。”</em></p><p id="cdb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们深入研究这些例子之前，让我们从概念上理解数组析构是如何工作的。</p><p id="4cba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">析构是ECMAScript 6 (ES6/ECMAScript 2015)的一项功能。就数组而言，析构基本上是一种将数组中的值解包到单独的变量中的方法。换句话说，析构就是将一个复杂的数据结构(本例中是一个数组)分解成一个更小(因此也更简单)的数据结构，比如一个变量。</p><p id="624c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于数组，析构的主要好处是我们可以从数组中检索元素，并以一种非常简单的方式将它们存储到变量中。让我们从一个非常简单的数组开始，使用析构来从中提取元素。</p><h2 id="35fd" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">提取元素</h2><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4eac" class="kv kw in lt b gy lx ly l lz ma">let arr = ['Soumadri', 'Sunil', 'John'];</span></pre><p id="7cbe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，这是我们传统的检索每个元素的方法。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="a0ac" class="kv kw in lt b gy lx ly l lz ma">let name1 = arr[0];</span><span id="ea7e" class="kv kw in lt b gy mb ly l lz ma">let name2 = arr[1];</span><span id="6049" class="kv kw in lt b gy mb ly l lz ma">let name3 = arr[2];</span><span id="1e2c" class="kv kw in lt b gy mb ly l lz ma">console.log(name1, name2, name3);</span></pre><p id="8c1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将为我们提供以下输出:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/bae3181b05e870351981e1dc556df596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/0*ef-xHSoJ-AeBvfq-"/></div></div></figure><p id="61b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们看看如何使用析构来做同样的事情。为了析构一个数组，我们在赋值操作符的左边使用了一个“[]”。每当JavaScript看到这个，它就会知道它需要执行析构。</p><p id="b0e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，使用析构，我们可以同时声明所有三个变量。让我们看看我们将如何做:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="03bb" class="kv kw in lt b gy lx ly l lz ma">let [name1, name2, name3] = arr;</span></pre><p id="d982" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样。现在让我们在控制台中检查结果。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="f845" class="kv kw in lt b gy lx ly l lz ma">console.log(name1, name2, name3);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/458f1ecae558b5911cf67dc696a77b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/0*HgGBkZeaF8ij51UM"/></div></figure><p id="bccb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实上，正如我们所看到的，我们的代码产生了完全相同的结果，但是只有一行代码。</p><p id="268a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以看到，原始数组没有受到影响。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="2a59" class="kv kw in lt b gy lx ly l lz ma">console.log(arr);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi me"><img src="../Images/7dba8d9d50c40d5d34b65bb0d5b377f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*jlMdJIYubQVm9S-o"/></div></figure><h2 id="963e" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">提取选定的元素</h2><p id="eea8" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">我们也不需要从数组中取出所有的元素。让我们来看一个例子，在这个例子中，我们执行析构来从数组中检索选定的元素。我们将再次使用arr数组。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="1aa2" class="kv kw in lt b gy lx ly l lz ma">let arr = ['Soumadri', 'Sunil', 'John'];</span><span id="b5bf" class="kv kw in lt b gy mb ly l lz ma">let [name1, ,name2] = arr;</span></pre><p id="a4c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">name1和name2之间的双逗号确保跳过相应索引位置的元素。因此<strong class="jx io"> name1 </strong>检索第<strong class="jx io">个索引</strong>(“Soumadri”)处的元素，<strong class="jx io"> name2 </strong>检索第<strong class="jx io">个索引</strong>(“John”)处的元素，而中间的元素，即第<strong class="jx io">个索引位置(“Sunil”)处的元素被跳过。</strong></p><p id="b3cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看结果。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="187f" class="kv kw in lt b gy lx ly l lz ma">console.log(name1, name2);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5900da8fcb20ef2e61d026e11ef52171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/0*oiZswsSiXJwbiEOV"/></div></figure><p id="9283" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实上，我们得到了预期的Soumadri和约翰。</p><h2 id="f14a" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">交换变量</h2><p id="37d8" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">让我们看看如何使用析构来交换变量。让我们声明两个变量name1和name2，并给它们赋值。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ba4e" class="kv kw in lt b gy lx ly l lz ma">let name1 = 'Sunil';</span><span id="6df4" class="kv kw in lt b gy mb ly l lz ma">let name2 = 'Soumadri';</span></pre><p id="b1d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">传统上，这是我们执行交换的方式。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="36e8" class="kv kw in lt b gy lx ly l lz ma">let tmp = name1;</span><span id="9117" class="kv kw in lt b gy mb ly l lz ma">name1 =name2;</span><span id="f3dd" class="kv kw in lt b gy mb ly l lz ma">name2 = tmp;</span><span id="9a7e" class="kv kw in lt b gy mb ly l lz ma">console.log(name1, name2);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/08dd354ba9dd20d3420ed94cd53e502c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*s6nkwCYQamjCEmD8"/></div></figure><p id="52d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，有了析构，我们可以在一行中完成。重置name1和name2的值，以防您使用相同的文件和/或没有注释掉上面的代码。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e52f" class="kv kw in lt b gy lx ly l lz ma">let name1 = 'Sunil';</span><span id="3889" class="kv kw in lt b gy mb ly l lz ma">let name2 = 'Soumadri';</span><span id="193d" class="kv kw in lt b gy mb ly l lz ma">[name2, name1] = [name1, name2];</span></pre><p id="bcac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们来看看结果。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="317c" class="kv kw in lt b gy lx ly l lz ma">console.log(name1, name2);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/40ab6c8b0f3bf4e90f6fd2f4ac748c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/0*X_V46eYRIODtAgWJ"/></div></figure><p id="5a69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实上，我们得到了name1和name2的交换值。</p><p id="02f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们在下面的library对象中的一些数组上尝试这些技术(随意创建一个带有自己值的数组)。这将有助于您对析构在实际应用中的工作原理有一个简单的了解。</p><h2 id="d509" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">从对象中析构数组值</h2><p id="3078" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">首先，让我们创建我们的库对象。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="7ff7" class="kv kw in lt b gy lx ly l lz ma">const library = {</span><span id="1acc" class="kv kw in lt b gy mb ly l lz ma"> name: "Soumadri’s Fiction Book Shelf",</span><span id="3f84" class="kv kw in lt b gy mb ly l lz ma"> location: '1234 Fiction Palace, Calcutta, India',</span><span id="8b0d" class="kv kw in lt b gy mb ly l lz ma"> genres: [</span><span id="7e47" class="kv kw in lt b gy mb ly l lz ma">  'Mystery',</span><span id="2827" class="kv kw in lt b gy mb ly l lz ma">  'Horror',</span><span id="7d9e" class="kv kw in lt b gy mb ly l lz ma">  'Fantasy',</span><span id="ccbe" class="kv kw in lt b gy mb ly l lz ma">  'Sci-Fi',</span><span id="954e" class="kv kw in lt b gy mb ly l lz ma">  'Literary Fiction',</span><span id="3d1a" class="kv kw in lt b gy mb ly l lz ma">  'Historical Fiction',</span><span id="4390" class="kv kw in lt b gy mb ly l lz ma"> ],</span><span id="0a6c" class="kv kw in lt b gy mb ly l lz ma"> titles: [</span><span id="eca0" class="kv kw in lt b gy mb ly l lz ma">  'The Inugami Clan',</span><span id="3f8b" class="kv kw in lt b gy mb ly l lz ma">  'The Three Coffins',</span><span id="66a8" class="kv kw in lt b gy mb ly l lz ma">  'In Search of Lost Time',</span><span id="85d6" class="kv kw in lt b gy mb ly l lz ma">  'Sandman',</span><span id="dc81" class="kv kw in lt b gy mb ly l lz ma">  'The Left Hand of Darkness',</span><span id="0b15" class="kv kw in lt b gy mb ly l lz ma">  'The Complete Works of H.P. Lovecraft',</span><span id="ea88" class="kv kw in lt b gy mb ly l lz ma">  'Do Androids Dream of Electric Sheep?',</span><span id="c7f2" class="kv kw in lt b gy mb ly l lz ma">  'In the Woods',</span><span id="0c47" class="kv kw in lt b gy mb ly l lz ma">  'In a Glass Darkly',</span><span id="fcf2" class="kv kw in lt b gy mb ly l lz ma">  'Fingersmith',</span><span id="98e0" class="kv kw in lt b gy mb ly l lz ma"> ],</span><span id="7415" class="kv kw in lt b gy mb ly l lz ma"> authors: [</span><span id="125b" class="kv kw in lt b gy mb ly l lz ma">  'Neil Gaiman',</span><span id="b0ed" class="kv kw in lt b gy mb ly l lz ma">  'Ursula Le Guin',</span><span id="2484" class="kv kw in lt b gy mb ly l lz ma">  'Sheridan Le Fanu',</span><span id="4513" class="kv kw in lt b gy mb ly l lz ma">  'H.P. Lovecraft',</span><span id="b7d7" class="kv kw in lt b gy mb ly l lz ma">  'Marcel Proust',</span><span id="36ed" class="kv kw in lt b gy mb ly l lz ma">  'Tana French',</span><span id="0ce0" class="kv kw in lt b gy mb ly l lz ma">  'John Dickson Carr',</span><span id="8f61" class="kv kw in lt b gy mb ly l lz ma">  'Seishi Yokomizo',</span><span id="ce79" class="kv kw in lt b gy mb ly l lz ma">  'Philip K. Dick',</span><span id="0af1" class="kv kw in lt b gy mb ly l lz ma">  'Sarah Waters',</span><span id="fefc" class="kv kw in lt b gy mb ly l lz ma"> ],</span><span id="fc0c" class="kv kw in lt b gy mb ly l lz ma">};</span></pre><p id="f5d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你是初学者，请不要被物体的大小吓倒。我简单解释一下键和值。</p><ul class=""><li id="a95a" class="mn mo in jx b jy jz kc kd kg mp kk mq ko mr ks ms mt mu mv bi translated"><strong class="jx io">名称:</strong>我的个人书架/图书馆的名称。</li><li id="738c" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated"><strong class="jx io">地址:</strong>图书馆的地址。</li><li id="b5a7" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated"><strong class="jx io">流派:</strong>存储图书馆中所有书籍流派的数组。</li><li id="1b8c" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated"><strong class="jx io"> titles: </strong>存储图书馆中所有书籍名称的数组。</li><li id="a7a5" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated"><strong class="jx io"> authors: </strong>一个数组，存储图书馆中所有作者的名字。</li></ul><p id="5532" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，假设我们只想从<code class="fe nb nc nd lt b">library.titles</code>数组中检索第一个和第二个元素(即两本书的名称)。因此，这就是我们写的代码。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="908b" class="kv kw in lt b gy lx ly l lz ma">let [firstBook, secondBook] = library.titles;</span></pre><p id="3ed4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，变量<code class="fe nb nc nd lt b">firstBook</code>对应于<code class="fe nb nc nd lt b">library.titles</code>数组中的<strong class="jx io">第0个索引</strong>(‘犬猫族’)，变量<code class="fe nb nc nd lt b">secondBook</code>对应于<code class="fe nb nc nd lt b">library.titles</code>数组中的<strong class="jx io">第1个索引</strong>(‘三口棺材’)。</p><p id="217f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果是:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="d242" class="kv kw in lt b gy lx ly l lz ma">console.log(firstBook, secondBook);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/99d5734dd4a217076dfa77c0220cac6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*-UPmaU4v8dMAH0YH"/></div></figure><p id="995f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是现在，假设我们想要选取两个标题，但是这次，从数组中选取第一个标题(索引0)和第三个标题(索引2)。换句话说，我们希望像前面一样提取选定的元素，并跳过某个索引位置。您可以自己尝试一下，然后回来检查解决方案。</p><p id="5153" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，让我们来看看我们如何做到这一点。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ee0b" class="kv kw in lt b gy lx ly l lz ma">let [firstBook, ,secondBook] = library.titles;</span></pre><p id="e5fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像前面一样，<code class="fe nb nc nd lt b">firstBook</code>和<code class="fe nb nc nd lt b">secondBook</code>中间的双逗号意味着<strong class="jx io">对应于空元素的索引被跳过</strong>，因此我们的第二个标题(secondBook)现在将是<code class="fe nb nc nd lt b">library.titles</code>数组中的第二个索引位置(“寻找失去的时间”)。</p><p id="2268" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们检查结果:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="17ba" class="kv kw in lt b gy lx ly l lz ma">console.log(firstBook, secondBook);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/fceb8e664bc59eb0898afc94877c8ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*5cUsMJa6Nx107NQK"/></div></figure><p id="c061" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，这真的很强大。析构可以用来做很多很酷的事情。</p><p id="8095" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，现在，假设我们想选择第一个索引的标题(“三口棺材”)作为我们的第一个标题，第0个索引的标题(“犬神部落”)作为我们的第二个标题(基本上，我们想交换第一个和第二个标题的状态)。</p><p id="13c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你从<code class="fe nb nc nd lt b">library.titles</code>数组中看到的，现在，没有交换，我们选择的第一个标题是“犬神部落”，而我们选择的第二个标题是“三口棺材”。现在，我们想换一下。</p><p id="5678" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，要在不破坏结构的情况下做到这一点，我们必须这样做:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e151" class="kv kw in lt b gy lx ly l lz ma">let [firstBook, secondBook] = library.titles;</span><span id="6079" class="kv kw in lt b gy mb ly l lz ma">console.log(‘First pick: ‘+firstBook+’, Second pick: ‘+secondBook);</span></pre><p id="b088" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们要用我们最初的选择。我们可以通过将结果记录到控制台来检查第一次和第二次选择的初始状态:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/360d59f55fe8c7555cd9a85d9c2a94a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*4qWElixcBaFVXKdT"/></div></figure><p id="186d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们进行传统的交换。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="cc7d" class="kv kw in lt b gy lx ly l lz ma">const tmp = firstBook;</span><span id="bc5a" class="kv kw in lt b gy mb ly l lz ma">firstBook = secondBook;</span><span id="3afd" class="kv kw in lt b gy mb ly l lz ma">secondBook = tmp;</span><span id="a295" class="kv kw in lt b gy mb ly l lz ma">console.log(‘First pick: ‘+firstBook+’, Second pick: ‘+secondBook);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/00a9e46f409dcdc640c03a1069b83977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/0*QPmQWSGBkQBJY-nE"/></div></figure><p id="9c68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是有了析构，整个过程可以变得容易得多。</p><p id="2ce6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们是这样做的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="cb41" class="kv kw in lt b gy lx ly l lz ma">let [firstBook, secondBook] = library.titles;</span><span id="35f8" class="kv kw in lt b gy mb ly l lz ma">[firstBook, secondBook] = [secondBook, firstBook];</span><span id="71d9" class="kv kw in lt b gy mb ly l lz ma">console.log(‘First pick: ‘+firstBook+’, Second pick: ‘+secondBook);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/76f8fcd416fbde4cbf4ad5a2a0476070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*gzZPzm_erGf1pIFF"/></div></figure><p id="5a07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们开始吧。</p><h2 id="b48a" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">从函数返回的数组中提取元素</h2><p id="e538" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">现在，一些新的东西。析构的另一个漂亮的特性是我们可以让一个函数返回一个数组，然后我们可以立即在不同的变量中析构结果。这允许我们从一个函数中返回多个值。为了验证这一点，让我们向库对象添加一个函数。</p><p id="8b71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是添加了lend()函数(借2本书)的更新后的图书馆对象的样子。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="7fcb" class="kv kw in lt b gy lx ly l lz ma">const library = {</span><span id="b64e" class="kv kw in lt b gy mb ly l lz ma"> name: "Soumadri’s Fiction Book Shelf",</span><span id="f1f0" class="kv kw in lt b gy mb ly l lz ma"> location: '1234 Fiction Palace, Calcutta, India',</span><span id="b8a4" class="kv kw in lt b gy mb ly l lz ma"> genres: [</span><span id="3684" class="kv kw in lt b gy mb ly l lz ma">  'Mystery',</span><span id="80f9" class="kv kw in lt b gy mb ly l lz ma">  'Horror',</span><span id="8c2a" class="kv kw in lt b gy mb ly l lz ma">  'Fantasy',</span><span id="6582" class="kv kw in lt b gy mb ly l lz ma">  'Sci-Fi',</span><span id="6ac4" class="kv kw in lt b gy mb ly l lz ma">  'Literary Fiction',</span><span id="3188" class="kv kw in lt b gy mb ly l lz ma">  'Historical Fiction',</span><span id="c3f7" class="kv kw in lt b gy mb ly l lz ma"> ],</span><span id="2ac0" class="kv kw in lt b gy mb ly l lz ma"> titles: [</span><span id="757d" class="kv kw in lt b gy mb ly l lz ma">  'The Inugami Clan',</span><span id="c87d" class="kv kw in lt b gy mb ly l lz ma">  'The Three Coffins',</span><span id="4480" class="kv kw in lt b gy mb ly l lz ma">  'In Search of Lost Time',</span><span id="79fe" class="kv kw in lt b gy mb ly l lz ma">  'Sandman',</span><span id="6acc" class="kv kw in lt b gy mb ly l lz ma">  'The Left Hand of Darkness',</span><span id="eae5" class="kv kw in lt b gy mb ly l lz ma">  'The Complete Works of H.P. Lovecraft',</span><span id="120e" class="kv kw in lt b gy mb ly l lz ma">  'Do Androids Dream of Electric Sheep?',</span><span id="5c3b" class="kv kw in lt b gy mb ly l lz ma">  'In the Woods',</span><span id="4139" class="kv kw in lt b gy mb ly l lz ma">  'In a Glass Darkly',</span><span id="afb0" class="kv kw in lt b gy mb ly l lz ma">  'Fingersmith',</span><span id="151b" class="kv kw in lt b gy mb ly l lz ma"> ],</span><span id="8476" class="kv kw in lt b gy mb ly l lz ma"> authors: [</span><span id="6306" class="kv kw in lt b gy mb ly l lz ma">  'Neil Gaiman',</span><span id="9812" class="kv kw in lt b gy mb ly l lz ma">  'Ursula Le Guin',</span><span id="596c" class="kv kw in lt b gy mb ly l lz ma">  'Sheridan Le Fanu',</span><span id="8dac" class="kv kw in lt b gy mb ly l lz ma">  'H.P. Lovecraft',</span><span id="ca16" class="kv kw in lt b gy mb ly l lz ma">  'Marcel Proust',</span><span id="a580" class="kv kw in lt b gy mb ly l lz ma">  'Tana French',</span><span id="bf52" class="kv kw in lt b gy mb ly l lz ma">  'John Dickson Carr',</span><span id="1133" class="kv kw in lt b gy mb ly l lz ma">  'Seishi Yokomizo',</span><span id="f3f7" class="kv kw in lt b gy mb ly l lz ma">  'Philip K. Dick',</span><span id="5db2" class="kv kw in lt b gy mb ly l lz ma">  'Sarah Waters',</span><span id="07fa" class="kv kw in lt b gy mb ly l lz ma"> ],</span><span id="00ea" class="kv kw in lt b gy mb ly l lz ma"> lend: function (firstBookIndex, secondBookIndex) {</span><span id="71e4" class="kv kw in lt b gy mb ly l lz ma">  return [this.titles[firstBookIndex], this.titles[secondBookIndex]];</span><span id="b67b" class="kv kw in lt b gy mb ly l lz ma"> },</span><span id="b492" class="kv kw in lt b gy mb ly l lz ma">};</span></pre><p id="9002" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经向库对象添加了函数<code class="fe nb nc nd lt b">lend()</code>。这是一个接受两个参数的函数——第一个标题的<strong class="jx io">索引位置和第二个标题</strong>的<strong class="jx io">索引位置。</strong></p><p id="7638" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用户通过提供每个标题的索引号来借两本书。我们从<code class="fe nb nc nd lt b">library.titles</code>数组中的相应位置返回值(以数组的形式)，这是基于作为参数传递的位置。</p><p id="83ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在，让我们借我们的书。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="f6b7" class="kv kw in lt b gy lx ly l lz ma">console.log(library.lend(2,6));</span></pre><p id="fa82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的结果:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/9df37460a8f6019b44e33b93bb777b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*bozBlKiv52aXpLza"/></div></figure><p id="0368" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们从<code class="fe nb nc nd lt b"> library.titles</code>数组中选取了<strong class="jx io">索引位置2和6 </strong>，这些对应的标题就是我们以数组形式返回的结果。</p><p id="d959" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们来破坏这个数组。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="2516" class="kv kw in lt b gy lx ly l lz ma">let [firstBook, secondBook] = library.lend(2, 6);</span></pre><p id="9916" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们记录这些值。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="d950" class="kv kw in lt b gy lx ly l lz ma">console.log(firstBook, secondBook);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b12a3a0c22b85ebe1856355bd54f0e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/0*wZreNihQJAEU82jn"/></div></figure><p id="0fd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实上，我们得到了“寻找失去的时间”和“机器人会梦见电子羊吗？”。</p><p id="a99a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我们如何从一个函数中得到两个或更多的返回值。这也可以在没有析构的情况下完成，但是这是一个非常简洁和方便的方法，可以在一个函数调用中立即创建两个或更多的变量。</p><h2 id="c250" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">嵌套析构</strong></h2><p id="3769" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">让我们来看看如果你有一个嵌套数组(数组中的数组)会发生什么。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="fa83" class="kv kw in lt b gy lx ly l lz ma">const nested = [1, 3, [2, 4]];</span></pre><p id="674a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在，基于我们目前所学的，让我们尝试得到值1(第0个索引)和嵌套数组[2，4](第2个索引)。我们将跳过第一个索引位置(3)的值。我建议在找到解决方案之前，自己先试一试。</p><p id="3fdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，我希望你能成功。如果你不是，别担心。下面是我们将如何着手做这件事。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b8af" class="kv kw in lt b gy lx ly l lz ma">const [i, ,j] = nested;</span><span id="e6b0" class="kv kw in lt b gy mb ly l lz ma">console.log(i, j);</span></pre><p id="363c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，我们得到了我们想要的结果。</p><p id="2987" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这很棒，但是如果我们想要所有的单个值，而不是整个嵌套数组呢？如果你从逻辑上考虑，这其实很简单。然后，我们只需要在析构中进行析构。因此，让我们尝试分别检索3个值— 1、2、4。我们将再次跳过第一个索引。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6d05" class="kv kw in lt b gy lx ly l lz ma">const [i, ,[j, k]] = nested;</span></pre><p id="680a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们正在数组析构中执行数组析构(在=运算符的左侧用[]表示)。因此，j和k将分别获得值2和4。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4bb6" class="kv kw in lt b gy lx ly l lz ma">console.log(i, j, k);</span></pre><p id="c55d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，我们做到了。</p><h2 id="e5f1" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">设置默认值</strong></h2><p id="8d6b" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">最后，我们还可以在提取变量时为它们设置默认值。当我们不知道从中检索值的数组的长度时(这在现实世界的应用程序和项目中很常见)，这将非常有帮助。</p><p id="c9ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有一个数组(右手边),它的值我们不知道(当然，我会在这里设置值，但为了这节课，我们假装不知道长度和值)。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="37ed" class="kv kw in lt b gy lx ly l lz ma">const [p, q, r] = [8, 9];</span></pre><p id="f2ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们尝试记录这些值:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="d636" class="kv kw in lt b gy lx ly l lz ma">console.log(p, q, r);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/393f036828a6fd7db9b1115860cb14ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*WbnFOOB9rSfc3J6Y"/></div></figure><p id="1865" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没错。我们得到未定义的r值，解决这个问题的方法是设置默认值。我们只需将p、q和r的默认值设置为1。如果在相应的索引位置有可用的值，默认值将被覆盖。如果右侧没有相应的索引位置，那么将保持默认值。让我们试试这个。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5a0b" class="kv kw in lt b gy lx ly l lz ma">const [p=1, q=1, r=1] = [8, 9];</span><span id="8aa1" class="kv kw in lt b gy mb ly l lz ma">console.log(p, q, r);</span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0ed1e77b4f13529322674ff9877d7554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/0*HiQderewgb5UyAxP"/></div></figure><p id="5827" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，p和q的值分别为8和9，而r现在有了默认值1。</p><h2 id="6602" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">结论</h2><p id="e441" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">就这些了，恭喜你到达本文结尾。我要感谢Jonas Schmedtmann和他出色而全面的Udemy <a class="ae kt" href="https://www.udemy.com/course/the-complete-javascript-course/" rel="noopener ugc nofollow" target="_blank">课程</a>，让我对这些话题有了清晰而恰当的理解。我希望这个小指南对你也有用。如果您有任何疑问或意见，请随时发表评论。</p><p id="a196" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的下一篇文章中，我将介绍JavaScript 中对象的<strong class="jx io">析构。享受你的一天，并有一个美好的一天。回头见。</strong></p><p id="a13c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ku">plain English . io</em></a></p></div></div>    
</body>
</html>