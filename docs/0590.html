<html>
<head>
<title>Easiest Way to Find the Most Frequent Element in Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找数组中最频繁元素的最简单方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-find-the-most-frequent-element-in-an-array-in-javascript-c85119dc78d2?source=collection_archive---------4-----------------------#2021-02-05">https://javascript.plainenglish.io/how-to-find-the-most-frequent-element-in-an-array-in-javascript-c85119dc78d2?source=collection_archive---------4-----------------------#2021-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b47c0600c0b0c62e1af475eec0e2fe6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VStEGWJRRFZXIBXpe8ZmwQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@casparrubin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Caspar Camille Rubin</a> on <a class="ae kc" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="77ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在浏览时，我找不到最有效和最短的解决方案来找到数组中最频繁的元素，但我只找到了许多长的解决方案，但最好的方法是<strong class="kf ir">不要使用嵌套的for循环。</strong>因为在大O符号中，它是一个<code class="fe lb lc ld le b">O(n2)</code>复杂度，意味着它是无效的。</p><p id="9805" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">找到数组中最频繁出现的元素的最好方法是使用reduce函数并创建一个hashmap。这就是你需要的全部代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2da9" class="ln lo iq le b gy lp lq l lr ls">function getMostFrequent(arr) {<br/>   const hashmap = arr.reduce( (acc, val) =&gt; {<br/>    acc[val] = (acc[val] || 0 ) + 1<br/>    return acc<br/> },{})<br/>return Object.keys(hashmap).reduce((a, b) =&gt; hashmap[a] &gt; hashmap[b] ? a : b)<br/>}</span></pre><p id="7fdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我所做的是，用reduce创建一个散列表。如果我们有一个类似于<code class="fe lb lc ld le b">[‘john’, ‘doe’, ’john’, ’bilge’]</code>的数组，我们的散列表将会是这样的:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/bfb1aad5e3dcb45a890e414c1a11e42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*cWmFdzad5JVm02XpMj4fXg.jpeg"/></div></figure><p id="6609" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们在第一个reduce函数中使用acc创建了一个对象，注意<strong class="kf ir"/><code class="fe lb lc ld le b"><strong class="kf ir">acc</strong></code><strong class="kf ir">的初始值是{} </strong>。</p><p id="18df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们检查数组的每个值:这个值已经在<code class="fe lb lc ld le b">acc</code>中了吗？</p><p id="aec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有，在对象中放一个键值对。(元素的第一次出现)</p><p id="4bc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，增加它的值。</p><p id="ab07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了包含元素及其在数组中的出现次数的hashmap，那么我们只需要得到具有最大值的键。</p><p id="fc97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们只需找到数组中的最大值，然后像这样用reduce函数返回它的键。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1aac" class="ln lo iq le b gy lp lq l lr ls">Object.keys(hashmap).reduce((a, b) =&gt; hashmap[a] &gt; hashmap[b] ? a : b)</span></pre><p id="7f92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>正如您可能注意到的，这将只返回<strong class="kf ir">一个具有最高值的键</strong>，如果您有两个具有最高值的元素，并且您想要返回它的数组，那么您需要更改第二个reduce函数。</p><p id="a787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果数组中不只有一个最大值，并且想要返回一个最大值数组，可以使用:</strong></p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0fa5" class="ln lo iq le b gy lp lq l lr ls">return Object.keys(hashmap).filter(x =&gt; {<br/>             return hashmap[x] == Math.max.apply(null, <br/>             Object.values(hashmap))<br/>       })</span></pre><p id="f028" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这将返回最频繁出现的元素的数组，即使有一个。它会过滤掉没有最大值的元素并返回。</p><h2 id="fc06" class="ln lo iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">结论</h2><p id="2ac8" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">我们做到了！如何找到数组中最常见的元素？我希望您发现这很有用！</p></div></div>    
</body>
</html>