<html>
<head>
<title>Write a Simple Static Site Generator to Convert HTML hardcoded values into Dynamic Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写一个简单的静态站点生成器，将HTML硬编码值转换为动态值</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/write-a-simple-static-site-generator-to-convert-html-hardcoded-values-and-to-dynamic-values-8f59bb1d9d34?source=collection_archive---------12-----------------------#2021-05-27">https://javascript.plainenglish.io/write-a-simple-static-site-generator-to-convert-html-hardcoded-values-and-to-dynamic-values-8f59bb1d9d34?source=collection_archive---------12-----------------------#2021-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f20d6d25690b19f35305fbcc1357a912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EYsxMnQNwgUewvtqgKOhQ.jpeg"/></div></div></figure><p id="9955" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，我要写的是我们如何轻松地创建自己的静态站点生成器。</p><p id="3cac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我接到一个任务，我必须转换一个有大量硬编码数据的HTML网站。我被要求删除它，并使用一个内容丰富或棱柱形的数据源。</p><p id="c02d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于Node.js和文件系统(fs ),编写一个获取代码、更改内容并输出项目的生成器非常容易。</p><p id="b36a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但为了让它变得非常简单，我想出了一个每个人都能理解的解决方案。这是需要的步骤。</p><h2 id="feb7" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">步伐</h2><ol class=""><li id="dada" class="lm ln in jx b jy lo kc lp kg lq kk lr ko ls ks lt lu lv lw bi translated">读取输入文件</li><li id="fcab" class="lm ln in jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">修改输入文件的内容</li><li id="9c44" class="lm ln in jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">将输入文件文件夹复制到输出目录</li><li id="b739" class="lm ln in jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">替换步骤2中修改的内容，并将其与您在步骤3中创建的输出文件合并</li></ol><p id="0f2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以创造奇迹但并不容易的四个步骤。阅读输入文件意味着我们将有一个装满各种垃圾的文件夹。我们将只针对HTML文件。我们将在源文件夹或嵌套的根目录中找到所有的HTML。<br/> <br/>下一步将修改输入文件的内容。为了修改输入文件的内容，我们将不得不使用Node.js可以解析的某种模板引擎，在我们的例子中，考虑到它的流行和支持以及GitHub上的明星，它将是handlebars。<br/> <br/>下一步相当简单。您只需将所有文件从src复制并粘贴到output (src - &gt; output)，我们将借助Node.js. <br/> <br/>提供的文件系统来完成这项工作。最后一步将包括合并编译后的修改代码，并将其替换到输出文件中。为了在输出文件中替换它，我们需要知道需要替换的文件的确切位置。</p><p id="a13b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，不要再说了！让我们从结构开始吧。我们将只有一个Node.js文件，所需的依赖关系是:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="56e2" class="kt ku in mh b gy ml mm l mn mo">const path = require("path");<br/>const fs = require("fs");<br/>const fse = require("fs-extra");<br/>const walkSync = require("walk-sync");<br/>const Handlebars = require("handlebars");</span></pre><p id="5d94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个函数给我们所有人<em class="mp"> *。文件夹中的html </em>文件。我们将使用一个已经为此创建的库。它的名字叫walkSync。函数会是这样的。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3a35" class="kt ku in mh b gy ml mm l mn mo">const getAllTheHTMLFiles = (directory) =&gt; {<br/> const paths = walkSync(directory, { globs: ["**/*.html"] });<br/> return paths;<br/>};</span></pre><p id="2cea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们写一个函数，这个函数将使用车把编译后的HTML返回给我们。但在此之前，让我给你一个车把的小例子。</p><p id="e52c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有一个数据对象:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e554" class="kt ku in mh b gy ml mm l mn mo">const data = {<br/>  title: “The Boring Company”,<br/>   description : “Just a boring company”<br/> }</span></pre><p id="d3fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有这样一个HTML结构:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3b68" class="kt ku in mh b gy ml mm l mn mo">&lt;h1&gt;{{ title }}&lt;/h1&gt;<br/> &lt;p&gt; {{ description }} &lt;/p&gt;</span></pre><p id="bad2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在编译时，它返回:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b2c1" class="kt ku in mh b gy ml mm l mn mo">&lt;h1&gt;The Boring Company&lt;/h1&gt;<br/> &lt;p&gt; Just a boring company&lt;/p&gt;</span></pre><p id="41ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，函数。我们考虑数据对象看起来像这样:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8262" class="kt ku in mh b gy ml mm l mn mo">const data = {<br/> ["index.html"]: {<br/>    title: “The Boring Company - Home”,<br/>   description: “Just a boring company”<br/> },<br/> ["blog-detail.html"]: {<br/>    title: “The Boring Company - Blog”,<br/>   description : “Just a boring company”<br/> },<br/>};</span></pre><p id="f6e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ff0e" class="kt ku in mh b gy ml mm l mn mo">const compileFilesOneByOne = (path) =&gt; {</span><span id="c8ca" class="kt ku in mh b gy mq mm l mn mo">fs.readFile(outDir + "/" + path, (e, file) =&gt; {<br/>  const source = file.toString();<br/> // Handlebars compile the html and saved in template<br/>  var template = Handlebars.compile(source);</span><span id="4caf" class="kt ku in mh b gy mq mm l mn mo">const magic = data[path];<br/>  if (!magic) return;<br/>// and now the out can be written in the files of output directory<br/>  const output = template(magic);</span><span id="4768" class="kt ku in mh b gy mq mm l mn mo">fs.writeFile(outDir + "/" + path, output, (e, a) =&gt; {<br/>   console.log({ e, a });<br/>  });<br/> });<br/>};</span></pre><p id="a1af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们编写一个函数，将一个文件夹的内容复制到另一个文件夹，为了进行复制，我们将使用FS-extra库。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="78d8" class="kt ku in mh b gy ml mm l mn mo">const copySrcContent = async () =&gt; {<br/> await fse.copySync(srcDir, outDir, { overwrite: true }, function (err) {<br/>  if (err) {<br/>   console.error(err); // add if you want to replace existing folder or file with same name<br/>  } else {<br/>   console.log("success!");<br/>  }<br/> });<br/>};</span></pre><p id="6532" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，总结一下，让我们创建一个名为init()的函数，并按顺序调用上述所有函数。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="53b9" class="kt ku in mh b gy ml mm l mn mo">const srcDir = path.join(__dirname, "src");<br/>const outDir = path.join(__dirname, "output");</span><span id="b1b8" class="kt ku in mh b gy mq mm l mn mo">const init = async () =&gt; {<br/>// Copy the content form src -&gt; output<br/> await copySrcContent();<br/>// We now fetch all the .html files<br/> const htmlFiles = getAllTheHTMLFiles(srcDir);<br/> // Now we rewrite the output files with the compiled data<br/> htmlFiles.forEach((e) =&gt; {<br/>  compileFilesOneByOne(e);<br/> });<br/>};</span><span id="ab8b" class="kt ku in mh b gy mq mm l mn mo">init()</span></pre><p id="9e60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">砰的一声。运行时，所有HTML模板化的代码将被转移到另一个名为output的文件夹中，在那里您将拥有HTML编译后的代码。</p><p id="d122" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天就到这里，希望你喜欢这篇文章。请随意竖起大拇指，如果您有任何疑问，请告诉我。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/38b8591e729e1cf3a97754591886fd0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*tOtw_CEDhwy0NOL9_LyCgg.jpeg"/></div></figure><p id="fb94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你愿意，你可以雇佣我通过https://www.fiverr.com/share/b5ydeW建立一个静态站点生成器</p><h2 id="d1be" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">谢谢你。</h2><p id="0709" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated"><em class="mp">更内容于</em><a class="ae ms" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5</a></p></div></div>    
</body>
</html>