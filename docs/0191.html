<html>
<head>
<title>Implementing Quicksort in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中实现快速排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-quicksort-in-javascript-8923a9773044?source=collection_archive---------12-----------------------#2021-01-11">https://javascript.plainenglish.io/implementing-quicksort-in-javascript-8923a9773044?source=collection_archive---------12-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6b5588b8dffe630dcd0ac6d131afaafa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h2B0CDFU2JAITUeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@mikael_k?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mikael Kristenson</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3274" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上周我报道了用JavaScript 实现合并排序的<a class="ae jz" href="https://medium.com/javascript-in-plain-english/implementing-merge-sort-in-javascript-4ea74f92bbea" rel="noopener">。本周我将介绍快速排序，这是另一种常用的排序算法。像合并排序一样，快速排序是另一种比较排序算法，它采用了一种分治和并发的方法。</a></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="1c7a" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">分步示例</h1><p id="8caa" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">对阵列执行快速排序的步骤如下:</p><ul class=""><li id="488c" class="mi mj in kc b kd ke kh ki kl mk kp ml kt mm kx mn mo mp mq bi translated">从数组中挑选一个元素，称为<em class="mr">中枢。</em></li><li id="8a63" class="mi mj in kc b kd ms kh mt kl mu kp mv kt mw kx mn mo mp mq bi translated">对数组重新排序，使小于轴心的元素排在前面，大于轴心的元素排在后面。这称为分区，因为现在阵列位于两个分区中。</li><li id="276e" class="mi mj in kc b kd ms kh mt kl mu kp mv kt mw kx mn mo mp mq bi translated">在两个分区上递归调用quicksort，只要分区至少包含1个元素(基本情况)。</li></ul><p id="c5f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有几件事需要注意。选择哪个元素作为枢纽会极大地影响性能，例如，如果选择第一个或最后一个元素作为枢纽，并对已经排序的数组运行快速排序，将导致O(n)时间复杂度。</p><p id="50fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一件要注意的事情是，我们将使用霍尔的分区。以开发快速排序算法的计算机科学家东尼·霍尔命名。霍尔的分区通过使用两个索引来工作，分别指向数组的开头和结尾。索引将彼此相向移动，直到左边的索引(或数组的开始)找到大于或等于主元的元素，而右边的索引(或数组的结尾)找到小于或等于主元的元素。在这一点上，这两个元素将交换。当左和右(或开始和结束)索引交叉时，算法将返回左索引的值。</p><p id="c382" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经了解了整个过程以及分区过程，让我们开始吧。</p><h2 id="4b0d" class="mx lg in bd lh my mz dn ll na nb dp lp kl nc nd lt kp ne nf lx kt ng nh mb ni bi translated">预期结果</h2><p id="89aa" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">按升序排序<br/>输入:[4，2，5，1，3，6] <br/>输出:[1，2，3，4，5，6]</p><h2 id="9350" class="mx lg in bd lh my mz dn ll na nb dp lp kl nc nd lt kp ne nf lx kt ng nh mb ni bi translated">第一步</h2><p id="114c" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们需要决定我们的支点。因为我们知道第一个或最后一个元素可能导致O(n)时间复杂度，所以通常建议选择随机索引、中间索引或中间索引。为简单起见，我们将选择中间的索引。</p><p id="b0e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">array = [4, 2, 5, 1, 3, 6]<br/>pivot = 2 // since we’re working with 0 based indexing</code></p><p id="8ba9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们需要对阵列进行分区。我们将引用pivot处的数组值，并将开始和结束时的值与pivot值进行比较，以找到我们需要交换的内容。</p><p id="1c42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">startIndex = 0<br/>endIndex = 5<br/>pivotVal = 5<br/>[<strong class="kc io">4</strong>, 2, <strong class="kc io">5</strong>, 1, 3, <strong class="kc io">6</strong>]</code></p><p id="dcdb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">startIndex (4)处的值小于pivot处的值，因此我们将递增startIndex。endIndex (6)处的值大于我们的pivot值，因此我们将减少endIndex。</p><p id="4a23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">startIndex = 1<br/>endIndex = 4<br/>pivotVal = 5<br/>[4, <strong class="kc io">2</strong>, <strong class="kc io">5</strong>, 1, <strong class="kc io">3</strong>, 6]</code></p><p id="030c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在2 &lt; 5, so we increment startIndex. However 3 &lt; 5, so we won’t decrement endIndex.</p><p id="f897" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"> 【T1】 </p><p id="f0ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Now that the startIndex has overlapped with pivot it isn’t less than the pivot (they are equal). So at this point we will swap the elements at startIndex and endIndex (since we had already found an element less than our pivot at the endIndex).</p><p id="58ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">So our array now looks like: [4, 2, 3, 1, 5, 6]<br/>由于我们执行了交换，我们将增加startIndex并减少endIndex。</p><p id="b1b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">startIndex = 3<br/>endIndex = 3<br/>pivotVal = 5<br/>[4, 2, 3, <strong class="kc io">1</strong>, <strong class="kc io">5</strong>, 6]</code></p><p id="10f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1&lt; 5, so we will increment startIndex. Then startIndex and endIndex will have crossed and we will end our partition algorithm and return startIndex.</p><p id="3959" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">This is what we are left with:<br/>T3】</p><h2 id="e62d" class="mx lg in bd lh my mz dn ll na nb dp lp kl nc nd lt kp ne nf lx kt ng nh mb ni bi translated">第二步</h2><p id="5070" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">现在我们将使用返回的startIndex创建两个分区。第一个是从0索引到返回的索引减1，第二个是从返回的索引到原始数组的末尾。</p><p id="5edb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">partition1 = [4, 2, 3, 1]<br/>partition2 = [5, 6]</code></p><p id="6efb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将在每个分区上运行quicksort。让我们来看一下分区1的过程。</p><p id="8338" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">array = [4, 2, 3, 1]<br/>pivot = 1</code></p><p id="1475" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">startIndex = 0<br/>endIndex = 3<br/>pivotVal = 2<br/>[<strong class="kc io">4</strong>, <strong class="kc io">2</strong>, 3, <strong class="kc io">1</strong>]</code></p><p id="90a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4 &gt; 2和1 &lt; 2<br/>交换4和1，并分别递增和递减startIndex和endIndex。</p><p id="44aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">startIndex = 1<br/>endIndex = 2<br/>pivotVal = 2<br/>[1, <strong class="kc io">2</strong>, <strong class="kc io">3</strong>, 4]</code></p><p id="f762" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2不小于2，所以我们不会增加startIndex，3 &gt; 2，所以我们会减少endIndex。</p><p id="bd68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">startIndex = 1<br/>endIndex = 1<br/>pivotVal = 2<br/>[1, <strong class="kc io">2</strong>, 3, 4]</code></p><p id="e267" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在startIndex、endIndex和pivotVal的值都相同了。这有点奇怪，因为它实际上会导致我们“交换”这些值，尽管实际上什么都没有改变。之后，我们递增和递减startIndex和endIndex。</p><p id="5c67" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nj nk nl nm b">startIndex = 2<br/>endIndex = 0<br/>pivotVal = 2<br/>[1, 2, 3, 4]</code></p><p id="6358" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于startIndex &gt; endIndex，我们将结束我们的分区算法，并返回值2。</p><h2 id="164b" class="mx lg in bd lh my mz dn ll na nb dp lp kl nc nd lt kp ne nf lx kt ng nh mb ni bi translated">最终迭代</h2><p id="1cf2" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">从这里开始，我们的分区1现在实际上被分成另外两个分区[1，2]和[3，4]。我们还将对这些元素运行快速排序，尽管它们已经按顺序排列，这将对[1]和[2]以及[3]和[4]运行快速排序，它们都将遇到只有一个元素的数组的基本情况。分割2也是如此，因为它是[5，6]。它会分成[5]和[6]两部分，并击中基本情况。至此，我们的数组已经排序，快速排序算法也完成了。</p><h1 id="8038" class="lf lg in bd lh li nn lk ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc bi translated">密码</h1><p id="ad1f" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">首先，我们需要制定我们的划分算法。</p><pre class="ns nt nu nv gt nw nm nx ny aw nz bi"><span id="40ad" class="mx lg in nm b gy oa ob l oc od">function partition(arr, start, end) {<br/>    // For random pivot use =&gt; arr[Math.floor(Math.random() * (end - start + 1) + start)];</span><span id="2f32" class="mx lg in nm b gy oe ob l oc od">    // middle pivot<br/>    const pivotVal = arr[Math.floor((start + end) / 2)];</span><span id="bd1a" class="mx lg in nm b gy oe ob l oc od">    while (start &lt;= end) {<br/>        while (arr[start] &lt; pivotVal) {<br/>            start++;<br/>        }<br/>        while (arr[end] &gt; pivotVal) {<br/>            end--;<br/>        }</span><span id="d472" class="mx lg in nm b gy oe ob l oc od">        if (start &lt;= end) {<br/>            // swap<br/>            let temp = arr[start];<br/>            arr[start] = arr[end];<br/>            arr[end] = temp;</span><span id="4645" class="mx lg in nm b gy oe ob l oc od">            start++;<br/>            end--;<br/>        }<br/>    }</span><span id="3a24" class="mx lg in nm b gy oe ob l oc od">    return start;<br/>}  </span></pre><p id="071c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像我们一步一步的例子一样，我们得到了元素在轴上的值。从这里开始，我们将循环遍历数组，直到<code class="fe nj nk nl nm b">start</code>索引小于<code class="fe nj nk nl nm b">end</code>索引。</p><p id="c259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的<code class="fe nj nk nl nm b">while</code>循环中，开始时有两个<code class="fe nj nk nl nm b">while</code>循环。他们的目的是增加<code class="fe nj nk nl nm b">start</code>索引，直到有一个元素大于我们的枢纽值，并减少我们的<code class="fe nj nk nl nm b">end</code>索引，直到有一个元素小于我们的枢纽值。</p><p id="3852" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此时，我们交换<code class="fe nj nk nl nm b">start</code>和<code class="fe nj nk nl nm b">end</code>处的元素，并分别递增和递减它们。</p><p id="a94e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我们脱离了第一个<code class="fe nj nk nl nm b">while</code>循环，我们就返回<code class="fe nj nk nl nm b">start</code>，这样我们就可以用它来找到我们的分区。</p><p id="5ffe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们实现快速排序算法。</p><pre class="ns nt nu nv gt nw nm nx ny aw nz bi"><span id="8a44" class="mx lg in nm b gy oa ob l oc od">function quickSort(arr, start = 0, end = arr.length - 1) {<br/>    if (start &lt; end) {<br/>        const index = partition(arr, start, end);</span><span id="5d58" class="mx lg in nm b gy oe ob l oc od">        quickSort(arr, start, index - 1);<br/>        quickSort(arr, index, end);<br/>    }</span><span id="acfd" class="mx lg in nm b gy oe ob l oc od">    return arr;<br/>}</span></pre><p id="2c57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们开始我们的<code class="fe nj nk nl nm b">quickSort</code>函数，接受一个数组、一个<code class="fe nj nk nl nm b">start</code>值和一个<code class="fe nj nk nl nm b">end</code>值。我们给它们数组的第一个和最后一个索引的默认值，这样我们就可以在一个数组上调用<code class="fe nj nk nl nm b">quickSort</code>,而不需要自己手动传递这些值。</p><p id="1e5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，只要数组有不止一个元素(只要<code class="fe nj nk nl nm b">start &lt; end</code>)我们就会运行partition，它会返回决定我们分区分割的<code class="fe nj nk nl nm b">index</code>。最后我们返回数组。</p><h1 id="55ff" class="lf lg in bd lh li nn lk ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc bi translated">时间复杂度、空间复杂度和稳定性</h1><h2 id="557c" class="mx lg in bd lh my mz dn ll na nb dp lp kl nc nd lt kp ne nf lx kt ng nh mb ni bi translated">时间复杂度</h2><p id="b344" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">最坏情况下的时间复杂度是O(n)，这发生在所选择的中枢是重复的，其中大多数或所有其他元素大于或小于中枢的时候。平均和最好的时间复杂度是O(n log n)。在这一点上，你可能想知道为什么我们会使用快速排序而不是合并排序，因为合并排序<em class="mr">总是</em>具有线性时间复杂度。使用快速排序很少得到最坏情况下的时间复杂度。除此之外，快速排序具有更好的缓存局部性。什么是缓存局部性？</p><p id="6bc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是来自<a class="ae jz" href="https://www.cs.cornell.edu/courses/cs3110/2012sp/lectures/lec25-locality/lec25.html" rel="noopener ugc nofollow" target="_blank">康乃尔大学</a> : <em class="mr">的简短描述“为了应对计算机内存相对变慢的问题，计算机架构师引入了</em> <strong class="kc io"> <em class="mr">高速缓存</em> </strong> <em class="mr">，它们是位于CPU和主内存之间的更小、更快的内存。高速缓存跟踪处理器最近请求的存储器位置的内容。如果处理器要求这些位置中的一个，缓存将给出答案。因为高速缓存比主存小得多(几百千字节而不是几十或几百兆字节)，所以它可以比主存更快地传送请求:几十个周期而不是几百个周期</em></p><h2 id="c0cc" class="mx lg in bd lh my mz dn ll na nb dp lp kl nc nd lt kp ne nf lx kt ng nh mb ni bi translated">空间复杂性</h2><p id="dfc4" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">快速排序就地排序，这是它比合并排序更受欢迎的另一个原因。也就是说，它具有O(log n)的空间复杂度。这与在每个分区上进行的递归调用有关。<a class="ae jz" href="https://stackoverflow.com/questions/12573330/why-does-quicksort-use-ologn-extra-space#:~:text=Quicksort%20with%20in%2Dplace%20and,O(log%20n)%20space." rel="noopener ugc nofollow" target="_blank">这个堆栈溢出</a>问题在评论中有一些非常有见地的答案(即使是关于java的，这些答案仍然适用)。</p><h2 id="6524" class="mx lg in bd lh my mz dn ll na nb dp lp kl nc nd lt kp ne nf lx kt ng nh mb ni bi translated">稳定性</h2><p id="bc70" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">快速排序不是一种稳定的排序算法，这也是您可能希望使用合并排序而不是快速排序的原因。这意味着它不会保持等值元素的顺序。</p><h1 id="403a" class="lf lg in bd lh li nn lk ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc bi translated">最后</h1><p id="2622" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">快速排序和合并排序比我们前面的例子更难理解。就个人而言，我仍然更多地关注线性时间复杂度，现在我需要理解堆栈上的递归调用如何影响空间复杂度。也就是说，很高兴终于能够实现一些更广泛使用的排序算法。我已经把这篇博客中使用的代码放在了GitHub仓库<a class="ae jz" href="https://github.com/ReginaF2012/JavaScript_quickSort" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>