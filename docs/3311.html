<html>
<head>
<title>How to Handle Database Deadlock in Sequelize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理Sequelize中的数据库死锁</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-handle-database-deadlock-in-sequelize-6bee46e9ed99?source=collection_archive---------2-----------------------#2021-07-06">https://javascript.plainenglish.io/how-to-handle-database-deadlock-in-sequelize-6bee46e9ed99?source=collection_archive---------2-----------------------#2021-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8588ee72d1a48b3ea29a52ebe4ad5a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9jrA0Js4mbPGt1VA"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@punttim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Gouw</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fdab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎来到另一个新故事。在这个故事中，我将分享我处理<a class="ae jz" href="https://www.sentryone.com/sql-server/sql-deadlock" rel="noopener ugc nofollow" target="_blank"> SQL死锁</a>场景的经验。这个故事有四个部分:</p><ul class=""><li id="0ccb" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">您可能遇到的死锁情况的类型</li><li id="eea4" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">解决僵局的方法</li><li id="b647" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">示例代码</li><li id="d267" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">一些帮助我解决问题的有用资源</li></ul><p id="2647" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">事不宜迟，我们开始吧</strong>。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="7982" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">您可能遇到的死锁情况的类型</h1><p id="1465" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">首先，在庞大而复杂的软件系统中，遇到数据库(DB)死锁是很常见的，尤其是当您的应用程序频繁更新相同的DB记录时。</p><p id="5082" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我根据频率将死锁场景分为两种不同的类型:</p><ul class=""><li id="8779" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">每次在同一行代码出现<strong class="kc io">的死锁错误</strong></li><li id="06b3" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">在同一行代码中偶然出现的死锁错误<strong class="kc io"/></li></ul></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="3fb7" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">解决僵局的方法</h1><p id="c173" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">有两种方法可以解决死锁。</p><ul class=""><li id="aae7" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="kc io">确定死锁发生的位置并解决它</strong>。这适用于第一种情况，因为每次都会发生死锁，所以您没有其他选择。通常，您可以在代码级别解决这个问题。</li><li id="5027" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="kc io">死锁发生时的重试策略。</strong>这适用于第二种情况，在这种情况下,<strong class="kc io">您几乎不知道它为什么会发生，并且具有不一致的发生模式</strong>。最后但同样重要的是，这个场景也需要花费大量的时间和精力来调试。所以实施重试策略是最好的解决方法。</li></ul><p id="2302" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，根据MySQL <a class="ae jz" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html" rel="noopener ugc nofollow" target="_blank">文档</a>，</p><blockquote class="mw"><p id="657b" class="mx my in bd mz na nb nc nd ne nf kx dk translated"><a class="ae jz" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_deadlock" rel="noopener ugc nofollow" target="_blank">死锁</a>是事务数据库中的一个经典问题，但它们并不危险，除非它们非常频繁，以至于您根本无法运行某些事务。通常，您必须编写自己的应用程序，以便在事务因死锁而回滚时，它们总是准备好重新发出事务。— <a class="ae jz" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html" rel="noopener ugc nofollow" target="_blank"> MySQL文档</a></p></blockquote><p id="eb7a" class="pw-post-body-paragraph ka kb in kc b kd ng kf kg kh nh kj kk kl ni kn ko kp nj kr ks kt nk kv kw kx ig bi translated">通俗地说，如果发生死锁，只需重试一次。在下一节，我将分享当死锁发生时如何在Sequelize中实现重试。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="3201" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">Sequelize中的示例代码</h1><p id="4abf" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">现在，我将使用<a class="ae jz" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank">序列表单</a>设置重试策略。事实上，这很容易设置。在初始化序列库时定义重试策略。</p><p id="0173" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是完整的代码。主要焦点是<code class="fe nl nm nn no b">retry</code>对象。<code class="fe nl nm nn no b">retry</code>对象是重试策略的配置。</p><ul class=""><li id="b3b4" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><code class="fe nl nm nn no b"><strong class="kc io">match</strong></code>:由一组错误组成。如果匹配，数据库事务将再次重试，直到达到最大尝试次数。我使用regex <code class="fe nl nm nn no b">/Deadlock/i</code>来确保事务只在死锁发生时重试。</li><li id="b851" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><code class="fe nl nm nn no b"><strong class="kc io">max</strong></code>:最大重试次数。</li><li id="5a04" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><code class="fe nl nm nn no b"><strong class="kc io">backOffBase</strong></code>:初始退避持续时间。</li><li id="fcf7" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><code class="fe nl nm nn no b"><strong class="kc io">backOffExponent</strong></code> <strong class="kc io"> : </strong>每次重试退避增加的指数。</li></ul><figure class="np nq nr ns gt jo"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="c42c" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">其他有用的资源</h1><h2 id="49e8" class="nv lu in bd lv nw nx dn lz ny nz dp md kl oa ob mh kp oc od ml kt oe of mp og bi translated">指数补偿计算器</h2><p id="1884" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">您可以使用下面的指数补偿计算器获得更多信息以及每个信息之间的间隔。</p><div class="oh oi gp gr oj ok"><a href="http://exponentialbackoffcalculator.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">指数补偿计算器</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">一个在线指数补偿计算器。输入间隔(秒)、最大重试次数和指数速率。想象一下…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">exponentialbackoffcalculator.com</p></div></div></div></a></div><h2 id="fd91" class="nv lu in bd lv nw nx dn lz ny nz dp md kl oa ob mh kp oc od ml kt oe of mp og bi translated">承诺重试库</h2><p id="2b77" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">这是用来实现他们的重试策略的库序列。请参考<a class="ae jz" href="https://www.npmjs.com/package/retry-as-promised" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">承诺重试</strong> </a> <strong class="kc io"> </strong>了解您可以在<code class="fe nl nm nn no b">retry</code>对象中设置的所有配置。</p><p id="eecb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后但同样重要的是，Sequelize中还有一个关于重试事务的很棒的帖子。请参考下面的链接。</p><div class="oh oi gp gr oj ok"><a href="https://dev.to/anonyma/how-to-retry-transactions-in-sequelize-5h5c" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">如何在Sequelize中重试事务</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">您可能会得到类似“SequelizeDatabaseError:试图获取锁时发现死锁；尝试重新启动…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">开发到</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy jt ok"/></div></div></a></div></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="48c9" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="6745" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在这个故事中，我分享了死锁场景的类型以及如何使用Sequelize ORM实现重试策略。</p><p id="68a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读。</p><p id="89ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="oz">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="oz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>