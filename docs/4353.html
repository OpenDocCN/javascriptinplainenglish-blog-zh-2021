<html>
<head>
<title>Running JavaScript in WebAssembly with WasmEdge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WasmEdge在WebAssembly中运行JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/running-javascript-in-webassembly-883ec71438e1?source=collection_archive---------8-----------------------#2021-08-30">https://javascript.plainenglish.io/running-javascript-in-webassembly-883ec71438e1?source=collection_archive---------8-----------------------#2021-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ce6f2eec3af52336b6cc6f6be3919e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4LKOkLu-MB2QAQb9FaRhQ.png"/></div></div></figure><p id="0180" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>一开始是“浏览器的JavaScript替代品”。想法是在浏览器中安全地运行由C/C++或Rust等语言编译的高性能应用程序。在浏览器中，WebAssembly与JavaScript并行运行。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/0ec9a4f5ad5924944021c9fe816da02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*h59dPAp6HQcaaIQt7GdejA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk">Figure 1. WebAssembly and JavaScript in the browser.</figcaption></figure><p id="2117" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着WebAssembly越来越多地在云中使用，它现在是云原生应用的通用运行时<a class="ae kt" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"/>。与Docker类应用程序容器相比，WebAssembly运行时以较低的资源消耗实现了更高的性能。云中WebAssembly的常见用例包括。</p><ul class=""><li id="3a65" class="ld le in jx b jy jz kc kd kg lf kk lg ko lh ks li lj lk ll bi translated"><a class="ae kt" href="https://github.com/second-state/aws-lambda-wasm-runtime" rel="noopener ugc nofollow" target="_blank">无服务器功能即服务</a> (FaaS)的运行时</li><li id="841e" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated">将<a class="ae kt" href="http://reactor.secondstate.info/en/docs/" rel="noopener ugc nofollow" target="_blank">用户自定义函数嵌入SaaS </a>应用程序或数据库</li><li id="bd99" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated">服务网格中<a class="ae kt" href="https://github.com/second-state/dapr-wasm" rel="noopener ugc nofollow" target="_blank">边车应用</a>的运行时间</li><li id="e530" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated">用于web代理的可编程插件</li><li id="b9d3" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated">边缘设备的沙盒运行时间，包括<a class="ae kt" href="https://www.secondstate.io/articles/second-state-joins-the-autoware-foundation/" rel="noopener ugc nofollow" target="_blank">软件定义的工具</a>和智能工厂</li></ul><p id="10f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，在那些云原生用例中，开发人员通常希望使用JavaScript来编写业务应用程序。这意味着我们现在必须在WebAssembly 中支持<a class="ae kt" href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/run_javascript.md" rel="noopener ugc nofollow" target="_blank"> JavaScript。此外，我们应该支持在WebAssembly运行时从JavaScript调用C/C++或Rust函数，以利用WebAssembly的计算效率。WasmEdge WebAssembly运行时允许您这样做。</a></p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/65558d8141084bc236e7f1b1d2c43729.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*OmqZydcKW18qNIbVKs0J3A.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk">Figure 2. WebAssembly and JavaScript in the cloud.</figcaption></figure><h1 id="6f4a" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">瓦斯梅奇</h1><p id="52e9" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> WasmEdge </a>是领先的云原生WebAssembly运行时<a class="ae kt" href="https://www.secondstate.io/articles/wasmedge-joins-cncf/" rel="noopener ugc nofollow" target="_blank">，由CNCF </a>(云原生计算基金会)/ Linux基金会托管。它是当今市场上最快的WebAssembly运行时。WasmEdge支持所有标准的WebAssembly扩展以及Tensorflow推理、KV存储和图像处理等专有扩展。其编译器工具链不仅支持C/C++、Rust、Swift、Kotlin和AssemblyScript等WebAssembly语言，还支持<a class="ae kt" href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/run_javascript.md" rel="noopener ugc nofollow" target="_blank">常规JavaScript </a>。</p><p id="c49b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">WasmEdge应用程序可以嵌入到一个<a class="ae kt" href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/c_api_quick_start.md" rel="noopener ugc nofollow" target="_blank"> C </a>程序、一个<a class="ae kt" href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/" rel="noopener ugc nofollow" target="_blank"> Go </a>程序、一个<a class="ae kt" href="https://github.com/WasmEdge/WasmEdge/tree/master/bindings/rust" rel="noopener ugc nofollow" target="_blank"> Rust </a>程序、一个<a class="ae kt" href="https://www.secondstate.io/articles/getting-started-with-rust-function/" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>程序或者操作系统的<a class="ae kt" href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/run.md" rel="noopener ugc nofollow" target="_blank"> CLI </a>中。运行时可以由Docker工具(如<a class="ae kt" href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/" rel="noopener ugc nofollow" target="_blank"> CRI-O </a>)、编排工具(如K8s)、无服务器平台(如<a class="ae kt" href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>、<a class="ae kt" href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>、<a class="ae kt" href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>、<a class="ae kt" href="https://github.com/second-state/tencent-scf-wasm-runtime" rel="noopener ugc nofollow" target="_blank">腾讯SCF </a>)和数据流框架(如<a class="ae kt" href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/" rel="noopener ugc nofollow" target="_blank"> YoMo </a>和Zenoh)来管理。</p><p id="9786" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您可以在WasmEdge支持的无服务器功能、微服务和AIoT应用程序中运行JavaScript程序！它不仅运行普通的JavaScript程序，还允许开发人员使用Rust和C/C++在WebAssembly的安全沙箱中创建新的JavaScript APIs。</p><h1 id="b60d" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">在WasmEdge中构建JavaScript引擎</h1><p id="3668" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">首先，让我们为WasmEdge构建一个基于WebAssmbly的JavaScript解释程序。它基于带有WasmEdge扩展的<a class="ae kt" href="https://bellard.org/quickjs/" rel="noopener ugc nofollow" target="_blank"> QuickJS </a>，如<a class="ae kt" href="https://github.com/second-state/wasmedge_wasi_socket" rel="noopener ugc nofollow" target="_blank">网络套接字</a>和<a class="ae kt" href="https://www.secondstate.io/articles/wasi-tensorflow/" rel="noopener ugc nofollow" target="_blank">张量流推理</a>，作为JavaScript APIs并入解释器。你需要<a class="ae kt" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank">安装Rust </a>来构建解释器。</p><blockquote class="mv mw mx"><p id="a43c" class="jv jw my jx b jy jz ka kb kc kd ke kf mz kh ki kj na kl km kn nb kp kq kr ks ig bi translated"><em class="in">如果只是想用解释器运行JavaScript程序，可以跳过这一节。确保你已经安装了</em> <a class="ae kt" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank"> <em class="in">锈</em> </a> <em class="in">和</em> <a class="ae kt" href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md" rel="noopener ugc nofollow" target="_blank"> <em class="in">锈</em> </a> <em class="in">。</em></p></blockquote><p id="c501" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">派生或克隆wasmegde-quickjs Github存储库来开始。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="1c4b" class="nh lt in nd b gy ni nj l nk nl">$ git clone <a class="ae kt" href="https://github.com/second-state/wasmedge-quickjs" rel="noopener ugc nofollow" target="_blank">https://github.com/second-state/wasmedge-quickjs</a></span></pre><p id="53e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照报告中的说明，您将能够为WasmEdge构建一个JavaScript解释器。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="ca6b" class="nh lt in nd b gy ni nj l nk nl"># Install GCC<br/>$ sudo apt update<br/>$ sudo apt install build-essential</span><span id="a5d0" class="nh lt in nd b gy nm nj l nk nl"># Install wasm32-wasi target for Rust<br/>$ rustup target add wasm32-wasi</span><span id="bdc7" class="nh lt in nd b gy nm nj l nk nl"># Build the QuickJS JavaScript interpreter<br/>$ cargo build --target wasm32-wasi --release</span></pre><p id="81b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于WebAssembly的JavaScript解释程序位于构建目标目录中。您现在可以尝试一个简单的“hello world”JavaScript程序(<a class="ae kt" href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js" rel="noopener ugc nofollow" target="_blank"> example_js/hello.js </a>)，它将命令行参数打印到控制台。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="a796" class="nh lt in nd b gy ni nj l nk nl">args = args.slice(1)<br/>print("Hello", ...args)</span></pre><p id="de2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在WasmEdge的QuickJS运行时运行<code class="fe nn no np nd b">hello.js</code>文件，如下所示。注意，命令行上的<code class="fe nn no np nd b">--dir .:.</code>是为了给<code class="fe nn no np nd b">wasmedge</code>权限来读取<code class="fe nn no np nd b">hello.js</code>文件在文件系统中的本地目录。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="e755" class="nh lt in nd b gy ni nj l nk nl">$ cd example_js<br/>$ wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm hello.js WasmEdge Runtime<br/>Hello WasmEdge Runtime</span></pre><h1 id="07de" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">ES6模块支持</h1><p id="3daf" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">WasmEdge QuickJS运行时支持ES6模块。GitHub repo中的<a class="ae kt" href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo" rel="noopener ugc nofollow" target="_blank">example _ js/es6 _ module _ demo</a>文件夹包含一个例子。<a class="ae kt" href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js" rel="noopener ugc nofollow" target="_blank"> module_def.js </a>文件定义并导出一个简单的js函数。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="4a05" class="nh lt in nd b gy ni nj l nk nl">function hello(){<br/>    console.log('hello from module_def.js')<br/>}</span><span id="5da2" class="nh lt in nd b gy nm nj l nk nl">export {hello}</span></pre><p id="de23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js" rel="noopener ugc nofollow" target="_blank"> module_def_async.js </a>文件定义并导出aysnc函数和变量。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="07f0" class="nh lt in nd b gy ni nj l nk nl">export async function hello(){<br/>    console.log('hello from module_def_async.js')<br/>    return "module_def_async.js : return value"<br/>}</span><span id="a346" class="nh lt in nd b gy nm nj l nk nl">export var something = "async thing"</span></pre><p id="d5a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js" rel="noopener ugc nofollow" target="_blank"> demo.js </a>文件从这些模块中导入函数和变量并执行它们。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="2119" class="nh lt in nd b gy ni nj l nk nl">import { hello as module_def_hello } from './module_def.js'<br/>module_def_hello()</span><span id="e99e" class="nh lt in nd b gy nm nj l nk nl">var f = async ()=&gt;{<br/>    let {hello , something} = await import('./module_def_async.js')<br/>    await hello()<br/>    console.log("./module_def_async.js `something` is ",something)<br/>}<br/>f()</span></pre><p id="9a73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要运行该示例，您可以在CLI上执行以下操作。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="c890" class="nh lt in nd b gy ni nj l nk nl">$ cd example_js/es6_module_demo<br/>$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm demo.js<br/>hello from module_def.js<br/>hello from module_def_async.js<br/>./module_def_async.js `something` is  async thing</span></pre><p id="017b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，让我们尝试几个更高级的JavaScript程序。</p><h1 id="2d43" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">JavaScript网络客户端示例</h1><p id="a282" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">解释器支持WasmEdge网络套接字扩展，这样您的JavaScript就可以与互联网建立HTTP连接。这里有一个JavaScript的例子。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="6ccb" class="nh lt in nd b gy ni nj l nk nl">let r = GET("http://18.235.124.214/get?a=123",{"a":"b","c":[1,2,3]})<br/>print(r.status)<br/>    <br/>let headers = r.headers<br/>print(JSON.stringify(headers))let body = r.body;<br/>let body_str = new Uint8Array(body)<br/>print(String.fromCharCode.apply(null,body_str))</span></pre><p id="df11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在WasmEdge运行时运行JavaScript，您可以在CLI上执行此操作。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="16a0" class="nh lt in nd b gy ni nj l nk nl">$ cd example_js<br/>$ wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm http_demo.js</span></pre><p id="5c74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您应该可以在控制台上看到HTTP GET结果。</p><h1 id="e9c6" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">JavaScript网络服务器示例</h1><p id="1477" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">下面是一个JavaScript运行HTTP服务器监听端口3000的例子。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="e317" class="nh lt in nd b gy ni nj l nk nl">import {HttpServer} from 'http'</span><span id="6d73" class="nh lt in nd b gy nm nj l nk nl">let http_server = new HttpServer('0.0.0.0:8000')<br/>print('listen on 0.0.0.0:8000')</span><span id="f2e8" class="nh lt in nd b gy nm nj l nk nl">while(true){<br/>    http_server.accept((request)=&gt;{<br/>        let body = request.body<br/>        let body_str = String.fromCharCode.apply(null,new Uint8Array(body))<br/>        print(JSON.stringify(request),'\n body_str:',body_str)</span><span id="9069" class="nh lt in nd b gy nm nj l nk nl">        return {<br/>            status:200,<br/>            header:{'Content-Type':'application/json'},<br/>            body:'echo:'+body_str<br/>        }<br/>    });<br/>}</span></pre><p id="b103" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在WasmEdge运行时运行JavaScript，您可以在CLI上执行此操作。既然是服务器，就应该在后台运行。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="91d0" class="nh lt in nd b gy ni nj l nk nl">$ cd example_js<br/>$ nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm http_server_demo.js &amp;</span></pre><p id="d30b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，您可以通过在网络上查询服务器来测试它。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="937e" class="nh lt in nd b gy ni nj l nk nl">$ curl -d "WasmEdge" -X POST http://localhost:8000<br/>echo:WasmEdge</span></pre><p id="547d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您应该看到控制台上打印的HTTP POST主体。</p><h1 id="5d70" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">JavaScript Tensorflow推理示例</h1><p id="e235" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">解释器支持WasmEdge Tensorflow lite推理扩展，因此您的JavaScript可以运行ImageNet模型进行图像分类。这里有一个JavaScript的例子。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="fe93" class="nh lt in nd b gy ni nj l nk nl">import {TensorflowLiteSession} from 'tensorflow_lite'<br/>import {Image} from 'image'let img = new Image('./example_js/tensorflow_lite_demo/food.jpg')</span><span id="491f" class="nh lt in nd b gy nm nj l nk nl">let img_rgb = img.to_rgb().resize(192,192)<br/>let rgb_pix = img_rgb.pixels()let session = new TensorflowLiteSession('./example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite')</span><span id="763a" class="nh lt in nd b gy nm nj l nk nl">session.add_input('input',rgb_pix)<br/>session.run()<br/>let output = session.get_output('MobilenetV1/Predictions/Softmax');<br/>let output_view = new Uint8Array(output)<br/>let max = 0;<br/>let max_idx = 0;<br/>for (var i in output_view){<br/>    let v = output_view[i]<br/>    if(v&gt;max){<br/>        max = v;<br/>        max_idx = i;<br/>    }<br/>}<br/>print(max,max_idx)</span></pre><p id="32ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在WasmEdge运行时运行JavaScript，您可以在CLI上执行以下操作，使用Tensorflow重新构建QuickJS引擎，然后使用Tensorflow API运行JavaScript程序。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="9243" class="nh lt in nd b gy ni nj l nk nl">$ cargo build --target wasm32-wasi --release --features=tensorflow<br/>... ...<br/>$ cd example_js/tensorflow_lite_demo<br/>$ wasmedge-tensorflow-lite --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm main.js<br/>label:<br/>Hot dog<br/>confidence:<br/>0.8941176470588236</span></pre><h2 id="eb11" class="nh lt in bd lu nq nr dn ly ns nt dp mc kg nu nv mg kk nw nx mk ko ny nz mo oa bi translated">注意:</h2><ul class=""><li id="ea7b" class="ld le in jx b jy mq kc mr kg ob kk oc ko od ks li lj lk ll bi translated">编译器标志用WasmEdge Tensorflow扩展构建QuickJS引擎的一个版本。</li><li id="8dcf" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated"><code class="fe nn no np nd b">wasmedge-tensorflow-lite</code>程序是WasmEdge包的一部分。它是内置了Tensorflow扩展的WasmEdge运行时。</li></ul><p id="3a4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您应该可以看到TensorFlow lite ImageNet模型识别的食品名称。</p><h1 id="a7f5" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">让它更快</h1><p id="af51" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">上面的Tensorflow推理示例需要1-2秒来运行。这在web应用程序场景中是可以接受的，但还可以改进。回想一下，WasmEdge是当今最快的WebAssembly运行时，这是因为它的AOT(提前编译)优化。WasmEdge提供了一个<code class="fe nn no np nd b">wasmedgec</code>实用程序来将<code class="fe nn no np nd b">wasm</code>文件编译到一个本地的<code class="fe nn no np nd b">so</code>共享库中。您可以使用<code class="fe nn no np nd b">wasmedge</code>来运行<code class="fe nn no np nd b">so</code>文件，而不是<code class="fe nn no np nd b">wasm</code>文件，以获得更快的性能。</p><p id="9086" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下示例使用扩展版本的<code class="fe nn no np nd b">wasmedge</code>和<code class="fe nn no np nd b">wasmedgec</code>来支持WasmEdge Tensorflow扩展。</p><pre class="kv kw kx ky gt nc nd ne nf aw ng bi"><span id="b63e" class="nh lt in nd b gy ni nj l nk nl">$ cd example_js/tensorflow_lite_demo<br/>$ wasmedgec-tensorflow ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.so<br/>$ wasmedge-tensorflow-lite --dir .:. wasmedge_quickjs.so main.js<br/>label:<br/>Hot dog<br/>confidence:<br/>0.8941176470588236</span></pre><p id="ae21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以看到图像分类任务可以在0.1s内完成，至少是10x的提升！</p><blockquote class="mv mw mx"><p id="ba75" class="jv jw my jx b jy jz ka kb kc kd ke kf mz kh ki kj na kl km kn nb kp kq kr ks ig bi translated"><em class="in"/><code class="fe nn no np nd b"><em class="in">so</em></code><em class="in">共享库不能跨机器和操作系统移植。您应该在您部署和运行应用程序的机器上运行</em> <code class="fe nn no np nd b"><em class="in">wasmedgec</em></code> <em class="in">和</em> <code class="fe nn no np nd b"><em class="in">wasmedgec-tensorflow</em></code> <em class="in">。</em></p></blockquote><h1 id="dd78" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">关于QuickJS的一个注记</h1><p id="70a0" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">现在，选择QuickJS作为我们的JavaScript引擎可能会带来性能问题。QuickJS <a class="ae kt" href="https://bellard.org/quickjs/bench.html" rel="noopener ugc nofollow" target="_blank">不是因为缺乏JIT支持而比v8慢很多吗？是的，但是…</a></p><p id="8ff8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先QuickJS比v8小很多。事实上，它只占用v8消耗的运行时资源的1/40(或2.5%)。在一台物理机器上，您可以运行比v8函数更多的QuickJS函数。</p><p id="77aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其次，对于大多数业务逻辑应用程序，原始性能并不重要。该应用程序可能有计算密集型任务，如人工智能的飞行推理。WasmEdge允许QuickJS应用程序使用高性能的WebAssembly来完成这些任务，而在v8中添加这样的扩展模块并不容易。</p><p id="bf41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第三，众所周知<a class="ae kt" href="https://www.theregister.com/2021/08/06/edge_super_duper_security_mode/" rel="noopener ugc nofollow" target="_blank">许多JavaScript安全问题源于JIT </a>。也许在云原生环境中关闭JIT并不是一个坏主意！</p><h1 id="b188" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">下一步是什么？</h1><p id="9f4e" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">示例演示了如何在WasmEdge中使用<code class="fe nn no np nd b">wasmedge-quickjs.wasm</code> JavaScript引擎。除了使用CLI，您还可以使用<a class="ae kt" href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/" rel="noopener ugc nofollow" target="_blank"> Docker / Kubernetes tools </a>来启动WebAssembly应用程序，或者将该应用程序嵌入到您自己的应用程序或框架中，正如我们在本文前面所讨论的。</p><p id="23d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在接下来的几篇文章中，我将重点介绍如何结合使用JavaScript和Rust来充分利用这两种语言。</p><ul class=""><li id="64eb" class="ld le in jx b jy jz kc kd kg lf kk lg ko lh ks li lj lk ll bi translated"><a class="ae kt" href="https://www.secondstate.io/articles/embed-javascript-in-rust/" rel="noopener ugc nofollow" target="_blank">将JavaScript整合到Rust应用中</a></li><li id="d6ba" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated"><a class="ae kt" href="https://www.secondstate.io/articles/embed-rust-in-javascript/" rel="noopener ugc nofollow" target="_blank">使用Rust创建高性能JavaScript APIs】</a></li><li id="3101" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated"><a class="ae kt" href="https://www.secondstate.io/articles/call-native-functions-from-javascript/" rel="noopener ugc nofollow" target="_blank">从JavaScript调用本地函数</a></li></ul><p id="2208" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">云原生WebAssembly中的JavaScript仍然是下一代云和边缘计算基础设施中的新兴领域。我们才刚刚开始！如果您感兴趣，请加入我们的<a class="ae kt" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> WasmEdge </a>项目(或者通过提出功能请求问题告诉我们您想要什么)。</p><h1 id="18ea" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><em class="oe">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ak"><em class="oe">plain English . io</em></strong></a></h1></div></div>    
</body>
</html>