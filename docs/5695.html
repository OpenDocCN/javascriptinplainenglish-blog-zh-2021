<html>
<head>
<title>Functional Programming In JavaScript: TypeScript for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数式编程:面向初学者的TypeScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-programming-in-javascript-typescript-for-beginners-ab3a40a912f3?source=collection_archive---------5-----------------------#2021-12-01">https://javascript.plainenglish.io/functional-programming-in-javascript-typescript-for-beginners-ab3a40a912f3?source=collection_archive---------5-----------------------#2021-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b5e333a0344a91cc0ffa7402c8c4086c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*09ulsgmuct-MQWrb"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sigmund</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="d654" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数式编程是编程世界中最容易误导人的话题之一。你会发现多篇文章，搞不清楚。那么应该如何理解函数式编程呢？</p><p id="a806" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript，或者说JavaScript，并没有被设计成与<a class="ae jd" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程(FP) </a>兼容。JavaScript是一种基于<a class="ae jd" href="https://en.wikipedia.org/wiki/Prototype-based_programming" rel="noopener ugc nofollow" target="_blank">原型的</a>面向对象语言。每当你创建一个变量，它就被当作一个对象来使用。那么，问题是:JavaScript如何支持函数式编程呢？要回答上面的问题，有<a class="ae jd" href="https://stackoverflow.com/questions/50835572/" rel="noopener ugc nofollow" target="_blank">糖语法</a>和自动换行。这些帮助开发人员不用太担心就可以编写函数式方法。让我们彻底了解他们。</p><p id="0336" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong> <em class="lb">所有代码示例都是用TypeScript编写的。可以使用</em><a class="ae jd" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"><em class="lb">TypeScript Playground</em></a><em class="lb">将TypeScript转换为JavaScript代码。</em></p><h1 id="e8e8" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">基本原则</h1><p id="b50a" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在进一步学习之前，您应该了解下面描述的一些基本原则。</p><ol class=""><li id="4cd8" class="mf mg jg kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">纯函数</li><li id="8baf" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">确定性函数</li><li id="839b" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">高阶函数</li><li id="406d" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">不变</li><li id="dbdd" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">Currying或部分功能</li><li id="4cd0" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">功能组成</li></ol><h2 id="e8b7" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">1.纯函数</h2><p id="693b" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">纯函数是确定性函数，没有副作用，也就是说，对于相同的输入，输出总是相同的。同时，它不会消耗任何其他全局变量。</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/32303043a833301d84758181b8123dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/0*pLVGm9R8vTaoS-o6"/></div></figure><p id="2433" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">纯函数的例子:</strong></p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e436" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，无论什么，对于相同的输入，输出将是相同的。</p><p id="4771" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">拥有一个纯函数的好处是容易理解和测试。然而，仅仅使用纯函数来构建一个完整的应用程序是非常困难的。我们也需要一些确定性函数。</p><p id="a8fd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注:</strong> <a class="ae jd" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank">反应纯分量</a>本质上是确定性的，但不是纯函数。它们有副作用，比如创建文档元素的React.createElement。</p><h2 id="8880" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">2.确定性函数</h2><p id="0728" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">确定性函数是指函数的输出总是确定的。这可能有副作用，但输出不应随时间而改变。同样的输入应该产生同样的输出。</p><p id="bf67" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">简单的例子:</strong></p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3965" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">另一个例子:</strong>确定性函数会有副作用。也就是说，它可以访问全局变量。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4432" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非确定性函数的示例:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8dd1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，方法<code class="fe nm nn no np b">rand</code>使用<code class="fe nm nn no np b">Math.random</code>生成一个随机数。这个API的输出将是不确定的。</p><p id="b3e2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确定性函数的好处是它在任何语言中都很常见。它很容易创建和理解。然而，它有一些副作用。有时候，很难测试。</p><h2 id="5656" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">3.HOF:高阶函数</h2><p id="75a5" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">HOF可以接受一个函数作为输入，也可以返回一个函数作为输出。</p><p id="e93a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e499" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong>在上面的例子中，<code class="fe nm nn no np b">groupBy</code>是一个函数。您可能已经注意到，我没有使用关键字<code class="fe nm nn no np b">function</code>来创建函数，因为我使用lambda作为函数，并将它赋给一个变量。在ES6/ES2015之后，JavaScript引入了lambda的概念以及许多新的语法。大多数都是围绕实际实现的糖语法。这里可以阅读更多<a class="ae jd" href="https://www.w3schools.com/js/js_es6.asp" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b4a6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nm nn no np b">groupBy</code>是一个将输入<code class="fe nm nn no np b">fn</code>作为函数，将<code class="fe nm nn no np b">data</code>作为数组的函数。对数组中的所有项进行计算后，它返回一个由键和值组成的对象。</p><p id="85a8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong>和HOF一样，<a class="ae jd" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> HOC in React </a>是一个可以把另一个组件作为输入，并且可以返回另一个组件的组件。</p><h2 id="4d35" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">4.不变</h2><p id="1676" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">不变性是指一旦数据/变量被创建，就不能在一段时间内改变。这个想法是为了避免交叉共享环境中的数据竞争，比如异步编程，副作用。</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/c95bacd1640bbf8b16e7c1b06b9746a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g8F1vNlTNIWiH0NY"/></div></div></figure><p id="285d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript确实有一些不变性API。然而，这些还不够。让我们来看一些例子。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="97a2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于JavaScript是一种动态语言，也就是说，数据可以在运行时改变，这使得在JavaScript中实现不变性很困难。同时，并不是所有的成员/对象都支持不变性。可以使用<a class="ae jd" href="https://github.com/immutable-js/immutable-js" rel="noopener ugc nofollow" target="_blank">不可变-js </a>。然而，我建议将不可变性作为一种实践，并且不要包含另一个库。</p><h2 id="f98f" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">实现不变性的简单方法</h2><p id="133a" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated"><strong class="kf jh">数组</strong>:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d57a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">对象</strong></p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6120" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">地图</strong></p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="56f3" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">5.Currying或部分功能</h2><p id="9866" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Currying是FP中的一种方法或技术，其中一个函数可以被组合成部分接受输入。也就是说，如果一个函数<code class="fe nm nn no np b">sum</code>接受输入<code class="fe nm nn no np b">a</code>和<code class="fe nm nn no np b">b</code>作为参数，那么currying这个函数可以让这个函数<code class="fe nm nn no np b">sum</code>接受一个参数<code class="fe nm nn no np b">a</code>并返回另一个函数。稍后，我们可以使用新创建的函数进行求和。</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0f359ed14b526d8154aae4dde8885a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/0*KCxrFG9mISuMagh0"/></div></figure><p id="8e02" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">我们从例子来看:</strong></p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="77da" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，<code class="fe nm nn no np b">split</code>函数接受令牌和字符串数据进行拆分。我们已经创建了一个函数<code class="fe nm nn no np b">splitByHash</code>，其中已经定义了令牌。只需要一根绳子就能把它劈开。这里，<code class="fe nm nn no np b">splitByHash</code>是部分函数。</p><p id="31be" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong>上面的例子很好地演示了部分函数。然而，创建这样的部分函数对于超过2/3的参数是不可伸缩的。我们可以使用一些基本的工具来创建一个部分函数或定制函数。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="457a" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">6.功能组成</h2><p id="4cf4" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">函数合成是一个数学概念，其中一个运算取两个函数f和g，并产生一个函数h，使得h(x) = g(f(x))。为简单起见，(g f)(x) = g(f(x))</p><p id="8460" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">我们来看例子:</strong></p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cafa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，你可以看到，<code class="fe nm nn no np b">multiplyAndAdd5</code>是从右向左组合的。它首先乘以2(5x 2 = 10)。拿出来加10。</p><p id="c1c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">让我们看另一个例子:</strong>获取活跃用户的平均年龄</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8405" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，为了获得活跃用户的平均年龄，我们必须调用多个方法。这很好。但是我们可以使用compose使其更具声明性。如果我们必须写一些功能性的东西，它看起来会像下面这样:</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b360" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，添加compose使得组合函数和创建另一个函数变得容易。可以在以后重复使用。</p><h2 id="49e5" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">一些现实生活中的问题</h2><p id="4c82" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">现在既然知道了FP的基础，那就来举例探究一下吧。</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="05e5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，首先，我们使用rest API获取一些todos。之后，我们将根据todo的完成状态对其进行过滤。一旦我们都完成了todos，我们就收集id并获取所有用户。</p><p id="0b2c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切都好。然而，如果我们必须改变一个简单的行为，那就去找那些没有完成待办事项的用户。即使它只是不变，但会改变所有的编码声明。我们必须改变所有的变量名。这是一项乏味的工作。我们可以使用FP让这个程序更具声明性。为此，我们确实需要一些辅助方法:</p><p id="1f6f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">助手方法:</strong> <a class="ae jd" href="https://decipher.dev/30-seconds-of-typescript/docs/" rel="noopener ugc nofollow" target="_blank"> 30秒的打字稿</a></p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6442" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们重写同样的程序</p><figure class="ng nh ni nj gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a24f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong>函数式编程还有其他一些方面。我还没有涵盖所有的内容。原因是:要么对于本文的范围来说太复杂，要么与JavaScript本身无关。</p><p id="ade7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">一些值得一提的概念:</strong></p><ol class=""><li id="9bee" class="mf mg jg kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">功能数据结构</li><li id="47e5" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">无例外地处理错误</li><li id="3863" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">严与懒(懒评)</li><li id="e73d" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">功能并行性(异步浮点)</li><li id="5ce1" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">幺半群和函子</li><li id="690e" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">副作用</li></ol><h2 id="33c8" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated">从这里去哪里</h2><p id="6e0e" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">正如我已经提到的，JavaScript不是一种全功能语言。同时，作为JavaScript开发人员，我们必须在前端使用文档和窗口。所以我们不能完全忽略杂质。我们必须混合搭配。以这种方式编写函数使您的代码更具声明性和可读性。然而，就核心概念而言，它确实增加了一点代码的复杂性。也就是说，如果你知道上面描述的基本概念，你就可以开始编写函数式程序了。网上有多篇文章。如果你真的想学函数，我在下面列出了一些。我还会推荐用像<a class="ae jd" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>、<a class="ae jd" href="https://clojure.org/" rel="noopener ugc nofollow" target="_blank"> Clojure </a>、<a class="ae jd" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>这样的语言写一些代码。它将帮助你理解FP背后的核心概念和思想。</p><p id="c5a8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="lb">注:</em> </strong> <em class="lb">由于内容篇幅原因，我不得不把这个话题分成多篇文章。我将很快发表下一部分。</em></p><h2 id="e6c5" class="mt ld jg bd le mu mv dn li mw mx dp lm ko my mz lq ks na nb lu kw nc nd ly ne bi translated"><strong class="ak">参考文章</strong></h2><ol class=""><li id="e989" class="mf mg jg kf b kg ma kk mb ko ns ks nt kw nu la mk ml mm mn bi translated"><a class="ae jd" href="https://opensource.com/article/17/6/functional-javascript#:~:text=Those%20first%2Dclass%20functions%20are,growing%20trend%20toward%20functional%20programming." rel="noopener ugc nofollow" target="_blank">JavaScript函数式编程简介</a></li><li id="9189" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">每个人都应该知道的9个函数式编程概念</li><li id="fbcf" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://medium.com/swlh/understand-the-key-functional-programming-concepts-bca440f1bcd6" rel="noopener">理解关键的函数式编程概念</a></li><li id="71c3" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://decipher.dev/30-seconds-of-typescript/docs/" rel="noopener ugc nofollow" target="_blank"> 30秒的打字稿/ </a></li><li id="3dae" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://docs.scala-lang.org/overviews/scala-book/functional-programming.html" rel="noopener ugc nofollow" target="_blank">Scala-book/函数式编程</a></li><li id="52de" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://www.freecodecamp.org/news/an-introduction-to-the-basic-principles-of-functional-programming-a2c2a15c84/" rel="noopener ugc nofollow" target="_blank">函数式编程基本原理简介</a></li></ol><p id="7255" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更多内容看</em> <a class="ae jd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="lb">说白了。报名参加我们的</em> <a class="ae jd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="lb">免费每周简讯在这里</em> </strong> </a> <strong class="kf jh"> <em class="lb">。</em> </strong></strong></a></p></div></div>    
</body>
</html>