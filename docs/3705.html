<html>
<head>
<title>How Many Requests Can a Real-World Node.js Server-Side App Handle?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个真实的Node.js服务器端应用程序可以处理多少请求？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-many-requests-can-handle-a-real-world-nodejs-server-side-application-55da7a2f06f3?source=collection_archive---------0-----------------------#2021-07-25">https://javascript.plainenglish.io/how-many-requests-can-handle-a-real-world-nodejs-server-side-application-55da7a2f06f3?source=collection_archive---------0-----------------------#2021-07-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="8d12" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">简介</strong></h1><p id="6b88" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当我第一次接触Node.js时，我想知道在生产环境中(作为一个真实的应用程序)，有多少请求可以真正处理我的Node.js应用程序。或者我需要多少服务器实例来处理特定数量的流量。</p><p id="8d37" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">去年，我在一家独角兽公司<a class="ae ll" href="https://picsart.com" rel="noopener ugc nofollow" target="_blank"> PicsArt </a>的一篇文章中读到了一些非常有趣的东西。他们每秒处理40K个请求，后端使用Node.js(主要是)。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/2094e889ba51f685cc943018d89801e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gucMBly1rZRgLpfRZxzMA.png"/></div></div></figure><p id="882c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">嗯，40K rps确实很庞大，也取决于后端服务器之外的一些其他因素。但此时此刻，让我们忘记这些因素，只考虑后端硬件和软件，特别是Node.js。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ly"><img src="../Images/610e3f90ce2eeafc3ba7bdaa71abb382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPQ7MDPCOdpdJSXP2f3Jjw.png"/></div></div></figure><h1 id="1e58" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">研究</strong></h1><h2 id="b766" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">Fastify基准</h2><p id="f2fe" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">有一个由<a class="ae ll" href="https://www.fastify.io" rel="noopener ugc nofollow" target="_blank"> Fastify </a> creators做的基准测试，它显示express.js每秒可以处理~15K的请求，vanilla HTTP模块可以处理70K的rps。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ml"><img src="../Images/0799baba681d6aa7eaaa0726eddd885d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Y9MVRmPIQDP4vyEeBC7Zg.png"/></div></div></figure><p id="a10c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我用一台Macbook Pro 15" 2015试了一下，得到了几乎一样的结果。express.js连15K rps成绩听起来真的很棒。但是基准测试通常是在一个很小的API处理器上进行的，这与真实世界的API相差甚远。那么，是什么让API成为“真实世界”的呢？数据、数据传输以及组件之间的交互。要拥有一个真实的API，我们必须创建一个与DB或其他服务通信的处理程序。</p><h2 id="8583" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">我的实验</h2><p id="1c1b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这些结果并不重要。在大多数情况下，像express(15K)这样经过验证的框架更好，因为实际上，您不会用一个实例每秒处理100K个请求。因此，我为我的基准安装了express.js，创建了一个具有各种类型操作的小API处理程序，并进行了负载测试</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mm"><img src="../Images/d00f06cdcfdabcf79ef4e47e053cc49d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92XeB8qnQ-OJm4vAoH5sww.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Api handler for the load tests</figcaption></figure><ol class=""><li id="f079" class="mr ms in kk b kl lg kp lh kt mt kx mu lb mv lf mw mx my mz bi translated">在数据库中写入一个新用户</li><li id="92f8" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf mw mx my mz bi translated">从数据库中获取20个用户</li><li id="56b0" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf mw mx my mz bi translated">stringify/Parse 20个用户的数组</li><li id="b4bc" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf mw mx my mz bi translated">递归地将20个用户对象转换为camelCase</li><li id="3594" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf mw mx my mz bi translated">对20个用户的数组进行排序</li><li id="aa93" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf mw mx my mz bi translated">还有一些简单的计算和标准输出(Date.now，console . log——它们也消耗计算资源)</li></ol><p id="5596" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">响应大小约为12KB，每个用户对象如下所示</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nf"><img src="../Images/c47d717b70b574581a9f38f311512c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcEKrvTtvcE-FilCG4Br6w.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">User object, 609 bytes of data</figcaption></figure><p id="9835" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">Heroku中的Node.js与AWS RDS </strong></p><p id="d34d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我在Heroku以每月25美元的硬件部署了这个应用程序。然后，我在不增加平均延迟的情况下尽可能多地发送请求。因此，我的Node.js实例能够在60秒内处理31K个请求，这意味着平均每秒515个请求。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ng"><img src="../Images/e1f488fcefae7eaa779d38e49ed1d20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WRQVQFNf5-Y9_06cieBF9Q.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Node.js benchmark</figcaption></figure><p id="2b3f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">Heroku的Django，带AWS RDS </strong></p><p id="78a9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然后，我问如果我用非单线程的技术做同样的尝试会怎么样。我用一个等价的处理程序为Django应用程序创建了完全相同的条件，并将其部署到相同的服务器上。结果比Node.js差一点，我可以在60秒内达到23K个请求，也就是每秒389个请求。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nh"><img src="../Images/613def9db81c9b70fcb97bca42a6718d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5tFzAbZf0Pzvv95ZhRKaA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Django benchmark</figcaption></figure><p id="7659" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">带有AWS RDS的AWS EB上的Node.js(3个实例)</strong></p><p id="c095" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然后，我问，如果我的Node.js应用程序是一个真正的生产应用程序，并且部署在AWS中，为特定的流量而启动和运行，会怎么样？我选择了法兰克福(eu-central-1，离我最近，大约3000公里😁)区域，用于数据库和后端服务器。我在那个测试中使用了3个带有AWS负载平衡的Node.js实例。我的3个实例能够在10秒内处理19K个请求，这意味着每秒1858个请求。然后，我持续对我的应用程序进行负载测试，我可以在13分钟内达到150万个成功的请求，这很令人兴奋😁</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ni"><img src="../Images/518de44c33e3d371581596d5f2f1c2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QhkWRqA7KrimaCiLbSz15g.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Node.js benchmark deployed on AWS EB</figcaption></figure><p id="3294" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">那么，我们用一个实例处理600个rps，我们需要什么来处理每秒40K个请求呢？如果我们平台的平均API比我测试的大两倍<strong class="kk io"> * </strong>。因此，对于一个全球规模的独角兽应用程序，我需要40.000/(600/2) = 133个位于世界各地不同位置的实例。没什么大不了的😁</p><p id="7493" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> <em class="nj"> * </em> </strong> <em class="nj">它可以大3倍，但它也可以使用各种缓存技术、基于事件的</em>通信、<em class="nj">等来赢得每秒更多的请求，所以我认为大2倍是准确的度量</em></p><p id="d0d2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">我想以一个有用的列表来结束这篇文章，这个列表列出了你正在使用或将要使用的应用程序中可能会遇到的一些问题。</strong></p><h1 id="ff63" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">可能的性能问题</h1><p id="0c4c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">有数不清的因素会降低我们的API。我分离了一些性能相关的部分，我们可以在大多数web服务器端应用程序中看到。</p><ul class=""><li id="7cfb" class="mr ms in kk b kl lg kp lh kt mt kx mu lb mv lf nk mx my mz bi translated">从数据库中存储或提取的数据大小。尤其是当我们谈到关系数据库时，这一点更为重要，因为大数据量通常意味着数据库管理系统和数据库内存磁盘之间的复杂查询或复杂操作。然而，在所有情况下，我们有越多的字节，我们需要更多的传输时间。我们还应该记住，在DB中保存文件是一种反模式，相反，我们应该考虑使用对象存储。理想情况下，我们的数据大小不应该超过几十千字节，通常是1-20kb</li><li id="b50e" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">后端服务器和数据库服务器之间的物理距离。更远的距离意味着DB接收查询并将其发送回后端服务器需要更多的时间。举个例子，我们在美国弗吉尼亚州和德国法兰克福有两台后端服务器，但是在美国弗吉尼亚州只有一台数据库服务器。我们美国用户的请求将被路由到我们美国后端实例，延迟约为10–40毫秒，然后从后端(弗吉尼亚)到数据库(弗吉尼亚)的延迟为1–5毫秒。还不错。让我们看看对于来自德国的用户来说会发生什么，“用户的设备”—“后端服务器”的延迟将为10–20毫秒，但查询数据将需要120–130毫秒。因此，如果我们有一个单一区域的应用程序，理想情况下，我们的数据和后端逻辑是邻居。或者，如果我们有一个全球规模的应用程序，我们应该准备好做各种复杂的工程工作，以获得良好的性能</li><li id="a621" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">DB服务器硬件也有很大的影响。如果我们有一个小应用程序，考虑购买更好的硬件来适应我们的流量，否则——“各种复杂的工程材料”☝️😁</li><li id="3457" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">数据库配置。数据库带有默认配置，以避免管理成为一个额外的难题。根据我们的规模，我们将处理它。我想提到的一件事是最大连接数，它可能是我们应用程序的瓶颈，或者是我们数据库服务器的负担。它通常由数据库客户端库(ORM等)重新配置..).另一件事是连接超时。</li><li id="8f56" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">数据库调用的数量。在现实世界的API中，我们可以有几十个独立的数据库调用来最终完成工作，此外，在该API中，我们还可以有服务调用，每个服务都有自己的“几十个数据库调用”。我遇到的一个令人印象深刻的例子，是在我很久以前加入的一个项目中，一个银行业整体后端API。在云开发环境中，有一个响应时间为9s的API。这个API下的服务处理程序有300行代码，其中我们可以找到大约30个DB调用和大约10个内部服务调用。这通常发生在我们的方法是“代码优先”而不是“设计优先”的时候。根据我们的业务逻辑，有许多解决方案可以帮助避免这种情况。例如，队列和其他异步措施可以让我们有可能在“后台”处理一些DB调用。为了利用这一点，我们需要将我们的大服务分解成小服务。此外，我们可以加入查询，以减少数据库调用的数量。</li><li id="128f" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">钩子。在所有流行的ODM/ORM中，有一个特性叫做钩子/中间件。有时候让这个特性处理一些逻辑真的很舒服。有时，尤其是在处理批量操作时，我们可能会面临一个“隐藏的”瓶颈。ODM/ORM插件也需要计算资源，这也意味着需要时间(例如用于camelCase/pascal_case转换的插件)。挂钩真的很有帮助，但需要仔细考虑我们写了什么，在哪里写。</li><li id="f789" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">CPU密集型任务不仅会降低服务器速度，还会让最终用户等待。在Node.js中，许多CPU密集型任务依赖于线程池。虽然它不会阻塞异步IO，但它会使API变慢。例如，用户点击注册并等待线程池散列他/她的密码，顺便说一下，这需要100毫秒。</li><li id="f754" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">事件循环瓶颈。在Node.js中，代码的执行依赖于事件循环，所以我们的代码的性能对整个应用程序有直接的影响(因为它是在单线程上运行的)。例如，使用JSON.parse/stringify会降低我们的API的速度。嵌套循环和递归函数也很危险。当忽略Node.js如何工作时，根据数据大小和应用程序流量，我们可能会遇到问题，我们的应用程序可能不可用。</li><li id="9fd5" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">糟糕的基础架构。大型基础设施中可能出现的问题不仅仅是整体应用中的问题，它们是不同的，有时需要复杂的架构解决方案。当我们的基础设施包含许多组件时，糟糕的架构会对我们的API产生巨大的影响，我们的系统将以资源低效的方式工作，这意味着我们将为本来可以更便宜的东西支付更多的钱。因此，在设计复杂的应用程序时，我们必须考虑特定技术解决的问题，并充分了解替代方案。我们还需要考虑前景，如果我们在两个月或六个月内制作一个功能时有业务需求变化，会发生什么，在每个语句上尽可能多地猜测。想想<a class="ae ll" href="https://en.wikipedia.org/wiki/Service-level_agreement" rel="noopener ugc nofollow" target="_blank"> SLA </a>。想想<a class="ae ll" href="https://en.wikipedia.org/wiki/Non-functional_requirement" rel="noopener ugc nofollow" target="_blank">非功能需求</a>，流量上去了怎么办？随时准备应对意想不到的高流量，即使有一种理论认为我们必须准备处理比我们现有流量多10倍的流量。</li><li id="e6de" class="mr ms in kk b kl na kp nb kt nc kx nd lb ne lf nk mx my mz bi translated">元件规模/硬件/设置。我们在基础架构中创建的组件会降低整个平台的速度。假设我们使用RabbitMQ。像任何技术一样，它有大量的配置和选项。如果我们一开始就有标准，那就没问题。但是，随着时间的推移，如果我们做更多的研究，如果我们深入到一个特定的组件，我们会意识到，我们可以通过做一些设置审查，或通过重构我们服务中的配置或使用来改善我们的基础设施。此外，我们必须根据使用情况扩展组件，以免在基础架构中造成瓶颈。</li></ul><p id="50ab" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">感谢阅读。而如果你喜欢与表演相关的文章，别忘了鼓掌，它会帮助我准备更多深思熟虑、见解更深刻的文章。</p><p id="222a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><em class="nj">更多内容尽在</em><a class="ae ll" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="nj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>