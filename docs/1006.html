<html>
<head>
<title>Writing a Node.js GraphQL backend that actually scales</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写实际可伸缩的Node.js GraphQL后端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-a-node-js-graphql-backend-that-actually-scales-d20c920a4494?source=collection_archive---------4-----------------------#2021-03-03">https://javascript.plainenglish.io/writing-a-node-js-graphql-backend-that-actually-scales-d20c920a4494?source=collection_archive---------4-----------------------#2021-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2654" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第3部分—分页和数据加载器</h2></div><p id="be16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你到了这一步，恭喜你！到目前为止，您已经拥有了一个功能完整的服务器，它通过GraphQL在最后一节上公开数据。但是，如果你想扩展你的应用，你还需要学习更多，小学徒。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/43ebba379839ecc7c79f7068985738ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vt5mit1vuKWmY9LZ.jpg"/></div></div></figure><p id="76dc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你是随机来到这里的，我鼓励你查看一下本教程的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/writing-a-node-js-graphql-backend-that-actually-scales-a-complete-guide-part-1-setup-cddceae25bdc">第一部分</a>和<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/writing-a-node-js-graphql-backend-that-actually-scales-bd5b3411b293">第二部分</a>，这样你也许能够理解我们在谈论什么，尽管这些知识可能适用于任何用相同堆栈编写的后端。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ll"><img src="../Images/98e9aaf105b9dea8ec394e2626854328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENMJyVnsHHu9ksNkO1NkDg.jpeg"/></div></div></figure><p id="6d08" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了继续我们此刻已经构建的内容，您应该还记得我们创建了允许GraphQL在数据库中从实体到实体进行无限连接的关系。</p><p id="a063" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这正是我们想要的，但它有一些问题，如何大和沉重的操作可能会得到，我们将需要应用一些额外的策略来解决这个问题。</p><p id="57d8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">开始之前，请记住，我们在这里看到的一切都是公开的<a class="ae ky" href="https://github.com/ernestognw/graphql-backend/tree/part-3" rel="noopener ugc nofollow" target="_blank">在主回购</a>这里</p><p id="ebac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们首先了解如何改进GraphQL模式与数据加载器之间的关系</p><h1 id="e21a" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">数据加载器</h1><p id="7aab" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated"><a class="ae ky" href="https://www.npmjs.com/package/dataloader" rel="noopener ugc nofollow" target="_blank"> Data Loader </a>是npm的一个库，它为您提供了一个对不同数据源进行批处理请求的实用程序，允许您通过避免重复请求来提高GraphQL应用程序的性能。</p><p id="8393" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用他们自己的话说:</p><blockquote class="mj mk ml"><p id="1e8a" class="kc kd mm ke b kf kg jo kh ki kj jr kk mn km kn ko mo kq kr ks mp ku kv kw kx ig bi translated">DataLoader是一个通用实用程序，可用作应用程序数据提取层的一部分，通过批处理和缓存为各种远程数据源(如数据库或web服务)提供一个简化且一致的API。</p></blockquote><p id="4b2b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了理解为什么这对我们很重要，让我们看一下之前的查询:</p><pre class="la lb lc ld gt mq mr ms mt aw mu bi"><span id="4e99" class="mv ln in mr b gy mw mx l my mz">query authors {<br/>  authors {<br/>    id<br/>    publishers {<br/>      id<br/>      authors {<br/>        id<br/>        publishers {<br/>          authors {<br/>            id<br/>            publishers {<br/>              id<br/>              authors {<br/>                id<br/>                publishers {<br/>                  id<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="a703" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里发生的情况是，每当我们更进一步，我们将不得不重新查询数据来填充关系，但是，如果数据已经被请求了呢？我们怎么知道呢？更重要的是，如何进行优化？</p><p id="3b81" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们的数据库中有以下关系图:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi na"><img src="../Images/83e57d6ca2fd137f18679e92ea0ccec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvYFOJuKAWTb6o6BgOkjMQ.png"/></div></div></figure><p id="a51c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个图表示的操作是一个作者查询，在这个查询中，我们请求它的出版商、这些出版商的作者，然后是这些作者的出版商，等等…你明白了。</p><p id="03da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类似于我们对运行的查询所做的，这是填充结果树，结果树可能会呈指数级增长。问题不在于规模本身，而在于我们所做的操作。</p><p id="300b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我把相同的颜色放在重复的记录上，这样你可以看到我们有多少重复的数据。所以，每次我们请求GraphQL填充一个关系，你都要再次查询你的数据库来得到你已经在内存中的结果。如果有某种缓存来检查我们在启动查询之前是否已经填充了一些数据，这不是很神奇吗？</p><p id="24f3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是数据加载器的好处。</p><p id="fac0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它获取一组键(id ),将它们存储在缓存中，一旦我们的查询到达末尾，DataLoader就运行一个查询来获取提供的每个键的相应结果，然后填充空白区域。</p><p id="59f6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要添加它，只需:</p><pre class="la lb lc ld gt mq mr ms mt aw mu bi"><span id="7d9e" class="mv ln in mr b gy mw mx l my mz">yarn add dataloader</span></pre><h1 id="904d" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">用数据加载器填充上下文</h1><p id="77ff" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">还记得每个解析器的第三个参数吗？上下文？太好了！</p><p id="ff78" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它将用于为我们发出的每个请求创建数据加载器，但是，等等，我们是在为每个请求创建加载器吗？是的。</p><p id="9dd9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原因很简单。每个加载器都有一个缓存，一旦某些数据发生变化，这个缓存就需要失效，否则，加载器将返回它第一次被请求时收到的相同记录，而没有数据的新变化。</p><p id="3871" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">建议创建加载器来完成请求，然后删除它们，这样下一个查询可能会再次准确。出于这个目的，我们需要一些可以传送到每个解析器的东西，这样它就可以为GraphQL模式中的每个实体携带一个加载器，这就是上下文。</p><p id="4c04" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/api/apollo-server/#context" rel="noopener ugc nofollow" target="_blank"> Apollo Docs </a>的说法，上下文是<em class="mm">一个对象或一个创建对象的函数，</em>所以我们可以提供一个函数来创建我们的请求加载器，然后在对象内部传递它们</p><p id="eb75" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在graphql文件夹中创建一个<code class="fe nb nc nd mr b">context.js</code>文件，这样我们可以添加一些代码来填充<code class="fe nb nc nd mr b">graphql/index.js</code>中的ApolloServer:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bc81" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">注意:</strong>我们没有为WorksAt创建loader，因为它是一个弱实体，所以这意味着它没有主键来查询，即使MongoDB分配了一个主键，我们的模式也不知道这些id是什么。所以，现在，这是没有用的，但我们稍后会深入探讨。</p><p id="ec31" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们只导出上下文函数，它返回一个包含加载器的对象。然后，我们还创建了一个实用函数，为提供的每个模型创建一个加载器。</p><p id="20ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd mr b">createLoader</code>函数以一个模型作为参数，在操作中用相同的$构造加载器。因此，它接收id，然后在一个查询中将提供的每个id加载到数据库中。</p><p id="e972" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">MongoDB的一个缺点是，对于$in操作中提供的id，它不能保证项目返回的顺序。因此，我们需要将它们映射在中间，以避免将来得到混合的结果。</p><p id="a599" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，对于每个加载器，我们返回一个<code class="fe nb nc nd mr b">.one</code>和<code class="fe nb nc nd mr b">.many</code>，因此您可以将它们用于单个或多个id。请注意，我们将它们转换为字符串。这是一种形式，您可以在使用它们时这样做，但通常更容易的是传递mongo返回给您的id，它不是字符串而是ObjectId。</p><p id="dcb2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，只需导入上下文并将其添加到您的Apollo服务器中</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="be7f" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">使用我们的装载机</h1><p id="375d" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">概括地说，数据加载器就像一个缓存层，可以避免重复查询。酷毙了。那么，我们基本上在哪里都可以应用，但是最好先分析一下在哪里可以应用。</p><p id="df83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果我们将它们应用到我们的主单个解析器中，比如<code class="fe nb nc nd mr b">books</code>或<code class="fe nb nc nd mr b">book</code>，此时可能是正确的，但是由于加载器<strong class="ke io">只接收id</strong>，如果我们想要以特定的方式过滤数据，会发生什么呢？我们不能。</p><p id="3c49" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么尽管数据加载器很棒，我还是建议在以自定义方式查询或修改数据之后使用它们，这样我们就可以调整查询以接收不同的参数，这是我们将在下一篇文章中使用的。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0d14cb8b5029c955cf3f4426a2f68003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*jHti1SX3-wCDxZmFJ071QQ.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">This is the recommended flow to use the loaders</figcaption></figure><p id="16f8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们把这些知识应用到作者身上，然后，剩下的就交给你自己去完成了。</p><p id="1bdc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将从查询开始。你不会注意到太多的变化，但是装载机的使用:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a5ab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，我们首先查询作者，然后他们返回加载器。这些看起来像是我们再次复制查询，因为加载器将再次获取数据并返回它，在某种程度上，我们是这样，但让我详细说明一下这种情况。</p><p id="bdbc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您有一个来自客户端的类似这样的查询:</p><pre class="la lb lc ld gt mq mr ms mt aw mu bi"><span id="6869" class="mv ln in mr b gy mw mx l my mz">query customQuery {<br/>  authors {<br/>    id<br/>    name<br/>    createdAt<br/>    updatedAt<br/>  }<br/>  publisher {<br/>    authors {<br/>      id<br/>    }<br/>  }<br/>  books {<br/>    author {<br/>      id<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="1396" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，看看我们是如何请求不同地方的作者的。也就是说，即使我们在<code class="fe nb nc nd mr b">authors</code>解析器上复制查询，它也将有助于为同一请求上的其他查询填充缓存。</p><p id="33ab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能会说，使用加载器比只返回结果更有效的情况不太可能出现。你完全正确。就我个人而言，我不喜欢在主查询中使用加载器，我会直接返回<code class="fe nb nc nd mr b">Author.find()</code>，但是如果查询中更深层次的内容到达了我们已经获取的作者，它会再次从数据库中请求它，然后，即使我们在开始时保存了副本，它也会再次发生。</p><p id="f962" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你也可以说我们可以只返回<code class="fe nb nc nd mr b">loaders.author.many()</code>，但是因为我们没有键，这不会得到预期的结果，而且，这也剥夺了我们向<code class="fe nb nc nd mr b">.find()</code>函数传递参数以创建更详细和有用的查询定义的机会。</p><p id="4a92" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我建议您分析哪一个更好，这样您就可以决定是否使用这个级别的加载器，但是，出于本指南的目的，我将保留它们，只要向我保证您意识到了这个问题，并且您也可以在您的项目中管理它。</p><p id="3827" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只是尝试复制不太可能的查询</p><p id="6f35" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们来看看突变:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5a3e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，对于字段:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0168" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我告诉你的，我会让你填充剩余的实体，但你可以随时检查回购来复制我们在这里所做的。</p><p id="5633" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果你去操场，再次运行你的深度查询，你会看到时间上的轻微改善</p><pre class="la lb lc ld gt mq mr ms mt aw mu bi"><span id="a254" class="mv ln in mr b gy mw mx l my mz">query authors {<br/>  authors {<br/>    id<br/>    publishers {<br/>      id<br/>      authors {<br/>        id<br/>        publishers {<br/>          authors {<br/>            id<br/>            publishers {<br/>              id<br/>              authors {<br/>                id<br/>                publishers {<br/>                  id<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="d4d4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为查询没有像以前那样激增。唯一的问题是我们无法在我们的领域中优化<code class="fe nb nc nd mr b">WorksAt.find</code>，这是因为它是一个弱关系，我们不知道它的键。</p><p id="1485" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用mongo可以通过将这个实体保存在作者的模式中的一个数组中来改进这一点，但是这不可能在每个数据库中都实现，所以我决定不深入研究这个问题。但是，您总是可以尝试找到一种方法，将关系的键保存在您的作者模型中的某个位置，这样您就可以使用特殊的加载器或其他工具来优化该查询。</p><p id="c577" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数据加载器真正出彩的地方是，当你有数千条记录和一个非常深入的查询时，可能会有一些重复，正如我们之前谈到的，但关键是要获得可伸缩性，如果你愿意，加载器允许你的GraphQL查询很好地伸缩。</p><p id="6adb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，如果您需要对查询的执行深度设置限制，我建议您查看<a class="ae ky" href="https://www.npmjs.com/package/graphql-depth-limit" rel="noopener ugc nofollow" target="_blank">graph QL-depth-李米</a> t</p><p id="f0d8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经优化了获取数据的方式，让我们添加另一个优化来避免我们的查询随着数据库的增长而增长:分页。</p><h1 id="a15c" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">页码</h1><p id="0f51" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">如果您的数据库开始增长，您可能会面临这样的问题:单个查询会返回数据库中的每一条记录，导致您的前端应用程序变慢，并且您的用户会抱怨。</p><p id="9efa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分页非常好，因为对于相同的查询执行，它将保持我们的执行时间相对固定，因此我们可以为客户端提供可靠的响应时间，并且，我们可以利用它来限制某些深度级别上可能发生的查询爆炸。</p><p id="9aa2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有许多方法可以对查询进行分页，甚至官方的apollo文档也建议您以某种方式进行分页，无论是偏移分页还是游标分页，但是让我向您展示我个人的分页方法，以及它如何为您的客户提供额外的有用信息。</p><p id="d015" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当你在一个网站上分页时，你通常需要关于你的数据的额外信息，比如页数，项目总数，以及是否有额外的页面。这是我们的起点。</p><p id="818c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将在GraphQL模式的<code class="fe nb nc nd mr b">common.graphql</code>文件中定义两个新类型，因为它们用于每个实体。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d5c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类型<code class="fe nb nc nd mr b">Info</code>保存了我们需要的关于分页的信息，它是在我们将<code class="fe nb nc nd mr b">QueryParams</code>作为参数传递给我们的查询之后生成的，它将被附加到我们在查询定义上进行的每个常规查询，例如下面形式的<code class="fe nb nc nd mr b">books</code>或<code class="fe nb nc nd mr b">authors</code>:</p><pre class="la lb lc ld gt mq mr ms mt aw mu bi"><span id="ea65" class="mv ln in mr b gy mw mx l my mz">type Authors {<br/>  info: Info!<br/>  results: [Author]!<br/>}</span><span id="961e" class="mv ln in mr b gy nl mx l my mz">...</span><span id="a6e7" class="mv ln in mr b gy nl mx l my mz">type Query {<br/>  authors(params: QueryParams): Authors!<br/>  ...<br/>}</span></pre><p id="d408" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你知道我要去哪里吗？</p><p id="4538" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们重新配置我们的graphql文件来保存我们的新类型以及我们的<code class="fe nb nc nd mr b">index.graphql</code>来使用它们作为返回值:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">We add Authors type</figcaption></figure><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">We add Books type</figcaption></figure><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">We add Publishers type</figcaption></figure><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Adapt every plural query</figcaption></figure><p id="f589" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一步是调整我们的查询解析器以正确处理这种分页，因此，我将再次向您展示如何在author查询中做到这一点，并让您尝试在剩下的查询中做到这一点，但是，与往常一样，您可以使用解决方案检查repo。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e0bf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里没有什么可谈的，让我们逐一讨论:</p><ol class=""><li id="ea13" class="nm nn in ke b kf kg ki kj kl no kp np kt nq kx nr ns nt nu bi translated">为什么我们同时返回信息和结果的函数？如果你还记得的话，我们讨论过graphql如何解析一个字段，它在发送之前检查返回值是否可序列化，如果不可序列化，它将只在客户端请求时执行它:这是关键。您应该能够只请求计数而不获取整个列表，或者返回分页的结果而不计算数据库中的总数。</li><li id="1a94" class="nm nn in ke b kf nv ki nw kl nx kp ny kt nz kx nr ns nt nu bi translated"><strong class="ke io">为什么我们要为参数定义默认值？</strong>这是因为查询参数并不是获取结果所必需的，我们只是提供了一个默认的第1页，其中有20个标准结果。如果你愿意，你可以移动它。</li><li id="c668" class="nm nn in ke b kf nv ki nw kl nx kp ny kt nz kx nr ns nt nu bi translated"><strong class="ke io">如果我们在每个解析器上计算页数和总计数，有另一个实用函数不是更好吗？</strong>没错，我通常在graphql中用@指令来做这个。你可以以后再尝试，但我认为这是这个系列的基本内容。</li></ol><p id="21b7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦您填充了模式的每个复数解析器，您将拥有一个分页和优化的模式，公开您数据库中的数据，并且您已经准备好用它构建一些前端。</p><p id="38d0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了知道一切都已正确设置，请到您的操场运行以下查询:</p><pre class="la lb lc ld gt mq mr ms mt aw mu bi"><span id="ca40" class="mv ln in mr b gy mw mx l my mz">query {<br/>  authors(params: { page: 1, pageSize: 2 }) {<br/>    info {<br/>      count<br/>      next<br/>      prev<br/>      pages<br/>    }<br/>    results {<br/>      id<br/>    }<br/>  }<br/>  books(params: { page: 2, pageSize: 4 }) {<br/>    info {<br/>      count<br/>      next<br/>      prev<br/>      pages<br/>    }<br/>    results {<br/>      id<br/>    }<br/>  }<br/>  publishers(params: { page: 1, pageSize: 1 }) {<br/>    info {<br/>      count<br/>      next<br/>      prev<br/>      pages<br/>    }<br/>    results {<br/>      id<br/>    }<br/>  }<br/>}</span></pre><p id="41a7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以用不同的查询参数在任何深度开始使用它。</p><h1 id="2836" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">包裹</h1><p id="c9a5" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">在本系列的第3部分中，我们:</p><ul class=""><li id="3683" class="nm nn in ke b kf kg ki kj kl no kp np kt nq kx oa ns nt nu bi translated">了解graphql深度查询</li><li id="6337" class="nm nn in ke b kf nv ki nw kl nx kp ny kt nz kx oa ns nt nu bi translated">实现了数据加载器来优化我们的查询在处理复杂关系时的伸缩方式</li><li id="0d84" class="nm nn in ke b kf nv ki nw kl nx kp ny kt nz kx oa ns nt nu bi translated">用这些数据加载器填充我们的GraphQL上下文来提供数据</li><li id="63d4" class="nm nn in ke b kf nv ki nw kl nx kp ny kt nz kx oa ns nt nu bi translated">在我们的查询第一层讨论了查询重复的困境</li><li id="066e" class="nm nn in ke b kf nv ki nw kl nx kp ny kt nz kx oa ns nt nu bi translated">向我们的模式添加了一个分页方法</li><li id="e405" class="nm nn in ke b kf nv ki nw kl nx kp ny kt nz kx oa ns nt nu bi translated">实现了缺省分页，以避免意外的大查询</li></ul><p id="a0e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，在这一点上的一切都可以咨询和审查到我的整个系列的公开回购中，<a class="ae ky" href="https://github.com/ernestognw/graphql-backend/tree/part-3" rel="noopener ugc nofollow" target="_blank">你可以在这里找到</a>。</p><p id="d61d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">——埃内斯托G. <br/>在IG上关注我:<a class="ae ky" href="https://www.instagram.com/ernestognw/" rel="noopener ugc nofollow" target="_blank"> @ernestognw </a></p></div></div>    
</body>
</html>