<html>
<head>
<title>GraphQL Code Generator with TypeScript and GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有TypeScript和GraphQL的代码生成器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-graphql-code-generator-to-create-a-great-developer-experience-with-typescript-and-graphql-30e30261b75?source=collection_archive---------3-----------------------#2021-03-14">https://javascript.plainenglish.io/using-graphql-code-generator-to-create-a-great-developer-experience-with-typescript-and-graphql-30e30261b75?source=collection_archive---------3-----------------------#2021-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ccd5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用GraphQL代码生成器创建出色的TypeScript和GraphQL开发人员体验</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/115a8d64c41a3adfccaaf79c763af076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAqIy4oyldivwUNa9I6Jxw.png"/></div></div></figure><p id="7a09" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你和我一样，你最近几乎都是用TypeScript写代码，偶尔打开一个. js文件会让你有点惊慌。您可能还会花时间构建REST APIs和GraphQL层来与前端应用程序通信。起初，TypeScript和GraphQL似乎是天作之合；它们都是类型化的，所以它们应该可以很好地合作。</p><p id="86ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，当您有两个不同类型的系统，或者关于您的数据应该如何的两个真实来源时(在您甚至包括一个数据库之前)，在构建特性时不可避免地会有挫折，并且当您发布那些特性时会有错误。这一直是我的经验，直到我遇到一个项目，每当我改变我的GraphQL模式时，GraphQL代码生成器就会神奇地为我创建TS类型。我不太喜欢在不了解底层工具的情况下使用magic，所以我想重新创建一个最小的例子来做同样的事情，希望其他人也能发现这很有用！</p><p id="f723" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们将:</p><ul class=""><li id="337e" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">从头开始创建TypeScript项目</li><li id="d2bf" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">添加一个非常简单的GraphQL服务器</li><li id="51e0" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">添加GraphQL代码生成器，以无缝方式将它们集成在一起</li></ul><p id="3aa5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果整件事是TL；博士，你可以在这里找到最终代码<a class="ae ly" href="https://github.com/Djangofs/graphql-ts-codegen" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="b3f8" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">设置类型脚本</h1><p id="c3e7" class="pw-post-body-paragraph ko kp in kq b kr my jo kt ku mz jr kw kx na kz la lb nb ld le lf nc lh li lj ig bi translated"><em class="nd">在本节结束时，您的项目应该类似于</em> <a class="ae ly" href="https://github.com/Djangofs/graphql-ts-codegen/commit/5f60f3a821c91e8f60dec9f5c01b9a4fd3bdace0" rel="noopener ugc nofollow" target="_blank"> <em class="nd">这个</em> </a> <em class="nd">。</em></p><p id="924d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我假设如果你正在阅读这篇文章，你已经在你的机器上安装了Node、npm和Yarn，并且对它们的使用相当熟悉。</p><p id="25f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我们要创建一个空的npm项目(默认选项都可以):</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="3a10" class="nj mh in nf b gy nk nl l nm nn">mkdir my_project &amp;&amp; cd my_project &amp;&amp; npm init</span></pre><p id="9313" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，我们要将typescript添加到项目的<code class="fe no np nq nf b">devDependencies</code>中。这是因为我们使用TypeScript将我们的代码转换成Javascript，我们不需要在我们的产品构建中运行它。在这里，我们还要添加ts-node和nodemon，稍后我们将看到如何使用它们。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="ce45" class="nj mh in nf b gy nk nl l nm nn">yarn add -D typescript ts-node nodemon</span></pre><p id="d1ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在你想初始化你的TypeScript项目。这将创建一个默认的<code class="fe no np nq nf b">tsconfig.json</code>文件。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="28e1" class="nj mh in nf b gy nk nl l nm nn">npx tsc --init</span></pre><p id="f45f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看看默认情况下没有启用的选项。设置<code class="fe no np nq nf b">"outDir": "dist"</code>和<code class="fe no np nq nf b">"sourceMap": true</code>。这将把你的编译后的代码发送到一个<code class="fe no np nq nf b">dist</code>目录，你不应该把它提交给Git，这样在出错时可以更容易地调试。</p><p id="150c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们已经设置了TS，让我们在<code class="fe no np nq nf b">src</code>文件夹中添加一个<code class="fe no np nq nf b">index.ts</code>文件，并向其中添加以下代码。这是一个非常简单的Hello World TS项目:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="50a7" class="nj mh in nf b gy nk nl l nm nn">const world = "world";</span><span id="2545" class="nj mh in nf b gy nr nl l nm nn">export function hello(word: string): void {<br/>    console.log(`Hello ${word}! `);<br/>}</span><span id="893b" class="nj mh in nf b gy nr nl l nm nn">hello(world);</span></pre><p id="bf06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您现在可以运行<code class="fe no np nq nf b">npx tsc</code>来传输代码，运行<code class="fe no np nq nf b">node dist/index.js</code>来运行代码，您应该会在控制台上看到输出。虽然这是可行的，但每次修改代码时都必须这样做是很烦人的。相反，我们可以使用<code class="fe no np nq nf b">ts-node</code>同时传输和执行我们的代码。简单地运行<code class="fe no np nq nf b">ts-node src/index.ts</code>，你的TS代码将在一个命令中被编译和执行。重要的是要注意，这是一个优化，只有在你的机器上快速迭代和运行代码的时候才有意义。任何生产应用程序都不应使用ts-node执行。</p><p id="e360" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还可以做得更好。每次我们保存文件时都必须运行这个命令有点痛苦。相反，创建一个<code class="fe no np nq nf b">nodemon.json</code>文件，并包含以下内容:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="adfe" class="nj mh in nf b gy nk nl l nm nn">{<br/>  "watch": ["src"],<br/>  "ext": "ts",<br/>  "exec": "ts-node ./src/index.ts"<br/>}</span></pre><p id="6794" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将删除<code class="fe no np nq nf b">src</code>文件夹中扩展名为<code class="fe no np nq nf b">.ts</code>的所有文件，并在其中一个文件发生变化时执行<code class="fe no np nq nf b">ts-node</code>命令。</p><p id="1337" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，为了运行这个<code class="fe no np nq nf b">nodemon</code>文件，让我们在<code class="fe no np nq nf b">package.json</code>文件中添加一个npm脚本:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="dfee" class="nj mh in nf b gy nk nl l nm nn">"scripts": {<br/>  "start": "nodemon",<br/>}</span></pre><p id="1ca4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以用<code class="fe no np nq nf b">yarn start</code>来执行它，然后更改index.ts文件，并立即看到我们的更改被执行🚀</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="0e17" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">添加GraphQL服务器</h1><p id="2822" class="pw-post-body-paragraph ko kp in kq b kr my jo kt ku mz jr kw kx na kz la lb nb ld le lf nc lh li lj ig bi translated">在本节结束时，你的代码应该看起来像 <a class="ae ly" href="https://github.com/Djangofs/graphql-ts-codegen/commit/9dc1797f68fbeae1a7fa0648f7acdf802f8b1659" rel="noopener ugc nofollow" target="_blank"> <em class="nd">这个</em> </a> <em class="nd">。</em></p><p id="adab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们添加我们将在本节中使用的依赖项，我们最终会看到这些依赖项:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="2f3a" class="nj mh in nf b gy nk nl l nm nn">yarn add apollo-server graphql <a class="ae ly" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/load <a class="ae ly" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/graphql-file-loader <a class="ae ly" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/schema</span></pre><p id="7a0e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，让我们在<code class="fe no np nq nf b">src/types/types.ts</code>中添加我们的第一批TS类型:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="659a" class="nj mh in nf b gy nk nl l nm nn">export interface Todo {<br/>  title: string;<br/>  description: string;<br/>}</span></pre><p id="7aa1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们向使用该类型的<code class="fe no np nq nf b">index.ts</code>文件添加一些数据(您可以从该文件中删除所有旧代码):</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="01b5" class="nj mh in nf b gy nk nl l nm nn">import { Todo } from "./types/types";</span><span id="4fd2" class="nj mh in nf b gy nr nl l nm nn"><em class="nd">const</em> todos: Todo[] = [<br/>  {<br/>    title: "Walk dog",<br/>    description: "Before 9am",<br/>  },<br/>  {<br/>    title: "Clean bathroom",<br/>    description: "",<br/>  },<br/>];</span></pre><p id="63f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们添加一个GraphQL模式(在<code class="fe no np nq nf b">src/schemas/index.graphql</code>中)，它允许我们查询待办事项:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="dc6d" class="nj mh in nf b gy nk nl l nm nn">type Todo {<br/>  title: String<br/>  description: String<br/>}</span><span id="ed0b" class="nj mh in nf b gy nr nl l nm nn">type Query {<br/>  todos: [Todo]<br/>}</span></pre><p id="2b4d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们有了一个新的文件扩展名，让我们也更新一下<code class="fe no np nq nf b">nodemon.json</code>文件的<code class="fe no np nq nf b">ext</code>部分，这将在<code class="fe no np nq nf b">.ts</code>或<code class="fe no np nq nf b">.graphql</code>文件改变时启用我们的热重载。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="e22a" class="nj mh in nf b gy nk nl l nm nn"><em class="nd">"ext"</em>: "ts,graphql"</span></pre><p id="3706" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们想使用这个模式来设置我们的GraphQL服务器。为此，首先让我们将之前安装的依赖项中所需的所有函数添加到<code class="fe no np nq nf b">index.ts</code>文件中:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="be66" class="nj mh in nf b gy nk nl l nm nn">import { loadSchemaSync } from "@graphql-tools/load";<br/>import { GraphQLFileLoader } from "@graphql-tools/graphql-file-loader";<br/>import { addResolversToSchema } from "@graphql-tools/schema";<br/>import { ApolloServer } from "apollo-server";</span></pre><p id="e1a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们使用<code class="fe no np nq nf b">loadSchemaSync</code>和<code class="fe no np nq nf b">GraphQLFileLoader</code>加载我们之前定义的GraphQL模式。这些函数让我们可以导入我们定义的所有GraphQL文件，这在TypeScript中没有常规的方法。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="8e69" class="nj mh in nf b gy nk nl l nm nn"><em class="nd">const</em> schema = loadSchemaSync("**/*.graphql", {<br/>  loaders: [new GraphQLFileLoader()],<br/>});</span></pre><p id="03c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，让我们定义一些解析器来实现该模式:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="9ec7" class="nj mh in nf b gy nk nl l nm nn"><em class="nd">const</em> resolvers = {<br/>  Query: {<br/>    todos: (): Todo[] <em class="nd">=&gt;</em> todos,<br/>  },<br/>};</span></pre><p id="0c76" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将简单地返回我们之前定义的<code class="fe no np nq nf b">todos</code>数据。</p><p id="625a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们可以使用<code class="fe no np nq nf b">addResolversToSchema</code>将解析器添加到模式中:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="6a1e" class="nj mh in nf b gy nk nl l nm nn"><em class="nd">const</em> schemaWithResolvers = addResolversToSchema({<br/>  schema,<br/>  resolvers,<br/>});</span></pre><p id="35fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们准备将这个模式提供给我们的Apollo服务器(Apollo是一个流行的Javascript graph QL实现):</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="2df0" class="nj mh in nf b gy nk nl l nm nn">const server = new ApolloServer({ schema: schemaWithResolvers });</span><span id="428d" class="nj mh in nf b gy nr nl l nm nn">server.listen().then(({ url }) =&gt; {<br/>  console.log(`🚀  Server ready at ${url}`);<br/>});</span></pre><p id="42f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当您保存<code class="fe no np nq nf b">index.ts</code>时，您应该会在控制台中看到服务器就绪日志。现在在浏览器中打开<code class="fe no np nq nf b">localhost:4000</code>，您可以在GraphQL playground中尝试这个查询:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/5208ef567153fe36f3acce1024366a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuRZsRckhgn2jZNfxkwWew.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Getting Todos data back using GraphQL</figcaption></figure><p id="f041" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此时，我们有了一个GraphQL服务器，为我们的GraphQL和TypeScript文件进行热重载，一个GraphQL模式和一些TS类型，以及一些要响应的数据。</p><p id="42ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，这有一个相当明显的问题。当我们的数据模型不可避免地改变时，我们必须更新TS类型和GraphQL模式。在这个简单的例子中，这是微不足道的，但是在任何超出这个范围的情况下都会出错。这也很无聊，不能很好地利用工程师的时间，而工程师的时间是非常宝贵的！当你发布这段代码时，这也是一个非常常见的错误来源。</p><p id="9281" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了解决这个问题，我们可以利用<a class="ae ly" href="https://graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="9c4c" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">添加GraphQL代码生成器</h1><p id="7de9" class="pw-post-body-paragraph ko kp in kq b kr my jo kt ku mz jr kw kx na kz la lb nb ld le lf nc lh li lj ig bi translated"><em class="nd">在这一节的最后，你的代码应该看起来像</em> <a class="ae ly" href="https://github.com/Djangofs/graphql-ts-codegen/commit/8784a596e12c1153f11d1a39395ce548e81c30f5" rel="noopener ugc nofollow" target="_blank"> <em class="nd">这个</em> </a> <em class="nd">。</em></p><p id="a47e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样，让我们从添加我们将使用的依赖项开始:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="6d8d" class="nj mh in nf b gy nk nl l nm nn">yarn add <a class="ae ly" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/cli <a class="ae ly" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript <a class="ae ly" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript-resolvers</span></pre><p id="780a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">并创建一个包含以下内容的<code class="fe no np nq nf b">codegen.yaml</code>文件:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="db80" class="nj mh in nf b gy nk nl l nm nn">overwrite: true<br/>schema: src/schemas/**/*.graphql<br/>documents: null<br/>generates:<br/>  src/types/types.d.ts:<br/>    plugins:<br/>      - "typescript"<br/>      - "typescript-resolvers"</span></pre><p id="dbe8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将获取<code class="fe no np nq nf b">src/schemas</code>中的所有<code class="fe no np nq nf b">.graphql</code>文件，并在<code class="fe no np nq nf b">src/types/types.d.ts</code>中生成TypeScript类型。</p><p id="96f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了执行此操作，让我们添加另一个npm脚本:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="580e" class="nj mh in nf b gy nk nl l nm nn"><em class="nd">"generate"</em>: "graphql-codegen"</span></pre><p id="5fcb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">并用<code class="fe no np nq nf b">yarn generate</code>运行。一旦完成，您就可以看到您生成的文件了！现在我们有了这个，我们可以删除旧文件<code class="fe no np nq nf b">src/types.types.ts</code>。</p><p id="32ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这一点上，没有什么真正改变，我们的代码仍然运行相同。让我们通过更新<code class="fe no np nq nf b">nodemon.json</code>中的<code class="fe no np nq nf b">exec</code>部分，确保每次修改代码时都运行这个生成命令:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="b786" class="nj mh in nf b gy nk nl l nm nn"><em class="nd">"exec"</em>: "yarn generate &amp;&amp; ts-node ./src/index.ts"</span></pre><p id="8838" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当您在<code class="fe no np nq nf b">index.graphql</code>的<code class="fe no np nq nf b">Todo</code>类型中添加一个<code class="fe no np nq nf b">id</code>字段时:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="3595" class="nj mh in nf b gy nk nl l nm nn">type Todo {<br/>  title: String<br/>  description: String<br/>  id: Int<br/>}</span></pre><p id="4c7f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您应该会看到一些错误，因为我们的数据中没有定义<code class="fe no np nq nf b">id</code>字段…但是我们没有？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/0624e03323c93091312997805706a76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*LhZ9JAbLGnukH3vfSQ99kA.png"/></div></div></figure><p id="2116" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们看一下<code class="fe no np nq nf b">Todo</code>类型，我们可以看到所有的字段都是可选的，并且接受未定义的。这不是我们想要的，因为该数据模型要求所有数据始终存在，所以让我们更新GraphQL模式以反映这一点:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="7538" class="nj mh in nf b gy nk nl l nm nn">type Todo {<br/>  title: String!<br/>  description: String!<br/>  id: Int!<br/>}</span></pre><p id="25dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当我们保存文件并重新加载服务器时，它崩溃了，我们可以在编辑器中清楚地看到错误:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/e6278fca0822f77a0397546969ccd85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9tTSdVy6_zKu0dSW7Mc7w.png"/></div></div></figure><p id="c2e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以通过向Todos数据对象添加id来修复这个错误，此时我们的服务器将重新启动，我们现在可以查询<code class="fe no np nq nf b">id</code>数据。🎉</p><p id="9d28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们处在一个可爱的地方，我们的TS类型完全从我们的GraphQL模式生成，每次模式改变时，类型都会重新生成。这极大地简化了开发人员的体验，加快了反馈循环，甚至在我们的代码被编译之前就捕捉到了错误，更不用说测试或部署了。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="25ca" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">更进一步</h1><p id="76dc" class="pw-post-body-paragraph ko kp in kq b kr my jo kt ku mz jr kw kx na kz la lb nb ld le lf nc lh li lj ig bi translated">如果您想继续从事这项工作，您可以添加一些使用参数的GraphQL变体，并查看代码生成器如何为参数和响应对象创建类型。如果你想变得更好，你也可以尝试将这种方法与数据库类型的系统相结合，以实现完全的数据模型同步💆‍♂.</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><p id="8c0e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢一路读到最后！如果你想听我更多的漫谈，你可以在<a class="ae ly" href="https://twitter.com/DjangoFS" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ly" href="https://www.linkedin.com/in/django-shelton-99a07aa0/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ly" href="https://github.com/Djangofs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我。</p></div></div>    
</body>
</html>