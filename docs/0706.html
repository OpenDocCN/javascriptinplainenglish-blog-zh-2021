<html>
<head>
<title>How well do you know “this” in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你对JavaScript中的“this”了解多少？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-well-do-you-know-this-ce4355bc9b?source=collection_archive---------6-----------------------#2021-02-13">https://javascript.plainenglish.io/how-well-do-you-know-this-ce4355bc9b?source=collection_archive---------6-----------------------#2021-02-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/19475928db5c7c1c75e52736329fa84e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mGTOF628X19KtShc.png"/></div></div></figure><h1 id="daf8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">“这个”是什么？</h1><p id="cace" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">用最简单的术语来说，JavaScript关键字<code class="fe lr ls lt lu b">this</code>指的是它在运行时所属的对象，这取决于它的<strong class="kv io">调用点</strong>(它被调用的地方)。</p><p id="286c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">然而，要理解它在任何给定的上下文中所指的内容，需要对一些相关概念有稍微深入的理解，这将在本文中涉及。</p><p id="882f" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">首先，<code class="fe lr ls lt lu b">this</code>可以有以下值，这取决于它被访问的位置:</p><ul class=""><li id="735d" class="ma mb in kv b kw lv la lw le mc li md lm me lq mf mg mh mi bi translated"><strong class="kv io"> <em class="mj">默认为</em> </strong> : <code class="fe lr ls lt lu b">this</code>指全局对象。</li><li id="5392" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq mf mg mh mi bi translated"><strong class="kv io"> <em class="mj">在一个函数里面</em> </strong> : <code class="fe lr ls lt lu b">this</code>是指全局对象。然而在严格模式下，<code class="fe lr ls lt lu b">this</code>将会是<code class="fe lr ls lt lu b">undefined</code>。</li><li id="34e3" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq mf mg mh mi bi translated"><strong class="kv io"> <em class="mj">里面有一个方法</em> </strong> : <code class="fe lr ls lt lu b">this</code>指的是拥有者对象。(方法是属于对象内部的函数。换句话说，它是一个函数，是一个对象的属性。)</li><li id="7f1b" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq mf mg mh mi bi translated"><strong class="kv io"> <em class="mj">事件中的</em> </strong> : <code class="fe lr ls lt lu b">this</code>是指事件被触发的元素。</li><li id="4d55" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq mf mg mh mi bi translated"><strong class="kv io"> <em class="mj">内部一个立即被调用的函数表达式(life)</em></strong>:<code class="fe lr ls lt lu b">this</code>指全局对象。在严格模式下，<code class="fe lr ls lt lu b">this</code>将是<code class="fe lr ls lt lu b">undefined</code>，就像全局上下文中的任何其他函数一样。</li><li id="f62a" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq mf mg mh mi bi translated"><strong class="kv io"> <em class="mj">在胖箭头函数</em> </strong>内:当胖箭头<code class="fe lr ls lt lu b">()=&gt;</code>用于定义一个函数时，它不会为<code class="fe lr ls lt lu b">this</code>创建一个新值，相反，它会一直引用它在函数外引用的同一个对象。</li></ul><p id="d20c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">本文希望让您了解这些值是如何分配给<code class="fe lr ls lt lu b">this</code>的，以及如何利用这些知识来满足我们的需求。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="a96e" class="jv jw in bd jx jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks bi translated"><strong class="ak">调用点和调用栈</strong></h1><p id="d055" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">正如上一节所讨论的，我们知道了<code class="fe lr ls lt lu b">this</code>是为每个函数调用制作的<strong class="kv io"><em class="mj"/></strong>运行时绑定，这完全取决于它被调用的确切位置。</p><p id="af4f" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">代码中调用相关函数的位置称为<strong class="kv io">调用点</strong>。理解确定<strong class="kv io">调用点<em class="mj"> </em> </strong>对于理解<code class="fe lr ls lt lu b">this</code>在任何给定的执行点将被绑定到什么是至关重要的。</p><p id="2a09" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">虽然找到<strong class="kv io"> <em class="mj">调用点</em> </strong>通常就像定位函数被调用的位置一样简单，但由于某些编码模式可能会使其模糊不清，所以可能并不总是那么清楚。</p><p id="10cc" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">因此，考虑<strong class="kv io"> <em class="mj">调用栈</em> </strong>是很重要的，它是被调用来让我们进入我们所关心的当前执行阶段的函数栈。</p><p id="2989" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">让我们举一个简单的例子来说明如何确定<strong class="kv io"> <em class="mj">调用栈</em> </strong>和<strong class="kv io"> <em class="mj">调用点</em> </strong>。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">1. Call-sites and Call-stacks</figcaption></figure><p id="b3fa" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">通过按顺序跟踪函数调用链，您可以确定<strong class="kv io">调用栈和调用点。</strong></p><h2 id="d9eb" class="nl jw in bd jx nm nn dn kb no np dp kf le nq nr kj li ns nt kn lm nu nv kr nw bi translated"><strong class="ak"> *确定调用堆栈的提示</strong></h2><p id="82f5" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">利用任何现代浏览器开发工具提供的内置JS调试器。</p><p id="f25c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">在任何JS代码的执行中，都可以使用关键字<strong class="kv io"> <em class="mj">调试器</em> </strong> <em class="mj">，</em>设置断点，在浏览器中停止该点的执行。</p><p id="c21f" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">比方说，我们在调用<code class="fe lr ls lt lu b">thunderbolt()</code>时添加了一个断点。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/e0f03297a87d691ed4b489ba870b0956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ajrjhWdWgzo3xfRA2yBLA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The <strong class="bd ny">debugger</strong> stops the execution at the custom breakpoint, and the function <strong class="bd ny">call-stack</strong> at that point can be viewed on the right side.</figcaption></figure><p id="1898" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">在上图中，我们可以看到，在我们提到<strong class="kv io">调试器</strong>关键字的地方，一调用<code class="fe lr ls lt lu b">thunderbolt()</code> <strong class="kv io"> </strong>就停止了执行。在这一点上，我们不会观察到任何在<strong class="kv io">调试器</strong>之后的代码的执行(在这种情况下，只有<code class="fe lr ls lt lu b">thunderbolt()</code> <em class="mj">日志</em>)。</p><p id="95b4" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">我们现在最感兴趣的是<strong class="kv io">调用栈</strong>，它清晰地显示在右边，和我们在上面的例子中确定的一样。<code class="fe lr ls lt lu b">(anonymous)</code> <em class="mj"> </em>在栈底，指初始全局调用到<code class="fe lr ls lt lu b">choosePikachu()</code> <em class="mj">。</em></p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="0ce2" class="jv jw in bd jx jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks bi translated"><strong class="ak">绑定规则为</strong></h1><p id="06c9" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">现在我们已经了解了什么是<strong class="kv io">调用点</strong>和<strong class="kv io">调用栈</strong>，我们可以了解<strong class="kv io">调用点</strong>如何决定在执行期间<code class="fe lr ls lt lu b">this</code>将持有什么。</p><p id="e91c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">有四个通用规则适用。首先，让我们独立地理解它们<em class="mj"/>，然后，当多个规则可以应用于<strong class="kv io">调用点</strong>时，它们的<em class="mj">优先顺序</em>。</p><h1 id="1b18" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">1.默认绑定</h1><p id="ee55" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">当没有其他规则适用时，这是默认的总括规则。它来自最常见的函数调用，即独立的函数调用。</p><p id="05ac" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">让我们看看下面的例子。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">2. Default Binding</figcaption></figure><p id="8ec5" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">在全局作用域中声明的变量<code class="fe lr ls lt lu b">ultraBall</code>与在同名的全局对象上声明的属性相同。</p><p id="994c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">在<code class="fe lr ls lt lu b">getPokemon()</code>内部，对<code class="fe lr ls lt lu b">this</code>的引用默认为全局对象。因此，我们将看到<code class="fe lr ls lt lu b">this.ultraBall</code>的值被记录。</p><p id="6222" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">但是，如果<code class="fe lr ls lt lu b">strict</code>模式在全局有效或者在<code class="fe lr ls lt lu b">getPokemon</code>内部有效，则全局对象不允许默认绑定。在这种情况下，我们将看到错误<code class="fe lr ls lt lu b">TypeError : 'this' is 'undefined'</code>。</p><h1 id="6fd4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">2.隐式结合</h1><p id="60c8" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果调用点有一个上下文对象(如果一个函数通过一个拥有或包含的对象调用，作为它的属性)，隐式绑定适用。</p><p id="0c21" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">该规则规定，当函数引用有一个上下文对象时，对象应该用于其方法调用的<code class="fe lr ls lt lu b">this</code>绑定。</p><p id="87e9" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">让我们看几个例子来说明可能出现的不同情况。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">3. Simple Implicit Binding</figcaption></figure><p id="875a" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">因为对象<code class="fe lr ls lt lu b">pikachu</code>是<code class="fe lr ls lt lu b">getBaseSpeed</code>调用的<code class="fe lr ls lt lu b">this</code>，所以<code class="fe lr ls lt lu b">this.baseSpeed</code>与<code class="fe lr ls lt lu b">pikachu.baseSpeed</code>同义。</p><p id="b298" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">让我们看另一个例子，看看只有对象属性引用链的顶层或最后一层对隐式<code class="fe lr ls lt lu b">this</code>绑定的调用点有什么影响。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">4. Object chain in Implicit Binding</figcaption></figure><p id="db75" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">我们可以看到，<code class="fe lr ls lt lu b">baseSpeed</code>的值仍然是<code class="fe lr ls lt lu b">90</code>。这是因为对<code class="fe lr ls lt lu b">getBaseSpeed</code>的调用被绑定到它的直接调用者<code class="fe lr ls lt lu b">pikachu</code>，这充当了它的<code class="fe lr ls lt lu b">this</code>绑定。在这种情况下，<code class="fe lr ls lt lu b">baseSpeed</code>值为<code class="fe lr ls lt lu b">90</code>。</p><p id="765d" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">让我们再看几个例子，展示隐式绑定看起来出乎意料的常见情况。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">5. Lost Implicit “this” binding</figcaption></figure><p id="3f6d" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">在这个例子中，如果将<code class="fe lr ls lt lu b">pikachu.getBaseSpeed</code>赋给一个不同的变量<code class="fe lr ls lt lu b">baseSpeedFunction</code>，我们就失去了与<code class="fe lr ls lt lu b">pikachu</code>的隐式<code class="fe lr ls lt lu b">this</code>绑定。现在，对于<code class="fe lr ls lt lu b">baseSpeedFunction</code>，<code class="fe lr ls lt lu b">this</code>指的是全局对象(<em class="mj">默认绑定</em>发生)。因此，对于该调用，<code class="fe lr ls lt lu b">this.baseSpeed</code>将是<code class="fe lr ls lt lu b">50</code>。</p><p id="8218" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">现在，隐式绑定丢失的一个更常见但不太明显的方式是当我们传递回调函数时。考虑下面的例子:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">6. Lost Implicit “this” binding, another case.</figcaption></figure><p id="f34c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">同样，在回调函数执行器<code class="fe lr ls lt lu b">executeFunction</code>内部，我们有效地传递了对<code class="fe lr ls lt lu b">pikachu.getBaseSpeed</code>函数的引用。执行后，<code class="fe lr ls lt lu b">this</code>将再次绑定到全局对象(或者抛出一个<code class="fe lr ls lt lu b">TypeError</code>，如果<code class="fe lr ls lt lu b">strict</code>模式被启用)，而不是<code class="fe lr ls lt lu b">pikachu</code>。</p><p id="4db7" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">函数回调失去它们的<code class="fe lr ls lt lu b">this</code>绑定是很常见的。当我们将回调传递给的函数有意改变调用的<code class="fe lr ls lt lu b">this</code>时，会出现另一个意想不到的结果。例如，流行的JavaScript库中的事件处理程序经常修改<code class="fe lr ls lt lu b">this</code>以指向触发事件的DOM元素。</p><p id="c809" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">您并不能真正控制回调函数引用的执行方式。到目前为止，您还没有任何方法来控制调用点来分配您想要的绑定。这就是<strong class="kv io"> <em class="mj">显式绑定</em> </strong>发挥作用的地方。</p><h1 id="a3c8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">3.显式绑定</h1><p id="792d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">为了通过隐式绑定解决<code class="fe lr ls lt lu b">this</code>的意外丢失，我们可以为函数调用将<code class="fe lr ls lt lu b">this</code>的值显式设置为给定的对象。</p><p id="5404" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">有几个内置方法可以帮助我们实现<strong class="kv io"><em class="mj"/></strong><em class="mj"/>的显式绑定，比如:</p><h2 id="0c93" class="nl jw in bd jx nm nn dn kb no np dp kf le nq nr kj li ns nt kn lm nu nv kr nw bi translated">bind()方法</h2><p id="aeb4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><code class="fe lr ls lt lu b"><strong class="kv io">bind()</strong></code>是<code class="fe lr ls lt lu b"><strong class="kv io">Function.prototype</strong></code>属性的一个方法。这意味着<code class="fe lr ls lt lu b"><strong class="kv io">bind()</strong></code>可以被每一个功能使用。</p><p id="6515" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated"><code class="fe lr ls lt lu b"><strong class="kv io">bind()</strong></code>方法创建一个新函数，当调用该函数时，它的<code class="fe lr ls lt lu b">this</code>关键字被设置为提供的值，当调用新函数时，在任何提供的参数之前有一个给定的参数序列。</p><p id="2bf0" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">换句话说，<code class="fe lr ls lt lu b"><strong class="kv io">bind()</strong></code> <strong class="kv io"> </strong>返回一个新的函数，该函数被硬编码为使用指定的<code class="fe lr ls lt lu b">this</code>上下文来调用原始函数。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">7. “this” binding with bind()</figcaption></figure><h2 id="3256" class="nl jw in bd jx nm nn dn kb no np dp kf le nq nr kj li ns nt kn lm nu nv kr nw bi translated"><strong class="ak">调用()和应用()方法</strong></h2><p id="fdf0" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><code class="fe lr ls lt lu b"><strong class="kv io">call()</strong></code>和<code class="fe lr ls lt lu b"><strong class="kv io">apply()</strong></code>也是<code class="fe lr ls lt lu b"><strong class="kv io">Function.prototype</strong></code>属性的方法，用法相似但略有不同。</p><p id="57d6" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated"><code class="fe lr ls lt lu b"><strong class="kv io">call()</strong></code>方法使用给定的<code class="fe lr ls lt lu b">this</code>值和单独提供的参数调用函数。</p><p id="b82e" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">然而，<code class="fe lr ls lt lu b"><strong class="kv io">apply()</strong></code>方法调用一个具有给定<code class="fe lr ls lt lu b">this</code>值的函数，并且<code class="fe lr ls lt lu b">arguments</code>被提供为一个数组(或者一个类似<a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects" rel="noopener ugc nofollow" target="_blank">数组的对象</a>)。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">8. “this” binding with call() or apply()</figcaption></figure><p id="adfb" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">通过<code class="fe lr ls lt lu b">Pokémon.call()</code>或<code class="fe lr ls lt lu b">Pokémon.apply()</code>显式绑定来调用<code class="fe lr ls lt lu b">Pokémon</code>允许我们强制其<code class="fe lr ls lt lu b">this</code>成为函数<code class="fe lr ls lt lu b">PokémonExtension</code>的<code class="fe lr ls lt lu b">this</code>。</p><p id="1a68" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">此外，上面例子中值得注意的一点是，<code class="fe lr ls lt lu b">PokémonExtension</code>的所有实例都将它们各自的<code class="fe lr ls lt lu b">this</code>绑定到它们内部<code class="fe lr ls lt lu b">Pokémon</code>的执行。这种显式绑定也称为<strong class="kv io">硬绑定。</strong></p><h1 id="f308" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">4.新绑定</h1><p id="b089" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在JavaScript中，真的没有“构造函数”这种东西，只有函数的构造调用。</p><p id="67df" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">当调用前面有<code class="fe lr ls lt lu b">new</code>的函数时，也称为构造函数调用，下面的事情会自动完成。</p><ol class=""><li id="4b25" class="ma mb in kv b kw lv la lw le mc li md lm me lq oa mg mh mi bi translated">一个全新的物体凭空被创造出来。</li><li id="aef3" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">新构造的对象被<code class="fe lr ls lt lu b">[[Prototype]]</code>链接。(超出了本文的范围)</li><li id="a8dc" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">新构造的对象被设置为该函数调用的<code class="fe lr ls lt lu b">this</code>绑定。</li><li id="f7e4" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">除非函数返回自己的替代对象，否则<code class="fe lr ls lt lu b">new</code>调用的函数调用将<em class="mj">自动</em>返回新构造的对象。</li></ol><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">9. Simple “this” binding in case of new</figcaption></figure></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="38aa" class="jv jw in bd jx jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks bi translated">所有生效的约束规则</h1><p id="10b4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">应该清楚的是，<em class="mj">默认绑定</em>是四个规则中优先级最低的。</p><p id="2d9b" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">让我们比较一下<em class="mj">隐式绑定、显式绑定、</em>和<em class="mj">新绑定</em>。</p><h2 id="910d" class="nl jw in bd jx nm nn dn kb no np dp kf le nq nr kj li ns nt kn lm nu nv kr nw bi translated"><strong class="ak">隐式与显式</strong></h2><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">10. Implicit versus Explicit binding</figcaption></figure><p id="edd2" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">正如我们所见，<code class="fe lr ls lt lu b">firstAttempt.catchPokémon</code>的<em class="mj">显式绑定</em>与<code class="fe lr ls lt lu b">secondAttempt</code>优先于其自身的<em class="mj">隐式绑定，</em>也是如此。</p><p id="87f7" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">因此，<em class="mj">显式绑定</em>的优先级高于<em class="mj">隐式绑定</em>。</p><h2 id="f97b" class="nl jw in bd jx nm nn dn kb no np dp kf le nq nr kj li ns nt kn lm nu nv kr nw bi translated">隐式与新</h2><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">11. Implicit versus new binding</figcaption></figure><p id="b4b5" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">所以，<em class="mj">新绑定</em>比<em class="mj">隐式绑定</em>更有先例。</p><h2 id="95b0" class="nl jw in bd jx nm nn dn kb no np dp kf le nq nr kj li ns nt kn lm nu nv kr nw bi translated">显性对新？</h2><p id="9a34" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><code class="fe lr ls lt lu b">new</code>和<code class="fe lr ls lt lu b">call</code>或者<code class="fe lr ls lt lu b">apply</code>不能一起使用，所以类似<code class="fe lr ls lt lu b">var fourthAttempt = new catchPokémon.call(firstAttempt);</code>的东西不允许直接针对<em class="mj">显式绑定</em>来测试<em class="mj">新绑定</em>。但是，我们仍然可以使用一个<em class="mj">硬绑定</em>来测试两者的优先级。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">12. Explicit versus new through hard-binding</figcaption></figure><p id="e675" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated"><code class="fe lr ls lt lu b">attemptBinder</code>硬绑反<code class="fe lr ls lt lu b">firstAttempt</code>，但是<code class="fe lr ls lt lu b">new attemptBinder(“Steelix”)</code>并没有像我们可能预料的那样，把<code class="fe lr ls lt lu b">firstAttempt.name</code>改成<code class="fe lr ls lt lu b">"Steelix"</code>，而是保持了<code class="fe lr ls lt lu b">"Onix"</code>。</p><p id="bac7" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">相反，对<code class="fe lr ls lt lu b">attemptBinder("Steelix")</code>的硬绑定调用可以被<code class="fe lr ls lt lu b">new</code>覆盖。由于应用了<code class="fe lr ls lt lu b">new</code>，我们获得了新创建的对象，我们将其命名为<code class="fe lr ls lt lu b">secondAttempt</code>，并且我们看到<code class="fe lr ls lt lu b">secondAttempt.name</code>确实具有值<code class="fe lr ls lt lu b">"Steelix"</code>。</p><p id="0e21" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">因此，新创建的<code class="fe lr ls lt lu b">this</code>被使用，而不是先前指定的<em class="mj">硬绑定</em>用于<code class="fe lr ls lt lu b">this</code>。实际上，<code class="fe lr ls lt lu b">new</code>能够覆盖<em class="mj">硬绑定</em>。</p><p id="5276" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">这种行为的主要原因是创建了一个基本上忽略了<code class="fe lr ls lt lu b">this</code> <em class="mj">硬绑定</em>的函数，并预设了该函数的部分或全部参数。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="9728" class="jv jw in bd jx jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks bi translated">最后，确定“这个”</h1><p id="9143" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们可以从函数调用的<strong class="kv io">调用点、</strong>中总结出确定<code class="fe lr ls lt lu b">this</code>的规则。</p><p id="2dcf" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">他们在这里:</p><ol class=""><li id="7425" class="ma mb in kv b kw lv la lw le mc li md lm me lq oa mg mh mi bi translated">函数是用<code class="fe lr ls lt lu b">new</code>调用的吗？如果是，<code class="fe lr ls lt lu b">this</code>就是新构造的对象<em class="mj">(新绑定)。</em>例，<code class="fe lr ls lt lu b">var attempt = new catchPokémon("Pidgey");</code></li><li id="c26f" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">函数是用<code class="fe lr ls lt lu b">call</code>还是<code class="fe lr ls lt lu b">apply</code>调用，甚至隐藏在一个<code class="fe lr ls lt lu b">bind</code> <em class="mj">硬绑定</em>里面？如果是，<code class="fe lr ls lt lu b">this</code>是显式指定的对象(<em class="mj">显式绑定)</em>。例，<code class="fe lr ls lt lu b">var attempt = catchPokémon.call("Pidgeotto");</code></li><li id="380c" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">这个函数是用一个上下文调用的吗，或者说是一个拥有或包含的对象？如果是，<code class="fe lr ls lt lu b">this</code>就是那个上下文对象(<em class="mj">隐式绑定)</em>。例，<code class="fe lr ls lt lu b">var attempt = firstAttempt.catchPokémon("Pidgeot");</code></li><li id="70fe" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">否则，<code class="fe lr ls lt lu b">this</code>默认为<code class="fe lr ls lt lu b">global</code>对象，或者<code class="fe lr ls lt lu b">strict</code>模式下的<code class="fe lr ls lt lu b">undefined</code>(<em class="mj">默认绑定)。</em></li></ol></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="e6fc" class="jv jw in bd jx jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks bi translated">摘要</h1><p id="a4b8" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">确定正在执行的函数的<code class="fe lr ls lt lu b">this</code>绑定需要找到该函数的直接<strong class="kv io">调用点</strong>。</p><p id="9436" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">一旦检查完毕，可以将四个规则应用于调用点，按照以下优先顺序。</p><ol class=""><li id="0ebb" class="ma mb in kv b kw lv la lw le mc li md lm me lq oa mg mh mi bi translated">用<code class="fe lr ls lt lu b">new</code>打电话？使用新构造的对象。</li><li id="43fd" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">用<code class="fe lr ls lt lu b">call</code>或<code class="fe lr ls lt lu b">apply</code>或<code class="fe lr ls lt lu b">bind</code>称呼？使用指定的对象。</li><li id="bced" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">用拥有调用的上下文对象调用？使用上下文对象。</li><li id="32fd" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">默认:<code class="fe lr ls lt lu b">undefined</code>在<code class="fe lr ls lt lu b">strict</code>模式，否则<code class="fe lr ls lt lu b">global</code>对象。</li></ol></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h2 id="bb43" class="nl jw in bd jx nm nn dn kb no np dp kf le nq nr kj li ns nt kn lm nu nv kr nw bi translated"><strong class="ak">学分</strong></h2><ol class=""><li id="0d84" class="ma mb in kv b kw kx la lb le ob li oc lm od lq oa mg mh mi bi translated">官方文档:<a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/this</a></li><li id="6ad4" class="ma mb in kv b kw mk la ml le mm li mn lm mo lq oa mg mh mi bi translated">你不知道JS:这和对象原型，凯尔辛普森。</li></ol></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="6047" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le lx lg lh li ly lk ll lm lz lo lp lq ig bi translated">非常感谢你的阅读！❤️ </p></div></div>    
</body>
</html>