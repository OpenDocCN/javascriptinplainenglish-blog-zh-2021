<html>
<head>
<title>Why the forEach JavaScript Method Might Not Always be the Best Choice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么forEach JavaScript方法不总是最佳选择</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-the-foreach-js-method-might-not-always-be-the-best-choice-5eeaf048c3a2?source=collection_archive---------12-----------------------#2021-04-20">https://javascript.plainenglish.io/why-the-foreach-js-method-might-not-always-be-the-best-choice-5eeaf048c3a2?source=collection_archive---------12-----------------------#2021-04-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a625" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个我发现自己多次陷入的陷阱。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0081bfe96a58b7dd1d1b7f6f2a92e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cxcfNSFVypqD_wGC"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NeONBRAND</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="02f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然当您想要在JavaScript中循环一个元素数组时，<code class="fe kz la lb lc b">Array.prototype.forEach()</code>方法看起来是一个不错的选择，但是在很多情况下，一个简单的<code class="fe kz la lb lc b">for</code>循环或另一个内置数组方法才是您所需要的。</p><p id="34f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个简单的<code class="fe kz la lb lc b">forEach</code>方法的糟糕用例的例子:</p><pre class="kj kk kl km gt ld lc le lf aw lg bi"><span id="c8a0" class="lh li in lc b gy lj lk l ll lm">let array = [1, 2, 3];</span><span id="1aea" class="lh li in lc b gy ln lk l ll lm">array.forEach(num =&gt; num += 1);</span></pre><p id="814b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">forEach</code>接受一个回调函数作为参数(<code class="fe kz la lb lc b">num =&gt; num += 1</code>)，它又有一个参数<code class="fe kz la lb lc b">num</code>。这个参数将被赋予在<code class="fe kz la lb lc b">forEach</code>的每次迭代中被迭代的元素的值。因此，给定数组<code class="fe kz la lb lc b">[1, 2, 3]</code>，数字1、2和3将在每次迭代中被分配给回调的参数<code class="fe kz la lb lc b">num</code>。</p><p id="1f5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在可以说在原始值(比如数字)的情况下，JavaScript是“按值传递”的。这意味着当我们传递数组的第一个元素时，在我们的例子中，数字<code class="fe kz la lb lc b">1</code>作为回调函数的参数，实际发生的是数字1的<em class="lo">副本</em>被赋给变量<code class="fe kz la lb lc b">num</code>。调用数组中索引<code class="fe kz la lb lc b">0</code>处的元素和回调函数中变量<code class="fe kz la lb lc b">num</code>的值完全相等；他们没有任何联系。</p><p id="13eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在回调中，我们将<code class="fe kz la lb lc b">num</code>的值重新分配给<code class="fe kz la lb lc b">num + 1</code>的结果(也就是说，我们将它的值增加1)。因此，<code class="fe kz la lb lc b">num</code>现在将等于<code class="fe kz la lb lc b">2</code>(在第一次迭代时)。然而，<em class="lo">调用数组元素的值不会受到这种重新分配的影响，</em>因为“按值传递”行为。调用数组仍将包含元素1、2和3。</p><p id="230d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个我发现自己多次陷入的陷阱，通过写下它，我不仅试图分享它，还试图让我的脑袋永远围绕着它。一个有经验的开发人员只要看一下上面的例子就会知道有什么地方出错了。这个例子，按照现在的方式，没有有用的返回值(<code class="fe kz la lb lc b">forEach</code>总是返回<code class="fe kz la lb lc b">undefined</code>)，也没有副作用；换句话说，它什么也没做。</p><p id="df56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果目标是增加数组中的每个元素，我们可以通过使用<code class="fe kz la lb lc b">Array.prototype.map()</code>方法来实现，如果我们不介意用一个新的数组来代替变异调用数组，或者用一个很好的旧的<code class="fe kz la lb lc b">for</code>循环来变异原始数组，就像这样:</p><pre class="kj kk kl km gt ld lc le lf aw lg bi"><span id="fd29" class="lh li in lc b gy lj lk l ll lm">for (let i = 0; i &lt; array.length; i++) {</span><span id="be65" class="lh li in lc b gy ln lk l ll lm"> array[i] += 1;</span><span id="2186" class="lh li in lc b gy ln lk l ll lm">}</span></pre><p id="3c0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">长话短说，例如，您不能像使用<code class="fe kz la lb lc b">map</code>那样使用<code class="fe kz la lb lc b">forEach</code>循环来更改数组元素的值。如果这是你的目标，最简单的方法就是去做一个<code class="fe kz la lb lc b">for</code>环。但是，请注意，如果数组的元素本身是对象，那么<em class="lo">可以</em>改变它们。</p><p id="8cc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编辑:然而，这个问题有一个不太常见的解决方法，使用分配给调用数组的第三个参数<code class="fe kz la lb lc b">forEach</code>，如下所示:</p><pre class="kj kk kl km gt ld lc le lf aw lg bi"><span id="8d13" class="lh li in lc b gy lj lk l ll lm">array.forEach((_, index, arr) =&gt; arr[index] += 1);</span></pre></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="2a8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其他一些不适合使用<code class="fe kz la lb lc b">forEach</code>循环的情况是，在满足某个条件后，您打算退出循环机制，或者当您想在循环过程中改变调用数组时。在第一种情况下，<code class="fe kz la lb lc b">forEach</code>根本不会工作，因为没有办法退出它；在后一种情况下，如果突变影响了调用数组的长度属性，您可能会得到意想不到的结果。</p><p id="d27a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:</p><pre class="kj kk kl km gt ld lc le lf aw lg bi"><span id="1e1b" class="lh li in lc b gy lj lk l ll lm">let nums = [1, 2, 5, 7, 6];</span><span id="2a63" class="lh li in lc b gy ln lk l ll lm">nums.forEach((num, index) =&gt; {<br/>  if (num % 2 === 1) {<br/>    nums.splice(index, 1);<br/>  }<br/>});</span><span id="a0dc" class="lh li in lc b gy ln lk l ll lm">nums; //returns [ 2, 7, 6 ]</span></pre><p id="8195" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，我们试图使用<code class="fe kz la lb lc b">Array.prototype.splice()</code>破坏性方法从<code class="fe kz la lb lc b">nums</code>数组中移除每个奇数。不过从最终返回值可以看出，<code class="fe kz la lb lc b">nums</code>还是包含了奇数<code class="fe kz la lb lc b">7</code>。这是因为当<code class="fe kz la lb lc b">forEach</code>循环遍历数组时，每个元素及其对应的索引都作为参数传递给回调函数。当一个元素被移除时，下一个元素将占用被移除元素的槽，并因此占用其索引。在<code class="fe kz la lb lc b">forEach</code>的下一次迭代中，分配给<code class="fe kz la lb lc b">index</code>的值将随着迭代进行到下一个元素而递增，忽略向后移动一个槽的元素。</p><p id="5d42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这在下面的流程图中有更好的解释:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/19d2887db1c89d139b2a4865524eda9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2A-E_fEGLHJKiZQSjJTng.png"/></div></div></figure><p id="5727" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lo">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lo">plain English . io</em></a></p></div></div>    
</body>
</html>