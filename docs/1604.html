<html>
<head>
<title>React Lazy Loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对延迟加载做出反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-guide-to-react-lazy-loading-6bca6be7159?source=collection_archive---------5-----------------------#2021-04-06">https://javascript.plainenglish.io/a-guide-to-react-lazy-loading-6bca6be7159?source=collection_archive---------5-----------------------#2021-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="455a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React组件代码拆分指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9fb9c1e6f5147ddead05dd0be5accda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KATAK7SiFyEVpaPk"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clément Hélardot</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fe9f" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="96a0" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">随着我的单页应用程序的功能越来越丰富，它的大小也越来越大。事实上，每次我构建时，Webpack都会警告我这一点。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="9595" class="mm ku in mi b gy mn mo l mp mq">WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB).<br/>This can impact web performance.<br/>Assets:<br/>  static/js/main.ff956fb8.chunk.js (1.78 MiB)</span></pre><p id="bf50" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">用户需要等待这个1.78MB的文件完全加载到浏览器中，然后才能与它进行交互。如果网络连接很慢，这种感觉就像是永远。必须做些什么来让这种最初的体验变得更快。</p><h1 id="dcb5" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">代码拆分</h1><p id="de14" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">代码分割将单个页面应用程序的代码分割成更小的块。不是全部请求，而是只请求当前需要的块。代码库分割得越多，每个块就越小，加载时间就越快。代码拆分是通过动态导入语法实现的。代替常规的导入语法，</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="e7c1" class="mm ku in mi b gy mn mo l mp mq">import func from './func'</span><span id="b2a5" class="mm ku in mi b gy mw mo l mp mq">func.doSomething()</span></pre><p id="25ff" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">动态导入返回一个承诺，该承诺将解析为导入模块的内容。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="0f45" class="mm ku in mi b gy mn mo l mp mq">import('./func').then(func =&gt; func.doSomething());</span></pre><p id="7145" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">Webpack(或其他捆绑器)将识别动态导入语法，并将<code class="fe mx my mz mi b">func</code>模块的内容放入它自己单独的代码块中。</p><h1 id="2bab" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">惰性装载</h1><p id="5e77" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">但是这不是容易消耗的。兑现承诺不是一个快速简单的改变。幸运的是，React通过其<code class="fe mx my mz mi b">lazy</code>函数使这变得简单多了。它与动态导入协同工作，为React组件启用代码拆分。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="5deb" class="mm ku in mi b gy mn mo l mp mq">import React, { lazy } from 'react';</span><span id="240e" class="mm ku in mi b gy mw mo l mp mq">const LazyLoad = lazy(() =&gt; import('./LazyLoad'));</span><span id="ffd2" class="mm ku in mi b gy mw mo l mp mq">const App = () =&gt; {<br/>  return &lt;LazyLoad /&gt;;<br/>};</span></pre><p id="87e2" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">现在，<code class="fe mx my mz mi b">App</code>和<code class="fe mx my mz mi b">LazyLoad</code>在不同的代码块中。仅当<code class="fe mx my mz mi b">App</code>被渲染时，请求被发送以获取<code class="fe mx my mz mi b">LazyLoad</code>代码块。当请求完成时，React将呈现<code class="fe mx my mz mi b">LazyLoad</code>。您可以通过查看网络检查器中的Javascript请求来验证这一点。</p><h1 id="6b55" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">焦虑</h1><p id="68fe" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">这也引入了一个问题。该组件不能立即呈现，因为它必须通过网络调用获取。这可能需要一些时间来完成。我们如何向用户展示一些东西，让他们知道有些东西正在加载，而不仅仅是坏了？</p><p id="c4cb" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">React用<code class="fe mx my mz mi b">Suspense</code>组件解决了这个问题。该组件可以检测是否有任何子代(或孙代等)被延迟加载。当它们仍被请求时，<code class="fe mx my mz mi b">Suspense</code>将转而呈现指定的<code class="fe mx my mz mi b">fallback</code>。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="9b56" class="mm ku in mi b gy mn mo l mp mq">const App = () =&gt; {<br/>  return (<br/>    &lt;Suspense fallback="Loading"&gt;<br/>      &lt;LazyLoad /&gt;<br/>    &lt;/Suspense&gt;<br/>  );<br/>};</span></pre><p id="0978" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">现在，当呈现App并发起获取<code class="fe mx my mz mi b">LazyLoad</code>代码的请求时，会呈现回退<code class="fe mx my mz mi b">Loading</code>。当这个请求完成时，React将呈现<code class="fe mx my mz mi b">LazyLoad</code>。</p><h1 id="2e4d" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">块预取</h1><p id="1484" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">为了最小化加载时间，如果您能够准确预测用户下一步需要什么，您还可以预取一些组件。例如，如果用户在登录页面上，您可以加载登录后主页。动态导入函数中带有<code class="fe mx my mz mi b">webpackPrefetch</code>键的行内注释将指示Webpack这样做。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="6c60" class="mm ku in mi b gy mn mo l mp mq">const PrefetchLoad = lazy(() =&gt;<br/>  import(<br/>    /* webpackPrefetch: true */ './PrefetchLoad'<br/>  )<br/>);<br/><br/>const App = () =&gt; {<br/>  return (<br/>    &lt;Suspense fallback="Loading"&gt;<br/>      {condition &amp;&amp; &lt;PrefetchLoad /&gt;}<br/>    &lt;/Suspense&gt;<br/>  );<br/>};</span></pre><p id="09e7" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">在这里，即使没有满足<code class="fe mx my mz mi b">condition</code>，应用程序也会抢先请求<code class="fe mx my mz mi b">PrefetchLoad</code>。当<code class="fe mx my mz mi b">condition</code>被满足时，<code class="fe mx my mz mi b">PrefetchLoad</code>将被立即渲染。</p><h1 id="6d92" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">区块名称</h1><p id="e8b0" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">默认情况下，代码分割块由创建它们的索引命名。在上面的例子中，<code class="fe mx my mz mi b">LazyLoad</code>包含在<code class="fe mx my mz mi b">0.chunk.js</code>中。如果有多个块，就很难知道哪个块对应于哪个代码。类似于<a class="ae ks" href="#2e4d" rel="noopener ugc nofollow">预取</a>，您可以使用<code class="fe mx my mz mi b">webpackChunkName</code>键指定带有行内注释的块名。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="ef69" class="mm ku in mi b gy mn mo l mp mq">const LazyLoad = lazy(() =&gt;<br/>  import(/* webpackChunkName: 'lazyload' */ './LazyLoad')<br/>);</span></pre><p id="b97f" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">现在，这个块将被称为<code class="fe mx my mz mi b">lazyload.chunk.js</code>以便于识别。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="7d7d" class="kt ku in bd kv kw nh ky kz la ni lc ld jt nj ju lf jw nk jx lh jz nl ka lj lk bi translated">结论</h1><p id="366e" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在我的应用中，在实现延迟加载后，文件大小和初始加载时间显著下降。登录页面有自己的代码块，只有5KB。此外，每个单独的路由都被分割成自己的块，常用的路由都被预取，以便在用户登录后可以立即使用。由于React惰性加载，所有这些代码拆分都是可能的。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><ul class=""><li id="4b14" class="nm nn in ln b lo mr lr ms lu no ly np mc nq mg nr ns nt nu bi translated"><a class="ae ks" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">官方反应懒惰文档</a></li><li id="a08a" class="nm nn in ln b lo nv lr nw lu nx ly ny mc nz mg nr ns nt nu bi translated"><a class="ae ks" href="https://github.com/mjchang/medium/tree/master/lazy-loading" rel="noopener ugc nofollow" target="_blank">本文Github回购</a></li><li id="65c7" class="nm nn in ln b lo nv lr nw lu nx ly ny mc nz mg nr ns nt nu bi translated"><a class="ae ks" href="https://codesandbox.io/s/github/mjchang/medium/tree/master/lazy-loading" rel="noopener ugc nofollow" target="_blank">本文的code sandbox</a></li></ul></div></div>    
</body>
</html>