<html>
<head>
<title>How I used a TypeScript decorator to solve a coding issue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用TypeScript装饰器来解决编码问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-i-used-a-typescript-decorator-to-solve-my-issue-aa4816bf791f?source=collection_archive---------1-----------------------#2021-10-09">https://javascript.plainenglish.io/how-i-used-a-typescript-decorator-to-solve-my-issue-aa4816bf791f?source=collection_archive---------1-----------------------#2021-10-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/90d20c9be96da4f44f28fd935e937798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CT0uhdv5xXXnZSQV"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Dziedzic</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0dfe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我目前正在开发一个Angular应用程序，我需要在其中显示工作流执行的历史。这些工作流由不同类型的步骤组成，实际上有许多不同类型的步骤，因此，我必须找到某种通用的和可重用的方式来显示它们。</p><p id="8086" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该解决方案的第一个构建块是一个组件，它接收历史记录条目，并负责通过加载相应的组件来显示它。事实上，我希望有一个历史条目类型的组件。这样，我有非常轻的组件，只接收他们需要显示的数据。</p><p id="eceb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有以下数组，对应于REST API返回的工作流历史。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="d5da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，条目的类型决定了必须加载哪个组件，并且使用输入属性将“数据”属性传递给该组件。</p><p id="74fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以想象，用于显示历史条目的组件看起来非常相似，因此我们将为它们创建一个基本组件类:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="a819" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我可以轻松地创建一个新组件来扩展这个组件，以显示历史条目。例如，假设类型“3”是指示工作流已完成的历史条目，并且应该显示工作流执行所用的毫秒数。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7ef1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模板中使用的“数据”实际上来自基本组件，并将由实例化子组件的主组件传递。说到这，我们来实施一下。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="d704" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们首先在视图中添加一个“ng-template ”,用于实例化子组件。这个实例化是在“ngAfterViewInit”钩子中完成的。这里的主要问题(也是我写这篇文章的原因)是找到一种方法来知道组件工厂解析器需要根据条目类型返回什么组件工厂。不幸的是，目前还不可能(至少就我所知)获得一个定义的角度组件列表，以某种方式浏览和分析它们，从而获得组件和条目类型之间的匹配。</p><p id="76c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的第一个解决方案是维护一个将条目类型与组件类型相关联的目录(基本上是一个数组)。它像预期的那样工作，但是它又是一个要添加到解决方案中的文件，而且大多数时候，我总是忘记它，浪费了几分钟才想起我必须为新的历史条目类型添加一个条目。</p><p id="4e86" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么我决定学习一些关于装饰者的知识，希望它能改进我的代码，而且它确实做到了。这里的想法是向我们的组件添加一个装饰器，以便将它们与相应的条目类型相关联。让我们创建这个装饰器:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="38df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里没什么复杂的。首先，我们创建一个映射来存储类型和组件类之间的关联。然后，我们创建装饰函数(“HistoryEntryComponent”)，该函数简单地将它所应用的类添加到map中，并带有传入参数的类型。最后，我们还创建了一个名为“GetHistoryEntryComponent”的函数，它根据条目类型返回组件类。</p><p id="c6a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以将这个装饰器应用于历史条目组件:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><blockquote class="le lf lg"><p id="42f3" class="ka kb lh kc b kd ke kf kg kh ki kj kk li km kn ko lj kq kr ks lk ku kv kw kx ig bi translated">我们使用number作为条目类型，但更好的做法可能是使用枚举或一些常数，在这里，我们尽可能简化代码，以便每个人都清楚。</p></blockquote><p id="cd43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以在主组件中使用函数“GetHistoryEntryComponent ”,以便获得与条目类型对应的组件工厂:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="d5b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们只需要更新我们的应用程序组件模板来循环不同的条目:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="f85f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有这一切的结果如下:</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/3796727f81acb03b2d4cbce493776a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*SH8FfevMB-b84LJ0fZhxpw.png"/></div></figure><p id="8480" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此正确的组件会根据条目类型进行实例化。</p><blockquote class="le lf lg"><p id="b75f" class="ka kb lh kc b kd ke kf kg kh ki kj kk li km kn ko lj kq kr ks lk ku kv kw kx ig bi translated">重要提示:如果您希望在不使用Ivy渲染引擎的应用程序中使用此解决方案，您还必须将入口组件添加到模块的“entry components”数组中。</p></blockquote><p id="3fcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之，使用一个简单的TypeScript装饰器，我可以摆脱关联数组，以一种优雅的方式直接在组件中处理关联。</p><p id="8a98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章的源代码可以在<a class="ae jz" href="https://stackblitz.com/edit/angular-uwvskx" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>上访问。</p><p id="33f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lh">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>