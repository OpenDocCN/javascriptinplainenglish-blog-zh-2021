<html>
<head>
<title>Exploring the Possibilities of Node’s Virtual Machine Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索节点虚拟机模块的可能性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-vm-5727c269f8ec?source=collection_archive---------3-----------------------#2021-07-02">https://javascript.plainenglish.io/node-js-vm-5727c269f8ec?source=collection_archive---------3-----------------------#2021-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="36ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解上下文、执行和用例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f096bdfb5ea14a3a45fe77d72815930b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94CwXAE_ZXd1vzn0m7jLig.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by the author, based on official <a class="ae kv" href="https://nodejs.org/en/about/resources/" rel="noopener ugc nofollow" target="_blank">resources</a> and <a class="ae kv" href="https://pixabay.com/de/vectors/box-offen-karton-container-152428/" rel="noopener ugc nofollow" target="_blank">pixabay</a></figcaption></figure><p id="0168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node.js使用V8 JavaScript引擎——我想你以前听说过。但是您知道我们可以在Node.js中轻松访问引擎吗？</p><p id="3197" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，有一个默认的模块，这给了我们很大的能力去玩。这里是Node.js虚拟机(VM)模块的终极介绍。</p><h1 id="4feb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在虚拟机中执行您的第一个代码</h1><p id="12dc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Node.js中的<code class="fe mp mq mr ms b">vm</code>模块是默认可用的——不需要NPM。一旦实现了它，我们就可以定义我们想要执行的实际JS代码。为了在VM中执行代码，我们调用<code class="fe mp mq mr ms b">runInThisContext</code>。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="f517" class="mx lt iq ms b gy my mz l na nb">const vm = require('vm')</span><span id="7a46" class="mx lt iq ms b gy nc mz l na nb">const code = `console.log('hello from the vm')`</span><span id="892e" class="mx lt iq ms b gy nc mz l na nb">vm.runInThisContext(code) // hello from the vm </span></pre><p id="c7c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，就目前而言，就这么简单——但是还有更多有待发现。您可能已经注意到了关于VM对象中特性的其他建议。此外，<code class="fe mp mq mr ms b">runInThisContext</code>还有<code class="fe mp mq mr ms b">runInNewContext</code>和<code class="fe mp mq mr ms b">runInContext</code>。<br/>但这一切意味着什么？</p><h1 id="af49" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">理解上下文</h1><p id="f813" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在JavaScript中，有一个窗口对象。它是“最高”的对象，我们可以通过调用<code class="fe mp mq mr ms b">this</code>直接访问它。因为Node.js不是在浏览器中执行的，所以没有使用<code class="fe mp mq mr ms b">window</code>对象，而是使用了<code class="fe mp mq mr ms b">global</code>对象，它包含了所有像<code class="fe mp mq mr ms b">console.log</code>这样著名的函数。</p><p id="0d38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和浏览器中的JS一样，<code class="fe mp mq mr ms b">this</code>默认也是指全局对象，这里可以看到:<code class="fe mp mq mr ms b">this == global // true</code>。定义的全局对象在Node.js VM的上下文中是指“上下文”。</p><p id="eac9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你注意到我们是如何在VM中执行的代码中使用<code class="fe mp mq mr ms b">console.log()</code>的吗？正确，看起来像是在我们运行<code class="fe mp mq mr ms b">vm.runInThisContext</code>时定义了<code class="fe mp mq mr ms b">console.log</code>所属的<code class="fe mp mq mr ms b">global</code>对象。</p><p id="8d72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是这个函数的用途——在VM中执行代码，并把代码的全局对象放在它周围。这是另一个很好的例子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="7c42" class="mx lt iq ms b gy my mz l na nb">global.name = 'Max'</span><span id="21b2" class="mx lt iq ms b gy nc mz l na nb">const code = `console.log(this.name)`</span><span id="7aa8" class="mx lt iq ms b gy nc mz l na nb">vm.runInThisContext(code) // Max</span></pre><p id="b607" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，<code class="fe mp mq mr ms b">runInThisContext</code>保留了关于全局对象的周围环境——顾名思义。既然我们理解了这一点，剩下的就不言自明了——实际上，但这有点棘手。</p><p id="b19b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mp mq mr ms b">vm.runInContext</code>时，我们需要首先自己定义上下文。因此，我们需要一个context-object，传递给VM，它保存我们需要的全局变量。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="52c1" class="mx lt iq ms b gy my mz l na nb">const context = {<br/>  name: 'max',<br/>  console: console<br/>}</span><span id="2ab7" class="mx lt iq ms b gy nc mz l na nb">vm.createContext(context)</span><span id="be51" class="mx lt iq ms b gy nc mz l na nb">const code = `console.log(this.name)`</span><span id="c61b" class="mx lt iq ms b gy nc mz l na nb">vm.runInContext(code, context) // max</span></pre><p id="0de9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然<code class="fe mp mq mr ms b">global</code>默认不可用，<code class="fe mp mq mr ms b">console.log</code>不也是吗。如果我们想使用它，我们需要将它传递到我们的上下文中。当仅仅在VM中记录<code class="fe mp mq mr ms b">this</code>时，我们看到我们的全局变量有多瘦:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="2fa1" class="mx lt iq ms b gy my mz l na nb">{<br/>  name: 'max',<br/>  console: Object [console] { .. }<br/>}</span></pre><h1 id="58e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在虚拟机中导入和运行模块</h1><p id="e8e4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">打印日志很酷，但有时我们想写比这更复杂的代码。幸运的是，我们甚至可以将与NPM一起安装的模块导入到我们的虚拟机中。</p><p id="7f46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多种方法可以使外部模块在虚拟机中可用。<br/>我将坚持我认为最优雅的方式:将我们想要的模块传递给上下文对象。下面是我们如何在虚拟机中导入和运行Express:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="37d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在实际上可以通过浏览器中的端口8080访问我们的应用程序，即使它实际上是在虚拟机内部运行的。</p><h1 id="80c5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一个实际的用例</h1><p id="20d5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">即使没有任何实际的用例，我也从测试这个模块中获得了乐趣。当然，也有一些。最有趣的是我通过谷歌找到的一个。一家公司使用VM模块在安全的环境中测试其Node.js代码。</p><p id="b340" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一个小问题，他们已经用VM模块解决了。传递给VM进行测试的代码自然包含大量的console.log。为了给测试环境的日志留下干净的输出，他们使用了一个小技巧:作为log函数的上下文，简单地传递一个空函数。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="4576" class="mx lt iq ms b gy my mz l na nb">const context = {<br/>  console: () =&gt; {}<br/>}</span></pre><p id="463b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，内部日志可以被干净地静音。但在我看来，最酷的部分是可以在不改变原始代码的情况下定制console.log函数——这就是定制上下文的强大之处。</p><p id="d51d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让日志静音很酷，但是您仍然希望出于分析目的保留它们。对于自定义上下文，有一种方法可以做到这一点:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a61b" class="mx lt iq ms b gy my mz l na nb">let internalLogs = []</span><span id="4c9b" class="mx lt iq ms b gy nc mz l na nb">const context = {<br/>  console: {<br/>    log: (value) =&gt; {<br/>      internalLogs.push(value)<br/>    }<br/>  }<br/>}</span></pre><p id="e713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，所有的console.logs都被静默，但是保存在一个数组中。他们写了一整篇关于他们用法的文章<a class="ae kv" href="https://blog.idagio.com/testing-express-js-with-node-vm-63a344075052" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="c300" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p><p id="5b41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多Node.js深度内容:</p><div class="nf ng gp gr nh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/if-your-code-is-garbage-nodes-garbage-collector-won-t-help-f48d32d3bc9a"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">如果你的代码是垃圾，Node的垃圾收集器就没用了</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">以下是你需要知道的</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kp ni"/></div></div></a></div><p id="154c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nx">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>