<html>
<head>
<title>React Virtual DOM: Explained in Simple Words</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React虚拟DOM:用简单的话解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-guide-for-understanding-virtual-dom-tekolio-2f107d5122cc?source=collection_archive---------15-----------------------#2021-12-16">https://javascript.plainenglish.io/a-guide-for-understanding-virtual-dom-tekolio-2f107d5122cc?source=collection_archive---------15-----------------------#2021-12-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/1126b85df5d1de9c95f7618776442fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*LbgMegXIc6rT2nS7p_DPTg.png"/></div></figure><p id="7ae1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们先了解一下DOM是什么。DOM代表文档对象模型。它是一个树的结构表示，节点将不同的HTML标签表示为JavaScript对象，这使得浏览器更容易理解。</p><p id="6648" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们以前都在普通JS中使用过DOM，比如document.getElementById或document.getElementByClass，列表是红色的，我们可以根据自己的意愿轻松地修改内容。</p><h1 id="18ca" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">更新内容</h1><p id="0539" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">要修改内容或样式，我们需要JavaScript对象，因为浏览器不能理解HTML标签。每次我们更改内容或样式时，都会产生一个与该更改相对应的新状态，因此会有一个状态更改(从初始到最终)来更新DOM (UI)。</p><p id="1418" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">但是我们仍然不知道什么成为了这样一个理想过程的最昂贵的限制，React有它自己的解决方案来处理它。</p><h1 id="4f19" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">DOM的问题</h1><p id="0f4c" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">如前所述，实际过程中不存在这样的问题，但是这个过程只能用于具有少量节点的DOM树，当我们谈论，比如说一千个节点时，一切都可能出错。</p><p id="de4a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">根据该过程，在每次状态改变之后，DOM树必须被重新呈现，并且重新呈现具有1000个节点的树不是处理它的好方法，因为许多事情可能出错，例如失去速度或准确性，并且甚至可能花费我们很多空间。</p><p id="b6e3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了解决这个问题，react developed为他的应用程序开发了一个名为虚拟DOM的新DOM。</p><h1 id="681b" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">虚拟DOM</h1><p id="cf76" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">根据React 的<a class="ae ls" href="https://reactjs.org/docs/faq-internals.html" rel="noopener ugc nofollow" target="_blank">文档，“<strong class="jt io">虚拟DOM或VDOM只是UI的虚拟表示，保存在内存中，与真实DOM同步”。</strong></a></p><p id="c942" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">更简单地说，VDOM与真正的DOM没有什么不同，只是它是UI的虚拟或轻量级副本，存储在内存中，并始终与实际的UI保持联系。</p><p id="07d8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">它与真实的DOM具有相同的属性并遵循相同的过程，但它不能直接影响内容，而真实的DOM在相对于VDOM进行修改后需要更多的时间来加载或呈现其UI。</p><blockquote class="lt lu lv"><p id="66f2" class="jr js lw jt b ju jv jw jx jy jz ka kb lx kd ke kf ly kh ki kj lz kl km kn ko ig bi translated"><strong class="jt io"> <em class="in">但真正的问题是，在修改后所有属性甚至渲染UI的过程都一样的情况下，如何更快？</em> </strong></p></blockquote><h1 id="2313" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">VDOM的工作</h1><p id="0e93" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">我们都知道，在虚拟DOM中，与实际对象相似的虚拟对象是用相似的属性创建的，并且在每次状态改变后，DOM都会重新呈现自己，但是React为我们准备了一些不同的东西。</p><p id="1eb9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">React同时维护两个虚拟DOM。一个DOM是更新版本，而另一个是预更新版本或原始版本。它们之间会发生状态变化。</p><p id="c318" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在两个DOM之间进行比较，并且其中发生了变化的组件(只有该组件)将被再次呈现，而其他组件保持不变。这个过程叫做<strong class="jt io">差分。</strong></p><p id="f4bf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一旦diffing完成，React拥有了发生了变化的组件或对象，那么在真正的DOM中只有这一部分得到更新。这个过程是一个批处理过程，而不是一步到位的过程，在这个过程中，所有的更改都被同时发送到真正的DOM。</p><p id="ef5f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">简单地说，真正的DOM将只为那些发生变化的部分渲染，而不会为树的其余部分重新渲染。这将影响我们的应用程序和页面的速度和效率。</p><h1 id="86de" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">例子</h1><p id="f6bb" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">让我们看一个例子来更好地理解它。</p><p id="7eeb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下图显示了DOM的树结构及其节点。蓝色圆圈代表DOM的原始状态，而红色圆圈代表更新后的状态</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/96a8dd286530192b1429abbd21903b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*9vLmGDIEBdaqWCf_.png"/></div></figure><p id="fbfb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如上所述，虚拟DOM在真实DOM之前得到更新，这是因为真实Dom将只进行虚拟Dom检测到的那些更改，并按原样显示UI的其余部分。</p><p id="9710" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在上图中，虚拟DOM检测到第三组节点中的两处红色变化，第三组节点中的真实DOM显示相同的圆圈，而之前没有任何变化。</p><p id="1e9f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">红色的圆圈只会被渲染，因为只有那些被检测到被真正的DOM修改的圆圈会被渲染得更快更有效。</p><h1 id="4c85" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">概述</h1><ol class=""><li id="91ee" class="mf mg in jt b ju ln jy lo kc mh kg mi kk mj ko mk ml mm mn bi translated">虚拟DOM是DOM在内存中的虚拟表示或轻量级副本。</li><li id="bd4c" class="mf mg in jt b ju mo jy mp kc mq kg mr kk ms ko mk ml mm mn bi translated">虚拟DOM和真实DOM通过ReactDOM库同步在一起。这个过程叫做和解。</li><li id="7888" class="mf mg in jt b ju mo jy mp kc mq kg mr kk ms ko mk ml mm mn bi translated">React将更新后的虚拟DOM与更新前的虚拟DOM进行比较，以检查更新后的对象或组件，然后在真实DOM中进行更新。这个过程叫做diffing。</li><li id="ded4" class="mf mg in jt b ju mo jy mp kc mq kg mr kk ms ko mk ml mm mn bi translated">React使用关键点来避免不必要的重新渲染。</li><li id="0c2a" class="mf mg in jt b ju mo jy mp kc mq kg mr kk ms ko mk ml mm mn bi translated">虚拟DOM比真实DOM快</li><li id="87aa" class="mf mg in jt b ju mo jy mp kc mq kg mr kk ms ko mk ml mm mn bi translated">虚拟DOM具有与真实DOM相同的属性，但是它缺乏直接改变屏幕UI的能力。</li><li id="ff3b" class="mf mg in jt b ju mo jy mp kc mq kg mr kk ms ko mk ml mm mn bi translated">每件事都是分批完成的，这样更容易、更快地完成。</li></ol></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="805e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="lw">原载于2021年12月16日</em><a class="ae ls" href="https://tekolio.com/a-guide-for-understanding-virtual-dom/" rel="noopener ugc nofollow" target="_blank"><em class="lw">【https://tekolio.com】</em></a><em class="lw">。</em></p><p id="50e8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="lw">更多内容请看</em><a class="ae ls" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="lw">plain English . io</em></strong></a><em class="lw">。报名参加我们的</em> <a class="ae ls" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="lw">免费周报</em> </strong> </a> <em class="lw">。关注我们关于</em><a class="ae ls" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="lw">Twitter</em></strong></a><em class="lw">和</em><a class="ae ls" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="lw">LinkedIn</em></strong></a><em class="lw">。加入我们的</em> <a class="ae ls" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="lw">社区不和谐</em> </strong> </a> <em class="lw">。</em></p></div></div>    
</body>
</html>