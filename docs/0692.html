<html>
<head>
<title>Create scalable CLI using Schematics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Schematics创建可扩展CLI</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-scalable-cli-using-schematics-ad0d07c950cb?source=collection_archive---------9-----------------------#2021-02-12">https://javascript.plainenglish.io/create-a-scalable-cli-using-schematics-ad0d07c950cb?source=collection_archive---------9-----------------------#2021-02-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e4cb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">react Angular CLI的等价物，用RxJS和Ramda以函数方式编写</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1ecff46a9bc764bdf85deac4051751c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibrRMIQqesVlzHsSNACOEw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://medium.com/personal-growth/8-traits-of-emotionally-intelligent-people-5f8ae400e151" rel="noopener">Ben Allan</a> on <a class="ae ks" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bf10" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Angular生态系统中，我一直欣赏的一点是它丰富而直观的CLI。开发人员可以通过一个shell命令轻松创建新的组件和模块。这就是我们为React应用架构选择Angular Schematics的原因。本文将介绍如何以最具伸缩性的方式实现新的CLI。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/fdf254d535d74a3ad0342bd3089eae52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/0*SDuGCHZIYLpBeehi.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Angular Schematics</figcaption></figure><p id="9371" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您想通过直观的示例了解Schematics essentials的更多信息，以及我们为什么选择编写自己的CLI，请熟悉本文<a class="ae ks" href="https://medium.com/javascript-in-plain-english/increase-velocity-with-angular-schematics-cc276a7849ac" rel="noopener">。我也鼓励你在继续学习之前，回顾一下关于创建你自己的原理图的文章，比如</a><a class="ae ks" href="https://medium.com/rocket-fuel/angular-schematics-simple-schematic-76be2aa72850" rel="noopener">这个</a>。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="cfe0" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">功能</h1><p id="210a" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">单个<strong class="kv io">原理图</strong>被认为是角度原理图项目的最小构建模块。该实体负责元素创建，例如</p><ul class=""><li id="742f" class="mu mv in kv b kw kx kz la lc mw lg mx lk my lo mz na nb nc bi translated">成分</li><li id="4e20" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">钩</li><li id="48da" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">希腊奥委会（Hellenic Olympic Committee)</li><li id="3594" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">途径</li></ul><p id="f6a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它还生成所有相关的文件(测试、CSS、故事书、类型等。).</p><p id="a3d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了生成输出文件，原理图执行几个步骤:</p><ul class=""><li id="ec7f" class="mu mv in kv b kw kx kz la lc mw lg mx lk my lo mz na nb nc bi translated">从文件中读取通用配置</li><li id="a698" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">从提示或CLI参数中读取特定元素的用户输入</li><li id="11a4" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">使用从用户输入和配置中解析的变量复制和处理模板</li><li id="dc03" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">将代码注入现有文件</li><li id="c051" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">解析文件</li></ul><p id="ff62" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，这里有几个不同的操作。对于更复杂的生成器，比如创建一组负责一个业务领域的组件，示意图就变成了一个非常大的模块。</p><p id="40ce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幸运的是，Angular Schematics允许使用<strong class="kv io"/><a class="ae ks" href="https://github.com/angular/angular-cli/blob/e262c1bae66a86bb6ff8eee0136823e2e7267a44/packages/angular_devkit/schematics/src/rules/schematic.ts#L22" rel="noopener ugc nofollow" target="_blank">external schematic()</a>函数以编程方式运行其他生成器。这可能用于委托某些操作，比如将组件重新导出到帮助器原理图。</p><h1 id="7638" class="lx ly in bd lz ma ni mc md me nj mg mh jt nk ju mj jw nl jx ml jz nm ka mn mo bi translated">体系结构</h1><p id="53c8" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">申请流程分为3个部分:</p><ul class=""><li id="2a76" class="mu mv in kv b kw kx kz la lc mw lg mx lk my lo mz na nb nc bi translated"><strong class="kv io">收集选项</strong></li><li id="9e27" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated"><strong class="kv io">复制模板</strong></li><li id="bbfe" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated"><strong class="kv io">合并文件</strong></li></ul><p id="a732" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每个阶段都会带来一些挑战，需要采取不同的方法。接下来的段落将描述如何使用嵌入式Schematics实用程序和外部库处理特定阶段。</p><h2 id="7dc9" class="nn ly in bd lz no np dn md nq nr dp mh lc ns nt mj lg nu nv ml lk nw nx mn ny bi translated">示意流程</h2><p id="a251" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">为了增加原理图的可伸缩性和可读性，使用了函数式编程风格。每个复合动作组成如下:</p><ul class=""><li id="aa01" class="mu mv in kv b kw kx kz la lc mw lg mx lk my lo mz na nb nc bi translated"><code class="fe nz oa ob oc b">chain()</code> <strong class="kv io"> </strong>方法提供的有角示意图将几个<strong class="kv io">规则</strong>挤成一个</li><li id="22d5" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">由<a class="ae ks" href="https://rxjs-dev.firebaseapp.com/guide/overview" rel="noopener ugc nofollow" target="_blank"> RxJS </a>提供的<code class="fe nz oa ob oc b">pipe()</code>封装异步动作(如附加提示)</li><li id="ac16" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">由<a class="ae ks" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>提供<code class="fe nz oa ob oc b">pipe()</code>来包装同步动作(例如使用角度示意图<strong class="kv io">树</strong>对象方法)</li></ul><p id="3c3b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">规则是在<strong class="kv io">树</strong>和<strong class="kv io"> SchematicContext </strong>对象上执行的同步或异步操作。需要规则来返回一个对象树，不需要其他任何东西。这有助于使用管道作为规则映射到管道上一元函数的输出。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1835" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">基于此，一个<strong class="kv io">规则</strong>可能是:</p><ul class=""><li id="6859" class="mu mv in kv b kw kx kz la lc mw lg mx lk my lo mz na nb nc bi translated">一个curried函数，返回一个带有树对象的可观察对象(这个CLI中的大多数操作都需要包装在这个风格中)</li><li id="ae63" class="mu mv in kv b kw nd kz ne lc nf lg ng lk nh lo mz na nb nc bi translated">一个<a class="ae ks" href="https://github.com/angular/angular-cli/tree/master/packages/angular_devkit/schematics/src/rules" rel="noopener ugc nofollow" target="_blank">嵌入式实用程序</a>，比如forEach()，它允许针对树中的特定文件运行函数</li></ul><p id="81d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">RxJS和Ramda pipe将返回一个根据应用规则的结果执行的定制函数。</p><p id="fd97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我在这里准备了一些示例函数<a class="ae ks" href="https://gist.github.com/radekwarisch/7c2e329673a407752a420714ca0fcb7a" rel="noopener ugc nofollow" target="_blank">。下面是整个流程图，包括为我们的动作管道提供输入的规则执行。</a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/060eb5f5b74a832d2377d41849bad191.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*XGb59TFgJqzRxIFGskVZIg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Full flow of performed actions</figcaption></figure><h2 id="bc21" class="nn ly in bd lz no np dn md nq nr dp mh lc ns nt mj lg nu nv ml lk nw nx mn ny bi translated">主文件</h2><p id="1415" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">运行CLI命令时执行的函数使用函数组合以<strong class="kv io">声明方式</strong>实现应用流程。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="d098" class="nn ly in bd lz no np dn md nq nr dp mh lc ns nt mj lg nu nv ml lk nw nx mn ny bi translated">收集选项</h2><p id="45d8" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">创建新元素所需的数据在<strong class="kv io">配置文件</strong>中定义，其中包括模板和文件创建的默认路径，以及来自命令行参数或提示的<strong class="kv io">用户输入</strong>。</p><p id="ffbc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">负责选项收集的逻辑还提示用户共享附加信息。例如，用于在树中查找匹配结果的文件名，让用户选择他们的目标。这避免了没完没了地输入又长又难记的完整路径。这需要自定义提示实现，因为Angular Schematic在运行生成器代码之前只处理schema.json文件中定义的用户输入。为此，我们的CLI使用<a class="ae ks" href="https://github.com/SBoudrias/Inquirer.js" rel="noopener ugc nofollow" target="_blank"> Inquirer.js </a>。</p><p id="df79" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为我们的规则为我们的操作提供输入，所以用Inquier.js创建的提示在输入被传递到函数链之前收集并转换输入。这是一种链接任意数量的数据收集和验证步骤的非常精简的方式。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4fa7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当CLI代码通过改变共享对象来传递输入时，就创建了一个合适的包装器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="a00a" class="nn ly in bd lz no np dn md nq nr dp mh lc ns nt mj lg nu nv ml lk nw nx mn ny bi translated">复制模板</h2><p id="18f2" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">流水线的这一阶段负责使用Angular Schematics函数来加载、解析模板并将模板移动到所需的目录中。然后这些动作被<code class="fe nz oa ob oc b">apply()</code>包装。<a class="ae ks" href="https://ejs.co/" rel="noopener ugc nofollow" target="_blank"> EJS模板</a>用提供的变量处理。然后经过解析的模板被包含在可变输入中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4b20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了允许有条件的文件创建(例如，故事书或测试文件可能被排除)，我们使用<a class="ae ks" href="https://github.com/angular/angular-cli/blob/e262c1bae66a86bb6ff8eee0136823e2e7267a44/packages/angular_devkit/schematics/src/rules/schematic.ts#L22" rel="noopener ugc nofollow" target="_blank"> externalSchematic() </a>作为插件实现了文件排除。解析EJS扩展时执行了类似的步骤。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="7006" class="nn ly in bd lz no np dn md nq nr dp mh lc ns nt mj lg nu nv ml lk nw nx mn ny bi translated">合并文件</h2><p id="b8cf" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">最后一步将创建和解析的模板与当前文件系统合并。这包括定义<a class="ae ks" href="https://github.com/angular/angular-cli/blob/36a28e52266938d4e87a9065b54ee605d932e835/packages/angular_devkit/schematics/src/tree/interface.ts#L12" rel="noopener ugc nofollow" target="_blank">合并策略</a>。<strong class="kv io"> </strong>如果你希望用户在覆盖现有文件之前确认，不要使用<code class="fe nz oa ob oc b">MergeStrategy.Overwrite</code>策略。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5ba4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一步，我们使用一个外部生成器来lint和美化输出文件。使用外部生成器促进了重用，并保持了职责边界的完整性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><h1 id="8ab5" class="lx ly in bd lz ma ni mc md me nj mg mh jt nk ju mj jw nl jx ml jz nm ka mn mo bi translated">例子</h1><p id="8af7" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">我们的原理图CLI提供了与<a class="ae ks" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank">角度CLI </a>等效的反应。要求开发人员输入组件(名称、道具等。)，剩下的由生成器代码处理。这有助于确保我们的设计模式和测试需求得到严格遵守。它还减少了样板文件，从而提高了每个团队成员的绩效。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="og oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React component generation</figcaption></figure><p id="d977" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是一个生成组件的示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9788" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太神奇了。通过结合功能编程和角度原理图的灵活性，我们能够生成所有的应用功能。我们还可以提高代码的可测试性和重用性，在多个团队中产生全新的自动化工具。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="45b1" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">未来</h1><p id="68e4" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">代码搭建将成为前端和后端技术的一部分，作为减少错误和提高速度的一种方式。在前端世界中，有许多新兴技术结合了脚手架和人工智能，以创建基于设计或简单草图的应用程序。它们可能标志着网络发展的未来。你可以在这里找到一个有趣的例子。</p><h1 id="16d7" class="lx ly in bd lz ma ni mc md me nj mg mh jt nk ju mj jw nl jx ml jz nm ka mn mo bi translated">结论</h1><p id="fa4c" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">感谢您的阅读。我希望你会觉得这很鼓舞人心。</p><p id="8281" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将很快发布我们的CLI，敬请关注！</p></div></div>    
</body>
</html>