<html>
<head>
<title>TypeScript advanced types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript高级类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-advanced-types-b6d0f19bcbf5?source=collection_archive---------9-----------------------#2021-04-11">https://javascript.plainenglish.io/typescript-advanced-types-b6d0f19bcbf5?source=collection_archive---------9-----------------------#2021-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a8aa" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">提高开发技能的打字技巧</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/722672f429796ddcfb07b0c52ab3121b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Ca38BL7C5MRI0qsdAQT3Q.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@pankajpatel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pankaj Patel</a> on <a class="ae ks" href="https://unsplash.com/s/photos/advanced-types-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="12c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TypeScript具有一些高级语言功能，可以在处理基本类型和对象时使用。在本文中，我们将快速了解这些高级类型特性，包括:</p><ul class=""><li id="5b78" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">工会类型</li><li id="2651" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">防护类型</li><li id="bf33" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">键入别名</li><li id="724c" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">空且未定义</li><li id="2b3d" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">物体静止和伸展</li></ul><h2 id="d7a7" class="md me in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">工会类型</h2><p id="11c8" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">TypeScript允许我们将一个类型表示为两个或更多其他类型的组合。这种技术称为联合类型，使用管道符号(|)。考虑以下类型脚本代码:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="6bbd" class="md me in nc b gy ng nh l ni nj">var union : string | number;</span><span id="859a" class="md me in nc b gy nk nh l ni nj">union = 7;<br/>console.log(`union : ${union}`); <!-- -->// Output: union: 7</span><span id="1851" class="md me in nc b gy nk nh l ni nj">union = "article"; <br/>console.log(`union : ${union}`); <!-- -->// Output: union: article</span></pre><p id="97c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">变量<code class="fe nl nm nn nc b">union</code>使用联合类型语法来表示它可以保存一个<code class="fe nl nm nn nc b">string</code>或一个<code class="fe nl nm nn nc b">number</code>。</p><p id="e832" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">函数参数也可以是联合类型:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="8569" class="md me in nc b gy ng nh l ni nj">function checkType(patientId: (string | number))<br/>{<br/>    if(typeof(patientId) === "number")<br/>        console.log('PatientId is a number.')<br/>    else if(typeof(patientId) === "string")<br/>        console.log('PatientId is a string.')<br/>}<br/><br/>checkType(9876); // Output: PatientId is a number.<br/>checkType("PI-1234-AZ"); // Output: PatientId is a string.<br/>cheyType(true); //Compiler Error: Argument of type 'true' is not assignable to a parameter of type string | number</span></pre><h2 id="fba6" class="md me in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">防护类型</h2><p id="0cc5" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">当使用联合类型时，编译器仍然会应用它的强类型规则来确保我们不会混合和匹配我们的类型。例如，考虑以下代码:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="6c09" class="md me in nc b gy ng nh l ni nj">function add(<br/>union1 : string | number,<br/>union2 : string | number<br/>){<br/> return union1 + union2;<br/>}</span></pre><p id="01ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nl nm nn nc b">add</code>函数接受两个参数并返回它们的和。<code class="fe nl nm nn nc b">union1</code>和<code class="fe nl nm nn nc b">union2</code>参数是联合类型，因此可以是<code class="fe nl nm nn nc b">string</code>或<code class="fe nl nm nn nc b">number</code>。但是，编译此代码会生成以下错误:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="50f5" class="md me in nc b gy ng nh l ni nj"><strong class="nc io">error TS2365: Operator '+' cannot be applied to types 'string | number' and 'string | number'.</strong></span></pre><p id="882f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里编译器告诉我们的是，在函数体中，它无法确定<code class="fe nl nm nn nc b">union1</code>的类型是什么。</p><p id="4434" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是型警卫的用武之地。Type guards是一个表达式，它检查我们的类型，然后确保该类型在其范围内。考虑以下代码:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="0566" class="md me in nc b gy ng nh l ni nj">function typeGuardAdd(<br/>union1 : string | number,<br/>union2 : string | number<br/>) : string | number {<br/> if( typeof union1 ==="string") {<br/>  console.log('first argument is a string'); <br/>  return union1 + union2;<br/>}<br/> if (typeof union1 === "number" &amp;&amp; typeof union2 === "number") {<br/>  console.log('both arguments are numbers');<br/>  return union1 + union2;<br/>}<br/>console.log('default return');<br/>return union1.toString() + union2.toString();<br/>}</span></pre><p id="534d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在代码的主体中，我们有两个if语句。第一条if语句检查<code class="fe nl nm nn nc b">union1</code>的类型是否为<code class="fe nl nm nn nc b">string</code>。如果是一个<code class="fe nl nm nn nc b">string</code>，那么<code class="fe nl nm nn nc b">union1</code>的类型将被视为<code class="fe nl nm nn nc b">if</code>语句体中的<code class="fe nl nm nn nc b">string</code>。第二个<code class="fe nl nm nn nc b">if</code>语句检查<code class="fe nl nm nn nc b">union1</code>和<code class="fe nl nm nn nc b">union2</code>是否都是数字类型。在第二个<code class="fe nl nm nn nc b">if</code>语句的主体中，<code class="fe nl nm nn nc b">union1</code>和<code class="fe nl nm nn nc b">union2</code>都被视为数字。这两个if语句是我们的类型守卫。</p><p id="d6ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，我们最后的返回语句是在<code class="fe nl nm nn nc b">union1</code>和<code class="fe nl nm nn nc b">union2</code>上调用<code class="fe nl nm nn nc b">toString</code>函数。默认情况下，所有基本的JavaScript类型都有一个<code class="fe nl nm nn nc b">toString</code>函数，所以实际上，我们将两个参数都视为字符串并返回结果。</p><h2 id="e206" class="md me in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">键入别名</h2><p id="0a26" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">有时，当使用联合类型时，可能很难记住允许哪些类型。出于这个原因，TypeScript引入了类型别名的概念，在这里我们可以为类型联合创建特殊的命名类型。因此，类型别名是联合类型的一种方便的命名约定。</p><p id="d590" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">类型别名可以在任何使用通用类型的地方使用，并由Type关键字表示。因此，我们可以将代码简化如下:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="f8f2" class="md me in nc b gy ng nh l ni nj">type StringOrNumber = string | number;</span><span id="53a6" class="md me in nc b gy nk nh l ni nj">function aliasesAdd(<br/>union1 : StringOrNumber,<br/>union2 : StringOrNumber<br/>){<br/> return union1.toString() + union2.toString();<br/>}</span></pre><p id="f457" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">类型别名也可以用于函数签名，如下所示:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="d654" class="md me in nc b gy ng nh l ni nj">type CallbackWithString = (string) =&gt; void;</span><span id="b89a" class="md me in nc b gy nk nh l ni nj">function usingCallbackWithString(<br/>callback: CallbackWithString) {<br/>  callback("this is a string");<br/>}</span></pre><h2 id="b938" class="md me in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">空且未定义</h2><p id="acb2" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">在JavaScript中，如果已经声明了一个变量，但没有赋值，那么对其值的查询将返回<code class="fe nl nm nn nc b">undefined</code>。JavaScript还包括关键字<code class="fe nl nm nn nc b">null</code>来区分变量已知但没有值的情况(空)和变量未在当前范围内定义的情况(未定义)。考虑以下JavaScript代码:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="ad1b" class="md me in nc b gy ng nh l ni nj">function testUndefined(test) {<br/>  console.log('test parameter :' + test);<br/>}<br/>testUndefined(); // test parameter :undefined</span><span id="bebb" class="md me in nc b gy nk nh l ni nj">testUndefined(null); // test parameter :null</span></pre><p id="1cac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一次不带任何参数调用<code class="fe nl nm nn nc b">testUndefined</code>函数。实际上，这是在不知道或不关心函数需要什么参数的情况下调用函数。JavaScript允许这种函数调用语法。</p><p id="18cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TypeScript为这些案例提供了两个关键字，分别名为<code class="fe nl nm nn nc b">null</code>和<code class="fe nl nm nn nc b">undefined</code>。让我们用TypeScript重写这个函数，如下所示:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="84a6" class="md me in nc b gy ng nh l ni nj">function testUndefined(test : null | number) { <br/>  console.log('test parameter :' + test);<br/>}</span></pre><p id="0be4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，我们定义了<code class="fe nl nm nn nc b">testUndefined</code>函数，允许用数字或空值调用该函数。如果我们试图在TypeScript中不带任何参数(<code class="fe nl nm nn nc b">testUndefined();</code>)调用这个函数，就像我们在JavaScript中所做的那样，TypeScript将生成一个错误:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="2839" class="md me in nc b gy ng nh l ni nj"><strong class="nc io">error TS2346: Supplied parameters do not match any signature of call target.</strong></span></pre><p id="b583" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种指定可以用<code class="fe nl nm nn nc b">null</code>值调用函数的能力允许我们确保在编译时知道函数的正确用法。</p><h2 id="8669" class="md me in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">物体静止和伸展</h2><p id="3364" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">在使用基本的JavaScript对象时，我们经常需要将一个对象的属性复制到另一个对象中，或者混合匹配各种对象的属性。为了满足这些需求，TypeScript采用了ES7的提议和语言语法，称为Object Rest和Spread。考虑以下类型脚本代码:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="fd03" class="md me in nc b gy ng nh l ni nj">let firstPerson = { id: 1, name : "Rachel"};<br/>let secondPerson = { …firstPerson };</span><span id="ae99" class="md me in nc b gy nk nh l ni nj">console.log(`secondPerson.id : ${secondPerson.id}`); // secondPerson.id : 1<br/>console.log(`secondPerson.name : ${secondPerson.name}`); // secondPerson.name : Rachel</span></pre><p id="5e04" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，我们首先定义一个名为<code class="fe nl nm nn nc b">firstPerson</code>的简单JavaScript对象，它有<code class="fe nl nm nn nc b">id</code>和<code class="fe nl nm nn nc b">name</code>属性。然后，通过指定{… firstPerson}，使用新的ES7语法将<code class="fe nl nm nn nc b">firstPerson</code>的所有属性复制到另一个名为<code class="fe nl nm nn nc b">secondPerson</code>的对象。为了测试它是否真的复制了所有属性，我们将<code class="fe nl nm nn nc b">secondPerson.id</code>和<code class="fe nl nm nn nc b">secondPerson.name</code>的值记录到控制台。</p><p id="be3b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也可以使用这个语法将多个对象组合在一起，如下所示:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="819b" class="md me in nc b gy ng nh l ni nj">let name = { name : "Rachel"};<br/>let id = { id : 2};</span><span id="e50a" class="md me in nc b gy nk nh l ni nj">let compose = { ...name, ...id };</span><span id="d78e" class="md me in nc b gy nk nh l ni nj">console.log(`compose.id : ${compose.id}`);<br/>console.log(`compose.name : ${compose.name}`);</span></pre><p id="bba0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">复制属性的rest和spread语法将递增地应用这些属性。换句话说，如果两个对象都有相同名称的属性，则最后指定的对象属性优先。</p><h2 id="54f0" class="md me in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated"><strong class="ak">结论</strong></h2><p id="7d8a" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">在本文中，我们回顾了一些高级的类型脚本类型和技术。一些要点如下:</p><ul class=""><li id="68e5" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">当我们需要在代码中经常使用联合类型时，类型别名提供了一种更简单、更直观的方式来声明命名的联合类型。</li><li id="6168" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">当您需要组合两个对象时，Rest和spread语法会很有用</li><li id="c1c1" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">TypeScript编译器通常会保护我们的代码不被以非预期的方式使用。例如，调用带有未定义值的函数。在JS中可以做的事情。</li><li id="70c6" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">类型保护允许您检查代码中变量的类型，并保证代码块中的变量是您期望的类型。</li></ul><p id="e862" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="no">更多内容尽在</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="no">plain English . io</em></strong></a></p></div></div>    
</body>
</html>