# 角度符合 RxJS:基本概念

> 原文：<https://javascript.plainenglish.io/angular-meets-rxjs-basic-concepts-f178d8fe0e02?source=collection_archive---------9----------------------->

![](img/01f9d18345747e05d47c93d90cc41ce1.png)

Photo by [Ryan Lara](https://unsplash.com/@ryanlara?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

# 介绍

自从 1.4 版本以来，我一直在使用“Angular”，我真的很喜欢它。当我切换到 Angular 2 时，我第一次听说了“RxJS”和反应式编程。我有点惭愧地承认，我的第一反应是告诉自己“谁在乎？没有它我也能构建很好的应用程序”…我没有错…事实上，没有“RxJS”也能创建很好的应用程序，就像使用扫帚柄成为一名优秀的高尔夫球员一样。在一天结束的时候，即使你学会了很好地使用球杆，努力学习使用常规的高尔夫球杆也会帮助你变得更好。

《Angular》中的“RxJS”也是如此。即使没有任何东西强迫你使用它(好吧……老实说，是“HttpClient”实现强迫你使用)，如果你掌握了它，你会更有效，你的应用程序也会更有**反应**。

我不愿意学习如何使用这个令人敬畏的库，这与这样一个事实有很大关系，让我们承认，它不是最容易掌握的库(即使现在我也不会说我掌握了它)。然而，这也是因为反应式编程方法与我过去使用的每种编程风格都非常不同。

这就是为什么我决定写一系列文章来指导您学习如何在“Angular”应用程序中有效地使用“RxJS”。我并不是说你将要学习的是使用“RxJS”的唯一方法，但这是我如何做的，到目前为止，它似乎相当可靠。

# 目录

基本概念
[RxJS 科目](/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3)
[RxJS 操作符(第一部分)](/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e)
[RxJS 操作符(第二部分)](https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-60d8b2140d20)
[RxJS 操作符(第三部分)](https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-e64caa5f72e7)
[“take until”和“async”管道](https://ssougnez.medium.com/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d)
[高阶可观察量](https://ssougnez.medium.com/angular-meets-rxjs-higher-order-observables-632e560ce2d0)
[错误处理](https://ssougnez.medium.com/angular-meets-rxjs-error-handling-8fad48721e49)
RxJS 调度器(即将推出)

# 在本文中…

好了，我们开始吧…这篇文章的主题不是有史以来最有趣的事情。的确，在能够开始使用“RxJS”之前，最好先了解一下背后的理论。我不会用大量的信息来淹没你，相反，我会给出你在当前文章中需要的最基本的理论，然后我会在下一篇文章中展开我留下的部分。所以，振作起来，勇敢一点，一旦你读完这篇文章，你就可以享受编程的乐趣了:-)

# 反应式编程

“RxJS”中的“Rx”实际上代表“ReactiveX ”,这是一套可以用来进行反应式编程的工具。的确，你要知道，反应式编程并不是专属于“JavaScript”的。您可以使用“RxJava”库用“Java”进行反应式编程，或者使用“System”。反应式”包装。这意味着“RxJS”只是“JavaScript”中用来进行反应式编程的库。

如果你的开发人员生活和我一样，你可能主要习惯于其他编程范式，比如事件驱动编程、面向对象编程等等，这可能是学习反应式编程如此困难的主要原因。这是一个非常不同的范例，很难改变你的心态去接受它，但是不用担心，我们会度过这个难关的:-)

反应式编程背后的主要思想是你的应用程序对数据变化作出反应(是的，不是开玩笑。现在，你可能想知道…数据怎么会自己改变？

假设您正在构建一个聊天应用程序。为此，您可能希望使用一个 web 套接字连接，让您的“Angular”应用程序不断地与您的服务器连接。这样，当有人告诉你一些事情时，服务器可以向你的“Angular”应用程序发送数据，而无需它请求。在这种情况下，您的“Angular”应用程序将接收新数据，这些数据将更新您的应用程序，因此，应用程序需要对这些新数据做出反应。这就是反应式编程发挥作用的地方。它将允许您的应用程序“监听这些变化”并对它们作出反应，例如，更新主组件以显示接收到的消息以及其他信息(谁发送的，什么时候等等)。

# 可观测量和观察者

## 该理论

反应式编程建立在两个重要的概念之上:可观察对象和观察者。

可观察值是一组值。然而，可观察值和数组之间的区别在于，可观察值是随着时间的推移而发出的，而数组的值是在已知的同时发出的。例如，在您的聊天应用程序中，我们可以想象我们有一个消息的可观察对象。事实上，这些信息会随着时间的推移进入你的应用程序:当有人告诉你一些事情的时候。起初，可观察的事物不会散发出任何价值(没有人告诉你任何事情)，然后，有人会记得你有多可爱，并决定与你交谈。这意味着随着时间的推移，应用程序将开始接收那个人发送给你的消息，因此你的被观察对象将开始一个接一个地发出这些消息，应用程序将能够对它们做出反应。一个可观察的事物经常被比作一个数据流。

另一个重要的概念是观察者。这其实挺有逻辑的。事实上，正如我们刚刚了解到的，可观测值是一个随着时间推移而产生价值的集合。然而，您还需要一种方法来获得这些值，这就是您使用观察器的地方。实际上，观察者只是被观察对象发出的数据的消费者。但是理论已经足够了，让我们看一些代码来帮助你理解这些基本概念。

# 有趣的部分

下面的代码显示了如何创建每秒发出一个值的可观察对象。请注意，由于我们还没有了解所有的概念，这段代码不会是最佳的，并且会出现一些内存泄漏问题，但是它将帮助我们理解我们刚刚谈到的基本概念。

好吧，那我们这里有什么？

## 可观察的

创建一个可观察对象就像调用第 3 行所示的“可观察”构造函数一样简单。此构造函数需要一个带有一个观察器参数的函数。重要的是要注意，我们没有创造观察者，只有可观察的。如前所述，观察者是被观察对象发出的数据的消费者，因此由对发出的值感兴趣的代码来创建观察者。

上面代码中名为“观察者”的变量实际上是对订阅可观察对象的观察者的引用。但是，我们如何创造这些观察者呢？我会在几秒钟后解释这个，但让我们先完成对可观察现象的解释。

> 我们称之为“订阅”的事实是将一个观察者与一个可观察对象联系起来，因此一个观察者只有在订阅后才会收到可观察对象的数据。

在这里，对于每个订阅了可观察值的观察者，我们首先创建一个名为“x”的局部变量，然后开始一个每秒调用“observer.next(++x)”的区间。

“next”是一个非常重要的函数，因为它实际上是您想要调用的函数，以便从可观察对象向观察者发送一个值。总的来说，这个可观测值将在每次观测者订阅它时开始一个间隔，然后每秒发出一个新值。

请注意这里非常重要的一点:如果您只有上面的代码，实际上什么都不会发生。事实上，上面创建的可观察对象不会产生任何价值，除非观察者订阅它。

> 变量名末尾的“$”是一个命名约定，表明我们正在处理一个可观察的事实。

## 观察家报

现在我们有了一个可观察对象，是时候用观察者来订阅它了。有不同的方法可以做到这一点，但让我们从更有意义的方法开始:

如果您看一下创建可观察对象的代码片段，您会记得当可观察对象想要发出一个新值时，它会调用与之连接的观察器的“next”函数，因此我们为对象提供一个“subscribe”方法之后的方法才有意义。事实上，这个用来连接一个观察者和一个可观察对象，所以我们需要传递一个有效的观察者给它。在这里的(最简单的)例子中，我们只是传递一个拥有“下一个”函数的对象，该函数在每次发出一个值时被调用。这样，10 秒钟后，您可以在控制台中看到:

![](img/ba1dbbf6b94cc140b39959398c05bc55.png)

所以这个管用！我们创建了一个可观察对象，然后通过提供一个观察器来订阅它，该观察器记录发出的值以及可观察对象每次发出值的日期。

一个可观察对象可以有任意多的观察者。例如，下面的代码非常好:

这会产生:

![](img/69f4744e87c5e78bd787c31e696f3eb3.png)

所以现在，我们每秒钟在控制台中有两个日志，只是因为可观察对象现在有两个观察者与之连接。为了真正理解发生了什么，让我们通过添加一些控制台日志来更改代码:

我使用“console.warn”而不是“console.log”只是为了让这些日志更明显:

![](img/48876a28b3ff84f7b336833e390eaf0c.png)

控制台中的前两个日志证明了“Observable”构造函数中定义的函数在每次观察者订阅可观察对象时都会被执行。

如果到目前为止你都明白了，那么文章的其余部分将是小菜一碟。事实上，这些是需要理解的最重要的概念，现在，我们将学习一些方便的基本特性，以便更好地使用可观察对象并避免内存泄漏。

# 签署

订阅一个可观察的当然非常重要，但退订也同样重要。事实上，当您订阅在前面的代码片段中创建的可观察对象时，您触发了每秒发出一个值的区间循环的创建。现在，让我们想象你有一个按钮，你可以点击它来停止监听发出的值，你会怎么做？

答案在于“subscribe”方法返回所谓的“订阅”,这个订阅有一个“unsubscribe”方法，您可以调用它来破坏可观察对象和观察者之间的连接。例如:

因为我们想在点击按钮时取消订阅，所以在订阅可观察对象时，我们将它存储在一个私有变量中。点击按钮时会调用“kill”功能。让我们试着在 2 或 3 秒后这样做:

![](img/47e519663e9e5db6c313bdfa89f06ec2.png)

上图展示了一些非常有趣和重要的东西。我们可以期望在点击按钮后控制台保持空白，但是只有一半的期望得到了满足。事实上，尽管我们不再在控制台中看到值的日志记录，但我们仍然可以看到警告日志。

这实际上是因为在这种情况下调用 unsubscribe 只会切断可观察对象和观察者之间的连接，但不会取消由“setInterval”函数创建的间隔，所以我们最终会遇到某种内存泄漏，因为间隔会在应用程序的整个生命周期中一直触发它。

幸运的是，有一种方法可以解决这个问题。您只需要稍微更新一下您的可观察对象的创建，以便返回一个具有“取消订阅”功能的对象，该功能会终止间隔(或者更一般地说，释放可观察对象分配的资源):

在这里，如果您尝试与之前相同的操作，您将会看到单击该按钮现在会停止控制台中出现的所有日志记录。

所以现在，你要问自己的问题是:“我应该什么时候退订一个可观察的？”。答案是…在文章的后面给出。事实上，为了给这个问题提供一个明确的答案，我们需要看看如何处理错误和完成一个可观察的。

# 错误处理

在一个完美的世界里，我们不需要处理错误，因为一切都会尽可能顺利，没有任何错误。然而，如果你编程不止一天，你可能知道错误是不可避免的，必须正确处理，所以问题是“我如何处理可观察到的错误？”。

答案很简单:

通过调用观察器上的“错误”函数，可以从可观察对象中抛出错误。如果您只这样做，错误将不会被捕获并出现在控制台中:

![](img/7f3bc892581ebc47a2048ce493522511.png)

然而，有一个简单的方法来捕捉错误。如果你理解观察者是如何与他们的可观察对象联系在一起的，你可能不会对下面的代码感到惊讶:

捕捉一个可观察到的错误就像在订阅可观察对象时提供一个“错误”回调函数一样简单。如果这样做，当使用观察器的“error”函数抛出错误时，将执行该函数。

![](img/5aadff17a5fc0da52cde1b1d73f53b11.png)

您可能还想知道为什么我们在抛出错误后清除了间隔。原因是可观测量的一个非常重要的特征。

> 抛出异常的可观察对象被认为是坏的，不会发出新的值。其状态是不可恢复的。

这一特性解释了我们为什么要处理这个区间。如果我们不这样做，我们就会有内存泄漏，因为抛出异常的事实会在执行错误回调后切断观察者和可观察对象之间的连接，所以在抛出异常时释放可观察对象使用的资源是很重要的。

# 完成一个观察

一个可观察的事物不一定要散发出永恒的价值。事实上，让我们想象一下，你想创造一个模拟从 5 到 0 倒计时的可观察对象。这个可观察值应该发出 5 个值(4、3、2、1 和 0)，然后停止这样做，观察者应该知道可观察值何时完成。您可以通过以下方式实现这一点:

1.  调用观察器的“完整”函数
2.  订阅时提供“完整”的回调

这里，我们更新了一点代码，将“x”的值从 5 减少到 0，并在它达到 0 时完成可观测性。请再次注意，我们在完成可观察对象时处理了间隔，以确保我们的可观察对象分配的所有资源都被释放。为了捕捉可观察对象的完成，我们在订阅可观察对象时简单地定义了一个“完整的”回调。注意，没有数据传递给这个回调函数，因为所有可观察的值都必须通过“next”函数发出。“完成”的那个只是用来向观察者表明，可观察物已经完成，不会发出新的值。

# 何时退订？

让我们回到问题“我应该什么时候退订？”。答案取决于上下文。如果您订阅了一个完成的可观察对象，则可能没有必要取消订阅。事实上，当可观察对象完成(或抛出错误)时，可观察对象和观察者之间的联系就被切断了，因此没有必要取消订阅。

正如我们将在本系列的另一篇文章中看到的，也可以使用操作符来修改可观察对象的行为。例如，它存在一个运算符，可用于仅检索由可观察对象发出的第一个值，并自动完成订阅。在这种情况下，可能也没有必要取消订阅。

然而，如果你订阅了《永不落幕的观察》，退订是非常重要的。典型的“Angular”情况是在“ngOnInit”挂钩中订阅可观察对象，将订阅存储在私有变量中，并在“ngOnDestroy”挂钩中取消订阅，以确保当组件被销毁时订阅被终止。

正如我所说的，答案取决于上下文，所以我们将在其他文章中回过头来给出这个问题的更精确的答案。

# 其他语法

订阅我们刚刚看到的一个可观察对象的方式并不是唯一的。您还可以使用这样的语法:将“下一个”回调作为“订阅”的第一个参数，将“错误”回调作为第二个参数，将“完成”回调作为第三个参数。所以下面的代码:

可能是这样写的:

这两种语法是等价的，尽管我倾向于选择第一种，因为你可以选择只使用你需要的回调。

# 热可观测量与冷可观测量

本文中的下一个概念是冷和热可观测的区别。从纯理论的角度来看，这种差异可以这样表述:

*   当数据的生产者是在观察者订阅它时创建的时，一个可观察对象被认为是冷的。
*   当数据的生产者独立于观察者的订阅而创建时，可观察的被认为是热的。

不太清楚，嗯？好吧，先说制作人的定义。生产者就是生产由可观察对象发出的数据的实体。在前面的示例中，生产者是“setInterval”函数。

有了这些信息，你应该能够回答这个问题“这个例子是热的还是冷的？”。

如果你很好地理解了我所有的解释，你就会明白答案是它们是冷的。事实上，生产者(“setInterval”)是在可观察对象的构造函数中调用的，这意味着每次新的观察者订阅可观察对象时都会调用它，因此，如果我们有两个观察者连接到可观察对象，我们实际上有两个间隔在运行，发出的值不会在不同的观察者之间共享。

这可以用下面的代码来验证:

在这个例子中，值的生产者仍然是“setInterval”函数，所以我们知道可观察对象是冷的。如果我们检查发出的值:

![](img/7eebe432b3b661388ab874f2c85a2558.png)

在这里，我们可以注意到，一秒钟后，第一个订阅发出了值“11 ”,而第二个订阅发出了值“7”。这说明了这样一个事实，即使我们订阅了相同的可观测值，发出的值对每个观察者来说是独立的。

现在…不幸的是，我不能给你一段代码来演示什么是热可观测性，因为它需要超出本文范围的概念。然而，我将在本系列的另一篇文章中再回到这个问题，当它写好后，我将把它链接到这里。

# 最后的想法

我们到了，这个系列的第一篇文章的结尾。正如我在介绍中所说的，反应式编程和“RxJS”不是很容易理解，需要**大量的练习**才能习惯。这篇文章是这个系列中最重要的一篇，因为它真正解释了基础知识，所以如果你不明白或者需要更多的澄清，不要犹豫，发表评论，我会回答或者更新文章的澄清。

下一篇文章将关注[“RxJS”主题和订阅管理。](/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3)

[![](img/6d60b235fcc46a4bd696b90e886419ee.png)](https://www.buymeacoffee.com/ssougnez)