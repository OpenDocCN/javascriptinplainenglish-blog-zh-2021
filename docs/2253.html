<html>
<head>
<title>What is a Provider in React/Redux?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React/Redux中的提供者是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-a-provider-in-react-redux-ed5f6991550c?source=collection_archive---------6-----------------------#2021-05-11">https://javascript.plainenglish.io/what-is-a-provider-in-react-redux-ed5f6991550c?source=collection_archive---------6-----------------------#2021-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="64da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我在React中构建一个应用程序并实现Redux时，我总是会遇到一个叫做<code class="fe ki kj kk kl b">Provider</code>的东西。我开始使用它的时候并不知道它到底是做什么的，也不知道为什么我需要使用它，但是我被告知这是React和Redux之间正确通信所必需的。在最近的一次代码审查中，有人问我“T1到底是什么，它有什么用途？”我今天的目标就是回答这个问题。</p><p id="c62f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，Redux是React代码，可以处理应用程序中所有的全局状态变化。与其他一些功能和中间件一起，redux的想法是将所有被定义为“状态”的部分存储在一个被称为<code class="fe ki kj kk kl b">store</code>的地方。Redux使用一个叫做<code class="fe ki kj kk kl b">reducer</code>的东西，根据发送给减速器的<code class="fe ki kj kk kl b">dispatch</code>来控制状态改变的内容和方式。</p><p id="f409" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在查看react应用程序中的<code class="fe ki kj kk kl b">index.js</code>文件，其中有一个<code class="fe ki kj kk kl b">store</code>变量。<code class="fe ki kj kk kl b">store</code>变量将由导入的<code class="fe ki kj kk kl b">createStore</code>函数(如果使用了<code class="fe ki kj kk kl b">thunk</code>，可能还有<code class="fe ki kj kk kl b">applyMiddleware</code>)和应用程序的缩减器组成。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f66baa2a7cc46f18cab11ce8cad07f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TzlETLU8zPDaUA3T9B6pqA.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/2f13ba17e1f792a899eefb79d0c7b782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2s1kSOLmd9LuxE_wSmFQw.png"/></div></div></figure><p id="afc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这很重要，因为在应用程序的当前位置，我有一个公共位置来存储我的状态，但是没有办法实际访问它。</p><h2 id="f1e6" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">这就是提供商的用武之地。</h2><p id="dc37" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">实现<code class="fe ki kj kk kl b">Provider</code>包括将任何需要知道<code class="fe ki kj kk kl b">Provider</code>组件内部状态的组件包装为子组件，并向<code class="fe ki kj kk kl b">Provider</code>(理想情况下)传递一个名为<code class="fe ki kj kk kl b">store</code>的属性，该属性等于创建的<code class="fe ki kj kk kl b">store</code>变量。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lx"><img src="../Images/eb5d5614143cbc53385050d2ac686444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdBHLr-wTM95jEfxOUtHYg.png"/></div></div></figure><p id="340b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我这里有<strong class="jm io"> <em class="ly">可以</em> </strong>连接到<code class="fe ki kj kk kl b">Provider</code>里面的全局存储的组件。这些组件<strong class="jm io"> <em class="ly">尚不具备</em> </strong>访问商店的能力，但可以与<code class="fe ki kj kk kl b">react-redux</code>内部的另一个功能连接。<code class="fe ki kj kk kl b">Provider</code>顾名思义，它<em class="ly">提供</em>访问商店的能力。</p><p id="c63a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让我的组件实际使用并更新状态的<code class="fe ki kj kk kl b">store</code>，我将使用从<code class="fe ki kj kk kl b">react-redux</code>导入的<code class="fe ki kj kk kl b">connect</code>函数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lz"><img src="../Images/12901c38337ab83b6622e531eaa89e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOZY9ZW15dt8IDpT7WjMtw.png"/></div></div></figure><p id="bb8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数做了几件事。首先，它允许我将一个组件连接到全局存储，但是它也允许我映射存储中存在的状态，以及我拥有的任何功能，作为我的组件的道具。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ma"><img src="../Images/7f4c75b6a2e4516950b9a4227d68c645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJUtCGviMf0_E9pwj6g0Zw.png"/></div></div></figure><p id="674c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个来自我的21点模拟器的例子展示了我创建的两个函数，<code class="fe ki kj kk kl b">mapDispatchToProps</code>和<code class="fe ki kj kk kl b">mapStateToProps</code>。<code class="fe ki kj kk kl b">mapStateToProps</code>将内部返回对象左侧的键匹配到全局状态内部的相应值。<code class="fe ki kj kk kl b">mapDispatchToProps</code>获取我创建的任何动作创建器，将它们传递给<code class="fe ki kj kk kl b">dispatch</code>，并将该函数绑定到一个具有给定键的匿名函数，该函数可以像<code class="fe ki kj kk kl b">this.props.updateRecord(user, playerOne)</code>一样被调用。这里最需要记住的是<code class="fe ki kj kk kl b">dispatch</code> <em class="ly">单独</em> <strong class="jm io">只接受对象</strong>。中间件<code class="fe ki kj kk kl b">thunk</code>提供了向<code class="fe ki kj kk kl b">dispatch</code>传递函数的能力，它与上面我的<code class="fe ki kj kk kl b">store</code>变量中的<code class="fe ki kj kk kl b">applyMiddleware</code>一起使用。<code class="fe ki kj kk kl b">Thunk</code>告诉<code class="fe ki kj kk kl b">dispatch</code>它可以接受对象、<em class="ly">以及</em>函数。它还说任何给它的函数都应该立即调用<strong class="jm io"/>。</p><p id="8cd9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">光靠这两个功能还不足以连接到商店。我需要导出带有<code class="fe ki kj kk kl b">connect</code>函数和两个<code class="fe ki kj kk kl b">mapTo</code>函数的组件<code class="fe ki kj kk kl b">Game</code>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ca"><img src="../Images/5fe1ff6739ad9bbdc21c658d1a9f9e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6eVdAxfU1jKg0Gv82AXYA.png"/></div></div></figure><p id="3a14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的connect函数是提供者的另一端。它告诉提供者，“嘿，这个组件需要访问存储”。请注意，mapTo函数并不都是必需的。可以传递空值来代替这两个值。</p><p id="b1f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看我的动作创建者，<code class="fe ki kj kk kl b">updateRecord</code>函数的返回值是一个匿名函数，它发送一个<code class="fe ki kj kk kl b">fetch</code>请求(在本例中是发送给<code class="fe ki kj kk kl b">user#show</code>方法),根据需要更新数据库，并按照构建<code class="fe ki kj kk kl b">dispatch</code>的方式将<code class="fe ki kj kk kl b">fetch</code>的响应发送给<code class="fe ki kj kk kl b">dispatch</code>;带有类型和有效载荷。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mb"><img src="../Images/81cbdc421295815de20d8792201a3564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WakfyJ2vaFj1NofOGvVDqQ.png"/></div></div></figure><p id="1427" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">reducer的结构是一个名为<code class="fe ki kj kk kl b">appReducer</code>的函数，它使用一个<code class="fe ki kj kk kl b">switch</code>语句来检查<code class="fe ki kj kk kl b">action</code>参数的<code class="fe ki kj kk kl b">type</code>，并基于那个<code class="fe ki kj kk kl b">type</code>执行代码。这里，如果<code class="fe ki kj kk kl b">type</code>是<code class="fe ki kj kk kl b">‘UPDATE_RECORD’</code>，该语句更新全局状态以分别反映<code class="fe ki kj kk kl b">player</code>和<code class="fe ki kj kk kl b">dealer</code>的<code class="fe ki kj kk kl b">wins</code>和<code class="fe ki kj kk kl b">losses</code>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mc"><img src="../Images/d8d4bd68372237a8aaccd7661ed82fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PW6-aHq5flBKcgXHOCB0HQ.png"/></div></div></figure><h2 id="a054" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">结论</h2><p id="208d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在你知道了。提供者本身并不是一个非常复杂的概念，而是一个更大的整体的一部分。要回答“什么是提供者”这个问题，不解释这里的所有其他概念是不可能的，因为它们一起帮助管理React中的状态。</p><p id="dda4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ly">更多内容请看</em><a class="ae md" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ly">plain English . io</em></strong></a></p></div></div>    
</body>
</html>