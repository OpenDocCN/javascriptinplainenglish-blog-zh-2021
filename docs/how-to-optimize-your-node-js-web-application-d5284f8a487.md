# 如何优化 Node.js Web 应用程序

> 原文：<https://javascript.plainenglish.io/how-to-optimize-your-node-js-web-application-d5284f8a487?source=collection_archive---------16----------------------->

## 如果最终用户认为你的网站表现不佳，他们的下一次点击将会是 your-competition.com

每当我们开发一个 web 应用程序时，基本上都有两个性能目标。

1.  任务完成(用户体验)
2.  吞吐量(规模)

这里我们所说的任务完成是指任务及时完成，吞吐量是指每秒的请求数。

在设计和实际编码时，我们必须考虑这两个目标，以便我们的系统具有最高的性能和最低的延迟。

让我们看看如何优化 Node.js 应用程序。

![](img/34f7866f772ea0fd0c5241ad13034d30.png)

# **加速数据库查询**

让我们看看我们能做些什么来加速我们的数据库查询

## 索引

> 索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。

我们应该扫描索引，而不是扫描整个集合，因为这样更快。一个或多个字段的集合可用于建立索引，称为查询索引，以提高查询的性能。

索引存储特定字段或字段集的值，按字段值排序。索引条目的排序支持高效的等式匹配和基于范围的查询操作。此外，MongoDB 可以通过使用索引中的排序返回排序的结果。

```
db.employee.createIndex({ employee_email: 1})
```

如果您的查询是这样的，可以减少查询时间

```
db.employee.find().sort({ employee_name: 1})
```

> 在创建集合的过程中，MongoDB 在 _id 字段上创建一个惟一的索引。_id 索引防止客户端插入两个具有相同 _id 字段值的文档。

**复合指数**

复合索引中列出的字段顺序很重要。例如，如果一个复合索引由{ userid: 1，score: -1 }组成，则该索引首先按 userid 排序，然后在每个 userid 值中按分数排序。

对于复合索引和排序操作，索引键的排序顺序(即升序或降序)可以确定索引是否支持排序操作。

考虑一个包含带有用户名和日期字段的文档的事件集合。

应用程序可以发出查询，返回首先按用户名值升序排序，然后按日期值降序排序的结果，例如:

```
db.events.find().sort( { username: 1, date: -1 } )
```

或者返回首先按用户名值降序排序，然后按日期值升序排序的结果的查询，例如:

```
db.events.find().sort( { username: -1, date: 1 } )
```

以下索引可以支持这两种排序操作:

```
db.events.createIndex( { “username” : 1, “date” : -1 } )
```

但是，上述索引不支持先按用户名值升序排序，然后按日期值升序排序，如下所示:

```
db.events.find().sort( { username: 1, date: 1 } )
```

> 如果 MongoDB 不能使用一个或多个索引来获得排序顺序，那么 MongoDB 必须对数据执行阻塞排序操作。阻塞排序表示 MongoDB 必须在返回结果之前消耗和处理排序的所有输入文档。阻塞排序不会阻塞集合或数据库上的并发操作。

**稀疏索引**

索引的稀疏属性确保索引只包含具有索引字段的文档的条目。索引会跳过没有索引字段的文档。

您可以将稀疏索引选项与唯一索引选项结合使用，以防止插入索引字段具有重复值的文档，并跳过对缺少索引字段的文档进行索引。

```
db.restaurants.createIndex({ “rating”: 1 }, { sparse: 1 })
```

**提示**

使用$hint 选择特定的索引–
在大多数情况下，查询优化器为特定的操作选择最佳的索引；但是，您可以使用 hint()方法强制 MongoDB 使用特定的索引。

**獴瘦()法**

默认情况下，mongose 查询返回 mongose 文档类的一个实例。文档比普通的 JavaScript 对象要重得多，因为它们有许多内部状态用于变更跟踪。猫鼬允许你添加。通过返回普通的 JSON 对象而不是 Mongoose 文档，lean()极大地提高了查询的性能。

**预测**

当您只需要文档中字段的子集时，可以通过只返回您需要的字段来获得更好的性能:

示例:

```
db.employee.find({ email: 1 , lastName: 1 , firstName: 1 })
```

**聚合**

聚合操作处理数据记录并返回计算结果。聚合操作将多个文档中的值组合在一起，并可以对分组的数据执行各种操作以返回单个结果。

# **Node.js 集群模块**

Node.js 的一个重要特性就是可伸缩性。每个 Node.js 进程都在一个线程中运行，默认情况下，它在 32 位系统上的内存限制是 512MB，在 64 位系统上是 1GB。尽管内存限制在 32 位系统上可以达到约 1GB，在 64 位系统上可以达到约 1.7GB，但内存和处理能力仍然会成为各种进程的瓶颈。

Node.js 为扩展应用程序提供的优雅解决方案是将单个流程拆分成多个流程或*工作器*，这可以通过集群模块来实现。集群模块允许您创建子进程(workers)，这些子进程与主节点进程(master)共享所有服务器端口。

# **GZIP 压缩**

打开 gzip 压缩会极大地影响您的 web 应用程序的性能。当 gzip 兼容的浏览器请求某些资源时，服务器可以在将响应发送给浏览器之前对其进行压缩。如果你不使用 gzip 来压缩你的静态资源，浏览器可能需要更长的时间来获取它。

在 Express 应用程序中，您可以使用内置的 express.static()中间件来提供静态内容。此外，您可以使用压缩中间件来压缩和提供静态内容。下面是一个片段，展示了如何做到这一点:

```
var compression = require(‘compression’);app.use(compression()); //use compression 
app.use(express.static(path.join(__dirname, ‘public’)));
```

# 避免内存泄漏

在 Node.js 中，每个进程都有 1.5 GB 内存堆的容量，而不考虑可用的总内存。但是，Node.js 中的 V8 引擎有一个内置的垃圾收集器(GC)，它会自动清理不活动的内存，以便使其可供使用。

但是，有时内存中过期很长时间的数据会逃过垃圾收集器，导致内存泄漏。

简而言之，很多时候内存使用量不断增加，而垃圾收集器却无法清理内存。这需要紧急解决。

但是，跟踪内存泄漏比您想象的要困难。在 Node.js 应用程序中跟踪内存泄漏的最佳方式是通过获取内存堆快照并分析它们来识别稳步增长的对象和类。

事实上，如果未能诊断出内存泄漏，Node.js 应用程序很有可能会耗尽内存并被关闭。

如果发生这种情况，您总是可以雇佣 Node js 开发人员来帮助您在内存使用阈值接近定义的限制时设置自动警报。

除此之外，您还应该考虑评估您的应用基础设施，并收集英特尔的性能信息，以检测是否有任何可用的资源，并准备好进行扩展以进行优化。

# **避免同步功能**

在使用同步函数之前要小心，因为对同步函数的单个调用可能会在几毫秒内返回。在高流量网站的情况下，这样的请求会降低应用程序的性能。确保避免在生产中使用同步函数。在初始启动时，同步功能是值得证明的。

# **使用反向代理**

通常，反向代理在 web 应用程序前面对请求执行支持操作，而不是将请求定向到应用程序，它具有处理压缩、错误页面、服务文件、缓存和负载平衡等功能。处理任务不需要应用程序的熟练知识来反转代理释放以执行特定的应用程序任务。这就是为什么，我想建议，你在制作中使用像 HAProxy 或 Nginx 这样的反向代理。

# 结论

我们参观了如何通过使用某些方法优化 Node.js 应用程序的性能，尽管到目前为止还没有设计出被称为**完美**的系统。所以现在我们可以注意到一件事:*“如果不首先创新你制造产品的方式，你就不能创新产品”。*

*更多内容请看*[***plain English . io***](http://plainenglish.io)