<html>
<head>
<title>How to Design and Create Custom Hooks in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中设计和创建定制钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-custom-hooks-in-react-46a8e0fb63cb?source=collection_archive---------6-----------------------#2021-08-22">https://javascript.plainenglish.io/how-to-make-custom-hooks-in-react-46a8e0fb63cb?source=collection_archive---------6-----------------------#2021-08-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cb6b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在React中设计定制钩子的简单教程</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/733fafcc576801a4df71acbc36361092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYZ-UOOLealSJah-_j0Lew.png"/></div></div></figure><p id="8e92" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们将讨论如何以及何时使用定制的react钩子来支持常见的副作用，并进而编写更可靠的代码。</p><p id="f082" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你了解抽象，那很好，<a class="ae lk" href="https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase" rel="noopener ugc nofollow" target="_blank">有时不了解</a>。尽管如此，有时我们需要比简单的抽象更多的东西来使代码可读和可重用。在定制钩子之外，我们寻求获得与现代钩子的流动性和力量相结合的抽象的优点。在继续之前，如果你还不熟悉的话，我建议阅读一下React <a class="ae lk" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">文档</a>中的内置挂钩，比如<em class="ll">使用状态</em>和<em class="ll">使用效果</em>。</p><h1 id="94e6" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">构建定制挂钩的3个步骤</h1><ol class=""><li id="4c39" class="me mf in kq b kr mg ku mh kx mi lb mj lf mk lj ml mm mn mo bi translated"><em class="ll">组织</em>。我最喜欢的做法是在项目的顶层创建一个钩子目录，这样所有定制的钩子都很容易找到。事实上，当您创建名为“hooks”的文件夹时，Visual Studio代码有一个默认图标。按照我的规则，这是个好兆头！</li><li id="f344" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><em class="ll">名字。我喜欢以“使用”开始钩子的名字，然后避免给钩子起像“使用”这样模糊的名字，然后简明扼要地表达它的责任。一个很好的例子可能是“useToggle”。那是相当明显的！</em></li><li id="b9f8" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><em class="ll">设计挂钩！构建定制的react挂钩实际上非常简单！只是要警惕什么逻辑放在那里，并记住，如果他们需要清理。错过这一点可能会导致内存泄漏！</em></li></ol><p id="0bf7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面我们来看几个例子！</p><h1 id="a4c9" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">简单的自定义挂钩示例</h1><p id="f542" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">最常见的是，我们在现有的基础上定制钩子。让我们首先创建一个名为<em class="ll"> useToggle </em>的超级简单的定制钩子，它利用<em class="ll"> useState </em>作为主干。</p><h2 id="e0cd" class="mx ln in bd lo my mz dn ls na nb dp lw kx nc nd ly lb ne nf ma lf ng nh mc ni bi translated">示例1: useToggle —最适合开/关开关类型的行为</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e3df" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们一行一行地看一下这个例子(耐心点，只有5行):</p><ol class=""><li id="ed83" class="me mf in kq b kr ks ku kv kx nl lb nm lf nn lj ml mm mn mo bi translated">首先，我们创建一个名为<em class="ll"> useToggle </em>的函数，它采用一个布尔值<em class="ll"> </em>作为参数，作为钩子的<em class="ll"> initialState </em>。如果没有提供，它将默认为假。</li><li id="e835" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">接下来，我们使用从React的内置<a class="ae lk" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> <em class="ll"> useState </em>钩子派生的标准表达式。这就是通常用来存放和操作我们的开关的东西。这个表达式将让我们访问<em class="ll">状态</em>——一个布尔变量(在这种情况下),它将跨渲染持久化——和<em class="ll">设置状态</em> —一个方法，当传递一个布尔变量时，它将调度状态更新并相应地触发重新渲染。</a></li><li id="4d2b" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">然后我们定义一个本地<em class="ll"> toggle </em>方法，该方法将读取当前状态并设置相反的状态。换句话说，如果状态为真，它会将其设置为假，反之亦然。</li><li id="eb11" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">最后，从我们的钩子返回一个数组，其中包含对可切换状态([0])和切换方法([1])的引用。这就是全部了。在你的组件中实现它，然后发疯！对于这个简单钩子的优化版本，<a class="ae lk" href="https://usehooks.com/useToggle/" rel="noopener ugc nofollow" target="_blank">参考这里。</a></li><li id="f3f8" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">哦对了…还有这个“}”</li></ol><p id="a7e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以使用这些代码来制作一些简单但华而不实的东西，比如下面的电灯开关(代码如下):</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/f4dcf9f0ba478b3bf1f6fad9b84ef205.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*dUSSFwmG8AOhGfx3Dj9nhg.gif"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="de28" class="mx ln in bd lo my mz dn ls na nb dp lw kx nc nd ly lb ne nf ma lf ng nh mc ni bi translated">例2:useFocusToggle——用于当反应导航屏幕聚焦或模糊时的处理</h2><p id="172b" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">为了想象这可能有用的场景，想象一下:我的团队发现了一个错误，当我们试图导航到某个屏幕时，应用程序会崩溃。我们很快意识到，一些在后台运行的复杂组件导致了这次崩溃。经过更深入的调查，我了解到当使用react-navigation的<a class="ae lk" href="https://reactnavigation.org/docs/5.x/tab-based-navigation" rel="noopener ugc nofollow" target="_blank"> <em class="ll">底部标签导航器</em> </a>时，屏幕在改变标签后不会<em class="ll">卸载</em>。换句话说，一个解决方案是当屏幕失去焦点时，想办法卸载有问题的组件。首先，我尝试利用react-navigation的<a class="ae lk" href="https://reactnavigation.org/docs/5.x/use-focus-effect" rel="noopener ugc nofollow" target="_blank"> useFocusEffect </a>功能，但这并不适合我——因为我不断遇到错误，没有时间深入研究——我构建了以下钩子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9f6f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个名为<em class="ll"> useFocusToggle </em>的定制钩子接受1个必需参数和2个可选参数。</p><ol class=""><li id="f4ae" class="me mf in kq b kr ks ku kv kx nl lb nm lf nn lj ml mm mn mo bi translated"><em class="ll">导航(必需)。</em>这必须是某个<a class="ae lk" href="https://reactnavigation.org/docs/navigation-prop/" rel="noopener ugc nofollow" target="_blank"><em class="ll">navigation prop</em></a>类型，属于使用react-navigation的项目中的某个屏幕</li><li id="deb8" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><em class="ll">焦点事件(可选)。</em>这应该是一个回调函数，包含当屏幕聚焦时要执行的任何任务。</li><li id="bed3" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated"><em class="ll">模糊事件(可选)。这应该是一个回调函数，包含当屏幕离开焦点时要执行的任何任务</em></li></ol><p id="10c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从第2行开始，钩子建立了一个类似开关的状态来表示实现钩子的屏幕是否被聚焦。</p><p id="0641" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，我们利用两个独立的useEffect挂钩，每次导航(prop #1)引用更新时执行。考虑到react-navigation的行为，根据应用程序的架构，这种情况通常不会出现超过两次。在每个钩子中，我们使用react-navigation的<em class="ll">导航来定义不同但相似的事件监听器。</em><a class="ae lk" href="https://reactnavigation.org/docs/navigation-events/" rel="noopener ugc nofollow" target="_blank"><em class="ll">addevent listener</em></a>方法。当屏幕聚焦时，一个侦听器将状态变为true，并执行focusEvents (prop #2)中传递的任何回调。当屏幕离开焦点时，另一个监听器将状态变为false并执行blurEvents (prop #3)中传递的任何回调。</p><p id="e4cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们返回表示屏幕是焦点还是非焦点的状态。</p><p id="65e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我知道对于这个钩子的用处可能会有一些混淆，在这种情况下，让我确定这个钩子真的只对使用react-navigation的顶级屏幕组件有意义。无论如何，如果useFocusToggle 被一个较低级别的组件调用，那么它需要被它的一个祖先屏幕传递一个导航属性。</p><p id="3f4c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回想一下我们最初的困境，即使我们的选项卡屏幕仍然保持挂载状态，这个钩子允许我们通过使用<em class="ll">聚焦的</em>状态来挂载和卸载子组件。这是一个简单的例子，展示了它的实际效果:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="6f35" class="mx ln in bd lo my mz dn ls na nb dp lw kx nc nd ly lb ne nf ma lf ng nh mc ni bi translated">何时不使用定制钩子(或一般钩子)</h2><p id="c177" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">假设你正在为一家企业构建一个结账屏幕，它需要有各种各样的副作用。因此，举例来说，当用户将一件商品添加到购物车时，如果他们花费超过50美元，他们将获得20%的折扣和免费送货(假设业务刚刚起步，可能会非常慷慨，希望获得牵引力)。让我们看看实现这一点的几种方法:</p><p id="d7de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">使用自定义挂钩的方法# 1:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="05a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从技术上讲，我们可以创建一个不必要的自定义钩子，它接受3个参数:一个“track”属性，一个条件表达式，它期望属性作为参数并返回一个布尔值，以及一个初始状态。让我们看看它是如何实现的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c3f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每当amountSpent prop发生变化时，我们的useConditionalHook中的useEffect将触发并报告用户是否有资格享受折扣。</p><p id="df89" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">方法#2无自定义挂钩</strong></p><p id="200b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是为什么你不需要这个钩子…这里不需要使用useEffect和useState。我们应该永远记住<strong class="kq io">当道具改变时，我们的组件重新渲染</strong>。因此，大多数表达式(没有被挂钩)被再次读取和执行。总之，我们需要的是一个表达式，如下所示，来替换第4行中的钩子，以达到相同的结果:</p><pre class="kd ke kf kg gt np nq nr ns aw nt bi"><span id="441d" class="mx ln in nq b gy nu nv l nw nx">const eligibleForDiscount = amountSpent &gt; 50</span></pre><p id="e902" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">瞧啊。每次父项更改amountSpent时，eligibleForDiscount都会根据我们的需要准确地更新。我认为避免前一种方法的一个好办法是在使用props初始化本地状态时要小心。</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="7ed2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我希望你从这篇文章中学到了一些东西！请参考这里的链接进行进一步阅读，如果你觉得这篇文章有趣，有任何问题或评论，请联系我。支持票帮助和感谢你的支持！</p><p id="c43d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">更多内容看</em><a class="ae lk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">plain English . io</em></strong></a></p></div></div>    
</body>
</html>