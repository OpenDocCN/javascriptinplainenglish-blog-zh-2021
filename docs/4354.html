<html>
<head>
<title>Find Callbacks Confusing? They are Nothing But…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">觉得回调很混乱？他们只不过是…</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/find-callbacks-confusing-they-are-nothing-but-ce3df3601fc5?source=collection_archive---------9-----------------------#2021-08-30">https://javascript.plainenglish.io/find-callbacks-confusing-they-are-nothing-but-ce3df3601fc5?source=collection_archive---------9-----------------------#2021-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="519c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为回访建立一个坚实的心理模型！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fd538fef5b43a486cdfdfc4ccbf19b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PdCAM12TC-XxJlEL"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.pexels.com/@igor-14869791?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">📷</a></figcaption></figure><p id="4081" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调是JavaScript中经常出现的一个重要术语。它们使得承诺和异步/等待成为可能，并且是异步JavaScript的一个重要特性。它们也为使用JavaScript进行函数式编程铺平了道路。</p><p id="981a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一百万篇博客都是关于复试的，为什么你还要读另一篇呢？在本帖中，我们将尝试开发一个正确的心智模型，并检查几个用例。</p><p id="ee45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开始之前，我想提醒您，在JavaScript中，每个函数都是一个一级对象。每个函数都是一个对象，可以像任何其他对象(字符串、数字等)一样使用。).</p><p id="26f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使我们能够</p><ul class=""><li id="d66c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将其赋给其他对象的变量和属性</li><li id="a202" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将它作为参数传递给函数</li><li id="c336" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">作为函数的值返回</li></ul><p id="f64a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在另一个函数中使用函数作为参数是JavaScript中回调的基础。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f5c3" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">回调只是传递给其他函数的函数。</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/2d57900ca595164e8b1655ff69f42847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qI9n0qm_2yxrVHpbAhj2pA.png"/></div></div></figure><p id="162b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，<code class="fe ng nh ni nj b">name()</code>函数作为一个参数被传递给<code class="fe ng nh ni nj b">say() </code>函数并进入它的内部。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/ea5ca435c915f9b8f4336041b59330fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N88ZgUKP6JtHzUEsoWVOyg.png"/></div></div></figure><p id="1577" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，每当我们将一个函数传递给另一个函数并在那个函数中执行它时，我们称之为<strong class="ky ir"> <em class="nl">回调</em> </strong>。</p><p id="2728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那就是所有的那一个<strong class="ky ir"> <em class="nl">回调</em> </strong>就是。它只是程序员为彼此交流代码而创造的一个术语。</p><p id="541c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，回调函数并不是立即被调用的。它在所包含的函数体内的特定点被“回调”(因此得名)。</p><p id="7eb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果回调被称为事后调用，可能就不会那么令人困惑了，但是你能做什么呢？我们暂时被这个术语困住了，我们最多能做的就是彻底理解它。</p><p id="00bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，接受其他函数作为参数的函数在我们的例子中称为<strong class="ky ir"> <em class="nl">高阶函数</em> </strong> <em class="nl"> — </em> say()。</p><p id="95a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nl"/><strong class="ky ir"><em class="nl">高阶函数</em> </strong>包含回调函数执行时<em class="nl">的逻辑。这两者的结合使我们能够扩展我们的功能。</em></p><p id="c872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多时候我们不需要独立的函数，在这种情况下我们使用匿名函数。我们可以传入匿名函数而不是命名函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/d37b11273b712508f7c53aad37dbfd6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asdjmVDSisxX-Wpq2yuHoQ.png"/></div></div></figure><p id="9015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以利用箭头功能使它看起来更光滑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/3fc6def805ac6016765c816b893d1555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G36tvVPzKV7rImTjJuQ63Q.png"/></div></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="1100" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">你的方式不是唯一的方式。</h1><p id="88bb" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">这是我的问题！</p><h2 id="61e6" class="nt mo iq bd mp nu nv dn mt nw nx dp mx lf ny nz mz lj oa ob nb ln oc od nd oe bi translated"><strong class="ak"> <em class="of">我们需要这样写代码吗？</em> </strong></h2><p id="6b40" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">我们可以这样写上面的代码来做同样的事情:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/49c5ba4ade2d89222a26a6cea83066f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ty5O6kxngOMUHi_A3QIfA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">This still works.</figcaption></figure><p id="8b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阅读起来也容易多了！那为什么我们在JavaScript中使用回调来做事情呢？</p><p id="b0b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="nl">我们需要用回调来完成事情吗？</em> </strong></p><p id="951a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你继续之前慢慢来——试着想出你需要它的情况。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="dd8c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">任何事物都有它的用途，直到它的用途被达到</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/b8cf3ea2f92c818cb21e03f60c205cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1yL0WE1xEpejrwM58FUiw.png"/></div></div></figure><p id="5285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有将回调作为参数传递的可能性，您的say将被绑定到一致执行<code class="fe ng nh ni nj b">name()</code>,因为它在您的函数代码中是固定的。</p><p id="db08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你在做一些简单的事情时，在一个函数中调用另一个函数是有意义的。尽管如此，当事情变得复杂时，我们会使用回调。</p><p id="c900" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调和更高阶的函数简化了我们的代码并保持它的干爽——不要重复你自己。T11】</p><p id="3424" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调可以防止长时间运行的操作被阻塞。您传递一个回调函数，在函数操作完成后运行。在处理它时，代码将控制返回到主事件循环，而不是阻塞。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/25e906fc7bb0c086ee26b7e334038151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNLw9gTOiJMtZMr-GcWZRw.png"/></div></div></figure><p id="0d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们添加一个<strong class="ky ir"> <em class="nl">回调</em> </strong>函数作为<strong class="ky ir"> <em class="nl"> load </em> </strong>的第二个参数，它应该在脚本加载时执行，现在如果我们想从脚本中调用新函数，我们应该在回调中编写:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/019f440a91d9ac7479c3bdb17236a504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idAmUysGUj65N_qaYrXgJg.png"/></div></div></figure><p id="7ccb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做使我们能够用JavaScript进行基本的异步编程。JavaScript是单线程的——一次只能做一件事。在最基本的层面上，JavaScript中的异步编程是通过回调来完成的。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="175d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">顺便说一下，回调被调用成为:同步和异步回调。</h1><p id="99cf" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">理解他们是如何工作的对于避免混乱是至关重要的。</p><p id="240b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nl">同步回调</em>在使用回调的高阶函数执行期间<em class="nl">被执行。我们之前看到的例子都是<em class="nl">同步回调。</em></em></p><p id="3541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript主机环境提供了许多功能，允许您调度<em class="nl">异步</em>动作。换句话说，我们现在开始的行动，后来才结束。</p><p id="7ae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，一个这样的功能是<code class="fe ng nh ni nj b"><strong class="ky ir">setTimeout</strong></code> <strong class="ky ir">功能</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/e74d5dc222fa3b8ffdd824f164f93fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vAASJETysYOzYaxuwlpJXw.png"/></div></div></figure><p id="b600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将在特定时间—毫秒或秒(<strong class="ky ir"><em class="nl"/></strong>)后运行特定代码块或代码函数(<strong class="ky ir"> <em class="nl"> func </em> </strong>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/425ea8ad2598811988046de0bca435d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNY14WUxKsuJia42HQhPeA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We pass in five thousand, which is five seconds, and the first argument is a function we want to execute after 5secs.</figcaption></figure><p id="56c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用匿名函数做同样的事情。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/9451d8f8de7c3eba5f9e9c681f49d7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VbT_U9VELKWp22fwAiaLVw.png"/></div></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="6b5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端JavaScript程序几乎都是事件驱动的。这意味着，它们通常会等待用户做一些事情，然后对用户的动作做出响应，而不是运行某种预定的计算。</p><p id="c93f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户按下键盘上的键、移动鼠标、单击鼠标按钮或触摸触摸屏设备时，web浏览器会生成一个事件。</p><p id="da9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">事件驱动的JavaScript </strong>程序在指定的上下文中为指定类型的事件注册回调函数，当指定的事件发生时，web浏览器调用这些函数。</p><p id="02f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nl">这些回调函数被称为事件处理器或事件监听器</em>，它们被注册到<code class="fe ng nh ni nj b">addEventListener()</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/e6749974dcee3472d8134e4c9db69692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8QrJrdcxxdyCet1DkVrjg.png"/></div></div></figure><p id="c32d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用Node.js在后端工作时，回调大放异彩。可以说回调是Node.js的基础。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/a7aa73cba8622f65472e97623b0f4aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpzR-EEcb2IJckZomccUaw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/e3c9f6c124c8f3da71be40e23f9d0367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hs2m0o-SJkwIQ5ZZqVzQAA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">When the fs.readFile() is done reading the file, it invokes the callback function, giving us the data inside the file. Meanwhile, the execution thread continues down the line.</figcaption></figure><p id="1840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe ng nh ni nj b">fs.readFile()</code>读取完文件后，它调用回调函数，给我们提供文件中的数据。同时，执行线程继续运行。这就是我们所说的无阻塞的含义。</p><p id="f894" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调给了你一个接口，你可以说，“当你完成了那件事，做所有这些。”我们可以像这样以嵌套形式使用回调:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/8d0b763f58fd6e5bcf39cbbddbfb46b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gc7lRlknXAh5TkVJK1p9FA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">After the outer <code class="fe ng nh ni nj b">downloadPic()</code> is complete, the callback initiates the inner one.</figcaption></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="57f7" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">末日金字塔</h1><p id="bac2" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">乍一看，这是一种可行的异步编码方式。的确如此。对于一个或两个嵌套调用来说，这看起来没什么问题，但是对于一个接一个的多个异步操作来说，我们会有这样的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/bbdd4dcf397b647eeaa5f541e23d8524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_8ZzDJUnCZzm0nrs9l0kg.png"/></div></div></figure><p id="428d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着调用变得更加嵌套，代码变得更加深奥，管理起来也越来越困难。这有时被称为“<strong class="ky ir"> <em class="nl">”或“末日金字塔”</em>T11】</strong></p><p id="ab0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您一次只等待一个操作或者当响应返回时您只有一项工作要做时，回调非常有用。尽管如此，当您需要管理多个异步依赖项或者有几个不相关的任务等待相同的数据时，承诺变得非常有用。</p><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/struggling-with-promises-in-javascript-7808ec1303cc"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">纠结于JavaScript中的承诺？</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">结束你的痛苦。了解如何在现有代码中使用承诺。现实生活中的例子将帮助你掌握…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kp ov"/></div></div></a></div><h1 id="87f3" class="mn mo iq bd mp mq pk ms mt mu pl mw mx jw pm jx mz jz pn ka nb kc po kd nd ne bi translated">摘要</h1><ul class=""><li id="db89" class="ls lt iq ky b kz no lc np lf pp lj pq ln pr lr lx ly lz ma bi translated">传递给另一个函数的函数称为回调。</li><li id="2d5d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">接受一个函数的外部函数是我们的高阶函数</li><li id="39ac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">回调和高阶函数简化了我们的代码</li><li id="0885" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">保持干燥</li><li id="9697" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">顺便说一下，回调被调用成为:<em class="nl">同步</em>和<em class="nl">异步</em>回调。</li><li id="38da" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在函数返回之前会调用一个<strong class="ky ir">同步</strong>回调——而接收回调的API会保留在堆栈上。一个例子可能是一个<code class="fe ng nh ni nj b">list.foreach(callback)</code>；当<code class="fe ng nh ni nj b">foreach()</code>返回时，您会期望在每个元素上调用回调。</li><li id="431e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一个<strong class="ky ir">异步</strong>或<strong class="ky ir">延迟</strong>回调在一个函数返回后，在另一个线程的堆栈上被调用。延迟的机制包括线程和主循环(其他名称包括事件循环、调度程序、执行程序)。</li><li id="feb4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">异步回调在IO相关的API中很流行，比如<code class="fe ng nh ni nj b">fs.readFile</code>。您可能期望当<code class="fe ng nh ni nj b">readFile()</code>返回时，回调可能还没有被调用，因为它正在等待读操作完成。</li><li id="955e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们可以将一个回调函数嵌套在另一个回调函数中，但是这样做会增加代码的可读性，并导致我们称之为末日金字塔的结果。</li><li id="b325" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">承诺提供了一种更好的方法来管理多个异步依赖项，或者您有几个不相关的任务在等待相同的数据。</li></ul><h1 id="e017" class="mn mo iq bd mp mq pk ms mt mu pl mw mx jw pm jx mz jz pn ka nb kc po kd nd ne bi translated">感谢信</h1><p id="b290" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">我想利用这最后的机会说声谢谢。</p><p id="4e85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的光临！如果没有像你们<em class="nl"> </em>这样的<em class="nl"> </em>人跟随并带着这种信念阅读我的帖子，我将无法做我现在做的事情。</p><p id="219f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你能<a class="ae kv" href="https://polymathsomnath.medium.com/subscribe" rel="noopener"> <strong class="ky ir">加入我的<a class="ae kv" href="https://polymathsomnath.medium.com/subscribe" rel="noopener"> <strong class="ky ir">我的未来博客</strong> </a>中的</strong> </a>并留下来，因为我认为我们这里有一些很棒的东西。我希望在未来的许多年里，我能在你的职业生涯中帮助你！</p><p id="b285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次见。再见！</p><p id="9498" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nl">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nl">plain English . io</em></a></p></div></div>    
</body>
</html>