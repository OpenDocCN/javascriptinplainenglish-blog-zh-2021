<html>
<head>
<title>Testing async code in React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用中测试异步代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-async-code-in-react-apps-33bd405f25bf?source=collection_archive---------16-----------------------#2021-10-15">https://javascript.plainenglish.io/testing-async-code-in-react-apps-33bd405f25bf?source=collection_archive---------16-----------------------#2021-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c632" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用Jest和mock函数，以便在React应用程序中有效地测试您的异步代码！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2c86ba6477c533fd1589a1e01eb8cbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94uA4-MqX7L9yBWm2u3GHg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Jest</figcaption></figure><p id="3571" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本教程不是React中单元测试的介绍，所以如果你正在寻找类似的东西，我不确定这是否是正确的教程。但是请继续读下去吧！</p><h2 id="6b4e" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">先决条件</h2><p id="f034" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你满足以下先决条件，你将很容易地遵循本教程:</p><ul class=""><li id="097b" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">React的基础知识</li><li id="b7b1" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">单元测试的基本知识</li></ul><h1 id="c055" class="nd ls iq bd lt ne nf ng lw nh ni nj lz jw nk jx mc jz nl ka mf kc nm kd mi nn bi translated">概观</h1><p id="70ac" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们先来看看我们正在测试的应用程序。最终它将只是一个基本页面，呈现一堆编程语言。这里的重点是真正的测试，而不是应用程序本身。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">App.js</figcaption></figure><p id="3c8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，我们只呈现了<strong class="kx ir">语言组件</strong>，我们现在将仔细研究它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Languages.js</figcaption></figure><p id="d253" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在<strong class="kx ir"> useEffect </strong>钩子中，我们从一个假的API中异步获取一些数据，然后在<strong class="kx ir">呈现函数</strong>中，我们简单地呈现一个带有语言名称的无序列表。很基本，对吧？但这是组件，它将运行我们的测试！</p><p id="8371" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以让我们写下测试的初稿吧！</p><h1 id="5c0b" class="nd ls iq bd lt ne nf ng lw nh ni nj lz jw nk jx mc jz nl ka mf kc nm kd mi nn bi translated">编写第一个测试</h1><p id="895e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们将使用Jest运行我们的测试，Jest通常包含在标准的React应用程序中。所以不需要安装任何外部库！</p><p id="86f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的<strong class="kx ir">目标</strong>是测试，如果对API的请求成功，语言组件<strong class="kx ir">是否呈现列表项</strong>。让我们看看如何实现这个目标。根据通常的命名惯例，我们将测试文件命名为<strong class="kx ir"> Languages.test.js </strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Languages.test.js</figcaption></figure><p id="2abb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，我们在第4行创建了一个标题为“语言组件”的测试套件<strong class="kx ir">。从技术上来说，如果你只在测试套件中运行一个测试，那么创建一个测试套件是没有多大意义的，但是我们仍然在这里这样做。</strong></p><p id="c875" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与“正常”代码相比，测试异步代码的第一个区别是，我们实际上可以将异步函数传递给第5行<strong class="kx ir">中的<strong class="kx ir"> test </strong>函数。</strong>在这个测试函数中，我们首先定义了我们想要呈现的<strong class="kx ir">语言组件。</strong></p><p id="b6f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Languages.test.js的第9行你会注意到，我使用了<code class="fe nq nr ns nt b">findAllbyRole()</code>来查找组件中的列表项。我们<strong class="kx ir">没有</strong>使用<code class="fe nq nr ns nt b">getAllbyRole()</code>，因为这会导致<strong class="kx ir">错误</strong>。原因是<code class="fe nq nr ns nt b">getAllbyRole()</code>会<strong class="kx ir">立即</strong>寻找组件中的列表项，但是由于获取数据需要几毫秒的时间，数据需要一些时间存储在状态中。<code class="fe nq nr ns nt b">findAllbyRole()</code>另一方面，返回一个<strong class="kx ir">承诺，</strong>我们可以等待这个承诺，这个承诺将被重新评估几次。</p><p id="aa69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于<code class="fe nq nr ns nt b">listItemElements</code>将是一组编程语言，我们简单地定义我们期望<code class="fe nq nr ns nt b">listItemElements</code>在最后一行代码中的长度大于零。</p><p id="8d76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是这种方法仍然存在一个问题。你能想到一个吗？嗯，通过这段代码，我们实际上向服务器发送了请求，在这个特定的例子中，这可能没有问题。但是想象一下，我们正在运行数以千计的测试，我们不仅获取数据，还将数据写入数据库。这可能会很快失去控制。这就是<strong class="kx ir">模拟功能</strong>进入游戏的地方。</p><h1 id="78a4" class="nd ls iq bd lt ne nf ng lw nh ni nj lz jw nk jx mc jz nl ka mf kc nm kd mi nn bi translated">使用模拟函数</h1><p id="6c87" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">模拟函数是一种虚拟函数，可以在测试代码中使用。我们只需要添加几行代码来实现这些模拟功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="220a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过<code class="fe nq nr ns nt b">window.fetch = jest.fn()</code>，我们告诉代码<strong class="kx ir">用我们自己定制的模拟函数覆盖</strong>fetch函数！</p><p id="1555" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">第9行</strong>中，我们使用<code class="fe nq nr ns nt b">mockResolvedValueOnce()</code>来设置这个获取函数在被调用时应该解析的值。所以首先我们说这个函数应该在一个json对象中解析。如果你看一下<strong class="kx ir"> Languages.js </strong>这正是我们的<strong class="kx ir"> getData </strong>函数所解决的问题。其次，我们定义这将异步发生，并且我们期望包含一个<strong class="kx ir"> id </strong>和一个<strong class="kx ir">名称的对象的<strong class="kx ir">数组</strong>。分配给id和name键的值并不重要，重要的是格式。</strong></p><p id="6a0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其余的保持不变！现在，如果您用<code class="fe nq nr ns nt b">npm test</code>运行这个测试，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c1c0d9e496d4df0f6262df98bd002ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*_PokuQsgtqLJzJKexOebCQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of our test</figcaption></figure><h1 id="59f3" class="nd ls iq bd lt ne nf ng lw nh ni nj lz jw nk jx mc jz nl ka mf kc nm kd mi nn bi translated">结论</h1><p id="af1d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我希望我能帮助你理解如何在React with Jest和mock函数的帮助下测试异步代码。</p><p id="ee9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢你阅读这篇文章！</p><p id="3ad5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nv">更多内容看</em><a class="ae nw" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>