<html>
<head>
<title>Synchronize Your Asynchronous code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步您的异步代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useful-javascript-tips-tricks-and-best-practices-synchronize-your-asynchronous-code-4da04126c491?source=collection_archive---------9-----------------------#2021-06-23">https://javascript.plainenglish.io/useful-javascript-tips-tricks-and-best-practices-synchronize-your-asynchronous-code-4da04126c491?source=collection_archive---------9-----------------------#2021-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2c29" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">思维程序员</h2><div class=""/><div class=""><h2 id="f64b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">提高web开发的JavaScript技巧。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0fdef63b5a08f452b4d26d0f76aababe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iVO0IvSdj79wiwMB"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@wocintechchat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christina @ wocintechchat.com</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="404a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">“<em class="mb">你好！</em></p><p id="800a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="mb">在加载脚本时，我们有一系列要一个接一个执行的异步任务。</em></p><p id="d61e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你怎么能给它编程呢？</p><p id="908d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在编码面试中，这是一个具有挑战性的问题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mc"><img src="../Images/8169e1d1c6d6e09f8bfdcb659fa22af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsCxnj7gSkDSIdAKE8Mnug.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">the promise chain</figcaption></figure><p id="4bed" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">目标是确保异步块的执行只能在前一个块完成时开始。</p><h1 id="c93e" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">解决方案</h1><p id="f1c1" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">“<em class="mb">承诺可以被链接</em>”，其中一个最重要的承诺是链接和管理异步操作序列的能力。</p><blockquote class="na"><p id="5375" class="nb nc iq bd nd ne nf ng nh ni nj ma dk translated">作为ES6的一部分，Promises是JavaScript最重要的增强之一。</p></blockquote><p id="bc38" class="pw-post-body-paragraph lf lg iq lh b li nk ka lk ll nl kd ln lo nm lq lr ls nn lu lv lw no ly lz ma ij bi translated">这种承诺能力包括同步操作的两个关键特性，如下所示(或者<code class="fe np nq nr ns b">then()</code>接受两个回调)。</p><ul class=""><li id="ccdd" class="nt nu iq lh b li lj ll lm lo nv ls nw lw nx ma ny nz oa ob bi translated">得到结果后，调用<code class="fe np nq nr ns b">resolve()</code>，传递最终结果。</li><li id="bebb" class="nt nu iq lh b li oc ll od lo oe ls of lw og ma ny nz oa ob bi translated">如有错误，请致电<code class="fe np nq nr ns b">reject()</code>。</li></ul><p id="8f2f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个想法是通过<code class="fe np nq nr ns b">.then()</code>处理程序链传递结果。</p><h1 id="1f87" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">让我们来看看这是怎么回事……！</h1><p id="8ff8" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">我们编写一个<code class="fe np nq nr ns b">wait()</code>函数，它返回一个<code class="fe np nq nr ns b">Promise</code>，该函数使用<code class="fe np nq nr ns b">setTimeout() </code>函数延迟一段指定的时间。</p><pre class="kp kq kr ks gt oh ns oi oj aw ok bi"><span id="9812" class="ol me iq ns b gy om on l oo op">const wait = (ms) =&gt; new Promise((res) =&gt; setTimeout(res, ms))</span></pre><p id="2fc9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是一个非常基本的示例代码，演示了一个连锁承诺。</p><pre class="kp kq kr ks gt oh ns oi oj aw ok bi"><span id="9cb1" class="ol me iq ns b gy om on l oo op">wait(3000).then(function () {<br/>    console.log("promise 1")<br/>}).then(function () {<br/>    console.log("promise 2")<br/>}).then(function () {<br/>    console.log("promise 3")<br/>})</span></pre><p id="af89" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">代码的第二部分是链接发生的地方。我们首先调用刚刚创建的<code class="fe np nq nr ns b">wait()</code>;既然它会返回一个<code class="fe np nq nr ns b">Promise</code>，我们就可以对它调用<code class="fe np nq nr ns b">then()</code>。现在，既然那么回报一个承诺，我们可以链另一个然后调用它；这将在承诺解决后执行。</p><p id="2035" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因为我们需要一个维护其内部状态的函数，这可以通过如下的闭包来实现。</p><pre class="kp kq kr ks gt oh ns oi oj aw ok bi"><span id="b04e" class="ol me iq ns b gy om on l oo op">const synchronize = (() =&gt; {<br/>    let chain = Promise.resolve()<br/>    return async (promise) =&gt; {<br/>        return chain = chain.then(promise)<br/>    }<br/>})()</span></pre><ul class=""><li id="60ee" class="nt nu iq lh b li lj ll lm lo nv ls nw lw nx ma ny nz oa ob bi translated"><code class="fe np nq nr ns b">Promise.resolve()</code>是<code class="fe np nq nr ns b">chain</code>的开始。每隔一个调用附加到这个<code class="fe np nq nr ns b">Promise</code>。</li><li id="f495" class="nt nu iq lh b li oc ll od lo oe ls of lw og ma ny nz oa ob bi translated">我们有<code class="fe np nq nr ns b">async</code>关键字，你把它放在一个函数声明的前面，把它变成一个异步函数。</li></ul><h1 id="6f9c" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">应用程序</h1><p id="51fd" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">现在，当您调用以下函数时，后续调用将等待前面的完成。</p><ul class=""><li id="a39d" class="nt nu iq lh b li lj ll lm lo nv ls nw lw nx ma ny nz oa ob bi translated">第一区</li></ul><pre class="kp kq kr ks gt oh ns oi oj aw ok bi"><span id="7a5a" class="ol me iq ns b gy om on l oo op">synchronize(async () =&gt; {<br/>    await wait(1000)<br/>    console.log("Block 1 start")<br/>    await wait(1000)<br/>    console.log("Block 1 end")<br/>})</span></pre><ul class=""><li id="7055" class="nt nu iq lh b li lj ll lm lo nv ls nw lw nx ma ny nz oa ob bi translated">第二区</li></ul><pre class="kp kq kr ks gt oh ns oi oj aw ok bi"><span id="3c94" class="ol me iq ns b gy om on l oo op"><br/>synchronize(async () =&gt; {<br/>    await wait(1000)<br/>    console.log("Block 2 start")<br/>    await wait(1000)<br/>    console.log("Block 2 end")<br/>})</span></pre><ul class=""><li id="a4ac" class="nt nu iq lh b li lj ll lm lo nv ls nw lw nx ma ny nz oa ob bi translated">第三区</li></ul><pre class="kp kq kr ks gt oh ns oi oj aw ok bi"><span id="13b2" class="ol me iq ns b gy om on l oo op">synchronize(async () =&gt; {<br/>    await wait(1000)<br/>    console.log("Block 3 start")<br/>    await wait(1000)<br/>    console.log("Block 3 end")<br/>})</span></pre><p id="daa1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上述程序的输出会是什么？顺序是:<code class="fe np nq nr ns b">Block 1 -&gt; Block 2 -&gt; Block 3</code>。</p><pre class="kp kq kr ks gt oh ns oi oj aw ok bi"><span id="8915" class="ol me iq ns b gy om on l oo op">Block 1 start<br/>Block 1 end</span><span id="7aec" class="ol me iq ns b gy oq on l oo op">Block 2 start<br/>Block 2 end</span><span id="9c0b" class="ol me iq ns b gy oq on l oo op">Block 3 start<br/>Block 3 end</span></pre><h1 id="02e0" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">结论</h1><p id="86a6" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">上面的例子展示了如何链接承诺，以便使用then将一个承诺的响应传递给下一个承诺。</p><p id="c426" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以看到，承诺为JavaScript中异步操作的链接提供了一个很好的机制。</p><p id="9654" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这比<code class="fe np nq nr ns b">callback</code>方法要好。</p><p id="087a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">很简单，对吧？</p><p id="808a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="mb">更多内容看</em><a class="ae le" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"><em class="mb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>