<html>
<head>
<title>Algorithms Visualized</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法可视化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-visualized-4506b96fc3bc?source=collection_archive---------18-----------------------#2021-02-20">https://javascript.plainenglish.io/algorithms-visualized-4506b96fc3bc?source=collection_archive---------18-----------------------#2021-02-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="78b9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">冒泡排序</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/d48529c824d869a8ff27a631f344eb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*NQxkS9QrXfTNacKgX1ykBA.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Bubbles, bubbles, bubbles</figcaption></figure><p id="0128" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">冒泡排序</strong>是基于重复比较相邻值对的想法，然后<strong class="kq io">在值乱序时交换它们的位置</strong>。这是一种<strong class="kq io">直观的</strong>排序方法，因为它的逻辑是基于一次一个值的比较。缺点是与其他排序方法相比，这种方法效率低且耗时。</p><p id="81db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里是JavaScript中<strong class="kq io">冒泡排序</strong>的实现。</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="6c6c" class="lp lq in ll b gy lr ls l lt lu">const <strong class="ll io">bubbleSort</strong> = (sortMe) =&gt; {<br/>  sortMe.forEach((item, pass) =&gt; {<br/>    console.log('<strong class="ll io">pass:</strong>', pass)<br/>    sortMe.forEach((item, j) =&gt; {<br/>      console.log('<strong class="ll io">sortMe</strong>', sortMe)<br/>      if(item &gt; sortMe[j + 1]) {<br/>        const temp = sortMe[j]<br/>        sortMe[j] = sortMe[j + 1]<br/>        sortMe[j + 1] = temp<br/>      }<br/>    })<br/>    console.log('------')<br/>  })<br/>  return sortMe<br/>}</span><span id="e38f" class="lp lq in ll b gy lv ls l lt lu">console.log(bubbleSort(<strong class="ll io">[7, 3, 4, 2, 1]</strong>))<br/>//output: [1, 2, 3, 4, 7]</span></pre><p id="955a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该函数包含一个<strong class="kq io">嵌套循环</strong>，再次对数组中的每个元素进行迭代。外部嵌套循环是如何遍历数组的，内部嵌套循环是每次遍历中对每个项目的迭代。</p><p id="1267" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是<strong class="kq io"> [7，3，4，2，1] </strong>数组的冒泡排序的<strong class="kq io"> console.log() </strong>输出。在下面的最终输出中，我们可以看到它正确地将数组从最小值(1)到最大值(7)排序。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/e4a55286d4673ad6bd2ad78e95f38a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*PfiCEBAkiO76lhDhTvT92g.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">The final sorted array is: [1, 2, 3, 4, 7]</figcaption></figure><p id="c674" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们分解一下<strong class="kq io"> BubbleSort </strong>函数，以便更好地了解它是如何工作的。因为输入数组长度为5，所以该函数执行5次，索引从0到4(外部循环)。</p><h2 id="72a3" class="lp lq in bd lx ly lz dn ma mb mc dp md kx me mf mg lb mh mi mj lf mk ml mm mn bi translated">一传</h2><p id="055e" class="pw-post-body-paragraph ko kp in kq b kr mo jo kt ku mp jr kw kx mq kz la lb mr ld le lf ms lh li lj ig bi translated"><strong class="kq io"> sortMe </strong>数组输入数组开始为:</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="29e5" class="lp lq in ll b gy lr ls l lt lu"><strong class="ll io">[7, 3, 4, 2, 1]</strong></span></pre><p id="7a2e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以看到，值7是数组中最大的数字，位于最左侧的第一个位置。这个想法是将较大的数字向右移动。内部循环在每次遍历数组时再次迭代。这种迭代将左边最大的数字移动到右边。所以，在第一遍的过程中，7会“冒泡”到右边。这里我们可以直观的看到。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/927a54333adcc41e713d5fd1d8be42a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*TpauHfDFZfl4HDyMf7WhhA.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">7 “bubbles” all the way to the right</figcaption></figure><p id="9907" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在内循环中的每次迭代中，从左到右比较相邻的值，如果两个比较值中的较大值顺序不对，则交换它们，将较大的值向右移动，准备再次与下一个值进行比较。</p><p id="ba24" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为在第一遍的每次比较中，7都是较大的值，所以它在每次迭代中交换位置，最终停留在数组的最后一个位置。在第一遍之后，数组被部分排序。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/cf16e5724fb78d62ef2efd31e71addbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*6hE3eACAr8w5A2dbNS8gzw.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Array sort after the first pass (0)</figcaption></figure><p id="dcf8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">需要多次遍历数组才能完成排序。对数组排序所需的最大遍数等于数组中的元素数。</p><h2 id="4699" class="lp lq in bd lx ly lz dn ma mb mc dp md kx me mf mg lb mh mi mj lf mk ml mm mn bi translated">第二遍</h2><p id="a59b" class="pw-post-body-paragraph ko kp in kq b kr mo jo kt ku mp jr kw kx mq kz la lb mr ld le lf ms lh li lj ig bi translated">在第二遍中，因为4大于2，所以发生了两次交换，然后在下一次比较中，4大于1。作为第二次传递的结果，值4在7旁边“冒泡”。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/e10e8546922fd39b021f417d9510d4b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*GaiwbzzTfW7znDCz0vMzGw.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">4 “bubbles” into place next</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/063cabf21f7993af361e9ee7ed1c7ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*77-v6_Y9O44wSGjhTl8sEA.png"/></div></figure><p id="fd10" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二遍后排序的数组是:</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="46ad" class="lp lq in ll b gy lr ls l lt lu">[3,2,1,4,7]</span></pre><p id="2355" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">4号和7号在右边正确的位置，还有3次传球。</p><h2 id="2715" class="lp lq in bd lx ly lz dn ma mb mc dp md kx me mf mg lb mh mi mj lf mk ml mm mn bi translated">第三遍</h2><p id="ebf3" class="pw-post-body-paragraph ko kp in kq b kr mo jo kt ku mp jr kw kx mq kz la lb mr ld le lf ms lh li lj ig bi translated">该算法继续比较项目，并像以前一样将较大的值向右移动。这一次，3“冒泡”到4下面的位置，因为它大于2和1。我们看到数组越来越接近完全排序。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/4725cc7805f034a23d9139213aacba91.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*EY3zPlZLrc0mJEN__hyOxw.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">3 “bubbles” into place</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/1c468563559166a75bcdf4826181a7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*NGzbZ6fmBDw2RBjJ7KN72w.png"/></div></figure><p id="b0e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第三遍之后的数组如下…</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="031d" class="lp lq in ll b gy lr ls l lt lu">[2, 1, 3, 4, 7] //almost there.</span></pre><h2 id="b337" class="lp lq in bd lx ly lz dn ma mb mc dp md kx me mf mg lb mh mi mj lf mk ml mm mn bi translated">第四遍</h2><p id="6b89" class="pw-post-body-paragraph ko kp in kq b kr mo jo kt ku mp jr kw kx mq kz la lb mr ld le lf ms lh li lj ig bi translated">因为2大于1，所以在第四遍时仅发生一次交换。在此过程之后，数组被正确排序。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/3673e2df0fb1e7966668ee9c5839b7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*0vh0pzjCDa5umVqo7NHHVg.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">2 “bubbles” into place</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b347adbbe85f511b3c944be22b4e6b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*4Hu7-o8Yb0_xUv7GRY9lCQ.png"/></div></figure><h2 id="ce1c" class="lp lq in bd lx ly lz dn ma mb mc dp md kx me mf mg lb mh mi mj lf mk ml mm mn bi translated"><strong class="ak">第五遍</strong></h2><p id="59f5" class="pw-post-body-paragraph ko kp in kq b kr mo jo kt ku mp jr kw kx mq kz la lb mr ld le lf ms lh li lj ig bi translated">尽管此时数组已被正确排序，但算法仍会进行最后一次处理。这一次没有发生交换，一切正常。最终的数组正确排序为[1，2，3，4，7]。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/04a319365dcc78c81d473029de9b1670.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*WoQJvAqGK_6ngxAoL64PxA.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Final sorted array: [1, 2, 3, 4, 7]</figcaption></figure></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h2 id="6243" class="lp lq in bd lx ly lz dn ma mb mc dp md kx me mf mg lb mh mi mj lf mk ml mm mn bi translated"><strong class="ak">bubble sort的缺点</strong></h2><p id="af25" class="pw-post-body-paragraph ko kp in kq b kr mo jo kt ku mp jr kw kx mq kz la lb mr ld le lf ms lh li lj ig bi translated"><strong class="kq io">冒泡排序</strong>一次只考虑一个元素，费时低效。使用带有(n ) 的<strong class="kq io">大O符号的，对于大型数组来说效率非常低。</strong></p><p id="6ef4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要了解更多关于大O符号的知识，请查看我最近的博客文章<a class="ae nj" href="https://levelup.gitconnected.com/counting-stars-86a168c9d14d" rel="noopener ugc nofollow" target="_blank">数星星:使用大O分析编写高效代码</a>。</p><h2 id="d206" class="lp lq in bd lx ly lz dn ma mb mc dp md kx me mf mg lb mh mi mj lf mk ml mm mn bi translated">参考</h2><p id="8d21" class="pw-post-body-paragraph ko kp in kq b kr mo jo kt ku mp jr kw kx mq kz la lb mr ld le lf ms lh li lj ig bi translated"><a class="ae nj" href="https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/visualize/" rel="noopener ugc nofollow" target="_blank">https://www . hackere earth . com/practice/algorithms/sorting/bubble-sort/visualize/</a></p><div class="nk nl gp gr nm nn"><a href="https://visualgo.net/en/sorting" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">VisuAlgo -排序(冒泡、选择、插入、合并、快速、计数、基数)</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">排序是一个非常经典的重新排序项目的问题(可以比较，例如整数，浮点数…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">visualgo.net</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ki nn"/></div></div></a></div><p id="c109" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="oc">详见</em><a class="ae nj" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="oc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>