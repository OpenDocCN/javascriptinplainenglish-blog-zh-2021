<html>
<head>
<title>Replace Redux with useReducer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用useReducer替换Redux</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/replace-redux-with-usereducer-100406773332?source=collection_archive---------5-----------------------#2021-03-10">https://javascript.plainenglish.io/replace-redux-with-usereducer-100406773332?source=collection_archive---------5-----------------------#2021-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/284c61dca179ccb78be5946b4d1d823e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pRS2vZ1R86w7DwK_"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pankaj Patel</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="58fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Redux曾经是我管理全局应用程序状态的首选。我喜欢它的简单性，它周围的社区，令人敬畏的开发者工具。然而，我也喜欢让我的应用程序的依赖性最小化。有了<a class="ae jz" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>和钩子(更具体地说<a class="ae jz" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank"> useContext </a>和<a class="ae jz" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> useReducer </a>，我们可以很容易地用已经内置的react工具替换<em class="ky"> basic </em> Redux。在这样做的时候，我们仍然可以对我们已经知道的概念进行操作，如<em class="ky">动作</em>、<em class="ky">状态</em>或<em class="ky">减少功能</em>。</p><h1 id="a437" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">减少功能</strong></h1><p id="0c62" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">让我们从写一个reduce函数开始。提醒一下，reducer函数接受现有的状态和动作，并返回新的状态。我们将使用TypeScript来避免与类型相关的错误，并提供更好的开发人员体验。示例缩减器指定了两个动作:</p><ul class=""><li id="3d88" class="mc md in kc b kd ke kh ki kl me kp mf kt mg kx mh mi mj mk bi translated"><code class="fe ml mm mn mo b">ADD_TOOD</code> <em class="ky"> </em>向列表中添加新的待办事项</li><li id="10c2" class="mc md in kc b kd mp kh mq kl mr kp ms kt mt kx mh mi mj mk bi translated"><code class="fe ml mm mn mo b">TOGGLE_TODO</code>这将切换特定待办事项的已完成属性</li></ul><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="13d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用<a class="ae jz" href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#discriminating-unions" rel="noopener ugc nofollow" target="_blank">区别联合</a>来输入所有可能的动作。这非常有用，请注意TypeScript如何能够在reduce函数中适当缩小操作类型。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/b2f6400956fb14fca3ff3a29d6f785ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9lCA-cl58y5-tGV3G_h9tQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">It’s not just an Action, it’s AddTodoAction!</figcaption></figure><p id="75cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经准备好了reduce函数，让我们用<code class="fe ml mm mn mo b">useReducer</code>钩子把它包起来。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="0b3e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">语境</h1><p id="71eb" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">为了在应用程序中访问redux store，通常使用<a class="ae jz" href="https://react-redux.js.org/api/provider" rel="noopener ugc nofollow" target="_blank">提供者</a>组件。在我们的例子中，我们将用我们自己的上下文(实际上是两个上下文)来替换它。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9c9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们来分析一下上面的代码。<code class="fe ml mm mn mo b">useAppReducer</code>返回<code class="fe ml mm mn mo b">state</code>和<code class="fe ml mm mn mo b">dispatch</code>功能(就像普通的<code class="fe ml mm mn mo b">useReducer</code>钩子一样)。我们将使用一个上下文来提供<code class="fe ml mm mn mo b">state</code>，使用另一个上下文来提供<code class="fe ml mm mn mo b">dispatch</code>。这是一种性能优化，每次上下文值发生变化时，订阅该上下文的所有组件都会重新呈现。当<code class="fe ml mm mn mo b">state</code>改变时，只对分派事件感兴趣的组件不应该重新呈现，这就是引入这种分离的原因。</p><p id="30b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，我使用了<a class="ae jz" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype" rel="noopener ugc nofollow" target="_blank"> ReturnType </a>助手来从<code class="fe ml mm mn mo b">useAppReducer </code>中提取返回类型，并使用它们来键入上下文的值。你很快就会明白为什么这很重要。</p><p id="84c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我创建了两个自定义钩子，用于从上下文访问<code class="fe ml mm mn mo b">state</code>和<code class="fe ml mm mn mo b">dispatch</code>函数。在<code class="fe ml mm mn mo b">ctx</code>为null的情况下，我抛出一个错误(这意味着上下文提供者没有被呈现，在这种情况下，我只想快速失败)。注意TypeScript如何正确地推断我的自定义钩子的返回类型。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/0af32611f1f0784fd734fd0d03154821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYUR_VH8nxjosBOqiny8UQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">state type</figcaption></figure><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/c4019b61b96aaf299ecb90b5f590deab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0f7In2wd5n5ZCdOMVTorEA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">dispatch type</figcaption></figure><h1 id="d863" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">装上电线</h1><p id="2322" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">因此，为了使应用程序商店在全球范围内可用，我将它包装在整个应用程序中。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b901" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是应用程序组件的样子</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f13f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，<code class="fe ml mm mn mo b">dispatch</code>函数是完全类型化的，这意味着我已经自动完成了动作名和它的有效载荷。而且，这意味着我不需要像<code class="fe ml mm mn mo b">TODO_ACTIONS.ADD_TODO</code>这样丑陋的(至少在我看来)常量。TypeScript已经解决了这个问题，所以不可能调度一个不存在的动作。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/709a1525d73cb2a336f39b6f26e684eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*ZgbQVY6sZNRJvCUAxVnHEw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">I love when autocompletion just works</figcaption></figure><p id="4ada" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果提供了无效的操作名称或有效负载，我们会得到一个错误</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8853b012b39c299fd51819bcf1f50467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*JlZDPhDY_J5KWsa8h21ynA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">it must be a string</figcaption></figure><p id="a1c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然<code class="fe ml mm mn mo b">state</code>也是完全类型化的。</p><h1 id="79b0" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="13df" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">就这样了！如您所见，从头开始创建一个简单的类似redux的状态管理解决方案并不困难。谁知道呢，也许你的下一个React项目不需要<code class="fe ml mm mn mo b">redux</code>？</p></div></div>    
</body>
</html>