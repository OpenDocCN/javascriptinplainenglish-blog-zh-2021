<html>
<head>
<title>JavaScript Execution Context: Behind the Scenes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript执行上下文:幕后</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-execution-context-behind-the-scenes-1463a0ef3dd8?source=collection_archive---------12-----------------------#2021-08-20">https://javascript.plainenglish.io/javascript-execution-context-behind-the-scenes-1463a0ef3dd8?source=collection_archive---------12-----------------------#2021-08-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8d46" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中“执行上下文”的初学者友好指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6249918991d844f7000a73844195ae3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ahbWjp_g9hqhaTDSJOL1Q.png"/></div></div></figure><p id="7dda" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在继续利用一项技术创建项目之前，最好先掌握这项技术。当我在使用React时，我遇到过无法找出为什么一个组件没有像预期的那样运行的情况。经过几个小时的调试，浏览了一系列博客文章和StackOverflow线程，我对JavaScript如何在幕后处理事情有了新的了解。从那以后，我一直在深入挖掘类似的话题，并将所有这些信息整理成一系列博客文章。</p><p id="84de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这篇文章将主要关注JS文件是如何在浏览器中执行的。我会尽量让它简单易懂。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><p id="e088" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lr">注:我也曾在一段视频中悲惨地试图用</em><strong class="kq io"><em class="lr"/></strong><em class="lr">来解释这一点。可以在这里</em>  <em class="lr">看完</em> <a class="ae ls" href="https://youtu.be/_FjKFCVR4QA" rel="noopener ugc nofollow" target="_blank"> <em class="lr">。</em></a></p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="8578" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">JavaScript执行上下文</h1><p id="5b16" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">为了理解JavaScript文件是如何执行的，我们需要知道什么是“<strong class="kq io">执行上下文</strong>”。简单地说，它是为代码块及其依赖项创建的环境。JavaScript引擎查看一段代码，检查它需要执行的所有资源，然后将它们打包到一个块中。这个块是为这段代码创建的执行上下文。一个脚本中可能有几个这样的执行上下文。让我们看一个例子来更好地理解它。</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="f8ee" class="mv lu in mr b gy mw mx l my mz">1. let greeting = "Hello";<br/>2. const greetUser = (name) =&gt; {<br/>3.    console.log(greeting + name); <br/>4. }<br/>5. greetUser("Jim");  // "Hello Jim"</span></pre><p id="d441" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">上面的例子是一个简单的函数，它为特定的用户打印一个问候。当在第5行调用该函数时，会为此函数创建一个执行上下文。这个上下文充当一个具有一组资源的"<strong class="kq io">封闭环境"</strong>-在本例中，变量<strong class="kq io">name</strong>&amp;<strong class="kq io">greeting</strong>。</p><p id="ecdd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个上下文<strong class="kq io">中<strong class="kq io">创建的资源(变量、参数、函数)将不会</strong>成为其他执行上下文的一部分。尽管在上下文范围之外创建的任何东西都可以在上下文内部访问。所以如果你看上面的例子，函数"<strong class="kq io"> greetUser " </strong>"将有它自己的执行上下文，将能够访问<strong class="kq io"> greeting </strong>变量，它是外部执行上下文的一部分。不要担心，一旦我们在本文后面看到一个可视化的例子，这将变得更有意义。</strong></p><h2 id="dbe7" class="mv lu in bd lv na nb dn lz nc nd dp md kx ne nf mf lb ng nh mh lf ni nj mj nk bi translated">执行上下文的类型</h2><p id="9311" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">主要有两种执行上下文。<br/> - <strong class="kq io">全局执行上下文(GEC) </strong> <br/> - <strong class="kq io">函数执行上下文(FEC) <br/> </strong>我们前面看到的那个，是函数执行上下文。让我们看一下全局执行上下文。</p><p id="be3f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">全局执行上下文(GEC) </strong>非常类似于函数执行上下文。当您在浏览器上运行脚本时，在任何代码执行之前发生的第一件事就是创建一个GEC。这个GEC将有两个默认属性，<strong class="kq io">窗口对象</strong>和名为<strong class="kq io"> this的变量。</strong>在GEC的例子中，窗口对象和<strong class="kq io">这个</strong>本质上具有相同的值。如果您正在桌面上阅读这篇文章，您可以打开您的开发工具控制台，亲自检查一下。“<strong class="kq io"> this </strong>和window对象的值将是相同的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/22daf87be77e41c7edfb45dc25302f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQKeXc-DlpDls_qK6KNK2w.png"/></div></div></figure><p id="0672" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在FEC的情况下，“<strong class="kq io"> this </strong>”的值根据创建执行上下文的范围而改变。</p><h2 id="2c6a" class="mv lu in bd lv na nb dn lz nc nd dp md kx ne nf mf lb ng nh mh lf ni nj mj nk bi translated">执行上下文的生命周期</h2><p id="ba68" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">一个执行上下文通常有两个阶段。<br/> - <strong class="kq io">创作阶段</strong>-<br/>-<strong class="kq io">执行阶段</strong>。GEC和FEC的创建阶段几乎相似，只有一些小的不同。下表突出了这些差异。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/c8a862001d199b45c7beb36c8c11b699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmnGiwG44P1i_AWgQrK3Yw.png"/></div></div></figure><p id="474a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦创建阶段完成，执行阶段开始。同样，GEC和FEC在执行阶段有细微的差别。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/61c77a75bbfdd6a56a206345f1789118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MhR6VnAL8Hu-tfy1hQZ-Q.png"/></div></div></figure><p id="c02e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们演练一个例子，看看这是如何工作的。我们将在示例中引用这段代码。</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="da6a" class="mv lu in mr b gy mw mx l my mz">1. let fruit = "Apple";<br/>2. function eatFruit(kid) {<br/>3.    console.log(`${kid} ate the ${fruit}");<br/>4. }<br/>5. eatFruit("Jim");</span></pre><p id="fa48" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">步骤1: </strong>创建一个全局执行上下文。这个上下文将有一个<strong class="kq io">窗口</strong>对象。它还有一个指向窗口对象的变量。JS引擎遍历脚本，寻找变量和函数。我们有1个全局变量，<strong class="kq io">水果</strong>。该变量被赋予一个未定义的值<strong class="kq io"/>。“<strong class="kq io"> eatFruit </strong>”的函数声明按原样放入内存。至此，GEC的创作阶段告一段落。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/3156c088dbc8b2ca040633ed0b44848b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvUNcSjPG56lx1XYjQOTfw.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Step 1</figcaption></figure><p id="1a2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">第二步:</strong>一旦创建阶段完成，执行阶段就开始了。先前分配给<strong class="kq io">未定义</strong>的全局变量<strong class="kq io"> fruit </strong>现在被分配给它的实际值，即“<strong class="kq io"> Apple </strong>”。当我们到达第5行时，我们调用函数“<strong class="kq io">eat fruit”</strong>。调用函数导致<strong class="kq io">函数执行上下文</strong>的创建。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/d91f36805772b08520ee138a0cff7b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_tWYRhKsAoskrHfmAJIFA.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Step 2</figcaption></figure><p id="1e04" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">步骤3: </strong>现在，该FEC将进入其自己的创建阶段。”<strong class="kq io">这个“T3”指着窗外。因为这是一个FEC，我们将有一个<strong class="kq io"> arguments </strong>对象来跟踪传递给函数的参数。在我们的例子中确实有一个参数，<strong class="kq io"> kid </strong>，所以我们将为它分配内存，并将其设置为<strong class="kq io"> undefined。</strong></strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/9ac61ae820c473ac38d099e3a4de6914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FSZ_K-UPjAjeq_p68D0uQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Step 3</figcaption></figure><p id="4296" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">第4步:</strong>在创建阶段<strong class="kq io">之后，</strong>变量<strong class="kq io"> kid </strong>被赋予实际值，该值将是“<strong class="kq io"> Jim </strong>”。该函数现在得到执行，并在控制台中打印一条消息。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/c3dda2010e44e0bd10b59197057cf96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5CKsK-WM6O4czElVxK0-Q.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Step 4</figcaption></figure><p id="a783" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">步骤5: </strong>一旦执行完成，它将从执行堆栈中移除。由于全局执行也在“<strong class="kq io">eat fruit”</strong>之后完成，GEC也从堆栈中弹出，脚本执行结束。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/54720137dfda2f4ec36ed6c44c99db53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUzILIxnDGwec5jPyMKfIg.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Step 5</figcaption></figure><p id="0ae8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是JavaScript文件在浏览器中执行的基本方式。如果您正在开发一个nodeJs应用程序，那么这个流程与传统的基于浏览器的Js文件没有什么不同。我将在另一篇文章中介绍它。</p><p id="fd16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我希望这对你有所帮助。如果您有任何疑问，请随时发表评论。如前所述，我将发布更多的文章，涵盖类似的高级JavaScript概念，敬请关注。干杯！</p><p id="5f84" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae ls" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae ls" href="https://twitter.com/themangalorian" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae ls" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">Github</a></p><p id="6f5f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lr">更多内容请看</em><a class="ae ls" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>