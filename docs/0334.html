<html>
<head>
<title>How to cancel an HTTP fetch request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何取消HTTP获取请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-cancel-an-http-fetch-request-37bb937d8d14?source=collection_archive---------13-----------------------#2021-01-19">https://javascript.plainenglish.io/how-to-cancel-an-http-fetch-request-37bb937d8d14?source=collection_archive---------13-----------------------#2021-01-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2475de33df630abfc2400930d5b73732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vgIqaIyon5D3_ZRO.jpg"/></div></div></figure><p id="4b5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript承诺是该语言中异步编码的巨大催化剂。他们极大地改善了web开发的性能和体验。native promises的一个缺点是，一旦发起了HTTP fetch请求，我们就不能取消它。但是现在有一种方法可以做到这一点。</p><p id="d093" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">DOM标准中添加了一个名为AbortController的新控制器，允许我们将它用作取消HTTP获取请求的信号。它利用AbortSignal属性来实现这一点。</p><p id="1674" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它是在2017年添加的，在大多数浏览器中都受支持(显然IE除外)。但是现在IE支持很快就要结束了，这可能是一件大事。</p><h1 id="95fa" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么我们需要取消一个HTTP获取请求？</h1><p id="35e0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在我们进入how-to部分之前，让我们先看看为什么我们需要取消一个HTTP fetch请求。</p><p id="ee7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们有一个由多个组件组成的应用程序，这些组件可以动态地添加到DOM树中或者从DOM树中移除时，许多组件必然会发出HTTP请求。并且有可能在获取请求完成之前这些组件中的一个被卸载。在网速较慢的情况下，或者用户在页面间跳跃时，这种情况很常见。</p><p id="9dd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为fetch请求是异步的，所以它将继续在后台执行，如果处理不当，当它完成时可能会导致一些错误。</p><p id="aa7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Chrome的默认获取超时是300秒，Firefox是90秒。在网络条件不可靠的情况下，这远远超过了用户希望等待的时间。因此，如果需要的话，我们肯定希望实现我们自己的方法来取消HTTP获取请求。</p><h1 id="6eda" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">中止控制器和中止信号</h1><p id="e71b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">AbortController和AbortSignal API是由<a class="ae lw" href="https://dom.spec.whatwg.org/#aborting-ongoing-activities" rel="noopener ugc nofollow" target="_blank"> DOM标准</a>提供的，并且保持了通用性，以便它们可以被其他web标准使用。要声明控制器:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="cca7" class="mg ku in mc b gy mh mi l mj mk">const controller = new AbortController();</span></pre><p id="e6d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于信号:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a9c0" class="mg ku in mc b gy mh mi l mj mk">const signal = controller.signal;</span></pre><p id="f739" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">控制器只有一种中止方法。当它被调用时，信号会得到通知。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6938" class="mg ku in mc b gy mh mi l mj mk">controller.abort();<br/>signal.addEventListener('abort', () =&gt; {<br/>  console.log(signal.aborted); // true<br/>});</span></pre><h1 id="b768" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何中止HTTP获取请求？</h1><p id="37d8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">fetch API本身不允许以编程方式取消请求。但是它可以接受AbortSignal作为参数。然后，如果我们愿意，我们可以在特定的持续时间后中止获取请求。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9fd4" class="mg ku in mc b gy mh mi l mj mk">const controller = new AbortController();<br/>const signal = controller.signal;<br/><br/>fetch(url, { signal })<br/>  .catch(err =&gt; {<br/>    if (err.name === 'AbortError') {<br/>      console.log('Fetch was aborted');<br/>    }<br/>  });<br/><br/><br/>// Abort the request after 4s<br/>// aborts the fetch with 'AbortError'<br/>setTimeout(() =&gt; {<br/>  controller.abort();<br/>}, 4000);</span></pre><p id="c756" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果需要，我们甚至可以创建自己的超时获取调用包装器:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="83e6" class="mg ku in mc b gy mh mi l mj mk">async function cancellableFetch(url, data, timeout = 4000) {<br/>  const controller = new AbortController();<br/>  const timer = setTimeout(() =&gt; controller.abort(), timeout);<br/><br/>  const response = await fetch(url, {<br/>    ...data,<br/>    signal: controller.signal  <br/>  });<br/>  clearTimeout(timer);<br/><br/>  return response;<br/>}</span></pre><p id="63a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意一些事情:</p><ul class=""><li id="e25b" class="ml mm in jx b jy jz kc kd kg mn kk mo ko mp ks mq mr ms mt bi translated">如果您将同一个信号传递给多个fetch调用，它会在abort上取消所有带有该信号的请求。因此，如果有多个请求需要在一个失败时中止，我们可以使用它。</li><li id="a11b" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">由于控制器不可重用，如果我们不想在取消HTTP获取请求时中止所有获取，我们需要为所有获取创建一个新的控制器实例。</li><li id="b084" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">请求仅在客户端被中止。尽管客户端不会收到响应，但服务器可能仍然会处理它。</li><li id="ffcc" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">我们也可以使用Promise.race来实现这个功能，但是这个解决方案会让请求挂起，而不是中止请求。它会在后台继续消耗带宽。</li></ul><p id="c201" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是如何在超时后取消HTTP获取请求，或者以编程方式中止它。我很兴奋能够这样做，希望你也是。如果你打算使用这个，请在评论区告诉我。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="5855" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ng">原载于2021年1月19日</em><a class="ae lw" href="https://www.wisdomgeek.com/development/web-development/javascript/how-to-cancel-http-fetch-request/" rel="noopener ugc nofollow" target="_blank"><em class="ng">【https://www.wisdomgeek.com】</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>