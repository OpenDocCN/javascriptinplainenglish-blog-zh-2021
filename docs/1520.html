<html>
<head>
<title>React App Routing with Wouter — Active Links, Trailing Slash, and Nested Paths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Wouter活动链接、尾随斜线和嵌套路径反应应用程序路由</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-app-routing-with-wouter-active-links-trailing-slash-and-nested-paths-d13856a930a?source=collection_archive---------14-----------------------#2021-03-31">https://javascript.plainenglish.io/react-app-routing-with-wouter-active-links-trailing-slash-and-nested-paths-d13856a930a?source=collection_archive---------14-----------------------#2021-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/975f0081dd77e34b5799796ae1fc6ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xWht_UZ7m-5b-Pxi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@martysouthwell?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marty Southwell</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0c1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Wouter是一个库，允许我们根据URL加载React组件。</p><p id="e1a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何使用Wouter向React应用程序添加路由。</p><h1 id="60b9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">活动链接</h1><p id="222d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过检查从<code class="fe me mf mg mh b">useRoute</code>属性返回的<code class="fe me mf mg mh b">isActive</code>变量来设置活动链接。</p><p id="4803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cdf9" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import { Link, Route, Router, useRoute } from "wouter";</span><span id="8e3c" class="mq lc iq mh b gy mv ms l mt mu">const InboxPage = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;inbox&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="ff17" class="mq lc iq mh b gy mv ms l mt mu">const UserPage = () =&gt; {<br/>  const [, params] = useRoute("/users/:name");<br/>  return &lt;div&gt;Hello, {params.name}!&lt;/div&gt;;<br/>};</span><span id="c2e7" class="mq lc iq mh b gy mv ms l mt mu">const ActiveLink = (props) =&gt; {<br/>  const [isActive] = useRoute(props.href);</span><span id="1c00" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;Link {...props}&gt;<br/>      &lt;a className={isActive ? "active" : ""}&gt;{props.children}&lt;/a&gt;<br/>    &lt;/Link&gt;<br/>  );<br/>};</span><span id="faed" class="mq lc iq mh b gy mv ms l mt mu">export default function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;style&gt;<br/>        {`.active {<br/>            font-weight: bold<br/>          }`}<br/>      &lt;/style&gt;<br/>      &lt;Router&gt;<br/>        &lt;ActiveLink href="/users/foo"&gt;Users&lt;/ActiveLink&gt;<br/>        &lt;ActiveLink href="/about"&gt;About&lt;/ActiveLink&gt;<br/>        &lt;Route path="/about"&gt;<br/>          &lt;p&gt;About Us&lt;/p&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route path="/users/:name" component={UserPage}&gt;&lt;/Route&gt;<br/>        &lt;Route path="/inbox" component={InboxPage} /&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="3229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">ActiveLink</code>组件，它用当前URL调用<code class="fe me mf mg mh b">useRoute</code>钩子，并返回一个带有<code class="fe me mf mg mh b">isActive</code>变量的数组。</p><p id="e048" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">isActive</code>为<code class="fe me mf mg mh b">true</code>表示当前URL的链接处于活动状态。</p><h1 id="5abb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">尾随斜线</h1><p id="adfc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用自定义的URL匹配器让Wouter匹配一个带斜杠的路由。</p><p id="9f72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4efb" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import { Route, Router } from "wouter";<br/>import makeMatcher from "wouter/matcher";<br/>import { pathToRegexp } from "path-to-regexp";</span><span id="47cd" class="mq lc iq mh b gy mv ms l mt mu">const customMatcher = makeMatcher((path) =&gt; {<br/>  let keys = [];<br/>  const regexp = pathToRegexp(path, keys, { strict: true });<br/>  return { keys, regexp };<br/>});</span><span id="b4da" class="mq lc iq mh b gy mv ms l mt mu">export default function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Router matcher={customMatcher}&gt;<br/>        &lt;Route path="/foo"&gt;foo&lt;/Route&gt;<br/>        &lt;Route path="/foo/"&gt;/foo/&lt;/Route&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="f3c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用回调函数调用<code class="fe me mf mg mh b">makeMatcher</code>来返回一个对象，该对象的<code class="fe me mf mg mh b">strict</code>设置为<code class="fe me mf mg mh b">true</code>。</p><p id="fac3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将确保带结尾和不带结尾但其他方面相同的URL被视为不同。</p><h1 id="4e9e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">嵌套路径</h1><p id="f034" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过设置基本路径来添加嵌套路径。</p><p id="79ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e93a" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import { Link, Route, Router, useLocation, useRouter } from "wouter";</span><span id="03fd" class="mq lc iq mh b gy mv ms l mt mu">const NestedRoutes = (props) =&gt; {<br/>  const router = useRouter();<br/>  const [parentLocation] = useLocation();</span><span id="3142" class="mq lc iq mh b gy mv ms l mt mu">  const nestedBase = `${router.base}${props.base}`;<br/>  if (!parentLocation.startsWith(nestedBase)) return null;</span><span id="d9e8" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;Router base={nestedBase} key={nestedBase}&gt;<br/>      {props.children}<br/>    &lt;/Router&gt;<br/>  );<br/>};</span><span id="5a31" class="mq lc iq mh b gy mv ms l mt mu">export default function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Router&gt;<br/>        &lt;Route path="/about"&gt;about&lt;/Route&gt;<br/>        &lt;NestedRoutes base="/dashboard"&gt;<br/>          &lt;Link to="/users" /&gt;<br/>          &lt;Route path="/users"&gt;users&lt;/Route&gt;<br/>        &lt;/NestedRoutes&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="bd62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了使用<code class="fe me mf mg mh b">base</code>属性来设置基本路径的<code class="fe me mf mg mh b">NestedRoutes</code>组件。</p><p id="9e14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此基础上，我们通过组合<code class="fe me mf mg mh b">router.base</code>和<code class="fe me mf mg mh b">props.base</code>来创建基本路径，从而创建了<code class="fe me mf mg mh b">nestedBase</code>变量。</p><p id="df62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe me mf mg mh b">base</code>属性的值设置为<code class="fe me mf mg mh b">nestedBase</code>来设置嵌套路由的基本路径。</p><h1 id="c509" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3cdc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以检查哪个链接是活动的，添加尾部斜杠匹配，以及带有Wouter的嵌套路径。</p><p id="0f5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>