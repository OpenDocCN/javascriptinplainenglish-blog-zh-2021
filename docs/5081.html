<html>
<head>
<title>Build a Composable Sorting Control with Custom React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用自定义的React钩子构建一个可组合的排序控件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-composable-sorting-control-with-custom-react-hooks-2d82397bc5b1?source=collection_archive---------3-----------------------#2021-10-15">https://javascript.plainenglish.io/build-a-composable-sorting-control-with-custom-react-hooks-2d82397bc5b1?source=collection_archive---------3-----------------------#2021-10-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/438cb64fa8ccacb315d9bf50df1b7a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2arZsZQNA8eaYZrqoa6VDQ.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">sort of unrelated (by the author)</figcaption></figure><div class=""/><div class=""><h2 id="7a5d" class="pw-subtitle-paragraph jz jb jc bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用从视图组件中提取的状态和逻辑对列表进行排序</h2></div></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="066a" class="ky kz jc bd la lb lc ld le lf lg lh li ki lj kj lk kl ll km lm ko ln kp lo lp bi translated">背景</h1><p id="972e" class="pw-post-body-paragraph lq lr jc ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml ig bi translated">大多数web应用程序需要以某种形式的列表显示数据，对数据进行排序是用户友好列表的基本特性之一。使用<a class="ae mm" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>，我们可以很容易地将状态和逻辑从相关的视图组件中分离出来。</p><p id="1822" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">自从几年前发布钩子<a class="ae mm" href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html" rel="noopener ugc nofollow" target="_blank"/>以来，React库变得(甚至)更容易使用。钩子实现了客户端逻辑的清晰抽象，特别是在UI组件状态、渲染生命周期和用户交互等副作用方面。</p><p id="c367" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">与早期的反应组件的OOP方法相反，在早期的OOP方法中，组件逻辑被绑定到类方法，钩子允许代码的抽象和重用，以实现更具功能性的方法。</p><h2 id="feb3" class="ms kz jc bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">问:很好，但是为什么要开发自己的表库呢，因为您可以使用现有的包含排序和更多功能的万能表库。</h2><h2 id="1e18" class="ms kz jc bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">答:在大多数情况下，你可能应该这样做</h2><p id="4af8" class="pw-post-body-paragraph lq lr jc ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml ig bi translated">数据表或列表库，尤其是那些有活跃贡献者社区的库，比如<a class="ae mm" href="https://react-table.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> react-table </a>，通常会公开排序、分页和样式的所有重要属性；允许开发人员快速配置任何列表特性。</p><h2 id="d98c" class="ms kz jc bd la mt mu dn le mv mw dp li lz mx my lk md mz na lm mh nb nc lo nd bi translated">*然而，有足够的理由编写自己的排序实现或任何其他功能</h2><p id="d8de" class="pw-post-body-paragraph lq lr jc ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml ig bi translated">例如:</p><ul class=""><li id="028d" class="ne nf jc ls b lt mn lw mo lz ng md nh mh ni ml nj nk nl nm bi translated"><strong class="ls jd">没有两个用户界面是相同的</strong>:并非所有的数据都能在传统表格中得到最好的显示:虽然大多数数据表库在数据管理以及列、行和单元格呈现器的布局方面提供了灵活性，但您可能<em class="nn">仍然</em>需要一种更独特的显示方式来满足您的预期用户体验。</li><li id="0c1e" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls jd">包的大小很重要</strong>:在许多项目中，所需的特性集是有限的，最干净的实现并不保证所有的样板代码和一个完整的、全能的库的大小:只编码我们从一个特定的功能中需要的东西允许我们决定到底有多少东西进入我们的应用程序。</li><li id="3394" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls jd">成长的烦恼伤害</strong>:一个应用程序，其特性最初可能被第三方库覆盖，但通常(几乎总是<em class="nn"/>)会扩大范围，导致重复、复合、丑陋的事情，如配置扭曲和特殊特性<em class="nn">，</em>，直到<em class="nn">最不坏的</em>解决方案是构建和维护一个定制的脚手架，以满足每一个连续的需求。</li><li id="644a" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls jd"> DIY让你成为更好的开发人员</strong>:不需要重新发明轮子，但是构建一个自主开发的功能所涉及的试验、错误、汗水、眼泪和咖啡因自然会为精确定制逻辑和UI/UX提供更多的自由。此外，从头开始推理，然后实际编写一个特性，可以提供对业务逻辑和代码实现的第一手理解，特别是当一个人厌倦了每晚熬夜，放弃了整个DIY策略(通常是因为有问题的项目已经过期)，然后不得不匆忙评估真正的库并确定最合适的库时。</li></ul></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="d5f7" class="ky kz jc bd la lb lc ld le lf lg lh li ki lj kj lk kl ll km lm ko ln kp lo lp bi translated">要求</h1><p id="2b82" class="pw-post-body-paragraph lq lr jc ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml ig bi translated">记住这些警告，我们将从头开始编写我们自己的排序组件实现。</p><p id="2e15" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">这个例子不会复制一个成熟的库的全部排序特性。相反，我们将通过满足几个基本标准来解决上述要点:</p><ul class=""><li id="c9d8" class="ne nf jc ls b lt mn lw mo lz ng md nh mh ni ml nj nk nl nm bi translated">我们的排序逻辑应该是可重用和可组合的，独立于视图组件而存在。</li><li id="e604" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls jd">我们的代码应该只处理<em class="nn">给定数据集的排序，而不会产生副作用或干扰数据集的其他逻辑，如过滤或分页。</em></strong></li><li id="8b71" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><strong class="ls jd">虽然不是必需的，但是我们将通过使用</strong><a class="ae mm" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ls jd">styled-components</strong></a><strong class="ls jd">和</strong><a class="ae mm" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ls jd">Typescript</strong></a><strong class="ls jd">，尽量使我们的视图组件的布局具有可读性和一致性。</strong></li></ul></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="3792" class="ky kz jc bd la lb lc ld le lf lg lh li ki lj kj lk kl ll km lm ko ln kp lo lp bi translated">示例代码</h1><p id="94ec" class="pw-post-body-paragraph lq lr jc ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml ig bi translated">这个例子的核心是排序状态和相关的逻辑，我们将把它们放在一个定制的React钩子<code class="fe nt nu nv nw b">useSort.ts</code>中，以保持它独立于显示组件。这没有太多的逻辑，但是我们将首先分解概念，然后展示整个脚本。</p><p id="dd78" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated"><strong class="ls jd">内置React钩子的局部状态和效果:</strong></p><figure class="nx ny nz oa gt ip"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="a208" class="ne nf jc ls b lt mn lw mo lz ng md nh mh ni ml nj nk nl nm bi translated">首先，我们用内置的<code class="fe nt nu nv nw b">React.useState</code>和<code class="fe nt nu nv nw b">React.useEffect</code>钩子设置本地状态和效果，允许我们跟踪特定于<code class="fe nt nu nv nw b">useSort</code>的每个实例的变化；这将从可能使用它的任意数量的视图组件中删除状态和效果逻辑。</li><li id="04e5" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">为了涵盖排序的基础知识，我们为一个<code class="fe nt nu nv nw b">sortKey</code>(在下面的<code class="fe nt nu nv nw b">SortingControl</code>)和一个<code class="fe nt nu nv nw b">sortDirection</code>(与一个向上/向下图标按钮一起使用)声明了getters和setters。</li><li id="33ad" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><code class="fe nt nu nv nw b">React.useEffect</code>内置钩子执行<code class="fe nt nu nv nw b">data</code>数组的实际排序，并在<code class="fe nt nu nv nw b">useSort</code>钩子的任何依赖关系改变时更新其内部状态值。重要的是，这里还调用了<code class="fe nt nu nv nw b">onSortChange</code>回调:当钩子更新它的内部<code class="fe nt nu nv nw b">data</code>值时，这个回调被提供给视图组件以引起它自己的重新呈现或相关效果。<br/> <em class="nn">更新(2022年10月)</em>:为了防止不必要的重新渲染，我们在调用<code class="fe nt nu nv nw b">onSortChange</code>之前，将排序后的数据与传递给钩子的本地值进行比较。</li></ul><p id="2d18" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated"><strong class="ls jd"> UI回调:</strong></p><figure class="nx ny nz oa gt ip"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="1727" class="ne nf jc ls b lt mn lw mo lz ng md nh mh ni ml nj nk nl nm bi translated">这些函数是为了在任何使用我们钩子的视图中可用而导出的回调函数。</li><li id="c2d5" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><code class="fe nt nu nv nw b">handleSortKeyChange</code>假设我们的按键出现在下面<code class="fe nt nu nv nw b">SortControl</code>中的选择控件中</li><li id="d565" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated"><code class="fe nt nu nv nw b">handleDirectionToggle</code>也显示在<code class="fe nt nu nv nw b">SortControl</code>中，在本例中仅支持升序和降序。</li><li id="f866" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">两者都用来更新钩子的内部状态，这将依次调用上面指定的<code class="fe nt nu nv nw b">onSortChange</code>，以便随后更新适用的视图。</li></ul><p id="0f04" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated"><strong class="ls jd">整体使用排序钩</strong></p><figure class="nx ny nz oa gt ip"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5e12" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated"><strong class="ls jd">类型</strong></p><p id="3551" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">既然挂钩已经设置好了，在深入研究视图组件之前，我们将设置我们的类型。我通常更喜欢先设置类型，尽管钩子本身是这个例子的关键部分。</p><figure class="nx ny nz oa gt ip"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="198e" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated"><strong class="ls jd">款式</strong></p><p id="3bc2" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">为了将样式包装到组件中以获得简洁的布局，下面是使用<code class="fe nt nu nv nw b">styled-components</code>声明的TSX(使用Typescript的JSX)构建块。该示例在CSS flexbox布局中使用扩展的<code class="fe nt nu nv nw b">&lt;div&gt;</code>元素，避免了通过实际的HTML表格进行布局的需要。</p><figure class="nx ny nz oa gt ip"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="40f9" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated"><strong class="ls jd">分类控制</strong></p><p id="a15d" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">为了提供一个用于排序操作的用户界面，这里有一个基本的<code class="fe nt nu nv nw b">SortControl</code>，它包括一个用于选择排序键的Select，以及一个用于将排序方向从升序切换到降序的基本图标。</p><p id="58b6" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">选择和图标当然是任意的UI选择:重要的联系是它们使用排序回调<code class="fe nt nu nv nw b">handleSortKeyChange</code>和<code class="fe nt nu nv nw b">handleDirectionToggle</code>，这是我们从自定义的<code class="fe nt nu nv nw b">useSort</code>钩子导出的。</p><p id="ed6a" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">为了完成这个逻辑，<code class="fe nt nu nv nw b">SortControl</code>在实例化<code class="fe nt nu nv nw b">useSort</code>钩子时，从它的选择控件传递<code class="fe nt nu nv nw b">data</code>、<code class="fe nt nu nv nw b">onSortChange</code>回调和<code class="fe nt nu nv nw b">sortOptions</code>。</p><figure class="nx ny nz oa gt ip"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9bc4" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated"><strong class="ls jd">功能布局</strong></p><p id="779b" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">最后，我们将布局我们的特性，包括在TSX节点中声明的<code class="fe nt nu nv nw b">SortControl</code>和我们的列表组件。</p><p id="2d46" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">我们可以迭代<code class="fe nt nu nv nw b">return()</code>语句中的所有内容，但是<code class="fe nt nu nv nw b">renderHeader()</code>和<code class="fe nt nu nv nw b">renderList/Item()</code>函数将视图的不同部分分开，以便于维护。</p><figure class="nx ny nz oa gt ip"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="555c" class="ky kz jc bd la lb lc ld le lf lg lh li ki lj kj lk kl ll km lm ko ln kp lo lp bi translated">结论</h1><p id="338a" class="pw-post-body-paragraph lq lr jc ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml ig bi translated">所以这不是很多实际的代码，但是这个练习的原则是我们已经创建了一个定制的钩子来将特性的排序状态和逻辑从视图中分离出来。</p><p id="c811" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated">这允许我们在一个或多个视图组件中独立地使用<code class="fe nt nu nv nw b">useSort</code>钩子。此外，带有自定义钩子回调的功能视图组件的策略使得我们的排序组件是可组合的，因此它可以很容易地与其他类似设计的特性配对，独立地作用于相同的数据集。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="2fa1" class="ky kz jc bd la lb lc ld le lf lg lh li ki lj kj lk kl ll km lm ko ln kp lo lp bi translated">资源</h1><ul class=""><li id="0592" class="ne nf jc ls b lt lu lw lx lz od md oe mh of ml nj nk nl nm bi translated">GitHub库:<br/>T13】https://github.com/fauteuil/react-data-sort-component</li><li id="e456" class="ne nf jc ls b lt no lw np lz nq md nr mh ns ml nj nk nl nm bi translated">codesandbox.io上的示例应用:<a class="ae mm" href="https://codesandbox.io/s/github/fauteuil/react-data-sort-component" rel="noopener ugc nofollow" target="_blank">https://code sandbox . io/s/github/fauteuil/react-data-sort-component</a></li></ul><p id="f13a" class="pw-post-body-paragraph lq lr jc ls b lt mn kd lv lw mo kg ly lz mp mb mc md mq mf mg mh mr mj mk ml ig bi translated"><em class="nn">更多内容请看</em><a class="ae mm" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ls jd"><em class="nn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>