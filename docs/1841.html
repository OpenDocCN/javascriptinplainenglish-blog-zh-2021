<html>
<head>
<title>How to Handle Redux Reducers in an Immutable and Declarative Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以不可变和声明的方式处理Redux Reducers</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-solve-the-problem-with-immutability-and-reducers-in-a-declarative-way-10274691b06c?source=collection_archive---------14-----------------------#2021-04-18">https://javascript.plainenglish.io/how-to-solve-the-problem-with-immutability-and-reducers-in-a-declarative-way-10274691b06c?source=collection_archive---------14-----------------------#2021-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9b53152b094062aa4947e83ff072fd9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ruozjggasSrZyW_z"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@mero_dnt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chinh Le Duc</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a4f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们都在Redux代码中编写了一个缩减器，它有十亿个扩展操作符。我们很高兴它能起作用，但是我们为它的冗长而感到难过。</p><p id="6ab8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将从《粉碎》杂志上的<a class="ae jz" href="https://www.smashingmagazine.com/2020/06/better-reducers-with-immer/" rel="noopener ugc nofollow" target="_blank">这篇</a>作者<a class="ae jz" href="https://www.smashingmagazine.com/author/chidi-orji/" rel="noopener ugc nofollow" target="_blank">希迪·奥尔吉</a>的文章中借用一个例子，来展示我所说的减速器类型，以防你有幸从未有机会在野外遇到这些怪物:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7ef7" class="lh li in ld b gy lj lk l ll lm">const updateReducer = (state = initState, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'ADD_PACKAGE':<br/>      return {<br/>        ...state,<br/>        packages: [...state.packages, action.package],<br/>      };<br/>    case 'UPDATE_INSTALLED':<br/>      return {<br/>        ...state,<br/>        packages: state.packages.map(pack =&gt;<br/>          pack.name === action.name<br/>            ? { ...pack, installed: action.installed }<br/>            : pack<br/>        ),<br/>      };<br/>    default:<br/>      return state;<br/>  }<br/>};</span></pre><p id="c5a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">老实说，这本书并没有那么糟糕:相信我，我看过和写过更糟糕的书！</p><p id="52a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么这里的问题到底是什么呢？好吧，如果我们想更新一个对象的属性，这个对象深深地嵌套在我们的状态树中，为了克隆当前状态并返回新状态，我们必须做大量的复制和传播工作。记住:reducers不应该执行副作用，因为它们应该是纯函数，所以最终我们不能改变状态对象，我们必须返回新的状态，因此是一个不同的对象(一个不同的引用)。</p><p id="bfed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就可读性和可维护性而言，过度使用spread操作符的问题是，我们没有表达任何关于状态如何更新的意图。我们只是四处复制东西，当我们到达我们想要更新的属性时，周围有很多代码，除了复制我们的状态树的结构之外没有任何用途。</p><h1 id="f99d" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">让事情具有宣示性</h1><p id="205e" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">嵌入在React中的函数式编程概念教会我们的一件事是，以声明的方式表达意图使我们的代码更容易理解。这对我们未来的自己和我们的同事来说更容易，因为我们写代码是为了让其他人阅读。如果这不重要，我们都会写汇编或字节码，高级编程语言就不会存在了。</p><p id="55bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，与其手动复制东西，然后试图找出我们编写的代码应该做什么，不如实际描述代码应该做什么。以声明方式做到这一点的最佳方式是使用函数。</p><p id="e057" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看<code class="fe mp mq mr ld b">'ADD_PACKAGE'</code>动作是如何更新我们前面例子中的状态的:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="3f44" class="lh li in ld b gy lj lk l ll lm">case 'ADD_PACKAGE':<br/>  return {<br/>    ...state,<br/>    packages: [...state.packages, action.package],<br/>  };</span></pre><p id="605b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很简单，对吧？因此，一个新值<em class="ms">将</em>关联到<code class="fe mp mq mr ld b">packages</code>属性，我们可以通过<em class="ms">向旧包列表添加</em>一个新包来获得这个新值。</p><p id="06a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，让我们定义一些函数来执行这些操作。首先，我们要定义一个<code class="fe mp mq mr ld b">assoc</code>函数:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0e8c" class="lh li in ld b gy lj lk l ll lm">const assoc = (key, value, record) =&gt; Object.assign(<br/>  {},<br/>  record,<br/>  { [key]: value }<br/>);</span></pre><p id="4d30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来是一个<code class="fe mp mq mr ld b">append</code>功能:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="43ac" class="lh li in ld b gy lj lk l ll lm">const append = (element, list) =&gt; [ ...list, element ];</span></pre><p id="7fcf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用这些函数来更新我们的状态:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="df32" class="lh li in ld b gy lj lk l ll lm">case 'ADD_PACKAGE’:<br/>  return <em class="ms">assoc</em>(<br/>    'packages’,<br/>    <em class="ms">append</em>(action.package, state.packages),<br/>    state<br/>  );</span></pre><p id="c066" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，对于一个简单的例子，好处并不明显。让我们试着用<code class="fe mp mq mr ld b">'UPDATE_INSTALLED'</code>行动:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="35ce" class="lh li in ld b gy lj lk l ll lm">case 'UPDATE_INSTALLED':<br/>  return {<br/>    ...state,<br/>    packages: state.packages.map(pack =&gt;<br/>      pack.name === action.name<br/>        ? { ...pack, installed: action.installed }<br/>        : pack<br/>    ),<br/>  };</span></pre><p id="f478" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，只有当包<code class="fe mp mq mr ld b">name</code>等于<code class="fe mp mq mr ld b">action.name</code>时，我们才希望<em class="ms">调整</em>(或者<em class="ms">关联</em>一个新值到)包的<code class="fe mp mq mr ld b">installed</code>属性。现在，我们仍然可以<em class="ms">映射</em>我们的包列表，但是这有点误导。当我们<em class="ms">映射</em>一个集合时，我们会认为集合中的所有值都将被转换，所以决定我们是否想要只更新一个元素不仅仅是映射，这是映射的一个特殊版本:我们正在进行选择性更新。</p><blockquote class="mt mu mv"><p id="8259" class="ka kb ms kc b kd ke kf kg kh ki kj kk mw km kn ko mx kq kr ks my ku kv kw kx ig bi translated"><em class="in">在我们的代码中有很多处理分支的方法:最简单的是使用</em> <code class="fe mp mq mr ld b"><em class="in">if</em></code> <em class="in">语句或表达式。尽管有更好的方法来处理条件性，如果条件性意味着行为的改变，我们真正需要的只是一个专门的行为。</em></p></blockquote><p id="f7bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，让我们创建一个专门的函数来更好地描述这种行为:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4f48" class="lh li in ld b gy lj lk l ll lm">const adjustByWhere = (adjustFn, selectFn, list) =&gt; {<br/>  return list.map((acc, item) =&gt; {<br/>    return selectFn(item) ? adjustFn(item) : item;<br/>  });<br/>};</span></pre><p id="2f15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我听到你说:<strong class="kc io">嘿，那和你在减速器里的东西一模一样！没错！这是同一件事，但它被抽象在一个名称下，这个名称真正描述了事情实际在做什么，这就是进行声明式编程的全部意义:让您的代码描述它做什么，而不是让我们每次读取它时都试图弄清楚它做什么。</strong></p><p id="bfbc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的操作如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8e9f" class="lh li in ld b gy lj lk l ll lm">case 'UPDATE_INSTALLED':<br/>  return <em class="ms">assoc</em>(<br/>    'packages’,<br/>    adjustByWhere(<br/>      package =&gt; <em class="ms">assoc</em>('installed', action.installed, package),<br/>      package =&gt; package.name === 'foo',<br/>      state.packages<br/>    ),<br/>    state<br/>  );</span></pre><p id="7946" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个解决方案远非完美，我们可以对API做一些改进，但想法是存在的:开始编写代码，告诉你正在做什么，而不是每次阅读时都必须弄清楚。</p><h1 id="7467" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">明摆着的难题</h1><blockquote class="mt mu mv"><p id="0b7e" class="ka kb ms kc b kd ke kf kg kh ki kj kk mw km kn ko mx kq kr ks my ku kv kw kx ig bi translated"><em class="in">如果我不提</em> <code class="fe mp mq mr ld b"><em class="in">Immer</em></code> <em class="in">我会觉得很不负责任，因为它出色地解决了这个问题。我将简要地谈论它，但是如果你想深入研究，请确保阅读文档。</em></p></blockquote><p id="a755" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr ld b">Immer</code>它的出现就像一个巨大的破坏球，为这个问题提供了另一种解决方案:它给你一个草稿，你可以直接更新，改变你想要的任何属性，而不是让你手动复制你的应用程序以前的状态来返回新的状态。在你完成交易后，它会用你修改的草稿不变地创建新的状态。如果你问我(或者如果你问任何人，这是一个聪明的想法)，这是非常整洁和聪明的。</p><p id="4dca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">前面的代码看起来像这样:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f464" class="lh li in ld b gy lj lk l ll lm">import { produce } from 'immer';</span><span id="92d1" class="lh li in ld b gy mz lk l ll lm">const updateReducer = (state = initState, action) =&gt;<br/>  produce(state, draft =&gt; {<br/>    switch (action.type) {<br/>      case 'ADD_PACKAGE': {<br/>        draft.packages.push(action.package);<br/>        break;<br/>      }<br/>      case 'UPDATE_INSTALLED': {<br/>        const package = draft.packages.find(p =&gt; p.name === action.name);<br/>        if (package) package.installed = action.installed;<br/>        break;<br/>      }<br/>      default: {<br/>        break;<br/>      }<br/>    }<br/>  });</span></pre><p id="bcc0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，这看起来简单多了。然而，这里有一个问题:当使用<code class="fe mp mq mr ld b">immer</code>时，我们必须遵循几个规则，因为这就是魔术的工作方式。</p><p id="88ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之:</p><ul class=""><li id="fd6a" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">您可以修改草稿或返回新对象。如果你两样都做了，地狱就会爆发。</li><li id="f26a" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">您不能为草稿指定不同的值。您可以更改草稿中的任何内容<em class="ms">，但不能更改草稿本身。</em></li></ul><p id="2da4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想进一步了解它，查看文档中的条目<a class="ae jz" href="https://immerjs.github.io/immer/return" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="62fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仅此而已。希望你喜欢阅读这篇文章。</p><p id="76f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ms">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ms">plain English . io</em></strong></a></p></div></div>    
</body>
</html>