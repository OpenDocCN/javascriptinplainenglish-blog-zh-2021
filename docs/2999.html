<html>
<head>
<title>Cognito via OAuth2 in NestJS: Outsourcing Authentication Without Vendor Lock-in</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NestJS中通过OAuth2的Cognito:无供应商锁定的外包认证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/cognito-via-oauth2-in-nestjs-outsourcing-authentication-without-vendor-lock-in-ce908518f547?source=collection_archive---------0-----------------------#2021-06-18">https://javascript.plainenglish.io/cognito-via-oauth2-in-nestjs-outsourcing-authentication-without-vendor-lock-in-ce908518f547?source=collection_archive---------0-----------------------#2021-06-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1239" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">认证是复杂的，如果能外包就太好了。但我也想避免被锁在里面。我可以鱼与熊掌兼得吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2da4b1cec34db3182213e6c3025f42c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*SUAnE-TxOIOGATM5tHMpvg.png"/></div></figure><p id="c78c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TLDR；是啊！在<a class="ae kq" href="https://github.com/thisismydesign/nestjs-starter" rel="noopener ugc nofollow" target="_blank">nestjs-starter repo</a>中，我通过OAuth2使用Cognito及其托管UI，同时将所有用户数据保存在我的应用程序中。所以大部分认证的复杂性被外包给一个现成的解决方案(价格<a class="ae kq" href="https://aws.amazon.com/cognito/pricing/" rel="noopener ugc nofollow" target="_blank">可能是最低的</a>，我可以随时替换这个策略，例如通过<a class="ae kq" href="https://csaba-apagyi.medium.com/oauth2-in-nestjs-for-social-login-google-facebook-twitter-etc-8b405d570fd2" rel="noopener">直接实现社交登录</a>。</p><p id="a027" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这种方式，我可以以集成一个OAuth2提供商为代价，获得许多身份验证策略(密码、谷歌、脸书等)。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><p id="ec89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kq" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-app-integration.html" rel="noopener ugc nofollow" target="_blank"> Setup Cognito </a>:创建用户池，App客户端，配置托管UI。将配置添加到<code class="fe ky kz la lb b">.env</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="627f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们将使用<code class="fe ky kz la lb b">passport-oauth2</code>，一个通用的OAuth2策略来与Cognito集成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="a548" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">需要记住的唯一技巧是，在这个通用策略中，<code class="fe ky kz la lb b">id_token</code>没有暴露给<code class="fe ky kz la lb b">validate</code>方法，因此我们需要进行一个额外的调用。</p><p id="56f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是基本的认知整合！要使这成为一个完整的身份验证流程，还需要两个步骤:</p><ul class=""><li id="050e" class="le lf in jm b jn jo jr js jv lg jz lh kd li kh lj lk ll lm bi translated">在重定向端点中发布JWT令牌，以便我们可以在应用程序中处理用户会话。你可以在我的<a class="ae kq" href="https://csaba-apagyi.medium.com/oauth2-in-nestjs-for-social-login-google-facebook-twitter-etc-8b405d570fd2" rel="noopener">oauth 2 in NestJS for social log in</a>文章中看到如何做。</li><li id="256d" class="le lf in jm b jn ln jr lo jv lp jz lq kd lr kh lj lk ll lm bi translated">在<code class="fe ky kz la lb b">validate</code>回调中查找或存储用户数据。我在<a class="ae kq" href="https://github.com/thisismydesign/nestjs-starter" rel="noopener ugc nofollow" target="_blank"> nestjs-starter </a> repo中使用一个带有TypeORM存储库的数据库。你也可以从<a class="ae kq" href="https://docs.nestjs.com/techniques/database" rel="noopener ugc nofollow" target="_blank">官方文件</a>中了解更多。</li></ul></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><p id="618e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，这是一种外包身份验证复杂性的方法，而不会被提供商锁定！你会在回购协议(<a class="ae kq" href="https://github.com/thisismydesign/nestjs-starter" rel="noopener ugc nofollow" target="_blank">https://github.com/thisismydesign/nestjs-starter</a>)中发现更多很酷的功能。我还写过一个结合Next.js和NestJS 的<a class="ae kq" href="https://csaba-apagyi.medium.com/nestjs-react-next-js-in-one-mvc-repo-for-rapid-prototyping-faed42a194ca" rel="noopener"> MVC设置，以及</a><a class="ae kq" href="https://csaba-apagyi.medium.com/automagically-typed-graphql-queries-and-results-with-apollo-3731bad989aa" rel="noopener">用Apollo </a>自动键入GraphQL查询和结果。</p><p id="8e5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ls">更多内容参见</em> <a class="ae kq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">简明英语. io </em> </a></p></div></div>    
</body>
</html>