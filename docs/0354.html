<html>
<head>
<title>Let’s Build a Video Chat App with JavaScript and WebRTC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用JavaScript和WebRTC构建一个视频聊天应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-video-chat-app-with-javascript-and-webrtc-de745072c38c?source=collection_archive---------0-----------------------#2021-01-21">https://javascript.plainenglish.io/lets-build-a-video-chat-app-with-javascript-and-webrtc-de745072c38c?source=collection_archive---------0-----------------------#2021-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7568" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:了解WebRTC</h2></div><p id="c67a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们WebRTC系列的第一篇教程。本系列的目的是解释什么是WebRTC，以及我们如何在web应用程序中使用它。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a9b34618def0d04d61d7692f1d60fab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzslQ5AaS04-1X-r9fmvSQ.png"/></div></div></figure><p id="9098" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一部分中，我们将了解使用WebRTC开发应用程序所需的各种概念。</p><blockquote class="ln"><p id="6e2b" class="lo lp iq bd lq lr ls lt lu lv lw la dk translated"><a class="ae lx" href="https://simplecoding.dev/articles/let-s-build-a-video-chat-app-with-javascript-and-webrtc-1c16" rel="noopener ugc nofollow" target="_blank"> <em class="ly">本文最初发表于简单编码</em> </a></p></blockquote><h1 id="3f6f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">演示</h1><p id="d9a9" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><a class="ae lx" href="https://desolate-depths-86299.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">你可以在</a>下面测试视频聊天，加入foo room。</p><div class="mw mx gp gr my mz"><a href="https://desolate-depths-86299.herokuapp.com/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">WebTutsPlus WebCon</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">编辑描述</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">desolate-depths-86299.herokuapp.com</p></div></div></div></a></div><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Let’s Build a Video Chat App with JavaScript and WebRTC</figcaption></figure><h1 id="01ff" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">本系列教程</h1><ol class=""><li id="c528" class="nr ns iq kh b ki mr kl ms ko nt ks nu kw nv la nw nx ny nz bi translated">了解WebRTC(本教程)</li><li id="ba23" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><a class="ae lx" href="https://medium.com/javascript-in-plain-english/lets-develop-a-video-chat-app-using-javascript-and-webrtc-71d86cff8faf" rel="noopener">用代码实现WebRTC</a></li></ol><div class="mw mx gp gr my mz"><a href="https://medium.com/javascript-in-plain-english/lets-develop-a-video-chat-app-using-javascript-and-webrtc-71d86cff8faf" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">让我们使用JavaScript和WebRTC开发一个视频聊天应用程序</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">第2部分:如何在后端使用JavaScript和Node.js实现WebRTC</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ll mz"/></div></div></a></div><h1 id="93ec" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">介绍</h1><p id="09f6" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">如果你在新冠肺炎疫情之前不熟悉网络视频会议平台和应用程序，我们打赌你现在对它们了如指掌，而且一定用过其中的一个。</p><p id="ed32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新冠肺炎目前的情况是，比以往任何时候都有更多的人在家工作，公司使用网络会议作为员工和客户之间沟通的主要方式。</p><p id="0aa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着社交距离措施的实施，世界上大部分地区都处于封锁状态，即使是与家人和朋友共度时光，现在也基本上限于在线视频通话。从聚会到商务会议，这些视频会议平台现在对几乎每个人来说都很平常。</p><p id="a773" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本系列教程的目的是教授如何开发这样一个视频会议web应用程序。此外，本系列肯定会帮助那些想学习如何构建实时广告、多人游戏、直播、电子学习等应用程序的开发人员。</p><h1 id="ea12" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">基本原则</h1><p id="3fbe" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在我们开始开发这样的web应用程序之前，我们需要了解电子会议应用程序与简单的聊天web应用程序有何不同。</p><p id="976c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个简单的聊天web应用程序中，当两个浏览器需要互相发送消息时，它们通常需要一个服务器来协调和传递消息。但是中间有一个服务器会导致浏览器之间的通信延迟。这种延迟几乎不会影响聊天应用程序的实用性。即使这个延迟是(比方说)5秒，我们仍然能够使用这个聊天应用程序。</p><p id="3aa6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在视频会议应用的情况下，这种延迟是显著的。使用这种应用程序与人交谈会非常困难。想象你正在和一个5秒钟后收到你声音的人说话。你就能体会到会有多烦了。</p><p id="74d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于视频会议，我们需要浏览器之间的<strong class="kh ir">实时通信</strong>。如果我们把服务器从中间去掉，这样的通信是可能的。这就是为什么我们将不得不使用<strong class="kh ir">WebRTC</strong>——一个开源框架，通过简单的API为web浏览器和移动应用程序提供实时通信。</p><h1 id="d0a8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated"><strong class="ak"> WebRTC </strong></h1><p id="d24f" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">WebRTC代表<strong class="kh ir"> Web实时通信</strong>。它支持点对点通信，中间没有任何服务器，并允许在连接的对等点之间交换音频、视频和数据。使用WebRTC，服务器的角色仅限于帮助两个对等体发现彼此并建立直接连接。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/a1afa59e40654c764fee0594cc6602ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*nC95tW-GRitnDX9ZuM9irw.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Communication <strong class="bd om">WITHOUT</strong> WebRTC</figcaption></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/84c4880b16d4e977ce252a961713eb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*S0hOkg3FuncVM4wFmx5bvQ.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Communication <strong class="bd om">WITH</strong> WebRTC</figcaption></figure><p id="3d37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在没有WebRTC的情况下从头构建一个应用程序(需要点对点通信),您需要大量的框架和库来处理典型的问题，比如</p><ul class=""><li id="ef08" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la oq nx ny nz bi translated">数据丢失</li><li id="3ade" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">掉线</li><li id="a144" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">NAT穿越</li><li id="5c50" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">回波消除</li><li id="985a" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">带宽适应性</li><li id="b297" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">动态抖动缓冲</li><li id="2087" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">自动增益控制</li><li id="6520" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">噪音降低和抑制</li></ul><p id="77e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了WebRTC，所有这些都内置在浏览器中，开箱即用。WebRTC <strong class="kh ir">在幕后自动处理所有这些问题</strong>。这项技术不需要任何插件或第三方软件。它是开源的，其源代码可以在<a class="ae lx" href="http://www.webrtc.org/" rel="noopener ugc nofollow" target="_blank">http://www.webrtc.org/.</a>免费获得</p><p id="4012" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管大多数主流浏览器(如Chrome、Firefox等。)已经实现了WebRTC框架，并为开发人员公开了WebRTC的API，最好确认一下您的浏览器版本是否支持它。你可以在这里找到所有支持WebRTC的浏览器列表。</p><h1 id="08ec" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">WebRTC APIs</h1><p id="4a08" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">WebRTC由几个相互关联的API和协议组成，它们一起工作以实现实时通信。我们将在本教程系列中使用的最重要的API是——单击链接查看演示</p><ul class=""><li id="e2e5" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la oq nx ny nz bi translated"><code class="fe or os ot ou b"><a class="ae lx" href="https://webrtc.github.io/samples/src/content/getusermedia/gum/" rel="noopener ugc nofollow" target="_blank">getUserMedia()</a></code>:捕捉音频和视频。</li><li id="8273" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated"><code class="fe or os ot ou b"><a class="ae lx" href="https://webrtc.github.io/samples/src/content/getusermedia/record/" rel="noopener ugc nofollow" target="_blank">MediaRecorder</a></code>:录制音频和视频。</li><li id="0f3e" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated"><code class="fe or os ot ou b"><a class="ae lx" href="https://webrtc.github.io/samples/src/content/peerconnection/pc1/" rel="noopener ugc nofollow" target="_blank">RTCPeerConnection</a></code>:在用户之间流式传输音频和视频。</li><li id="2f88" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated"><code class="fe or os ot ou b"><a class="ae lx" href="https://webrtc.github.io/samples/src/content/datachannel/basic/" rel="noopener ugc nofollow" target="_blank">RTCDataChannel</a></code>:用户之间的数据流。</li></ul><h1 id="0869" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">发信号</h1><p id="5edc" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在两个对等体可以开始相互通信之前，它们需要知道关于彼此的许多信息，例如—</p><ul class=""><li id="4fd0" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la oq nx ny nz bi translated">如果有任何其他对等体可用于通信。</li><li id="68c4" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">网络数据，例如外界看到的对等体的IP地址和端口</li><li id="36fa" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">会话控制消息—用于打开或关闭通信</li><li id="d733" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">错误消息</li><li id="c21c" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">将由对等方发送的媒体元数据，如编解码器、编解码器设置、带宽和媒体类型</li><li id="e002" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">用于建立安全连接的关键数据</li></ul><p id="8de7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您不理解以上信息所代表的含义，请不要担心。重要的是要认识到，在建立直接连接之前，需要交换大量信息。这种信息可以被称为<strong class="kh ir">元数据</strong>。</p><p id="f22c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">信令指的是协调初始通信并允许在对等体(浏览器)之间发送元数据的机制。因此，最初，对等体使用信令机制相互通信，主要是为了发现其他对等体并共享在它们之间创建直接连接所需的信息。一旦建立了直接连接，此后就没有信令的作用了。</p><p id="89ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">记住— </strong>对于信令，我们需要一台服务器。</p><p id="2fa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">会话描述协议:- </strong></p><ul class=""><li id="366d" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la oq nx ny nz bi translated">信令机制(方法、协议等。)不是由WebRTC指定的。我们需要自己建造它。(尽管这似乎是一项复杂的任务，但请相信我们——事实并非如此。在这个系列中，我们将使用套接字。IO用于信令，但有<a class="ae lx" href="https://github.com/muaz-khan/WebRTC-Experiment/blob/master/Signaling.md" rel="noopener ugc nofollow" target="_blank">多种选择</a>。</li><li id="517a" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">WebRTC只需要在<strong class="kh ir"> <em class="ov">提供</em>和<em class="ov">回答</em> </strong>的对等体之间交换上述媒体元数据。提议和回答以<strong class="kh ir">会话描述协议(SDP)格式</strong>进行通信，格式如下:-</li></ul><pre class="lc ld le lf gt ow ou ox oy aw oz bi"><span id="75a8" class="pa ma iq ou b gy pb pc l pd pe">v=0<br/>o=- 7614219274584779017 2 IN IP4 127.0.0.1<br/>s=-<br/>t=0 0<br/>a=group:BUNDLE audio video<br/>a=msid-semantic: WMS<br/>m=audio 1 RTP/SAVPF 111 103 104 0 8 107 106 105 13 126<br/>c=IN IP4 0.0.0.0<br/>...</span></pre><ul class=""><li id="b218" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la oq nx ny nz bi translated">如果您想知道上面格式中的每一行是什么意思，不要担心。WebRTC会根据您的笔记本电脑/PC上的音频/视频设备自动创建它。</li></ul><h1 id="c694" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">那么WebRTC应用程序是如何工作的呢？</h1><p id="0ea3" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">到目前为止，我们已经描述了什么是WebRTC，什么是信令，以及开发者可以使用的各种API。现在，让我们讨论一下所有这些是如何协同工作的。一旦我们知道了这一点，我们就可以开始编写代码了。</p><p id="ab1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们讨论之前，您必须了解什么是IP地址和端口。</p><ul class=""><li id="07b2" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la oq nx ny nz bi translated">连接到互联网的每台设备都使用IP地址进行识别。</li><li id="8089" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated"><strong class="kh ir">端口</strong>数字标识互联网或其他网络消息到达设备时要转发到的特定进程。使用<strong class="kh ir">端口</strong>号，来自互联网的数据被导向设备内的正确位置。</li></ul><p id="a8ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，每台连接到互联网的设备都有一个IP地址和许多端口(通常为65，536)。</p><h2 id="3b89" class="pa ma iq bd mb pf pg dn mf ph pi dp mj ko pj pk ml ks pl pm mn kw pn po mp pp bi translated"><code class="fe or os ot ou b">RTCPeerConnection</code> API和信号:报价、回答和候选</h2><p id="eb83" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">正如我们之前所讨论的，WebRTC的<code class="fe or os ot ou b">RTCPeerConnection</code> API用于在用户之间流式传输音频和视频。因此，Signalling与<code class="fe or os ot ou b">RTCPeerConnection</code>合作在浏览器之间建立直接连接。</p><p id="bf60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要初始化这个过程<code class="fe or os ot ou b">RTCPeerConnection</code>有两个任务:</p><ul class=""><li id="ccdb" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la oq nx ny nz bi translated">确定本地媒体条件(音频和视频)，如分辨率和编解码器能力。这是用于提供和回答的元数据，并通过信令发送。</li><li id="5af4" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">获取应用程序主机的潜在网络地址(称为<em class="ov">候选者</em>)(包括IP地址和端口号)，也必须通过信令发送</li></ul><p id="fb2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦确定了该本地数据，就必须通过信令机制与远程对等体交换该本地数据。</p><p id="cd73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下艾米试图给伯纳黛特T20打电话。以下是完整的提供/回答机制的所有细节:首先，让我们讨论一下他们将如何共享有关媒体条件的信息。</p><ol class=""><li id="29fe" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la nw nx ny nz bi translated"><strong class="kh ir">艾米</strong>创建一个<code class="fe or os ot ou b">RTCPeerConnection</code>对象。</li><li id="2d1d" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><strong class="kh ir"> Amy </strong>使用<code class="fe or os ot ou b">RTCPeerConnection</code> <code class="fe or os ot ou b">createOffer()</code>方法创建要约(SDP会话描述)。</li><li id="2d91" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><strong class="kh ir"> Amy </strong>调用<code class="fe or os ot ou b">setLocalDescription()</code>将创建的要约(会话描述)设置为将创建的连接中的本地媒体的描述。</li><li id="310d" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><strong class="kh ir">艾米签下邀约，然后通过信号机制将其发送给<strong class="kh ir">伯纳黛特</strong>。</strong></li><li id="3157" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><strong class="kh ir">伯纳黛特</strong>将<code class="fe or os ot ou b">setRemoteDescription()</code>与<strong class="kh ir">艾米</strong>的报价联系起来，这样她的<code class="fe or os ot ou b">RTCPeerConnection</code>就知道<strong class="kh ir">艾米</strong>的布局了。</li><li id="00e2" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><strong class="kh ir"> Bernadette </strong>调用<code class="fe or os ot ou b">createAnswer()</code>，并为此成功回调函数传递一个本地会话描述— <strong class="kh ir"> Bernadette </strong>的答案。</li><li id="8219" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><strong class="kh ir">伯纳黛特</strong>给<code class="fe or os ot ou b">setLocalDescription()</code>打电话，将自己的回答设定为当地语系。</li><li id="a05a" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><strong class="kh ir">伯纳黛特</strong>然后使用信号机制将她字符串化的答案发送给<strong class="kh ir">艾米</strong>。</li><li id="d603" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><strong class="kh ir"> Amy </strong>使用<code class="fe or os ot ou b">setRemoteDescription()</code>将<strong class="kh ir"> Bernadette </strong>的答案设置为远程会话描述。</li></ol><p id="c512" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在<strong class="kh ir">艾米</strong>和<strong class="kh ir">伯纳黛特</strong>也需要交换网络信息。术语“寻找候选者”指的是使用<a class="ae lx" href="https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" rel="noopener ugc nofollow" target="_blank"> ICE框架</a>寻找<strong class="kh ir">网络接口和端口(</strong>出现在一个对等体上并可用于建立与另一个对等体的直接连接)的过程。</p><ol class=""><li id="e616" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la nw nx ny nz bi translated">艾米用一个<code class="fe or os ot ou b">onicecandidate</code>处理程序创建了一个<code class="fe or os ot ou b">RTCPeerConnection</code>对象。</li><li id="939e" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">当网络候选变得可用时，调用该处理程序。</li><li id="d70d" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">在处理程序中，<strong class="kh ir"> Amy </strong>通过他们的信令通道将字符串化的候选数据发送给<strong class="kh ir"> Bernadette </strong>。</li><li id="2d0c" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated">当<strong class="kh ir"> Bernadette </strong>从<strong class="kh ir"> Amy </strong>处获得候选人消息时，她调用<code class="fe or os ot ou b">addIceCandidate()</code>将候选人添加到远程对等描述中。</li></ol><p id="f429" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">WebRTC支持<a class="ae lx" href="https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-03#section-3.4.1" rel="noopener ugc nofollow" target="_blank"> ICE候选流</a>，它允许调用者在初始提议后逐渐自动向被调用者提供候选，并允许被调用者自动开始处理呼叫并建立连接，而无需等待所有候选到达。如果你不明白<a class="ae lx" href="https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-03#section-3.4.1" rel="noopener ugc nofollow" target="_blank">冰候选人涓涓</a>也不用担心。重要的是，一旦对等体创建了提议，WebRTC就会自动创建ICE候选(包含IP地址)。我们只需实现通过信令接收和发送这些候选对象所需的方法。</p><p id="4d21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.一旦关于媒体条件和ice候选的信息在两个对等体之间共享，WebRTC自动在对等体之间创建一个直接连接。</p><h1 id="665c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">发信号后——使用ICE应对NAT和防火墙</h1><p id="37de" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">因此，很自然地，您会期望每个WebRTC连接端点都有一个惟一的IP地址和端口号，它可以与其他对等点交换，以便直接通信。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi pq"><img src="../Images/1f6fbde94414e33c274022572de256b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VOaeRbpHKK-7AJ95AFmGJA.png"/></div></div></figure><p id="dd4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但事情并非如此简单。这里有两个因素会引起问题。在使用我们的web会议应用程序之前，我们必须处理这些问题。</p><p id="d5db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">问题1 — NAT </strong></p><p id="11a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你熟悉计算机网络，你就会知道什么是NAT。如果不知道，不要担心。我们将在这里解释它:</p><p id="43ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你已经知道什么是IP地址。它是一个地址，用于标识连接在互联网上的设备。从逻辑上讲，您可能会认为每台连接到互联网的设备都必须有一个唯一的IP地址。但这并不完全正确。</p><p id="8448" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IPv4地址为32位长，这意味着大约有40亿个唯一地址(2 = <strong class="kh ir"> 4，294，967，296)。</strong>2018年底，约有220亿台设备连接到互联网。所以，你一定想知道——如果只有40亿个IP地址，220亿个设备是如何连接到互联网上的？这个问题的答案是NAT。</p><p id="e49d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维护互联网的家伙们想出了以下解决方案——他们将整个IPv4地址范围分成两组——<strong class="kh ir">公共</strong> IP地址和<strong class="kh ir">私有</strong> IP地址。现在，每个公有IP地址只能分配给一台设备，而私有IP地址则不能。更多细节请看下图。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi pr"><img src="../Images/7c6be731dbc2dde21ead9edbbb1f5360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtSQG-F77u-aK8HSzedT1Q.png"/></div></div></figure><p id="00d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上图中，每台路由器都有两个IP地址——一个公有IP地址(面向服务器)和一个私有IP地址(面向内部网络)。因此，如果内部网络1中的任何设备向服务器发送请求，服务器会发现该请求来自同一个IP地址，即180.190.104.50</p><p id="a1ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着每台路由器都将一个公有IP地址映射到设备的多个私有IP地址。这也意味着每个设备(笔记本电脑、PC、智能手机)只知道自己的私有IP地址，而不知道路由器的公共IP地址。(<em class="ov">还有，如果你在Google上搜索—我的IP地址，Google会告诉你(你连接的)路由器的公有IP地址，因为Google看到的是路由器的公有IP地址，而不是你的私有IP地址</em>。)</p><p id="6cd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<strong class="kh ir">在某种程度上</strong>，我们可以说每个设备都有两个IP地址——一个私有IP地址(分配给设备)和一个公共IP地址(分配给设备所连接的路由器)。</p><p id="2c69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能会给WebRTC带来问题，因为网络ICE候选(由浏览器生成)包含设备的私有IP地址，而不是公共IP地址。因此，我们必须找到一种方法让浏览器知道公共IP地址，以便它可以创建包含公共IP地址的候选地址。解决方案是一个STUN(NAT会话遍历工具)服务器。当设备向STUN服务器发出请求时，STUN服务器会用一条包含该设备所连接的路由器的公共IP的消息进行响应。通过这种方式，STUN服务器帮助浏览器生成候选项。</p><p id="f0b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在教程的后面看到如何将STUN与WebRTC集成。</p><p id="a44c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">问题2 —防火墙</strong></p><p id="aedc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，大多数设备都位于一层或多层防火墙的后面，这就像杀毒软件屏蔽某些端口和协议一样。防火墙和网络地址转换实际上可以由同一个设备实现，比如家庭WIFI路由器。由于WebRTC使用了许多非标准端口，一些防火墙不允许在两个浏览器之间建立直接连接。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ps"><img src="../Images/b50107d33ce08074e6bd671001a8cf4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXd5r6NWBd4YqfXC7CKYoA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Firewall Blocking the direct connection between the browsers</figcaption></figure><p id="acc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了解决这个问题，我们需要一个TURN(使用中继NAT的遍历)服务器。TURN服务器基本上充当中继服务器，即如果直接(对等)连接失败，则直接在两个对等体之间中继流量。下图说明:-</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ps"><img src="../Images/13ea718368dd65d942ed5418577ca605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xak-wVX3xUL_QgdD8u1zGQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Using a TURN server</figcaption></figure><p id="7541" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">溶液</strong></p><p id="2df0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，我们需要使用STUN和TURN服务器，同时使用WebRTC建立对等连接。要将TURN和STUN与webrtc集成，我们只需要将包含TURN和STUN服务器URL的<code class="fe or os ot ou b">object</code>传递给<code class="fe or os ot ou b">RTCPeerConnection()</code>作为参数。下面的代码说明了:-</p><pre class="lc ld le lf gt ow ou ox oy aw oz bi"><span id="71f7" class="pa ma iq ou b gy pb pc l pd pe">//Object containing TURN/STUN URLs.<br/>var pcConfig = {<br/>  'iceServers': [<br/>    {<br/>      'urls': 'stun:stun.l.google.com:19302'<br/>    },<br/>    {<br/>      'urls': 'turn:192.158.29.39:3478?transport=udp',<br/>      'credential': 'JZEOEt2V3Qb0y27GRntt2u2PAYA=',<br/>      'username': '28224511:1379330808'<br/>    },<br/>    {<br/>      'urls': 'turn:192.158.29.39:3478?transport=tcp',<br/>      'credential': 'JZEOEt2V3Qb0y27GRntt2u2PAYA=',<br/>      'username': '28224511:1379330808'<br/>    }<br/>  ]<br/>}</span><span id="744e" class="pa ma iq ou b gy pt pc l pd pe">........<br/>//Passing the above object to RTCPeerConnection<br/>RTCPeerConnection(pcConfig);</span></pre><p id="5ebb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上图所示，我们只需要传递URL。WebRTC管理着幕后的一切。</p><p id="a6e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图说明了在WebRTC调用期间建立的所有连接</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ps"><img src="../Images/dfef01203729db18da95098e9960b810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyKvaHYQDvGHfK53RE2IOg.png"/></div></div></figure><p id="793d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注:- </strong></p><ul class=""><li id="bf74" class="nr ns iq kh b ki kj kl km ko on ks oo kw op la oq nx ny nz bi translated">大多数情况下，成功的连接将只使用STUN服务器，而不需要TURN服务器。只有几次，您需要一台TURN服务器才能成功通话。</li><li id="7a69" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated">有一些公司(比如XirSys)提供免费的TURN/STUN服务器。</li></ul><h1 id="fe4a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">恭喜</h1><p id="f245" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">您已经完成了本教程的学习。您现在必须清楚地了解WebRTC是如何工作的。</p><p id="ffca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们只描述了一个人(在我们的例子中为<strong class="kh ir"> Amy </strong>)试图使用WebRTC呼叫另一个人(在我们的例子中为<strong class="kh ir"> Bernadette </strong>)时发生的一组事件。如果您想知道如何在代码中实现所有这些，请继续关注我们。我们将在下一个教程中编写并解释实现所有这些概念的代码。</p><h1 id="b1ad" class="lz ma iq bd mb mc md me mf mg mh mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">来源</h1><ul class=""><li id="4d42" class="nr ns iq kh b ki mr kl ms ko nt ks nu kw nv la oq nx ny nz bi translated"><a class="ae lx" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank">WebRTC.org</a></li><li id="2b3d" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated"><a class="ae lx" href="https://en.wikipedia.org/wiki/WebRTC" rel="noopener ugc nofollow" target="_blank">维基百科</a></li><li id="5fcb" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></li><li id="652f" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la oq nx ny nz bi translated"><a class="ae lx" href="https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" rel="noopener ugc nofollow" target="_blank"> HTML5Rocks </a></li></ul></div></div>    
</body>
</html>