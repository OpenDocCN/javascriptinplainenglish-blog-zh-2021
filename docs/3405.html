<html>
<head>
<title>A Better Way to Optimize Data Fetching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化数据提取的更好方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stored-fetch-optimize-data-fetching-5328332ceb52?source=collection_archive---------5-----------------------#2021-07-10">https://javascript.plainenglish.io/stored-fetch-optimize-data-fetching-5328332ceb52?source=collection_archive---------5-----------------------#2021-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fbc6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">无论你的应用平台是什么，缓存获取优化你的应用的数据获取</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ad1e70251918107400a5718197af1d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLsLimigMGfRLkWeKU_DQg.png"/></div></div></figure><p id="069d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你开发过React app，你可能听说过<a class="ae lk" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank">《SWR》</a>。SWR缓存获取的数据。因此应用程序调用相同的fetch，缓存的数据在没有网络通信的情况下返回。</p><p id="de03" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但它只对反应钩有效。如果你想使用SWR，你必须调用' useSWR' API。你也可以只定制“获取”部分，就像这样。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="f39a" class="lq lr in lm b gy ls lt l lu lv"><strong class="lm io">const</strong> fetcher = (...args) =&gt; fetch(...args).then(res =&gt; res.json());</span><span id="18a8" class="lq lr in lm b gy lw lt l lu lv"><br/>function App() {</span><span id="3c6f" class="lq lr in lm b gy lw lt l lu lv"><strong class="lm io">  const</strong> { data, error } = useSWR('/api/user/123', fetcher);</span><span id="92d4" class="lq lr in lm b gy lw lt l lu lv">  ...<br/>}</span></pre><p id="2684" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您只需输入两个参数path和fetcher。你无法理解缓存是如何工作的。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="137b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://github.com/wkddngus5/cached-fetch" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">cache-fetch</strong></a>即使开发环境是普通的JavaScript也能工作。您可以选择缓存数据的存储。当然，提供了默认存储。是一个窗口API的<a class="ae lk" href="https://developer.mozilla.org/ko/docs/Web/API/Window/sessionStorage" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">会话存储</strong> </a>。</p><ol class=""><li id="be6a" class="me mf in kq b kr ks ku kv kx mg lb mh lf mi lj mj mk ml mm bi translated">CachedFetcher组件获取存储和获取(第22行)。</li><li id="8d18" class="me mf in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated">当调用fetch方法时，cachedFetcher实例从存储中查找缓存的数据。</li><li id="8699" class="me mf in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated">如果缓存的数据不存在或过期，它会提取到服务器。服务器响应数据被缓存并发送给客户端。</li><li id="07a3" class="me mf in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated">如果缓存的数据有效，缓存的数据将在没有网络通信的情况下返回。</li></ol><p id="d89c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有时你想向服务器请求实时数据。因此您可以将过期时间设置为数据并丢弃缓存的数据。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="9f7c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要使用这个库，你必须输入存储器和提取器。这些都是考虑<code class="fe ms mt mu lm b"><strong class="kq io">DI(Dependency Injection)</strong></code>实现的。</p><p id="ba25" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们看看<strong class="kq io"> Storage.ts </strong>文件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="04f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您只需扩展存储接口并遵循其详细信息:</p><ol class=""><li id="1e87" class="me mf in kq b kr ks ku kv kx mg lb mh lf mi lj mj mk ml mm bi translated"><code class="fe ms mt mu lm b">core</code>:存储核心引擎</li><li id="c3d1" class="me mf in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated"><code class="fe ms mt mu lm b">getItem</code>:从存储器中获取数据。标识符是关键。</li><li id="84a4" class="me mf in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated"><code class="fe ms mt mu lm b">setItem</code>:从存储器中设置数据。标识符是关键。</li><li id="44e4" class="me mf in kq b kr mn ku mo kx mp lb mq lf mr lj mj mk ml mm bi translated"><code class="fe ms mt mu lm b">removeItem</code>:从存储器中删除数据。标识符是关键。</li></ol><p id="3a21" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看<code class="fe ms mt mu lm b">SessionStorage</code>。这是一个默认的<code class="fe ms mt mu lm b">Storage</code>实现:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="9ae6" class="lq lr in lm b gy ls lt l lu lv">class SessionStorage extends Storage {</span><span id="61c8" class="lq lr in lm b gy lw lt l lu lv">  core: globalThis.Storage;</span><span id="554c" class="lq lr in lm b gy lw lt l lu lv">  constructor() {<br/>    super();</span><span id="136e" class="lq lr in lm b gy lw lt l lu lv">    if (!sessionStorage) {</span><span id="1250" class="lq lr in lm b gy lw lt l lu lv">      throw new Error('sessionStorage not exists.');</span><span id="ffb1" class="lq lr in lm b gy lw lt l lu lv">    }</span><span id="69ce" class="lq lr in lm b gy lw lt l lu lv">    this.core = sessionStorage;</span><span id="4664" class="lq lr in lm b gy lw lt l lu lv">  }</span><span id="dcc6" class="lq lr in lm b gy lw lt l lu lv">  getItem(key: string): CachedItem {</span><span id="6d59" class="lq lr in lm b gy lw lt l lu lv">    const cached = this.core.getItem(key);</span><span id="e206" class="lq lr in lm b gy lw lt l lu lv">    if (typeof cached !== 'string') {</span><span id="4566" class="lq lr in lm b gy lw lt l lu lv">      return null;</span><span id="b439" class="lq lr in lm b gy lw lt l lu lv">    }</span><span id="3dcf" class="lq lr in lm b gy lw lt l lu lv">    const cachedItem = JSON.parse(cached);</span><span id="03d4" class="lq lr in lm b gy lw lt l lu lv">    if (!cachedItem.data || !cachedItem.expiredAt) {</span><span id="3018" class="lq lr in lm b gy lw lt l lu lv">      return null;</span><span id="2d0f" class="lq lr in lm b gy lw lt l lu lv">    }</span><span id="fe91" class="lq lr in lm b gy lw lt l lu lv">    return cachedItem;</span><span id="ff05" class="lq lr in lm b gy lw lt l lu lv">  }</span><span id="be89" class="lq lr in lm b gy lw lt l lu lv">  setItem(key: string, item: CachedItem) {</span><span id="1f9e" class="lq lr in lm b gy lw lt l lu lv">    this.core.setItem(key, JSON.stringify(item));</span><span id="4bdf" class="lq lr in lm b gy lw lt l lu lv">  }</span><span id="eb2c" class="lq lr in lm b gy lw lt l lu lv">  removeItem(key: string) {</span><span id="db77" class="lq lr in lm b gy lw lt l lu lv">    this.core.removeItem(key);</span><span id="3375" class="lq lr in lm b gy lw lt l lu lv">  }</span><span id="57fc" class="lq lr in lm b gy lw lt l lu lv">}</span></pre><p id="e1c5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ms mt mu lm b"><strong class="kq io">sessionStorage</strong> of window</code>按键存储数据。键和值只是字符串类型。所以setItem存储<code class="fe ms mt mu lm b"><strong class="kq io">stringify</strong></code>之后的数据，getItem返回<code class="fe ms mt mu lm b"><strong class="kq io">parse</strong></code>之后的数据。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="31ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">费彻在这里:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="78f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它有一个方法，<code class="fe ms mt mu lm b"><strong class="kq io">fetch</strong></code>。fetch方法获取URI，方法，头。不难。</p><p id="0a06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在html Fetcher(Fetcher的一个实现)的例子中，它只是调用了<code class="fe ms mt mu lm b">HTML <strong class="kq io">fetch</strong></code>方法。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="a511" class="lq lr in lm b gy ls lt l lu lv">// HTMLFetcher.ts</span><span id="d3ad" class="lq lr in lm b gy lw lt l lu lv">class HTMLFetcher extends Fetcher {</span><span id="bd04" class="lq lr in lm b gy lw lt l lu lv">  core: Window = window;</span><span id="3913" class="lq lr in lm b gy lw lt l lu lv">  fetch(fetchParam: FetchParam): Promise&lt;unknown&gt; {</span><span id="72f3" class="lq lr in lm b gy lw lt l lu lv">    return this.core.fetch(fetchParam.uri, { headers: fetchParam.headers });</span><span id="18d3" class="lq lr in lm b gy lw lt l lu lv">  }</span><span id="f608" class="lq lr in lm b gy lw lt l lu lv">}</span></pre></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="aaca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">CachedFetcher只运行在<code class="fe ms mt mu lm b"><strong class="kq io">GET</strong></code> api调用上。缺少的一点是对数据最新的判断依赖于<code class="fe ms mt mu lm b"><strong class="kq io">expiredAt</strong></code>。欢迎任何反馈:)</p><div class="mx my gp gr mz na"><a href="https://github.com/wkddngus5/cached-fetch" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">wkddngus 5/缓存提取</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">在GitHub上创建一个帐户，为wkddngus5/cached-fetch开发做贡献。</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no km na"/></div></div></a></div><p id="c313" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="np">更多内容尽在</em><a class="ae lk" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="np">plain English . io</em></strong></a></p></div></div>    
</body>
</html>