<html>
<head>
<title>React in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一言以蔽之</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-in-a-nutshell-e494041d78eb?source=collection_archive---------8-----------------------#2021-09-07">https://javascript.plainenglish.io/react-in-a-nutshell-e494041d78eb?source=collection_archive---------8-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/78aa35875cb362526b618f1a1420e1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUAFZB0vvYrdKMCSKgNOvw@2x.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mockupgraphics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mockup Graphics</a> on <a class="ae kc" href="https://unsplash.com/s/photos/nutshell?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a> and edited by the author</figcaption></figure><h2 id="3ab3" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">让我们浏览一下介绍性的东西</h2><p id="00c7" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">所以我们现在都知道React是由脸书开发的，并于2017年9月首次发布到野外。</p><p id="6769" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">它是一个JavaScript库，而不是真正的框架。这是因为它没有提供构建成熟应用程序所需的一切。您需要熟悉一些第三方库，例如，如果您需要构建一个表单，可以使用像<a class="ae kc" href="https://formik.org/docs/tutorial" rel="noopener ugc nofollow" target="_blank"> Formik </a>这样的库，或者使用<a class="ae kc" href="https://axios-http.com/" rel="noopener ugc nofollow" target="_blank"> Axios </a>来替代Fetch API。</p><p id="91f3" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">React是<strong class="lb ir">声明式</strong>，基本意思是我们告诉React我们想要什么，React让它发生。我们不需要指定<strong class="lb ir">它应该如何呈现我们想要的特定UI元素。我们不需要管理何时插入或删除HTML元素，或者如何修改页面上当前的元素，我们只需要说，我想要一个文本字段，并且它必须是只读的。React然后处理剩下的事情。</strong></p><p id="617a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">React是<strong class="lb ir">基于组件的</strong>。这意味着我们可以构建自己的组件来封装它们自己的状态。这些组件可以用作构建复杂ui的构件。构建组件是保持应用程序模块化并确保通用代码可重用性的好方法。</p><p id="0640" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">React也很百搭。可以使用React Native创建移动应用程序，执行服务器端渲染(如果对您的应用程序有意义)以及开发渐进式web应用程序。如果您对服务器端渲染(SSR) <a class="ae kc" href="https://www.freecodecamp.org/news/server-side-rendering-your-react-app-in-three-simple-steps-7a82b95db82e/" rel="noopener ugc nofollow" target="_blank">感兴趣，请参阅本文</a>。</p><h2 id="8ffc" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">JSX</h2><p id="f313" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">那么什么是JSX呢？JSX是JavaScript的模板语言，它只是普通的旧JavaScript的扩展。建议将JSX与React一起使用，因为React接受了呈现逻辑与UI逻辑内在耦合的事实。例如，当单击某个按钮时，其他一些组件应该会变得可见。JSX为我们提供了一种在描述用户界面的标记中嵌入JavaScript逻辑的简洁方法。这里有一个例子:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Basic JSX example</figcaption></figure><p id="2469" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在上面的例子中，当组件被渲染时，变量<em class="mf"> name </em>的值将被插入到变量的位置。您还可以将任何有效的JavaScript表达式放在花括号内，表达式的结果将被嵌入到语句中。JSX还可以用于条件呈现，例如，如果用户没有登录，则呈现一个按钮，否则显示一个问候。请参见下面的示例。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Conditional rendering with JSX</figcaption></figure><h2 id="bb07" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">虚拟世界</h2><p id="58c3" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">虚拟DOM是React用来在内存中表示用户界面的一种模式。它本质上是UI的虚拟副本，保存在内存中，并通过ReactDOM等库与真实的DOM保持同步。这个同步过程被称为协调。这就是React使用差分算法来确定自上次渲染以来必须渲染到屏幕上的元素发生了什么变化的地方。这也是React在渲染时效率很高的原因之一，因为当发生变化时，它不仅仅是重新渲染整个页面。相反，当发生变化时，<em class="mf"> render </em>方法将返回一个期望的React元素树。React然后将该树与先前的树(当前页面)进行比较，然后确定需要对页面进行的一组更改。然后，它将应用必要的更改来实现所需的结构。</p><h2 id="233e" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">组件的剖析</h2><p id="75ae" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">现在我们来看看组件。在React中，组件基本上是接受一组任意参数的JavaScript函数，称为<strong class="lb ir">道具</strong>。组件也总是有一个<strong class="lb ir"> return </strong>语句，该语句返回应该显示在屏幕上的React元素的层次结构。组件也可以写成ES6类，但是，更好的方法是把它们写成功能组件。</p><p id="ff2a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">组件的return语句返回的元素应该总是只有一个包含其他子元素的父元素。这显示在下面的组件中。这个组件没有状态，所以被称为无状态组件。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="02de" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">如果我们想将上面的<em class="mf"> Book </em>组件呈现为另一个组件的一部分，它将被实例化如下:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="39a2" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">React应用程序通常有一个名为<em class="mf"> App </em>的根组件，它是应用程序组件层次结构中的顶级组件。</p><p id="7751" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">状态vs道具</strong></p><p id="af2e" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">组件还可以有一个内部状态，用于控制呈现哪些数据和控件。这些被称为有状态组件。</p><p id="d5c7" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">状态和道具不一样。状态可以被认为类似于内部函数变量。它们保存数据并影响“拥有”它们的功能/组件的行为。只能通过调用<em class="mf"> setState() </em>方法来修改状态，而不能直接在对象上设置值。当状态更新时，变化异步发生<strong class="lb ir"/>。这是一件要永远记在心里的事情，因为它肯定会在某个时候绊倒你。</p><p id="6c10" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">另一方面，Props是只读的，可以认为它类似于传递给函数的参数。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/060d04ddc27873a179d29e8362bdc654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7fLhAWTP_ihETUB4tdjtQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://i.stack.imgur.com/wqvF2.png" rel="noopener ugc nofollow" target="_blank">https://i.stack.imgur.com/</a></figcaption></figure><p id="7566" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">向我们的组件添加状态</strong></p><p id="0d42" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">随着时间的推移，向组件添加状态的方法有很多种。如果使用类组件，state可以作为名为<em class="mf"> state </em>的变量添加，它存储一个JavaScript对象。然而，首选的方法是使用<em class="mf"> useState </em>钩子。在本文中，我不打算详细介绍所有可用的挂钩。如果你想了解更多，你可以阅读《T4》。</p><p id="8f1a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">本质上，<em class="mf"> useState </em>钩子允许你为你需要的每个状态设置不同的变量，并为你提供一个特定的方法(在幕后调用setState)来更新那个状态。这比以前的方法更好，以前的方法必须调用setState(<em class="mf">{ updatedStateObject })</em>，并且必须将使用您想要更改的特定属性更新的对象传递给<em class="mf"> setState </em>函数。让我们给Book组件添加一些状态。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6aa0" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在上面的例子中，我们使用<em class="mf"> useState </em>钩子添加了一个名为<em class="mf"> hasBeenRead </em>的状态变量。第二个参数<em class="mf"> setHasBeenRead </em>，是用于更新状态变量的函数。<em class="mf"> useState(false) </em>中值为<em class="mf"> false </em>的参数是分配给状态变量的默认值。然后在return语句中，我们使用基于<em class="mf"> hasBeenRead </em>状态变量的值的条件渲染。如果值为<em class="mf"> true </em>，我们显示文本，<em class="mf">我读过这本书</em>，否则我们不显示任何内容。</p><p id="5068" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">提升状态上升</strong></p><p id="e4b6" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">通常情况下，应用程序层次结构中的多个组件需要相同的状态来呈现。在这种情况下，最佳实践是将状态提升到需要它的组件的最低公共祖先。然后，可以将所需的状态作为道具传递给相应的组件。这确保了我们对于特定的信息只有一个真实的来源。要更详细地了解这个话题，我推荐阅读<a class="ae kc" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">这个</a>。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="8036" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我希望这已经让您很好地了解了React的关键要素。我建议您浏览下面列出的官方文档，因为有很多内容我无法在一篇文章中涵盖。</p><p id="7cc5" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">感谢阅读！</p><h2 id="44b4" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">参考</h2><p id="478b" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">https://reactjs.org/docs/introducing-jsx.html JSX<a class="ae kc" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"/></p><p id="ff04" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">React文档:<a class="ae kc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/</a></p><p id="104d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="mf">更多内容看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lb ir"><em class="mf">plain English . io</em></strong></a></p></div></div>    
</body>
</html>