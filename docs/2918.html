<html>
<head>
<title>Advanced TypeScript: A Generic Function to Merge Object Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级类型脚本:合并对象数组的通用函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-typescript-a-generic-function-to-merge-object-arrays-cb0bd9a5c382?source=collection_archive---------9-----------------------#2021-06-14">https://javascript.plainenglish.io/advanced-typescript-a-generic-function-to-merge-object-arrays-cb0bd9a5c382?source=collection_archive---------9-----------------------#2021-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a408" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">SaaS产品档案中的另一个强大的通用功能。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7f07c28a360a8237c93e97ac65f550d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSPjWyGGYkOpse4gOrq2cw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The mergeArrays function we’ll be building.</figcaption></figure><p id="57be" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae lo" href="https://chrisfrew.in/blog/advanced-typescript-generic-array-merging/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">这篇文章反映在我的博客chrisfrew.in </em> </a></p><h1 id="5368" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">TypeScript泛型疯狂！</h1><p id="d3ce" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">我就是无法停止编写这些通用函数！这是继我上一篇文章<a class="ae lo" href="https://dev.to/blog/advanced-typescript-a-generic-function-to-update-and-manipulate-object-arrays/" rel="noopener ugc nofollow" target="_blank">之后的又一个强大的通用函数，构建一个通用函数来根据特定的测试值</a>更新特定键处的数组。当我试图为<a class="ae lo" href="https://reduxplate.com/" rel="noopener ugc nofollow" target="_blank"> ReduxPlate </a>维护尽可能干净的代码库时，我继续为这些易于使用但功能强大的通用函数寻找新的用例。</p><h1 id="9132" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">动机</h1><p id="7e53" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">通常，在进行状态修改时，您希望将从API或其他来源获得的一些属性合并或添加到对象中。您<strong class="ku io">可以</strong>为您想要更新的键显式编写键/值分配…或者您可以利用JavaScript的内置<code class="fe mn mo mp mq b">Object.assign</code>函数和TypeScript的通用功能，只为您整个应用程序中需要的所有合并操作编写一个这样的函数！😄</p><p id="634f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">例如，在ReduxPlate中，我有两种类型，<code class="fe mn mo mp mq b">IFile</code>和<code class="fe mn mo mp mq b">IEditorSettings</code>:</p><p id="39d8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mn mo mp mq b">IFile</code>:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="a5d1" class="mv lr in mq b gy mw mx l my mz">export default interface IFile {<br/>    fileLabel: string<br/>    code: string<br/>}</span></pre><p id="e357" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mn mo mp mq b">IEditorSettings</code>:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="6965" class="mv lr in mq b gy mw mx l my mz">export default interface IEditorSettings extends IFile {<br/>  isActive: boolean<br/>}</span></pre><p id="7a04" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mn mo mp mq b">IEditorSettings</code>扩展了<code class="fe mn mo mp mq b">IFile</code>，并且只有一个额外的属性:<code class="fe mn mo mp mq b">isActive</code>。当访问者点击“生成！”按钮时，来自服务器的响应返回类型为<code class="fe mn mo mp mq b">IFile</code>而不是<code class="fe mn mo mp mq b">IEditorSettings</code>的对象数组，因为服务器不关心<code class="fe mn mo mp mq b">isActive</code>属性。<code class="fe mn mo mp mq b">isActive</code>仅涉及用于显示目的的前端。然后我将<code class="fe mn mo mp mq b">IFile</code>数组合并到现有的<code class="fe mn mo mp mq b">IEditorSettings</code>数组中，在不修改<code class="fe mn mo mp mq b">isActive</code>现有值的情况下更新代码。让我们看看我是如何编写这个功能的第一次迭代。</p><h1 id="611e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">天真的实施</h1><p id="b558" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">一个初始的实现可以足够快地组装起来。<code class="fe mn mo mp mq b">fileLabel</code>作为一个键，我们可以在上面比较我们的对象。然后，我用匹配文件返回的<code class="fe mn mo mp mq b">match.code</code>值替换<code class="fe mn mo mp mq b">editorSetting.code</code>的值(如果找到匹配的话):</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="59dc" class="mv lr in mq b gy mw mx l my mz">const editorSettings = useState(...) // existing object array of IEditorSettings, stateful<br/>const files = &lt;&lt;API fetch code here&gt;&gt; // array of IFile returned by API<br/>...<br/>editorSettings.map(editorSetting =&gt; {<br/>  const match = files.find(<br/>    file =&gt; file.fileLabel === editorSetting.fileLabel<br/>  )<br/>  if (match) {<br/>    editorSetting.code = match.code<br/>  }<br/>  return editorSetting<br/>})</span></pre><p id="3035" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果后面有更多属性内置到<code class="fe mn mo mp mq b">IFile</code>里怎么办？也许是每个文件上的一系列导入或警告？这些也是我们想要合并到现有状态中的属性。如果我们可以将这些属性添加到<code class="fe mn mo mp mq b">IFile</code>中，而不必手动编辑上面的<code class="fe mn mo mp mq b">if</code>块中的代码，那就最好了。让我们创建一个通用的util函数来为<em class="lp">任何</em>两个相关类型的对象数组完成合并任务。</p><h1 id="2c5c" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">通用类型</h1><p id="bde3" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">让我们假设有一些类型为<code class="fe mn mo mp mq b">T</code>的对象，和一些更复杂的对象类型<code class="fe mn mo mp mq b">U</code>，其中<code class="fe mn mo mp mq b">U extends T</code>。我们希望将类型为<code class="fe mn mo mp mq b">T</code>的对象数组合并到类型为<code class="fe mn mo mp mq b">U</code>的更复杂的对象数组中，并返回类型为<code class="fe mn mo mp mq b">U</code>的新数组。我们不必假设这些数组是有组织的，或者长度相同。因此，我们需要确保在某种类型的<code class="fe mn mo mp mq b">matchKey</code>上合并适当的对象，这必须是<code class="fe mn mo mp mq b">keyof T</code>，因为<code class="fe mn mo mp mq b">U</code>中的一些键可能在<code class="fe mn mo mp mq b">T</code>中不存在。定义了<code class="fe mn mo mp mq b">matchKey</code>之后，我们应该只需要另外两个数组，现有数组和传入数组，来定义这个函数的签名:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="154d" class="mv lr in mq b gy mw mx l my mz">export const mergeArrays = &lt;T, U extends T&gt;(params: {<br/>  mergeArray: Array&lt;T&gt;<br/>  existingArray: Array&lt;U&gt;<br/>  matchKey: keyof T<br/>}): Array&lt;U&gt;</span></pre><p id="2bc8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里我像在<a class="ae lo" href="https://dev.to/snippets/#updateArray" rel="noopener ugc nofollow" target="_blank"> updateArray </a>函数中一样利用了<code class="fe mn mo mp mq b">params</code>模式，因为它使得调用代码更容易阅读。</p><h1 id="ac25" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">履行</h1><p id="0f3c" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">我们可以从<code class="fe mn mo mp mq b">params</code>对象中提取所有的参数。然后，我们遍历现有的数组，试图在<code class="fe mn mo mp mq b">matchKey</code>上找到一个匹配。如果这样做，我们将把匹配对象中的所有值赋给现有对象。如果没有，我们只需通过返回来保留现有的项目:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="540b" class="mv lr in mq b gy mw mx l my mz">const { mergeArray, existingArray, matchKey } = params<br/>return existingArray.map(existingItem =&gt; {<br/>  const match = mergeArray.find(<br/>    mergeItem =&gt; mergeItem[matchKey] === existingItem[matchKey]<br/>  )<br/>  if (match) {<br/>    return Object.assign(existingItem, match)<br/>  }<br/>  return existingItem<br/>})</span></pre><h1 id="e66f" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">决赛成绩</h1><p id="6c0c" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">结合函数签名和主体，我向您展示<code class="fe mn mo mp mq b">mergeArrays</code>实用函数:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="0c25" class="mv lr in mq b gy mw mx l my mz">export const mergeArrays = &lt;T, U extends T&gt;(params: {<br/>  mergeArray: Array&lt;T&gt;<br/>  existingArray: Array&lt;U&gt;<br/>  matchKey: keyof T<br/>}): Array&lt;U&gt; =&gt; {<br/>  const { mergeArray, existingArray, matchKey } = params<br/>  return existingArray.map(existingItem =&gt; {<br/>    const match = mergeArray.find(<br/>      mergeItem =&gt; mergeItem[matchKey] === existingItem[matchKey]<br/>    )<br/>    if (match) {<br/>      return Object.assign(existingItem, match)<br/>    }<br/>    return existingItem<br/>  })<br/>}</span></pre><h1 id="e2c8" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">谢谢！</h1><p id="3db1" class="pw-post-body-paragraph ks kt in ku b kv mi jo kx ky mj jr la lb mk ld le lf ml lh li lj mm ll lm ln ig bi translated">一如既往，感谢阅读，敬请关注📻—将会有更多这些强大的通用函数出现！结合我的<a class="ae lo" href="https://dev.to/blog/react-typescript-generic-search-sort-and-filters/" rel="noopener ugc nofollow" target="_blank">通用搜索、排序和过滤功能</a>——以及我藏在其他项目代码中的一些其他秘密好东西——我想我会出版某种“高级类型脚本食谱”📘那包括他们所有人！</p><p id="4b48" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">干杯！🍻</p><p id="2a21" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">克莉丝</p><p id="e7c4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lp">更多内容尽在</em><a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>