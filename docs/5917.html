<html>
<head>
<title>How to Create and Update Lists in Vanilla JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vanilla JS中创建和更新列表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/working-with-the-dom-in-vanilla-js-apps-part-2-ebd9a8064f6c?source=collection_archive---------3-----------------------#2021-12-19">https://javascript.plainenglish.io/working-with-the-dom-in-vanilla-js-apps-part-2-ebd9a8064f6c?source=collection_archive---------3-----------------------#2021-12-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d3ae" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在普通JS应用程序中使用DOM(第2部分):创建和更新列表</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1556cf3a94082679594470a1a786427d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xseIRxDjJ4pE41AY"/></div></div></figure><p id="4cb1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我在之前的帖子<a class="ae lk" href="https://medium.com/@hayavuk/working-with-the-dom-in-vanilla-js-apps-part-1-bf8ccc0faaed" rel="noopener">中承诺过，我会在这个帖子中涵盖列表。我们将讨论使用列表的几种不同方法，这些方法应该涵盖大多数常见的情况。</a></p><p id="5ae5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，这些方法并不是唯一的。我们在这里的目标不是涵盖所有可能的边缘情况，而是提供在大多数时候都有效的解决方案，或者至少作为一个良好的基础。</p><p id="b124" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将介绍的方法有:</p><ul class=""><li id="56bc" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated">带有隐藏元素的静态列表</li><li id="02b9" class="ll lm in kq b kr lu ku lv kx lw lb lx lf ly lj lq lr ls lt bi translated">任意长度的动态列表</li><li id="dd8c" class="ll lm in kq b kr lu ku lv kx lw lb lx lf ly lj lq lr ls lt bi translated">具有未使用节点池的动态列表</li></ul><p id="837d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我还将介绍列表排序，并分享一个CSS小技巧来提高列表呈现性能。</p><h1 id="c428" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">静态列表</h1><p id="15e3" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">静态列表最常用于从不改变的列表(例如，预先知道的选择列表中的选项)，但是它们也可以用于本身不是静态的数据。当我们的数据是一个任意长度的列表时，我们仍然可以通过一次只显示列表的一个子集来将其映射到一个静态列表。</p><p id="efc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，在这种情况下，可以使用分页来促进子集的选择。在我们的HTML中，我们将创建足够的元素来覆盖单个页面。这些元素最初都是隐藏的。当我们要渲染一些数据的时候，我们会先根据数据更新每个元素，然后显示更新的项目。</p><p id="a38e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为我提前知道了呈现的项目的数量，并且在HTML中有它们，所以我可以提前预选所有的元素。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="ee82" class="nb ma in mx b gy nc nd l ne nf">let $$listItems = document.querySelectorAll('.list-item')</span></pre><p id="f301" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">更新静态列表的技巧是总是迭代元素而不是数据:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="db6f" class="nb ma in mx b gy nc nd l ne nf">let data = []</span><span id="7ccf" class="nb ma in mx b gy ng nd l ne nf">let updateList = () =&gt; {<br/>  $$listItems.forEach(($item, idx) =&gt; {<br/>    let item = data[idx]<br/>    if (itemx) {<br/>      $item.querySelector('.title').textContent = item.title<br/>      $item.querySelector('.price').textContent = item.price<br/>    }<br/>    $item.classList.toggle('hidden', item == null)<br/>  })<br/>}</span></pre><p id="f6ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我检查现有的列表项元素时，我试图将它们与数据进行匹配。如果没有数据，那么我隐藏元素。不然我先填空再揭示。</p><p id="7223" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">重要的是重申你要先填空，然后<em class="nh">再</em>揭示物品。这减少了回流和重画的次数。</p><p id="4c0a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我可以对更长的列表使用分页来重用静态列表。上面的例子非常适合这种情况:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="e48b" class="nb ma in mx b gy nc nd l ne nf">let data = []<br/>let startPage = 0<br/>let endPage = 10</span><span id="8d1f" class="nb ma in mx b gy ng nd l ne nf">let updateList = () =&gt; {<br/>  let shownData = data.slice(startPage, endPage + 1)<br/>  $$listItems.forEach(($item, idx) =&gt; {<br/>    let item = shownData[idx]<br/>    if (itemx) {<br/>      $item.querySelector('.title').textContent = item.title<br/>      $item.querySelector('.price').textContent = item.price<br/>    }<br/>    $item.classList.toggle('hidden', item == null)<br/>  })<br/>}</span></pre><p id="324e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于分页列表，我简单地将<code class="fe ni nj nk mx b">startPage</code>和<code class="fe ni nj nk mx b">endPage</code>变量添加到应用程序状态中。(假设我通过用户交互来更新它们。)然后我创建一个<code class="fe ni nj nk mx b">shownData</code>作为整个数组的一部分，并将列表项映射到它，而不是整个<code class="fe ni nj nk mx b">data</code>数组。</p><h2 id="08cc" class="nb ma in bd mb nl nm dn mf nn no dp mj kx np nq ml lb nr ns mn lf nt nu mp nv bi translated">添加事件侦听器</h2><p id="e0b9" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">列表的某些部分可能是交互式的。在这种情况下，我们需要添加事件侦听器。我们有几个选择，但是我最常用的方法是给所有列表项添加事件监听器，然后使用<code class="fe ni nj nk mx b">data-*</code>属性来控制监听器要做什么。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="0f60" class="nb ma in mx b gy nc nd l ne nf">let updateList = () =&gt; {<br/>  $$listItems.forEach(($item, idx) =&gt; {<br/>    let item = data[idx]<br/>    if (itemx) {<br/>      $item.querySelector('.title').textContent = item.title<br/>      $item.querySelector('.price').textContent = item.price<br/>    }<br/>    $item.classList.toggle('hidden', item == null)<br/>    <strong class="mx io">$item.dataset.index = idx</strong><br/>  })<br/>}</span><span id="1b54" class="nb ma in mx b gy ng nd l ne nf"><br/>$$listItems.forEach($item =&gt; {<br/>  $item.querySelector('.delete').onclick = () =&gt; <br/>    onDeleteItem(<strong class="mx io">Number($item.dataset.index)</strong>)<br/>});</span></pre><h1 id="87ad" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">动态列表</h1><p id="df32" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">有时，由于UX的原因，我们可能希望避免分页。相反，我们可以使用“加载更多”按钮或使用<code class="fe ni nj nk mx b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">IntersectionObserver</a></code>自动加载列表末尾的附加项目。</p><p id="ab18" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下，我发现在JavaScript中创建DOM节点比在HTML中创建更简单。我称这种方法为“动态列表”</p><p id="c259" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然如果初始项目的数量总是相同的话，这种方法可以与静态列表相结合，但是我发现如果我在简单的情况下坚持使用这种或那种方法，代码总体上会更简单。我还将在后面介绍混合方法，在那里我将介绍一个更合适的例子。</p><p id="5558" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当使用动态列表方法时，我通常有一个单独的函数来创建列表项元素。我们可以将元素创建为字符串或DOM节点。至于使用字符串和使用<code class="fe ni nj nk mx b">document.createElement</code>创建顶级DOM节点之间的性能差异，应该没有太大的区别。主要区别在于您是立即获得对列表项节点的引用，还是必须在以后选择它们。</p><p id="f425" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们来看看这两种方法。</p><h2 id="1c0e" class="nb ma in bd mb nl nm dn mf nn no dp mj kx np nq ml lb nr ns mn lf nt nu mp nv bi translated">仅使用字符串创建列表项</h2><p id="c122" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">下面是一个仅使用字符串的示例:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="a064" class="nb ma in mx b gy nc nd l ne nf">const ITEMS_PER_PAGE = 10</span><span id="76fb" class="nb ma in mx b gy ng nd l ne nf">let data = []<br/>let nShown = 0</span><span id="0e2c" class="nb ma in mx b gy ng nd l ne nf">let nextPage = () =&gt; nShown += ITEMS_PER_PAGE</span><span id="a1c0" class="nb ma in mx b gy ng nd l ne nf">let $list = document.getElementById('list')<br/>let $loadMore = document.getElementById('load-more')</span><span id="ac42" class="nb ma in mx b gy ng nd l ne nf">let createItem = item =&gt; `<br/>  &lt;li class="list-item"&gt;<br/>    &lt;span class="item-title"&gt;${item.title}&lt;/span&gt;<br/>    &lt;span class="item-price"&gt;${item.price}&lt;/span&gt;<br/>  &lt;/li&gt;<br/>`<br/>let appendItems = () =&gt; {<br/>  let itemsToShow = data.slice(nShown, nShown + ITEMS_PER_PAGE)<br/>  let $t = document.createElement('template')<br/>  $t.content.innerHTML = itemsToShow.map(createItem).join('')<br/>  $list.append($t.content)<br/>}</span><span id="8f0d" class="nb ma in mx b gy ng nd l ne nf">let onLoadMore = () =&gt; {<br/>  appendItems()<br/>  nextPage()<br/>}</span><span id="2f7e" class="nb ma in mx b gy ng nd l ne nf">$loadMore.onclick = onLoadMore</span><span id="7dda" class="nb ma in mx b gy ng nd l ne nf">onLoadMore()</span></pre><p id="a397" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">需要注意一些事情:</p><p id="9594" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我使用模板字符串将数据嵌入到生成的HTML中。这意味着你必须小心数据的来源。如果是用户提供的数据，你有可能成为XSS攻击的牺牲品，所以你应该采取额外的措施来确保数据是经过净化的(例如，不包含HTML)。</p><p id="9886" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们首先使用一个<code class="fe ni nj nk mx b">template</code>元素来收集新创建的项目。<code class="fe ni nj nk mx b">template</code>元素的工作方式类似于<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" rel="noopener ugc nofollow" target="_blank">文档片段</a>，除了它支持<code class="fe ni nj nk mx b">innerHTML</code>属性，而后者不支持。</p><h2 id="5ff2" class="nb ma in bd mb nl nm dn mf nn no dp mj kx np nq ml lb nr ns mn lf nt nu mp nv bi translated">使用字符串和DOM节点创建列表项</h2><p id="9880" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">下面是一个使用组合字符串和DOM节点的示例:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="9c96" class="nb ma in mx b gy nc nd l ne nf">const ITEMS_PER_PAGE = 10</span><span id="473c" class="nb ma in mx b gy ng nd l ne nf">let data = []<br/>let nShown = 0</span><span id="adf2" class="nb ma in mx b gy ng nd l ne nf">let nextPage = () =&gt; nShown += ITEMS_PER_PAGE</span><span id="9efb" class="nb ma in mx b gy ng nd l ne nf">let $list = document.getElementById('list')<br/>let $loadMore = document.getElementById('load-more')</span><span id="99db" class="nb ma in mx b gy ng nd l ne nf">let createItem = item =&gt; {<br/>  let $el = document.createElement('li')<br/>  $el.className = 'list-item'<br/>  $el.innerHTML = `<br/>    &lt;span class="item-title"&gt;${item.title}&lt;/span&gt;<br/>    &lt;span class="item-price"&gt;${item.price}&lt;/span&gt;<br/>  `<br/>  return $el<br/>}<br/>let appendItems = () =&gt; {<br/>  let itemsToShow = data.slice(nShown, nShown + ITEMS_PER_PAGE)<br/>  $list.append(...itemsToShow.map(createItem))<br/>}</span><span id="45bf" class="nb ma in mx b gy ng nd l ne nf">let onLoadMore = () =&gt; {<br/>  appendItems()<br/>  nextPage()<br/>}</span><span id="ddf2" class="nb ma in mx b gy ng nd l ne nf">$loadMore.onclick = onLoadMore</span><span id="2e20" class="nb ma in mx b gy ng nd l ne nf">onLoadMore()</span></pre><p id="58da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与只有字符串的版本不同，我们不必使用<code class="fe ni nj nk mx b">template</code>元素来创建DOM节点。作为一种折衷，我们不能将顶级列表项元素本身定义为字符串。</p><h2 id="1c92" class="nb ma in bd mb nl nm dn mf nn no dp mj kx np nq ml lb nr ns mn lf nt nu mp nv bi translated">添加事件侦听器</h2><p id="444f" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">这两种方法之间的区别不仅仅是表面上的。使用第二种方法，我们可以引用列表项节点，而不必选择它。因此，在我可能需要添加事件侦听器和类似于列表项节点或其子节点的情况下，我更喜欢第二种方法。</p><p id="bb59" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也就是说，选择节点通常是一种优化良好的操作，所以我不期望它会对性能产生明显的影响。</p><p id="1bf4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看如何在这两种情况下添加事件侦听器。</p><p id="e971" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先是只有字符串的方法:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="e667" class="nb ma in mx b gy nc nd l ne nf">let appendItems = () =&gt; {<br/>  let itemsToShow = data.slice(nShown, nShown + ITEMS_PER_PAGE)<br/>  let $t = document.createElement('template')<br/>  $t.content.innerHTML = itemsToShow.map(createItem).join('')<br/>  <strong class="mx io">$t.content.querySelectorAll('.buy-now')</strong>.forEach(($btn, idx) =&gt; {<br/>    let dataIdx = nShown + idx<br/>    <strong class="mx io">$btn.onclick = () =&gt; onBuyNow(dataIdx)</strong><br/>  })<br/>  $list.append($t.content)<br/>}</span></pre><p id="019d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用混合方法:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="0d61" class="nb ma in mx b gy nc nd l ne nf">let appendItems = () =&gt; {<br/>  let itemsToShow = data.slice(nShown, nShown + ITEMS_PER_PAGE)<br/>  $list.append(...itemsToShow.map((item, idx) =&gt; {<br/>    let $el = createItem(item)<br/>    let dataIdx = nShown + idx<br/>    <strong class="mx io">$el.querySelector('.buy-now').onclick = () =&gt; onBuyNow(dataIdx)</strong><br/>  }))<br/>}</span></pre><p id="9d22" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于这两种方法，我们也可以使用延迟事件处理程序。延迟处理程序被绑定到所有列表项的公共祖先(通常是直接的父节点)，我们计算侦听器中的实际目标是什么。</p><p id="6d85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在基于字符串的节点创建中，我们可以避免使用延迟事件处理程序选择创建的节点，因此延迟事件侦听器有时可以稍微简化代码。不过，延迟事件处理程序没有那么高效，所以这是一种权衡。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="13b0" class="nb ma in mx b gy nc nd l ne nf">let appendItems = () =&gt; {<br/>  let itemsToShow = data.slice(nShown, nShown + ITEMS_PER_PAGE)<br/>  let $t = document.createElement('template')<br/>  $t.content.innerHTML = itemsToShow.map(createItem).join('')<br/>  $list.append($t.content)<br/>}</span><span id="622b" class="nb ma in mx b gy ng nd l ne nf">$list.onclick = ev =&gt; {<br/>  let $realTarget = ev.target.closest('.buy-now')<br/>  if ($realTarget) onBuyNow($realTarget.dataset.index)<br/>}</span></pre><p id="8f88" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个例子中，我正在进行检查，以确定是否需要对click事件做出反应。使用<code class="fe ni nj nk mx b">Element.closest()</code>的检查测试被点击的元素是或者包含在一个<code class="fe ni nj nk mx b">.buy-now</code>元素中。为了让上面的例子正常工作，我将在按钮上使用一个<code class="fe ni nj nk mx b">data-index</code>属性来计算出我们正在谈论的项目，否则事件监听器将无法访问这些信息。</p><h1 id="116f" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">带有节点池的动态列表</h1><p id="676b" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">前面的动态列表示例只实现了在末尾添加新的条目。如果我们需要删除项目或者在中间插入新的项目呢？如何将物品从一个位置移动到另一个位置？为此，我将使用稍微不同的方法来维护节点池。</p><p id="cc08" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">节点池只是一个数组，包含对DOM节点的引用，这些引用与底层数据的顺序相同。这类似于我们对静态列表所做的，在静态列表中，我们为HTML页面中的元素创建了一个对节点集合的引用，但是我们是为动态创建的元素创建的。</p><p id="ec86" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">向列表中添加节点的基本操作与前面的例子相同，即使用列表元素的DOM节点创建动态列表。唯一的区别是，我们还在创建时将节点添加到节点池中。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="0f0c" class="nb ma in mx b gy nc nd l ne nf">const ITEMS_PER_PAGE = 10</span><span id="10a3" class="nb ma in mx b gy ng nd l ne nf">// State<br/>let data = []<br/>let nShown = 0</span><span id="0c94" class="nb ma in mx b gy ng nd l ne nf">// State manipulation<br/>let nextPage = () =&gt; nShown += ITEMS_PER_PAGE</span><span id="d57c" class="nb ma in mx b gy ng nd l ne nf">// DOM references<br/>let $list = document.getElementById('list')<br/><strong class="mx io">let $$listItems = []</strong><br/>let $loadMore = document.getElementById('load-more')</span><span id="5916" class="nb ma in mx b gy ng nd l ne nf">// DOM manipulation<br/>let createItem = (item) =&gt; {<br/>  let $el = document.createElement('li')<br/>  $el.className = 'list-item'<br/>  $el.innerHTML = `<br/>    &lt;span class="item-title"&gt;${item.title}&lt;/span&gt;<br/>    &lt;span class="item-price"&gt;${item.price}&lt;/span&gt;<br/>  `<br/>  return $el<br/>}<br/>let appendItems = () =&gt; {<br/>  let itemsToShow = data.slice(nShown, nShown + ITEMS_PER_PAGE)<br/>  let $$items = itemsToShow.map(createItem)<br/>  $list.append(...$$items)<br/><strong class="mx io">  $$listItems.push(...$items)</strong><br/>}</span><span id="5903" class="nb ma in mx b gy ng nd l ne nf">// Event handlers<br/>let onLoadMore = () =&gt; {<br/>  appendItems()<br/>  nextPage()<br/>}</span><span id="c4c3" class="nb ma in mx b gy ng nd l ne nf">// Event bindings<br/>$loadMore.onclick = onLoadMore</span><span id="8f80" class="nb ma in mx b gy ng nd l ne nf">// Initial view<br/>onLoadMore()</span></pre><p id="750d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">删除项目时，我会同时从数据和节点池中删除它们:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="77d0" class="nb ma in mx b gy nc nd l ne nf">// State manipulation<strong class="mx io"><br/>let deleteItem = idx =&gt; {<br/>  data.splice(idx, 1)<br/>  nShown--<br/>}</strong></span><span id="5a59" class="nb ma in mx b gy ng nd l ne nf">// DOM manipulation<br/>let createItem = (item) =&gt; {<br/>  let $el = document.createElement('li')<br/>  $el.className = 'list-item'<br/>  $el.innerHTML = `<br/>    &lt;span class="item-title"&gt;${item.title}&lt;/span&gt;<br/>    &lt;span class="item-price"&gt;${item.price}&lt;/span&gt;<br/><strong class="mx io">    &lt;button class="delete"&gt;Delete&lt;/button&gt;</strong><br/>  `<br/>  <strong class="mx io">$el.querySelector('.delete').onclick = () =&gt; onDeleteItem($el)</strong><br/>  return $el<br/>}<br/><strong class="mx io">let removeListItem = $item =&gt; {<br/>  $list.removeChild($item)<br/>  $$listItems.splice($$listItems.indexOf($item), 1)<br/>}</strong></span><span id="3e8b" class="nb ma in mx b gy ng nd l ne nf">// Event handlers<strong class="mx io"><br/>let onDeleteItem = $item =&gt; {<br/>  deleteItem($$listItems.indexOf($item))<br/>  removeListItem($item)<br/>}</strong></span></pre><p id="925d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为我总是确保<code class="fe ni nj nk mx b">$$listItems</code>阵列中的节点池与数据同步，所以我可以通过查找池中节点的索引来查找底层数据的索引。我还减少了显示的项目数，因为一个显示的项目被删除了。我也可以显示一个项目，而不是减少项目的数量。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="93bd" class="nb ma in mx b gy nc nd l ne nf">// State manipulation<strong class="mx io"><br/></strong>let deleteItem = idx =&gt; <strong class="mx io">data.splice(idx, 1)</strong></span><span id="9580" class="nb ma in mx b gy ng nd l ne nf">// DOM manipulation<br/>let removeListItem = $item =&gt; {<br/>  $list.removeChild($item)<br/>  $$listItems.splice($$listItems.indexOf($item), 1)<br/><strong class="mx io">  let newItem = data[nShown - 1]<br/>  let $newItem = createItem(newItem)<br/>  $list.append($newItem)<br/>  $$listItems.push($newItem)</strong><br/>}</span></pre><p id="865c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当插入或移动项目时，我们将再次对数据和节点池执行相同的操作。下面是一个插入的例子:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="090e" class="nb ma in mx b gy nc nd l ne nf">// State manipulation<br/><strong class="mx io">let insertItem = (idx, title, price) =&gt; {<br/>  data.splice(idx, 0, { title, price })<br/>  nShown++<br/>}</strong></span><span id="1721" class="nb ma in mx b gy ng nd l ne nf">// DOM references<br/><strong class="mx io">$titleField = document.getElementById('title-field')<br/>$priceField = document.getElementById('price-field')</strong></span><span id="c6c5" class="nb ma in mx b gy ng nd l ne nf">// DOM manipulation<br/>let createItem = (item) =&gt; {<br/>  let $el = document.createElement('li')<br/>  $el.className = 'list-item'<br/>  $el.innerHTML = `<br/><strong class="mx io">    &lt;button class="insert"&gt;Insert new item here&lt;/button&gt;</strong><br/>    &lt;span class="item-title"&gt;${item.title}&lt;/span&gt;<br/>    &lt;span class="item-price"&gt;${item.price}&lt;/span&gt;<br/>    &lt;button class="delete"&gt;Delete&lt;/button&gt;<br/>  `<br/>  $el.querySelector('.delete').onclick = () =&gt; onDeleteItem($el)<br/><strong class="mx io">  $el.querySelector('.insert').onclick = () =&gt; onInsertItem($el)<br/></strong>  return $el<br/>}<br/><strong class="mx io">let insertListItemBefore = $item =&gt; {<br/>  let idx = $listItems.indexOf($item)<br/>  let item = data[idx]<br/>  let $newItem = createItem(item)<br/>  $list.insertBefore($newItem, $item)<br/>  $$listItems.splice(idx, 0, $newItem)<br/>}</strong></span><span id="dbc2" class="nb ma in mx b gy ng nd l ne nf">// Event handlers<br/><strong class="mx io">let onInsertItem = $item =&gt; {<br/>  insertItem(<br/>    $$listItems.indexOf($item),<br/>    $titleField.value<br/>    $priceField.value<br/>  )<br/>  insertListItemBefore($item)<br/>}</strong></span></pre><h1 id="f0bd" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">使用节点池交换列表</h1><p id="fe38" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">还有另一种情况，我会使用节点池。如果列表不断用全新的数据集更新，我会保留池并更新现有的项目，而不是每次都创建全新的项目。这是一种结合了前面例子中使用的各种技术的方法。</p><p id="5915" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的例子中，我们从HTML页面中的一个静态列表开始，有足够的元素来覆盖通常的情况。这些列表项元素会立即添加到池中。然后，随着数据集的增长，池会扩展，但元素不会被删除，而是被隐藏。为了简单起见，我们不做“加载更多”的部分。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="11f1" class="nb ma in mx b gy nc nd l ne nf">let $list = document.getElementById('list')<br/>let $$listItems = []</span><span id="1fe3" class="nb ma in mx b gy ng nd l ne nf">let createItem = item =&gt; {<br/>  let $el = document.createElement('li')<br/>  $el.className = 'list-item'<br/>  $el.innerHTML = `<br/>    &lt;span class="item-title"&gt;${item.title}&lt;/span&gt;<br/>    &lt;span class="item-price"&gt;${item.price}&lt;/span&gt;<br/>    &lt;button class="delete"&gt;Delete&lt;/button&gt;<br/>  `<br/>  $el.querySelector('.delete').onclick = () =&gt; onDeleteItem($el)<br/>  return $el<br/>}<br/>let updateItem = ($item, item) =&gt; {<br/>  $item.querySelector('.item-title').textContent = item.title<br/>  $item.querySelector('.item-price').textContent = item.price<br/>  $item.classList.remove('hidden')<br/>}<br/>let updateList = () =&gt; {<br/>  let $$createdItems = []<strong class="mx io">  <br/>  </strong>data.forEach(function (item, idx) {<br/>    let $item = $$listItems[idx]<br/>    if ($item == null) {<br/>      $item = createItem(item)<br/>      $$listItems.push($item)<br/>      $$createdItems.push($item)<br/>    }<br/>    else updateItem($item)<br/>  })<br/>  $list.append(...$createdItems)<br/><strong class="mx io">  </strong>for (let i = data.length, l = $$listItems.length; i &lt; l; i++) {<br/>    $$listItems[i].classList.add('hidden')<br/>  }<br/>}<br/>let deleteListItem = $item =&gt; {<br/>  $item.classList.add('hidden')<br/>  $$listItems.splice($$listItems.indexOf($item), 1)<br/>  $$listItems.push($item)<br/>}</span></pre><h1 id="ad70" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">排序列表</h1><p id="ef46" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">在对列表进行排序时，我们总是从数据开始，并将排序后的数据同步到DOM。因为我们有几种不同的方法来管理列表，所以我们也有几种不同的方法来将排序后的数据转换成DOM操作。</p><p id="599a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们没有在任何给定的时间显示整个列表时，我通常的做法是简单地做与呈现列表项相同的事情:我对数据进行排序，然后更新所有呈现的列表项以匹配数据。</p><p id="efe1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们要显示整个列表，那么只对DOM节点重新排序会更有效。一个简单的实现只是简单地按照节点在数据中出现的顺序添加节点。在大多数情况下，这种方式非常有效。然而，要做到这一点，我们需要一个将数据映射到节点的索引。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="4a93" class="nb ma in mx b gy nc nd l ne nf">// State<br/>let data = []</span><span id="d015" class="nb ma in mx b gy ng nd l ne nf">// State manipulation<br/>let sortByPrice = () =&gt; data.sort((a, b) =&gt; <br/>  a.price - b.price)<br/>let sortByTitle = () =&gt; data.sort((a, b) =&gt; <br/>  a.title.localeCompare(b.title))</span><span id="ccd1" class="nb ma in mx b gy ng nd l ne nf">// DOM references<br/>let $list = document.getElementById('list')<br/>let $sortByTitle = document.getElementById('sort-title')<br/>let $sortByPrice = document.getElementById('sort-price')<br/><strong class="mx io">let listItemIndex = new Map()</strong></span><span id="4110" class="nb ma in mx b gy ng nd l ne nf">// DOM manipulation<br/>let createItem = item =&gt; {<br/>  let $el = document.createElement('li')<br/>  $el.className = 'list-item'<br/>  $el.innerHTML = `<br/>    &lt;span class="item-title"&gt;${item.title}&lt;/span&gt;<br/>    &lt;span class="item-price"&gt;${item.price.toFixed(2)}&lt;/span&gt;<br/>  `<br/>  return $el<br/>}<br/>let appendItems = () =&gt; {<br/>  let $$items = data.map(item =&gt; {<br/>    let $item = createItem(item)<br/>    <strong class="mx io">listItemIndex.set(item, $item)</strong><br/>    return $item<br/>  })<br/>  $list.append(...$$items)<br/>}<br/><strong class="mx io">let sortListItems = () =&gt; {<br/>  let $$sortedItems = data.map(item =&gt; listItemIndex.get(item))<br/>  $list.append(...$$sortedItems)<br/>}</strong></span><span id="a8f0" class="nb ma in mx b gy ng nd l ne nf">// Event handlers<br/>let onSortByTitle = () =&gt; {<br/>  sortByTitle()<br/>  sortListItems()<br/>}<br/>let onSortByPrice = () =&gt; {<br/>  sortByPrice()<br/>  sortListItems()<br/>}</span><span id="bc11" class="nb ma in mx b gy ng nd l ne nf">// Event bindings<br/>$sortByTitle.onclick = onSortByTitle<br/>$sortByPrice.onclick = onSortByPrice</span><span id="622f" class="nb ma in mx b gy ng nd l ne nf">// Initial view<br/>appendItems()</span></pre><p id="4f19" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感兴趣的函数是上面代码片段中突出显示的<code class="fe ni nj nk mx b">sortListItems()</code>。当节点被附加到新位置时，它们会自动从先前的位置移除。我利用了这一点，只是按照正确的(更新后的)顺序将节点附加到父节点。</p><h1 id="3a5b" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">渲染和回流性能改进</h1><p id="c8f9" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">使用列表时，如果列表项的大小保持不变，而与内容无关，则可以对列表项使用以下CSS规则来提高呈现性能:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="5d76" class="nb ma in mx b gy nc nd l ne nf">.list-item {<br/>  contain: content;<br/>}</span></pre><p id="a44c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在MDN 上阅读更多关于<code class="fe ni nj nk mx b">contain</code>属性<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/CSS/contain" rel="noopener ugc nofollow" target="_blank">的内容，但它的缺点是它向浏览器表明这些项目可以独立于页面的其余部分重新呈现。这加快了布局计算的速度。</a></p><h1 id="341e" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">结论</h1><p id="f571" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">这是关于普通JS应用程序中DOM操作的两部分系列和我的普通JS开发系列的结论。不过，这不是我就这个话题写的最后一篇文章。在以后的文章中，我希望分享我在继续追求简化前端开发(对我来说)的过程中遇到的更高级的小细节。</p><h1 id="86bc" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated"><em class="nw">你愿意全职和香草JS一起工作吗？</em></h1><p id="c151" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated"><em class="nh">如果你想加入一个遵循上述原则的团队，你可能会有兴趣了解一下</em><a class="ae lk" href="https://coinmetrics.io/" rel="noopener ugc nofollow" target="_blank"><em class="nh">Coin Metrics</em></a><em class="nh">是</em> <a class="ae lk" href="https://boards.greenhouse.io/coinmetrics/jobs/4031704004" rel="noopener ugc nofollow" target="_blank"> <em class="nh">招聘</em> </a> <em class="nh">(香草)JavaScript开发人员加入他们的前端工程团队。</em></p><p id="1081" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nh">更多内容请看</em><a class="ae lk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nh">plain English . io</em></a><em class="nh">。报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">免费周报在这里</em> </a> <em class="nh">。</em></p></div></div>    
</body>
</html>