<html>
<head>
<title>Create a Breadcrumb Component With React and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和TypeScript创建面包屑组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-breadcrumb-component-with-react-and-typescript-46863155dcea?source=collection_archive---------4-----------------------#2021-01-25">https://javascript.plainenglish.io/create-a-breadcrumb-component-with-react-and-typescript-46863155dcea?source=collection_archive---------4-----------------------#2021-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c900" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一次性增强搜索结果和用户导航</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8df09bbfd40e97e5df75e36bc644d9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7QhXZnUzsYSEOIjP"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lintaho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Linhao Zhang</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0d46" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">网页上的面包屑轨迹指示用户当前在网站层级中的位置。它可以帮助用户更有效地浏览网站。面包屑允许用户在网站的层次结构中一次向上导航一级。本文探讨了如何在React和Typescript中用不到50行代码轻松实现breadcrumb。</p><p id="3b75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">创建面包屑的目标有两个。面包屑为用户提供了一种导航网站结构的简单方法。此外，正确的实现丰富了搜索引擎的搜索结果。后者通过提供结构化数据来实现。</p><h1 id="ee20" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结构数据</h1><p id="24a2" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">首先，让我们更深入地了解结构化数据。搜索引擎尽最大努力解析和理解它们所抓取的网站的结构。但他们对特定网页上的内容了解有限。</p><p id="881b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">结构化数据为搜索引擎提供了关于网页内容的附加信息。有各种类型的结构化数据。关于食谱、书籍、评论、文章等等的信息都可以添加到网页上。</p><p id="675e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Schema.org为谷歌、微软、雅虎和Yandex支持的结构化数据提供了一个共享词汇表。值得注意的一点是，并不是所有的模式都能增强最终用户的搜索体验。</p><p id="98c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">哪些模式有助于你的网站在搜索结果中显示更丰富的功能，可以在谷歌的的<a class="ae ks" href="https://developers.google.com/search/docs/guides/search-gallery" rel="noopener ugc nofollow" target="_blank">搜索图库中找到。一个</a><a class="ae ks" href="https://developers.google.com/search/docs/data-types/breadcrumb" rel="noopener ugc nofollow" target="_blank">的面包屑</a>是显示导航的模式的一个例子，它指示页面在站点层次结构中的位置。</p><p id="610b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在网页上包含结构化数据有多种格式。最值得注意的是<a class="ae ks" href="https://json-ld.org/" rel="noopener ugc nofollow" target="_blank"> JSON-LD </a>和<a class="ae ks" href="https://www.w3.org/TR/microdata/" rel="noopener ugc nofollow" target="_blank">微数据</a>。使用JSON-LD，数据包含在页面的脚本标记中。相比之下，微数据将元数据嵌套在页面的现有内容中。使用这种格式，HTML属性被用来在网页上嵌入简单的机器可读数据。</p><p id="3782" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文使用微数据，因为它减少了所需的代码量。用同样的代码达到了帮助用户和搜索引擎的目的，一举两得。</p><h1 id="b0cf" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">微观数据</h1><p id="e16e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">微数据是一个<a class="ae ks" href="https://www.w3.org/TR/microdata/" rel="noopener ugc nofollow" target="_blank"> HTML标准</a>。本质上，微数据由一组名称-值对组成。每个组称为一个项目。特定的名称-值对描述了项目的属性。</p><p id="9271" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了指定一个项目，将<code class="fe mm mn mo mp b">itemscope</code>属性添加到一个元素中。当添加这个属性时，您就声明了该元素中包含的HTML是关于某个项目的。</p><p id="0362" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">项目有一定的类型。这是由<code class="fe mm mn mo mp b">itemtype</code>属性指定的。项目类型以URL的形式提供给<a class="ae ks" href="http://schema.org" rel="noopener ugc nofollow" target="_blank">schema.org</a>网站。</p><p id="1751" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">项目的附加信息在其属性中定义。这些是通过向元素添加一个或多个<code class="fe mm mn mo mp b">itemprop</code>属性来声明的。这些属性被附加到该项目的嵌套元素上。属性可以是字符串或URL。后者通常使用<code class="fe mm mn mo mp b">&lt;a&gt;</code>元素及其href属性来表示。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5d42" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面提供了一个关于电影的微数据的例子。外部div元素通过将itemscope属性及其itemtype设置为<a class="ae ks" href="http://schema.org/Movie" rel="noopener ugc nofollow" target="_blank"> movie </a>来定义电影项目。嵌套元素都描述了电影的某些属性。它们所描述的是使用itemprop属性声明的。</p><p id="5200" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个相当简单的例子。然而，有时项目属性的值本身可以是另一个具有自己的属性集的项目。下一节将对此进行说明。</p><h1 id="0d0c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">利润</h1><p id="335e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在<a class="ae ks" href="https://developers.google.com/search/docs/data-types/breadcrumb" rel="noopener ugc nofollow" target="_blank">谷歌搜索中心</a>可以找到面包屑微数据的例子。使用有序列表，其中列表元素用&gt;字符可视地分开。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="aa93" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">外部的<code class="fe mm mn mo mp b">&lt;ol&gt;</code>标签定义了一个名为BreadcrumbList的微数据项。这种类型的精确属性可以在<a class="ae ks" href="https://schema.org/BreadcrumbList" rel="noopener ugc nofollow" target="_blank">这里</a>找到。该列表包含三个元素，每个元素描述一个itemListElement，它是BreadcrumbList的一个属性。</p><p id="d647" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上一节中，我们注意到，有时一个项目属性的值本身可以是另一个具有自己的属性集的项目。面包屑列表的属性就是这种情况。列表元素本身就是一个项目，即ListItem。</p><p id="9d77" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可以观察到ListItem的三个属性。url，由元素的<em class="ms">项目</em>属性、<em class="ms">名称</em>和<em class="ms">位置</em>表示。请注意，该位置以1而不是0开始。</p><h1 id="052a" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">功能组件和道具</h1><p id="752b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">现在，让我们开始考虑React组件以及呈现上述标记的组件所需的数据。变量是已知的，因此为组件的属性创建类型定义相对简单。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b3cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">传递给组件的数据是breadcrumb元素的数组，每个元素都有一个<code class="fe mm mn mo mp b">url</code>和<code class="fe mm mn mo mp b">name</code>，它们都是字符串。让我们将用户界面分解成React的组件层次结构。</p><p id="230f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可以发现最后一部分的标记中的重复元素:条目列表。这由两个功能组件实现，一个用于<code class="fe mm mn mo mp b">Breadcrumb</code>本身，另一个用于其中的元素:<code class="fe mm mn mo mp b">BreadcrumbItem</code>。</p><p id="9b09" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">面包屑功能组件接收<code class="fe mm mn mo mp b">BreadcrumbProps</code>作为参数。该组件可以实现为:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="112b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">列表被包装在一个<code class="fe mm mn mo mp b">nav</code>标签中，因为内容定义了一个导航链接块。使用(稍微修改的)<a class="ae ks" href="http://getbem.com/" rel="noopener ugc nofollow" target="_blank"> BEM </a>方法添加类名，以允许以后进行样式化。其余的标记与上面显示的HTML示例完全一样。需要注意的一点是，属性在camelCase中，这是React中所有DOM属性的预期属性。</p><p id="af7e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">组件接收的breadcrumb条目的数组是使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> map </a>函数呈现的，该函数将<code class="fe mm mn mo mp b">BreadcrumbItemProps</code>对象映射到<code class="fe mm mn mo mp b">BreadcrumbItem</code>组件。</p><p id="3335" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mm mn mo mp b">BreadcrumbItem</code>组件需要四个变量:<code class="fe mm mn mo mp b">url</code>、<code class="fe mm mn mo mp b">name</code>、<code class="fe mm mn mo mp b">index</code>和一个名为<code class="fe mm mn mo mp b">isLast</code>的布尔变量。前两个由数组中当前对象的属性提供，使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展语法</a>。通过将正在处理的当前元素的索引加1来传递position属性。</p><p id="4d89" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果某个<code class="fe mm mn mo mp b">BreadcrumbItem</code>是列表的最后一个元素，则不应该呈现可视分隔符。因此，组件需要知道它是否是最后一项。这是通过检查map函数中当前项的索引是否等于数组长度减一(因为索引从零开始)来实现的。</p><p id="443a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后但同样重要的是，添加了一个<code class="fe mm mn mo mp b">key</code>属性，这不是传递给组件本身的属性。<a class="ae ks" href="https://reactjs.org/docs/lists-and-keys.html" rel="noopener ugc nofollow" target="_blank">键</a>是内部反应。它帮助React识别哪些项目已经更改、添加或删除。应该给数组内部的元素赋予键，以给元素一个稳定的标识。在代码中，索引被用作关键字。</p><p id="5319" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mm mn mo mp b">BreadcrumbItem</code>可以按如下方式实现:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2e5d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mm mn mo mp b">isLast</code>参数用于有条件地渲染分割线。当显示分隔线时，组件将返回多个DOM元素，因此它被包装在一个<code class="fe mm mn mo mp b">Fragment</code>中。<a class="ae ks" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank"> Fragments </a>让您不用向DOM添加额外的节点就可以对孩子列表进行分组。</p><h1 id="1913" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">丰富结果的验证</h1><p id="9959" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">面包屑现在可以呈现如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="666c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">breadcrumb变量是一个遵循<code class="fe mm mn mo mp b">BreadcrumbProps</code>接口的对象。有许多方法可以达到这个目的。它可以被定义在你的服务器上的一个文件中，或者你可以从后端接收它。出于演示的目的，它被硬编码在一个常量变量中。</p><p id="9169" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该组件呈现以下html:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c25f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可以使用Google的<a class="ae ks" href="https://search.google.com/test/rich-results" rel="noopener ugc nofollow" target="_blank"> Rich Results Test </a>来验证呈现的HTML。代码可以粘贴在那里，它将显示该页面有资格获得丰富的结果。面包屑的功能已经完成。</p><p id="0fa4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">唯一剩下的事情就是设计面包屑的样式。这将留给读者作为练习，因为有太多的方法可以达到这个目的。由于有许多方法，造型会根据情况有很大的不同。</p><h1 id="1144" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="0dfb" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">本文展示了一种实现包含结构化数据的面包屑的简单方法。感谢您的阅读！我鼓励你去探索其他可以用来丰富网页搜索结果的模式。</p><p id="297a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文展示了一个微数据示例。然而，当内容还没有出现在页面上时，使用JSON-LD可能更简单。可以看一下<a class="ae ks" href="https://github.com/google/react-schemaorg" rel="noopener ugc nofollow" target="_blank"> React Schemaorg </a>，它提供了两个npm包。其中一个以JSON-LD格式为Schema.org的<a class="ae ks" href="http://schema.org/" rel="noopener ugc nofollow" target="_blank">词汇表提供了类型定义。而另一个提供了在React应用中轻松插入有效的Schema.org</a><a class="ae ks" href="http://schema.org/" rel="noopener ugc nofollow" target="_blank">JSON-LD的方法。</a></p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="69f6" class="lp lq in bd lr ls na lu lv lw nb ly lz jt nc ju mb jw nd jx md jz ne ka mf mg bi translated">资源</h1><div class="nf ng gp gr nh ni"><a href="https://schema.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">Schema.org-Schema.org</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Schema.org是一个协作性的社区活动，它的任务是创建、维护和推广…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">schema.org</p></div></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://schema.org/BreadcrumbList" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">面包屑列表</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Schema.org类型:面包屑列表——面包屑列表是一个项目列表，由一系列链接的网页组成，通常…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">schema.org</p></div></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://developers.google.com/search/docs/guides/search-gallery" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">探索搜索库和丰富的结果|谷歌搜索中心</h2><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">developers.google.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw km ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://developers.google.com/search/docs/data-types/breadcrumb" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">面包屑|谷歌搜索中心|谷歌开发者</h2><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">developers.google.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw km ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://www.w3.org/TR/microdata/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">HTML微数据</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">这个[html-extensions]规范定义了新的html属性，以便在HTML中嵌入简单的机器可读数据…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">www.w3.org</p></div></div></div></a></div></div></div>    
</body>
</html>