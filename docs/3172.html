<html>
<head>
<title>Implement Debouncing in React in 3 Different Ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以3种不同的方式在React中实现去抖</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-debouncing-in-react-f3316ef344f5?source=collection_archive---------0-----------------------#2021-06-28">https://javascript.plainenglish.io/implementing-debouncing-in-react-f3316ef344f5?source=collection_archive---------0-----------------------#2021-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="13a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">去抖动用于优化web应用的性能。这是通过限制特定功能的执行速率(也称为速率限制)来实现的。</p><p id="2a7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将通过在带有onChange事件的输入框中实现去抖动来学习它。当我们在这个输入框中输入内容时，每次击键都会调用一个API。如果我们进入Chrome的network选项卡，在输入框中输入results，我们会看到在我们输入的每个字母上，都有一个网络/API调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b7e3cd7f5515543dc2921556e8ed125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Nv55lGOJ7lea_V5Y_kNBw.png"/></div></div></figure><p id="c2fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从性能的角度来看，这并不好，因为如果用户在输入框中输入50或100个字符，那么将会进行50-100次API调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/54a092c1038808d020819b7ce351999a.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*jbeUxZIZcrdOtAziDiu0DQ.gif"/></div></figure><p id="de1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在去抖的帮助下修复它。</p><h1 id="962e" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">方法1:从头开始实施</strong></h1><p id="cdee" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">让我们做一个函数去抖。它将返回另一个函数(优化的函数)。该函数背后的逻辑是，只有当两次按键事件之间的时间大于500毫秒时，才会从API获取数据。如果延迟超过500毫秒，只有这时才会调用<em class="ly"> handleChange </em>函数。</p><p id="203d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用apply函数来修复我们的上下文。如果这两个击键事件之间的延迟小于500 ms，那么我们应该清除这个setTimeout(定时器变量)。我们将使用这个优化的函数(从去抖函数返回)，而不是直接调用handleChange方法。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="9818" class="me kw in ma b gy mf mg l mh mi">const debounce = (func) =&gt; {<br/>    let timer;<br/>    return function (...args) {<br/>      const context = this;<br/>      if (timer) clearTimeout(timer);<br/>      timer = setTimeout(() =&gt; {<br/>        timer = null;<br/>        func.apply(context, args);<br/>      }, 500);<br/>    };<br/>  };</span><span id="a049" class="me kw in ma b gy mj mg l mh mi">const handleChange = (value) =&gt; {<br/>    fetch(`<a class="ae mk" href="https://demo.dataverse.org/api/search?q=${value}`" rel="noopener ugc nofollow" target="_blank">https://demo.dataverse.org/api/search?q=${value}`</a>)<br/>      .then((res) =&gt; res.json())<br/>      .then((json) =&gt; setSuggestions(json.data.items));<br/>  };</span></pre><p id="fd73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以在Chrome的网络标签中查看，并输入结果。当我们在输入框中输入完整的结果时，只有一两次调用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/c89f1b68fdd687df5b95d64f9cddfb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7eYong3TOpQ0vfB60pKeQ.png"/></div></div></figure><p id="741d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的去抖将在每次渲染时返回一个新的函数。这是我们不想要的，所以我们将使用<em class="ly"> useCallBack </em>钩子。它将为我们提供记忆回调。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="85f6" class="me kw in ma b gy mf mg l mh mi">const optimizedFn = useCallback(debounce(handleChange), []);</span></pre><p id="7b8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是从头开始实现去抖的完整代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="bae0" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">方法2:使用lodash</h1><p id="35b0" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">另一种实现去抖的方法是使用<a class="ae mk" href="https://www.npmjs.com/package/lodash" rel="noopener ugc nofollow" target="_blank"> lodash </a>。Lodash提供了一个去抖方法，我们可以用它来限制handleChange函数的执行速率。只需用去抖方法包装回调函数，并提供我们想要的两个事件之间的延迟量。现在，如果你回到Chrome上检查，它的工作原理是一样的。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="661e" class="me kw in ma b gy mf mg l mh mi">import { debounce } from "lodash";</span><span id="f94b" class="me kw in ma b gy mj mg l mh mi">const handleChangeWithLib = debounce((value) =&gt; {<br/>    fetch(`<a class="ae mk" href="https://demo.dataverse.org/api/search?q=${value}`" rel="noopener ugc nofollow" target="_blank">https://demo.dataverse.org/api/search?q=${value}`</a>)<br/>      .then((res) =&gt; res.json())<br/>      .then((json) =&gt; setSuggestions(json.data.items));<br/>  }, 500);</span></pre><h1 id="918c" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">方法3:使用反作用-去抖-输入</h1><p id="f6b5" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我们还可以使用一个名为<a class="ae mk" href="https://www.npmjs.com/package/react-debounce-input" rel="noopener ugc nofollow" target="_blank"> react-debounce-input </a>的npm包。与前两种方法相比，这是最简单的方法。只需使用react-debounce-Input库提供的DebounceInput，而不是使用普通的input标记。并提供延迟作为属性。现在，如果我们回到Chrome，再次检查，只有当我们完全输入结果时，才会调用。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="3b88" class="me kw in ma b gy mf mg l mh mi">&lt;DebounceInput<br/>     minLength={2}<br/>     className="search"<br/>     placeholder="Enter something here..."<br/>     debounceTimeout={500}<br/>     onChange={e =&gt; handleChange(e.target.value)} /&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/5aa8bf2f52c5072781c8a6fcf6c78d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*1Tfzeh5N__cKiQU0IrksrA.gif"/></div></figure><p id="a053" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是React中实现去抖的3种不同方法。我希望你们中的一些人会发现这些对我很有用。</p><p id="3c45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看这个GitHub资源库，获取源代码:s <a class="ae mk" href="https://github.com/ankitsaxena21/react-debounce-tutorial" rel="noopener ugc nofollow" target="_blank">源代码链接</a></p><p id="59e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">视频解释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mn l"/></div></figure><p id="fc24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ly">更多内容尽在</em><a class="ae mk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ly">plain English . io</em></strong></a></p></div></div>    
</body>
</html>