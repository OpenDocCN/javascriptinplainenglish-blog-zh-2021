<html>
<head>
<title>Camel Case Revisited: Optimizing String Conversion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Camel案例回顾:优化JavaScript中的字符串转换</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/camel-to-dash-revisited-optimizing-a-javascript-string-conversion-df6610dc6804?source=collection_archive---------17-----------------------#2021-08-30">https://javascript.plainenglish.io/camel-to-dash-revisited-optimizing-a-javascript-string-conversion-df6610dc6804?source=collection_archive---------17-----------------------#2021-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1f453156382ad44fdc977f2cfe1106cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWw0ej-MLc43gQINoyiv3A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image provided by <a class="ae kc" href="https://www.freepik.com/vectorjuice" rel="noopener ugc nofollow" target="_blank">vectorjuice</a> on <a class="ae kc" href="https://www.freepik.com" rel="noopener ugc nofollow" target="_blank">freepik.com</a></figcaption></figure><p id="2a85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你好，谢谢你过来。如果您来到这里是因为想学习更多关于JavaScript和性能测试的知识，那么您来对地方了。在之前的一篇文章中，我们仔细检查了一段代码，这段代码将一个用camelCase编写的字符串翻译成dash语法中的等价字符串。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A code snippet</figcaption></figure><p id="2db6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，这个函数会将JavaScript对象上的<code class="fe lh li lj lk b">dataTarget</code>转换成DOM元素上的<code class="fe lh li lj lk b">data-target</code>。我们深入了解了这一功能的复杂性，总体来说玩得很开心。</p><p id="305b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我骄傲地喝着咖啡，欣赏这篇完成的文章时，我注意到了另一位作者Jason Knight的评论，他指出了一些低效之处，并提出了一些优化代码速度的方法。</p><p id="6dfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，虽然上面的函数完成了工作，但是它可能没有它应该完成的速度快，尤其是如果您必须多次运行它的话。所以我做了一些测试，看看不同的方法是否能让字符串转换运行得更快。</p><p id="75f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了上面的函数，我还尝试了Jason建议的另外两个函数:一个使用三元运算符，另一个使用预定义的常数。作为第四种方法，我尝试了一个既有三元运算符又有预定义常数的函数。</p><p id="c9cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每个测试，我运行给定的函数一百万次。为什么？因为当运算数量增加时，算法效率的差异通常会变得更加明显。</p><p id="5f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测量速度，我在每个百万函数循环的开始和结束时使用了JavaScript的<code class="fe lh li lj lk b">performance.now()</code>方法来测量所用的时间。</p><p id="d121" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的预测是，这两种方法——三元运算符和预定义常数——都会带来明显更好的性能。我还觉得在一个函数中同时使用这两种方法会给我们带来最快的结果。让我们看看我是不是对的。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="c64a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">该测试设备</h1><p id="415b" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我首先设置了我的测试设备，在那里我可以测试四种不同的字符串转换方法。如您所见，默认行为是运行给定的方法一百万次。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/e08379611720f06d805cc2efab9dbc7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6n7Pkrp7uJmYqNufz92LA.png"/></div></div></figure><p id="505b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是输入<code class="fe lh li lj lk b">nevinKatz</code>的结果。我们可以看到，将它转换成<code class="fe lh li lj lk b">nevin-katz</code>花了510毫秒，或者半秒多一点。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/c6b5f39fc638dcc31326bf64e8f0509a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kADf67MRsZcy0w4FCp1VQ.png"/></div></div></figure><p id="e812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在下面的代码栏中试用这个小工具。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mw lg l"/></div></figure><p id="55d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是底层标记。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The HTML markup for the tester.</figcaption></figure><p id="a2d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将在最后讨论CSS，但是首先，让我们关注测试、逻辑、结果以及我是如何解释它们的。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="0062" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测试</h1><p id="307a" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我的目标是比较四个不同的camel-to-dash函数将<code class="fe lh li lj lk b">nevinKatz</code>转换为<code class="fe lh li lj lk b">nevin-katz</code>一百万次所花费的时间。下面是四个函数。</p><ul class=""><li id="5ff7" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated"><code class="fe lh li lj lk b">regular</code>，就是我上面用的那个。</li><li id="d806" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe lh li lj lk b">ternary</code>，使用三元运算符代替if/then。</li><li id="50ab" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe lh li lj lk b">constants</code>，使用预定义的常量。</li><li id="10d9" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe lh li lj lk b">ternary_and_constants</code>，两种手法都用。</li></ul><p id="860d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我的CodePen测试，我创建了一个名为<code class="fe lh li lj lk b">converter</code>的对象来保存这些测试函数。</p><pre class="lb lc ld le gt nl lk nm nn aw no bi"><span id="6e91" class="np lt iq lk b gy nq nr l ns nt">let converter = {};</span></pre><p id="9f7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这些函数被附加到<code class="fe lh li lj lk b">converter</code>对象上，所以它们也可以被称为<code class="fe lh li lj lk b">methods</code>。让我们更详细地检查一下。</p><h2 id="0281" class="np lt iq bd lu nu nv dn ly nw nx dp mc ko ny nz mg ks oa ob mk kw oc od mo oe bi translated">正则函数</h2><p id="6edb" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我首先添加了我在上一篇文章中使用的函数，这次命名为<code class="fe lh li lj lk b">regular</code>。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The original camel-to-dash function, this time as a method attached to the converter object.</figcaption></figure><h2 id="727d" class="np lt iq bd lu nu nv dn ly nw nx dp mc ko ny nz mg ks oa ob mk kw oc od mo oe bi translated">三元运算符</h2><p id="3c82" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">下面是带有三元运算符的函数。问题是删除<code class="fe lh li lj lk b">if</code>语句是否会带来一些开销。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The ternary function.</figcaption></figure><h2 id="91b9" class="np lt iq bd lu nu nv dn ly nw nx dp mc ko ny nz mg ks oa ob mk kw oc od mo oe bi translated">预定义常数</h2><p id="fe32" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">下面是我们的<code class="fe lh li lj lk b">constants</code>函数以及它使用的三个预定义常数:</p><ul class=""><li id="e236" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated"><code class="fe lh li lj lk b">camelToDashRx</code>存储匹配大写字母的正则表达式<code class="fe lh li lj lk b">/[A-Z]/g</code>。</li><li id="ff28" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe lh li lj lk b">camelToDashFn</code>添加破折号并将字母改为小写。</li><li id="a876" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe lh li lj lk b">camelToDash</code>获取字符串中的每个大写字母，并通过<code class="fe lh li lj lk b">camelToDashFun</code>运行每个字母，添加破折号并使其小写。</li></ul><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A conversion function that uses constants.</figcaption></figure><h2 id="6a30" class="np lt iq bd lu nu nv dn ly nw nx dp mc ko ny nz mg ks oa ob mk kw oc od mo oe bi translated">带常数的三元</h2><p id="94d5" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">下面是同时使用三元运算符和预定义的<code class="fe lh li lj lk b">camelToDash</code>函数的方法，该函数被初始化为常量。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A function that uses both the ternary operator and the predefined camelToDash function.</figcaption></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="c5c5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测试逻辑</h1><p id="ba65" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">下面是程序启动时运行的测试逻辑。如您所见，我们为每个按钮添加了一个<code class="fe lh li lj lk b">click</code>监听器，按钮的<code class="fe lh li lj lk b">data-func</code>属性用于标识要调用的函数。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="e220" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看到我从输入框中拉出了<code class="fe lh li lj lk b">num-ops</code>，函数被调用了这个次数。对于这次行动，我只是把数字留在100万。</p><p id="b609" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是做繁重工作的循环，前后都有时间检查。在循环中，注意括号语法被用来访问<code class="fe lh li lj lk b">converter</code>上选择的函数。</p><pre class="lb lc ld le gt nl lk nm nn aw no bi"><span id="c886" class="np lt iq lk b gy nq nr l ns nt">let start = performance.now();</span><span id="a94d" class="np lt iq lk b gy of nr l ns nt">for (var i = 0; i &lt; num_ops; ++i) {                                         <br/>     output = converter[func](str);                                  <br/>}<br/>let end = performance.now();</span></pre><p id="9c54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在后面的函数中找到了<code class="fe lh li lj lk b">end</code>和<code class="fe lh li lj lk b">start</code>之间的差异来计算所用的时间。</p><pre class="lb lc ld le gt nl lk nm nn aw no bi"><span id="9486" class="np lt iq lk b gy nq nr l ns nt">let time_diff = parseFloat(end - start);</span></pre><p id="7f4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我承认<code class="fe lh li lj lk b">time_diff</code>会考虑到<code class="fe lh li lj lk b">for</code>循环产生的任何开销，但是我相信对于四个函数中的每一个来说，任何开销通常都是相同的。</p><h1 id="1451" class="ls lt iq bd lu lv og lx ly lz oh mb mc md oi mf mg mh oj mj mk ml ok mn mo mp bi translated">结果</h1><p id="d3c2" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我注意到的一件事是，任何函数在页面刷新后直接运行时，平均运行时间都要长一些。如果我刷新页面并运行一个初始函数，那么它之后的任何函数都会运行得更快。</p><h2 id="e70f" class="np lt iq bd lu nu nv dn ly nw nx dp mc ko ny nz mg ks oa ob mk kw oc od mo oe bi translated">刷新后测试</h2><p id="9227" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">下面是每个函数在页面刷新后直接启动时所用的平均时间(以毫秒为单位)，换句话说，在它们之前没有其他操作发生。对于每个功能，平均时间是通过20次试验计算的。</p><pre class="lb lc ld le gt nl lk nm nn aw no bi"><span id="524b" class="np lt iq lk b gy nq nr l ns nt">regular: 522 ms<br/>ternary: 520 ms<br/>constants: 509 ms<br/>ternary with constants: 508 ms</span></pre><h2 id="12af" class="np lt iq bd lu nu nv dn ly nw nx dp mc ko ny nz mg ks oa ob mk kw oc od mo oe bi translated">后续功能测试</h2><p id="4ecf" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">以下是运行之前的操作后触发每个功能所花费的平均时间。例如，我会刷新页面并按一次“常规”按钮。随后，我又按了20次同样的按钮，记录下每次按下的时间。</p><pre class="lb lc ld le gt nl lk nm nn aw no bi"><span id="2a94" class="np lt iq lk b gy nq nr l ns nt">regular: 180 ms<br/>ternary: 181 ms<br/>constants: 176 ms<br/>ternary with constants: 176 ms</span></pre></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="92a8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">外卖食品</h1><p id="5b2b" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">基于这个数据，使用三元运算符代替<code class="fe lh li lj lk b">if</code>语句导致转换运行速度平均快了2毫秒。在随后的函数测试中，三元函数平均运行慢了ms。在这两种情况下，意义都是值得怀疑的。</p><p id="288e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，使用预定义的常数会导致更显著的性能提升。平均而言，在刷新后测试中，<code class="fe lh li lj lk b">constants</code>函数比<code class="fe lh li lj lk b">regular</code>函数快13毫秒，比<code class="fe lh li lj lk b">ternary</code>函数快11毫秒。在随后的功能测试中，它比<code class="fe lh li lj lk b">regular</code>快了5 ms，比<code class="fe lh li lj lk b">ternary</code>快了6 ms。</p><p id="5699" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lh li lj lk b">ternary with constants</code>函数可能稍微受益于三元运算符，因为它在刷新后测试中比<code class="fe lh li lj lk b">constants</code>快1 ms。然而，在随后的功能测试中没有任何变化。</p><p id="91e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的主要观点是，如果你想提高性能，预先定义那些字符串函数和正则表达式。字符串操作开销很大，因此只定义一次字符串操作有助于优化代码。三元运算符的附加值更值得怀疑，因此我现在还不能说我的预测是正确的——与其说三元运算符和预定义常数都提供了性能提升，倒不如说常数似乎真的有很大的不同。</p><p id="3109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，这只是在一台笔记本电脑上的一种浏览器(Firefox)上运行的CodePen上的一个非常小的数据集。因此，需要收集更可靠的数据来证实或反驳这些结论。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="c13e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">器械类型</h1><p id="6b86" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">为了更加美观，下面是CSS，以防你想创建一个看起来像这样的测试设备。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The tester CSS.</figcaption></figure><h1 id="f571" class="ls lt iq bd lu lv og lx ly lz oh mb mc md oi mf mg mh oj mj mk ml ok mn mo mp bi translated">后续步骤</h1><p id="d6dd" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">如果您想更深入地研究这个性能测试示例，下面是您可以尝试的一些附加步骤。</p><ul class=""><li id="0e80" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">试着在同一个CodePen上运行你自己的测试，看看你的数据和我的相比如何。</li><li id="0d4e" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">修改您运行每个函数的次数，并查看它如何影响您的数据。</li><li id="a14c" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">如果您输入一个包含更多大写字母的更长的字符串，函数将花费更长的时间。尝试用更长的单词进行额外的测试，看看这种趋势是否持续。</li><li id="54ed" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">分叉CodePen并修改它，这样您就可以对您感兴趣的函数运行一些性能测试。</li><li id="1b49" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">如果你尝试以上任何一种测试，请在下面的评论中告诉我你的发现。</li><li id="3967" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">在介绍“常规”camelCase to dash语法函数的文章中了解更多信息。</li></ul><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/from-camel-case-to-dash-syntax-in-javascript-c685206ee682"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">JavaScript中从骆驼大小写到破折号的语法</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">仔细看看一个概念丰富的代码片段。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc jw oo"/></div></div></a></div><p id="93c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你已经发现这些非正式测试的结果是有趣和有帮助的。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="9c7a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">承认</h1><p id="3931" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">非常感谢<a class="ae kc" href="https://deathshadow.medium.com/" rel="noopener"> Jason Knight </a>提供了如何优化这段代码的建议。我感谢他提供了三元运算符转换函数、常数相关转换函数和常数表达式的语法，以及促使我撰写本文的一般反馈。此外，他对为什么特定类型的语法可以使包含字符串操作的函数运行得更快有一些有用的见解。</p><p id="4970" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="pd">更多内容看</em> <a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="pd">说白了. io </em> </strong> </a> <strong class="kf ir"> <em class="pd">。</em> </strong> <em class="pd">为无限制访问我的文章，考虑</em> <a class="ae kc" href="https://medium.com/@nevkatz/membership" rel="noopener"> <strong class="kf ir"> <em class="pd">加盟中</em> </strong> </a> <strong class="kf ir"> <em class="pd">。</em>T25】</strong></p></div></div>    
</body>
</html>