<html>
<head>
<title>Event Loop, Callbacks, Promises, and Async/Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的事件循环、回调、承诺和异步/等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/event-loop-callbacks-promises-and-async-await-in-javascript-7b22cfdd7a11?source=collection_archive---------6-----------------------#2021-09-05">https://javascript.plainenglish.io/event-loop-callbacks-promises-and-async-await-in-javascript-7b22cfdd7a11?source=collection_archive---------6-----------------------#2021-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="de6d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="d273" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在互联网的早期，网站通常由一个<a class="ae lj" href="https://www.digitalocean.com/community/tutorial_series/how-to-build-a-website-with-html" rel="noopener ugc nofollow" target="_blank"> HTML页面</a>中的静态数据组成。但是现在网络应用程序变得更加交互和动态，它变得越来越有必要进行密集的操作，比如发出外部网络请求来检索<a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Glossary/API" rel="noopener ugc nofollow" target="_blank"> API </a>数据。为了在JavaScript中处理这些操作，开发人员必须使用<em class="lk">异步编程</em>技术。</p><p id="64cd" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">由于JavaScript是一种<em class="lk">单线程</em>编程语言，具有<em class="lk">同步</em>执行模型，处理一个又一个操作，所以一次只能处理一条语句。但是，像从API请求数据这样的操作可能需要不确定的时间，这取决于所请求数据的大小、网络连接的速度以及其他因素。如果API调用是以同步方式执行的，浏览器将无法处理任何用户输入，比如滚动或单击按钮，直到该操作完成。这就是所谓的<em class="lk">阻塞</em>。</p><p id="4bff" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">为了防止阻塞行为，浏览器环境有许多JavaScript可以访问的Web APIs，它们是<em class="lk">异步的</em>，这意味着它们可以与其他操作并行运行，而不是顺序运行。这很有用，因为它允许用户在处理异步操作时继续正常使用浏览器。</p><p id="ee21" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">作为一名JavaScript开发人员，您需要知道如何使用异步Web APIs并处理这些操作的响应或错误。在本文中，您将了解事件循环、通过回调处理异步行为的原始方式、更新的<a class="ae lj" href="http://www.ecma-international.org/ecma-262/6.0/" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2015 </a>增加的承诺，以及使用<code class="fe lq lr ls lt b">async/await</code>的现代实践</p><h1 id="46a4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">事件循环</h1><p id="e906" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本节将解释JavaScript如何处理带有事件循环的异步代码。它将首先演示工作中的事件循环，然后解释事件循环的两个元素:堆栈和队列。</p><p id="c631" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">不使用任何异步Web APIs的JavaScript代码将以同步方式执行——一次一个，按顺序执行。这个示例代码演示了这一点，它调用三个函数，每个函数向<a class="ae lj" href="https://www.digitalocean.com/community/tutorials/how-to-use-the-javascript-developer-console" rel="noopener ugc nofollow" target="_blank">控制台</a>打印一个数字:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0edf" class="mc jo iq lt b gy md me l mf mg">// Define three example functions<br/>function first() {<br/>  console.log(1)<br/>}</span><span id="d70d" class="mc jo iq lt b gy mh me l mf mg">function second() {<br/>  console.log(2)<br/>}</span><span id="1842" class="mc jo iq lt b gy mh me l mf mg">function third() {<br/>  console.log(3)<br/>}</span></pre><p id="48ad" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在这段代码中，您定义了三个用<code class="fe lq lr ls lt b">console.log()</code>打印数字的函数。</p><p id="4e26" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">接下来，编写对函数的调用:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0338" class="mc jo iq lt b gy md me l mf mg">// Execute the functions<br/>first()<br/>second()<br/>third()</span></pre><p id="ed3b" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">输出将基于函数被调用的顺序— <code class="fe lq lr ls lt b">first()</code>、<code class="fe lq lr ls lt b">second()</code>，然后是<code class="fe lq lr ls lt b">third()</code>:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0e04" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="e109" class="mc jo iq lt b gy mh me l mf mg">1<br/>2<br/>3</span></pre><p id="d484" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">当使用异步Web API时，规则变得更加复杂。您可以用一个内置的API<code class="fe lq lr ls lt b">setTimeout</code>进行测试，它设置了一个定时器，并在指定的时间后执行一个动作。<code class="fe lq lr ls lt b">setTimeout</code>需要异步，否则整个浏览器将在等待期间保持冻结，这将导致糟糕的用户体验。</p><p id="34c3" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">向<code class="fe lq lr ls lt b">second</code>函数添加<code class="fe lq lr ls lt b">setTimeout</code>来模拟异步请求:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="1346" class="mc jo iq lt b gy md me l mf mg">// Define three example functions, but one of them contains asynchronous code<br/>function first() {<br/>  console.log(1)<br/>}</span><span id="75bf" class="mc jo iq lt b gy mh me l mf mg">function second() {<br/>  setTimeout(() =&gt; {<br/>    console.log(2)<br/>  }, 0)<br/>}</span><span id="22fe" class="mc jo iq lt b gy mh me l mf mg">function third() {<br/>  console.log(3)<br/>}</span></pre><p id="fc7f" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><code class="fe lq lr ls lt b">setTimeout</code>接受两个参数:它将异步运行的函数，以及在调用该函数之前它将等待的时间。在这段代码中，您将<code class="fe lq lr ls lt b">console.log</code>包装在一个匿名函数中，并将其传递给<code class="fe lq lr ls lt b">setTimeout</code>，然后将该函数设置为在<code class="fe lq lr ls lt b">0</code>毫秒后运行。</p><p id="958d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现在像以前一样调用这些函数:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="c5e5" class="mc jo iq lt b gy md me l mf mg">// Execute the functions<br/>first()<br/>second()<br/>third()</span></pre><p id="726b" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">您可能希望在<code class="fe lq lr ls lt b">setTimeout</code>设置为<code class="fe lq lr ls lt b">0</code>的情况下，运行这三个函数仍然会导致数字按顺序打印。但是因为它是异步的，超时的函数将最后打印出来:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="2834" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="3406" class="mc jo iq lt b gy mh me l mf mg">1<br/>3<br/>2</span></pre><p id="4a95" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">无论您将超时设置为零秒还是五分钟都没有区别——异步代码调用的<code class="fe lq lr ls lt b">console.log</code>将在同步顶级函数之后执行。这是因为JavaScript主机环境(在本例中是浏览器)使用了一个叫做<em class="lk">事件循环</em>的概念来处理并发或并行事件。由于JavaScript一次只能执行一条语句，因此需要通知事件循环何时执行哪条特定的语句。事件循环用一个<em class="lk">堆栈</em>和一个<em class="lk">队列</em>的概念来处理这个问题。</p><h1 id="16fa" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">堆</h1><p id="993d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lk">堆栈</em>或调用堆栈，保存当前正在运行的函数的状态。如果你不熟悉堆栈的概念，你可以把它想象成一个具有“后进先出”(LIFO)属性的<a class="ae lj" href="https://www.digitalocean.com/community/tutorials/understanding-arrays-in-javascript" rel="noopener ugc nofollow" target="_blank">数组</a>，这意味着你只能在堆栈的末尾添加或删除项目。JavaScript会运行堆栈中当前的<em class="lk">帧</em>(或者特定环境下的函数调用)，然后移除它，继续下一个。</p><p id="f33f" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">对于仅包含同步代码的示例，浏览器按以下顺序处理执行:</p><ul class=""><li id="a908" class="mi mj iq kn b ko ll ks lm kw mk la ml le mm li mn mo mp mq bi translated">将<code class="fe lq lr ls lt b">first()</code>添加到堆栈中，运行将<code class="fe lq lr ls lt b">1</code>记录到控制台的<code class="fe lq lr ls lt b">first()</code>，从堆栈中移除<code class="fe lq lr ls lt b">first()</code>。</li><li id="0fed" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">将<code class="fe lq lr ls lt b">second()</code>添加到堆栈中，运行将<code class="fe lq lr ls lt b">2</code>记录到控制台的<code class="fe lq lr ls lt b">second()</code>，从堆栈中移除<code class="fe lq lr ls lt b">second()</code>。</li><li id="3ab4" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">将<code class="fe lq lr ls lt b">third()</code>添加到堆栈中，运行将<code class="fe lq lr ls lt b">3</code>记录到控制台的<code class="fe lq lr ls lt b">third()</code>，从堆栈中移除<code class="fe lq lr ls lt b">third()</code>。</li></ul><p id="e56e" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">第二个带有<code class="fe lq lr ls lt b">setTimout</code>的例子如下所示:</p><ul class=""><li id="1bcb" class="mi mj iq kn b ko ll ks lm kw mk la ml le mm li mn mo mp mq bi translated">将<code class="fe lq lr ls lt b">first()</code>添加到堆栈中，运行将<code class="fe lq lr ls lt b">1</code>记录到控制台的<code class="fe lq lr ls lt b">first()</code>，从堆栈中移除<code class="fe lq lr ls lt b">first()</code>。</li><li id="2f43" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">将<code class="fe lq lr ls lt b">second()</code>添加到堆栈中，运行<code class="fe lq lr ls lt b">second()</code>。</li><li id="7e50" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">将<code class="fe lq lr ls lt b">setTimeout()</code>添加到堆栈中，运行<code class="fe lq lr ls lt b">setTimeout()</code> Web API，它启动一个定时器并将匿名函数添加到<em class="lk">队列</em>中，从堆栈中移除<code class="fe lq lr ls lt b">setTimeout()</code>。</li><li id="9955" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">从堆栈中移除<code class="fe lq lr ls lt b">second()</code>。</li><li id="12d3" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">将<code class="fe lq lr ls lt b">third()</code>添加到堆栈中，运行将<code class="fe lq lr ls lt b">3</code>记录到控制台的<code class="fe lq lr ls lt b">third()</code>，从堆栈中移除<code class="fe lq lr ls lt b">third()</code>。</li><li id="f89c" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">事件循环检查队列中是否有任何未决消息，并从<code class="fe lq lr ls lt b">setTimeout()</code>中找到匿名函数，将该函数添加到将<code class="fe lq lr ls lt b">2</code>记录到控制台的堆栈中，然后将其从堆栈中移除。</li></ul><p id="48fd" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">使用异步Web API<code class="fe lq lr ls lt b">setTimeout</code>，引入了<em class="lk">队列</em>的概念，本教程将在接下来介绍。</p><h1 id="d049" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">长队</h1><p id="53ed" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lk">队列</em>，也称为消息队列或任务队列，是函数的等待区。每当调用堆栈为空时，事件循环将从最早的消息开始，检查队列中是否有任何等待的消息。一旦找到一个，它将把它添加到堆栈中，堆栈将执行消息中的函数。</p><p id="c2a9" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在<code class="fe lq lr ls lt b">setTimeout</code>示例中，匿名函数在顶层执行的剩余部分之后立即运行，因为计时器被设置为<code class="fe lq lr ls lt b">0</code>秒。重要的是要记住，计时器并不意味着代码将在精确的<code class="fe lq lr ls lt b">0</code>秒或任何指定的时间内执行，而是在这段时间内将匿名函数添加到队列中。这个队列系统之所以存在，是因为如果计时器在计时器结束时将匿名函数直接添加到堆栈中，它将中断当前正在运行的任何函数，这可能会产生意想不到的和不可预测的影响。</p><p id="4419" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现在您知道了事件循环如何使用堆栈和队列来处理代码的执行顺序。下一个任务是找出如何控制代码的执行顺序。为此，您将首先了解确保异步代码被事件循环正确处理的原始方法:回调函数。</p><h1 id="cda4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">回调函数</h1><p id="ea3c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<code class="fe lq lr ls lt b">setTimeout</code>示例中，超时的函数在主顶级执行上下文中的所有内容之后运行。但是如果你想确保其中一个函数，比如<code class="fe lq lr ls lt b">third</code>函数，在超时后运行，那么你必须使用异步编码方法。这里的超时可以表示包含数据的异步API调用。您希望处理来自API调用的数据，但是您必须确保首先返回数据。</p><p id="cbc6" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">处理这个问题的原始解决方案是使用<em class="lk">回调函数</em>。回调函数没有特殊的语法；它们只是一个作为参数传递给另一个函数的函数。将另一个函数作为自变量的函数称为<em class="lk">高阶函数</em>。根据这个定义，任何函数如果作为参数传递，都可以成为回调函数。回调本质上不是异步的，但是可以用于异步目的。</p><p id="b724" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">下面是高阶函数和回调的语法代码示例:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="c22f" class="mc jo iq lt b gy md me l mf mg">// A function<br/>function fn() {<br/>  console.log('Just a function')<br/>}</span><span id="f5bf" class="mc jo iq lt b gy mh me l mf mg">// A function that takes another function as an argument<br/>function higherOrderFunction(callback) {<br/>  // When you call a function that is passed as an argument, it is referred to as a callback<br/>  callback()<br/>}</span><span id="13b6" class="mc jo iq lt b gy mh me l mf mg">// Passing a function<br/>higherOrderFunction(fn)</span></pre><p id="39fe" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在这段代码中，您定义了一个函数<code class="fe lq lr ls lt b">fn</code>，定义了一个以函数<code class="fe lq lr ls lt b">callback</code>为参数的函数<code class="fe lq lr ls lt b">higherOrderFunction</code>，并将<code class="fe lq lr ls lt b">fn</code>作为回调传递给<code class="fe lq lr ls lt b">higherOrderFunction</code>。</p><p id="bd84" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">运行这段代码将得到以下结果:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="6997" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="f7e7" class="mc jo iq lt b gy mh me l mf mg">Just a function</span></pre><p id="4600" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">让我们回到带有<code class="fe lq lr ls lt b">setTimeout</code>的<code class="fe lq lr ls lt b">first</code>、<code class="fe lq lr ls lt b">second</code>和<code class="fe lq lr ls lt b">third</code>功能。这是你目前所拥有的:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="58b0" class="mc jo iq lt b gy md me l mf mg">function first() {<br/>  console.log(1)<br/>}</span><span id="6d4f" class="mc jo iq lt b gy mh me l mf mg">function second() {<br/>  setTimeout(() =&gt; {<br/>    console.log(2)<br/>  }, 0)<br/>}</span><span id="6069" class="mc jo iq lt b gy mh me l mf mg">function third() {<br/>  console.log(3)<br/>}</span></pre><p id="ce1b" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">任务是让<code class="fe lq lr ls lt b">third</code>函数总是延迟执行，直到<code class="fe lq lr ls lt b">second</code>函数中的异步动作完成。这就是回调的用武之地。您将把<code class="fe lq lr ls lt b">third</code>函数作为参数传递给<code class="fe lq lr ls lt b">second</code>，而不是在顶层执行<code class="fe lq lr ls lt b">first</code>、<code class="fe lq lr ls lt b">second</code>和<code class="fe lq lr ls lt b">third</code>。<code class="fe lq lr ls lt b">second</code>函数将在异步动作完成后执行回调。</p><p id="fbc5" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">下面是应用了回调的三个函数:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="6635" class="mc jo iq lt b gy md me l mf mg">// Define three functions<br/>function first() {<br/>  console.log(1)<br/>}</span><span id="9602" class="mc jo iq lt b gy mh me l mf mg">function second(callback) {<br/>  setTimeout(() =&gt; {<br/>    console.log(2)</span><span id="006f" class="mc jo iq lt b gy mh me l mf mg">    // Execute the callback function<br/>    callback()<br/>  }, 0)<br/>}</span><span id="5556" class="mc jo iq lt b gy mh me l mf mg">function third() {<br/>  console.log(3)<br/>}</span></pre><p id="38c3" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现在，执行<code class="fe lq lr ls lt b">first</code>和<code class="fe lq lr ls lt b">second</code>，然后将<code class="fe lq lr ls lt b">third</code>作为参数传递给<code class="fe lq lr ls lt b">second</code>:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0704" class="mc jo iq lt b gy md me l mf mg">first()<br/>second(third)</span></pre><p id="d3c4" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">运行此代码块后，您将收到以下输出:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="e5dc" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="2246" class="mc jo iq lt b gy mh me l mf mg">1<br/>2<br/>3</span></pre><p id="7699" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">首先<code class="fe lq lr ls lt b">1</code>将会打印，在计时器完成后(在本例中是零秒，但您可以将其更改为任意值)，它将会打印<code class="fe lq lr ls lt b">2</code>然后<code class="fe lq lr ls lt b">3</code>。通过将函数作为回调传递，您成功地延迟了函数的执行，直到异步Web API ( <code class="fe lq lr ls lt b">setTimeout</code>)完成。</p><p id="9354" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这里的关键要点是回调函数不是异步的— <code class="fe lq lr ls lt b">setTimeout</code>是负责处理异步任务的异步Web API。回调只允许您在异步任务完成时得到通知，并处理任务的成功或失败。</p><p id="7fb4" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现在您已经学习了如何使用回调来处理异步任务，下一节将解释嵌套太多回调和创建“末日金字塔”的问题</p><h1 id="d593" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">嵌套回调和末日金字塔</h1><p id="e812" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">回调函数是确保延迟执行一个函数直到另一个函数完成并返回数据的有效方法。然而，由于回调的嵌套性质，如果您有许多相互依赖的连续异步请求，代码可能会变得混乱。这在早期对JavaScript开发人员来说是一个很大的挫折，因此包含嵌套回调的代码通常被称为“末日金字塔”或“回调地狱”</p><p id="e803" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">下面是嵌套回调的演示:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="ef08" class="mc jo iq lt b gy md me l mf mg">function pyramidOfDoom() {<br/>  setTimeout(() =&gt; {<br/>    console.log(1)<br/>    setTimeout(() =&gt; {<br/>      console.log(2)<br/>      setTimeout(() =&gt; {<br/>        console.log(3)<br/>      }, 500)<br/>    }, 2000)<br/>  }, 1000)<br/>}</span></pre><p id="cdfe" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在这段代码中，每个新的<code class="fe lq lr ls lt b">setTimeout</code>都嵌套在一个更高阶的函数中，创建了一个越来越深的回调的金字塔形状。运行这段代码将得到以下结果:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="786f" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="e644" class="mc jo iq lt b gy mh me l mf mg">1<br/>2<br/>3</span></pre><p id="91e3" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">实际上，对于现实世界中的异步代码，这可能会变得更加复杂。您很可能需要在异步代码中进行错误处理，然后将每个响应中的一些数据传递给下一个请求。用回调做这件事会使你的代码难以阅读和维护。</p><p id="890d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这里有一个更现实的“末日金字塔”的运行示例，您可以随意摆弄:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="3cb3" class="mc jo iq lt b gy md me l mf mg">// Example asynchronous function<br/>function asynchronousRequest(args, callback) {<br/>  // Throw an error if no arguments are passed<br/>  if (!args) {<br/>    return callback(new Error('Whoa! Something went wrong.'))<br/>  } else {<br/>    return setTimeout(<br/>      // Just adding in a random number so it seems like the contrived asynchronous function<br/>      // returned different data<br/>      () =&gt; callback(null, {body: args + ' ' + Math.floor(Math.random() * 10)}),<br/>      500,<br/>    )<br/>  }<br/>}</span><span id="c628" class="mc jo iq lt b gy mh me l mf mg">// Nested asynchronous requests<br/>function callbackHell() {<br/>  asynchronousRequest('First', function first(error, response) {<br/>    if (error) {<br/>      console.log(error)<br/>      return<br/>    }<br/>    console.log(response.body)<br/>    asynchronousRequest('Second', function second(error, response) {<br/>      if (error) {<br/>        console.log(error)<br/>        return<br/>      }<br/>      console.log(response.body)<br/>      asynchronousRequest(null, function third(error, response) {<br/>        if (error) {<br/>          console.log(error)<br/>          return<br/>        }<br/>        console.log(response.body)<br/>      })<br/>    })<br/>  })<br/>}</span><span id="50b3" class="mc jo iq lt b gy mh me l mf mg">// Execute<br/>callbackHell()</span></pre><p id="1ee1" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在这段代码中，你必须让每个函数都考虑到一个可能的<code class="fe lq lr ls lt b">response</code>和一个可能的<code class="fe lq lr ls lt b">error</code>，让函数<code class="fe lq lr ls lt b">callbackHell</code>在视觉上变得混乱。</p><p id="3811" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">运行这段代码将得到以下结果:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="6f08" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="8b65" class="mc jo iq lt b gy mh me l mf mg">First 9<br/>Second 3<br/>Error: Whoa! Something went wrong.<br/>    at asynchronousRequest (&lt;anonymous&gt;:4:21)<br/>    at second (&lt;anonymous&gt;:29:7)<br/>    at &lt;anonymous&gt;:9:13</span></pre><p id="4ba0" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这种处理异步代码的方式很难遵循。于是，在ES6中引入了<em class="lk">承诺</em>的概念。这是下一节的重点。</p><h1 id="53b0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">承诺</h1><p id="7ad7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一个<em class="lk">承诺</em>代表一个异步函数的完成。它是一个将来可能会返回值的对象。它实现了与回调函数相同的基本目标，但是增加了许多额外的特性和更易读的语法。作为一名JavaScript开发人员，您可能会花更多的时间来消费承诺，而不是创建承诺，因为通常是异步Web APIs返回一个承诺供开发人员消费。本教程将向您展示如何做到这两点。</p><h1 id="6c21" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">创造承诺</h1><p id="5608" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可以用<code class="fe lq lr ls lt b">new Promise</code>语法初始化一个承诺，而且你必须用一个函数来初始化它。传递给promise的函数有<code class="fe lq lr ls lt b">resolve</code>和<code class="fe lq lr ls lt b">reject</code>参数。<code class="fe lq lr ls lt b">resolve</code>和<code class="fe lq lr ls lt b">reject</code>函数分别处理操作的成功和失败。</p><p id="4210" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">写下面一行来宣告一个承诺:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="5c66" class="mc jo iq lt b gy md me l mf mg">// Initialize a promise<br/>const promise = new Promise((resolve, reject) =&gt; {})</span></pre><p id="e7e2" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">如果您使用web浏览器的控制台检查这种状态下的初始化承诺，您会发现它有一个<code class="fe lq lr ls lt b">pending</code>状态和<code class="fe lq lr ls lt b">undefined</code>值:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="f00a" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="8987" class="mc jo iq lt b gy mh me l mf mg">__proto__: Promise<br/>[[PromiseStatus]]: "pending"<br/>[[PromiseValue]]: undefined</span></pre><p id="3c5c" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">到目前为止，还没有为承诺设置任何东西，所以它将永远处于<code class="fe lq lr ls lt b">pending</code>状态。检验一个承诺的第一件事就是通过用一个价值来解决它来履行承诺:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="85cd" class="mc jo iq lt b gy md me l mf mg">const promise = new Promise((resolve, reject) =&gt; {<br/>  resolve('We did it!')<br/>})</span></pre><p id="b8ff" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现在，在检查承诺时，您会发现它的状态为<code class="fe lq lr ls lt b">fulfilled</code>，并且<code class="fe lq lr ls lt b">value</code>被设置为您传递给<code class="fe lq lr ls lt b">resolve</code>的值:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="3c56" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="b82e" class="mc jo iq lt b gy mh me l mf mg">__proto__: Promise<br/>[[PromiseStatus]]: "fulfilled"<br/>[[PromiseValue]]: "We did it!"</span></pre><p id="9292" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">如本节开头所述，承诺是可以返回值的对象。成功完成后，<code class="fe lq lr ls lt b">value</code>从<code class="fe lq lr ls lt b">undefined</code>变为被数据填充。</p><p id="dde5" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">承诺可以有三种可能的状态:待定、履行和拒绝。</p><ul class=""><li id="0271" class="mi mj iq kn b ko ll ks lm kw mk la ml le mm li mn mo mp mq bi translated"><strong class="kn ir">待定</strong> —解决或拒绝前的初始状态</li><li id="4acd" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated"><strong class="kn ir">履行完毕</strong> —操作成功，承诺已解决</li><li id="e891" class="mi mj iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated"><strong class="kn ir">被拒绝</strong> —操作失败，承诺被拒绝</li></ul><p id="fb1d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在履行或拒绝之后，承诺就达成了。</p><p id="379e" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">既然你对承诺是如何产生的有了一个概念，让我们看看一个开发者如何消费这些承诺。</p><h1 id="ef8b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">履行诺言</h1><p id="a235" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上一节中的承诺已经用一个值实现了，但是您还希望能够访问该值。承诺有一个名为<code class="fe lq lr ls lt b">then</code>的方法，它将在承诺到达代码中的<code class="fe lq lr ls lt b">resolve</code>后运行。<code class="fe lq lr ls lt b">then</code>将返回承诺的值作为参数。</p><p id="3d15" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这是您返回并记录示例承诺的<code class="fe lq lr ls lt b">value</code>的方式:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="25d5" class="mc jo iq lt b gy md me l mf mg">promise.then((response) =&gt; {<br/>  console.log(response)<br/>})</span></pre><p id="cbe6" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">你创造的承诺有一个<code class="fe lq lr ls lt b">We did it!</code>的<code class="fe lq lr ls lt b">[[PromiseValue]]</code>。这个值将作为<code class="fe lq lr ls lt b">response</code>传递给匿名函数:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="45fb" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="1d36" class="mc jo iq lt b gy mh me l mf mg">We did it!</span></pre><p id="4814" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">到目前为止，您创建的示例没有涉及异步Web API——它只解释了如何创建、解析和使用原生JavaScript promise。使用<code class="fe lq lr ls lt b">setTimeout</code>，您可以测试出一个异步请求。</p><p id="4bb0" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">以下代码将异步请求返回的数据模拟为承诺:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="b71e" class="mc jo iq lt b gy md me l mf mg">const promise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve('Resolving an asynchronous request!'), 2000)<br/>})</span><span id="2d09" class="mc jo iq lt b gy mh me l mf mg">// Log the result<br/>promise.then((response) =&gt; {<br/>  console.log(response)<br/>})</span></pre><p id="cef1" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">使用<code class="fe lq lr ls lt b">then</code>语法确保只有在<code class="fe lq lr ls lt b">2000</code>毫秒后<code class="fe lq lr ls lt b">setTimeout</code>操作完成时才会记录<code class="fe lq lr ls lt b">response</code>。所有这些都是在没有嵌套回调的情况下完成的。</p><p id="45ad" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现在，两秒钟后，它将解析承诺值，并记录在<code class="fe lq lr ls lt b">then</code>中:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="f90f" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="c2b4" class="mc jo iq lt b gy mh me l mf mg">Resolving an asynchronous request!</span></pre><p id="2ae1" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">承诺也可以被链接起来，将数据传递给多个异步操作。如果在<code class="fe lq lr ls lt b">then</code>中返回一个值，可以添加另一个<code class="fe lq lr ls lt b">then</code>来满足前一个<code class="fe lq lr ls lt b">then</code>的返回值:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="a5fc" class="mc jo iq lt b gy md me l mf mg">// Chain a promise<br/>promise<br/>  .then((firstResponse) =&gt; {<br/>    // Return a new value for the next then<br/>    return firstResponse + ' And chaining!'<br/>  })<br/>  .then((secondResponse) =&gt; {<br/>    console.log(secondResponse)<br/>  })</span></pre><p id="b7bd" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">第二个<code class="fe lq lr ls lt b">then</code>中完成的响应将记录返回值:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="c095" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="ac2d" class="mc jo iq lt b gy mh me l mf mg">Resolving an asynchronous request! And chaining!</span></pre><p id="4087" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">由于<code class="fe lq lr ls lt b">then</code>可以被链接，它允许承诺的消费看起来比回调更同步，因为它们不需要嵌套。这将允许更多的可读代码，可以更容易地维护和验证。</p><h1 id="640a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">错误处理</h1><p id="17c5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">到目前为止，您只处理了一个成功的<code class="fe lq lr ls lt b">resolve</code>承诺，它将承诺置于<code class="fe lq lr ls lt b">fulfilled</code>状态。但是通常对于异步请求，您还必须处理一个错误——如果API关闭，或者发送了一个格式错误或未经授权的请求。一个承诺应该可以处理这两种情况。在本节中，您将创建一个函数来测试创建和消费承诺的成功和错误情况。</p><p id="6dc3" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这个<code class="fe lq lr ls lt b">getUsers</code>函数将传递一个标志给一个承诺，并返回承诺:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="024a" class="mc jo iq lt b gy md me l mf mg">function getUsers(onSuccess) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      // Handle resolve and reject in the asynchronous API<br/>    }, 1000)<br/>  })<br/>}</span></pre><p id="f6b2" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">设置代码，以便如果<code class="fe lq lr ls lt b">onSuccess</code>是<code class="fe lq lr ls lt b">true</code>，超时将通过一些数据实现。如果<code class="fe lq lr ls lt b">false</code>，该功能将出错拒绝:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="da3d" class="mc jo iq lt b gy md me l mf mg">function getUsers(onSuccess) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      // Handle resolve and reject in the asynchronous API<br/>      if (onSuccess) {<br/>        resolve([<br/>          {id: 1, name: 'Jerry'},<br/>          {id: 2, name: 'Elaine'},<br/>          {id: 3, name: 'George'},<br/>        ])<br/>      } else {<br/>        reject('Failed to fetch data!')<br/>      }<br/>    }, 1000)<br/>  })<br/>}</span></pre><p id="9855" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">对于成功的结果，您返回代表样本用户数据的JavaScript对象。</p><p id="b0f1" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">为了处理这个错误，您将使用<code class="fe lq lr ls lt b">catch</code>实例方法。这将给你一个失败回调，并把<code class="fe lq lr ls lt b">error</code>作为一个参数。</p><p id="1244" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在<code class="fe lq lr ls lt b">onSuccess</code>设置为<code class="fe lq lr ls lt b">false</code>的情况下运行<code class="fe lq lr ls lt b">getUser</code>命令，对成功案例使用<code class="fe lq lr ls lt b">then</code>方法，对错误案例使用<code class="fe lq lr ls lt b">catch</code>方法:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="a034" class="mc jo iq lt b gy md me l mf mg">// Run the getUsers function with the false flag to trigger an error<br/>getUsers(false)<br/>  .then((response) =&gt; {<br/>    console.log(response)<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.error(error)<br/>  })</span></pre><p id="4ed0" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">由于错误被触发，将跳过<code class="fe lq lr ls lt b">then</code>并由<code class="fe lq lr ls lt b">catch</code>处理错误:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="6c1d" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="0e48" class="mc jo iq lt b gy mh me l mf mg">Failed to fetch data!</span></pre><p id="5fda" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">如果您切换标志和<code class="fe lq lr ls lt b">resolve</code>，则<code class="fe lq lr ls lt b">catch</code>将被忽略，数据将返回:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="f905" class="mc jo iq lt b gy md me l mf mg">// Run the getUsers function with the true flag to resolve successfully<br/>getUsers(true)<br/>  .then((response) =&gt; {<br/>    console.log(response)<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.error(error)<br/>  })</span></pre><p id="b53e" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这将产生用户数据:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="ea5c" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="44d1" class="mc jo iq lt b gy mh me l mf mg">(3) [{…}, {…}, {…}]<br/>0: {id: 1, name: "Jerry"}<br/>1: {id: 2, name: "Elaine"}<br/>3: {id: 3, name: "George"}</span></pre><p id="9682" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">作为参考，这里有一个关于<code class="fe lq lr ls lt b">Promise</code>对象的处理程序方法的表格:</p><p id="1a81" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">方法描述<code class="fe lq lr ls lt b">then()</code>处理一个<code class="fe lq lr ls lt b">resolve</code>。返回一个承诺，并异步调用<code class="fe lq lr ls lt b">onFulfilled</code>函数<code class="fe lq lr ls lt b">catch()</code>处理一个<code class="fe lq lr ls lt b">reject</code>。返回一个承诺，并在承诺完成时异步调用<code class="fe lq lr ls lt b">onRejected</code>函数<code class="fe lq lr ls lt b">finally()</code>。返回一个承诺，异步调用<code class="fe lq lr ls lt b">onFinally</code>函数</p><p id="f337" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">承诺可能会使新开发人员和以前从未在异步环境中工作过的有经验的程序员感到困惑。然而，如上所述，消费承诺比创造承诺更常见。通常，浏览器的Web API或第三方库会提供承诺，您只需要使用它。</p><p id="cc0a" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在最后的承诺部分，本教程将引用一个返回承诺的Web API的常见用例:<a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">Fetch API</a>。</p><h1 id="f46a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用带有承诺的获取API</h1><p id="75e0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最有用和最常用的Web APIs之一是Fetch API，它允许您通过网络发出异步资源请求。<code class="fe lq lr ls lt b">fetch</code>是一个两部分的过程，因此需要链接<code class="fe lq lr ls lt b">then</code>。这个例子演示了使用GitHub API获取用户数据，同时处理任何潜在的错误:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="30e7" class="mc jo iq lt b gy md me l mf mg">// Fetch a user from the GitHub API<br/>fetch('https://api.github.com/users/octocat')<br/>  .then((response) =&gt; {<br/>    return response.json()<br/>  })<br/>  .then((data) =&gt; {<br/>    console.log(data)<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.error(error)<br/>  })</span></pre><p id="b8e2" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><code class="fe lq lr ls lt b">fetch</code>请求被发送到<code class="fe lq lr ls lt b">https://api.github.com/users/octocat</code> URL，它异步等待响应。第一个<code class="fe lq lr ls lt b">then</code>将响应传递给一个匿名函数，该函数将响应格式化为<a class="ae lj" href="https://www.digitalocean.com/community/tutorials/how-to-work-with-json-in-javascript" rel="noopener ugc nofollow" target="_blank"> JSON数据</a>，然后将JSON传递给第二个<code class="fe lq lr ls lt b">then</code>，后者将数据记录到控制台。<code class="fe lq lr ls lt b">catch</code>语句将任何错误记录到控制台。</p><p id="359d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">运行此代码将产生以下结果:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="92a7" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="2537" class="mc jo iq lt b gy mh me l mf mg">login: "octocat",<br/>id: 583231,<br/>avatar_url: "https://avatars3.githubusercontent.com/u/583231?v=4"<br/>blog: "https://github.blog"<br/>company: "@github"<br/>followers: 3203<br/>...</span></pre><p id="7155" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这是从<code class="fe lq lr ls lt b">https://api.github.com/users/octocat</code>请求的数据，以JSON格式呈现。</p><p id="5b5c" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">教程的这一部分显示了promises包含了许多处理异步代码的改进。但是，尽管使用<code class="fe lq lr ls lt b">then</code>处理异步动作比金字塔式的回调更容易实现，一些开发人员仍然更喜欢编写异步代码的同步格式。为了满足这一需求，<a class="ae lj" href="https://www.ecma-international.org/ecma-262/7.0/index.html" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2016 (ES7) </a>引入了<code class="fe lq lr ls lt b">async</code>函数和<code class="fe lq lr ls lt b">await</code>关键字，使处理承诺变得更加容易。</p><h1 id="1514" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">带<code class="fe lq lr ls lt b">async/await</code>的异步功能</h1><p id="3880" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一个<code class="fe lq lr ls lt b"><em class="lk">async</em></code> <em class="lk">函数</em>允许你以一种看似同步的方式处理异步代码。<code class="fe lq lr ls lt b">async</code>函数仍然使用承诺，但是有更传统的JavaScript语法。在本节中，您将尝试这种语法的示例。</p><p id="dfd2" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">您可以通过在函数前添加<code class="fe lq lr ls lt b">async</code>关键字来创建一个<code class="fe lq lr ls lt b">async</code>函数:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="ace6" class="mc jo iq lt b gy md me l mf mg">// Create an async function<br/>async function getUser() {<br/>  return {}<br/>}</span></pre><p id="5ba3" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">虽然这个函数还没有处理任何异步的东西，但是它的行为与传统函数不同。如果您执行该函数，您会发现它返回一个带有<code class="fe lq lr ls lt b">[[PromiseStatus]]</code>和<code class="fe lq lr ls lt b">[[PromiseValue]]</code>的承诺，而不是返回值。</p><p id="93f9" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">通过记录对<code class="fe lq lr ls lt b">getUser</code>函数的调用来尝试一下:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="e6a9" class="mc jo iq lt b gy md me l mf mg">console.log(getUser())</span></pre><p id="be73" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这将给出以下内容:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="5314" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="4062" class="mc jo iq lt b gy mh me l mf mg">__proto__: Promise<br/>[[PromiseStatus]]: "fulfilled"<br/>[[PromiseValue]]: Object</span></pre><p id="d370" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这意味着你可以用<code class="fe lq lr ls lt b">then</code>处理<code class="fe lq lr ls lt b">async</code>函数，就像处理承诺一样。用下面的代码试试看:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="09df" class="mc jo iq lt b gy md me l mf mg">getUser().then((response) =&gt; console.log(response))</span></pre><p id="486b" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">对<code class="fe lq lr ls lt b">getUser</code>的调用将返回值传递给一个匿名函数，该函数将该值记录到控制台。</p><p id="4d29" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">运行该程序时，您将收到以下内容:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="da30" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="36f1" class="mc jo iq lt b gy mh me l mf mg">{}</span></pre><p id="7be1" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">一个<code class="fe lq lr ls lt b">async</code>函数可以使用<code class="fe lq lr ls lt b">await</code>操作符处理在它内部调用的承诺。<code class="fe lq lr ls lt b">await</code>可以在<code class="fe lq lr ls lt b">async</code>函数中使用，在执行指定的代码之前会一直等待，直到承诺完成。</p><p id="deae" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">有了这些知识，您可以使用<code class="fe lq lr ls lt b">async</code> / <code class="fe lq lr ls lt b">await</code>重写上一节的获取请求，如下所示:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="a5f7" class="mc jo iq lt b gy md me l mf mg">// Handle fetch with async/await<br/>async function getUser() {<br/>  const response = await fetch('https://api.github.com/users/octocat')<br/>  const data = await response.json()</span><span id="b55a" class="mc jo iq lt b gy mh me l mf mg">  console.log(data)<br/>}</span><span id="a1b4" class="mc jo iq lt b gy mh me l mf mg">// Execute async function<br/>getUser()</span></pre><p id="bd59" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">这里的<code class="fe lq lr ls lt b">await</code>操作符确保在请求用数据填充之前<code class="fe lq lr ls lt b">data</code>不会被记录。</p><p id="3449" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现在，最终的<code class="fe lq lr ls lt b">data</code>可以在<code class="fe lq lr ls lt b">getUser</code>函数中处理，而不需要使用<code class="fe lq lr ls lt b">then</code>。这是<code class="fe lq lr ls lt b">data</code>测井的输出:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="2225" class="mc jo iq lt b gy md me l mf mg">Output</span><span id="74c3" class="mc jo iq lt b gy mh me l mf mg">login: "octocat",<br/>id: 583231,<br/>avatar_url: "https://avatars3.githubusercontent.com/u/583231?v=4"<br/>blog: "https://github.blog"<br/>company: "@github"<br/>followers: 3203<br/>...</span></pre><p id="15c2" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">最后，因为您在异步函数中处理已实现的承诺，所以您也可以在函数中处理错误。您将使用<code class="fe lq lr ls lt b"><a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener ugc nofollow" target="_blank">try</a></code>/<a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener ugc nofollow" target="_blank">/</a><code class="fe lq lr ls lt b"><a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener ugc nofollow" target="_blank">catch</a></code>模式来处理异常，而不是使用<code class="fe lq lr ls lt b">then</code>的<code class="fe lq lr ls lt b">catch</code>方法。</p><p id="488b" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">添加以下突出显示的代码:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="509f" class="mc jo iq lt b gy md me l mf mg">// Handling success and errors with async/await<br/>async function getUser() {<br/>  try {<br/>    // Handle success in try<br/>    const response = await fetch('https://api.github.com/users/octocat')<br/>    const data = await response.json()</span><span id="7db9" class="mc jo iq lt b gy mh me l mf mg">    console.log(data)<br/>  } catch (error) {<br/>    // Handle error in catch<br/>    console.error(error)<br/>  }<br/>}</span></pre><p id="71a0" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">如果程序接收到一个错误，它将跳到<code class="fe lq lr ls lt b">catch</code>块，并将该错误记录到控制台。</p><p id="fd20" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">现代的异步JavaScript代码通常用<code class="fe lq lr ls lt b">async</code> / <code class="fe lq lr ls lt b">await</code>语法处理，但是了解承诺如何工作是很重要的，尤其是当承诺能够提供用<code class="fe lq lr ls lt b">async</code> / <code class="fe lq lr ls lt b">await</code>无法处理的额外特性时，比如用<code class="fe lq lr ls lt b"><a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>组合承诺。</p><p id="3a80" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir">注意:</strong> <code class="fe lq lr ls lt b">async</code> / <code class="fe lq lr ls lt b">await</code>可以通过使用<a class="ae lj" href="https://www.digitalocean.com/community/tutorials/understanding-generators-in-javascript#asyncawait-with-generators" rel="noopener ugc nofollow" target="_blank">生成器结合promises </a>来重现，为您的代码增加更多的灵活性。要了解更多，请查看我们的JavaScript 教程中的<a class="ae lj" href="https://www.digitalocean.com/community/tutorials/understanding-generators-in-javascript" rel="noopener ugc nofollow" target="_blank">理解生成器。</a></p><h1 id="5723" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="8b81" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为Web APIs通常异步提供数据，所以学习如何处理异步操作的结果是JavaScript开发人员的一个重要部分。在本文中，您了解了主机环境如何使用事件循环来处理带有<em class="lk">堆栈</em>和<em class="lk">队列</em>的代码的执行顺序。您还尝试了三种处理异步事件成功或失败的方法，包括回调、承诺和<code class="fe lq lr ls lt b">async</code> / <code class="fe lq lr ls lt b">await</code>语法。最后，您使用了Fetch Web API来处理异步操作</p><p id="bab2" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><em class="lk">更多内容请看</em><a class="ae lj" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kn ir"><em class="lk">plain English . io</em></strong></a><em class="lk">。报名参加我们的</em> <a class="ae lj" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir"> <em class="lk">免费周报</em> </strong> </a> <em class="lk">。关注我们关于</em><a class="ae lj" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kn ir"><em class="lk">Twitter</em></strong></a><a class="ae lj" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kn ir"><em class="lk">LinkedIn</em></strong></a><em class="lk"/><a class="ae lj" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kn ir"><em class="lk">YouTube</em></strong></a><em class="lk"/><a class="ae lj" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kn ir"><em class="lk">不和</em> </strong> </a> <strong class="kn ir"> <em class="lk">。</em>T49】</strong></p><p id="9280" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir"> <em class="lk">对缩放您的软件启动感兴趣</em> </strong> <em class="lk">？检查</em> <a class="ae lj" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir"> <em class="lk">电路</em> </strong> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>