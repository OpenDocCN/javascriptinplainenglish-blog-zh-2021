<html>
<head>
<title>Understanding Prototypal Inheritance in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的原型继承</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-prototypal-inheritance-in-javascript-cb1139c7cb8?source=collection_archive---------10-----------------------#2021-03-14">https://javascript.plainenglish.io/understanding-prototypal-inheritance-in-javascript-cb1139c7cb8?source=collection_archive---------10-----------------------#2021-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c785" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">旨在帮助您理解原型继承的基本概念的简要概述。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dafa4afc8ef52507e1c7f7057594479c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J35GNlxMvP1j7WJv"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@samferrara?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Samuel Ferrara</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f277" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是原型继承？</h1><p id="7b0b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">简单地说，原型继承指的是对象<em class="mc">从其他对象继承</em>属性和方法。这些被继承属性的对象被称为<em class="mc">原型</em>。JavaScript是一种基于原型的语言。它不是基于<strong class="jm io">类的。</strong></p><p id="659f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是等等！JavaScript没有类吗？如果你熟悉JavaScript，很可能你已经写了类似这样的东西。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="57d4" class="mi la in me b gy mj mk l ml mm">class Dog {<br/>  constructor(name, breed) {<br/>    this.name = name;<br/>    this.breed = breed;<br/>  }<br/>}</span></pre><p id="be46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要让这个愚弄你！ES6中引入了类语法，但它只是简单的语法糖。上面的<code class="fe mn mo mp me b">Dog</code>类同下面。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="9bce" class="mi la in me b gy mj mk l ml mm">function Dog(name, breed) {<br/>  this.name = name;<br/>  this.breed = breed;<br/>}                   </span></pre><h1 id="80a2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">到底什么是原型？</h1><p id="c6be" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在JavaScript中，对象从其他对象继承。记住函数也是对象。这可以用<code class="fe mn mo mp me b">typeof</code>来确认。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="1cec" class="mi la in me b gy mj mk l ml mm">function dog {</span><span id="fc89" class="mi la in me b gy mq mk l ml mm">}</span><span id="3638" class="mi la in me b gy mq mk l ml mm">typeof dog // “function”</span></pre><p id="8056" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当在JavaScript中创建一个对象时，它将自动拥有一个名为<strong class="jm io"> prototype </strong>的属性。这是连接物体的链接，原型链中的<em class="mc">链</em>。</p><h1 id="8220" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">原型是如何使用的？</h1><p id="12d1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当您访问一个对象的属性时，JavaScript引擎将首先搜索对象内部的属性。如果搜索失败，它将转移到对象的<strong class="jm io">原型</strong>。这个过程将一直重复，直到找到属性或到达原型链的末尾。</p><p id="a7ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你继续沿着原型链向上，最终你会到达顶端。最末端是基础对象。所有对象(包括函数和数组)都是从基对象创建的。例如，如果你使用object literal创建一个对象，然后检查<code class="fe mn mo mp me b">__proto__</code>属性，它将指向基类<code class="fe mn mo mp me b">Object</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/32bc43e3ce8657a929a9c544a6051753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgQoUUNSPpPtY5DIGAF6Ug.png"/></div></div></figure><h1 id="f346" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">运行中的原型链</h1><p id="e2ff" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">下面我们来分解一下代码片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ol class=""><li id="7bf4" class="mu mv in jm b jn jo jr js jv mw jz mx kd my kh mz na nb nc bi translated">首先，我们定义我们的构造函数，<code class="fe mn mo mp me b">Dog</code>。顺便说一下，构造函数只是一个普通的旧函数，但是按照惯例，它是以大写字母命名的。</li><li id="2841" class="mu mv in jm b jn nd jr ne jv nf jz ng kd nh kh mz na nb nc bi translated">接下来，我们向<code class="fe mn mo mp me b">Dog</code>原型对象添加一个函数<code class="fe mn mo mp me b">bark</code>。这意味着<code class="fe mn mo mp me b">Dog</code>的所有实例都可以访问<code class="fe mn mo mp me b">bark</code>。因为<code class="fe mn mo mp me b">bark</code>应用于<strong class="jm io">原型</strong> <em class="mc">而不是</em>实例，<code class="fe mn mo mp me b">bark</code>只在内存中存储一次，减少了重复。</li><li id="e811" class="mu mv in jm b jn nd jr ne jv nf jz ng kd nh kh mz na nb nc bi translated">在第10行，我们创建了新的<code class="fe mn mo mp me b">Dog</code>实例<code class="fe mn mo mp me b">spot</code>。最后，我们援引<code class="fe mn mo mp me b">spot.bark()</code>。在幕后，JavaScript引擎正在检查我们的<code class="fe mn mo mp me b">spot</code>对象是否有一个名为<code class="fe mn mo mp me b">bark</code>的方法。它不会找到的。因此，它将沿着原型链向上移动到<code class="fe mn mo mp me b">spot.prototype</code>，在那里它可以找到方法并调用它。</li></ol></div></div>    
</body>
</html>