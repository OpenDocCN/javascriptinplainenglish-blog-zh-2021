<html>
<head>
<title>Which type of loop is fastest in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中哪种类型的循环速度最快？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/which-type-of-loop-is-fastest-in-javascript-ec834a0f21b9?source=collection_archive---------0-----------------------#2021-01-20">https://javascript.plainenglish.io/which-type-of-loop-is-fastest-in-javascript-ec834a0f21b9?source=collection_archive---------0-----------------------#2021-01-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c96b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">了解哪个for循环或迭代器适合您的需求，并防止您犯愚蠢的错误，影响您的应用程序性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ca855e63138414ed78001ea59b785e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FjGuCxH-seN1PrRF"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="111a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript是web开发的新感觉。不仅仅是NodeJS、React、Angular Vue等JS框架。但是，香草JS也有一个庞大的粉丝群。先说现代JavaScript。循环一直是大多数编程语言的重要组成部分。现代JS给了你很多方法来迭代或循环你的值。</p><p id="e070" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但问题是，你真的知道哪个循环或迭代最适合你的需求吗？for loops有很多选项，<code class="fe kz la lb lc b">for</code>，<code class="fe kz la lb lc b">for(reverse)</code>，<code class="fe kz la lb lc b">for...of</code>，<code class="fe kz la lb lc b">foreach</code>，<code class="fe kz la lb lc b">for...in</code>，<code class="fe kz la lb lc b">for...await</code>。本文将涉及这样一场辩论。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h1 id="6482" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">哪个for循环更快？</h1><p id="54af" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated"><strong class="jm io">回答:</strong> <code class="fe kz la lb lc b">for (reverse)</code></p><p id="0580" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最令人惊讶的是，当我在本地机器上测试时，我开始相信<code class="fe kz la lb lc b">for (reverse)</code>是所有for循环中最快的。让我分享一个例子。取一个超过一百万个条目的<code class="fe kz la lb lc b">array</code>，执行一个循环。</p><p id="a4be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mn">免责声明</em> </strong> <em class="mn"> : console.time()结果准确性高度依赖于您的系统配置。仔细查看准确度</em> <a class="ae ky" href="https://johnresig.com/blog/accuracy-of-javascript-time/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">这里</em> </a> <em class="mn">。</em></p><pre class="kj kk kl km gt mo lc mp mq aw mr bi"><span id="b537" class="ms ll in lc b gy mt mu l mv mw">const <!-- -->million <!-- -->= 1000000; <br/>const arr = Array(<!-- -->million<!-- -->);</span><span id="ea36" class="ms ll in lc b gy mx mu l mv mw">console.time('⏳');<br/><br/>for (let i = arr.length; i &gt; 0; i--) {} // for(reverse) :- 1.5ms</span><span id="db0d" class="ms ll in lc b gy mx mu l mv mw">for (let i = 0; i &lt; <!-- -->arr.length<!-- -->; i++) {} // for          :- 1.6ms<br/><br/>arr.forEach(v =&gt; v)                     // foreach      :- 2.1ms</span><span id="a206" class="ms ll in lc b gy mx mu l mv mw">for (const v of arr) {}                 // for...of     :- 11.7ms<br/><br/>console.timeEnd('⏳');</span></pre><p id="0d45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原因:在这里，正向和反向for循环花费的时间几乎相同。只有0.1毫秒的差别，因为<code class="fe kz la lb lc b">for(reverse)</code>只计算一次起始变量<code class="fe kz la lb lc b">let i = arr.length</code>。在前向<code class="fe kz la lb lc b">for</code>循环中，它在变量每次增加后检查条件<code class="fe kz la lb lc b">i &lt; arr.length</code>。这一点点差别都无所谓，可以忽略。</p><p id="bbe6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一半<code class="fe kz la lb lc b">foreach</code>是一个数组原型的方法。与普通的<code class="fe kz la lb lc b">for</code>循环相比，<code class="fe kz la lb lc b">foreach</code>和<code class="fe kz la lb lc b">for...of</code>在数组的迭代上花费了更多的时间。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h1 id="4aeb" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">循环的类型，以及应该在哪里使用它们</h1><h2 id="9550" class="ms ll in bd lm my mz dn lq na nb dp lu jv nc nd ly jz ne nf mc kd ng nh mg ni bi translated">1.For循环(正向和反向)</h2><p id="0d62" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">可能大家都很熟悉这个循环。您可以使用<code class="fe kz la lb lc b">for</code>循环，在您需要的地方，运行一个重复的代码块来固定计数器时间。传统的<code class="fe kz la lb lc b">for</code>循环是最快的，所以你应该一直使用它，对吗？没那么快——性能不是唯一重要的东西。代码可读性通常更重要，所以默认适合你的应用的风格。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h2 id="80a5" class="ms ll in bd lm my mz dn lq na nb dp lu jv nc nd ly jz ne nf mc kd ng nh mg ni bi translated">2.为每一个</h2><p id="51dc" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">这个方法接受一个回调函数作为输入参数，对于数组中的每个元素，这个回调函数都会执行。同样，<code class="fe kz la lb lc b">foreach</code>回调函数接受当前值和各自的索引。<code class="fe kz la lb lc b">foreach</code>此外，允许在回调函数中使用<code class="fe kz la lb lc b">this</code>作为可选参数。</p><pre class="kj kk kl km gt mo lc mp mq aw mr bi"><span id="ee6d" class="ms ll in lc b gy mt mu l mv mw">const things = ['have', 'fun', 'coding'];</span><span id="37db" class="ms ll in lc b gy mx mu l mv mw">const callbackFun = (item, idex) =&gt; {<br/>    console.log(`${item} - ${index}`);<br/>}</span><span id="e968" class="ms ll in lc b gy mx mu l mv mw">things.foreach(callbackFun); </span><span id="4e3b" class="ms ll in lc b gy mx mu l mv mw">o/p:- have - 0<br/>      fun - 1<br/>      coding - 2</span></pre><p id="ca0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:-如果你使用<code class="fe kz la lb lc b">foreach</code>，你不能利用JavaScript中的短路。如果你不知道短路，让我给你介绍。当我们在JavaScript中使用像<code class="fe kz la lb lc b">AND(&amp;&amp;)</code>、<code class="fe kz la lb lc b">OR(||)</code>这样的逻辑操作符时，它将帮助我们提前终止和/或跳过一个循环的迭代。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h2 id="e485" class="ms ll in bd lm my mz dn lq na nb dp lu jv nc nd ly jz ne nf mc kd ng nh mg ni bi translated">3.为了…的</h2><p id="306f" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated"><code class="fe kz la lb lc b">for...of</code>在ES6(ECMAScript 6)中是标准化的。<code class="fe kz la lb lc b">for...of</code>创建一个循环，在一个可迭代的对象上迭代，比如数组、映射、集合、字符串等。这个循环的另一个优点是可读性更好。</p><pre class="kj kk kl km gt mo lc mp mq aw mr bi"><span id="1dab" class="ms ll in lc b gy mt mu l mv mw">const arr = [3, 5, 7];<br/>const str = 'hello';</span><span id="d731" class="ms ll in lc b gy mx mu l mv mw">for (let i of arr) {<br/>   console.log(i); // logs 3, 5, 7<br/>}</span><span id="950b" class="ms ll in lc b gy mx mu l mv mw">for (let i of str) {<br/>   console.log(i); // logs 'h', 'e', 'l', 'l', 'o'<br/>}</span></pre><p id="ab9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:-不要在发电机上重复使用<code class="fe kz la lb lc b">for...of</code>，即使<code class="fe kz la lb lc b">for...of</code>提前终止。退出循环后，生成器被关闭，再次尝试重复它不会产生进一步的结果。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h2 id="8a6e" class="ms ll in bd lm my mz dn lq na nb dp lu jv nc nd ly jz ne nf mc kd ng nh mg ni bi translated">4.为了…在</h2><p id="5f0a" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated"><code class="fe kz la lb lc b">for...in</code>在一个对象的所有可枚举属性上迭代一个指定的变量。对于每个不同的属性，<code class="fe kz la lb lc b">for...in</code>语句除了返回数字索引之外，还将返回用户定义属性的名称。</p><p id="b33a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在迭代数组时，最好使用传统的带数字索引的<code class="fe kz la lb lc b">for</code>循环。因为<code class="fe kz la lb lc b">for...in</code>语句除了迭代数组元素之外，还迭代用户定义的属性，即使修改数组对象(比如添加自定义属性或方法)。</p><pre class="kj kk kl km gt mo lc mp mq aw mr bi"><span id="58af" class="ms ll in lc b gy mt mu l mv mw">const details = {firstName: 'john', lastName: 'Doe'};<br/>let fullName = '';</span><span id="1795" class="ms ll in lc b gy mx mu l mv mw">for (let i in details) {<br/>    fullName += details[i] + ' '; // fullName: john doe<br/>}</span></pre><p id="6bcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">for..of</code>和<code class="fe kz la lb lc b">for...in</code>的区别</p><p id="71b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">for..of</code>和<code class="fe kz la lb lc b">for...in</code>的主要区别在于它们迭代的内容。<code class="fe kz la lb lc b">for...in</code>循环迭代对象的属性，而<code class="fe kz la lb lc b">for...of</code>循环迭代可迭代对象的值。</p><pre class="kj kk kl km gt mo lc mp mq aw mr bi"><span id="1f1c" class="ms ll in lc b gy mt mu l mv mw">let arr= [4, 5, 6];<br/><br/>for (let i in arr) {<br/>   console.log(i); // '0', '1', '2'<br/>}<br/><br/>for (let i of arr) {<br/>   console.log(i); // '4', '5', '6'<br/>}</span></pre></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/b82444f0ee287daf9db6e28e24088ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E9FPH2LFeFnTGWF5"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine Ivanič</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="83be" class="ms ll in bd lm my mz dn lq na nb dp lu jv nc nd ly jz ne nf mc kd ng nh mg ni bi translated">结论</h2><ul class=""><li id="b6ce" class="nk nl in jm b jn mi jr mj jv nm jz nn kd no kh np nq nr ns bi translated"><code class="fe kz la lb lc b">for</code>速度最快，但可读性差。</li><li id="eb51" class="nk nl in jm b jn nt jr nu jv nv jz nw kd nx kh np nq nr ns bi translated"><code class="fe kz la lb lc b">foreach</code>快速，对迭代属性的控制。</li><li id="14cc" class="nk nl in jm b jn nt jr nu jv nv jz nw kd nx kh np nq nr ns bi translated"><code class="fe kz la lb lc b">for...of</code>缓慢，但更甜。</li><li id="9365" class="nk nl in jm b jn nt jr nu jv nv jz nw kd nx kh np nq nr ns bi translated"><code class="fe kz la lb lc b">for...in</code>慢，不那么得心应手。</li></ul><p id="a7af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，给你一个明智的建议。把你的优先级设置为可读性。当你开发一个复杂的结构时，代码的可读性是必不可少的，但是你也应该关注性能。尽量避免在代码中添加不必要的额外装饰，有时这会影响应用程序的性能。祝你编码愉快。</p></div></div>    
</body>
</html>