<html>
<head>
<title>LeetCode Algorithm Challenge: Maximum Subarray — Brute Force versus Kadane’s Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法挑战:最大子阵列—暴力对抗Kadane算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-challenge-maximum-subarray-brut-force-versus-kadanes-algorithm-333b1267fbc1?source=collection_archive---------5-----------------------#2021-05-10">https://javascript.plainenglish.io/leetcode-algorithm-challenge-maximum-subarray-brut-force-versus-kadanes-algorithm-333b1267fbc1?source=collection_archive---------5-----------------------#2021-05-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1d600df041a141cf83861d8f709e08ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAQcJ-wyEVboL8tpU8K3WQ.png"/></div></div></figure><h2 id="dcab" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">问题</h2><p id="8256" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">给定一个整数数组“nums ”,找到具有最大和的连续子数组(至少包含一个数),并返回其和。</p><p id="9d90" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">例一:</strong></p><p id="f79b" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">输入:</strong> nums = [-2，1，-3，4，-1，2，1，-5，4]</p><p id="aec3" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">输出:</strong> 6</p><p id="4097" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">解释:</strong> [4，-1，2，1]的和最大= 6。</p><p id="7c41" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">例2: </strong></p><p id="ea5a" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">输入:</strong> nums = [1]</p><p id="b614" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">输出:</strong> 1</p><p id="f3fb" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">例3: </strong></p><p id="f05e" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">输入:</strong> nums = [5，4，-1，7，8]</p><p id="12bb" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">输出:</strong> 23</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="7f73" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们在找什么？</h2><p id="0977" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">在此任务中，该函数应该返回子数组值的最大和。子数组是连续数组中的一部分(即，占据连续的位置),并且本质上保持元素的顺序。所以它可以是整个数组的和，数组的一部分，甚至数组的单个元素(例如，[-1，0，-2，5]函数将只返回5)。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="5216" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">选择</h2><p id="6ad8" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们有两个选择来解决这个问题</p><ol class=""><li id="4f3a" class="lz ma in kt b ku ln ky lo ke mb ki mc km md ll me mf mg mh bi translated">蛮力—计算每个可能子数组的总和并进行比较，然后返回最大值。</li><li id="2894" class="lz ma in kt b ku mi ky mj ke mk ki ml km mm ll me mf mg mh bi translated">Kadane的算法——我们不是计算每个最大和，而是基于比较一个元素是否总是增加子数组的和，以及它的值是否高于包括先前元素的子数组的和来计算它。</li></ol></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="9b49" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">蛮力2圈</h2><p id="e20c" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">对于这两种情况，我将使用两个变量:</p><ol class=""><li id="11a4" class="lz ma in kt b ku ln ky lo ke mb ki mc km md ll me mf mg mh bi translated">currSum —当前子数组的总和，它将被赋予数组的第一个元素的默认值。</li><li id="8fa0" class="lz ma in kt b ku mi ky mj ke mk ki ml km mm ll me mf mg mh bi translated">maxSum —最大总和，在开始之前，我们假设数组的第一个元素提供最大总和。</li></ol><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="b5e4" class="jv jw in ms b gy mw mx l my mz">let currSum = nums[0]</span><span id="62eb" class="jv jw in ms b gy na mx l my mz">let maxSum = currSum;</span></pre><p id="2469" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">使用蛮力，我们将需要通过数组循环两次，以计算所有数组的总和。这是第一个循环的开始。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="306c" class="jv jw in ms b gy mw mx l my mz">for (let i = 0; i &lt; nums.length; i++) {</span><span id="b4ec" class="jv jw in ms b gy na mx l my mz">currSum = nums[i];</span></pre><p id="39c4" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">在这个解决方案中，我们将经常检查我们的最大和是否已经改变。因此，如果当前总和高于最大总和，则更新最大总和。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="40a9" class="jv jw in ms b gy mw mx l my mz">if (currSum &gt; maxSum) {</span><span id="ab4e" class="jv jw in ms b gy na mx l my mz">maxSum = currSum</span><span id="7efa" class="jv jw in ms b gy na mx l my mz">}</span></pre><p id="1abc" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">现在，我们进入第二个循环，以确保我们通过每个子数组。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="b5ff" class="jv jw in ms b gy mw mx l my mz">for (let j = i + 1; j &lt; nums.length; j++) {</span><span id="ef27" class="jv jw in ms b gy na mx l my mz">currSum = currSum + nums[j];</span></pre><p id="798d" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">一旦我们到了那里，我们会检查越来越多，如果我们找到一个最大值。一旦我们完成了这个双循环<strong class="kt io"> <em class="lm"> maxSum </em> </strong>将保存可以返回的答案。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="3066" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">野蛮的代码</h2><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="0798" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">卡丹算法</h2><p id="beee" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">据我所知，这种方法是通过消去数字来减少子阵列的和，从而得到最大值。你可以在这里了解更多关于Kadane的算法<a class="ae nd" href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm" rel="noopener ugc nofollow" target="_blank">并且解决这个问题在</a><a class="ae nd" href="https://www.youtube.com/watch?v=jnoVtCKECmQ" rel="noopener ugc nofollow" target="_blank">这个视频</a>中有非常详细的解释。</p><p id="af7f" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">正如我提到的，这两种方法的设置是一样的，但是这种方法会有一些循环，因此速度会更快。</p><p id="7c8e" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">因为在设置中我们假设当前总和等于最大总和，并且等于数组的第一个元素，所以我们可以从数组的第二个元素开始迭代。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="cc10" class="jv jw in ms b gy mw mx l my mz">for (let i = 1; i &lt; nums.length; i++) {</span></pre><p id="f39c" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">棘手的部分来了，我们将比较当前元素加到当前sum值是否会小于当前值。如果当前值更大，我们将使用当前值重置当前总和，并删除数组中开始新的子数组的所有先前部分。否则，我们将只增加当前值的当前总和。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="60b9" class="jv jw in ms b gy mw mx l my mz">if (currSum + nums[i] &lt; nums[i]) {</span><span id="f24e" class="jv jw in ms b gy na mx l my mz">currSum = nums[i]</span><span id="e6d8" class="jv jw in ms b gy na mx l my mz">} else {</span><span id="51b0" class="jv jw in ms b gy na mx l my mz">currSum = currSum + nums[i];</span><span id="3eca" class="jv jw in ms b gy na mx l my mz">}</span></pre><p id="5526" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">然后我们将返回到我们的最大值检查，这看起来和暴力选项exit中的一样，结束我们的循环并返回<strong class="kt io"> maxSum </strong>。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="a67f" class="jv jw in ms b gy mw mx l my mz"> if (currSum &gt; maxSum) {</span><span id="f3ac" class="jv jw in ms b gy na mx l my mz"> maxSum = currSum</span><span id="4e2f" class="jv jw in ms b gy na mx l my mz"> }</span><span id="a475" class="jv jw in ms b gy na mx l my mz">}</span><span id="f66b" class="jv jw in ms b gy na mx l my mz">return maxSum;</span></pre></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="fc71" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">密码</h2><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="fd88" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">蛮力解决方案通常更容易想出来，能够完成这些很好，但这些通常很耗时，我建议尝试找到更聪明和更快的方法。我想我们都知道，现在你可以在网上很多地方找到答案，youtube上也有大量的视频讲解。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="0942" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><em class="lm">请也在以下社交网络上关注我，我很乐意收到你的来信！——</em><a class="ae nd" href="https://www.linkedin.com/in/nick-solonyy/" rel="noopener ugc nofollow" target="_blank"><em class="lm">LinkedIn</em></a><em class="lm">，</em> <a class="ae nd" href="https://github.com/nicksolony" rel="noopener ugc nofollow" target="_blank"> <em class="lm"> GitHub </em> </a>，<a class="ae nd" href="https://www.facebook.com/nick.solony" rel="noopener ugc nofollow" target="_blank"> <em class="lm">脸书</em> </a> <em class="lm">。</em></p><p id="6972" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><em class="lm">更多内容请看</em><a class="ae nd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lm">plain English . io</em></a></p></div></div>    
</body>
</html>