<html>
<head>
<title>Prototype, this stranger!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原型，这个陌生人！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/prototype-this-stranger-7a444098cdd4?source=collection_archive---------11-----------------------#2021-07-21">https://javascript.plainenglish.io/prototype-this-stranger-7a444098cdd4?source=collection_archive---------11-----------------------#2021-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="51dc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中的对象、类和继承指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/35bee21bed179d3027af3a57eed8ddd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsB1jWtHPvpGUdB7aufryQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lordarcadius?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Vipul Jha</a> on <a class="ae ks" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6973" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这篇文章中，我们将看到如何在JavaScript中使用对象、类和继承。特别是，我们将讨论“<em class="lp">原型</em>的概念，以及它如何帮助我们解决与JavaScript中面向对象编程相关的特定问题。</p><h1 id="9e7a" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">一般概念</h1><p id="e317" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">类、对象和继承是面向对象编程中非常重要的概念。在其经典版本中，基本概念基本上有三个:</p><ul class=""><li id="bfd8" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">真实世界的抽象，我们可以用它来表现，比如，一个人，一件事等等。一个类定义了一个状态(<strong class="kv io">属性</strong>)和一个行为(<strong class="kv io">方法</strong>)。</li><li id="0333" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><strong class="kv io"> Object </strong>:是某个类的具体实例，就是我们使用<code class="fe nb nc nd ne b"><strong class="kv io">new</strong></code>操作符时返回给我们的那个。它有自己特定的状态和行为。</li><li id="f026" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">继承:表示一种机制，允许您基于另一个已经定义的(<strong class="kv io">父对象</strong>)创建一个对象(<strong class="kv io">子对象</strong>)。</li></ul><p id="09ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在图形上，我们可以用一个非常简单的例子来概括刚刚表达的概念:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/f4584b1136c2c6b272b7e610fae8379b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3AUlzbasxoxUGPUS-TbrQ.png"/></div></div></figure><p id="cf6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">猫</strong>和<strong class="kv io">狗</strong>类继承了<strong class="kv io">哺乳动物</strong>类的行为，而<strong class="kv io"> c1 </strong>、<strong class="kv io"> c2 </strong>是<strong class="kv io">猫</strong>类的实例，<strong class="kv io"> d1 </strong>、<strong class="kv io"> d2 </strong>是<strong class="kv io">狗</strong>类的实例。</p><h1 id="f35c" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">JavaScript对象</h1><p id="c98f" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">JavaScript中任何不是原始类型的东西都是对象。对象是一组键值对，其中的值可以是对象、原始变量或函数。如果一个对象有多个键值对，它们必须用逗号分隔。可以用两种方式声明一个对象，第一种是使用<code class="fe nb nc nd ne b">Object</code>构造函数，第二种是声明一个变量，其中的键值对被<code class="fe nb nc nd ne b"><strong class="kv io">{}</strong></code>包围。让我们用一个小例子来看看如何声明一个对象:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="5d80" class="nk lr in ne b gy nl nm l nn no">const student = {<br/>  name: 'Davide',<br/>  number: '123456'<br/>}</span><span id="6314" class="nk lr in ne b gy np nm l nn no">const classroom = new Object({<br/>  name: 'Computer Science I',<br/>  teacher: 'Dennis Ritchie'<br/>})</span><span id="f70e" class="nk lr in ne b gy np nm l nn no">console.log(student) <br/>console.log(classroom)</span></pre><p id="24ef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您运行这段代码，结果将是</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="cec1" class="nk lr in ne b gy nl nm l nn no">{ name: 'Davide', number: '123456' }<br/>{ name: 'Computer Science I', teacher: 'Dennis Ritchie' }</span></pre><p id="53a8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以使用点号<code class="fe nb nc nd ne b"><strong class="kv io">.</strong></code>访问对象属性:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="2530" class="nk lr in ne b gy nl nm l nn no">const student = {<br/>  name: 'Davide',<br/>  number: '123456'<br/>}</span><span id="f163" class="nk lr in ne b gy np nm l nn no">const classroom = new Object({<br/>  name: 'Computer Science I',<br/>  teacher: 'Dennis Ritchie'<br/>})</span><span id="c8f1" class="nk lr in ne b gy np nm l nn no">console.log(`Student: ${student.name}`)<br/>console.log(`Teacher: ${classroom.teacher}`)</span></pre><p id="3e51" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，结果将是:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="e78c" class="nk lr in ne b gy nl nm l nn no">Student: Davide<br/>Teacher: Dennis Ritchie</span></pre><h2 id="0f84" class="nk lr in bd ls nq nr dn lw ns nt dp ma lc nu nv mc lg nw nx me lk ny nz mg oa bi translated">定义对象属性</h2><p id="0467" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在JavaScript中有几种方法来定义对象的属性。第一个是指定对象名称，后跟:点、新属性的名称、等号和新属性的值:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="7cf6" class="nk lr in ne b gy nl nm l nn no">const student = {<br/>  name: 'Davide',<br/>  number: '123456'<br/>}</span><span id="06ea" class="nk lr in ne b gy np nm l nn no">student.birthday = '4th July'<br/>console.log(student)</span></pre><p id="4c25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">显然，如果我们运行这段代码，结果将是:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="dff3" class="nk lr in ne b gy nl nm l nn no">{ name: 'Davide', number: '123456', birthday: '4th July' }</span></pre><p id="a353" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在对象之间组合属性是一种常见的做法。一个财产一个财产地去做是很无聊的。静态函数<code class="fe nb nc nd ne b">Object.assign</code>用几行代码帮助我们做到这一点。让我们通过一个小例子来看看它是如何工作的:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="fc58" class="nk lr in ne b gy nl nm l nn no">const obj = {}<br/>const student = {<br/>  name: 'Davide',<br/>  number: '123456'<br/>}</span><span id="0e88" class="nk lr in ne b gy np nm l nn no">Object.assign(obj, student, {<br/>  birthday: '4th July'<br/>})</span><span id="1046" class="nk lr in ne b gy np nm l nn no">console.log(obj)</span></pre><p id="733a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，在这种情况下，我们通过运行脚本得到的结果将是:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="3bcf" class="nk lr in ne b gy nl nm l nn no">{ name: 'Davide', number: '123456', birthday: '4th July' }</span></pre><p id="195e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该函数从最后一个对象开始迭代输入中传递的对象的所有属性，并将它们赋给先前输入中给定的对象。所以在上面的例子中，<code class="fe nb nc nd ne b">birthday</code>属性被分配给<code class="fe nb nc nd ne b">student</code>对象，之后<code class="fe nb nc nd ne b">student</code>对象的属性被分配给<code class="fe nb nc nd ne b">obj</code>。如果我们分配的属性存在于最左边的对象中，作为参数传递，这将被新的对象覆盖。如果我们修改脚本如下:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="ab72" class="nk lr in ne b gy nl nm l nn no">const obj = {<br/>  birthday: '2nd July'<br/>}</span><span id="92ae" class="nk lr in ne b gy np nm l nn no">const student = {<br/>  name: 'Davide',<br/>  number: '123456',<br/>  birthday: '3rd July'<br/>}</span><span id="6f30" class="nk lr in ne b gy np nm l nn no">Object.assign(obj, student, {<br/>  birthday: '4th July'<br/>})</span><span id="edf5" class="nk lr in ne b gy np nm l nn no">console.log(obj)</span></pre><p id="5bbb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">毫无疑问，我们通过运行这个脚本得到的结果将与前面的示例中得到的结果相同:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="80da" class="nk lr in ne b gy nl nm l nn no">{ name: 'Davide', number: '123456', birthday: '4th July' }</span></pre><p id="610b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">定义对象属性的另一种方法是使用静态函数<code class="fe nb nc nd ne b">Object.assign</code>。它不仅允许我们定义属性的名称和可能的值，还为我们提供了一系列对我们定义的属性有用的选项。特别是，该函数将三个参数作为输入:</p><ul class=""><li id="ce6f" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">要向其添加属性的对象；</li><li id="3a10" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">属性的名称；</li><li id="02bf" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">一个选项对象。</li></ul><p id="61fc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过将options对象作为第三个参数传递，我们可以指定以下属性:</p><ul class=""><li id="f968" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated"><strong class="kv io">可配置</strong>:如果设置为<code class="fe nb nc nd ne b">true</code>，属性可以被删除或修改。其默认值为<code class="fe nb nc nd ne b">false</code>。</li><li id="6e1c" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><strong class="kv io">可枚举</strong>:如果设置为<code class="fe nb nc nd ne b">true</code>，则该属性在对象的属性枚举过程中可见(例如<code class="fe nb nc nd ne b">for..in</code>或<code class="fe nb nc nd ne b">Object.keys()</code>)。默认值为<code class="fe nb nc nd ne b">false</code>；</li><li id="0669" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><strong class="kv io">值</strong>:我们想要分配给属性的值。其默认值为<code class="fe nb nc nd ne b">undefined</code>；</li><li id="c2c0" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><strong class="kv io">可写</strong>:如果设置为<code class="fe nb nc nd ne b">true</code>，该属性可被覆盖。其默认值为<code class="fe nb nc nd ne b">false</code>；</li><li id="caa4" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><strong class="kv io"> get </strong>:表示返回添加属性的值的方法的函数。其默认值为<code class="fe nb nc nd ne b">undefined</code>；</li><li id="e50e" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><strong class="kv io"> set </strong>:表示设置添加属性的值的方法的函数。其默认值为<code class="fe nb nc nd ne b">undefined</code>；</li></ul><p id="528a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们用一些实际例子来看看如何使用这个函数。我们在我们的<code class="fe nb nc nd ne b">student</code>对象上定义一个新的<code class="fe nb nc nd ne b">birthday</code>属性。该属性只有在定义后才是可读的，并且不可编辑，因此，除了给value属性一个初始值，我们还将writable属性设置为<code class="fe nb nc nd ne b">false</code>:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="001e" class="nk lr in ne b gy nl nm l nn no">const student = {<br/>  name: 'Davide',<br/>  number: '123456'<br/>}</span><span id="6058" class="nk lr in ne b gy np nm l nn no">Object.defineProperty(student, 'birthday', {<br/>  writable: false,<br/>  value: '4th July'<br/>})</span><span id="617d" class="nk lr in ne b gy np nm l nn no">console.log(student) // [1]<br/>console.log(student.birthday) // [2]</span><span id="b04c" class="nk lr in ne b gy np nm l nn no">// [3]<br/>student.birthday = 'Another date'<br/>console.log(student.birthday)</span></pre><p id="3ea6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">运行该脚本时，您会得到一个运行时错误，例如:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="ac77" class="nk lr in ne b gy nl nm l nn no">TypeError: Cannot assign to read only property ‘birthday’ of object ‘#&lt;Object&gt;’</span></pre><p id="31e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们分析一下脚本中强调的三点:</p><ul class=""><li id="303b" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">我们没有设置<code class="fe nb nc nd ne b">enumerable</code>属性，那么该属性将具有默认值<code class="fe nb nc nd ne b">false</code>，因此当我们试图用<code class="fe nb nc nd ne b">console.log</code>在屏幕上打印整个对象时，<code class="fe nb nc nd ne b">birthday</code>属性及其相对值将不会显示。</li><li id="8d1d" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">第二个<code class="fe nb nc nd ne b">console.log</code>将正确地在屏幕上打印生日属性的值。</li><li id="cd3f" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">我们没有将<code class="fe nb nc nd ne b">writable</code>选项的值设置为<code class="fe nb nc nd ne b">false</code>，<code class="fe nb nc nd ne b">birthday</code>属性不能被覆盖，结果我们将在运行时得到一个错误。</li></ul><p id="e3f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看第1点和第3点的行为是如何变化的，对我们的代码做了这个小小的改变:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="1bdd" class="nk lr in ne b gy nl nm l nn no">...<br/>Object.defineProperty(student, 'birthday', {<br/>  writable: true,<br/>  enumerable: true,<br/>  value: '4th July'<br/>})<br/>...</span></pre><p id="cffa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将<code class="fe nb nc nd ne b">writable</code>和<code class="fe nb nc nd ne b">enumerable</code>属性设置为<code class="fe nb nc nd ne b">true</code>后，脚本将不会出错退出，还会显示之前不可见的<code class="fe nb nc nd ne b">birthday</code>属性:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="c788" class="nk lr in ne b gy nl nm l nn no">{ name: 'Davide', number: '123456', birthday: '4th July' }<br/>4th July<br/>Another date</span></pre><p id="2d8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在JavaScript中，可以使用<code class="fe nb nc nd ne b">delete</code>删除对象的属性。现在让我们试着删除之前定义的<code class="fe nb nc nd ne b">birthday</code>属性。让我们在脚本的末尾添加这两行:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="6b38" class="nk lr in ne b gy nl nm l nn no">...<br/>Object.defineProperty(student, 'birthday', {<br/>  writable: true,<br/>  enumerable: true,<br/>  value: '4th July'<br/>})<br/>...</span><span id="7204" class="nk lr in ne b gy np nm l nn no">delete student.birthday<br/>console.log(student)</span></pre><p id="a0f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们运行这个脚本，我们将在运行时得到以下错误:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="a188" class="nk lr in ne b gy nl nm l nn no">TypeError: Cannot delete property 'birthday' of #&lt;Object&gt;</span></pre><p id="96e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们得到这个错误是因为<code class="fe nb nc nd ne b">configurable</code>参数的默认值是其<code class="fe nb nc nd ne b">false</code>。这意味着不可能从我们的对象中删除<code class="fe nb nc nd ne b">birthday</code>属性。如果我们尝试将它设置为true，如下所示:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="a7b8" class="nk lr in ne b gy nl nm l nn no">...<br/>Object.defineProperty(student, 'birthday', {<br/>  <strong class="ne io">configurable: true</strong>,<br/>  writable: true,<br/>  enumerable: true,<br/>  value: '4th July'<br/>})<br/>...</span><span id="7cfd" class="nk lr in ne b gy np nm l nn no">delete student.birthday<br/>console.log(student)</span></pre><p id="95fc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">脚本将不再以错误结束，但结果会如预期的那样正确地打印在屏幕上:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="f024" class="nk lr in ne b gy nl nm l nn no">{ name: 'Davide', number: '123456', birthday: '4th July' }<br/>4th July<br/>Another date<br/>{ name: 'Davide', number: '123456' }</span></pre><h2 id="8a13" class="nk lr in bd ls nq nr dn lw ns nt dp ma lc nu nv mc lg nw nx me lk ny nz mg oa bi translated">原型</h2><p id="96a6" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">所有的JavaScript对象都有[[prototype]]。此属性是对在属性搜索中查询的另一个对象的隐式引用。</p><p id="cd00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果对象没有特定属性，则检查对象的<code class="fe nb nc nd ne b">prototype</code>是否有该属性。如果对象<code class="fe nb nc nd ne b">prototype</code>不具有该属性，则对象<code class="fe nb nc nd ne b">prototype</code>被选中，依此类推。这就是继承在JavaScript中的工作方式，JavaScript是一种原型语言。这将在本文后面详细探讨。</p><h2 id="8bed" class="nk lr in bd ls nq nr dn lw ns nt dp ma lc nu nv mc lg nw nx me lk ny nz mg oa bi translated">对象.创建</h2><p id="0a58" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在JavaScript中这个方法可以用来替换<strong class="kv io">新的</strong>关键字。我们可以使用它来创建一个基于已定义原型的空对象，然后将它分配给一个不同的原型:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="d54c" class="nk lr in ne b gy nl nm l nn no">const anotherObject = {<br/>  a: 2<br/>}<br/><br/>// create an object linked to anotherObject<br/>const myObject = Object.create(anotherObject)<br/><br/>myObject.a // the value will be 2</span></pre><p id="f5a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在<code class="fe nb nc nd ne b">myObject</code>与<code class="fe nb nc nd ne b">anotherObject</code>挂钩。显然<code class="fe nb nc nd ne b">myObject.a</code>实际上并不存在，但是，对属性的访问是成功的，因为在<code class="fe nb nc nd ne b">anotherObject</code>上存在，并且实际上找到了值<code class="fe nb nc nd ne b">2</code>。</p><h1 id="d104" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">遗产</h1><p id="c38c" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">基本上在JavaScript中，继承是通过一系列的<strong class="kv io"> [[prototype]] </strong>获得的。创建这个原型链有几种方法，但在本文中我们将分析最常见的方法:</p><ul class=""><li id="fdea" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">功能的</li><li id="61a1" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">构造函数</li><li id="b15e" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">班级</li></ul><p id="57cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<strong class="kv io"> [[prototype]] </strong>我们可以向现有的对象构造函数添加新的属性和方法。然后，我们可以告诉我们的JavaScript代码从原型继承属性。这个原型链允许我们通过指针函数引用从一个JavaScript对象到另一个对象重用属性和方法。想要与经典继承进行比较，下面是发生的图形:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/087082b23ddffc2da00f4c3c13acd39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6eqVcxdNizGZDoWzV3nXA.png"/></div></div></figure><h2 id="ce64" class="nk lr in bd ls nq nr dn lw ns nt dp ma lc nu nv mc lg nw nx me lk ny nz mg oa bi translated">功能继承</h2><p id="ea5b" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">要用这种方法创建原型链，只需使用前面显示的<code class="fe nb nc nd ne b">Object.create</code>函数。让我们用一个例子来看看怎么做:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="b967" class="nk lr in ne b gy nl nm l nn no">const mammal = {<br/>  introduceYourself: function () {<br/>    console.log(`Hello I'm a ${this.type} and my name is: ${this.name}`)<br/>  }<br/>}</span><span id="4edc" class="nk lr in ne b gy np nm l nn no">const cat = Object.create(mammal, {<br/>  type: { value: 'cat' },<br/>  noise: { value: 'meow' },<br/>  meow: { value: function () {<br/>    console.log(`I ${this.verso}: MEEEEEOOOOOW`)<br/>  }}<br/>})</span><span id="9aef" class="nk lr in ne b gy np nm l nn no">const dog = Object.create(mammal, {<br/>  type: { value: 'dog' },<br/>  noise: { value: 'bark' },<br/>  bark: { value: function () {<br/>    console.log(`I ${this.noise}: WOOF WOOF`)<br/>  }}<br/>})</span><span id="dcdc" class="nk lr in ne b gy np nm l nn no">const fuffy = Object.create(cat, { name: { value: 'Fuffy' } })<br/>fuffy.introduceYourself()<br/>fuffy.meow()</span><span id="651d" class="nk lr in ne b gy np nm l nn no">const bobby = Object.create(dog, { name: { value: 'Bobby' } })<br/>bobby.introduceYourself()<br/>bobby.bark()</span></pre><p id="3c12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nb nc nd ne b">mammal</code>对象是一个简单的JavaScript对象，使用括号<code class="fe nb nc nd ne b">{}</code>定义。这种简单物体的原型是<code class="fe nb nc nd ne b">Object.prototype</code>。前面描述的<code class="fe nb nc nd ne b">Object.create</code>函数，我们已经创建了<code class="fe nb nc nd ne b">cat</code>和<code class="fe nb nc nd ne b">dog</code>对象，将所需对象的原型作为第一个参数传递，在本例中为<code class="fe nb nc nd ne b">mammal</code>。所以<code class="fe nb nc nd ne b">mammal</code>就是<code class="fe nb nc nd ne b">cat</code>和<code class="fe nb nc nd ne b">dog</code>的原型。当<code class="fe nb nc nd ne b">bobby</code>和<code class="fe nb nc nd ne b">fuffy</code>对象被创建时，它们作为第一个参数被分别传递给<code class="fe nb nc nd ne b">Object.create</code>函数、<code class="fe nb nc nd ne b">dog</code>和<code class="fe nb nc nd ne b">cat</code>。所以<code class="fe nb nc nd ne b">dog</code>是<code class="fe nb nc nd ne b">bobby</code>的原型<code class="fe nb nc nd ne b">cat</code>是<code class="fe nb nc nd ne b">fuffy</code>的原型。整个原型链是:</p><ul class=""><li id="eb6b" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">fuffy</code>的原型是<code class="fe nb nc nd ne b">cat</code>；</li><li id="de57" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">bobby</code>的原型是<code class="fe nb nc nd ne b">dog</code>；</li><li id="8cc0" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">dog</code>和<code class="fe nb nc nd ne b">cat</code>原型为<code class="fe nb nc nd ne b">mammal</code>；</li><li id="b5f1" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">mammal</code>原型是<code class="fe nb nc nd ne b">Object.prototype</code>。</li></ul><p id="9270" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">分析<code class="fe nb nc nd ne b">fuffy.introduceYourself()</code>执行的步骤(同样地<code class="fe nb nc nd ne b">bobby.introduceYourself()</code>)，让我们试着更好地理解执行了哪些步骤:</p><ul class=""><li id="bed1" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">检查<code class="fe nb nc nd ne b">fuffy</code>是否具有属性<code class="fe nb nc nd ne b">introduceYourself</code>；事实并非如此；</li><li id="a316" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">检查<code class="fe nb nc nd ne b">fuffy</code>、<code class="fe nb nc nd ne b">cat</code>的原型是否具有属性<code class="fe nb nc nd ne b">introduceYourself</code>；事实并非如此；</li><li id="9a55" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">检查<code class="fe nb nc nd ne b">cat</code>、<code class="fe nb nc nd ne b">mammal</code>的原型是否具有属性<code class="fe nb nc nd ne b">introduceYourself</code>；执行它；</li><li id="25d7" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">对<code class="fe nb nc nd ne b">fuffy</code>执行功能<code class="fe nb nc nd ne b">introduceYourself</code>，因此<code class="fe nb nc nd ne b">mammal</code>类型、<code class="fe nb nc nd ne b">this.type</code>将为<code class="fe nb nc nd ne b">cat</code>、<code class="fe nb nc nd ne b">this.name</code>将为“Fuffy”。</li></ul><p id="bb18" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了完成应用于原型继承的函数范例，创建一个<code class="fe nb nc nd ne b">dog</code>和一个<code class="fe nb nc nd ne b">cat</code>的实例可以用一个函数来概括:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="f156" class="nk lr in ne b gy nl nm l nn no">...<br/><br/>function createCat (name) {<br/>  return Object.create(cat, {<br/>    name: { value: name }<br/>  })<br/>}</span><span id="570b" class="nk lr in ne b gy np nm l nn no">function createDog (name) {<br/>  return Object.create(dog, {<br/>    name: { value: name }<br/>  })<br/>}</span><span id="1f00" class="nk lr in ne b gy np nm l nn no">const fuffy = createCat('Fuffy')<br/>fuffy.introduceYourself()<br/>fuffy.meow()</span><span id="a9e6" class="nk lr in ne b gy np nm l nn no">const bobby = createCat('Bobby')<br/>bobby.introduceYourself()<br/>bobby.bark()</span></pre><p id="db85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">记住物体的原型可以用<code class="fe nb nc nd ne b">Object.getPrototypeOf()</code>检查:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="1184" class="nk lr in ne b gy nl nm l nn no">console.log(Object.getPrototypeOf(fuffy) === cat) //true<br/>console.log(Object.getPrototypeOf(bobby) === dog) //true</span></pre><h2 id="5733" class="nk lr in bd ls nq nr dn lw ns nt dp ma lc nu nv mc lg nw nx me lk ny nz mg oa bi translated">构造函数继承</h2><p id="5204" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这种方法常用且简单，只需声明一个函数并使用<strong class="kv io"> new </strong>关键字调用它。让我们回到之前展示的例子:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="bdd4" class="nk lr in ne b gy nl nm l nn no">function Mammal (name) {<br/>  this.name = name<br/>}</span><span id="89fa" class="nk lr in ne b gy np nm l nn no">Mammal.prototype.introduceYourself = function () {<br/>  console.log(`Hello I'm a ${this.type} and my name is: ${this.name}`)<br/>}</span><span id="172f" class="nk lr in ne b gy np nm l nn no">function Cat (name) {<br/>  this.type = 'cat'<br/>  this.noise = 'meow'<br/>  Mammal.call(this, name)<br/>}</span><span id="d5be" class="nk lr in ne b gy np nm l nn no">Cat.prototype.meow = function () {<br/>  console.log(`I ${this.noise}: MEEEEEOOOOOW`)<br/>}</span><span id="566c" class="nk lr in ne b gy np nm l nn no">Object.<strong class="ne io">setPrototypeOf</strong>(Cat.prototype, Mammal.prototype)</span><span id="b32c" class="nk lr in ne b gy np nm l nn no">function Dog (name) {<br/>  this.type = 'dog'<br/>  this.noise = 'bark'<br/>  <br/>  Mammal.call(this, name)<br/>}</span><span id="d3e9" class="nk lr in ne b gy np nm l nn no">Dog.prototype.bark = function () {<br/>  console.log(`I ${this.noise}: WOOF WOOF`)<br/>}</span><span id="756a" class="nk lr in ne b gy np nm l nn no">Object.<strong class="ne io">setPrototypeOf</strong>(Dog.prototype, Mammal.prototype)</span><span id="aa23" class="nk lr in ne b gy np nm l nn no">const fuffy = new Cat('Fuffy')<br/>fuffy.introduceYourself()<br/>fuffy.meow()<br/>const bobby = new Dog('Bobby')<br/>bobby.introduceYourself()<br/>bobby.bark()</span></pre><p id="1292" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">构造函数<code class="fe nb nc nd ne b">Dog</code>、<code class="fe nb nc nd ne b">Cat</code>和<code class="fe nb nc nd ne b">Mammal</code>的首字母大写。就像在面向对象编程中一样，这是一个惯例，在这种情况下也是如此。</p><p id="21f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当<code class="fe nb nc nd ne b">new Cat('Fuffy')</code>被调用时，一个新的<code class="fe nb nc nd ne b">Cat</code>实例被创建(<code class="fe nb nc nd ne b">fuffy</code>)。这个新对象也是<code class="fe nb nc nd ne b">Cat</code>构造函数中的<code class="fe nb nc nd ne b">this</code>对象。之后，<code class="fe nb nc nd ne b">Cat</code>将对自身的引用，<code class="fe nb nc nd ne b">this</code>传递给<code class="fe nb nc nd ne b">Mammal.call</code>。使用这个方法允许您通过传递给它的第一个参数来设置函数的<code class="fe nb nc nd ne b">this</code>对象。然后，当<code class="fe nb nc nd ne b">this</code>被传递给<code class="fe nb nc nd ne b">Mammal.call</code>时，通过<code class="fe nb nc nd ne b">Cat</code>构造函数内的<code class="fe nb nc nd ne b">this</code>对象，对新创建的对象(最终被分配给<code class="fe nb nc nd ne b">fuffy</code>)的引用也被创建。传递给调用的所有后续参数都成为函数的参数，所以传递给哺乳动物的名字的参数是“Fuffy”。<code class="fe nb nc nd ne b">Mammal</code>构造器将<code class="fe nb nc nd ne b">this.name</code>设置为“Fuffy”，这意味着最终<code class="fe nb nc nd ne b">fuffy.name</code>也将是“Fuffy”。所以如果我们想描述整个原型链:</p><ul class=""><li id="e8be" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">fuffy</code>原型为<code class="fe nb nc nd ne b">Cat.prototype</code>；</li><li id="1fa7" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">bobby</code>原型为<code class="fe nb nc nd ne b">Dog.prototype</code>；</li><li id="1a6a" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">dog</code>和<code class="fe nb nc nd ne b">cat</code>原型为<code class="fe nb nc nd ne b">Mammal.prototype</code>；</li><li id="9bf0" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">Mammal</code>的原型是<code class="fe nb nc nd ne b">Object.prototype</code>。</li></ul><h2 id="e4bd" class="nk lr in bd ls nq nr dn lw ns nt dp ma lc nu nv mc lg nw nx me lk ny nz mg oa bi translated">类别继承</h2><p id="09cd" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">JavaScript的现代版本中引入了一点语法糖。显然我们说的是关键字<strong class="kv io"> class </strong>，建议不要把这个关键字和其他OOP语言中的同一个词混淆，比如Java。</p><p id="10be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript中的这个关键字无非是创建一个构造函数，然后必须用<strong class="kv io"> new </strong>调用它。事实上，如果您使用任何浏览器的开发人员控制台并尝试键入:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="12fa" class="nk lr in ne b gy nl nm l nn no"><strong class="ne io">typeof</strong> class Mammal {}</span></pre><p id="1834" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">结果将是:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ef85cd8a0a5715f1a3f543f7599d1e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*PgxfslWlUVj52H8I9TKrrQ.png"/></div></figure><p id="dfe5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用class只会减少代码行数，从而增加可读性，这对创建原型链很有用。现在让我们第三次也是最后一次回到我们的例子:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="cc96" class="nk lr in ne b gy nl nm l nn no"><strong class="ne io">class</strong> Mammal {<br/>  <strong class="ne io">constructor</strong> (name) {<br/>    this.name = name<br/>  }</span><span id="655c" class="nk lr in ne b gy np nm l nn no">  introduceYourself () {<br/>    console.log(`Hello I'm a ${this.type} and my name is: ${this.name}`)<br/>  }<br/>}</span><span id="490f" class="nk lr in ne b gy np nm l nn no"><strong class="ne io">class</strong> Cat <strong class="ne io">extends</strong> Mammal {<br/>  <strong class="ne io">constructor</strong> (name) {<br/>    super(name)</span><span id="89d7" class="nk lr in ne b gy np nm l nn no">    this.type = 'cat'<br/>    this.noise = 'meow'<br/>  }</span><span id="cd90" class="nk lr in ne b gy np nm l nn no">  meow () {<br/>    console.log(`I ${this.noise}: MEEEEEOOOOOW`)<br/>  }<br/>}</span><span id="c271" class="nk lr in ne b gy np nm l nn no"><strong class="ne io">class</strong> Dog <strong class="ne io">extends</strong> Mammal {<br/>  <strong class="ne io">constructor</strong> (name) {<br/>    super(name)</span><span id="55a8" class="nk lr in ne b gy np nm l nn no">    this.type = 'dog'<br/>    this.noise = 'bark'<br/>  }</span><span id="7edc" class="nk lr in ne b gy np nm l nn no">  bark () {<br/>    console.log(`I ${this.noise}: WOOF WOOF`)<br/>  }<br/>}</span><span id="2efd" class="nk lr in ne b gy np nm l nn no">const fuffy = new Cat('Fuffy')<br/>fuffy.introduceYourself()<br/>fuffy.meow()</span><span id="bb69" class="nk lr in ne b gy np nm l nn no">const bobby = new Dog('Bobby')<br/>bobby.introduceYourself()<br/>bobby.bark()</span></pre><p id="a721" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，原型链也是:</p><ul class=""><li id="44c9" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">fuffy</code>原型是<code class="fe nb nc nd ne b">Cat.prototype</code>；</li><li id="9b10" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">bobby</code>的原型是<code class="fe nb nc nd ne b">Dog.prototype</code>；</li><li id="936f" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">dog</code>和<code class="fe nb nc nd ne b">cat</code>的原型是<code class="fe nb nc nd ne b">Mammal.prototype</code>；</li><li id="efea" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated"><code class="fe nb nc nd ne b">Mammal</code>的原型是<code class="fe nb nc nd ne b">Object.prototype</code>。</li></ul><p id="87d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关键字<code class="fe nb nc nd ne b">extends</code>使得原型继承更加容易。在示例代码中，<code class="fe nb nc nd ne b">Dog</code>扩展了<code class="fe nb nc nd ne b">Mammal</code>类，将确保<code class="fe nb nc nd ne b">Dog.prototype</code>的原型是<code class="fe nb nc nd ne b">Mammal.prototype</code>。每个类中的构造函数方法相当于构造函数的函数体。例如，这个函数:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="550f" class="nk lr in ne b gy nl nm l nn no">function Dog (name) {<br/>  this.name = name<br/>}</span></pre><p id="729a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">相当于:</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="6f82" class="nk lr in ne b gy nl nm l nn no">class Dog {<br/>  constructor (name) {<br/>    this.name = name<br/>  }<br/>}</span></pre><p id="c8df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nb nc nd ne b">Dog</code>类构造函数方法中的<code class="fe nb nc nd ne b">super</code>关键字是通过将<code class="fe nb nc nd ne b">this</code>设置到当前实例中来调用父类构造函数的通用方法。在构造函数<code class="fe nb nc nd ne b">Dog.call(this, name)</code>的例子中，这里变成了<code class="fe nb nc nd ne b">super(name)</code>的等价物。</p><h1 id="955c" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">结论</h1><p id="cfda" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">JavaScript中原型继承的概念经常会引起一些混乱。我希望通过阅读这篇文章，它会更加清晰和简单。好吧，现在…</p><pre class="kd ke kf kg gt ng ne nh ni aw nj bi"><span id="2fb2" class="nk lr in ne b gy nl nm l nn no">HAPPY, CODING!</span></pre><h1 id="2f6f" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">文献学</h1><div class="od oe gp gr of og"><a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">ECMA-262 - Ecma国际</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">敬请注意，规范性文案是HTML版本；已经制作了PDF版本，以生成可打印的…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.ecma-international.org</p></div></div></div></a></div><div class="od oe gp gr of og"><a href="https://www.packtpub.com/product/ecmascript-cookbook/9781788628174" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">ECMAScript食谱| Packt</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">通过使用ES6和ES8编写高效的模块化代码，成为更好的web程序员</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.packtpub.com</p></div></div><div class="op l"><div class="oq l or os ot op ou km og"/></div></div></a></div><p id="a222" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>