<html>
<head>
<title>Stacks— Purposes, Implementations &amp; Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈—目的、实施和应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stacks-purposes-implementations-applications-2d9e2bc6f33b?source=collection_archive---------20-----------------------#2021-01-11">https://javascript.plainenglish.io/stacks-purposes-implementations-applications-2d9e2bc6f33b?source=collection_archive---------20-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/89f7b90a4da45b6affa42b347921b655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sAM3X-F9GfVbZGAV"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brooke Lark</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f516" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi ky translated">成为一名伟大的开发人员的道路有时会非常坎坷。<a class="ae jz" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lh">栈溢出</em> </a>可能是这个时代最受欢迎的网站和工具之一，几乎每个开发者每天至少引用一次，<em class="lh">如果不是更多</em>。这个名字来自计算机科学中使用的最重要和最常见的数据结构之一，一个<em class="lh">栈</em>。我们将回顾一下<em class="lh">堆栈溢出</em>实际上是什么，但是首先…</p><h1 id="4294" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是堆栈？</h1><p id="87e1" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">与<a class="ae jz" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表</a>或<a class="ae jz" href="https://en.wikipedia.org/wiki/Array_data_structure" rel="noopener ugc nofollow" target="_blank">数组</a>相比，<em class="lh">栈</em>是一种线性数据结构，可以包含一组元素。作为一种具有有限容量的抽象数据类型，堆栈只是一种数据结构，允许以特定的顺序添加和删除元素。当添加一个元素时，它位于堆栈的顶部，唯一可以移除的元素是最后添加的元素，其位置在堆栈的最顶部。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/854f8db9f3d065342bbea7d0e2638f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvo7eCYWQEjcXXy1AYAu2A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Stack Push &amp; Pop operations taken from <a class="ae jz" href="https://www.programiz.com/dsa/stack" rel="noopener ugc nofollow" target="_blank">Programiz</a></figcaption></figure><p id="e724" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想到这一点的一个简单方法是想象一个叠一个的板块。堆叠顶部的板是第一个被移除的板，放置在最底部位置的板将在堆叠中保留最长时间。这种行为被称为后进先出法(T21)或后进先出法。</p><h2 id="350e" class="mq lj in bd lk mr ms dn lo mt mu dp ls kl mv mw lw kp mx my ma kt mz na me nb bi translated">常见操作</h2><p id="2323" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">以下是在堆栈上执行的一些最常见的操作:</p><ul class=""><li id="472b" class="nc nd in kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated"><strong class="kc io"> Push: </strong>将一个项目添加到堆栈中——如果堆栈已满，会导致<em class="lh">堆栈溢出(不是网站)。</em></li><li id="0f11" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><strong class="kc io">弹出:</strong>从堆栈中删除一个项目——如果堆栈为空，将导致<em class="lh">堆栈下溢。</em></li><li id="f761" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><strong class="kc io"> Peek或Top: </strong>返回栈顶元素。</li><li id="4f52" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><strong class="kc io"> isEmpty: </strong>如果堆栈为空，则返回true否则，将返回false。</li></ul><h1 id="2385" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用JavaScript实现</h1><blockquote class="nq"><p id="8172" class="nr ns in bd nt nu nv nw nx ny nz kx dk translated">这里是一个使用数组的JavaScript实现stack的例子— <em class="oa">假设stack可以动态增长。</em></p></blockquote><figure class="ob oc od oe of jo"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Implementation of a Stack in JavaScript ES6 using an array.</figcaption></figure></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><h1 id="597e" class="li lj in bd lk ll op ln lo lp oq lr ls lt or lv lw lx os lz ma mb ot md me mf bi translated">JavaScript的调用堆栈</h1><p id="488b" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">作为一名学习JavaScript的新开发人员，您将了解到该语言是单线程的，每个语句都是同步运行的。这意味着语言中的语句不能同时或并行执行。JavaScript引擎基于单个<a class="ae jz" href="https://en.wikipedia.org/wiki/Call_stack" rel="noopener ugc nofollow" target="_blank"> <em class="lh">调用堆栈</em> </a> <em class="lh"> </em>，这是一个堆栈数据结构，基本上存储了关于任何给定JavaScript程序中的每个函数调用和语句的信息。</p><blockquote class="ou ov ow"><p id="0468" class="ka kb lh kc b kd ke kf kg kh ki kj kk ox km kn ko oy kq kr ks oz ku kv kw kx ig bi translated">调用堆栈是一种解释器跟踪其在调用多个函数的脚本中的位置的机制——当前正在运行什么函数，以及从该函数中调用了什么函数。[1]</p></blockquote><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi pa"><img src="../Images/39f50a1ac05f1552283e50bb2089b004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RfetiQ2EnnN2RvyN.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Call Stack visualization taken from <a class="ae jz" href="https://medium.com/swlh/in-depth-introduction-to-call-stack-in-javascript-a07b8513bcc3" rel="noopener">Medium</a></figcaption></figure><p id="b144" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">开发人员在使用JavaScript时，尤其是在发出API请求时，通常需要编写异步代码。例如，如果您正在编写一个使用外部API的应用程序，并且您正在请求同步下载一个图像，如果互联网速度慢或API关闭，程序将会冻结并且无法继续运行。当您同步请求数据时会发生这种情况，因为JavaScript会等待，直到请求完成且响应从API发回，然后再继续应用程序中的下一条语句。</p><p id="6654" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用JavaScript ES6，有许多新的和旧的方法来编写异步代码。一个简单而伟大的异步JavaScript例子是<code class="fe pb pc pd pe b">setTimeout()</code>。该方法利用浏览器的Web API来确保作为该方法的参数调用的代码将在给定的时间后运行。</p><pre class="mm mn mo mp gt pf pe pg ph aw pi bi"><span id="56f7" class="mq lj in pe b gy pj pk l pl pm">//setTimeout([callback], milliseconds)</span><span id="a2f3" class="mq lj in pe b gy pn pk l pl pm">function hello() {<br/>    console.log('Hello world');<br/>}</span><span id="2536" class="mq lj in pe b gy pn pk l pl pm">setTimeout(hello, 5000);<br/>console.log("This will output before: 'Hello World'");</span></pre><p id="4772" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的块中，<code class="fe pb pc pd pe b">setTimeout()</code>方法在<em class="lh"> 5000毫秒</em>后调用<code class="fe pb pc pd pe b">hello()</code>函数。虽然<code class="fe pb pc pd pe b">console.log()</code>是在<code class="fe pb pc pd pe b">setTimeout()</code>方法被调用之后被调用的，但是Web API将回调作为第一个参数传递到<code class="fe pb pc pd pe b">setTimeout()</code>方法中，并将其放入<strong class="kc io"> <em class="lh">回调队列</em> </strong>中，直到给定的时间(在本例中为<em class="lh"> 5000毫秒</em>)过去。</p><h1 id="c0c4" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">JavaScript的事件循环</h1><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi po"><img src="../Images/a54da9abfd30576e6bb71cf6cce93ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5yeInQdtk0lDI49J.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">JavaScript’s Event Loop taken from <a class="ae jz" href="https://www.loginradius.com/blog/async/understanding-event-loop/" rel="noopener ugc nofollow" target="_blank">loginradius</a></figcaption></figure><p id="c234" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是事件循环中每个元素的简要概述:</p><p id="c965" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">堆栈(调用堆栈):</strong>这是一个堆栈，所有的JavaScript代码在整个程序中被同步地推入其中。解释器读取代码，一旦执行完成，每个项目按时间顺序从堆栈中弹出。如果调用栈中的语句是异步的，比如<code class="fe pb pc pd pe b">setTimeout(),</code>一个承诺，或者<code class="fe pb pc pd pe b">ajax()</code>一个请求，回调函数将被推送到回调队列，这是另一个<em class="lh">栈，</em>它将在那里等待执行。</p><p id="8875" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">堆(内存堆):</strong>这是为整个程序中的任何变量、对象和函数分配内存的地方。</p><p id="1c0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">回调队列:</strong>来自调用栈中异步代码的回调会被推送到回调队列中，一直等到调用栈空闲。一旦调用栈被释放，来自异步函数的回调将被推回到调用栈，并且回调将作为正常的函数执行来执行。</p><p id="e441" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">事件循环:</strong>事件循环持续运行，一直检查调用栈中是否有函数调用，如果没有，会检查回调队列。如果回调队列不为空，它将弹出回调队列中的任何内容，并将其推入调用堆栈以便执行。</p><blockquote class="nq"><p id="83fe" class="nr ns in bd nt nu nv nw nx ny nz kx dk translated"><a class="ae jz" href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">放大镜</a>是一个很棒的工具，可以帮助你可视化调用栈是如何排队的，以及事件循环和回调队列是如何工作的。</p></blockquote><h1 id="c917" class="li lj in bd lk ll lm ln lo lp lq lr ls lt pp lv lw lx pq lz ma mb pr md me mf bi translated">有用的应用</h1><p id="973c" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated"><strong class="kc io">内存管理— </strong>任何现代计算机都使用堆栈。计算机系统上运行的每个程序都有自己的内存分配。它被称为堆栈内存分配，因为分配发生在函数调用堆栈中。</p><p id="84eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些<em class="lh">(但不是全部)</em>其他有用的应用包括:</p><ul class=""><li id="35cb" class="nc nd in kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated">重做-撤销特性(几乎在任何程序中)</li><li id="047e" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">浏览器历史记录</li><li id="2f6e" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">Web浏览器中的向前和向后功能</li><li id="1fc3" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">回溯问题</li><li id="020f" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">字符串反转</li><li id="05bf" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><a class="ae jz" href="https://www.geeksforgeeks.org/topological-sorting/" rel="noopener ugc nofollow" target="_blank">拓扑排序</a> &amp; <a class="ae jz" href="https://www.geeksforgeeks.org/strongly-connected-components/" rel="noopener ugc nofollow" target="_blank">强连通分量</a></li></ul></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><h1 id="b795" class="li lj in bd lk ll op ln lo lp oq lr ls lt or lv lw lx os lz ma mb ot md me mf bi translated">那么……是什么让栈如此特别呢？</h1><p id="c126" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">堆栈模式本身！回想一下<strong class="kc io"> LIFO </strong> <em class="lh">(后进先出)</em>，从堆栈中插入或移除元素的唯一方法，允许从顶部开始调整任何内容。在计算机科学中，我们在堆栈中存储对象，无论是数字、字符串、内存地址，甚至是其他数据结构；不胜枚举！</p></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><h2 id="376c" class="mq lj in bd lk mr ms dn lo mt mu dp ls kl mv mw lw kp mx my ma kt mz na me nb bi translated"><strong class="ak">参考文献</strong></h2><p id="1c08" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">[1]<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Glossary/Call _ stack</a></p><div class="ps pt gp gr pu pv"><a href="https://www.programiz.com/dsa/stack" rel="noopener  ugc nofollow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd io gy z fp qa fr fs qb fu fw im bi translated">堆栈数据结构</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">堆栈是编程中一种有用的数据结构。就像一堆盘子叠放在一起。在这个…</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">www.programiz.com</p></div></div><div class="qe l"><div class="qf l qg qh qi qe qj jt pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a href="https://www.geeksforgeeks.org/stack-data-structure-introduction-program/#:~:text=Mainly%20the%20following%20three%20basic,an%20item%20in%20the%20stack.&amp;text=Peek%20or%20Top%3A%20Returns%20top,stack%20is%20empty%2C%20else%20false" rel="noopener  ugc nofollow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd io gy z fp qa fr fs qb fu fw im bi translated">堆栈数据结构(简介和程序)- GeeksforGeeks</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">堆栈是一种线性数据结构，它遵循操作执行的特定顺序。订单可能会…</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="qe l"><div class="qk l qg qh qi qe qj jt pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a href="https://www.geeksforgeeks.org/implementation-stack-javascript/" rel="noopener  ugc nofollow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd io gy z fp qa fr fs qb fu fw im bi translated">JavaScript - GeeksforGeeks中栈的实现</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">在本文中，我们将使用Javascript实现堆栈数据结构。栈是一个非常有用的数据结构和…</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="qe l"><div class="ql l qg qh qi qe qj jt pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a href="https://www.loginradius.com/blog/async/understanding-event-loop/" rel="noopener  ugc nofollow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd io gy z fp qa fr fs qb fu fw im bi translated">理解JavaScript中的事件循环</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">我们经常听说JavaScript是单线程编程语言，这意味着它执行所有的…</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">www.loginradius.com</p></div></div><div class="qe l"><div class="qm l qg qh qi qe qj jt pv"/></div></div></a></div></div></div>    
</body>
</html>