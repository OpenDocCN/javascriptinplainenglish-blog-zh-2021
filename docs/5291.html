<html>
<head>
<title>What are the Benefits of Functional Programming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程有什么好处？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/benefits-of-functional-programming-8e69e2b06fd6?source=collection_archive---------1-----------------------#2021-10-30">https://javascript.plainenglish.io/benefits-of-functional-programming-8e69e2b06fd6?source=collection_archive---------1-----------------------#2021-10-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/3f43e0982f4416d74481d024df98cfe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*fzPRbnHIwEohJhEZBAbKiA.jpeg"/></div></figure><h1 id="3ff7" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">介绍</h1><p id="54e4" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">函数式编程是一种范式，在这种范式中，我们通常使用函数来构建代码。这些函数接受名为参数的输入，然后显示在接受的输入上创建的输出。虽然输出本身可能不同，但函数体中有相同的参数集和相似的逻辑，相同的逻辑被重用，从而防止我们编写多余的代码。</p><p id="fc6f" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">函数式编程是计算机科学中的一种模式，其中程序是严格通过函数创建的。在函数式编程中，所有这些都是在函数的支持下完成的，基本的构建模块只是函数。</p><p id="30f8" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">近年来，函数式编程在开发社区中变得非常流行。这通常是由于它提供的好处。在这篇文章中，我们将对函数式编程及其好处有一个深入而透彻的理解。</p><h1 id="9423" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">描述</h1><p id="4003" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">函数式编程是一种抽象，以一种简单和可操作的方式解决现实世界中的复杂问题。在面向对象编程出现之前，软件行业完全依赖于函数式编程。这种模式扰乱了软件行业几十年。</p><p id="0ae2" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">函数式编程不允许任何变异和共享状态。在这种范式下，函数应该保持纯粹和真实的表达。相对于命令性或程序性，它是声明性的。</p><p id="1072" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">函数式编程只是一组不允许外部作用域和对象突变的函数。然后，我们通过在范围内添加或删除来改变数组，以获得类似于OOP的解决方案。泛函是纯粹的，直接的，不会变异。它以开放的方式为其智能功能提供了答案。</p><h1 id="71ea" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">函数式编程的特点</h1><p id="7251" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">函数式编程的主要特点是:</p><p id="8c8c" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><strong class="kr io">数据不可变:</strong></p><p id="76db" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">存在于函数中的数据是不可变的。在函数式编程中，我们可以很容易地创建一个新的数据结构，但不能修改现有的数据结构。我们可以随时在函数中插入函数，而没有任何限制。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6388" class="mb js in lx b gy mc md l me mf">function executeFunctions(x, y) { </span><span id="05df" class="mb js in lx b gy mg md l me mf">const add = (x, y) =&gt; x + y;  </span><span id="9d93" class="mb js in lx b gy mg md l me mf">const subtract = (x, y) =&gt; x — y;  </span><span id="616e" class="mb js in lx b gy mg md l me mf">console.log(`sum: ${add(x,y)}`);  </span><span id="a5fa" class="mb js in lx b gy mg md l me mf">console.log(`difference: ${subtract(x,y)}`);}</span></pre><p id="a052" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><strong class="kr io">高阶函数</strong></p><p id="71a6" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">它是一个函数，作为一个参数成为一个函数。它可以将函数作为结果输出返回，也可以不返回。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ea93" class="mb js in lx b gy mc md l me mf">function greaterThan(n) {<br/>   return x =&gt; x &gt; n;<br/>}let greaterThanTwo = greaterThan(2);console.log(greaterThanTwo(5));</span></pre><p id="a749" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><strong class="kr io">模块化</strong></p><p id="4d93" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">这是函数式编程最重要的特性之一。这有助于我们将一个大项目分解成更简单的模块。这些模块可以被清楚地测试，这支持我们减少花费在单元测试和调试上的时间。</p><p id="37e6" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">函数组合是一种组合或创建函数的性能，通过将函数作为参数并返回输出，我们可以进一步简化和压缩函数。它还可以返回另一个函数作为输出，而不是数值或字符串值。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="178f" class="mb js in lx b gy mc md l me mf">var compose = (f, g) =&gt; (x) =&gt; f(g(x));</span></pre><h1 id="7768" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">函数式编程的好处</h1><p id="185f" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kr io">用更简单的方式解决问题:</strong></p><p id="9381" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">函数式编程是一个纯函数。这意味着它不会复制其范围之外的任何数据。它只关心其范围内的内容。它只根据输入提供输出。</p><p id="6c8f" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">例如，纯函数确保外部程序的状态不会改变。在可能情况下，它们比不纯的函数更适合编写。然而，在某些情况下，需要一个不纯的函数。例如，如果我们需要打一个网络电话，与一个数据库相关，或者打印数据到控制台。</p><p id="7b04" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><strong class="kr io">一尘不染，开放而简洁</strong></p><p id="8b34" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">函数式编程一直是开放的。因此，很容易发现函数中的一些差异并调试一些bug。实际上，构建函数比在OOP中构建一个类更干净，更容易维护。从那时起，我们需要从命令或程序模式的角度来考虑问题。例如，设计类层次结构、封装、继承、方法和多态。</p><p id="fbf0" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><strong class="kr io">它导致更少的bug</strong></p><p id="1896" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">为了减少bug，用纯函数调试和编写代码要容易得多。每一层的简单堆栈跟踪或打印语句都会揭示问题，因为每个函数只是输入到输出的映射。我们几乎可以在代码库中的任何地方共享或可变状态，这可能会导致命令式范例的错误。</p><p id="4617" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><strong class="kr io">函数签名更可靠</strong></p><p id="f6dc" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">请看下面的Go代码:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6b0d" class="mb js in lx b gy mc md l me mf">var radius = 2.0</span><span id="47ce" class="mb js in lx b gy mg md l me mf">func areaOfCircle() float64 {</span><span id="2c40" class="mb js in lx b gy mg md l me mf">    return 3.14 * radius * radius</span><span id="f172" class="mb js in lx b gy mg md l me mf">}</span></pre><p id="d8e3" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">条件是，无论我们在哪里计算圆的面积，我们首先更新全局半径变量，然后得到正确的输出。理论上，这个代码是可行的。困难在于检查函数的签名并不能提供全部情况。一个纯函数会有一个签名，告诉我们所有我们需要知道的关于它的用法。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="328a" class="mb js in lx b gy mc md l me mf">// we don't know which circle's area is being computed, there's no explicit input</span><span id="a269" class="mb js in lx b gy mg md l me mf">func areaOfCircle() float64</span><span id="3eca" class="mb js in lx b gy mg md l me mf">We may fix the problem by creation the function pure:</span><span id="c0be" class="mb js in lx b gy mg md l me mf">func areaOfCircle(radius float64) float64 {</span><span id="cd04" class="mb js in lx b gy mg md l me mf">    return 3.14 * radius * radius</span><span id="9d8c" class="mb js in lx b gy mg md l me mf">}</span></pre><h1 id="db5c" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">不可变的变量导致较少的副作用</h1><p id="4cdf" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">数据内部函数程序的函数是不可变的。我们总是会创造新的变量和数据结构。但是，我们不允许修改现有的值。</p><p id="ced5" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">如果一个程序中的每个值只被赋值一次，那么就很容易阅读代码并控制在任何给定点的值。如果作为一种替代方法，允许更新指定的值，那么要查看代码中不同行发生了什么可能要困难得多。不变性大大简化了程序，提高了开发速度。</p><p id="d405" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><em class="mh">欲了解更多详情，请访问:</em></p><div class="mi mj gp gr mk ml"><a href="https://www.technologiesinindustry4.com/2021/10/benefits-of-functional-programming.html" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">函数式编程的好处——工业4.0的新兴技术</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">函数式编程是一种范式，在这种范式中，我们通常使用函数来构建代码。这些…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">www.technologiesinindustry4.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jp ml"/></div></div></a></div><p id="24ce" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><em class="mh">更多内容请看</em><a class="ae na" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="mh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>