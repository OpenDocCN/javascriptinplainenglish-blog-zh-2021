<html>
<head>
<title>JavaScript Const vs. Var vs. Let: A Comprehensive Guide for All Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Const vs. Var vs. Let:一个全面的指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-const-vs-var-vs-let-a-comprehensive-guide-for-all-time-d6d836c8bbd7?source=collection_archive---------4-----------------------#2021-10-19">https://javascript.plainenglish.io/javascript-const-vs-var-vs-let-a-comprehensive-guide-for-all-time-d6d836c8bbd7?source=collection_archive---------4-----------------------#2021-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="89c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你应该使用什么以及为什么常量变量不总是常量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8e477c8347b16f0c3ef8ef10b9e74732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Boqy3gan6hWdM-igyVSog.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image made by the <a class="ae kv" href="http://www.arnoldcode.com" rel="noopener ugc nofollow" target="_blank">Author</a> with assets from (<a class="ae kv" href="https://www.pngkey.com/download/u2q8e6r5u2e6t4u2_image-black-and-white-stock-lavapotion-potion-bottle/" rel="noopener ugc nofollow" target="_blank">pngkey</a> &amp; <a class="ae kv" href="https://pin.it/4LcP11V" rel="noopener ugc nofollow" target="_blank">Pinterest</a>)</figcaption></figure><p id="f5b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用<code class="fe ls lt lu lv b">var</code>创建的变量似乎与用<code class="fe ls lt lu lv b">let</code>创建的变量相同？你已经创建了一个<code class="fe ls lt lu lv b">const</code>变量，但是属性已经被改变了，嗯？<br/><code class="fe ls lt lu lv b">var</code><code class="fe ls lt lu lv b">let</code><code class="fe ls lt lu lv b">const</code>对你来说还是个谜吗？</p><p id="a61e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在ECMAScript6诞生之前，声明统治了世界。存在与用<code class="fe ls lt lu lv b">var</code>声明的变量相关的问题。谣言四起，是时候出现声明变量的新方法了。作为<a class="ae kv" href="https://en.wikipedia.org/wiki/ECMAScript" rel="noopener ugc nofollow" target="_blank"> ES6 </a>的一部分，增加了<code class="fe ls lt lu lv b">let</code>和<code class="fe ls lt lu lv b">const</code>来声明变量。</p><p id="2e3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于<code class="fe ls lt lu lv b">var</code>、<code class="fe ls lt lu lv b">let</code>、<code class="fe ls lt lu lv b">const</code>的<strong class="ky ir">范围</strong>、<strong class="ky ir">使用</strong>、<strong class="ky ir">吊装</strong>，你会有一个非常清楚的了解。当你阅读时，记下不同之处，然后像专业人士一样编码。</p><h1 id="6bbe" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">定义变量</h1><blockquote class="mo mp mq"><p id="fea6" class="kw kx mr ky b kz la jr lb lc ld ju le ms lg lh li mt lk ll lm mu lo lp lq lr ij bi translated">想象一下，你正在玩一个RPG中的角色，你想从一个妖精商人那里买一些药水。有人不知道<code class="fe ls lt lu lv b"><em class="iq">var</em></code>、<code class="fe ls lt lu lv b"><em class="iq">let</em></code>和<code class="fe ls lt lu lv b"><em class="iq">const</em></code>之间的区别，却开发了这个商店，例子解释了我们没有错的地方和实际上好的地方以及原因。</p></blockquote><p id="634c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们讨论上述问题之前，你必须了解更多。</p><h2 id="635d" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">风险值的范围</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/74c3af55111a4d8d2f06bf67a9540987.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*igfk4Ye58wTmALDfYKUX6Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image made by the <a class="ae kv" href="http://www.arnoldcode.com" rel="noopener ugc nofollow" target="_blank">Author</a> with asset from <a class="ae kv" href="https://www.freepik.com/free-vector/what-is-witchcraft-horizontal-banner-with-ancient-manuscripts-glass-bottles-magical-potion_15078063.htm#page=1&amp;query=potion&amp;from_query=health%20potion&amp;position=8&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">freepik</a></figcaption></figure><p id="226f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">作用域</strong>表示可以使用这些变量的地方。<code class="fe ls lt lu lv b">var</code>声明是全局作用域或函数/局部作用域。</p><p id="fe44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个<code class="fe ls lt lu lv b">var</code>变量在函数外被声明时，全局作用域“发生”。在功能块外用<code class="fe ls lt lu lv b">var</code>声明它，那么它可以在整个窗口中使用。</p><p id="aee3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你把一个用<code class="fe ls lt lu lv b">var</code>声明的变量放入一个函数中时，它就是函数范围的。它仅在该功能中可用和可访问。</p><p id="89e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进一步理解，请看下面的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e414" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<code class="fe ls lt lu lv b">priceTag</code>是全局范围的，因为它是在函数<code class="fe ls lt lu lv b">newFunction()</code>之外声明和初始化的，而<code class="fe ls lt lu lv b">name</code>是函数范围的。</p><p id="1db2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您不能在<code class="fe ls lt lu lv b">newFunction()</code>之外访问变量<code class="fe ls lt lu lv b">name</code>。尝试访问它并…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0e18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…您刚刚创建了一个错误。<code class="fe ls lt lu lv b">name</code>的结果在<code class="fe ls lt lu lv b">newFunction()</code>之外不可用。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="2545" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">重新声明和更新Var变量</h2><p id="9dc7" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">您可以在相同的范围内这样做，并且不会得到错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d52c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那个肮脏的小贩提高了价格！</p><p id="8745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在不引发错误的情况下，也可以执行以下操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="ad2b" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">Var的吊装</h2><p id="221b" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">提升是一种JavaScript机制，在代码执行之前，变量和函数声明被移动到它们作用域的顶部。这意味着如果你这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript将其解释如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1af5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在第一个例子的第2行中放入一个<code class="fe ls lt lu lv b">console.log(priceTag)</code>并调用该函数，然后您将得到<code class="fe ls lt lu lv b">undefined</code>来访问<code class="fe ls lt lu lv b">priceTag</code>。</p><p id="9a30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码似乎在工作，没有出现错误。但是变量稍后被初始化(将一个值放入变量中)。</p><blockquote class="mo mp mq"><p id="81f3" class="kw kx mr ky b kz la jr lb lc ld ju le ms lg lh li mt lk ll lm mu lo lp lq lr ij bi translated">一个变量在被声明之前就存在并不直观，但是在JavaScript中，这是事实。这个变量可以在这个函数的开始使用，尽管它可以在函数体的最后一行声明。请记住，在执行初始化代码行之前，变量是未定义的。</p></blockquote></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="82a7" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">风险值的问题是</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/5950474b399e4f5d70712f4793c70ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDLYyk8hvVf4WQopKGKUaw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image made by the <a class="ae kv" href="http://www.arnoldcode.com" rel="noopener ugc nofollow" target="_blank">Author</a> with asset from <a class="ae kv" href="https://www.freepik.com/free-vector/what-is-witchcraft-horizontal-banner-with-ancient-manuscripts-glass-bottles-magical-potion_15078063.htm#page=1&amp;query=potion&amp;from_query=health%20potion&amp;position=8&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">freepik</a></figcaption></figure><p id="3dbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">var</code>的缺点是在第二个作用域中覆盖了一个已经定义的全局变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mr">这个可疑的卖主不给我们购买四种药剂的折扣。他玩了个小把戏，所以我们每瓶药水要付45金币！</em></p><p id="911b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，由于<code class="fe ls lt lu lv b">amountToBuy &gt; 3</code>返回true，所以<code class="fe ls lt lu lv b">priceTag</code>被重新定义为<code class="fe ls lt lu lv b">45</code>。虽然如果你有意想要重新定义<code class="fe ls lt lu lv b">priceTag</code>这不是问题，但是当你没有意识到一个变量<code class="fe ls lt lu lv b">priceTag</code>之前已经被定义了，这就成问题了。</p><blockquote class="mo mp mq"><p id="48fd" class="kw kx mr ky b kz la jr lb lc ld ju le ms lg lh li mt lk ll lm mu lo lp lq lr ij bi translated">对于本文中的一小段，您可能会直接发现问题。想象一下在一个更大的代码库中…</p></blockquote><p id="114f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经在代码的其他部分使用了<code class="fe ls lt lu lv b">priceTag</code>，您可能会对您可能得到的输出感到惊讶。这可能会导致代码中出现错误。</p><p id="02af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mr">这就是为什么</em><code class="fe ls lt lu lv b"><em class="mr">let</em></code><em class="mr"/><code class="fe ls lt lu lv b"><em class="mr">const</em></code><em class="mr">是必要的。</em></p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="cdd3" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">Star Vars —吊装专业角</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/15c7afe5e2856d03138d91795eefb58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjG_C8ZkoboOviImWYZngQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image made by the <a class="ae kv" href="http://www.arnoldcode.com" rel="noopener ugc nofollow" target="_blank">Author</a> from <a class="ae kv" href="https://www.dafont.com/de/star-jedi.font" rel="noopener ugc nofollow" target="_blank">dafont.com</a></figcaption></figure><blockquote class="mo mp mq"><p id="eb67" class="kw kx mr ky b kz la jr lb lc ld ju le ms lg lh li mt lk ll lm mu lo lp lq lr ij bi translated">这是额外的信息，你需要知道什么是块，但没有必要理解let &amp; var &amp; const的区别。直接进入第<strong class="ky ir">章，让</strong>通过，不要领取200美元。</p></blockquote><p id="b0dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于循环，此<strong class="ky ir">提升</strong>与<em class="mr">相关。</em>很快导致bug，照顾你在屏幕前疑惑的脸。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码不会像您可能假设的那样打印出两个项目<code class="fe ls lt lu lv b">Healing Potion</code>和<code class="fe ls lt lu lv b">Gold</code>。</p><p id="1319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你得到的反而是两倍的<code class="fe ls lt lu lv b">undefined</code>。这就是证据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b21d8e8a122bdee224a28bc5d7360a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*MqrMZA-Nfzqwpu5Z5F3elw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Console Printout of Code From hoistingPro.js</figcaption></figure><p id="c19f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">它是怎么来的？</strong></p><p id="30a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数定义了变量的作用域。一个块(也就是我们的for循环)不能为用<code class="fe ls lt lu lv b">var</code>声明的变量定义范围。</p><p id="758b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有函数允许这样做。运行指数<code class="fe ls lt lu lv b">i</code>存在于全局空间中，并且只有一次。不是块的每次迭代一次。由于<code class="fe ls lt lu lv b">setTimeout</code>将暂停执行<code class="fe ls lt lu lv b">i</code>乘以1000毫秒，在打印输出之前，运行索引<code class="fe ls lt lu lv b">i</code>将具有<code class="fe ls lt lu lv b">2</code>的值。</p><p id="536e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数组<code class="fe ls lt lu lv b">items</code>只得到两个元素，它们的索引分别是<code class="fe ls lt lu lv b">0</code>和<code class="fe ls lt lu lv b">1</code>。结果以<code class="fe ls lt lu lv b">undefined</code>作为返回。</p><p id="ee4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank">闭包</a>帮助你将循环的内容放入一个匿名函数中，并用运行索引作为参数调用它。它将外部块的状态保存到setTimeout的内部块中，即匿名函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/51eb3d7726237352fea37a975cd62dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*Jo3GMkbF7g-gLA5IG2FQUQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Console Printout of Code From hoistingClosure.js</figcaption></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="29d1" class="lw lx iq bd ly lz ny mb mc md nz mf mg jw oa jx mi jz ob ka mk kc oc kd mm mn bi translated">让</h1><p id="603d" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">对于变量声明，你应该总是选择<code class="fe ls lt lu lv b">let</code>。这并不奇怪，因为它是对<code class="fe ls lt lu lv b">var</code>声明的改进。它也解决了我们在<code class="fe ls lt lu lv b">var</code>中提到的托管问题。</p><h2 id="6a93" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">Let是块范围的，这是块的信条</h2><ol class=""><li id="4c03" class="od oe iq ky b kz nr lc ns lf of lj og ln oh lr oi oj ok ol bi translated">一个<strong class="ky ir">块</strong>是由<code class="fe ls lt lu lv b">{ }</code>界定的一段代码。</li><li id="58cb" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr oi oj ok ol bi translated">一个<strong class="ky ir">块</strong>住在花括号里。</li><li id="2a88" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr oi oj ok ol bi translated">花括号内的任何内容都是一个<strong class="ky ir">块</strong>。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/f27595a183bc8cf70ca095c6878c6e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZ-gfv6Z_3nntXOm7ai-rg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image made by the <a class="ae kv" href="http://www.arnoldcode.com" rel="noopener ugc nofollow" target="_blank">Author</a> with asset from <a class="ae kv" href="https://www.freepik.com/free-vector/what-is-witchcraft-horizontal-banner-with-ancient-manuscripts-glass-bottles-magical-potion_15078063.htm#page=1&amp;query=potion&amp;from_query=health%20potion&amp;position=8&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">freepik</a></figcaption></figure><p id="f4af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在块内用<code class="fe ls lt lu lv b">let</code>声明的变量只能在该块内使用。让我用一个例子来解释这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="mo mp mq"><p id="25c1" class="kw kx mr ky b kz la jr lb lc ld ju le ms lg lh li mt lk ll lm mu lo lp lq lr ij bi translated">那个见不得人的小贩不会再骗我们了！</p></blockquote><p id="4446" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到，在其块外使用<code class="fe ls lt lu lv b">priceTag</code>会返回一个<code class="fe ls lt lu lv b">30</code>。这是因为<code class="fe ls lt lu lv b">let</code>变量是块范围的。</p><p id="68b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么这没有引发错误？因为这两个实例被视为不同的变量，因为它们具有不同的作用域。与上面的<code class="fe ls lt lu lv b">shadyVendor.js</code>进行比较，以完全理解不同之处。</p><p id="5538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得<code class="fe ls lt lu lv b">let</code>比<code class="fe ls lt lu lv b">var</code>更好。当你使用<code class="fe ls lt lu lv b">let</code>时，你不必在变量存在之前就为变量命名。只有在它的范围内，你才必须小心谨慎。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h2 id="3d39" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">用字母更新但不重新声明</h2><p id="4792" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">就像<code class="fe ls lt lu lv b">var</code>一样，用<code class="fe ls lt lu lv b">let</code>声明的变量可以在其作用域内更新。</p><p id="1068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">var</code>不同，<code class="fe ls lt lu lv b">let</code>变量不能在其作用域内重新声明。所以尽管这行得通:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="951b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将返回一个错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="61eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果同一个变量在不同的作用域中定义，就不会有错误，正如你在<code class="fe ls lt lu lv b">notThisTime.js</code>中看到的。</p><p id="7159" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从外部访问块范围的变量怎么样？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，由于一个变量不能在任何范围内被声明超过一次，那么前面讨论的关于<code class="fe ls lt lu lv b">var</code>的问题就不会发生。</p><h2 id="a826" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">左起重</h2><p id="6f87" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">var</code>一样，<code class="fe ls lt lu lv b">let</code>申报被吊到最上面。</p><p id="178d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与初始化为<code class="fe ls lt lu lv b">undefined</code>的<code class="fe ls lt lu lv b">var</code>不同，<code class="fe ls lt lu lv b">let</code>关键字没有初始化。如果你试图在声明前使用一个<code class="fe ls lt lu lv b">let</code>变量，你会得到一个<code class="fe ls lt lu lv b">Reference Error</code>。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="5861" class="lw lx iq bd ly lz ny mb mc md nz mf mg jw oa jx mi jz ob ka mk kc oc kd mm mn bi translated">常数</h1><p id="0f3a" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">用<code class="fe ls lt lu lv b">const</code>声明的变量保持恒定值。<code class="fe ls lt lu lv b">const</code>声明与<code class="fe ls lt lu lv b">let</code>声明有一些相似之处。</p><h2 id="385b" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">具有常量的块范围声明</h2><p id="7ebd" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated"><code class="fe ls lt lu lv b">const</code>声明只能在声明它们的块中被访问。类似于<code class="fe ls lt lu lv b">let</code>声明。</p><h2 id="f027" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">没有用Const更新或重新声明</h2><p id="c3b3" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">这意味着用<code class="fe ls lt lu lv b">const</code>声明的变量的值在其作用域内保持不变。它不能更新或重新声明。用<code class="fe ls lt lu lv b">const</code>声明变量，你既不能这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a3ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也不是这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="75c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，每个<code class="fe ls lt lu lv b">const</code>声明都必须在声明时初始化。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="b80b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于用 <code class="fe ls lt lu lv b">const</code> <strong class="ky ir">声明的对象，这种行为有些不同。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/eed9754b683b81be806c57cda70d9348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sv82fvtGo_pUjn-M5EgHZg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image made by the <a class="ae kv" href="http://www.arnoldcode.com" rel="noopener ugc nofollow" target="_blank">Author</a> with asset from <a class="ae kv" href="https://www.freepik.com/free-vector/what-is-witchcraft-horizontal-banner-with-ancient-manuscripts-glass-bottles-magical-potion_15078063.htm#page=1&amp;query=potion&amp;from_query=health%20potion&amp;position=8&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">freepik</a></figcaption></figure><p id="c61d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然不能更新整个对象的引用，但可以更新对象的属性。</p><p id="4d8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果您像这样声明一个<code class="fe ls lt lu lv b">const</code>对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bf31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然您不能这样做(在源代码的另一部分):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7efb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1c5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将更新<code class="fe ls lt lu lv b">potion.priceTag</code>的值，而不会返回错误。</p><p id="9c77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">黑幕妖精又耍我们了！现在我们不得不花60金币买一瓶简单的健康药水，而不是30金币… </p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/3b782a3bf172181d1b32bfff04653dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*IMLmZeVNPhQ--DIZ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Gif from <a class="ae kv" href="https://thehustle.co/gold-on-gold-on-goldddd/" rel="noopener ugc nofollow" target="_blank">theHustle</a></figcaption></figure><h2 id="70a0" class="mv lx iq bd ly mw mx dn mc my mz dp mg lf na nb mi lj nc nd mk ln ne nf mm ng bi translated">建筑吊装</h2><p id="1364" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">就像<code class="fe ls lt lu lv b">let</code>，<code class="fe ls lt lu lv b">const</code>声明被提升到顶部，但是没有被初始化。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="7d30" class="lw lx iq bd ly lz ny mb mc md nz mf mg jw oa jx mi jz ob ka mk kc oc kd mm mn bi translated">外卖食品</h1><ul class=""><li id="422d" class="od oe iq ky b kz nr lc ns lf of lj og ln oh lr os oj ok ol bi translated"><code class="fe ls lt lu lv b">var</code>声明存在于全局作用域或函数作用域中。</li><li id="2c63" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr os oj ok ol bi translated"><code class="fe ls lt lu lv b">let</code>和<code class="fe ls lt lu lv b">const</code>是块范围的。</li><li id="0313" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr os oj ok ol bi translated">您可以更新<code class="fe ls lt lu lv b">var</code>变量，并在其作用域内重新声明它们。</li><li id="6536" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr os oj ok ol bi translated">您也可以更新但不能重新声明<code class="fe ls lt lu lv b">let</code>变量。</li><li id="f196" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr os oj ok ol bi translated"><code class="fe ls lt lu lv b">const</code>变量既不能更新也不能重新声明。</li><li id="77bd" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr os oj ok ol bi translated">所有都被提升到其范围的顶部。</li><li id="79e0" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr os oj ok ol bi translated">当<code class="fe ls lt lu lv b">var</code>变量用<code class="fe ls lt lu lv b">undefined</code>初始化时，<code class="fe ls lt lu lv b">let</code>和<code class="fe ls lt lu lv b">const</code>变量不初始化。</li><li id="6fb5" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr os oj ok ol bi translated"><code class="fe ls lt lu lv b">var</code>和<code class="fe ls lt lu lv b">let</code>无需初始化即可声明</li><li id="9791" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr os oj ok ol bi translated"><code class="fe ls lt lu lv b">const</code>必须在声明期间初始化。</li></ul><p id="d1f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有任何问题或补充吗？请让我知道。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="6aef" class="lw lx iq bd ly lz ny mb mc md nz mf mg jw oa jx mi jz ob ka mk kc oc kd mm mn bi translated">结论</h1><p id="9225" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated"><code class="fe ls lt lu lv b">var</code>是一个遗产，但主要由新人使用，因为它似乎是最好的/第一选择，或者你在没有选择的时候就开始编写JavaScript代码。</p><p id="080d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<code class="fe ls lt lu lv b">var</code>很容易被误解为<code class="fe ls lt lu lv b">variable</code>或<code class="fe ls lt lu lv b">variant</code>的简称，我在2015年刚接触JavaScript时，甚至不知道自己在做什么就用了这个词。</p><p id="7848" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mr">今天已经不宜再用了。从你的工具集中禁止它，或者至少将它锁定在遗留代码中，那里的损害可能已经造成了，哈哈哈！</em></strong></p><p id="d709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要处理遗留代码，必须具备提升和<code class="fe ls lt lu lv b">var</code>方面的知识。</p><p id="a5ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，当配置正确时，棉绒使我们的生活变得更容易，即使不正确，也可以慢慢使用<code class="fe ls lt lu lv b">const</code> &gt; <code class="fe ls lt lu lv b">let</code> &gt; <code class="fe ls lt lu lv b">var</code>。</p><p id="a088" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读:)</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="d989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获取26份备忘单，只研究你真正需要的东西，以获得你的第一份网络开发工作！T3】</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/227a060a3bfa55f41fa795d5990e6032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nqyiu4c6K-mCxE9e.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank">Arnold Code Academy 26 Web Developer Cheatsheets</a></figcaption></figure><p id="15b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mr">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>