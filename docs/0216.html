<html>
<head>
<title>How To Write Your Own Custom React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写自己的自定义React挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-write-your-own-custom-react-hooks-e0cc05160ba2?source=collection_archive---------15-----------------------#2021-01-12">https://javascript.plainenglish.io/how-to-write-your-own-custom-react-hooks-e0cc05160ba2?source=collection_archive---------15-----------------------#2021-01-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4fe1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">抽象函数中的复杂逻辑，并在组件间重用它</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c30f7967c36696afd6d8eb08dedc0c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*piM9lYxWXqon6aXg.png"/></div></div></figure><p id="2216" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您使用React已经有一段时间了，那么您可能会遇到需要将一些逻辑提取到一个可重用的函数中。随着React hooks的出现，这样做已经变成了在公园里散步。我们可以编写自己的自定义react挂钩来抽象函数中的复杂逻辑，并跨组件重用它。</p><h1 id="e2cd" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">什么是自定义React挂钩？</h1><p id="0b9b" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">自定义的React钩子实际上是一个在组件内部运行的函数。它可以在内部运行其他钩子或者其他函数。这些函数/钩子也可以是递归的。它使得像渲染道具和高阶组件这样的模式变得不必要。在编写功能组件时，这是一个强大的工具，它为我们提供了以下优势:</p><ul class=""><li id="064f" class="mh mi in kq b kr ks ku kv kx mj lb mk lf ml lj mm mn mo mp bi translated">构建自己的钩子/逻辑</li><li id="1b6e" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">提供挂钩React特定功能的能力，例如生命周期和状态</li><li id="6470" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">便携式逻辑</li><li id="4279" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">快速迭代</li></ul><p id="5b4d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了应用程序中的钩子和定制的React钩子，我们可以开始依赖我们的组件来负责用户界面，钩子是处理业务逻辑的部分。</p><p id="c122" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你还没有研究过React钩子，我们建议你在研究这个钩子之前先看看我们之前关于React钩子的文章。</p><p id="8a38" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在开始使用自定义React挂钩之前，需要知道的一件事是，函数有一个命名约定。里面的逻辑不要紧，但是函数前面一定要加“用”字。</p><p id="9dc5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在使用定制钩子之前，检查一下React文档中钩子<a class="ae mv" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank"> post </a>的规则也是一个好主意。</p><p id="22c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这篇文章是关于理解和编写自定义的React钩子，而不是关于使用它们的可能性。天空是无限的，许多开源社区已经开发了数量惊人的钩子。虽然它们可能对我们的应用程序有用，但是我们应该知道如何编写我们自己的自定义React钩子，因为我们的业务用例相关钩子将不存在。</p><h1 id="b44d" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们要做什么？</h1><p id="daaa" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">尽管我们知道自定义的React钩子释放出的合成水平远远超过了我们以前见过的任何东西，但我们将为这篇文章构建一个基本的自定义React钩子。我们将抽象我们的逻辑，将数据存储在浏览器的本地存储中。我们还将把我们制作的这个定制钩子添加到我们的<a class="ae mv" href="https://www.wisdomgeek.com/development/web-development/react/react-hooks-and-local-storage-lets-build-a-todo-app/" rel="noopener ugc nofollow" target="_blank">本地存储和React钩子</a>示例中。</p><p id="4595" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将把一个键作为钩子的输入，这个键将作为在浏览器的本地存储器中存储值的键。我们还将为将要创建的变量获取一个默认值。钩子将向消费者返回一个变量，并向这个变量返回一个setter。每当这个变量改变时，钩子也将负责更新它在本地存储中的值。</p><p id="6787" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们的钩子有如下定义:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="47b3" class="nb ll in mx b gy nc nd l ne nf">export const useLocalStorage = (key, defaultValue) =&gt; {<br/>  // logic to be added<br/>  return [value, setValue]<br/>}</span></pre><p id="9995" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了返回React跟踪的变量，我们可以使用<a class="ae mv" href="https://www.wisdomgeek.com/development/web-development/react/react-hooks-and-local-storage-lets-build-a-todo-app/" rel="noopener ugc nofollow" target="_blank"> useState React钩子</a>。此外，由于我们在本地存储中总是以字符串的形式存储值，所以我们将使用JSON字符串来存储值，并在检索时解析它们。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="a5e7" class="nb ll in mx b gy nc nd l ne nf">export const useLocalStorage = (key, defaultValue) =&gt; {<br/>  const storedValue = JSON.parse(localStorage.getItem(key));<br/>  const [value, setValue] = useState(storedValue || defaultValue);<br/>  return [value, setValue]l<br/>}</span></pre><p id="6d7b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这负责返回一个将使用React state跟踪的变量。但是我们还需要在每次更新时更新本地存储中的变量值。我们将在自定义的React钩子中使用useEffect钩子来实现这一点。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="94e0" class="nb ll in mx b gy nc nd l ne nf">export const useLocalStorage = (key, defaultValue) =&gt; {<br/>  const storedValue = JSON.parse(localStorage.getItem(key));<br/>  const [value, setValue] = useState(storedValue || defaultValue);</span><span id="ab98" class="nb ll in mx b gy ng nd l ne nf">useEffect(() =&gt; {<br/>    localStorage.setItem(key, JSON.stringify(value));<br/>  }, [value, key]);</span><span id="1649" class="nb ll in mx b gy ng nd l ne nf">return [value, setValue]l<br/>}</span></pre><p id="90ec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这对于我们自己定制的React钩子来说已经足够了！每当值改变时，更新的值将反映在本地存储中。而且每当钩子被初始化的时候，如果它不存在，这个值就会被设置为默认值。为了完整起见，我们将把这个键添加到效果的依赖项中，即使它在钩子的生命周期中不会被更新。</p><h1 id="616f" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">在我们的应用程序中使用自定义的React钩子</h1><p id="9a09" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">现在，我们可以交换应用程序中的以下代码:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="772f" class="nb ll in mx b gy nc nd l ne nf">function App() {<br/>  const [items, setItems] = useState([]);<br/>  const removeItem = (itemToBeDeleted) =&gt; {<br/>    setItems(items.filter((item) =&gt; itemToBeDeleted !== item));<br/>  };</span><span id="9da6" class="nb ll in mx b gy ng nd l ne nf">useEffect(() =&gt; {<br/>    const items = JSON.parse(localStorage.getItem('items'));<br/>    if (items) {<br/>      setItems(items);<br/>    }<br/>  }, []);</span><span id="0527" class="nb ll in mx b gy ng nd l ne nf">useEffect(() =&gt; {<br/>    localStorage.setItem('items', JSON.stringify(items));<br/>  }, [items]);</span><span id="aa85" class="nb ll in mx b gy ng nd l ne nf">return (<br/>    &lt;div className="App"&gt;<br/>      &lt;header className="App-header"&gt;<br/>        To Do items<br/>        &lt;ItemList items={items} removeItem={removeItem} /&gt;<br/>        &lt;AddItemForm addItem={addItem} /&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="7f26" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="c539" class="nb ll in mx b gy nc nd l ne nf">function App() {<br/>  const [items, setItems] = useLocalStorage('items', []);<br/>  const removeItem = (itemToBeDeleted) =&gt; {<br/>    setItems(items.filter((item) =&gt; itemToBeDeleted !== item));<br/>  };</span><span id="e5ce" class="nb ll in mx b gy ng nd l ne nf">return (<br/>    &lt;div className="App"&gt;<br/>      &lt;header className="App-header"&gt;<br/>        To Do items<br/>        &lt;ItemList items={items} removeItem={removeItem} /&gt;<br/>        &lt;AddItemForm addItem={addItem} /&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="e693" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它应该还能像以前一样工作。但是现在我们有了在自定义React钩子中抽象的本地存储逻辑。我们可以在希望保存到本地存储的任何地方跨多个组件使用这个钩子。</p><p id="5a6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">需要注意的是，自定义钩子是独立的。如果在两个组件中使用同一个钩子，它们将不会共享状态。因此，我们有一段真正可重用的代码，可以跨多个组件使用。</p><p id="34fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">希望你在读完这篇文章后对React中的自定义钩子有更好的理解。现在开始创建你自己的吧。天空是无限的！请在下面留下你的评论，分享你打算创造什么样的钩子。</p><p id="916b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nh">原载于2021年1月12日</em><a class="ae mv" href="https://www.wisdomgeek.com/development/web-development/react/how-to-write-your-own-custom-react-hooks/" rel="noopener ugc nofollow" target="_blank"><em class="nh">【https://www.wisdomgeek.com】</em></a><em class="nh">。</em></p></div></div>    
</body>
</html>