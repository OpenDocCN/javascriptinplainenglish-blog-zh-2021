<html>
<head>
<title>React Native — Infinite Scroll Pagination with FlatList</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native —使用FlatList进行无限滚动分页</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-infinite-scroll-pagination-with-flatlist-e5fe5db6c1cb?source=collection_archive---------0-----------------------#2021-11-07">https://javascript.plainenglish.io/react-native-infinite-scroll-pagination-with-flatlist-e5fe5db6c1cb?source=collection_archive---------0-----------------------#2021-11-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/47f4bf9766c179aed647c0739a18457d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HTf5WQASbiyvo54WeXiSg.jpeg"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="7461" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">分页是一个重要的概念，它可以帮助开发人员加载大量的数据，而不是一次性加载。对于web开发，开发人员通常使用基于页面索引的方法，但是对于移动开发，我们通常使用无限滚动方法。</p><p id="4c81" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">作为一名Android开发人员，我们知道用RecyclerView建立一个列表并实现一个分页库有多难。然而，使用React Native，我们可以轻松地用FlatList构建无限滚动分页！</p><h1 id="374f" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用案例— NewsAPI</h1><p id="7d58" class="pw-post-body-paragraph kc kd in ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ig bi translated">我用<a class="ae md" href="https://newsapi.org/" rel="noopener ugc nofollow" target="_blank">新闻API </a>构建了一个简单的用例，用<code class="fe me mf mg mh b">page</code> &amp; <code class="fe me mf mg mh b">pageSize</code>参数加载文章页面。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/27102613cdecc7f6db465b88bfb10f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHYo8sX_bnwkgz75AA10OA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Demo of Infinite Scroll Pagination on News App</figcaption></figure><p id="6fd1" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">只有<code class="fe me mf mg mh b">10</code>的文章被放在第一页。然后，当用户滚动到底部时，另一篇<code class="fe me mf mg mh b">10</code>文章将在第二页被取出，反之亦然。当它到达列表的末尾时，一个指示器将提示用户此时没有更多的文章可用。</p><h1 id="259d" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">给我看看代码！</h1><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/4f21b665f495d2fce9568ab77f3d4cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXm7_O0xYbevnrofWTgliA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">FlatList implementation</figcaption></figure><p id="f628" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">好吧，好吧，让我们把手弄脏。为了实现无限滚动，我们的FlatList中有<code class="fe me mf mg mh b">onEndReached</code> &amp; <code class="fe me mf mg mh b">onEndReachedThreshold</code>道具。<code class="fe me mf mg mh b">onEndReachedThreshold</code>用于确定距离底部多远才能触发<code class="fe me mf mg mh b">onEndReached</code>。阈值越小，离底部的距离越小，因此越向下滚动将触发<code class="fe me mf mg mh b">onEndReached</code>。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/48325b021d1b16920a3d72565b8b94c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEtNZ4st9NxUCWlmv-Tw4A.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">fetchMoreData()</figcaption></figure><p id="3c5d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">当<code class="fe me mf mg mh b">onEndReached</code>被触发时，将调用<code class="fe me mf mg mh b">fetchMoreData</code>以增加当前页码。同时，为了<strong class="ke io">防止API请求</strong>的重复，检查API是否已经到达其结尾或者当前正在加载更多数据。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/0981a9ae0e2c3d10b61a8bd6704135d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7HMmuBmmWRf2K3DaWr6bg.png"/></div></div></figure><p id="6037" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">当页码增加时，<code class="fe me mf mg mh b">useEffect</code> hook会检测并调用<code class="fe me mf mg mh b">requestAPI()</code>函数。</p><p id="60a7" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">但是，Redux reducer是如何处理所有这些状态并正确返回到UI中的呢？</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/86263889e7699bffffcb8cf70a8f1b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZ7PxuwiymVXqlwnSUhh-g.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Redux Reducers</figcaption></figure><p id="1893" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">有4种不同的状态，让我们一个一个来看。</p><ol class=""><li id="0ad0" class="mv mw in ke b kf kg kj kk kn mx kr my kv mz kz na nb nc nd bi translated"><code class="fe me mf mg mh b">API_REQUEST</code></li></ol><p id="1c9d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">当用户请求API时，有两种加载方式，初始加载和更多数据加载。因此，我们要做的是检查<code class="fe me mf mg mh b">page</code>并确定加载的是初始数据还是更多数据。</p><p id="350f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">2.<code class="fe me mf mg mh b">API_SUCCESS</code></p><p id="5f44" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">当用户从API响应中获得值时，我们通过使用数组扩展操作符<code class="fe me mf mg mh b">[...]</code>将它附加到<code class="fe me mf mg mh b">data</code>中，这样<code class="fe me mf mg mh b">data</code>将不断地被附加新数据。</p><p id="bd68" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">3.<code class="fe me mf mg mh b">API_FAILURE</code></p><p id="60dc" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">设置<code class="fe me mf mg mh b">error</code>状态及其错误信息，并显示在UI中。</p><p id="0c75" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">4.<code class="fe me mf mg mh b">API_LIST_END</code></p><p id="f3c7" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">将<code class="fe me mf mg mh b">isListEnd</code>状态设置为true，以指示FlatList在下一页上没有更多数据。<code class="fe me mf mg mh b">isListEnd</code>还有助于阻止任何进一步的API请求。</p><h1 id="c24d" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">让我们回到用户界面</h1><p id="cda9" class="pw-post-body-paragraph kc kd in ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ig bi translated">下面是与UI工作方式相关的代码片段。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/c4adc16027f6c99e80d7bb19fce804f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbWR8u-nBIEtfW2OQvpzzQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">UI for Initial Data Loading</figcaption></figure><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/93ebf8db8a14767d60cec0251d6b8239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWDS0xu20n-fTUL6gw4R8Q.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">UI for error/no internet connection</figcaption></figure><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/bd5e05ade4025481ce35a32633873854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*APv9WI60XkL8QUKFSZ9cSA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Bottom indicator for more data loading and no more data</figcaption></figure><p id="05c0" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">沃拉。我们已经完成了覆盖多个状态的FlatList的无限滚动分页。🌸</p><h1 id="f38d" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="b67c" class="pw-post-body-paragraph kc kd in ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ig bi translated">与命令式UI (Android)相比，声明式UI (React Native)可以在没有大量复杂代码的情况下做这些事情，这真的很酷(PS:我知道Jetpack Compose正在路上。稍后会试用)。然而，有一些<strong class="ke io">弱点</strong>需要修正和克服。</p><ol class=""><li id="fc81" class="mv mw in ke b kf kg kj kk kn mx kr my kv mz kz na nb nc nd bi translated">如何处理本地db值？在Android Paging3中，有一个<code class="fe me mf mg mh b">RemoteMediator</code>有助于方便来自远程和本地的数据，但我在RN中找不到。</li><li id="0182" class="mv mw in ke b kf nh kj ni kn nj kr nk kv nl kz na nb nc nd bi translated">在请求更多数据时，如果没有互联网连接，如何实现底部刷新指示器？我知道这可以通过控制Redux状态来实现，但我不确定这样做是否有效。</li></ol><p id="f472" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">无论如何，我认为分页是一个重要的概念，也许有更多的人关注这个领域。一起，我们将使社区变得更好！快乐的反应！✅</p><p id="a75d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">github:<a class="ae md" href="https://github.com/WenLonG12345/RNNewsPagination" rel="noopener ugc nofollow" target="_blank">https://github.com/WenLonG12345/RNNewsPagination</a></p><p id="0319" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><em class="nm">更多内容请看</em> <a class="ae md" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nm">说白了。报名参加我们的</em> <a class="ae md" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nm">免费周报</em> </strong> </a> <em class="nm">。在我们的</em> <a class="ae md" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nm">社区不和谐</em> </strong> </a> <em class="nm">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>