<html>
<head>
<title>The Fibonacci sequence in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿中的斐波那契数列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-fibonacci-sequence-in-typescript-4401bd3b9d1f?source=collection_archive---------6-----------------------#2021-03-15">https://javascript.plainenglish.io/the-fibonacci-sequence-in-typescript-4401bd3b9d1f?source=collection_archive---------6-----------------------#2021-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/015d2f6eedee6555cd92cceaf91c37ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vz336s-pmVyqyfly.jpg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image included so article has nice thumbnail 😄</figcaption></figure><p id="b40a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">用Javascript写斐波那契数列就是递归的“hello world”。你可能会在计算机科学入门课上第一次遇到它。它看起来像这样:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="2dd0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这篇文章中，我想展示的是如何在类型系统中编写斐波那契数列。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h1 id="1da4" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">积木</h1><p id="517a" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">在编写我们的算法之前，让我们先来研究一些最近和不久前添加到TypeScript类型系统中的特性。我们将把这些作为我们最终算法的基础。</p><h2 id="8b3d" class="mn ll in bd lm mo mp dn lq mq mr dp lu kk ms mt ly ko mu mv mc ks mw mx mg my bi translated">查找类型</h2><p id="b89b" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated"><em class="mz">在TS 2.1中引入</em></p><p id="9923" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了查找另一种类型的属性的结构类型，TypeScript引入了<em class="mz">索引访问类型</em>，也称为<strong class="kb io">查找类型</strong>。从语法上来说，它们看起来完全像一个元素访问，但是被写成类型:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h2 id="b014" class="mn ll in bd lm mo mp dn lq mq mr dp lu kk ms mt ly ko mu mv mc ks mw mx mg my bi translated">条件类型</h2><p id="25d3" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated"><em class="mz">在TS 2.8中引入</em></p><p id="97b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae na" href="https://github.com/Microsoft/TypeScript/pull/21316" rel="noopener ugc nofollow" target="_blank">https://github.com/Microsoft/TypeScript/pull/21316</a></p><blockquote class="nb nc nd"><p id="619e" class="jz ka mz kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated"><em class="in">条件类型根据表示为类型关系测试的条件选择两种可能类型之一:</em></p></blockquote><pre class="kx ky kz la gt nh ni nj nk aw nl bi"><span id="2a2c" class="mn ll in ni b gy nm nn l no np">T extends U ? X : Y</span></pre><p id="ca1d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面这句话的意思是:如果<code class="fe nq nr ns ni b">T</code>可以赋给<code class="fe nq nr ns ni b">U</code>，那么类型就是<code class="fe nq nr ns ni b">X</code>，否则类型就是<code class="fe nq nr ns ni b">Y</code>。条件类型的一些示例如下:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h2 id="fde1" class="mn ll in bd lm mo mp dn lq mq mr dp lu kk ms mt ly ko mu mv mc ks mw mx mg my bi translated">在条件类型中推断</h2><p id="6b2b" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated"><em class="mz">在TS 2.8中引入</em></p><p id="b2f7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae na" href="https://github.com/microsoft/TypeScript/pull/21496" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/TypeScript/pull/21496</a></p><blockquote class="nb nc nd"><p id="c0ce" class="jz ka mz kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated"><em class="in">条件类型也为我们提供了一种方法，使用infer关键字</em>从我们在true分支中比较的类型中进行推断</p></blockquote><p id="209f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，在条件类型的<code class="fe nq nr ns ni b">extends</code>子句中，我们可以使用<code class="fe nq nr ns ni b">infer</code>关键字来引入一个要被推断的类型变量。这些推断的类型变量以后可能会在条件类型的分支中被引用。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h2 id="0481" class="mn ll in bd lm mo mp dn lq mq mr dp lu kk ms mt ly ko mu mv mc ks mw mx mg my bi translated">可变元组类型</h2><p id="b9ed" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated"><em class="mz">在TS 4.0中引入</em></p><p id="615d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae na" href="https://github.com/microsoft/TypeScript/pull/39094" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/TypeScript/pull/39094</a></p><blockquote class="nb nc nd"><p id="fa5b" class="jz ka mz kb b kc kd ke kf kg kh ki kj ne kl km kn nf kp kq kr ng kt ku kv kw ig bi translated"><em class="in">元组类型具有扩展通用类型的能力，这些通用类型可以通过类型实例化用实际元素替换。</em></p></blockquote><p id="98fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">查看拉取请求，深入了解该特性。有很多东西需要解开，包括类型推断、数组文字的展开、索引/析构、rest参数和展开参数。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h2 id="7219" class="mn ll in bd lm mo mp dn lq mq mr dp lu kk ms mt ly ko mu mv mc ks mw mx mg my bi translated">递归条件类型</h2><p id="cf7b" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated"><em class="mz">在TS 4.1中引入</em></p><p id="1f22" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae na" href="https://github.com/microsoft/TypeScript/pull/40002" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/TypeScript/pull/40002</a></p><p id="7bf1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">TS 2.8中引入了条件类型，但限制为非递归(即条件类型不能引用自身)。这种限制是由于当时TS编译器中的一些限制而产生的。从那以后，有了许多改进，允许TypeScript团队移除这一限制，并发布了<strong class="kb io">递归条件类型，</strong>，但是递归深度限制为50(这已经足够了)。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="1d4c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">伴随着这个特性的<a class="ae na" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#recursive-conditional-types" rel="noopener ugc nofollow" target="_blank">发布公告</a>的是这个警告:</p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/5b14cf750c2096e8f6e9c0605f794ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hY0py2LqUdNqxPhMSQxfA.png"/></div></div></figure></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h1 id="a0fa" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">将这一切与斐波那契数列结合在一起</h1><p id="081c" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">现在我们已经得到了我们的背景(和我们的警告)，我们可以继续编写我们的算法。为了写出斐波那契数列，我们需要能够做<strong class="kb io">加法</strong>。不幸的是，类型系统不支持加法——至少以我们熟悉的方式。然而，类型系统支持添加(或连接)元组类型，这可以帮助我们实现添加。我们将处理<code class="fe nq nr ns ni b">true</code>的元组，但是元素实际上可以是任何东西。</p><p id="ae96" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了利用元组的加法，我们需要一种从整数到元组以及从元组到整数的映射方式。我们可以通过以下类型实现这一点:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d0fe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还需要一些其他的算术工具类型，比如加法和减法:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="78c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有了这个和我们从上面学到的一切，我们可以写出我们的斐波纳契公式:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="539b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如你所见，我们能够在TypeScript的类型系统<em class="mz">中单独编写斐波那契数列。</em>这只是一个例子，展示了TypeScript的强大功能和灵活性，以及TypeScript团队所做的出色工作。</p><p id="5074" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您想自己试验代码，可以在TypeScript playground中查看这个<a class="ae na" href="https://www.typescriptlang.org/play?ts=4.2.3#code/C4TwDgpgBAggTnAhiA8gMwMoEsBeEA8AclBAB7AQB2AJgM5SUCuAtgEYRwB8UAvFMWQo16xAPxQAFEzYcS5KnX5RxrAPaqANhESUA2gF0oALigB9eElSZcBQgBooBzgEpjDCADcOAbgCwAKFBIMwtkdGw8IjkhRWl2OAcAJWiFekZKAGtKVQB3PX1uPkTdAHItSgBzYAALEsNBVKVxZJNzBDDrSPtHYDhGCAcAOmHEgr9-AKDoAAUNRloARnwYFOEoHRAnXh6+gahhwZh9canYampl1cUNgwcAISv6G4Lt3QOYIeG748nwaABZLBMRaXBprZ6FWCPKBwbTUVSUDQgRwbUSfQZAtCyACqhnE2Lcb2GRxOfyggOBACZQfJwZRNi8+BT5ktmSCYJxOOMAgB6HlQLxwLBoZGMYBYDRYcUQeg5VRwDK-YIrPihKwRAgAZi5UD5O36Dl6BqgRog+gCSugDz4sxZyx1et0psNuxdxtN5sCZIAwts2UsOd5dfyna6TbtPacACJ+oHzamB4P6s0Wr3BUwAMSwrHwAEkACoAUUSMHzuZQAlpijUmm0+UhBeLpfLhFK5SqtXqVfoCygAB8oAAGAJQZRQRslssVkduGDnfCZ7P4f15ouTluchyLnNs6kT5sVzlcy1QLM5ysxehxDiQ7fLdrqmxETltqgdurctPQDO9vhn-ALA6-ILCeGaUts-6UkBUAgV+p6ahBS7akGeqUqBAAsiE5uh0GaqBACsWH4Ph0H4aBABsRHkdBAAcoEAOxEfR0ELHhcEZjRRE0dBlKwacGYAJxEQJuHoaBlKDkREnQeR9HkWR7GapJf5IYO0GFgg8oBEAA" rel="noopener ugc nofollow" target="_blank">链接。</a></p></div></div>    
</body>
</html>