<html>
<head>
<title>TypeScript Generics: What’s with the Angle Brackets &lt;&gt;?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript泛型:尖括号&lt;&gt;是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-generics-whats-with-the-angle-brackets-4e242c567269?source=collection_archive---------0-----------------------#2021-10-18">https://javascript.plainenglish.io/typescript-generics-whats-with-the-angle-brackets-4e242c567269?source=collection_archive---------0-----------------------#2021-10-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dfe0" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">一个好的可重用组件在软件工程中有很高的声望。好的抽象很难提出来。他们甚至更难通过满足不断上升的边缘情况来维持生存。但是经过充分测试的设计模式可以提供帮助。泛型就是其中之一。</p><blockquote class="km kn ko"><p id="424a" class="jo jp kp jq b jr js jt ju jv jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kl ig bi translated">泛型编程是计算机编程的一种形式，其中算法是根据稍后指定的<strong class="jq io">类型</strong><strong class="jq io"/>编写的，然后在需要时为作为参数提供的特定类型进行实例化。—维基百科。</p></blockquote><p id="ce20" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">JavaScript社区慢慢接受了TypeScript，因为它在大型项目中提供了<a class="ae kt" href="https://karthickragavendran.medium.com/typescript-why-866281eaebf8" rel="noopener">的好处。</a></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/8ae8a1989e32dbd3c9cd6321abd1862a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crdnFKXowgNqYBuXkO0l7Q.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">TypeScript generics</figcaption></figure><h2 id="9d0a" class="lk ll in bd lm ln lo dn lp lq lr dp ls jz lt lu lv kd lw lx ly kh lz ma mb mc bi translated">句法</h2><pre class="kv kw kx ky gt md jn me mf aw mg bi"><span id="0fc4" class="lk ll in jn b gy mh mi l mj mk">const func = &lt;T&gt;(arg: T) =&gt; arg</span></pre><p id="4711" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">申报时<code class="fe jk jl jm jn b">func</code>的类型为<code class="fe jk jl jm jn b">&lt;T&gt;(arg: T) =&gt; T</code></p><p id="7167" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">这不是一个非常有用的函数，它只是返回我们发送的任何内容。但是让我们从这里开始，看看如何使用泛型。</p><p id="c2b5" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我们可以像下面这样执行<code class="fe jk jl jm jn b">func</code>。</p><pre class="kv kw kx ky gt md jn me mf aw mg bi"><span id="4f1e" class="lk ll in jn b gy mh mi l mj mk">func&lt;number&gt;(12)</span></pre><p id="57db" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">注意我们在上面的函数调用<strong class="jq io">中传递了<strong class="jq io">两个不同的参数</strong>。</strong>一个在括号内<code class="fe jk jl jm jn b">()</code>另一个在尖括号内<code class="fe jk jl jm jn b">&lt; &gt;</code></p><p id="dfcc" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我们知道在函数调用<code class="fe jk jl jm jn b">func(12)</code>中，圆括号内的参数<code class="fe jk jl jm jn b">12</code>代表<code class="fe jk jl jm jn b">arg</code>参数。</p><p id="afda" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">类似地，在<code class="fe jk jl jm jn b">func&lt;number&gt;(12)</code>中，尖括号内的参数<code class="fe jk jl jm jn b">number</code>表示泛型类型参数<code class="fe jk jl jm jn b">T</code>。</p><h2 id="9929" class="lk ll in bd lm ln lo dn lp lq lr dp ls jz lt lu lv kd lw lx ly kh lz ma mb mc bi translated">让我们推理一下语法</h2><p id="18c9" class="pw-post-body-paragraph jo jp in jq b jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh mp kj kk kl ig bi translated">如果你要为TypeScript中的泛型设计一个语法，你会怎么做？</p><pre class="kv kw kx ky gt md jn me mf aw mg bi"><span id="1749" class="lk ll in jn b gy mh mi l mj mk">Requirement: Find a way to pass <strong class="jn io">type arguments</strong> along with the normal arguments.</span></pre><p id="ce2c" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">如果我们在JavaScript中执行<code class="fe jk jl jm jn b"> func(number)(12)</code>，就会执行<code class="fe jk jl jm jn b">func</code>函数两次。所以我们必须有别的东西，这样我们可以让我们的TypeScript编译器将<code class="fe jk jl jm jn b">number</code>理解为一个类型参数，它不会干扰现有的JavaScript语法。</p><p id="a876" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">你会读到其他语言中的泛型设计模式，比如Java和C#。他们使用<code class="fe jk jl jm jn b">&lt; &gt;</code>来传递类型参数。所以你决定用同样的。</p><p id="ada6" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我们最终会得到，</p><pre class="kv kw kx ky gt md jn me mf aw mg bi"><span id="fbd3" class="lk ll in jn b gy mh mi l mj mk">func&lt;number&gt;(12)</span></pre><blockquote class="mq"><p id="2959" class="mr ms in bd mt mu mv mw mx my mz kl dk translated">不要让<code class="fe jk jl jm jn b">&lt; &gt;</code>吓倒你。这只是一种将类型作为参数传递的方式。</p></blockquote><h2 id="8c5b" class="lk ll in bd lm ln na dn lp lq nb dp ls jz nc lu lv kd nd lx ly kh ne ma mb mc bi translated">泛型的实际应用</h2><p id="845b" class="pw-post-body-paragraph jo jp in jq b jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh mp kj kk kl ig bi translated">假设您的项目中有以下类型。</p><pre class="kv kw kx ky gt md jn me mf aw mg bi"><span id="5322" class="lk ll in jn b gy mh mi l mj mk">export type AsyncGame = {<br/>  item: Game<br/>  fulfilled?: boolean<br/>  loading?: boolean<br/>  error?: boolean<br/>}</span><span id="df3a" class="lk ll in jn b gy nf mi l mj mk">export type AsyncGames = {<br/>  items: Game[]<br/>  fulfilled?: boolean<br/>  loading?: boolean<br/>  error?: boolean<br/>}</span><span id="d6e0" class="lk ll in jn b gy nf mi l mj mk">export type AsyncUserGame = {<br/>  item: UserGame<br/>  fulfilled?: boolean<br/>  loading?: boolean<br/>  error?: boolean<br/>}</span><span id="fdd1" class="lk ll in jn b gy nf mi l mj mk">export type AsyncUserGames = {<br/>  items: UserGame[]<br/>  fulfilled?: boolean<br/>  loading?: boolean<br/>  error?: boolean<br/>}</span><span id="d160" class="lk ll in jn b gy nf mi l mj mk">// Game and UserGame are types we expect from different API <br/>// responses.</span></pre><p id="7274" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">这是非常多余的。他们在行为上有许多共同之处。</p><ul class=""><li id="4f53" class="ng nh in jq b jr js jv jw jz ni kd nj kh nk kl nl nm nn no bi translated"><strong class="jq io">易错:</strong>查看网络状态<code class="fe jk jl jm jn b">fulfilled</code>、<code class="fe jk jl jm jn b">loading</code>、<code class="fe jk jl jm jn b">error</code>在所有类型中都是可选的。如果我们决定改变某些行为，我们必须更新上面的每个类型。我们可能会错过更新的东西。</li><li id="16de" class="ng nh in jq b jr np jv nq jz nr kd ns kh nt kl nl nm nn no bi translated"><strong class="jq io">可伸缩性:</strong>如果我们想引入一种新的类型<code class="fe jk jl jm jn b">AsyncBrowseGames</code>，将<code class="fe jk jl jm jn b">BrowseGames</code>类型与网络状态包装在一起，我们将不得不在代码库中创建更多冗余代码。这将导致更多容易出错的地方。</li></ul><h2 id="72b2" class="lk ll in bd lm ln lo dn lp lq lr dp ls jz lt lu lv kd lw lx ly kh lz ma mb mc bi translated">拯救仿制药</h2><p id="48e0" class="pw-post-body-paragraph jo jp in jq b jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh mp kj kk kl ig bi translated">让我们创建一个通用类型，如下所示:</p><pre class="kv kw kx ky gt md jn me mf aw mg bi"><span id="5fcd" class="lk ll in jn b gy mh mi l mj mk">type AsyncData&lt;<strong class="jn io">T</strong>&gt; = {<br/>  data: <strong class="jn io">T</strong><br/>  fulfilled?: boolean<br/>  loading?: boolean<br/>  error?: boolean<br/>}</span></pre><p id="f600" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">它接收一个泛型类型参数<code class="fe jk jl jm jn b">T</code>，并将其分配给它的一个属性，名为<code class="fe jk jl jm jn b">data</code>。</p><p id="8bd4" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">现在，我们可以创建许多类型来包装其他类型以及网络状态。</p><pre class="kv kw kx ky gt md jn me mf aw mg bi"><span id="6e3a" class="lk ll in jn b gy mh mi l mj mk">type AsyncGames = AsyncData&lt;<strong class="jn io">Game[]</strong>&gt;<br/>type AsyncGame = AsyncData&lt;<strong class="jn io">Game | null</strong>&gt;<br/>type AsyncUser = AsyncData&lt;<strong class="jn io">User | null</strong>&gt;<br/>type AsyncUserGames = AsyncData&lt;<strong class="jn io">UserGame[]</strong>&gt;<br/>type AsyncBrowseGames = AsyncData&lt;<strong class="jn io">BrowseGame[]</strong>&gt;</span></pre><p id="3073" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">看看当我们将鼠标悬停在其中一种类型上时，VSCode向我们显示了什么？</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nu"><img src="../Images/8f6e0bcc5369ca144a5872c3f52b1b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gIcYa-_l4YTEQQGH719Nw.png"/></div></div></figure><p id="e50c" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">多酷啊。</p><p id="231a" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">我们用很少的代码生成了很多派生类型。我们还确保了这些派生类型之间行为的一致性。</p><p id="fe0f" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">这就是TypeScript中泛型的全部内容。谢谢你。下次见。</p><p id="6cb4" class="pw-post-body-paragraph jo jp in jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><em class="kp">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jq io"><em class="kp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>