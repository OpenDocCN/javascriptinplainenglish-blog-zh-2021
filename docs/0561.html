<html>
<head>
<title>Mastering TypeScript for React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握React挂钩的类型脚本</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mastering-typescript-for-react-hooks-3e9e9e3797d7?source=collection_archive---------3-----------------------#2021-02-03">https://javascript.plainenglish.io/mastering-typescript-for-react-hooks-3e9e9e3797d7?source=collection_archive---------3-----------------------#2021-02-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a108" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，您希望在React应用程序中使用TypeScript，但即使是钩子也让您感到苦恼。好吧，让我们让你熟悉如何使用这些钩子来使用TypeScript打字，并带你上路。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8116705f0b024884bd95f29a09494d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BEPuAzdDn1WqkM1P-sgew.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Banner image</figcaption></figure><p id="315c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章旨在补充优秀的<a class="ae ky" href="https://github.com/typescript-cheatsheets/react" rel="noopener ugc nofollow" target="_blank"> React打字稿备忘单</a>，你一定要看一看。</p><h1 id="e7f2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用状态</h1><p id="b838" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">useState是一个有趣的工具，因为我们一直在使用它，而且大部分时间它都很好，直到它变得不好。举个例子:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="02ac" class="mh la in md b gy mi mj l mk ml">const [myNumber, myNumberSet] = useState(10);</span><span id="b745" class="mh la in md b gy mm mj l mk ml">const onClick = () =&gt; myNumberSet(20);</span></pre><p id="00a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript对此完全没有问题，因为在<code class="fe mn mo mp md b">useState</code>上的键入会查看初始值，看到它是一个数字，并将此类型设置为:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="4527" class="mh la in md b gy mi mj l mk ml">const [myNumber, myNumberSet] = useState&lt;number&gt;(10);</span></pre><p id="d16d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以任何数字都可以。</p><p id="c10b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你遇到这样的情况时，问题就来了:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="618e" class="mh la in md b gy mi mj l mk ml">const [myAccount, myAccountSet] = useState(null);</span><span id="66fd" class="mh la in md b gy mm mj l mk ml">const onAuthResponse = () =&gt; myAccountSet({ user: "foo", ... });</span></pre><p id="fc17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript不知道您最初设置为<code class="fe mn mo mp md b">null</code>的内容可能是一个帐户记录。所以你需要做的就是告诉它:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="d9b0" class="mh la in md b gy mi mj l mk ml">interface IAccount {<br/>  user: string;<br/>  ...<br/>}<br/>const [myAccount, myAccountSet] = useState&lt;IAccount | null&gt;(null);</span><span id="6618" class="mh la in md b gy mm mj l mk ml">const onAuthResponse = () =&gt; myAccountSet({ user: "foo", ... });</span></pre><p id="9175" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，TypeScript知道您的<code class="fe mn mo mp md b">myAccount</code>值可以是null，也可以是一个匹配<code class="fe mn mo mp md b">IAccount</code>类型的对象。</p><p id="5ac9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数组也有类似的问题。举个例子:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="94ff" class="mh la in md b gy mi mj l mk ml">const [myNumbers, myNumbersSet] = useState([]);</span><span id="f845" class="mh la in md b gy mm mj l mk ml">const onClick = () =&gt; myNumbersSet([10, 20, 30]);</span></pre><p id="6032" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript将会给出一个非常奇怪的错误，当需要一个<code class="fe mn mo mp md b">never[]</code>时，却试图使用一个<code class="fe mn mo mp md b">number[]</code>。这实际上是有意义的，因为据TypeScript所知，唯一的有效值是一个空数组(即<code class="fe mn mo mp md b">never[]</code>)。它不知道你打算在那里储存数字。</p><p id="eae4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以解决这个问题的方法是键入它</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="70ea" class="mh la in md b gy mi mj l mk ml">const [myNumbers, myNumbersSet] = useState&lt;number[]&gt;([]);</span><span id="85fb" class="mh la in md b gy mm mj l mk ml">const onClick = () =&gt; myNumbersSet([10, 20, 30]);</span></pre><p id="2c72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在TypeScript又高兴了，因为即使是空数组也是<code class="fe mn mo mp md b">number[]</code>的有效类型。</p><h1 id="cc6c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用效果</h1><p id="aa25" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">useEffect的优点是它不接受任何类型。所以，如果你想确保你输入正确，不用担心，你会的。</p><p id="43d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想自己检查一下，那么在你的VS代码中右击单词<code class="fe mn mo mp md b">useEffect</code>并使用<code class="fe mn mo mp md b">Go to Type Definition</code>命令转到React源代码中定义<code class="fe mn mo mp md b">useEffect</code>的地方。</p><p id="8b3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mn mo mp md b">useEffect</code>有两个参数，第一个是没有参数的函数，要么返回void，要么返回另一个函数(cleanup函数)，后者没有参数，返回void。</p><p id="cf19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">依我看，无论何时你在TypeScript中遇到问题，使用<code class="fe mn mo mp md b">Go to Type Definition</code>应该是你的第一站。</p><h1 id="f66b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用上下文</h1><p id="e74d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">正确输入<code class="fe mn mo mp md b">useContext</code>实际上就是正确输入<code class="fe mn mo mp md b">createContext</code>调用。例如，您可能会看到这样的内容:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="4faa" class="mh la in md b gy mi mj l mk ml">const MyContext = createContext(null);</span></pre><p id="7d50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这基本上让TypeScript对上下文中潜在的内容一无所知，所以它就这样了；上下文必须始终包含null。这可能不是你想要的。</p><p id="e78d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想要<code class="fe mn mo mp md b">null</code>或者一些数据，最简单的方法就是这样定义它:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="a627" class="mh la in md b gy mi mj l mk ml">interface IMyContextState {<br/>  userID: string;<br/>}<br/>const MyContext = createContext&lt;IMyContextState | null&gt;(null);</span></pre><p id="192c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它告诉TypeScript上下文必须包含一个匹配<code class="fe mn mo mp md b">IMyContextState</code>或<code class="fe mn mo mp md b">null</code>的对象。</p><p id="8d28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你有一个默认状态，那就简单多了:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="e076" class="mh la in md b gy mi mj l mk ml">const myDefaultState = {<br/>  userID: "";<br/>}</span><span id="1a9d" class="mh la in md b gy mm mj l mk ml">export type MyContextType = typeof myDefaultState;</span><span id="028a" class="mh la in md b gy mm mj l mk ml">const MyContext = createContext(myDefaultState);</span><span id="f771" class="mh la in md b gy mm mj l mk ml">export default MyContext;</span></pre><p id="4e72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们不需要告诉TypeScript上下文已经知道了<code class="fe mn mo mp md b">myDefaultState</code>中的类型，但是我们现在将默认状态的模式导出为<code class="fe mn mo mp md b">MyContextType</code>。这样我们就可以像这样调用<code class="fe mn mo mp md b">useContext</code>时使用它:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="733e" class="mh la in md b gy mi mj l mk ml">import MyContext, { MyContextType } from './store';<br/>...<br/>const ctx:MyContextType = useContext(MyContext);</span></pre><p id="68cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，<code class="fe mn mo mp md b">ctx</code>的输入有点矫枉过正，因为<code class="fe mn mo mp md b">useContext</code>已经知道了来自<code class="fe mn mo mp md b">MyContext</code>的类型，您可以这样做:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="bcb1" class="mh la in md b gy mi mj l mk ml">import MyContext from './store';<br/>...<br/>const ctx = useContext(MyContext);</span></pre><h1 id="ba01" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">用户教育</h1><p id="8f7b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">键入<code class="fe mn mo mp md b">useReducer</code>很像键入Redux，所以这是一个两全之策，如果你做对了，你就离Redux键入更近了。所以<code class="fe mn mo mp md b">useReducer</code>取两个东西，减速器和初态。让我们从初始状态开始:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="2903" class="mh la in md b gy mi mj l mk ml">const initialState = {<br/>  counter: 0,<br/>};</span></pre><p id="5a95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来我们需要一些行动。现在，在Javascript中，我们根本不会键入这些内容，但在TypeScript中，我们可以也应该键入它们，看起来就像这样:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="0746" class="mh la in md b gy mi mj l mk ml">type ACTIONTYPES =<br/>  | { type: "increment"; payload: number; }<br/>  | { type: "decrement"; payload: number; };</span></pre><p id="9876" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后减速器看起来会像这样:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="f18b" class="mh la in md b gy mi mj l mk ml">function myReducer(state: typeof initialState, action: ACTIONTYPES) {<br/>  ...<br/>}</span><span id="5738" class="mh la in md b gy mm mj l mk ml">const [state, dispatch] = useReducer(myReducer, initialState);</span></pre><p id="f767" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将在<code class="fe mn mo mp md b">state</code>上给你提示，并确保任何调度呼叫都需要匹配<code class="fe mn mo mp md b">ACTIONTYPES</code>中的一个变量。</p><h1 id="327d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">useRef</h1><p id="4f6f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">键入<code class="fe mn mo mp md b">useRef</code>，特别是在使用带有DOM元素的refs时，这是一个非常常见的用例，非常简单。假设你有这样的东西:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="a5ce" class="mh la in md b gy mi mj l mk ml">return (&lt;input ref={inputRef} /&gt;);</span></pre><p id="3e20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在您的代码中，相应的<code class="fe mn mo mp md b">useRef</code>将如下所示:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="51c7" class="mh la in md b gy mi mj l mk ml">const inputRef = useRef&lt;HTMLInputElement | null&gt;(null);</span></pre><p id="b7b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里指定类型也不是100%必要的。唯一的技巧是确保获得相应DOM元素的正确类型。</p><p id="2275" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你要用一个引用来保存数据，你可以这样做:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="614e" class="mh la in md b gy mi mj l mk ml">const intervalRef = useRef&lt;number | null&gt;(null);</span></pre><p id="466f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你持有一个区间的引用。</p><h1 id="572e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用备忘录</h1><p id="a4e9" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><code class="fe mn mo mp md b">useMemo</code>上的输入都是关于你放入的工厂函数所产生的内容。例如:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="d2ab" class="mh la in md b gy mi mj l mk ml">const [numbers] = useState([1,2,3,4]);<br/>const filteredNums = useMemo(<br/>  () =&gt; numbers.filter(n =&gt; n &gt; 2),<br/>  [numbers]<br/>);</span></pre><p id="422d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，由于工厂函数的输出，TypeScript将<code class="fe mn mo mp md b">filteredNums</code>上的类型推断为<code class="fe mn mo mp md b">number[]</code>。如果您想键入它，您可以:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="0f82" class="mh la in md b gy mi mj l mk ml">const filteredNums: number[] = useMemo(<br/>  () =&gt; numbers.filter(n =&gt; n &gt; 2),<br/>  [numbers]<br/>);</span></pre><p id="9a13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是你真的不需要。TypeScript非常非常擅长计算函数的返回类型。事实上，如果你愿意的话，你可以使用<code class="fe mn mo mp md b">ReturnType</code>实用程序类型从一个函数中获取返回类型，如下所示:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="e002" class="mh la in md b gy mi mj l mk ml">type MyFunctionReturnType = ReturnType&lt;typeof myFunction&gt;;</span></pre><p id="27eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在TypeScript语言网站上找到更多关于<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">惊人的实用程序类型的信息。</a></p><h1 id="baff" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">视频版本</h1><p id="b2ea" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">如果你想深入了解这些信息，请查看相关的YouTube视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Mastering React Hooks with TypeScript YouTube video</figcaption></figure><h1 id="93d2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="5504" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我使用TypeScript和React的次数越多，我就越确信它是值得投资的。您可以在编码时获得提示的好处。你通过这些类型来传达你的意图。并且您可以在编译时获得类型安全检查的好处。</p><p id="e9ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这篇文章能够帮助您在React项目中尝试使用TypeScript，并学习掌握React钩子的类型时实现这些好处。</p></div></div>    
</body>
</html>