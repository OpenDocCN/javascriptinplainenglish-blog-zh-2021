<html>
<head>
<title>Learn Generics with TypeScript: A Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript学习泛型:初学者指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learn-generics-with-typescript-a-beginners-guide-6d1eba83ce8b?source=collection_archive---------10-----------------------#2021-10-08">https://javascript.plainenglish.io/learn-generics-with-typescript-a-beginners-guide-6d1eba83ce8b?source=collection_archive---------10-----------------------#2021-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0f2a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">不要忽视他们！不要觉得他们对你来说太高级了！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8e354744556ae4b74b519b6f924da516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWjxtPjFqriDYXb6_xW_tw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image courtesy of me :)</figcaption></figure><h1 id="e385" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">回到基础</h1><p id="3c2f" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我认为我关于简洁的泛型类型脚本函数的指南会受到软件世界的喜爱。像我的<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/react-and-typescript-generic-search-sort-and-filter-879c5c3e2f0e">泛型搜索、排序和过滤</a>，或者我的<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/advanced-typescript-a-generic-function-to-merge-object-arrays-cb0bd9a5c382">泛型函数合并对象数组</a>，或者我的<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/advanced-typescript-a-generic-function-to-update-and-manipulate-object-arrays-caacd601cedf">泛型函数更新和操作对象数组</a>，都是在TypeScript中，都是泛型的，而且(我以为！)都超级酷。</p><p id="4b71" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">但是……也许我需要给初学者一个循序渐进的教程来真正理解类型脚本泛型的概念。然后就会对这些超级干净的函数式打字稿技术产生更多的兴趣！这是我试图(第四次)说服你！</p><h1 id="77bb" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">为什么使用泛型？</h1><p id="d395" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">当在React中编写前端ui时，我们经常听到设计可重用的组件很重要，无论是通过保持组件较小还是以一种良好的方式组合它们，或者，例如，使用props来提取可以针对任何用例进行修改的任何部分。</p><p id="599b" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">但对于我们代码库中的非组件代码来说也是如此:像我们在React组件旁边或外部构建的<em class="mm">函数</em>和<em class="mm">类</em>。如果您曾经构建过大型应用程序，那么您经常会在应用程序的多个页面、多个区域中使用类似的功能(例如，排序，我们很快就会看到)，最重要的是，针对各种不同的数据类型。在这篇文章中，我将强调泛型如何帮助我们解决这些有价值的功能在应用中的可重用性问题。</p><h1 id="9df0" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">界面工具栏</h1><p id="2ebd" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我将从定义一个简单的接口<code class="fe mn mo mp mq b"><strong class="lm io">IFooBar</strong></code>开始:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="6c3a" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">interface</em> IFooBar {</strong></span><span id="ea92" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">foo: string;</strong></span><span id="3464" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">bar: string;</strong></span><span id="373a" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span></pre><p id="cd97" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">这个基本接口只有两个属性，<code class="fe mn mo mp mq b"><strong class="lm io">foo</strong></code>和<code class="fe mn mo mp mq b"><strong class="lm io">bar</strong></code>，都是类型<code class="fe mn mo mp mq b"><strong class="lm io">string</strong></code>。</p><p id="6b82" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">为了获得与此类型相关的一些具体数据，我将定义一个<code class="fe mn mo mp mq b"><strong class="lm io">const fooBars</strong></code>，它将是<code class="fe mn mo mp mq b"><strong class="lm io">IFooBar</strong></code>的一个<code class="fe mn mo mp mq b"><strong class="lm io">Array</strong></code>:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="78f4" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">const</em> fooBars: Array&lt;IFooBar&gt; = [</strong></span><span id="e570" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">{</strong></span><span id="0c39" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">foo: "foo1",</strong></span><span id="0923" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">bar: "bar1"</strong></span><span id="76fd" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">},</strong></span><span id="8ae4" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">{</strong></span><span id="d468" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">foo: "i am foo two",</strong></span><span id="a8fd" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">bar: "i am bar two"</strong></span><span id="77dc" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">},</strong></span><span id="bff6" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">{</strong></span><span id="9c13" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">foo: "foo three",</strong></span><span id="2ac6" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">bar: "bar three"</strong></span><span id="b462" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span><span id="de2d" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">]</strong></span></pre><p id="74ee" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">让我们想象一下，在我们应用程序的某个地方，由于某种原因，我们想要像这样对数据类型进行排序。我们可以想象我们从一个API端点接收到一个数组<code class="fe mn mo mp mq b"><strong class="lm io">IFooBar</strong></code>。我们可以编写一个<code class="fe mn mo mp mq b"><strong class="lm io">sortByFoo</strong></code>函数来完成这个任务:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="6b45" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">function</em> sortByFoo(fooBars: Array&lt;IFooBar&gt;) {</strong></span><span id="8014" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">fooBars.sort((a, b) =&gt; {</strong></span><span id="0ddb" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">if</em> (a.foo &gt; b.foo) {</strong></span><span id="26d2" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> 1;</strong></span><span id="b80d" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span><span id="16dc" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">if</em> (a.foo &lt; b.foo) {</strong></span><span id="0bfe" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> -1;</strong></span><span id="9e9d" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span><span id="bb1e" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> 0;</strong></span><span id="8b57" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">})</strong></span><span id="7d74" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span></pre><p id="0246" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">如果我们想按另一个属性<code class="fe mn mo mp mq b"><strong class="lm io">bar</strong></code>排序，就会遵循相同的逻辑，创建一个函数<code class="fe mn mo mp mq b"><strong class="lm io">sortByBar</strong></code>:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="bf46" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">function</em> sortByBar(fooBars: Array&lt;IFooBar&gt;) {</strong></span><span id="0790" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">fooBars.sort((a, b) =&gt; {</strong></span><span id="e7c2" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">if</em> (a.bar &gt; b.bar) {</strong></span><span id="fb9f" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> 1;</strong></span><span id="6c20" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span><span id="1006" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">if</em> (a.bar &lt; b.bar) {</strong></span><span id="b72a" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> -1;</strong></span><span id="7cd2" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span><span id="577e" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> 0;</strong></span><span id="8d8b" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">})</strong></span><span id="ba6a" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span></pre><p id="76e0" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">这些解决方案对于只有属性<code class="fe mn mo mp mq b"><strong class="lm io">foo</strong></code>和<code class="fe mn mo mp mq b"><strong class="lm io">bar</strong></code>的数据非常有效，但是很容易想象出更复杂的具有几十个属性的类型。很明显，我们不能把所有的时间都花在为所有的属性编写显式排序函数上！😄这是有问题的，原因有二:</p><ol class=""><li id="470e" class="nb nc in lm b ln mh lq mi lt nd lx ne mb nf mf ng nh ni nj bi translated">这要花很多时间</li><li id="1b1c" class="nb nc in lm b ln nk lq nl lt nm lx nn mb no mf ng nh ni nj bi translated">它会引入大量重复的代码来完成几乎相同的任务(排序)</li></ol><h1 id="54bc" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">输入泛型</h1><p id="548d" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">这是TypeScript通用功能的一个完美用例。我们可以创建一个通用函数<code class="fe mn mo mp mq b"><strong class="lm io">sortByKey</strong></code>,它将能够替换<code class="fe mn mo mp mq b"><strong class="lm io">sortByFoo</strong></code>和<code class="fe mn mo mp mq b"><strong class="lm io">sortByBar</strong></code>,并且以后还可以很容易地扩展，例如，如果添加了一个额外的属性<code class="fe mn mo mp mq b"><strong class="lm io">hello</strong></code><code class="fe mn mo mp mq b"><strong class="lm io">IFooBar</strong></code>:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="4a07" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">interface</em> IFooBar {</strong></span><span id="8cdf" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">foo: string;</strong></span><span id="4715" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">bar: string;</strong></span><span id="ae1a" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">hello: string;</strong></span><span id="cf8d" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span></pre><p id="b8ef" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">让我们看看如何编写这个通用函数！</p><h1 id="85de" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">入门:您的第一个通用函数</h1><p id="c86e" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">为了表示类型脚本代码中使用了泛型，使用了尖括号(即<code class="fe mn mo mp mq b"><strong class="lm io">&lt;</strong></code>和<code class="fe mn mo mp mq b"><strong class="lm io">&gt;</strong></code>)语法。泛型的一个常见模式是以大写字母<code class="fe mn mo mp mq b"><strong class="lm io">T</strong></code>开始，表示需要提供的泛型“类型”。因此，为了开始我们的排序函数，我们将在函数名后面添加一个<code class="fe mn mo mp mq b"><strong class="lm io">&lt;T&gt;</strong></code>:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="92dc" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">function</em> sortByKey&lt;T&gt;() {</strong></span><span id="3586" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span></pre><blockquote class="np nq nr"><p id="b478" class="lk ll mm lm b ln mh jo lp lq mi jr ls ns mj lv lw nt mk lz ma nu ml md me mf ig bi translated">*注意:在需要多个泛型类型的情况下，最常见的模式是继续使用大写字母<code class="fe mn mo mp mq b"><strong class="lm io">U</strong></code>、<code class="fe mn mo mp mq b"><strong class="lm io">V</strong></code>等等，用逗号分隔。例如，如果我们需要三种通用类型的<code class="fe mn mo mp mq b"><strong class="lm io">sortByKey</strong></code>，函数签名应该是这样的:<code class="fe mn mo mp mq b"><strong class="lm io">sortByKey&lt;T, U, V&gt;</strong></code>。例如，在React中创建类组件时会出现这种情况。您可能已经注意到react组件的类型如下:<code class="fe mn mo mp mq b"><strong class="lm io">class React.Component&lt;P = {}, S = {}, SS = any&gt;</strong></code>在本例中，<code class="fe mn mo mp mq b"><strong class="lm io">P</strong></code>用于表示<code class="fe mn mo mp mq b"><strong class="lm io">props</strong></code>类型，<code class="fe mn mo mp mq b"><strong class="lm io">S</strong></code>表示<code class="fe mn mo mp mq b"><strong class="lm io">state</strong></code>，而<code class="fe mn mo mp mq b"><strong class="lm io">SS</strong></code>很少使用，表示<code class="fe mn mo mp mq b"><strong class="lm io">snapshot</strong></code>类型。</p></blockquote><p id="2c5e" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">按照我们编写<code class="fe mn mo mp mq b"><strong class="lm io">sortByFoo</strong></code>和<code class="fe mn mo mp mq b"><strong class="lm io">sortByBar</strong></code>的方式，我们需要给我们的函数添加参数。而在<code class="fe mn mo mp mq b"><strong class="lm io">sortByFoo</strong></code>和<code class="fe mn mo mp mq b"><strong class="lm io">sortByBar</strong></code>的情况下，我们明确地提供了<code class="fe mn mo mp mq b"><strong class="lm io">Array&lt;IFooBar&gt;</strong></code>，我们希望使用我们的泛型类型<code class="fe mn mo mp mq b"><strong class="lm io">T</strong></code>作为参数类型。换句话说，我们的函数应该能够处理任何类型的数组<code class="fe mn mo mp mq b"><strong class="lm io">T</strong></code>，或者用TypeScript符号来说，<code class="fe mn mo mp mq b"><strong class="lm io">Array&lt;T&gt;</strong></code>。由于这个数组可以是任何类型，我认为合适的变量名应该是<code class="fe mn mo mp mq b"><strong class="lm io">data</strong></code>。因此，我们可以将<code class="fe mn mo mp mq b"><strong class="lm io">data</strong></code>添加到我们的<code class="fe mn mo mp mq b"><strong class="lm io">sortByKey</strong></code>函数的签名中:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="74ba" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">function</em> sortByKey&lt;T&gt;(data: Array&lt;T&gt;) {</strong></span><span id="0fa7" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span></pre><p id="53cd" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">嗯……还是少了点什么🤔…我们需要添加传递关键字名称进行排序的功能！我将再次依靠TypeScript的强大功能，使用TypeScript的<code class="fe mn mo mp mq b"><strong class="lm io">keyof</strong></code>类型操作符。<code class="fe mn mo mp mq b"><strong class="lm io">keyof</strong></code>类型接受类型键的文字联合。但是我们要带什么类型的呢？啊，对了，我们的通用型<code class="fe mn mo mp mq b"><strong class="lm io">T</strong></code>！TypeScript足够智能，我们甚至可以在泛型类型上使用<code class="fe mn mo mp mq b"><strong class="lm io">keyof</strong></code>类型操作符。那么让我们完成我们的函数<code class="fe mn mo mp mq b"><strong class="lm io">sortByKey</strong></code>的签名:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="d747" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">function</em> sortByKey&lt;T&gt;(data: Array&lt;T&gt;, key: <em class="mm">keyof</em> T) {</strong></span><span id="20ef" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span></pre><p id="8351" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">现在就写正文吧！</p><h1 id="ad12" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">编写sortByKey的主体</h1><p id="29c7" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><code class="fe mn mo mp mq b"><strong class="lm io">sortByKey</strong></code>的主体与<code class="fe mn mo mp mq b"><strong class="lm io">sortByFoo</strong></code>或<code class="fe mn mo mp mq b"><strong class="lm io">sortByBar</strong></code>不会有太大的不同，除了我们需要用<code class="fe mn mo mp mq b"><strong class="lm io">bar</strong></code>或<code class="fe mn mo mp mq b"><strong class="lm io">foo</strong></code>的显式使用的键来替换我们的<code class="fe mn mo mp mq b"><strong class="lm io">key</strong></code>变量。因为我们已经使用了<code class="fe mn mo mp mq b"><strong class="lm io">keyof T</strong></code>，所以当我们使用像<code class="fe mn mo mp mq b"><strong class="lm io">a[key]</strong></code>或<code class="fe mn mo mp mq b"><strong class="lm io">b[key]</strong></code>这样的语法时，Typescript不会反对，因为<code class="fe mn mo mp mq b"><strong class="lm io">key</strong></code>就是字面上的<code class="fe mn mo mp mq b"><strong class="lm io">key of T</strong></code>:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="04bb" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io"><em class="mm">function</em> sortByKey&lt;T&gt;(data: Array&lt;T&gt;, key: <em class="mm">keyof</em> T) {</strong></span><span id="9cdd" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">data.sort((a, b) =&gt; {</strong></span><span id="5780" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">if</em> (a[key] &gt; b[key]) {</strong></span><span id="56bf" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> 1;</strong></span><span id="48fb" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span><span id="6233" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">if</em> (a[key] &lt; b[key]) {</strong></span><span id="6f5f" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> -1;</strong></span><span id="109c" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span><span id="b7e0" class="mv kt in mq b gy na mx l my mz"><strong class="mq io"><em class="mm">return</em> 0;</strong></span><span id="45d9" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">})</strong></span><span id="a175" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">}</strong></span></pre><p id="86f5" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">就是这样！我们现在可以在应用程序中的任何地方对任何数据类型进行排序！</p><h1 id="2985" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">双重好处</h1><p id="9645" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们不仅编写了一个可在整个应用程序中重用的函数，还编写了一个在我们尝试和排序数据时帮助我们避免运行时错误的函数。</p><p id="57f6" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">下面这两个示例行都很好。TypeScript不会抱怨，因为<code class="fe mn mo mp mq b"><strong class="lm io">foo</strong></code>和<code class="fe mn mo mp mq b"><strong class="lm io">bar</strong></code>是<code class="fe mn mo mp mq b"><strong class="lm io">IFooBar</strong></code>接口的键:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="4f16" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io">// Both fine: foo and bar are properties of IFooBar!</strong></span><span id="496c" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">sortByKey&lt;IFooBar&gt;(fooBars, "foo")</strong></span><span id="6bb0" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">sortByKey&lt;IFooBar&gt;(fooBars, "bar")</strong></span></pre><p id="e6d8" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">但是如果我试着按属性<code class="fe mn mo mp mq b"><strong class="lm io">cat</strong></code>对<code class="fe mn mo mp mq b"><strong class="lm io">fooBars</strong></code>排序:</p><pre class="kd ke kf kg gt mr mq ms mt aw mu bi"><span id="a46e" class="mv kt in mq b gy mw mx l my mz"><strong class="mq io">// TypeScript complains: cat is not a property of IFooBar!</strong></span><span id="aa39" class="mv kt in mq b gy na mx l my mz"><strong class="mq io">sortByKey&lt;IFooBar&gt;(fooBars, "cat")</strong></span></pre><p id="f9d9" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">TypeScript会立即用红色下划线标出<code class="fe mn mo mp mq b"><strong class="lm io">cat</strong></code>，将鼠标悬停在错误上方会显示以下警告:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/c66a3dbb1b68a889a21f2f26487e884c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGFtGSR4ERqQvOhE1DkI2w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The official TypeScript error we see when hovering over `cat`: Argument of type ‘“cat”’ is not assignable to parameter of type ‘keyof IFooBar’. ts(2345)</figcaption></figure><p id="9d16" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">这是一个你在Javascript中看不到的警告，只会在运行时遇到，很可能会让你的应用崩溃。</p><h1 id="a445" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">仿制药太棒了！</h1><p id="a6ea" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">很棒，对吧？最棒的部分？这只是TypeScript泛型的冰山一角！🔌<strong class="lm io">栓塞区警报</strong>🔌如果您对此着迷，请查看我利用TypeScript泛型整理的其他精彩帖子和课程:</p><div class="nw nx gp gr ny nz"><a href="https://www.udemy.com/course/advanced-typescript-generic-search-sorting-and-filtering/?referralCode=22441D8B6B06045473D2" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd io gy z fp oe fr fs of fu fw im bi translated">高级类型脚本:通用搜索、排序和过滤</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">大家好。我已经成为一名专业的全堆栈软件工程师7年多了，我已经编程很多年了…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.udemy.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on km nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/advanced-typescript-a-generic-function-to-merge-object-arrays-cb0bd9a5c382"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd io gy z fp oe fr fs of fu fw im bi translated">高级类型脚本:合并对象数组的通用函数</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">另一个强大的通用功能来自SaaS产品档案。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oi l"><div class="oo l ok ol om oi on km nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/advanced-typescript-a-generic-function-to-update-and-manipulate-object-arrays-caacd601cedf"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd io gy z fp oe fr fs of fu fw im bi translated">高级类型脚本:更新和操作对象数组的通用函数</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">终极力量的另一个奇特的通用功能！</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oi l"><div class="op l ok ol om oi on km nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/react-and-typescript-generic-search-sort-and-filter-879c5c3e2f0e"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd io gy z fp oe fr fs of fu fw im bi translated">反应和类型脚本:通用搜索、排序和筛选</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">一个利用TypeScript泛型的强大功能来实现可重用的搜索、排序和…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oi l"><div class="oq l ok ol om oi on km nz"/></div></div></a></div><p id="3ead" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated"><em class="mm">更内容于</em> <a class="ae mg" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lm io"> <em class="mm">通俗地说就是</em> </strong> </a></p></div></div>    
</body>
</html>