<html>
<head>
<title>How to Solve Valid Parentheses in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决JavaScript中的有效括号</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-solve-valid-parentheses-in-javascript-a1ffc8477685?source=collection_archive---------0-----------------------#2021-01-01">https://javascript.plainenglish.io/how-to-solve-valid-parentheses-in-javascript-a1ffc8477685?source=collection_archive---------0-----------------------#2021-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b2d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这篇简单易懂的文章中，你可以解决流行的面试问题，提高你对堆栈的理解。</h2></div><p id="9680" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://leetcode.com/problems/valid-parentheses/" rel="noopener ugc nofollow" target="_blank">有效括号</a>是软件开发人员常见的面试问题。</p><p id="04b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题通常用作候选过滤器，因为它提供了对开发人员的算法和数据结构知识的清晰评估。</p><p id="fa42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果受访者实施了暴力、幼稚的解决方案，面试官可能会认为他们缺乏工作所需的数据结构知识，因为有一个优雅、易于理解的解决方案使用了<strong class="kh ir">堆栈</strong>数据结构。</p><p id="b12a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将对栈进行快速概述，然后深入研究手头的实际问题。</p><h1 id="b9e9" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">栈上的最低限度</h1><p id="96f6" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">堆栈<strong class="kh ir">是一种线性数据结构，遵循一组规定的操作。在开始研究它在代码中的样子之前，让我们想象一下现实生活中的一堆书。</strong></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/2574a848cabc971bec6fe64e464edefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9rKSkDpxTAecFd0RctWHw.jpeg"/></div></div></figure><p id="759f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这幅画里有一摞书。如果有人要拿走其中一本书，哪一本最容易拿走？</p><p id="0f1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何不是专业叠人偶玩家的读者都会说<strong class="kh ir">顶级书籍</strong>。要删除那本书，根本不需要删除任何其他书。我们可以将该操作的成本想象为<strong class="kh ir"> 1，</strong>，因为我们只移动了1本书。</p><p id="f7d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最下面那本书怎么样？需要搬多少本书才能到那本书？答案是<strong class="kh ir"> 7 </strong>，因为我们需要从另一本书的顶部挑选一本书，直到我们到达最底部的书。</p><p id="6e0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过<strong class="kh ir">总是</strong>将我们下一个<strong class="kh ir">想要的书</strong>直接放在书库<strong class="kh ir">顶部</strong>来提高书库的效率。这样，运营成本总是1，因为我们需要的书就在最上面。</p><p id="d5ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编程中的堆栈通过实现<strong class="kh ir">后进先出(LIFO) </strong>策略来使用这个概念，这意味着最后推入堆栈的元素是第一个从堆栈中弹出的元素。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/9410e8e6696859acc611f23887ebd6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAqLFedpgKa-AupAwvF5Aw.png"/></div></div></figure><p id="a298" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了说明后进先出策略，以下面的数组为例:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/bdaf273ea6e599fb4f7490c5f1147738.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*SH1wfwiIa-KSmOE2AiSJGg.png"/></div></figure><p id="6dd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推入数组的最后一个元素是<code class="fe mn mo mp mq b">2</code>。让我们将<code class="fe mn mo mp mq b">11</code>推到数组上。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/e427dbb48d99ad20bc96765a807fab5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*hONp1v-9YG4zQiRyg3jiVQ.png"/></div></figure><p id="1ce0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，最后一个元素是<code class="fe mn mo mp mq b">11</code>。当我们从数组中弹出时，我们移除最后一个元素<code class="fe mn mo mp mq b">11</code>，使<code class="fe mn mo mp mq b">2</code>再次成为堆栈中的最后一个元素。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/bdaf273ea6e599fb4f7490c5f1147738.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*SH1wfwiIa-KSmOE2AiSJGg.png"/></div></figure><p id="fd11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是栈的两个操作:<code class="fe mn mo mp mq b">push</code>和<code class="fe mn mo mp mq b">pop</code>。其他操作与本文无关。</p><p id="6a75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用堆栈的好处在于所有的操作现在都是O(1) 时间，因为我们只在堆栈的末尾操作。如果我们要从数组中间移除一个元素，我们需要将该元素后面的元素的所有索引下移。有了栈，我们再也不需要担心那个耗时的操作了。</p><h1 id="46f7" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">回到有效括号</h1><p id="cd06" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们来分解这个问题:</p><blockquote class="ms mt mu"><p id="ddf2" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">给定一个仅包含字符<code class="fe mn mo mp mq b">'('</code>、<code class="fe mn mo mp mq b">')'</code>、<code class="fe mn mo mp mq b">'{'</code>、<code class="fe mn mo mp mq b">'['</code>和<code class="fe mn mo mp mq b">']'</code>的字符串<code class="fe mn mo mp mq b">s</code>，确定输入的字符串是否有效。</p></blockquote><p id="8242" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从问题描述中我们可以看出，问题的名称有点用词不当。我们正在检查有效的括号、有效的大括号和有效的方括号。</p><p id="8b45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题的核心是确保在<strong class="kh ir">正确的顺序</strong>中，任何开始符号后面都有正确的结束符号。</p><p id="c6b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<code class="fe mn mo mp mq b">[]</code>是有效的，因为<code class="fe mn mo mp mq b">[</code>后面直接有结束的<code class="fe mn mo mp mq b">]</code>。</p><p id="c24c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例子<code class="fe mn mo mp mq b">[[]</code>怎么样？这是无效的，因为第一个<code class="fe mn mo mp mq b">[</code>在字符串末尾没有结束<code class="fe mn mo mp mq b">]</code>。</p><p id="a5f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们尝试一个更复杂的例子:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/436f81bb5499758970929366d5c4c473.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*D-BsKlozZxwIESD_3g-wNA.png"/></div></figure><p id="efc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个是有效的。每个开始符号在正确的位置都有相应的结束符号。这里需要注意的是，结束符号出现的顺序也决定了字符串的有效性。</p><p id="bab9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个示例说明了所有结束符号都存在但顺序错误的情况:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/43b1bad158dc5852d67e4bceb51f4f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*-t14zfEhsshgXfxHNQMc6w.png"/></div></figure><p id="931e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这两个相似但不同的例子之间，出现了一种模式。注意，第一个元素<code class="fe mn mo mp mq b">{</code>的结束元素是序列中最后一个元素<strong class="kh ir">？第二个元素<code class="fe mn mo mp mq b">[</code>的结束元素位于倒数第二个索引处。最后，第三个元素<code class="fe mn mo mp mq b">(</code>的结束元素紧随其后。</strong></p><p id="62f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎开启元件的顺序决定了关闭元件应该放置在的位置<strong class="kh ir">。我们一会儿将回到这一点。</strong></p><h1 id="18d3" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">制定计划</h1><p id="2ef6" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">既然我们已经分解了这个问题并注意到了一个模式，让我们开始制定一个计划来解决这个问题。</p><p id="c2b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将使用以下示例作为模板:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/436f81bb5499758970929366d5c4c473.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*D-BsKlozZxwIESD_3g-wNA.png"/></div></figure><p id="d722" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一次一个元素地浏览这个例子，并自己解决它。由于输入是以字符串的形式出现的，让我们假设我们用指针循环访问它，或者把它转换成一个数组。</p><p id="001f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个元素是<code class="fe mn mo mp mq b">{</code>。这是一个开放符号，所以我们还不能确定它是否有效。</p><p id="7308" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个元素是<code class="fe mn mo mp mq b">[</code>。往前走。</p><p id="6a90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个元素是<code class="fe mn mo mp mq b">(</code>，所以继续下去，直到我们碰到一个结束符号。</p><p id="117b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">终于！第四个元素<code class="fe mn mo mp mq b">)</code>是关闭元素。让我们看看它是否在正确的地方。我们仅仅通过观察字符串就知道它在正确的位置，因为它正在关闭它前面的<code class="fe mn mo mp mq b">(</code>。</p><p id="6c3e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何存储开始符号的序列，以便实际上以编程方式进行检查呢？</p><p id="83e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经讨论了使用堆栈，那么让我们在这里尝试一下。记住，是后进先出。让我们试试下面的策略:如果当前元素是一个开始符号，让我们把它推到堆栈上。如果是结束符号，让我们从堆栈中弹出最后一个元素，看看它是否是与当前结束符号匹配的<strong class="kh ir">开始符号。</strong></p><p id="7ad0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从一个空栈开始，<code class="fe mn mo mp mq b">[]</code>:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi na"><img src="../Images/0e38dd476b23034bd9063363f9f86919.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*F2OOWr3JSJ3s_H1wkkOgqA.png"/></div></figure><p id="9018" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个元素是<code class="fe mn mo mp mq b">{</code>。这是一个开口，所以把它推到堆栈上。移动到下一个元素。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/85a0ef0c79d422286aec089888196c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*yFiVBxMSkAoeh8kUuCgkKQ.png"/></div></figure><p id="8b3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们目前的元素仍然是一个开放，所以推动它，继续前进。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/cae54ddaa8b18bcecda97cbad2ad724c.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*LmClRP63wsgDUHAGqsW9Tg.png"/></div></figure><p id="7850" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是最后一个开始符号。按下它，让我们来看看结束符号。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9f3929b3d9f14da187abc4571a0abc9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*RoLkwqpbOlCzcQgj4tGrRA.png"/></div></figure><p id="6bab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们终于碰到了结束符号<code class="fe mn mo mp mq b">)</code>。让我们弹出堆栈的最后一个元素，看看它是否是<code class="fe mn mo mp mq b">)</code>关闭的正确符号。</p><p id="e40a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确实是！移动到下一个元素。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/79d95747cca1ba21f70697a73be710ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*LT2JaNX2RKp0MSou4_1GBg.png"/></div></figure><p id="369e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">弹出堆栈的最后一个元素，并检查它是否是关闭<code class="fe mn mo mp mq b">]</code>的正确符号。是的，所以我们继续。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/8ca6ad7b2e0c33554d2a8361a80f519e.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*dbPxIE0SUMnbOX7Y_gVXsQ.png"/></div></figure><p id="4590" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个要素是正确的符号对。当我们完成对符号集合的迭代后，如果堆栈为空，我们就可以确定字符串是有效的。如果堆栈中还有剩余的符号，这意味着字符串是无效的，因为有些符号没有关闭。</p><p id="bd86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们对如何处理这个问题有了一个高层次的理解，让我们实际上写一些代码。</p><h1 id="1028" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">编写代码</h1><p id="6494" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">首先，创建函数<code class="fe mn mo mp mq b">isValid</code>并在其中初始化一个堆栈。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1e3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始迭代输入<code class="fe mn mo mp mq b">s</code>之前，让我们考虑一下如何检查从堆栈中弹出的元素是否是当前结束符号的正确开始符号。在我们对这个问题的高层次回顾中，我们从未讨论过我们将如何实际实现它。</p><p id="ae7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以检查的一种方法是将正确的<strong class="kh ir">开始和结束</strong>符号对存储在<strong class="kh ir">散列表</strong>中。这样，我们可以检查堆栈中弹出的元素，即<strong class="kh ir">键</strong>，是否与该键的值匹配，该值将是该对的<strong class="kh ir">结束符号</strong>。如果这不完全合理，请查看下一个代码片段。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="725b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将检查弹出元素的值，例如可能是<code class="fe mn mo mp mq b">closings['(']</code>，并查看<code class="fe mn mo mp mq b">s</code>中的当前元素是否与来自<code class="fe mn mo mp mq b">closings</code>的值相匹配。</p><p id="3112" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们设置<code class="fe mn mo mp mq b">s</code>的迭代。为了最大化时间效率，我们将在这里使用一个<code class="fe mn mo mp mq b">for</code>循环，这样我们可以在<code class="fe mn mo mp mq b">s</code>无效的情况下尽早<code class="fe mn mo mp mq b">return</code>。</p><p id="6047" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在循环中，首先检查当前元素是否是任何开始符号。如果是，将它推到堆栈上，并转到下一个元素。如果不是开始符号，我们需要从堆栈中弹出一个元素，并检查当前元素是否是弹出元素的正确结束符号。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="735a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们结束循环时，我们需要检查堆栈中是否还有剩余的元素。如果是，字符串无效，并且<code class="fe mn mo mp mq b">isValid</code>返回<code class="fe mn mo mp mq b">false</code>。如果堆栈是空的，字符串是有效的，我们将返回<code class="fe mn mo mp mq b">true</code>。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ede7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，我们都完了。</p><p id="17f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇文章帮助你理解了这个问题，多叠加一点。编码快乐！</p></div></div>    
</body>
</html>