<html>
<head>
<title>The Case for Transducers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">传感器的情况</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-case-for-transducers-8ac9fc4ed93c?source=collection_archive---------9-----------------------#2021-12-01">https://javascript.plainenglish.io/the-case-for-transducers-8ac9fc4ed93c?source=collection_archive---------9-----------------------#2021-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4e67" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">人们常说函数式编程对内存使用有负面影响。传感器解决了这个问题。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ad26bf44b0c21e53cb12324fac4b34fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4xmNL1FARqEHnt9zcq32Q.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@worldsbetweenlines?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Patrick Hendry</a> on <a class="ae ks" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ff01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> map </a>、<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"> filter </a>和<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reducehttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank"> reduce </a>函数是JavaScript中众所周知的数组方法，广泛应用于函数式编程中。人们可以很容易地将它们链接起来，极大地增加了开发者的体验。</p><p id="599b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，每个操作都会创建一个<strong class="kv io">中间数组</strong>。对于大多数不需要性能优化的应用程序来说，这不是问题，但对于大型阵列来说，这可能会成为一个严重的限制—想想数千个，或者更糟:数百万个值。</p><p id="5353" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面的例子说明了这一点，其中的附加类型将对本文接下来的部分有所帮助:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="6a84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">除了初始数组(<code class="fe lr ls lt lu b">[0, 1, 2, 3]</code>)，在此过程中还创建了两个中间数组:<code class="fe lr ls lt lu b">[1, 2, 3, 4]</code>和<code class="fe lr ls lt lu b">[2, 4]</code>。</p><p id="9cdc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">人们可能希望有一个<em class="lv">工具</em>，一个接一个地映射、过滤和求和初始数组<strong class="kv io">的每个值，比如:</strong></p><pre class="kd ke kf kg gt lw lu lx ly aw lz bi"><span id="a07b" class="ma mb in lu b gy mc md l me mf">Initial array -&gt; increment -&gt; isEven -&gt; sum<br/>0             -&gt; 1         -&gt;        -&gt; 0<br/>1             -&gt; 2         -&gt; 2      -&gt; 2<br/>2             -&gt; 3         -&gt;        -&gt; 2<br/>3             -&gt; 4         -&gt; 4      -&gt; 6</span></pre><p id="898b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个工具叫做<strong class="kv io">传感器</strong>。为了精确起见，在这个例子中，传感器是用<code class="fe lr ls lt lu b">filter</code>连接的<code class="fe lr ls lt lu b">map</code>，并与<code class="fe lr ls lt lu b">sum</code>减速器一起使用。稍后会详细介绍。</p><pre class="kd ke kf kg gt lw lu lx ly aw lz bi"><span id="961b" class="ma mb in lu b gy mc md l me mf">Initial array -&gt; transducer -&gt; sum<br/>0             -&gt;            -&gt; 0<br/>1             -&gt; 2          -&gt; 2<br/>2             -&gt;            -&gt; 2<br/>3             -&gt; 4          -&gt; 6</span></pre><p id="cac7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，换能器是一种功能，它将一个减速器转换成另一个减速器，打开了作曲的大门:</p><pre class="kd ke kf kg gt lw lu lx ly aw lz bi"><span id="d23c" class="ma mb in lu b gy mc md l me mf">reducer: (accumulator, current) -&gt; accumulator<br/>transducer: reducer -&gt; reducer</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><h1 id="0468" class="mg mb in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">作为转换器映射和过滤，允许合成</h1><p id="487c" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">我们的目标是组合<code class="fe lr ls lt lu b">map</code>和<code class="fe lr ls lt lu b">filter</code>操作，这需要将这些方法重写为转换器。让我们从<code class="fe lr ls lt lu b">map</code>开始:</p><pre class="kd ke kf kg gt lw lu lx ly aw lz bi"><span id="638a" class="ma mb in lu b gy mc md l me mf">map: fn -&gt; reducer -&gt; reducer</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="c731" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lr ls lt lu b">array.map(increment)</code>现在改写为<code class="fe lr ls lt lu b">array.reduce(map(increment)(identity), [])</code>。这是很大的进步，听起来可能很复杂，所以让我们一步一步来:</p><ul class=""><li id="f415" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated"><code class="fe lr ls lt lu b">identity</code>:顾名思义，这是一个将一个数组的值累加到一个新数组中的reducer。因此结果等于数组本身:<code class="fe lr ls lt lu b">[0, 1, 2, 3].reduce(identity); // [0, 1, 2, 3]</code></li><li id="1c34" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><code class="fe lr ls lt lu b">map(increment)</code>是一个换能器。因此，它将一个减速器(<code class="fe lr ls lt lu b">identity</code>)转换成一个新的减速器，同时应用<code class="fe lr ls lt lu b">increment</code>功能。</li></ul><p id="5716" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">光是这一点，就将是徒劳无益的。但是一旦以同样的方式准备好<code class="fe lr ls lt lu b">filter</code>方法，这将是有意义的:</p><pre class="kd ke kf kg gt lw lu lx ly aw lz bi"><span id="7dad" class="ma mb in lu b gy mc md l me mf">filter: fn -&gt; reducer -&gt; reducer</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="d80c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，<code class="fe lr ls lt lu b">array.filter(isEven)</code>被重写为<code class="fe lr ls lt lu b">array.reduce(filter(isEven)(identity), [])</code>，推理与前面相同。</p><p id="a8f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这终于有意义了(希望如此)，因为我们现在能够将<code class="fe lr ls lt lu b">map</code>和<code class="fe lr ls lt lu b">filter</code>重写为转换器:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="8120" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">挺厉害的吧？</p><p id="3ad5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更强大的，我应该说，因为我们可以提供这种传感器与其他初始减速器:</p><p id="fdbf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lr ls lt lu b">sum</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="6af6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lr ls lt lu b">count</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="9531" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">多棒的旅程啊。但还有更多！</p><h1 id="180b" class="mg mb in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">传感器x项目</h1><p id="cffa" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">到目前为止，我们已经处理了长度有限的数组。如<code class="fe lr ls lt lu b">[0, 1, 2, 3]</code>。如何处理“无限”的物体，比如可观察的或可重复的？</p><p id="55a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们考虑一个建立在自然数的生成器上的iterable:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="315d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们希望之前制造的传感器能和这个仪器一起使用。为此，我们需要一个<code class="fe lr ls lt lu b">reduce</code>函数，由我们来定义这意味着什么。</p><p id="fefc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简单来说，<code class="fe lr ls lt lu b">Array.reduce</code>函数有如下签名(简化是因为在<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">规范</a>中，缩减器接受额外的参数、索引和数组本身):</p><pre class="kd ke kf kg gt lw lu lx ly aw lz bi"><span id="012b" class="ma mb in lu b gy mc md l me mf">Array&lt;U&gt;.reduce(reducer: ReducerFunction&lt;U, R&gt;, seed: R): R</span></pre><p id="a188" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">受这个签名的启发，我们可以定义一个<code class="fe lr ls lt lu b">reduce</code>函数，它不是返回一个原始值<code class="fe lr ls lt lu b">R</code>，而是返回一个新的<code class="fe lr ls lt lu b">Iterable&lt;R&gt;</code>。这对于无限的可迭代对象尤其有意义，因为对于无限的可迭代对象，reduce操作应该考虑“到目前为止”产生的所有值，没有结束:</p><pre class="kd ke kf kg gt lw lu lx ly aw lz bi"><span id="6aad" class="ma mb in lu b gy mc md l me mf">Iterable&lt;U&gt;.reduce(reducer: ReducerFunction&lt;U, R&gt;, seed: R): Iterable&lt;R&gt;</span></pre><p id="7128" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们称<code class="fe lr ls lt lu b">IterableAndReducible</code>为<code class="fe lr ls lt lu b">Iterable</code>，它也是一个<code class="fe lr ls lt lu b">Reducible</code>(即公开一个<code class="fe lr ls lt lu b">reduce</code>函数):</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="fb5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在原生<code class="fe lr ls lt lu b">Iterable</code>型上的这项工作允许重复使用以前为阵列建造的减速器和传感器。太好了！这同样适用于RxJS中使用<a class="ae ks" href="https://rxjs.dev/api/operators/scan" rel="noopener ugc nofollow" target="_blank">扫描</a>方法的可观察值。要点是:只要数据结构公开了一个<code class="fe lr ls lt lu b">reduce</code>函数，就可以使用减速器和转换器！</p><h1 id="ef89" class="mg mb in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">进一步阅读</h1><ul class=""><li id="4fc7" class="nc nd in kv b kw mx kz my lc nq lg nr lk ns lo nh ni nj nk bi translated"><a class="ae ks" href="https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d" rel="noopener">https://medium . com/JavaScript-scene/Transducers-efficient-data-processing-pipelines-in-JavaScript-7985330 Fe 73d</a>(Transducers，作者Eric Elliott)</li><li id="3020" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae ks" href="https://medium.com/@dtipson/javascript-transducers-2-stateful-gateful-1faa1b01ae50" rel="noopener">https://medium . com/@ dt ipson/JavaScript-transducers-2-stateful-gate ful-1 FAA 1 b 01 AE 50</a>(stateful transducers)</li><li id="c967" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae ks" href="https://github.com/mathieueveillard/transducers" rel="noopener ugc nofollow" target="_blank">https://github.com/mathieueveillard/transducers</a></li></ul><p id="841f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lv">更多内容请看</em><strong class="kv io"><em class="lv"/></strong><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lv">说白了。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="lv">免费周报在这里</em> </strong> </a> <em class="lv">。</em></strong></a></p></div></div>    
</body>
</html>