<html>
<head>
<title>Sharpen Your Testing Skills by Debugging in Cypress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过在Cypress中调试来提高您的测试技能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/sharpen-your-testing-skills-by-debugging-in-cypress-597de915ffab?source=collection_archive---------13-----------------------#2021-03-16">https://javascript.plainenglish.io/sharpen-your-testing-skills-by-debugging-in-cypress-597de915ffab?source=collection_archive---------13-----------------------#2021-03-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="52d9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解如何有效地调试Cypress测试代码。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/55520e7c8b477bfed4aed46c4453e7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YKxpjTcQuAimvg79"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">It’s easier than this, trust me. (Photo by <a class="ae ks" href="https://unsplash.com/@clemono?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clem Onojeghuo</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>)</figcaption></figure><p id="ed5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">调试——我们都经历过。一连几个小时盯着一行行的代码，想知道为什么有些东西会以这种方式出现。调试自动化代码可能是一个令人沮丧和精疲力尽的经历。无论工具集是什么，深入代码行以确定自动化在哪里出了问题都是一个挑战。</p><p id="153b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我个人犯了一个错误，然后立即再次运行我的代码。出于某种原因，我仍然认为第二次我的代码会顺利通过。似乎50%的失败率是一件值得自信的事情——事实并非如此。</p><p id="677c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幸运的是，Cypress自带的方法和特性极大地提高了工程师快速有效地调试自动化代码的能力。</p><p id="8eca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本教程假设您熟悉Cypress和测试自动化。我们将使用<a class="ae ks" href="https://www.demoqa.com/elements" rel="noopener ugc nofollow" target="_blank"> DemoQA元素</a>页面作为我们测试和调试活动的基础。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="4803" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">设置调试器</h1><p id="98d7" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">为了正确地使用Cypress进行调试，您必须配置浏览器窗口以使用开发人员工具打开。这可以通过将下面的代码添加到插件目录中的<code class="fe mt mu mv mw b">index.js</code>模块来实现。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Automatically open DevTools for Chrome, Electron, and Firefox.</figcaption></figure><p id="5a77" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mz">注意:在没有插件</em> <code class="fe mt mu mv mw b"><em class="mz">index.js</em></code> <em class="mz">模块的情况下启动浏览器实例(或者没有手动打开控制台)将不允许进行调试。</em></p><p id="6517" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以通过打开Cypress GUI并在headful模式下运行测试来验证代码是否有效。浏览器窗口现在应该会打开，并突出显示开发人员工具。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/9003fe80620d29f02fe5d95709417903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcjGz6J6Dzc1RqY0bCwnyg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Cypress window with a console session open. (Screenshot by Jonathan Thompson)</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="2f54" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">调试方法</h1><p id="0f38" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">Cypress允许两种独立的调试方法:</p><ol class=""><li id="00c4" class="nb nc in kv b kw kx kz la lc nd lg ne lk nf lo ng nh ni nj bi translated">JavaScript <code class="fe mt mu mv mw b">debugger</code>语句</li><li id="5a86" class="nb nc in kv b kw nk kz nl lc nm lg nn lk no lo ng nh ni nj bi translated"><code class="fe mt mu mv mw b">cy.debug()</code>柏树的方法</li></ol><p id="9065" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我个人发现赛普拉斯<code class="fe mt mu mv mw b">cy.debug()</code>方法对测试工程师更有用，所以我将把重点放在它的用法而不是<code class="fe mt mu mv mw b">debugger</code>语句上。这在很大程度上是因为当调用debug方法时，Cypress会捕获元素标准。</p><p id="004f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，您正在构建一个测试，用于选择<a class="ae ks" href="https://www.demoqa.com/buttons" rel="noopener ugc nofollow" target="_blank">演示按钮</a>页面上的动态点击按钮。动态点击按钮是页面上显示的第三个按钮，位于双击和右键按钮下方。编写一个简单的调用来获取一个按钮并单击它会失败，因为页面上有多个按钮元素。</p><p id="28d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">找到要选择的按钮的一种快速简单的方法是在获得页面上的所有按钮后立即使用debug方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">An example usage of cy.debug().</figcaption></figure><p id="40cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">运行上述代码将在浏览器窗口中返回以下内容:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/e9564b2520fb29df59e778e69430b2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5GZ5_CTHIbVAiE2OALIBQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The result of cy.debug() on the Buttons page. (Screenshot by Jonathan Thompson)</figcaption></figure><p id="0e01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，页面上有四个按钮，动态点击按钮占据了第三个索引。在控制台中打开索引会显示选择器的信息，从childNodes和innerText到onClick数据。对于这个特别的问题，我们将关注innerText条目，因为按钮有一个我们可以使用的独特的文本节点。</p><p id="080a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，对文本“点击我”使用<code class="fe mt mu mv mw b">cy.contains()</code>方法是行不通的，因为屏幕上有三个带有“点击我”的按钮。相反，我们将求助于使用regex模式，并将其与使用debug方法时找到的innerText数据的确切内容进行匹配。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Selection of a button based on exact innerText.</figcaption></figure><p id="f82f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的测试将顺利通过，因为我们在屏幕上选择了正确的按钮。</p><p id="d891" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这看起来像是一个基本的例子。目的是展示使用<code class="fe mt mu mv mw b">cy.debug()</code>方法寻找元素标准的实践，这有助于为测试消耗构建选择器。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="da92" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">过去和现在</h1><p id="2786" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">吸引我采用Cypress 1 . 0 . 0版的一个原始特性是页面操作前后的DOM截图。在Cypress之前，工程师通过图像截图依靠两种模式进行调试:</p><ol class=""><li id="1d31" class="nb nc in kv b kw kx kz la lc nd lg ne lk nf lo ng nh ni nj bi translated">在测试代码中手动输入屏幕截图调用</li><li id="912f" class="nb nc in kv b kw nk kz nl lc nm lg nn lk no lo ng nh ni nj bi translated">失败呼叫后的屏幕截图</li></ol><p id="ddee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一个问题是，它要求工程师明确知道在哪里输入截屏调用。在极端的情况下，工程师会在每个动作前后添加截图。然后，每次自动化运行都会用截图填充一个目录，以便在没有上下文的情况下进行筛选，这进一步模糊了工程师准确解决自动化问题的能力。</p><p id="9991" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">失败时的屏幕截图只对确定操作失败时的应用程序状态有用。查看失败前的应用程序状态没有任何帮助。</p><p id="dc68" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Cypress通过在页面上执行操作前后提供DOM截图来解决这些问题。下面是<a class="ae ks" href="https://www.demoqa.com/buttons" rel="noopener ugc nofollow" target="_blank">演示按钮</a>页面上的一个交互。当用户双击特定按钮时，按钮行下面的容器中会显示一条消息。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/61ed421e3b96c1552ca04b93ef180f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_pIJysYd4aoeDUjNP_btDg.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Before and after screenshots. (Gif by Jonathan Thompson)</figcaption></figure><p id="6f16" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">gif显示了Cypress测试运行程序，在屏幕底部有“before”和“after”按钮。“之前”按钮显示操作之前的应用程序状态，而“之后”按钮显示结果。切换“after”按钮显示带有消息文本的屏幕截图，声明在正确的按钮上发生了双击，从而确认在页面上发生了双击。</p><p id="2ff7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然此信息仅在headful模式下运行时可用，但它允许工程师查看应用程序内已采取的操作以及应用程序之前的状态。通过提供何时添加<code class="fe mt mu mv mw b">cy.debug()</code>方法的基础，这在调试过程中被证明是非常有用的。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="9508" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">用视频捕捉它</h1><p id="77b9" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">默认情况下，在headless模式下，Cypress会为每个已经完成的测试捕获视频文件——不管它是通过还是失败。这些视频可以在显示测试中的整体工作流程的同时，提供测试期间应用程序状态的一瞥。工程师可以使用这些视频快速发现应用程序状态中的错误，同时考虑正在发生的操作，以便标记需要输入调试语句的位置。</p><p id="5655" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">作为一名测试工程师，您应该在每次失败后查看视频，以确定从哪里开始故障排除。虽然它们不是交互式的，但它们确实提供了足够的背景。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="fcee" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">暂停以获得效果</h1><p id="2456" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">许多编程语言都有一个读取-求值-打印循环(REPL ),允许工程师在执行过程中进入代码。从这里，工程师可以写出步骤，并实时观察命令的结果。我非常熟悉这种模式，因为我的自动化经验中有很大一部分是用Python和Ruby，这两种编程语言都有REPLs的特性。</p><p id="795e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每种语言都允许我编写自动化代码，打开一个满满的窗口，然后分别使用Ruby的<code class="fe mt mu mv mw b">binding.pry</code>和Python的<code class="fe mt mu mv mw b">breakpoint</code>进入其中。一旦进入，我就可以在REPL中写出下一步测试的代码，并观察我的交互结果。这个过程允许我看到动作的执行，以及我应该寻找什么样的问题，比如需要等待的缓慢加载的元素。</p><p id="6dea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不幸的是，JavaScript没有REPL。然而，Cypress的创造者确实为我们提供了另一种选择:方法<code class="fe mt mu mv mw b">cy.pause()</code>。</p><p id="1525" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用pause方法可以停止自动化代码，并提供两个附加功能:</p><ol class=""><li id="66fc" class="nb nc in kv b kw kx kz la lc nd lg ne lk nf lo ng nh ni nj bi translated">播放按钮</li><li id="0fe0" class="nb nc in kv b kw nk kz nl lc nm lg nn lk no lo ng nh ni nj bi translated">下一步按钮</li></ol><p id="0604" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">play按钮将简单地正常运行测试。“下一步”按钮对于解决自动化代码问题至关重要。</p><p id="d8e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是按钮的运行情况:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/751ed5907c7d9e8ed4d3f8b9cb0378e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fJJplMFVKoDy4kmlVOjFDA.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Step-by-step interactions using cy.pause(). (Gif by Jonathan Thompson)</figcaption></figure><p id="7c25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用next按钮，我们可以查看测试中每一步代码的操作和结果。这是非常强大的，因为它允许工程师查看视频或截图范围之外的结果。工程师直接控制的不是静态资产，而是Cypress。这对于解决页面加载、挑剔的选择器或其他各种问题来说是完美的。</p><p id="d52a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每当我发现自己在用Cypress进行故障诊断时，不管问题有多大，我个人都会使用这种模式。在编写或维护自动化代码时，不能不使用<code class="fe mt mu mv mw b">cy.pause()</code>方法。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="0a89" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">摘要</h1><p id="3faf" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">调试测试自动化不一定是痛苦的经历。通过使用Cypress的debug方法，您可以发现在测试自动化代码中使用的应用程序元素。查看DOM截图和视频可以让您构建输入调试语句的上下文。最后，<code class="fe mt mu mv mw b">cy.pause()</code>方法是一个强大的工具，它允许工程师在测试代码运行时进入测试代码，并手动执行测试步骤。</p><p id="cfbc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些工具中的每一个都将极大地增强您对自动化代码进行故障诊断和调试的能力。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="7eb3" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">资源</h1><ol class=""><li id="bcbd" class="nb nc in kv b kw mo kz mp lc ns lg nt lk nu lo ng nh ni nj bi translated">“调试。”2021年3月5日，【docs.cypress.io/guides/guides/debugging.html】<a class="ae ks" href="http://docs.cypress.io/guides/guides/debugging.html" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="be36" class="nb nc in kv b kw nk kz nl lc nm lg nn lk no lo ng nh ni nj bi translated">柏树-木卫一。"建议:添加命令行标志，用于在运行期间打开开发工具."<em class="mz"> GitHub </em>，<a class="ae ks" href="http://github.com/cypress-io/cypress/issues/2024" rel="noopener ugc nofollow" target="_blank">github.com/cypress-io/cypress/issues/2024</a>。</li></ol></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="c3c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Jonathan Thompson </strong>是Pendo.io的高级质量工程师，专攻测试自动化。他目前和妻子以及一只名叫温斯顿的金毛猩猩住在北卡罗来纳州的罗利。你可以在<a class="ae ks" href="https://www.linkedin.com/in/jonathanmnthompson/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，或者在<a class="ae ks" href="https://twitter.com/jacks_elsewhere" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae ks" href="http://github.com/ThompsonJonM" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注他。</p></div></div>    
</body>
</html>