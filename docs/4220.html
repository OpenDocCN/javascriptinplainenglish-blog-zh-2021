<html>
<head>
<title>Was Client-Side Rendering a Mistake?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">客户端渲染是一个错误吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/client-side-vs-server-side-rendering-4a491c4a1746?source=collection_archive---------0-----------------------#2021-08-22">https://javascript.plainenglish.io/client-side-vs-server-side-rendering-4a491c4a1746?source=collection_archive---------0-----------------------#2021-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7bf5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Web开发的历史上，客户端渲染是一个错误吗？它的历史、现状和前景</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/38a93a561b4c25e2e3791cdfc5e301b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QGnlDRyDjd6AT2SI"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@punttim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Gouw</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="63a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于客户端和服务器端渲染的老话题。据我所知，所有关于这个主题的文章都是这样陈述的:服务器端渲染是更好的选择。一直都是。</p><p id="6638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自企业社会责任与安全部门改革的辩论开始以来，几年过去了。从那以后，很多事情可能已经改变了。我想提供一幅客户端渲染的现状图，它的历史，问题，甚至一个潜在的用例。</p><p id="24ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">玩得开心！</p><h1 id="51a5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">这是结果——而不是意图</h1><p id="46aa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一开始，客户端渲染的想法可能很难让人理解。尤其是你已经知道它的缺点的情况下。因此，知道客户端呈现是一个好消息。</p><p id="b0c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有人说，“让我们创建应用程序，提供巨大的JS文件，执行昂贵的渲染，同时延迟我们的第一次内容丰富的绘制，使我们的页面SEO不友好。这不是很好吗？”</p><p id="4834" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很难说它是从什么时候开始的，但也许它是从Angular.js开始的。当我们开始越来越多地用JavaScript操纵web时，Angular.js和其他框架在这个时候走得更远:不是操纵web，而是用JavaScript 呈现web。</p><p id="9261" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不一会儿，Angular 2和尤React.js接手了。我们没有在index.html中编写HTML标记，而是用下面的代码代替:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="53a9" class="mu lt iq mq b gy mv mw l mx my">function App() {<br/>  return React.createElement("div", { className: "App" }, [<br/>    React.createElement("h1", null, "Hello World!")<br/>  ]);<br/>}</span></pre><p id="e8db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为什么呢？嗯，完全用JavaScript来描述HTML使得操纵它变得很容易。当我们点击“增量”按钮时，这是DOM自动变化的伟大时代。</p><p id="fb13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">被所有操纵DOM的工具可能性蒙蔽了双眼，我们最终使用了客户端渲染。几乎100%客户端渲染。</p><p id="5d85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">index.html突然变成了一点样板代码bundle.js变得更大了。事情就是这样开始的。它开始于一个结果。</p><h1 id="8824" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">性能问题仍然是一个问题</h1><p id="54ac" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有很多技术使得网络应用越来越快。<br/>懒加载，默认代码拆分，最小化，压缩，三抖。有人可能认为这也极大地改善了客户端渲染的命运。然而，它仍然面临一些问题。</p><p id="4a36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然谷歌公司声称客户端呈现的页面在排名中不受歧视，但还有另一个问题:性能。</p><p id="a3e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前端重要的是显示内容。当然，交互性也很重要，但是对用户来说最大的障碍是看到一个空页面。</p><p id="552a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这个问题，客户端渲染是一个问题。因为所有的HTML都是在JavaScript加载并执行后呈现的，所以我们有很大的延迟。<br/>为了说明这个问题，我创建了两个相同的React.js应用程序。</p><p id="ec42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个是通过使用默认的React.js生产流程构建的，该流程生成一个客户端呈现的应用程序。第二个应用程序完全相同，但呈现在服务器上。下面是Lighthouse中的性能结果。</p><p id="6cc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端渲染版本:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/fd5a8129bc5aaa33d90a4e1fedaa757c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YobgjGWBFFmdokfuqqKGsA.png"/></div></div></figure><p id="df6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器端呈现的版本:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/f995f83de7910bcf6ba31b33766cf442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0WJRMZT67Dw55fkGcoZWyA.png"/></div></div></figure><p id="41e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如所料，服务器端渲染的应用程序要快得多，尤其是在第一次内容丰富的绘制时。即使交互的时间并没有好到哪里去，一些东西也应该尽可能快地被用户看到。否则，用户更有可能退出页面。</p><p id="c8d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，请记住，这只是默认的React.js应用程序，使用create-react-app创建。它没有那么大，也没有交互元素。</p><p id="2de3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当谈到性能比较时，人们经常会提出一个反对服务器端渲染的糟糕论点:</p><p id="7431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“但客户端呈现的页面可以托管在简单的webspace上，而服务器端呈现的应用程序总是需要执行函数，这导致了更高的服务器响应时间和负载。”</p><p id="d824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们谈到主动服务器端渲染时，这是正确的。在这种情况下，每当有请求时，页面都会在服务器上呈现。当然，这是一件很糟糕的事情。然而，在一些项目中实际上需要它，例如，在呈现页面时包括来自数据库或API的数据。</p><p id="6451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，许多服务器端渲染框架帮助我们保持良好的性能。缓存响应或更精确地决定是否真的需要渲染。</p><p id="6bfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，替代方案也没那么美好。这并不是说客户端渲染可以简单地解决这个问题，而不会产生新的问题。想想获取数据并将其集成到服务器上的渲染过程中的例子，CSR的答案可能是这样的:</p><p id="7e88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将数据提取库发送到客户端，并在用户设备上请求数据。我不需要解释这增加了包的大小，并且客户端渲染会出现已知的问题。</p><p id="87a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，我们仍然可以在服务器端呈现的或静态的应用程序中发布数据获取的代码——在这种情况下，CSR没有优势。</p><h1 id="eb24" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">性能问题仍然是一个问题</h1><p id="f6de" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">单页应用是完全客户端渲染的自然产物。我们坚持使用唯一的index.html，而不是每个URL都有一个单独的HTML文件。这个文件包括JavaScript包，然后它呈现了我们的应用程序。我们将它们虚拟化，并通过JavaScript模拟一个包含多个HTML文件的web应用程序的体验，而不是“物理”URL。</p><p id="36f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我第一次接触单页app是在著名的React路由器上使用React.js。设置好路线后，整个应用程序会保存在几个文件中。我很快意识到这个系统也有巨大的好处。</p><p id="0282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好处之一是避免加载单独的页面。浏览器不会通过HTTP加载另一个页面。相反，JavaScript注意到我们想要移动到另一个站点并呈现相关内容。</p><p id="6263" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，完整的路由过程，如处理URL参数，取决于我们开发的前端。我经常使用SPAs来构建动态页面，其内容应该根据URL参数或查询而变化。</p><p id="18b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，今天，服务器端渲染赶上了曾经是CSR优势的一切。例如，SSR在浏览应用程序时采用了平滑过渡，使用了页面预加载。因此，我们收到的应用程序实际上是一个单页应用程序，但在每个页面上都提供了SSR优势。</p><h2 id="ef9b" class="mu lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">客户端渲染的例子？</h2><p id="aa70" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">CSR背后的想法是，用JavaScript捆绑我们要呈现的HTML结构。你可能知道在像React或Vue这样的技术中，我们可以渲染几乎无限数量的元素。就拿这个Vue例子来说:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0f27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<em class="nn">项</em>有10个元素，我们将收到一个由10个<code class="fe no np nq mq b">&lt;li&gt;</code>元素组成的无序列表。问题是，我们只将这个语法发送到浏览器，而不是这个列表的实际HTML结构。这让我相信客户端渲染可能有一个优势:压缩巨大的列表，向浏览器发送更少的千字节。</p><p id="57a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我原本打算在本文中运行一个案例研究，然而，它变得太大了。呈现大列表的CSR与SSR现在是一篇7分钟的独立文章:</p><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/client-side-rendering-list-3b79e596668f"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">呈现巨大的数据列表——客户端呈现的好例子？</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">南车能比SSR有优势吗？</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><p id="3754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要在这里吊人胃口:DR:不，当涉及到巨大的列表时，客户端渲染并没有服务器端渲染的真正优势。服务器端压缩非常有助于最小化我们发送给浏览器的数千字节的巨大HTML结构。</p><h1 id="2c43" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="b985" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">服务器端呈现和预呈现的页面似乎比客户端呈现更有优势。我所知道的每种情况都有优势。那么，我会说客户端渲染是一个错误吗？</p><p id="fab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我同意使用它可能是一个错误。无论你写的是React，Vue，Angular，甚至是Svelte，都没有理由在产品中提供客户端渲染的页面。</p><p id="87d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我不会说客户端渲染是web开发历史上的一个错误。最终，这是其发展过程中的必要一步。感谢早期的CSR，我们得到了所有那些提供有用特性的库和框架。React、Vue、Angular，如果没有CSR，所有这些都不会存在。</p><p id="9c7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p><p id="bfcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于渲染网页的更多信息:</p><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/next-js-client-side-rendering-56a3cae65148"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">如何在Next.js中客户端呈现组件</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">以及为什么这真的有用</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="od l"><div class="oj l of og oh od oi kp nu"/></div></div></a></div><p id="4f1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>