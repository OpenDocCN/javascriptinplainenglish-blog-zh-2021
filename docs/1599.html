<html>
<head>
<title>Create a JIRA/Trello Clone with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React创建JIRA/特雷罗克隆体</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-trello-clone-with-react-6eca324f155a?source=collection_archive---------0-----------------------#2021-04-06">https://javascript.plainenglish.io/create-a-trello-clone-with-react-6eca324f155a?source=collection_archive---------0-----------------------#2021-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f146a20c0d805bdc96e7bec9a7d5f71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPby2AqZRil9pJaXBhhu9g.png"/></div></div></figure><p id="10c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你曾经在大型IT公司工作过，我相信你一定遇到过像JIRA或特雷罗这样的项目管理工具。这些工具利用<a class="ae kt" href="https://en.wikipedia.org/wiki/Kanban_(development)" rel="noopener ugc nofollow" target="_blank">看板</a>来创建工作流，将复杂的任务分解成单个的、更易管理的块。这些方法提高了效率和生产力，也使每个人都容易有效地协作。</p><p id="10b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇博文中，我们将使用React构建类似的东西。</p><h2 id="651a" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">设置</h2><p id="e989" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">如标题所述，在本教程中，我们将使用<strong class="jx io">反应堆</strong>。在一个空文件夹中创建一个新的react项目。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="7db9" class="ku kv in lx b gy mb mc l md me">npx create-react-app react-kanban</span></pre><p id="9c0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建项目后，在目录中安装这些依赖项。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="8ac2" class="ku kv in lx b gy mb mc l md me">npm i react-beautiful-dnd styled-components</span></pre><p id="dddd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://www.npmjs.com/package/react-beautiful-dnd" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">React beautiful dnd</strong></a>是一个令人惊叹的库，可以让你用最少的代码创建<strong class="jx io">拖放</strong>列表。它有很多特性，是一个全面的健壮的库，如果你想自己从头开始创建一个拖放列表，它可以消除很多顾虑。</p><p id="6576" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">样式化组件</strong> </a> <strong class="jx io"> </strong>是一个<strong class="jx io">‘CSS-in-JS’</strong>库，允许您在组件文件中添加样式。因为它是JS内部的CSS，所以您可以使用模板字符串有条件地样式化您的组件。<br/>(你不需要特别使用这个库，你可以使用任何你喜欢的样式模式。)</p><p id="6fa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在开始编写代码之前，让我们简要地浏览一下这个库的核心组件。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/df6b563b2b2f5cd44dbb22270cbf21e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*mcBQgUt_eh4BXA9r-H-zBA.gif"/></div></figure><p id="3837" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">DragDropContext组件是根容器，它基本上封装了您希望启用拖放功能的应用程序部分。</p><p id="5da6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">drop able</strong>顾名思义，就是一个部件可以掉落的块。</p><p id="7f47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个<strong class="jx io">可拖动的</strong>块可以四处拖动。</p><p id="e8b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这三个组件有它们自己的一套规则和属性，当我们在应用程序中创建它们时，我们需要遵守这些规则和属性。</p><h1 id="1b41" class="mg kv in bd kw mh mi mj kz mk ml mm lc mn mo mp lf mq mr ms li mt mu mv ll mw bi translated">步骤1:创建一个DragDropContext</h1><p id="1330" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">因为本教程主要关注如何构建拖放列表，所以我们不会涉及任何数据库或API调用。相反，我们将简单地为这个例子创建一个<strong class="jx io">虚拟数据集</strong>对象。这个对象应该给你在使用这个库时如何设置你自己的数据结构的要点。</p><p id="99b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在根目录下创建一个名为<strong class="jx io"> dataset.js </strong>的文件，复制下面的代码。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="98b4" class="ku kv in lx b gy mb mc l md me">const dataset = {<br/>  tasks: {<br/>    "task-1": { id: "task-1", content: "Content for task 1" },<br/>    "task-2": { id: "task-2", content: "Content for task-2" },<br/>    "task-3": { id: "task-3", content: "Content for task-3" },<br/>    "task-4": { id: "task-4", content: "Content for task-4" }<br/>  },<br/>  columns: {<br/>    "column-1": { id: "column-1", title: "Todo", taskIds: ['task-1']},<br/>    "column-2": { id: "column-2", title: "In progress", taskIds: ['task-2', 'task-3'] },<br/>    "column-3": { id: "column-3", title: "Review", taskIds: [] },<br/>    "column-4": { id: "column-4", title: "Completed", taskIds: ["task-4"] }<br/>},</span><span id="5cea" class="ku kv in lx b gy mx mc l md me">columnOrder: ["column-1", "column-2", "column-3", "column-4"]}</span><span id="e2f1" class="ku kv in lx b gy mx mc l md me">export default dataset</span></pre><p id="bcae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的数据集是一个简单的对象，有三个属性。</p><p id="e4a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">任务:我们列表中的单个任务项</strong> <br/>每个项都有一个id和一些文本内容。</p><p id="2477" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">列</strong> : <strong class="jx io">将包含任务的不同列<br/> </strong>每列都有一个id、一个标题和它将包含的任务id列表。</p><p id="62f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> ColumnOrder:列最初放置的顺序</strong></p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/b5c959628984bf5062eca9613c9d6281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MjzrOTEr6CCiznDPeEl9w.png"/></div></div></figure><p id="5a9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看这个截屏，我们有4列，有一些<strong class="jx io">预定义的顺序</strong>。这些列有自己的一组任务，可以从一列拖到另一列。</p><p id="90d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开App.js文件，并将其替换为以下代码。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">App.js</figcaption></figure><p id="fee6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经在这里导入了我们的数据集。我们还从react-beautiful-dnd导入了<strong class="jx io"> DragDropContext </strong>和<strong class="jx io">drop able</strong>。</p><p id="2b9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的组件中，我们首先在useState钩子中初始化数据集。</p><p id="f650" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们示例中的<strong class="jx io"> DragDropContext </strong>将是主容器。该组件需要一个名为<strong class="jx io"> onDragEnd </strong>的强制事件，每当<strong class="jx io">一个可拖动对象完成将</strong>从一点拖动到另一点时，该事件就会被触发。我们将在下一步定义这个方法。</p><p id="1c40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">drop able</strong>是DragDropContext中的一个容器，它将保存我们所有的列。</p><ul class=""><li id="5f83" class="nf ng in jx b jy jz kc kd kg nh kk ni ko nj ks nk nl nm nn bi translated">我们给它一个<strong class="jx io">dropbableid</strong>prop，它基本上充当可丢弃对象的唯一标识符。</li><li id="8adb" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">一个<strong class="jx io">方向</strong>道具可以让你在那个特定的方向拖放元素。所以对于列，我们想要水平地拖动它们<strong class="jx io"/>。</li><li id="96fb" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated"><strong class="jx io">类型</strong>道具描述了我们可投放的类型。该块的可删除类型将是<strong class="jx io">列</strong>。稍后我们将把<strong class="jx io">任务</strong>作为另一个可删除的类型。</li></ul><p id="6d4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个Droppable中，我们将有一个返回React组件的函数。(这就是可拖放和可拖动API的工作方式，它们<strong class="jx io">都期望一个函数返回一个React组件</strong>，作为子组件。)这个函数得到两个参数，<strong class="jx io">提供</strong>和<strong class="jx io">快照。</strong></p><p id="b239" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">容器</strong>组件，是我们使用样式化组件创建的组件。它只是我们的列的一个<strong class="jx io"> flex容器</strong>。</p><p id="5592" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它接受一些道具</p><ul class=""><li id="5243" class="nf ng in jx b jy jz kc kd kg nh kk ni ko nj ks nk nl nm nn bi translated"><strong class="jx io">provided . inner ref</strong>:<br/>为了使droppable正常工作，您必须将<strong class="jx io"> provided.innerRef </strong>绑定到ReactElement中尽可能高的DOM节点。我们这样做是为了避免使用ReactDOM查找DOM节点。</li><li id="2c4e" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated"><strong class="jx io">provided . dropbableprops:</strong><br/>这是一个对象，它包含需要应用到可拖放元素的属性。它需要应用到你应用<strong class="jx io"> provided.innerRef </strong>的同一个元素。</li></ul><p id="aa8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在容器内部，我们映射来自数据集中的<strong class="jx io"> columnOrder </strong>数组，并返回一个<strong class="jx io"> Column </strong>组件(我们将在后面创建它)以及一组属性:<strong class="jx io"> key </strong>(列id)、<strong class="jx io"> column </strong>(来自数据集的列数据)、<strong class="jx io"> tasks </strong>(来自数据集的任务数据)、<strong class="jx io"> index </strong>。</p><p id="23df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，在底部，我们提供了一个<strong class="jx io">占位符。</strong>用于在拖动过程中根据需要在Droppable中创建空间。当用户在不是主列表的列表上拖动时，需要这个空间。请确保将占位符放在您提供了引用的组件内。</p><p id="642e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在继续创建列组件之前，我们将在App组件中定义<strong class="jx io"> onDragEnd </strong>方法。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6434" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可能看起来有点复杂，但实际上并不复杂。我们将一个接一个地检查每个街区。<br/>作为论证我们得到一个<strong class="jx io">结果</strong>对象。这个结果对象有不同的属性，我们将从这些属性中使用<strong class="jx io">目的地</strong>、<strong class="jx io">源</strong>、<strong class="jx io">类型</strong>和<strong class="jx io"> draggableId </strong>。</p><p id="f200" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们先检查到<strong class="jx io">看看是否有目的地</strong>。如果没有，我们就直接从函数中返回。</p><p id="007a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们检查<strong class="jx io">用户是否从他开始的地方拖拽了一个组件到相同的位置</strong>。如果是，我们就退出函数。</p><p id="245d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仅当类型为<strong class="jx io">列</strong>时，即当您水平移动列时，下一个“if”程序块才会运行。如果我们在列内移动任务，这个块不会运行。所以在这个街区我们首先，</p><ul class=""><li id="9957" class="nf ng in jx b jy jz kc kd kg nh kk ni ko nj ks nk nl nm nn bi translated">复制一份我们的专栏。</li><li id="76ed" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">使用拼接将柱从其原始位置移除。</li><li id="5a6f" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">再次使用拼接将柱替换到新位置。</li><li id="66ad" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">取代我们州的这个新订单。</li></ul><p id="417b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(这种策略是重新排列数组中项目的一种方式。可以用自己的策略)</p><p id="ce99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在此if块列之后，当您拖动任务项时，您看到的任何代码都会被触发。</p><p id="4484" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们首先为我们的任务初始化一个<strong class="jx io">开始</strong>和<strong class="jx io">结束</strong>点。这些是从你<strong class="jx io">开始拖动任务到放下任务的点。</strong></p><p id="cc7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果你已经<strong class="jx io">在同一列</strong>中放下了一个任务，即改变了它的垂直顺序，我们运行一个类似的重新排列策略，就像我们在“如果”列块的情况下所做的那样。</p><p id="69a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相反，如果您<strong class="jx io">将任务放在不同的列</strong>中，我们必须<strong class="jx io">改变开始列数组和结束列数组</strong>的taskIds，因为每个数组(列)的任务计数现在已经改变。</p><p id="3b43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这基本上是我们希望发生的事情<strong class="jx io">翁德拉根</strong>。</p><p id="896e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们将创建我们的列组件。在根目录下创建一个名为<strong class="jx io"> Column.js </strong>的文件，并复制下面的代码。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f0d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个组件代表我们看板中的一个单独的列。它与我们的应用程序组件非常相似。</p><p id="ebcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有3个定义了一些样式的组件。<br/> -一个<strong class="jx io">容器</strong>，它基本上充当我们任务的<strong class="jx io">垂直</strong>伸缩容器。<br/> -显示列的<strong class="jx io">名称的<strong class="jx io">标题</strong>属性。<br/> -一个<strong class="jx io">任务列表</strong>，它将保存所有任务组件(将在此之后创建)</strong></p><ul class=""><li id="3a50" class="nf ng in jx b jy jz kc kd kg nh kk ni ko nj ks nk nl nm nn bi translated">可拖动组件类似于可拖放组件。我们传入<strong class="jx io"> draggableId </strong>和一个<strong class="jx io">索引</strong>属性给它。</li><li id="47fe" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">它也有一个函数返回一个React组件，就像一个Droppable。</li><li id="2a13" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">返回的组件是我们的容器。该容器将具有来自所提供参数的<strong class="jx io"> innerRef </strong>和<strong class="jx io"> draggableProps </strong>。(你可以在这里看到图案。)</li><li id="4408" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">我们还有一个带有<strong class="jx io">dragchandleprops</strong>的标题组件，因为我们只希望该列可以从标题部分拖动。</li><li id="66c1" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">然后，我们有一个类似的道具可丢弃的部分。任务将被放入这个可放置的部分。</li><li id="b7ab" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">TaskList组件将包含每一列的所有任务。TaskList组件用一些道具来呈现任务组件(将在下一步中创建)。<br/>我们还在这里使用了<strong class="jx io">快照</strong>属性来根据拖动状态改变列的颜色。</li></ul><p id="91d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，对于任务组件，在根目录下创建一个名为<strong class="jx io"> Task.js </strong>的文件，并复制下面的代码。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0289" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，非常类似于列组件，我们有一个可拖动的类似道具。我们有一个函数作为<strong class="jx io"> Draggable的子函数，它返回一个React组件。</strong></p><p id="b2e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个react组件是一个样式化的容器组件，就像我们在列组件文件中一样。我们将<strong class="jx io"> draggableProps </strong>、<strong class="jx io">dragchandleprops</strong>、<strong class="jx io"> innerRef </strong>传递给这个react元素。</p><p id="1412" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还使用<strong class="jx io"> snapshot.isDragging </strong>来检查可拖动的状态。使用它，我们可以有条件地设置任务背景的样式，向用户显示它正在被拖动，就像我们在Column组件中所做的那样。</p><p id="35c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果你打开你的终端，输入<strong class="jx io"> npm start，</strong>你会发现一个类似的应用程序。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/189bde71cc1e9e2269c8289983bd690b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*z99j3cubH97wXdcXvLptXg.gif"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Final project</figcaption></figure><h1 id="bb9d" class="mg kv in bd kw mh mi mj kz mk ml mm lc mn mo mp lf mq mr ms li mt mu mv ll mw bi translated">结论</h1><p id="47b2" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">就是这样！现在你有了一个用React beautiful dnd构建的功能看板。请随意调整代码，用一些额外的业务逻辑和更好的风格制作一个更好的版本。</p><p id="c56a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在<a class="ae kt" href="https://github.com/AkileshRao/react-kanban" rel="noopener ugc nofollow" target="_blank">这里</a>找到这个项目的代码。你可以在这里找到这个应用<a class="ae kt" href="https://ak-react-kanban.netlify.app/" rel="noopener ugc nofollow" target="_blank">的现场演示。如果您有任何与项目相关的疑问，请发表评论。我也经常在youtube上发布编程内容，所以一定要去看看，</a><a class="ae kt" href="https://t.co/IO2spWubW9?amp=1" rel="noopener ugc nofollow" target="_blank">这里</a>。干杯！</p><p id="3f56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nu">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nu">plain English . io</em></strong></a></p></div></div>    
</body>
</html>