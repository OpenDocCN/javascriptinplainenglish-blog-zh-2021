<html>
<head>
<title>Discovering the Web Storage Api in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中发现Web存储Api</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/discovering-localstorage-and-sessionstorage-56d047052dc7?source=collection_archive---------13-----------------------#2021-01-12">https://javascript.plainenglish.io/discovering-localstorage-and-sessionstorage-56d047052dc7?source=collection_archive---------13-----------------------#2021-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6023d42bab3cad6b5e8561184ee0abde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbz-ii84h83QBuPqEW1V5Q.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="3d68" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">JavaScript web存储对象，<code class="fe kq kr ks kt b">localStorage</code>和<code class="fe kq kr ks kt b">sessionStorage,</code>允许在浏览器中保存键/值对</h2></div><h1 id="89fd" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">介绍</h1><p id="9976" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated"><code class="fe kq kr ks kt b">localStorage</code>是用户浏览器上可用的键/值数据存储。和cookies一样，<code class="fe kq kr ks kt b">localStorage</code>只能为它的键和值存储字符串数据。该数据存储只能由该域中的JavaScript访问。</p><p id="765d" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">Cookies仍然有用，特别是对于认证，但是有时候使用<code class="fe kq kr ks kt b">localStorage</code>或<code class="fe kq kr ks kt b">sessionStorage</code>可能是更好的选择。</p><p id="b312" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">所有现代浏览器都支持<code class="fe kq kr ks kt b">localStorage</code>或<code class="fe kq kr ks kt b">sessionStorage</code>，你现在可以毫无问题地使用它们。</p><h1 id="eeb0" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">什么是Web存储API？</h1><p id="7d58" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">Web存储API 是一组使浏览器能够存储键/值对的机制。它被设计得比使用cookies更直观。</p><p id="a429" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">键/值对表示存储对象，它类似于对象，只是在页面加载期间保持不变，并且始终是字符串。您可以像访问一个对象一样访问这些值，或者使用<code class="fe kq kr ks kt b">getItem()</code>方法(稍后会详细介绍)。</p><h1 id="ada4" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">本地存储与Cookies</h1><p id="2bf4" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">如前所述，<code class="fe kq kr ks kt b">localStorage</code>与cookies的相似之处在于，两种机制都可以用来在HTTP请求之间在浏览器中存储数据。但是<code class="fe kq kr ks kt b">localStorage</code>和饼干是有区别的。</p><p id="c79a" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">Cookies是服务器可以存储在浏览器中的小块数据。浏览器将cookie和所有将来的HTTP请求一起发送到设置cookie的服务器。Cookies的总大小不能超过4KB。</p><blockquote class="mo mp mq"><p id="30db" class="lm ln mr lo b lp mi kc lr ls mj kf lu ms mk lx ly mt ml mb mc mu mm mf mg mh ij bi translated"><code class="fe kq kr ks kt b">localStorage</code>通过浏览器中执行的JavaScript进行设置。</p></blockquote><p id="eb9b" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><code class="fe kq kr ks kt b">localStorage</code>属性永远不会被发送到任何服务器——除非您显式地将它们从<code class="fe kq kr ks kt b">localStorage</code>中复制出来并附加到AJAX请求中。</p><p id="1353" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><code class="fe kq kr ks kt b">localStorage</code>可在浏览器中存储2MB至10MB的数据(根据来源-域名)。具体允许多少数据取决于浏览器。</p><blockquote class="mo mp mq"><p id="ac6d" class="lm ln mr lo b lp mi kc lr ls mj kf lu ms mk lx ly mt ml mb mc mu mm mf mg mh ij bi translated">5MB到10MB的限制是最常见的。</p></blockquote><h1 id="c120" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated"><code class="fe kq kr ks kt b">localStorage</code>和<code class="fe kq kr ks kt b">sessionStorage</code>的区别</h1><p id="4dca" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated"><code class="fe kq kr ks kt b">localStorage</code>和<code class="fe kq kr ks kt b">sessionStorage</code>非常相似，都有相同的API。</p><p id="9bf6" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">主要区别在于使用<code class="fe kq kr ks kt b">sessionStorage</code>时，数据只保存到窗口或标签关闭。</p><p id="fc54" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用<code class="fe kq kr ks kt b">localStorage</code>，数据将被持久化，直到用户手动清除浏览器缓存，或者直到您的web应用程序清除数据。</p><p id="ea96" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在本教程中，我们看到了一些使用<code class="fe kq kr ks kt b">localStorage api</code>的例子，创建、读取和更新键/值对，但是您可以将这些原则应用于使用<code class="fe kq kr ks kt b">sessionStorage</code>编写代码。</p><h1 id="5f36" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">创建新项目</h1><p id="aa3e" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">您可以使用<code class="fe kq kr ks kt b">setItem()</code>方法为<code class="fe kq kr ks kt b">localStorage</code>对象创建条目。</p><p id="96fa" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">对于<code class="fe kq kr ks kt b">setItem()</code>方法，我们需要传递两个参数，即<code class="fe kq kr ks kt b">key</code>和我们想要保存的值:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="fdd1" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">阅读项目</h1><p id="efef" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">要读取条目，请使用<code class="fe kq kr ks kt b">getItem()</code>方法。</p><p id="826d" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><code class="fe kq kr ks kt b">getItem()</code>方法接受一个必须是密钥的参数。该函数将以字符串形式返回相应的值:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1928" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">上面的代码将变量<code class="fe kq kr ks kt b">myItem</code>设置为等于<code class="fe kq kr ks kt b">'Value'</code>，这是<code class="fe kq kr ks kt b">key</code>的对应值。</p><h1 id="e38c" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">更新项目</h1><p id="e488" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">要更新现有的条目，我们可以简单地使用我们已经使用的<code class="fe kq kr ks kt b">setItem()</code>方法，它有两个参数，第一个是现有条目的键值，在我们的例子中是“greeting1”，而value参数是新条目:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="67cd" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">现在，<code class="fe kq kr ks kt b">greeting1</code>的<code class="fe kq kr ks kt b">localStorage</code>值是<code class="fe kq kr ks kt b">'Hello LocalStorage Again!'</code>而不是<code class="fe kq kr ks kt b">'Hello LocalStorage!'</code>。</p><h1 id="b86a" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">删除和清除项目</h1><p id="1f1b" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">您可以使用<code class="fe kq kr ks kt b">removeItem()</code>方法删除一个条目。<code class="fe kq kr ks kt b">removeItem()</code>方法接受一个参数，该参数将成为<code class="fe kq kr ks kt b">localStorage</code>对象的一个键:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="00ca" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">如果您想删除存储在<code class="fe kq kr ks kt b">sessionStorage</code>或<code class="fe kq kr ks kt b">localStorage</code>对象中的所有属性，您可以使用<code class="fe kq kr ks kt b">clear()</code>功能:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="0d6f" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">用JSON存储对象</h1><p id="3195" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">LocalStorage只能对其键和值使用字符串。如果我们试图存储任何其他类型的数据，它会在存储之前将其转换为字符串。当我们想要保存JavaScript对象时，这会带来一些意想不到的行为。</p><p id="2f2f" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">为了在LocalStorage中正确存储JavaScript对象，我们首先需要将对象转换为JSON字符串。</p><p id="424f" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">为此，我们使用内置的<code class="fe kq kr ks kt b">JSON.stringify()</code>函数。该函数的结果字符串将包含我们的JSON对象的所有属性。当我们使用<code class="fe kq kr ks kt b">setItem()</code>时，我们保存该函数的输出。</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c9d7" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">虽然<code class="fe kq kr ks kt b">personObj</code>是一个对象，但是<code class="fe kq kr ks kt b">JSON.stringify(personObj)</code>将它转换成一个字符串。所以<code class="fe kq kr ks kt b">personObj</code>现在是一个有效的<code class="fe kq kr ks kt b">localStorage</code>值。</p><p id="f709" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">现在我们的对象被保存为一个字符串值，所以如果我们调用<code class="fe kq kr ks kt b">getItem() </code>方法，我们将得到一个字符串，而我们的原始值是一个对象。</p><p id="be9e" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">感谢<code class="fe kq kr ks kt b">JSON.parse()</code>方法，我们可以返回到我们的原始对象，该方法获取JSON字符串并将它们转换成JavaScript对象。<code class="fe kq kr ks kt b">JSON.parse()</code>以<code class="fe kq kr ks kt b">.getItem()</code>为自变量:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="239f" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">现在<code class="fe kq kr ks kt b">item</code>被设置为等于<code class="fe kq kr ks kt b">key</code>的值。在前面的代码片段中，<code class="fe kq kr ks kt b">key</code>的值被设置为<code class="fe kq kr ks kt b">personObj</code>的字符串化版本。使用<code class="fe kq kr ks kt b">JSON.parse</code>将<code class="fe kq kr ks kt b">personObj</code>转换回一个对象。所以<code class="fe kq kr ks kt b">item</code>被设为等于<code class="fe kq kr ks kt b">personObj</code>作为对象，而不是字符串。</p><p id="5a1a" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">能够使用<code class="fe kq kr ks kt b">JSON.stringify</code>将数组和对象转换成字符串，然后使用<code class="fe kq kr ks kt b">JSON.parse</code>将它们转换回来是非常有用的。您还需要知道如何检查<code class="fe kq kr ks kt b">localStorage</code>是否为空。</p><h1 id="8e70" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">迭代项目</h1><p id="a918" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated"><code class="fe kq kr ks kt b">localStorage</code>和<code class="fe kq kr ks kt b">sessionStorage</code>对象不支持<code class="fe kq kr ks kt b">forEach</code>方法。</p><p id="4526" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">要迭代<code class="fe kq kr ks kt b">localStorage</code>中的项目，使用一个<code class="fe kq kr ks kt b">for</code>循环:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1598" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">迭代<code class="fe kq kr ks kt b">localStorage</code>项的问题是它们是用字符串键标识的，而不是用一个渐进的数字标识的，所以当你像上面一样使用for循环时，你不能直接访问这些项。</p><p id="42f0" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">解决方案很简单，来自于<code class="fe kq kr ks kt b">key()</code>方法，该方法将一个整数作为参数，并返回相应的键:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="30b0" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用<code class="fe kq kr ks kt b">getItem</code>方法返回<code class="fe kq kr ks kt b">key</code>的相应值:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="eb02" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">创建一条<code class="fe kq kr ks kt b">console.log</code>语句，将<code class="fe kq kr ks kt b">key</code>和<code class="fe kq kr ks kt b">value</code>打印到屏幕上:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5da8" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用<code class="fe kq kr ks kt b">for</code>循环遍历<code class="fe kq kr ks kt b">localStorage</code>时，<code class="fe kq kr ks kt b">key()</code>非常有用。并不是所有的浏览器都支持<code class="fe kq kr ks kt b">localStorage</code>。</p><h1 id="29bf" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">检查支持</h1><p id="a753" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">您可以通过使用<code class="fe kq kr ks kt b">if</code>语句检查<code class="fe kq kr ks kt b">window</code>对象上是否有<code class="fe kq kr ks kt b">localStorage</code>支持来测试它:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="247f" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">您也可以使用<a class="ae mn" href="https://caniuse.com/namevalue-storage" rel="noopener ugc nofollow" target="_blank">我可以使用……</a>网站来检查主流浏览器对<code class="fe kq kr ks kt b">localStorage</code>的支持。</p><h1 id="cbe9" class="ku kv jb bd kw kx ky kz la lb lc ld le kh lf ki lg kk lh kl li kn lj ko lk ll bi translated">结论</h1><p id="7497" class="pw-post-body-paragraph lm ln jb lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">您可以使用<code class="fe kq kr ks kt b">localStorage</code>或<code class="fe kq kr ks kt b">sessionStorage</code>对象来存储键/值对。</p><p id="fd6d" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">有一些方法可以让您与<code class="fe kq kr ks kt b">localStorage</code>中的项目进行交互。<br/>在本教程中，您创建、删除和更新了<code class="fe kq kr ks kt b">localStorage</code>中的条目。</p><p id="815c" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">您还使用JSON方法将数组和对象数据转换成字符串，然后再转换回来。</p><p id="8ed1" class="pw-post-body-paragraph lm ln jb lo b lp mi kc lr ls mj kf lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><em class="mr">感谢阅读！</em></p></div></div>    
</body>
</html>