<html>
<head>
<title>How to Make a Progressive Web App (PWA) With a Native Wrapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用原生包装器制作渐进式Web应用程序(PWA)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-a-pwa-with-a-native-wrapper-9308b5f70f65?source=collection_archive---------16-----------------------#2021-06-15">https://javascript.plainenglish.io/how-to-make-a-pwa-with-a-native-wrapper-9308b5f70f65?source=collection_archive---------16-----------------------#2021-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bdde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://medium.com/@kateshokurova" rel="noopener"> <em class="kj">由</em> </a> <a class="ae ki" href="https://blog.shakuro.com/wp-admin/edit.php?post_type=post&amp;author=36" rel="noopener ugc nofollow" target="_blank"> <em class="kj">康斯坦丁·博日科夫</em></a><em class="kj"/><a class="ae ki" href="https://medium.com/@kateshokurova" rel="noopener"><em class="kj">开发人员在</em> </a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/10c3cfc335b2e9a087cbafc5137588d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFilzvrvfo1OYHnhuZTQHA.jpeg"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">illustration by Jiani Ma</figcaption></figure><p id="58df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前段时间，我们写了一篇关于渐进式Web应用技术的商业价值和本质的文章。今天是时候深入一点技术细节，并向您展示如何通过几个步骤用PWA制作一个原生应用程序。</p><p id="d1bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重点是，虽然pwa速度快，比原生应用程序轻量级得多，而且通常更灵活，但它们有一些我们在上一篇文章中讨论过的限制，主要与它们不能出现在应用程序商店有关。因此，合乎逻辑的后续问题是，是否有可能采用PWA并使其看起来像一个原生应用程序，在应用程序商店中发布它，以及所有事情？有！事实上，我们已经提到过它，并讨论了它的好处和要求。是时候研究如何实际创建一个了。</p><h1 id="d22a" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何制作PWA</h1><p id="6b60" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">首先，让我们看看如何制作一个PWA。</p><p id="2265" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">重要注意事项:</strong>你的网站必须有SSL证书并支持HTTPS协议。不遵守这些要求，PWAs就无法工作。</p><p id="c295" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要知道，一个现代的PWA申请包括以下关键要素:</p><ul class=""><li id="e460" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">Manifest.json文件</li><li id="ec3a" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">服务人员。</li></ul><p id="91e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们仔细看看它们。</p><h1 id="669b" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Manifest.json</h1><p id="e058" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">这个文件的目的是告诉浏览器你的网站可以作为一个渐进的应用程序来执行。它包含应用程序的名称、图标和其他必要信息。你可以在这篇文章中找到更多关于它的参数<a class="ae ki" href="https://web.dev/add-manifest/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c668" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需添加Manifest.json文件，浏览器就会将您的网站视为PWA，并将其安装为移动应用程序。但到目前为止，它与真正的移动应用程序几乎没有共同之处。</p><h1 id="dd2f" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">服务人员(软件)</h1><p id="41da" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">简单来说，它是浏览器和你的网站之间的一层。服务工作者是后台执行的脚本，无法阻塞JavaScript执行线程，在单独的线程中执行。关键点在于，SW运行在<em class="kj"> worker </em>上下文中，并且不能访问文档对象模型(DOM)。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mr"><img src="../Images/1f59a8c21f9e6c524f18b24d02795c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8WOqd9umTniLaf-Q.png"/></div></div></figure><p id="9ac1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">服务工作者有自己的生命周期事件。你可以在这里找到更多关于他们的信息。</p><p id="712f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SW还允许您缓存和欺骗来自浏览器的网站请求。例如，知道你所有的CSS和JS文件没有改变，你可以缓存它们。在这种情况下，浏览器将从服务人员那里接收这些文件，而无需向您的站点发出请求。</p><p id="5506" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了方便在SW中使用cache工作，Google开发了一组<a class="ae ki" href="https://developers.google.com/web/tools/workbox" rel="noopener ugc nofollow" target="_blank"> workbox库</a>。本文后面显示的代码就是使用这些库编写的。Workbox提供了几种缓存策略，旨在满足各种各样的需求。你可以在<a class="ae ki" href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies#:~:text=A%20caching%20strategy%20is%20a,them%20in%20your%20service%20worker." rel="noopener ugc nofollow" target="_blank">谷歌开发者</a>上阅读更多关于这些策略的信息。</p><p id="70aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如何连接服务人员</strong></p><p id="643b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要连接SW，您需要使用浏览器API，它提供了一种注册workers的方法。通常，连接代码有一个通用的形式，你可以在这里熟悉<a class="ae ki" href="https://gist.github.com/andrew-bazhanov/5dae992c1b1eeb727800a27419100ce2#file-include-sw-js" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5c82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">带工具箱的缓存</strong></p><p id="b716" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如前所述，workbox提供了不同的缓存策略，每种文件类型都需要自己的策略。例如，字体文件最少受到更改，因此，它们可以设置为更长的过期时间。这实际上是一个非常宽泛的话题，我们建议你使用<a class="ae ki" href="https://gist.github.com/andrew-bazhanov/d65b8366ad7c0eacf371fa805ecd8efb#file-offline-sw-js" rel="noopener ugc nofollow" target="_blank">我们的例子</a>。</p><h1 id="e108" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何制作离线模式</h1><p id="afe7" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">为了使您的web应用程序更类似于本地应用程序，它必须能够在没有互联网连接的情况下工作。</p><p id="f599" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">完全离线</strong></p><p id="0f37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">全面离线模式的实现意味着缓存的本地化使用。并不是每个PWA应用程序都需要它，因为它可能需要很长时间。主要的想法是在缓存我们的应用程序的所有HTML页面，以及一些应用程序正常工作所需的后端响应。与此同时，我们需要让我们的web应用程序显示一个弹出窗口或提示来通知用户，并继续进一步处理缓存的数据。在本文中，您可以阅读更多关于服务人员和web应用程序<a class="ae ki" href="https://felixgerschau.com/how-to-communicate-with-service-workers/" rel="noopener ugc nofollow" target="_blank">之间的通信。</a></p><p id="38a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个主题很难进行更详细的分析，因为这种方法严重依赖于web应用程序本身的架构，并且没有一个普遍接受的实现。</p><p id="8b07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">离线叠加</strong></p><p id="a283" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个任务的实现几乎总是有相同的解决方案:在安装服务工作器的时候，它沿着HTML页面后面的某个路径发出请求，并缓存它。在没有互联网连接的情况下，页面内容将作为覆盖图显示给用户。我们建议在这个页面上添加一个带有<code class="fe ms mt mu mv b">`location.reload ()`</code>的刷新按钮，这样当用户确定他们的互联网连接已经恢复时，他们就可以更新应用程序而不必重启它。</p><p id="f6b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们建议在你的网站上创建一个<em class="kj">/离线</em>页面。然后用<a class="ae ki" href="https://gist.github.com/andrew-bazhanov/d65b8366ad7c0eacf371fa805ecd8efb#file-offline-sw-js" rel="noopener ugc nofollow" target="_blank">我们的例子</a>。</p><h1 id="1c45" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何启用PWA安装</h1><p id="e5e9" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">关于这一点<a class="ae ki" href="https://web.dev/customize-install/" rel="noopener ugc nofollow" target="_blank">这里有充足的信息</a>。</p><h1 id="45a0" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何使用PWA制作iOS和Android的原生应用</h1><p id="45e1" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">目标是在Google Play和app Store上发布一个App，PWA只能从浏览器安装。因此，我们需要一个包装PWA的包装，使它看起来像一个真正的本地交易。</p><p id="3656" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要开发这种应用，你需要有开发经验的人来开发iOS或Android。</p><h1 id="79c6" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">ios</h1><p id="3cce" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">对于本机包装器，我们需要创建一个iOS项目:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mw"><img src="../Images/65d81963849e6ba0c00eef8b91461ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XBycacWzML1gNTB7.png"/></div></div></figure><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mx"><img src="../Images/01e758f155453cdb5a21f96bdd234710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8tsc2dWRyIJb4KKm.png"/></div></div></figure><p id="b188" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在新创建的项目中，添加一个WKWebView。在这里，我们将展示我们的PWA应用程序。第一次启动并检查功能，只需调用</p><pre class="kl km kn ko gt my mv mz na aw nb bi"><span id="2ccc" class="nc lb in mv b gy nd ne l nf ng">let urlRequest = URLRequest(url: appURL)<br/> webView.load(urlRequest)</span></pre><p id="ea22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进一步的定制包括实现WKWebView委托方法。要使它完全可操作，定义3个方法就足够了。</p><p id="cadc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法1告诉我们应用程序已经完成加载，例如，我们可以隐藏进度条:</p><pre class="kl km kn ko gt my mv mz na aw nb bi"><span id="6374" class="nc lb in mv b gy nd ne l nf ng">func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!)</span></pre><p id="6c51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们向用户处理/显示加载错误:</p><pre class="kl km kn ko gt my mv mz na aw nb bi"><span id="65cd" class="nc lb in mv b gy nd ne l nf ng">func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error)</span></pre><p id="c4e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法允许我们拒绝或限制/重定向导航。在PWA应用程序的情况下，只允许通过属于PWA的URL导航，而将其余的URL留给Safari是有意义的。</p><pre class="kl km kn ko gt my mv mz na aw nb bi"><span id="58d2" class="nc lb in mv b gy nd ne l nf ng">func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) <br/>func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) {<br/>        guard let url = navigationAction.request.url else {<br/>            decisionHandler(.allow)<br/>            return<br/>        }<br/>        if let host = url.host, host.lowercased().contains(Constant.allowedHost) {<br/>            decisionHandler(.allow)<br/>        } else {<br/>            if UIApplication.shared.canOpenURL(url) {<br/>                UIApplication.shared.open(url, options: [:], completionHandler: nil)<br/>            }<br/>            decisionHandler(.cancel)<br/>        }<br/>    }</span></pre><p id="9110" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里找到完整的项目<a class="ae ki" href="https://gitlab.com/shakuro-public/ios_pwa_wrapper" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="3cc1" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">机器人</h1><p id="843d" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">根据我们的主题，您可以在Android上开发3种类型的应用程序:</p><ul class=""><li id="0f3e" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io"> WebView。</strong>此选项意味着启动您自己的浏览器来执行PWA。</li><li id="91c3" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">自定义选项卡。</strong>您的应用程序将使用用户自己的浏览器，而无需创建您自己的浏览器。这个选项适用于已经存在的本地应用程序，以及需要打开网页的情况。这种方法不太适合PWA执行，因为用户会看到浏览器工具栏。</li><li id="3ec9" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">可信网络活动(TWA) </strong>。实现PWA应用程序的标准。有了这个选项，您使用用户浏览器的方式使得他们不会注意到它，这与自定义选项卡相反。</li></ul><p id="aebd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，我们理解我们需要使用TWA方法，但是它的特点是什么呢？</p><ol class=""><li id="3b8f" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh nh mj mk ml bi translated">我们的TWA应用程序和浏览器有一个共同的上下文，这提供了以下优势:如果用户登录到web版本的应用程序，他们也登录到TWA，反之亦然。</li><li id="6e1d" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh nh mj mk ml bi translated">您不能将JavaScript代码注入页面。此外，无法访问PWA和服务器之间执行的内容和请求。这些限制确保了用户的安全。但是我们仍然可以通过查询参数传递数据。</li><li id="f7fa" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh nh mj mk ml bi translated">我们的PWA应用程序只能从引用头“知道”它是作为TWA启动的。而在iOS中，我们可以很容易地从<code class="fe ms mt mu mv b">`window.navigator.userAgent`</code>确定这一点。</li><li id="80bc" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh nh mj mk ml bi translated">我们仍然能够使用本机平台功能，例如推送通知。</li></ol><p id="d176" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了创建一个TWA，我们建议使用<a class="ae ki" href="https://github.com/GoogleChromeLabs/bubblewrap" rel="noopener ugc nofollow" target="_blank">泡泡糖</a>(对于网络开发者来说)，或者<a class="ae ki" href="https://github.com/GoogleChrome/android-browser-helper" rel="noopener ugc nofollow" target="_blank"> Android浏览器助手</a>。整个开发过程只包括对已经完成的项目进行配置，即对<code class="fe ms mt mu mv b">build.gradle</code>文件进行修改。您可以在这里阅读更多关于创建TWA <a class="ae ki" href="https://developers.google.com/web/android/trusted-web-activity/quick-start" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h1 id="12da" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何使用PWA发布本地应用程序</h1><h1 id="6162" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">应用商店</h1><p id="1b2e" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">苹果在他们的<a class="ae ki" href="https://developer.apple.com/app-store/submitting/" rel="noopener ugc nofollow" target="_blank">文档</a>中有关于向应用商店提交应用的详细信息。如果你需要一个有经验的开发人员一步一步的指导，网上有很多，像<a class="ae ki" href="https://codewithchris.com/submit-your-app-to-the-app-store/" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="78b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，经验告诉我们，最<a class="ae ki" href="https://developer.apple.com/app-store/review/#common-app-rejections" rel="noopener ugc nofollow" target="_blank">常见的应用拒绝原因</a>如下:</p><ul class=""><li id="f0cc" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">您严重违反了苹果的指导方针。</li><li id="3c86" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">应用程序没有足够的功能被认为是完整的。</li><li id="6408" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">缺乏关于该应用程序的足够信息。</li><li id="ecc5" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">您没有足够清楚地说明请求访问设备硬件或用户数据的目的。</li></ul><h1 id="cfab" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">谷歌游戏</h1><p id="e652" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">谷歌也发布了一组描述应用程序发布过程的文章。</p><p id="be91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，为了不显示浏览器界面(地址、菜单等。)在您的应用程序中将其添加到Google Play控制台后，您需要添加<a class="ae ki" href="https://domain.example/.well-known/assetlinks.json" rel="noopener ugc nofollow" target="_blank">此文件</a>包含以下内容:</p><pre class="kl km kn ko gt my mv mz na aw nb bi"><span id="02bc" class="nc lb in mv b gy nd ne l nf ng">[{<br/>   "relation": ["delegate_permission/common.handle_all_urls"],<br/>   "target": {<br/>       "namespace": "android_app",<br/>       "package_name": "com.company_name.twa.app_name",<br/>       "sha256_cert_fingerprints": ["96:00:...:8D"]<br/>   }<br/>}]</span></pre><p id="482d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ms mt mu mv b">package_name</code>参数必须与您在创建应用程序时指定的参数<code class="fe ms mt mu mv b">applicationId</code>相匹配。</p><p id="39ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ms mt mu mv b">sha256_cert_fingerprints</code>参数必须包含将应用添加到Google Play控制台后生成的证书，该证书可以通过<strong class="jm io">应用签名- &gt;应用签名证书- &gt; SHA-256证书指纹获得。</strong></p><h1 id="57f8" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">加分。如何制作原生推送通知</h1><p id="32a5" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">目前，创建和发送推送通知的最佳工具是Firebase，所以在下面的例子中，我们将使用这个特定的服务。</p><p id="b497" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您不打算使用PWA开发本机应用程序，那么您可以使用服务工作者工具来实现推送通知。Firebase提供了一篇关于它的详细文章。</p><p id="cbcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过SW实现推送通知的主要问题是用户必须同意，这可能会使他们不信任应用程序。这是因为服务人员会从用户访问的每个网站上下载。这种确认的存在是为了让他们避免被不请自来的通知轰炸。</p><p id="ad67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与SW不同，本机应用程序可以在没有用户许可的情况下发送通知，因为它们在安装时对此表示同意。</p><p id="4184" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们希望更详细地分析涉及使用本机应用程序的方法。</p><h1 id="f94b" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">机器人</h1><p id="decc" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">如前所述，Firebase已经退出竞争，我们的实现就是基于这项服务。</p><p id="3e3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在这里使用来自可用项目<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example" rel="noopener ugc nofollow" target="_blank">的代码示例。</a></p><p id="85ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> FCM连接</strong></p><p id="6d43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要将Google服务添加到我们的依赖项中:<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/build.gradle#L27" rel="noopener ugc nofollow" target="_blank"> bundle.gradle </a>和<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/build.gradle#L200" rel="noopener ugc nofollow" target="_blank"> app/bundle.gradle </a>。接下来，您需要下载google-services.json文件，您可以在本文中了解更多信息。将该文件放在<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/tree/main/app" rel="noopener ugc nofollow" target="_blank">应用程序</a>中。</p><p id="f3a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">添加通知图标</strong></p><p id="c1fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，Android风格指南坚持认为图标必须是一个面具，即白色，以便Android以后可以用任何颜色填充它。此外，图标应该有不同的大小。要创建图标，请打开资源管理器，按+然后按Image Asset。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b8730e4bf9132b2d17ed5edf786e741e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/0*7HMBnwiAdKzvkZOT.png"/></div></figure><p id="0b9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在出现的窗口中，选择图标类型作为通知图标，并根据您的需要配置图标。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nj"><img src="../Images/4b79f936dbcee19ff31b484a6aafef42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-Ca9NAkIQ84cji_0.png"/></div></div></figure><p id="2937" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建通知图标后，连接到<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/AndroidManifest.xml#L58" rel="noopener ugc nofollow" target="_blank">app/src/main/Android manifest . XML</a>中的Firebase。</p><p id="165a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">默认通知通道声明</strong></p><p id="a9cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当没有明确分配给通知的通道时，此通道接收通知。为此，我们需要将值添加到<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/res/values/srting.xml#L18" rel="noopener ugc nofollow" target="_blank"> values/string.xml </a>中，并将其连接到<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/AndroidManifest.xml#L63" rel="noopener ugc nofollow" target="_blank">app/src/main/androidmanifest . XML</a>。</p><p id="9e69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">FirebaseMessagingService</strong></p><p id="e9e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个类给了我们处理令牌接收的能力，以及在<code class="fe ms mt mu mv b">onMessageReceived</code>方法中接收数据消息的能力。你可以在这里找到一个类扩展<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/java/com/shakuro/twa_demo_app/FcmService.java" rel="noopener ugc nofollow" target="_blank">的例子</a>，以及了解更多关于它的<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/AndroidManifest.xml#L155" rel="noopener ugc nofollow" target="_blank">连接</a>。</p><ul class=""><li id="5009" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io"> onNewToken </strong></li></ul><p id="32a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装后第一次启动应用程序时，以及清除数据后启动应用程序时，都会调用此方法。这是我们必须获取令牌并将其保存在存储器中的地方，我们<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/java/com/shakuro/twa_demo_app/FcmService.java#L106" rel="noopener ugc nofollow" target="_blank">使用了</a> SharedPreferences。由于onNewToken是在应用程序启动后调用的，我们需要<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/java/com/shakuro/twa_demo_app/FcmService.java#L114" rel="noopener ugc nofollow" target="_blank">重启</a>应用程序，以便使用令牌进行启动。实际上，重启应用程序的过程是不可见的。</p><ul class=""><li id="5bef" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io">创建通知频道</strong></li></ul><p id="2769" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了简化示例，我们<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/java/com/shakuro/twa_demo_app/FcmService.java#L84" rel="noopener ugc nofollow" target="_blank">创建了</a>这种通知通道初始化方法，并将<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/java/com/shakuro/twa_demo_app/FcmService.java#L26" rel="noopener ugc nofollow" target="_blank">称为</a>。</p><ul class=""><li id="830c" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io">收到的on消息</strong></li></ul><p id="71a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了理解何时调用这个方法，让我们看看通知和数据消息之间的区别。</p><p id="22d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数据报文</p><ol class=""><li id="f0b9" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh nh mj mk ml bi translated">它的有效载荷只有数据。</li><li id="5577" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh nh mj mk ml bi translated">有效负载可以有任何字段(标题、正文是可选的)。</li><li id="3b27" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh nh mj mk ml bi translated">Firebase云消息(FCM)不显示通知。</li><li id="f7db" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh nh mj mk ml bi translated">它进入<code class="fe ms mt mu mv b">onMessageReceived</code>，在那里我们可以，例如，根据来自Firebase的数据创建一个定制的通知。</li></ol><p id="3adb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通知</p><ol class=""><li id="47d3" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh nh mj mk ml bi translated">通知中的有效负载是必需的，并且必须包含标题和正文。</li><li id="86d4" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh nh mj mk ml bi translated">它可以从数据中接收有效负载，如果用户单击通知，就可以在LauncherActivity中获得该有效负载。</li><li id="5f07" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh nh mj mk ml bi translated">FCM显示一个通知，我们不能干预(比如添加一个按钮)。</li></ol><p id="786d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从这些差异中，我们可以得出结论，这个方法只针对数据消息调用。</p><p id="1bca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，我们检查数据是否有有效载荷字段，然后调用传递<code class="fe ms mt mu mv b">remoteMessage</code>的<code class="fe ms mt mu mv b">createNotification</code>方法。</p><ul class=""><li id="284b" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io">创建通知</strong></li></ul><p id="8459" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，这个方法负责显示数据消息的通知。</p><ul class=""><li id="c109" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io"> id </strong></li></ul><p id="e07a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它不必是唯一的，但在将来，它可能是有用的，因为我们可以通过它的id找到并删除一个通知。</p><ul class=""><li id="9deb" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io">通知意图</strong></li></ul><p id="b5a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个点击通知时发生的事件，即启动(重新启动)一个应用程序，将数据URL传输到数据。您也可以通过putExtras传输任何数据。</p><ul class=""><li id="dc17" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io">行动意图</strong></li></ul><p id="54b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单击通知的(操作)按钮时发生的事件。</p><p id="325a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">扩展LauncherActivity类</strong></p><p id="6cc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们创建一个<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/java/com/shakuro/twa_demo_app/LauncherActivity.java#L23" rel="noopener ugc nofollow" target="_blank">geturlfromentintent</a>方法，负责从数据和附加内容中获取URL。我们在<code class="fe ms mt mu mv b">createNotification</code>中输入数据，而extras中的URL仅在发送带有<a class="ae ki" href="https://github.com/shakurocom/pwa-for-twa-notifications-example/blob/main/api/index.ts#L24" rel="noopener ugc nofollow" target="_blank">数据的通知时包含该数据:{ url } </a>。</p><p id="6989" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是重写getLaunchingUrl方法。它负责在应用程序启动时返回URL。此时，我们可以通过将令牌作为查询参数来修改URL。你可以在这里了解更多关于这种方法的信息<a class="ae ki" href="https://github.com/shakurocom/twa-notifications-example/blob/main/app/src/main/java/com/shakuro/twa_demo_app/LauncherActivity.java#L44" rel="noopener ugc nofollow" target="_blank">。在我们的示例中，我们从SharedPreferences获取令牌。请注意，令牌并不总是存在。最常见的是在应用程序安装后第一次启动时，我们已经在onNewToken子句中提到过。</a></p><h1 id="4c0a" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">ios</h1><p id="6a5c" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">与Android一样，Firebase是这项工作的最佳选择。</p><p id="ffcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目前，有两种方法可以将FCM令牌转移到PWA应用程序:</p><ul class=""><li id="2b19" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io"> JavaScript </strong></li></ul><p id="d5d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">WKWebview允许在应用程序页面上执行Javascript，因此我们可以在应用程序加载后随时将令牌传递给应用程序。</p><pre class="kl km kn ko gt my mv mz na aw nb bi"><span id="c688" class="nc lb in mv b gy nd ne l nf ng"><strong class="mv io">let</strong> jsStr: String = "window.appNotifications.token = '\(token)';"<br/>                actualSelf.webView.evaluateJavaScript(jsStr, completionHandler: { (_, <strong class="mv io">error</strong>) <strong class="mv io">in</strong><br/>                    <strong class="mv io">if</strong> <strong class="mv io">let</strong> actualError = <strong class="mv io">error</strong> {<br/>                        debugPrint(actualError)<br/>                    }<br/>                })</span></pre><ul class=""><li id="c15f" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io">加载PWA时通过URL参数传递令牌</strong></li></ul><p id="5fc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，在下载PWA之前，我们需要发出一个请求，并等待FCM令牌被接收。</p><pre class="kl km kn ko gt my mv mz na aw nb bi"><span id="9902" class="nc lb in mv b gy nd ne l nf ng">InstanceID.instanceID().instanceID { [<strong class="mv io">weak</strong> <strong class="mv io">self</strong>] (result, _) <strong class="mv io">in</strong><br/>            <strong class="mv io">guard</strong> <strong class="mv io">let</strong> actualResult = result <strong class="mv io">else</strong> {<br/>                <strong class="mv io">return</strong><br/>            }<br/>           debugPrint(actualResult.token)<br/>          // Load PWA URL here<br/>        }</span></pre><p id="2b0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从安全角度来看，这种方法更可取，但有几个缺点:</p><ul class=""><li id="fa70" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">如果Firebase SDK返回错误而不是<code class="fe ms mt mu mv b">instanceID</code>，令牌只能在下次启动应用程序时重新发送。</li><li id="cb27" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">启动应用程序时会有额外的延迟，因为我们需要等待令牌。</li></ul><p id="b52b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整的项目可在<a class="ae ki" href="https://gitlab.com/shakuro-public/ios_pwa_wrapper" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="2408" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">网</h1><p id="a4c6" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">本机包装器将FCM令牌传递给PWA令牌。然后，您必须将它发送到后端，使它将用户与设备相关联。为此，您可以使用上述令牌创建一个字段，并在需要时刷新它。</p><p id="be20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以点击查看示例<a class="ae ki" href="https://github.com/shakurocom/pwa-for-twa-notifications-example" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="185c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">由康斯坦丁·博日科夫、弗拉德·奥尼普琴科和凯特·绍库罗娃撰写</em></p><p id="62da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">【https://shakuro.com】最初发表于<a class="ae ki" href="https://shakuro.com/blog/how-to-make-a-pwa-with-a-native-wrapper" rel="noopener ugc nofollow" target="_blank"><em class="kj"/></a><em class="kj">。</em></p><p id="0cdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">更多内容请看</em><a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>