<html>
<head>
<title>JavaScript Regex Quantifiers in Under 10 Minutes? Seriously?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不到10分钟的JavaScript Regex量词？真的吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/seriously-javascript-regex-quantifiers-in-under-10-mins-f281146bfea2?source=collection_archive---------20-----------------------#2021-04-16">https://javascript.plainenglish.io/seriously-javascript-regex-quantifiers-in-under-10-mins-f281146bfea2?source=collection_archive---------20-----------------------#2021-04-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi jr"><img src="../Images/e47e4a43907a26f3173aa4b044fae9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hqahMpqrCjTQmNHmzyf1Q.png"/></div></div><figcaption class="kd ke gj gh gi kf kg bd b be z dk">Six different quantifiers to explore in regex.</figcaption></figure><h1 id="5b4a" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">介绍</h1><p id="e7c6" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">如果不使用被称为<strong class="lh io"> <em class="md">量词</em> </strong>的特殊概念，正则表达式是相当单调和累人的。</p><p id="1958" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">量词用来将一个模式复制给定的次数。</p><p id="3777" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">如果你被要求在一个测试字符串中匹配连续出现100次的字符<code class="fe mj mk ml mm b">'a'</code>,你会用100个a来构造一个表达式吗，或者更有效的方法？</p><p id="ae4c" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">在这一章中，我们将发现量词的细节，并看到大量的例子。所以，我们不要再浪费时间了，马上开始吧。</p><h1 id="b162" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">什么是量词？</h1><p id="cfd5" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">顾名思义，<strong class="lh io">量词</strong>是用来<em class="md">量化</em>给定模式的特殊字符。通过<em class="md">‘量化’</em>，我们的意思是模式被<strong class="lh io">复制了一定的次数</strong>。</p><p id="eb53" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">更具体地说，量词不仅仅量化某些给定的模式，而是量化紧接在它们前面的模式<em class="md">。</em></p><p id="be7c" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">因此，当我们需要匹配连续出现<em class="md"> n </em>次的模式时，我们可以使用量词，而不是手动重新输入模式那么多次。</p><p id="4d27" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">以量词+为例。它获取其先前的模式，并对其进行一次或多次量化。</p><p id="7ff5" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">这意味着表达式<code class="fe mj mk ml mm b">/a+/</code>将匹配字符串<code class="fe mj mk ml mm b">'a'</code>、<code class="fe mj mk ml mm b">'aa'</code>、<code class="fe mj mk ml mm b">'aaa'</code>等等，因为<code class="fe mj mk ml mm b">+</code>之前的模式，即<code class="fe mj mk ml mm b">a</code>，将在测试字符串中被查找一次或多次。</p><p id="9915" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">类似地，<code class="fe mj mk ml mm b">/ca+t/</code>将匹配字符串<code class="fe mj mk ml mm b">'cat'</code>、<code class="fe mj mk ml mm b">'caat'</code>、<code class="fe mj mk ml mm b">'caaat'</code>、<code class="fe mj mk ml mm b">'caaaat'</code>，以此类推。该表达式将查找一次或多次<code class="fe mj mk ml mm b">c</code>，然后是<code class="fe mj mk ml mm b">a</code>，最后是<code class="fe mj mk ml mm b">t</code>。</p><p id="905e" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">在这两个表达式中，我们说<code class="fe mj mk ml mm b">a</code>已经被范围从1到无穷大的<strong class="lh io"> </strong> <code class="fe mj mk ml mm b"><strong class="lh io">+</strong></code> <strong class="lh io"> <em class="md">量词</em> </strong>量化了<strong class="lh io"><em class="md"/></strong>(我们稍后将看到范围是如何工作的)。</p><p id="d484" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">正则表达式配备了比仅仅<code class="fe mj mk ml mm b">+</code>量词多得多的量词。下面给出了完整的列表。在接下来的例子中，我们将使用这里显示的每一个量词。</p><h1 id="8a68" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">* —零或更多</h1><p id="1893" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated"><code class="fe mj mk ml mm b">*</code>量词零次或多次寻找其前面的模式<strong class="lh io"/>。</p><p id="817a" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">与<code class="fe mj mk ml mm b">+</code>不同，它甚至匹配那些前面的表达式从未出现过的子字符串。其范围为<strong class="lh io"> 0-∞ </strong>。</p><p id="6001" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">比如<code class="fe mj mk ml mm b">/ca*t/</code>匹配字符串<code class="fe mj mk ml mm b">'ct'</code>、<code class="fe mj mk ml mm b">'cat'</code>、<code class="fe mj mk ml mm b">'caat'</code>、<code class="fe mj mk ml mm b">'caaat'</code>等等。注意这里的第一个匹配，即<code class="fe mj mk ml mm b">'ct'</code> —它有零个字符<code class="fe mj mk ml mm b">a</code>出现的<strong class="lh io">和仅匹配表达式<code class="fe mj mk ml mm b">/ca*t/</code>，而不是<code class="fe mj mk ml mm b">/ca+t/</code>。</strong></p><p id="d8af" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">这仅仅是因为<code class="fe mj mk ml mm b">+</code>需要至少出现一次其前面的模式，而<code class="fe mj mk ml mm b">*</code>至少不需要。</p><h1 id="7ad5" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak"> <em class="mn"> + —一个或多个</em> </strong></h1><p id="1412" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated"><code class="fe mj mk ml mm b">+</code>量词一次或多次寻找其前面的模式<strong class="lh io"/>。</p><p id="d887" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">其范围为<strong class="lh io"> 1-∞ </strong>。</p><p id="3651" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">例如<code class="fe mj mk ml mm b">/se+/</code>匹配字符串<code class="fe mj mk ml mm b">'se'</code>、<code class="fe mj mk ml mm b">'see'</code>、<code class="fe mj mk ml mm b">'seee'</code>、<code class="fe mj mk ml mm b">'seeee'</code>等等。然而<code class="fe mj mk ml mm b">/se+/</code>不会匹配字符串<code class="fe mj mk ml mm b">'s'</code>，因为那里没有<code class="fe mj mk ml mm b">e</code>。</p><h1 id="0577" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">？—零或一</h1><p id="19a6" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated"><code class="fe mj mk ml mm b">+</code>量词为<strong class="lh io">零个或一个出现</strong>寻找其前面的模式。这意味着它的范围是0-1。</p><p id="2bf6" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">因此，表达式<code class="fe mj mk ml mm b">/ca?t/</code>将只匹配字符串<code class="fe mj mk ml mm b">'ct'</code>和<code class="fe mj mk ml mm b">'cat'</code>，在测试字符串中分别出现0次和1次<code class="fe mj mk ml mm b">'a'</code>。</p><h1 id="6881" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">自定义范围</h1><p id="bbf9" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">除了量词<code class="fe mj mk ml mm b">+</code>、<code class="fe mj mk ml mm b">*</code>和<code class="fe mj mk ml mm b">?</code>的这些预定义范围，在正则表达式中，我们还有机会<strong class="lh io">创建自定义量词</strong>。</p><p id="0558" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">它们由花括号<code class="fe mj mk ml mm b">{}</code>和至少一个数字给出。</p><p id="3cf2" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">下面是自定义量词的工作原理:</p><p id="b55d" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">如果我们在大括号中只指定了一个值，比如<code class="fe mj mk ml mm b">{5}</code>，那么量词就会在测试字符串中查找<strong class="lh io">的前一个模式，其次数正好是</strong>的次数。例如,<code class="fe mj mk ml mm b">/c{2}t/</code>将只匹配子串<code class="fe mj mk ml mm b">'caat'</code>和两次出现的<code class="fe mj mk ml mm b">a</code>——没有别的。</p><p id="804b" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">另一方面，如果我们在大括号内用逗号分隔两个数字，如在<code class="fe mj mk ml mm b">{1,2}</code>中，量词在给定的<strong class="lh io">量化范围</strong>内寻找前面的模式。例如<code class="fe mj mk ml mm b">/ca{1,3}t/</code>将匹配子字符串<code class="fe mj mk ml mm b">'cat'</code>、<code class="fe mj mk ml mm b">'caat'</code>和<code class="fe mj mk ml mm b">'caaat'</code>——没有其他的。</p><p id="8a11" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">省略逗号后的结束值，就像在<code class="fe mj mk ml mm b">{0,}</code>中一样，使<strong class="lh io">成为一个开放范围的量词</strong>，即它从给定的数字开始，然后一直到无穷大。例如，<code class="fe mj mk ml mm b">/ca{3,}t/</code>将匹配至少出现3次<code class="fe mj mk ml mm b">a</code>的子字符串<code class="fe mj mk ml mm b">'caaat'</code>、<code class="fe mj mk ml mm b">'caaaat'</code>和<code class="fe mj mk ml mm b">'caaaaat'</code>——没有其他。</p><h1 id="5b63" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">这是它的乡亲们！</h1><p id="6dfa" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">本质上，这都是关于JavaScript正则表达式中的量词。</p><p id="1491" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">正如您可能从本文中体会到的，正则表达式的优势在于量化的概念。没有它，我们无法控制复杂模式的匹配，因为<em class="md">的东西可能会重复任意次</em>。</p><p id="9d0a" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">让我们以一个简单的任务来结束这篇文章。解决办法可以在<a class="ae mo" href="https://www.codeguage.com/courses/regexp/quantifiers" rel="noopener ugc nofollow" target="_blank"><em class="md">https://www.codeguage.com/courses/regexp/quantifiers</em></a><em class="md">找到。</em></p><h2 id="b5c1" class="mp ki in bd kj mq mr dn kn ms mt dp kr lq mu mv kv lu mw mx kz ly my mz ld na bi translated">编写一个表达式，在字符串中查找以下序列:</h2><h2 id="45dc" class="mp ki in bd kj mq mr dn kn ms mt dp kr lq mu mv kv lu mw mx kz ly my mz ld na bi translated"><code class="fe mj mk ml mm b">'1'</code>(出现一次或多次)，然后是<code class="fe mj mk ml mm b">'0'</code>(出现三次或三次以上)，最后是<code class="fe mj mk ml mm b">'2'</code>(正好出现三次)。</h2></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="de06" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><em class="md">原载于</em><a class="ae mo" href="https://www.codeguage.com/courses/regexp/quantifiers" rel="noopener ugc nofollow" target="_blank"><em class="md">https://www.codeguage.com/courses/regexp/quantifiers.</em></a></p><p id="ca6f" class="pw-post-body-paragraph lf lg in lh b li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><a class="ae mo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="md">更多内容敬请关注</em>. io</a></p></div></div>    
</body>
</html>