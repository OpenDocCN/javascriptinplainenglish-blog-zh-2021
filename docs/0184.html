<html>
<head>
<title>When Should You Use sinon’s Restore and Reset Functions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候应该使用sinon的恢复和复位功能？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/when-should-you-use-sinons-restore-and-reset-functions-bdbd39550a2f?source=collection_archive---------5-----------------------#2021-01-11">https://javascript.plainenglish.io/when-should-you-use-sinons-restore-and-reset-functions-bdbd39550a2f?source=collection_archive---------5-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2012" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在本文中，我们分析了sinon中的restore、reset、resetHistory和resetBehaviour函数的区别，以及它们的行为取决于我们的sinon fakes是匿名的还是包装了现有的属性。</h2></div><p id="4f4a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如他们自己的文档中的<a class="ae ky" href="https://sinonjs.org/releases/latest/sandbox/" rel="noopener ugc nofollow" target="_blank">所示，在与sinon合作时，一个非常常见的方法是调用函数<code class="fe kz la lb lc b">restore</code>作为Mocha的<code class="fe kz la lb lc b">afterEach</code>钩子的一部分。</a></p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="15a0" class="ll lm in lc b gy ln lo l lp lq">afterEach(function () {<br/>    // completely restore all fakes created through the sandbox<br/>    sandbox.restore();<br/>});</span></pre><p id="156a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这应该足以确保在新的测试开始时一切都恢复正常，并且它们不会相互影响，对吗？嗯，<strong class="ke io">有时候不是这样</strong>。</p><p id="4c0b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看下面的例子:</p><figure class="ld le lf lg gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="5b2b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来<code class="fe kz la lb lc b">restore</code>做得很好，除了<code class="fe kz la lb lc b">log.info</code>间谍的呼叫计数。作为第二个单元测试的一部分，我们期望它只被调用一次，但是结果是前一个单元测试的调用计数没有被正确地重置，并且间谍的<code class="fe kz la lb lc b">callCount</code>的值是<strong class="ke io"> 3 </strong>。</p><h1 id="1f97" class="lu lm in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">为什么sinon.restore不能像我预期的那样工作？</h1><p id="e5a7" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">如果我们看一下sinon spy的<code class="fe kz la lb lc b">restore</code>函数的文档，我们会读到以下内容:</p><blockquote class="mq mr ms"><p id="df49" class="kc kd mt ke b kf kg jo kh ki kj jr kk mu km kn ko mv kq kr ks mw ku kv kw kx ig bi translated">用原来的方法代替间谍。<strong class="ke io">仅在间谍替换现有方法</strong>时可用。</p></blockquote><p id="a66c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重点强调的句子是关键。sinon <strong class="ke io">中的<code class="fe kz la lb lc b">restore</code>函数只对替换现有方法</strong>的间谍和存根起作用，我们的间谍被创建为匿名(独立)间谍。</p><p id="0be7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，<code class="fe kz la lb lc b">restore</code>不会重置调用计数，随着spy函数在后续测试中被调用，调用计数将继续增加。</p><p id="754a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们如何让它发挥作用？</p><h1 id="ed65" class="lu lm in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">介绍复位和复位历史功能</h1><p id="21ca" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">如果我们查看文档，我们会发现间谍和存根具有以下一些功能:</p><ul class=""><li id="9282" class="mx my in ke b kf kg ki kj kl mz kp na kt nb kx nc nd ne nf bi translated"><code class="fe kz la lb lc b">resetHistory</code>:对于<strong class="ke io">间谍</strong>，复位状态；对于<strong class="ke io">存根</strong>，它重置历史调用。对于<strong class="ke io">沙箱</strong>，它重置沙箱中创建的所有存根的历史。</li><li id="dc29" class="mx my in ke b kf ng ki nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><code class="fe kz la lb lc b">resetBehavior</code>:仅适用于<strong class="ke io">存根</strong>和<strong class="ke io">沙箱</strong>，它重置存根的原始行为。</li><li id="2b0c" class="mx my in ke b kf ng ki nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><code class="fe kz la lb lc b">reset</code>:对于<strong class="ke io">存根</strong>，重置行为和历史；对于<strong class="ke io">沙箱</strong>，重置沙箱中创建的所有内容的内部状态。</li></ul><p id="a562" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，我们可以使用<code class="fe kz la lb lc b">resetHistory</code>函数来确保spy的调用计数在第一次测试后被重置，这样它的执行就不会与第二次测试冲突。我们可以将此作为摩卡<code class="fe kz la lb lc b">afterEach</code>钩子的一部分:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="df1f" class="ll lm in lc b gy ln lo l lp lq">afterEach(() =&gt; {<br/>    sandbox.restore();<br/><strong class="lc io">    log.info.resetHistory();</strong><br/>});</span></pre><p id="6693" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住:在<code class="fe kz la lb lc b">afterEach</code>挂钩中添加<code class="fe kz la lb lc b">sandbox.reset()</code>不会有帮助，但是如果我们将它添加到第一个单元测试的末尾，它是有效的——仍然没有弄清楚为什么会发生这种情况。</p><h1 id="b7f1" class="lu lm in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">或者只是避免使用匿名间谍</h1><p id="dbc7" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">这将是另一种选择。不使用匿名间谍:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="97b6" class="ll lm in lc b gy ln lo l lp lq">const log = {<br/>    info: sandbox.spy(),<br/>    error: sandbox.spy()<br/>};</span></pre><p id="f85f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有一个通用的日志模拟对象，并在其上安装间谍:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="88cd" class="ll lm in lc b gy ln lo l lp lq">const log = {<br/>    info: function () { /* Do nothing */ },<br/>    error: function () { /* Do nothing */ }<br/>};</span><span id="eda9" class="ll lm in lc b gy nl lo l lp lq">sandbox.spy(log, 'info');<br/>sandbox.spy(log, 'error');</span></pre><figure class="ld le lf lg gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/d09e795ee0c81f4db5e33b0364ab1128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XkpTPK1N3SpPBhmN"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@bernardhermant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bernard Hermant</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>