<html>
<head>
<title>Redux Best Practices for Creating Scaleable API Architectures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少创建可伸缩API架构的最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-scalable-api-architecture-in-frontend-dc6bdd13bbaf?source=collection_archive---------6-----------------------#2021-03-14">https://javascript.plainenglish.io/best-scalable-api-architecture-in-frontend-dc6bdd13bbaf?source=collection_archive---------6-----------------------#2021-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0309" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">停止在Redux操作中提取数据。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/732f77f503f1558105bbe6e56103f054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzQ4Z9vvMubVOKhj6w1-rQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="http://ihatereading.in/creativity" rel="noopener ugc nofollow" target="_blank">Scalable architecture design</a></figcaption></figure><h1 id="2847" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">当前形势</strong></h1><p id="148d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们经常对获取数据和如何连接前端应用程序和后端感到困惑，我们总是以阅读大量文章而告终。当从API获取数据时，我们更喜欢用Redux动作来获取数据，然后调度Redux动作来更新存储。这个逻辑并不完全错误，但它有以下后果:</p><ol class=""><li id="3314" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">获取数据更新/重新呈现整个应用程序，而不管数据是否与特定组件相关。</li><li id="9321" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">对用户反馈活动的控制越少，你就只能从API给用户更好的响应。例如显示加载程序、错误等。</li><li id="b9eb" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">Redux中的动作变得更加复杂，难以阅读。</li></ol><h1 id="9640" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">备选方案</strong></h1><p id="d8d5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">redux背后的主要逻辑是，我们将有一个存储，其中将存储组件之间共享的所有公共值，以及有助于调度任何数据以使用reducers更新存储的操作。我们的主要议程应该是让它像定义一样简单。</p><p id="85b3" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">求解步骤</p><ol class=""><li id="bf1f" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">分别添加所有API获取方法。</li><li id="95ca" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">为更新商店创建单独的操作。</li><li id="fe63" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">为每个动作命名，以便更好地理解。</li><li id="787a" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">调用组件内部的获取方法，并在API响应后通过action更新Redux存储。</li></ol><p id="4f77" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">在这种方法中，我们可以让用户更好地了解API的响应，最重要的是用户体验，例如，加载程序、错误、互联网连接或服务器正在维护中。这种问题在应用程序中经常出现，如果不能向用户提供更好的透明度，将会导致糟糕的用户体验。</p><h2 id="7e60" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated">执行</h2><p id="1d0d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将使用我们之前创建的一个存储库来解释架构。这里是repository = &gt;<a class="ae kv" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/NextJSArchitecture" rel="noopener ugc nofollow" target="_blank">https://github . com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/NextJSArchitecture</a></p><p id="43c1" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们已经解释了我们将遵循的架构，到达本文进行详细理解= &gt;<a class="ae kv" href="https://medium.com/nerd-for-tech/building-solid-next-js-architecture-a8c6702dc67d" rel="noopener">https://medium . com/nerd-for-tech/building-solid-next-js-architecture-a8c 6702 DC 67d</a>。我们已经为所有Redux动作、存储和reducers创建了一个名为“<strong class="lq ir">Redux”</strong>的文件夹。此外，我们还有另一个名为packages的文件夹，其中有一个文件夹<strong class="lq ir"> api </strong>文件夹。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d949ee8963076ed80c0e15227ef35cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*Rc4C_esi_ArXg0gc1Cvv6w.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">API folded inside packages</figcaption></figure><p id="cf3f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">现在，在api文件夹中，我们将根据您的需要创建子文件夹或文件。根据API的名称创建命名的文件，例如，如果您正在为仪表板获取"<strong class="lq ir">用户"</strong>数据，然后创建文件夹"<strong class="lq ir">用户</strong>"和文件名"<strong class="lq ir">仪表板</strong>或"<strong class="lq ir">用户数据</strong>"，尝试理解命名约定对于其他开发人员和您来说都不应该太难理解，所以请忽略名称的长度等等来命名它们。</p><p id="9572" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们将在“<strong class="lq ir">仪表板”中创建一个api方法“<strong class="lq ir">fetchUsersApi”</strong>。</strong>接下来<strong class="lq ir">，</strong>我们将使用axios发出api请求，或者在其中提取数据<strong class="lq ir">。</strong>我们将使用简单示例从JSONplaceholder获取API(<a class="ae kv" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">链接获取api) </a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/6821d0da0169e0afcb3aacb305de0d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Q46b_DZuX9TCsFwL0kHIA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">fetchUsers Method inside dashboard.js</figcaption></figure><p id="1679" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">现在，我们的独立API方法已经完成，根据您的需要，您可以返回这个"<strong class="lq ir"> fetchUsersApi "中的任何内容，</strong>例如，您可以返回响应对象本身，或者像<strong class="lq ir"> response.data </strong>等数据。</p><p id="98e8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">现在，最后一步是在组件内部调用这个API方法，所以出于开发目的，我在index.js文件内部调用了这个API方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/f4d1673f543820a40279df8b98880cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLM60vBzO5PXhCtjk5b5fg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Index.js</figcaption></figure><p id="85d3" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们从api获取用户，然后更新状态并显示列表，此外，我们还添加了一个加载文本，以便在API获取数据时提供适当的用户体验和反馈。</p><div class="kg kh ki kj gt ab cb"><figure class="ns kk nt nu nv nw nx paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/0b46ad05022bf35c295c9db551bf2338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*7a5oGxhQ-sInBE2grf6JxQ.png"/></div></figure><figure class="ns kk nt nu nv nw nx paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/c82110ae1a066364a0d19f9bf1e5d0f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*La0lpDYK5hlsxBXTecSWPQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk ny di nz oa">Loading in the left image and users list in the right image.</figcaption></figure></div><p id="f5ef" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">下一步也是最后一步是，我们如何将数据从API更新到Redux store，然后将数据从store显示到组件。</p><h1 id="1be5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">在Redux中存储来自API的数据</strong></h1><p id="8987" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将像现在一样获取数据，只增加一项，而不是直接在"<strong class="lq ir"> fetchUsers" </strong> method <strong class="lq ir">，</strong>中更新状态。我们将在这里调度我们的Redux操作，它将相应地更新商店。在商店更新后，我们将从商店中获取用户数据，然后在应用程序组件中更新我们的用户状态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/78cd5e30c606261924349d11f9abe39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTre7lxJjZ5kWhEMZKL0-g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Read the commented part.</figcaption></figure><p id="f9a6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">注释部分解释了从API获取数据并在reducer状态下设置响应数据的方法，然后获取reducer状态并更新组件useState挂钩以直接显示来自store的数据。</p><h1 id="1ca7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">结论</strong></h1><p id="85cb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我看来，这一原则相当可靠，因为我们通过仅获取仪表板页面的用户数据来消除更新/重新呈现整个应用程序的延迟，这创建了可重用的api方法，因为我们可以在任何需要的地方重用"<strong class="lq ir"> fetchUsersApi" </strong>。</p><pre class="kg kh ki kj gt oc od oe of aw og bi"><span id="89c2" class="nd kx iq od b gy oh oi l oj ok"><a class="ae kv" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/ApiArchitecture" rel="noopener ugc nofollow" target="_blank">https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/ApiArchitecture</a></span></pre><p id="2c90" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">感谢阅读，下次再见，祝大家愉快。</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/7204979985d527414aa26ee0814cbab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fc7xTBr7W9_By17CTwFo7w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="http://ihatereading.in" rel="noopener ugc nofollow" target="_blank">Our Website</a></figcaption></figure><h2 id="44b3" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated">让我们一起建造伟大的东西</h2><p id="e0a0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们可以帮助你把你的想法变成现实。给我们发电子邮件或访问网站进行联系。</p></div></div>    
</body>
</html>