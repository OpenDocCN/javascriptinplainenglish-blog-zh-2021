<html>
<head>
<title>Build a REST API with NestJS and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NestJS和MongoDB构建一个REST API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rest-api-with-nestjs-using-mongodb-58150eef02a8?source=collection_archive---------6-----------------------#2021-03-07">https://javascript.plainenglish.io/rest-api-with-nestjs-using-mongodb-58150eef02a8?source=collection_archive---------6-----------------------#2021-03-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/2d28f270f19a18d196c42a02cf8a8865.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*9tcadgJckrWkPQrKt_Hldg.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">NestJS + MongoDB</figcaption></figure><p id="1e22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嘿，伙计们，让我们创建一个NestJS REST API，但是在继续之前，请确保您已经先阅读了<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/getting-started-with-nestjs-application-overview-installation-setup-288e0e83c889">入门</a>文章。</p><p id="0ece" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上一篇文章中，我们已经熟悉了基本的NestJS概念，让我们开始连接数据库并创建一个实际的REST API。</p><h2 id="bf55" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">概述</strong></h2><p id="8259" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">对于数据库，您可以使用MySQL、MongoDB或PostgreSQL等，但对于本例，我们将使用MongoDB，为了将其与我们的应用程序连接，我们将使用<code class="fe ls lt lu lv b">mongoose</code>作为ODM，这允许我们与数据库连接，并在模式构建和验证方面提供了更大的灵活性。</p><p id="9ba6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">先决条件</strong></p><ul class=""><li id="06af" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">以前的经验与MongoDB，Mongoose将是有益的</li><li id="e550" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">REST API的基本知识</li><li id="6d0a" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">承诺的基本知识，异步等待。</li></ul><h1 id="cd5c" class="mk kv in bd kw ml mm mn kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na bi translated"><em class="nb">我们开始吧！</em></h1><p id="6a13" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">首先转到MongoDB，创建一个帐户并创建第一个数据库集群。</p><p id="f2c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦创建了数据库，让我们确保我们的IP地址在白名单中&amp;我们有一个数据库用户可以从我们的NestJS应用程序无缝地访问数据库。</p><p id="abba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要创建一个DB用户和白名单IP。</p><p id="7abb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">转到您的集群，然后单击<code class="fe ls lt lu lv b">connect</code>，这将提示您创建一个用户并允许IP地址访问数据库。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nc"><img src="../Images/ebcb6f751c019d3f3e2f2ae43b24a2fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vrxjrY-4JQdDXA22VZQ0g.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">MongoDB Cluster Options</figcaption></figure><p id="bb5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击<code class="fe ls lt lu lv b">Add Your Current IP Address</code>，它会将你当前的IP地址列入白名单，并允许你使用当前的IP地址进行连接。</p><p id="812b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完成后，通过添加用户名和密码为您的数据库创建一个用户，您也可以自动生成密码，然后单击选择连接方法。</p><p id="dcec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选择连接类型:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nl"><img src="../Images/51b7862ee768e6816f6b983870dde406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVbWsxeKVn2QHp3R7WFpYQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Connect your application</figcaption></figure><p id="a030" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦看到该屏幕，您需要选择第二个选项<code class="fe ls lt lu lv b">Connect your application</code>。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nm"><img src="../Images/28e31342e06ba735d28dd9ec5c0870f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5dh_jjo8-9afWQVoTHRCw.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Mongo URI model</figcaption></figure><p id="8de0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你将在这个屏幕上，它将向你显示一个mongo连接字符串，包含你的用户名和数据库的详细信息。</p><p id="c55b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">复制该字符串，用您的实际密码替换<code class="fe ls lt lu lv b">&lt;password&gt;</code>，并将<code class="fe ls lt lu lv b">myFirstDatabase</code>更改为适合您的用例的数据库名称。</p><p id="9b91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nn">注意:如果您的密码包含特殊字符，您应该对它们进行URL编码，否则您在从NestJS应用程序建立连接时将会遇到问题。</em></p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="6390" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从Mongo URI和mongoose创建数据库连接。为此，转到<code class="fe ls lt lu lv b">app.module.ts</code>并添加以下代码:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="ef0a" class="ku kv in lv b gy nz oa l ob oc">...<br/>import { MongooseModule } from '@nestjs/mongoose';</span><span id="3443" class="ku kv in lv b gy od oa l ob oc">@Module({</span><span id="f8eb" class="ku kv in lv b gy od oa l ob oc">  imports: [<br/>    MongooseModule.forRoot('mongodb+srv://db-admin:v0PYTcgsc91oHPUn@cluster0.m3i8w.mongodb.net/api-demo?retryWrites=true&amp;w=majority'),<br/>],<br/>  controllers: [AppController],<br/>  providers: [AppService],<br/>})</span><span id="9e40" class="ku kv in lv b gy od oa l ob oc">export class AppModule {}</span></pre><p id="32ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将通知应用程序，我们希望与数据库连接，因为这是我们的应用程序包含导入的主要模块，这将确保应用程序一启动就连接到数据库。</p><p id="9d5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们来看看您的项目，为我们的API端点创建一些文件，它们是<code class="fe ls lt lu lv b">*.controller.js</code>、<code class="fe ls lt lu lv b">*.module.js</code>、<code class="fe ls lt lu lv b">*.service.js</code>，因为我们需要定义模式，所以我们将使用<code class="fe ls lt lu lv b">*.model.js</code></p><p id="6016" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">转到<code class="fe ls lt lu lv b">src</code>目录并创建一个<code class="fe ls lt lu lv b">products</code>文件夹，并为该模块创建模型、模块、控制器和服务，一旦创建完成，将如下所示:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/6b0f40e58323b95d6e8ab463a24e9e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*GZX8usuDV5rF9draVkD9lw.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Product module</figcaption></figure><p id="59b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论需要哪一个与产品相关的端点，我们都将在控制器中创建它，但是要这样做，我们首先需要定义我们的产品模式。</p><p id="efca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们如何定义它的，在我们的例子中，我们的产品将有3个字段，名称、描述和价格，所以它将被定义如下，并且因为我们使用typescript，让我们确保我们为产品定义了接口，以便在我们需要时验证产品。</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="8412" class="ku kv in lv b gy nz oa l ob oc">import * as mongoose from 'mongoose';<br/><br/>export const ProductSchema = new mongoose.Schema({<br/>  name: { type: String, required: true },<br/>  description: { type: String, required: true },<br/>  price: { type: Number, required: true },<br/>});<br/><br/>export interface Product extends mongoose.Document {<br/>  id: string;<br/>  name: string;<br/>  description: string;<br/>  price: number;<br/>}</span></pre><p id="18d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在<code class="fe ls lt lu lv b">product.module.js</code>中添加代码，它包装控制器和服务，并在您的模块中导入所需的功能。</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="8a22" class="ku kv in lv b gy nz oa l ob oc">import { Module } from '@nestjs/common';<br/>import { MongooseModule } from '@nestjs/mongoose';</span><span id="a78b" class="ku kv in lv b gy od oa l ob oc">@Module({</span><span id="a863" class="ku kv in lv b gy od oa l ob oc">  imports: [<br/>    MongooseModule.forFeature([<br/>      { name: 'Product', schema: ProductSchema }<br/>    ]),<br/>  ],<br/>  controllers: [],<br/>  providers: [],<br/>});</span></pre><p id="2fd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们添加了ProductSchema作为这个特定特性的产品，并且我们通知模块，我们将在控制器、服务中需要这个模式，如果您的模块使用更多的模块、模式，您需要如上导入它们。</p><p id="5624" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在转到<code class="fe ls lt lu lv b">products.service.ts</code>，让我们将模型注入到构造函数中，所以让我们添加这段代码</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="aafd" class="ku kv in lv b gy nz oa l ob oc">...<br/>import { InjectModel } from '@nestjs/mongoose';<br/>import { Product } from './product.model';</span><span id="16e3" class="ku kv in lv b gy od oa l ob oc">@Injectable()<br/>export class ProductsService {<br/>  constructor(<br/>   @InjectModel('Product') private readonly productModel: Model&lt;Product&gt;,<br/>  ) {}<br/>}</span></pre><p id="3637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您需要确保您对<code class="fe ls lt lu lv b">@InjectModel(‘Product’)</code>的命名与您在<code class="fe ls lt lu lv b">product.module.js</code>中的命名相同。同样，这将是一个超模型模式，我们不会以任何方式修改它，我们保留了<code class="fe ls lt lu lv b">private</code>和<code class="fe ls lt lu lv b">readonly</code>。在<code class="fe ls lt lu lv b">Model&lt;&gt;</code>中传递的<code class="fe ls lt lu lv b">Product</code>不是mongo模式，它是我们已经定义的typescript接口。</p><p id="684c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们几乎已经涵盖了创建第一个端点的所有内容，所以让我们开始吧。我们将创建第一个POST端点，这将允许我们创建产品。</p><p id="a790" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">转到<code class="fe ls lt lu lv b">product.controller.ts</code>并添加以下代码:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="0d9b" class="ku kv in lv b gy nz oa l ob oc">import { Controller, Post, Body } from '@nestjs/common';</span><span id="109c" class="ku kv in lv b gy od oa l ob oc">@Controller('products')<br/>export class ProductsController {<br/>  constructor(private readonly productsService: ProductsService) {}<br/><br/>  @Post()<br/>  async addProduct(<br/>    @Body('title') prodTitle: string,<br/>    @Body('description') prodDesc: string,<br/>    @Body('price') prodPrice: number,<br/>  ) {<br/>    const generatedId = await this.productsService.createProduct(<br/>      prodTitle,<br/>      prodDesc,<br/>      prodPrice,<br/>    );<br/>    return { product };<br/>}</span></pre><p id="8175" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ls lt lu lv b">Controller</code>、<code class="fe ls lt lu lv b">Post</code>、<code class="fe ls lt lu lv b">Body</code>是NestJS提供的装饰器，同样我们也有其他REST API方法装饰器，我们也有<code class="fe ls lt lu lv b">Headers</code>和<code class="fe ls lt lu lv b">Params</code>的装饰器，你也可以创建你的<a class="ae kt" href="https://docs.nestjs.com/custom-decorators" rel="noopener ugc nofollow" target="_blank">自定义装饰器</a>，这将允许你在任何你需要的地方使用它们。</p><p id="1bdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让这个端点运行的最后一件事，正如你看到的，我们正在使用来自<code class="fe ls lt lu lv b">productsService</code>的<code class="fe ls lt lu lv b">createProduct</code>，但是我们还没有定义它，所以要定义它，请转到<code class="fe ls lt lu lv b">product.service.ts</code>并在<code class="fe ls lt lu lv b">constructor</code>下面添加<code class="fe ls lt lu lv b">createProduct</code>函数。</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="075f" class="ku kv in lv b gy nz oa l ob oc">...<br/>async createProduct(title: string, desc: string, price: number) {<br/>  const newProduct = new this.productModel({<br/>    title,<br/>    description: desc,<br/>    price,<br/>  });<br/>  const result = await newProduct.save();<br/>  return result;<br/>}</span></pre><p id="d42f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们将所有这些添加到我们的<code class="fe ls lt lu lv b">product.module.ts</code>中，以便我们的应用程序知道从哪里为这些端点提供服务，以及应该调用哪些服务，为此，添加以下代码:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="f794" class="ku kv in lv b gy nz oa l ob oc">...<br/><strong class="lv io">import { ProductsController } from './product.controller';<br/>import { ProductsService } from './product.service';</strong></span><span id="1726" class="ku kv in lv b gy od oa l ob oc">@Module({<br/>  imports: [<br/>    MongooseModule.<em class="nn">forFeature</em>([{ name: 'Product', schema: ProductSchema<strong class="lv io"> </strong>}]),<br/>  ],<br/><strong class="lv io">  controllers: [ProductsController],<br/>  providers: [ProductsService],<br/></strong>})</span></pre><p id="caea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就对了。您已经成功设置了您的第一个端点，现在让我们尝试使用来自<a class="ae kt" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>的这个端点。如果您还没有安装它，请先安装它并提出以下请求。</p><p id="2171" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nn">(提示:Postman可能会提示您创建一个帐户，但是您可以在不创建帐户的情况下使用它，检查窗口底部您会看到</em> <code class="fe ls lt lu lv b"><em class="nn">Skip Sign in</em></code> <em class="nn">选项。)</em></p><h2 id="d708" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">创建第一个请求</strong></h2><ul class=""><li id="0e9c" class="lw lx in jx b jy ln kc lo kg of kk og ko oh ks mb mc md me bi translated">创建新请求</li><li id="e6b4" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">将方法更改为<strong class="jx io">帖子</strong></li><li id="d12a" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">将URL改为指向您的NestJS服务器，在我们的例子中是<code class="fe ls lt lu lv b">localhost:3000</code></li><li id="1620" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">根据您的用途添加适当的端点，在我们的例子中是<code class="fe ls lt lu lv b">/products</code></li></ul><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oi"><img src="../Images/d766216d27838866da5db9677a84e073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CydMoYTduoMKDYxCGLLR_A.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">POST /products</figcaption></figure><ul class=""><li id="bd79" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">一旦你添加了所有这些细节，点击发送按钮，等待结果。如果您已经正确地添加了所有内容，适当地设置了数据库，您将看到以下结果。</li></ul><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oj"><img src="../Images/45bb63d7eae8417608c769780077a076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWS33COA0TT4kYaisZNH9A.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">POST /products response</figcaption></figure><p id="a9fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nn">(如果出现任何错误，请阅读错误，以了解问题并尝试调试该问题。如果您面临数据库连接问题，请确保您当前的IP地址在MongoDB集群上的白名单中。)</em></p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="9b47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们添加一个<strong class="jx io"> GET </strong>端点来检索我们添加的所有产品。</p><p id="1869" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ls lt lu lv b">products.service.ts</code>中创建一个新服务:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="7264" class="ku kv in lv b gy nz oa l ob oc">async getProducts() {<br/>  const products = await this.productModel.find().exec();<br/>  return products;<br/>}</span></pre><p id="dbcc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nn">(提示:如果您想修改您的产品以具有特定的字段，您可以循环通过</em> <code class="fe ls lt lu lv b"><em class="nn">products</em></code> <em class="nn">并决定您需要哪些字段)</em></p><p id="c6de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在添加一个控制器来利用这个服务，之后我们可以从邮递员那里调用它。在<code class="fe ls lt lu lv b">product.controller.ts</code>中添加以下代码</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="07ad" class="ku kv in lv b gy nz oa l ob oc">...<br/>@Get()<br/>async getAllProducts() {<br/>  const products = await this.productsService.getProducts();<br/>  return products;<br/>}</span></pre><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ok"><img src="../Images/0f07619a28add162d3b66dbd7b411e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0DCkm5KvsT4W56LCJpT0w.png"/></div></div></figure><p id="3597" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，到Postman创建一个指向<code class="fe ls lt lu lv b">localhost:3000/products</code>的<strong class="jx io"> GET </strong>请求，点击<strong class="jx io"> Send </strong>按钮查看响应，它应该是这样的:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ok"><img src="../Images/0f07619a28add162d3b66dbd7b411e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0DCkm5KvsT4W56LCJpT0w.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">GET /products example</figcaption></figure></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="863f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，下一步是什么？让我们尝试通过特定的ID来获取产品，并更新和删除产品。</p><p id="2399" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要通过ID获取产品，请在<code class="fe ls lt lu lv b">product.controller.ts</code>中添加以下代码:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="b243" class="ku kv in lv b gy nz oa l ob oc">@Get(':id')<br/>getProduct(@Param('id') prodId: string) {<br/>  return this.productsService.getProductById(prodId);<br/>}</span></pre><p id="aeb1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里查看Params的用法，我们从Params中提取ID，并使用该ID来检索特定的产品。我们还需要添加一个<code class="fe ls lt lu lv b">getProductById</code>服务，所以让我们将它添加到<code class="fe ls lt lu lv b">product.service.ts</code>中</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="c738" class="ku kv in lv b gy nz oa l ob oc">async getProductById(productId: string) {<br/>  const product = await this.findProduct(productId);<br/>}</span></pre><p id="0d85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您仍然需要定义<code class="fe ls lt lu lv b">findProduct</code>函数来确保这个端点工作良好！所以让我们继续把它添加到<code class="fe ls lt lu lv b">product.service.ts</code>里面</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="edb7" class="ku kv in lv b gy nz oa l ob oc">...<br/>private async findProduct(id: string): Promise&lt;Product&gt; {<br/>  let product;<br/>  try {<br/>    product = await this.productModel.findById(id).exec();<br/>  } catch (error) {<br/>    throw new NotFoundException(`Product with ID: ${id} does not exist.`);<br/>  }<br/>  if (!product) {<br/>    throw new NotFoundException(`Product with ID: ${id} does not exist.`);<br/>}<br/>  return product;<br/>}</span></pre><p id="6f5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个新的错误<code class="fe ls lt lu lv b">NotFoundException</code>，对吗？那是NestJS提供的错误处理，可以像下面这样导入:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="2e4e" class="ku kv in lv b gy nz oa l ob oc">import { NotFoundException } from '@nestjs/common';</span></pre><p id="303e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有许多其他可用的异常，您可以直接使用这些异常来为您处理那些错误案例！</p><p id="2f40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您可以点击来自postman的API，让我们创建一个新的请求<strong class="jx io"> GET </strong> <code class="fe ls lt lu lv b">localhost:3000/products/&lt;id&gt;</code>，用您创建的最近的产品ID替换<code class="fe ls lt lu lv b">&lt;id&gt;</code>，现在点击<code class="fe ls lt lu lv b">SEND </code>按钮，您应该会看到产品作为响应。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ol"><img src="../Images/32ce170f04dc770c9ac7b476b885ef45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1e_urJ0JoatsAv-KtcyFg.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">GET /product/:id</figcaption></figure></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="bf71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们添加一个<strong class="jx io">补丁</strong>请求:</p><p id="e1c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当更新一个产品时，我们需要用一个特定的ID来更新产品，这个ID将出现在<code class="fe ls lt lu lv b">params</code>中，新的数据将出现在<code class="fe ls lt lu lv b">body</code>中，所以让我们使用这两个装饰器并创建一个<strong class="jx io">补丁</strong>端点。</p><p id="3546" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内部<code class="fe ls lt lu lv b">product.controller.ts</code>:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="44fb" class="ku kv in lv b gy nz oa l ob oc">...<br/>@Patch(':id')<br/>async updateProduct(<br/>  @Param('id') productId: string,<br/>  @Body('name') productName: string,<br/>  @Body('description') productDesc: string,<br/>  @Body('price') productPrice: number,<br/>) {<br/>  const result = await this.productsService.updateProduct(<br/>    productId,<br/>    productName,<br/>    productDesc,<br/>    productPrice,<br/>  );<br/>  return result;<br/>}</span></pre><p id="134d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内部<code class="fe ls lt lu lv b">product.service.ts</code>:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="b4ce" class="ku kv in lv b gy nz oa l ob oc">...<br/>async updateProduct(<br/>  productId: string,<br/>  name: string,<br/>  desc: string,<br/>  price: number,<br/>) {<br/>  const updatedProduct = await this.findProduct(productId);<br/>  const result = await updatedProduct.update({<br/>    $set: {<br/>      name: name ? name : updatedProduct.name,<br/>      description: desc ? desc : updatedProduct.description,<br/>      price: price ? price : updatedProduct.price,<br/>    },<br/>  });<br/>  if (result.n === 0) {<br/>    throw new NotFoundException(`Product with ID: ${productId} does not exist.`,<br/>    );<br/>  }<br/>  return {<br/>    message: `A product with ID: ${productId} has been updated successfully`,<br/>  };<br/>}</span></pre><p id="d14c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很好，在使用这个API之前，让我们添加<strong class="jx io"> DELETE </strong>请求，一起尝试一下。</p><p id="9bb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先添加删除服务:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="15a7" class="ku kv in lv b gy nz oa l ob oc">...<br/>async deleteProduct(productId: string) {<br/>  const result = await this.productModel.deleteOne({ <br/>    _id: productId<br/>  }).exec();<br/>  if (result.n === 0) {<br/>    throw new NotFoundException(`Product with ID: ${productId} does not exist.`);<br/>  }<br/>  return {<br/>    message: `A product with ID: ${productId} has been updated successfully`,<br/>  };<br/>}</span></pre><p id="f09e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在为此添加一个控制器:</p><pre class="nd ne nf ng gt nv lv nw nx aw ny bi"><span id="6609" class="ku kv in lv b gy nz oa l ob oc">...<br/>@Delete(':id')<br/>async removeProduct(@Param('id') productId: string) {<br/>  const res = await this.productsService.deleteProduct(productId);<br/>  return res;<br/>}</span></pre><p id="01d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">瞧啊。您已经完成了，现在让我们前往postman，尝试这些端点，看看效果如何。</p><p id="b1d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个新的请求<strong class="jx io">补丁</strong> <code class="fe ls lt lu lv b">localhost:3000/products/&lt;id&gt;</code>，用您希望更新的产品ID替换<code class="fe ls lt lu lv b">&lt;id&gt;</code>。转到<code class="fe ls lt lu lv b">Body</code>选项卡，添加您希望更新的字段。在我们的例子中，我们正在更新名称和价格</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi om"><img src="../Images/35123870f44b2755301323c742a18145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KTuV-FxJfdAXBARdNNAAA.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">PATCH /products/:id</figcaption></figure><p id="96e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击相同产品的GET请求，查看您的产品是否已更新:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi on"><img src="../Images/0a74e1c437e365f80884d7cfa4b6e42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*895nJljB2ykd2vBQ3RCFZg.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">GET /products/:id</figcaption></figure><p id="781c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建更多的产品并尝试使用GET、PATCH端点，然后让我们尝试删除端点:</p><p id="2c01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建新请求<strong class="jx io">删除</strong> <code class="fe ls lt lu lv b">localhost:3000/products/&lt;id&gt;</code>，用您希望删除的产品ID替换<code class="fe ls lt lu lv b">&lt;id&gt;</code>，并点击发送按钮，这将从我们的数据库中删除该产品。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oj"><img src="../Images/7e9a2c88bea18a0ee03b9ba3ee365dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqmv6AMDqYlJcCNf1Z6P0Q.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">DELETE /products/:id</figcaption></figure><p id="3267" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以尝试一个随机ID来检查它是否抛出异常，也可以对PATCH和GET端点进行同样的尝试！😉</p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="f336" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">万岁，就是这样！现在您可以自己创建一个简单的REST API了！</p><p id="cc4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于更大规模的应用程序，你应该使用额外的装饰器和函数来确保它是<strong class="jx io"> <em class="nn">安全，快速&amp;可靠</em> </strong>！</p><h1 id="b716" class="mk kv in bd kw ml mm mn kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na bi translated">结论</h1><p id="aa39" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">感谢你阅读这篇文章。如果这有助于您创建第一个NestJS REST API，请在评论中告诉我。如果您正在寻找更多与开发相关的文章，请关注我！对于任何疑问，你可以在下面评论。</p><p id="d86e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢你，快乐阅读，并有一个好的！😄</p></div></div>    
</body>
</html>