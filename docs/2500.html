<html>
<head>
<title>7 JavaScript Interview Questions — Conceptual and Tricky</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7个JavaScript面试问题——概念性的和棘手的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-javascript-interview-questions-conceptual-and-tricky-debb2703ed63?source=collection_archive---------5-----------------------#2021-05-23">https://javascript.plainenglish.io/7-javascript-interview-questions-conceptual-and-tricky-debb2703ed63?source=collection_archive---------5-----------------------#2021-05-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5346a18b87f2cd97212a9a4dcc47f1bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRmfi7BqNAibBdqvsuGTqQ.png"/></div></div></figure><p id="7111" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将讨论一些常见的基于概念的JavaScript面试问题。有许多简单的问题乍看起来很棘手。清楚地理解这些概念可能有助于我们克服这些棘手的问题。</p><p id="78df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在参加了几次前端开发人员的面试后，我写了这篇文章。希望这能帮助你为面试做好准备…</p><blockquote class="kt ku kv"><p id="9e69" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> 1。理解闭包、超时和作用域的概念。</em> </strong></p><p id="acb4" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">闭包:</em> </strong>简单来说，这意味着一个函数内部的变量和属性是该函数独占的，但是该函数可以访问外部的属性。</p></blockquote><p id="f567" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这听起来很简单，但是当你的面试官问你一个基于类似下面代码的问题时，困难就出现了。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="28fe" class="lj lk in lf b gy ll lm l ln lo">for (var i = 0;  i &lt; 5;  i++) {<br/>    setTimeout(function log(){<br/>        console.log(i);<br/>    }, 1000);<br/>}</span></pre><p id="226a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不，上面代码的输出不是0 1 2 3 4。</p><p id="b4fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们运行这个时，它们都是5。原因是<code class="fe lp lq lr lf b">console.log(i)</code>会立即执行并引用console.log中(I)的值。然而，一秒钟后，整个循环已经经历了每一次迭代，变量(I)在每一次迭代中都被覆盖。</p><p id="4093" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，setTimeout函数创建一个函数(闭包),它可以访问其外部作用域，即包含索引(I)的循环。迭代之后，执行函数并打印出(I)的值，在循环结束时，该值为5。这里的问题是，在第一个setTimeout()运行的时候，(I)已经在5了，没有办法引用它。</p><p id="cf17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解决方案:</strong>解决此问题的两种简单方法是:</p><p id="8464" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">a.通过创建一个立即调用的函数表达式(IIFE):</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="cda0" class="lj lk in lf b gy ll lm l ln lo">for (var i = 0; i &lt; 5; i++) {<br/>   setTimeout((function(param){<br/>        console.log(i);<br/>    })(i), 1000);<br/>}</span></pre><p id="8de4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">b.通过使用ES6功能“let”，它为您提供了一个数据块范围。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4beb" class="lj lk in lf b gy ll lm l ln lo">for (let i = 0;  i &lt; 5;  i++) {<br/>    setTimeout(function log() {<br/>        console.log(i);<br/>    }, 1000);<br/>}</span></pre><p id="3417" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的解决方案工作得很好，也就是说，你得到的输出是0，1，2，3，4。</p><p id="6b8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">附加:</strong>此处输出同时显示。如果要求您让输出中的每个数字在一秒钟的间隔后显示出来，该怎么办？</p><p id="4bbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是解决办法。setTimeout的第二个参数需要乘以(I)。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="38d7" class="lj lk in lf b gy ll lm l ln lo">for (let i = 0;  i &lt; 5;  i++) {<br/>    setTimeout(function log() {<br/>        console.log(i);<br/>    }, i*1000);<br/>}</span></pre><blockquote class="kt ku kv"><p id="aeb9" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">②<em class="in">。理解使用数字数组的排序方法。</em> </strong></p><p id="682d" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"><em class="in"/></strong><em class="in"/>方法对数组中的元素进行排序并返回排序后的数组。默认的排序顺序是升序，基于<strong class="jx io">将元素转换成字符串</strong>，然后比较它们的UTF-16代码单元值序列。</p></blockquote><p id="064a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设有一组数字需要排序。下面的代码应该返回什么作为输出？</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d218" class="lj lk in lf b gy ll lm l ln lo">var myArray = [45,10,21,54,1,55,100];<br/>myArray.sort();</span></pre><p id="58e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你的猜测是这会输出为[1，10，21，45，54，55，100]，那么你就不对。不幸的是，对数字进行排序并不那么简单。如果我们将sort方法直接应用于numbers数组，我们将会看到一个意外的结果。</p><p id="4db4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，sort方法按字母顺序对元素进行排序。上面排序数字数组的方法不能正确排序数组。</p><p id="a638" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解决方案:</strong>数字排序添加一个新方法来处理数字排序。</p><p id="efc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">a.以下升序排序的输出:[1，10，21，45，54，55，100]</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c5c2" class="lj lk in lf b gy ll lm l ln lo">myArray.sort((a, b) =&gt; a - b);</span></pre><p id="6abe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">b.以下升序排序的输出:[100，55，54，45，21，10，1]</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="09dc" class="lj lk in lf b gy ll lm l ln lo">myArray.sort((a, b) =&gt; b - a);</span></pre><blockquote class="kt ku kv"><p id="88ee" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> 3。编写一个函数来检查给定的参数是偶数还是奇数，而不使用任何条件语句</em>T5】</strong></p><p id="3f50" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">这是一个逻辑问题，用来检验你解决某个问题的方法。</p></blockquote><p id="562b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">担心如何在不使用if-else或三元的情况下执行检查。嗯，这个解决方案很有趣，也很怪异，足以让你在面试中思考几分钟。</p><p id="80b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解决方案:这个问题的解决方案是使用数组或对象。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="5da0" class="lj lk in lf b gy ll lm l ln lo">function checkNumber(num){<br/>    const check = ['even', 'odd'];<br/>    console.log(`${num} is ${check[num%2]}`);<br/>}</span><span id="d391" class="lj lk in lf b gy ls lm l ln lo">checkNumber(6); // 6 is even<br/>checkNumber(5); // 5 is odd</span></pre><blockquote class="kt ku kv"><p id="a699" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> 4。Slice是一种内置的方法，可以用来在面试中欺骗你。</em>T11】</strong></p><p id="ee0d" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">我们都知道<strong class="jx io"> Slice() </strong>方法将数组的一部分的浅拷贝返回到一个从头到尾选中的新数组对象中。原始数组不会被修改。</p></blockquote><p id="09c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，如果我们在将新值压入数组之前使用slice while提取数组值，会发生什么情况呢？</p><p id="fc89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面给出的代码是执行的代码片段，它可能不会给你想要的输出。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="beab" class="lj lk in lf b gy ll lm l ln lo">var obj = {<br/>    name : 'Sourabh',<br/>    sports : ['Chess', 'Football', 'Snooker']<br/>}</span><span id="bdf8" class="lj lk in lf b gy ls lm l ln lo">var mySports= obj.sports.slice();<br/>obj.sports.push('Bowling');<br/>console.log(mySports);</span></pre><p id="5d5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你的猜测是输出为[“国际象棋”、“足球”、“斯诺克”、“保龄球”]，那你就错了。但是如果你的猜测是[“保龄球”]，那么是的，你又错了。</p><p id="a1b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解:</strong>输出为[“象棋”、“足球”、“斯诺克”]。</p><p id="a790" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原因是尽管数组是一个引用类型，我们仍然使用slice方法为数组创建一个新的引用指针。</p><blockquote class="kt ku kv"><p id="a19e" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> 5。识别全局和局部变量。</em>T19】</strong></p><p id="7d43" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">局部变量</strong>是在函数中定义的变量。它们有局部作用域，这意味着它们只能在定义它们的函数中使用。</p><p id="6741" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">全局变量</strong>是在函数之外定义的变量。这些变量具有全局范围，因此它们可以被任何函数使用，而不需要将它们作为参数传递给函数。</p></blockquote><p id="7300" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是需要识别全局和局部变量的代码。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d8be" class="lj lk in lf b gy ll lm l ln lo">function myFunc() {<br/>    let x = y = 0;<br/>    return x += 1;<br/>}</span><span id="0c68" class="lj lk in lf b gy ls lm l ln lo">myFunc();<br/>console.log(typeof x);<br/>console.log(typeof y);</span></pre><p id="7ce4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解:</strong>这里‘x’是局部变量，as‘y’是全局变量。</p><p id="3cc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，x的类型是“未定义的”。变量x存在于myFunc()范围内，在范围外不可用。其中y是值为0的全局变量，y的类型是“数字”。</p><p id="9280" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以像下面给出的那样理解上面的代码。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4f59" class="lj lk in lf b gy ll lm l ln lo">function myFunc() {<br/>    let x;<br/>    window.y = 0;<br/>    x= window.y;<br/>    return x+= 1;<br/>}</span><span id="f41d" class="lj lk in lf b gy ls lm l ln lo">myFunc();<br/>typeof x;<br/>typeof window.y;</span></pre><blockquote class="kt ku kv"><p id="88c5" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> 6。失去“这个”。</em>T3】</strong></p><p id="aa8c" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">‘this’</strong>关键字指的是一个对象，这个对象正在执行当前的javascript代码。换句话说，每个javascript函数在执行时都有一个对其当前执行上下文的引用，称为“this”。</p></blockquote><p id="7938" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是使用“this”来引用相同范围内的值的代码，它应该显示问候消息。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="57c1" class="lj lk in lf b gy ll lm l ln lo">let greeting = {<br/>    message: 'Good morning!', <br/>    name: 'Sourabh',</span><span id="bbd8" class="lj lk in lf b gy ls lm l ln lo">displayMessage() {<br/>        console.log(`Hello ${this.name}, ${this.message}`);<br/>    }<br/>};</span><span id="0641" class="lj lk in lf b gy ls lm l ln lo">setTimeout(greeting.displayMessage, 1000);;</span></pre><p id="c309" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不幸的是，它给出的输出是Hello undefined，undefined。</p><p id="e129" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，setTimeout()函数使用greeting.displayMessage作为回调，但它调用greeting.displayMessage作为常规函数，而不是方法。在常规的函数调用中，这相当于全局对象，在浏览器环境中是窗口。</p><p id="04a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解决方案:</strong>我们既可以使用包装函数，也可以使用内置方法bind。</p><p id="cf21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">a.使用包装函数。</p><p id="0ad9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将起作用，因为它从外部词法环境接收问候，然后正常调用该方法。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="37b1" class="lj lk in lf b gy ll lm l ln lo">let greeting = {<br/>    message: 'Good morning!', <br/>    name: 'Sourabh',</span><span id="54ac" class="lj lk in lf b gy ls lm l ln lo">displayMessage() {<br/>        console.log(`Hello ${this.name}, ${this.message}`);<br/>    }<br/>};</span><span id="40f7" class="lj lk in lf b gy ls lm l ln lo">setTimeout(function() {<br/>  greeting.displayMessage();<br/>}, 1000);</span></pre><p id="78d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">b.可以使用Bind关键字。</p><p id="a477" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们采用方法greeting.displayMessage并将其绑定到greeting。displayMessage是一个“绑定”函数，可以单独调用，也可以传递给setTimeout(没关系，上下文是对的)。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="514a" class="lj lk in lf b gy ll lm l ln lo">let greeting = {<br/>    message: 'Good morning!', <br/>    name: 'Sourabh',</span><span id="d54a" class="lj lk in lf b gy ls lm l ln lo">displayMessage() {<br/>        console.log(`Hello ${this.name}, ${this.message}`);<br/>    }<br/>};</span><span id="5f40" class="lj lk in lf b gy ls lm l ln lo">let welcomeMessage = greeting.displayMessage.bind(greeting);</span><span id="82e4" class="lj lk in lf b gy ls lm l ln lo">setTimeout(welcomeMessage, 1000);</span></pre><blockquote class="kt ku kv"><p id="46c6" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> 7。JavaScript中的单例模式</em> </strong></p><p id="2152" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">在JavaScript上下文中，Singleton是一个对象，用于创建名称空间并将一组相关的方法和属性组合在一起(封装)，如果我们允许启动，那么它只能启动一次。</p></blockquote><p id="0b5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我能想到的最简单的方法是创建一个消耗更少时间的单例模式，同时避免面试中的交叉提问，如下所示。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="cb82" class="lj lk in lf b gy ll lm l ln lo">function getInstance() {<br/>  if(typeof instance === 'object') {<br/>   console.log("object exists");<br/>    return instance;<br/>  }<br/>  instance = this<br/>}</span><span id="eabe" class="lj lk in lf b gy ls lm l ln lo">var a = new getInstance();<br/>var b = new getInstance(); // object exists<br/>var c = new getInstance(); // object exists</span></pre></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><p id="710b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您不知道这些，那么您可能至少在JavaScript知识方面有了一点进步。如果你都知道，那么希望这是一次练习和增长知识的尝试。</p><p id="36f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">祝你面试好运。享受阅读…谢谢！</p><p id="1d58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">最初发表于</em><a class="ae ma" href="https://codersread.com/improve-performance-of-web-application-react-js/" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://codersread.com</em></a></p><p id="d49c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">更多内容请看</em><a class="ae ma" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>