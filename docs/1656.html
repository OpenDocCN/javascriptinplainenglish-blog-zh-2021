<html>
<head>
<title>Scalable React: A Proposal with Lerna</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可伸缩React:与Lerna的一个提议</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/scalable-react-a-proposal-with-lerna-a3343a3fd3ae?source=collection_archive---------12-----------------------#2021-04-09">https://javascript.plainenglish.io/scalable-react-a-proposal-with-lerna-a3343a3fd3ae?source=collection_archive---------12-----------------------#2021-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c06b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">大型项目的React/Redux文件结构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2f3ca8a54f292e408f155da748cd401d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TH0KaGedU6N09E3GjwTnZg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lukechesser" rel="noopener ugc nofollow" target="_blank">lukechesser</a> on <a class="ae kv" href="https://unsplash.com/s/photos/growth" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="702c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是可扩展性</h1><p id="993e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于高风险的大型项目，可伸缩性是圣杯。很少完全实现，一篇优秀的论文把它分成四个部分。</p><p id="cf6b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">前三个不言自明:<strong class="lq ir">负载</strong>可伸缩性、<strong class="lq ir">性能</strong>可伸缩性、<strong class="lq ir">空间</strong>可伸缩性。</p><p id="844d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后一个可能更难理解，也是今天讨论的内容:<strong class="lq ir">结构性</strong>可伸缩性。从<a class="ae kv" href="https://www.win.tue.nl/~johanl/educ/2II45/2010/Lit/Scalability-bondi%202000.pdf" rel="noopener ugc nofollow" target="_blank">介绍<strong class="lq ir">可扩展性的特点及其对性能的影响</strong> </a>:</p><blockquote class="mp mq mr"><p id="0461" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">结构可伸缩性是一个系统在一个选定的维度上扩展而不需要对其架构进行重大修改的能力。</p></blockquote><p id="5f73" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从computertechreviews给出了另一个定义:</p><blockquote class="mp mq mr"><p id="2460" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">结构可伸缩性是系统的标志，其实现不会显著阻碍在自定义范围内增加对象的数量。</p></blockquote><div class="mw mx gp gr my mz"><a href="https://www.computertechreviews.com/definition/scalability/#Time-Spatial_Scalability" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">什么是可伸缩性？定义、类型、功能等</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">可伸缩性是一个IT系统的能力。系统能够适应硬件和软件性能的提高或降低…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.computertechreviews.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kp mz"/></div></div></a></div><p id="3c49" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在web应用程序的环境中，今天的基础设施和云计算服务使得获得<strong class="lq ir">负载</strong>、<strong class="lq ir">性能、</strong>和<strong class="lq ir">空间</strong>可伸缩性变得相当简单。现在，如何用更简单的术语定义<strong class="lq ir">结构</strong>可伸缩性，并实现它？</p><p id="211b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当谈到软件开发时，结构可伸缩性可以被看作是以稳定的速度添加新功能的能力。它意味着作为一个团队来计划、创造和交付。</p><p id="9638" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">常见实践有助于实现结构可伸缩性，其中包括:</p><ul class=""><li id="373d" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">版本控制系统(GIT、CVS)</li><li id="ba97" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">合适的自动化工作流(GitFlow、语义发布)</li><li id="8bdd" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">质量流程(SonarQube，…)</li><li id="5b55" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">证明文件</li><li id="2df7" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">测试</li></ul><p id="c41e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些实践解决了关于团队工作的问题。在某种程度上，它们也有助于保持从计划到交付的稳定速度。</p><h1 id="0baa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">React有什么问题</h1><p id="f26b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我在加入React project时面临的最大问题总是一样的:架构。在软件中，架构是最重要的基础之一。如果仓促行事，可能会在短短几个月内拖垮一个项目。</p><p id="c885" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在当今时代，许多制作精良的框架都是可用的，它们都带有自己的架构，旨在进行扩展。</p><p id="d83a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是React不在其中。 React是一个库，对你的组件和<a class="ae kv" href="https://reactjs.org/docs/faq-structure.html" rel="noopener ugc nofollow" target="_blank">文件结构</a>没有意见。同样的<a class="ae kv" href="https://redux.js.org/faq/code-structure" rel="noopener ugc nofollow" target="_blank">也适用于Redux </a>。</p><p id="e240" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">作为一名对软件架构和React充满热情的工程师，这几年来一直是一场噩梦。在我的旅程中，我从一个多年来不断改进的基本结构开始。</p><blockquote class="mp mq mr"><p id="e13d" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">我在这里的目的不是提供代码示例，而是讨论项目组织，重点是文件结构。</p><p id="a354" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">每个文件的内容，如何编写函数和组件，导出它们可以根据您喜欢的实践而改变。</p></blockquote><h2 id="33f4" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">开始</h2><p id="a8b6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">像每个人一样，我从一个基本项目和一个<strong class="lq ir">组件/ </strong>目录开始:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="4dbc" class="oc kx iq op b gy ot ou l ov ow">my-app<br/>├── src<br/>│   ├── components<br/>│       ├── Component.js<br/>├── package.json</span></pre><p id="08bd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">事实上…这是一个好的开始。当你只需要一个简单的图形来展示时，一个<strong class="lq ir">组件/ </strong>目录就可以完成这项工作。</p><p id="022c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们想要创建复杂的应用程序。我们的需求包括:</p><ul class=""><li id="fa37" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">使用<a class="ae kv" href="https://reactrouter.com/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank">导航</a>。</li><li id="a45e" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">存储<a class="ae kv" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">全局状态</a>。</li><li id="73b1" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">发送<a class="ae kv" href="https://axios-http.com/" rel="noopener ugc nofollow" target="_blank">请求</a>到我们的服务器。</li><li id="b1d9" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">编写<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型化的JavaScript </a>。</li></ul><h2 id="d8cc" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">航行</h2><p id="bf54" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有时候，简单更好。这就是为什么我添加了一个<strong class="lq ir">导航/ </strong>目录来处理导航。</p><p id="b6e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我使用一个<strong class="lq ir"> Routes </strong>组件来定义我的可能页面列表，一个<strong class="lq ir"> PublicRoute </strong>组件来处理连接用户不应该访问的页面，一个<strong class="lq ir"> PrivateRoute </strong>组件用于连接用户:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="7946" class="oc kx iq op b gy ot ou l ov ow">my-app<br/>├── src<br/>│   ├── components<br/>│       ├── Component.js<br/>│   ├── navigation<br/>│       ├── PrivateRoute.js<br/>│       ├── PublicRoute.js<br/>│       ├── Routes.js<br/>├── package.json</span></pre><p id="448f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我的<strong class="lq ir"> Routes </strong>文件中，我需要每页使用一个组件。开始时，它们位于<strong class="lq ir">组件/ </strong>目录中，但这产生了两个问题:</p><ul class=""><li id="b02d" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">当需要时，这些页面更难找到。</li><li id="ebfd" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated"><strong class="lq ir">组件/ </strong>目录已经存储了很多文件。</li></ul><p id="09fc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">相反，我创建了一个<strong class="lq ir"> screens/ </strong>目录，其唯一目的是存储页面专用的组件:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="8bf4" class="oc kx iq op b gy ot ou l ov ow">my-app<br/>├── src<br/>│   ├── components<br/>│       ├── Component.js<br/>│   ├── navigation<br/>│       ├── PrivateRoute.js<br/>│       ├── PublicRoute.js<br/>│       ├── Routes.js <br/>│   ├── screens<br/>│       ├── HomeScreen.js<br/>├── package.json</span></pre><h2 id="ffe3" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">Redux</h2><p id="3a36" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">关于<strong class="lq ir"> Redux </strong>，我是用一个常用的模式开始的。即使在今天，我还能看到它被我加入的团队使用，尽管对我来说，它更像是一种反模式。</p><p id="4050" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://redux.js.org/faq/code-structure" rel="noopener ugc nofollow" target="_blank"> Redux </a>将它作为大多数Redux开发人员倾向于使用的<em class="ms">常见模式来谈论</em>:</p><blockquote class="mp mq mr"><p id="8be8" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">Rails-style:用于“动作”、“常数”、“缩减器”、“容器”和“组件”的独立文件夹</p></blockquote><p id="9eeb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">实际上，如下所示:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="6b43" class="oc kx iq op b gy ot ou l ov ow">my-app<br/>├── src<br/>│   ├── store.js<br/>│   ├── components<br/>│       ├── Component.js<br/>│   ├── navigation<br/>│       ├── PrivateRoute.js<br/>│       ├── PublicRoute.js<br/>│       ├── Routes.js<br/>│   ├── screens<br/>│       ├── HomeScreen.js<br/>│   ├── actions<br/>│       ├── xActions.js<br/>│   ├── reducers<br/>│       ├── rootReducer.js<br/>│       ├── xReducer.js<br/>├── package.json</span></pre><p id="8daf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">很长一段时间，我的软件架构师告诉我有什么不对劲，但是我不知道具体是什么。</p><p id="74bf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">那是直到我一直在Redux文档上徘徊。我是不是说Redux没有怀孕？是的，除了最后一部分:<a class="ae kv" href="https://redux.js.org/style-guide/style-guide" rel="noopener ugc nofollow" target="_blank">风格指南</a>。</p><div class="mw mx gp gr my mz"><a href="https://redux.js.org/style-guide/style-guide" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">风格指南| Redux</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">这是编写Redux代码的官方风格指南。它列出了我们推荐的模式、最佳实践和…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">redux.js.org</p></div></div><div class="ni l"><div class="ox l nk nl nm ni nn kp mz"/></div></div></a></div><p id="4878" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">《Redux Style guide》的简介告诉我们以下内容:</p><blockquote class="mp mq mr"><p id="245c" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">Redux核心库和大部分Redux文档都是未绑定的。有很多种使用Redux的方式，而且很多时候都没有一种“正确”的方式来做事情。</p><p id="e17e" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">然而，时间和经验表明，对于某些主题，某些方法比其他方法更有效。此外，许多开发商要求我们提供官方指导，以减少决策疲劳。</p></blockquote><p id="63f2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">关于我们的目录，我们强烈建议<a class="ae kv" href="http://Structure Files as Feature Folders with Single-File Logic" rel="noopener ugc nofollow" target="_blank">将文件作为具有单文件逻辑的特征文件夹</a>:</p><blockquote class="mp mq mr"><p id="693e" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">虽然旧的Redux代码库通常使用“逐类型文件夹”的方法，将“动作”和“缩减器”分开，但是将相关的逻辑放在一起可以更容易地找到和更新代码。</p></blockquote><p id="f707" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该文档甚至给了我们两种以这种方式实现Redux的方法:<a class="ae kv" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux Toolkit </a>和<a class="ae kv" href="https://github.com/erikras/ducks-modular-redux" rel="noopener ugc nofollow" target="_blank">duck</a>。这些都是很好的解决方案，在类型上比我们的文件夹要好，但是我没有使用它们中的任何一个。原因是，我喜欢<a class="ae kv" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>，它可以解决我所有的副作用问题。</p><p id="1e8a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Redux Toolkit改为与Redux Thunk一起工作。另一方面，即使Ducks <a class="ae kv" href="https://github.com/cyrilluce/saga-duck" rel="noopener ugc nofollow" target="_blank">给出了Redux Thunk </a>的例子，也有人建议使用Redux-Saga 实现<a class="ae kv" href="https://github.com/cyrilluce/saga-duck" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d8f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不幸的是，这个实现很重，没有说服我。相反，我保留了每个功能都有一个<strong class="lq ir"> store/ </strong>文件夹和另一个文件夹的想法，同时仍然分离文件类型:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="28a0" class="oc kx iq op b gy ot ou l ov ow">my-app<br/>├── src<br/>│   ├── components<br/>│       ├── Component.js<br/>│   ├── navigation<br/>│       ├── PrivateRoute.js<br/>│       ├── PublicRoute.js<br/>│       ├── Routes.js<br/>│   ├── screens<br/>│       ├── HomeScreen.js<br/>│   ├── store<br/>│       ├── store.js<br/>│       ├── rootReducer.ts<br/>│       ├── xFeature<br/>│           ├── actions.js<br/>│           ├── reducer.js<br/>│           ├── saga.js<br/>├── package.json</span></pre><h2 id="4675" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">要求</h2><p id="10b7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我开发的每个应用程序都需要以某种方式获取外部数据。最常见的用例是使用<a class="ae kv" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>从web服务请求数据。</p><p id="3676" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里没有什么复杂的，我仍然通过使用一个<strong class="lq ir">服务/ </strong>文件夹将相关的逻辑放在一起，每个公共端点一个文件。</p><p id="6b27" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，在一个博客应用程序中，我将有一个文件专用于登录，另一个文件专用于创建和获取文章。</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="1e06" class="oc kx iq op b gy ot ou l ov ow">my-app<br/>├── src<br/>│   ├── components<br/>│       ├── Component.js<br/>│   ├── navigation<br/>│       ├── PrivateRoute.js<br/>│       ├── PublicRoute.js<br/>│       ├── Routes.js<br/>│   ├── screens<br/>│       ├── HomeScreen.js<br/>│   ├── store<br/>│       ├── store.js<br/>│       ├── rootReducer.ts<br/>│       ├── xFeature<br/>│           ├── actions.js<br/>│           ├── reducer.js<br/>│           ├── saga.js<br/>│   ├── services<br/>│       ├── xService.js<br/>├── package.json</span></pre><h2 id="17c6" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">以打字打的文件</h2><p id="30de" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我使用TypeScript时，我的结构需要一点小小的改变。主要是用<strong class="lq ir">重命名我的文件。ts </strong>扩展并添加一个<strong class="lq ir">类型/ </strong>文件夹:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="c7c9" class="oc kx iq op b gy ot ou l ov ow">my-app<br/>├── src<br/>│   ├── components<br/>│       ├── Component.tsx<br/>│   ├── navigation<br/>│       ├── PrivateRoute.tsx<br/>│       ├── PublicRoute.tsx<br/>│       ├── Routes.tsx<br/>│   ├── screens<br/>│       ├── HomeScreen.tsx<br/>│   ├── store<br/>│       ├── store.ts<br/>│       ├── rootReducer.ts<br/>│       ├── xFeature<br/>│           ├── actions.ts<br/>│           ├── reducer.ts<br/>│           ├── saga.ts<br/>│   ├── services<br/>│       ├── xService.ts<br/>│   ├── types<br/>│       ├── xType.ts<br/>├── package.json<br/>├── tsconfig.json</span></pre><h2 id="f0f2" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">完成</h2><p id="3778" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我不时会遇到新的问题。</p><p id="c6e5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，使用环境变量和其他指定的值。为了以一致的方式访问这些值，我决定添加一个<strong class="lq ir"> constants/ </strong>目录。同样，将公共值保存在同一个文件中。</p><p id="c56c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我开始需要定制方法来测试、转换对象或处理函数。这些不是库，而是我的应用程序所需的小函数。我想出了一个<strong class="lq ir"> utils/ </strong>目录和每期一个文件。</p><p id="e948" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我意识到<strong class="lq ir"> utils </strong>被认为是一种反模式，在OOP中可能更多。在我们的JavaScript用例中，utils模块的良好设置对我来说是可以接受的。</p><p id="6358" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，对于专用于给定特性的React组件，我可以很容易地在<strong class="lq ir"> components/ </strong>中创建子目录。但是常见的反应元件如<strong class="lq ir">按钮</strong>或<strong class="lq ir">卡</strong>呢？我没有把它们存储在根目录下的<strong class="lq ir">组件/ </strong>目录中，而是很快发现了片段的概念。</p><p id="230f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在每个应用中重复使用公共组件可以存储在<strong class="lq ir">片段/ </strong>子目录中:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="8c33" class="oc kx iq op b gy ot ou l ov ow">my-app<br/>├── src<br/>│   ├── components<br/>│       ├── fragments<br/>│           ├── Button.tsx<br/>│       ├── Component.tsx<br/>│   ├── constants<br/>│       ├── xConstants.ts<br/>│   ├── navigation<br/>│       ├── PrivateRoute.tsx<br/>│       ├── PublicRoute.tsx<br/>│       ├── Routes.tsx<br/>│   ├── screens<br/>│       ├── HomeScreen.tsx<br/>│   ├── store<br/>│       ├── store.ts<br/>│       ├── rootReducer.ts<br/>│       ├── xFeature<br/>│           ├── actions.ts<br/>│           ├── reducer.ts<br/>│           ├── saga.ts<br/>│   ├── services<br/>│       ├── xService.ts<br/>│   ├── types<br/>│       ├── xType.ts<br/>│   ├── utils<br/>│       ├── xUtils.ts<br/>├── package.json<br/>├── tsconfig.json</span></pre><h1 id="1ad0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">勒娜呢。</h1><p id="5e0c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">以前的结构对我这边的很多项目来说都很棒。我和几个中小型团队一起工作了几个月，效率很高。</p><p id="245f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是更大规模的项目呢？花费数年时间和数十(或数百)名开发人员开发更多功能的开发？</p><p id="2fb8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我很确定，在某个时候，添加一个特性的时间会成倍增加，开发成本也会成倍增加。这是我开始对一个我讨厌的工具感兴趣的主要原因:<em class="ms"> Lerna </em>。</p><div class="mw mx gp gr my mz"><a href="https://lerna.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">一个用多个包管理JavaScript项目的工具。</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">将大型代码库分割成单独的独立版本包对于代码共享非常有用…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">lerna.js.org</p></div></div></div></a></div><h2 id="e472" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">概观</h2><blockquote class="mp mq mr"><p id="d06f" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">将大型代码库分割成单独的独立版本包对于代码共享非常有用。然而，跨许多存储库进行变更是很麻烦的，并且难以跟踪，跨存储库的测试很快变得复杂。</p></blockquote><p id="4bd9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在实践中，Lerna帮助您在一个单一的GIT存储库中创建和管理一个被分割成多个模块的项目。例如:</p><ul class=""><li id="be84" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">您有一个依赖于后端应用程序的前端，但在保持同步和维护这两个存储库方面有困难。Lerna可能是一个很好的解决方案。</li><li id="23d6" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">同样，您可能有一个依赖于多个库的复杂应用程序。与其分别维护应用程序和每个包，不如为它们创建一个单独的存储库，并用Lerna管理一切，这样可以节省时间。</li></ul><p id="58c2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">根据我的经验，Lerna是在浪费时间。它应该有助于分离和链接模块，执行所有包的命令(如测试或质量检查)并提供其他实用程序。</p><p id="5d6f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我所面临的是时间的流失。事实上，我见过Lerna的项目中管道配置很差。这导致当只有一个模块被更新时，启动所有模块的QA和/或部署过程，即使那些模块没有受到影响。此外，单一回购结构混乱且难以操作，真是一场噩梦。</p><p id="b63e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些经历仍然让我得以瞥一眼Lerna，并理解它试图解决的问题。</p><h1 id="1dda" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Lerna &amp; React</h1><p id="9637" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">几个月后，当我询问我的React应用程序的文件结构/架构时，Lerna想到了这个问题。</p><p id="4a04" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我对用我的React应用程序在monorepo中维护我的后端不感兴趣。我也没有使用自定义库。我的目标是，在一个React项目中，允许大量开发人员同时处理几个功能，而没有架构的障碍。</p><p id="1d31" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">随着时间的推移和更多的功能，前面提到的体系结构促使开发人员为每项功能创建嵌套目录:</p><ul class=""><li id="b2eb" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">每个目录和子目录都变得很大</li><li id="28c7" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">寻找给定的组件变得非常耗时</li><li id="ef3a" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">添加新元素会使情况变得更糟</li><li id="6135" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">随着时间的推移，生产力会下降</li></ul><p id="7b46" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我想到的解决方案是，不要在我的整个应用程序中有一个包，而是为每个功能创建一个包，并创建一个具有入口点角色的包。如何管理那些包？<strong class="lq ir">蕾娜</strong>。</p><p id="7e90" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在实践中，我将Lerna与<a class="ae kv" href="https://classic.yarnpkg.com/en/docs/workspaces/" rel="noopener ugc nofollow" target="_blank">纱线工作空间</a>一起使用。一个基本的项目应该是这样的:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="98a6" class="oc kx iq op b gy ot ou l ov ow">monorepo<br/>├── packages<br/>│   ├── package1<br/>│   ├── package2<br/>│   ├── package3<br/>├── package.json<br/>├── lerna.json<br/>├── yarn.lock</span></pre><p id="9613" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是我正在开发一个React应用程序。我想将每个功能分离到不同的模块中，但我仍然需要一个入口点来:</p><ul class=""><li id="d3c5" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">引导React应用程序</li><li id="dff2" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">设置导航</li><li id="5b31" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">设置冗余</li></ul><p id="bf46" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是为什么我的第一步是创建这个“入口点”模块，我称之为核心。你猜怎么着，我以前的架构工作得非常好，所以我将重用它:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="336b" class="oc kx iq op b gy ot ou l ov ow">monorepo<br/>├── packages<br/>│   ├── core<br/>│       ├── public<br/>│       ├── src<br/>│          ├── components<br/>│              ├── AppProvider.tsx<br/>│          ├── navigation<br/>│              ├── PrivateRoute.tsx<br/>│              ├── AppProvider.tsx<br/>│              ├── Routes.tsx<br/>│          ├── store<br/>│              ├── index.ts<br/>│              ├── rootReducer.ts<br/>│              ├── sagas.ts<br/>│          ├── index.tsx<br/>│       ├── package.json<br/>        ├── tsconfig.json<br/>├── package.json<br/>├── tsconfig.json<br/>├── lerna.json<br/>├── yarn.lock</span></pre><p id="0752" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里，核心包是用create-react-app生成的。我通常设置我的提供者并调用<em class="ms"> AppProvider </em>文件中的<em class="ms"> Routes </em>组件。然后这个文件由index.js导入并引导。</p><p id="5cf9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<em class="ms"> Routes.tsx </em>中，我将从其他模块导入屏幕，并使用我的<em class="ms"> PublicRoute </em>和<em class="ms"> PrivateRoute。</em></p><p id="3adb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<strong class="lq ir"> store/ </strong>目录中，索引文件使用<em class="ms"> rootReducer </em>和sagas文件，以构建一个有效的Reducer。另一方面，<em class="ms"> rootReducer.ts </em>从其他模块导入并组合Reducer，而<em class="ms"> sagas.ts </em>对saga workers也是如此。</p><h2 id="546e" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">模块</h2><p id="8166" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我想把我的核心目录和其他功能模块分开。为了尊重这个组织，我在<strong class="lq ir">核心/ </strong>旁边设置了一个<strong class="lq ir">模块/ </strong>目录。</p><p id="0ce1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我为每个功能创建另一个子目录，同时仍然使用相同的结构。这些模块使用index.js文件来重新导出它们的所有内容，以便于导入。</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="3b77" class="oc kx iq op b gy ot ou l ov ow">monorepo<br/>├── packages<br/>│   ├── core<br/>│       ├── ....<br/>│   ├── modules<br/>│       ├── xFeature<br/>│          ├── src<br/>│              ├── components<br/>│              ├── store<br/>│              ├── screens<br/>│              ├── services<br/>│              ├── types<br/>│          ├── package.json<br/>│          ├── tsconfig.json<br/>│          ├── index.js<br/>├── package.json<br/>├── tsconfig.json<br/>├── lerna.json<br/>├── yarn.lock</span></pre><h2 id="f0c3" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">巩固</h2><p id="368e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">随着时间的推移，我在这个结构中加入了一些元素:</p><p id="8bcb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，一个<strong class="lq ir">普通</strong>模块。我之前讲过一个<strong class="lq ir">片段/ </strong>目录，存放在哪里？<strong class="lq ir">通用</strong>模块。也许你有一些自定义的钩子，在你的应用程序中到处都可以使用。同样适用，将它们存储在<strong class="lq ir">公共</strong>模块中。</p><p id="b7da" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于我正在使用带有<a class="ae kv" href="https://testing-library.com/docs/react-testing-library/setup/" rel="noopener ugc nofollow" target="_blank">自定义渲染</a>的<a class="ae kv" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>，我需要定义几个关于测试的函数。将所有内容都存储在<strong class="lq ir"> common/ </strong>目录中会使其过于复杂。相反，我可以在与<strong class="lq ir">内核相同的级别上创建一个<strong class="lq ir">测试</strong>模块。这是一个简化我的测试的好方法，同时仍然将<strong class="lq ir">模块/ </strong>目录用于功能。</strong></p><p id="f85e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我的单元测试存储在测试文件旁边的__tests__目录中。另一方面，当我编写端到端测试时，我会创建一个不同的目录。在这里，看起来像是一个<strong class="lq ir"> e2e/ </strong>目录，紧挨着<strong class="lq ir">核心/ </strong>和<strong class="lq ir">测试/ </strong>就可以了，不会让我的结构变得更复杂。</p><p id="b0cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最终结果如下所示:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="d738" class="oc kx iq op b gy ot ou l ov ow">monorepo<br/>├── packages<br/>│   ├── core<br/>│       ├── ....<br/>│   ├── e2e<br/>│       ├── ....<br/>│   ├── testing<br/>│       ├── ....<br/>│   ├── modules<br/>│       ├── common<br/>│          ├── ...<br/>│       ├── xFeature<br/>│          ├── ...<br/>├── package.json<br/>├── tsconfig.json<br/>├── lerna.json<br/>├── yarn.lock</span></pre><h2 id="32ee" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">不利方面</h2><p id="12e4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">从我的经验来看，这种结构对于大型项目非常有效，但是:</p><ul class=""><li id="4eb4" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated"><strong class="lq ir"> Lerna </strong>和<strong class="lq ir">纱线工作空间</strong>可能很难配置。</li><li id="3491" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">你(和你的团队)必须学会如何使用<strong class="lq ir"> Lerna </strong>。</li><li id="68bf" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">开始需要一些时间。</li><li id="8b52" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">对于小型和独立的项目，创建、理解和使用这种结构所需的时间是不值得的。</li><li id="6c3d" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">前面提到的大多数结构都可以重新用于React Native。不幸的是，本机模块和Lerna可能很难使用。</li></ul><h2 id="e412" class="oc kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">结论</h2><p id="111e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">感谢您的阅读。我希望你已经发现这是有用的和有益的。如果你有任何问题，请在评论中告诉我。谢谢！</p></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt mz"><a href="https://morintd.medium.com/about-me-teddy-morin-9fb1d65fe24e" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">关于我——泰迪·莫林</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">嗨，我是泰迪，一个反应的爱人🚀。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">morintd.medium.com</p></div></div><div class="ni l"><div class="pf l nk nl nm ni nn kp mz"/></div></div></a></div><p id="ee98" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="ms">更多内容看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="ms">plain English . io</em></strong></a></p></div></div>    
</body>
</html>