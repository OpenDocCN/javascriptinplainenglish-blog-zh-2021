<html>
<head>
<title>What You Need to Know About SQL Joins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于SQL连接，您需要知道什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-you-need-to-know-about-sql-joins-4c39034f4063?source=collection_archive---------15-----------------------#2021-10-13">https://javascript.plainenglish.io/what-you-need-to-know-about-sql-joins-4c39034f4063?source=collection_archive---------15-----------------------#2021-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用一些实际例子来解释</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/968d663e9b9775468ab3e2a5e90dc931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8kkAnawoAbWXrC5gOE1IVw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@paige_cody?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Paige Cody</a> on <a class="ae kv" href="https://unsplash.com/s/photos/learn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fc06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将看到不同类型的连接在MySQL中是如何工作的。这是第二部分。第一部分可以在这里找到<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/learn-join-in-mysql-database-a-practical-approach-1933c5c6bae6">。</a></p><h1 id="2c40" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">SQL中的JOIN是什么？</h1><p id="6f06" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">加盟的目的是什么？</p><p id="f406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您有客户数据和他们的订单信息。现在，如果您想知道订购商品的客户的id和名字，您需要同时了解客户数据和订单数据。</p><p id="066d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以想象<code class="fe mp mq mr ms b">join</code>下面。</p><p id="32b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它创建一个临时表，根据某种条件组合两个或更多的表。</p><p id="1d6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，customer表中的客户id与orders表中的customer_id相同。所以我们要根据这个条件来连接这两个表。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="51fb" class="mx lt iq ms b gy my mz l na nb"><strong class="ms ir">USE</strong> sql_store;</span><span id="813f" class="mx lt iq ms b gy nc mz l na nb"><strong class="ms ir"># get the desired info<br/>SELECT</strong> c.customer_id,<br/>       c.first_name,<br/>       o.order_id</span><span id="3fd9" class="mx lt iq ms b gy nc mz l na nb"><strong class="ms ir"># define the tables</strong></span><span id="7ce0" class="mx lt iq ms b gy nc mz l na nb"><strong class="ms ir">FROM </strong>customers c<br/><strong class="ms ir">JOIN</strong> orders o</span><span id="962a" class="mx lt iq ms b gy nc mz l na nb"><strong class="ms ir"># define the condition</strong></span><span id="e824" class="mx lt iq ms b gy nc mz l na nb"><strong class="ms ir">ON</strong> c.customer_id = o.customer_id<br/><strong class="ms ir">ORDER BY</strong> c.customer_id</span></pre><p id="f80a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后你会看到下面的结果；</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/017377e05d3d63d36899b9dc1a60405e.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*QQi43uuN-49-ucNdkMBiCA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">image by author</figcaption></figure><p id="f615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这被称为内部连接，因为结果中只显示了与<code class="fe mp mq mr ms b">customer_id</code>相同的标准行。因此，只有当顾客点了他的东西，她的信息才会显示在这里。</p><h1 id="b305" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">外部连接</h1><p id="d895" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">但是，如果您希望看到所有的客户，而不管他们是否点了菜，该怎么办呢？</p><p id="26ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，您必须使用左连接。left join所做的是从左边的表(在我们的例子中是customers表)中取出所有的行，然后将适当的行匹配到右边(在我们的例子中是orders表)</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="8911" class="mx lt iq ms b gy my mz l na nb"><strong class="ms ir">USE</strong> sql_store;<br/><strong class="ms ir">SELECT</strong> c.customer_id,<br/>       c.first_name,<br/>       o.order_id<br/><strong class="ms ir">FROM </strong>customers c<br/><strong class="ms ir">LEFT JOIN</strong> orders o<br/>  <strong class="ms ir">ON</strong> c.customer_id = o.customer_id<br/>  <strong class="ms ir">ORDER BY</strong> c.customer_id</span></pre><p id="d432" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，你的结果是；</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/08cf2a471d268b0b19d3c8fc1fad297c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*pEDPrxpJ62uPlO1a3si89g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">image by author</figcaption></figure><p id="1980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看，第一次，我们没有看到customer_id 1，3，4。因为那些客户没有订购，在这个时候，我们连续获得客户id，也知道谁打电话或没有。</p><h1 id="5833" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">自外部连接</h1><p id="e7fe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设，来自一家公司；您想知道员工经理的姓名，以及他们在哪里提交报告。</p><p id="7174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有一些数据。在这里，每个员工都必须向另一个员工报告。这意味着您需要用不同的别名加入员工。员工的第一次是e，经理的第二次是m。</p><p id="bfc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在的问题是你必须把雇员数据和雇员数据连接起来。这称为自连接。这意味着您正在进入同一个表。但是如何区分两个表呢？</p><p id="d342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你必须使用别名。</p><p id="1387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MySQL里怎么问！</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0b22" class="mx lt iq ms b gy my mz l na nb"><strong class="ms ir">USE</strong> sql_hr;<br/><strong class="ms ir">SELECT</strong><br/>  e. employee_id,<br/>  e. first_name,<br/>  m. first_name AS Manager<br/><strong class="ms ir">FROM</strong> employees e<br/><strong class="ms ir">JOIN</strong> employees m<br/>    <strong class="ms ir">ON</strong> e. reports_to = m. employee_id</span></pre><p id="72b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将一个雇员表称为<code class="fe mp mq mr ms b">e</code>，将另一个雇员表称为<code class="fe mp mq mr ms b">m</code>。现实中，两者同桌。</p><p id="4caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您将获得向其他人提交报告的所有员工的姓名。因为我的条件是在“e. reports_to = m. employee_id”中给出的。</p><p id="9b8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您想知道是谁交付了还是没有交付，那么您只需要更改一件事。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="b16f" class="mx lt iq ms b gy my mz l na nb"><strong class="ms ir">FROM</strong> employees e<br/><strong class="ms ir">LEFT JOIN</strong> employees m<br/>    <strong class="ms ir">ON</strong> e. reports_to = m. employee_id</span></pre><p id="ade8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mp mq mr ms b">JOIN</code>前写<code class="fe mp mq mr ms b"> LEFT</code>就行了。然后你会看到；</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e2993f872775d1f6dac49179dc969327.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*Qz-7o5JN1KJhL2Vd_yPnZQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">image by author</figcaption></figure><p id="6285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看，<strong class="ky ir"> Yovonnda </strong>是唯一没有提交报告的经理。他刚刚收到了员工发来的所有文件。</p><h1 id="a843" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Using子句</h1><p id="8cc8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设你想使用比<code class="fe mp mq mr ms b">ON</code>子句最短的子句。你的专栏也一样</p><p id="975c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，可以编写<code class="fe mp mq mr ms b">USING</code>子句。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="2f2d" class="mx lt iq ms b gy my mz l na nb">USE sql_store;<br/>SELECT<br/>  c. first_name,<br/>  o. order_id<br/>FROM orders o<br/>JOIN customers c<br/><strong class="ms ir">-- ON o. customer_id = c. customer_id<br/> USING (customer_id)</strong></span></pre><p id="6d61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的列是相同的，即customer_id。您想知道那个有<code class="fe mp mq mr ms b">order_id</code>的客户的名字。</p><p id="fc33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">加入后，可以使用最后一种语法；</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="566c" class="mx lt iq ms b gy my mz l na nb"><strong class="ms ir">USING (customer_id)</strong></span></pre><h1 id="d99d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">自然连接</h1><p id="f164" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">Natural</code>子句用于根据两个连接表中的标准列来隐含join子句。语法很简单。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="e527" class="mx lt iq ms b gy my mz l na nb"><strong class="ms ir">USE</strong> sql_store;<br/><strong class="ms ir">SELECT</strong><br/> c.first_name,<br/> c.customer_id,<br/> o.order_id<br/><strong class="ms ir">FROM </strong>orders o<br/><strong class="ms ir">NATURAL JOIN</strong> customers c</span></pre><p id="d6c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，不鼓励在MySQL中使用该子句。因为from in无意中添加了一个新列，与另一个表中的另一列同名。</p><h1 id="c9a0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">交叉连接</h1><p id="a972" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">交叉联接将第一个表中的所有记录与第二个表中的所有历史记录结合起来。</p><p id="e63c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设你有A，B客户，和X，Y，Z产品。使用交叉连接，您会发现:</p><blockquote class="ng nh ni"><p id="4e08" class="kw kx nj ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">A-X，阿-Y，阿-Z</p><p id="dc68" class="kw kx nj ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">B-X，B-Y，B-Z</p></blockquote><p id="b921" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种连接的语法非常简单。这是你怎么做的。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="b481" class="mx lt iq ms b gy my mz l na nb"><strong class="ms ir">USE</strong> sql_store;<br/><strong class="ms ir">SELECT</strong><br/>c.first_name AS customers,<br/>p.name AS product<br/><strong class="ms ir">FROM</strong> customers c<br/><strong class="ms ir">CROSS JOIN</strong> products p<br/>  <strong class="ms ir">ORDER BY</strong> c.first_name</span></pre><h1 id="6bef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">联合加入</h1><p id="1fb1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在MySQL中，Union join用于将所有结果组合在一起。假设您需要查看一行中大于2000小于4000的客户点，您可以使用该子句。</p><p id="1ed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是语法:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a8a0" class="mx lt iq ms b gy my mz l na nb"><strong class="ms ir">USE</strong> sql_store;<br/><strong class="ms ir">SELECT</strong><br/>c. first_name,<br/>points<br/><strong class="ms ir">FROM </strong>customers c<br/><strong class="ms ir">WHERE </strong>points &gt;'2000'<br/><strong class="ms ir">UNION</strong><br/><strong class="ms ir">SELECT</strong><br/>c. first_name,<br/>points<br/><strong class="ms ir">FROM</strong> customers c<br/><strong class="ms ir">WHERE </strong>points &lt;'4000'</span></pre><p id="53ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果如下所示；</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b1a86f5a0efc9129a53c3999c642dee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*OE69bhDHXYkaPjCs0myXtQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">image by author</figcaption></figure><p id="d869" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有兴趣了解更多关于MySQL中的连接，请参考下面的文章。</p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/learn-join-in-mysql-database-a-practical-approach-1933c5c6bae6"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">在MySQL数据库中学习JOIN:一种实用的方法</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">电子商务数据库细分</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kp nr"/></div></div></a></div><p id="d3b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nj">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>