<html>
<head>
<title>7 Useful TypeScript Tips to Level-up your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高代码水平的7个有用的打字技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-useful-typescript-tips-to-level-up-your-code-25d0ff545009?source=collection_archive---------10-----------------------#2021-04-14">https://javascript.plainenglish.io/7-useful-typescript-tips-to-level-up-your-code-25d0ff545009?source=collection_archive---------10-----------------------#2021-04-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ce21" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">提升您的类型脚本代码的技巧和窍门</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f3945fadc53c7c273d132b77e69116f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tums41FARnW23dtyXsi86w.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@mkvandergriff?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Maranda Vandergriff</a> on <a class="ae ks" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="5d50" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">1.Currying</h2><p id="0e55" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">Currying是将一个接受多个参数的函数转换成一系列一次接受一个参数的函数的过程。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="f302" class="kt ku in mj b gy mn mo l mp mq">// A curried function<br/>let add = (x: number) =&gt; (y: number) =&gt; x + y;</span><span id="0417" class="kt ku in mj b gy mr mo l mp mq">// Simple usage<br/>add(321)(345);</span><span id="651f" class="kt ku in mj b gy mr mo l mp mq">// partially applied<br/>let add321 = add(321);</span><span id="2927" class="kt ku in mj b gy mr mo l mp mq">// fully apply the function<br/>add321(345);</span></pre><h2 id="85ab" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">2.字符串枚举</h2><p id="bc2c" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">有时你需要在一个公共键下收集一组字符串。在TypeScript 2.4之前，TypeScript仅支持基于数字的枚举。如果您使用2.4之前的版本，解决方案是使用字符串文字类型，通过组合<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/typescript-advanced-types-b6d0f19bcbf5">联合类型</a>来创建基于字符串的枚举。</p><p id="d607" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">在字符串枚举中，每个成员都必须用字符串或另一个字符串枚举成员进行常量初始化</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="4424" class="kt ku in mj b gy mn mo l mp mq">enum Direction {<br/>Up = "UP",<br/>Down = "DOWN",<br/>Left = "LEFT",<br/>Right = "RIGHT",<br/>}</span></pre><p id="f8be" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">虽然字符串枚举没有自动递增行为，但字符串枚举的优点是可以很好地“序列化”。换句话说，如果您正在调试并且必须读取数值枚举的运行时值，该值通常是不透明的，它本身不能传达任何有用的意义(尽管反向映射通常会有所帮助)，字符串枚举允许您在代码运行时提供有意义且可读的值，而不管枚举成员本身的名称如何。</p><h2 id="d4db" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">3.有状态函数</h2><p id="c99b" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">其他编程语言的一个共同特点是使用static关键字来增加函数变量的生存期(而不是作用域)，使其超出函数调用的作用域。下面是一个实现这一点的C示例:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="c17c" class="kt ku in mj b gy mn mo l mp mq">void addUp() {<br/>    static count = 0;<br/>    count++;<br/>    printf("Count : %d", count);<br/>}</span><span id="8ec7" class="kt ku in mj b gy mr mo l mp mq">int main () {<br/>    addUp(); // Count : 1<br/>    addUp(); // Count : 2<br/>    return 0;<br/>}</span></pre><p id="7244" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">因为TypeScript没有静态函数，所以您可以使用包装局部变量的各种抽象来实现同样的事情，例如使用<code class="fe mx my mz mj b">class</code>:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="9f4a" class="kt ku in mj b gy mn mo l mp mq">const {addUp} = new class {<br/>    count = 0;<br/>    addUp = () =&gt; { <br/>       this.count++;<br/>       console.log(`Count : ${this.count}`); <br/>    }<br/>};</span><span id="3735" class="kt ku in mj b gy mr mo l mp mq">addUp(); // Count : 1<br/>addUp(); // Count : 2</span></pre><h2 id="ee5a" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">4.导出默认值可能会导致问题</h2><p id="0310" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">如果你有一个文件<code class="fe mx my mz mj b">bar.ts</code>:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="ae66" class="kt ku in mj b gy mn mo l mp mq">class Bar {<br/>}<br/>export default Bar;</span></pre><p id="78f1" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">您可以使用ES6语法在<code class="fe mx my mz mj b">faa.ts</code>中导入它，如下所示:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="56e8" class="kt ku in mj b gy mn mo l mp mq">import Bar from "./bar";</span></pre><p id="a077" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">以下是一些可维护性问题:</p><ul class=""><li id="62f0" class="na nb in lr b ls ms lv mt lc nc lg nd lk ne mh nf ng nh ni bi translated">如果<code class="fe mx my mz mj b">Bar</code>在<code class="fe mx my mz mj b">bar.ts</code>中被重构，在<code class="fe mx my mz mj b">faa.ts</code>中不会被重命名。</li><li id="6892" class="na nb in lr b ls nj lv nk lc nl lg nm lk nn mh nf ng nh ni bi translated">如果您最终需要从<code class="fe mx my mz mj b">bar.ts</code>导出更多的东西(这是您的许多文件都有的)，那么您必须修改导入语法。</li></ul><p id="825c" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">因此，建议使用简单导出+析构导入:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="b494" class="kt ku in mj b gy mn mo l mp mq">export class Bar{<br/>}</span></pre><p id="d22d" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">然后:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="f984" class="kt ku in mj b gy mn mo l mp mq">import {Bar} from "./bar";</span></pre><h2 id="d83e" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">5.桶</h2><p id="f936" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">桶是一种将多个模块的导出集合到一个方便的模块中的方法。桶本身是一个模块文件，可以重新导出其他模块的选定导出。想象一下库中的如下类结构:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="6472" class="kt ku in mj b gy mn mo l mp mq">// tutorial/bar.ts<br/>export class Bar {} </span><span id="01d5" class="kt ku in mj b gy mr mo l mp mq">// tutorial/bas.ts<br/>export class Bas {}</span><span id="5e26" class="kt ku in mj b gy mr mo l mp mq">// tutorial/bat.ts<br/>export class Bat {}</span></pre><p id="76a4" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">如果没有桶，消费者将需要三个进口声明:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="6b0b" class="kt ku in mj b gy mn mo l mp mq">import { Bar } from '../tutorial/bar'; <br/>import { Bas } from '../tutorial/bas'; <br/>import { Bat } from '../tutorial/bat';</span></pre><p id="1a7f" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">您可以添加一个包含以下内容的桶<code class="fe mx my mz mj b">tutorial/index.ts</code>:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="81bc" class="kt ku in mj b gy mn mo l mp mq">// tutorial/index.ts<br/>export * from './bar'; <br/>export * from './bas'; <br/>export * from './bat';</span></pre><p id="c0d0" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">现在，消费者可以从桶中进口所需的东西:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="0f7f" class="kt ku in mj b gy mn mo l mp mq">import { Bar, Bas, Bat } from '../tutorial';</span></pre><h2 id="ca4a" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">6.暗示</h2><p id="4807" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">它是TypeScript的放大镜，这是一个漂亮的检查工具，可以提取被困在不同类型的结构中的类型。</p><p id="8ba0" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">例如，让我们从对象中提取属性的类型:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="4b5b" class="kt ku in mj b gy mn mo l mp mq">type ObjectInfer&lt;O&gt; = O <br/>  extends {a: infer A}<br/>  ? A<br/>  : never</span><span id="67fe" class="kt ku in mj b gy mr mo l mp mq">const object = {a: 'hello'};<br/>type testResult1 = ObjectInfer&lt;typeof object&gt;; // string<br/>type testResult2 = ObjectInfer&lt;string&gt;; // never</span></pre><h2 id="5987" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">7.真理</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7a3baecc1a86c07b1e4022fab5c43f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*_rw1KiK3xuHCoFah.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image from <a class="ae ks" href="https://samanthaming.com/" rel="noopener ugc nofollow" target="_blank">https://samanthaming.com</a></figcaption></figure><p id="faa7" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">最后一个技巧是正确理解一个基本概念——真理。真值是在某些地方评估为真的东西(比如条件和布尔&amp;&amp; ||运算符)。以下是JavaScript中的真实情况。一个例子是除0以外的任何数字，例如:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="cacd" class="kt ku in mj b gy mn mo l mp mq">if (1) { <br/>console.log('Any number other than 0 is truthy');<br/>}</span></pre><p id="e250" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated">不真实的东西叫做虚假。</p><p id="6460" class="pw-post-body-paragraph lp lq in lr b ls ms jo lu lv mt jr lx lc mu lz ma lg mv mc md lk mw mf mg mh ig bi translated"><em class="np">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="np">plain English . io</em></a></p></div></div>    
</body>
</html>