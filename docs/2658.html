<html>
<head>
<title>setTimeout vs. setImmediate Timer Functions in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的setTimeout与setImmediate计时器函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/settimeout-vs-setimmediate-timer-functions-in-nodejs-fbd29ed43db?source=collection_archive---------5-----------------------#2021-06-01">https://javascript.plainenglish.io/settimeout-vs-setimmediate-timer-functions-in-nodejs-fbd29ed43db?source=collection_archive---------5-----------------------#2021-06-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="50f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Node.js是一个异步的、非阻塞的、事件驱动的架构。它深受Nginx web服务器的高并发模型设计的启发。</p><p id="9a05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" rel="noopener ugc nofollow" target="_blank">与Nginx中的主进程和许多工作进程概念</a>一样，Node.js使用单线程事件循环和线程池。<a class="ae ki" href="https://libuv.org/" rel="noopener ugc nofollow" target="_blank"> LibUV </a>库帮助Node.js实现事件循环。</p><p id="9172" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如下图所示，这是事件循环中不同阶段的样子:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/2ac3acc08cbd3d8a9839e8ecd125959e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kg2L7HiLDL4wkx4mfmMuQ.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Source: <a class="ae ki" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a></figcaption></figure><h2 id="d014" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">介绍</h2><p id="d636" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在进入事件循环的执行阶段，计时器是最重要的功能之一，它有助于根据超时和立即执行来调度脚本。因此，这里有一篇帖子主要介绍两个重要的定时器函数的执行，这两个函数是<strong class="jm io"> setTimeout() </strong>和<strong class="jm io"> setImmediate() — </strong>，它们的设计是在事件循环的不同阶段运行。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/bda7dafc38b23f4168f0a8826c72b57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/1*aBb4VGABsMn9EPXInpbL_g.gif"/></div></figure><p id="fec7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">“当我这么说”执行:</strong> setTimeout()</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9696" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件循环中的<strong class="jm io">定时器阶段</strong>调度<strong class="jm io">funcexecaftemilisec</strong>回调函数的执行，指定阈值，在该阈值之后可以执行所提供的回调。根据Node.js文档，</p><blockquote class="ma mb mc"><p id="b27b" class="jk jl md jm b jn jo jp jq jr js jt ju me jw jx jy mf ka kb kc mg ke kf kg kh ig bi translated">从技术上讲，<a class="ae ki" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#poll" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">轮询</strong>阶段</a>控制定时器何时执行。</p></blockquote><p id="2b6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">【右后本】执行~ </strong> <em class="md"> setImmediate() </em></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="a87d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">轮询和检查阶段</strong>负责该即时定时器事件的调度和执行。当事件循环进入轮询阶段时，它的首要任务是耗尽轮询队列。如果轮询队列<strong class="jm io">为空，</strong>将通过<strong class="jm io"> setImmediate()查找预定脚本。如果存在，它结束轮询阶段并进入检查阶段来执行那些脚本。根据Node.js文档，</strong></p><blockquote class="ma mb mc"><p id="7f94" class="jk jl md jm b jn jo jp jq jr js jt ju me jw jx jy mf ka kb kc mg ke kf kg kh ig bi translated"><code class="fe mh mi mj mk b">setImmediate()</code>实际上是一个特殊的计时器，运行在事件循环的一个单独阶段。它使用一个libuv API来调度回调在<strong class="jm io">轮询</strong>阶段完成后执行。</p></blockquote><p id="0b0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，问题是—我们不能像这样用setTimeout()实现同样的行为吗？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上所述，两个定时器事件在事件循环的不同阶段执行。由于setImmediate()被设计为在当前<strong class="jm io">轮询阶段</strong>完成后执行脚本，这意味着它在轮询队列为空并且<strong class="jm io">事件循环</strong>空闲后执行；而setTimeout()的执行是由<strong class="jm io">定时器阶段</strong>调度的，它指定了一个阈值，在该阈值之后，所提供的回调可以被执行，这取决于轮询阶段。</p><p id="ef01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是这里有一个问题:让我们试着在一个不在I/O周期内的脚本中运行这两个定时器函数，这仅仅意味着事件循环在任何回调的执行中都不忙。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="a94f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的脚本中，猜测两个定时器的执行顺序是不确定的，因为它们受进程性能的限制。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="b276" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此脚本保证您在"<em class="md">之后首先执行setImmediate()定时器函数，而</em> <em class="md">事件循环是通过执行I/O事件队列中的文件读取事件完成的，并且事件队列为空。</em>”因此，事件循环将在<strong class="jm io">轮询阶段</strong>中了解预定的立即回调脚本，并移动到<strong class="jm io">检查阶段</strong>以执行相同的脚本。</p><h2 id="ceaa" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">结论</h2><p id="4879" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">尽管在不涉及I/O周期的情况下(因此是非确定性的)，在立即队列和超时队列中执行脚本不会显示出主要的区别，但是当我们在特定的I/O周期中运行这些定时器函数时，我们会看到它们不同实现的真正意义。</p><p id="64b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一个就到此为止。我将很快写下与process.nextTick()的比较，它有一个特殊的目的。我希望你喜欢阅读这篇文章。谢谢！</p><p id="fecc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="md">更多内容请看</em><a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="md">plain English . io</em></a></p></div></div>    
</body>
</html>