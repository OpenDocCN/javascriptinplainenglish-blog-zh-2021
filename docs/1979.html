<html>
<head>
<title>5 Gotchas for TypeScript New Comers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字新手的5个陷阱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-gotchas-for-typescript-new-comers-10e7b99dc23b?source=collection_archive---------7-----------------------#2021-04-25">https://javascript.plainenglish.io/5-gotchas-for-typescript-new-comers-10e7b99dc23b?source=collection_archive---------7-----------------------#2021-04-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="46f1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">来自其他静态类型语言时你可能会忽略的东西</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/14a1252c5d494ed85df6c61c061c6462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pnG-FsEVfebIZPbE"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@carly31?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Carla Anne</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fc60" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">所以你已经做出了重大决定:你的下一个项目将利用TypeScript，因为你已经到处阅读了<a class="ae kt" href="https://medium.com/javascript-in-plain-english/typescript-with-node-and-express-js-why-when-and-how-eb6bc73edd5d" rel="noopener">当你需要维护大型代码库时</a>它将如何拯救你。真的，我完全同意你的观点:我的编程背景主要是建立在静态类型语言之上的，比如C#，所以转向TypeScript就像回到了家。哦，当web前端需要时，我是用纯JavaScript编写的，但是很快转向TypeScript以获得所有自动完成和静态错误预防的好处是有意义的。</p><p id="46d6" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">然而，如果你正在经历类似的旅程，有一些陷阱需要注意:根据你的背景，其中一些陷阱对你来说可能比其他的更明显，所以请在评论中告诉我你的建议。</p><h1 id="db92" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">1.防御性地使用接口或类型</h1><p id="4f45" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">TypeScript接口或类型帮助我们构建更可靠的代码库，但是我想你很清楚，那些漂亮的类型定义在运行时消失了。事实上，编译器会在生成JavaScript文件时丢弃它们——正如您自己可能经历过的那样，它会拒绝任何在代码中使用带有接口的<code class="fe mn mo mp mq b">typeof</code>或<code class="fe mn mo mp mq b">instanceof</code>的尝试。</p><p id="828f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">一方面，如果您直观地看到编译器如何转换您的代码，这个问题就很简单了，但另一方面，我发现根据您的背景，很容易适应IDE的智能感知，并忘记您的类型在运行时可能不成立。让我们看一个例子来说明接口(或类型)是如何欺骗我们的。</p><h2 id="0a17" class="mr lr in bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">让太多的数据进入</h2><p id="7073" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">在下面的示例中，您可以看到一个用NestJS编写的API控制器，但这可能是任何框架，甚至是前端代码。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="875b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在可以想象，当在<code class="fe mn mo mp mq b">/user</code>端点上执行POST请求时，<code class="fe mn mo mp mq b">UserService</code>的<code class="fe mn mo mp mq b">create</code>方法会将我们的用户对象持久化到某种数据库中。如果一切顺利，我们将存储一个用户名……但是请记住,<code class="fe mn mo mp mq b">CreateUserDto</code>数据模型纯粹是开发时间的保障。TypeScript中没有任何东西可以确保提供了用户名，甚至更令人担心的是，没有任何东西可以确保没有提供额外的数据！如果这是一个公共API端点，那么任何人都可以在您的数据库中存储任何东西，这是一个拥有不一致数据并使您的服务面临安全威胁的好方法！</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nf ne l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Your API service when it expects a property according to your interface… and yet it’s not there at runtime</figcaption></figure><h2 id="2d0d" class="mr lr in bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">验证，验证，验证</h2><p id="a9c6" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">经验丰富的软件工程师知道不要相信外部输入，这一点在TypeScript中肯定成立。如果你想验证，你需要构建你自己的类型保护，或者使用现有的库，比如<a class="ae kt" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> IO-TS </a>，或者<a class="ae kt" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank"> class-validator </a>。有了这些工具，您现在可以过滤所有传入的数据，以便您的应用程序域可以安全地依赖类型和接口，并假设运行时对象满足它们的接口。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi ng"><img src="../Images/64f9aef783bd541304a4e6855b4556aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXbKBRLqcsre9CQuy1UA0A.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Any data that you manipulate in your application domain should be validated. If you limit yourself to user input, you may be surprised when some of the package or API service you use returns malformed content!</figcaption></figure><p id="dd76" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果您对验证数据库对象感兴趣，并且正在使用MongoDb，那么您很幸运:我这里有一篇专门为您准备的关于用Mongoose验证复杂嵌套类型的文章。</p><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/leverage-polymorphic-data-validation-with-nest-js-and-mongoose-10ae1dcbcf6d"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">利用Nest.js和Mongoose进行多态数据验证</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">验证填充了不同数据模型的文档数组的实践指南</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kn nk"/></div></div></a></div><h2 id="1b91" class="mr lr in bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">泄露太多数据</h2><p id="f46b" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">在继续之前，让我强调一下上图中的箭头是双向的。因此，如果从数据库中检索用户并将其作为JSON返回，就要非常小心。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Similarly, interfaces — or even classes- won’t limit the fields of a returned object at runtime. It sounds straightforward but can easily be forgotten when you are using and forwarding directly objects from 3rd party packages.</figcaption></figure><h1 id="161d" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">2.不使用ESLint</h1><p id="b84d" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">如果你来自C#世界，你可能熟悉StyleCop、Resharper——或者如果你是一个Java爱好者，你可能熟悉Checkstyle:这些linters在这里帮助标准化我们在团队中编码的方式，但是我不会确切地称它们为所有开发项目的基本。</p><p id="7cc1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">虽然ESLint看起来是一个可选的噱头，但它却是TypeScript程序员工具箱中的一个重要武器。事实上，一些打字错误和错误可能仍然是有效的类型脚本代码，不会被编译器突出显示。你调用了一个方法，却忘了加括号？您将实例方法作为参数传递，而没有将其绑定到实例本身？所有这些错误仍然会编译成有效的Typescript代码，所以只有使用正确的ESLint配置才能发现它们。</p><h2 id="aecd" class="mr lr in bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">承诺的例子</h2><p id="d77c" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">我感到惊讶的一种情况是TypeScript对<code class="fe mn mo mp mq b">async</code>方法没有帮助。在C#中，编译器会警告您没有在等待异步方法。在TypeScript中，<code class="fe mn mo mp mq b">async</code>方法返回承诺，这些承诺是常规对象，与任何返回的对象一样，不关心函数返回什么是合理的用例。但是在承诺的情况下，这通常意味着你忘记了<code class="fe mn mo mp mq b">await</code>一个功能的执行。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">A sample of what might go unnoticed if ESLint is not setup. When your program reaches line 15, you are potentially still busy sending emails — and an unhandled exception could be thrown.</figcaption></figure><p id="4760" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我认为这个例子特别有意义，因为根据上下文的不同，即使是单元测试也可能无法发现问题。单元测试中的<code class="fe mn mo mp mq b">async</code>函数经常被嘲笑为用<code class="fe mn mo mp mq b">Promise.resolve()</code>立即解决的承诺，这可能导致测试中的函数行为有些同步。一旦应用程序用真正的异步代码运行，调试就成了一个完整的旅程…</p><h1 id="d7a1" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">3.仅启用基本严格模式</h1><p id="83c7" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">启用严格模式对于利用类型检查的能力非常重要。因为这在TypeScript文章中已经讨论过了，所以让我进一步强调有时被忽略的一步:严格模式是不够的！如果您正在用最新的TypeScript版本(在撰写本文时是4.2)开始一个全新的项目，那么这就是您想要的:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Since a few versions, the TypeScript team tends to refer to those additional checks as “Linter Rules”. It’s true that it is blurring the line between compiler and linter — was there ever a line though?</figcaption></figure><p id="663c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">诚然，我理解<code class="fe mn mo mp mq b">noUnusedLocals</code>有多烦人。如果你经常需要注释掉一些代码来进行快速测试，编译器会对你大喊大叫，因为一些变量现在还没有被使用。公平。但是我用<code class="fe mn mo mp mq b">noUncheckedIndexedAccess</code>给你举个例子。</p><h2 id="4fd4" class="mr lr in bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">注意你的直接索引数组访问</h2><p id="f568" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">我喜欢TypeScript的一点是它如何处理<a class="ae kt" href="https://hinchman-amanda.medium.com/null-pointer-references-the-billion-dollar-mistake-1e616534d485" rel="noopener">空指针十亿美元错误</a>:如果你设置了严格模式，那么你必须显式标记一个对象何时可能是<code class="fe mn mo mp mq b">null</code>或<code class="fe mn mo mp mq b">undefined</code>。如果你也执行输入验证，你应该做得很好…直到你使用数组。见下文:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2cf8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果不打开<code class="fe mn mo mp mq b">noUncheckedIndexedAccess</code>，TypeScript将假设您可以获取任何索引，这可能会在运行时导致令人不快的意外。幸运的是，在大多数情况下，数组的作用是通过<code class="fe mn mo mp mq b">for .. of</code>或其他映射函数迭代它们，但是如果你需要直接访问一个特定的项，不要被编译器愚弄！</p><h1 id="02c5" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">4.应为名义类型特征</h1><p id="f3c1" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">这一条真的取决于你的其他语言经验，虽然听起来很直白，但它会在你最意想不到的时候偷袭你。如果您习惯于C#或Java之类的静态类型语言，那么您可能会认为Typescript也适用于名义类型。来自所有强大的<a class="ae kt" href="https://en.wikipedia.org/wiki/Nominal_type_system" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="nz"><p id="eca3" class="oa ob in bd oc od oe of og oh oi lp dk translated">名义类型化意味着两个变量是类型兼容的<strong class="ak"> <em class="kc">当且仅当它们的声明命名了相同的类型</em></strong></p></blockquote><p id="e0d6" class="pw-post-body-paragraph ku kv in kw b kx oj jo kz la ok jr lc ld ol lf lg lh om lj lk ll on ln lo lp ig bi translated">TypeScript绝对不是这种情况。TypeScript完全是关于形状的:您描述了一个对象必须具有的形状，无论是在类型、接口还是类中，只要变量具有相似的形状，它们就是类型兼容的。下面是一个用C#实现的标称输入效果的例子:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Demonstrating the concept of nominal typing in C#</figcaption></figure><p id="630c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在，打字稿的对应物:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">The <em class="kc">greet</em> function does not expect a person, it just wants a name property</figcaption></figure><p id="ab47" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如您所见，TypeScript编译器并不关心您是否传递了由实际的<code class="fe mn mo mp mq b">Person</code>类构造函数创建的内容。它只关心你提供给<code class="fe mn mo mp mq b">greet()</code>的对象上是否有一个<code class="fe mn mo mp mq b">name</code>字符串属性。</p><h2 id="28c9" class="mr lr in bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">为什么你应该拥抱它</h2><p id="7c08" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">如果您习惯于名义上的类型化语言，这是非常令人不安的，如果您通过防御性编程来进行编码，情况就更是如此。在我总结一些替代方法之前，让我首先声明:你需要改变你的思维模式，拥抱结构化类型。结构类型化的一个优点是允许无限的界面分离。如果你不从坚实的原理中回忆起“我”，看看<a class="ae kt" href="https://severinperez.medium.com/avoiding-interface-pollution-with-the-interface-segregation-principle-5d3859c21013" rel="noopener">这篇文章</a>。</p><p id="972d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">使用结构化类型，您可以定义每个函数期望的参数，但是您不需要像在C#中那样为每个对象添加<code class="fe mn mo mp mq b">implements MyInterface</code>。TypeScript的编译器将检查形状是否匹配，这非常方便，因为它减少了接口及其实现之间存在的静态耦合。</p><h2 id="73c0" class="mr lr in bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">绕过它</h2><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/07c9f6399d9c3926279a0b52a5b371fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*bxSLABNHDSZ4cIDmiBEW2Q.gif"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Structural typing, as illustrated by the “Square Hole” meme (@brock1137 on TikTok): if the shape you define is not specific enough, then you might allow anything to go through.</figcaption></figure><p id="2ac2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">有时你可能会面临这样一种情况，你的对象的形状是相似的，但它们在逻辑上应该是不同的。让我们想象一下，在前面的<code class="fe mn mo mp mq b">Pet</code> / <code class="fe mn mo mp mq b">Person</code>示例中，我们想要阻止一个开发人员用宠物来调用<code class="fe mn mo mp mq b">greet</code>。你可以这样解决它:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">This technique is sometimes called “branded types”. Notice how we use ECMAScript’s symbols to make sure the nominal type name is unique.</figcaption></figure><p id="036a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这种技术的要点是，在想要在名义样式中使用的值或对象类型上添加一个文字类型的属性。因此，当TypeScript检查对象的形状时，它将确保<code class="fe mn mo mp mq b">_nominalType</code>属性匹配。但是请记住:这都是在开发时发生的，一旦程序运行，这些信息都将不复存在！</p><h1 id="9200" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">5.信任确定类型的包</h1><p id="d334" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">TypeScript成功的原因之一在于它与裸JavaScript库集成得非常好。当你需要的库没有提供类型定义时，你很有可能通过使用<code class="fe mn mo mp mq b">npm install -D @types/your-package-name</code>在<a class="ae kt" href="https://github.com/DefinitelyTyped/DefinitelyTyped" rel="noopener ugc nofollow" target="_blank">明确类型化的回购</a>中找到它们。</p><p id="05a8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">而且很多时候，尤其是知名的图书馆，一切都会运转良好。但是，您必须记住，那些类型定义是由社区维护的，这意味着:</p><ul class=""><li id="45e5" class="op oq in kw b kx ky la lb ld or lh os ll ot lp ou ov ow ox bi translated">如果你正在使用的JavaScript库得到了更新并改变了它的API，你将不得不等待有人更新类型定义…如果它曾经被更新过的话</li><li id="b4c8" class="op oq in kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">因为类型定义的作者和库的作者可能是不同的，并且因为原始源代码不是用TypeScript编写的，所以在类型定义中可能会有打字错误或诚实的错误</li><li id="c7b7" class="op oq in kw b kx oy la oz ld pa lh pb ll pc lp ou ov ow ox bi translated">您要使用的库的类型定义可能根本不存在</li></ul><h2 id="6c08" class="mr lr in bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">如果你想得到很好的服务，请自便</h2><p id="e8d2" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">如果你发现自己处于前面三点中的一点，不要绝望。如果你需要让事情快速运行，你总是可以<a class="ae kt" href="https://www.typescriptlang.org/docs/handbook/2/type-declarations.html#your-own-definitions" rel="noopener ugc nofollow" target="_blank">为一个导入的包</a>声明定义。</p><p id="5762" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果您有更多的时间，这是一个很好的机会，您可以自己在明确类型化的存储库上创建或更新类型定义！信不信由你，修复声明类型文件并不复杂:除了改进开源代码，我可以向你保证它有助于揭开TypeScript类型在幕后是如何工作的。</p></div><div class="ab cl pd pe hr pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="ig ih ii ij ik"><h1 id="d8b6" class="lq lr in bd ls lt pk lv lw lx pl lz ma jt pm ju mc jw pn jx me jz po ka mg mh bi translated">结论</h1><p id="081d" class="pw-post-body-paragraph ku kv in kw b kx mi jo kz la mj jr lc ld mk lf lg lh ml lj lk ll mm ln lo lp ig bi translated">好了，我希望你已经学到了一些东西。也许你还遇到了其他的打字稿陷阱，所以不要犹豫，在评论里分享或者用文章回复吧！感谢您的阅读。</p><p id="ecf0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><em class="pp">更多内容请看</em><a class="ae kt" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="pp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>