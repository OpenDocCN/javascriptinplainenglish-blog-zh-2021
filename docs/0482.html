<html>
<head>
<title>Setting up a simple TypeScript project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置简单的TypeScript项目</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/setting-up-a-simple-typescript-project-b11140877e24?source=collection_archive---------2-----------------------#2021-01-29">https://javascript.plainenglish.io/setting-up-a-simple-typescript-project-b11140877e24?source=collection_archive---------2-----------------------#2021-01-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/eaf67ea04aa5f3d0a84ac7971503206a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ekoVX4x42phe_LGa"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8b3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">这篇文章记录了我创建一个完整网站的旅程的一小部分，这个网站可以在三个并行框架和三个并行设计系统中呈现(</em><a class="ae jz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"><em class="ky">React</em></a><em class="ky">+</em><a class="ae jz" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"><em class="ky">Material UI</em></a><em class="ky">)；</em><a class="ae jz" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"><em class="ky"/></a><em class="ky">+</em><a class="ae jz" href="https://clarity.design/" rel="noopener ugc nofollow" target="_blank"><em class="ky">清晰度</em></a><em class="ky">；</em> <a class="ae jz" href="https://www.javascript.com/" rel="noopener ugc nofollow" target="_blank">【香草】JS </a> <em class="ky"> + </em> <a class="ae jz" href="https://www.carbondesignsystem.com/" rel="noopener ugc nofollow" target="_blank">碳</a> <em class="ky">)。</em></p><p id="baf8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://simon-lutterbie.medium.com/hello-world-starting-a-web-app-from-a-blank-canvas-9b73fa2cb7e6" rel="noopener"> ←上一篇:你好，世界！</a></p><p id="8335" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://simon-lutterbie.medium.com/refactoring-a-static-html-site-into-typescript-part-1-of-2-the-content-b4c975ecab00" rel="noopener"> →下一篇文章:将静态HTML站点重构为类型脚本，第1部分，共2部分</a></p><p id="ba76" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的<a class="ae jz" href="https://simon-lutterbie.medium.com/hello-world-starting-a-web-app-from-a-blank-canvas-9b73fa2cb7e6" rel="noopener">上一篇(也是第一篇！)文章</a>，我创建了一个<em class="ky">非常</em>基本的HTML+JS页面:一个单独的<code class="fe kz la lb lc b">index.html</code>文件作为模板，一个单独的<code class="fe kz la lb lc b">index.js</code>呈现“Hello，World！”在所述模板中。我还创建了一个<code class="fe kz la lb lc b">git repository</code>，进行了第一次提交，并将其推送到<a class="ae jz" href="https://github.com/sjlutterbie/parallel-frameworks-website" rel="noopener ugc nofollow" target="_blank"> Github </a>。</p><p id="10fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">但是比起普通的JavaScript，我更喜欢</strong><a class="ae jz" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">TypeScript</strong></a><strong class="kc io">。起初，从JavaScript过渡到TypeScript可能看起来是不必要的开销。但相信我，这是值得的。</strong></p><p id="ac0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">采用打字稿</p><ul class=""><li id="db85" class="ld le in kc b kd ke kh ki kl lf kp lg kt lh kx li lj lk ll bi translated"><strong class="kc io">帮助减少代码中的错误和难以发现的bug。</strong>每个函数或类方法都可以提供一个关于它所期望的参数和它所返回的值类型的清晰契约。</li><li id="32e0" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated">促进代码的整洁和可读性。现在我们用TypeScript编写了，我的团队以最小化我们添加到代码中的注释数量为荣，因为清晰的类型允许代码自己说话。</li><li id="243e" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated"><strong class="kc io">实现新水平的测试。</strong>大多数开发人员都熟悉<em class="ky">单元</em>、<em class="ky">集成</em>、<em class="ky">、</em>和<em class="ky">端到端</em>测试。类型化代码自动包含静态测试——运行类型检查可以在代码运行之前检测出某些代码错误。有了好的IDE，这些错误将在开发中期被检测出来。是实时TDD。</li></ul><p id="b00b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">深信不疑？很好。让我们开始吧。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="8bd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在实现TypeScript之前，我需要将我的项目设置为一个<a class="ae jz" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm包</a>，这样我就可以加载必要的TypeScript模块。只需要一个简单的命令:<code class="fe kz la lb lc b">npm init</code>，和几个回答的问题。结果是项目目录中的一个<code class="fe kz la lb lc b">package.json</code>文件，它包含了关于项目的各种细节。这个文件将随着项目的复杂程度而增长，但是现在它足够简单，可以作为一个片段包含进来:</p><pre class="ly lz ma mb gt mc lc md me aw mf bi"><span id="e0cc" class="mg mh in lc b gy mi mj l mk ml">{<br/>  "name": "sjlutterbie-website-ui",<br/>  "version": "1.0.0",<br/>  "description": "Starting from a blank canvas, building a site that <br/>                  can be rendered in multiple frameworks.",<br/>  "main": "src/index.js",<br/>  "scripts": {},<br/>  "repository": {<br/>    "type": "git",<br/>    "url": "git+https://github.com/sjlutterbie/parallel-frameworks-website.git"<br/>  },<br/>  "author": "Dr. Simon Lutterbie",<br/>  "license": "ISC"<br/>}</span></pre><p id="299b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目前，它只不过是该项目的一个元描述。<code class="fe kz la lb lc b">main: src/index.js</code>是我的源代码的入口点。<code class="fe kz la lb lc b">scripts: {}</code>列举了我能跑的各种<code class="fe kz la lb lc b">npm commands</code>；它开始是空的(好吧，有一个占位符<code class="fe kz la lb lc b">test</code>命令，我已经删除了)，但不会持续很久。</p><p id="93f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将我的项目设置为一个<code class="fe kz la lb lc b">npm package</code>的主要好处是我现在可以安装依赖项…比如TypeScript！</p><pre class="ly lz ma mb gt mc lc md me aw mf bi"><span id="259d" class="mg mh in lc b gy mi mj l mk ml">npm i -D typescript tsc</span></pre><p id="9b45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的命令安装主<code class="fe kz la lb lc b">typescript</code>包以及<code class="fe kz la lb lc b">tsc</code>，TypeScript的“命令行解释器”。<code class="fe kz la lb lc b">-D</code>命令告诉npm将它们安装为<code class="fe kz la lb lc b">devDependencies</code>——开发所必需的包，但不会包含在最终版本中。TypeScript已加载！</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="b644" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我进入编码之前，还有一个重要的步骤。安装依赖项会在我的项目中创建一个<code class="fe kz la lb lc b">node_modules</code>文件夹，其中存储了所有的依赖项代码。这个目录会变得非常大和复杂，在您的<code class="fe kz la lb lc b">git history</code>中跟踪它实际上是有害的。因此，是时候设置一个<code class="fe kz la lb lc b">.gitignore</code>文件了。</p><p id="3205" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，像<code class="fe kz la lb lc b">git add .</code>这样的命令会跟踪项目中的每个文件，包括<code class="fe kz la lb lc b">node_modules</code>。但是创建一个<code class="fe kz la lb lc b">.gitignore</code>文件，您可以指示<code class="fe kz la lb lc b">git</code>忽略特定的文件、文件类型，甚至整个目录。</p><p id="1105" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我现在唯一真正需要忽略的是。然而，忽略其他文件几乎总是有意义的，并且在早期忽略它们会让它们随着项目的增长而溜走。我最初的<code class="fe kz la lb lc b">.gitignore</code>是基于<a class="ae jz" href="https://github.com/github/gitignore/blob/master/Node.gitignore" rel="noopener ugc nofollow" target="_blank">为节点项目</a>推荐的模板。我对它进行了删减，排除了我不想实现的文件，并添加了一些我自己的定制:</p><pre class="ly lz ma mb gt mc lc md me aw mf bi"><span id="6153" class="mg mh in lc b gy mi mj l mk ml">.gitignore<br/>==========</span><span id="289e" class="mg mh in lc b gy mm mj l mk ml"><em class="ky"># Cache files  <br/></em>.eslintcache<br/>.npm<br/>*.tsbuildinfo</span><span id="78b4" class="mg mh in lc b gy mm mj l mk ml"><em class="ky"># Directories<br/></em>dist/           # This is the build process will output code.<br/>node_modules/   # The original reason we're here!</span><span id="87da" class="mg mh in lc b gy mm mj l mk ml"><em class="ky"># Env files      # A good safeguard against accidentally publishing<br/></em>.env.           #  private information, including security keys<br/>.env.test</span><span id="6253" class="mg mh in lc b gy mm mj l mk ml"><em class="ky"># Logs<br/></em>*.log<br/>logs<br/>npm-debug.log*</span><span id="c25a" class="mg mh in lc b gy mm mj l mk ml"><em class="ky"># Misc files<br/></em>.DS_Store       # Macs often create this file<br/>notes.md        # Personal project notes, not my reference.</span></pre><p id="3011" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，让我们实现一些类型脚本！</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="1e15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦安装并配置了TypeScript，我就采取三个步骤将我的JavaScript项目转换成TypeScript项目。</p><p id="3fe4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">首先我配置了TypeScript </strong>。这是通过在您的项目中创建一个<code class="fe kz la lb lc b">tsconfig.json</code>文件来实现的，您可以在其中添加您想要的配置选项。像<code class="fe kz la lb lc b">package.json</code>一样，这个文件可能会随着我的项目的复杂性而增长。但是现在，它相对简单:</p><pre class="ly lz ma mb gt mc lc md me aw mf bi"><span id="e377" class="mg mh in lc b gy mi mj l mk ml">tsconfig.json<br/>=============</span><span id="9154" class="mg mh in lc b gy mm mj l mk ml">{<br/>  "compilerOptions": {<br/>    "allowJs": true,            <br/>    "checkJs": true,<br/>    "outDir": "dist",<br/>    "sourceMap": true,<br/>    "target": "ES6",<br/>    "noImplicitAny": true,<br/>    "noImplicitReturns": true,<br/>    "strict": true<br/>  }<br/>}</span></pre><p id="8d1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于TypeScript的一个简短说明:浏览器(目前)不支持TypeScript，它们只支持JavaScript。TypeScript所做的是检查您的<code class="fe kz la lb lc b">.ts</code>代码的类型错误，然后将其转换成JavaScript。例如，<code class="fe kz la lb lc b">index.ts</code>将被转换为<code class="fe kz la lb lc b">index.js</code>——代码将包括TypeScript提供的所有保护，但以浏览器可以理解的方式编写。</p><p id="9555" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述选项可分为三个部分:</p><ul class=""><li id="9ca5" class="ld le in kc b kd ke kh ki kl lf kp lg kt lh kx li lj lk ll bi translated"><code class="fe kz la lb lc b">allowJS</code>和<code class="fe kz la lb lc b">checkJs</code>告诉TypeScript如何处理它遇到的本地JavaScript代码。</li><li id="c4a3" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated"><code class="fe kz la lb lc b">outDir</code>告诉TypeScript将转换后的文件放在哪里，<code class="fe kz la lb lc b">sourceMap</code>指示它将转换后的代码链接回原始代码(对调试有用)，而<code class="fe kz la lb lc b">target</code>告诉它转换成浏览器友好但仍然现代的JavaScript版本。</li><li id="fed1" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated"><code class="fe kz la lb lc b">noImplicitAny</code>、<code class="fe kz la lb lc b">noImplicitReturns</code>和<code class="fe kz la lb lc b">strict</code>对代码施加了一系列额外的测试，IMHO(和TypeScript)提倡最佳实践。</li></ul><p id="54bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二，我将我的包配置为使用TypeScript构建。为此，我对我的<code class="fe kz la lb lc b">package.json</code>文件做了两处修改。我将<code class="fe kz la lb lc b">main: src/index.js</code>改成了<code class="fe kz la lb lc b">main: src/index.ts</code>,以代表我们即将实现的新文件类型。我还加了三个<code class="fe kz la lb lc b">npm scripts</code>:</p><pre class="ly lz ma mb gt mc lc md me aw mf bi"><span id="972c" class="mg mh in lc b gy mi mj l mk ml">package.json:<br/>=============</span><span id="5722" class="mg mh in lc b gy mm mj l mk ml">scripts: {<br/>  "build": "tsc &amp;&amp; npm run build:cp-public",<br/>  "build:cp-public": "cp ./public/** ./dist",<br/>  "type": "tsc --noEmit"<br/>}</span></pre><p id="9ed3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从下往上开始:</p><ul class=""><li id="605e" class="ld le in kc b kd ke kh ki kl lf kp lg kt lh kx li lj lk ll bi translated"><code class="fe kz la lb lc b"><strong class="kc io">type</strong></code> : <code class="fe kz la lb lc b">tsc</code>是TypeScript“命令行解释器”。如前所述，<code class="fe kz la lb lc b">tsc</code>通常会检查类型错误，然后将<code class="fe kz la lb lc b">.ts</code>文件转换为<code class="fe kz la lb lc b">.js</code>文件，并将其写入您选择的目录。如果我只想检查错误而不构建，我添加<code class="fe kz la lb lc b">--noEmit</code>来防止转换&amp;输出。由<code class="fe kz la lb lc b">npm run type</code>触发的<code class="fe kz la lb lc b">type</code>脚本是一个帮助调试的助手命令，而不是每次都要修改代码。</li><li id="5ca4" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated"><code class="fe kz la lb lc b"><strong class="kc io">build:cp-public</strong></code>:如<code class="fe kz la lb lc b">tsconfig.json</code>所述，TypeScript将把转换后的文件放在<code class="fe kz la lb lc b">dist</code>文件夹中。所以，我希望所有的文件，将使建成的网站进入该文件夹。现在，唯一的其他文件是<code class="fe kz la lb lc b">public/index.html</code>——但是后来添加到<code class="fe kz la lb lc b">public</code>的其他文件也应该包括在内。该命令将所有文件从<code class="fe kz la lb lc b">public</code>复制到<code class="fe kz la lb lc b">dist</code>。你会注意到我在命令前加了前缀<code class="fe kz la lb lc b">build:</code>——这告诉我这个命令并不打算独立运行(尽管它可以独立运行)；这是一个帮助命令，使核心命令<code class="fe kz la lb lc b">build</code>更具可读性。</li><li id="3213" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated">两个命令的组合，以及魔法发生的地方。<code class="fe kz la lb lc b">tsc</code>对代码进行类型检查，这次它会将转换后的代码输出到<code class="fe kz la lb lc b">dist</code>目录。然后将<code class="fe kz la lb lc b">public</code>文件复制过来，构建就完成了！</li></ul><p id="35a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">注意:</em> <code class="fe kz la lb lc b">build</code> <em class="ky">命令当前</em> <strong class="kc io"> <em class="ky">会覆盖</em> <code class="fe kz la lb lc b">dist</code> <em class="ky">文件夹中的</em> </strong> <em class="ky">文件。如果您更改文件名，这可能会导致旧文件留在</em> <code class="fe kz la lb lc b">dist</code> <em class="ky">中。最佳实践是在每次构建开始时清空</em> <code class="fe kz la lb lc b">dist</code> <em class="ky">文件夹；然而，我计划在不久的将来以不同的方式实现它，所以我现在跳过它。</em></p><p id="6361" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">终于到了写TypeScript代码的时候了！</strong>我把<code class="fe kz la lb lc b">index.js</code>改成<code class="fe kz la lb lc b">index.ts</code>，看看我需要做哪些编辑。这是我的原始函数:</p><pre class="ly lz ma mb gt mc lc md me aw mf bi"><span id="9ae3" class="mg mh in lc b gy mi mj l mk ml"><em class="ky">function</em> helloWorld() {<br/>  document.getElementById("hello-world").textContent =<br/>    "Hello, World!";<br/>}</span><span id="a044" class="mg mh in lc b gy mm mj l mk ml">helloWorld();</span></pre><p id="126e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在我的IDE中使用了<a class="ae jz" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>，它可以即时识别打字错误。马上，警告我说<code class="fe kz la lb lc b">document.getElementById("hello-world")</code>有问题，因为<code class="fe kz la lb lc b">Object is possibly 'null'.</code>的静态测试在起作用！如果我在一个不包含带有<code class="fe kz la lb lc b">id="hello-world"</code>的元素的HTML文档中运行这个函数，或者如果id拼错了(<code class="fe kz la lb lc b">hell-world</code>，有人知道吗？)那么程序就会崩溃，因为没有元素可以修改它的<code class="fe kz la lb lc b">textContent</code>。在JavaScript中，您将不得不艰难地解决这个问题。</p><p id="f805" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我修改了我的函数。首先，我将尝试找到该元素，只有当它存在时，我才会更新它的内容:</p><pre class="ly lz ma mb gt mc lc md me aw mf bi"><span id="39c7" class="mg mh in lc b gy mi mj l mk ml">function helloWorld() {<br/>  const element= document.getElementById("hello-world");<br/>  <br/>  if (element) {<br/>    element.textContent = "Hello, World!";<br/>  }<br/>}</span><span id="7dd9" class="mg mh in lc b gy mm mj l mk ml">helloWorld();</span></pre><p id="4ea4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">警告信息消失。我运行<code class="fe kz la lb lc b">npm run type</code>，确认没有错误。打字稿是快乐的，我是快乐的，并且<em class="ky">错误被阻止</em>意味着未来<em class="ky">到我的网站</em>的访问者会更快乐。</p><p id="6b3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还需要做最后一个改变。</p><p id="b00c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之前<code class="fe kz la lb lc b">public/index.html</code>拉进了<code class="fe kz la lb lc b">src/index.js</code>，所以它通过路径<code class="fe kz la lb lc b">../src/index.js</code>找到了它。然而，有了新的构建，它们都将在<code class="fe kz la lb lc b">dist</code>文件夹中。所以，我做了如下编辑:</p><pre class="ly lz ma mb gt mc lc md me aw mf bi"><span id="9e36" class="mg mh in lc b gy mi mj l mk ml">&lt;html&gt;<br/>  &lt;body&gt;<br/>    &lt;p <em class="ky">id</em>="hello-world"&gt;&lt;/p&gt;<br/>      &lt;script <em class="ky">src</em>="./index.js"&gt;&lt;/script&gt;  # Simpler import!<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="20d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意<code class="fe kz la lb lc b">index.html</code>指的是转换后的JavaScript文件，而不是原始的TypeScript文件。相信我，这是个容易犯的错误！🤦‍♂</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="0901" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该收拾东西了。首先，我运行<code class="fe kz la lb lc b">npm run build</code>来确保所有新的部分都在工作；我在浏览器中打开<code class="fe kz la lb lc b">dist/index.html</code>，一切正常！我检查我更改的文件，运行<code class="fe kz la lb lc b">git add .</code>来跟踪它们(但不是<code class="fe kz la lb lc b">.gitignore</code>中的那些)，运行<code class="fe kz la lb lc b">git commit</code>来保存我的工作，运行<code class="fe kz la lb lc b">git push</code>来将它存储在GitHub上。</p><p id="74ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">任务完成。该睡觉了。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="9e51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/sjlutterbie/parallel-frameworks-website/commit/1a590cefb26b7491f8db3bee41ae45e9a7bced16" rel="noopener ugc nofollow" target="_blank">本次提交的变化</a> | <a class="ae jz" href="https://github.com/sjlutterbie/parallel-frameworks-website/tree/1a590cefb26b7491f8db3bee41ae45e9a7bced16" rel="noopener ugc nofollow" target="_blank">浏览截至本次提交的回购</a> | <a class="ae jz" href="https://github.com/sjlutterbie/parallel-frameworks-website" rel="noopener ugc nofollow" target="_blank">我今天的回购</a></p><p id="f9d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://simon-lutterbie.medium.com/hello-world-starting-a-web-app-from-a-blank-canvas-9b73fa2cb7e6" rel="noopener"> ←上一篇:你好，世界！</a></p><p id="1b21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://simon-lutterbie.medium.com/refactoring-a-static-html-site-into-typescript-part-1-of-2-the-content-b4c975ecab00" rel="noopener"> →下一篇文章:将静态HTML站点重构为TypeScript，第1部分，共2部分</a></p></div></div>    
</body>
</html>