<html>
<head>
<title>Running JavaScript Functions in Parallel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并行运行JavaScript函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/running-javascript-functions-in-parallel-baf0e2fc6b11?source=collection_archive---------2-----------------------#2021-03-11">https://javascript.plainenglish.io/running-javascript-functions-in-parallel-baf0e2fc6b11?source=collection_archive---------2-----------------------#2021-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cd40ace38d55dd09152c874e1c8d3311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iH6TbcAWnyxB12YYSFDUMQ.jpeg"/></div></div></figure><p id="b8c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个快速教程中，我们将介绍并行执行异步JavaScript函数以及对代码执行时间的影响。</p><h1 id="659c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">问题是</h1><p id="44ca" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设我们需要进行一系列异步函数调用。这可能包括:API调用、超时或者读/写文件(如果使用Node的话)。为了模拟并行运行这些请求的效果，我们将创建一个简单的函数，在解析承诺之前等待2秒钟。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5f44" class="mi kx iq me b gy mj mk l ml mm">function <strong class="me ir">makeRequest</strong>() {<br/>    return new <strong class="me ir">Promise</strong>((<em class="mn">resolve</em>) =&gt;<br/>        <strong class="me ir">setTimeout</strong>(() =&gt; resolve({ status: 'done' }), 2000)<br/>    )<br/>}</span></pre><p id="4e4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从那里，我们将执行请求5次，并测量完成所有请求的时间。为了给我们的函数计时，我们利用了<strong class="ka ir"> <em class="mn"> console.time </em> </strong>和<strong class="ka ir"> <em class="mn"> console.timeEnd. </em> </strong>一旦所有的请求完成，时间(以毫秒为单位)将在控制台中输出，我们返回以停止执行。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="63df" class="mi kx iq me b gy mj mk l ml mm">async function <strong class="me ir">processInOrder</strong>() {<br/>    console.time('Processing In Order')<br/>    for (let i = 0; i &lt; 5; i++) { <br/>        await <strong class="me ir">makeRequest</strong>()<br/>     }<br/>    console.timeEnd('Processing In Order')<br/>    console.log('Processing In Order Complete')<br/>    <strong class="me ir">return</strong>;<br/>}</span></pre><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/34e5f8c948487c70283d38643015ecb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*5CYL09pbmBV5nl_6hlFjcA.png"/></div></figure><p id="1772" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行测试3次后，我们可以看到我们的结果在10秒多一点的时间内几乎相同。这非常有意义，因为我们调用的函数需要2秒来解决5个单独的时间，总共需要10秒。现在，如果我告诉你，我们可以将所有请求的时间缩短到略多于2s。</p><h1 id="b92c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">解决方案</strong></h1><p id="793a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了解决这个问题，我们可以使用<strong class="ka ir"> <em class="mn"> Promise.all — </em> </strong>，它将一个可迭代的承诺作为输入，并返回一个承诺，该承诺解析为输入承诺的结果数组。只有当输入的所有 都已解决时，该返回的承诺才会解决。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d028" class="mi kx iq me b gy mj mk l ml mm">const <em class="mn">arrayOfPromises</em> = [<br/>    <strong class="me ir">makeRequest</strong>(),<br/>    <strong class="me ir">makeRequest</strong>(),<br/>    <strong class="me ir">makeRequest</strong>(),<br/>    <strong class="me ir">makeRequest</strong>(),<br/>    <strong class="me ir">makeRequest</strong>()<br/>]</span><span id="56fd" class="mi kx iq me b gy mp mk l ml mm">async function <strong class="me ir">processParallel</strong>(<em class="mn">arrayOfPromises</em>) {<br/>    console.time('Processing Parallel')<br/>    await Promise.all(<em class="mn">arrayOfPromises</em>)<br/>    console.timeEnd('Processing Parallel')<br/>    console.log('Processing Parallel Complete  \n')<br/>    return;<br/>}</span><span id="3d78" class="mi kx iq me b gy mp mk l ml mm"><strong class="me ir">processParallel</strong>(<em class="mn">arrayOfPromises)</em></span></pre><p id="2378" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们非常接近每次运行两秒钟的完美时间。无论是编写客户端代码还是服务器端代码，这都是加速JavaScript的好方法。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/48c8e511f658745a6ad5a2294df7e40e.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*58hSfAhInzrSmCZRpDUegg.png"/></div></figure><p id="52bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在某些情况下，您的后端必须处理对数据库或外部API的多个请求，这是性能至关重要的地方，并且使用<strong class="ka ir"> <em class="mn"> Promise.all </em> </strong>并行运行请求确实很出色。</p></div></div>    
</body>
</html>