<html>
<head>
<title>The Power of JavaScript Purity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript纯净的力量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-power-of-javascript-purity-220a28339caa?source=collection_archive---------12-----------------------#2021-10-04">https://javascript.plainenglish.io/the-power-of-javascript-purity-220a28339caa?source=collection_archive---------12-----------------------#2021-10-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7c26" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">深入探讨如何、为什么以及何时使用纯函数</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9de90d08b264512b5ca12582c357fcc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hse1Oq9LWBXyJIHQCgp7dQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@arobj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Adam Jaime</a> on <a class="ae ks" href="https://unsplash.com/s/photos/bar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5aed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个男人走进一家酒吧，服务员给他拿来一杯水。喝完水后，男人点了一杯酸威士忌。服务员没有用新杯子盛酒，而是用苏格兰威士忌、柠檬汁和糖给水杯续杯。难以置信，对吧？当我点一杯饮料时，我希望它是直接从洗碗机里拿出来装在干净的玻璃杯里的。我不想重复使用已经喝过的杯子。这样，我知道我可以继续点饮料，而且里面的东西和以前点的没有任何区别。</p><p id="3a98" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用计算机科学的术语来说，廉价酒吧的水变成威士忌的场景可以被看作是一种<em class="lp">突变</em>或者是一种<em class="lp">副作用</em>。一些功能——served link——直接改变男人杯子里的内容。顾客的玻璃变异了。</p><p id="4813" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">相比之下，大多数酒吧用单独的杯子提供每一种新饮料，对吗？这个过程可以和一个纯函数<em class="lp">相媲美。功能<strong class="kv io">served link</strong>不会直接影响客户的玻璃。相反，它提供了一个全新的杯子，不管要求如何，给任何想要的人(并且愿意付钱！).</em></p><p id="6275" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">理解这些差异对于开发人员来说很重要，因为它鼓励我们编写更简洁、可重用的代码。此外，决定何时(何时)应用纯函数的能力是一个真正务实的程序员的标志。如果你还没有完全理解这个概念，没问题。让我们深入研究一下，看一些例子。</p><h1 id="862f" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">首先，什么是纯函数？</h1><p id="8cf2" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">纯函数相当简单。它们是函数或方法。他们可能会接受争论。他们不修改他们的论点。他们不修改他们<a class="ae ks" href="https://www.w3schools.com/js/js_scope.asp" rel="noopener ugc nofollow" target="_blank">功能范围</a>之外的任何东西。每次给定相同的参数，它们都返回相同的值。这里有几个<em class="lp">专业</em>的定义。</p><p id="1700" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据<a class="ae ks" href="https://www.sitepoint.com/functional-programming-pure-functions/" rel="noopener ugc nofollow" target="_blank">测点</a>:</p><blockquote class="mn"><p id="e610" class="mo mp in bd mq mr ms mt mu mv mw lo dk translated"><em class="mx">“纯函数是返回值仅由其输入值决定的函数，没有可观察到的副作用。”</em></p></blockquote><p id="aed6" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">维基百科说它遵循这两条规则:</p><blockquote class="mn"><p id="fe6d" class="mo mp in bd mq mr ms mt mu mv mw lo dk translated"><em class="mx"> 1。对于相同的参数，函数返回值是相同的(没有局部静态变量、非局部变量、可变引用参数或输入流的变化)。</em></p><p id="2a08" class="mo mp in bd mq mr ms mt mu mv mw lo dk translated"><em class="mx"> 2。函数应用程序没有副作用(没有局部静态变量、非局部变量、可变引用参数或输入/输出流的突变)。</em></p></blockquote><p id="2e2a" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">如果您仍然没有理解什么是纯函数，不要担心，让我们看几个使用JavaScript的例子:</p><h1 id="fae4" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">示例1:一个简单的连接</h1><p id="8e71" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">假设我们正在编写一些JavaScript应用程序，在与我们正在处理的模块相同的目录中，我们有一组png图像。每个图像的名称都与我们在当前作用域中使用的一些字符串变量的名称相匹配。现在，我们需要编写一个附加文件扩展名的函数。png "到字符串的末尾。让我们使用三种不同的功能设计风格来尝试一下:突变、副作用和纯粹。</p><h1 id="c713" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">突变(不纯)</h1><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="e467" class="ni lr in ne b gy nj nk l nl nm">function appendPng(image){ <br/>    image += ".png"<br/>}</span></pre><p id="5969" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，我们取一个字符串，只是将字符串<em class="lp"> "png" </em>附加到它的末尾。这种方法实际上会<em class="lp">改变</em>所提供的论点。换句话说，它在内存中的值会发生变化。没错，每次我们调用<em class="lp"> appendPng </em>并传入一个变量<em class="lp">，</em>那个变量的值就会追加字符串<em class="lp">。png" </em>并且永远不会相同(当然，除非您将它重新赋值或重新变异为其初始值)。</p><p id="7c4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在许多语言中，这种变异有时会很有成效。这真的取决于场景。我们可能不希望重用某个值，这就是为什么我们要使用这个策略。然而，它不是一个纯粹的函数，因为它改变了所提供的参数。此外，该函数不返回值。根据经验，<a class="ae ks" href="https://www.cs.fsu.edu/~cop3014p/lectures/ch7/index.html#:~:text=Void%20functions%20are%20created%20and,does%20not%20return%20a%20value." rel="noopener ugc nofollow" target="_blank"> void </a>函数通常是不纯的。</p><h1 id="b482" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">副作用(不纯)</h1><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="b3ef" class="ni lr in ne b gy nj nk l nl nm">let animal = "cat"</span><span id="5f88" class="ni lr in ne b gy nn nk l nl nm">function appendPng(){<br/>    animal += ".png"<br/>}</span></pre><p id="85fa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个函数不纯有两个原因。首先，它变异了一个全局/局部范围的变量，<em class="lp"> animal，</em>，这意味着它执行了一个<strong class="kv io">副作用</strong> <em class="lp">。</em>其次，它不返回值。最后，这个方法完成了我们添加的目标。png”转换为字符串，但是，这远远不符合纯功能性的规则。</p><p id="5587" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于这种方法，我想提到的另一点与内存管理有关。JavaScript使用了一个<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">垃圾收集器</a>，它通常会拾取我们用完的变量以节省一些内存，然而，它可能无法在这里完成它的工作。JavaScript可能会忽略垃圾收集<em class="lp">动物</em>，因为它在<em class="lp"> appendPng </em>中被引用。换句话说，只要<em class="lp">附肢</em>还在记忆中，那么<em class="lp">动物</em>也一定在记忆中。这很不幸，因为如果我们继续遵循这种编写函数的策略，那么我们的应用程序可能无法随着增长而扩展并保持最佳性能。</p><p id="813c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，我认为最好养成编写如下函数的习惯:</p><h1 id="c242" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">纯函数(纯！)</h1><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="5f77" class="ni lr in ne b gy nj nk l nl nm">function appendPng(image){<br/>    return `${image}.png`<br/>}</span><span id="cf30" class="ni lr in ne b gy nn nk l nl nm">//or with arrow functions...</span><span id="38ef" class="ni lr in ne b gy nn nk l nl nm">const appendPng = (image) =&gt; `${image}.png`</span><span id="90f8" class="ni lr in ne b gy nn nk l nl nm">//or using the + operator</span><span id="fb8b" class="ni lr in ne b gy nn nk l nl nm">const appendPng = (image) =&gt; image + ".png"</span></pre><p id="b2d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些都是纯函数，因为无论我们调用它们多少次，无论我们何时调用它们，给定相同的输入，它们总是返回相同的输出。此范围内使用的值是一个参数(图像)和一些字符(。png)。此外，它不会改变其函数范围之外的任何变量。取而代之的是，它返回一个新的值。png”到它的参数，它没有变异。</p><h1 id="9fa4" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">3之间最突出的区别</h1><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="7c6a" class="ni lr in ne b gy nj nk l nl nm">let animal = "cat"</span><span id="b18a" class="ni lr in ne b gy nn nk l nl nm">---Mutation---</span><span id="82f7" class="ni lr in ne b gy nn nk l nl nm">const animal_image = appendPng(animal) <br/>animal_image //"cat.png"<br/>animal //"cat.png"</span><span id="13c2" class="ni lr in ne b gy nn nk l nl nm">---Side effect---</span><span id="9a4d" class="ni lr in ne b gy nn nk l nl nm">const animal_image = appendPng(animal) <br/>animal_image //"cat.png"<br/>animal //"cat.png"</span><span id="ab0c" class="ni lr in ne b gy nn nk l nl nm">---Pure function---</span><span id="2b40" class="ni lr in ne b gy nn nk l nl nm">const animalImage = appendPng(animal) <br/>animal_image //"cat.png"<br/>animal //"cat"</span></pre><p id="f349" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是最显著的差异发挥作用的地方，纯粹的功能闪耀登场。假设我们想要声明一个新变量，<em class="lp"> animal_image </em>，它包含图像的引用，而不改变我们的原始字符串。在我们描述的选项中，使用pure函数是我们可以做到这一点的唯一方法。</p><blockquote class="mn"><p id="57f1" class="mo mp in bd mq mr ms mt mu mv mw lo dk translated">P-U-R-E …不是… P-U-R-R</p></blockquote><figure class="np nq nr ns nt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/85add678f279e39b97e9233be588effd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nf7Cx9x7Wj4XlAovaGRuw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@corinarainer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Corina Rainer</a> on <a class="ae ks" href="https://unsplash.com/s/photos/purr?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="262c" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">示例2:使用Array.prototype.filter</h1><p id="7a28" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">Javascript数组固有地拥有支持纯函数实践的方法，如map、filter和reduce。让我们通过创建一个从数组中删除字符串的函数来看看filter的作用。</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="781e" class="ni lr in ne b gy nj nk l nl nm">const removeStrings = (arr) =&gt; <br/>    arr.filter(el =&gt; typeof el !== "string")</span></pre><p id="aa3d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，我们遵循相同输入相同输出的规则。此外，这里需要注意的一件重要事情是Array.prototype.filter方法创建了一个新的<em class="lp">数组，并没有修改现有的数组。</em></p><p id="3b9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">行动中:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="bfe8" class="ni lr in ne b gy nj nk l nl nm">let a = [ 1, "by", true]<br/>let b = removeStrings(a) </span><span id="78e8" class="ni lr in ne b gy nn nk l nl nm">b.push("something else")</span><span id="89ed" class="ni lr in ne b gy nn nk l nl nm">a // [1, "by", true]<br/>b // [1, true, "something else"]</span></pre><p id="9f24" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你所看到的，<em class="lp"> a </em>保持了它原来的形式，而<em class="lp"> b </em>有点像是建立在<em class="lp"> a </em>之上的。这些变量和它们的内容在内存中拥有不同的地址，除了它们的值相似之外，彼此没有关系。您可以通过修改其中一个继续工作，而不会无意中更改另一个。</p><h1 id="de3a" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">例3对象和数组，命运的转折</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/0d0be80e50ab198bf1a032066a62ec57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J90c8MJfS64piRwEkZrDwg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@marcus_ganahl?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Marcus Ganahl</a> on <a class="ae ks" href="https://unsplash.com/s/photos/interstellar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ddfb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我们生活在一个未来世界，几个世纪后，人类终于变成了星际人。不仅如此，我们经常乘坐一些瑞克&amp;莫蒂级别的宇宙飞船。为了在太空深处导航，我们需要在车辆中存储一些空间地图数据。出于例证和高度简化的目的，让我们假设我们的地图是一组对象，例如:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="422e" class="ni lr in ne b gy nj nk l nl nm">{<br/>    id: 324234,<br/>    name: "Zorgon 34C",<br/>    government: "Zorgonthian Empire", <br/>    passport_required: true, <br/>    parallax_angle: 67.2982,<br/>    distance: 654656,<br/>}</span></pre><p id="24a9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了扩展我们的地图，我们可以冒险进入新的领域(不推荐，因为许多文明对加入星际联盟犹豫不决)，或者我们可以在一家名为Map Express的商店购买新的地图数据(推荐)。随着星际联盟的成长和宇宙的扩张,《地图快递》不断增加它在宇宙中的领土清单😂。让我们来看看他们如何将购买的数据加载到您的车辆上的两种方式:</p><h2 id="0ae8" class="ni lr in bd ls nv nw dn lw nx ny dp ma lc nz oa mc lg ob oc me lk od oe mg of bi translated">纯方法(可能未被Map Express使用)</h2><p id="f521" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">由于星际地图黑客水平很高，Map Express决定将其所有地图数据保存在本地。换句话说，他们不会将它存储在单独的数据库中。因此，不再是每次顾客提出请求时由<em class="lp">获取</em>数据，而是商店简单地将顾客指向适当的功能，如下所示:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="0425" class="ni lr in ne b gy nj nk l nl nm">const buy_Cheshire_92B = (customer_map) =&gt; <br/>    [ <br/>        ...customer_map, <br/>        {<br/>            id: 20919302,<br/>            name: "Cheshire 92B",<br/>            government: "Cheshire Cat Kingdom", <br/>            passport_required: true, <br/>            parallax_angle: 67.2982,<br/>            distance: 654656,<br/>        }<br/>    ]</span></pre><p id="ae06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，每次调用该函数时，它都会使用<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/the-secret-to-es6-spread-syntax-4066140678e0">扩展语法</a>克隆客户的地图，并将请求的区域附加到该克隆中。这是一种纯粹的方法，因为它不会改变它的参数，也不会导致任何副作用。</p><p id="bfde" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">尽管它很纯粹，但对于像Map Express这样的新兴企业来说，这可能不是最好的做法。随着他们的库存越来越大，他们将需要通过编写越来越多的函数来进行扩展。更好的方法可能是编写一个通用(非纯)函数，并利用安全的现代API和数据库技术来存储他们的地图数据。</p><h2 id="55ef" class="ni lr in bd ls nv nw dn lw nx ny dp ma lc nz oa mc lg ob oc me lk od oe mg of bi translated">非纯方法(更可能使用)</h2><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="ac9a" class="ni lr in ne b gy nj nk l nl nm">const buy_territory_map = async (customer_map, requested_territory) =&gt; {<br/>    const territory_map = await fetch(MapExpressAPI, requested_territory);<br/>    return [ ...customer_map, territory_map ]<br/>}</span></pre><p id="8073" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">演示的方法<em class="lp"> buy_territory_map </em>是<strong class="kv io">而不是纯粹的</strong>，因为它向Map Express构建的一些外部api发出网络请求。虽然很有可能这个请求确实会返回相同的数据，但总是有可能外部数据库中的某些内容被更新。因此，尽管使用了一些纯代码原则，如使用spread语法进行克隆，但不能认为这个函数是纯函数。</p><p id="debd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">也就是说，这就引出了一个关于<strong class="kv io">的重要话题，当</strong> <strong class="kv io">不</strong>使用纯函数时。Map Express平台的架构师应该已经决定使用这种非纯粹的方法，因为它的可扩展性更好。例如，每次Map Express添加一个新的地图到它的目录中，它不需要为它编写一个全新的函数！</p><p id="e12d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们来看看最后一种方法，它结合了我们刚刚看到的两种方法。(如果你对高阶函数不感兴趣，跳过这一步。)</p><h2 id="a7af" class="ni lr in bd ls nv nw dn lw nx ny dp ma lc nz oa mc lg ob oc me lk od oe mg of bi translated">好处# 1——几乎是一种纯粹的方法，但不完全是(可能使用过！)</h2><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="5e3a" class="ni lr in ne b gy nj nk l nl nm">const buy_map_territory = async (requested_territory) =&gt; {<br/>    const territory_map = await fetch(MapExpressAPI, requested_territory);<br/>    return (customer_map) =&gt; <br/>        [ <br/>            ...customer_map, <br/>            territory_map<br/>        ]<br/>}</span></pre><p id="540f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一种有趣的方法。基本上，我们创建一个名为<em class="lp"> buy_map_territory </em>的通用函数，它返回另一个函数！函数<em class="lp"> buy_map_territory </em>从我们的外部<em class="lp"> MapExpressAPI </em>异步存储请求的区域地图。返回的函数(未命名)只是通过扩展(克隆)客户的旧地图并向其追加新的区域来返回新定义的地图。</p><p id="dc43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">哇，等等，什么！？酷，我知道。</p><p id="6208" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些类型的函数通常以下列方式使用:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="3c94" class="ni lr in ne b gy nj nk l nl nm">const buy_earth_map = await buy_map_territory("Earth")</span><span id="f543" class="ni lr in ne b gy nn nk l nl nm">const JohnsNewMap = buy_earth_map(JohnsMap)</span><span id="e873" class="ni lr in ne b gy nn nk l nl nm">const SallysNewMap = buy_earth_map(SallysMap)</span><span id="1b28" class="ni lr in ne b gy nn nk l nl nm">const CindysNewMap = await buy_map_territory("Morag")(CindysMap)</span></pre><p id="0b6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，声明一个新函数，该函数只执行我们的网络请求一次，并将结果存储在<em class="lp"> territory_map </em>中。这有助于避免对同一地区的进一步网络请求。换句话说，每次我们调用<em class="lp"> buy_earth_map </em>时，我们不需要再次执行我们的请求。</p><p id="1a1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其次，为了快速获得我们的最终返回值，一个新的区域地图数组。</p><p id="c598" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" rel="noopener ugc nofollow" target="_blank">高阶函数</a>方法很有用，因为有时我们可能想要执行前者，而其他时候可能想要执行后者。</p><h2 id="8cf4" class="ni lr in bd ls nv nw dn lw nx ny dp ma lc nz oa mc lg ob oc me lk od oe mg of bi translated">好处# 2——深度嵌套克隆</h2><p id="93be" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">如果我们打算编写纯函数，特别重要的是密切关注对象和/或类似对象的数据类型(如数组和函数)，因为它们在内存中的处理方式。让我们以我们的星系际场景为例。假设，不是我们最初演示的类型，而是像这样存储区域地图:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="8ba6" class="ni lr in ne b gy nj nk l nl nm">{<br/>    id: 324234,<br/>    name: "Zorgon 34C",<br/>    government: "Zorgonthian Empire", <br/>    passport_required: true, <br/>    location: { <br/>        parallax_angle: 67.2982,<br/>        distance: 654656 <br/>    }<br/>}</span></pre><p id="1d61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，重要的是要知道如何按照我们之前的方式分布客户的地图阵列:</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="6ccc" class="ni lr in ne b gy nj nk l nl nm">[ ...customer_map ]</span></pre><p id="8496" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">会不会<strong class="kv io">不</strong>保持纯函数属性为真。这是因为常用的克隆方法如spread语法和Object.assign <a class="ae ks" href="https://stackoverflow.com/questions/38416020/deep-copy-in-es6-using-the-spread-syntax" rel="noopener ugc nofollow" target="_blank">执行<strong class="kv io">浅</strong>克隆(或一级深)</a>。换句话说，<em class="lp"> customer_map </em>数组及其对象的第一层将被成功克隆，但是，更深层次的嵌套对象(如<em class="lp"> location </em>)仍将引用它们在内存中的原始位置。这可能会也可能不会导致问题，具体取决于您的代码的其余部分。如果我在一个函数中结合了纯方法和非纯方法，我最常遇到的问题是，我可能会使用像redux这样的库，当你尝试改变状态值时，它真的不喜欢。</p><h1 id="d566" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">回到酒吧</h1><p id="1a70" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">让我们使用纯函数方法在JavaScript中实现我们的bar类比，并最终完成它！</p><pre class="kd ke kf kg gt nd ne nf ng aw nh bi"><span id="077c" class="ni lr in ne b gy nj nk l nl nm">const customer1 = {<br/>    drink: "Water",<br/>    name: "John",<br/>    amountOwed: 0<br/>}</span><span id="94b5" class="ni lr in ne b gy nn nk l nl nm">function serveDrink(order, customer){<br/>    return { <br/>        ...customer, <br/>        drink: order.drink, <br/>        amountOwed: customed.amountOwed + order.price <br/>    }<br/>}</span><span id="e84f" class="ni lr in ne b gy nn nk l nl nm">const customer1AfterDrink = serveDrink({ drink: "Tequila", price: 5 }, customer1);</span></pre><p id="cc3b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你现在应该明白这是怎么回事了。</p><h2 id="c041" class="ni lr in bd ls nv nw dn lw nx ny dp ma lc nz oa mc lg ob oc me lk od oe mg of bi translated">结论</h2><p id="8fbb" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">的确，纯函数并不总是一个选项。事实上，我作为JavaScript开发人员编写的大多数应用程序都是建立在副作用之上的。用户界面通常是基于副作用构建的。副作用和突变使我们的屏幕表现得很棒！我发现纯函数在创建<em class="lp"> utility- </em>这样的旨在全面使用的方法时，以及在处理React和Redux这样的库时最有用。</p><p id="a46c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">总之，让我们不要直接改变顾客杯子里的东西(除非是一杯接一杯的水),而是为每一杯点的饮料提供一个新杯子。我们最终可能会得到更好的小费！</p><p id="02a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>