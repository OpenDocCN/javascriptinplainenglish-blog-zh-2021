<html>
<head>
<title>Lazy loading Angular applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">惰性加载角度应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lazy-loading-angular-applications-62ee1518b219?source=collection_archive---------10-----------------------#2021-03-28">https://javascript.plainenglish.io/lazy-loading-angular-applications-62ee1518b219?source=collection_archive---------10-----------------------#2021-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ed5f8400d0967166319650fc17acaab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vivqKYnn74_BVp4DlQdTag.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Picture courtesy of <a class="ae kc" href="https://unsplash.com/@grievek1610begur" rel="noopener ugc nofollow" target="_blank">Kevin Grieve</a></figcaption></figure><p id="8c50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lb">非常罕见的</em>情况下，您可能想要延迟加载您的Angular应用程序。在本文中，我将向您展示如何做到这一点。</p><p id="0329" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">警告</em> </strong> <em class="lb">:不要轻举妄动。仔细评估你是否真的需要这样做，因为这会对用户体验产生毁灭性的影响！</em></p><h1 id="11dd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">角度模块导入副作用</h1><p id="3ad9" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在我的<a class="ae kc" href="https://dsebastien.net/blog/2021-03-28-angular-application-bootstrap" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我简要解释了Angular应用程序的引导过程。我在那里提到的一件事是，导入语句保留在运行时，由Webpack处理。</p><p id="b319" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我没有提到的是，当Webpack导入一个Angular模块时会发生什么；例如，使用以下代码行:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5dae" class="mo ld iq mk b gy mp mq l mr ms">import { AppModule } from './app/app.module';</span></pre><p id="9d06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您看到这一行时，您可能会认为除了<code class="fe mt mu mv mk b">AppModule</code>被加载并可用于当前模块的其余部分之外，没有发生什么。实际上这里有一个副作用！</p><p id="8e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要Webpack加载一个Angular模块，附加到Angular模块的类的装饰器就会被执行。我通过一个例子来解释一下:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dbfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，这是角度1–01模块。这是一个简单的类，带有包含元数据的装饰器。但是你可能不知道的是，decorators不仅仅是<em class="lb">元数据。</em></p><p id="1014" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">装饰者实际上是附加在元素上的<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank">函数</a>(例如，类、方法、访问器等)。它们接收修饰元素作为参数，并可以随意修改它们。TypeScript/JavaScript装饰器实际上是<a class="ae kc" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank">装饰器设计模式</a>的实例。</p><p id="7ca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这里有趣的问题是<em class="lb">装饰函数何时执行！当附加到一个类时，一旦类声明被执行，装饰器就被执行<a class="ae kc" href="https://stackoverflow.com/questions/50182601/when-does-decorator-code-execute" rel="noopener ugc nofollow" target="_blank">。由于Angular模块类通常是在顶层声明的，所以Webpack一加载es模块，类声明就会被执行<em class="lb">！</em></a></em></p><p id="b63d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，回到这一行:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fea0" class="mo ld iq mk b gy mp mq l mr ms">import { AppModule } from './app/app.module';</span></pre><p id="acec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这显然是<em class="lb">而不是</em>无副作用的代码！模块一加载，就执行模块的类声明，相关的装饰函数也是如此！记住这一点很重要；我一会儿会回到这个话题。</p><h1 id="20da" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">有问题的情况</h1><p id="2209" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在开始“如何做”之前，让我描述一下延迟加载Angular应用程序有意义的情况。</p><p id="9c9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我目前从事的项目中，我们使用了<a class="ae kc" href="https://github.com/auth0/auth0-angular" rel="noopener ugc nofollow" target="_blank"> Auth0 Angular SDK </a>。该库负责认证过程。此外，它还提供了一个Angular HTTP拦截器，可用于将OAuth访问令牌附加到相关的传出HTTP请求(例如，后端API调用)。</p><p id="6b7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让HTTP拦截器工作，必须加载SDK的<code class="fe mt mu mv mk b">AuthModule</code>，并配置<a class="ae kc" href="https://github.com/auth0/auth0-angular#configure-authhttpinterceptor-to-attach-access-tokens" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8df9" class="mo ld iq mk b gy mp mq l mr ms">AuthModule.forRoot({<br/>  domain: 'YOUR_AUTH0_DOMAIN',<br/>  clientId: 'YOUR_AUTH0_CLIENT_ID',<br/>  httpInterceptor: {<br/>      allowedList: [ ... ],<br/>      ...<br/>  },<br/>  ...<br/>}),</span></pre><p id="b1ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，一切顺利。你可能会问的问题在哪里？上面的<code class="fe mt mu mv mk b">allowedList</code>是一个URL/URL模式列表，HTTP拦截器将使用它来确定访问令牌是否应该附加到请求上。在我们的应用程序中，我们不想简单地硬编码这个列表，因为它在不同的环境中会有所不同。在配置<code class="fe mt mu mv mk b"> AuthModule</code>之前，我们首先需要加载环境配置文件。环境配置文件是一个静态JSON文件，包含当前环境的配置。</p><p id="9e50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，Auth0 Angular SDK提供了一种方法来<a class="ae kc" href="https://github.com/auth0/auth0-angular#dynamic-configuration" rel="noopener ugc nofollow" target="_blank">推迟模块</a>的配置，使用一个<code class="fe mt mu mv mk b">APP_INITIALIZER</code>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好，问题解决了…还是没有？</p><p id="dd30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，我们的情况不是这样！为什么？因为我们的应用程序已经有了其他的应用程序初始化器，其中一些需要注入一个<code class="fe mt mu mv mk b">HttpClient</code>实例。这就是开箱即用的解决方案让我们失望的地方。一旦需要在应用程序中的某个地方注入<code class="fe mt mu mv mk b">HttpClient</code>，Auth0 HTTP拦截器就会被实例化。如果在那个时间点Auth0模块还没有配置，那么拦截器就会崩溃，出现错误<a class="ae kc" href="https://github.com/auth0/auth0-angular/issues/70" rel="noopener ugc nofollow" target="_blank">解释配置丢失。多。</a></p><p id="7f13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经典的鸡和蛋的问题！</p><p id="5dce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，我们不能轻易地摆脱对其他初始化器中的<code class="fe mt mu mv mk b">HttpClient</code>的依赖；我们唯一的解决方案是在Angular应用程序启动之前加载配置，并延迟对<code class="fe mt mu mv mk b">AppModule</code>装饰器的评估，以确保我们的配置在运行时已经加载/可用。</p><p id="3eeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是为什么呢？正如我们所看到的，因为模块一导入，<code class="fe mt mu mv mk b">AppModule</code>上的<code class="fe mt mu mv mk b">@NgModule</code>装饰器就会被执行，默认情况下<code class="fe mt mu mv mk b">main.ts</code>会导入它。</p><p id="775e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在让我们看看<em class="lb">如何</em>延迟角度应用的自举。</p><h1 id="dad7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">延迟加载和执行角度</h1><p id="f182" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">延迟加载/执行角度应用的关键在默认入口点:<code class="fe mt mu mv mk b">main.ts</code>。</p><p id="a370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个想法是推迟<code class="fe mt mu mv mk b">platformBrowserDynamic().bootstrapModule(...)</code>被召唤的时刻。但是正如我之前在这篇文章中暗示的，光有<em class="lb">还不够。如果我们想避免由<code class="fe mt mu mv mk b">AppModule</code>导入引起的副作用，我们也需要去掉那个import语句。</em></p><p id="dfac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们不导入<code class="fe mt mu mv mk b">AppModule</code>，那么如何引导它呢？幸运的是，Angular支持<a class="ae kc" href="https://angular.io/guide/lazy-loading-ngmodules" rel="noopener ugc nofollow" target="_blank">延迟加载模块</a>:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9613" class="mo ld iq mk b gy mp mq l mr ms">const routes: Routes = [<br/>  {<br/>    path: 'items',<br/>    loadChildren: () =&gt;<br/>      import('./items/items.module').then((m) =&gt; m.ItemsModule),<br/>  },<br/>];</span></pre><p id="88ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports" rel="noopener ugc nofollow" target="_blank">动态导入</a>完成角度模块的延迟加载。此类导入仅在需要时执行。</p><p id="5df2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经有了拼图的所有部分:</p><ul class=""><li id="c4d8" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">移除<code class="fe mt mu mv mk b">AppModule</code>顶层导入</li><li id="f1d9" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">将呼叫延迟到<code class="fe mt mu mv mk b">platformBrowserDynamic().bootstrapModule(...)</code></li></ul><p id="d446" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看解决方案:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我解释一下这是如何工作的。首先，如前所述，我们不导入<code class="fe mt mu mv mk b">AppModule</code>。其次，我们使用<code class="fe mt mu mv mk b">runtimeConfigLoader$</code> observable加载应用程序的运行时配置。一旦加载了配置(第32+行)，我们将配置存储在<code class="fe mt mu mv mk b">sessionStorage</code>中——这是一个任意的选择；也可能是<code class="fe mt mu mv mk b">localStorage</code>或其他方式。</p><p id="9d95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们使用以下公式切换到不同的可观察值:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="be46" class="mo ld iq mk b gy mp mq l mr ms">return from(import('./app/app.module')).pipe(<br/>  concatMap((mod) =&gt; {<br/>    platformBrowserDynamic().bootstrapModule(mod.AppModule);<br/>    return of(void 0);<br/>  })<br/>);</span></pre><p id="4f02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mk b">import</code>语句返回一个<code class="fe mt mu mv mk b">Promise</code>，它为我们提供了es模块。一旦ES模块可用(第49+行)，我们最后使用<code class="fe mt mu mv mk b">platformBrowserDynamic().bootstrapModule(...)</code>加载Angular并引导<code class="fe mt mu mv mk b">AppModule</code>。</p><p id="3663" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你有了它，一个角度应用程序的延迟加载。当然，上面的代码对应于一个特定的场景，但是同样的方法也可以用来按需加载Angular应用程序。</p><h1 id="4e7c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="532c" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在本文中，我解释了导入Angular模块会有副作用，我还解释了如何避免这些副作用，以及如何惰性地引导Angular应用程序。</p><p id="e9bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，应该避免这种情况，因为它会降低应用程序的启动速度，并且会对用户体验产生非常负面的影响。</p><p id="1df6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天到此为止！</p><p id="37c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PS:如果你想了解大量关于产品/软件/web开发的其他很酷的事情，那么<a class="ae kc" href="https://dev-concepts.dev" rel="noopener ugc nofollow" target="_blank">看看开发概念系列</a>，<a class="ae kc" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">订阅我的时事通讯</a>，还有<a class="ae kc" href="https://twitter.com/dSebastien" rel="noopener ugc nofollow" target="_blank">来Twitter上打个招呼吧！</a></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="0422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">原载于2021年3月28日https://dsebastien.net</em><em class="lb"/><a class="ae kc" href="https://dsebastien.net/blog/2021-03-28-loading-an-angular-app-lazily" rel="noopener ugc nofollow" target="_blank"><em class="lb">。</em></a></p></div></div>    
</body>
</html>