<html>
<head>
<title>Angular meets RxJS: RxJS operators (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular符合RxJS: RxJS运算符(第2部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-meets-rxjs-rxjs-operators-60d8b2140d20?source=collection_archive---------12-----------------------#2021-03-09">https://javascript.plainenglish.io/angular-meets-rxjs-rxjs-operators-60d8b2140d20?source=collection_archive---------12-----------------------#2021-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/007c66de6d43da774a664d4cdac5cdcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dCMvH-L8BJr5jdpD"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@mitchkmetz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mitchell Kmetz</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7945" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="5327" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这篇文章属于名为“<strong class="la io"> Angular meets RxJS </strong>”的系列文章，在这篇文章中，我尽我所能在“Angular”上下文中使用“RxJS”来解释反应式编程。</p><h1 id="0894" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">目录</h1><p id="cda6" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-basic-concepts-f178d8fe0e02">基本概念</a> <br/> <a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3"> RxJS科目</a> <br/> <a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e"> RxJS运算符(第1部分)</a> <br/> RxJS运算符(第2部分)<br/> <a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-e64caa5f72e7" rel="noopener"> RxJS运算符(第3部分)</a><br/><a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d" rel="noopener">“take until”和“async”管道</a> <br/> <a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-higher-order-observables-632e560ce2d0" rel="noopener">高阶可观察量</a> <br/> <a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-error-handling-8fad48721e49" rel="noopener">错误处理</a> <br/> RxJS调度器(即将推出)<br/></p><h1 id="5ea3" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">在上一篇文章中…</h1><p id="51a2" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">…我们讨论了函数式编程、大理石图和创建运算符。我们用它们从常规值中或通过组合其他可观察值来创建可观察值。现在，我们将看到另一种类型的操作符:可管道操作符。这些算符用于将一个可观测值转换成另一个可观测值。</p><p id="ef5c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">有一百多个操作符，所以很明显，我不会一一列举。事实上，我将把重点放在最流行和最有用的方面。然而，如果你有任何问题，或者如果你认为我忘记了一个重要的问题，请在评论中告诉我，我会更新文章。</p><h1 id="0815" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">管</h1><p id="99b4" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">“管道”是一个函数，您可以在一个源可观察对象上调用它来应用操作符。理解“pipe”函数返回一个与源不同的<strong class="la io">可观察值</strong>很重要，称为<strong class="la io">输出可观察值</strong>。换句话说，这些操作符获取一个源可观察对象，对发出的值执行一些操作，并返回一个将发出转换后的值的输出可观察对象。您不需要像操作符那样多次调用“pipe ”,您可以在一次“pipe”调用中链接它们。如果还不清楚也不用担心，会在“地图”操作员的解释之后。</p><h1 id="1c47" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">地图</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/83754b7d8cb27ec3329e99091360bbb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6qqadiwENzvAUd6h64GuA.png"/></div></div></figure><p id="7bcc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">“map”操作符获取一个源可观测值，并通过对源可观测值发出的每个值应用投影来返回另一个可观测值。让我们以下面的代码为例:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5364" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这里，我们使用“pipe”函数对源可观察对象应用“map”操作符，以便返回另一个可观察对象,它发出源可观察对象的每个值的投影。这样做的结果是“subscribe”实际上是在输出可观察对象上调用的，而不是在源可观察对象上调用的，所以subscribe实际上不是对“observable$”的订阅，而是对“pipe”函数返回的可观察对象的订阅。</p><p id="1a42" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">执行这段代码会产生以下结果:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/4ed9278098b1fb2001ac59b150f30fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsHfm9VR2wYEajDBNpw0tw.png"/></div></div></figure><p id="28dd" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">所以基本上，这段代码的执行可以分为以下几个步骤:</p><ul class=""><li id="0087" class="mj mk in la b lb lw lf lx lj ml ln mm lr mn lv mo mp mq mr bi translated">源可观察值被创建为从“0”到“4”的范围。</li><li id="0376" class="mj mk in la b lb ms lf mt lj mu ln mv lr mw lv mo mp mq mr bi translated">另一个可观察对象是通过在源可观察对象上应用“映射”操作符而创建的。</li><li id="9aab" class="mj mk in la b lb ms lf mt lj mu ln mv lr mw lv mo mp mq mr bi translated">创建对输出可观察对象的订阅。</li><li id="38be" class="mj mk in la b lb ms lf mt lj mu ln mv lr mw lv mo mp mq mr bi translated">源可观察对象发出第一个值:“0”。</li><li id="83f6" class="mj mk in la b lb ms lf mt lj mu ln mv lr mw lv mo mp mq mr bi translated">“map”操作符为这个值执行，并在输出可观察值上发出投影值。在这种情况下，投影函数简单地将该值乘以自身，因此结果为“0”。</li><li id="2370" class="mj mk in la b lb ms lf mt lj mu ln mv lr mw lv mo mp mq mr bi translated">源可观察对象发出第二个值:“1”。</li><li id="8f37" class="mj mk in la b lb ms lf mt lj mu ln mv lr mw lv mo mp mq mr bi translated">“map”操作符为这个值执行，并在输出可观察值上发出投影值。在这种情况下，投影函数简单地将该值乘以自身，因此结果为“1”。</li><li id="24f9" class="mj mk in la b lb ms lf mt lj mu ln mv lr mw lv mo mp mq mr bi translated">如此等等…</li></ul><p id="f76f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这段代码的大理石图如下:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3d237f104b72187899e38d78edb9bedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*JGEPNmQ3xMH5X6nIuA_m0Q.png"/></div></figure><p id="cf7c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">所以，最后一次，<strong class="la io">这里需要理解的重要一点是，创建的订阅关系到底层的可观察对象，而不是顶层的</strong>。</p><h1 id="e1e4" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">过滤器</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/acbd1694b2b2d8b2bee2881a8615d745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0QvlorRbAcdwgTxC6TfdQ.png"/></div></div></figure><p id="9346" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">“filter”操作符可能是与“map”操作符一起使用最多的操作符之一。该操作符过滤源可观察值，以确定输出可观察值是否发出它们。例如，它可用于过滤所有值，以便只保留偶数值:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="85dd" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">上面的代码对源可观察对象应用了一个过滤器，只保留能被“2”除的值。这段代码的结果是:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/0173ab66ad238a26913928efdc3b3d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJgYrSAu9rUc1wICBMsaZQ.png"/></div></div></figure><p id="1afb" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这段代码的大理石图如下:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/adbad3cd6f62202dd09f6b1cc15fcd55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*CShAaySbo07mmAvVBL5v8w.png"/></div></figure><p id="2b5d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">还可以通过使用传递给“filter”的函数的第二个参数来获取当前值的索引:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h1 id="3bdc" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">链接运算符</h1><p id="23b2" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">到目前为止，我们一个接一个地使用操作符，但是“RxJS”的一个优势是能够链接操作符。例如，我们可以将刚才看到的两个操作符结合起来，以过滤值并映射通过测试的值:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6fa8" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">因此，在这种情况下，由源可观察对象发出的值由“过滤”条件评估，如果它返回“真”，则该值乘以自身并由输出可观察对象发出。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/0115fdc3f5e07b878d3f26b356b11196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMvCk0uOahK6WzlQnQM1wQ.png"/></div></div></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/02f57e4b596eb010547d299fcd6be48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*OHqRo5H5_gCZhR7zzu9P6g.png"/></div></figure><h1 id="1557" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">轻敲，水龙头</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/388fceecaae915a796fb7180e88ba090.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*mgF3AOuoNKaRPuyOtM4TfQ.png"/></div></figure><p id="d344" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">“tap”操作符是最简单的操作符，用于对发出的值“做点什么”。这是一个非常有用的操作符，可以通过在控制台中记录不同的输出值来调试可观察的对象。例如，我们可以更新上一个示例，记录“filter”运算符后面的值:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="a9b0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">上面的代码和前面的代码的区别在于，在执行“map”操作符之前，我们在控制台中记录过滤后的值。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/1ba1becc0f873826f0022e8ddc5ff10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6qM-ssQRPpYtfWVmZOtaQ.png"/></div></div></figure><p id="0ba6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">正如您所看到的，最终结果是相同的:“0”、“4”、“16”、“36”和“64”，但是，我们也看到一些值被“tap”操作符记录(用黄色表示)。这些值是在被“映射”操作符投影之前通过“过滤”操作符的值。</p><p id="92fa" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">值得注意的是，“tap”并不更新发出的值，它主要用于调试发出的值或应用副作用。然而，正如我们在上一篇文章的<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e">中看到的，在反应式编程中不建议使用副作用，所以尽量只在调试时使用这个操作符。</a></p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/abcff8a71498768cae53a2e7c630196f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Kv3fYLofCzA0PxYuwjdBIQ.png"/></div></figure><h1 id="b34d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">拿</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2ca0f3986b899cc881958a99a6db0c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*cIwKF7zjD8sV844A224o9A.png"/></div></figure><p id="96ec" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">“取”算子取可观测源发出的第“n”个值，然后<strong class="la io">完成</strong>输出一个值。可观察对象已完成这一事实非常重要，可以用来避免存储订阅和取消订阅。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0c99" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">上面的代码过滤了范围的值，只保留偶数，并且只取前三个值。同样,“take”操作符应用于由“filter”操作符返回的可观察值，换句话说，所有“take”操作符甚至不会考虑的值。我们还定义了“complete”回调，以表明一旦达到参数中指定的值的数量,“take”就完成了可观察对象。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/446a7c149e2fc27e14a0190dd39d1a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3_cvG51FQZhcczhZ82N8g.png"/></div></div></figure><p id="d33b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这段代码的大理石图如下:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9e68ffd70aad6c63446e1157c8f378a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*EPNz2dHmvSF8quP7nbsczA.png"/></div></figure><h1 id="46ff" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">抓紧时间</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/939352f4e13ecac9f1ff133aea1474c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*dI0GVNoNKn3RqdbX0aIPeg.png"/></div></figure><p id="956b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">操作符“takeWhile”的行为就像“take”一样，只是它使用一个谓词来确定是否应该继续获取值。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="f474" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在本例中，只要这些值小于“5”，运算符就会取这些值。一旦发出大于或等于“5”的值，可观察性就完成了。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/666c86323417cdc8a53430361545f73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWF52oID0_KBpFKafa4SoA.png"/></div></div></figure><p id="636b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">您还可以使用“takeWhile”的第二个参数来指定您还希望发出不满足谓词的第一个值。例如，如果您为上面的代码在该参数中指定“true ”,则结果会稍有不同:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/dda531a6f601d4344acae25419a42114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wm9x0hqiw04xNirNkZI37A.png"/></div></div></figure><p id="9ab0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">第一版代码的大理石图如下:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/358b41f2426558488231a4e5284086e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*qNefh9FwZtw3t_ReHL9jwg.png"/></div></figure><h1 id="21a6" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">跳跃</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/de1019e885c4c8a05ad873ccebdc61c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*7e58IySvsH0ltBf176ag8g.png"/></div></figure><p id="5ae9" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">“skip”操作符在开始发出源可观察值之前跳过一定数量的发出值。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2a13" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在本例中，“skip”忽略第一个发出的5个值，然后开始发出其他值。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/57b8ae33191f1782a6b4b20db3626ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdIgwrI2zHsbAX5rnJsP6A.png"/></div></div></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9e74aa4ff4e423ebaed6bb653b8e2e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*efJhuVOhmEAlG8oLaLJZOg.png"/></div></figure><h1 id="b027" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">滑雪时</h1><p id="9ba0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">“skipWhile”操作符与“skip”操作符的目的相同，只是它是一个条件，决定何时停止忽略发出的值。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8246" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这种情况下，只要源可观测物发出的值小于“5 ”,它们就会被忽略。只要一等于或大于“5”，输出可观察值就开始发出值。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/138b6acbbb657597e9485a5d067a627b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byaUvXUV9FbzfzxQpxaChA.png"/></div></div></figure><p id="f462" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">大理石图如下:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1e99cecfb8cbe1046eb6c698ae1cb8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*j-2Mmn5mU9j5qiQX5adlsA.png"/></div></figure><h1 id="9c08" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第一</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/71baef206935d07ee5d82ffd2c818de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*2qYCvxtDUjYzXZdYmRkJbg.png"/></div></figure><p id="d19c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">“first”操作符发出匹配谓词的第一个值，然后完成可观察值。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9afd" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这种情况下，满足谓词的第一个值是“6”，因此在输出可观察完成之前只发出这个值。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/f6c3d4f47721aa1637910b40b25d66a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jCnefhu75XOn6UgcWoVKQ.png"/></div></div></figure><p id="57e0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果源可观察对象在任何值满足谓词之前完成，就会抛出一个错误。如果在源可观察性完成之前没有值满足谓词，您可以通过指定一个缺省值来避免。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9497" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这种情况下，由于在源可观察对象完成之前没有满足谓词的值，所以发出默认值(“0”)。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/1c8e454a5bee896c296391dea059c5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Ry6LlzKUQnK4t2p2YHRhA.png"/></div></div></figure><p id="6c02" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">第一个示例的大理石图如下:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/e2a430818a0f5722cc2657b22cd94145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*WiwiDSZx7ENLuvMUkHzFVQ.png"/></div></figure><h1 id="d16d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">最后的</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ee83dd30dffa6d969aafc526f6233c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*5cin4pagcIw1rbj_rtVT7A.png"/></div></figure><p id="3825" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">有“第一”，就有“最后”。这个操作符只是在源观察完成之前发出最后一个匹配条件的值。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="508a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这将产生:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/dcd7666d407dca37a7e44c73c0ceb69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9niekuC7rxxSnOccyRijA.png"/></div></div></figure><p id="88b4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">对应的大理石图如下:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7bacc3ca0200098273682d5ab2b35e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*K7_LkLmqHYfjSraw8EWS7Q.png"/></div></figure><h1 id="8ea0" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">distinctUntilChanged</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/dbe8ae156b7904ff1fb1406c95638b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRk_H19lo1R3KbnbRIjXWA.png"/></div></div></figure><p id="7f9d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">操作符“distinctUntilChanged”非常好，可以帮助减少代码执行的操作数量。如果先前发出的值相同，它实际上会跳过这些值。让我们举一个简单的例子:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5865" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在上面的代码中，我们从包含重复连续值的数组中创建了一个可观察对象。使用“distinctUntilChanged”可以保证两个相同的值不会相继发出。上面代码的结果是:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/0469f1012255f564e9e47c5659539ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_q8PksLIyhK5Jz0oEbprCw.png"/></div></div></figure><p id="e3f1" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如您所见，所有重复的连续值，如["2 "、" 2"]或["4 "、" 4"]，都只发出过一次。默认情况下，该操作符使用“===”操作符来比较值，但是，您可以向它提供一个参数来改变这一点。下面的示例比较这些值的绝对值。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="d7a0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这段代码中，我们通过绝对值来比较这些值，这就是为什么值["2 "，"-2"]被认为是相等的。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/a49c9ff1fce382db72b36d59f4f71595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1AAqmNfY-yGKBkJVy1qhA.png"/></div></div></figure><p id="e8d4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">第一个示例的大理石图如下:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8fec932a18801ea36fd747b485226f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*x6cB_2xpHbOo6b-SKib3gA.png"/></div></figure><h1 id="ce5a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">distinctUntilKeyChanged</h1><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f50a1485b69d7269c37caa1f8a83b2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*ZIguLjwpdX-UAniY58Q3nQ.png"/></div></figure><p id="2604" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">该运算符的作用与“distinctUntilChanged”相同，只是您必须提供value属性的名称。例如，您可以使用它仅发出长度不同的单词:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7e02" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这种情况下，只有当先前发出的值的“长度”属性不同时，才会发出值，这就是为什么有些单词没有出现的原因:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/548f28c1a370d458f3789e6162196725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAy789Tw4KROeozZFNe8BQ.png"/></div></div></figure><p id="c944" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">至于“distinctUntilChanged”，可以使用第二个参数定义一个比较器函数。</p><p id="8442" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这个例子的大理石图是:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/b80881812a857e4af465034ead9562c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBMlEr8gDJwnOZNrgPjZ3w.png"/></div></div></figure><h1 id="1baf" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">最后的想法</h1><p id="97f1" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在这篇文章中，我们看到了大约十几个非常受欢迎的运营商。我决定在这里停止这篇文章，不要用太多的信息淹没你，但是如果你喜欢它，检查下一篇文章<a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-e64caa5f72e7" rel="noopener">，在那里我介绍了其他有用的操作符。</a></p><figure class="mc md me mf gt jo gh gi paragraph-image"><a href="https://www.buymeacoffee.com/ssougnez"><div class="gh gi nm"><img src="../Images/6d60b235fcc46a4bd696b90e886419ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Dpw8-hNGI2fDmosV4E8DVQ.png"/></div></a></figure></div></div>    
</body>
</html>