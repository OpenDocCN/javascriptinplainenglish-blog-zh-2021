<html>
<head>
<title>LeetCode Algorithm Challenge: Binary Tree Inorder Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法挑战:二叉树有序遍历</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-challenge-binary-tree-inorder-traversal-82d1886fb738?source=collection_archive---------7-----------------------#2021-06-07">https://javascript.plainenglish.io/leetcode-algorithm-challenge-binary-tree-inorder-traversal-82d1886fb738?source=collection_archive---------7-----------------------#2021-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="8aa1" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题</h1><p id="0e84" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae lg" href="https://leetcode.com/problems/binary-tree-inorder-traversal/" rel="noopener ugc nofollow" target="_blank">给定二叉树的</a> <code class="fe lh li lj lk b"><a class="ae lg" href="https://leetcode.com/problems/binary-tree-inorder-traversal/" rel="noopener ugc nofollow" target="_blank">root</a></code> <a class="ae lg" href="https://leetcode.com/problems/binary-tree-inorder-traversal/" rel="noopener ugc nofollow" target="_blank">，返回<em class="ll">对其节点值</em>的有序遍历。</a></p><p id="8712" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated"><strong class="kk io">例1: </strong></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/df01a46d95cc510b00d4eff8baf33186.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/0*nk4ANepiyNwXg1xw.jpg"/></div></figure><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="ef78" class="md jl in lk b gy me mf l mg mh"><strong class="lk io">Input:</strong> root = [1,null,2,3]<br/><strong class="lk io">Output:</strong> [1,3,2]</span></pre><p id="8ccb" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated"><strong class="kk io">例2: </strong></p><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="efa6" class="md jl in lk b gy me mf l mg mh"><strong class="lk io">Input:</strong> root = []<br/><strong class="lk io">Output:</strong> []</span></pre><p id="0eeb" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated"><strong class="kk io">例3: </strong></p><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="5da5" class="md jl in lk b gy me mf l mg mh"><strong class="lk io">Input:</strong> root = [1]<br/><strong class="lk io">Output:</strong> [1]</span></pre><p id="a572" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated"><strong class="kk io">例4: </strong></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/16ba9fcb5c37be24556eb78d7787f539.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/0*rsGM38nFTfv-iPvS.jpg"/></div></figure><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="0a5a" class="md jl in lk b gy me mf l mg mh"><strong class="lk io">Input:</strong> root = [1,2]<br/><strong class="lk io">Output:</strong> [2,1]</span></pre><p id="eef5" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated"><strong class="kk io">例5: </strong></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/4b1db9363c7385e7b7843421bf3d3d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/0*YagNT5ITPfylyiRb.jpg"/></div></figure><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="28c4" class="md jl in lk b gy me mf l mg mh"><strong class="lk io">Input:</strong> root = [1,null,2]<br/><strong class="lk io">Output:</strong> [1,2]</span></pre></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="5995" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">我第一次遇到使用树的挑战，所以我有很多问题。</p><h1 id="e5c8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">二叉树</h1><p id="bd69" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">什么是二叉树？它是一个<a class="ae lg" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树形数据结构</a>，其中每个节点最多有两个<a class="ae lg" href="https://en.wikipedia.org/wiki/Child_node" rel="noopener ugc nofollow" target="_blank">子节点</a>，分别称为<em class="ll">左子节点</em>和<em class="ll">右子节点</em>。(来源:<a class="ae lg" href="https://en.wikipedia.org/wiki/Binary_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_tree</a>)</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d40d582357868a6ea04203a3512701a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*4fLzdnkeA5rPQMyGeypoGQ.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk"><a class="ae lg" href="https://en.wikipedia.org/wiki/Binary_tree#/media/File:Binary_tree.svg" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_tree#/media/File:Binary_tree.svg</a></figcaption></figure><h1 id="45c7" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">树遍历</h1><p id="81fd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">树遍历</strong>指的是访问(检查和/或更新)一个<a class="ae lg" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树数据结构</a>中的每个节点的过程，恰好一次。这种遍历按照访问节点的顺序进行分类。(来源:<a class="ae lg" href="https://en.wikipedia.org/wiki/Tree_traversal" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Tree_traversal</a>)</p><p id="482d" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">Inorder Traversal —从左到右访问树的每个节点。所以如果你看下图。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/8ff76686b98533cb8baa31a69a4be17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*5HR3xR-d2H7d0pNMccjDaQ.png"/></div></figure><ol class=""><li id="9497" class="mv mw in kk b kl lm kp ln kt mx kx my lb mz lf na nb nc nd bi translated">访问的第一个元素将是4，我们将从根1开始，但是将通过左2移动到左4；</li><li id="4d2f" class="mv mw in kk b kl ne kp nf kt ng kx nh lb ni lf na nb nc nd bi translated">然后我们将返回并访问root 2；</li><li id="282a" class="mv mw in kk b kl ne kp nf kt ng kx nh lb ni lf na nb nc nd bi translated">现在向右——5；</li><li id="8fff" class="mv mw in kk b kl ne kp nf kt ng kx nh lb ni lf na nb nc nd bi translated">回到根1；</li><li id="8bf5" class="mv mw in kk b kl ne kp nf kt ng kx nh lb ni lf na nb nc nd bi translated">再次向右3。</li></ol><p id="593e" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">因此，如果我们在一个数组中传递它，它将看起来像这样[4，2，5，1，3]</p><p id="f327" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">现在，我对这个任务有了一个更好的想法，让我们来编码。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="a54f" class="jk jl in bd jm jn nj jp jq jr nk jt ju jv nl jx jy jz nm kb kc kd nn kf kg kh bi translated">密码</h1><p id="2bfd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们声明一个数组列表来收集我们的数据。</p><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="0614" class="md jl in lk b gy me mf l mg mh">let list = [];</span></pre><p id="30f7" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">现在我们将构建一个带有两个参数的递归函数检查树。我们将传递一个根和当前列表。</p><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="e814" class="md jl in lk b gy me mf l mg mh">function checkTree(root, list) {</span><span id="ddcc" class="md jl in lk b gy no mf l mg mh">~~~<br/>}</span></pre><p id="4059" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">如果我们的根是一个空节点，那么我们将返回列表中的所有数据。</p><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="c6db" class="md jl in lk b gy me mf l mg mh">if (root === null) {</span><span id="7e50" class="md jl in lk b gy no mf l mg mh">   return list</span><span id="5952" class="md jl in lk b gy no mf l mg mh">}</span></pre><p id="a49a" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">现在我们将开始深入我们的树，正如之前讨论的那样，我们将从左侧开始。我们将在左边的节点上使用递归函数。</p><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="a181" class="md jl in lk b gy me mf l mg mh">list = checkTree(root.left, list);</span></pre><p id="6023" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">现在，我们有了列表，我们得到了左边的值，我们将把根值添加到列表中，</p><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="6765" class="md jl in lk b gy me mf l mg mh">list.push(root.val);</span></pre><p id="8b11" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">用我们的递归函数在正确的子节点上结束一切。</p><pre class="ls lt lu lv gt lz lk ma mb aw mc bi"><span id="ad8b" class="md jl in lk b gy me mf l mg mh">return checkTree(root.right, list);</span></pre><p id="acba" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">以下是最终结果。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="4dcd" class="pw-post-body-paragraph ki kj in kk b kl lm kn ko kp ln kr ks kt lo kv kw kx lp kz la lb lq ld le lf ig bi translated">请在以下社交网络上查看我，我很乐意收到您的来信！——<a class="ae lg" href="https://www.linkedin.com/in/nick-solonyy/" rel="noopener ugc nofollow" target="_blank"><em class="ll">LinkedIn</em></a><em class="ll">，</em> <a class="ae lg" href="https://github.com/nicksolony" rel="noopener ugc nofollow" target="_blank"> <em class="ll"> GitHub </em> </a>，<a class="ae lg" href="https://www.facebook.com/nick.solony" rel="noopener ugc nofollow" target="_blank"> <em class="ll">脸书</em> </a> <em class="ll">。</em></p></div></div>    
</body>
</html>