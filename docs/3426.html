<html>
<head>
<title>LeetCode Algorithm Challenges: Minimum &amp; Maximum Depth of Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法挑战:二叉树的最小和最大深度</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-challenges-minimum-maximum-depth-of-binary-tree-d075a271fbda?source=collection_archive---------8-----------------------#2021-07-11">https://javascript.plainenglish.io/leetcode-algorithm-challenges-minimum-maximum-depth-of-binary-tree-d075a271fbda?source=collection_archive---------8-----------------------#2021-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="20f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天我将回答两个问题，因为它们看起来和我很相似，尽管寻找的是相反的结果。但是解决方案会有一些共同点。</p><h1 id="1304" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">问题1</h1><p id="f87d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">给定二叉树的<code class="fe ll lm ln lo b">root</code>，返回<em class="lp">其最大深度</em>。</p><p id="57dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉树的<strong class="jm io">最大深度</strong>是从根节点到最远叶节点的最长路径上的节点数。</p><p id="e390" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例1: </strong></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/79dc64c5e86de9e8b6cfc19067a2e485.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*vBXyJCGDBcNGokDp.jpg"/></div></figure><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="31a3" class="mc kj in lo b gy md me l mf mg"><strong class="lo io">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="lo io">Output:</strong> 3</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="26e2" class="ki kj in bd kk kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf bi translated">解决办法</h1><p id="efc3" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我发现在二叉树中使用递归函数非常有用，可以覆盖所有分支。这个问题其实有一行解，但是我们来分解一下。</p><p id="62fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在每个节点的左右分支上使用递归函数。但是首先，我们将检查根是否存在。因此，如果根不存在，我们将返回0，因为分支不存在。</p><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="d6c4" class="mc kj in lo b gy md me l mf mg">!root ? 0</span></pre><p id="fc6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，如果根存在，它给我们的深度为1。现在我们将使用<code class="fe ll lm ln lo b">Math.max()</code> Javascript函数，它返回作为输入参数的零个或多个数字中的最大值，并使用带有<code class="fe ll lm ln lo b">root.left</code>和<code class="fe ll lm ln lo b">root.right</code>作为参数的<code class="fe ll lm ln lo b">maxDepth</code>函数。它将比较每个节点的分支，最终将返回最长的分支深度，该深度将加1，表示我们的根。</p><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="8f4b" class="mc kj in lo b gy md me l mf mg">1 + Math.max(maxDepth(root.left),maxDepth(root.right))</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="ae2c" class="ki kj in bd kk kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf bi translated">密码</h1><p id="6afe" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">正如我前面提到的，最终代码将是一个简单的单行代码。</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="6c8a" class="ki kj in bd kk kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf bi translated">问题2</h1><p id="df98" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">给定一棵二叉树，求其最小深度。</p><p id="a016" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最小深度是从根节点到最近的叶节点的最短路径上的节点数。</p><p id="6c7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>叶子是没有子节点的节点。</p><p id="83b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例1: </strong></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/7d8ac5bc62c822a769a4a52d307c737a.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/0*a8tYxMhWfu4U8WYG.jpg"/></div></figure><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="f694" class="mc kj in lo b gy md me l mf mg"><strong class="lo io">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="lo io">Output:</strong> 2</span></pre><p id="9112" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例2: </strong></p><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="c6a6" class="mc kj in lo b gy md me l mf mg"><strong class="lo io">Input:</strong> root = [2,null,3,null,4,null,5,null,6]<br/><strong class="lo io">Output:</strong> 5</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="fe60" class="ki kj in bd kk kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf bi translated">问题</h1><p id="ed56" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">乍一看，这很简单，使用问题1中的代码，我们可以假设我们的解决方案如下所示。</p><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="4838" class="mc kj in lo b gy md me l mf mg">var minDepth = function(root) {</span><span id="e56e" class="mc kj in lo b gy mw me l mf mg">       return !root ? 0 : 1 +     <br/>       Math.min(maxDepth(root.left),maxDepth(root.right));</span><span id="d0ff" class="mc kj in lo b gy mw me l mf mg">};</span></pre><p id="9bec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对，我们用<code class="fe ll lm ln lo b">Math.min</code>代替<code class="fe ll lm ln lo b">Math.max</code>，就这样。不，这是错的，因为从上面的例子2中你可以看到。这是因为最小深度是从根节点到最近的叶节点的最短路径上的节点数。请注意，路径必须在叶节点上结束。在示例2中，只有右边的分支，左边没有叶子，这就是为什么正确答案是5，而不是上面函数返回的0。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="6d03" class="ki kj in bd kk kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf bi translated">解决办法</h1><p id="45cc" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">因此，在选择需要计数的分支之前，我们需要检查树叶是否存在。我仍然会开始检查根是否存在，如果不存在就返回0。</p><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="f392" class="mc kj in lo b gy md me l mf mg">var minDepth = function(root) {</span><span id="f8e8" class="mc kj in lo b gy mw me l mf mg">   if(root === null) {</span><span id="e06a" class="mc kj in lo b gy mw me l mf mg">       return 0</span><span id="3e68" class="mc kj in lo b gy mw me l mf mg">   }</span><span id="0e2e" class="mc kj in lo b gy mw me l mf mg">....</span><span id="5a2f" class="mc kj in lo b gy mw me l mf mg">};</span></pre><p id="ad8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们可以安全使用<code class="fe ll lm ln lo b">Math.min</code>的唯一情况是当两片叶子都存在的时候。我们将使用<code class="fe ll lm ln lo b">if</code>函数来检查这一点。</p><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="2b76" class="mc kj in lo b gy md me l mf mg">if (root.left &amp;&amp; root.right) {</span><span id="c27d" class="mc kj in lo b gy mw me l mf mg">    return 1 + Math.min(minDepth(root.left),minDepth(root.right))</span><span id="5ef4" class="mc kj in lo b gy mw me l mf mg">}</span></pre><p id="e592" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">否则，我们将检查唯一的<code class="fe ll lm ln lo b">root.left</code>是否存在，并应用类似的逻辑，但不使用<code class="fe ll lm ln lo b">Math.min</code>，因为我们已经知道<code class="fe ll lm ln lo b">root.right</code>是<code class="fe ll lm ln lo b">null</code>。</p><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="1289" class="mc kj in lo b gy md me l mf mg">else if (root.left) {</span><span id="b9e3" class="mc kj in lo b gy mw me l mf mg">   return 1 + minDepth(root.left)</span><span id="30b8" class="mc kj in lo b gy mw me l mf mg">}</span></pre><p id="b305" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，如果<code class="fe ll lm ln lo b">root.left</code>不存在，那么我们将使用<code class="fe ll lm ln lo b">root.right</code>作为<code class="fe ll lm ln lo b">minDepth</code>递归函数的参数。</p><pre class="lr ls lt lu gt ly lo lz ma aw mb bi"><span id="c711" class="mc kj in lo b gy md me l mf mg">else {</span><span id="77c5" class="mc kj in lo b gy mw me l mf mg">   return 1 + minDepth(root.right)</span><span id="248b" class="mc kj in lo b gy mw me l mf mg">}</span></pre><p id="5e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将涵盖所有场景，并提供最终结果。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="523a" class="ki kj in bd kk kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb ms ld le lf bi translated">密码</h1><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="2150" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我决定把这两个问题放在一起，因为我发现你如何解决一个问题，但看着一个不同的问题，这很有趣。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="c6a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lp">请在以下社交网络上查看我，我希望收到您的来信！——</em><a class="ae mx" href="https://www.linkedin.com/in/nick-solonyy/" rel="noopener ugc nofollow" target="_blank"><em class="lp">LinkedIn</em></a><em class="lp">，</em> <a class="ae mx" href="https://github.com/nicksolony" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> GitHub </em> </a>，<a class="ae mx" href="https://www.facebook.com/nick.solony" rel="noopener ugc nofollow" target="_blank"> <em class="lp">脸书</em> </a> <em class="lp">。</em></p><p id="bd70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lp">更多内容请看</em><a class="ae mx" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>