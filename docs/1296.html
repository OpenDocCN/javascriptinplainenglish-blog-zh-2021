<html>
<head>
<title>Common Junior Frontend Interview Questions about React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React的初级前端面试常见问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/commonly-asked-junior-frontend-interview-questions-about-react-90560bb54bcb?source=collection_archive---------5-----------------------#2021-03-18">https://javascript.plainenglish.io/commonly-asked-junior-frontend-interview-questions-about-react-90560bb54bcb?source=collection_archive---------5-----------------------#2021-03-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/66f040e64c64da5bd5f3181a1061ab78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huuIquyrL3HT7ukNyROrhQ.png"/></div></div></figure><p id="7bca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在面试中展示的最重要的事情之一是对公司正在使用的技术的充分理解。即使你觉得你的编码技能没有完全达到标准，表现出你能够理解所有的主要概念<em class="kt">是有价值的。我要复习一下我的个人学习指南，回答面试问题。</em></p><h2 id="30bc" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">React的虚拟DOM是什么？</h2><p id="9e84" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">这可能是理解React最重要的一个概念。React如此之快是因为它使用了一种叫做虚拟DOM的东西。考虑虚拟DOM的一种方式就像实际DOM的蓝图。有些人更倾向于认为它是实际DOM的轻量级副本，但我相信前者更合适。想想现实生活中的房子(实际的DOM)与用来建造它的蓝图(虚拟DOM)；其中一个花费了更多的时间和精力去建造(显然是房子)。这是我比较喜欢的比喻。</p><p id="cf88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在React中呈现JSX元素时，每个虚拟DOM对象都会更新。关键的区别在于，虚拟DOM没有被呈现到屏幕上——我们的蓝图被创建，而不是房子被建造。这使得更新虚拟DOM <em class="kt">方式</em>的过程比实际DOM将所有内容重新绘制到屏幕上要快。一旦更新了虚拟DOM，React就会将其虚拟DOM节点与实际DOM节点进行比较，通过React的“diffing”算法评估这些变化，然后只更新<em class="kt">实际DOM中受这些变化影响的元素。这整个过程被称为“和解”。所以基本上，在初始网站加载后，虚拟DOM允许页面上的更改和更新以令人难以置信的速度发生，而不需要实际的DOM刷新整个页面。这提供了巨大的性能提升！</em></p><h2 id="c883" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">类组件和功能组件有什么区别？</h2><p id="f8bb" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">功能组件只是一个返回JSX的JavaScript函数。class组件是React组件类的扩展，继承了一个render方法和几个lifecycle方法(下面将详细介绍),还初始化了一个构造函数来管理状态和属性。功能组件以道具为参数，用钩子管理状态。类也使用经常令人困惑的“this”语法，而功能组件则不使用。要析构props，可以在类组件的render方法中完成。在函数组件中，它是作为函数的参数来完成的。</p><p id="dac5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我看来，类组件正在慢慢走上恐龙的老路。尽管有许多利用它们的遗留代码，但大多数开发人员(包括开发React的人员)都将功能组件视为React的未来。了解这两个组件的工作原理并能够用它们创建工作代码仍然很重要。</p><h2 id="79d5" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">走完类组件和功能组件的生命周期</h2><p id="0bbe" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated"><strong class="jx io"> Class: </strong>第一阶段是初始化，其中构造函数方法设置状态和支柱。在初始化阶段不应出现任何副作用。接下来是安装阶段；组件被呈现到DOM，然后第一个生命周期方法componentDidMount变得可用。这个方法是我们运行副作用的第一个机会，比如异步请求，即从服务器获取数据、运行间隔函数等。接下来，如果修改了组件的状态或支柱，则组件将进入更新阶段。呈现方法将再次运行，而React将更新DOM。生命周期方法componentDidUpdate随后可用，我们可以再次运行副作用。此方法还可以使用组件的前一个状态和前一个道具作为参数。最后一个阶段是卸载，即从DOM中移除组件。就在销毁组件之前，我们可以访问componentWillUnmount方法，它非常适合运行任何必要的清理方法来删除事件监听程序、清除间隔、取消网络请求等。</p><p id="5937" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Functional: </strong>没有初始化阶段或构造函数，函数组件不能像类组件那样访问相同的生命周期方法。相反，可以实现useEffect挂钩来实现类似的结果。通过管理useEffect的依赖项，可以将它配置为在首次装载组件时运行一次，方法是将它的依赖项设置为空数组，或者可以传入依赖项，从而使它在每次修改依赖项时都运行。useEffect挂钩还有一个回调，在卸载组件时可以返回该回调以运行清理函数。</p><h2 id="405d" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">什么是JSX？</h2><p id="e627" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">JSX是一种类似于XML/HTML的语法，它允许我们将HTML元素放在reactor中的JavaScript表达式内部。然后，它可以被像Babel这样的预处理器转换成可以被解析的普通JavaScipt对象。在JSX诞生之前，就使用了React.createElement()。两者都允许我们创建React元素，然后将这些元素附加到虚拟DOM节点。JSX内部的HTML必须只包装在一个顶级元素中，例如div。但是，如果希望在不创建额外DOM节点的情况下对子级列表进行分组，则可以使用React片段来代替顶级元素。JSX使得编写React应用程序更易于编程和阅读。</p><h2 id="8952" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">解释道具和状态的区别</h2><p id="c9f0" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">props(properties的缩写)应该被认为是不可变的，而state是可变的。在组件中创建状态，并将属性传递给组件。但是，组件能够通过defaultProps创建自己的属性。状态用于跟踪组件呈现之间更新和创建的信息。道具不能向上传递给父组件，只能向下传递给子组件。但是，props可以传递允许子组件影响父组件状态的方法。</p><h2 id="a841" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">钥匙的用途是什么？</h2><p id="4a0c" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">键是一个唯一的字符串属性，当您在React中创建元素列表(包括充当列表元素的组件)时，需要包含这个属性。应为每个列表元素分配一个键。键的语法与props类似，但是它们不能像props一样被访问。只有React可以访问键，它使用键来识别哪些元素已经被更新或删除。重要的是不要将索引用作键(在映射数组时，您可能倾向于这样做)。这是因为如果数组在将来被重新排序，元素的键将改变为重新排序的索引。一个好的经验法则是在从map函数返回的任何东西中包含一个惟一的键。</p><h2 id="a07c" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">结论</h2><p id="5998" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">能够解释React的工作方式几乎和能够用它编码一样重要。它让面试官知道你不只是按照教程来创建你的项目，而且你实际上理解React如何以及为什么以这种方式工作的核心概念。这只是皮毛，但应该足以帮助你通过初级面试。祝你好运！</p><p id="a8b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">在</em> <a class="ae ls" href="https://www.linkedin.com/in/kylefarmer85" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> LinkedIn </strong> </a> <em class="kt">上联系我，在</em><a class="ae ls" href="https://kylefarmer.dev/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">Kyle farmer . dev</strong></a>，<em class="kt">上查看我的作品集，干杯！</em></p></div></div>    
</body>
</html>