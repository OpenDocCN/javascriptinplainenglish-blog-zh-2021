<html>
<head>
<title>Debouncing API requests in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的反跳API请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/debouncing-api-requests-in-react-using-useeffect-with-cleanup-function-explanation-c747e95493c?source=collection_archive---------5-----------------------#2021-05-02">https://javascript.plainenglish.io/debouncing-api-requests-in-react-using-useeffect-with-cleanup-function-explanation-c747e95493c?source=collection_archive---------5-----------------------#2021-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="befa" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用useEffect React钩子，通过反跳API请求来提高应用程序的效率</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b257ec18b9d793168315ef019d2a879d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsFqZTTwyOW7y5SeDUwfiQ.jpeg"/></div></div></figure><p id="db21" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这篇文章中，我们将讨论如何在每次用户输入改变时避免不必要的API调用请求，以使你的应用程序更加高效和可伸缩。</p><p id="9bf8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我想给你一个关于使用效果钩子的简介。useEffect挂钩是最有用的React函数挂钩之一，如果您已经熟悉基于类的React组件，那么您可以认为它几乎类似于componentDidMount挂钩，后者用于进行API调用，因为它是在组件首次加载时触发的。</p><p id="0530" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，useEffect钩子也用于在React功能组件中进行API调用，但是它有两个吸引人的特性</p><ol class=""><li id="fa9b" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><strong class="kq io">依赖数组—</strong>useEffect钩子将在组件加载时第一次运行，但除此之外，我们有能力在组件中的某个东西改变时运行它，所以我们可以在依赖数组中添加改变的东西，每当依赖改变时，我们将看到use effect将自动调用。(通常有助于在某些组件数据发生变化时发出请求)。</li><li id="04ac" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq io">清理功能- </strong>该功能在useEffect组件运行之前运行，但在第二次运行时运行，之后不会在组件的初始加载期间运行。不要在这个问题上花费太多精力，你会在文章的前面了解到更多。</li></ol><p id="e12c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">语法:<code class="fe ly lz ma mb b">useEffect(() =&gt; {}, [])</code></p><p id="dbf6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二个参数:依赖数组。</p><p id="ed0d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，总之，无论何时我们在搜索栏或任何其他输入字段中输入内容，都可以使用useHooks来防止API调用，例如在搜索栏中，您向某个作业API发出请求以获取作业数据，并说您想要获取React数据作业，当您开始键入时，甚至当您写入第一个字母“R”时，API也会被触发以获取带有“R”的作业，每次输入更改都会发生同样的情况。所以，如果我们想让API只在写完整的单词时触发，那么我们将使用带有清理功能的钩子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mc"><img src="../Images/859ff53c6eeea33bb043116fd0d2f3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSDjwlMc3mB1oL5Q6AptOA.png"/></div></div></figure><p id="8a79" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看，上面的代码，在这段代码中我们有一个输入字段，每当数据改变时，组件在useState的帮助下重新呈现，并且因为值在useEffect钩子中用作依赖项，所以每当值改变时，useEffect也调用。</p><p id="d31c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在useEffect函数内部，useEffect返回的函数是cleanup函数，它在useEffect每次运行之前运行，但从第二次开始运行。</p><p id="d5db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设您要在useEffect内部进行API调用，那么我已经设置了一个计时器，在3秒钟之后，计时器将调用回调函数，并且API将使用该值进行调用，但是由于在3秒钟之前该值发生了变化，因此API没有被调用，但是计时器仍然存在，现在我们想要去掉这个计时器，因为随着下一个输入的变化，将会创建另一个计时器， 因此，在下一次运行useEffect之前，清理函数将在它之前运行，并删除之前设置的计时器，这个过程将继续，直到我们输入查询的最后一个字，因为在这之后，3秒钟的计时器将完成，带有所需输入的API调用将进行。</p><p id="2b07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这有助于我们不要在每次击键/输入改变时调用API，也可以调用去抖，其次，通过清理，我们也可以通过使用useEffect清理函数来消除以前创建的超时。</p><p id="bd33" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="md">注意:</em></strong><em class="md">useEffect的清理功能也在组件卸载前运行，这是非常有益的，因为我们可以移除所有的超时或任何其他组件卸载时创建的东西，我们的应用不会随着用户流量的增加而崩溃，我们的应用现在也变得更加精简、高效和可伸缩。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi me"><img src="../Images/e43189f7e890175414a0232cc1382245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1Iclvq5ojmOk6It4PUPsg.png"/></div></div></figure><p id="9ae1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一个改变的值是当组件装载并运行useEffect时，然后在每次输入改变之后，清理运行，最后当我们写完查询时，改变的值显示，这意味着在查询的最后一个字之后超时完成。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mf"><img src="../Images/1d1fd92ed21666f1cb387807271bbfba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ACOLHMkfL94EuFf6De048A.gif"/></div></div></figure><p id="e63d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">希望你能从这篇文章中学到一些东西！谢谢你的阅读。</p><p id="66eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="md">更内容于</em> <a class="ae mg" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="md">通俗地说就是</em> </strong> </a></p></div></div>    
</body>
</html>