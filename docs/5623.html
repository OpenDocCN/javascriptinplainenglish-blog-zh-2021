<html>
<head>
<title>A Beginner’s Guide to the Levenshtein Distance Algorithm (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Levenshtein距离算法初学者指南(第3部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-beginners-guide-to-the-levenshtein-distance-algorithm-part-3-how-to-code-the-levenshtein-b4721538ba7?source=collection_archive---------2-----------------------#2021-11-24">https://javascript.plainenglish.io/a-beginners-guide-to-the-levenshtein-distance-algorithm-part-3-how-to-code-the-levenshtein-b4721538ba7?source=collection_archive---------2-----------------------#2021-11-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e579" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何编码Levenshtein距离矩阵</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/993d428b599f1d49db4dd494894c5310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cINXabNwX79FRhTW"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fotis Fotopoulos</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="909e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本系列的第1和第2部分已经涵盖了对Levenshtein距离的基本解释和对T2如何编写简单矩阵的分步说明。接下来，我们将创建用任意两个字符串的Levenshtein距离值填充矩阵的代码。如果字符串“centers”和“mentor”被传递到函数中，让我们再来看看第2部分中代码生成的最终矩阵。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/fcaf4a8a3ca3ebfb4f5d4b7106106a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*fEoEKVzbLOO4FnWRUPxKvA.png"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="ab gu cl lq"><img src="../Images/1092e59f3e13d47630c288caf133e0b8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ZeUUE_uk0-ltR7Grm48UVw.png"/></div></figure><p id="59b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此时，只有第一列显示了正确的Levenshtein距离值，因此我们必须用正确的Levenshtein距离计算填充其余的数组值。</p><p id="7115" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://medium.com/@redlisa125/a-beginners-guide-to-the-levenshtein-distance-algorithm-part-1-d581fef7588f" rel="noopener">回想一下第1部分</a>中确定Levenshtein距离中每个索引值的模式:如果子字符串的端点相等，则当前索引处的网格值与其左上角的网格值相同。如果子字符串的端点不相等，则当前索引值是周围三个值中最小的一个值，并加1。</p><p id="538d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着我们的代码将需要能够检查子字符串的端点在任何给定索引处是否相等，以及索引处周围的值是否相等。如果端点相等，它将需要能够抓住左上角的值。如果端点不相等，它将需要能够找到三个周围值中的最小值。</p><p id="5cdb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们编写这个功能的代码。删除现有代码底部的“return <em class="lr"> grid </em>”。我们将用新的逻辑替换它:首先，我们希望循环遍历每行中的每个元素，这样我们就可以设置它的值。为此，我们可以设置另一个嵌套的for循环。不过，这一次，我们从第一个索引开始(将<em class="lr"> i </em>和<em class="lr"> j </em>的起始值设置为1 ),因为第0个索引是一个空字符串，并且这个值已经被我们从<a class="ae ks" href="https://medium.com/@redlisa125/a-beginners-guide-to-the-levenshtein-distance-algorithm-part-2-how-to-code-a-matrix-in-javascript-5ab308eefcf0" rel="noopener">第2部分</a>设置的矩阵填充。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ls"><img src="../Images/8c98861009dfb96e6d9b2d139b3cf9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YzkiVC8SvoOUoPC7Y8brQ.png"/></div></div></figure><p id="8664" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，创建一个if语句，检查字符串1在当前索引处是否等于字符串2。请记住，在矩阵中，两个字符串在每个单词的开头都有一个空字符串("")，但实际的字符串是作为参数传入的，而不是。因此，要检查每个字符串中的最后一个字符，必须使用不同于矩阵中当前索引的索引。每个字符串的端点字符位于索引<em class="lr"> str1 </em> [ <em class="lr"> i - </em> 1]和<em class="lr"> str2 </em> [ <em class="lr"> j - </em> 1]。</p><p id="7110" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果端点字符相同，则将当前索引值设置为与左上角索引值相同的值。如果当前索引是<em class="lr">网格</em> [ <em class="lr"> i </em> ][ <em class="lr"> j </em> ]，那么左上角索引是(<em class="lr">网格</em>[<em class="lr">I-</em>1][<em class="lr">j-</em>1])。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lt"><img src="../Images/a327704ba4053c7c710487da4fc3fc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7dTqv4w1pFUnb9odYuemw.png"/></div></div></figure><p id="66a7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">否则，如果端点字符不相等，则找到三个周围值中的最小值，或者是当前索引左侧的值(<em class="lr">网格</em>[<em class="lr">I</em>]<em class="lr">【j-</em>1])，当前索引左上角的值(<em class="lr">网格</em>[<em class="lr">I-</em>1][<em class="lr">j-</em>1])， 或者当前索引正上方的值(<em class="lr">网格</em>[<em class="lr">I-</em>1】[<em class="lr">j</em>])，并将当前索引值设置为这个最小值，递增1。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/988fbee95eae241820d569aebde1837e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7QKb43-MVeKu1nzSQ0boA.png"/></div></div></figure><p id="2187" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这段代码将遍历每个数组中的每个元素，并用传入的任意两个字符串的所有子字符串的Levenshtein距离值填充它。要查找两个完整字符串之间的最终Levenshtein距离，请返回最后一个网格值，即右下角的值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/6b07532d038283f2f34d61f3984aa34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*CXJ7X3ECriAImAB6OOXGeA.png"/></div></figure><p id="cf06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个值代表两个字符串的Levenshtein距离。</p><p id="1858" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最终的代码看起来像这样:</p><pre class="kd ke kf kg gt lw lx ly lz aw ma bi"><span id="d5eb" class="mb mc in lx b gy md me l mf mg">function levDist(str1, str2) {</span><span id="f1dc" class="mb mc in lx b gy mh me l mf mg">   const grid = []</span><span id="922a" class="mb mc in lx b gy mh me l mf mg">   for (let i = 0; i &lt; str1.length + 1; i++) {</span><span id="93c1" class="mb mc in lx b gy mh me l mf mg">      const row = []</span><span id="85c4" class="mb mc in lx b gy mh me l mf mg">      for (let j = 0; j &lt; str2.length + 1; j++) {</span><span id="8a2b" class="mb mc in lx b gy mh me l mf mg">         row.push(j)</span><span id="bcdc" class="mb mc in lx b gy mh me l mf mg">      }</span><span id="c5fb" class="mb mc in lx b gy mh me l mf mg">      row[0] = i</span><span id="fdca" class="mb mc in lx b gy mh me l mf mg">      grid.push(row)</span><span id="0af3" class="mb mc in lx b gy mh me l mf mg">   }</span><span id="3b26" class="mb mc in lx b gy mh me l mf mg">   for (let i = 1; i &lt; str1.length + 1; i++) {</span><span id="85de" class="mb mc in lx b gy mh me l mf mg">      for (let j = 1; j &lt; str2.length + 1; j++) {</span><span id="baf1" class="mb mc in lx b gy mh me l mf mg">         if (str1[i - 1] === str2[j - 1]) {</span><span id="7d02" class="mb mc in lx b gy mh me l mf mg">            grid[i][j] = grid[i - 1][j - 1]</span><span id="1b60" class="mb mc in lx b gy mh me l mf mg">         }else {</span><span id="4aaf" class="mb mc in lx b gy mh me l mf mg">            grid[i][j] = 1 + Math.min(<br/>               grid[i][j - 1],<br/>               grid[i - 1][j - 1], <br/>               grid[i - 1][j])</span><span id="0d41" class="mb mc in lx b gy mh me l mf mg">         }</span><span id="a434" class="mb mc in lx b gy mh me l mf mg">      }</span><span id="6e4b" class="mb mc in lx b gy mh me l mf mg">   }</span><span id="4443" class="mb mc in lx b gy mh me l mf mg">   return grid[str1.length][str2.length]</span><span id="70f4" class="mb mc in lx b gy mh me l mf mg">}</span></pre><p id="982c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从我们的<a class="ae ks" href="https://medium.com/@redlisa125/a-beginners-guide-to-the-levenshtein-distance-algorithm-part-1-d581fef7588f" rel="noopener">第1部分</a>示例中传递两个字符串“导师”和“中心”,得到这个矩阵和Levenshtein距离数3。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/5fb163ed4d4d59641ab6919818cc1837.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*Yj-1FDLIpImBKP1Uo3WoYg.png"/></div></figure><p id="4084" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Levenshtein距离是一个很难理解的复杂算法，更不用说编码了。当我需要学习这个算法时，我很难找到针对初学者的现有教程，所以我创建了自己的教程。这个由三部分组成的教程旨在将每个步骤分解成一个过程，任何经验水平的程序员都可以接近这个过程。只要对JavaScript有基本的了解，任何人都可以征服这个挑战！</p><blockquote class="mj mk ml"><p id="d334" class="kt ku lr kv b kw kx jo ky kz la jr lb mm ld le lf mn lh li lj mo ll lm ln lo ig bi translated">来源:</p><p id="c29b" class="kt ku lr kv b kw kx jo ky kz la jr lb mm ld le lf mn lh li lj mo ll lm ln lo ig bi translated">https://www.30secondsofcode.org/js/s/Levenshtein·恩斯坦距离<br/>https://www.youtube.com/watch?v=_1Qb95R87jU<br/>https://medium.com/@ethannam/understanding-the-Levenshtein·恩斯坦距离——初学者方程式——c 4285 a 5604 f 0<br/>https://www.youtube.com/watch?v=MiqoA-yF-0M</p></blockquote><p id="859a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lr">更多内容看</em> <a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">说白了。报名参加我们的</em> </a><a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">免费每周简讯</em> </a> <em class="lr">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="lr">社区</em> </a> <em class="lr">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>