<html>
<head>
<title>Vue.js State Management with Vuex: A Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js使用Vuex进行状态管理:初学者指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vue-js-state-management-with-vuex-a-beginners-guide-a1a281d7e91d?source=collection_archive---------8-----------------------#2021-02-28">https://javascript.plainenglish.io/vue-js-state-management-with-vuex-a-beginners-guide-a1a281d7e91d?source=collection_archive---------8-----------------------#2021-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2e103bcd3019f526d5ea93810910b068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCXAQpCAX2PGtWAjVKEUow.jpeg"/></div></div></figure><p id="9304" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">web应用程序的状态管理是一个复杂的过程。做这件事本身没有正确的方法，但是如果你不遵循一定的规则，事情会很快变得一团糟。Vuex是VueJs维护状态的方式。如果你已经熟悉像Redux这样的东西，它非常简单易懂。本文将带您了解Vuex的关键概念，最后我们将有一个利用所有这些概念的基本演示应用程序。让我们开始吧。</p><h2 id="e888" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">Vuex的基础知识</h2><p id="b10f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">Vuex本质上使用了一个<strong class="jx io">真实的单一来源</strong>，这意味着你所有的应用程序状态将被存储在一个单一的对象中。然后，这个源被暴露给一组将使用它的组件。这种模式非常常见，因为它在整个应用程序中保持所有数据<strong class="jx io">的一致性。</strong>在继续前进之前，你需要理解几个关键概念。</p><h2 id="7ebc" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">状态对象</h2><p id="5b5c" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">这就是我之前提到的<strong class="jx io">真理的单一来源</strong>。假设你正在开发一个笔记应用程序。笔记列表将是您的根状态。下面的例子是一个最简单的Vuex商店。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5fa6" class="kt ku in lw b gy ma mb l mc md">const store = new Vuex.store({<br/>  state : {<br/>    notes : []  //Always initialize your state properties<br/>  }<br/>})</span></pre><h2 id="ec5d" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">突变</strong></h2><p id="5f20" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">现在，您想要向刚刚创建的notes state属性添加一个注释。您不能直接访问属性并向其推送注释。您将对状态执行的任何类型的更新都将借助于变异来完成。突变基本上看起来像一个帮助您更新状态属性的常规事件。突变可以访问状态，因此您可以使用它轻松地添加、更新或删除元素。除了状态之外，还可以传入一个有效负载对象，在我们的例子中是一个note对象。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="a85f" class="kt ku in lw b gy ma mb l mc md">const store = new Vuex.store({<br/>  state : {<br/>    notes : []  <br/>  },<br/>  mutations:{<br/>    ADD_NOTE(state, note) {<br/>      state.notes = [...state.notes, note]<br/>    },<br/>  },<br/>})</span></pre><p id="c4e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们假设您有一个Vue组件想要向这个商店添加一个注释。你不能像对待一个事件那样简单地调用突变。您将使用商店的提交方法。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="63e9" class="kt ku in lw b gy ma mb l mc md">store.commit("ADD_NOTE", note) //The note that needs to be added</span></pre><p id="eff6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">突变只负责更新状态，但是它们不处理异步操作。所以不能在突变内部进行api调用。这就是<strong class="jx io">动作</strong>进入画面的地方。</p><h2 id="72b8" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">动作</strong></h2><p id="c50b" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">动作处理异步操作。此外，您可以从一个动作提交一个变异，因此如果您想使用一个动作向数据库添加一个注释，您可以通过将添加的注释作为有效载荷传入来立即<strong class="jx io">提交(调用)</strong>一个变异。</p><p id="3dfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">动作可以访问<strong class="jx io">上下文对象</strong>。这个上下文对象公开了与store实例相同的一组方法和属性，这就是为什么您可以从一个动作内部提交一个变异。如果你愿意，你甚至可以调用不同的动作。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="622e" class="kt ku in lw b gy ma mb l mc md">const store = new Vuex.store({<br/>  state : {<br/>    notes : []  <br/>  },<br/>  mutations:{<br/>    ADD_NOTE(state, note) {<br/>      state.notes = [...state.notes, note]<br/>    },<br/>  },<br/>  actions:{<br/>    async addNote(context, note) {<br/>      const notes = await apiCallToAddANote(note)<br/>      context.commit("ADD_NOTE", note) //Pass in the added note<br/>    }<br/>  }<br/>})</span></pre><p id="b76c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过使用store的dispatch方法，我们可以从组件树的任何地方访问这些操作。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1a7c" class="kt ku in lw b gy ma mb l mc md">store.dispatch("addNote", note)</span></pre><h2 id="f52c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">吸气剂</h2><p id="5265" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">当您需要状态的计算版本时，通常会使用Getters。例如，假设我们需要所有突出显示的音符。因此，您可以定义一个getter来返回经过过滤的高亮显示的笔记列表。这非常有帮助，因为您可能在不同的组件中使用过滤列表，并且您不必在使用它的任何地方重复逻辑。</p><p id="d8e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了存储，Getters本质上是计算属性。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6a45" class="kt ku in lw b gy ma mb l mc md">const store = new Vuex.store({<br/>  state : {<br/>    notes : []  <br/>  },<br/>  getters: {<br/>    redNotes(state) {<br/>      return state.notes.filter(note =&gt; note.highlighted == true)<br/>    }<br/>  },   <br/>  mutations:{<br/>    ADD_NOTE(state, note) {<br/>      state.notes = [...state.notes, note]<br/>    },<br/>  },<br/>  actions:{<br/>    async addNote(context, note) {<br/>      const notes = await apiCallToAddANote(note)<br/>      context.commit("ADD_NOTE", note) //Pass in the added note<br/>    }<br/>  }<br/>})</span></pre><h2 id="adb9" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">模块</h2><p id="65b3" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">一旦您的应用程序开始增长，您的应用程序状态也会增长。不建议将所有东西都放在一个商店里，尤其是对于较大的项目。所以Vuex提出了<strong class="jx io">模块</strong>作为解决方案。模块可以帮助你<strong class="jx io">将你的商店分成单独的“迷你商店”</strong>，然后导入到你的主商店文件中。高效扩展应用的关键一步。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="dc8a" class="kt ku in lw b gy ma mb l mc md">const notesModule = {<br/>  state: () =&gt; ({ ... }),<br/>  mutations: { ... },<br/>  actions: { ... },<br/>  getters: { ... }<br/>}<br/><br/>const tagsModule = {<br/>  state: () =&gt; ({ ... }),<br/>  mutations: { ... },<br/>  actions: { ... }<br/>}<br/><br/>const store = new Vuex.Store({<br/>  modules: {<br/>    notes: notesModule,<br/>    tags: tagsModule<br/>  }<br/>})<br/><br/>store.state.notes <br/>store.state.tags </span></pre><p id="3802" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们已经介绍了基础知识，那就让我们深入项目吧。</p><h2 id="783c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">演示应用程序</h2><p id="8b6b" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们将创建一个简单的待办事项列表应用程序，它将涵盖大多数Vuex概念。如果还没有安装<a class="ae me" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae me" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> vue cli </a>并创建一个新项目。(可以跳过这一部分，在本文末尾获取源代码)</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0473" class="kt ku in lw b gy ma mb l mc md">vue create vuex-demo</span></pre><p id="0b55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建项目后，安装Vuex</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="ee3e" class="kt ku in lw b gy ma mb l mc md">npm install vuex</span></pre><p id="82e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安装完成后，在项目目录中打开一个名为main.js的文件，并粘贴以下代码。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="79ae" class="kt ku in lw b gy ma mb l mc md">import Vue from 'vue'<br/>import App from './App.vue'<br/>import { store } from './store'</span><span id="3796" class="kt ku in lw b gy mf mb l mc md">Vue.config.productionTip = false</span><span id="28b6" class="kt ku in lw b gy mf mb l mc md">new Vue({<br/>render: h =&gt; h(App),<br/>store<br/>}).$mount('#app')</span></pre><p id="aef3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里发生的唯一额外的事情是，我们正在导入我们将在下一步中创建的商店，并将其公开给我们的整个应用程序。</p><p id="df56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在创建存储之前，我们将在源文件夹中创建一个虚拟数据库。为了简单起见，我们将不使用任何API或任何真实的数据库，而是尝试用本地数据库来模拟行为。</p><p id="ced7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在src文件夹中创建一个名为dataset.js的文件，并复制以下代码</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1b17" class="kt ku in lw b gy ma mb l mc md">export const DATASET = [<br/>  {<br/>    id: 1,<br/>    completed: false,<br/>    task: "Wake up"<br/>  },<br/>  {<br/>    id: 2,<br/>    completed: false,<br/>    task: "Work out"<br/>  },<br/>  {<br/>    id: 3,<br/>    completed: false,<br/>    task: "Eat food"<br/>  },<br/>  {<br/>    id: 4,<br/>    completed: false,<br/>    task: "Read a book"<br/>  },<br/>  {<br/>    id: 5,<br/>    completed: false,<br/>    task: "Go to sleep"<br/>  },<br/>]</span></pre><p id="f4eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，再次在src文件夹中创建一个名为store.js的文件，并复制以下代码。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="d333" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可能看起来很多，但实际上非常简单。</p><ol class=""><li id="9e6b" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">在我们的存储中，我们有一个名为<strong class="jx io"> todos </strong>的根状态，这是一个空数组。</li><li id="0521" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">我们有3个getters，一个用于<strong class="jx io">已完成的待办事项</strong>，一个用于<strong class="jx io">未完成的待办事项</strong>，最后一个具有<strong class="jx io">所有待办事项</strong>。</li><li id="2784" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">我们有3个变化<br/> - <strong class="jx io"> SET_TODOS </strong>:将当前为空的根TODOS数组设置为todo项的实际列表。<br/> - <strong class="jx io"> ADD_TODO </strong>:将TODO项添加到数组中。<br/> - <strong class="jx io"> TOGGLE_TODO </strong>:将待办事项设置为完成或未完成。</li><li id="4d2a" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">我们还有3个动作<br/> - <strong class="jx io"> setTodos </strong>:从数据库中获取Todos，然后将这个todo列表作为有效负载传递给SET_TODOS变异。<br/> - <strong class="jx io"> addTodo </strong>:将Todo项添加到数据库中，然后将todo项作为有效负载传递给ADD_todo变异<br/> - <strong class="jx io"> toggleTodo </strong>:编辑TODO项的completed属性，然后调用TODO项的id和completed属性作为有效负载的TOGGLE_TODO变异</li></ol><p id="8f43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于这是一个小应用程序，我们将不使用模块。</p><p id="8ba7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在src文件夹中，用以下内容替换App.vue文件的所有内容</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c479" class="kt ku in lw b gy ma mb l mc md">&lt;template&gt;<br/>  &lt;div id="app"&gt;&lt;Todos /&gt;&lt;/div&gt;<br/>&lt;/template&gt;</span><span id="fc3a" class="kt ku in lw b gy mf mb l mc md">&lt;script&gt;<br/>import Todos from "./components/Todos.vue";<br/>export default {<br/>  name: "App",<br/>  components: { Todos },<br/>  mounted() {<br/>    this.$store.dispatch("setTodos");<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="8e83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们基本上是导入和注入一个叫做Todos的组件。同样在挂载的生命周期挂钩中，我们<strong class="jx io">从存储中调度setTodos操作</strong>。一旦组件被挂载，这将呈现一个待办事项列表。</p><p id="f001" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为商店是在main.js文件中导入的，所以它对整个应用程序公开。所以你可以像我们刚才做的那样，从组件树的任何地方调用任何动作。</p><p id="9c77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在我们的组件文件夹中删除所有组件(如果有的话),并创建一个名为Todos.vue的新文件</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="00c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将单独查看每个模块。模板块有一个<strong class="jx io">表单</strong>，该表单有一个基本输入和一个用于添加待办事项的<strong class="jx io">提交按钮。</strong></p><p id="1050" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面我们有两个列表，一个呈现未完成待办事项列表<strong class="jx io">另一个呈现已完成待办事项列表</strong>。(最初所有的todos都是不完整的)</p><p id="3db2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在脚本块中，我们有一个将todo 初始化为空字符串的<strong class="jx io">数据属性。使用v-model将这个数据属性<strong class="jx io">映射到模板中的输入字段</strong>。</strong></p><p id="f573" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有两个计算属性，分别叫做<strong class="jx io">完成任务</strong>和<strong class="jx io">未完成任务</strong>。我们使用Vuex提供的<strong class="jx io"> mapGetters </strong>将这些计算属性的值映射到我们的存储Getters。</p><p id="21a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有两个方法:<strong class="jx io"> addTodo </strong>将接受todo v-model并将其传递给一个id和completed属性设置为false的对象。然后<strong class="jx io"> addTodo动作被分派</strong>，上面的对象作为有效载荷被传入。</p><p id="34ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> toggleTodo </strong>接收id和Todo的completed属性，并反转computed属性的值。然后<strong class="jx io">分派一个toggleTodo动作</strong>并将上述对象作为有效载荷传递。</p><p id="a428" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在打开终端，运行<code class="fe mw mx my lw b">npm run serve</code> <strong class="jx io"> </strong>命令。在你的浏览器上打开<strong class="jx io"> localhost:8080 </strong>，你会看到一个类似这样的应用。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/5cdbab256151f8ed52c816f368943496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnqyot6JjNbvmmvlwCDZWQ.png"/></div></div></figure><p id="d16f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(还有一个todos组件的样式块。我没有把它包括在这里，因为它对这个主题来说并不重要，但是你可以在这里找到它。)</p><p id="aaff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您可以从输入框添加todo项。点击任何一个当前的待办事项，你会将它们设置为已完成。将呈现一个不同的列表，其中包含一组完整的待办事项。您可以将它们从完整切换到不完整，或者相反。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/847a9aec7b69c335979dff64374d4c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_dBYoUkgy4wZZJYejdvRQ.png"/></div></div></figure><p id="9cdc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仅此而已。现在您有了一个基本的vuejs应用程序，它利用vuex来处理状态。你可以在这里找到应用<a class="ae me" href="https://github.com/AkileshRao/vuex-demo" rel="noopener ugc nofollow" target="_blank">的源代码。随意克隆回购，并对应用程序进行自己的更改。另外还有几个额外的链接供你参考。干杯！</a></p><ul class=""><li id="6c6a" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks nb mo mp mq bi translated"><a class="ae me" href="https://vuejs.org/v2/guide/" rel="noopener ugc nofollow" target="_blank">T5】VueJS文档T7】</a></li><li id="8396" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks nb mo mp mq bi translated"><a class="ae me" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> Vuex文档</em> </a></li><li id="b3e4" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks nb mo mp mq bi translated"><a class="ae me" href="https://buefy.org/documentation" rel="noopener ugc nofollow" target="_blank"><em class="nc"/></a></li><li id="3a44" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks nb mo mp mq bi translated"><a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/react-context-api-a-quick-guide-2065c040ae3d"> <em class="nc">使用上下文API进行状态管理</em> </a></li></ul></div></div>    
</body>
</html>