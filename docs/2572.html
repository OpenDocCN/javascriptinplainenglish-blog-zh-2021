<html>
<head>
<title>Promise in JavaScript (with All the Methods)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的承诺(包含所有方法)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/promise-in-javascript-with-all-the-methods-b7357196a57e?source=collection_archive---------2-----------------------#2021-05-27">https://javascript.plainenglish.io/promise-in-javascript-with-all-the-methods-b7357196a57e?source=collection_archive---------2-----------------------#2021-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0b0fa17c21d6561d8a6582a60731c0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3S0Y1DQJe-NsUXHdNl8gHg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Promise in javascript</figcaption></figure><p id="3f35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">承诺是一个物体，一旦完成任务，它要么在未来给你一个结果，要么给你一个错误。它是一种流行的设计模式，用于处理Node.js中的异步任务。它可以处理许多任务的并行/串行执行以及它们的链接规则。promise结构还提供了有效的错误捕捉机制。</p><h2 id="1317" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">Promise.resolve():</h2><p id="de7f" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">Promise.resolve()方法返回一个带有给定值的已解析的Promise对象。根据确定的承诺值，它</p><p id="3f27" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">1.如果履行了承诺，则返回承诺<br/> 2。如果满足值<br/> 3，则返回一个值。通过采用最终状态返回可接受的承诺，如果可接受的承诺得到履行</p><p id="2a03" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此函数将类似承诺的对象(例如，解析为可解析为某物的承诺的承诺)的嵌套层展平为单一层。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b260" class="kx ky in ma b gy me mf l mg mh">Promise.resolve('Success').then((value) =&gt; {<br/>  console.log(value); // "Success"<br/>}).catch((error) =&gt; {<br/>  console.log(error);<br/>});</span></pre><h2 id="4c40" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">Promise.reject()。</h2><p id="dd58" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">Promise.reject()方法返回一个因给定原因而被拒绝的Promise对象。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f6d7" class="kx ky in ma b gy me mf l mg mh">Promise.reject('failure').then((value) =&gt; {<br/>  console.log(value); <br/>}).catch((error) =&gt; {<br/>  console.log(error); // "failure"<br/>});</span></pre><h2 id="c542" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">Promise.then():</h2><p id="e366" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated"><strong class="kb io"> then() </strong>方法返回一个承诺。它最多需要两个参数:回调函数用于<code class="fe mi mj mk ma b">Promise</code>的成功和失败情况。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b34b" class="kx ky in ma b gy me mf l mg mh">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  resolve('Success!');<br/>});</span><span id="77b6" class="kx ky in ma b gy ml mf l mg mh">promise1.then((value) =&gt; {<br/>  console.log(value);<br/>  // expected output: "Success!"<br/>}, (error) =&gt; {<br/>  console.log( error);<br/>});</span></pre><h2 id="1f2d" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">Promise.catch():</h2><p id="a7c6" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated"><strong class="kb io"> catch() </strong>方法返回被拒绝的承诺。其行为与调用promise . prototype . then(undefined，onRejected)相同。调用Promise.catch(onRejected)内部调用Promise.then(undefined，onRejected)。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="96e4" class="kx ky in ma b gy me mf l mg mh">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  throw 'Exception handling';<br/>});</span><span id="0fb9" class="kx ky in ma b gy ml mf l mg mh">promise1.then((value) =&gt; {<br/>  console.log(value);<br/>}).catch((error) =&gt; {<br/>  console.error(error);<br/>});</span><span id="2e50" class="kx ky in ma b gy ml mf l mg mh">&gt; "Exception handling"</span></pre><h2 id="42a4" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">Promise.finally():</h2><p id="16fa" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated"><strong class="kb io"> finally() </strong>方法返回一个承诺。当承诺完成时，执行指定的回调函数。这为代码运行提供了一种方式，而不考虑承诺结算。finally回调不会收到任何参数，因为无法确定承诺是被履行还是被拒绝。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f1f0" class="kx ky in ma b gy me mf l mg mh">const promise1 = Promise.reject("Rejecting Promise");<br/>promise1<br/>  .then(value =&gt; {<br/>    console.log(value)<br/>  })<br/>  .catch(err =&gt; {<br/>    console.log(err)<br/>  })<br/>  .finally(() =&gt; {<br/>    console.log("completed promise")<br/>  });</span><span id="34ac" class="kx ky in ma b gy ml mf l mg mh">&gt; "Rejecting Promise"<br/>&gt; "completed promise"</span></pre></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="4d3a" class="mt ky in bd kz mu mv mw lc mx my mz lf na nb nc li nd ne nf ll ng nh ni lo nj bi translated">常见的承诺效用方法:</h1><h2 id="63a7" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">无极. all():</h2><p id="6fed" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">Promise.all()方法接受一个承诺数组并返回一个承诺，该承诺根据任何可迭代的承诺被解析或拒绝。如果数组中的所有承诺都解析，则它解析；如果有任何承诺拒绝，则它拒绝。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="ee31" class="kx ky in ma b gy me mf l mg mh">const promise1 = Promise.resolve("hello world");<br/>const promise2 = "Promise 2";<br/>const promise3 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(resolve, 100, 'foo');<br/>});</span><span id="680b" class="kx ky in ma b gy ml mf l mg mh">Promise.all([promise1, promise2, promise3]).then((values) =&gt; {<br/>  console.log(values);<br/>});<br/>// expected output: Array ["hello world", "Promise 2", "foo"]</span></pre><h2 id="8cd0" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">无极. race():</h2><p id="5f15" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">Promise.race()方法也接受一个承诺数组并返回一个承诺，该承诺基于一个可迭代承诺数组被解析或拒绝。与promise.all()不同，它不会等到所有的承诺都执行了。一旦任何承诺被解决或拒绝，它将返回承诺。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8424" class="kx ky in ma b gy me mf l mg mh">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(resolve, 300, 'Hello world');<br/>});</span><span id="9c73" class="kx ky in ma b gy ml mf l mg mh">const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(resolve, 100, 'Goodbye world');<br/>});</span><span id="22fc" class="kx ky in ma b gy ml mf l mg mh">Promise.race([promise1, promise2]).then((value) =&gt; {<br/>  console.log(value);<br/>  // Both resolve, but promise2 is faster<br/>});<br/>&gt; "Goodbye world"</span></pre><h2 id="4cf8" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">无极. any():</h2><p id="2f17" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">Promise.any()方法接受一组承诺并返回一个承诺。如果数组中的任何承诺用解析的值解析，它将解析。如果所有承诺都被拒绝，承诺将被拒绝，并显示错误“aggregate error:All promises are rejected”。<code class="fe mi mj mk ma b"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError" rel="noopener ugc nofollow" target="_blank">AggregateError</a></code>，<code class="fe mi mj mk ma b"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="noopener ugc nofollow" target="_blank">Error</a></code>的一个新子类，将单个错误组合在一起。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9c11" class="kx ky in ma b gy me mf l mg mh">const promise1 = Promise.reject(0);<br/>const promise2 = Promise.resolve('Hello world');<br/>const promise3 = new Promise((resolve) =&gt; setTimeout(resolve, 300, 'Good bye'));</span><span id="f72a" class="kx ky in ma b gy ml mf l mg mh">const promises = [promise1, promise2, promise3];</span><span id="357e" class="kx ky in ma b gy ml mf l mg mh">Promise.any(promises).then((value) =&gt; console.log(value));</span><span id="c996" class="kx ky in ma b gy ml mf l mg mh">&gt; Hello world</span></pre><h2 id="c867" class="kx ky in bd kz la lb dn lc ld le dp lf kk lg lh li ko lj lk ll ks lm ln lo lp bi translated">Promise.allSettled():</h2><p id="10b2" class="pw-post-body-paragraph jz ka in kb b kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks lu ku kv kw ig bi translated">方法接受一个承诺数组并返回一个承诺。当数组中的承诺相互独立，并且拒绝一个承诺不会阻止另一个承诺时，通常使用这种方法。Promise.all()和Promise.allSettled()之间的主要区别在于，prior停止执行任何被拒绝的承诺，主要用于承诺相互依赖的情况，而following将等到所有承诺都被解决，并以数组形式给出结果。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b531" class="kx ky in ma b gy me mf l mg mh">const promise1 = Promise.resolve("Hello world");<br/>const promise2 = Promise.reject('Rejecting');;<br/>const promises = [promise1, promise2];</span><span id="1862" class="kx ky in ma b gy ml mf l mg mh">Promise.allSettled(promises).<br/>  then((results) =&gt; results.forEach((result) =&gt; console.log(result)));</span><span id="7eda" class="kx ky in ma b gy ml mf l mg mh">&gt; Object { status: "fulfilled", value: "Hello world" } <br/>&gt; Object { status: "rejected", reason: "Rejecting" }</span></pre><p id="2f96" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在接下来的一篇文章中，我们将关注async/await，这是一个更加语法化的东西，它可以从根本上简化代码，增加可读性，并显著减少代码行。</p><p id="ea07" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="nl">感谢阅读。最初发表于2021年5月26日https://noob2geek.in/</em></strong><strong class="kb io"><em class="nl"/></strong><a class="ae nk" href="https://noob2geek.in/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="nl">。</em>T15】</strong></a></p><p id="c60d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="nl">更多内容请看</em><a class="ae nk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nl">plain English . io</em></a></p></div></div>    
</body>
</html>