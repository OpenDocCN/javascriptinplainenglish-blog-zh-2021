<html>
<head>
<title>Dealing with Code Splitting Network Failures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理代码分割网络故障</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-deal-with-network-failures-from-code-splitting-13dd7fd3648?source=collection_archive---------4-----------------------#2021-04-14">https://javascript.plainenglish.io/how-to-deal-with-network-failures-from-code-splitting-13dd7fd3648?source=collection_archive---------4-----------------------#2021-04-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cef8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">重新加载代码分割块以尝试从网络故障中恢复。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8c66cf80842c4e061cc59b67df2acbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6A3f92BibsEAYNl1A5lsA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Network Failure</figcaption></figure><h2 id="0564" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">我的旅程</h2><p id="9ede" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">在我用动态导入和React惰性加载将我的<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/a-guide-to-react-lazy-loading-6bca6be7159">单页面应用包</a>分割成多个块之后，我开始偶尔在生产中看到错误。某些东西导致了运行时错误，这将导致整个应用程序崩溃，并冒泡到我的React错误边界。查看日志，令人不快的错误是这样的:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="63b9" class="ks kt in mj b gy mn mo l mp mq">Error: ChunkLoadError: Loading chunk 0 failed.</span></pre><h2 id="be55" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">根本原因</h2><p id="4e7a" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">经过一番挖掘，我意识到根本原因是网络。更多的块意味着更多的请求，这意味着更多的网络故障的机会。如果任何一个请求的块失败，就会触发上面的错误。但是我真的不能做任何事情来修复一个用户的网络。那么，下一个最好的是什么？</p><h2 id="dbf2" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">方法</h2><p id="4397" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">如果网页加载失败，我该怎么办？我刷新页面，再试一次。这个相同的原理可以应用于代码分割块。如果失败，再次加载有问题的块，并希望它成功。虽然这肯定不能保证解决问题，但这是解决我们无法控制的事情的次佳选择。</p><h2 id="bc72" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">组块重试</h2><p id="6835" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">那么，这是如何用代码实现的呢？代码拆分是通过动态导入语法实现的。这将返回一个承诺，当块被成功加载时，这个承诺就会实现。我们需要一个实现重试机制的包装器，而不是直接将动态导入承诺传递给React lazy。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="622e" class="ks kt in mj b gy mn mo l mp mq">// App.js<br/>import importRetry from './importRetry';</span><span id="7114" class="ks kt in mj b gy mr mo l mp mq">const Chunk = lazy(() =&gt;<br/>  importRetry(() =&gt; import('./Chunk'))<br/>);</span><span id="c36a" class="ks kt in mj b gy mr mo l mp mq">// importRetry.js<br/>async function importRetry(importFn, retries = 2, interval = 1000) {<br/>  try {<br/>    return await importFn();<br/>  } catch (error) {<br/>    if (retries) {<br/>      await wait(interval);<br/>      return importRetry(importFn, retries - 1, interval);<br/>    } else {<br/>      throw new Error(error);<br/>    }<br/>  }<br/>}</span><span id="0087" class="ks kt in mj b gy mr mo l mp mq">function wait(ms) {<br/>  return new Promise(resolve =&gt; setTimeout(resolve, ms));<br/>}</span></pre><p id="83f3" class="pw-post-body-paragraph lo lp in lq b lr ms jo lt lu mt jr lw lb mu ly lz lf mv mb mc lj mw me mf mg ig bi translated"><code class="fe mx my mz mj b">importRetry</code>包装器将尝试进行动态导入。如果不成功，它将等待一小段时间，然后再次尝试，直到达到<code class="fe mx my mz mj b">retries</code>指定的次数。希望通过等待，网络问题得到解决。如果在所有的重试之后请求仍然不成功，我们别无选择，只能返回错误。</p><h2 id="794d" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">网络包</h2><p id="fd54" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">如果你想要一个更加自动化的方法来处理动态导入重试，有一个npm包可以满足你的需求——<a class="ae mh" href="https://www.npmjs.com/package/webpack-retry-chunk-load-plugin" rel="noopener ugc nofollow" target="_blank">webpack-retry-chunk-load-plugin</a>通过web pack实现了相同的功能。它提供了一个插件，可以在失败时自动注入代码来重新加载程序块。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="46ba" class="ks kt in mj b gy mn mo l mp mq">// webpack.config.js<br/>const { RetryChunkLoadPlugin } = require('webpack-retry-chunk-load-plugin');</span><span id="40f5" class="ks kt in mj b gy mr mo l mp mq">module.exports = {<br/>  plugins: [<br/>    new RetryChunkLoadPlugin({<br/>      maxRetries: 3,<br/>    })<br/>  ];<br/>};</span></pre><p id="d743" class="pw-post-body-paragraph lo lp in lq b lr ms jo lt lu mt jr lw lb mu ly lz lf mv mb mc lj mw me mf mg ig bi translated">这个插件提供的灵活性不如直接通过代码实现重试，但它将保证每个导入都有一个重试机制。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h2 id="eac0" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">最后的想法</h2><p id="9628" class="pw-post-body-paragraph lo lp in lq b lr ls jo lt lu lv jr lw lb lx ly lz lf ma mb mc lj md me mf mg ig bi translated">随着我的单页面应用程序变得越来越大，代码分割成为确保良好加载时间的必要工具。但由于糟糕的路由器、不稳定的连接和太阳耀斑，这些代码分割块上的网络故障是可以预料的。我们必须尽最大努力使我们的代码库对错误有弹性，并在错误出现时尝试自我修复。在这种情况下，我们必须再次尝试加载数据块。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h2 id="be50" class="ks kt in bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">资源</h2><ul class=""><li id="003c" class="nh ni in lq b lr ls lu lv lb nj lf nk lj nl mg nm nn no np bi translated">web pack-retry-chunk-load-plugin的官方文档</li><li id="d93d" class="nh ni in lq b lr nq lu nr lb ns lf nt lj nu mg nm nn no np bi translated"><a class="ae mh" href="https://github.com/mjchang/medium/tree/master/chunk-retry" rel="noopener ugc nofollow" target="_blank"> Github回购本文</a></li><li id="65c7" class="nh ni in lq b lr nq lu nr lb ns lf nt lj nu mg nm nn no np bi translated"><a class="ae mh" href="https://codesandbox.io/s/github/mjchang/medium/tree/master/chunk-retry" rel="noopener ugc nofollow" target="_blank">本文的CodeSandbox】</a></li></ul></div></div>    
</body>
</html>