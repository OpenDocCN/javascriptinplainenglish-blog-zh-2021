<html>
<head>
<title>Do TypeScript Types Provide Enough Documentation On Their Own?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript类型本身是否提供了足够的文档？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/are-typescript-types-alone-enough-documentation-e09a524716bf?source=collection_archive---------17-----------------------#2021-01-25">https://javascript.plainenglish.io/are-typescript-types-alone-enough-documentation-e09a524716bf?source=collection_archive---------17-----------------------#2021-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0e99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个有趣的问题；您的TypeScript项目中的类型本身是否足够文档化，以允许某人学习该库？</p><p id="bf75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我看到亚马逊为AWS发布了React UI库时，我问了自己这个问题。他们只发布了代码和类型脚本类型。没有文件。没有故事书或styleguidist。只有代码和类型。</p><p id="7f03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我喜欢钻研UI库。这是一个有趣的挑战。我可以只从源代码学习库吗？所以我用<code class="fe ki kj kk kl b">typescript</code>模板创建了一个React应用，然后安装了<code class="fe ki kj kk kl b">@awsui/components-react</code>库，开始了我的侦查。</p><p id="a0b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先要意识到的是，VS Code热爱TypeScript，在这个旅程中，它将是你无价的伙伴。例如，您可以右键单击导入并询问定义，如下面的屏幕截图所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ac7106d37c67edf5c401094c3f4fe820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiUdcRZC7hCMve4mP-n6vg@2x.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Using VS Code to navigate to the definitions</figcaption></figure><p id="6020" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将把您带到列出所有组件及其属性的中央定义文件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lc"><img src="../Images/135cfb95e1027d8b666f45cb8b874360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oj2fExyG6UcSbtvZ8UAweQ@2x.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Just a few of the fascinating components in the AWS UI toolkit</figcaption></figure><p id="2f93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">头奖！现在我知道里面有什么了。但是怎么用呢？</p><h1 id="7667" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">获得正确的布局</h1><p id="9390" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">立刻吸引我眼球的是<code class="fe ki kj kk kl b">AppLayout</code>,因为，实际上，在UI库中有两种类型的玩具；布局组件和交互组件。第一项工作是创建布局，第二项工作是把东西放到布局中。</p><p id="64b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">命名很重要，对吧？<code class="fe ki kj kk kl b">AppLayout</code>。听起来不错！我正在做一个<code class="fe ki kj kk kl b">App</code>，检查。而且我需要一个<code class="fe ki kj kk kl b">Layout</code>，双重检查。<code class="fe ki kj kk kl b">AppLayout</code>正是！这也有助于它是按字母顺序排列的。</p><p id="cd0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我在页面上放了一个<code class="fe ki kj kk kl b">AppLayout</code>，马上我得到了一个三列布局，左边是一个可折叠的<code class="fe ki kj kk kl b">navigation</code>面板，右边是一个<code class="fe ki kj kk kl b">tools</code>面板，中间是一个<code class="fe ki kj kk kl b">content</code>部分。我怎么知道的？因为类型！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mg"><img src="../Images/776816d877a5ae98dc95272996084c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFQHu9woNB902kjGiigzvw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">The types for content, navigation and tools properties on the AppLayout component</figcaption></figure><p id="5170" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，这不仅告诉我哪些部分可用，还告诉我他们期望的内容类型，在本例中是基本上可以在React中呈现的<code class="fe ki kj kk kl b">ReactNode</code>类型。</p><p id="9793" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我用以下代码替换了封装的<code class="fe ki kj kk kl b">App</code>组件的全部内容:</p><pre class="kn ko kp kq gt mh kl mi mj aw mk bi"><span id="2777" class="ml le in kl b gy mm mn l mo mp">function App() {<br/>  return (<br/>    &lt;AppLayout<br/>      navigation={&lt;div&gt;Navigation&lt;/div&gt;}<br/>      content={&lt;div&gt;Content&lt;/div&gt;}<br/>      tools={&lt;div&gt;Tools&lt;/div&gt;}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="7dc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我运行<code class="fe ki kj kk kl b">yarn start</code>,马上我得到了一个看起来相当不错的响应布局，有三列和可折叠部分。我去赛马了！</p><h1 id="8570" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">正如所料，除了一些例外</h1><p id="a3ec" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">我不是一个只玩组件的人，我想做一些真实的东西。所以我创建了一个口袋妖怪滤镜应用程序。有些事情，比如<code class="fe ki kj kk kl b">Button</code>非常简单。</p><pre class="kn ko kp kq gt mh kl mi mj aw mk bi"><span id="72aa" class="ml le in kl b gy mm mn l mo mp">&lt;Button onClick={() =&gt; alert("hello!")}&gt;Say Hello&lt;/Button&gt;</span></pre><p id="bbb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是现成的，但默认情况下，按钮本身并不十分吸引人。再一次，打字稿来拯救！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/526f30051fa82841dc1bf76d030aefad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDMbdmxhDdNjAL5ox_0bwQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">The potential variants of Button styling</figcaption></figure><p id="1079" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用VSCode中的<code class="fe ki kj kk kl b">Go To Definition</code>,我可以选择一个<code class="fe ki kj kk kl b">Button</code>组件，并一直钻下去，直到我找到了<code class="fe ki kj kk kl b">ButtonProps</code>,它向我展示了一个<code class="fe ki kj kk kl b">variant</code>属性，我可以用它来选择不同风格的按钮。我最终选择了<code class="fe ki kj kk kl b">link</code>。</p><p id="acfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个时刻发生在我使用<code class="fe ki kj kk kl b">Input</code>组件的时候，正如你可能猜到的，它是一个文本输入。一切都进行得很顺利，直到我到达<code class="fe ki kj kk kl b">onChange</code>，那里的活动结构与我们预期的有点不同。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mr"><img src="../Images/343d9109a1ee64503d7b974ce15807b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEFFjuQWWl4RjVwlSFstEQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Hinting on the event data from onChange</figcaption></figure><p id="8b5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下<code class="fe ki kj kk kl b">event.target.value</code>不存在。又一次，VS Code来拯救我，我找到了我要找的机器人<code class="fe ki kj kk kl b">event.detail.value</code>。</p><h1 id="0032" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">寻找新的模式</h1><p id="5e57" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">最终我需要贴一张口袋妖怪的清单。我不仅找到了一个很好的<code class="fe ki kj kk kl b">Cards</code>组件来做这件事，我还找到了一个定义通用React组件的好方法。看看这个。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ms"><img src="../Images/291df5db2ae04e8e56458aaad79e31d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4p8k2Lojrj4jCV5E2LksZg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">TypeScript generics for React components</figcaption></figure><p id="814d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以你给了<code class="fe ki kj kk kl b">Cards</code>一个<code class="fe ki kj kk kl b">items</code>数组，然后你提供了<code class="fe ki kj kk kl b">content</code>函数来呈现每一项的内容。</p><p id="44d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论如何，因为TypeScript，AWS团队将<code class="fe ki kj kk kl b">Card</code>定义为泛型，当您为该<code class="fe ki kj kk kl b">items</code>属性传入一个数组时，TypeScript会自动推断该数组的类型，然后根据需要将它应用到属性定义的其他部分。在您的<code class="fe ki kj kk kl b">content</code>函数中，您可以从项目数组中获得类型安全和类型提示。作为消费者，你不需要做任何额外的工作来实现这一点。它只是免费工作，正如你所期望的那样。</p><p id="7216" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看到这一幕是旅途中最激动人心的发现时刻。出于这样或那样的原因，我还没有真正考虑过对React组件使用泛型。所以这是一个真正的“啊哈！”我从<strong class="jm io">读代码</strong>得到的瞬间。这不是我从文档中得到的东西(很可能)。</p><p id="0072" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了泛型之外，看到这种向组件提供一些数据和一个呈现函数的模式(这是整个工具包中的一种模式)也是非常好的。我以前在像苹果的iOS列表组件这样的工具包中见过它。但是我很少在网上看到它，我认为这是一个很好的架构模式，值得更广泛地使用。</p><h1 id="58ad" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">视频版</strong></h1><p id="325c" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">如果你想看我对AWS UI工具包的探索，请查看YouTube版本。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Hacking with the AWS React UI Toolkit</figcaption></figure><h1 id="7a41" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="437e" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">我从这次侦查经历中学到的两大收获是:</p><ul class=""><li id="8bb1" class="mv mw in jm b jn jo jr js jv mx jz my kd mz kh na nb nc nd bi translated"><strong class="jm io">学会阅读代码</strong> —代码就是真理。学习如何阅读别人的代码可以成为信息、灵感、教育等所有好东西的来源。更好的是，当你建立起代码阅读能力时，你可以开始把Github不仅仅看作是一个“抓取代码”的地方，而是宇宙中已知的最好的代码阅读库。</li><li id="1145" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated"><strong class="jm io">打字稿就是文档</strong>——当然打字并不能回答所有的问题。但是它能很快回答很多问题，而且是免费的。所以成本/收益比是突出的。各位，打字稿是值得的。</li><li id="8721" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated"><strong class="jm io">奖励:命名真的很重要</strong> —我只是触及了这个库的皮毛。有成吨的组件。唯一让我纠结的时刻是这些组件的命名。比如说；什么是“瓷砖”？(原来是单选按钮)。这并不是AWS的人的错。命名很难。但是作为前端开发人员，在某种程度上，规范我们对UI元素的命名可能会对我们有益。</li></ul></div></div>    
</body>
</html>