<html>
<head>
<title>How to Add a Timeout Limit to Asynchronous JavaScript Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何给异步JavaScript函数添加超时限制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-a-timeout-limit-to-asynchronous-javascript-functions-3676d89c186d?source=collection_archive---------2-----------------------#2021-08-23">https://javascript.plainenglish.io/how-to-add-a-timeout-limit-to-asynchronous-javascript-functions-3676d89c186d?source=collection_archive---------2-----------------------#2021-08-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/652f4aec4484e45021dd1d91e258a7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TInwON1DkNnO1_2F"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5fe4" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题</h1><p id="e547" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">当使用异步JavaScript时，很容易陷入试图记住如何正确使用<code class="fe lw lx ly lz b">async/await</code>或承诺来获得您想要的数据的困境。开发人员经常忘记(或者甚至不知道)本地JavaScript在进行这些调用时没有超时机制的概念，所以如果您允许的话，这些异步操作将永远继续下去。</p><p id="b0e3" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">显然，如果你在等待永远不会到达的数据，这不是一个好的行为。无限的等待时间会导致各种问题，包括耗尽内存、霸占服务器上的资源，以及许多其他可能导致意外甚至危险结果的问题。</p><h1 id="d32f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决方案</h1><p id="c828" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">对于异步JavaScript的这个突出问题，该怎么办呢？添加我们自己的暂停。实现函数运行时间的最大限制将允许开发人员安全地处理他们想要的数据既没有被解析也没有被拒绝的情况。</p><p id="5a26" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">通过包含超时，我们可以在函数运行时间超过预期时间时提供我们自己的拒绝。这种拒绝可以被我们选择的错误捕捉方法优雅地处理，并把我们从上面提到的糟糕情况中拯救出来。</p><h1 id="240d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">如何在JavaScript中创建超时</h1><p id="f620" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">为了创建超时，我们将使用一个接受承诺和时间限制的异步函数。因为JavaScript的原生<code class="fe lw lx ly lz b">setTimeout</code>函数使用毫秒作为参数，所以为了简单起见，我们将使用同样的方法。</p><pre class="mf mg mh mi gt mj lz mk ml aw mm bi"><span id="44bd" class="mn kb in lz b gy mo mp l mq mr">const asyncCallWithTimeout = (asyncPromise, timeLimit) =&gt; {};</span></pre><p id="9706" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">我们现在需要创建一个<code class="fe lw lx ly lz b">timeoutPromise</code>来使用<code class="fe lw lx ly lz b">timeLimit</code>值作为运行的最大时间。为此，如果达到时间限制，我们可以使用有错误的<code class="fe lw lx ly lz b">setTimeout</code>和<code class="fe lw lx ly lz b">reject</code>。</p><pre class="mf mg mh mi gt mj lz mk ml aw mm bi"><span id="1a7e" class="mn kb in lz b gy mo mp l mq mr">const timeoutPromise = new Promise((_resolve, reject) =&gt; {<br/>    timeoutHandle = setTimeout(<br/>        () =&gt; reject(new Error('Async call timeout limit reached')),<br/>        timeLimit<br/>    );<br/>});</span></pre><p id="e455" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">准备好之后，我们将使用<code class="fe lw lx ly lz b">Promise.race()</code>来运行两个不同的承诺。这两个承诺将是我们传进去的<code class="fe lw lx ly lz b">asyncPromise</code>，也是我们的<code class="fe lw lx ly lz b">timeoutPromise</code>。此外，我们希望在<code class="fe lw lx ly lz b">asyncPromise</code>成功的情况下移除超时，所以我们也将在这里添加清理。</p><pre class="mf mg mh mi gt mj lz mk ml aw mm bi"><span id="ed58" class="mn kb in lz b gy mo mp l mq mr">return Promise.race([asyncPromise, timeoutPromise]).then(result =&gt; {<br/>    clearTimeout(timeoutHandle);<br/>    return result;<br/>});</span></pre><p id="39b4" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">将所有这些部分放在一起(以及定义<code class="fe lw lx ly lz b">timeoutHandle</code>以便可以在多个地方使用),我们的整体功能应该是这样的:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="50b8" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">asyncCallWithTimeout的用法</h1><p id="bcea" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">为了理解<code class="fe lw lx ly lz b">asyncCallWithTimeout</code>函数的响应，我们可以考虑两种情况。首先要考虑的情况是没有达到时间限制，而asyncPromise成功了。第二种情况是超过时间限制，函数返回错误。</p><p id="efa8" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">为了演示其中的每一个，我们将使用<code class="fe lw lx ly lz b">axios</code>调用一个外部API<code class="fe lw lx ly lz b">GET</code>，<a class="ae jz" href="https://baconipsum.com/json-api/" rel="noopener ugc nofollow" target="_blank"> Bacon Ipsum </a>。这种基于承诺的方法将需要几秒钟的时间来解决，这使它成为超时函数能力的一个有用的演示，接近真实世界的用例。</p><blockquote class="mu mv mw"><p id="d450" class="ky kz mx la b lb ma ld le lf mb lh li my mc ll lm mz md lp lq na me lt lu lv ig bi translated"><strong class="la io">注意:</strong>本文假设您已经熟悉了<code class="fe lw lx ly lz b">npm</code>和安装包。如果没有，可以在<a class="ae jz" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios npm包</a>中找到安装说明。</p></blockquote><h2 id="9125" class="mn kb in bd kc nb nc dn kg nd ne dp kk lj nf ng ko ln nh ni ks lr nj nk kw nl bi translated">异步承诺成功返回</h2><p id="5442" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">为了成功地从Bacon Ipsum返回数据，我们可以使用下面的代码。<code class="fe lw lx ly lz b">wontTimeout</code>函数将我们的<code class="fe lw lx ly lz b">GET</code>调用作为<code class="fe lw lx ly lz b">asyncPromise</code>传递，时限为10秒。这个时间限制应该足以成功返回数据，但是如果您继续遇到错误消息，您可能需要增加限制。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9f6a" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">当我们运行这个<code class="fe lw lx ly lz b">wontTimeout</code>函数时，我们看到数据被成功返回，因为我们没有超过时间限制。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/652ea24d2bb0312260123fe9d90b535b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRTnRwFIAH-1sgnR5yM1QQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The data has been successfully returned</figcaption></figure><h2 id="98f0" class="mn kb in bd kc nb nc dn kg nd ne dp kk lj nf ng ko ln nh ni ks lr nj nk kw nl bi translated">达到时间限制</h2><p id="d8e8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在我们知道<code class="fe lw lx ly lz b">asyncPromise</code>正在成功运行，让我们探索一个例子，其中时间限制比成功调用API所需的时间要短。我们将使用与上面几乎相同的代码，只是传递给我们函数的时间限制要短得多。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="41e3" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">在1毫秒的时间限制下，肯定会超过允许的最大时间。因此，我们收到的不是来自API的数据，而是一个错误。</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/c88d59b6af5e3008605ba33d8a54eb51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7UZeRYWNCtxV5dVHaXkmA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">An error has been thrown</figcaption></figure><p id="2fa0" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">显然，1毫秒短得令人难以置信，而且很可能是一个不合理的异步调用返回时间，所以在现实世界中使用这个函数时，请确保设置了实际的时间限制。</p><h1 id="b177" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="14ac" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">超时是防止无限运行代码产生问题的一个重要工具。正确使用超时将允许您更快地失败，而不是让您的用户束手无策，等待您的代码崩溃或放弃。它还将节省您的资源，如果您在云中运行的是随用随付的情况，这是绝对重要的。</p><p id="dcda" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">最终，使用超时来保护您的代码库是一个明智的想法，尤其是当您与您无法控制的第三方服务进行交互时。如果您是一名从事任何类型的异步项目的JavaScript开发人员，请查看一下您的代码库，看看您能从中受益的地方。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="7a97" class="ka kb in bd kc kd nu kf kg kh nv kj kk kl nw kn ko kp nx kr ks kt ny kv kw kx bi translated">资源</h1><ul class=""><li id="33eb" class="nz oa in la b lb lc lf lg lj ob ln oc lr od lv oe of og oh bi translated"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺— MDN网络文档</a></li><li id="c73e" class="nz oa in la b lb oi lf oj lj ok ln ol lr om lv oe of og oh bi translated"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步功能— MDN Web文档</a></li><li id="c218" class="nz oa in la b lb oi lf oj lj ok ln ol lr om lv oe of og oh bi translated"><a class="ae jz" href="https://nodejs.org/en/docs/guides/timers-in-node/" rel="noopener ugc nofollow" target="_blank">node . js中的定时器— Node.js文档</a></li><li id="372c" class="nz oa in la b lb oi lf oj lj ok ln ol lr om lv oe of og oh bi translated"><a class="ae jz" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios包— npm存储库</a></li></ul><p id="298a" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><em class="mx">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="mx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>