<html>
<head>
<title>The benefit of the Thenable object in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中可命名对象的好处</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-benefit-of-the-thenable-object-in-javascript-78107b697211?source=collection_archive---------3-----------------------#2021-01-11">https://javascript.plainenglish.io/the-benefit-of-the-thenable-object-in-javascript-78107b697211?source=collection_archive---------3-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fe45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">thenable</code>对象、<code class="fe ki kj kk kl b">promise</code>和<code class="fe ki kj kk kl b">async/await</code>的关系</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/1528ee758632d7298a149051365ba40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9GDjf2iPnSquG52Pcr5Ng.png"/></div></figure><p id="0041" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你使用像<code class="fe ki kj kk kl b"><a class="ae ku" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">mongoose</strong></a></code>、<code class="fe ki kj kk kl b"><a class="ae ku" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">knex</strong></a><strong class="jm io"> </strong></code>和其他一些类似的库——它们有某种可链接的方法，也异步运行——你也应该读读这篇文章。</p><p id="8ce9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能已经听说过<code class="fe ki kj kk kl b">thenable</code>对象、<code class="fe ki kj kk kl b">promise</code>和<code class="fe ki kj kk kl b">async/await</code>。如果你还没有或仍然没有得到它们之间的关系，不要担心，我们会在这里完全覆盖。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h2 id="34d6" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">什么是“可”对象？</h2><p id="e36e" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated"><code class="fe ki kj kk kl b">thenable</code>对象的定义是世界上最简单的事情:</p><blockquote class="ma"><p id="6f79" class="mb mc in bd md me mf mg mh mi mj kh dk translated">任何包含名为"<code class="fe ki kj kk kl b">then” </code>的方法的对象都被称为"可命名"对象。</p></blockquote><p id="5689" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">例如:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8287" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个对象(<code class="fe ki kj kk kl b">obj</code>)是一个<code class="fe ki kj kk kl b">thenable</code>对象。</p><p id="fa94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mr">注意:一个</em> <code class="fe ki kj kk kl b"><em class="mr">thenable</em></code> <em class="mr">对象可以有任何其他属性和方法，也可以有任何名称，但是它必须有一个名为</em> <code class="fe ki kj kk kl b"><em class="mr">then</em></code> <em class="mr">的方法才能成为一个</em> <code class="fe ki kj kk kl b"><em class="mr">thenable</em></code> <em class="mr">对象。</em></p><h2 id="faa8" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">“能”的对象和“承诺”的关系？</h2><p id="764e" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">简单来说<strong class="jm io">每个</strong> <code class="fe ki kj kk kl b"><strong class="jm io">promise</strong></code> <strong class="jm io">对象只是一个</strong> <code class="fe ki kj kk kl b"><strong class="jm io">thenable</strong></code> <strong class="jm io">对象</strong>，因为它有一个<code class="fe ki kj kk kl b">then</code>方法(用来访问一个<code class="fe ki kj kk kl b"><strong class="jm io">settled</strong> promise</code>的结果)。就是这样。</p><p id="9977" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是要记住，这种关系不是反过来，也就是说<strong class="jm io">每一个</strong> <code class="fe ki kj kk kl b"><strong class="jm io">thenable</strong></code> <strong class="jm io">对象都不是一个</strong> <code class="fe ki kj kk kl b"><strong class="jm io">promise</strong></code> <strong class="jm io">对象</strong>。</p><h2 id="34da" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">“能”、“答应”和“异步/等待”的关系</h2><p id="460f" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated"><code class="fe ki kj kk kl b">then</code>关键字只是一个约定，定义它是为了让生活变得更容易。</p><p id="d9c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，现在我们都知道要访问一个承诺的结果，我们应该调用它的<code class="fe ki kj kk kl b">then</code>方法。名字不是<code class="fe ki kj kk kl b">exec</code>、<code class="fe ki kj kk kl b">run</code>、<code class="fe ki kj kk kl b">get</code>、<code class="fe ki kj kk kl b">map</code>或其他任何引起混淆的东西。</p><p id="18ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种命名约定也帮助我们在JavaScript中拥有了<code class="fe ki kj kk kl b">async/await</code>语法。但是怎么做呢？</p><p id="8c2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看下面的代码，看看它的神奇之处:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d579" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mr">如果你不熟悉IIFE函数的话，可以查看一下这篇</em> <a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank"> <em class="mr">文章</em> </a> <em class="mr">。</em></p><p id="b6b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能已经在代码中使用了<code class="fe ki kj kk kl b">async/await</code>语法，并且知道如何使用它。</p><p id="1016" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是你也知道<code class="fe ki kj kk kl b">async/await</code>是如何工作的吗？</p><p id="49b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们不打算完全覆盖<code class="fe ki kj kk kl b">async/await</code>场景的背后。然而，如果你对此感到好奇(你应该感到好奇)，你可以看看这篇文章来了解它是如何工作的。</p><h2 id="cc45" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">“<code class="fe ki kj kk kl b">async/await”</code>如何工作的简要说明</h2><p id="f2de" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">你要知道，每当你在任何函数(对象)前放一个<code class="fe ki kj kk kl b">await</code>关键字，JavaScript只是试图调用那个对象的<code class="fe ki kj kk kl b">then</code>方法。</p><p id="3483" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也因为<code class="fe ki kj kk kl b">async/await</code>语法是由<code class="fe ki kj kk kl b"><a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">generator</a></code>函数实现的，而<code class="fe ki kj kk kl b">await</code>关键字正好被使用，而不是<code class="fe ki kj kk kl b">yield</code>关键字，所以<code class="fe ki kj kk kl b">async</code>函数需要在调用<code class="fe ki kj kk kl b">then</code>方法后恢复。为了处理这个操作，<code class="fe ki kj kk kl b">async</code>函数还向<code class="fe ki kj kk kl b">then</code>方法发送一个回调，作为包含恢复自身功能的参数。</p><p id="51a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道这听起来有点模糊，为了更好地理解这个概念，您应该查看这个示例代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2c88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以自己运行这段代码并查看结果。</p><p id="b3a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您查看输出，您可以看到几乎一切都按预期运行。但是我们仍然没有上一次<code class="fe ki kj kk kl b">console.log(‘end’)</code>的结果，操作在那一点上有点冻结。</p><p id="eb12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">冻结的原因是因为已经发送给<code class="fe ki kj kk kl b">then</code>方法的回调函数还没有被调用来恢复<code class="fe ki kj kk kl b">async</code>函数。</p><p id="c873" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决问题，我们应该只调用回调来继续操作。</p><p id="285b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，如果您将任何值作为参数发送给回调，您将通过<code class="fe ki kj kk kl b">await</code>关键字获得它(参见下面的代码):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6b2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在一切都完美了。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h2 id="f1c6" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">主要议题</h2><p id="f4ef" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">我猜到这里你已经知道我们在谈论什么了，你可能会发现<code class="fe ki kj kk kl b">mongoose</code>、<code class="fe ki kj kk kl b">knex</code>和其他一些库是如何通过调整代码来工作的。</p><p id="df81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提醒一下，这些库是可以链接的，无论何时你在它们后面放一个<code class="fe ki kj kk kl b">await</code>关键字或者在它们的链接中调用<code class="fe ki kj kk kl b">then</code>方法，它们就像一个<code class="fe ki kj kk kl b">promise</code>对象一样工作。</p><p id="db4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下文中，我们打算通过一个简单的例子来演示一个可链接的对象，这个对象可以通过<code class="fe ki kj kk kl b">await</code>关键字和/或<code class="fe ki kj kk kl b">then</code>方法来运行。</p><p id="c90a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们期望从这个愚蠢的例子中实现的功能是一些简单的数学方法(即<code class="fe ki kj kk kl b">add</code>、<code class="fe ki kj kk kl b">sub</code>、<code class="fe ki kj kk kl b">mul</code>、<code class="fe ki kj kk kl b">div</code>)，每当我们使用<code class="fe ki kj kk kl b">await</code>关键字时，它将运行主异步操作并返回相应的结果(可以是<code class="fe ki kj kk kl b">fulfilled</code>或<code class="fe ki kj kk kl b">rejection</code>)。</p><p id="f03b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果最终值的余数除以2大于零或不等于零(<code class="fe ki kj kk kl b"><em class="mr">n % 2 !== 0</em></code>)，则完成主异步操作，否则将被拒绝。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d05f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了一个异步函数，让我们实现另一个可以链接的简单函数。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><blockquote class="ms mt mu"><p id="6347" class="jk jl mr jm b jn jo jp jq jr js jt ju mv jw jx jy mw ka kb kc mx ke kf kg kh ig bi translated">注意:我只是拒绝在这里使用<code class="fe ki kj kk kl b">this</code>关键字，以避免一些人对它的混淆。</p></blockquote><p id="d9bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在该功能(<code class="fe ki kj kk kl b">mathOp</code>)可以这样使用:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ff73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是时候抓住要点，给这个可链接的对象添加神奇的<code class="fe ki kj kk kl b">then</code>方法，并在其中运行<code class="fe ki kj kk kl b">asyncFunction</code>。然后返回它的结果(这是一个<code class="fe ki kj kk kl b">promise</code>对象)。</p><p id="1cf8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mr">提醒:不要忘记回调函数将由</em> <code class="fe ki kj kk kl b"><em class="mr">await</em></code> <em class="mr">关键字自动发送。</em></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="bb9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是<code class="fe ki kj kk kl b">then</code>方法的全部实现。很简单，不是吗？</p><p id="20b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们把它放在<code class="fe ki kj kk kl b">op</code>对象内部:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="dad7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您可以运行下面的代码来查看结果:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0ae1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，听起来它工作得很完美，但是让我提醒你，我们没有处理由<code class="fe ki kj kk kl b">asyncFunction</code>的<code class="fe ki kj kk kl b">rejection</code>状态引起的错误。</p><p id="a4d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，为了处理错误，除了<code class="fe ki kj kk kl b">then</code>方法之外，我们还需要一个<code class="fe ki kj kk kl b">catch</code>方法。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1cd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将此方法放在<code class="fe ki kj kk kl b">op</code>对象内<code class="fe ki kj kk kl b">then</code>方法的旁边。</p><p id="c395" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于<code class="fe ki kj kk kl b">catch</code>方法没有什么特别的，我们只是添加了它，我们可以自己在链接方法上使用它——它的工作方式类似于链接上的<code class="fe ki kj kk kl b">then</code>方法，并且还向返回的<code class="fe ki kj kk kl b">promise</code>对象上的<code class="fe ki kj kk kl b">catch</code>方法发送回调。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4283" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在处理错误的下一步中，我们需要调整我们的<code class="fe ki kj kk kl b">then</code>方法。</p><p id="de27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想知道为什么我们需要改变<code class="fe ki kj kk kl b">then</code>方法来处理错误，以及它们之间的关系，让我告诉你<code class="fe ki kj kk kl b">async/await</code>的另一个秘密。</p><p id="823e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我必须承认，我已经对你撒了谎，关于那个<code class="fe ki kj kk kl b">await</code>关键字，我说它只是在调用<code class="fe ki kj kk kl b">then</code>方法时发送一个回调，我对那个家伙感到抱歉，因为它发送了两个回调。</p><p id="a108" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为提醒，我们应该提到<code class="fe ki kj kk kl b">promise</code>对象上的<code class="fe ki kj kk kl b">then</code>方法接受两个回调，但是第二个是任意的，用作捕获错误的回调——就像<code class="fe ki kj kk kl b">catch</code>方法一样。</p><p id="e5b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mr">如果你很好奇</em> <code class="fe ki kj kk kl b"><em class="mr">promise</em></code> <em class="mr">是怎么工作的，你应该去看看这本</em> <a class="ae ku" href="https://github.com/Babak-Gholamzadeh/Understanding-the-Core-Ideas-of-Promise-by-Implementing-it-in-JavaScript" rel="noopener ugc nofollow" target="_blank"> <em class="mr">书</em> </a> <em class="mr">。</em></p><p id="f747" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您像下面的代码一样更改<code class="fe ki kj kk kl b">then</code>方法体，您将看到与下面相同的输出:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="efee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！现在我们也可以在<code class="fe ki kj kk kl b">try/catch</code>块中使用带有<code class="fe ki kj kk kl b">await</code>关键字的<code class="fe ki kj kk kl b">mathOp</code>函数来处理错误。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8605" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经完成了错误处理和愚蠢示例的全部功能。</p><p id="ef9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们还可以做一些有趣的事情，让代码更简洁。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="792a" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">包扎</h2><p id="f098" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">我希望这篇文章对你有用。</p><p id="9b56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果有任何不清楚或模棱两可的部分，请随时在评论区提出您的问题，或者您可以直接给我发消息。</p></div></div>    
</body>
</html>