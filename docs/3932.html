<html>
<head>
<title>JavaScript — Getting Started with the Map and Set Typed Collections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript —开始使用地图和设置类型化集合</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-getting-started-with-the-map-and-set-typed-collections-2ba173b0ce9f?source=collection_archive---------17-----------------------#2021-08-06">https://javascript.plainenglish.io/javascript-getting-started-with-the-map-and-set-typed-collections-2ba173b0ce9f?source=collection_archive---------17-----------------------#2021-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2fa8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript有许多不同的方法来分组和收集数据，包括数组和对象。还有另外两种组织数据集合的主要方法—地图和集合。尽管数组和对象提供了许多有用的特性，但它们也有一些缺点。例如，对象是值的关键集合，但不允许值的简单迭代或找到集合的大小。<code class="fe ki kj kk kl b">Map</code>和<code class="fe ki kj kk kl b">Set</code>集合很有用，在某些情况下比数组或对象更有优势。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/c235db92a19a1ad4c9d4a8ae6b91fa22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6eDVQAamUSZzxGSB_PpCA.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">JavaScript — Getting Started with the Map and Set Typed Collections</figcaption></figure><h1 id="7f99" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">地图</h1><p id="aaee" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> Map </a>对象提供了一种保存键值对集合的方法。地图保持数据添加到地图对象的顺序，当<code class="fe ki kj kk kl b">Map</code>迭代时，将按顺序检索数据。</p><h2 id="ce5d" class="mg ld in bd le mh mi dn li mj mk dp lm jv ml mm lq jz mn mo lu kd mp mq ly mr bi translated">地图对象的特征</h2><p id="41eb" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">可以通过调用<code class="fe ki kj kk kl b">Map()</code>构造函数来创建地图。可以在没有参数或可选的可迭代值的情况下调用构造函数。</p><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="b904" class="mg ld in kl b gy mw mx l my mz">let employees = new Map();<br/>let managers = new Map([<br/>  ['bob', 23],<br/>  ['kal', 36],<br/>]);</span></pre><p id="09ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Map对象有一个属性和几个使用地图的有用方法。</p><ul class=""><li id="9482" class="na nb in jm b jn jo jr js jv nc jz nd kd ne kh nf ng nh ni bi translated"><strong class="jm io"> size </strong> —是一个属性，返回Map对象拥有的键-值对的总数。</li><li id="c0ca" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> set(key，value) </strong> —是一种将新的键值对追加到映射中的方法。</li><li id="708b" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> get(key) </strong> —是一种通过键从地图中检索值的方法。</li><li id="8ef3" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> has(key) </strong> —是一种基于键值是否包含在地图对象中来返回布尔值的方法。</li><li id="02a3" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> delete(key) </strong> —这是一种基于键从地图对象中删除键值对的方法，并根据键值对是否被删除返回一个布尔值。</li><li id="0549" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> clear() </strong> —从映射中删除所有键值对。</li></ul><h2 id="fdef" class="mg ld in bd le mh mi dn li mj mk dp lm jv ml mm lq jz mn mo lu kd mp mq ly mr bi translated">使用地图对象</h2><p id="cb64" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">使用地图的一个主要好处是它们提供的灵活性，这可以通过一些例子来说明。</p><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="24cf" class="mg ld in kl b gy mw mx l my mz">let employee = new Map();<br/>employee.set('name', 'bob');<br/>employee.set('age', 32);<br/>employee.set('title', 'manager');<br/>employee.set('skills', ['javascript', 'C#', 'Ruby']);</span><span id="0860" class="mg ld in kl b gy no mx l my mz">employee.size; // 4<br/>employee.get('name'); // 'bob'</span><span id="a602" class="mg ld in kl b gy no mx l my mz">employee.has('title'); // true</span><span id="2653" class="mg ld in kl b gy no mx l my mz">employee.set('name', 'melvin');<br/>employee.get('name'); // 'melvin'</span><span id="de4f" class="mg ld in kl b gy no mx l my mz">employee.delete('age'); // true<br/>employee.size; // 3</span><span id="d166" class="mg ld in kl b gy no mx l my mz">employee.clear();<br/>employee.size; // 0</span></pre><p id="ba7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Map</code>对象的一个关键特性是能够使用任何数据类型作为键。这与一个<code class="fe ki kj kk kl b">Object</code>不同，它只允许字符串或符号用于键。</p><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="8e49" class="mg ld in kl b gy mw mx l my mz">let person = new Map();<br/>person.set('name', 'kal');<br/>person.set(10, 'rating level');</span><span id="144c" class="mg ld in kl b gy no mx l my mz">let age = Symbol('age of person');<br/>person.set(age, 36);</span><span id="04e7" class="mg ld in kl b gy no mx l my mz">let education = ['high school', 'college', 'coding bootcamp'];<br/>person.set(education, 'completed');</span><span id="3afa" class="mg ld in kl b gy no mx l my mz">let contacts = {<br/>  supervisor: 'jim',<br/>  friend: 'hal',<br/>};<br/>person.set(contacts, 'work and home');</span></pre><h2 id="26f8" class="mg ld in bd le mh mi dn li mj mk dp lm jv ml mm lq jz mn mo lu kd mp mq ly mr bi translated">方法来迭代地图对象</h2><p id="3b39" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Map</code>对象也有几种不同的迭代方式。它可以通过Map对象方法或使用<code class="fe ki kj kk kl b">for..of</code>或<code class="fe ki kj kk kl b">forEach</code>循环迭代它的键和/或值。</p><ul class=""><li id="e73e" class="na nb in jm b jn jo jr js jv nc jz nd kd ne kh nf ng nh ni bi translated"><strong class="jm io"> keys() </strong> —返回一个迭代器对象，其中包含每个项目的键。</li><li id="4ae5" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> values() </strong> —返回包含每个项目值的迭代器对象。</li><li id="81c9" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> entries() </strong> —返回一个迭代器对象，该对象包含<code class="fe ki kj kk kl b">Map</code>对象的每个元素的[key，value]数组。</li></ul><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="f75e" class="mg ld in kl b gy mw mx l my mz">let employee = new Map();<br/>employee.set('name', 'bob');<br/>employee.set('age', 32);<br/>employee.set('title', 'manager');<br/>employee.set('certified', true);</span><span id="11fa" class="mg ld in kl b gy no mx l my mz">employee.keys(); // [Map Iterator] { 'name', 'age', 'title', 'certified' }<br/>employee.values(); // [Map Iterator] { 'bob', 32, 'manager', true }<br/>employee.entries(); // [Map Entries] { [ 'name', 'bob' ], [ 'age', 32 ], [ 'title', 'manager' ], [ 'certified', true ] }</span><span id="122d" class="mg ld in kl b gy no mx l my mz">for (const [key, value] of employee) {<br/>  console.log(`employee ${key} is ${value}`);<br/>}</span><span id="38f7" class="mg ld in kl b gy no mx l my mz">// employee name is bob<br/>// employee age is 32<br/>// employee title is manager<br/>// employee certified is true</span></pre><p id="f57f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">地图对象也可以用<code class="fe ki kj kk kl b">forEach()</code>方法迭代。</p><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="303a" class="mg ld in kl b gy mw mx l my mz">employee.forEach((key, value) =&gt; {<br/>  console.log(`employee ${key} is ${value}`);<br/>});</span></pre><h1 id="9600" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">一组</h1><p id="c2da" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"> Set </a>对象是值的集合，可以是任何类型的原始值。<strong class="jm io">集合中的每个值都是唯一的</strong>，这意味着它在<code class="fe ki kj kk kl b">Set</code>对象中只能出现一次。</p><h2 id="b57d" class="mg ld in bd le mh mi dn li mj mk dp lm jv ml mm lq jz mn mo lu kd mp mq ly mr bi translated">设置对象的特征</h2><p id="600e" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">可以通过调用<code class="fe ki kj kk kl b">Set()</code>构造函数来创建集合。可以在没有参数或可选的值的可迭代对象的情况下调用构造函数。</p><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="a80e" class="mg ld in kl b gy mw mx l my mz">let employees = new Set();<br/>let managers = new Set(['bob', 'kal', 'melvin']);</span></pre><p id="9871" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Set对象有一个属性和几个有用的方法来处理地图。</p><ul class=""><li id="2c0d" class="na nb in jm b jn jo jr js jv nc jz nd kd ne kh nf ng nh ni bi translated"><strong class="jm io"> size </strong> —是一个属性，返回由Set对象保存的值的总数。</li><li id="3d62" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> add(value) </strong> —是一种向集合追加新值的方法。</li><li id="35a5" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> has(value) </strong> —是一种基于值是否包含在设置对象中来返回布尔值的方法。</li><li id="1ecf" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> delete(value) </strong> —从设置对象中删除值的方法，并根据值是否被删除返回一个布尔值。</li><li id="5367" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> clear() </strong> —从集合中删除所有值。</li></ul><h2 id="65a3" class="mg ld in bd le mh mi dn li mj mk dp lm jv ml mm lq jz mn mo lu kd mp mq ly mr bi translated">使用设定的对象</h2><p id="8562" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">使用集合的一个主要好处是它们保持了值添加到集合中的顺序。它们也是可重复的。</p><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="f339" class="mg ld in kl b gy mw mx l my mz">let employees = new Set();<br/>employees.add('melvin');<br/>employees.add('bob');<br/>employees.add('lou');<br/>employees.add('gill');</span><span id="3806" class="mg ld in kl b gy no mx l my mz">employees.size; // 4<br/>employees.has('jim'); // false<br/>employees.has('lou'); // true</span><span id="6062" class="mg ld in kl b gy no mx l my mz">employees.delete('bob'); // true<br/>employees.size; // 3</span><span id="fd91" class="mg ld in kl b gy no mx l my mz">employees.clear();<br/>employees.size; // 0</span></pre><h2 id="3fce" class="mg ld in bd le mh mi dn li mj mk dp lm jv ml mm lq jz mn mo lu kd mp mq ly mr bi translated">方法来迭代集合对象</h2><p id="ab0b" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Set</code>对象也有几种不同的方法来迭代Set对象，与Map不同，它只有值。它可以通过Set object方法或者使用<code class="fe ki kj kk kl b">forEach</code>循环来迭代。</p><ul class=""><li id="588d" class="na nb in jm b jn jo jr js jv nc jz nd kd ne kh nf ng nh ni bi translated"><strong class="jm io"> values() </strong> —返回包含每个项目值的迭代器对象。</li><li id="a0a5" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> keys() </strong> —与<code class="fe ki kj kk kl b">Set</code>对象的<code class="fe ki kj kk kl b">values()</code>方法功能相同</li><li id="a6f7" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><strong class="jm io"> entries() </strong> —返回一个迭代器对象，该对象包含<code class="fe ki kj kk kl b">Set</code>对象的每个元素的数组[value，value]。</li></ul><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="9c30" class="mg ld in kl b gy mw mx l my mz">let holidays = new Set();<br/>holidays.add('Mothers Day');<br/>holidays.add('Flag Day');<br/>holidays.add('Memorial Day');<br/>holidays.add('Halloween');</span><span id="dd52" class="mg ld in kl b gy no mx l my mz">holidays.values(); // [Set Iterator] { 'Mothers Day', 'Flag Day', 'Memorial Day', 'Halloween' }<br/>holidays.keys(); // [Set Iterator] { 'Mothers Day', 'Flag Day', 'Memorial Day', 'Halloween' }<br/>holidays.entries(); // [Set Entries] { [ 'Mothers Day', 'Mothers Day' ], [ 'Flag Day', 'Flag Day' ], [ 'Memorial Day', 'Memorial Day' ], [ 'Halloween', 'Halloween' ] }</span></pre><p id="d51d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Set对象也可以用<code class="fe ki kj kk kl b">forEach()</code>方法迭代。</p><pre class="kn ko kp kq gt ms kl mt mu aw mv bi"><span id="8424" class="mg ld in kl b gy mw mx l my mz">holidays.forEach((value) =&gt; {<br/>  console.log(`holiday ${value}`);<br/>});</span></pre><h2 id="07bd" class="mg ld in bd le mh mi dn li mj mk dp lm jv ml mm lq jz mn mo lu kd mp mq ly mr bi translated">结论</h2><p id="1d64" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Map</code>和<code class="fe ki kj kk kl b">Set</code>对象为数组和对象提供了相似但有用的替代品，用于存储数据集合。与数组和对象相比，映射和集合提供了一些明显的优势——最明显的是，当条目被添加到集合中时，它们保持条目的顺序，这与集合不同。与数组不同，映射允许任何类型数据的键值对集合，提供了很大的灵活性。在搜索集合条目时，它们还提供了一些性能优势。</p><p id="af89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="np">更多内容尽在</em><a class="ae mf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="np">plain English . io</em></strong></a></p></div></div>    
</body>
</html>