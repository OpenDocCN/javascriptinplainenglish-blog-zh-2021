<html>
<head>
<title>How to Mock Only One Function from a Module in Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Jest中只模仿模块中的一个函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-mock-only-one-function-from-a-module-in-jest-daf94265c0cc?source=collection_archive---------22-----------------------#2021-04-18">https://javascript.plainenglish.io/how-to-mock-only-one-function-from-a-module-in-jest-daf94265c0cc?source=collection_archive---------22-----------------------#2021-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/22ac58a3e9cf36219a41b6c93e574d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mq5S8vp0ZmlQi-ei"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@oskaryil?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Oskar Yildiz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="735b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模拟代码的依赖性是软件测试的基本方面之一，它允许开发人员获得对数据流和代码行为的控制。</p><p id="f20b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个JavaScript测试框架，Jest有一个广泛的API集合，这将使我们的生活更容易，并有助于模仿依赖。然而，有时选项太多，很难知道所有选项，更不用说确定最佳选项。</p><p id="7d58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我有一个类似的案例，我从一个模块<code class="fe lb lc ld le b">@module/api</code>导入了几个不同的导出，并在我的代码中使用它。然而，在我的测试中，我想模拟一个特定的导入函数<code class="fe lb lc ld le b">functionToMock</code>,并让所有其他的导入保持不变。</p><p id="d68b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个特定的函数在后台执行一些在测试环境中无法模拟的逻辑，并且对我的测试的完整性没有意义。所以，我想嘲笑它，但重要的是，所有其他的进口仍然会像最终用户将如何体验它。</p><p id="3d4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在做了一些研究并尝试了不同的方法之后，我对不同的可用模仿方法、它们之间的差异有了更多的了解，并且总体上对Jest中的模仿依赖有了更好的理解。在这篇文章中，我将分享我在Jest中如何模拟一个导入模块的特定函数的经验。</p><h1 id="9e68" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">人工模拟</h1><p id="ddd8" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在整个过程之后，我发现的主要问题是，试图模仿一个导入模块中的某个特定函数与模仿任何其他模块中的任何函数在本质上是一样的。因此，从最基本的方法开始是有意义的，即手动模拟函数。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0f73" class="mq lg iq le b gy mr ms l mt mu">import * as moduleApi from '@module/api';</span><span id="07bf" class="mq lg iq le b gy mv ms l mt mu">// Somewhere in your test case or test suite<br/>moduleApi.functionToMock = jest.fn().mockReturnValue({ someObjectProperty: 42 });</span></pre><p id="17ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里所做的是首先从<code class="fe lb lc ld le b">@module/api</code>导入所有的导入，将其捆绑成一个对象，并存储到名为<code class="fe lb lc ld le b">moduleApi</code>的变量中。然后，我们用一个Jest模仿函数覆盖了我们想要模仿的函数<code class="fe lb lc ld le b">functionToMock</code>。这意味着在我们的测试环境中，从我们的代码对<code class="fe lb lc ld le b">functionToMock</code>的任何调用都不会触发实际的函数，而是这个jest mock函数。</p><p id="8b9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这之后，我们可以使用Jest实用函数来根据测试或测试套件的需求改变这个函数的行为。在上面的例子中，我们使用了<code class="fe lb lc ld le b">mockReturnValue</code>让mock函数总是返回某个值，在本例中，这个值是一个具有某个键和值的对象。</p><p id="bc6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是最低级的方法，应该适用于大多数用例。其他方法基本上使用Jest实用函数，这些函数基本上是这种基本方法的某种形式的抽象。然而，手动模拟相当乏味，在处理更复杂的情况时，需要手动记账。因此，在尝试了Jest的内置实用函数后，这种方法可能是最好的退路。</p><p id="1ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在某些情况下，这种方法也不起作用。尝试这种方法时，我遇到最多的错误是<code class="fe lb lc ld le b">TypeError: Cannot set property functionToMock of #&lt;Object&gt; which has only a getter</code>。在这种情况下，您可以尝试本文中的其他方法之一。</p><h1 id="a4ba" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用<code class="fe lb lc ld le b">jest.spyOn</code>刺探功能</h1><p id="7153" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">从导入的模块中模拟特定函数的另一种方法是使用<code class="fe lb lc ld le b">jest.spyOn</code>函数。这个函数的API似乎正是我们的用例所需要的，因为它接受一个完整的模块和应该被监视的特定输出。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3e0c" class="mq lg iq le b gy mr ms l mt mu">import * as moduleApi from '@module/api';</span><span id="849c" class="mq lg iq le b gy mv ms l mt mu">// Somewhere in your test case or test suite<br/>jest.spyOn(moduleApi, 'functionToMock').mockReturnValue({ someObjectProperty: 42 });</span></pre><p id="eadb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就用法而言，这基本上与上一节所述的手动模拟相同。但是这是稍微干净的语法，允许更容易地清理模拟，并且使得对函数执行断言更容易，因为<code class="fe lb lc ld le b">jest.spyOn</code>将返回模拟的函数。但是就功能而言，在这个用例中，使用这段代码监视函数和手动嘲笑它没有区别。</p><p id="6ade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，从技术角度来看，这有很大的不同，因为<code class="fe lb lc ld le b">jest.spyOn(moduleApi, 'functionToMock')</code>仍然会自己运行实际的<code class="fe lb lc ld le b">functionToMock</code>代码，而不是嘲笑它。从模块中窥探一个函数只会跟踪它的调用。如果你还想模拟底层代码，你必须用普通的模拟实用函数如<code class="fe lb lc ld le b">mockReturnValue</code>或<code class="fe lb lc ld le b">mockImplementation</code>来链接它。</p><p id="8d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种方法，您有可能会遇到<code class="fe lb lc ld le b">TypeError: Cannot redefine property: functionToMock at Function.defineProperty (&lt;anonymous&gt;)</code>。这类似于我们尝试手动模拟时遇到的错误。尽管如此，我还是建议您首先尝试进行手动模拟来解决这个问题，如果您还没有这样做的话，因为开销没有那么大。但是，如果手动嘲笑和监视功能都不起作用，你可以参考下一个也是最后一个方法。</p><h1 id="2462" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用<code class="fe lb lc ld le b">jest.requireActual</code>模拟整个模块并恢复不必要的模拟</h1><p id="ef6f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在大多数情况下，其他方法之一应该可以满足您的用例。但是在极少数情况下，您会遇到错误，无法重新定义单个导出的函数。这正是我所面临的，我使用的解决方案如下。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ed6d" class="mq lg iq le b gy mr ms l mt mu">import { functionToMock } from "@module/api"; // Step 3.</span><span id="bacb" class="mq lg iq le b gy mv ms l mt mu">// Step 1.<br/>jest.mock("@module/api", () =&gt; {<br/>    const original = jest.requireActual("@module/api"); // Step 2.<br/>    return {<br/>        ...original,<br/>        functionToMock: jest.fn()<br/>    };<br/>});</span><span id="1228" class="mq lg iq le b gy mv ms l mt mu">// Step 4. Inside of your test suite:<br/>functionToMock.mockImplementation(() =&gt; ({ mockedValue: 2 }));</span></pre><p id="bf26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里发生了很多事情，让我们来分析一下。</p><p id="9af9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在步骤1中，我们使用<code class="fe lb lc ld le b">jest.mock("@module/api", ...)</code>来模拟整个模块。这意味着<em class="mw">模块的每个</em>导入在测试环境中都将是一个模拟函数。这显然不是我们想要的，因为我们只想模拟<code class="fe lb lc ld le b">functionToMock</code>导出。我们可以在<code class="fe lb lc ld le b">jest.mock</code>调用的第二个参数中解决这个问题，它接受一个应该返回一个对象的回调。当模块在我们的测试环境中以任何方式导入时，这个对象被返回，而不是实际的模块。</p><p id="2383" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在步骤2中，在第二个参数回调中，我们使用<code class="fe lb lc ld le b">jest.requireActual("@module/api")</code>来捕获原始代码并从模块中导入，并将它存储在一个变量中。然后，我们通过做两件事来创建应该替换模块导入的对象:将所有原始导入放入其中，并用jest模仿函数覆盖我们想要模仿的<code class="fe lb lc ld le b">functionToMock</code>。</p><p id="6034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，要使用模拟函数，我们必须从模块导入函数，步骤3。最后，在测试套件中的某个地方，步骤4，您可以使用该导入来做各种事情，比如定制模拟实现，如上面的示例代码所示，或者对其执行断言。</p><p id="e980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所做的基本上是模拟整个模块，创建模块实际导入的快照，使用该快照作为模拟版本，然后通过在模拟模块中覆盖它来调整我们测试环境中喜欢的任何导入。在这种情况下，我们只想模仿<code class="fe lb lc ld le b">functionToMock</code>函数，所以我们只需用jest模仿函数覆盖它。</p><p id="e712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这种方法“抛弃一切，从头开始”的性质，当试图模仿Jest模块中的某个特定函数时，这是最好的解决方案。</p><p id="d816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这种方法在所有情况下都适用，但对于我们试图实现的目标来说，这是一种矫枉过正的解决方案，可能会给其他开发人员带来一些困惑。如果可能，尝试使用更复杂的方法来监视出口，甚至手动模仿出口。但是如果其他方法都失败了，或者其他两种方法都行不通，这个方法可以解决你的问题。</p><p id="ef53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mw">plain English . io</em></a></p></div></div>    
</body>
</html>