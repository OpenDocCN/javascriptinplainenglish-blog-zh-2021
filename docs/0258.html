<html>
<head>
<title>Snail Array Challenge Solution JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蜗牛数组挑战解决方案JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/snail-array-challenge-solution-javascript-336bbc35e36c?source=collection_archive---------16-----------------------#2021-01-14">https://javascript.plainenglish.io/snail-array-challenge-solution-javascript-336bbc35e36c?source=collection_archive---------16-----------------------#2021-01-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/613b108460dce01fd441da0f055c99ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJBoM8Jr1vY4_RkLJLDc4g.png"/></div></div></figure><p id="21a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天我们向《代码大战》借一个挑战！</p><p id="b75d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">免责声明:</strong>这不是我的挑战，原挑战是有关联的。还有，解决这个问题的方法有很多。这些是我写的或者我觉得聪明的一些答案，解释了它们为什么/如何工作</p><p id="2df3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> TLDR: </strong>在帖子底部解释最佳解决方案，在每个部分底部解释实际解决方案</p><h1 id="e263" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">问题是</h1><p id="3b61" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">创建一个接受和数组的函数。给定一个<code class="fe lx ly lz ma b">n x n</code>数组，返回从最外层元素到中间元素排列的数组元素，顺时针方向移动。</p><p id="7792" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e8db" class="mj kv in ma b gy mk ml l mm mn">snail( [[1,2,3], [4,5,6],[7,8,9]]) // [1,2,3,6,9,8,7,4,5] <br/>        snail([[1,2,3], [8,9,4], [7,6,5]]) // [1,2,3,4,5,6,7,8,9]<br/>        snail([[1,2,3,1], [4,5,6,4], [7,8,9,7], [7,8,9,7]]) // [1,2,3,1,4,7,7,9,8,7,7,4,5,6,8,9]</span></pre><p id="51f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下图可能会有所帮助。你也可以去<a class="ae kt" href="https://www.codewars.com/kata/521c2db8ddc89b9b7a0000c1/javascript" rel="noopener ugc nofollow" target="_blank"> Codewars </a>页面获取更多信息并测试你的解决方案</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/7224b6edccae4c11003970a4dfd82667.png" data-original-src="https://miro.medium.com/v2/5ff3e8f901412d670beec954"/></div></figure><h1 id="6b2e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">解决方法</h1><p id="87e6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">所以让我们分解一些可能的解决方案</p><ul class=""><li id="ed09" class="mp mq in jx b jy jz kc kd kg mr kk ms ko mt ks mu mv mw mx bi translated">可能性1</li><li id="83b2" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">为最终数组创建一个变量</li><li id="eb26" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">在父数组中循环——当数组中仍有项目时</li><li id="025e" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">获取第一行(数组中的第一个数组)</li><li id="8738" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">获取每个数组末尾的项目(右侧)</li><li id="8108" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">从末端到前面得到底部行(底部行反转)</li><li id="c080" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">获取数组开头的项目(左侧)</li><li id="3509" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">可能性2</li><li id="bce2" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">为最终数组创建一个变量</li><li id="5caf" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">在父数组中循环——当数组中仍有项目时</li><li id="e857" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">坐第一排</li><li id="cf86" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">获取每个数组中的最后一项</li><li id="c4e8" class="mp mq in jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">反转父数组和父数组中的每个数组</li></ul><h1 id="d570" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">解决方案1 —可读性和性能</h1><p id="a207" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，我们需要创建一个接受数组的函数</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="588f" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  //create a variable for the final array<br/>  //loop through the parent array - while array still has items in it<br/>    //get the first row (first array in the array)<br/>    //get the items at the end of each array (right side) <br/>    //get the bottom row from end to front (bottom row reversed)<br/>    //get the items at the beginning of the arrays (left side)<br/>}</span></pre><p id="67b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们必须创建变量来将所有内容放入其中，以获得最终的数组。我们将把它实例化为一个空数组，所有的内容都将被添加到这个数组中，如果没有任何内容要添加，我们将按预期在最后返回[]</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e7d3" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  let finalArray = []<br/>  //loop through the parent array - while array still has items in it<br/>    //get the first row (first array in the array)<br/>    //get the items at the end of each array (right side) <br/>    //get the bottom row from end to front (bottom row reversed)<br/>    //get the items at the beginning of the arrays (left side)<br/>}</span></pre><p id="bad7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要添加一个while循环。如果您不熟悉它们，请查看本MDN页面<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while" rel="noopener ugc nofollow" target="_blank">。我们需要在这里做一个while循环，因为我们不知道这个循环要经历多少次才能得到最终答案。我们将在数组有长度的情况下进行循环，因为我们将在循环时从每个数组中移除元素。最后数组里什么都没有了，所以长度为0，这就是我们结束循环执行的时候。</a></p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="bb01" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  let finalArray = []<br/>  while (arr.length){<br/>    //get the first row (first array in the array)<br/>    //get the items at the end of each array (right side) <br/>    //get the bottom row from end to front (bottom row reversed)<br/>    //get the items at the beginning of the arrays (left side)<br/>  }<br/>}</span></pre><p id="9dc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们想得到数组的数组中的第一个数组(第一行)如果你不知道如何<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" rel="noopener ugc nofollow" target="_blank">。移位()</a>，<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="noopener ugc nofollow" target="_blank">。push() </a>或<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread操作符</a>可以检查这个MDN页面，但基本上它接受数组中的第一项。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="7e30" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  let finalArray = []<br/>  while (arr.length){<br/>    finalArray.push(...arr.shift())<br/>    //get the items at the end of each array (right side) <br/>    //get the bottom row from end to front (bottom row reversed)<br/>    //get the items at the beginning of the arrays (left side)<br/>  }<br/>}</span></pre><p id="5ecf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你不熟悉循环或<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae kt" href="https://www.w3schools.com/js/js_loop_for.asp" rel="noopener ugc nofollow" target="_blank">，我们需要得到每个数组末尾(右侧)的所有项目。在继续之前，请查看每个网站上的链接。</a></p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="5a2e" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  let finalArray = []<br/>  while (arr.length){<br/>    finalArray.push(...array.shift())<br/>    for (var i = 0; i &lt; arr.length; i++) {<br/>        finalArray.push(arr[i].pop());<br/>    }<br/>    //get the bottom row from end to front (bottom row reversed)<br/>    //get the items at the beginning of the arrays (left side)<br/>  }<br/>}</span></pre><p id="b604" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要得到最后一个数组，如果你不熟悉的话，把它反转(底线)。reverse()在继续之前，检查此MDN页面的<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" rel="noopener ugc nofollow" target="_blank">。你会注意到我给了它一个空数组，以防没有最后一个数组，或者什么都没有。如果没有空数组，reverse就会出错，所以如果数组没有要弹出的内容，我们就给它一个空数组。</a></p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="d9a9" class="mj kv in ma b gy mk ml l mm mn">const snail = (array) =&gt;{<br/>  let finalArray = []<br/>  while(array.length){<br/>    finalArray.push(...array.shift())<br/>    for (var i = 0; i &lt; array.length; i++){<br/>      finalArray.push(array[i].pop())<br/>    }<br/>    finalArray.push(...(array.pop() || []).reverse())<br/>    //get the items at the beginning of the arrays (left side)<br/>  }<br/>}</span></pre><p id="86b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们剩下的就是获取左侧，所以我们需要从每个数组中获取所有的第一项。你会注意到I将是数组-1的长度，因为我们不想抓取第一个数组。我们将在下一个循环中获取它，所以我们只需要第一个数组之前的第一个数字。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="724b" class="mj kv in ma b gy mk ml l mm mn">const snail = (array) =&gt;{<br/>  let finalArray = []<br/>  while(array.length){<br/>    finalArray.push(...array.shift())<br/>    for (var i = 0; i &lt; array.length; i++){<br/>      finalArray.push(array[i].pop())<br/>    }<br/>    finalArray.push(...(array.pop() || []).reverse())<br/>    for (var i = array.length -1; i &gt;= 0; i--){<br/>      finalArray.push(array[i].shift())<br/>    }<br/>  }<br/>}</span></pre><p id="372d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后但同样重要的是，我们返回我们已经构建的最终数组</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="86db" class="mj kv in ma b gy mk ml l mm mn">const snail = (array) =&gt;{<br/>  let finalArray = []<br/>  while(array.length){<br/>    finalArray.push(...array.shift())<br/>    for (var i = 0; i &lt; array.length; i++){<br/>      finalArray.push(array[i].pop())<br/>    }<br/>    finalArray.push(...(array.pop() || []).reverse())<br/>    for (var i = array.length -1; i &gt;= 0; i--){<br/>      finalArray.push(array[i].shift())<br/>    }<br/>  }<br/>  return finalArray<br/>}</span></pre><h1 id="30dd" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">解决方案2——聪明且更少的代码行</h1><p id="75bb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这个解决方案是Codewars<a class="ae kt" href="https://www.codewars.com/kata/521c2db8ddc89b9b7a0000c1/javascript" rel="noopener ugc nofollow" target="_blank">上每个人都喜欢的解决方案</a>它的性能较差，我不喜欢它的可读性，但它的代码行较少，非常聪明，所以我想我会与你分享它。</p><p id="f510" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前几行与第一个解决方案相同</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="49bc" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  var finalArray = [];<br/>  while (arr.length) {<br/>    finalArray.push(...arr.shift());<br/>    //get the last item in each array<br/>    //reverse the parent array and each array in the parent array<br/>  }<br/>}</span></pre><p id="5a88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一部分与第一个解决方案非常相似，实际上您可以为此切换第一个for循环，但我们将使用<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">。map() </a>从每个数组(行)中获取最后一个数字，并将其推入finalArray</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e920" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  var finalArray = [];<br/>  while (arr.length) {<br/>    finalArray.push(...arr.shift());<br/>    arr.map(row =&gt; finalArray.push(row.pop()))<br/>    //reverse the parent array and each array in the parent array<br/>  }<br/>}</span></pre><p id="d0bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这才是真正有趣的地方。现在，我们将反转整个数组和父数组中的每一项，并执行所有相同的逻辑，而不是反转底部的行。这将翻转一切，所以我们得到的不是顶行，而是底行，不是右侧，而是左侧。然后循环继续</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="ec46" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  var finalArray = [];<br/>  while (arr.length) {<br/>    finalArray.push(...arr.shift());<br/>    arr.map(row =&gt; finalArray.push(row.pop()))<br/>    arr.reverse().map(row =&gt; row.reverse());<br/>  }<br/>}</span></pre><p id="96b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们返回finalArray和TA DA！你有你的解决方案</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="ff63" class="mj kv in ma b gy mk ml l mm mn">const snail = (arr) =&gt; {<br/>  var finalArray = [];<br/>  while (arr.length) {<br/>    finalArray.push(...arr.shift());<br/>    arr.map(row =&gt; finalArray.push(row.pop()))<br/>    arr.reverse().map(row =&gt; row.reverse());<br/>  }<br/>  return finalArray<br/>}</span></pre><p id="bc9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相当酷！</p><h1 id="bda9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="5760" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">第二种解决方案很聪明，行数更少，但是更难阅读，性能也不好。下面是使用上面例子的<a class="ae kt" href="https://jsbench.me/" rel="noopener ugc nofollow" target="_blank"> jsbench </a>性能结果，供感兴趣的人参考。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/62a58f02b4a6a5e12fd2ca43eb2575e9.png" data-original-src="https://miro.medium.com/v2/5ff4ab1c04a6e77005e4e104"/></div></figure><p id="e0ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你玩得开心！请在评论区留下你的解决方案。如果你有任何你希望看到完成的挑战，也请在下面的评论中留下，你可能会看到它出现！如果你想在每天早上通过电子邮件收到挑战，并在发布解决方案时收到通知，请订阅下面的<strong class="jx io"> </strong></p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e86c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">【hellodevworld.com】原载于<a class="ae kt" href="https://hellodevworld.com/365-days-of-coding/snail-array-challenge-solution-javascript" rel="noopener ugc nofollow" target="_blank"><em class="nf"/></a></p></div></div>    
</body>
</html>