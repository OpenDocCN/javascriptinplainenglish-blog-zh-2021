<html>
<head>
<title>Using the useCallback and useMemo Hooks in React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React组件中使用useCallback和useMemo挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-usecallback-and-usememo-hooks-in-react-components-3ec6dc2624de?source=collection_archive---------15-----------------------#2021-04-20">https://javascript.plainenglish.io/using-the-usecallback-and-usememo-hooks-in-react-components-3ec6dc2624de?source=collection_archive---------15-----------------------#2021-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3826150db4441c70f3a94d9bc14989d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NSVhXBNMu7sLtORp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@chiabra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paolo Chiabrando</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">useCallback</code>和<code class="fe lb lc ld le b">useMemo</code>挂钩是除了基本的<code class="fe lb lc ld le b">useState</code>和<code class="fe lb lc ld le b">useEffect</code>挂钩之外增加的两个更高级的挂钩。</p><p id="d233" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们在不同的方面都很有用。</p><p id="1f92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何在React组件中使用<code class="fe lb lc ld le b">useCallback</code>和<code class="fe lb lc ld le b">useMemo</code>钩子。</p><h1 id="439d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">useCallback</code></h1><p id="e491" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">useCallback</code>钩子用于记忆我们可能多次调用的回调。</p><p id="12de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lb lc ld le b">useCallback</code>钩子，我们可以缓存组件中的回调，这样它们就不会被创建多次，除非状态或属性发生改变。</p><p id="4f7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0df2" class="mq lg iq le b gy mr ms l mt mu">import React from "react";</span><span id="62d2" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const handleClick = () =&gt; {<br/>    console.log("Clicked");<br/>  };<br/>  return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;<br/>}</span></pre><p id="9ff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="cd6f" class="mq lg iq le b gy mr ms l mt mu">import React, { useCallback } from "react";</span><span id="0c82" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const handleClick = useCallback(() =&gt; console.log("Clicked"), []);</span><span id="a960" class="mq lg iq le b gy mv ms l mt mu">  return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;<br/>}</span></pre><p id="d8ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将回调函数传递给<code class="fe lb lc ld le b">useCallback</code>钩子，这样当我们点击按钮时，我们在第一个参数中传递的函数就会被调用。</p><p id="d9b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe lb lc ld le b">handleClick</code>函数只创建一次，而不是每次渲染。</p><p id="7ab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是一个数组，在这里我们可以传入在函数中可以观察到的项目。</p><p id="d9d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e864" class="mq lg iq le b gy mr ms l mt mu">import React, { useCallback, useState } from "react";</span><span id="41e0" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const [num, setNum] = useState(0);</span><span id="6f30" class="mq lg iq le b gy mv ms l mt mu">  const increment = useCallback(() =&gt; setNum((c) =&gt; c + 1), []);<br/>  const handleClick = useCallback(() =&gt; console.log(num), []);</span><span id="dc29" class="mq lg iq le b gy mv ms l mt mu">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="c78c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">handleClick</code>函数将总是记录0，因为该函数仅在安装组件时创建，因为我们在第二个参数中有一个空数组。</p><p id="97a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我们将<code class="fe lb lc ld le b">[num]</code>传递给<code class="fe lb lc ld le b">useCallback</code>:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ec4a" class="mq lg iq le b gy mr ms l mt mu">import React, { useCallback, useState } from "react";</span><span id="b715" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const [num, setNum] = useState(0);</span><span id="10b3" class="mq lg iq le b gy mv ms l mt mu">  const increment = useCallback(() =&gt; setNum((c) =&gt; c + 1), []);<br/>  const handleClick = useCallback(() =&gt; console.log(num), [num]);</span><span id="86e0" class="mq lg iq le b gy mv ms l mt mu">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="1b99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们单击Click Me时，控制台日志显示<code class="fe lb lc ld le b">num</code>的最新值。</p><p id="a8a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为自从我们在<code class="fe lb lc ld le b">useCallback</code>的第二个参数中传递<code class="fe lb lc ld le b">[num]</code>后，当<code class="fe lb lc ld le b">num</code>发生变化时，会重新创建<code class="fe lb lc ld le b">handleClick</code>函数。</p><h1 id="d623" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">useMemo</code></h1><p id="4d71" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当它所依赖的任何一个状态改变时，<code class="fe lb lc ld le b">useMemo</code>钩子让我们计算一个从现有状态得到的值。</p><p id="95cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="89d4" class="mq lg iq le b gy mr ms l mt mu">import React, { useCallback, useMemo, useState } from "react";</span><span id="9019" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const [num1, setNum1] = useState(0);<br/>  const [num2, setNum2] = useState(0);</span><span id="68d6" class="mq lg iq le b gy mv ms l mt mu">  const increment1 = useCallback(() =&gt; setNum1((c) =&gt; c + 1), []);<br/>  const increment2 = useCallback(() =&gt; setNum2((c) =&gt; c + 1), []);<br/>  const sum = useMemo(() =&gt; num1 + num2, [num1, num2]);</span><span id="eaa0" class="mq lg iq le b gy mv ms l mt mu">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={increment1}&gt;increment 1&lt;/button&gt;<br/>      &lt;button onClick={increment2}&gt;increment 2&lt;/button&gt;<br/>      &lt;p&gt;num1: {num1}&lt;/p&gt;<br/>      &lt;p&gt;num2: {num2}&lt;/p&gt;<br/>      &lt;p&gt;sum: {sum}&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="8861" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe lb lc ld le b">num1</code>和<code class="fe lb lc ld le b">num2</code>状态，当我们点击按钮时它们会改变。</p><p id="298c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们定义<code class="fe lb lc ld le b">sum</code>变量，它是从<code class="fe lb lc ld le b">useMemo</code>钩子赋值的。</p><p id="93f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入一个函数，返回加在一起的<code class="fe lb lc ld le b">num1</code>和<code class="fe lb lc ld le b">num2</code>。</p><p id="8f41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">useMemo</code>的第二个参数中，我们传入了我们正在观察的<code class="fe lb lc ld le b">num1</code>和<code class="fe lb lc ld le b">num2</code>。</p><p id="a9b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">意味着当<code class="fe lb lc ld le b">num1</code>或<code class="fe lb lc ld le b">num2</code>发生变化时，<code class="fe lb lc ld le b">useMemo</code>回调的返回值将被赋给<code class="fe lb lc ld le b">sum</code>。</p><p id="34e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们点击其中一个按钮时，<code class="fe lb lc ld le b">sum</code>就会发生变化。</p><h1 id="1a45" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="6889" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">useCallback</code>来缓存函数，只在状态或属性改变时重新创建它们。</p><p id="7b0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">useMemo</code>让我们创建从状态或属性值派生的变量，并缓存它们，直到任何相关值发生变化。</p><p id="3e0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>