<html>
<head>
<title>Most Important Feature Ever Put in a Programming Language!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程语言中最重要的特性！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/most-important-feature-ever-put-in-a-programming-language-5b139e1e170f?source=collection_archive---------21-----------------------#2021-04-09">https://javascript.plainenglish.io/most-important-feature-ever-put-in-a-programming-language-5b139e1e170f?source=collection_archive---------21-----------------------#2021-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="56a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript如何借鉴Lisp几十年前的思想</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2f0d31a66f1ff7f6cab3ca732e604197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikIEGhnStfS-uDFRW_1EuQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.twitter.com/tweetsbysoma" rel="noopener ugc nofollow" target="_blank">🖌</a></figcaption></figure><blockquote class="kw kx ky"><p id="be53" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">本文是这个系列的第一部分，在这里我们将探索闭包的起源、幕后工作、现实生活中的用法以及与闭包相关的面试问题。</p></blockquote><h1 id="a27e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">介绍</h1><p id="b264" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">几乎所有编程语言最基本的标准可能是在变量中存储<em class="lb">值的能力，</em>，以及以后访问或更改这些特性的能力。</p><p id="7520" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">如果没有这样的想法，一个程序可以完成某些任务，但是它们会受到很大的限制。在我们的程序中包含变量会引发最有趣的问题，比如这些变量在哪里？换句话说，它们储存在哪里？此外，更重要的是，我们的程序如何在需要时发现它们？</p><p id="b903" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">这些调查解决了对一套全面表征的规则的需求，这些规则用于在某个领域中保存变量，并在以后的时间里发现这些变量。我们称这种规则的排列:<strong class="lc ir">范围</strong></p><blockquote class="mw"><p id="e44e" class="mx my iq bd mz na nb nc nd ne nf lv dk translated">变量的作用域是程序源代码中定义变量的区域。变量的作用域是程序中变量可见和可用的部分。</p></blockquote><p id="1d64" class="pw-post-body-paragraph kz la iq lc b ld ng jr lf lg nh ju li mq ni ll lm ms nj lp lq mu nk lt lu lv ij bi translated">当一个变量被<a class="ae kv" href="https://icarus.cs.weber.edu/~dab/cs1410/textbook/1.Basics/definitions.html#definition" rel="noopener ugc nofollow" target="_blank">定义</a>在一个块内时，它的作用域被限制在那个块内；也就是说，在块内定义的变量在定义块外是不可见或不可访问的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/c4a1275e6e800351f3b59cb13015dcab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tK9t4-oan03VxpLZJO7rfw.png"/></div></div></figure><p id="38c9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">让我们利用JavaScript中的伪代码来理解上述语句的含义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/c7390777940b4b37ff87b801e036674b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdcGzTl7KFhpW6Zf_GsjFw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Generally wherever you see curly braces is a block scope</figcaption></figure><p id="6309" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">上面我们有两个积木，一个在另一个里面。第二个块可以看到它的变量和外部块的变量。第一个块只能看到自己的变量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/33e92f324a56a3d06c705be21f5b2ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNSWqjYyvBxKXU7FGUz2Sw.png"/></div></div></figure><p id="172e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">我假设现在您已经熟悉了块范围的概念。</p><p id="150c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">现在，让我们对函数做同样的事情。把<strong class="lc ir"> <em class="lb">函数想象成一个简单的块</em> </strong>加上一点点<strong class="lc ir"> <em class="lb">额外的机制</em> </strong>，这样你就可以在将来调用它，它就可以执行特定的任务了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/f5a6799675b2e882cd23f1d00deb5548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9NJm_MdIU0yF8G8fGX7QA.png"/></div></div></figure><p id="d456" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">我们得到了<strong class="lc ir"> <em class="lb">内部函数</em> </strong>，可以看到变量<code class="fe nm nn no np b">a</code>和<code class="fe nm nn no np b"> b</code>，以及<strong class="lc ir"> <em class="lb">外部函数</em> </strong>，只能看到变量<code class="fe nm nn no np b">a</code>。</p><blockquote class="mw"><p id="f422" class="mx my iq bd mz na nb nc nd ne nf lv dk translated">这意味着函数中定义的参数和变量在函数外部是不可见的，而函数中任何地方定义的变量在函数中任何地方都是可见的。</p></blockquote><p id="4826" class="pw-post-body-paragraph kz la iq lc b ld ng jr lf lg nh ju li mq ni ll lm ms nj lp lq mu nk lt lu lv ij bi translated">我们可以用集合来表示这种关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/c4421ac5809f7442cb8b063fd2b46b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqrNRQNSJyUfeqkGQ4BTbA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Yellow is the set of variables, the Inner function can see. Purple is the set of variables, the Outer function can see.</figcaption></figure><p id="5f05" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">我们做的和block一样，但是这里我们用内部函数的一组变量来描述这种关系，这些变量包围了外部函数的集合。这种<strong class="lc ir">外函数</strong>的变量从<strong class="lc ir">内函数</strong>的<em class="lb">包围</em>就是我们所说的<em class="lb">闭包</em>。</p><p id="1fb4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">由于作用域的工作方式，这似乎是一个简单的想法——就像上面那样添加嵌套函数，让内部函数<strong class="lc ir">的变量访问外部函数<strong class="lc ir">的变量。</strong></strong></p><p id="3783" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">看似显而易见的关系需要很长时间才能形成。</p><h1 id="c75b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">花了多长时间？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/a1286c23f371257951d7653041591cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIwo-Qge_HkjRNWtvxD9XQ.png"/></div></div></figure><p id="3679" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">你看到了吗？从Lisp到Scheme，我们花了将近20年才发现闭包，因为你需要一门有三样东西的语言。</p><ul class=""><li id="e252" class="nr ns iq lc b ld le lg lh mq nt ms nu mu nv lv nw nx ny nz bi translated">词法范围🔗</li><li id="83d9" class="nr ns iq lc b ld oa lg ob mq oc ms od mu oe lv nw nx ny nz bi translated">嵌套函数🖇</li><li id="d57d" class="nr ns iq lc b ld oa lg ob mq oc ms od mu oe lv nw nx ny nz bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" rel="noopener ugc nofollow" target="_blank">功能，为一级值</a>。🚀</li></ul><p id="dae6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">自20世纪60年代以来，我们有了编程语言，这些语言得到的函数将具有三个中的两个，但直到<strong class="lc ir"> <em class="lb"> Scheme </em> </strong>我们才得到一个同时具有三个的函数。</p><p id="4e81" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">Scheme是麻省理工学院的一项实验，旨在了解70岁出头的卡尔·休伊特的<a class="ae kv" href="https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf" rel="noopener ugc nofollow" target="_blank">演员模型</a>。实验<a class="ae kv" href="https://web.archive.org/web/20060615225746/http://www.brics.dk/~hosc/local/HOSC-11-4-pp399-404.pdf" rel="noopener ugc nofollow" target="_blank">不成功</a>，他们无法完全实现演员模型。然而，他们发现了一种新的编程方式，使用<strong class="lc ir">闭包编写代码。</strong></p><p id="ba61" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">这种方式scheme成为了第一种引入闭包的语言，但是scheme并不是第一种将这种思想带入主流的语言。你能猜出是哪种语言吗？</p><h2 id="af34" class="of lx iq bd ly og oh dn mc oi oj dp mg mq ok ol mi ms om on mk mu oo op mm oq bi translated">果然是<strong class="ak"> JavaScript </strong>！</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/242c4903e3ecde86cccfea4585c0fb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-QBkAdn0aEOfYfLiF481A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.twitter.com/tweetsbysoma" rel="noopener ugc nofollow" target="_blank">🖌</a></figcaption></figure><p id="721a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">其他语言如Ruby、Python和C#紧随其后。</p><p id="7897" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">闭包之所以花了这么长时间才出现是因为这个问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/aa5ddb3da2ba178ff4d10de8269d5ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBzS0tkz6wzlMwgCuBkBTQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Pseudocode in JavaScript</figcaption></figure><p id="3805" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">所以，我们得到了和以前一样的东西，我们得到了一个内部函数和一个外部函数。但是这一次，内部函数在外部函数执行之后仍然存在，因为外部函数正在返回内部函数。</p><p id="e6bc" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">因此，我们将调用外部函数，它将在堆栈上分配变量<code class="fe nm nn no np b">a</code>。它将返回函数<code class="fe nm nn no np b">Inner()</code>并退出。</p><p id="3c15" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">现在我们想要调用函数<code class="fe nm nn no np b">Inner()</code>，但是它想要访问变量<code class="fe nm nn no np b">a</code>，而<code class="fe nm nn no np b">a</code>已经不在堆栈上了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/004185c2cc885ad41b04513a14c8fa05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*T0fmqVaHGTFVQAmmFyF-DA.gif"/></div></div></figure><p id="e543" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">我们花了几十年才想出该怎么做！<br/> <em class="lb">原来解决办法是</em> <strong class="lc ir"> <em class="lb">相当琐碎的</em> </strong> <em class="lb">！</em></p><h1 id="2314" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">是什么？</strong></h1><p id="d4ec" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated"><strong class="lc ir">我们将在</strong> <a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/grokking-closure-in-javascript-7e8194924398?sk=0f6e01511d6400590608f10f0ea85017"> <strong class="lc ir">系列的下一篇文章</strong> </a> <strong class="lc ir">中看到，届时我们将</strong> <a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/grokking-closure-in-javascript-7e8194924398?sk=0f6e01511d6400590608f10f0ea85017"> <strong class="lc ir">探究闭包的概念</strong> </a> <strong class="lc ir">并学习JavaScript如何在内部实现闭包。</strong></p><h1 id="00a2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">本系列的下一篇文章再见。😊</h1><h2 id="2cfd" class="of lx iq bd ly og oh dn mc oi oj dp mg mq ok ol mi ms om on mk mu oo op mm oq bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/most-important-feature-ever-put-in-a-programming-language-5b139e1e170f?sk=baff3bd18de9be10a66bb27eb2d265d4"> 1。编程语言中最重要的特性</a></h2><h2 id="723c" class="of lx iq bd ly og oh dn mc oi oj dp mg mq ok ol mi ms om on mk mu oo op mm oq bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/grokking-closure-in-javascript-7e8194924398?sk=0f6e01511d6400590608f10f0ea85017"> 2。在JavaScript中寻找闭包</a></h2><h2 id="05b3" class="of lx iq bd ly og oh dn mc oi oj dp mg mq ok ol mi ms om on mk mu oo op mm oq bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/practical-usage-of-closures-in-javascript-b3203770ba2?sk=dc404a83106d791c943d16b6b389e26c"> 3。闭包的实际用法</a></h2><h2 id="d2dd" class="of lx iq bd ly og oh dn mc oi oj dp mg mq ok ol mi ms om on mk mu oo op mm oq bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/ultimate-interview-questions-on-javascript-closures-8dd12a210677?sk=4d15f7e3756b76a9e2886b97515975b1"> 4。终极JavaScript面试问题—结束</a></h2></div></div>    
</body>
</html>