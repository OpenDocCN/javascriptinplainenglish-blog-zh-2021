<html>
<head>
<title>Authentication in Node.js, with HTTP Cookies, JWT &amp; BCrypt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的身份验证，使用HTTP Cookies、JWT和BCrypt</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/auth-in-node-js-http-cookies-jwt-bcrypt-part-1-64b3c0159035?source=collection_archive---------2-----------------------#2021-01-17">https://javascript.plainenglish.io/auth-in-node-js-http-cookies-jwt-bcrypt-part-1-64b3c0159035?source=collection_archive---------2-----------------------#2021-01-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8e70" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第一部分</h2></div><blockquote class="kc kd ke"><p id="d18b" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">因此，您已经决定最终在您的节点应用程序中提出身份验证的话题。我发现在Node中实现Auth的方法有很多，那么从哪里开始呢？第一个选择是决定你是想让第三方服务为你处理它，还是你有足够的勇气自己完成并实现它！如果第二个选择适合你，那么你来对地方了。我将向您介绍许多方法中的一种，您可以使用JsonWebTokens、BCrypt和HTTP Cookies在节点项目中实现Auth。</p></blockquote><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/99795dcebee76a8da7935f81bb1394de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHCalZHXSVLYARTikN0QDw.png"/></div></div></figure><p id="2bc5" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">首先，为什么要使用JsonWebTokens、BCrypt和Cookies？</p><p id="c663" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">很好的问题，从什么是JWT综合症以及为什么使用它开始。引用他们的<a class="ae lr" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">文档</a>:<em class="kh">“JSON Web Token(JWT)是一个开放的标准(</em> <a class="ae lr" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> <em class="kh"> RFC 7519 </em> </a> <em class="kh">)，它定义了一种紧凑且独立的方式，以JSON对象的形式在各方之间安全地传输信息。”如果你正在创建一个节点应用程序，你很可能非常熟悉JSON。所以本质上是一个JWT，顾名思义，一个用于在各方之间传输数据的紧凑令牌，用JSON编写。在节点应用程序中使用jwt的实现也很容易。简单的:</em></p><pre class="ld le lf lg gt ls lt lu lv aw lw bi"><span id="6560" class="lx ly in lt b gy lz ma l mb mc">npm install --save jsonwebtoken</span></pre><p id="ac57" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">将包含它作为一个依赖项，因此我们可以在需要时通过应用程序调用该模块。</p><p id="8199" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">接下来我们有BCrypt，这是最容易解释的，它只是一个用于散列密码的中间件。当然还有很多其他的，但是BCrypt被广泛使用，易于安装，并且有很棒的<a class="ae lr" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank">文档</a>，这是你开始工作所需要的一切，所以让我们把它也包括到这个项目中:</p><pre class="ld le lf lg gt ls lt lu lv aw lw bi"><span id="593c" class="lx ly in lt b gy lz ma l mb mc">npm install --save bcryptjs</span></pre><p id="2399" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">最后，我们有我们的Cookies，如果你在过去的5到10年里一直在使用网络，你肯定听说过它。这是我们将在客户端存储JWT的地方，因此能够根据每个请求发送回服务器。当然，对于在哪里存储这些信息的问题，还有其他选择。本地存储？会话存储？饼干？如果您有兴趣了解更多关于所有不同客户端存储选项的利与弊，我将只<a class="ae lr" href="https://bitsofco.de/an-overview-of-client-side-storage/" rel="noopener ugc nofollow" target="_blank">链接这篇文章</a>，而不是讨论它们之间的所有细节。可以说，cookies是一种易于使用/实现的解决方案，可以存储我们用户的JWT，并且对于简单的身份验证来说足够安全。因此，在我们开始在代码中实现它们之前，最后安装一个包:</p><pre class="ld le lf lg gt ls lt lu lv aw lw bi"><span id="3997" class="lx ly in lt b gy lz ma l mb mc">npm install --save cookie-parser</span></pre><p id="77c9" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">在这次演练中，我们将使用Express为后端RESTful API创建auth。首先，我已经写出了遵循MVC架构所需的<em class="kh">用户</em>文件(除去视图，它是一个API，我们的响应将是JSON数据而不是HTML页面),并安装了我们所需的其他中间件。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi md"><img src="../Images/aab2349f92e19f492d8acbcda9aa7b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGCPhzjGW-9S1kRid-9OEw.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Initial User files</figcaption></figure><p id="82d7" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">完成所有这些初始设置后，我们可以开始在我们的应用程序中实现一些身份验证。首先，我们将从routes文件开始，因此指定一些端点，从创建用户开始。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/8aaa699e03763fee5c67677be2e62661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*9UjAeR7wCh2Idtu69W96fQ.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Setting up endpoint for User Signup route</figcaption></figure><p id="d24c" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">首先，我们将引入并要求我们的<em class="kh"> user_controller.js </em>。然后，我们将用一个简单的“/signup”来定义我们的第一个端点，它最终将是<code class="fe mj mk ml lt b">http://localhost:8000/signup</code></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/f7930da88931197f02d2fd42a3b1d344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*wXf0EGHLYHI4VXE_QQR7SA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">User Controller w/signup method using Bcrypt</figcaption></figure><p id="c981" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">完成这些后，我们将进入用户控制器文件，这是我们大部分授权代码所在的地方。从导出我们在路由文件中调用的注册方法开始。在这个演示中，我使用ES6 async/await关键字编写了这个方法，但是这也可以使用Promise链来完成。JWT &amp; Bcrypt的文件都解释了如果你使用承诺链代替。</p><p id="952d" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">我们首先使用hashSync(异步和阻塞的)散列来自req.body的传入密码，然后按照我们的mongoose模式中的定义创建/保存我们的新用户。</p><p id="e231" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">这里需要注意的是，我省略了任何验证或严重的错误处理，这是你肯定会有的。在本文中，我将只介绍“注册”的实现，但在第2和第3部分中，我将结束对传入的<code class="fe mj mk ml lt b">req</code>的验证，以检查电子邮件和密码的“唯一性”、“格式”等。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/98b8b28f77f45dd6bb9263de996a5213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*inux2trgADkvsS4je5xlIg.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">User Controller creating JWT</figcaption></figure><p id="7cea" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">接下来，我们使用jwt中间件创建令牌。的。<code class="fe mj mk ml lt b">sign()</code>方法需要三个参数。第一个是您希望实际的令牌是什么，在这种情况下，我只是将他们的电子邮件和mongoose创建的userId发送回客户端。</p><p id="e701" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">第二个参数是secretOrPrivateKey，它可以是一个字符串，也可以是一个对象，但最终将在它们的算法中用来编码和解码令牌。我们稍后解码令牌时会用到它。你当然可以指定你想使用的算法，对于我来说，这方面的信息只需查看他们的<a class="ae lr" href="https://www.npmjs.com/package/jsonwebtoken#usage" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="3560" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">最后，您可以向它传递选项或回调。我们选择的选项，虽然JWT给你许多定制，我只选择了一个过期，以帮助安全。他们所有的其他优化都列在他们的文档中，见上面的链接。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/942657db966a04c712e6f08743f18e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*QBbPmt9_5_3_CY-6GCiooQ.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">User Controller creating and sending cookie</figcaption></figure><p id="26a0" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">最后，我们创建我们的cookie。第一个争论是我们的cookie应该叫什么，我选择了一个经典的“令牌”。</p><p id="f0ca" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">第二个参数是payload，在本例中是我们新创建的令牌。</p><p id="8b05" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">第三个论点是我们的选择。就像JWT一样，你可以对你的cookie进行许多不同的优化，但是我只简单地将它设置为httpOnly: true。由于在客户端被设置为仅HTTP cookie，cookie本身不能在客户端被修改，这使它稍微更安全。</p><p id="b455" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">最后，我们将cookie和一个JSON对象一起发送回去，这个JSON对象只包含一条消息，但是您可以包含任何您想要的内容，通常是关于所创建的用户的更多细节。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="cea0" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">现在你知道了！您的后端节点API被设置为创建一个新用户并发回一个包含该用户信息的cookie，该cookie将随客户端的每个请求一起发送。</p><p id="f9d2" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">前端应用需要注意的一点是。在开发过程中，您很可能会在两个独立的端口上同时运行后端服务器和前端服务器。通过使您的cookies安全和httpOnly，它们必须从同一个域发送和接收。这意味着您最有可能需要使用一个代理，至少在开发期间，在您的前端设置为<code class="fe mj mk ml lt b">http://localhost:8000</code>，这是我们的节点应用程序当前正在监听的。如果您的前端应用程序是React应用程序，就像我的应用程序一样，只需将<code class="fe mj mk ml lt b">“proxy”: “http://localhost:8000"</code>添加到package.json文件中，然后通过删除整个url只留下相对端点来调整fetch()调用。例如<code class="fe mj mk ml lt b">fetch(‘/signup’).then(resp=&gt;resp.json()).then()</code>等。该代理将用于您的前端发送的所有HTTP请求。</p><p id="83ab" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">在我的下一篇博文中，我将介绍如何接收带有cookie的请求，解码它的令牌，从而验证用户是否允许使用后端中的其他端点和功能。我还将继续向我们后端API添加两个端点，允许我们的用户“登录”和“注销”。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="ca83" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated">如果你想了解更多关于BCrypt、JSON Web Token或Cookies的信息，我在下面链接了更多的文档。</p><p id="1f1c" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated"><em class="kh">【1】:HTTP cookie Docs(</em>T5【https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies】T6)</p><p id="d282" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated"><em class="kh">【2】:https://www.npmjs.com/package/jsonwebtoken</em><a class="ae lr" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank">JWT文件</a></p><p id="64a8" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lo kq kr ks lp ku kv kw lq ky kz la lb ig bi translated"><em class="kh">【3】:Bcrypt Docs(</em><a class="ae lr" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank">)https://www.npmjs.com/package/bcrypt</a><em class="kh">)</em></p></div></div>    
</body>
</html>