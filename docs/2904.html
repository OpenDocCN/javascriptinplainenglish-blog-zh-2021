<html>
<head>
<title>Let’s Build a Continuous Delivery and Branching Process with Github Actions, Vercel and Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用Github Actions、Vercel和Heroku构建一个连续的交付和分支流程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-continuous-delivery-and-branching-process-c27dae09f0b6?source=collection_archive---------7-----------------------#2021-06-13">https://javascript.plainenglish.io/lets-build-a-continuous-delivery-and-branching-process-c27dae09f0b6?source=collection_archive---------7-----------------------#2021-06-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f83f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">对于JavaScript应用程序(第1/2部分)</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f771c9615a70466bfb77d7a419196386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMmV-OlbXDEvejwNpuqHjQ.jpeg"/></div></div></figure><p id="f41c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将在本出版物中介绍的策略是我在<a class="ae lk" href="https://mymenon.com.br" rel="noopener ugc nofollow" target="_blank"> Menon </a>产品中实施的。我将鼓励读者对这样的环境采取战略性的、实际的和广泛的观点。</p><p id="bb38" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将使用一个例子<em class="ll"> monorepo </em>项目，在那里我将在<strong class="kq io"> Vercel </strong>上从前端建模一个<strong class="kq io">连续交付</strong>流程，并在<strong class="kq io"> Heroku </strong>上建模API。</p><p id="d378" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">在怀疑出现之前，我将使用构建在Github Actions本身之上的图像来完成任务。当部署集成来自我们自己配置和构建的工作流时，该过程变得更加可控，这一事实推动了这一决策。</strong></p><p id="78cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它将分为两部分:首先，我将致力于前端工作流程。最后是API。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="1fcd" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">首先</h1><p id="ae00" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">我将使用我的出版物<strong class="kq io">“Yarn work spaces，Vue.js，Node.js，TypeScript和Github Actions”</strong>的存储库作为例子，在那里我将教如何制作一个<em class="ll"> monorepo </em>项目的样板文件— <strong class="kq io">只有葡萄牙文</strong>，查看<a class="ae lk" href="https://pedromoraisf.medium.com/monorepo-com-yarn-workspaces-vue-js-node-js-typescript-github-actions-ep-1-3b9a4b5653c1" rel="noopener">第1部分</a>和<a class="ae lk" href="https://pedromoraisf.medium.com/monorepo-com-yarn-workspaces-vue-js-node-js-typescript-github-actions-parte-2-97b13fde66ff" rel="noopener">第2部分</a>。</p><p id="48fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该策略将遵循<strong class="kq io">图1.0 </strong>的流程，其中我们将从推送或拉取请求开始自动化流程。接下来，我们将链接一个测试流程，如果成功，将开始部署。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/2e10c3ce3f5d4b9c7954f2a3efa56260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpGPxYNfqCnSYh2dykOS0w.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">1.0 — Process overview.</figcaption></figure><p id="1add" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">重要的是要记住，自动化过程可以根据需要进行扩展。如果我们需要一个验收测试过程，我们可以在正常的测试过程前面加链。完成后，我们发布部署流程。这取决于你。</p><p id="3a76" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了这个流，我们在<strong class="kq io"> Git流</strong>中做的每一个<strong class="kq io">分支</strong>都会产生一个云预览工件。</p><p id="3191" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们将一个项目与某个<strong class="kq io"> Git </strong>提供者中的存储库连接起来时，Vercel 使这个特性变得可用。<strong class="kq io">然而，如简介中所述，我们将通过Github Actions来控制该流程，以便在流程方面有更多的自主权。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/261936fe11ac26e8a048b58dfcffad20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYcM6j_TfXnLqS3brpNqBw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">1.1 — Detailed view of branching strategy with production of cloud artifacts.</figcaption></figure><p id="6824" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io"> Heroku </strong>上，该功能不像在<strong class="kq io"> Vercel </strong>上那样是本地可用的。<strong class="kq io">我们将开发相同的行为</strong>，其中工作流将被编程为创建我们的API的工件，如果它还不存在的话。</p><p id="998b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了密封整个流程，我们将配置两个工作流(前端和API ),以根据我们当前所在的分支链接工件。这样，我们就可以让前端和后端之间的通信完美地工作，并且成功地交付了<strong class="kq io">满栈</strong>工件。</p><h1 id="b43e" class="lt lu in bd lv lw mw ly lz ma mx mc md jt my ju mf jw mz jx mh jz na ka mj mk bi translated">发现秘密并添加到Github秘密</h1><p id="5b44" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">我将这个主题从出版物中分离出来，分成两部分。</p><p id="36b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io"> Github Actions </strong>中配置工作流之前，我们将为我们的应用找出<strong class="kq io"> Vercel </strong>服务器的<strong class="kq io">"项目Id" </strong>和<strong class="kq io">"组织Id" </strong>。</p><p id="5cfb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在那之后，我们会拿到密码。克隆最后一个出版物的存储库，我们将一步一步地对流程进行必要的修改。</p><p id="2869" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">可以通过单击下面的链接来访问该存储库:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/pedromoraisf/monoyarn" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">pedromoraisf/单线</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">结果做了EP 1 da série系列全栈-什么也没有了💫。维加·克里坎多·阿奎。o项目…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns km ne"/></div></div></a></div><h2 id="055b" class="nt lu in bd lv nu nv dn lz nw nx dp md kx ny nz mf lb oa ob mh lf oc od mj oe bi translated">发现秘密并添加到Github秘密</h2><p id="2dac" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">下载<strong class="kq io"> Vercel CLI </strong>。通过<strong class="kq io"> NPM </strong>或<strong class="kq io">纱线</strong>点击<a class="ae lk" href="https://vercel.com/cli" rel="noopener ugc nofollow" target="_blank">此处</a>遵循安装说明。</p><p id="ec50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">安装完成后，通过终端访问前端文件夹，我们通过命令<code class="fe of og oh oi b">$ vercel</code>使用<strong class="kq io"> Vercel CLI </strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/c62f71c5f7090b4a2547d9faec759e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hc1fCZoaVIewY-vTBLb4Sg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">2.0 — Using Vercel CLI.</figcaption></figure><p id="7ef7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">按照<strong class="kq io">图2.0 </strong>中的步骤操作后，出现一个名为<strong class="kq io">的文件夹。vercel </strong>将会在前端目录中创建。</p><p id="79d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个文件夹中，<strong class="kq io"> project.json </strong>文件将包含我们正在寻找的信息。</p><p id="ad6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过访问<strong class="kq io"> Github </strong>上我们的存储库中<strong class="kq io">【设置】</strong>内的<strong class="kq io"/>选项卡，我们将把这些敏感数据添加到<a class="ae lk" href="https://docs.github.com/pt/actions/reference/encrypted-secrets" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">Github Secrets</strong></a>变量中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ok"><img src="../Images/bf1392c5a8984f9c947ceb9c71a817c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OnfIcMYZ_yHKwPyZtJlrHg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">2.1 — Variables added to Github Secrets.</figcaption></figure><p id="4a2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们将属性<strong class="kq io"> "orgId" </strong>命名为一个名为<strong class="kq io"> VERCEL_ORG_ID </strong>的变量，并将<strong class="kq io"> "projectId" </strong>命名为<strong class="kq io"> VERCEL_PROJECT_ID </strong>。</p><p id="d395" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，访问<a class="ae lk" href="https://vercel.com/account/tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> Vercel的访问令牌生成器</strong> </a>，我们将为访问我们帐户的工作流创建一个。名字将会是<strong class="kq io"> VERCEL_TOKEN </strong>。</p><h2 id="912b" class="nt lu in bd lv nu nv dn lz nw nx dp md kx ny nz mf lb oa ob mh lf oc od mj oe bi translated">将作业添加到工作流</h2><p id="ba40" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">下面的工作流程可以在位于<strong class="kq io">的<em class="ll"> monorepo </em>根内的文件中找到。github/workflows/pipeline-web . yml</strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">3.0 — Workflow Web Github Actions.</figcaption></figure><p id="d8cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从<strong class="kq io">线31 </strong>开始，是<strong class="kq io">展开步骤</strong>工作。这份工作造就了这份出版物的魅力。尽管它被列在出版物的参考文献中，但是负责与<strong class="kq io"> Vercel </strong>集成的操作的链接在下面。</p><div class="nb nc gp gr nd ne"><a href="https://github.com/amondnet/vercel-action" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">amondnet/vercel-action</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">这一行动从前是Zeit Now部署的。迁移指南Vercel是一个用于静态站点和…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="on l np nq nr nn ns km ne"/></div></div></a></div><p id="4e60" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io">第33行</strong>上，我们声明<strong class="kq io">展开步骤</strong>需要<strong class="kq io">测试程序</strong>成功完成才能启动。如果没有该声明，这两个作业将并行运行，从而破坏我们在本文开始时建模的策略。</p><p id="c60c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用<a class="ae lk" href="https://github.com/rlespinasse/github-slug-action" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">rlespinasse/Github-slug-action</strong></a>动作(也在参考文献中列出)我们有一个由<strong class="kq io"> Github动作</strong>上下文本身为slug格式提供的环境变量版本。这样，我们就为根据我们正在处理的分支生成自定义URL腾出了空间— <strong class="kq io">非常适合我们具有分支目标</strong>的连续交付。</p><p id="793d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，我将部署分成两个块:一个用于生产，一个用于分支。</p><p id="292a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我做出这个决定是因为这两个场景的环境变量在数量上存在差异。这样就把责任分开，把利益说清楚了。</p><p id="8ff0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io">第56行</strong>的<strong class="kq io">with</strong>块中，我将秘密(之前创建的)添加到amondnet/vercel-action<strong class="kq io">库</strong>的 <a class="ae lk" href="https://github.com/amondnet/vercel-action" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">的<strong class="kq io">自述文件中列出的强制输入中。没什么特别的。</strong></strong></a></p><p id="60e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io">“vercel-args”</strong>中，我们构建了<strong class="kq io">分支</strong>连续交付策略。标志<code class="fe of og oh oi b">--build-env</code>允许在构建时传递环境变量，有可能根据我们正在处理的分支动态创建API URL。</p><p id="41a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">API URL的构建将在下一集完成，<strong class="kq io">我将为你自己的工作流</strong>建模。</p><h1 id="1799" class="lt lu in bd lv lw mw ly lz ma mx mc md jt my ju mf jw mz jx mh jz na ka mj mk bi translated">查看结果</h1><p id="1407" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">提交更改并将它们推送到<strong class="kq io"> Github </strong>存储库，我们可以看到一个新的动作开始了。这是由于使用了<strong class="kq io"> Vercel CLI </strong>，其中<strong class="kq io">。gitignore </strong>被更新为包含隐藏<strong class="kq io">的一行。vercel </strong>文件夹。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oo"><img src="../Images/b24f173b30ab878fcfcfbfde98186e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_OsQ9pz8ih-ylFEqR5whA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">4.0 — deployment-step details.</figcaption></figure><p id="14e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过点击操作所使用的机器上生成的输出的第53 行的地址，我们可以看到生产中的工件——因为我们直接在主分支上工作，主分支负责生产变更的版本控制。</p><p id="0dc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">构建细节可以在<strong class="kq io"> Vercel自己的仪表板</strong>中查阅。这是因为这个动作没有在<strong class="kq io"> Github Actions </strong>容器中构建项目。整个准备过程在<strong class="kq io"> Github动作</strong>侧进行。构建被发送到<strong class="kq io"> Vercel </strong>，它将执行构建并返回结果输出。</p><h1 id="65af" class="lt lu in bd lv lw mw ly lz ma mx mc md jt my ju mf jw mz jx mh jz na ka mj mk bi translated">结论</h1><p id="df74" class="pw-post-body-paragraph ko kp in kq b kr ml jo kt ku mm jr kw kx mn kz la lb mo ld le lf mp lh li lj ig bi translated">有了<strong class="kq io">部署步骤</strong>工作，除了第一个测试工作流(已经存在于存储库中)，我们还有一个<strong class="kq io">带有分支</strong>的连续交付过程，从而完成了一个<strong class="kq io">准备工作的环境</strong>。</p><p id="5920" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下一集，我将完成这篇分两步的文章，在这里我将对API <strong class="kq io">部署步骤</strong>进行建模，就像我们对web堆栈所做的那样。</p><p id="73c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/lets-build-a-continuous-delivery-and-branching-process-with-github-actions-vercel-and-heroku-a7d9a803f4e2">点击这里看下一集→ </a></p><h1 id="adc5" class="lt lu in bd lv lw mw ly lz ma mx mc md jt my ju mf jw mz jx mh jz na ka mj mk bi translated">参考</h1><ul class=""><li id="47c2" class="op oq in kq b kr ml ku mm kx or lb os lf ot lj ou ov ow ox bi translated">韦尔塞尔</li><li id="0a43" class="op oq in kq b kr oy ku oz kx pa lb pb lf pc lj ou ov ow ox bi translated"><a class="ae lk" href="https://heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku </a></li><li id="8b1c" class="op oq in kq b kr oy ku oz kx pa lb pb lf pc lj ou ov ow ox bi translated"><a class="ae lk" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a></li><li id="be16" class="op oq in kq b kr oy ku oz kx pa lb pb lf pc lj ou ov ow ox bi translated"><a class="ae lk" href="https://docs.github.com/pt/actions/reference/encrypted-secrets" rel="noopener ugc nofollow" target="_blank"> Github秘密</a></li><li id="cc33" class="op oq in kq b kr oy ku oz kx pa lb pb lf pc lj ou ov ow ox bi translated"><a class="ae lk" href="https://github.com/amondnet" rel="noopener ugc nofollow" target="_blank">在网络中</a> / <a class="ae lk" href="https://github.com/amondnet/vercel-action" rel="noopener ugc nofollow" target="_blank"> vercel-action </a></li><li id="133a" class="op oq in kq b kr oy ku oz kx pa lb pb lf pc lj ou ov ow ox bi translated"><a class="ae lk" href="https://github.com/rlespinasse" rel="noopener ugc nofollow" target="_blank">rlespinasse</a>/<a class="ae lk" href="https://github.com/rlespinasse/github-slug-action" rel="noopener ugc nofollow" target="_blank">github-slug-action</a></li></ul><p id="86ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">更多内容请看</em><a class="ae lk" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ll">plain English . io</em></strong></a></p></div></div>    
</body>
</html>