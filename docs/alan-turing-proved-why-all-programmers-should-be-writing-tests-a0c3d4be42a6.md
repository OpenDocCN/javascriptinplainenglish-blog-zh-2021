# 艾伦·图灵证明了为什么所有程序员都应该编写测试

> 原文：<https://javascript.plainenglish.io/alan-turing-proved-why-all-programmers-should-be-writing-tests-a0c3d4be42a6?source=collection_archive---------13----------------------->

## 你能不能写一个函数，如果这个函数完成了就返回 true，如果没有完成就返回 false？

![](img/8bcca6706967039db083b660770a177a.png)

您能否编写一个 JavaScript 函数，它接收一个任意函数和一个输入作为参数，如果这个函数在被调用后执行完毕(暂停)，则返回 ***true*** ，如果没有，则返回 ***false*** ，针对函数和输入的每一种可能的组合？

出于练习的目的，假设没有时间或内存限制来绑定我们的 JS 引擎，并且引擎本身工作完美。

我们要找的是这样的东西:

相当有趣的任务，不是吗？让我们仔细检查一下。

对于一些函数来说，在没有任何特殊算法的帮助下回答问题是相对琐碎的。例如，我们可以很快判断出下面的函数永远不会停止:

而我们同样可以很快判断出这另一个功能将总是停止:

但是随着功能变得更加复杂，任务也变得更加棘手。我们可能在谈论具有数千行代码和数百万可能输出的函数，这取决于输入。

这个问题——或者它的正式的、定义明确的版本——在计算机科学和数学中被称为**停机问题**。如果你有 CS 背景，你大概知道，也讨论过，但是作为一个(厉害？)自学的电脑程序员，职业生涯后期才偶然发现的。

# 停顿问题

艾伦·图灵和阿隆佐·邱奇在 20 世纪早期分别证明了停机问题是不可解的。他们从数学上证明了不可能有一个通用算法总是能解决停机问题。图灵的证明之所以吸引人，是因为其思维的直观性和平易近人。

假设有一个程序总是决定停机问题。换句话说，假设有一个程序，能够明确正确地回答“程序 X，不管它是什么，给定一个输入 Y，不管它是什么，会终止还是不会终止？”对于每一个可能的程序输入。此外，假设我们将这个程序做成一个 JavaScript 函数，并将这个函数导入到一个不同的模块中。然后我们修改它，所以如果函数返回 true，我们让它永远循环，如果它返回 false，我们输出 ***true*** 。

假设您调用这个新函数，它本身是一个参数。

在这个假设的程序中，当我点击 ***checkIfHalts*** 函数并询问它，“checkIfHaltsModified 会停止吗？”如果回答是，我们的 ***doesItHalt*** 函数将返回 ***true*** ，程序将进入循环，永不停止。同样的，如果我们假设的函数用“不，它不会停止”来回答我们的问题，那么 ***doesItHalt*** 将会是 ***false*** ，而函数将会停止并吐出 ***true*** 作为它的最终输出——这是一个悖论。

> *反证法*

如果停机问题的正确解的前提导致一个悖论，这意味着假设一定是不正确的。这意味着无法解决停机问题。简直天才！想象一下图灵在 1931 年就得出这样的结论，比我们看到第一台计算机早了几十年！

现在，这是一个很好的理论性的小东西，相当有趣，但那又怎么样呢？这对我们开发人员的日常生活有实际意义吗？

乍一看，答案似乎是否定的。在处理停机问题时，图灵将具有无限时间和资源的虚拟机器概念化，以运行任何计算。在现实生活中，计算机会遇到时间和资源的限制。"理论上程序可能永远不会停止，但是服务器请求肯定会超时！"

此外，除了可能出现相同性质问题的感觉领域，停止或不停止的特殊情况似乎与大多数日常软件开发人员任务无关。我们知道我们不希望事情结束，比如服务器和事件循环。当我们不这样做的时候，我们就终止那个悬挂过程，就这样。但是，如果我们抛开物质含义，敞开我们的思想去理解理论告诉我们的本质，我们可能会发现一些令人兴奋的想法，可以帮助我们扩展软件是什么以及如何处理它的视野。

# 潜得更深

我们刚刚看到，不可能编写一个程序来判断另一个程序是否会停止。但是，假设我们对编写一个解决停机问题的程序不感兴趣，而是想知道任意一个程序是否会给我们一个有效的 React 组件作为它的计算结果。

事实证明，在我们之前假设的理论条件下，你也不能。我们可以用停顿问题来帮助我们说明为什么这也是不可能的。

按照我们对停机问题解决方案采取的相同步骤，再次想象这样一个程序会以我们可以导入的 JavaScript 函数的形式存在。如果可以的话，我们就可以用它来写另一个决定暂停程序的程序！

方法如下:

在这个例子中，我们首先创建一个中间函数(g ),它执行作为参数传递的任意函数，而不考虑结果，然后立即返回一个反应组件。然后我们把这个中间函数给我们的假设函数，它检查函数产生反应成分的能力。如果***is react component generator***函数返回真，那一定意味着 ***fn*** 最终会完成执行，也就是说它会停止。另一方面，如果返回 false，则意味着 ***fn*** 永远不会结束运行。但是，如果我们只是证明我们不能对停顿问题有一个明确的解决方案，那么我们的假设一定是错误的。换句话说，这意味着不能有一个函数明确决定任何任意函数是否返回一个反作用分量。

亨利·戈登·赖斯在 1951 年提出了这个想法，当时他证明了程序的所有非平凡语义属性都是不可判定的，这就是所谓的赖斯定理。换句话说，这意味着不可能编写一个通用的程序，给定一对任意的程序输入，它可以明确地告诉你，对于所有可能的参数，该程序的输出是什么。

> 在给定一对任意的程序输入的情况下，不可能写出一个通用的程序，它能明确地告诉你对于所有可能的参数，该程序的输出会是什么。

证明了这一点，赖斯为计算的本质提供了一个新的视角。赖斯、图灵和丘奇在数学上证明的是，计算能力并不重要:根本不可能设想一种算法来检查给定的程序，并告诉你它将为每一个可能的程序做什么。无论您在旧的英特尔 486 或量子计算机上运行它。这就是事情开始变得更有趣的地方。

形成这种情况的软件系统有什么独特之处？作为一种自然现象，代码有什么内在的东西赋予它潜在不可能的可理解性？我们怎么可能把有限的和容易理解的语法结合起来，创造出如此复杂的东西，以至于我们无法说出它的结果呢？

# 软件和现实世界相遇的地方

![](img/3b40816ae1757366452f555c1ae4148b.png)

Plants in a complex pattern, by [Mitchell Luo](https://unsplash.com/@mitchel3uo?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/fractal?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

这些问题并不局限于计算机科学领域。从经济到生物学，从心理学到医学，在最不同的领域，我们都有类似问题的例子。一个被充分理解的神经元网络如何产生大脑？各种各样的独立代理人如何推动股市？原子的组合是如何结合并随着时间进化而产生生命的，这就是这些原子最初是如何做到这一点的原因？

在 20 世纪下半叶，来自不同领域的科学家和思想家开始观察这些相似的现象，它们在最不同的背景下重复出现。到处都是相同的模式:简单规则的集合开始以复杂的方式结合，产生更重要的东西，但难以理解和预测。

我们知道并理解买卖的概念，我们已经广泛分析了许多不同的理论互动游戏，然而，没有人能预测股票市场将如何表现。我们已经将神经元切割成无限小的部分，并测量了它如何与其他神经元相互作用的每个细节，但大脑仍然是科学中最大的谜团之一。同样，我们理解我们所写的每一行代码的语法，然而更多的时候，从这些代码行中出现的系统行为是不可预测的。

这一整套类似的问题产生了一个新的科学领域，叫做复杂性。正如科学所言，复杂性是一个仍处于早期阶段的领域。它主要关注的是理解复杂系统是如何出现的。它曾被称为混沌，也是蝴蝶效应和分形等概念诞生的地方。有趣的是，科学家用来理解这些复杂系统的主要工具之一是计算机。

将复杂系统建模为计算机模拟，以了解这些系统是如何出现的，一直是该领域的主要技术。方法的发展代表了计算机科学的重大进步，其影响范围从硬件工程到人工智能理论。背后的想法很简单。

我们不能用我们对一个系统基本条件的了解来预测它将如何表现。与其试着去推理，不如实际看到系统在我们面前展开。没有什么工具能比计算机更好地帮助我们完成这项任务了。

为了理解复杂系统是如何产生的，科学家们发明了许多模拟现实生活中进化和涌现概念的模拟。较小版本的股票市场、神经元网络和生命本身运行在一个完全抽象的环境中，从我们软件开发人员每天编写的相同代码行中诞生。

虽然这个新的科学领域本身令人兴奋，但我们关心的是这一切对我们日常生活的影响。我们刚刚看到，从理论上讲，从纯算法的角度来分析任何一段重要的代码是不可能的。换句话说，你不能仅仅通过阅读来判断任何非平凡的代码将会做什么。我们也看到这是不可能的，因为软件似乎有一些特殊之处，使得预测它将做什么变得不可能。最后，我们观察到这种同样的不可能性存在于其他现实世界的现象中，科学家们一直试图使用软件本身来理解它。

尽管如此，尽管这种借口潜在的不可预测性，编写软件的整个企业是关于让它做我们想要它做的事情。那么，我们如何确保它做我们想要它做的事情呢？我们就像研究复杂性的科学家一样:我们模拟它。

> 判断任何非平凡软件系统将做什么的最有效方法是运行它。

作为软件开发人员，这是我们的工作方式。我们编写代码只是为了运行它，并检查它是否做了我们想要它做的事情，因为否则，我们无法知道我们工作的系统会做什么。换句话说，**要知道一个非平凡的软件系统会做什么，最有效的方法就是运行它。这不是人类思维的局限，而是自然的基本法则。几十年前，图灵、丘奇和赖斯通过逻辑和数学的语言向我们指出了一条定律。**

观察我们作为软件工匠的工作的一部分是自动化可重复的任务。您不希望每次发生变化时都在运行的服务器上下载新的源代码。您构建自动化部署。你不想通过每小时阅读你的日志来跟踪错误。您可以自动发送通知。你也不想每次修改代码时都运行软件模拟并开始测试它。你也可以通过**编写测试**来实现自动化。

这是因为没有其他更有效的方法来处理您编写测试的代码固有的复杂本质。

# 最后的想法

从艾伦·图灵 1931 年发表的一个数学证明来看，在我们拥有第一种编程语言的二十年前，我们已经可以看到逻辑机器将揭示的复杂世界。从那里，我们可以追踪一条通向我们日常工作的科学知识发现之路，并解释我们为什么做一些事情，比如写测试。

尽管有时他们会感到脱节，但理论发现可以帮助我们建立良好的心智模型，并对我们的日常工作有更好的理解。尽管理论计算机科学和数学可能会让来自学术界之外的软件开发人员感到畏惧，但这些领域比人们最初想象的更容易接近。人们可以依靠很多资源来更好地了解这个地区。

从根本上说，人们不需要理解这些理论的每一个细微的方面来了解它们告诉我们关于世界的事情，尽管你可以。即使像这篇文章中所说的那样，这些想法和理论也能激发你的想法，重塑你对代码的看法，增加你的创造力和对你工作的基本理解。