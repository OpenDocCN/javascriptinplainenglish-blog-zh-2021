<html>
<head>
<title>LeetCode Algorithm Challenges: Convert Sorted Array to Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法挑战:将排序数组转换为二叉查找树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-challenges-convert-sorted-array-to-binary-search-tree-a0f3e7b18fd4?source=collection_archive---------17-----------------------#2021-08-02">https://javascript.plainenglish.io/leetcode-algorithm-challenges-convert-sorted-array-to-binary-search-tree-a0f3e7b18fd4?source=collection_archive---------17-----------------------#2021-08-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="003f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题</h1><p id="5792" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">给定一个整数数组<code class="fe lg lh li lj b">nums</code>，其中的元素按<strong class="kk io">升序</strong>排序，将<em class="lk">转换为一个高度平衡的</em><strong class="kk io"><em class="lk"/></strong><em class="lk">二叉查找树</em>。</p><p id="ccf8" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">高度平衡的二叉树是这样一种二叉树，其中每个节点的两个子树的深度相差不超过1。</p><p id="ad21" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">例1: </p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/42268a13b5b9784c5da31b7c1a8921da.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*AWx_DiXDPGukxV7B.jpg"/></div></figure><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="1d19" class="mc jl in lj b gy md me l mf mg"><strong class="lj io">Input:</strong> nums = [-10,-3,0,5,9]<br/><strong class="lj io">Output:</strong> [0,-3,9,-10,null,5]<br/><strong class="lj io">Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/59261a190edbe18dddbfb7978f806d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*BZPxFP1rDVHBiT5Q.jpg"/></div></figure><p id="0f5c" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><strong class="kk io">例2: </strong></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ff5eaf29a7b0a528724aa2fd2628d217.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*IJTPxjrMH8F1kRyv.jpg"/></div></figure><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="90b3" class="mc jl in lj b gy md me l mf mg"><strong class="lj io">Input:</strong> nums = [1,3]<br/><strong class="lj io">Output:</strong> [3,1]<br/><strong class="lj io">Explanation:</strong> [1,3] and [3,1] are both a height-balanced BSTs.</span></pre></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="212a" class="jk jl in bd jm jn mp jp jq jr mq jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh bi translated">问题</h1><p id="cc26" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在我的上一篇文章中，我解释了平衡二叉树的概念。</p><div class="mv mw gp gr mx my"><a href="https://nicksolonyy.medium.com/leetcode-algorithm-challenges-balanced-binary-tree-3bb95007163c" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd io gy z fp nd fr fs ne fu fw im bi translated">LeetCode算法挑战:平衡二叉树</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">问题</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">nicksolonyy.medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm lw my"/></div></div></a></div><p id="e81f" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">为了确保我们将一个数组转换成一个平衡的二叉树，每个创建的子树上的数组元素的数量之差不超过1。这个想法导致了一个非常简单的解决方案，我们应该把数组分成两半。</p><p id="1e2c" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">基于以上内容，我们将创建一个递归函数，将子数组一分为二，并创建下一组树节点。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="0b6b" class="jk jl in bd jm jn mp jp jq jr mq jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh bi translated">解决办法</h1><p id="d3e8" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们从一个空数组的例子开始，我们只需要返回<code class="fe lg lh li lj b">null</code>。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="741d" class="mc jl in lj b gy md me l mf mg">if (nums.length === 0) return null;</span></pre><p id="2629" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">我们仍然需要返回<code class="fe lg lh li lj b">null</code>值，因为随着递归的深入，一些树节点将会变成<code class="fe lg lh li lj b">null</code>。</p><p id="ddc6" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">使用简单的数学计算，我们将确定我们的中间元素。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="4989" class="mc jl in lj b gy md me l mf mg">let middle = Math.floor(nums.length / 2);</span></pre><p id="34c5" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">现在，<code class="fe lg lh li lj b">middle</code>之前和之后的任何东西都是相同的大小(如果差1个元素我们没问题)，我们可以从<code class="fe lg lh li lj b">root</code>开始构建树。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="9c02" class="mc jl in lj b gy md me l mf mg">let root = new TreeNode(nums[middle]);</span></pre><p id="f16b" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">中间元素之前的子数组将使用<code class="fe lg lh li lj b">sortedArrayToBST</code>创建左子树，并使用<code class="fe lg lh li lj b">.slice</code>函数获取新的子数组。</p><p id="ad1f" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">类似地，中间元素后的子数组将创建右边的子树。我们将在这里使用我们的递归函数，遍历整个数组并构建一个完整的树。</p><pre class="lr ls lt lu gt ly lj lz ma aw mb bi"><span id="7155" class="mc jl in lj b gy md me l mf mg">root.left = sortedArrayToBST(nums.slice(0, middle));</span><span id="5750" class="mc jl in lj b gy nn me l mf mg">root.right = sortedArrayToBST(nums.slice(middle + 1));</span></pre></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="9123" class="jk jl in bd jm jn mp jp jq jr mq jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh bi translated">密码</h1><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="456c" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">请在以下社交网络上查看我，我很乐意收到您的来信！——<a class="ae mu" href="https://www.linkedin.com/in/nick-solonyy/" rel="noopener ugc nofollow" target="_blank"><em class="lk">LinkedIn</em></a><em class="lk">，</em> <a class="ae mu" href="https://github.com/nicksolony" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> GitHub </em> </a>，<a class="ae mu" href="https://www.facebook.com/nick.solony" rel="noopener ugc nofollow" target="_blank"> <em class="lk">脸书</em> </a> <em class="lk">。</em></p></div></div>    
</body>
</html>