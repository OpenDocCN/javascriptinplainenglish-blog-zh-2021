<html>
<head>
<title>You Probably Don’t Need act() in Your React Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能不需要在反应测试中采取行动()</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-probably-dont-need-act-in-your-react-tests-2a0bcd2ad65c?source=collection_archive---------0-----------------------#2021-04-05">https://javascript.plainenglish.io/you-probably-dont-need-act-in-your-react-tests-2a0bcd2ad65c?source=collection_archive---------0-----------------------#2021-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="70c7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你应该做的是。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/332f1c96c4897b4305202d14fa08550d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjgMW8a4mDuoAvpbU5se0w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@pilgrim" rel="noopener ugc nofollow" target="_blank">Marek Novotný </a>on <a class="ae kv" href="https://unsplash.com/photos/sAYjHNsD0rI" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2f3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">TL；DR </strong>如果您发现自己将<code class="fe ls lt lu lv b">act()</code>与RTL ( <code class="fe ls lt lu lv b">react-testing-library</code>)一起使用，您应该看看是否可以改用RTL异步实用程序:<code class="fe ls lt lu lv b">waitFor</code>、<code class="fe ls lt lu lv b">waitForElementToBeRemoved</code>或<code class="fe ls lt lu lv b">findBy</code>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="fd73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React希望所有可能导致状态更新的测试代码<a class="ae kv" href="https://reactjs.org/docs/test-utils.html#act" rel="noopener ugc nofollow" target="_blank">都包含在</a> <code class="fe ls lt lu lv b"><a class="ae kv" href="https://reactjs.org/docs/test-utils.html#act" rel="noopener ugc nofollow" target="_blank">act()</a></code>中。</p><p id="9210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="md">但是等一下</em>，标题不是说我们应该<strong class="ky ir">而不是</strong>使用<code class="fe ls lt lu lv b">act()</code>吗？嗯……是的，因为<code class="fe ls lt lu lv b">act()</code>是样板，我们可以用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://testing-library.com/docs/" rel="noopener ugc nofollow" target="_blank">react-testing-library</a></code>去掉🚀</p><h2 id="a859" class="me mf iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated"><code class="fe ls lt lu lv b">act()</code>解决了什么问题？</h2><p id="c618" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这样想:当测试中发生什么事情时，例如，某个按钮被点击，React需要<strong class="ky ir">调用事件处理程序，更新状态，然后运行</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">useEffect</strong></code>。由于<a class="ae kv" href="https://reactjs.org/docs/design-principles.html#scheduling" rel="noopener ugc nofollow" target="_blank">反应状态更新是异步的</a>，反应必须知道何时做所有这些事情。这就是为什么<code class="fe ls lt lu lv b">act()</code>是必要的。</p><p id="8bc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想挖掘得更深，有一个<a class="ae kv" href="https://github.com/threepointone/react-act-examples/blob/master/sync.md" rel="noopener ugc nofollow" target="_blank">惊人的读数</a>。</p><h2 id="0fd0" class="me mf iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated"><code class="fe ls lt lu lv b">react-testing-library</code>已经在<code class="fe ls lt lu lv b">act()</code>中包装了实用程序</h2><p id="2e68" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">每次使用<code class="fe ls lt lu lv b">render()</code>、<code class="fe ls lt lu lv b">userEvent</code>、<code class="fe ls lt lu lv b">fireEvent</code>时，都是<a class="ae kv" href="https://testing-library.com/docs/preact-testing-library/api/#act" rel="noopener ugc nofollow" target="_blank">已经将</a>包裹在<code class="fe ls lt lu lv b">act()</code>中。<strong class="ky ir">实际上是什么意思？</strong></p><p id="ee07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着每次您使用这些实用程序之一时，所有组件的相关状态更新都会被刷新。额外的同步<code class="fe ls lt lu lv b">act()</code>不会改变<em class="md">任何东西</em>。</p><p id="16c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不相信我，看看这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://codesandbox.io/s/late-frost-3j2sr?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/late-frost-3j2sr?file=/src/App.js</a></figcaption></figure><p id="0045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="md">注:所有例子都是基于一个新鲜的</em> <code class="fe ls lt lu lv b"><em class="md">create-react-app</em></code> <em class="md">。</em></p><p id="07d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，我们没有使用<code class="fe ls lt lu lv b">act()</code>，新标题在点击后被刷新。</p><p id="93b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我提到<strong class="ky ir">同步</strong>T2是有原因的。事情开始变得棘手了🙊</p><h1 id="4db5" class="ne mf iq bd mg nf ng nh mj ni nj nk mm jw nl jx mp jz nm ka ms kc nn kd mv no bi translated">😈异步组件</h1><p id="6ee9" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">每当状态更新被<strong class="ky ir">调度</strong> <strong class="ky ir">异步</strong>(例如，在承诺解决之后)<strong class="ky ir">，</strong>测试就不能再保持同步。否则，React将警告我们状态更新没有被包装在<code class="fe ls lt lu lv b">act()</code>中。</p><p id="34f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我来说明我的意思。我们将从API中获取标题，而不是在单击按钮时设置标题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://codesandbox.io/s/act-warning-7y357?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/act-warning-7y357?file=/src/App.js</a></figcaption></figure><p id="d3d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个测试不仅会失败，而且还会产生臭名昭著的<code class="fe ls lt lu lv b">An update to App inside a test was not wrapped in act(...).</code>警告。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/119ec098f95b7835aae812915e6ad06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3bmxrLs4vIIBeIzvPKxcg.png"/></div></div></figure><p id="bc8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么会出现这种情况？答案与<a class="ae kv" href="https://flaviocopes.com/javascript-event-loop/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">事件循环</strong> </a>的关系比与React的关系更大。</p><p id="6ff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经注意到测试同步地做所有的事情。它没有<code class="fe ls lt lu lv b">await</code>或承诺链。出于这个原因，<code class="fe ls lt lu lv b">setTitle(title)</code>进入<strong class="ky ir">任务队列</strong>(也称为<strong class="ky ir">消息队列</strong> ) <strong class="ky ir"> </strong>，并且只有在调用栈清空之后才被执行<strong class="ky ir">。在另一端，<code class="fe ls lt lu lv b">expect(screen.getByText("Fetched")).toBeInTheDocument()</code>进入<strong class="ky ir">调用栈</strong>，这意味着它在状态更新被调度之前运行！</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/8c86431759b2a9318cdd10e77d7e0c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9oH90yW8BV00YTHkDCChQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">setTitle() goes into task queue, hence executes later than expect()</figcaption></figure><p id="7b62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，但是为什么要警告呢？毕竟，<code class="fe ls lt lu lv b">render()</code>导致了状态更新，它被RTL包装在<code class="fe ls lt lu lv b">act()</code>中，所以我们应该是好的，对吗？😧</p><p id="db15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不完全是。由于<code class="fe ls lt lu lv b">render()</code>是一个同步函数，它只刷新同步状态更新。</p><p id="f90b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之:</p><ul class=""><li id="c8d1" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated">测试失败，因为状态更新被安排在断言之后<strong class="ky ir">。</strong></li><li id="c174" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">打印警告是因为状态更新计划在测试完成后<strong class="ky ir">进行。</strong></li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="e5da" class="me mf iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">这怎么解决？</h2><p id="8acb" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">🔴让我从一个不正确的例子开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://codesandbox.io/s/hide-act-warning-7e1b2?file=/src/App.test.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/hide-act-warning-7e1b2?file=/src/App.test.js</a></figcaption></figure><p id="b3a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这解决了我们两个的问题。它隐藏了警告，也使测试通过，但它带来了其他问题:</p><ul class=""><li id="71a2" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated">这只是因为状态更新发生在事件循环的下一个节拍。</li><li id="cc41" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><code class="fe ls lt lu lv b">act()</code>这里没有什么特别的，只是隐藏了警告。</li></ul><p id="3162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，为了展示这种解决方案的粗糙本质，请看另一个例子。它还隐藏警告并使测试通过。看起来没什么意义吧？语义上，这两者差别不大。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://codesandbox.io/s/hide-act-warning-2-r9tlq?file=/src/App.test.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/hide-act-warning-2-r9tlq?file=/src/App.test.js</a></figcaption></figure><p id="1cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了证明我的第一点，<code class="fe ls lt lu lv b">This only works because the state update happens in the next tick of the event loop</code>，考虑一个例子，我们<code class="fe ls lt lu lv b">await</code>一个额外的承诺。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://codesandbox.io/s/hide-act-warning-3-oezlf?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/hide-act-warning-3-oezlf?file=/src/App.js</a></figcaption></figure><p id="5e7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它会使测试失败！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="eeed" class="me mf iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">✅使用RTL异步实用程序</h2><p id="f588" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">好消息是在这些场景中没有必要使用<code class="fe ls lt lu lv b">act()</code>。我们可以使用<a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-async" rel="noopener ugc nofollow" target="_blank">与RTL </a> : <code class="fe ls lt lu lv b">waitFor</code>，<code class="fe ls lt lu lv b">waitForElementToBeRemoved</code>和<code class="fe ls lt lu lv b">findBy</code>查询一起提供的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://codesandbox.io/s/testing-async-the-proper-way-jvedu?file=/src/App.test.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/testing-async-the-proper-way-jvedu?file=/src/App.test.js</a></figcaption></figure><p id="df2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者是<code class="fe ls lt lu lv b">waitFor</code>变型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://codesandbox.io/s/testing-async-the-proper-way-2-5b5qu?file=/src/App.test.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/testing-async-the-proper-way-2-5b5qu?file=/src/App.test.js</a></figcaption></figure><p id="e87e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两种变体都通过了测试，它们没有上述问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7df40b441f62fd2186c29ce54c37844a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*KlfJC_NuafMLwg3E3hYYmw.png"/></div></figure><h2 id="afc0" class="me mf iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">如果我在一个事件后获取会怎样？</h2><p id="8de2" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果异步调度的状态更新发生在<code class="fe ls lt lu lv b">useEffect</code>或事件处理程序中，没有区别。在测试中，我们可以等待事情发生后的<strong class="ky ir">，而不是等待事情发生后的<code class="fe ls lt lu lv b">render()</code>。</strong></p><p id="3319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重温第一个例子，但这次我们将异步更新状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://codesandbox.io/s/testing-userevent-the-proper-way-6zs7o?file=/src/App.test.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/testing-userevent-the-proper-way-6zs7o?file=/src/App.test.js</a></figcaption></figure><p id="24da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，状态更新被安排在用户点击之后，而不是在<code class="fe ls lt lu lv b">useEffect</code>中，从测试的角度来看，这并没有太大的变化。<code class="fe ls lt lu lv b">act()</code>中的<code class="fe ls lt lu lv b">userEvent</code>包装和<code class="fe ls lt lu lv b">render()</code>包装一样差。</p><h2 id="1c41" class="me mf iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">是否存在使用<code class="fe ls lt lu lv b">act()</code>不可避免的情况？</h2><p id="37ee" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">是的，可能会有某些情况。例如，您可能希望安排一个去抖功能的状态更新。在这种情况下，使用jest的假计时器并将<code class="fe ls lt lu lv b">jest.runAllTimers</code>或<code class="fe ls lt lu lv b">jest.advanceTimersByTime </code>包装在<code class="fe ls lt lu lv b">act()</code>中似乎是一种合理的方法。</p><p id="6644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我建议在这里阅读更多关于棘手案件的信息。</p><h1 id="7292" class="ne mf iq bd mg nf ng nh mj ni nj nk mm jw nl jx mp jz nm ka ms kc nn kd mv no bi translated">🚪结论</h1><p id="ce28" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在大多数情况下，<code class="fe ls lt lu lv b">react-testing-library</code>使得<code class="fe ls lt lu lv b">act()</code>中的包装测试代码变得不必要。此外，这样做可能会导致其他问题。相反，请尝试使用RTL异步实用程序，它们应该可以满足您的大部分需求。</p><p id="fa24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/testing-library/eslint-plugin-testing-library/issues/186" rel="noopener ugc nofollow" target="_blank">eslint-plugin-testing-library v4</a>中提供<code class="fe ls lt lu lv b">no-unnecessary-act</code>规则的工作已经在进行中，但是在撰写本文时，它仍然是一个正在进行中的<a class="ae kv" href="https://github.com/testing-library/eslint-plugin-testing-library/issues/259" rel="noopener ugc nofollow" target="_blank">工作</a>。希望它能尽快完成。</p><p id="fd6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我非常感谢你花时间阅读这篇文章，我希望你学到了一些新的东西🙂</p><p id="a3c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://www.linkedin.com/in/tomas-zaicevas/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kv" href="https://github.com/zaicevas" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae kv" href="https://twitter.com/tozaicevas" rel="noopener ugc nofollow" target="_blank"> Twitter </a>中随意<strong class="ky ir">连接</strong>与我</p><h1 id="1904" class="ne mf iq bd mg nf ng nh mj ni nj nk mm jw nl jx mp jz nm ka ms kc nn kd mv no bi translated">资源</h1><ul class=""><li id="dec3" class="nr ns iq ky b kz mx lc my lf og lj oh ln oi lr nw nx ny nz bi translated"><code class="fe ls lt lu lv b">act()</code> <a class="ae kv" href="https://reactjs.org/docs/test-utils.html#act" rel="noopener ugc nofollow" target="_blank">单据</a></li><li id="c189" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://testing-library.com/docs/" rel="noopener ugc nofollow" target="_blank"> RTL文件</a></li><li id="0029" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-async" rel="noopener ugc nofollow" target="_blank"> RTL异步公用事业</a></li><li id="6899" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://github.com/threepointone/react-act-examples/blob/master/sync.md" rel="noopener ugc nofollow" target="_blank">更深入地洞察</a> <code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/threepointone/react-act-examples/blob/master/sync.md" rel="noopener ugc nofollow" target="_blank">act()</a></code> <a class="ae kv" href="https://github.com/threepointone/react-act-examples/blob/master/sync.md" rel="noopener ugc nofollow" target="_blank">所做的事情</a></li><li id="43b5" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><code class="fe ls lt lu lv b">no-unnecessary-act</code> eslint规则<a class="ae kv" href="https://github.com/testing-library/eslint-plugin-testing-library/issues/259" rel="noopener ugc nofollow" target="_blank"> GitHub发布</a></li><li id="60f3" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://flaviocopes.com/javascript-event-loop/" rel="noopener ugc nofollow" target="_blank">JavaScript事件循环</a></li><li id="a202" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">事件循环到底是什么？|菲利普·罗伯茨| JSConf欧盟</li><li id="2f49" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://kentcdodds.com/blog/fix-the-not-wrapped-in-act-warning" rel="noopener ugc nofollow" target="_blank">修正了RTL创作者的“没有被包裹在act(……)”警告</a></li><li id="50e6" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://kentcdodds.com/blog/common-mistakes-with-react-testing-library#wrapping-things-in-act-unnecessarily" rel="noopener ugc nofollow" target="_blank">把东西包在</a> <code class="fe ls lt lu lv b"><a class="ae kv" href="https://kentcdodds.com/blog/common-mistakes-with-react-testing-library#wrapping-things-in-act-unnecessarily" rel="noopener ugc nofollow" target="_blank">act</a></code> <a class="ae kv" href="https://kentcdodds.com/blog/common-mistakes-with-react-testing-library#wrapping-things-in-act-unnecessarily" rel="noopener ugc nofollow" target="_blank">不必要地</a></li></ul><p id="27ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="md">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="md">plain English . io</em></strong></a></p></div></div>    
</body>
</html>