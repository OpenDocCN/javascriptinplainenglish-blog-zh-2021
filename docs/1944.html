<html>
<head>
<title>Intro to Unit Testing with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest单元测试简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-unit-testing-with-jest-628aa3c6f832?source=collection_archive---------7-----------------------#2021-04-23">https://javascript.plainenglish.io/intro-to-unit-testing-with-jest-628aa3c6f832?source=collection_archive---------7-----------------------#2021-04-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/a8b8085bbda306217f14fba210478acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*veOyRtKTPeoqC_VlWNUc5Q.png"/></div></figure><h2 id="bf07" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">测试驱动的开发和单元测试</h2><p id="d9a5" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">测试是软件生产最重要的方面之一。测试让开发人员清楚地知道应用程序的某些部分应该完成什么。</p><p id="cfef" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">许多公司使用被称为测试驱动开发(TDD)的编程方法来指导生产。TDD规定，为了在编写任何代码之前指导软件生产，应该首先创建自动化单元测试。</p><p id="018d" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">但是什么是单元测试呢？</p><p id="4985" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">单元测试是一种测试可以从软件中分离出来的最小代码片段(也称为单元或组件)的方法。单元可以是单独的函数、方法、过程、模块或对象。</p><p id="92f7" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">了解代码将如何被测试可以让开发人员知道代码应该如何被最好地组合和模块化。</p><p id="00f4" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated"><a class="ae ln" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>在开发测试中起着有益的作用，因为每个单元测试应该只检查井的完成，单一责任。这将促使代码以遵循相同原则的方式编写。</p><p id="fd1b" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">在TDD中，只有当测试失败时，才应该编写或修改新代码；测试总是推动开发。</p><h2 id="dd3e" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么是玩笑？</h2><p id="bcf8" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated"><a class="ae ln" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>是一个令人愉快的JavaScript测试框架，专注于简单性。它与项目一起使用:<a class="ae ln" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴贝尔</a>、<a class="ae ln" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a>、<a class="ae ln" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">节点</a>、<a class="ae ln" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>、<a class="ae ln" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">角度</a>、<a class="ae ln" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>等等！”Jest是开源的，由克里斯托夫·中泽友秀创建，由脸书维护。</p><p id="64f4" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">它预装了create-creat-app，最初是专门为测试React应用程序而设计的。</p><p id="176f" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">此后，它成为前端和后端应用程序最流行的JavaScript测试框架之一，也可以说是最容易使用的。截至2021年4月，Jest的周下载量超过1100万。</p><h2 id="547c" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">构建我们的第一个测试</h2><p id="1684" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">出于演示目的，我们将不使用create-react-app，而是在Node.js中创建一个非常简单的应用程序。因此，让我们从命令行创建一个新目录，初始化npm，创建一个文件，并安装Jest:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="238e" class="jr js in lt b gy lx ly l lz ma">$ mkdir test<br/>$ cd test<br/>$ npm init -y</span><span id="5b2a" class="jr js in lt b gy mb ly l lz ma">$ touch script.js<br/>$ npm install --save-dev jest<br/>$ code . (open the new dir in whatever code editor you use)</span></pre><p id="5ee1" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">现在打开package.json并指定“test”来运行jest，方法是将文本替换为“Jest”:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/fd9008b84469e55c0dab89ffe4e46bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*GFFnWCwFeyJXDgTSJB2AYg.png"/></div></figure><p id="bc26" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">现在我们只需在命令行中输入“npm test”就可以运行Jest了。让我们打开script.js并创建一个简单的函数来获得两个数的和。我们将使用CommonJS模块来导出:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/bec45d23351994a5961efc4b8d61373b.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*V7-2MQxvbTM8B9PYM2fZ1w.png"/></div></figure><p id="3c63" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">让我们创建一个新文件，与我们将要测试的文件同名，但是添加“. test.js”来保存我们的测试。</p><p id="f491" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">每一个使用Jest的测试文件都需要在名字的末尾有一个“. test.js”来作为测试用例。下面是一个用Jest语法创建的简单测试，用于测试sum函数的2 + 3结果是否为5:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/9f3dc77f5c3e1629e296907603f31b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbM7d1mm9ajF5izf_YuZ1Q.png"/></div></div></figure><p id="448e" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">注意，它读起来几乎像一个句子，多好啊！</p><p id="6af2" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">“test”函数有两个参数；第一个参数是一个字符串，我们在其中定义了测试要检查的内容(这只是为了便于阅读，它与测试的操作没有实际关系)。</p><p id="8299" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">第二个参数是包含我们将要运行的测试的函数。在这个函数中，我们有一个“expect”函数，它接受一个指定的要测试的函数(“sum”)和我们选择的参数。</p><p id="9158" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">然后使用类似的“匹配器”将结果与我们的预期结果进行核对。toBe(检查严格相等===)。点击查看完整的匹配者列表<a class="ae ln" href="https://github.com/sapegin/jest-cheat-sheet#matchers" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="122a" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">现在让我们运行:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4133" class="jr js in lt b gy lx ly l lz ma">$ npm test</span></pre><p id="86bf" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">终端应该输出类似如下的内容:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/3c72efef946b8e10b6b5bb9a466b1483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*UCS1q6sYOlrx4KcAltLl5A.png"/></div></figure><p id="f88f" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">呜哇！我们第一次通过单元测试。让我们再做一个，这样我们可以看到如何在一个文件中管理多个单元的测试，以及如何使用另一个匹配器。让我们在<strong class="kp io"> script.js </strong>文件中创建一个名为cloneObj的新函数，它将使用<a class="ae ln" href="https://www.samanthaming.com/tidbits/70-3-ways-to-clone-objects/" rel="noopener ugc nofollow" target="_blank"> ES6扩展操作符</a>获取一个对象并返回其副本。然后我们导出两个函数:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/033f158a94478c37d0d91f84340caee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*2fnXQ4-l6IG9OgwynHdNNA.png"/></div></figure><p id="87ad" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">现在让我们在<strong class="kp io"> script.test.js </strong>文件中编写一个测试:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/0c054aec6ef24bf3cebb093ed8cf8491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHVuankdmCnTqhe_2qxXBA.png"/></div></div></figure><p id="d462" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">运行<code class="fe mm mn mo lt b">$ npm test</code>看看会发生什么。检查我们的cloneObj函数的测试是<em class="mp">失败:</em></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mq"><img src="../Images/e571d32d43fb7c3914be11f1e9cd5891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sxfMA18nshPmpzLGIqKxg.png"/></div></div></figure><p id="02f1" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">如果你看一下<a class="ae ln" href="https://github.com/sapegin/jest-cheat-sheet" rel="noopener ugc nofollow" target="_blank"> Jest小抄</a>，你可以看到匹配器。toBe检查严格相等===。但是，两个对象永远不是同一个对象。</p><p id="1c53" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">它们可能包含相同的属性和值，但这并不表示它们相等，因为两个对象在内存中占用不同的地址或空间。</p><p id="fb4d" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">有一种方法可以让<a class="ae ln" href="https://dmitripavlutin.com/how-to-compare-objects-in-javascript/" rel="noopener ugc nofollow" target="_blank">检查</a>一个对象的内容是否包含相同的属性和值，这就是所谓的“深度相等”或“深度相等”。如果你看了这条消息，Jest建议我们使用“toStrictEqual”来检查深度相等，这听起来有点令人困惑。</p><p id="6ecb" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">更好的解决方案是:Jest有匹配器”。这让我们的意图更加明确。因此，让我们交换匹配器，我们的测试现在都应该通过了:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mr"><img src="../Images/346133f643443541c87f7970bdad825c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajuoWb7me2FQAEZ2idJ-eQ.png"/></div></div></figure><p id="0e82" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">值得注意的是，您可以在同一个文件中为您正在测试的每个单元编写多个测试。确保你收藏了<a class="ae ln" href="https://github.com/sapegin/jest-cheat-sheet" rel="noopener ugc nofollow" target="_blank">笑话小抄</a>！</p><h2 id="8856" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">等待测试</h2><p id="d9c1" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">如果希望node监视对。js文件，这样您就不必一遍又一遍地输入<code class="fe mm mn mo lt b">$ npm test </code>，只需将以下代码添加到package.json中的测试脚本中，运行<code class="fe mm mn mo lt b">$ npm test</code>，测试就会在您对. js文件进行更改的任何时候自动运行。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="00ac" class="jr js in lt b gy lx ly l lz ma">--watch *.js </span></pre><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/0cd90e386de30d3d329b39ee58ff4b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*ZU-dnlOsPPL-B5SsQ9SHaA.png"/></div></figure><p id="5662" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">一如既往，感谢阅读。欢迎在<a class="ae ln" href="https://www.linkedin.com/in/kylefarmer85/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我！</p><p id="f7ff" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated"><em class="mp">更多内容请看</em><a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kp io"><em class="mp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>