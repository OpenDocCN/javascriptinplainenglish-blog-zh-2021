<html>
<head>
<title>Node.js: Create Job Queue Using Bull And Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js:使用Bull和Redis创建作业队列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-create-job-queue-using-bull-and-redis-20fabcee60c5?source=collection_archive---------0-----------------------#2021-08-24">https://javascript.plainenglish.io/node-js-create-job-queue-using-bull-and-redis-20fabcee60c5?source=collection_archive---------0-----------------------#2021-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b4f75b84b81c0dd36a02d375dc4bf1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PKIEFGva29lOKU1RAOeMA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd jz"><em class="ka">Examples of architectural drawings</em></strong></figcaption></figure><h1 id="69c0" class="kb kc in bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="54ef" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">队列可以以一种有趣的方式解决许多不同的问题，通过将繁重的进程分散到其他服务器来减少一台服务器上的进程负载。在Nodejs中，有一些很好的库可以用于排队过程，比如<strong class="lb io"> <em class="lx">、蜜蜂队列</em> </strong>、<strong class="lb io"> <em class="lx">公牛</em> </strong>等等。在本练习中，我们将使用一只<strong class="lb io"> <em class="lx">公牛</em> </strong>进行尝试。简单的案例研究用户想要下载数据，这里我将给出一个带有少量虚拟数据的例子。</p><p id="e2e5" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">在这里，我们将创建两个具有不同角色的应用程序，如下所示:</p><ul class=""><li id="e9a4" class="md me in lb b lc ly lg lz lk mf lo mg ls mh lw mi mj mk ml bi translated"><strong class="lb io"> Producer </strong>:添加任务到队列的节点程序</li><li id="421e" class="md me in lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb io">消费者</strong>:定义流程功能的节点程序，以及要做的工作</li></ul><h1 id="4bfa" class="kb kc in bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">创建应用程序</h1><p id="58df" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">首先，创建一个文件夹，并在终端中使用以下命令初始化我们的应用程序，指向之前创建的文件夹:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a1eb" class="na kc in mw b gy nb nc l nd ne">$ npm init</span></pre><p id="e34a" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">初始化完成后，我们将安装<strong class="lb io"> <em class="lx"> bull </em> </strong>和<strong class="lb io"> <em class="lx"> dotenv </em> </strong>包，在终端中使用以下命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2a2f" class="na kc in mw b gy nb nc l nd ne">$ npm install bull dotenv</span></pre><p id="66c5" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">然后创建一个名为<strong class="lb io"> <em class="lx"> config.js </em> </strong>的文件，输入如下所示的代码，对于<strong class="lb io"> <em class="lx"> REDIS_HOST </em> </strong>和<strong class="lb io"> <em class="lx"> REDIS_PORT </em> </strong>变量，填写它们拥有的REDIS主机和端口。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/f606011eb4561251b91c55e94fb60ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkqCwxHto1OCls-XdOa6SA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd jz">config.js</strong></figcaption></figure><p id="c9c6" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">然后创建一个名为<strong class="lb io"> <em class="lx"> handler.js，consumer.js </em> </strong>和<strong class="lb io"> <em class="lx"> produer.js </em> </strong>的文件，如下所示:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="ak"><em class="ka">handler.js</em></strong></figcaption></figure><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="ak">producer.js</strong></figcaption></figure><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="ak">consumer.js</strong></figcaption></figure><p id="4fa9" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">现在让我们测试应用程序，首先，我们使用1分钟的延迟测试应用程序，打开两个终端，导航到我们的文件夹，并按照下面的视频运行它:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="ni nh l"/></div></figure><p id="67f2" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">如果您不希望队列中有任何延迟，那么您可以在本节producer.js的delay部分注释代码。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/612463602d12217dda95b6309c4de25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*VzYZ3KpwT_pREQE4VLs-wQ.png"/></div></figure><h1 id="ba92" class="kb kc in bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="e9bd" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">队列有<strong class="lb io"> <em class="lx">先进先出</em> </strong>的概念，可以将同时(异步)进行的订单映射为依次(同步)进行。</p><p id="8363" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">在一个真实的案例中，我使用queue with bull将超过100万个数据导出为<strong class="lb io"> <em class="lx"> xlsx </em> </strong>格式。它不会降低服务器速度，导出时也很流畅。</p><p id="a04f" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">完整源代码的链接在这里。</p><div class="nk nl gp gr nm nn"><a href="https://github.com/firmanJS/producer-consumer-example" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd io gy z fp ns fr fs nt fu fw im bi translated">GitHub-firmanJS/生产者-消费者-示例</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在GitHub上创建一个帐户，为firmanJS/生产者-消费者示例开发做出贡献。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div></div></a></div><p id="d9f9" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated">感谢您的阅读！</p><p id="b173" class="pw-post-body-paragraph kz la in lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw ig bi translated"><em class="lx">更多内容请看</em><a class="ae nw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="lx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>