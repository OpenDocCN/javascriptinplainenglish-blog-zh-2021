<html>
<head>
<title>Replacing Create-React-App With Snowpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Snowpack替换Create-React-App</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/replace-create-react-app-with-snowpack-6a979e65ab90?source=collection_archive---------4-----------------------#2021-03-07">https://javascript.plainenglish.io/replace-create-react-app-with-snowpack-6a979e65ab90?source=collection_archive---------4-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="350d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置构建工具和捆绑器是任何前端开发人员工作流程的重要部分。但通常，它感觉更像是开发真正乐趣的阻碍。虽然最新的<a class="ae kl" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>需要的启动工作比以前少得多，但它仍然远远不能满足开箱即用的所有需求。</p><p id="69d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我开始使用<a class="ae kl" href="https://www.snowpack.dev/" rel="noopener ugc nofollow" target="_blank"> Snowpack </a>作为前端捆扎机。我第一次听说它是在2020年JavaScript开源大会上，Snowpack获得了<a class="ae kl" href="https://osawards.com/javascript/2020" rel="noopener ugc nofollow" target="_blank">生产力助推器</a>奖。我现在已经在一个企业项目中非常轻松地使用了它。并将我的个人网站从使用<a class="ae kl" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> Create-React-App </a> (CRA)转换成Snowpack。</p><p id="96f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章旨在强调积雪场的好处，以及用积雪场取代CRA所需的几个步骤。(跳过重点部分，滚动到“好东西”部分查看分步指南。)</p><p id="1dca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TLDR；创建-反应-应用和需要弹出</strong></p><p id="b088" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像React、Vue、Angular这样的前端框架都有它们建议的或内置的启动器来帮助引导项目。</p><p id="4aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于React项目，常见的入门工具是官方CRA，它为您提供了从代码质量、构建、捆绑和测试工具的完整工具链。开始React项目的便捷方式。它提供了一个问题的解决方案，我认为这有助于推动当时React的采用。</p><p id="5c77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在许多项目中使用过CRA，从小型到大型。对于很少定制的项目来说，这是非常完美的。它对于独立的React站点尤其适用。但是如果项目需要任何超出其规定的文件组织、配置模式的定制，或者需要与后端结合，CRA肯定是不灵活或不可扩展的。</p><p id="dfbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常情况下，最后也是唯一的方法是弹出或者<a class="ae kl" href="https://create-react-app.dev/docs/alternatives-to-ejecting/" rel="noopener ugc nofollow" target="_blank">分叉react-scripts和依赖关系</a>。但是这个选择是全有或全无。一旦你离开了CRA(或者尝试了其他选择)，你仍然会留下一个非常复杂的基于Webpack的工具链。大量的Babel/TypeScript、Jest和其他依赖项需要处理。对于正在进行开发来说，试图维护它们并不是一个小任务。</p><p id="da60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用Snowpack，这是一个比自己处理所有复杂问题更好的选择。</strong></p><p id="1f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TLDR；关于积雪场的一些亮点</strong></p><p id="600f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.snowpack.dev/" rel="noopener ugc nofollow" target="_blank"> Snowpack </a>是一个前端构建工具，提供了许多现代web开发常用的<a class="ae kl" href="https://www.snowpack.dev/reference/supported-files" rel="noopener ugc nofollow" target="_blank">开箱即用文件支持</a>，以及像<a class="ae kl" href="https://www.snowpack.dev/concepts/hot-module-replacement" rel="noopener ugc nofollow" target="_blank">热模块替换</a> (HMR)和<a class="ae kl" href="https://www.snowpack.dev/concepts/dev-server" rel="noopener ugc nofollow" target="_blank">开发服务器</a>这样的特性。</p><p id="0969" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是轻量级的，启动时只需要很少的配置。要启动一个全新的React项目，我们可以使用<a class="ae kl" href="https://github.com/snowpackjs/snowpack/tree/main/create-snowpack-app/cli" rel="noopener ugc nofollow" target="_blank">Create-snow pack-App</a>(CSA)CLI。不像CRA，它一旦产生就不会把我们锁在里面。CSA是一个更像约曼的脚手架CLI。我们可以选择从空白的JavaScript、TypeScript或特定于框架的模板开始。例如:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="6119" class="kv kw iq kr b gy kx ky l kz la">npx create-snowpack-app new-dir --template <a class="ae kl" href="http://twitter.com/snowpack/app-template-react-typesc" rel="noopener ugc nofollow" target="_blank">@snowpack/app-template-react-typesc</a>ript</span></pre><p id="b2d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Snowpack和Webpack的另一个关键特性和区别是<a class="ae kl" href="https://www.snowpack.dev/concepts/how-snowpack-works#unbundled-development" rel="noopener ugc nofollow" target="_blank">非捆绑开发</a>。这带来了闪电般的确定性开发体验，尤其是在与HMR结合的时候。为此，Snowpack利用了现代浏览器的ESM支持。<em class="lb">这里需要注意的是，本地开发环境不支持在IE11这样的旧浏览器中构建。</em></p><p id="b07a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Snowpack中有许多更令人兴奋的设计选择和功能，如<a class="ae kl" href="https://www.snowpack.dev/reference/javascript-interface" rel="noopener ugc nofollow" target="_blank"> API接口</a>、<a class="ae kl" href="https://www.snowpack.dev/guides/streaming-imports#nav-primary" rel="noopener ugc nofollow" target="_blank">流导入</a>、<a class="ae kl" href="https://www.snowpack.dev/guides/server-side-render#option-3%3A-server-side-rendering-(ssr)" rel="noopener ugc nofollow" target="_blank">带节点运行时的SSR</a>，以及使用<a class="ae kl" href="https://www.snowpack.dev/guides/optimize-and-bundle#option-1%3A-built-in-optimizations" rel="noopener ugc nofollow" target="_blank"> esbuild </a>的可选内置优化，当esbuild本身更加成熟时，这将是一个很好的功能。想了解更多关于积雪场的概念，这里有一个来自创造者 @FredKSchott的<a class="ae kl" href="https://www.youtube.com/watch?v=65R4th-rixM" rel="noopener ugc nofollow" target="_blank">演讲。</a></p><h1 id="63ae" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">好东西——用积雪包替换的步骤</h1><h2 id="51c2" class="kv kw iq bd ld lz ma dn lh mb mc dp ll jy md me lp kc mf mg lt kg mh mi lx mj bi translated"><strong class="ak"> 1。更新Package.json:依赖关系</strong></h2><p id="e7e2" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">移除<code class="fe mp mq mr kr b">react-scripts</code>并添加以下当前版本的包:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="0d34" class="kv kw iq kr b gy kx ky l kz la"><em class="lb">"@snowpack/app-scripts-react"</em>: "^2.0.0", // has useful defaults<br/><em class="lb">"@snowpack/plugin-dotenv"</em>: "^2.0.5", // env variables like CRA<br/><em class="lb">"@snowpack/plugin-react-refresh"</em>: "^2.4.0", // Fast refresh<br/><em class="lb">"snowpack-plugin-svgr"</em>: "^0.1.2", // to import SVG as components<br/><em class="lb">"@snowpack/plugin-webpack"</em>: "^2.3.0", // to optimize prod build<br/><em class="lb">"jest"</em>: "^26.6.3", // testing using your jest.config<br/><em class="lb">"serve"</em>: "^11.3.2", // to serve up static prod build like CRA<br/><em class="lb">"snowpack"</em>: "^3.0.1",</span></pre><p id="8c23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个最基本的包列表，你需要它为React JS项目提供一个非常相似的CRA环境，同样支持<strong class="jp ir"> env vars </strong>、<strong class="jp ir">快速刷新</strong>，以及导入<strong class="jp ir"> SVG作为React组件</strong>。CRA也来了个笑话和静发球。所以我们也把这些加进去。(见结尾关于Jest设置的注释)。</p><p id="9069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于TypeScript项目，添加这两个附加项目:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="903c" class="kv kw iq kr b gy kx ky l kz la"><em class="lb">"@snowpack/plugin-typescript"</em>: "^1.2.1",<br/><em class="lb">"@types/snowpack-env"</em>: "^2.3.2",</span></pre><p id="d3ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lb">值得注意的是，Snowpack使用TypeScript进行类型检查而不是transpile。在引擎盖下，它仍然与巴别塔一起运输(与CRA的行为相同)。</em></p><h2 id="6292" class="kv kw iq bd ld lz ma dn lh mb mc dp ll jy md me lp kc mf mg lt kg mh mi lx mj bi translated">2.<strong class="ak">更新Package.json脚本</strong></h2><p id="8e7e" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">将以<code class="fe mp mq mr kr b">react-scripts</code>命令开始的<code class="fe mp mq mr kr b">serve</code>、<code class="fe mp mq mr kr b">build</code>和<code class="fe mp mq mr kr b">test</code>脚本替换为:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="eced" class="kv kw iq kr b gy kx ky l kz la">"start": "snowpack dev --reload",    <br/>"build": "snowpack build",    <br/>"test": "npx jest", </span><span id="3146" class="kv kw iq kr b gy ms ky l kz la">//optional nice to have:<br/><em class="lb">"test-watch"</em>: "npx jest --watch",<br/><em class="lb">"test-coverage"</em>: "npx jest --coverage",</span></pre><p id="d811" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个<code class="fe mp mq mr kr b">serve-prod</code>命令应该不需要改变。当然，让我们也删除<code class="fe mp mq mr kr b">eject</code>命令。CRA还附带了一个<code class="fe mp mq mr kr b">lint</code>命令和eslint设置，我们将在后面介绍。</p><h2 id="35c5" class="kv kw iq bd ld lz ma dn lh mb mc dp ll jy md me lp kc mf mg lt kg mh mi lx mj bi translated">3.<strong class="ak">添加了</strong> <code class="fe mp mq mr kr b"><strong class="ak">snowpack.config.js</strong></code></h2><p id="348c" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在这一点上，我们几乎准备好开始使用snowpack。接下来，我们将设置我们的snowpack配置文件。</p><p id="7134" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是大多数支持类型脚本和SPA <a class="ae kl" href="https://www.snowpack.dev/guides/routing#scenario-1%3A-spa-fallback-paths" rel="noopener ugc nofollow" target="_blank">回退路由</a>的React SPAs的配置示例。所有可用选项参见<a class="ae kl" href="https://www.snowpack.dev/reference/configuration" rel="noopener ugc nofollow" target="_blank">正式文件</a>。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="f231" class="kv kw iq kr b gy kx ky l kz la">/** <em class="lb">@type</em> {import("snowpack").SnowpackUserConfig } */</span><span id="eca3" class="kv kw iq kr b gy ms ky l kz la"><em class="lb">module</em>.<em class="lb">exports</em> = {</span><span id="c98a" class="kv kw iq kr b gy ms ky l kz la">mount: {<br/> public: {url: '/', static: true},<br/> src: {url: '/dist'},<br/>},</span><span id="c4fe" class="kv kw iq kr b gy ms ky l kz la">plugins: [ <br/>'@snowpack/plugin-react-refresh', <br/>'@snowpack/plugin-dotenv', <br/>'@snowpack/plugin-webpack', <br/>'@snowpack/plugin-typescript', // TS support<br/>'snowpack-plugin-svgr' // import SVG as React component<br/>],</span><span id="927e" class="kv kw iq kr b gy ms ky l kz la">/* for local SPA fallback routing support, more below */<br/>routes: [<br/>  {"match": "routes", "src": ".*", "dest": "/index.html"},<br/>],</span><span id="fbb1" class="kv kw iq kr b gy ms ky l kz la">devOptions: {<br/>  port: 3000,<br/>},</span><span id="4a5b" class="kv kw iq kr b gy ms ky l kz la">testOptions: {<br/>  files: ['src/**/*.test.*']<br/>},</span><span id="8353" class="kv kw iq kr b gy ms ky l kz la">/* optional, if you want to use alias when importing */<br/>alias: {<br/>  "@app": "./src/",<br/>}</span><span id="8802" class="kv kw iq kr b gy ms ky l kz la">};</span></pre><p id="2135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> SPA </strong> <a class="ae kl" href="https://www.snowpack.dev/guides/routing#scenario-1%3A-spa-fallback-paths" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">回退路由</strong> </a> <strong class="jp ir">在本地开发</strong>默认情况下被CRA封装。这对于任何有不止一条基本路线供用户直接导航的应用程序来说都是相当典型的。</p><p id="696c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Snowpack中的<strong class="jp ir">路线</strong>部分对于更接近地模拟应用程序的生产环境非常有用。例如，在生产中，我们提供一个您的React SPA无法处理的自定义404页面。</p><p id="fc05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用路由，Snowpack的另一个本地开发特性，如CRA，能够用相同的基域代理API请求。这是SPA +微服务架构的另一个典型生产设置。与CRA不同，Snowpack的灵活路线可以让你对代理行为进行更精细的控制。</p><p id="bb12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要代理和SPA回退，我建议这样设置(按顺序):</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="3121" class="kv kw iq kr b gy kx ky l kz la">const httpProxy = require('http-proxy');<br/>const proxy = httpProxy.createServer({ target: 'http://localhost:3001' });</span><span id="8e9e" class="kv kw iq kr b gy ms ky l kz la">.....skip....</span><span id="41db" class="kv kw iq kr b gy ms ky l kz la">routes: [<br/>    { match: 'all', src: '/api/.*', dest: (req, res) =&gt;     <br/>      proxy.web(req, res) <br/>    },<br/>    { match: 'routes', src: '.*', dest: '/index.html' },<br/>],</span></pre><h2 id="5cae" class="kv kw iq bd ld lz ma dn lh mb mc dp ll jy md me lp kc mf mg lt kg mh mi lx mj bi translated">4.<strong class="ak">(可选，TS使用)更新</strong> <code class="fe mp mq mr kr b"><strong class="ak">tsconfig.json</strong></code></h2><p id="7cfa" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">对于一个TypeScript项目，你<em class="lb">不应该</em>需要调整你的tsconfig.json太多。事实上，不像CRA会自动格式化并删除某些定义，Snowpack可以让你做任何你想做的事情。</p><p id="07b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些微小的变化是建议有一个更灵活的指向root而不是<code class="fe mp mq mr kr b">src</code>的baseUrl配置，并像我在snowpack.config.js中做的那样添加相同的<a class="ae kl" href="https://www.snowpack.dev/reference/configuration#alias" rel="noopener ugc nofollow" target="_blank">绝对别名导入</a>路径我的本地组件。</p><figure class="km kn ko kp gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mt"><img src="../Images/867d07f3ff1936c4750d7ed03b5ce6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h27br3izq4_QHANe2HtGnQ.png"/></div></div></figure><h2 id="8f9f" class="kv kw iq bd ld lz ma dn lh mb mc dp ll jy md me lp kc mf mg lt kg mh mi lx mj bi translated">5.<strong class="ak">更新</strong> <code class="fe mp mq mr kr b"><strong class="ak">process.env</strong></code> <strong class="ak">至</strong><code class="fe mp mq mr kr b"><strong class="ak">import.meta.env</strong></code><strong class="ak">&amp;public/index . html</strong></h2><p id="de47" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">首先，也是最重要的，把这个添加到你的<code class="fe mp mq mr kr b">public/index.html</code>文件中。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="4a0f" class="kv kw iq kr b gy kx ky l kz la">&lt;script type=”module” src=”/dist/index.js”&gt;&lt;/script&gt;</span></pre><p id="a5e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是你的应用程序如何启动一个非绑定的本地开发。不用担心，在产品构建期间，webpack插件将生成适当的缩小和分割的JS文件，以链接到部署的index.html上。</p><p id="6223" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，继续从index.html移除<code class="fe mp mq mr kr b">PUBLIC_URL/</code>，只要这些资产在<code class="fe mp mq mr kr b">public</code>文件夹中，在产品构建时，snowpack会正确放置它们。</p><p id="078a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，Snowpack对环境变量有自己的<a class="ae kl" href="https://www.snowpack.dev/reference/environment-variables" rel="noopener ugc nofollow" target="_blank">约定</a>。只需将任何<code class="fe mp mq mr kr b">process.env</code>引用替换为<code class="fe mp mq mr kr b">import.meta.env</code>。任何以<code class="fe mp mq mr kr b">PUBLIC_</code> CRA公约到<code class="fe mp mq mr kr b">SNOWPACK_PUBLIC_</code>开头的环境变量。</p><figure class="km kn ko kp gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nb"><img src="../Images/dc8821b29eb1452cbdbb03276e5ae274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SRfUY7sXqMddCLY7TKe86w.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">index.html from CRA vs for Snowpack</figcaption></figure><h2 id="f9e6" class="kv kw iq bd ld lz ma dn lh mb mc dp ll jy md me lp kc mf mg lt kg mh mi lx mj bi translated">我们完成了！</h2><p id="fc12" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在运行<code class="fe mp mq mr kr b">npm run start</code>在本地启动应用程序，运行<code class="fe mp mq mr kr b">npm run serve-prod</code>使用静态服务。</p><p id="9483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有专门的Webpack配置来优化你的产品版本，请查看官方的snowpack webpack插件文档，了解如何快速添加定制配置。</p><h2 id="6f4f" class="kv kw iq bd ld lz ma dn lh mb mc dp ll jy md me lp kc mf mg lt kg mh mi lx mj bi translated"><strong class="ak">关于杰斯特、林挺和Svgr的更多注释:</strong></h2><ol class=""><li id="156d" class="ng nh iq jp b jq mk ju ml jy ni kc nj kg nk kk nl nm nn no bi translated"><code class="fe mp mq mr kr b">jest -init</code>启动新文件或使用现有文件。连接所有需要的巴别塔转换的最简单的方法是从雪堆默认值开始。从<code class="fe mp mq mr kr b">@snowpack/app-scripts-react </code>导入开始就很容易了。任何定制都可以从中扩展:</li></ol><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="2616" class="kv kw iq kr b gy kx ky l kz la"><em class="lb">const</em> snowpackJestConfig = require('@snowpack/app-scripts-react/jest.config.js')();</span><span id="6b38" class="kv kw iq kr b gy ms ky l kz la"><em class="lb">module</em>.<em class="lb">exports</em> = {<br/>...snowpackJestConfig,<br/>[custom overrides here]</span></pre><p id="8c80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.要使用SVG作为反应组件来测试组件，请查看如何使用几行代码来模拟 <code class="fe mp mq mr kr b">svgr</code>进行Jest单元测试。</p><p id="1bbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<code class="fe mp mq mr kr b">require</code>不适用于未捆绑的当地开发。将需要使用动态导入。</p><p id="b163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.CRA得到了Eslint的支持和一个<code class="fe mp mq mr kr b">npm run lint</code>。两者都非常有帮助。要继续使用，请<a class="ae kl" href="https://www.npmjs.com/package/eslint-config-react-app#usage-outside-of-create-react-app" rel="noopener ugc nofollow" target="_blank">安装CRA使用的eslit-config</a>，并按照步骤进行操作。</p></div></div>    
</body>
</html>