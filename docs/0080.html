<html>
<head>
<title>Internationalization (i18n) in Large Microfrontend Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大型微前端系统的国际化(i18n)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/npm-i18n-internationalization-25da8201b3b8?source=collection_archive---------6-----------------------#2021-01-05">https://javascript.plainenglish.io/npm-i18n-internationalization-25da8201b3b8?source=collection_archive---------6-----------------------#2021-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4bfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当实现微前端和/或私有NPM模块时，我们需要在整个系统中保持一致的国际化。每个模块都应该使用同一来源的通用文本和翻译。在本帖中，我将分享我在这方面的经验。一切都极其简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4290b230d93a48d02c6fd5e97227c66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dwtl3DOfQ8GnLtp7"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@plhnk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paul Hanaoka</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="0aac" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">我们的方式</h2><p id="e272" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们需要创建一个私有的NPM包，包含所有常见的翻译/文本+一个实例来初始化它们。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="0751" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">第一步。准备</h2><p id="d03f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">第一步是创建一个私有的NPM包。我不会描述完整的创建过程，互联网上有很多这样的信息。我唯一的建议是命名新的NPM包<code class="fe me mf mg mh b">@scope-name/translations</code>。它应该是一个单独的包，系统中的其他模块将在这个包的基础上构建。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="063d" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">第二步。履行</h2><p id="0a5a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们的翻译将被创建为TypeScript方言中的基本常量。有些情况下，开发人员会像json文件一样加载<strong class="jm io"> i18n </strong>并异步初始化它们，但在我看来，就浏览器的“网络”负载而言，这并不是最佳选择。现在，我们将把必要的翻译直接注入到我们的js块中。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="54f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此时只有页面/组件所需的翻译将被嵌入到块中。有条件地，<strong class="jm io">我们正在国际化层面上实现树抖动</strong>。相比之下，<code class="fe me mf mg mh b">i18n.json</code>异步加载方法有一个数据过剩的问题:它要么下载100多个小文件，要么在单个json文件中加载比当前所需多得多的翻译。</p><p id="b55c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顺便说一下，在<a class="ae ky" href="https://podumaihorosho.medium.com/npm-packages-in-ts-modules-format-7f64aa87591" rel="noopener">上一篇文章</a>中，我谈到了<strong class="jm io"> ts-modules </strong>，其中我谈到了将TypeScript源代码发布到NPM包的好处。翻译也将作为源代码发布，我们仍然使用<a class="ae ky" href="https://www.npmjs.com/package/copy" rel="noopener ugc nofollow" target="_blank">副本</a>来准备<code class="fe me mf mg mh b">public</code>版本。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="abd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，让我们为通知创建一个通用转换常数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/de377c0ae39c63c5655fddc5535ba6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXocZuYyqM_ffFyiamnj2Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">@scope-name/translations/src/consts/Translations/en/Common/Notification.ts</figcaption></figure><p id="602f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将所有的翻译收集在一起，并发送给一个公共的i18n实例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/6b10ee1ce00714e88d7f400fb4b367e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uujqf7s_4IdVEkhUDG69g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">@scope-name/translations/src/consts/Translations/en/Common/index.ts</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/0c9d4c89beb82157c784be13c0516448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_FOLnINXQY6dwRIib5EdbQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">@scope-name/translations/src/i18nCommon.ts</figcaption></figure><p id="8537" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为创建i18n实例创建了一个特殊的工厂函数，首先，除了这个NPM包之外，这个实用程序还可以在微前端和项目的主应用程序中创建翻译，例如，为一些独立的组件创建翻译。让我们仔细看看这个实用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/60de8b7bd0f0bd5615fce8dbfd2dee67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBR2MSW8MpKUu10Q4XmecQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">@scope-name/translations/src/utils/i18nCreateInstance.ts</figcaption></figure><p id="fd51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe me mf mg mh b">i18nCreateInstanceSync</code>函数允许我们从常量创建翻译实例。和Async函数是通过json-file创建实例所需要的(遗留方法的后备)。在下文中，我将只考虑同步函数。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="c20e" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">第三步——使用</h2><p id="e827" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当将带翻译的NPM包连接到主应用程序或微前端，或独立的NPM包(例如，组件库)时，我们只需导入i18n实例并使用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/dc61b99155f53abb0c839ef7fa25652d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIQFAqUGa7rFhMqgLKGDbA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Using common translations from NPM</figcaption></figure><p id="c3ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也可以通过常规导入在实用函数中使用翻译。在我们的系统中，早些时候，我们在组件级别接收翻译，并通过组件和功能的整个树将带有i18n-instance的props代理给消费者。现在我们直接用在需要的地方。例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/6919d711a41a02dbc8a73369061d75f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcQf5ZPXMBaISTCPc32Q_g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">No ‘junk’ props + translations are allowed anywhere</figcaption></figure><blockquote class="mn mo mp"><p id="e933" class="jk jl mq jm b jn jo jp jq jr js jt ju mr jw jx jy ms ka kb kc mt ke kf kg kh ig bi translated">T <!-- -->感谢发布带翻译的<strong class="jm io"> TS-constants </strong>的源代码，如果现成的i18nextCommon实例的冗余不适合我们，我们可以使用预制的<strong class="jm io"> TS-constants </strong>构建我们自己的通用翻译实例。即给予消费者完全的行动自由。</p></blockquote></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="7783" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">步骤4 —创建本地翻译</h2><p id="e804" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">因为除了NPM包中的翻译本身，我们额外提供了一个创建i18n实例的函数，这意味着我们可以创建自己的实例(例如，改善项目的语义)。</p><p id="f575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们现在在自己的微前端工作，我们需要将项目的业务实体划分为i18n个实例。为此，我们必须重复本文中的<code class="fe me mf mg mh b">Step 2</code>，使用<code class="fe me mf mg mh b">i18nCreateInstanceSync</code>函数，但是带有本地翻译。</p><p id="eea3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们实现了项目的每个业务实体的翻译都在自己的i18n实例中，例如:<code class="fe me mf mg mh b">i18nextIssue</code>、<code class="fe me mf mg mh b">i18nextLetters</code>、<code class="fe me mf mg mh b">i18nextUsers</code>、<code class="fe me mf mg mh b">i18nextCommon</code>。只有这个列表的最后一个在系统的所有微前端之间是公共的，其余的都是本地的。如果您需要代理或以某种方式同步使用这些实例，这将是非常语义化的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/deab2355ac665f310fd1428b8c5d5072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4skDbVLXxRfLdwiTQe5UQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Semantics of decomposed i18n-instances</figcaption></figure></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="0660" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">安排</h2><p id="4aa7" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们<strong class="jm io">不直接使用</strong>任何没有常量的文本。这是可重用的，系统的文本库保持干净+将来创建i18n-实例更容易。</p><p id="7f48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，如果翻译<strong class="jm io">不需要</strong> i18n功能，例如，动态语言变化、词尾变化、翻译中的变量等。—然后我们以导入一个<strong class="jm io"> TS-constant </strong>的形式直接使用翻译，而不需要创建一个单独的i18n实例。</p><p id="20fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了优化对i18n实例的调用，可以使用currying，例如，通过传递当前语言的参数。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="c8c6" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">结论</h2><p id="788a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">开发人员不应该忘记<strong class="jm io"> DRY </strong>即使是在国际化这样看似简单的话题中。尤其是在大型微前端系统中。</p></div></div>    
</body>
</html>