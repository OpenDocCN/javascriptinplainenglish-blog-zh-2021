<html>
<head>
<title>How To Remove Duplicate Code Properly From Your App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从应用程序中正确删除重复代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-the-dry-principle-properly-21fd354b48c3?source=collection_archive---------11-----------------------#2021-02-04">https://javascript.plainenglish.io/how-to-use-the-dry-principle-properly-21fd354b48c3?source=collection_archive---------11-----------------------#2021-02-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="94be" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">减少重复代码是软件开发中可伸缩性的一个核心方面，但是知道何时停止是很重要的</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/edcb3a830d4b565eda84682f9a299dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dAO0kT0oU_pTEvIJ"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@matthewhenry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matthew Henry</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b88c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">删除重复代码是一个容易理解的概念，但它对代码质量和可伸缩性有深远的影响。尽管实现起来很简单，但删除重复或遵循DRY原则肯定可以用在难以处理的地方。这就是我们将要在这里讨论的，正确地合并代码，这样它就不会在以后回来困扰你。</p><h1 id="7ae7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">1.遵循单一责任原则(SRP)</h1><p id="4e00" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在将DRY实现到您的逻辑中时，SRP是一个需要牢记的非常重要的原则。尽管听起来比DRY更复杂，SRP是另一个理解起来相当简单的概念。它基本上说明了一个函数、类或模块应该做一件事，而且应该做得很好。如果我们在将重复代码移入一个函数时不遵循这个规则，那么处理先前重复代码的函数在以后的维护中会变得混乱。举个例子，我经常遇到这种情况，你看到的重复代码并不完全相同，而是非常相似。这使得将类似的代码放入函数中并简单地传递几个参数来使函数处理这两种情况变得很有诱惑力。传入一些参数是好的，重要的是它们在函数中的用途是什么。</p><p id="c334" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">避免使用参数来处理不同的情况，除非将类似的代码合并到一个函数中。例如，如果你需要添加一个<code class="fe mm mn mo mp b">if()</code>语句来合并“重复”的代码，那么它就不是重复代码，它是相似的。所以不要合并。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="eec0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">传入的参数应该是字符串而不是布尔值。对于字符串，您可以使用括号符号，并动态地更改您用单个参数引用的属性或函数。</p><p id="2ce5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，假设您在React中有一个布尔属性，或者在函数中有一个参数。布尔型被称为<code class="fe mm mn mo mp b"> isLoading.</code>，因为它只能支持两个值(真/假),它被限制在它所能表达的范围内。如果我们想知道一个api是否失败了呢？<code class="fe mm mn mo mp b"> isLoading</code> <em class="ms"> </em>无法告诉我们，传递另一个参数/道具怎么样？现在我们要同时兼顾两个布尔，<em class="ms"> </em> <code class="fe mm mn mo mp b">isLoading</code>和<code class="fe mm mn mo mp b"> isError</code> <em class="ms">。</em>参数/属性列表增加了，布尔检查多了，不好。让我们尝试一个字符串，并将其命名为<code class="fe mm mn mo mp b">apiStatus</code> <em class="ms">。</em>该属性可以取各种值，现在让我们将期望值设置为<code class="fe mm mn mo mp b">“loading”, “loaded”, “error”</code>。如果我们做对了，我们甚至不需要函数中的If()语句来决定基于<code class="fe mm mn mo mp b">apiStatus</code>值做什么。</p><p id="18d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以使用括号符号来自动引用我们想要的行为，就像这样:<code class="fe mm mn mo mp b">handleStatus[apiStatus]();</code> <em class="ms"> </em>这看起来像是一个跳转，但基本上我们使用的是一个对象<code class="fe mm mn mo mp b"> handleStatus </code>，它内部有一系列函数，这些函数与值<code class="fe mm mn mo mp b">apiStatus</code> <em class="ms"> </em>匹配。</p><p id="8ea8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个使用括号符号的例子中，如果<code class="fe mm mn mo mp b">apiStatus = “loading”,</code> <em class="ms"> </em> <code class="fe mm mn mo mp b">handleStatus[apiStatus]();</code> <em class="ms"> </em>将与<code class="fe mm mn mo mp b">handleStatus.loading();</code> <em class="ms"> </em>相同，只需在末尾加上括号()；我们正在调用<code class="fe mm mn mo mp b">apiStatus</code>找到的函数。</p><p id="dce7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">遵循这些要点，并使用SRP原则保持您的干代码将有助于确保代码保持易于维护。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="17b0" class="lp lq in bd lr ls na lu lv lw nb ly lz jt nc ju mb jw nd jx md jz ne ka mf mg bi translated">2.循环可能是限制性的</h1><p id="2b6f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">这是我亲身经历的，发现了使用循环采用干原则的缺陷。我遇到了一个React组件，它多次重用了同一个子组件，只是为参数传递了不同的值。我想我可以把这个子组件放在一个循环中，然后给它一个对象数组。它在不同的地方进行了一些重构，比如将一些不同的对象合并成一个数组，以便于循环。</p><p id="6cc1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使整个设置更加复杂的部分是，它涉及从一个数据源获取数据并将其转换为数组，然后对另一个数据源执行相同的过程并将其转换为数组。完成后，我将数组合并在一起，这样我就可以循环遍历它，并将该项传递给子组件。DRY成功地实现了，所有人都很高兴，至少在一段时间内。</p><p id="fc1c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">后来，使用这种循环方法的一个父组件出现了api问题，需求发生了变化，因此在api问题得到解决之前，我们不可能对该父组件使用循环方法。我们的决定是注释掉循环设置，并重新实现之前的直接调用设置，这样我们就可以控制数组中的哪一项将被显示，而其他项将被跳过。这是使用循环出现问题的第一个迹象。</p><p id="85bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">出现的第二种情况迫使我们使用一种难看的设置来解决循环的僵化问题，那就是根据条件将一个值更改为null，然后在循环过程中检查该值是否为null。没有人乐意这样做。所以现在调用了refactor来移除React应用程序中的这个循环。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="fbdd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当使用循环来删除重复代码时，可以遵循以下一些准则:</p><ul class=""><li id="a833" class="nf ng in kv b kw kx kz la lc nh lg ni lk nj lo nk nl nm nn bi translated">在执行旨在解决干原理的循环之前，不要将循环合并在一起。这样做将要求合并在一起的其他循环彼此保持同步。</li><li id="2e3f" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">在某种情况下，可能会出现一个要求，要求您删除循环中的一个项目。由于要管理多个循环，可能很难从两个数组中删除正确的项目。如果这没有正确发生，最终结果将是一个数组中的第一项与另一个数组中的第二项混合。</li><li id="40d5" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">不要试图添加逻辑，这样就不会发生这种情况，重构，这样就不需要逻辑了。如果可以的话，基本上避免混合数组。它会变得很乱。</li></ul></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="66de" class="lp lq in bd lr ls na lu lv lw nb ly lz jt nc ju mb jw nd jx md jz ne ka mf mg bi translated">3.各个击破</h1><p id="6a7f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">不要吃超过你的能力所能消化的东西，把它分解成小块。如果您在多个较大的函数之间发现重复的代码。希望将代码分解成它自己函数。当发现重复的模式与其他不重复的代码混合在一起时，这也很有帮助。如果您必须将重复的部分分解成每个独立的函数，然后在更大的函数中调用它们。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="9e1b" class="lp lq in bd lr ls na lu lv lw nb ly lz jt nc ju mb jw nd jx md jz ne ka mf mg bi translated">4.遵循开放/封闭原则</h1><p id="4d45" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">开放封闭原则规定，封闭用于编辑，开放用于扩展。我们的意思是让功能具有可伸缩性，并在新的需求或特性出现时要求不断的变化。这就是DRY参与进来的地方。我怎么知道我的函数是否遵循OCP？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1145" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mm mn mo mp b">Switch</code>和<code class="fe mm mn mo mp b"> if() else if()</code>陈述通常是不好的做法，很少会有什么好结果。所以请不要使用它们。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="a84f" class="lp lq in bd lr ls na lu lv lw nb ly lz jt nc ju mb jw nd jx md jz ne ka mf mg bi translated">结论</h1><p id="f463" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">干燥原则是最重要的设计理念之一。正确实现将极大地提高应用程序的可维护性和可伸缩性。正确地做同样重要。在删除重复代码时，注意不要过于激进，因为你为使应用程序更易维护所做的努力最终会给你带来麻烦。</p></div></div>    
</body>
</html>