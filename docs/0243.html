<html>
<head>
<title>How to Deal with Selectors in Cypress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理柏树中的选择器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dealing-with-selectors-in-cypress-8b9ac0dfe240?source=collection_archive---------1-----------------------#2021-01-14">https://javascript.plainenglish.io/dealing-with-selectors-in-cypress-8b9ac0dfe240?source=collection_archive---------1-----------------------#2021-01-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bb5c6c6385b6d62011efc33b8e612bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uSGH2rxIyCIWh652"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@alanveob?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aleksey Boev</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="22ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自从我开始使用柏树已经有一段时间了，我没有发现太多关于使用选择器的信息。</p><p id="4c41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">柏树文档没有超出<a class="ae jz" href="https://docs.cypress.io/guides/references/best-practices.html#Selecting-Elements" rel="noopener ugc nofollow" target="_blank">建议</a>使用“稳定的”属性选择器而不是脆弱的CSS选择器，也没有提出组织和重用选择器的方法。</p><p id="8dab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文的目的是填补这一空白，并发现到目前为止有哪些可用的方案。</p><p id="0c98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 0。使用硬编码选择器</strong></p><p id="3472" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用选择器最简单的方法是在所有地方对它们进行硬编码。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="30e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不用说，这不是处理选择器的最佳方式，因为:</p><ul class=""><li id="463a" class="le lf in kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">您不能重用硬编码在测试代码中的选择器</li><li id="fc30" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">如果选择器中断，您需要更新测试代码中该选择器的所有出现</li><li id="526e" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">选择器可能不表示它确切定位了哪个元素(例如<code class="fe ls lt lu lv b">div &gt; .item</code>不提供关于它所查询的元素的目的的任何线索)</li></ul><p id="d1b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">鉴于这种方法的所有缺点，我会说这是使用选择器的最不可取的方式。</p><p id="c04e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 1。将选择器存储在常数中</strong></p><p id="1752" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接近<strong class="kc io"> #0 </strong>的明显改进是将选择器存储在常量中，然后通过引用来使用它们——这是重用选择器的最简单方法:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="1e38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们甚至可以将这些选择器添加到某个对象(命名空间？)来强调这些选择器是密切相关的，然后通过访问我们的特定页面/小部件的选择器的“名称空间”来使用它们:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="a68b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优势:</strong></p><ul class=""><li id="48c6" class="le lf in kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">这样的选择器可以被重用(只需通过引用来访问任何一个选择器)</li><li id="d99b" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">如果选择器命名正确，就很容易理解它所指向的元素的功能/目的</li><li id="295b" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">如果选择器坏了，您只需要在一个地方修复它</li></ul><p id="946a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> Cons: </strong></p><ul class=""><li id="6ea0" class="le lf in kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">虽然可以定义一个“复合”选择器来查询另一个元素中的一个元素(例如，父元素中的子元素)，但是它有点麻烦和不方便:</li></ul><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="4c25" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2 .定义选择元素的自定义功能</strong></p><p id="38dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您足够幸运，能够访问被测应用程序的代码库。在这种情况下，您可以将测试属性添加到要交互的元素中，然后定义一个自定义命令，该命令将使用如下测试id来查询这些元素:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="61c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，您可以让TypeScript知道(如果您使用它的话)Cypress API已经被扩展:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="1b40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，通过使用这个自定义命令，我们可以通过将选择器提取到单独的函数中来重用它们:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="926b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的测试将如下所示:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="a0e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们定义的命令支持“相对”选择器，我们也可以搜索其他元素中的元素:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="e850" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的是，这种方法可能会导致不可靠的测试(在极少数情况下)。事情是这样的，<a class="ae jz" href="https://docs.cypress.io/guides/core-concepts/retry-ability.html#Only-the-last-command-is-retried" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">柏命令只重试断言</strong> </a>之前的最后一个命令。实际上，这意味着如果你有一堆嵌套的<code class="fe ls lt lu lv b">find</code>命令，如下例所示</p><pre class="ky kz la lb gt lw lv lx ly aw lz bi"><span id="6a54" class="ma mb in lv b gy mc md l me mf">cy.get(&lt;root&gt;).find(&lt;parent&gt;).find(&lt;children&gt;).shold(&lt;assertion&gt;)</span></pre><p id="1db6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并且断言失败，Cypress将只重试断言前的最后一个命令(上例中的<code class="fe ls lt lu lv b">.find(&lt;children&gt;)</code>)。因此，如果第一个<code class="fe ls lt lu lv b">find</code>命令(<code class="fe ls lt lu lv b">.find(&lt;parent&gt;)</code>)针对错误的父元素执行，您的测试将会失败。有关此行为的详细解释，请参见<a class="ae jz" href="https://docs.cypress.io/guides/core-concepts/retry-ability.html#Only-the-last-command-is-retried" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="80fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样值得注意的是，在200+ E2E测试中，我只看到这种情况发生了两次，而且这两次测试只在CI容器中失败(正如文章中提到的)。</p><p id="2e29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的优点和缺点与前一种方法非常相似:</p><p id="8f2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">优点:</strong></p><ul class=""><li id="32c8" class="le lf in kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">这种方法允许您定义一次选择器，然后通过调用查询元素的函数来使用它们</li><li id="596c" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">如果您的“选择器函数”命名正确，就很容易推断出它们返回什么元素</li><li id="5e68" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">如果一个选择器坏了，只有一个地方需要修复</li></ul><p id="60c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">缺点:</strong></p><ul class=""><li id="2029" class="le lf in kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">这种方法在99%的情况下都有效，但是在某些情况下，您可能会遇到令人不愉快的剥落</li></ul><p id="b3a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经使用这种方法很长时间了，但是它似乎不是最好的解决方案，因为有可能引入一个不可靠的测试(即使它很肤浅)，并且使用函数来选择元素的测试代码似乎有点麻烦。</p><p id="f537" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3。将选择器存储在页面对象中</strong></p><p id="45a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，我知道，Cypress团队认为<a class="ae jz" href="https://martinfowler.com/bliki/PageObject.html" rel="noopener ugc nofollow" target="_blank"> PageObject </a>是一个反模式，根据<a class="ae jz" href="https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/" rel="noopener ugc nofollow" target="_blank">文章</a>，你应该避免使用它。理由是PageObject模式“引入了另一个间接层”，并阻止您在“隔离”状态下测试您的特性。虽然这些都是有效的观点，但是“孤立测试”并不是我大部分时间都需要的。相反，我更喜欢测试覆盖多个页面的完整流程，这正是PageObject模式派上用场的地方。我认为该模式有助于组织和重用选择器(以及其他一些东西)。</p><p id="dd95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">据我所知，在Java的“自动化世界”中，将选择器存储在类/接口中并使用注释声明性地定义它们是一种常见的技术。以下是使用<a class="ae jz" href="https://github.com/qameta/atlas" rel="noopener ugc nofollow" target="_blank"> atlas </a>选择器的代码示例:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="c1cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我没有找到任何允许在Cypress中做类似事情的库，所以我写了自己的库。它被称为<a class="ae jz" href="https://www.npmjs.com/package/cypress-selectors" rel="noopener ugc nofollow" target="_blank"> cypress-selectors </a>，它使您能够声明性地定义您的选择器(就像上面的例子一样)。</p><p id="c06a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看一些例子。首先，让我们定义一个类，并声明性地定义我们的选择器:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="2384" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，让我们在“示例”测试中使用这些选择器:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="e44e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，您可以通过访问一个类的成员来查询元素——就这么简单。</p><p id="8df1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该库允许通过<code class="fe ls lt lu lv b">attribute</code>、<code class="fe ls lt lu lv b">class</code>、<code class="fe ls lt lu lv b">id</code>、<code class="fe ls lt lu lv b">xpath</code>、<code class="fe ls lt lu lv b">type</code>和jQuery <code class="fe ls lt lu lv b">selector</code>选择元素。</p><p id="99b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它还支持查询另一个元素中的元素(复合选择器):</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="26cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您在上面的例子中看到的，您可以为一个元素分配一个“别名”,然后在另一个选择器中引用它来指定它的父元素。</p><p id="3f1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了方法#1和#2的“优点”,还有几个优点:</p><ul class=""><li id="6742" class="le lf in kc b kd ke kh ki kl lg kp lh kt li kx lj lk ll lm bi translated">这种方法允许您以声明方式定义选择器</li><li id="f50e" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">您可以通过访问成员或PageObject类来查询元素</li><li id="fc41" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">指定选择器的“父代”很容易</li><li id="7d73" class="le lf in kc b kd ln kh lo kl lp kp lq kt lr kx lj lk ll lm bi translated">这种方法没有方法#2中描述的问题——该库不构建一个<code class="fe ls lt lu lv b">find</code>命令链，而是按照文档的建议合并查询<a class="ae jz" href="https://docs.cypress.io/guides/core-concepts/retry-ability.html#Merging-queries" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><p id="e40b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在过去的几个月里，我一直在我的项目中使用这种方法，我对结果很满意——测试代码简洁易读。在上述四种方法中，这一种对我来说似乎是最佳的。查看文档，了解更多关于https://anton-kravchenko.github.io/cypress-selectors/图书馆的信息。</p></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><p id="dde6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每种方法都有自己的优点，由您决定哪种方法最适合您。欢迎在评论中分享你的想法，祝你编码愉快！</p><p id="963b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>