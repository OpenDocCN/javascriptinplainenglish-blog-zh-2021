<html>
<head>
<title>Why I Finally Chose React over Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我最终选择React而不是Vue.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-i-finally-chose-react-over-vue-f090cb0e097a?source=collection_archive---------0-----------------------#2021-05-06">https://javascript.plainenglish.io/why-i-finally-chose-react-over-vue-f090cb0e097a?source=collection_archive---------0-----------------------#2021-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ad7d637a405915a1798051b603f110ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vD2fc4A1Vwe3ivRLa7dW2w.jpeg"/></div></div></figure><p id="d051" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的十年中，单页面应用程序(SPA)框架已经确立了其作为现代web开发标准的地位。React和Vue.js是新项目中最受欢迎的两个SPA库，在这场web革命中扮演了重要角色。</p><p id="d18c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从远处看，这些库在形式和功能上几乎完全相同；在这两者之间做出选择主要决定了你代码的风格，而不是你产品的质量。然而你只能为你的下一个项目选择一个。你应该选择哪个？</p><p id="7c76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这场激烈的辩论引发了许多充满激情的文章和讨论，但共识似乎逐年远离我们。</p><p id="dd93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在用这两个库构建应用程序几年后，我发现我更喜欢React。在我陈述我的理由之前，我将讨论一些通常被引用的理由，这些理由并没有真正影响我的决定。</p><h2 id="5dca" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">并不是因为React更受欢迎</h2><p id="8fc8" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">React的粉丝通常会指出其生态系统的规模和成熟度。这是真的:React有更多的Github库和经验丰富的开发人员，与此相关的是，附加组件在质量和数量上都更胜一筹。</p><p id="aa90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着您可以参考更多的堆栈溢出问题、教程和示例，以及更多可以使用的NPM软件包。但是我不认为这是选择React的令人信服的理由，原因有二。</p><p id="903b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，随着Vue的势头飙升，这一差距正在缩小，这一趋势在可预见的未来肯定会继续。</p><p id="e4b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，目前的差距本身还不足以排除Vue，Vue有足够多的官方和非官方图书馆来保持强大的竞争力。</p><h2 id="ad2c" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Vue.js更简单——但还不足以产生影响</h2><p id="b478" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Vue粉丝通常会引用易用性和更温和的学习曲线作为他们的理由。虽然更加主观，但这一点通常也没有争议。Vue的文档是现存的最好的文档之一。它的模板系统比JSX更直观，尤其是对初学者来说，视图和模型代码更清晰的分离有助于新的web开发人员理解MVC设计背后的重要原则。</p><p id="e0b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<em class="kw">是</em>初学者在React之前学习Vue的一个令人信服的理由。事实上，这是我向两者都没有经验的程序员推荐的顺序。</p><p id="1037" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是React更陡峭的学习曲线不应该阻止更有经验的工程师。一旦开发人员在React和Vue中构建了一个重要的应用程序，学习曲线不会显著影响开发速度或产品质量。</p><p id="d8c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，如果两个库如此相似，并且各有利弊，为什么我更喜欢React呢？</p><p id="f82b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案最终在于JSX，React的模板系统。Vue使用嵌入Javascript的XML，而JSX是真正的Javascript，只是格式像XML。</p><p id="9a55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，React完全是JavaScript这有两个重要的好处。</p><h1 id="36c6" class="lv ky iq bd kz lw lx ly lc lz ma mb lf mc md me li mf mg mh ll mi mj mk lo ml bi translated">1.与TypeScript更好的兼容性</h1><p id="3b6b" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">为了理解Typescript兼容性的价值，我们首先需要回顾一下拥有类型系统的好处。</p><p id="c597" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，它使代码更具可读性。这不仅有利于你的队友，也有利于未来你扩展应用程序。</p><p id="81c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，类型系统帮助你设计更健壮的抽象。如果没有一个，随着模块数量的增加，管理许多不同的模块会变得异常困难。静态定义类型所损失的时间可以很容易地重新获得，并且不再需要记忆或手动引用类型。</p><p id="f7e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript的最后一个好处是它有助于快速捕捉细微的错误。考虑以下等式比较:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2b39" class="kx ky iq mr b gy mv mw l mx my">const num = 5;<br/>const str = "5";<br/>if (num === str) {<br/>  // do something<br/>}</span></pre><p id="95b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码的简单性立刻暴露了我们的错误:使用严格的等式来比较一个数字和一个字符串。但是我们可以想象，在一个没有类型的更大的系统中，我们可能会完全忽略这个错误。如果我们给我们的变量类型，IDE将立即突出错误，潜在地节省几分钟甚至几小时的挫折。</p><p id="64ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些好处意味着更快的开发和更少的错误，随着应用程序复杂性的增加，改进的回报也会增加。</p><h2 id="b48e" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">JSX =更多类型</h2><p id="7621" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">但是打字稿和JSX有什么关系呢？对Javascript更真实的库对TypeScript也更真实。JSX元素的每个部分都可以(也应该)被类型化:组件、道具、子元素等等。</p><p id="bf6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Typescript的一个重要原则是我所说的全有或全无原则。对一些文件使用Typescript，对另一些文件使用普通JS会助长懒惰。同样，为一些变量设置类型，但对另一些变量使用<code class="fe mz na nb mr b">any</code>,这违背了拥有类型的初衷。</p><p id="2f35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，要使一个库与Typescript很好地集成，它的所有特性都必须易于键入。多亏了JSX，React轻松满足了这个标准。</p><p id="e73c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，在Vue中也可以输入许多这样的元素，但是需要的工作量通常更大，文档和堆栈溢出问题更少。</p><p id="e623" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果你执意同时使用Vue和Typescript，所有的希望都不会落空。最近，Vue团队已经优先改善库的类型脚本体验——毕竟，Vue 3是用它编写的。</p><p id="25d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是除了采用JSX(可能性极小)，Vue无法与React的类型脚本兼容性相媲美。</p><h2 id="b52b" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">React更大的生态系统确实有所不同</h2><p id="2bd0" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">React与TypeScript配合得更好还有一个重要原因，这要归功于更大的生态系统。因为TypeScript更容易与JSX一起使用，更多的React项目比Vue项目依赖它；反过来，React库和插件更有可能支持TypeScript。</p><p id="98c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，这意味着我们更多的文件可以以。ts而不是。js，全有或全无原则的胜利。</p><p id="e34a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您对在下一个SPA项目中使用TypeScript不感兴趣怎么办？如果不是因为JSX的第二个重要好处，我可能会推荐Vue，因为它易于使用，原型制作能力更快。</p><p id="e9d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但我也要警告你，对于任何比四函数计算器更复杂的应用程序来说，绕开类型系统都是错误的，尤其是如果你打算以后扩展应用程序的话。</p><h1 id="77e6" class="lv ky iq bd kz lw lx ly lc lz ma mb lf mc md me li mf mg mh ll mi mj mk lo ml bi translated">2.更实用的范例</h1><p id="ef8f" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">让我们简单回顾一下功能性代码的含义，以及为什么我们通常更喜欢功能性代码而不是过程性代码。</p><p id="3bbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在数学和计算机科学中，函数是消耗一些输入并返回一些输出的运算。最好的函数是<strong class="ka ir">纯</strong>和<strong class="ka ir">确定性</strong>。</p><p id="ce2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">纯函数没有副作用；它们忽略状态，只关心函数的输入。</p><p id="efa6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定相同的输入，确定性函数总是返回相同的输出。</p><p id="151f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于各种原因，尽可能编写确定性的纯函数可以提高代码质量。这些函数更容易测试，更容易思考，并且提高了代码的可读性。</p><p id="a150" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑功能代码和过程代码之间的简单对比:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3b49" class="kx ky iq mr b gy mv mw l mx my">const arr = [4, 5, 6];</span><span id="39fb" class="kx ky iq mr b gy nc mw l mx my">// Procedural<br/>for (let i of arr) {<br/>  i += 1;<br/>}</span><span id="76ce" class="kx ky iq mr b gy nc mw l mx my">// Functional equivalent<br/>arr = arr.map(i =&gt; i + 1);</span></pre><p id="a8b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们去掉了两行代码，但更重要的是，第二个代码片段更简洁，更容易阅读:<em class="kw">我们将</em> <code class="fe mz na nb mr b"><em class="kw">arr</em></code> <em class="kw">设置为同一个数组，由一个函数映射，该函数返回它的输入加上一个</em>。</p><p id="c4bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于函数式JavaScript的好处或操作方法，请查看本文。</p><p id="69b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么JSX鼓励更多的函数式代码？由于JSX是JavaScript，我们可以将JSX元素视为一级变量。我们可以通过呈现元素列表来轻松演示这一点:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="61fd" class="kx ky iq mr b gy mv mw l mx my">const arr = [4, 5, 6];</span><span id="338c" class="kx ky iq mr b gy nc mw l mx my">const renderFunction = (n) =&gt; {<br/>  return &lt;SomeComponent someProp={n} /&gt;<br/>}</span><span id="85ed" class="kx ky iq mr b gy nc mw l mx my">return (<br/>  &lt;&gt;<br/>    { arr.map(renderFunction) }  <br/>  &lt;/&gt;<br/>)</span></pre><p id="27a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在Vue中，使用<code class="fe mz na nb mr b">v-for</code>可以说更加简单:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9797" class="kx ky iq mr b gy mv mw l mx my">&lt;template&gt;<br/>  &lt;SomeComponent v-for="n in arr" :someProp="n" /&gt;<br/>&lt;/template&gt;<br/>...<br/>{<br/>  data() {<br/>    return {<br/>      arr: [4, 5, 6]<br/>    }<br/>  }<br/>}</span></pre><p id="72ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们想传入的不是<code class="fe mz na nb mr b">n</code>，而是<em class="kw">对</em> <code class="fe mz na nb mr b">n</code>的某种操作的结果，作为某个组件的道具，比如将其格式化为货币，该怎么办呢？</p><p id="2222" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React中，调整是最小的:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7f09" class="kx ky iq mr b gy mv mw l mx my">const arr = [4, 5, 6];</span><span id="90ec" class="kx ky iq mr b gy nc mw l mx my">const renderFunction = (n) =&gt; {<br/>  const formattedText = `$${n.toFixed(2)}`;<br/>  return &lt;SomeComponent someProp={formattedText} /&gt;<br/>}</span><span id="4fa6" class="kx ky iq mr b gy nc mw l mx my">return (<br/>  &lt;&gt;<br/>    { arr.map(renderFunction) }  <br/>  &lt;/&gt;<br/>)</span></pre><p id="65c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们将格式化逻辑包含在<code class="fe mz na nb mr b">renderFunction</code>中，确保关注点的分离。但是在Vue中，我们必须为整个组件定义一个方法:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="59b1" class="kx ky iq mr b gy mv mw l mx my">&lt;template&gt;<br/>  &lt;SomeComponent v-for="n in arr" :someProp="n" /&gt;<br/>&lt;/template&gt;<br/>...<br/>{<br/>  data() {<br/>    return {<br/>      arr: [4, 5, 6]<br/>    }<br/>  },<br/>  methods: {<br/>    formatAsMoney(n) {<br/>      return `$${n.toFixed(2)}`<br/>    }<br/>  }<br/>}</span></pre><p id="3c81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(是的，在这两个例子中，您可以在模板中编写格式化逻辑，但是要考虑一个复杂得多的操作)。</p><p id="240d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种差异可能看起来微不足道，但Vue的组织有两个明显的缺点。首先，它将组件一部分的代码分散到整个文件中。第二，仅仅通过查看<code class="fe mz na nb mr b">formatAsMoney</code>方法并不清楚该方法在哪里被使用，或者如果它被更改或删除会发生什么。</p><p id="356a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React和Vue的另一个重要区别是，子组件如何将数据传递给父母。在reaction中，父组件将一个函数传递给子组件调用的子组件；这种模式需要对函数式JavaScript有深入的理解，但比Vue的<code class="fe mz na nb mr b">emit</code>模式要强大和灵活得多。同时，由于React的功能模式更接近于Javascript，因此它还提供了卓越的TypeScript兼容性。</p><h1 id="f4a2" class="lv ky iq bd kz lw lx ly lc lz ma mb lf mc md me li mf mg mh ll mi mj mk lo ml bi translated">这对你来说意味着什么？</h1><p id="b1eb" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">决定使用哪种技术并不是一个普遍的客观问题，因为软件工程并不是一门有简单答案的硬科学。</p><p id="e123" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在选择SPA框架时，您应该考虑各种因素。这里提出的想法应该有助于你的决定，以及任何其他原因，你可能有赞成或反对或Vue或反应；这些可能与您的编程风格、您的团队对库的舒适度或者对特定附加库的需求有关。</p><p id="3a5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我想提几点建议:不要在没有充分了解自己的选择之前就做出重大科技决策。在开始一个大型网络客户端之前，不要因为你一直在使用Vue就选择Vue(这个错误我已经犯过很多次了)。花点时间精通reaction，了解它的优缺点。那些一直使用“反应”的人也是如此。</p><p id="9823" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论你选择什么，你的选择都不应该决定你的最终产品的质量，它当然也不应该决定你的代码的质量。</p><p id="63bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个团队，理清你的需求，讨论你的选择的利弊，达成一个让你的团队尽可能满意的协议。</p><p id="1e8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果之后你仍然无法自拔，那就选择“做出反应”吧。</p><p id="4a4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">更多内容参见</em><a class="ae nd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T4</a></p></div></div>    
</body>
</html>