<html>
<head>
<title>If Your Code Is Garbage, Node’s Garbage Collector Won’t Help</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果你的代码是垃圾，Node的垃圾收集器就没用了</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/if-your-code-is-garbage-nodes-garbage-collector-won-t-help-f48d32d3bc9a?source=collection_archive---------5-----------------------#2021-02-07">https://javascript.plainenglish.io/if-your-code-is-garbage-nodes-garbage-collector-won-t-help-f48d32d3bc9a?source=collection_archive---------5-----------------------#2021-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="45b7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以下是你需要知道的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ce8d26aa4aff6a73507e914385795b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Axh0upT6FP554ctp"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paweł Czerwiński</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7f42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">垃圾听起来不好——那是因为它不好。它甚至会使你的程序崩溃。但是这是什么意思呢？</p><p id="6319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当执行代码时，东西被存储在内存中——这样我们的程序可以快速访问它们。我们也可以在内存中动态创建新的东西。然而，内存是有限的，所以删除不再需要的项目是个好主意。这正是垃圾收集器为我们做的——它删除内存中的内容，为新内容腾出空间。</p><p id="49bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果无用的东西没有被删除，内存变得越来越满，我们说内存泄漏。这些错误的致命之处在于——当你发现它们的时候已经太晚了。当内存满到极限时，程序不能创建新的对象——它必须中止。</p><p id="16d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是关于JavaScript中的内存泄漏，尤其是Node.js中的内存泄漏，您需要了解的内容。</p><h1 id="1aea" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是内存泄漏，什么不是？</h1><p id="6e54" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">简单地说:如果不删除不用的东西，这可能会导致内存泄漏。</p><p id="5ede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要是这么简单就好了——因为它更多的是关于垃圾收集器<strong class="ky ir">认为不再被使用的东西</strong>。</p><p id="3323" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GC的行为是防御性的，有时<strong class="ky ir">不会移除不再需要的</strong>物品。这就是为什么仅仅依赖垃圾收集器是致命的——它不是全知的。</p><p id="00f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">让我们看一个危险的例子。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="95a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码每秒输出一次对象需要多少内存。</p><p id="0fd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5秒钟后，一个巨大的数组被创建。</p><p id="8463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这需要很大的内存。但事实上，它从未被使用过。</p><p id="a065" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您可以看到内存使用量每秒钟是如何变化的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/c48a16141261bd07c2de43d4e3a7492a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRt9Q3RprTgwZi4BhWaBgg.png"/></div></div></figure><p id="f2cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建数组后，内存使用量急剧增加。仅仅过了几秒钟，使用量又下降了——GC已经删除了该数组，因为不再需要它了。学习:GC是间歇工作的。</p><p id="c808" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在这种情况下，GC可以正确地检测未使用的对象。</p><p id="c9e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是也有我们不能依赖GC的情况。</p><p id="0a44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0a2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码与第一个例子只有很小的不同。 <br/>这里我们把大数组存放在全局范围内。该数组实际上仍未被使用——但垃圾收集器对此有不同的看法。</p><p id="bc64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您运行它时，您会注意到内存使用量再次上升，但也没有下降。垃圾收集器认为该数组很重要，因此不会移除它。</p><p id="8500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">学习:</strong>从<strong class="ky ir"> setTimeout </strong>、<strong class="ky ir"> setInterval、</strong>等引用全局作用域变量是危险的。</p><h1 id="30a7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">怪异的JS行为导致内存泄漏</h1><p id="df88" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通常你用<strong class="ky ir"> var、let或const来声明变量。</strong></p><p id="772b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不这样做，变量无论如何都会存在。</p><p id="793c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后台发生的事情可能会有问题。无论我们在哪里“错误地”声明了变量，它都会被赋给全局对象——即使它应该只在函数的范围内。</p><p id="a1c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4a7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是合法的代码。<br/>不出所料，该变量只在函数范围内可用——我们不能在greet-function之外记录它。</p><p id="5f05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当只删除const-keyword时，它看起来像这样，一切都变了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="351e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码也可以。</p><p id="ed64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该变量突然在全局范围内可用，这意味着垃圾收集器不会清理它。</p><p id="e29d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码示例在Node.js中——没有窗口对象，只有全局对象。两者都是顶级对象。因此，如果将“全局”替换为“窗口”，这些示例在浏览器中的工作方式是相同的</p><h1 id="5df9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">有时候GC会捉弄你</h1><p id="f912" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">垃圾收集器帮助你释放程序的内存。如果内存没有被再次释放，并且变得越来越满，程序将最终终止。</p><p id="2b43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是垃圾收集器究竟在什么时候查看需要删除什么呢？正是这一点可能导致垮台。我向您展示了如何输出堆的使用情况。这是查找漏洞的有力工具。</p><p id="61c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是:并不是所有看起来像内存泄漏的事情都是内存泄漏。如果您跟踪内存使用情况，一开始它可能会上升但不会下降——这看起来像是内存泄漏，但这可能是因为GC还没有开始删除任何东西。</p><p id="4ee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个强大的技巧来测试您的代码是否存在内存泄漏:我们可以故意调用Node.js中的垃圾收集器，重要的是:这是以性能为代价的，所以建议只在开发期间使用这个技巧。</p><p id="e546" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要手动运行垃圾收集器，我们必须像这样启动我们的应用程序:<code class="fe ms mt mu mv b">node --expose-gc index.js</code>。用<code class="fe ms mt mu mv b">global.gc()</code>我们可以调用垃圾收集器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0e35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您已经知道了代码，这需要几秒钟的时间来清理内存。但是通过我们的技巧，我们可以立即打开GC。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/0b3fc2aeec2b17effe00e1008ebb8090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8lbis_J0J7TxuxzoP82URw.png"/></div></div></figure><p id="8bfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需添加以下代码:</p><pre class="kg kh ki kj gt mx mv my mz aw na bi"><span id="4cd6" class="nb lt iq mv b gy nc nd l ne nf">setInterval(function() { <br/>  global.gc()<br/>}, 3500)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/09363eba73701b6c691bc15b5c7069ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItDbj6hfHVGzRD5Y5w2a7A.png"/></div></div></figure><p id="9682" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第3秒，垃圾被创建；半秒钟后，我们再次移除它。很方便，不是吗？</p><h2 id="9d32" class="nb lt iq bd lu nh ni dn ly nj nk dp mc lf nl nm me lj nn no mg ln np nq mi nr bi translated"><a class="ae kv" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank">加入我的时事通讯，了解最新消息</a></h2></div></div>    
</body>
</html>