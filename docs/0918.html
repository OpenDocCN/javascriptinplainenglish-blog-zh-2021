<html>
<head>
<title>Frontend API calls with TypeScript and Axios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript和Axios的前端API调用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/frontend-api-calls-with-typescript-and-axios-68792d1e63c2?source=collection_archive---------0-----------------------#2021-02-26">https://javascript.plainenglish.io/frontend-api-calls-with-typescript-and-axios-68792d1e63c2?source=collection_archive---------0-----------------------#2021-02-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3df2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用TypeScript和Axios增强前端API调用的自以为是的方法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4bc0f07a7471ccd11d0e270e990f6fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q2oEctfvO9-6FJSWEsx5eQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Cover image</figcaption></figure><p id="d58c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">许多开发人员采用了将后端服务与前端应用程序分离的方法。这种方法允许它们独立成长和进化。</p><p id="8c24" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在前端开发中，了解如何向后端服务发出动态请求是很重要的。</p><p id="9dbb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本教程中，我们将使用React和TypeScript开发我们的前端应用程序。(<em class="lo">注意:您可以在其他前端库/框架上使用相同的方法。</em>)</p><p id="c8ff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于后端服务，我们将使用<a class="ae lp" href="http://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> JSONPlaceholder </strong> </a>。一个免费的在线API服务。</p><p id="247b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">您可以通过克隆这个存储库来编写代码(<strong class="ku io">主分支</strong>)<br/><a class="ae lp" href="https://github.com/Mr-Malomz/api-call" rel="noopener ugc nofollow" target="_blank">https://github.com/Mr-Malomz/api-call</a><a class="ae lp" href="https://github.com/Mr-Malomz/api-call" rel="noopener ugc nofollow" target="_blank"/><br/>)(如果您更喜欢查看完整的代码，请检查同一个存储库的<strong class="ku io"> dev </strong>分支。)</p><p id="83c0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本教程中，我们将只关注API调用。项目UI已经设置了<a class="ae lp" href="https://chakra-ui.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io">脉轮UI </strong> </a></p><h1 id="b910" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">文件夹结构</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/42ec6603b47c01d8e3e37fe733424265.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*76fzf7ns_dZePbWIG17AQA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">project folder structure</figcaption></figure><p id="a56e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看看上面的一些关键目录和文件:</p><ul class=""><li id="f508" class="mj mk in ku b kv kw ky kz lb ml lf mm lj mn ln mo mp mq mr bi translated"><code class="fe ms mt mu mv b">api:</code>存储API调用相关文件的文件夹。</li><li id="21ab" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated"><code class="fe ms mt mu mv b">components:</code>一个文件夹，用于存储我们应用程序的构建模块。</li><li id="5a75" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated"><code class="fe ms mt mu mv b">models:</code>存储描述响应类型的文件的文件夹。</li><li id="9cd7" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated"><code class="fe ms mt mu mv b">App.tsx:</code>连接所有组件的文件。</li></ul><h1 id="bdc8" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">运行项目</h1><p id="748d" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">导航到项目位置，打开您的终端并安装项目依赖项</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">install project dependency</figcaption></figure><p id="f7d1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然后使用下面的命令运行项目</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Start project</figcaption></figure><blockquote class="ni nj nk"><p id="5ed9" class="ks kt lo ku b kv kw jo kx ky kz jr la nl lc ld le nm lg lh li nn lk ll lm ln ig bi translated">你的项目应该在<code class="fe ms mt mu mv b"><a class="ae lp" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code>上弹出</p></blockquote><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/df11a3252b9c3cc53e67f84a750eb57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XP5iK_T27X5fECTMUnHWPQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Project running on <code class="fe ms mt mu mv b"><a class="ae lp" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code></figcaption></figure><h1 id="d864" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">模型</h1><p id="5548" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">在利用TypeScript自带的其他打字系统时，我们需要创建一个模型来描述API响应<a class="ae lp" href="http://jsonplaceholder.typicode.com/posts/1" rel="noopener ugc nofollow" target="_blank"><strong class="ku io">JSONPlaceholder</strong></a><strong class="ku io"/>的返回。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">jsonplaceholder response</figcaption></figure><p id="ee50" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有了来自<a class="ae lp" href="http://jsonplaceholder.typicode.com/posts/1" rel="noopener ugc nofollow" target="_blank"><strong class="ku io">JSONPlaceholder</strong></a>的响应，现在让我们创建一个模型来表示响应类型。</p><h2 id="1a19" class="np lr in bd ls nq nr dn lw ns nt dp ma lb nu nv mc lf nw nx me lj ny nz mg oa bi translated"><strong class="ak">第一步</strong></h2><p id="f1b3" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">在<strong class="ku io">模型</strong>文件夹中创建一个新文件<code class="fe ms mt mu mv b">post.interface.ts</code>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/b193144cc087a1e0e55e51d16cdeb2a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*GS4H6pXYhJxy4C1Kh8e-Dg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated folder structure</figcaption></figure><h2 id="51ad" class="np lr in bd ls nq nr dn lw ns nt dp ma lb nu nv mc lf nw nx me lj ny nz mg oa bi translated"><strong class="ak">第二步</strong></h2><p id="7aa1" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">创建一个接口来描述响应属性(userId、Id、title和body)。<em class="lo">在</em> <strong class="ku io"> <em class="lo"> id </em> </strong> <em class="lo">和</em><strong class="ku io"><em class="lo">userId</em></strong><em class="lo">key前面的问号告诉TypeScript这些属性是可选的，因为它是由</em><a class="ae lp" href="http://jsonplaceholder.typicode.com/posts/1" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lo">JSONPlaceholder</em></strong></a><em class="lo">自动生成的。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">post.interface.ts</figcaption></figure><h1 id="81c2" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak"> API调用</strong></h1><p id="ae99" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">包装好模型后，我们现在可以开始对<a class="ae lp" href="http://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank"><strong class="ku io">JSONPlaceholder</strong></a>端点进行API调用。我们将在这个应用程序中使用<a class="ae lp" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> axios </strong> </a>进行API调用。Axios是一个基于promise的HTTP客户端，用于浏览器和node.js。</p><h2 id="44c3" class="np lr in bd ls nq nr dn lw ns nt dp ma lb nu nv mc lf nw nx me lj ny nz mg oa bi translated"><strong class="ak">第一步</strong></h2><p id="5fab" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">在<strong class="ku io"> api </strong>文件夹中创建一个新文件<code class="fe ms mt mu mv b">api.ts</code>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/201488447179626ccd1373bdd3210432.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*pzfiVu7cFsH6pApb7aAuuw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">updated folder structure</figcaption></figure><h2 id="e9e9" class="np lr in bd ls nq nr dn lw ns nt dp ma lb nu nv mc lf nw nx me lj ny nz mg oa bi translated"><strong class="ak">第二步</strong></h2><p id="72a9" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">我们需要配置<strong class="ku io"> axios、</strong> create <strong class="ku io"> Requests </strong>和<strong class="ku io"> Post </strong>对象来处理创建、读取、更新和删除(CRUD ),如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">api.ts</figcaption></figure><p id="31af" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们解释一下这段代码。我们遵循以下步骤:</p><ul class=""><li id="d517" class="mj mk in ku b kv kw ky kz lb ml lf mm lj mn ln mo mp mq mr bi translated">进口<strong class="ku io"> axios </strong>和AxiosResponse。AxiosResponse是axios提供的类型脚本响应类型。我们还导入了PostType，这是我们之前创建的响应类型。</li><li id="cc65" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">将<strong class="ku io"> axios </strong>配置为使用<a class="ae lp" href="http://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io">JSONPlaceholder</strong></a>作为我们请求的基本URL和15秒超时。</li><li id="3ca6" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">析构<strong class="ku io"> axios </strong>并从其响应对象获得数据响应。</li><li id="6485" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">创建了一个请求对象来处理CRUD，并返回了之前创建的被析构的<strong class="ku io"> axios </strong>体。</li><li id="bb1b" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">创建并导出一个<strong class="ku io"> Post </strong>对象，该对象使用之前创建的请求对象来处理使用请求对象的CRUD操作。</li></ul><h1 id="0905" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak">消费终点</strong></h1><p id="ed6b" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated"><strong class="ku io">获取所有帖子<br/> </strong>要获取所有帖子，我们需要使用之前在<code class="fe ms mt mu mv b">api.ts</code>中创建的Post对象的getPosts函数进行API调用</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">updated app.tsx</figcaption></figure><p id="f5bf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们在上面的代码中采取了以下步骤:</p><ul class=""><li id="7ea0" class="mj mk in ku b kv kw ky kz lb ml lf mm lj mn ln mo mp mq mr bi translated">导入的<code class="fe ms mt mu mv b">useEffect</code>、<code class="fe ms mt mu mv b">useState</code>、<code class="fe ms mt mu mv b">PostType</code>(响应类型)、和<code class="fe ms mt mu mv b">Post</code> (API对象)。</li><li id="2ce1" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">创建了状态来分别管理和更新帖子和错误。我们还为post(post type类型的数组)和isError(boolean)定义了响应类型。</li><li id="fba7" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">使用<code class="fe ms mt mu mv b">useEffect</code>钩子内的<strong class="ku io"> Post.getPosts </strong>函数进行API调用。然后，我们用post和catch错误(如果有的话)更新了应用程序状态。</li><li id="dbd9" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">设置一个错误界限，并显示一条适当的消息(如果有的话)。然后我们遍历卡片组件，将密钥和post作为参数传递。</li></ul><p id="25c8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo"> TypeScript会抱怨卡片组件没有</em><strong class="ku io"><em class="lo">post</em></strong><em class="lo">属性。我们会解决的。</em></p><p id="0a51" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">要解决这个问题，导航到组件文件夹并编辑<code class="fe ms mt mu mv b">Card.tsx</code>，如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated Card.tsx</figcaption></figure><p id="c968" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">注意，在上面的代码中，我们向CardProps添加了<strong class="ku io"> post </strong>属性，并在Card组件中对其进行了析构。</p><p id="6d94" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最后，我们在<code class="fe ms mt mu mv b">Card.tsx</code>元素中显示了<strong class="ku io">标题</strong>和<strong class="ku io">正文</strong>属性。</p><p id="f4e9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你的结果应该如下图所示。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/0e048b96a771430b430727473430e8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*da0t1CzM1cb10yTrXrtRdg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">List of posts</figcaption></figure><p id="6688" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">创建帖子<br/> </strong>要创建帖子，我们需要将<code class="fe ms mt mu mv b">posts</code>和<code class="fe ms mt mu mv b">setPosts</code>状态作为参数传递给<strong class="ku io">创建组件</strong>。我们还需要更新<code class="fe ms mt mu mv b">CreateProps</code>界面来反映这些变化。这些属性将帮助我们从<strong class="ku io">创建</strong> <strong class="ku io">组件</strong>中更新我们的UI。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated App.tsx. Posts and setPosts Added to Create component</figcaption></figure><p id="d236" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们还需要用之前传递给它的<code class="fe ms mt mu mv b">posts</code>和<code class="fe ms mt mu mv b">setPosts </code>状态更新<code class="fe ms mt mu mv b">Create.tsx </code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Create.tsx</figcaption></figure><p id="e67f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">完成后，我们可以向API发出post请求。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated Create.tsx</figcaption></figure><p id="59bd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们解释一下这段代码。</p><ul class=""><li id="a237" class="mj mk in ku b kv kw ky kz lb ml lf mm lj mn ln mo mp mq mr bi translated">首先，我们添加了一个状态来管理创建表单时的错误。</li><li id="9b57" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">其次，我们通过使用<strong class="ku io"> Post.createPost() </strong>函数进行API调用来更新<strong class="ku io"> handleSubmit </strong>函数，更新状态，并相应地关闭模态。</li><li id="23b3" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">最后，我们有条件地处理了创建表单时可能出现的错误。</li></ul><p id="b671" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">由于我们的API调用没有保存在数据库中，当我们刷新浏览器时，它会被删除。</em></p><h2 id="7ef7" class="np lr in bd ls nq nr dn lw ns nt dp ma lb nu nv mc lf nw nx me lj ny nz mg oa bi translated"><strong class="ak">更新帖子</strong></h2><p id="7274" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">更新一篇文章和创建一篇文章几乎是一回事。我们需要将<code class="fe ms mt mu mv b">posts</code>和<code class="fe ms mt mu mv b">setPosts</code>状态作为参数传递给<strong class="ku io">编辑组件</strong>。我们还需要更新<strong class="ku io"> EditProps </strong>接口来反映这些变化。这些属性将帮助我们从<strong class="ku io">编辑组件</strong>中更新我们的UI。<br/>除此之外，我们还需要创建一个新的状态，以便在每次点击编辑按钮时跟踪选中的<strong class="ku io">文章id </strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated App.tsx</figcaption></figure><p id="40d5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将更新<code class="fe ms mt mu mv b">Card.tsx</code>组件，使我们能够更新postID。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated Card.tsx</figcaption></figure><blockquote class="ni nj nk"><p id="f756" class="ks kt lo ku b kv kw jo kx ky kz jr la nl lc ld le nm lg lh li nn lk ll lm ln ig bi translated"><strong class="ku io"> PS: </strong>砰(！)在<strong class="ku io"> setPostID(post.id！)</strong>告诉编译器放松非空约束错误(意味着参数不能为空或未定义)</p></blockquote><p id="05ad" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接下来，我们需要在<strong class="ku io">编辑组件</strong>中进行如下修改。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated Edit.tsx</figcaption></figure><p id="5f92" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有了这些变化，我们现在可以调用API来获取一篇文章的细节，然后进行相应的编辑。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated Edit.tsx</figcaption></figure><p id="9d74" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们解释一下这段代码。</p><ul class=""><li id="1a9b" class="mj mk in ku b kv kw ky kz lb ml lf mm lj mn ln mo mp mq mr bi translated">我们对端点进行了API调用，以获取特定的帖子，并分别更新表单标题和正文。</li><li id="b306" class="mj mk in ku b kv mw ky mx lb my lf mz lj na ln mo mp mq mr bi translated">我们通过使用<strong class="ku io"> Post.updatePost() </strong>函数进行API调用来更新<strong class="ku io"> handleSubmit </strong>函数，更新状态，并相应地关闭模态。</li></ul><h2 id="9704" class="np lr in bd ls nq nr dn lw ns nt dp ma lb nu nv mc lf nw nx me lj ny nz mg oa bi translated"><strong class="ak">删除一个帖子</strong></h2><p id="6faf" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">要删除一篇文章，我们需要用<strong class="ku io"> handleDelete </strong>函数更新<code class="fe ms mt mu mv b">Card.tsx</code>组件，并对我们的删除端点进行API调用。</p><p id="5b03" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们还需要用<strong class="ku io"> Posts </strong>和<strong class="ku io"> setPosts </strong>状态更新<code class="fe ms mt mu mv b">Card.tsx</code>和<code class="fe ms mt mu mv b">App.tsx</code>组件。这将允许我们相应地更新应用程序状态。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated App.tsx</figcaption></figure><p id="b516" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们还需要修改<code class="fe ms mt mu mv b">Card.tsx</code>并调用API来删除帖子</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Updated Card.tsx</figcaption></figure><h2 id="33d5" class="np lr in bd ls nq nr dn lw ns nt dp ma lb nu nv mc lf nw nx me lj ny nz mg oa bi translated"><strong class="ak">结论</strong></h2><p id="6813" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">这种将axios与TypeScript结合使用的方法使得代码易于测试、可重用并且更加简洁。</p><p id="f4a1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">参考文献<br/></strong><a class="ae lp" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank">https://github.com/axios/axios</a><br/><a class="ae lp" href="https://chakra-ui.com/" rel="noopener ugc nofollow" target="_blank">https://chakra-ui.com/</a><br/><a class="ae lp" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/</a><br/><a class="ae lp" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/</a></p></div></div>    
</body>
</html>