# 如何在 TypeScript 中使用类型保护

> 原文：<https://javascript.plainenglish.io/how-to-use-type-guarding-in-typescript-b3bbcd471970?source=collection_archive---------15----------------------->

## 不同的类型保护方式及其工作原理，并附有向导示例。

![](img/631f384640d719756292487553f93620.png)

TypeScript 规则，我花了几个小时将各种 JS(X)文件转换成 TS(X)。一路走来，我遇到了不少令人头疼的问题。我最近遇到的一个问题是必须使用**类型保护**，它用来“保护”某个代码块不使用错误的类型。这是一个相对简单的概念，但我想我会通过一些常见类型的守卫…使用向导的例子！

假设你有一个由冒险者组成的乌合之众团队，他们的任务是摧毁一个古老而邪恶的戒指，所有人的命运都悬而未决。

这些类中的每一个都继承自一个公共的`Adventurer`类，具有像`name`、`health`等基本属性。，并在其构造函数中接受一个`name`参数。此外，每个冒险者都有自己独特的技能和能力，例如`Wizard`可以`castSpell`而精灵可以`fireArrow`。

在他们冒险的一个特别痛苦的阶段，`Wizard`必须使用他们神奇的法术能力来抵挡大坏蛋巴洛克，所以我们很自然地找到了拥有`castSpell`能力的冒险者:

***TypeScript 编译器错误***

是的，我们得到的 TS 错误看起来像这样:

```
Property 'castSpell' does not exist on type 'Hobbit | Human | Dwarf | Wizard | Elf'.
```

什么给出了打字稿？嗯，当我们最初创建我们的`fellowship`数组时，TS 看到数组中有 5 种不同类型的`Adventurer`，因此将数组类型化为包含霍比特人、人类、矮人、巫师、*或*精灵的*联合*数组类型。我们也可以在创建数组时显式设置类型:

使用 TypeScript，我们不能使用类似于`adventurer.castSpell`的属性访问器，除非*类型的*联合*的所有*成员都具有该属性。可恶。我们的友谊开局不利。

为了绕过这一点，我们需要一个**型的防护罩。类型保护**“保护”代码块免受不需要的类型的影响。和所有事情一样，有几种方法可以使用类型保护。

## 选项 1 —类型断言

类型断言类似于其他语言中的“强制转换”。它们是我们告诉 TS 编译器我们知道的比它多，并“断言”给定实体是某种类型的一种方式。此外，类型断言不做任何额外的工作，只是假设您已经做了功课，并且断言的类型是正确的。因此，类型断言是 TS 不能完全解决的用例的一种逃生出口。总之，*明智地使用它们*。

有两种语法可以用于类型断言，即`as`语法和“尖括号”语法。对于我们的向导示例，它们看起来像这样:

`as`语法更加直观(imo)，如果你使用最新的`@typescript-eslint`，如果你使用尖括号，它甚至会对你大喊大叫。无论如何，回想我们的“明智使用”警告，我们需要绝对*确定*这是一个没有 TS 帮助的巫师。因为我们的`Wizard`职业是唯一一个使用`castSpell`方法的*职业，我们可以放心，我们抓到了正确的冒险者。*

然而，即使添加了断言，如果我们去施展我们的咒语:

我们又遇到了一个打字错误！这是因为我们只将参数`adventurer`断言为`Wizard`，但是 TypeScript 无法推断出这意味着`find`的返回值必须是`Wizard`。在得到我们想要的东西之前，我们必须在返回值上添加一个断言:

在实践中，使用类型断言通常不是最好的选择，而且通常有更好的方法来解决这个众所周知的难题。

## 选项 2 —类型谓词函数

对于向导的担心，另一个可能更可取的解决方案是定义一个返回**类型谓词**的函数:

这里的返回类型是**类型谓词**，形式为`parameterName` `is` `Type`。快速查字典告诉我们(是的，我查了字典)，在这个上下文中，谓词被定义为“逻辑中一个命题的主语所肯定或否定的东西”，这是有道理的。我们正在编写一个函数来确认或否认这实际上是一个向导。该函数接受一个*宽的*联合类型，在本例中为`Adventurer`，而*将*缩小为`Wizard`(从`Adventurer`继承而来)。注意，我们在这里也使用了类型断言。在这种情况下，区别在于我们实际上定义了一个函数，它说“如果它有一个`castSpell`属性，它*必须是一个`Wizard`，否则它不是没有`Wizard`”*

现在，有了我们闪亮的新型防护功能:

最后，一线希望照耀着我们的友谊！

如果我们的`fellowship`中有不止一个`Wizard`，并且我们想让他们一起对付邪恶的巴洛克，我们可以`filter`使用我们新的类型守卫的联合类型数组，给我们一个类型为`Wizard[]`的数组。

这是一个很好的向导！

## 选项 3 —输入运算符

我们可以使用的另一个选项是`in`操作符，看起来像这样:

在 JavaScript 中，如果属性存在于对象*或对象的原型链*中，则`in`操作符返回`true`。使用`in`操作符，TypeScript 将把并集缩小到只有具有给定属性的类型，即`Wizard`。此外，如果你添加了一个`else`块，TS 知道既然`if`块必须是一个`Wizard`，那么`else`块必须是其余块的并集。

像这样:

正如我们所看到的，与使用属性访问器(`wizard.castSpell`)不同，TypeScript *允许使用`in`操作符来测试属性的存在性，即使联合的所有成员都没有该属性。所以如果你需要测试一个对象的属性，使用`in`操作符！*

## 选项 4 — `instanceof`

我们还可以使用另一种技术来保护我们无畏的巫师，那就是使用`instanceof`。现在，每个人都知道巫师不是唯一拥有施法能力的神话生物，精灵也经常拥有异想天开的力量。假设我们的`Elf`类也有一个`castSpell`属性。既然两个生物现在可以`castSpell`，或者说`if` / `else`挡住现在的样子:

这是不行的！因为这两个实体现在都有了`castSpell`能力，我们得到了`Elf`或者`Wizard`的联盟，但是只有`Wizard`足够强大来阻止可怕的巴洛克。

进来的是`instanceof`操作符。`instanceof`操作符非常简单明了；它确定该对象是否是该类的的实例*。此外，它检查它是否出现在原型链中的任何地方。*

就像前面的选项一样，使用`instanceof`操作符*将`if`块中的联合类型缩小到`Wizard`:*

万岁。所以，很简单，我们需要做的就是这个:

## 选项 5-ish — `typeof`

我说这是第五种选择，因为它并不完全适用于我们的情况，但是如果我没有提到它，那就是我的失职。也可以使用`typeof`来缩小联合的类型。这更适用于处理字符串或数字等原语的情况:

# “真实世界”示例

巫师、领主和指环都很棒，但是你更可能在野外看到的例子呢？这是我最近遇到的一个(不太有趣的)问题，它让我陷入了这种特殊类型的守兔洞:

由于`url.searchParams.get`的返回类型是`string | null`，所以我不能把它赋给`media`，它的类型是`'svg' | 'video' | 'image' | 'all'`。我们需要确认用户传递的查询参数是(1)一个`string`类型而不是`null`,( 2)将其类型缩小到`Media`。我们可以使用上面概述的任意数量的策略来实现这一点——我选择编写一个快速类型谓词函数:

现在我们只需在分配`mediaParam`之前添加一个检查:

# 摘要

好吧。下面是我们检查过的保护向导类型的一些选项的快速运行:

## 类型断言

## 类型谓词函数

## `in`操作员

## `instanceof`操作员

基于简单和准确，使用`instanceof`可能是我们帮助`fellowship`逃离巴洛克魔爪的最佳选择。当然，不同类型防护装置的使用将取决于问题和环境！

感谢你们的阅读，希望你们学到了一些东西！

# 资源

*   [https://www . typescriptlang . org/docs/handbook/advanced-types . html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)
*   [https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/instance of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof)
*   [https://lotr.fandom.com/wiki/Main_Page](https://lotr.fandom.com/wiki/Main_Page)