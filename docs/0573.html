<html>
<head>
<title>Writing a Svelte Store with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用打字稿写一个苗条的商店</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-a-svelte-store-with-typescript-22fa1c901a4?source=collection_archive---------1-----------------------#2021-02-04">https://javascript.plainenglish.io/writing-a-svelte-store-with-typescript-22fa1c901a4?source=collection_archive---------1-----------------------#2021-02-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="70a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文不是对Svelte或TypeScript的介绍。如果您对这些技术中的任何一种都不熟悉，我建议您在深入研究这些主题之前做一些单独的研究。说完了，让我们开始吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d85654a68f1db8ec0e36363b477622c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H5MQ7xFwRuAN0j4d"/></div></div></figure><h1 id="0ac9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为什么是苗条商店</h1><p id="ea22" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">作为一名从事大型React应用程序开发的React开发人员，随着时间的推移，我对React应用程序的可伸缩性越来越失望。大型嵌套组件中的提升状态总是令人困惑和重复的，尤其是当组件有3层以上的深度时。将状态从一个更小的嵌套组件(如textfield)提升到页面的根级组件以便在组件之间共享数据是没有意义的</p><p id="79f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">找替代品，找了Redux，看了“为什么要用Redux”和“为什么不用Redux”的文章，最后都没用过。关于过多的样板代码和混乱的工作流的评论赶走了我，而且我从未从事过大到需要那种级别的状态管理的项目。</p><p id="d12e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后React发布了Context API，我以为会修复一切。在很短的一段时间里，前景似乎是光明的，但是上下文也开始让我失望，即使是在Hooks API集成的情况下。没完没了的组件包装器让我的组件变得冗长而不可读，并且强制子级重新渲染对性能的影响开始显现出来。</p><p id="09d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在很短的时间内，我研究了Vue3和Composition API，虽然它解决了一些问题，但它似乎也有一些React面临的潜在问题。我仍然认为组合API背后有一些潜在的力量，但Vue3还没有被广泛采用，因为从Vue2手动迁移，我不相信它会修复我所希望的一切。</p><p id="f69f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我决定是时候全身心投入到Svelte上了，这是一个新的闪亮的框架，有些人对此赞不绝口(它实际上是一个编译器，但我们不需要在这里深入研究)。几乎没有人支持，社区也很小，这似乎是一个风险，但我必须尝试。</p><p id="5527" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经过几周的教程和代码沙盒，我的赌博似乎有了回报。到目前为止，Svelte给我印象最深的是它的商店，以至于我正在写我的第一篇媒体文章来赞美它。</p><h1 id="f6d0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">示例商店</h1><p id="0dcb" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这个苗条的商店完全是对国家管理的重新想象，我喜欢它。让值“可反应”而不是必须将它们存储在“状态对象”中是一种范式转变，而且是一种受欢迎的转变。下面是我为一个简单应用程序创建的存储示例，它管理两个输入的值，firstname和lastname。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4b74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你在这一点上被吓倒了，<strong class="jm io">不要做</strong>。我们将讨论一个秘密语法，它使得使用这个商店<em class="lz">变得如此简单</em>。</p><p id="df03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">可写的</strong>函数使这些值“可反应”，允许组件订阅(读取)和更新这些值。如果你来自一个反动的背景，这有点像国家，但这是不同的。</p><p id="fc1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以使用<strong class="jm io">派生的</strong>函数，它类似于Vue中的计算值。这将把你的“存储”对象(可写的)，并拉当前值，然后在一个可读的对象返回它。Derived还监视传递给它的任何可写对象的变化，只有当它们发生变化时才更新，所以您将总是获得最新的值，并且具有出色的性能。</p><p id="2558" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，在我的存储文件中，我在底部附近导出了一个<strong class="jm io">单例</strong>，这个<strong class="jm io">只被创建一次</strong>，并且可以全局访问。这与React不同，React会在每次重新渲染时重新运行所有的状态代码。React有一个设置，使这成为一个非常有效的过程，但它仍然是不同的。如果您想要创建多个存储，这对于使用苗条的上下文(另一篇文章的主题)可能是有效的，您可以使用存储文件最底部的注释代码。</p><h1 id="cc95" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">行动中的苗条商店</h1><p id="bb6c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在我们已经创建了这个商店，让我们使用它。这是一个从我们的存储中访问值的瘦组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4039" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们从myFormStore中析构属性以获取firstname和lastname时，我们接收到了两个可写的<strong class="jm io">对象。本质上，你不能从writable中访问值，但是通过一些特殊的语法，我们可以。通过在我们的变量前加前缀' $ '，Svelte为该值创建了一个自动订阅，甚至会在组件卸载时取消订阅(太神奇了！).如果你想了解更多关于订阅的信息，我推荐你跟随他们网站上的苗条教程，它很直观也很容易跟随。</strong></p><p id="0f19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在第12行和第16行看到使用' $ '快捷方式的示例，这里我们将可写值绑定到输入的值属性。这个绑定类似于Vue的v-model，它去掉了添加onChange和value prop的模板。现在，如果我们在输入字段中输入值，那么存储中的firstname和lastname值将会自动更新，还有我们派生的fullname属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="a420" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还在上面创建了另一个组件，它利用商店并使用全名值。它与第一个组件(无嵌套)在同一层级上。在这里，我们再次使用了' $ '语法，因为fullname是一个<strong class="jm io">可读的</strong>对象，现在每当任何一个<strong class="jm io">可写的</strong>存储值(firstname或lastname)发生变化时，我们都会自动更新该值。该存储可以被10到15个组件使用，而不会引入混乱和冗长的嵌套。</p><h1 id="4efa" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="6851" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">到目前为止，我对Svelte的体验非常棒，我想分享我所学到的东西，这样社区就会发展壮大，并开始被大规模采用。如果你喜欢这篇文章，请让我知道，我很乐意提供更多的概念，如上下文或使用' $:'语法燃料反应性苗条教程。编码快乐！</p><p id="4a71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个Github回购和代码的链接<br/><a class="ae ma" href="https://github.com/doughill1000/store-svelte-typescript" rel="noopener ugc nofollow" target="_blank">https://github.com/doughill1000/store-svelte-typescript</a></p><div class="mb mc gp gr md me"><a href="https://doughill1000.github.io/store-svelte-typescript/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd io gy z fp mj fr fs mk fu fw im bi translated">苗条的应用</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">编辑描述</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">doughill1000.github.io</p></div></div></div></a></div></div></div>    
</body>
</html>