<html>
<head>
<title>What Makes Modern Web Development Frustrating</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让现代Web开发令人沮丧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-makes-modern-web-development-frustrating-92d696ae1da3?source=collection_archive---------16-----------------------#2021-07-20">https://javascript.plainenglish.io/what-makes-modern-web-development-frustrating-92d696ae1da3?source=collection_archive---------16-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="44de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么会这样</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5958322f2a8127bf2f26a70d8a547971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTNqW3DxVVnlKP4Xz9ZQ5g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Base image by <a class="ae kv" href="https://unsplash.com/@sharonmccutcheon" rel="noopener ugc nofollow" target="_blank">@sharonmccutcheon</a> on <a class="ae kv" href="https://unsplash.com/photos/KFqosh9fuDo" rel="noopener ugc nofollow" target="_blank">unsplash</a>. Code generated using <a class="ae kv" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">Carbon</a></figcaption></figure><p id="935e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">web是开发人员构建应用程序的最受欢迎的平台之一。根据<a class="ae kv" href="https://insights.stackoverflow.com/survey/2020#technology-programming-scripting-and-markup-languages-all-respondents" rel="noopener ugc nofollow" target="_blank"> Stack Overflow的2020年调查</a>，JavaScript和HTML/CSS是最受欢迎的技术<a class="ae kv" href="https://insights.stackoverflow.com/survey/2015#tech" rel="noopener ugc nofollow" target="_blank">自2013年</a>以来一直如此。</p><p id="b0f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管web开发如此受欢迎，但它也有令人沮丧的地方。这对于现代web开发和过去的web开发都是如此。然而，所有web开发的一个共同点是JavaScript的使用以及随之而来的问题。</p><p id="5b6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript基于一个名为<a class="ae kv" href="https://www.ecma-international.org/technical-committees/tc39/" rel="noopener ugc nofollow" target="_blank"> ECMAScript (ES) </a>的规范。过去规范的进展非常缓慢。ES5于2009年12月发布；上一个版本的10年后。ES6也称为ES2015，于2015年6月发布，比ES5晚了近6年。ES6带来了许多改变JavaScript的新特性。此外，在ES2015之后，ES的新版本开始更加一致地发布。JavaScript终于变得更好了！然而，这也产生了新的问题。</p><h1 id="ea6d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题</h1><p id="f969" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JavaScript主要运行在web浏览器上。这就是web应用程序如此容易访问和流行的原因。市场上有很多浏览器在竞争。最重要的是，这些浏览器定期更新，并且有多种版本。这对最终用户来说是件好事，但对开发者来说却很复杂。这是因为浏览器运行在用户的机器上，开发者无法控制它。</p><p id="666d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于桌面应用，我们经常会看到“此应用只能在Windows 10上运行”之类的软件需求。对于web应用程序，很难告诉用户类似“该应用程序运行在Chrome v80及更高版本上”的内容。对于大多数普通用户来说，跟踪浏览器版本是一项艰巨的任务，因为浏览器更新发布得如此频繁。忘记用户；即使是开发人员也很难跟踪浏览器版本及其支持的功能。</p><p id="5757" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如在ES5 中引入了方法<code class="fe mp mq mr ms b">Array.reduce</code> <a class="ae kv" href="https://262.ecma-international.org/5.1/#sec-15.4.4.21" rel="noopener ugc nofollow" target="_blank">。如果你要编写使用<code class="fe mp mq mr ms b">Array.reduce</code>的JavaScript代码，它将不能在任何没有实现ES5的<code class="fe mp mq mr ms b">Array.reduce</code>的浏览器中运行。这将包括在下图所示版本之前发布的所有浏览器版本。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/9f629ef8a0bc16f9933d1ad168d4b8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWE7YK6WqZAdgLzPzHkLXQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">MDN</a></figcaption></figure><p id="1991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，让<code class="fe mp mq mr ms b">Array.reduce</code>在旧的浏览器中工作是可能的。你可以在你的文件顶部放一个特殊的脚本来实现<code class="fe mp mq mr ms b">Array.reduce</code>。这保证了<code class="fe mp mq mr ms b">Array.reduce</code>可以在老版本的浏览器上运行。这被称为聚合填充。<code class="fe mp mq mr ms b">Array.reduce</code>的自定义实现被称为polyfill。</p><p id="8084" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">真正轰动的是ES6的发布，因为它带来了无法聚合填充的功能。这是因为它引入了诸如<a class="ae kv" href="https://262.ecma-international.org/6.0/#sec-template-literal-lexical-components" rel="noopener ugc nofollow" target="_blank">模板字符串</a>、<code class="fe mp mq mr ms b"><a class="ae kv" href="https://262.ecma-international.org/6.0/#sec-imports" rel="noopener ugc nofollow" target="_blank">import/export</a></code>语法、<code class="fe mp mq mr ms b"><a class="ae kv" href="https://262.ecma-international.org/6.0/#sec-for-in-and-for-of-statements" rel="noopener ugc nofollow" target="_blank">for…of</a></code>循环、<a class="ae kv" href="https://262.ecma-international.org/6.0/#sec-arrow-function-definitions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>、<code class="fe mp mq mr ms b"><a class="ae kv" href="https://262.ecma-international.org/6.0/#sec-let-and-const-declarations" rel="noopener ugc nofollow" target="_blank">let</a></code>、<a class="ae kv" href="https://262.ecma-international.org/6.0/#sec-let-and-const-declarations" rel="noopener ugc nofollow" target="_blank">、</a>、<a class="ae kv" href="https://262.ecma-international.org/6.0/#sec-generator-function-definitions" rel="noopener ugc nofollow" target="_blank">生成器</a>等语言特性。创建方法和类的自定义实现是可能的。然而，创建语言语法的自定义实现是不可能的。</p><p id="4ce4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员需要一种方法来编写现代JavaScript代码，并且仍然能够在较旧的浏览器中运行。这产生了现代web开发中使用的两个重要概念——传输和捆绑。</p><h1 id="46bc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">当今的解决方案</h1><p id="7f0d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Transpilation类似于编译。在JavaScript的上下文中，翻译就是将代码从一个ECMAScript版本转换到另一个版本的过程。无论你使用哪种前端框架，它都有办法将现代的JavaScript移植到旧的框架中。一些框架会隐藏这些细节，以减轻开发人员的负担。最流行的JavaScript翻译工具之一是babel。</p><p id="1291" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于JavaScript生态系统来说，Transpilation并不是一个新概念。在ES6推出的时候，我们已经有了像<a class="ae kv" href="https://coffeescript.org/" rel="noopener ugc nofollow" target="_blank"> CoffeeScript </a>和<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>这样的语言，这两种语言都可以向下转换成JavaScript。</p><p id="d52e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Polyfills现在也在使用，因为新的API一直在引入和起草。但是，与过去不同的是，您不必手动包含聚合填充。</p><p id="a140" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个很好的工具叫做<a class="ae kv" href="https://github.com/zloirock/core-js" rel="noopener ugc nofollow" target="_blank"> core-js </a>，它会自动为你做这件事。<code class="fe mp mq mr ms b">babel</code>可以使用<code class="fe mp mq mr ms b">core-js</code>,如果您将其配置为。这是一种让babel为您完成运输和多灌装的便捷方式。</p><p id="ac25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一个很棒的服务叫做<a class="ae kv" href="https://polyfill.io/" rel="noopener ugc nofollow" target="_blank"> polyfill.io </a>，它可以检测你正在使用的浏览器，并自动填充缺失的功能。</p><p id="10df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Transpilation和polyfilling也为语言特性的实验打开了大门，甚至在它们发布之前。<a class="ae kv" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> React的JSX </a>也有<a class="ae kv" href="https://betterprogramming.pub/how-react-jsx-works-under-the-hood-6b177a8a57e1" rel="noopener ugc nofollow" target="_blank">可能是因为transpilation </a>。</p><p id="3ecf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与transpilaton和polyfills完美结合的工具是<a class="ae kv" href="https://github.com/browserslist/browserslist" rel="noopener ugc nofollow" target="_blank"> browserslist </a>。这个工具维护一个数据库，其中包含哪些浏览器支持哪些功能。该工具还允许开发人员指定他们想要的目标浏览器。像<code class="fe mp mq mr ms b">babel</code>和<code class="fe mp mq mr ms b">core-js</code>这样的工具可以读取<code class="fe mp mq mr ms b">browserslist</code>的配置。这就把决定要向下转换到哪个es版本以及要包含哪些聚合填充的负担从开发人员的肩上卸了下来。这些工具将使用<code class="fe mp mq mr ms b">browserslist</code>配置自动做出这些决定。相当整洁！</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="0923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">捆绑销售完全是另一回事。在过去，如果您想在多个文件中编写JavaScript代码，您必须公开可以在这些脚本中使用的全局变量。因此，您最终会有多个脚本标记。例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/67a7cab6cdd91c68465bad30adf988e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*4A27MK9x2TkEjGbKN94EcQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Created using <a class="ae kv" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">Carbon</a></figcaption></figure><p id="13ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这在当时非常慢，因为浏览器使用了<a class="ae kv" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#History" rel="noopener ugc nofollow" target="_blank"> HTTP/1 </a>。这个版本的HTTP在处理多个请求时速度较慢。即使现在，并不是每个人都迁移到新版本HTTP/2，但是<a class="ae kv" href="https://almanac.httparchive.org/en/2020/http2#http2-adoption" rel="noopener ugc nofollow" target="_blank">的采用正在逐渐增加</a>。</p><p id="837e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是加载一个大文件。我们都知道处理一个有数千行代码的长文件是多么令人沮丧。对此的解决方案是以某种方式将这些多个文件缝合在一起，并创建一个包含所有代码的新文件。在<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>发布之前，这个解决方案是相当可行的。</p><p id="bf67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node.js带来了<code class="fe mp mq mr ms b"><a class="ae kv" href="https://nodejs.org/en/knowledge/getting-started/what-is-require/" rel="noopener ugc nofollow" target="_blank">require</a></code>语法。表面上看，这和<code class="fe mp mq mr ms b">import</code>差不多。有一些不同之处，我们不会在这里讨论。最终，一个名为<a class="ae kv" href="https://browserify.org/" rel="noopener ugc nofollow" target="_blank"> Browserify </a>的工具诞生了，它的目标是使在浏览器中使用Node.js编写的代码成为可能。这自然需要对polyfill <code class="fe mp mq mr ms b">require</code>施些魔法，让它在浏览器中运行。这个魔术最重要的部分之一是创建一个文件——一个包含应用程序中所有导入/必需代码的包。</p><p id="a53d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后来，像<a class="ae kv" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>这样的工具紧随其后，它们引入的特性不仅捆绑了JavaScript，还捆绑了其他文件类型，比如<code class="fe mp mq mr ms b">css</code>和<code class="fe mp mq mr ms b">svg</code>文件等等。Webpack还可以配置为使用babel或typescript，以便在构建包时能够传输和聚合填充代码。</p><p id="86cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bundlers也可以用来做其他整洁的事情，比如移除未使用的代码、<a class="ae kv" href="https://en.wikipedia.org/wiki/Minification_(programming)" rel="noopener ugc nofollow" target="_blank">缩小</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Obfuscation_(software)" rel="noopener ugc nofollow" target="_blank">混淆</a>等等。目前，有少数捆扎机可供选择。</p><h1 id="6891" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的想法</h1><p id="73b2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于用户和开发者来说，Web是最容易访问的平台之一。这种可访问性和易用性也产生了对web应用程序能够处理各种用例的需求。因此，网络技术和浏览器一直在发展。</p><p id="63d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着技术和浏览器的发展，开发人员将需要支持旧版本的浏览器。使用允许开发人员维护向后兼容性的工具可能会令人沮丧，尤其是对初学者而言。这是因为有太多的概念和工具需要学习。除此之外，还有很多插件可以与这些工具一起工作。</p><p id="5451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，尽管有时会很复杂和令人沮丧，但我们现在拥有的解决方案是非常必要的。另一种选择是企业失去潜在客户，这是很难接受的。目前，我们能做的最好的事情就是为那些不想或不需要处理它的开发人员抽象出复杂性，让他们免受挫折。</p><p id="ffdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，现代web开发相当复杂，但这使得设计和构建复杂的应用程序变得更加容易。初学者仍然可以在不深入复杂的情况下制作应用程序。有经验的开发人员应该能够理解复杂性，而不会不知所措。</p><h1 id="39df" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">进一步阅读</h1><p id="7837" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">想了解更多关于polyfills的信息吗？这里有一篇由<a class="nc nd ep" href="https://medium.com/u/f735d3b0f2f3?source=post_page-----92d696ae1da3--------------------------------" rel="noopener" target="_blank">大卫·吉尔伯森</a>撰写的关于polyfills的精彩文章。它甚至解释了transpiling和polyfilling之间的细微差别，如果这让你感到困惑的话。</p><div class="ne nf gp gr ng nh"><a href="https://medium.com/hackernoon/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">Polyfills:你想知道的一切，或者少一点</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">我们今天生活的浏览器世界非常棒。你可以使用承诺、获取和箭头函数以及常量和…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div><p id="1f4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想弄清楚为什么HTTP/1对于多个请求比较慢，HTTP/2是如何解决这个问题的？<a class="ae kv" href="https://factoryhr.medium.com/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b" rel="noopener">这里</a>是HTTP/2上<a class="nc nd ep" href="https://medium.com/u/b859a48da322?source=post_page-----92d696ae1da3--------------------------------" rel="noopener" target="_blank"> Factory.hr </a>的一篇文章。</p><div class="ne nf gp gr ng nh"><a href="https://factoryhr.medium.com/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">HTTP/2:HTTP/1.1的区别，好处以及如何使用</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">关于如何为ubuntu设置HTTP/2和服务器推送使用的细节也可以在工厂Github上找到。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">factoryhr.medium.com</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv kp nh"/></div></div></a></div><p id="3c2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nx">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>