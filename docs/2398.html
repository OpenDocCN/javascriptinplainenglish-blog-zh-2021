<html>
<head>
<title>Introduction to Raycasting in Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Three.js中光线投射的介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-raycasting-in-three-js-211ac4aae768?source=collection_archive---------1-----------------------#2021-05-18">https://javascript.plainenglish.io/intro-to-raycasting-in-three-js-211ac4aae768?source=collection_archive---------1-----------------------#2021-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/0e7571512c9f75b264c8f46cb3c81295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*G-f2vTSSQ5GFn0hX7P8QOA.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk"><a class="ae jv" href="https://somethinghitme.com/2011/11/16/fake-2d-lighting-with-javascript/" rel="noopener ugc nofollow" target="_blank">https://somethinghitme.com/2011/11/16/fake-2d-lighting-with-javascript/</a></figcaption></figure><p id="0b06" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">如果你是游戏开发者，这篇文章可能很平常。但是对于很多前端开发人员和交互设计师(包括我自己)来说，这个概念相当新。<a class="ae jv" href="https://en.wikipedia.org/wiki/Ray_casting" rel="noopener ugc nofollow" target="_blank"> <strong class="jy io">光线投射</strong>是利用光线-表面相交测试来解决3D计算机图形学和计算几何中的各种问题</a></p><p id="07f6" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">当使用<a class="ae jv" href="https://threejs.org/" rel="noopener ugc nofollow" target="_blank"> Three.js </a>在网络上处理3D图形时，图形使用<a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> HTML canvas </a> API进行渲染。除了一些“例外”，这可能会阻止您将渲染对象作为<a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank"> DOM元素</a>进行访问。例如，如果您在three.js中创建一个立方体并检查浏览器检查器，您会注意到您只能访问保存Three.js场景的画布容器。像这样的情况可以用Three.js中的<a class="ae jv" href="https://threejs.org/docs/#api/en/core/Raycaster" rel="noopener ugc nofollow" target="_blank"> Raycaster </a>类来解决。</p><h1 id="b216" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是光线投射？</h1><p id="8c90" class="pw-post-body-paragraph jw jx in jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ig bi translated"><a class="ae jv" href="https://threejsfundamentals.org/threejs/lessons/threejs-picking.html" rel="noopener ugc nofollow" target="_blank">Threejsfundamentals.org</a>将光线投射或物体拾取描述为“找出用户点击或触摸了哪个物体的过程”。本质上，一个指针从你的鼠标或手指(在手机上)通过场景的<a class="ae jv" href="https://threejs.org/docs/#api/en/math/Frustum" rel="noopener ugc nofollow" target="_blank">平截头体</a>投射到与之相交的物体上。为了在特定对象上执行逻辑，这个方法非常有用。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lx"><img src="../Images/afad019b43c05c4d505a53e8143b0643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JXgLTYksSHsAMxb5AJluXg.png"/></div></div></figure><h1 id="8e05" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Three.js中的Raycaster类是什么？</h1><p id="2ac6" class="pw-post-body-paragraph jw jx in jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ig bi translated">Raycaster类是Three.js提供的一个类，用于简化对象拾取。</p><h1 id="ab2c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">让我们编码。</h1><p id="d9e7" class="pw-post-body-paragraph jw jx in jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ig bi translated">本文的计划是解释如何点击一个已经在3D世界空间中渲染的球体。如果你想学习如何设置一个Three.js场景，可以看看我的另一篇文章<a class="ae jv" href="https://levelup.gitconnected.com/visually-mapping-out-3d-with-three-js-eef3f6adfd2f" rel="noopener ugc nofollow" target="_blank">“用Three.js可视化绘制3D”</a>。对于本文，我们将只关注光线投射的流程。</p><p id="683b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">下面是一个简单的three.js样板设置:</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="d792" class="ml kv in mh b gy mm mn l mo mp">// set inner height and width based on screen size</span><span id="c228" class="ml kv in mh b gy mq mn l mo mp">const winWidth = window.innerWidth;</span><span id="91e5" class="ml kv in mh b gy mq mn l mo mp">const winHeight = window.innerHeight;</span><span id="bccb" class="ml kv in mh b gy mq mn l mo mp">// global variables</span><span id="b7eb" class="ml kv in mh b gy mq mn l mo mp">let scene, camera, renderer, controls, circle;</span><span id="c1d0" class="ml kv in mh b gy mq mn l mo mp">let objects = [];</span><span id="c755" class="ml kv in mh b gy mq mn l mo mp">init();</span><span id="940b" class="ml kv in mh b gy mq mn l mo mp">update();</span><span id="87c2" class="ml kv in mh b gy mq mn l mo mp">function init() {<br/></span><span id="e1d8" class="ml kv in mh b gy mq mn l mo mp">// scene and camera positioning</span><span id="5dc6" class="ml kv in mh b gy mq mn l mo mp">scene = new THREE.Scene();</span><span id="f24e" class="ml kv in mh b gy mq mn l mo mp">scene.background = new THREE.Color(0xffffff);</span><span id="04be" class="ml kv in mh b gy mq mn l mo mp">camera = new THREE.PerspectiveCamera(75, winWidth / winHeight, 0.01, 1000);</span><span id="e3a0" class="ml kv in mh b gy mq mn l mo mp">camera.position.set(0, 0, 40);</span><span id="d9f7" class="ml kv in mh b gy mq mn l mo mp">//lighting</span><span id="2507" class="ml kv in mh b gy mq mn l mo mp">const hemisphere = new THREE.HemisphereLight(0xffffff, 0xff0000, 1);</span><span id="ce63" class="ml kv in mh b gy mq mn l mo mp">scene.add(hemisphere);</span><span id="8534" class="ml kv in mh b gy mq mn l mo mp">const directional = new THREE.DirectionalLight(0xffffff, 0.5);</span><span id="fbea" class="ml kv in mh b gy mq mn l mo mp">scene.add(directional);</span><span id="931d" class="ml kv in mh b gy mq mn l mo mp">// render</span><span id="e2f5" class="ml kv in mh b gy mq mn l mo mp">renderer = new THREE.WebGLRenderer();</span><span id="caeb" class="ml kv in mh b gy mq mn l mo mp">renderer.setSize(winWidth, winHeight);</span><span id="bd72" class="ml kv in mh b gy mq mn l mo mp">//geometry</span><span id="ca7f" class="ml kv in mh b gy mq mn l mo mp">const geometry = new THREE.SphereGeometry(10, 64, 64);</span><span id="6dec" class="ml kv in mh b gy mq mn l mo mp">//material</span><span id="118d" class="ml kv in mh b gy mq mn l mo mp">const material = new THREE.MeshStandardMaterial({</span><span id="b4e9" class="ml kv in mh b gy mq mn l mo mp">color: "red",</span><span id="fb41" class="ml kv in mh b gy mq mn l mo mp">metalness: 0.5,</span><span id="6c4d" class="ml kv in mh b gy mq mn l mo mp">roughness: 1,</span><span id="a94a" class="ml kv in mh b gy mq mn l mo mp">});<br/></span><span id="abc8" class="ml kv in mh b gy mq mn l mo mp">//mesh</span><span id="5f5e" class="ml kv in mh b gy mq mn l mo mp">circle = new THREE.Mesh(geometry, material);</span><span id="a533" class="ml kv in mh b gy mq mn l mo mp">scene.add(circle);</span><span id="a2c1" class="ml kv in mh b gy mq mn l mo mp">// raycaster code goes here</span><span id="17ee" class="ml kv in mh b gy mq mn l mo mp">// append canvas to dom element</span><span id="5e84" class="ml kv in mh b gy mq mn l mo mp">document.getElementById("container").appendChild(renderer.domElement);</span><span id="90c3" class="ml kv in mh b gy mq mn l mo mp">// call resize function on resize</span><span id="b3b1" class="ml kv in mh b gy mq mn l mo mp">window.addEventListener("resize", resize, false);</span><span id="5bc2" class="ml kv in mh b gy mq mn l mo mp">}</span><span id="02f4" class="ml kv in mh b gy mq mn l mo mp">// update loop</span><span id="ed6e" class="ml kv in mh b gy mq mn l mo mp">function update() {</span><span id="04d2" class="ml kv in mh b gy mq mn l mo mp">requestAnimationFrame(update);</span><span id="975a" class="ml kv in mh b gy mq mn l mo mp">renderer.render(scene, camera);</span><span id="7ef9" class="ml kv in mh b gy mq mn l mo mp">}</span><span id="c8bc" class="ml kv in mh b gy mq mn l mo mp">// resize function</span><span id="e5bb" class="ml kv in mh b gy mq mn l mo mp">function resize() {</span><span id="b905" class="ml kv in mh b gy mq mn l mo mp">camera.aspect = winWidth / winHeight;</span><span id="27dc" class="ml kv in mh b gy mq mn l mo mp">camera.updateProjectionMatrix();</span><span id="247e" class="ml kv in mh b gy mq mn l mo mp">renderer.setSize(window.innerWidth, window.innerHeight);</span><span id="b5a3" class="ml kv in mh b gy mq mn l mo mp">}</span></pre><h1 id="9111" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">添加Raycaster类</h1><p id="1a85" class="pw-post-body-paragraph jw jx in jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ig bi translated">下面，写着…</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="8dca" class="ml kv in mh b gy mm mn l mo mp">// raycaster code goes here</span></pre><p id="72a9" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">…添加以下代码:</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="45eb" class="ml kv in mh b gy mm mn l mo mp">// 3d mouse<br/>  document.addEventListener('mousedown', onMouseDown);</span><span id="db97" class="ml kv in mh b gy mq mn l mo mp">function onMouseDown( event ){<br/>    event.preventDefault();</span><span id="ca99" class="ml kv in mh b gy mq mn l mo mp">// x<br/>    const mouse3D = new THREE.Vector3( (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerheight) * 2 - 1, 0.5 )</span><span id="3de1" class="ml kv in mh b gy mq mn l mo mp">    const raycaster = new THREE.Raycaster()<br/>    raycaster.setFromCamera(mouse3D, camera)<br/>    const intersects = raycaster.intersectObjects(objects);</span><span id="01e5" class="ml kv in mh b gy mq mn l mo mp">if(intersects.length &gt; 0){<br/>      intersects[0].object.material.color.setHex( Math.random() * 0xffffff )<br/>    }<br/>  }</span></pre><h1 id="f596" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置鼠标按下事件</h1><p id="0e8c" class="pw-post-body-paragraph jw jx in jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ig bi translated">我们需要做的第一件事是添加一个事件监听器来监听鼠标点击。我们可以使用<a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mousedown_event" rel="noopener ugc nofollow" target="_blank"> mousedown </a>事件来做到这一点。我们还可以创建一个名为<em class="mr"> onMouseDown </em>的事件处理函数，当鼠标被点击时，它将触发光线投射。</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="9a69" class="ml kv in mh b gy mm mn l mo mp">// mousedown event listener<br/>document.addEventListener('mousedown', onMouseDown);</span><span id="19b2" class="ml kv in mh b gy mq mn l mo mp">// mousedown event handler function<br/>function onMouseDown( event ){<br/>event.preventDefault();</span><span id="a850" class="ml kv in mh b gy mq mn l mo mp">   //insert raycaster code here   <br/></span><span id="4bfa" class="ml kv in mh b gy mq mn l mo mp"> }</span></pre><h1 id="fa32" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">获取鼠标的坐标</h1><p id="b721" class="pw-post-body-paragraph jw jx in jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ig bi translated">目前，当鼠标按下事件被触发时，没有办法知道鼠标与场景的哪个部分相交。一旦计算出来，我们就可以检查这个坐标是否与圆相交。</p><p id="0feb" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在<em class="mr"> onMouseDown </em>函数中添加以下内容:</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="d6bd" class="ml kv in mh b gy mm mn l mo mp">const mouse3D = new THREE.Vector3( (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerheight) * 2 - 1, 0.5 )</span></pre><p id="68d4" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">由于格式的原因，上面的代码可能看起来有点混乱，但本质上是这样的。</p><ol class=""><li id="45b9" class="ms mt in jy b jz ka kd ke kh mu kl mv kp mw kt mx my mz na bi translated">我们正在创建Three.js <a class="ae jv" href="https://threejs.org/docs/#api/en/math/Vector3" rel="noopener ugc nofollow" target="_blank"> Vector3 </a>类的一个实例，并将其存储在一个变量中。</li><li id="09d7" class="ms mt in jy b jz nb kd nc kh nd kl ne kp nf kt mx my mz na bi translated">Vector3接受3个数字参数Vector3( x，y，z)。这些数字可以用于不同的原因，但其中最常见的是在场景或“世界空间”中设置一个坐标(<a class="ae jv" href="https://gamedev.stackexchange.com/questions/65783/what-are-world-space-and-eye-space-in-game-development" rel="noopener ugc nofollow" target="_blank">这个论坛帖子很好地解释了世界空间的概念</a>)。</li><li id="54f2" class="ms mt in jy b jz nb kd nc kh nd kl ne kp nf kt mx my mz na bi translated">我们传入的参数是使用以下方法获取鼠标按下时的x、y和z坐标:</li></ol><p id="7fdc" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><em class="mr"> //获取x坐标<br/>event . clientx/window . inner width)* 2–1</em></p><p id="feaf" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><em class="mr"> //获取y坐标<br/>-(event . clienty/window . inner height)* 2–1</em></p><p id="d5c5" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><em class="mr"> // z坐标始终为0.5 <br/> 0.5 </em></p><p id="e855" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">注意:</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="424c" class="ml kv in mh b gy mm mn l mo mp">* 2 - 1</span></pre><p id="e3e1" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">上面的等式是为了确保坐标范围从-1到1。如果我们把它去掉，坐标范围就是0到1。</p><h1 id="5db4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置Raycaster</h1><p id="d9a7" class="pw-post-body-paragraph jw jx in jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ig bi translated">在下一步，我们最终要设置光线投射功能。在<em class="mr"> onMouseMove </em>函数下面添加以下代码:</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="f081" class="ml kv in mh b gy mm mn l mo mp">// instantiate raycaster <br/>const raycaster = new THREE.Raycaster()</span><span id="b5b5" class="ml kv in mh b gy mq mn l mo mp">// sets the pointer/ray with an orgin and direction<br/>raycaster.setFromCamera(mouse3D, camera)</span><span id="3b7c" class="ml kv in mh b gy mq mn l mo mp"><br/>//checks object array for any intersecting objects</span><span id="7eda" class="ml kv in mh b gy mq mn l mo mp">const intersects = raycaster.intersectObjects(objects);</span><span id="92b6" class="ml kv in mh b gy mq mn l mo mp"><br/>//if the array is more than zero, get the first intersected object and change the object material color to a random color</span><span id="029d" class="ml kv in mh b gy mq mn l mo mp">if(intersects.length &gt; 0){<br/>      intersects[0].object.material.color.setHex( Math.random() * 0xffffff )<br/>    }</span></pre><p id="816f" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">让我们来看看这些步骤。</p><ol class=""><li id="575b" class="ms mt in jy b jz ka kd ke kh mu kl mv kp mw kt mx my mz na bi translated">从Three.js <a class="ae jv" href="https://threejs.org/docs/?q=raycaster#api/en/core/Raycaster" rel="noopener ugc nofollow" target="_blank"> Raycaster </a>类中实例化一个raycaster</li></ol><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="da1a" class="ml kv in mh b gy mm mn l mo mp">// instantiate raycaster <br/>const raycaster = new THREE.Raycaster()</span></pre><p id="b352" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">2.调用光线投射方法<em class="mr"> setFromCamera </em>。这个方法需要两个参数，鼠标3D的坐标和相机的坐标。这个方法将设置光线的原点和方向。</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="a166" class="ml kv in mh b gy mm mn l mo mp">raycaster.setFromCamera(mouse3D, camera)</span></pre><p id="ed1e" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">3.调用光线投射方法<em class="mr">相交对象</em>。这个方法接受一个对象并返回一个相交对象的数组。如果没有相交对象，将返回一个空数组。</p><p id="08c6" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">注意:在这个特定的用例中，我最初创建了一个名为<em class="mr"> objects </em>的空数组，并将我的circle对象推入数组。然后我将数组传递给了<em class="mr"> intersectObjects </em>方法。这样，如果我有更多的对象，这个方法可以检查所有的对象。</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="9f99" class="ml kv in mh b gy mm mn l mo mp">//checks object array for any intersecting objects</span><span id="0064" class="ml kv in mh b gy mq mn l mo mp">const intersects = raycaster.intersectObjects(objects);</span></pre><p id="86ae" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">4.最后，如果有一个相交的物体，我们想改变颜色为随机颜色。</p><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="0b6b" class="ml kv in mh b gy mm mn l mo mp">//if the array is more than zero, get the first intersected object and change the object material color to a random color</span><span id="661c" class="ml kv in mh b gy mq mn l mo mp">if(intersects.length &gt; 0){<br/>      intersects[0].object.material.color.setHex( Math.random() * 0xffffff )<br/>    }</span></pre><h1 id="fbba" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">最终代码</h1><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="ng nh l"/></div></figure><pre class="ly lz ma mb gt mg mh mi mj aw mk bi"><span id="d6d1" class="ml kv in mh b gy mm mn l mo mp">// set inner height and width based on screen size<br/>const winWidth = window.innerWidth;<br/>const winHeight = window.innerHeight;</span><span id="4bbf" class="ml kv in mh b gy mq mn l mo mp">// global vars<br/>let scene, camera, renderer, controls, circle;<br/>let objects = [];</span><span id="2bb7" class="ml kv in mh b gy mq mn l mo mp">init();<br/>update();</span><span id="dda5" class="ml kv in mh b gy mq mn l mo mp">function init() {<br/>  // scene and camera positioning<br/>  scene = new THREE.Scene();<br/>  scene.background = new THREE.Color(0xffffff);<br/>  camera = new THREE.PerspectiveCamera(75, winWidth / winHeight, 0.01, 1000);<br/>  camera.position.set(0, 0, 40);</span><span id="c3a2" class="ml kv in mh b gy mq mn l mo mp">//lighting<br/>  const hemisphere = new THREE.HemisphereLight(0xffffff, 0xff0000, 1);<br/>  scene.add(hemisphere);</span><span id="b3b9" class="ml kv in mh b gy mq mn l mo mp">const directional = new THREE.DirectionalLight(0xffffff, 0.5);<br/>  scene.add(directional);</span><span id="0522" class="ml kv in mh b gy mq mn l mo mp">// render<br/>  renderer = new THREE.WebGLRenderer();<br/>  renderer.setSize(winWidth, winHeight);</span><span id="537f" class="ml kv in mh b gy mq mn l mo mp">//geometry<br/>  const geometry = new THREE.SphereGeometry(10, 64, 64);<br/>  //material<br/>  const material = new THREE.MeshStandardMaterial({<br/>    color: "red",<br/>    metalness: 0.5,<br/>    roughness: 1,<br/>  });</span><span id="c702" class="ml kv in mh b gy mq mn l mo mp">  //mesh<br/>  circle = new THREE.Mesh(geometry, material);<br/>  scene.add(circle);</span><span id="0386" class="ml kv in mh b gy mq mn l mo mp">//push everything into an object for raycasting<br/>  objects.push(circle);</span><span id="4f94" class="ml kv in mh b gy mq mn l mo mp">//3d mouse<br/>  document.addEventListener("mousedown", onMouseDown);</span><span id="25f6" class="ml kv in mh b gy mq mn l mo mp">function onMouseDown(event) {<br/>    event.preventDefault();</span><span id="17a8" class="ml kv in mh b gy mq mn l mo mp">//x<br/>    const mouse3D = new THREE.Vector3(<br/>      (event.clientX / window.innerWidth) * 2 - 1,<br/>      -(event.clientY / window.innerheight) * 2 - 1,<br/>      0.5<br/>    );<br/>    const raycaster = new THREE.Raycaster();<br/>    raycaster.setFromCamera(mouse3D, camera);<br/>    const intersects = raycaster.intersectObjects(objects);</span><span id="f496" class="ml kv in mh b gy mq mn l mo mp">if (intersects.length &gt; 0) {<br/>      intersects[0].object.material.color.setHex(Math.random() * 0xffffff);<br/>    }<br/>  }</span><span id="77a4" class="ml kv in mh b gy mq mn l mo mp">// append canvas to dom element<br/>  document.getElementById("container").appendChild(renderer.domElement);</span><span id="dd90" class="ml kv in mh b gy mq mn l mo mp">// call resize function on resize<br/>  window.addEventListener("resize", resize, false);<br/>}</span><span id="06f6" class="ml kv in mh b gy mq mn l mo mp">// update loop<br/>function update() {<br/>  requestAnimationFrame(update);<br/>  renderer.render(scene, camera);<br/>  //rotations go here<br/><br/>}</span><span id="b341" class="ml kv in mh b gy mq mn l mo mp">// resize function<br/>function resize() {<br/>  camera.aspect = winWidth / winHeight;<br/>  camera.updateProjectionMatrix();<br/>  renderer.setSize(window.innerWidth, window.innerHeight);<br/>}</span></pre><h1 id="8072" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="13d1" class="pw-post-body-paragraph jw jx in jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ig bi translated">与光线投射的许多用途相比，这只是一个小例子。当我第一次学习它的时候，这个概念对我来说很难理解，所以希望这能帮助其他想在网络上使用3D的人。</p><p id="2cd2" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">快乐编码。</p><p id="80aa" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">【来源:<br/><a class="ae jv" href="https://threejsfundamentals.org/threejs/lessons/threejs-picking.html" rel="noopener ugc nofollow" target="_blank">https://three js fundamentals . org/three js/lessons/three js-picking . html</a><br/><a class="ae jv" href="https://threejs.org/" rel="noopener ugc nofollow" target="_blank">https://threejs.org/</a></p><p id="0564" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><em class="mr">更多内容请看</em><a class="ae jv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mr">plain English . io</em></a></p></div></div>    
</body>
</html>