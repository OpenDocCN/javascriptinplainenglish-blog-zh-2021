<html>
<head>
<title>7 Ways to Debug Jest Tests in Terminal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在终端中调试Jest测试的7种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-ways-to-debug-jest-tests-in-terminal-400eec99281a?source=collection_archive---------25-----------------------#2021-03-15">https://javascript.plainenglish.io/7-ways-to-debug-jest-tests-in-terminal-400eec99281a?source=collection_archive---------25-----------------------#2021-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="aa7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎，你可能已经搜索了如何用Jest调试你的测试。我很高兴你发现了这篇博文，因为你将要学习在你的终端内部调试Jest测试的7种方法。众所周知，使用像VSCode或WebStorm这样的IDE可以很容易地做到这一点，但是如果您不使用它们呢？你如何着手调试它们呢？剧透警报—不含<code class="fe kl km kn ko b">console.log()</code>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/5ff3ea56b95cdf06f929cc707d58fc0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vi0Zx5SzwSR5AfyHgJ5Nhw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><em class="lf">Photo by </em><a class="ae lg" href="https://unsplash.com/@nikolalsvk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="lf">Nikola Đuza</em></a><em class="lf"> on </em><a class="ae lg" href="https://pragmaticpineapple.com/s/photos/bugs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="lf">Unsplash</em></a></figcaption></figure><h1 id="fbb3" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1.标准方式</h1><p id="eb34" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如果您在Jest文档中搜索一种方法，它会告诉您以下信息:</p><ul class=""><li id="b8ec" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">转到基于Chromium的浏览器，打开<code class="fe kl km kn ko b">chrome://inspect</code>。</li><li id="20dc" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">如下面的屏幕截图所示，单击“为节点打开专用的开发工具”:</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi my"><img src="../Images/14b70c4e6d591526f4a97023880c3911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*nK1V76WVYYdtKcQ4.png"/></div></figure><ul class=""><li id="4a6a" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">在你的代码中的某个地方放一个<code class="fe kl km kn ko b">debugger</code>语句(测试或生产代码)。</li><li id="e2f3" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">运行<code class="fe kl km kn ko b">node --inspect-brk node_modules/.bin/jest --runInBand [any other arguments here]</code>。</li></ul><p id="9888" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧，您的测试应该在您在步骤2中打开的DevTools中的调试器处运行和停止。实际上，由于<code class="fe kl km kn ko b">--inspect-brk</code>，这个进程一运行就会停止，但是我们稍后会讲到。</p><p id="db6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目中，通常不使用raw Jest命令。有时它被包装在其他库中，或者使用一些额外的配置来启动它。如果您是这种情况，让我们深入研究并找出不同的方法来调试和检查我们的测试。</p><blockquote class="mz na nb"><p id="85e8" class="jn jo nc jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated"><em class="iq">💡</em>让节点专用的DevTools窗口保持打开状态，我们将继续进行其他方式的调试。</p></blockquote><h1 id="e059" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2.没有最初的间断</h1><p id="d717" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如果你看一看，这里的大部分魔术是由节点检查器完成的。节点检查器的酷之处在于，当您执行<code class="fe kl km kn ko b">node --inspect</code>时，Node.js进程会在<code class="fe kl km kn ko b">127.0.0.1:9229</code>监听调试客户端。这个变化在2016年得到了<a class="ae lg" href="https://github.com/nodejs/node/pull/6792" rel="noopener ugc nofollow" target="_blank">的引入。</a>并允许每个人轻松检查他们的流程。</p><p id="5bff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前一节的例子中，我们使用了<code class="fe kl km kn ko b">node --inspect-brk ...</code>。使用<code class="fe kl km kn ko b">--inspect-brk</code>标志将在用户代码开始前中断。在我的例子中，我不在乎测试一开始就停止，只是求助于简单的<code class="fe kl km kn ko b">node --inspect</code>。<code class="fe kl km kn ko b">node --inspect</code>会在你放<code class="fe kl km kn ko b">debugger</code>的地方断裂，而不是在发射时立即断裂。从现在开始我们继续吧。我们的调试命令将是:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="2c73" class="nk li iq ko b gy nl nm l nn no">$ node --inspect node_modules/.bin/jest --runInBand</span></pre><p id="d8d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe kl km kn ko b">node_modules</code>位置可以依赖于操作系统，我们可以使它不可知，并使用<code class="fe kl km kn ko b">yarn bin</code>或<code class="fe kl km kn ko b">npm bin</code>。在我的例子中，我将像这样使用<code class="fe kl km kn ko b">npm bin</code>:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="309e" class="nk li iq ko b gy nl nm l nn no">$ node --inspect $(npm bin)/jest --runInBand</span></pre><h1 id="f3fc" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3.调试类型脚本测试</h1><p id="d8b7" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如果您现在正在使用TypeScript，如果您尝试运行:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="3446" class="nk li iq ko b gy nl nm l nn no">$ node --inspect $(npm bin)/jest --runInBand</span></pre><p id="2da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会得到一个错误，因为TypeScript测试没有转换成JavaScript。确保您在<code class="fe kl km kn ko b">jest.config.js</code>中配置了类似于以下配置的Jest:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="82cd" class="nk li iq ko b gy nl nm l nn no">module.exports = {<br/>  roots: ["&lt;rootDir&gt;/src"],<br/>  testMatch: [<br/>    "**/__tests__/**/*.+(ts|tsx|js)",<br/>    "**/?(*.)+(spec|test).+(ts|tsx|js)",<br/>  ],<br/>  transform: {<br/>    "^.+\\.(ts|tsx)$": "ts-jest", // The important part right here<br/>  },<br/>}</span></pre><p id="e2c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们告诉Jest使用<code class="fe kl km kn ko b">ts-jest</code>转换<code class="fe kl km kn ko b">.ts</code>和<code class="fe kl km kn ko b">.tsx</code>文件。如果没有<code class="fe kl km kn ko b">ts-jest</code>，可以装上<code class="fe kl km kn ko b">npm install -D ts-jest</code>，应该就可以了。我做了一个回购样本，你可以在这里试用<a class="ae lg" href="https://github.com/nikolalsvk/abacus" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="3fbe" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">4.调试™️的最佳方法</h1><p id="108e" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">好吧，所以这一节的标题承诺了很多，多包涵。如果你没有听说过Jest手表模式，你会喜欢这个。大部分时间我在写代码，我让<code class="fe kl km kn ko b">jest --watch</code>运行。监视模式的优点是它会监视您所做的任何更改，并运行相关的测试。要在监视模式下调试测试，可以键入以下内容:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="3d54" class="nk li iq ko b gy nl nm l nn no">$ node --inspect $(npm bin)/jest --watch --no-cache --runInBand</span></pre><p id="31c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在这里分解一下笑话的论点:</p><ul class=""><li id="6979" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated"><code class="fe kl km kn ko b">--watch</code>从Jest启动手表模式，相当酷。</li><li id="6815" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><code class="fe kl km kn ko b">--no-cache</code>将确保我们的代码被正确重载。您可以尝试不使用它，但手表模式可能无法正常工作。</li><li id="5812" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><code class="fe kl km kn ko b">--runInBand</code> -好吧，这面旗帜从一开始就跟着我们。它确保所有测试在一个进程中连续运行，而不是创建子进程。拥有一个过程使得<code class="fe kl km kn ko b">node --inspect</code>能够正确地“检查”测试。</li></ul><p id="5056" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以组合其他Jest命令，如运行单个测试:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="1515" class="nk li iq ko b gy nl nm l nn no">$ node --inspect $(npm bin)/jest --runTestsByPath src/index.test.ts --runInBand</span></pre><p id="787e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是不要忘记附加<code class="fe kl km kn ko b">--runInBand</code>或者仅仅是<code class="fe kl km kn ko b">-i</code>来确保Node.js检查器发挥它的魔力。</p><h1 id="de11" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">5.CRA怎么样？</h1><p id="f503" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如果你使用create-react-app (CRA)并让你的测试脚本使用react-scripts test，调试对你来说会有点不同。推荐的方法是向<code class="fe kl km kn ko b">package.json</code>添加一个新脚本，如下所示:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="98cb" class="nk li iq ko b gy nl nm l nn no">"scripts": {<br/>  ...,<br/>  "test:debug": "react-scripts --inspect test --runInBand --no-cache"<br/>}</span></pre><p id="667a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，每当你运行<code class="fe kl km kn ko b">npm run test:debug</code>，Jest就会以手表模式运行，停在你放<code class="fe kl km kn ko b">debugger</code>的地方。当然，您需要打开一个用于Node.js的专用DevTools，就像我们在第一节中描述的那样。</p><h1 id="70ee" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">6.从命令行调试</h1><p id="c4c6" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">好了，现在你已经有了使用Chromium浏览器和DevTools的初始调试器。但是，如果您是命令行爱好者，您可能正在考虑一种不使用DevTools的方法。对你来说是个好消息，这是可以做到的。幸运的是，我们有<code class="fe kl km kn ko b">node inspect</code>为我们启动命令行调试器。尝试运行以下命令:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="0496" class="nk li iq ko b gy nl nm l nn no">$ node inspect $(npm bin)/jest --runInBand</span></pre><p id="e05c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在我制作的示例回购中运行了这个，这是我得到的结果:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="690e" class="nk li iq ko b gy nl nm l nn no">$ node inspect $(npm bin)/jest --runInBand<br/>&lt; Debugger listening on ws://127.0.0.1:9229/be2d3410-48ad-46fb-a345-bb37339b5e38<br/>&lt; For help, see: https://nodejs.org/en/docs/inspector<br/>&lt; Debugger attached.<br/>Break on start in node_modules/jest/bin/jest.js:9<br/>  7  */<br/>  8<br/>&gt; 9 const importLocal = require('import-local');<br/> 10<br/> 11 if (!importLocal(__filename)) {<br/>debug&gt;</span></pre><p id="3e47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查员在<code class="fe kl km kn ko b">node_modules/jest/bin/jest.js:9</code>内的第一行停了下来。我们可以通过键入<code class="fe kl km kn ko b">cont</code>或<code class="fe kl km kn ko b">c</code>继续调试:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="c0ca" class="nk li iq ko b gy nl nm l nn no">$ node inspect $(npm bin)/jest --runInBand<br/>&lt; Debugger listening on ws://127.0.0.1:9229/be2d3410-48ad-46fb-a345-bb37339b5e38<br/>&lt; For help, see: https://nodejs.org/en/docs/inspector<br/>&lt; Debugger attached.<br/>Break on start in node_modules/jest/bin/jest.js:9<br/>  7  */<br/>  8<br/>&gt; 9 const importLocal = require('import-local');<br/> 10<br/> 11 if (!importLocal(__filename)) {<br/>debug&gt; cont<br/>break in src/index.test.ts:6<br/>  4 test("add", function () {<br/>  5     var result = index_1.add(1, 2);<br/>&gt; 6     debugger;<br/>  7     expect(result).toEqual(3);<br/>  8 });<br/>debug&gt;</span></pre><p id="09a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在检查员停在了我们测试代码中的<code class="fe kl km kn ko b">debugger</code>语句。我们可以键入<code class="fe kl km kn ko b">help</code>并熟悉我们可以在那里键入的所有命令。我不会一一介绍，但我会提到<code class="fe kl km kn ko b">repl</code>命令。通过在调试器中键入<code class="fe kl km kn ko b">repl</code>，您将进入读取-评估-打印-循环(REPL)模式，在这里您可以评估变量。如果我在我的例子中这样做，我将得到以下结果:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="7522" class="nk li iq ko b gy nl nm l nn no">$ node inspect $(npm bin)/jest --runInBand<br/>&lt; Debugger listening on ws://127.0.0.1:9229/be2d3410-48ad-46fb-a345-bb37339b5e38<br/>&lt; For help, see: https://nodejs.org/en/docs/inspector<br/>&lt; Debugger attached.<br/>Break on start in node_modules/jest/bin/jest.js:9<br/>  7  */<br/>  8<br/>&gt; 9 const importLocal = require('import-local');<br/> 10<br/> 11 if (!importLocal(__filename)) {<br/>debug&gt; cont<br/>break in src/index.test.ts:6<br/>  4 test("add", function () {<br/>  5     var result = index_1.add(1, 2);<br/>&gt; 6     debugger;<br/>  7     expect(result).toEqual(3);<br/>  8 });<br/>debug&gt; repl<br/>Press Ctrl + C to leave debug repl<br/>&gt; result<br/>3<br/>&gt;</span></pre><p id="422b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是从命令行检查代码的基础。开发者体验(DX)可能没有DevTools打开时的体验好，在dev tools打开时，你可以通过悬停在变量上来获得变量的值，但这仍然是一个不错的选择。让我们在下一节看看如何从命令行打开DevTools。</p><h1 id="051a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">7.一体化解决方案— ndb</h1><p id="400c" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">ndb是为Node.js改善调试体验的库，你可以用<code class="fe kl km kn ko b">npm install -g ndb</code>全局安装，也可以用<code class="fe kl km kn ko b">npm install -D ndb</code>本地安装。我在我的<a class="ae lg" href="https://github.com/nikolalsvk/abacus" rel="noopener ugc nofollow" target="_blank"> Abacus repo </a>上用全局命令试过，比如:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="c923" class="nk li iq ko b gy nl nm l nn no">$ ndb $(npm bin)/jest --watch --no-cache --runInBand</span></pre><p id="7e84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且效果很好。你一输入它，它就会为你打开DevTools。它的表现也比普通的<code class="fe kl km kn ko b">node --inspect</code>更快。ndb的伟大之处在于，你可以轻松地为<code class="fe kl km kn ko b">package.json</code>运行你的脚本。我设法运行了以下内容:</p><pre class="kq kr ks kt gt ng ko nh ni aw nj bi"><span id="f369" class="nk li iq ko b gy nl nm l nn no">$ ndb npm run test -- --watch --no-cache --runInBand</span></pre><p id="3781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信使用ndb的方法对那些想从命令行做任何事情的人来说最有吸引力。它让你不用在浏览器上打开DevTools for Node.js，ndb会帮你完成。</p><h1 id="bbf6" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">最后的想法</h1><p id="dc57" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">就这样了，伙计们。您应该能够挑选调试Jest测试的方法。在Jest中调试测试的想法困扰了我很长一段时间，我很高兴我找到了各种解决方案，并与大家分享。</p><p id="5bdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢收听，请务必订阅<a class="ae lg" href="https://pragmaticpineapple.com/newsletter" rel="noopener ugc nofollow" target="_blank">时事通讯</a>并在<a class="ae lg" href="https://twitter.com/nikolalsvk" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，获取新的博客帖子和技巧。如果你觉得这篇文章有用，可以考虑在Twitter上与你的朋友和同事分享:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ab36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到下一个，干杯。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="5f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nc">原载于2021年3月15日https://pragmaticpineapple.com</em><a class="ae lg" href="https://pragmaticpineapple.com/7-ways-to-debug-jest-tests-in-terminal/" rel="noopener ugc nofollow" target="_blank"><em class="nc"/></a><em class="nc">。</em></p></div></div>    
</body>
</html>