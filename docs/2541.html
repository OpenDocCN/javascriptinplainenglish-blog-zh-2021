<html>
<head>
<title>Finite State Machines in Real Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现实生活中的有限状态机</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/finite-state-machines-in-real-life-65370b1b091e?source=collection_archive---------7-----------------------#2021-05-25">https://javascript.plainenglish.io/finite-state-machines-in-real-life-65370b1b091e?source=collection_archive---------7-----------------------#2021-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="80f7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我们在哪里使用它们，为什么？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1b230eca584c34073a06ba735a0895af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rXurRoppXgFEnQuj"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@belgoncalves?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Isabel Gonçalves</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e376" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我为Yandex主持了一个以有限状态机为主题的网络研讨会。前几天和我的同事<a class="ae ks" href="https://www.linkedin.com/in/zakhar-ovcharov-a657a4197/" rel="noopener ugc nofollow" target="_blank">扎哈尔·奥夫查洛夫</a>一起在Praktikum 站台。网上研讨会已经在Youtube上发布。如果你熟悉俄语，看看这个！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">2 hours of theory and coding</figcaption></figure><p id="1061" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于Zakhar是一位专家，这篇文章的存在归功于他。我的部分是写这篇文章，并在<strong class="kv io">复杂表单</strong>部分创建一个基于FSM的复杂React组件。</p><p id="1cd4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">既然一切都解决了，我们开始吧！</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="c69b" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">有限状态机</h1><p id="63e5" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">首先，定义:</p><blockquote class="mv mw mx"><p id="4c96" class="kt ku my kv b kw kx jo ky kz la jr lb mz ld le lf na lh li lj nb ll lm ln lo ig bi translated">一个<strong class="kv io">有限状态机</strong> ( <strong class="kv io"> FSM </strong>)是一个抽象的机器，它在任何给定的时间都可以处于有限数量的状态中的一个。FSM可以响应一些输入从一种状态改变到另一种状态；从一种状态到另一种状态的变化称为过渡。FSM由其状态列表、初始状态和触发每个转换的输入来定义</p></blockquote><p id="f17e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">就是这样。FSM有有限数量的状态，每时每刻都停留在其中一种状态，并有一些从一种状态转换到另一种状态的规则。</p><p id="755c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了清楚起见，想象一只名叫威利的猫。假设威利可能快乐也可能悲伤。现在，威利很开心。当你离开时，威利变得悲伤。当你回来的时候，威利又开心了。你可能会说，猫不太在乎你离开后再来，但我的小宝贝在乎。您可能已经看到了其中的联系:</p><ol class=""><li id="112c" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated"><strong class="kv io">状态。威利不是快乐就是悲伤，不可能两者都是</strong></li><li id="6e7c" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">初始状态。</strong>我们默认威利是快乐的</li><li id="b082" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">转场。</strong>你可以离开，也可以来，威利会改变它目前的状态</li></ol><p id="ee91" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也可以用图表来描绘。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b5ba4c518ffb014c71554b6f29f11102.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*qpzw4URtFYI6EMO2eJpxIw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Happy (😻) and Sad (😿) Willy</figcaption></figure><p id="258e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我想到的最简单的有限状态机。在本文中，我们将讨论使用示例，并从头开始编写我们自己的FSM实现。我们还将使用它来解决几个任务。</p><p id="44d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们走吧！</p><h1 id="adfa" class="ly lz in bd ma mb nr md me mf ns mh mi jt nt ju mk jw nu jx mm jz nv ka mo mp bi translated">用法示例</h1><p id="a770" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">有限状态机可以用来描述一种算法来处理一些任务或模拟几乎任何过程。几个例子:</p><ol class=""><li id="565d" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated"><strong class="kv io">语言检查。</strong>这就是我们在<strong class="kv io">二进制代码检查</strong>部分要做的事情</li><li id="4861" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">游戏的AI逻辑。</strong>这里有一篇<a class="ae ks" href="https://gamedevelopment.tutsplus.com/tutorials/finite-state-machines-theory-and-implementation--gamedev-11867" rel="noopener ugc nofollow" target="_blank">文章</a>涵盖了这个想法</li><li id="3da3" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">句法和词汇分析。</strong>如果你想了解更多，请阅读这篇<a class="ae ks" href="https://hackernoon.com/lexical-analysis-861b8bfe4cb0" rel="noopener ugc nofollow" target="_blank">文章</a></li><li id="a244" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">成分复杂。</strong>本例也有一个<a class="ae ks" href="https://medium.com/okcupid-tech-blog/modeling-ui-states-in-a-react-form-component-using-a-finite-state-machine-d12a6258cd06" rel="noopener">好的</a>，我们也将在<strong class="kv io">复合形</strong>部分进行说明</li></ol><p id="ddef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您愿意，您可以很容易地扩展这个列表:FSM用于许多不同的领域，包括语言学、计算机科学、生物学、数学，甚至哲学。</p><h1 id="a5c3" class="ly lz in bd ma mb nr md me mf ns mh mi jt nt ju mk jw nu jx mm jz nv ka mo mp bi translated">二进制代码检查</h1><p id="7617" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">让我们创建我们的第一个FSM！</p><p id="05e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">查看<a class="ae ks" href="https://codepen.io/kotosha/pen/OJpyQPx" rel="noopener ugc nofollow" target="_blank">最终示例</a>或继续编码。</p><p id="767a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于这一个，我们必须创建一个<em class="my">确定性的有限态受体</em>。FSM的目标是根据其定义接受或拒绝某些价值。我们已经讨论了状态、初始状态和转换，但是现在我们必须定义另外两个选项:</p><ol class=""><li id="aed1" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated"><strong class="kv io">字母表。</strong>可测试值必须具有的一组符号(除此之外没有其他符号)</li><li id="d680" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">有限状态。</strong>现有状态的子集(可能为空)。当FSM完成工作时，如果这个子集包括当前状态，它接受可测试值，否则拒绝</li></ol><p id="1679" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们谈谈任务:</p><ol class=""><li id="9bda" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated">我们必须创建FSM来测试随机值，以检查它是否是二进制代码</li><li id="c8c2" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">我们接受包含字符0和1的非空字符串，拒绝任何其他字符串</li></ol><p id="8c65" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了处理这个问题，FSM应该逐个字符地检查可测试的字符串。每个字符都应根据指定的字母表进行测试。每次迭代都应该产生转换。完成后，FSM应该根据当前状态和指定的有限状态来决定是否接受可测试值。</p><p id="9608" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以下是我们的FSM:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Deterministic finite-state acceptor</figcaption></figure><p id="5d3a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个基于类的FSM，能够根据其定义测试随机值。要使用它，我们必须用所有必需的参数创建它的实例。让我们把它分解一下:</p><ol class=""><li id="034d" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated"><strong class="kv io">字母表。</strong>这很容易。我们只接受字符0和1</li><li id="bf33" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">状态。</strong>这也很容易。值是否为二进制。我们将状态命名为<code class="fe nx ny nz oa b">q0</code>和<code class="fe nx ny nz oa b">q1</code>，其中<code class="fe nx ny nz oa b">q0</code>是<strong class="kv io">“值不是二进制码”</strong>,<code class="fe nx ny nz oa b">q1</code>是<strong class="kv io">“值是二进制码”</strong></li><li id="c4a1" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">初始状态。</strong>我们不接受空字符串，所以初始状态是<code class="fe nx ny nz oa b">q0</code></li><li id="03e3" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">有限状态。</strong>有限状态将值标记为已接受。在我们的例子中，唯一合适的状态是<code class="fe nx ny nz oa b">q1</code></li><li id="100f" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">转场。</strong>查看下图</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/652380eede6250e6e0a3902f8e99cf91.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*DLbe4A2vBrNSKME456Sulg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Diagram for the binary code acceptor</figcaption></figure><p id="a4cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每个状态都有字符0和1的转换。记住，转换发生在每次迭代中。你可以这样读:</p><ol class=""><li id="530a" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated">如果当前状态是<code class="fe nx ny nz oa b">q0</code>状态并且当前符号是0或1，则执行到状态<code class="fe nx ny nz oa b">q1</code>的转换</li><li id="4c28" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">如果当前状态为<code class="fe nx ny nz oa b">q1</code>状态且当前符号为0或1，则执行转移<em class="my">至相同状态</em></li><li id="e738" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">如果当前符号不是0或1，无论当前状态如何，都拒绝可测试值</li></ol><p id="05b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">解释完一切之后，让我们最后创建一个FSM实例并测试它！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Usage and testing</figcaption></figure><p id="a85f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有用！注意，我们没有为每个状态指定每个可能的符号。FSM的实现让我们了解到——当符号不属于字母表时，FSM会提前返回。</p><h1 id="7169" class="ly lz in bd ma mb nr md me mf ns mh mi jt nt ju mk jw nu jx mm jz nv ka mo mp bi translated">复杂形式</h1><p id="ae33" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">二进制检查的例子很简单。这不是你会经常做或根本不会做的事情。我还有另外一个例子。对于这一个，我们将使用面向UI的FSM构建一个多态表单。最终结果可在<a class="ae ks" href="https://codesandbox.io/s/finite-state-machine-6s69l" rel="noopener ugc nofollow" target="_blank"> Codesanbox </a>获得。你可以一头扎进去或者跟着编码。</p><p id="071f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，创建一个新的React项目:</p><pre class="kd ke kf kg gt ob oa oc od aw oe bi"><span id="7d43" class="of lz in oa b gy og oh l oi oj">create-react-app questionnaire</span></pre><p id="341a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">项目结构应该如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ok"><img src="../Images/575c26bb8c2efa7ed17fe9e86f8d321e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HENXxkoAf98VIzNdAck_Yw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Project boilerplate</figcaption></figure><p id="371e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nx ny nz oa b">App.js</code>和<code class="fe nx ny nz oa b">index.js</code>不需要任何改动。<code class="fe nx ny nz oa b">FSM.js</code>将包含新的FSM实现。让我们把它写下来:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Function-based FSM</figcaption></figure><p id="e6a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，我们已经去掉了字母表和州。现在，我们只有两个选项可以定义:</p><ol class=""><li id="8a63" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated"><strong class="kv io">初始状态。FSM必须从某个地方开始</strong></li><li id="e4b0" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">过渡。</strong>我们将它们与状态合并，因此我们精简了实例化，但提供了同等的功能</li></ol><p id="be39" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它强调了有限状态机的多功能性——我们可以根据任务的需要定义它们。只要我们有状态，转换，和初始状态，我们就没事。</p><p id="a4b8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个实现迫使我们使用方法<code class="fe nx ny nz oa b">send</code>来改变状态。我们还提供了一个<code class="fe nx ny nz oa b">subscribe</code>方法。如果我们想对状态变化做出反应，这是非常有用的。</p><p id="01df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们用威利的例子来测试一下。用以下内容创建<code class="fe nx ny nz oa b">test.js</code>文件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Willy testing</figcaption></figure><p id="dcf4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，运行它(确保您在文件目录中):</p><pre class="kd ke kf kg gt ob oa oc od aw oe bi"><span id="0050" class="of lz in oa b gy og oh l oi oj">node test.js</span></pre><p id="674d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">控制台输出应该是:</p><pre class="kd ke kf kg gt ob oa oc od aw oe bi"><span id="a7ad" class="of lz in oa b gy og oh l oi oj">happy<br/>sad<br/>happy</span></pre><p id="8e10" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">绝对管用！最后，让我们对威利的情绪变化作出反应:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Never leave your Willy</figcaption></figure><p id="1c79" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再运行一次。</p><pre class="kd ke kf kg gt ob oa oc od aw oe bi"><span id="5b06" class="of lz in oa b gy og oh l oi oj">happy<br/>happy</span></pre><p id="fdc9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">威利现在总是很开心，因为我们不会真的离开他。如果转换后的状态是<code class="fe nx ny nz oa b">sad</code>，那么我们发送<code class="fe nx ny nz oa b">come</code>触发器，威利又高兴了。</p><p id="0f60" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看起来一切正常。我们去真正的任务吧！</p><p id="c273" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们要做一份多州问卷。会有一堆状态来控制问卷界面。假设我们想询问用户的姓名和职业。如果用户是学生，我们会询问他上的大学。否则，他可能有一份工作，所以我们会问它。用户可以从表单的教育/工作步骤返回到个人步骤。最后，用户可以在两种情况下提交问卷。</p><p id="d62a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个小图表，使讨论的条款清晰:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ol"><img src="../Images/33e6d25169eeb518682c2dadc19f1a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EaaB0eF4wI7MPR1_-MGvQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">FSM that defines discussed questionnaire</figcaption></figure><p id="75d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在已经清楚了我们有哪些状态以及它们之间的关系，我们可以开始我们的项目了！</p><p id="c1d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们需要安装附加的依赖项:</p><pre class="kd ke kf kg gt ob oa oc od aw oe bi"><span id="70bc" class="of lz in oa b gy og oh l oi oj">npm i animate.css react-transition-group</span></pre><p id="1f4d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">安装完成后，添加<code class="fe nx ny nz oa b">/components</code>目录，其中包含一些组件。我们还将在<code class="fe nx ny nz oa b">/src</code>目录中创建<code class="fe nx ny nz oa b">questionnaireMachine.js</code>文件。之后，项目结构应该是这样的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/9666491a3d2b0269fcb6d6b81711feed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTnh6pNKhljsCN1jlg5qxw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Project structure</figcaption></figure><p id="8d0b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nx ny nz oa b">questionnaireMachine.js</code>文件将创建并导出问卷FSM实例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Questionnaire FSM</figcaption></figure><p id="8c37" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下一步是创建我们项目的表示层——问卷本身！我们要把它分成三个独立的部分:</p><ol class=""><li id="29a4" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated"><strong class="kv io">问卷。</strong>定义问卷流程的主要组件</li><li id="3b25" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">卡。</strong>用于显示问卷部分的可重用组件</li><li id="4d09" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><strong class="kv io">装载机。</strong>简单的动画圆点</li></ol><p id="0c7e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们从问卷部分开始:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Questionnaire component with styles</figcaption></figure><p id="68cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们需要订阅FSM状态更改。每次有变化，我们就更新<code class="fe nx ny nz oa b">uiState</code>。我们需要<code class="fe nx ny nz oa b">uiState</code>来计算卡组件<code class="fe nx ny nz oa b">active</code>的属性。该属性允许卡组件实例决定是否显示自身。</p><p id="26aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，卡组件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Card component with styles</figcaption></figure><p id="40af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">组件底部的按钮使用提供的动作作为单击事件侦听器。这就是我们传递改变FSM状态的函数的原因。问卷组件可以更新<code class="fe nx ny nz oa b">uiState</code>，然后显示相应的卡片。</p><p id="2224" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一个小东西是加载器组件。这里没有什么有趣的，只是一个动画点:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Loader component with styles</figcaption></figure><p id="1809" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，让我们将问卷注入到App组件中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Root component with styles</figcaption></figure><p id="2876" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当它完成后，你应该有一些非常类似于<a class="ae ks" href="https://6s69l.csb.app" rel="noopener ugc nofollow" target="_blank">这个</a>的东西。如果你这样做了，拍拍自己的肩膀，你刚刚创建了基于FSM的问卷！如果你不知道，请将你的代码与这个<a class="ae ks" href="https://codesandbox.io/s/finite-state-machine-6s69l" rel="noopener ugc nofollow" target="_blank">沙盒</a>进行比较，你很快就会赶上来。</p><p id="f2f2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们刚刚创建的问卷很好地分离了逻辑和表示，因此如果我们愿意，可以很容易地调整它的行为或外观。只要我们认为合适，FSM的单个实现可以用在尽可能多的组件中。这种方法确保了应用程序的可预测性和一致性。</p><p id="14e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一件事。尽管这是从头创建我们自己的FSM的一个有用的经验，我强烈推荐使用生产就绪的包，比如<a class="ae ks" href="https://xstate.js.org/docs/" rel="noopener ugc nofollow" target="_blank"> XState </a>。它有全面的文档和完成工作所需的所有工具(可能更多)。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="f853" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">结论</h1><p id="eaac" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">就是这样！在本文中，我们讨论了什么是FSM，以及我们可能希望在哪里使用它。我们从头开始编写FSM，并用它解决了两个不同的任务。FSM在许多领域都很有用。这使得FSM成为解决特定问题的好方法，也是必须了解的技术。</p><p id="bc17" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望这篇文章对你有帮助！如果你喜欢，请告诉我！</p><p id="7d6c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">祝你今天开心！玩的开心！</p><p id="dd55" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="my">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="my">plain English . io</em></a></p></div></div>    
</body>
</html>