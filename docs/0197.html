<html>
<head>
<title>Let’s Build a GraphQL Server with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用Node.js构建一个GraphQL服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-graphql-server-with-node-js-c31ee3f54761?source=collection_archive---------18-----------------------#2021-01-11">https://javascript.plainenglish.io/building-graphql-server-with-node-js-c31ee3f54761?source=collection_archive---------18-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dffb74828cfefbb1d5623cdc9340bc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZjbFOPbZghb2iO0yZpFZw.jpeg"/></div></div></figure><p id="2288" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt"> GraphQL </em> </strong>是一种查询语言，由脸书开发。可以说它是REST方法的改进版本。在这篇文章中，我想谈谈如何使用它，而不是它是什么。然而，与REST相比，我们可以说<em class="kt"> GraphQL </em>有以下优点:</p><p id="bdc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 1。在REST查询中，你需要端点。而且只要这些<em class="kt">端点</em>拉长，就很难读取。例如:</strong></p><p id="a12d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ku" href="https://domain.com/api/customers/customerId/products/productId/orders/orderId/" rel="noopener ugc nofollow" target="_blank">https://domain . com/API/customers/customerId/products/productId/orders/orderId/</a></p><p id="8b05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<em class="kt"> GraphQL </em>你不需要这样的查询。</p><p id="6871" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。</strong>在使用REST查询时，许多您不需要的数据会随您调用的数据一起出现。这样，服务器就超载了。GraphQL 让你摆脱获取你不需要的数据。</p><p id="e343" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。</strong> <em class="kt">嵌套查询</em>表示在REST中的连续查询。在<em class="kt"> GraphQL中进行嵌套查询更容易。因为你只需要一个查询。<em class="kt"> GraphQL </em>将这些查询进行分片，得到相关数据作为<em class="kt"> Promise </em>并重新汇总后返回给我们。这为我们节省了时间。</em></p><p id="23dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。GraphQL 提供了一个叫做<em class="kt"> Playground </em>的UI，我们可以在上面测试我们的API。</strong></p><p id="2af6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 5。</strong>因为<em class="kt">typedef</em>(schema-graph QL的一部分)中的所有字段都必须已经指定，所以后端开发人员不会忘记给函数添加一些<em class="kt">字段</em>。使用或不使用这些<em class="kt">字段</em>取决于API用户。</p><p id="d897" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看<em class="kt"> GraphQL </em>的结构:</p><p id="bcaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> GraphQL </em>由两个主要部分组成:</p><p id="0dc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt"> 1。TypeDefs: </em></strong>我们指定API模式的部分。在本节中，确定了函数和变量的类型。</p><p id="ba36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">T53】2。解析器:</strong>定义函数的部分。<em class="kt"> CRUD </em>功能在<em class="kt"> GraphQL </em>中的<em class="kt">解析器</em>下分两部分处理；“读取”功能在“<em class="kt">查询</em>下定义，其他在“<em class="kt">突变</em>下定义。</p><p id="c922" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们通过一个简单的例子来看看这些特性。</p><p id="0c78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<em class="kt"> GraphQL </em>是一种查询语言，我们需要一个工具来使用它。我更喜欢使用<em class="kt"> graphql-yoga </em>，因为我们正在用Node.js创建一个服务器。然而，在https://graphql.org/code/<a class="ae ku" href="https://graphql.org/code/" rel="noopener ugc nofollow" target="_blank">的链接</a>上可以找到适合每种语言的多种工具。</p><p id="cd73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我在文件夹中创建<em class="kt"> package.json </em>文件，我将在其中安装我的服务器:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d8c8" class="le lf in la b gy lg lh l li lj">npm init –y</span></pre><p id="e0d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我安装了JavaScript编译器<em class="kt"> babel </em>:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c9a7" class="le lf in la b gy lg lh l li lj">npm i babel-cli babel-preset-es2015</span></pre><p id="feec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Babel </em>基本上提供了语法上的便利。它将使用ES 2015和更高版本编写的代码转换为与浏览器兼容的JavaScript。</p><p id="519d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们安装<em class="kt"> graphql-yoga </em>工具。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6b73" class="le lf in la b gy lg lh l li lj">npm i graphql-yoga — save</span></pre><p id="566c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个<strong class="jx io"> <em class="kt"> index.js </em> </strong>文件，在这个文件中，我们在主目录中写入我们的服务器代码，并在其中添加以下代码:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="2344" class="le lf in la b gy lg lh l li lj">import { GraphQLServer } from “graphql-yoga”;<br/>const typeDefs = `<br/>  type Query {<br/>    hello: String<br/>  }<br/>`;<br/>const resolvers = {<br/>  Query: {<br/>    hello: () =&gt; “Selam.”,<br/>  }<br/>};</span><span id="f105" class="le lf in la b gy lk lh l li lj">const server = new GraphQLServer({ typeDefs, resolvers });</span><span id="d20c" class="le lf in la b gy lk lh l li lj">server.start(() =&gt; console.log(“Server is running on localhost:4000”));</span></pre><p id="4873" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我更喜欢通过<em class="kt"> nodemon </em>运行<strong class="jx io"> index.js </strong>。nodemon 是一个node.js包，它可以让你在开发阶段停止和重启你的项目。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="44ed" class="le lf in la b gy lg lh l li lj">npm i –g nodemon</span></pre><p id="4574" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们将以下代码添加到package.json文件的脚本中。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="a65a" class="le lf in la b gy lg lh l li lj">“start”: “nodemon index.js — exec babel-node — presets es2015”,</span></pre><p id="b9bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的服务器现在正以最简单的形式工作。</p><p id="8c6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单提一下:</p><ul class=""><li id="478a" class="ll lm in jx b jy jz kc kd kg ln kk lo ko lp ks lq lr ls lt bi translated">在第一行中，我们导入了相关的工具/包</li><li id="3879" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">我们在<em class="kt">类型定义</em>下指定了类型</li><li id="9991" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">我们在<em class="kt">解析器</em>中定义函数</li><li id="24cc" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">最后，我们从安装的<em class="kt"> graphql-yoga </em>包中获得实例，并运行服务器。</li></ul><p id="a450" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> GraphQL </em>默认运行在4000端口。您可以使用以下代码在不同的端口上运行。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="7ab9" class="le lf in la b gy lg lh l li lj">server.start({ port: 4001 }).then(console.log(“server runs on port localhost:4001”));</span></pre><p id="33ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们现在运行我们的项目。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="384e" class="le lf in la b gy lg lh l li lj">npm start</span></pre><p id="787e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在浏览器中，游乐场UI来自我们上面提到的。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/cf65b3b8b147be0a66274c9308d8af2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykFXp5YDcWKOjiICbflutw.jpeg"/></div></div></figure><p id="2cff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在左边调用我们定义的函数，在右边看到结果。</p><p id="4d14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们做一些不同的查询。为此，让我们创建由两个<em class="kt">数组</em>组成的假数据。我们可以在TypeDefs上面添加假数据。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="2eb1" class="le lf in la b gy lg lh l li lj">const Users = [<br/>  {<br/>    id: 1,<br/>    username: “john”,<br/>    city: “Melbourne”,<br/>  },<br/>  {<br/>    id: 2,<br/>    username: “mseven”,<br/>    city: “Istanbul”,<br/>  },<br/>  {<br/>    id: 3,<br/>    username: “maria”,<br/>    city: “Zagreb”,<br/>  },<br/>];</span><span id="a875" class="le lf in la b gy lk lh l li lj">const Posts = [<br/>  {<br/>    id: 1,<br/>    title:“Lorem Ipsum is simply dummy text of the printing and     typesetting industry.”,<br/>    userId: 1,<br/>  },<br/>  {<br/>    id: 2,<br/>    title:"Lorem Ipsum je jednostavno probni tekst koji se koristi u tiskarskoj i slovoslagarskoj industriji.”,<br/>    userId: 3,<br/>  },<br/>  {<br/>    id: 3,<br/>    title:“Lorem Ipsum, dizgi ve baskı endüstrisinde kullanılan mıgır metinlerdir.”,<br/>    userId: 2,<br/>  },<br/>  {<br/>    id: 4,<br/>    title:"Lorem Ipsum, dizgi ve baskı endüstrisinde kullanılan mıgır metinlerdir22222.”,<br/>    userId: 1,<br/>  },<br/>];</span></pre><p id="3b62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，数据表示用户数组中的用户以及由这些用户发出的组成帖子数组的帖子。</p><p id="c1a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们在<em class="kt">typedef</em>下创建数据的模式。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4a82" class="le lf in la b gy lg lh l li lj">const typeDefs = `<br/>  type Query {<br/>    hello: String<br/>  }  <br/>  type User{<br/>   id: ID!<br/>   username: String!<br/>   city: String<br/>  }  <br/>  type Post{<br/>   id: ID!<br/>   title: String!<br/>   userId: ID!<br/>  }`;</span></pre><p id="8814" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我想说一下<em class="kt"> GraphQL </em>的两个特点。"<em class="kt"> ID </em>"类型是GraphQL中赋予' ID '的一种特殊类型。以这种方式指定的id参数可以作为<em class="kt">字符串</em>或<em class="kt"> Int </em>传递给函数。另一个特点是感叹号。带感叹号的变量是不可空的变量。</p><p id="eaf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们指定函数的类型:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4eec" class="le lf in la b gy lg lh l li lj">type Query {<br/>  hello: String<br/>  users: [User!]!<br/>  posts: [Post!]!<br/>}</span></pre><p id="0515" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于这些函数将列出所有用户和帖子，我们将它们的类型写在“[]”中。这意味着它将返回一个数组给我们。括号内的感叹号表示该字段是必需的，并且以用户类型返回的结果不能为空，括号外的感叹号表示以数组类型返回的结果不能为空。</p><p id="face" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们定义我们在<em class="kt">解析器</em>中形成模式的函数。由于这些函数是“读”函数，我们将在<em class="kt">查询</em>下定义它们。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="7c55" class="le lf in la b gy lg lh l li lj">const resolvers = {<br/>  Query: {<br/>    hello: () =&gt; “Selam.”,<br/>    users: (parent, args) =&gt; Users,<br/>    posts: (parent, args) =&gt; Posts,<br/>  },<br/>};</span></pre><p id="372f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将在本文后面提到概念<em class="kt">父</em>和<em class="kt">参数</em>。</p><p id="c1a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们运行项目并在<em class="kt">操场</em>的左侧进行相关查询时，我们得到了出现在右侧的输出:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/148bf2e0cd51ed0d06f838191f920d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3NKBU38fgGOAC_764vyew.jpeg"/></div></div></figure><p id="5048" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在<em class="kt"> Playground </em>中用<em class="kt"> query </em>关键字调用我们定义为查询的函数。并且我们可以自己确定需要返回的<em class="kt">字段</em><em class="kt"/>。例如，当您删除城市<em class="kt">字段</em>时，该功能仍然有效。然而，至少有一个<em class="kt">字段</em>必须保留。</p><p id="94ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们尝试通过将用户id传递给查询来获取用户。</p><p id="8aba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，在模式中，我们确定函数类型、参数及其类型:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="f74f" class="le lf in la b gy lg lh l li lj">type Query {<br/>  hello: String<br/>  users: [User!]!<br/>  posts: [Post!]!<br/>  user(id: ID!): User!<br/>}</span></pre><p id="9f66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们定义解析器中的函数:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6adc" class="le lf in la b gy lg lh l li lj">const resolvers = {<br/>  Query: {<br/>    hello: () =&gt; “Selam.”,<br/>    users: (parent, args) =&gt; Users,<br/>    posts: (parent, args) =&gt; Posts,<br/>    user: (parent, args) =&gt; Users.find((user) =&gt; String(user.id) ===     args.id),<br/>  },<br/>};</span></pre><p id="4489" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我想说一下概念<em class="kt"> args </em>。<em class="kt"> Args </em>是一个<em class="kt">对象</em>，实际引用的是已定义函数的参数。如上面的用户函数所示，传递的id表示为“<em class="kt"> args.id </em>”。</p><p id="1b88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我们运行项目并执行左边出现的查询时，我们会得到右边的结果:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/80614e0eabb899464f8ef5b47b9b3bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dvi86_oUraL2u0Js1zDt5g.jpeg"/></div></div></figure><p id="f61a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">已获得id为1的用户。由于id参数的类型是<em class="kt"> ID </em>，所以可以传递给函数作为<em class="kt"> Int </em>或<em class="kt"> String </em>。</p><h1 id="2ed5" class="ma lf in bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">graph QL中的嵌套查询</strong></h1><p id="6407" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">让我们制作一个嵌套查询示例:</p><p id="1c37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，假设一个作者有不止一篇文章。根据我们的假数据，id为1的用户已经有两个帖子了。但是，由于一个帖子不能有多个作者，每个帖子将对应一个用户。</p><p id="e182" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们形成返回作者的帖子和帖子作者的查询。同样，我们首先从模式开始。在<em class="kt"> TypeDefs </em>中，我们添加“用户”<em class="kt">字段</em>到帖子，添加“帖子”<em class="kt">字段</em>到用户:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="0a37" class="le lf in la b gy lg lh l li lj">type User{<br/>  id: ID!<br/>  username: String!<br/>  city: String<br/>  posts: [Post!]<br/>}<br/>type Post{<br/>  id: ID!<br/>  title: String!<br/>  userId: ID!<br/>  user: User!<br/>}</span></pre><p id="d517" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是当我们查看数据时，就像用户数组中没有<em class="kt">的帖子字段</em>一样，在帖子数组中也没有<em class="kt">的用户字段</em>。我们将通过在<em class="kt">解析器</em>中定义匹配用户Id和文章用户id的函数来解决这个问题。然而，由于这些<em class="kt">字段</em>在数组中不可用，我们无法在<em class="kt">查询</em>下定义它们。</p><p id="9361" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了将用户添加到Post类型中，我们定义了一个单独的<em class="kt">解析器</em>，称为Post。同样，我们定义了一个单独的<em class="kt">解析器</em>，它被称为User，为用户定义一个帖子<em class="kt">字段</em>:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="30e8" class="le lf in la b gy lg lh l li lj">const resolvers = {<br/>  Query: {<br/>    hello: () =&gt; “Selam.”,<br/>    users: (parent, args) =&gt; Users,<br/>    posts: (parent, args) =&gt; Posts,<br/>    user: (parent, args) =&gt; Users.find((user) =&gt; String(user.id) === args.id),<br/>  },  Post: {<br/>    user: (parent, args) =&gt; Users.find((user) =&gt; user.id ===   parent.userId),<br/>  },  User: {<br/>    posts: (parent, args) =&gt; Posts.filter((post) =&gt; post.userId === parent.id),<br/>  },<br/>};</span></pre><p id="8738" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是<em class="kt">母</em>概念出现的地方。顾名思义，在<em class="kt">嵌套查询</em>中，“父查询”的参数由“<em class="kt"> parent </em>”参数表示，以便我们在子查询中使用。</p><p id="78b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">比如我们来读第二个函数。为了获取Id为1的用户的帖子，它检查posts数组并获取其userId等于所需的用户id的帖子。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/46a17ef1a3ee704d9017ebd6c26f99c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqbQJtlQMCSBR3yDIY2idQ.jpeg"/></div></div></figure><p id="6df9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们进行一个<em class="kt">突变</em>查询。让我们创建一个向用户数组添加新用户的函数。我将以下代码添加到TypeDefs中:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5b0c" class="le lf in la b gy lg lh l li lj">type Mutation{<br/> addUser(id:ID!, username:String!, city:String! ): User<br/>}</span></pre><p id="6db5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们定义这个函数的<em class="kt">解析器</em>，我们已经指定了它的模式。在<em class="kt">解析器</em>中，我们在<em class="kt">突变</em>下编写以下代码:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c4de" class="le lf in la b gy lg lh l li lj">Mutation: {<br/>  addUser: (_, { id, username, city }) =&gt; {<br/>    const newUser = {<br/>    id: id,<br/>    username: username,<br/>    city: city,<br/>  };  Users.push(newUser);<br/>  return newUser;<br/>},<br/>},</span></pre><p id="784c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们看到函数的第一个参数是一个下划线。由于我们在这里没有使用<em class="kt">父</em>参数，我们可以更喜欢这种实用的语法。第二个参数实际上是一个<em class="kt">对象</em>，它由三个参数组成，我们将它们传递给函数。(在大括号中)</p><p id="607a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们运行该函数并运行左边的查询时，我们得到以下结果:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/a682c51411aa7c4ad3250f9a63122d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*We60o8DKVbxuTfrONQGNlQ.jpeg"/></div></div></figure><h1 id="ba61" class="ma lf in bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">结论</strong></h1><p id="c6e7" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">综上所述，我们通过使用<em class="kt"> graphql-yoga </em>库，在Node.js中搭建了一个<em class="kt"> GraphQL </em> web服务器。我们通过解释概念<em class="kt">typedef</em>和<em class="kt"> resolvers </em>来举例说明，这是构成<em class="kt"> GraphQL </em>的两个主要元素。</p><p id="9890" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过以下链接访问整个项目:</p><p id="fa35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ku" href="https://github.com/azizkale/Web-Server-in-NodeJS-with-GraphQL" rel="noopener ugc nofollow" target="_blank">https://github . com/Aziz kale/Web-Server-in-NodeJS-with-graph QL</a></p><p id="4836" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多信息，可以访问<em class="kt"> GraphQL </em>官方网站。</p><div class="nd ne gp gr nf ng"><a href="https://www.graphql.org" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">API的查询语言</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">一种用于API的查询语言——graph QL提供了API中数据的完整描述，为客户提供了…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">www.graphql.org</p></div></div><div class="np l"><div class="nq l nr ns nt np nu jt ng"/></div></div></a></div><h2 id="7b8f" class="le lf in bd mb nv nw dn mf nx ny dp mj kg nz oa mn kk ob oc mr ko od oe mv of bi translated">更新(2021年12月17日):</h2><p id="c77b" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">您还可以用另一个更新的包:apollo-server构建一个GraphQL服务器</p><p id="0e33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您只需要将apollo-server添加到项目中:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6c08" class="le lf in la b gy lg lh l li lj">npm i apollo-server — save</span></pre><p id="1ce9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的package.json文件应该如下所示:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/a35488d9a6bcfa0d4308311dd17cf2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVllFZEzo2rVe1sUm42CsA.jpeg"/></div></div></figure><p id="f19a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在文件<strong class="jx io"> index.js </strong>中你应该做三个修改:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/9fda558f88d17cf3238097c636d2fe02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfNa2OxxCBTbCDdxJL2LbQ.jpeg"/></div></div></figure><p id="5144" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们从文件<strong class="jx io"> apollo-server </strong>中导入<strong class="jx io"> ApolloServer </strong></p><p id="4db2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代替</p><p id="9b35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> GraphQLServer </strong>来自<strong class="jx io"> graphql-yoga </strong></p><p id="f92b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们用类<strong class="jx io"> ApolloServer </strong>而不是<strong class="jx io"> GraphQLServer来定义<strong class="jx io">服务器</strong>对象。</strong></p><p id="9988" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们用<strong class="jx io">方法运行服务器。听()</strong>代替<strong class="jx io">。start() </strong></p><p id="8dfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您访问浏览器中的“http://localhost:4000”地址后，一个更现代化的界面(<em class="kt"> GraphQL-Apollo </em>欢迎我们:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oi"><img src="../Images/d71ddd57caf100e39e11c5c84428d62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cesAhwe2kJMSo4nyaZ9oiQ.jpeg"/></div></div></figure></div></div>    
</body>
</html>