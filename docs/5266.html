<html>
<head>
<title>Jest Mock for Unit Testing MERN Back-end</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest模拟单元测试MERN后端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/jest-mock-for-unit-testing-mern-backend-983c1e3fef83?source=collection_archive---------0-----------------------#2021-10-27">https://javascript.plainenglish.io/jest-mock-for-unit-testing-mern-backend-983c1e3fef83?source=collection_archive---------0-----------------------#2021-10-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/48b37f1efd912cc35a74dda3c6b4dac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJfQdZ-uaq8nIR4YVtJEbQ.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Mocking bird</figcaption></figure><div class=""/><p id="61ab" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最近，我不得不为一个Node.js后端编写一些单元测试，该后端使用多个外部服务，如Redis(数据库)和Kafka(消息队列)。尽管我有使用Jest进行Node.js单元测试的经验，但我不知道当函数调用外部进程时该做什么，比如进行数据库查找。这就是<code class="fe kx ky kz la b">mock</code>发挥作用的地方，它允许我们“模仿”一个函数的实现，这样我们就可以测试代码的准确性，而不用担心其他任何事情。</p><p id="8e86" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了解释这个概念，我将使用一个简单的关于餐馆的Node.js -backend🌮！我们的应用程序可以创建具有唯一名称的餐厅，并使用mongoose将其存储在MongoDB中。</p><p id="7692" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这假设你已经熟悉Jest和Node.js，如果不熟悉，请阅读我的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/unit-testing-node-js-mongoose-using-jest-106a39b8393d">其他教程</a>关于如何开始Jest节点单元测试。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="deb2" class="lj lk jc bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">第1部分:应用程序设置</h1><p id="dbfc" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">一旦我们初始化<code class="fe kx ky kz la b">npm</code>，我们只需要安装express和mongoose。这是我将在本教程中使用的最低限度，但请随意使用更多的☕️</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="b3c1" class="mu lk jc la b gy mv mw l mx my">// set up node<br/>npm init<br/>// install dependencies<br/>npm i express mongoose</span></pre><h2 id="31c5" class="mu lk jc bd ll mz na dn lp nb nc dp lt kk nd ne lx ko nf ng mb ks nh ni mf nj bi translated">模型</h2><p id="233d" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">我们的模型非常简单。我们只有一家餐馆的名称、菜系和地址。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nk"><img src="../Images/9b2bf4b1f0090b168edebaa5c3dd888f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfPy-I8HtHZhpzL0u1wAdQ.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Restaurant Model</figcaption></figure><h2 id="7b21" class="mu lk jc bd ll mz na dn lp nb nc dp lt kk nd ne lx ko nf ng mb ks nh ni mf nj bi translated">控制器</h2><p id="fc1f" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">我们将尝试为创建新餐馆的函数编写测试。该函数只接受一个名称、位置和菜肴类型，如果该名称尚未被使用，它将创建一个新餐馆。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nl"><img src="../Images/9756291d58a1b6e90114fc087ccf31d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vhtda97fusRgdUT7ig5hig.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Function to create a new restaurant: controllers/createRestaurant.js</figcaption></figure><p id="6b23" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个功能将被纳入我们的应用程序，就像这样</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nm"><img src="../Images/3abbf80512d9b6f849d299a1aeb559d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2s_0jm8r-MheTqx6ob1Ag.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Controller: controllers/index.js</figcaption></figure><p id="1d89" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过分解功能，我们可以很容易地在以后进行单元测试。最后，应用程序的入口点将看起来像:</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nn"><img src="../Images/420c05f1d14dba9a8bea66d59c074e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n392-ENU9RkPWZQC6Tk_nQ.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Entry point: index.js</figcaption></figure><h1 id="bec6" class="lj lk jc bd ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc ns me mf mg bi translated">第2部分:安装Jest</h1><p id="f147" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">我们可以使用<code class="fe kx ky kz la b">npm</code>为我们的测试安装Jest框架。</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="d467" class="mu lk jc la b gy mv mw l mx my">npm install jest</span></pre><h1 id="08a3" class="lj lk jc bd ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc ns me mf mg bi translated">第3部分:测试</h1><p id="f792" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">我发现一种简单易懂的方法是将单元测试放在与测试文件相同的文件夹中。因此，我们将在<code class="fe kx ky kz la b">controllers</code>文件夹中创建一个新文件。一个关键的事情是我们的测试文件的命名。他们不得不在<code class="fe kx ky kz la b">.test.js</code>结束。Jest就是这样识别它们并运行我们的测试的！</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/aadc26158fb5c999e6c0e5a601c1f06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*jvClHqxTCkx33eq1J8YRlA.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Folder structure for tests</figcaption></figure><h2 id="5828" class="mu lk jc bd ll mz na dn lp nb nc dp lt kk nd ne lx ko nf ng mb ks nh ni mf nj bi translated">第一个笑话——哎呀，测试😎</h2><p id="4eaa" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">最后，我们可以开始编写我们的第一个测试了！对于我们使用<code class="fe kx ky kz la b">mock</code>的第一个测试，我们将测试一个案例，我们试图用一个已经被使用的名字创建一个餐馆。这应该会抛出一个错误，我们希望确保这种情况发生。</p><p id="aa51" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要嘲笑这种行为，我们只需要说:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="492e" class="mu lk jc la b gy mv mw l mx my">Restaurant.findOne = jest.fn().mockReturnValueOnce({<br/>     name: "Amy's"<br/>});</span></pre><p id="75a6" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe kx ky kz la b">mock</code>的解剖是这样的。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/91dbbe6ccae34c603ab7e54827abdfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*su6JNm5mVBw8LGxrh8DUsQ.jpeg"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Mock anatomy</figcaption></figure><ol class=""><li id="004b" class="nv nw jc kb b kc kd kg kh kk nx ko ny ks nz kw oa ob oc od bi translated"><code class="fe kx ky kz la b">functionToMock</code>:这是您想在测试中改变其行为的函数。例如，对于我们的测试，我们需要模拟<code class="fe kx ky kz la b">Restaurant.findOne</code>来返回值，而不是实际搜索数据库。</li><li id="1073" class="nv nw jc kb b kc oe kg of kk og ko oh ks oi kw oa ob oc od bi translated">这是所有模仿中常见的</li><li id="0cae" class="nv nw jc kb b kc oe kg of kk og ko oh ks oi kw oa ob oc od bi translated"><code class="fe kx ky kz la b">mockReturnValueOnce</code>:这指定了我们想要模仿的内容。如果你只关心函数的返回值，你可以使用<code class="fe kx ky kz la b">mockReturnValueOnce</code>。换句话说，你想测试<code class="fe kx ky kz la b">functionToMock</code>何时抛出错误。在这种情况下，你可以使用<code class="fe kx ky kz la b">mockImplementation</code>。Jest为此提供了很多选择:<a class="ae lb" href="https://jestjs.io/docs/mock-function-api" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/mock-function-api</a>。</li><li id="7597" class="nv nw jc kb b kc oe kg of kk og ko oh ks oi kw oa ob oc od bi translated"><code class="fe kx ky kz la b">yourReturnValue</code>:这是你放置你想要的行为/回报值的地方。</li></ol><p id="0a6a" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在应该很清楚了，我们只是告诉<code class="fe kx ky kz la b">jest</code>，“嘿Jest，忘记函数的实际实现是什么，而是按照我告诉你的去做😎".厉害吧！我们不必担心创建一个在每个测试中都按照我们想要的方式运行的假数据库，相反，我们可以告诉<code class="fe kx ky kz la b">jest</code>从数据库调用中返回我们期望的值。</p><p id="bc71" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一个完整的例子，说明我们如何使用jest的模拟。首先，我们模仿<code class="fe kx ky kz la b">Model.findOne</code>，然后我们需要模仿<code class="fe kx ky kz la b">Model.prototype.save</code>函数。我们向<code class="fe kx ky kz la b">Restaurant.prototype.save</code>传递一个什么都不做的函数，这意味着当<code class="fe kx ky kz la b">jest</code>遇到我们在<code class="fe kx ky kz la b">controllers/createRestaurant.js</code>中调用<code class="fe kx ky kz la b">restaurant.save()</code>的代码时，它什么都不做。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oj"><img src="../Images/8ac622aa750ae31d974fafb4ba980b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3azrcjuU92ln6WWEQ_Fjzg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">First unit test: controllers/createRestaurant.unit.test.js</figcaption></figure><p id="9057" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">值得注意的是，我们可以使用<code class="fe kx ky kz la b">mockImplementation</code>而不是<code class="fe kx ky kz la b">mockReturnValue.</code>，例如，对于<code class="fe kx ky kz la b">Restaurant.findOne</code>，我们可以说:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="486a" class="mu lk jc la b gy mv mw l mx my">Restaurant.findOne = jest.fn().mockImplementation(() =&gt; {<br/>    return {<br/>        name: "Amy's"<br/>    }<br/>})</span></pre><p id="bf8f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这将以同样的方式运行，因为我们传递给它一个函数，它只返回一个名字。不信你试试看！</p><h2 id="65aa" class="mu lk jc bd ll mz na dn lp nb nc dp lt kk nd ne lx ko nf ng mb ks nh ni mf nj bi translated">运行覆盖测试</h2><p id="d676" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">现在是时候检查一切是否还在工作，我总是喜欢给我的测试增加覆盖率，这样我就知道我做得怎么样了。用玩笑话来说，这很简单。在<code class="fe kx ky kz la b">package.json</code>中，您需要添加这个脚本:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="4a35" class="mu lk jc la b gy mv mw l mx my">"test": "jest --coverage --verbose"</span></pre><p id="007f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，当您运行<code class="fe kx ky kz la b">npm run test</code>时，您将会看到您的覆盖结果以及🥳</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ok"><img src="../Images/499d858f658f3f42dd07a66aec29a6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVy4h0MWOjKGAw4Hty3qPA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Running tests</figcaption></figure></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="1ca5" class="lj lk jc bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">额外:模仿日志</h1><p id="0a18" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">大多数应用程序都有某种日志记录，测试我们是否记录了正确的信息是值得的。在您的函数中，您将记录信息、警告和错误，很可能使用第三方包。类似于当我们测试涉及数据库的函数时，我们可以在测试中模拟日志记录器的行为。</p><p id="20e4" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为本教程不是关于日志记录的，所以我将只创建一个虚拟函数，它只返回一个空对象，作为我们的日志记录器:</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ol"><img src="../Images/696653938c4d5ffa033a4f64ca8aad2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHEnBCzKRunvImiVlFBhAA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">utils/logger</figcaption></figure><p id="d7f7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在您的应用程序中，这将是日志系统(如<code class="fe kx ky kz la b">winston</code> logger)的合适助手。假设我们希望记录所有错误(第19行)以及成功创建餐馆时的信息日志(第29行)。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b5e90465694b718bf7637d18dc984a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUO_lZ7QkTRhAuwtq2xk1g.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Adding logging: controllers/createRestaurant.js</figcaption></figure><p id="f769" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在运行任何测试之前，我们需要在测试文件的顶部添加以下内容。这是一个具有两个级别的记录器示例:info和warn。如果你的记录器有更多的级别，你可以随意添加。</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="f500" class="mu lk jc la b gy mv mw l mx my">const mockInfo = jest.fn();<br/>const mockWarn = jest.fn();</span><span id="2963" class="mu lk jc la b gy om mw l mx my">// mocking Logging<br/>jest.mock("../utils/Logger", () =&gt; {<br/>    return {<br/>        getLogger: () =&gt; ({<br/>            info: mockInfo,<br/>            warn: mockWarn<br/>        })<br/>    }<br/>})</span></pre><p id="4b33" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这意味着当<code class="fe kx ky kz la b">createRestaurant</code>调用<code class="fe kx ky kz la b">"../utils/Logger"</code>文件中的<code class="fe kx ky kz la b">getLogger</code>函数时，不是创建并提供真正的logger函数，而是返回我们已经做好的空函数:<code class="fe kx ky kz la b">mockInfo</code>和<code class="fe kx ky kz la b">mockWarn</code>分别对应<code class="fe kx ky kz la b">info</code>和<code class="fe kx ky kz la b">warn</code>。</p><p id="79f8" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们如何检查我们在测试中调用了日志函数？🤔</p><p id="e473" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Jest提供了一个<code class="fe kx ky kz la b">toHaveBeenCalledWith</code>函数，它检查一个函数是否被某些参数调用。让我们为一个案例编写一个测试，在这个案例中，我们成功地创建了一个餐馆，并检查记录器是否正常工作。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi on"><img src="../Images/1e1964e11c489863748af475ae4c0730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuGQznp8Xy-cfZkCmJMqRQ.png"/></div></div></figure><p id="aff0" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，检查我们的测试是否全部通过…看看这个覆盖率！😯</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oo"><img src="../Images/f1a65fc10b27ae326da98566b98a166c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QH85Sozh3szd_bUaWTb47g.png"/></div></div></figure></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="e790" class="lj lk jc bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我们完成了🥳</h1><p id="dc8b" class="pw-post-body-paragraph jz ka jc kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">使用<code class="fe kx ky kz la b">mock</code>就是这样。当你编写单元测试时，它可以使生活变得简单得多，因为它消除了担心你正在使用的外部函数的行为的需要。给定特定的输入，你可以确保<strong class="kb jd">你的</strong>函数正常工作，这就是单元测试的意义所在！</p><p id="8935" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果有任何问题，或者在某一点上需要更多的指导，请联系我们。😊</p><p id="a7d8" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="op">更多内容请看</em><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb jd"><em class="op">plain English . io</em></strong></a></p></div></div>    
</body>
</html>