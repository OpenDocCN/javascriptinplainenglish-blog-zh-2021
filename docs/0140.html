<html>
<head>
<title>Create a GraphQL API Wrapper for your REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的REST API创建一个GraphQL API包装器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-graphql-api-wrapper-for-your-rest-api-7873c63fcce2?source=collection_archive---------10-----------------------#2021-01-08">https://javascript.plainenglish.io/create-a-graphql-api-wrapper-for-your-rest-api-7873c63fcce2?source=collection_archive---------10-----------------------#2021-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c18e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用现有的REST API，我们将学习如何围绕现有的服务创建GraphQL API，而不是完全重写</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1b58c433894a6ee8dd300d1de1dcb991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6UDn-S4VF_dDSZWM.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">GraphQL Consuming REST Services</figcaption></figure><h1 id="5c0e" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">介绍</h1><p id="e310" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">GraphQL是一个在客户端使用的有趣的服务。凭借其文档、游乐场和状态管理选项，如<a class="ae mg" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank"> relay </a>或<a class="ae mg" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> apollo </a>，开发人员体验对我和我的同事来说是一次爆炸。有一种常见的误解，认为可以使用REST或GraphQL，但不能两者都用。你可以两者兼得！当我学习的时候，我认为这是GraphQL或者REST的全部。要了解这些规范之间的差异，请访问<a class="ae mg" href="https://johnfay.dev/blog/understanding-graphql/" rel="noopener ugc nofollow" target="_blank">通过REST了解GraphQL】。我们中的许多人都有这样的情况，我们不想完全放弃现有的REST API来开始尝试GraphQL。</a></p><p id="1176" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">最后，您将拥有一个GraphQL API，它利用了您在JavaScript中选择的REST API。为了快速起见，我将使用<a class="ae mg" href="https://apidocs.covidactnow.org/" rel="noopener ugc nofollow" target="_blank"> Covid Act Now API </a>，但是您可以随意替换您自己的REST API和模型。如果您将使用相同的API，我建议<a class="ae mg" href="https://apidocs.covidactnow.org/access" rel="noopener ugc nofollow" target="_blank">现在获取您的API密钥</a>。这是即时的，所以不需要等待时间！让我们开始吧。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/5f7add5650924d7d83c5a9f16df29382.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*tnhIMGzR4i3iYaEP.gif"/></div></figure><h1 id="5c6d" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">构建您的API</h1><p id="6b30" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们将使用hello world脚本设置JavaScript，将其转换为GraphQL hello world端点，添加REST数据源，并建立关系以组合API调用。</p><h1 id="5b1e" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">项目设置</h1><p id="3f70" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">项目设置有一些可选步骤，例如使用<a class="ae mg" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank"> nodemon </a>为我们重新加载应用程序，使用<a class="ae mg" href="https://github.com/motdotla/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>加载环境变量。这将是您在JavaScript中添加您喜欢使用的工具的地方。</p><h1 id="22e9" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">创建项目</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="aaba" class="ms kt in mo b gy mt mu l mv mw">mkdir covid-graphql</span></pre><h1 id="a790" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">初始化npm包</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="5aea" class="ms kt in mo b gy mt mu l mv mw">npm init -y</span></pre><h1 id="dfa1" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">创建一个源目录和一个<code class="fe mx my mz mo b">index.js</code>文件</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="4574" class="ms kt in mo b gy mt mu l mv mw">touch src/index.js</span></pre><h1 id="28ba" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">给<code class="fe mx my mz mo b">index.js</code>添加一个<code class="fe mx my mz mo b">hello world</code>日志</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="5741" class="ms kt in mo b gy mt mu l mv mw">console.log("hello world")</span></pre><h1 id="bbb0" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">打开<code class="fe mx my mz mo b">package.json</code>，添加<code class="fe mx my mz mo b">dev</code>和<code class="fe mx my mz mo b">start</code>脚本</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="1c5c" class="ms kt in mo b gy mt mu l mv mw">"dev": "nodemon src/index.js --watch src/",<br/> "start": "node src/index.js"</span></pre><ul class=""><li id="0015" class="na nb in lm b ln mh lq mi lt nc lx nd mb ne mf nf ng nh ni bi translated"><code class="fe mx my mz mo b">dev</code>利用nodemon来监视<code class="fe mx my mz mo b">src</code>目录中的任何变化。</li><li id="7004" class="na nb in lm b ln nj lq nk lt nl lx nm mb nn mf nf ng nh ni bi translated"><code class="fe mx my mz mo b">start</code>使用node(比生产中的nodemon轻)。</li></ul><h1 id="b11a" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">在终端运行<code class="fe mx my mz mo b">npm run dev</code></h1><p id="db81" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">确保我们正常运行，不需要为未来的每一项变化重启我们的应用。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="0356" class="ms kt in mo b gy mt mu l mv mw">hello world</span></pre><p id="e5be" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">如果你认为这毫无意义，请对我宽容些。它会帮助某人。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/430b93146ccea11900c29b6d9c9d13d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*TRUedMLuD7t28UnF.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Be nice</figcaption></figure><h1 id="28e1" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">安装依赖项</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="64bf" class="ms kt in mo b gy mt mu l mv mw">npm install apollo-server apollo-datasource-rest dotenv</span></pre><h2 id="315b" class="ms kt in bd ku np nq dn ky nr ns dp lc lt nt nu le lx nv nw lg mb nx ny li nz bi translated">阿波罗服务器</h2><p id="0355" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">用于启动express服务器。</p><h2 id="d7d2" class="ms kt in bd ku np nq dn ky nr ns dp lc lt nt nu le lx nv nw lg mb nx ny li nz bi translated">阿波罗-数据源-休息</h2><p id="5c5c" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">用于利用REST源周围的缓存和其他基于类的继承。</p><h2 id="c012" class="ms kt in bd ku np nq dn ky nr ns dp lc lt nt nu le lx nv nw lg mb nx ny li nz bi translated">dotenv</h2><p id="4af1" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">用于传入环境变量。</p><h2 id="aada" class="ms kt in bd ku np nq dn ky nr ns dp lc lt nt nu le lx nv nw lg mb nx ny li nz bi translated">nodemon</h2><p id="7b58" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在开发模式下使用，因此您不需要在每次文件更改时重新启动应用程序。</p><h1 id="6560" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">创建Hello World模式</h1><p id="5e87" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">这个模式文件将是我们定义GraphQL API的地方。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="83c2" class="ms kt in mo b gy mt mu l mv mw">touch src/schema.js</span><span id="aea6" class="ms kt in mo b gy oa mu l mv mw">// schema.js<br/>const { gql } = require("apollo-server")</span><span id="3797" class="ms kt in mo b gy oa mu l mv mw">const typeDefs = gql`<br/>  type Query {<br/>    hello: String<br/>  }<br/>`</span><span id="5e77" class="ms kt in mo b gy oa mu l mv mw">module.exports = typeDefs</span></pre><p id="96d1" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">我们在<code class="fe mx my mz mo b">typeDefs</code>对象中所说的是，当我们在graphQL API中进行查询时，我们只能查询<code class="fe mx my mz mo b">hello</code>并且我们期望一个可空的<code class="fe mx my mz mo b">String</code>返回类型。为了使响应不可为空，我们将在末尾添加一个感叹号，就像这样<code class="fe mx my mz mo b">hello: String!</code>。</p><h1 id="007e" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">构建Apollo服务器</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="1218" class="ms kt in mo b gy mt mu l mv mw">// src/index.js<br/>require("dotenv").config()<br/>const { ApolloServer } = require("apollo-server")<br/>const typeDefs = require("./schema")</span><span id="e1d3" class="ms kt in mo b gy oa mu l mv mw">const server = new ApolloServer({ typeDefs })<br/>const port = process.env.port || 9000</span><span id="983d" class="ms kt in mo b gy oa mu l mv mw">server.listen(port).then(() =&gt; {<br/>  console.log(`server running 🚀 http://localhost:${port}`)<br/>})</span></pre><p id="9e75" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">在<a class="ae mg" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9000 </a>查看您的模式定义。如果您碰巧尝试查询<code class="fe mx my mz mo b">hello</code>，您将会发现响应为空。我们仍然需要定义解析器响应。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/4ff28358e67b9e5ed9f8d01dc30f8002.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*bz-Pvj-ky4GdeEww.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">You’re not losing it…expected</figcaption></figure><h1 id="e8b9" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">为<code class="fe mx my mz mo b">hello</code>创建解析器</h1><p id="b316" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">解析器是完成实际工作的地方。该模式根据客户端可以做什么来设置API的限制。实际上做这些工作是解析器的工作。类似于我以前帖子中的查询和突变解释，如果需要，我们将返回<code class="fe mx my mz mo b">Query</code>和<code class="fe mx my mz mo b">Mutation</code>。在query下，我们现在添加我们的<code class="fe mx my mz mo b">hello</code>解析器来返回<code class="fe mx my mz mo b">hello world</code>。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="c49d" class="ms kt in mo b gy mt mu l mv mw">touch src/resolvers.js</span><span id="51b6" class="ms kt in mo b gy oa mu l mv mw">module.exports = {<br/>  Query: {<br/>    hello: () =&gt; {<br/>      return "hello world"<br/>    }<br/>  }<br/>}</span></pre><h1 id="b0da" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">将解析器添加到<code class="fe mx my mz mo b">src/index.js</code> apollo-server声明</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="a0d9" class="ms kt in mo b gy mt mu l mv mw">const resolvers = require("./resolvers")</span><span id="87b6" class="ms kt in mo b gy oa mu l mv mw">const server = new ApolloServer({ typeDefs, resolvers })</span></pre><p id="4233" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">此时，当您查询<code class="fe mx my mz mo b">hello</code>时，您应该会得到预期的响应。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/11d1594131ee5f81d2d290c449d5d23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5ksBJJUSZOSNIy_a.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Hello world resolver</figcaption></figure><h1 id="42e7" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">连接REST源</h1><p id="09ea" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在这里，我们将构建一个REST数据源类，它将能够在我们的解析器中使用，以利用一些实际的结果。</p><h1 id="6fd2" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">创建REST数据源</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="eb10" class="ms kt in mo b gy mt mu l mv mw">mkdir src/datasources<br/>touch src/datasources/CovidActNowAPI.js</span><span id="bf72" class="ms kt in mo b gy oa mu l mv mw">const { RESTDataSource } = require("apollo-datasource-rest")</span><span id="b453" class="ms kt in mo b gy oa mu l mv mw">class CovidActNowAPI extends RESTDataSource {<br/>  constructor() {<br/>    super()<br/>    this.baseURL = "https://api.covidactnow.org/v2/"<br/>  }<br/>}</span><span id="cd2b" class="ms kt in mo b gy oa mu l mv mw">module.exports = CovidActNowAPI</span></pre><p id="12a9" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">这里我们真正需要做的是扩展<code class="fe mx my mz mo b">RESTDataSource</code>来访问内存缓存、HTTP助手函数和分页。要了解更多信息，请访问<a class="ae mg" href="https://github.com/apollographql/apollo-server/tree/main/packages/apollo-datasource-rest" rel="noopener ugc nofollow" target="_blank"> apollo-datasource-rest </a>。</p><h1 id="52e2" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">创造。简介中的env文件和插件API密钥</h1><p id="d1b1" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">希望您在<a class="ae mg" href="https://apidocs.covidactnow.org/access" rel="noopener ugc nofollow" target="_blank">从Covid Act Now api获得您的API密钥</a>后，已经将密钥存放好了。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1d5948e54618720e45230a0d239e6f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*Tgm44kyA1l8cCFeV.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">What is this amateur hour?</figcaption></figure><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="9530" class="ms kt in mo b gy mt mu l mv mw">touch .env</span><span id="de42" class="ms kt in mo b gy oa mu l mv mw">COVID_ACT_NOW=YOUR_KEY_HERE</span></pre><h1 id="e85f" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">添加一些方法来获取CovidActNowAPI类中的州和县</h1><p id="e657" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">看一下<a class="ae mg" href="https://apidocs.covidactnow.org/api#tag/State-Data" rel="noopener ugc nofollow" target="_blank"> Covid Act Now API文档</a>我们可以看到，JSON响应可以在我们的base URL(<a class="ae mg" href="https://api.covidactnow.org/v2/" rel="noopener ugc nofollow" target="_blank">https://api.covidactnow.org/v2/</a>)加上<code class="fe mx my mz mo b">states</code>中找到，针对美国所有州，<code class="fe mx my mz mo b">state/OH</code>针对美国个别州，如俄亥俄州，<code class="fe mx my mz mo b">counties</code>针对美国所有县，<code class="fe mx my mz mo b">county/39001</code>针对个别县，通过<a class="ae mg" href="https://www.nrcs.usda.gov/wps/portal/nrcs/detail/national/home/?cid=nrcs143_013697" rel="noopener ugc nofollow" target="_blank"> fips </a>加上我们的API键作为参数。还有一个可选的<code class="fe mx my mz mo b">.timeseries</code>,我们可以添加进来，以包含度量和实际数字之类的一组值。对于获取州或县的列表，我选择避免这样做，因为这是一个大得多的有效负载，但我启用了美国各个州和县的时间序列。使用它，我们现在可以创建与REST服务交互的函数。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="957a" class="ms kt in mo b gy mt mu l mv mw">async getAllStates() {<br/>    const response = await this.get(`states.json?apiKey=${process.env.COVID_ACT_NOW}`);<br/>    return response || [];<br/>}</span><span id="0ed2" class="ms kt in mo b gy oa mu l mv mw">async getState(stateCode) {<br/>    const response = await this.get(<br/>    `state/${stateCode}.timeseries.json?apiKey=${process.env.COVID_ACT_NOW}`<br/>    );<br/>    return response;<br/>}</span><span id="3a61" class="ms kt in mo b gy oa mu l mv mw">async getAllCounties() {<br/>    const response = await this.get(`counties.json?apiKey=${process.env.COVID_ACT_NOW}`);<br/>    return response || [];<br/>}</span><span id="de3d" class="ms kt in mo b gy oa mu l mv mw">async getCounty(fips) {<br/>    const response = await this.get(<br/>    `county/${fips}.timeseries.json?apiKey=${process.env.COVID_ACT_NOW}`<br/>    );<br/>    return response;<br/>}</span></pre><h1 id="1cf0" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">将数据源添加到apollo-graphql服务器</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="d741" class="ms kt in mo b gy mt mu l mv mw">// index.js<br/>const CovidActNowAPI = require("./datasources/CovidActNowAPI")</span><span id="bfeb" class="ms kt in mo b gy oa mu l mv mw">const server = new ApolloServer({<br/>  dataSources: () =&gt; ({<br/>    covidApi: new CovidActNowAPI()<br/>  }),<br/>  typeDefs,<br/>  resolvers<br/>})</span></pre><h1 id="a29c" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">更新模式以将州和县反映为查询</h1><p id="c089" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">这应该是你最费时间的部分。相对于Covid Act Now API，他们有一个方便的<a class="ae mg" href="https://apidocs.covidactnow.org/api#tag/Actuals" rel="noopener ugc nofollow" target="_blank">模型</a>部分，将向您显示一些您需要重新创建的子类别类型，以告诉该API的消费者什么是可能的。对于任何API，我在这里的过程都只是浏览JSON响应，并确保我想要的所有可用数据都包含在内。每个嵌套对象都需要模式中的类型才能被识别。如果你不需要它，不要为它创建类型，它会被忽略😊您还可以参考<a class="ae mg" href="https://www.apollographql.com/docs/tutorial/schema/" rel="noopener ugc nofollow" target="_blank"> apollo文档—构建一个模式</a>来查看这里的任何语法，比如不可空的(！)、查询或变异的输入参数(<code class="fe mx my mz mo b">county(fips: String!): County</code>)或数组响应(<code class="fe mx my mz mo b">[County]</code>)。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="0d5a" class="ms kt in mo b gy mt mu l mv mw">const typeDefs = gql`<br/>  type Query {<br/>    counties: [County!]!<br/>    county(fips: String!): County<br/>    states: [State!]!<br/>    state(stateCode: String!): State<br/>  }</span><span id="542f" class="ms kt in mo b gy oa mu l mv mw">type County {<br/>    fips: String!<br/>    country: String!<br/>    state: String!<br/>    county: String!<br/>    population: Int!<br/>    metrics: Metric!<br/>    riskLevels: RiskLevel!<br/>    actuals: Actual!<br/>    lastUpdatedDate: String<br/>    url: String<br/>    metricsTimeseries: [Metric!]<br/>    actualsTimeseries: [Actual!]<br/>    riskLevelsTimeseries: [RiskLevel!]<br/>  }</span><span id="2a51" class="ms kt in mo b gy oa mu l mv mw">type State {<br/>    fips: String!<br/>    country: String!<br/>    state: String!<br/>    population: Int!<br/>    metrics: Metric!<br/>    riskLevels: RiskLevel!<br/>    actuals: Actual!<br/>    lastUpdatedDate: String<br/>    url: String<br/>    metricsTimeseries: [Metric!]<br/>    actualsTimeseries: [Actual!]<br/>  }</span><span id="37d9" class="ms kt in mo b gy oa mu l mv mw">type Metric {<br/>    testPositivityRatio: Float<br/>    caseDensity: Float<br/>    contactTracerCapacityRatio: Float<br/>    infectionRate: Float<br/>    infectionRateCI90: Float<br/>    icuHeadroomRatio: Float<br/>    icuHeadroomDetails: ICUHeadroomDetails<br/>    icuCapacityRatio: Float<br/>    date: String<br/>  }</span><span id="c68f" class="ms kt in mo b gy oa mu l mv mw">type ICUHeadroomDetails {<br/>    currentIcuCovid: Int<br/>    currentIcuCovidMethod: String<br/>    currentIcuNonCovid: Int<br/>    currentIcuNonCovidMethod: String<br/>    icuCapacityRatio: Float<br/>  }</span><span id="a0d4" class="ms kt in mo b gy oa mu l mv mw">type RiskLevel {<br/>    overall: Int<br/>    testPositivityRatio: Float<br/>    caseDensity: Float<br/>    contactTracerCapacityRatio: Float<br/>    infectionRate: Float<br/>    icuHeadroomRatio: Float<br/>    icuCapacityRatio: Float<br/>    date: String<br/>  }</span><span id="5e61" class="ms kt in mo b gy oa mu l mv mw">type Actual {<br/>    cases: Int<br/>    deaths: Int<br/>    positiveTests: Int<br/>    negativeTests: Int<br/>    contactTracers: Float<br/>    hospitalBeds: HospitalBed<br/>    icuBeds: ICUBed<br/>    newCases: Int<br/>    date: String<br/>  }</span><span id="ece5" class="ms kt in mo b gy oa mu l mv mw">type HospitalBed {<br/>    capacity: Int<br/>    currentUsageTotal: Int<br/>    currentUsageCovid: Int<br/>    typicalUsageRate: Float<br/>  }</span><span id="c41c" class="ms kt in mo b gy oa mu l mv mw">type ICUBed {<br/>    capacity: Int<br/>    currentUsageTotal: Int<br/>    currentUsageCovid: Int<br/>    typicalUsageRate: Float<br/>  }<br/>`</span></pre><p id="b61b" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">我全力以赴做模特。我只留下了很少的几个键，在这里我得到了很多有用的信息。如果这是一个很大的量，开始小的和递增的插件类型。或者一次性完成。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/713e0b5679003a986adc7df33e3d1ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*ust_IlZkC3hSatZ8.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">I’m kind of a big deal…</figcaption></figure><h1 id="f5d3" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">更新解析程序以正确解析</h1><p id="af86" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">作为任何查询函数的一部分，每个查询都有一个输入列表。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="3e11" class="ms kt in mo b gy mt mu l mv mw">fieldName: (parent, args, context, info) =&gt; data</span></pre><p id="c2d5" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">我们的函数不需要<code class="fe mx my mz mo b">parent</code>或<code class="fe mx my mz mo b">info</code>，但是我们需要的是访问输入<code class="fe mx my mz mo b">args</code>或参数和<code class="fe mx my mz mo b">context</code>，因为这包括嵌套在我们定义的Apollo GraphQL服务器中的<code class="fe mx my mz mo b">dataSources</code>。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="3542" class="ms kt in mo b gy mt mu l mv mw">// resolvers.js<br/>Query: {<br/>    counties: (_, __, { dataSources }) =&gt; dataSources.covidApi.getAllCounties(),<br/>    county: (_, { fips }, { dataSources }) =&gt; dataSources.covidApi.getCounty(fips),<br/>    states: (_, __, { dataSources }) =&gt; dataSources.covidApi.getAllStates(),<br/>    state: (_, { stateCode }, { dataSources }) =&gt; dataSources.covidApi.getState(stateCode),<br/>},</span></pre><h1 id="116a" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">使生效</h1><p id="3db5" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">一旦您将新创建的REST数据源连接到解析器，您应该能够在操场上进行测试。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/d7e7e942f84306a36bec75846f5730d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dlormR4KrJMLoZBo.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Sample Counties response in GraphQL</figcaption></figure><h1 id="4a55" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">通过API调用伪造关系</h1><p id="66f6" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">假设此API的消费者正在构建一个美国地图，展示新冠肺炎的一个州及其县的影响。他们希望美国的一个州和所有的县都能呈现他们的UI。如果这还不是一个REST端点，那么它是两个端点:<code class="fe mx my mz mo b">/state/OH</code>和<code class="fe mx my mz mo b">/counties</code>端点。让我们把这些结合起来，把GraphQL推离客户端。</p><h1 id="05dc" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">将县数组添加到州</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="5403" class="ms kt in mo b gy mt mu l mv mw">// schema.js<br/>const typeDefs = gql`<br/>  type State {<br/>    counties: [County!] // highlight-line<br/>    fips: String!<br/>    country: String!<br/>    state: String!<br/>    population: Int!<br/>    metrics: Metric!<br/>    riskLevels: RiskLevel!<br/>    actuals: Actual!<br/>    lastUpdatedDate: String<br/>    url: String<br/>    metricsTimeseries: [Metric!]<br/>    actualsTimeseries: [Actual!]<br/>  }</span></pre><h1 id="b039" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">获取<code class="fe mx my mz mo b">getState</code>中的县</h1><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="41e5" class="ms kt in mo b gy mt mu l mv mw">// CovidActNowAPi.js</span><span id="850d" class="ms kt in mo b gy oa mu l mv mw">async getState(stateCode) {<br/>    const state = await this.get(<br/>      `state/${stateCode}.timeseries.json?apiKey=${process.env.COVID_ACT_NOW}`<br/>    );<br/>    const counties = await this.get(`counties.json?apiKey=${process.env.COVID_ACT_NOW}`);</span><span id="a9d1" class="ms kt in mo b gy oa mu l mv mw">return {<br/>      ...state,<br/>      counties: counties.filter(({ state: stateCode }) =&gt; stateCode === state.state),<br/>    };<br/>  }</span></pre><p id="bacb" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">如果你愿意，你也可以在此时将县添加到<code class="fe mx my mz mo b">getAllStates</code>函数中。虽然它的性能不会很好，但在这里比在客户端要好。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f708eb4d1a975321b5cb3687c7fd650f.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/0*lzG_KL6O9SdqzE9f.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">We are laughing… Anchorman</figcaption></figure><h1 id="84f3" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">验证州内的县</h1><p id="ae1d" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">测试以确保您可以查询您期望的内容。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="4868" class="ms kt in mo b gy mt mu l mv mw">{<br/>  state(stateCode:"OH"){<br/>    state<br/>    counties{<br/>      fips<br/>      county<br/>      population<br/>      metrics{<br/>        testPositivityRatio<br/>      }<br/>      actuals{<br/>        cases<br/>        deaths<br/>      }<br/>    }<br/>  }<br/>}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/06ede4e21e0751ae4574afbed8a14fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cbi6HH_Q3Tek82jT.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Counties nested under a State in GraphQL</figcaption></figure><h1 id="01a4" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">接下来:模式优先与代码优先</h1><p id="6c56" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">如果您有兴趣了解这两种GraphQL方法背后的利与弊，请继续关注我的下一篇文章，在这篇文章中，我们将使用本教程中编写的API，并通过从模式优先切换到代码优先以及使用更好的开发人员工具进行扩展来更进一步。我在想下一步该去哪里。如果你想看具体的东西，请告诉我。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/1b3f2ded1dbdd3739bff648552697aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*hz3ZceZxaDMcg1wm.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Immediately regret this decision — Anchorman</figcaption></figure><h1 id="2bee" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">摘要</h1><p id="a780" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们已经从头开始创建了一个GraphQL API，构建了一个REST服务数据源来利用我们现有的服务，并开始利用这个平台来看到一些GraphQL的好处。如果您在任何时候迷失了方向，这里的<a class="ae mg" href="https://github.com/keonik/covid-graphql" rel="noopener ugc nofollow" target="_blank">是<code class="fe mx my mz mo b">part1</code>分支上的存储库代码。你也可以参考Heroku上的</a><a class="ae mg" href="https://covid-act-now-graphql.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">游乐场</a>来尝试一些查询。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d6a64c9974c56108ffa00eaf207f20ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*AyblZ7dgqZUI1DA0.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Hooray!</figcaption></figure></div></div>    
</body>
</html>