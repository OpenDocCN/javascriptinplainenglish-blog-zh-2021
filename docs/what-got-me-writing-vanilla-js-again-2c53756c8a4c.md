# 是什么让我又开始写普通的 JavaScript 了

> 原文：<https://javascript.plainenglish.io/what-got-me-writing-vanilla-js-again-2c53756c8a4c?source=collection_archive---------2----------------------->

## 违背行业标准。但是值得吗？

![](img/3e133e72a6029a96609bc6c0b4629ac4.png)

逆水行舟不容易。前段时间，我写了一篇关于管理 DOM 节点的文章，并认为 T2 的普通 JS 比虚拟 DOM 要快。这些天，我在 3 年后重温这些话题。重读这些文章，我可以发现这些论点中的漏洞，因为这篇文章中可能也有一些漏洞。我也承认我自己并不是 100%赞同这些想法。

我现在意识到，我没有 100%支持这些想法的原因是我从错误的角度看待它。这不仅仅是性能的问题。拥有巨大的性能开销当然很好，但是那种认为普通开发更难或者更不愉快的想法也是完全错误的。不到一周的时间，我刚刚将我的一个项目移植到 vanilla，我想分享一下我对整个经历的想法。

我将在这篇文章之后继续写一系列关于*如何*的部分，但是在这里我想谈谈为什么。从我的经验来看，如何是容易的部分。这就是为什么许多开发人员会迷失的原因。

# 回到过去…

但在我们开始之前，我真的需要谈谈在我看来，在 2010 年至 2013 年期间我们行业中完全迷失的一些东西。

我很久以前就开始做网站开发了。大概是在 2004 年或 2005 年的时候。那是 HTML 4 的时代，当 [Internet Explorer](https://en.wikipedia.org/wiki/Internet_Explorer) 和 [Netscape Navigator](https://en.wikipedia.org/wiki/Netscape_Navigator) 忙于发动一场让每个人的生活变得悲惨的战争时，CSS Level 2 还在某种程度上被谣传。这是网络标准运动最终开始对现实世界产生切实影响的时候。

互联网也很慢。我们大多数人的拨号连接速度约为每秒 28~96 千波特(换算成 Kbps，那是“难以想象的慢”)。有些开发人员和网页设计人员建议你不要让每页的有效负载超过 15Kb，以减少加载时间。这包括所有的 CSS，gif(不，不是有趣的动画 gif，用于圆角的静态图像等等)，甚至 HTML。我们还必须跟踪流行的屏幕尺寸，因为没有那么多方法可以编写 CSS 来适应不同的屏幕。谢天谢地，大概有三个半。至少手机上网没那么多，也没人关心少数上网的人。

然而，真正的挑战不是*编写*应用程序。这部分很简单。你只需要把文件放在一个地方，在你的 HTML 中添加`<link>`和`<script>`标签就可以了。我们没有捆绑，缩小，或任何类似的事情。那时候一切都小得多。在某种程度上，那时的生活更简单。在很多方面。

然后互联网变快了。屏幕越来越大，像素越来越多。文件变大了。富客户端 web 应用程序的兴起使 JavaScript 成为业内最流行(同时也是最令人讨厌)的语言之一。今天，一个普通的应用程序在压缩和缩小时有几百 Kb 的代码，因为包的大小如此之大，涉及的文件数量如此之多，我们需要专门的工具来管理所有这些。很多时候，您将无法在 15Kb 的推荐有效载荷大小中容纳一张背景图像。

今天，您至少需要了解以下内容:

*   TypeScript 和/或 ESNext
*   巴比伦式的城市
*   网络包
*   玩笑
*   反应、Vue 或角度
*   JSX
*   许多非标准的 CSS 编写方法
*   Redux 或 Mobx 或任何数量的其他库来管理状态

我们被告知，我们使用这些工具是因为我们的应用程序变得越来越复杂，我们需要工具来解决这种复杂性。当然，变化是渐进的。先是这个工具，然后是那个工具。

最初，我站在一旁看着这一切，想知道这一切有什么大惊小怪的，仍然愉快地用 Backbone 和令人尊敬的 jQuery 编码。然后我很快了解到，如果不了解最新最棒的框架，被认为是一个严肃的开发人员变得越来越困难。我学会了其中的大部分，并坚持了几年，完全忘记了，在开始的时候，事情并没有那么复杂，也没有那么难。

# 然后就发生了

2021 年对我来说是忙碌的一年。我们有新人加入我们的团队，然后是雇用一群高级开发人员的混乱。试图在他们之间找到一个关于技术堆栈的共同主题，同时试图让项目离开冰面和地面是…有趣的。不久前，我还在做一个兼职项目，指导一些想从事 web 开发的人。

最初的几周确实很艰难。我致力于建立通用的工程原则，从这些原则中，团队可以就我们如何做事达成某种共识(无论如何是最通用的术语)。当我和不同的人交谈时，我注意到我们甚至对什么是复杂，复杂和简单之间的区别没有相同的概念。我和他们分享了 Rich Hickey 的 [Simple Made Easy](https://www.youtube.com/watch?v=LKtk3HCgTa8) ，这是 Clojure 语言的作者在 2011 年创作的经典作品。我自己重新看了一遍，它给我的感觉和我第一次看的时候一样。我开始怀疑自己目前的做法。

几乎在同一时间，我的一个学员找到我，问了我一个关于锻炼待办事项列表应用的问题。我看了该课程作者写的示例代码，它糟透了。我也这样告诉了学员，并承诺重写一遍，展示“专业人士会怎么做。”(是的，华而不实，我知道。)

我们开始了视频通话，我分享了我的屏幕。我能听到他们的孩子每五分钟就问一次问题。我不能说我羡慕他们的地位。他们的整个世界都崩溃了(或者即将崩溃)，他们不得不加快网络开发的速度，React，Webpack，所有这一切。

我们从一个`index.html`和`app.js`开始。CSS 是由 CDN 中的一些 CSS 框架提供的，最初的作者决定使用它，所以我们坚持使用它。在整个会议中，我试图保持代码尽可能的简单，不要将它们与类似 curried 函数、类等“花哨”的结构混淆。毕竟，这不是炫耀，而是传授正确的方法:关注点分离、效率等等。

完成后，学员对实现的清晰和简单欣喜若狂…我也是。

有些部分读起来就像用户故事。

```
function addNewTask(taskList, taskText) {
  let task = createTask(taskText)
  addTaskToTaskList(task, taskList)
  saveTaskListToLocalStorage(taskList)
}function removeTask(taskList, taskIndex) {
  removeTaskFromTaskList(taskIndex, taskList)
  saveTaskListToLocalStorage(taskList)
}function clearAllTasks(taskList) {
  clearTaskList(taskList)
  clearTaskListInLocalStorage()
}
```

简单的程度，没有代码的唯一目的是让*真正的*代码完成工作(又名，样板)，不需要任何构建工具的简单性以一种好的方式带来了 15 年前的记忆。

我和我的一些同事分享了这个结果。他们中的一个被逗乐了，但是确信这种方法不能扩展。另一个和我一样对此印象深刻。第三个，一个更有经验的开发人员，点头表示同意(或者至少我想象他们在空闲窗口的另一边这样做)，并说了一些大意是一般应该这样做的话。

困扰我的问题是，“为什么我们不这样写软件？”对普通代码印象最深的队友和我开始着手回答这个问题。然而，我们没有考虑为什么我们*没有*做这件事，而是开始回答为什么我们*应该*做这件事，以及这种体验会是什么样的。第三个同事后来加入了聚会。大约一周后，我们有了答案:没有理由用其他方式编写 web 应用程序。原因很简单:更简单，更便宜。

# 等等，什么？

请原谅我。

假设你仍然相信 React 很简单，而普通的 JavaScript 很难。让我们在两者中做传说中的“你好，世界”。我们只是希望应用程序在屏幕上说“你好，世界”。仅此而已。我们只是在心里做，因为我不想浪费你的时间在你已经看过无数次的代码上。

让我们先做出反应。

首先，安装 Node.js 和 NPM。(当然，你已经有了，但这是你在某个时候不得不做的事情。)接下来你装`npx`因为现如今谁不装！然后你跑`npx create-react-app hello-world`。接下来你用`yarn start`启动应用程序。在这一点上，你可以说你完成了，但也许还没有，因为示例应用程序不是一个“你好，世界。”所以你找到了`App.js`(或`App.tsx`)并对其进行编辑，使其显示如下:

```
export default () => <div>Hello, World</div>
```

开发服务器会自动更新页面。搞定了。

接下来，香草。

您使用您的文件管理器(或者您的 IDE/编辑器中的文件管理器)并创建一个名为`hello-world`的文件夹。你创造了`index.html`。然后向其中添加以下 HTML:

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Hello, World</title>
  </head>
  <body>
    <div>Hello, World</div>
  </body>
</html>
```

然后在浏览器中打开该文件。搞定了。

也许你在想“好吧，那是欺骗。您没有使用 JavaScript 创建 DOM 节点！那都只是 HTML。”

我的朋友，*是*的重点。如果用 HTML 可以做到，为什么*要用 JavaScript 来做*？你可能认为*应该*用 JavaScript 来完成，但那只是你编造的一个规则，与*能够*使用“仅仅 HTML”的物理现实没有任何关系。在浏览器中呈现 HTML 的能力在近三十年前[就已经存在了](https://en.wikipedia.org/wiki/Mosaic_(web_browser))，我认为我们只是因为一些虚构的规则而忘记了使用它。

当然，我并不是想说你的整个应用只需要 HTML 和 CSS 就可以完成。你仍然需要很多…嗯，一些… JavaScript。不过，我们将在以后的文章中讨论这个问题。现在，我想集中讨论几件事。

普通例子有什么是反应例子没有的？好吧，让我换个说法。当你开始吃香草冰淇淋时，你不再需要的东西是什么？

*   Node.js/NPM/yarn/npx/create-*-app
*   没有构建步骤
*   没有开发服务器

你会问，为什么这些会成为问题？

你是否曾经因为 yarn 缓存中的包太多而耗尽了固态硬盘上的空间？或许你没有，但我有。诚然，它是一个较小的 128GB 固态硬盘，但仍然是 128GB，只有操作系统和一些编程工具。没有游戏，没有媒体文件，什么都没有。纱线缓存超过 70GB！

我还在一个项目上运行了一个`npm audit`,只是发现如果不进去修改我的代码，就不可能满足更新的依赖关系。一些软件包需要一个主要的版本升级。

Node.js 也可能会过时，所以您必须更新，这有时会导致工作构建神秘地失败，并出现奇怪的错误消息。

虽然开发服务器可以自动刷新您的应用程序，这在大多数情况下是有效的，但它有时会无法正确完成，并使您的应用程序处于不一致的状态，需要您重新加载页面。更糟糕的是，你可能看不到你的应用程序处于不一致的状态，并试图追踪一个不存在的错误。

有时你安装了依赖项，然后你的`yarn.lock`或`package-lock.json`莫名其妙地得到更新，你不知道为什么，所以你必须花时间找出原因。

这些都是来自我们的*工具*的真实生活复杂性的例子，甚至在我们使用任何 JavaScript 代码或 JavaScript 库之前。当然，有些事情很少发生，但还是会发生。对于库，情况甚至更糟，因为复杂性无处不在，而且它们最直接地影响着您的代码。

# 成本效益计算

不管你是否觉得这些工具和库值得拥有，无论我们从中获得什么好处，我们都要支付一笔有形的*复杂性税。*

我将“好处”定义为工具解决特定的技术问题的能力。你可能会说可能会有情感上的好处，比如对一个新的闪亮玩具的兴奋，以某种方式做某事的满足感，从美学中得到的快乐。当然，有时这些东西会提升我们对生产力的感知，尽管更多时候，它们也会分散我们的注意力。在这里，我将自己局限于解决你在*项目*中遇到的具体问题，因为我发现优先考虑情感上的好处与我认为的软件工程师的工作有些矛盾。

在这里，我不打算详细介绍这些工具和库提供的所有好处，因为这是特定于项目和个人的。我只打算谈一谈人们普遍声称的这些工具的三个好处:易用性、有助于管理复杂性和雇佣能力。

易用性，我定义为“用很少的努力你就可以使用对你有益的东西”，在我看来，不是一个工具固有的特征。事情有多容易是由你的技能和过去的经验、习惯等决定的。即使你使用一个工具来使事情变得更容易，但只有当你知道如何使用工具时，它才是有效的。为了给你一种工具本身很容易的错觉，工具制造商让它们[看起来]更熟悉*——他们使工具适应他们认为你应该已经知道的东西，有时是以对它应该解决的问题的较差适应为代价。如果他们正确地判断了你之前的经历，你就不需要太多的努力就能开始。这就是通常所说的“像手套一样合身”(也就是说，只要你有 5 个手指，而不是 25 个)。*

*JSX 语法就是这样一个例子。如果你熟悉 HTML，你会发现 JSX 从第一天起就更容易使用(我们错误地称之为“容易上手”)。但是，如果我们不了解 HTML，JSX 就像 HTML 本身*加上*JavaScript 表达式的插值、React 中的小偏差一样“容易上手”(例如，臭名昭著的`className` vs `class`，或者像`ref`这样的非标准属性)。从技术上讲，JSX 既不“容易”也不“难”使用。这完全取决于你问谁。*

*有人说不应该低估熟悉度。但是你必须问自己:熟悉是你在项目中遇到的技术问题吗？但我们假设，为了便于论证，熟悉度是一个技术问题。例如，您可能会认为不熟悉会影响开发人员的入职，因此会花费您组织的资金。但是你也需要问自己:一个专门为解决熟悉性而写的抽象对于我的项目来说是一个足够的*抽象吗？这种抽象的代价是什么？回到 JSX 的例子:它需要一个构建步骤。这是有代价的。另一个例子是，您需要某种方法来获取 refs 以访问底层元素。那也是成本。诸如此类。当你把使用 JSX 的所有成本加起来，是不是比让人们熟悉你可以使用的东西(比如，嗯…普通的 HTML)的成本要少？**

*对我来说，用工具管理复杂性是一个自我实现的预言。当然，有些工具很简单，但大多数并不简单。但是大多数工具都有多重功能。例如，Webpack 编译、捆绑、解析模块、重写模块路径等。在它的典型应用中，它甚至可以作为 web 服务器，并提供一个 web 套接字来接收更新和自动重新加载页面。它是一只野兽。React 管理状态*和*执行 DOM 操作。借用里奇·希基喜欢用的一个术语，他们将多个事物“完成”成不可分割的整体。这就是复杂性的定义。像`grep`和`sed`这样的简单工具只做一件非常简单的事情，可以通过使用它们之间非常简单的接口将它们组合起来，构建更复杂的东西。*

*一些工具会将它们自身的复杂性泄漏到您的代码中。例如，React 是一个声明式框架。如果您试图集成一些命令性的东西(例如，音频回放)，那么您必须编写适配器代码，将状态变化转换为命令性命令。所述适配器基本上是一个*工具*，您必须拿出它来管理 React 应用程序编码风格和本机 DOM API(或您可能使用的任何非声明性 API)编码风格之间的差异所引入的复杂性。如果你使用 Redux，你需要一个工具来适应它的反应。如果你使用 MobX，你需要另一个工具。如果 React 也是必需的，那么您就不需要那些适配器了。(这一观察与关于声明式风格是否优越的讨论是正交的。)所以“管理复杂性”在这个意义上意味着处理由给定问题的工具*的错误选择所导致的复杂性。这就是为什么我说这是一个自我实现的预言:管理复杂性的工具创造了它自己的复杂性，这反过来又需要一个工具来管理新的复杂性。**

*说到自我实现的预言，雇佣能力是另一个。人们使用流行的工具，因为他们相信这将使雇佣开发人员变得更容易。因此，有更多的工作与这些工具相关。因此，越来越多的人试图学习这些工具来获得这些工作。因此，人们认为如果他们使用流行的工具，招聘会更容易。这是一个恶性循环。*

*但问题是。如果你曾经和那些刚刚开始 web 开发的人交谈过，你会知道他们学习的第一件事不是工具。它是 HTML、CSS、JavaScript 和 DOM API——也称为香草 JS。没错。不管他们以后继续学习什么样的框架，他们都是从香草开始的。如果你真正关心的是找到人的能力，也许你应该使用 Vanilla，因为更多的开发人员比任何单独的框架都了解 Vanilla？*

# *香草的好处*

*因此，带着这些想法，我用香草重写了我的一个项目。*

*该项目由两个应用程序和一个服务器组成，花了大约 5 天时间完成。我能够重用 React 版本中的一些 CSS 和一部分 JavaScript 代码，因为我已经在框架之外编写了很多东西。我不得不重写更多的代码，因为我必须处理声明式命令式的范式转换。*

*有很多方法可以编写普通的应用程序。你可以想多疯狂就多疯狂，或者想多简单就多简单。一切都取决于你。我不会骗你，我现在的技术不是我自己想出来的。在工作中向一个精明的队友借了很多。然而，一旦你经历了，就再也回不去了。正如另一位队友所说，“感觉更真实。”*

*但你不是来看一些哲学漫谈的(哈哈，来不及了！).你是来看事实的。*

*在我的一个应用中，我的*未统一的*代码和一个缩小的库(我仍然必须使用库)的捆绑包大小已经减少了 651Kb。从 788Kb 减少到 137Kb，减少了近六倍。这两个版本的应用程序的功能和外观基本相同，只是在一些地方修复了一些错误，并没有增加重要的功能。*

*总体来说，我自己的代码更少了。我在项目中有两个应用程序。在基于 React 的代码中，我自己的代码有 3650 行，而在普通版本中，只有 2064 行(少了 43%)。这意味着像 React 这样的库占了整个包大小减少的大部分。这是创建旧包时所有的树摇动和缩小，而除了预先缩小的库之外，没有为新的代码库做任何事情！*

*在普通版本中，我自己的代码在*中的总大小只有 12Kb，所以甚至不值得缩减。我不再需要为我自己的代码生成源地图，因为我不会以任何方式修改它。调试器输出与物理文件一对一匹配，无需额外成本。这是我没有被迫去解决一个根本不存在的问题的例子之一。**

*更重要的是，现在只有 9 个 JavaScript 文件，而以前有 60 个。事实证明，代码组织也是一种*工具*，就像任何工具一样，它具有导致复杂性的潜力。移除大部分模块结构会导致移除所有类型的代码和样板文件，并且还允许一些简化代码整体流程的模式(我将在后续的帖子中详细介绍)。*

*代码不同部分的接近性使得调用栈更浅。特别是在缺少库的情况下，我发现我遇到的大多数回溯只是两三次调用，大多数时候我只需查看一下回溯，就能知道问题可能出在哪里。这为我节省了很多调试时间。*

*当我使用浏览器提供的 API 编码时，我会根据 API 的设计来选择自己代码的风格。这消除了对从一种风格转换到另一种风格的适配器代码的需求，并从整体上简化了代码。*

*当然，减少代码库并不是唯一的目标。例如，反应式状态管理可能会进一步减少代码库的大小，但随之而来的是，我也失去了流程的明确性，这使得调试更加困难。我之前说过，做这些决定的时候一定要有成本收益的计算。*

# *下一步…*

*本系列的下一篇文章将为普通的 JavaScript 项目设置提供一些指导。*

# *你想全职从事普通的 JavaScript 工作吗？*

*如果你想加入一个遵循上述原则的团队，你可能会有兴趣了解到 [Coin Metrics](https://coinmetrics.io/) 正在[雇佣](https://boards.greenhouse.io/coinmetrics/jobs/4031704004)(普通)JavaScript 开发人员加入他们的前端工程团队。*

**更多内容请看**[***说白了。*** *报名参加我们的*](http://plainenglish.io/) [***免费每周简讯这里***](http://newsletter.plainenglish.io/) ***。*****