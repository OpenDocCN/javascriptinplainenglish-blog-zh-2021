<html>
<head>
<title>A Guide to Asynchronous Array Iterator Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步数组迭代器函数指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-guide-to-asynchronous-array-iterator-functions-b90d58b119e3?source=collection_archive---------9-----------------------#2021-03-23">https://javascript.plainenglish.io/a-guide-to-asynchronous-array-iterator-functions-b90d58b119e3?source=collection_archive---------9-----------------------#2021-03-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="68ba" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">对于映射、减少、过滤、每一个和一些</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d7ec803b211bbe828d1ed4277c92b5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h5LDEPstXEsV7O8m"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ac26" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="026b" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">JavaScript的内置数组<code class="fe mh mi mj mk b">map</code>、<code class="fe mh mi mj mk b">reduce</code>、<code class="fe mh mi mj mk b">filter</code>、<code class="fe mh mi mj mk b">every</code>和<code class="fe mh mi mj mk b">some</code>迭代器函数是我的第二天性。但是最近，我需要构建一些需要异步回调函数的功能。让我们看看如何实现这一点。</p><h1 id="1a14" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">地图</h1><p id="71de" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe mh mi mj mk b">map</code>遍历数组，使用提供的回调函数计算每个元素的结果，并返回一个新的结果数组。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="8d68" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].map(i =&gt; i * 2);<br/>// [2, 4, 6]</span></pre><p id="ff0b" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">如果所提供的函数返回一个承诺，那么<code class="fe mh mi mj mk b">map</code>将不会解析这个承诺。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="4eb6" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].map(async i =&gt; i * 2);<br/>// [Promise, Promise, Promise]</span></pre><p id="f83c" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">但是解决这个问题非常简单。Promise提供了一个内置的<code class="fe mh mi mj mk b">Promise.all</code>函数，该函数将解析一个数组中的所有承诺——这正是我们期望从<code class="fe mh mi mj mk b">map</code>得到的输出。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="d5a4" class="mp ku in mk b gy mq mr l ms mt">await Promise.all([1, 2, 3].map(async i =&gt; i * 2));<br/>// [2, 4, 6]</span></pre><h1 id="3a58" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">减少</h1><p id="f9b5" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe mh mi mj mk b">reduce</code>遍历数组，并根据提供的回调缩减器函数聚合一个值。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="e836" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].map((acc, i) =&gt; acc + i, 0)<br/>// 6</span></pre><p id="43da" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">如果提供的函数返回一个承诺，<code class="fe mh mi mj mk b">reduce</code>将出错。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="1182" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].reduce(async (acc, i) =&gt; {<br/>  return acc + i;<br/>}, 0);<br/>// Error</span></pre><p id="2f3a" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">为什么？因为<code class="fe mh mi mj mk b">acc</code>是前一次迭代的响应，所以它本身就是一个承诺——并且您不能在一个承诺上聚合。在聚集之前，您需要首先解决<code class="fe mh mi mj mk b">acc</code>。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="36df" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].reduce(async (acc, i) =&gt; {<br/>  return (await acc) + i;<br/>}, 0);<br/>// 6</span></pre><h1 id="0602" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">过滤器</h1><p id="89f5" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe mh mi mj mk b">filter</code>遍历数组并返回一个新数组，该数组只包含通过回调测试函数的元素。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="4f99" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].filter(i =&gt; i &lt; 3);<br/>// [1, 2]</span></pre><p id="96e9" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">如果提供的过滤函数返回一个承诺，<code class="fe mh mi mj mk b">filter</code>将不会像预期的那样工作，而是返回整个数组。这是因为异步函数返回一个承诺，但是过滤器函数不解析该承诺。相反，它直接使用promise，其计算结果为<code class="fe mh mi mj mk b">true</code>，导致过滤函数在结果中包含该元素。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="4437" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].filter(async i =&gt; i &lt; 3);<br/>// [1, 2, 3]</span></pre><p id="497c" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">不幸的是，过滤器不支持承诺，但您可以使用<code class="fe mh mi mj mk b">map</code>间接获得结果。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="91c3" class="mp ku in mk b gy mq mr l ms mt">const array = [1, 2, 3];<br/>const mapResult = await Promise.all(array.map(async i =&gt; i &lt; 3));<br/>array.filter((_, idx) =&gt; mapResult[idx]);<br/>// [1, 2]</span></pre><p id="b701" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">首先，使用在之前<a class="ae ks" href="#1a14" rel="noopener ugc nofollow">提到的异步<code class="fe mh mi mj mk b">map</code>方法，我们计算元素是否通过过滤功能测试，并解析所有的承诺。这会产生一个布尔数组，然后可以用它来确定原始数组中的哪些元素应该包含在结果中。</a></p><h1 id="c87d" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">每一/一些</h1><p id="c7b9" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe mh mi mj mk b">every</code>检查数组中的所有元素是否通过了提供的回调测试函数，<code class="fe mh mi mj mk b">some</code>检查数组中至少有一个元素通过了测试。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="b3ba" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].every(i =&gt; i &lt; 3);<br/>// false</span><span id="45cb" class="mp ku in mk b gy mz mr l ms mt">[1, 2, 3].some(i =&gt; i &lt; 3);<br/>// true</span></pre><p id="3aea" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">就像<code class="fe mh mi mj mk b">filter</code>一样，如果提供的测试函数返回一个承诺，<code class="fe mh mi mj mk b">every</code>和<code class="fe mh mi mj mk b">some</code>就不会像预期的那样工作。相反，他们将总是返回<code class="fe mh mi mj mk b">true</code>，因为未解决的承诺将评估为<code class="fe mh mi mj mk b">true</code>。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="745d" class="mp ku in mk b gy mq mr l ms mt">[1, 2, 3].every(async i =&gt; i &lt; 3);<br/>// true</span><span id="283b" class="mp ku in mk b gy mz mr l ms mt">[1, 2, 3].some(async i =&gt; i &lt; 3);<br/>// true</span></pre><p id="1ed3" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">解决方案类似于<code class="fe mh mi mj mk b">filter</code>的解决方案——通过使用异步<code class="fe mh mi mj mk b">map</code>来评估测试并遍历结果。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="b18d" class="mp ku in mk b gy mq mr l ms mt">const array = [1, 2, 3];<br/>const mapResult = await Promise.all(array.map(async i =&gt; i &lt; 3));<br/>array.every((_, idx) =&gt; mapResult[idx]);<br/>// false</span><span id="f707" class="mp ku in mk b gy mz mr l ms mt">array.some((_, idx) =&gt; mapResult[idx]);<br/>// true</span></pre><p id="f5cf" class="pw-post-body-paragraph ll lm in ln b lo mu jo lq lr mv jr lt lu mw lw lx ly mx ma mb mc my me mf mg ig bi translated">这种方法的缺点是迭代中的每个元素都将被解析。一旦第一个<code class="fe mh mi mj mk b">false</code>和<code class="fe mh mi mj mk b">true</code>结果分别被计算，则<code class="fe mh mi mj mk b">every</code>和<code class="fe mh mi mj mk b">some</code>可以短路并立即存在，从而节省计算时间。为了匹配这种行为，您必须遍历数组，并使用常规的<code class="fe mh mi mj mk b">for</code>循环一次运行一个测试函数。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="cef7" class="mp ku in mk b gy mq mr l ms mt">const asyncFunction = async i =&gt; i &lt; 3;</span><span id="c0d3" class="mp ku in mk b gy mz mr l ms mt">let everyResult = true;<br/>for (let i of [1, 2, 3]) {<br/>  if (!(await asyncFunction(i))) {<br/>    everyResult = false;<br/>    break;<br/>  }<br/>}<br/>// everyResult = false</span><span id="e744" class="mp ku in mk b gy mz mr l ms mt">let someResult = false;<br/>for (let i of [1, 2, 3]) {<br/>  if (await asyncFunction(i)) {<br/>    someResult = true;<br/>    break;<br/>  }<br/>}<br/>// someResult = true</span></pre></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="1ba5" class="kt ku in bd kv kw nh ky kz la ni lc ld jt nj ju lf jw nk jx lh jz nl ka lj lk bi translated">最后的想法</h1><p id="8a0c" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe mh mi mj mk b">map</code>、<code class="fe mh mi mj mk b">reduce</code>、<code class="fe mh mi mj mk b">filter</code>、<code class="fe mh mi mj mk b">every</code>和<code class="fe mh mi mj mk b">some</code>都可以处理异步回调函数，只需要稍微调整一下。虽然这里没有涉及，但是其他内置数组方法，如<code class="fe mh mi mj mk b">find</code>、<code class="fe mh mi mj mk b">findIndex</code>、<code class="fe mh mi mj mk b">forEach</code>和<code class="fe mh mi mj mk b">reduceRight</code>也可以使用相同的方法处理异步回调函数。你能想出怎么做吗？</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="2f59" class="kt ku in bd kv kw nh ky kz la ni lc ld jt nj ju lf jw nk jx lh jz nl ka lj lk bi translated">资源</h1><ul class=""><li id="1732" class="nm nn in ln b lo lp lr ls lu no ly np mc nq mg nr ns nt nu bi translated"><code class="fe mh mi mj mk b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">Array.map </a></code>T23】文献</li><li id="a9df" class="nm nn in ln b lo nv lr nw lu nx ly ny mc nz mg nr ns nt nu bi translated"><code class="fe mh mi mj mk b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">Array.reduce</a></code> <a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="a4db" class="nm nn in ln b lo nv lr nw lu nx ly ny mc nz mg nr ns nt nu bi translated"><code class="fe mh mi mj mk b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">Array.filter</a></code> <a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="3bc9" class="nm nn in ln b lo nv lr nw lu nx ly ny mc nz mg nr ns nt nu bi translated"><code class="fe mh mi mj mk b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank">Array.some</a></code> <a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="4150" class="nm nn in ln b lo nv lr nw lu nx ly ny mc nz mg nr ns nt nu bi translated"><code class="fe mh mi mj mk b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank">Array.every</a></code>T7】文档</li></ul></div></div>    
</body>
</html>