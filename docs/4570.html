<html>
<head>
<title>HTTP Request Methods: A Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP请求方法:完全指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/http-request-methods-complete-guide-cced531a42b7?source=collection_archive---------0-----------------------#2021-09-12">https://javascript.plainenglish.io/http-request-methods-complete-guide-cced531a42b7?source=collection_archive---------0-----------------------#2021-09-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9eaa" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">获取、发布、上传、修补、删除、标题、选项和跟踪</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/fb4d361a87f3135e13fdd88efaa5644d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*bqTWyL7IFU4Z4xL0y4Su6A.jpeg"/></div></figure><h1 id="404b" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">得到</h1><ul class=""><li id="c3c0" class="lc ld in le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><code class="fe lu lv lw lx b">GET</code>请求是API和网站中最常见、最广泛使用的方法。简单地说，GET方法用于<strong class="le io">从指定资源</strong>的服务器检索数据。例如，假设您有一个带有<code class="fe lu lv lw lx b">/users</code>端点的API。向该端点发出GET请求应该会返回所有可用用户的列表。</li><li id="a660" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">由于GET请求只是请求数据而不修改任何资源，所以它被认为是一个<strong class="le io">安全</strong>和<strong class="le io">幂等方法</strong>。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/404105ffb926b708274cf1f1bbed1d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_LuqZ3-qhm3yaR9ht5GrA.png"/></div></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="565e" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">邮政</h1><ul class=""><li id="3d95" class="lc ld in le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在web服务中，<code class="fe lu lv lw lx b">POST</code>请求用于<strong class="le io">向API服务器</strong>发送数据以创建或更新资源。发送到服务器的数据存储在HTTP请求的请求体中。</li><li id="2304" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">当一个新的资源被发布到服务器时，API服务将通过给它分配一个ID(新资源URI)来自动关联新资源。简而言之，这个方法用于创建一个新的数据条目。</li><li id="eaa9" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">最简单的例子就是网站上的联系方式。当您在表单中填写输入并点击<em class="mk">发送</em>时，数据被放入请求的<strong class="le io">响应体</strong>并发送到服务器。这可能是JSON、XML或查询参数(还有很多其他格式，但这些是最常见的)。</li><li id="0a8e" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">值得注意的是，一个<code class="fe lu lv lw lx b">POST</code>请求是<strong class="le io">非幂等</strong>。它改变后端服务器上的数据(通过创建或更新资源)，而不是不改变任何数据的<code class="fe lu lv lw lx b">GET</code>请求。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ml"><img src="../Images/60b69f034370c5458356db2c440a2704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLD2lZ6BPliuEx6EXH9qlQ.png"/></div></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mm"><img src="../Images/1e3f509af14cae3d70dc6e681ad0d756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gw9JdPZx1PgpkpkY9npiw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Comparison between GET and POST</figcaption></figure><h1 id="5cf9" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">放</h1><ul class=""><li id="b757" class="lc ld in le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">与POST类似，<code class="fe lu lv lw lx b">PUT</code>请求用于向API发送数据，以<strong class="le io">更新或创建资源</strong>。不同之处在于<strong class="le io"> PUT请求是幂等的</strong>。也就是说，多次调用相同的PUT请求<strong class="le io">将总是产生相同的结果</strong>。相反，重复调用POST请求会产生多次创建相同资源的副作用。</li><li id="9654" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">一般来说，当<code class="fe lu lv lw lx b">PUT</code>请求<em class="mk">创建</em>资源时，服务器会用<code class="fe lu lv lw lx b">201</code> ( <code class="fe lu lv lw lx b">Created</code>)进行响应，如果请求<em class="mk">修改了</em>现有资源，服务器会返回<code class="fe lu lv lw lx b">200</code> ( <code class="fe lu lv lw lx b">OK</code>)或<code class="fe lu lv lw lx b">204</code> ( <code class="fe lu lv lw lx b">No Content</code>)。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mr"><img src="../Images/abcda171a1a3b6b9ee78120b041d72d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HylQs8MOD_LXv2UM8WYIg.png"/></div></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ms"><img src="../Images/7836345bb900b66a894569bef99136b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6aodcxbM9uhj0ZtHPMQKw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Comparison between PUT and POST</figcaption></figure><h1 id="e0d7" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">修补</h1><ul class=""><li id="ef66" class="lc ld in le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><code class="fe lu lv lw lx b">PATCH</code>请求是一种鲜为人知的HTTP方法，但它类似于POST和PUT。与<code class="fe lu lv lw lx b">PATCH</code>的区别在于<strong class="le io">只对资源</strong>进行部分修改。</li><li id="a2e7" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">补丁和上传的区别在于<strong class="le io">补丁请求不是等幂的</strong>(类似于POST请求)。</li><li id="7b4c" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">为了扩展部分修改，假设你的API有一个<code class="fe lu lv lw lx b">/users/{{userid}}</code>端点，一个用户有一个<em class="mk">用户名</em>。对于补丁请求，<strong class="le io">您可能只需要在请求正文中发送更新后的用户名</strong>——而不是POST和PUT，后者需要完整的用户实体。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mt"><img src="../Images/20f4dfbad0c964c0cd24e41fe2820aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cg4HBni1AaPZo7C9u-pCWw.png"/></div></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f10e" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">正如您在这里看到的，请求与PUT请求非常相似，但是请求体只包含需要更改的资源的属性</p><h1 id="0924" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">删除</h1><ul class=""><li id="c3e1" class="lc ld in le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><code class="fe lu lv lw lx b">DELETE</code>方法顾名思义:<strong class="le io">删除指定URL处的资源</strong>。这个方法是RESTful APIs中比较常见的方法之一，所以了解它的工作原理是很有好处的。</li><li id="b2eb" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">如果一个新用户是通过对<code class="fe lu lv lw lx b">/users</code>的POST请求创建的，并且可以通过对<code class="fe lu lv lw lx b">/users/{{userid}}</code>的<code class="fe lu lv lw lx b">GET</code>请求来检索，那么对<code class="fe lu lv lw lx b">/users/{{userid}}</code>的<code class="fe lu lv lw lx b">DELETE</code>请求将完全删除那个用户。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nj"><img src="../Images/d0ccfa487b1985730a212264415a8bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRf3QbJktW0aqhDu8ibyPA.png"/></div></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="bee8" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">头</h1><ul class=""><li id="29d7" class="lc ld in le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">除了没有响应体之外，<code class="fe lu lv lw lx b">HEAD</code>方法几乎与<code class="fe lu lv lw lx b">GET</code>、<strong class="le io">相同。换句话说，如果<code class="fe lu lv lw lx b">GET /users</code>返回一个用户列表，那么<code class="fe lu lv lw lx b">HEAD /users</code>将发出同样的请求，但不会返回用户列表。</strong></li><li id="b5f7" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">HEAD请求<strong class="le io">对于在实际发出GET请求之前检查GET请求将返回什么</strong>很有用。例如，如果一个URL可能会产生大量的下载，那么一个<code class="fe lu lv lw lx b">HEAD</code>请求可以读取它的<code class="fe lu lv lw lx b"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length" rel="noopener ugc nofollow" target="_blank">Content-Length</a></code>头来检查文件大小，而不需要实际下载文件。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nl"><img src="../Images/5a18cb1659044c0f1e715acbf9f8534e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExGvkz2VK8nE4kpDSwV4kQ.png"/></div></div></figure><p id="dbca" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">以下示例演示了如何向有关用户的查询发送HTTP HEAD请求:</p><pre class="kd ke kf kg gt nm lx nn no aw np bi"><span id="445a" class="nq kl in lx b gy nr ns l nt nu">HEAD /users HTTP 1.1<br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)<br/>Host: medium.com<br/>Accept-Language: en-us<br/>Accept-Encoding: gzip, deflate<br/>Connection: Keep-Alive</span></pre><p id="f8d4" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">响应包含与GET方法相同的。</p><pre class="kd ke kf kg gt nm lx nn no aw np bi"><span id="d7b3" class="nq kl in lx b gy nr ns l nt nu">HTTP/1.1 200 OK<br/>Date: <!-- -->Mon, 23 Sept 2021 12:28:53 GMT<br/>Server: Apache/2.2.14 (Win32)<br/>Last-Modified: Wed, 22 Jul 2021 19:15:56 GMT<br/>ETag: "34aa387-d-1568eb00"<br/>Vary: Authorization,Accept<br/>Accept-Ranges: bytes<br/>Content-Length: 88<br/>Content-Type: application/json<br/>Connection: Closed</span></pre><h1 id="6981" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">选择</h1><ul class=""><li id="39b5" class="lc ld in le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">HTTP <code class="fe lu lv lw lx b">OPTIONS</code>方法为给定的URL或服务器请求允许的通信选项。客户端可以用这个方法指定一个URL，或者用一个星号(<code class="fe lu lv lw lx b">*</code>)来指代整个服务器。OPTIONS请求应该<strong class="le io">返回数据，描述在给定的URL上服务器支持什么<em class="mk">其他</em>方法和操作</strong>。</li><li id="ba0b" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">OPTIONS请求的定义和使用比其他请求更宽松，这使它们成为测试致命API错误的良好候选对象。如果一个API不期望一个选项请求，那么最好放置一个测试用例来验证失败的行为。</li><li id="4e8d" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">在<a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>中，使用<code class="fe lu lv lw lx b">OPTIONS</code>方法发送一个<a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request" rel="noopener ugc nofollow" target="_blank">预检请求</a>，以便服务器可以响应是否可以发送该请求。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nv"><img src="../Images/ebd30e741b01312730869842d118c4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ExIrp6-JLMzpgWb2ZumvA.png"/></div></div></figure><p id="29ca" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">以下示例请求运行在medium.com上的web服务器支持的方法列表:</p><pre class="kd ke kf kg gt nm lx nn no aw np bi"><span id="a46c" class="nq kl in lx b gy nr ns l nt nu">OPTIONS * HTTP/1.1<br/>Host: <!-- -->medium.com<br/>Origin: <a class="ae nk" href="https://medium.com/" rel="noopener">https://medium.com/</a></span></pre><p id="82a7" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">服务器的响应是:</p><pre class="kd ke kf kg gt nm lx nn no aw np bi"><span id="8177" class="nq kl in lx b gy nr ns l nt nu">HTTP/1.1 200 OK<br/>Allow: GET,POST,PUT,PATCH,DELETE,HEAD,OPTIONS<br/>Access-Control-Allow-Origin: <!-- -->https://medium.com/<br/>Access-Control-Allow-Methods: GET,POST,PUT,PATCH,DELETE,HEAD,OPTIONS<br/>Access-Control-Allow-Headers: Content-Type</span></pre><h2 id="a9df" class="nq kl in bd km nw nx dn kq ny nz dp ku lj oa ob kw ll oc od ky ln oe of la og bi translated">找到；查出</h2><ul class=""><li id="becc" class="lc ld in le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="le io"> HTTP </strong> <code class="fe lu lv lw lx b"><strong class="le io">TRACE</strong></code> <strong class="le io">方法</strong>设计用于诊断目的。它沿着到目标资源的路径执行消息环回测试，提供了一个有用的调试机制。</li><li id="d287" class="lc ld in le b lf ly lh lz lj ma ll mb ln mc lp lq lr ls lt bi translated">请求的最终接收者应该将收到的消息(不包括下面描述的一些字段)作为带有<code class="fe lu lv lw lx b">message/http</code>的<code class="fe lu lv lw lx b"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type" rel="noopener ugc nofollow" target="_blank">Content-Type</a></code>的<code class="fe lu lv lw lx b"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200" rel="noopener ugc nofollow" target="_blank">200</a></code> ( <code class="fe lu lv lw lx b">OK</code>)响应的消息体返回给客户端。最终接收者要么是源服务器，要么是在请求中接收到0的<code class="fe lu lv lw lx b"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards" rel="noopener ugc nofollow" target="_blank">Max-Forwards</a></code>值的第一个服务器。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nj"><img src="../Images/dab2de47e633c53a5adc9448372ae6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsupC1AJVvpjy9xZojuuVg.png"/></div></div></figure><p id="71cf" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">以下示例显示了TRACE方法的用法:</p><pre class="kd ke kf kg gt nm lx nn no aw np bi"><span id="bfa1" class="nq kl in lx b gy nr ns l nt nu">TRACE / HTTP/1.1<br/>Host: www.<!-- -->medium.com<br/>User-Agent: <!-- -->Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span></pre><p id="a435" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">对于上面的客户机请求，服务器响应被发送回来。</p><pre class="kd ke kf kg gt nm lx nn no aw np bi"><span id="6275" class="nq kl in lx b gy nr ns l nt nu">HTTP/1.1 200 OK<br/>Date: Mon, 23 Sept 2021 12:28:53 GMT<br/>Server: Apache/2.2.14 (Win32)<br/>Connection: close<br/>Content-Type: message/http<br/>Content-Length: 39</span><span id="8fa9" class="nq kl in lx b gy oh ns l nt nu">TRACE / HTTP/1.1<br/>Host: www.<!-- -->medium.com<br/>User-Agent: <!-- -->Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)</span></pre><h1 id="623c" class="kk kl in bd km kn ko kp kq kr ks kt ku jt kv ju kw jw kx jx ky jz kz ka la lb bi translated">结论</h1><p id="f630" class="pw-post-body-paragraph mu mv in le b lf lg jo mx lh li jr mz lj oi nb nc ll oj ne nf ln ok nh ni lp ig bi translated">在本指南中，我们已经了解了八种主要的HTTP请求方法。它们中的每一个都实现了不同的语义，但是它们之间有一些共同的特性:例如，请求方法可以是安全的、幂等的或者可缓存的。</p><blockquote class="ol"><p id="f146" class="om on in bd oo op oq or os ot ou lp dk translated">安全方法:<code class="fe lu lv lw lx b">GET</code>、<code class="fe lu lv lw lx b">HEAD</code>、<code class="fe lu lv lw lx b">OPTIONS, TRACE</code></p><p id="b356" class="om on in bd oo op oq or os ot ou lp dk translated">等幂方法:<code class="fe lu lv lw lx b">GET</code>、<code class="fe lu lv lw lx b">PUT</code>、<code class="fe lu lv lw lx b">DELETE</code>、<code class="fe lu lv lw lx b">HEAD,OPTIONS</code>、<code class="fe lu lv lw lx b">TRACE</code></p><p id="4512" class="om on in bd oo op oq or os ot ou lp dk translated">可缓存的方法:<code class="fe lu lv lw lx b">GET, HEAD</code></p></blockquote><p id="8c06" class="pw-post-body-paragraph mu mv in le b lf ov jo mx lh ow jr mz lj ox nb nc ll oy ne nf ln oz nh ni lp ig bi translated">如果指示了新鲜度并且设置了<code class="fe lu lv lw lx b">Content-Location</code>头，对<code class="fe lu lv lw lx b">POST</code>或<code class="fe lu lv lw lx b">PATCH</code>请求的响应也可以被缓存，但是这很少被实现。</p><p id="7f7e" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">我们对GET和POST以及PUT和POST进行了比较。有了这些知识，我希望您能够建设性地使用HTTP方法。</p><p id="f8d7" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated">一如既往，感谢阅读。如果你喜欢这篇文章，请分享它，看看我在Medium 上的其他文章。</p><p id="a37a" class="pw-post-body-paragraph mu mv in le b lf mw jo mx lh my jr mz lj na nb nc ll nd ne nf ln ng nh ni lp ig bi translated"><em class="mk">更多内容看</em><strong class="le io"><em class="mk"/></strong><a class="ae nk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="le io"><em class="mk">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>