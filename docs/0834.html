<html>
<head>
<title>Secure React SPA using Keycloak with OpenID Connect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有OpenID Connect的Keycloak保护React SPA</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/secure-react-spa-using-keycloak-with-openid-connect-a25e2ad51743?source=collection_archive---------1-----------------------#2021-02-21">https://javascript.plainenglish.io/secure-react-spa-using-keycloak-with-openid-connect-a25e2ad51743?source=collection_archive---------1-----------------------#2021-02-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="04a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据我之前的帖子<strong class="jm io"> " </strong> <a class="ae ki" href="https://js.plainenglish.io/secure-react-spa-using-azure-endpoints-with-authorization-code-flow-847f47f972d" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Secure React SPA使用Azure端点和授权代码流</strong> </a> <strong class="jm io"> " </strong>，我意识到用您的应用程序配置多个提供者需要大量的编码和配置，特别是当您想要坚持所有提供者的授权代码流时。虽然Azure，谷歌在某种程度上支持跨来源请求，但另一方面脸书严格地不支持它。(因此，我们需要创建一个代理服务器来修改CORS策略，以便接受您的请求)。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b299a98dd86afb1ff0fc4199053ad85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bMlcAcZkL3NOns3qs-u_A.jpeg"/></div></div></figure><h1 id="0708" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">1.介绍</h1><p id="24ef" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">感谢<a class="ae ki" href="https://en.wikipedia.org/wiki/WildFly" rel="noopener ugc nofollow" target="_blank"> WildFly </a>开发者社区开发了一个开源项目<a class="ae ki" href="https://www.keycloak.org/" rel="noopener ugc nofollow" target="_blank"> Keycloak </a>。"<strong class="jm io"> Keycloak </strong>是一款开源软件产品，允许<a class="ae ki" href="https://en.wikipedia.org/wiki/Single_sign-on" rel="noopener ugc nofollow" target="_blank">使用<a class="ae ki" href="https://en.wikipedia.org/wiki/Identity_and_Access_Management" rel="noopener ugc nofollow" target="_blank">身份和访问管理</a>进行单点登录</a>，旨在实现现代应用和服务"如维基百科所述。你所需要做的就是保持Keycloak应用服务器在一台机器上运行，不管它是在同一个域还是跨域都没有关系。在这篇文章中，我们将学习运行一个Keycloak服务器，一个React SPA将与它集成。</p><h1 id="e9c6" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">2.工作演示</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/1398489c180f464443884023a8812b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*tHkMjhTSNKZOEqnw5WmE-Q.gif"/></div></figure><h1 id="fad1" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">3.键盘锁设置和配置</h1><p id="4de0" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我使用Linux安装的VirtualBox来运行Keycloak。我还在Nginx服务器后面保留了Keycloak，用于反向代理、负载平衡之类的东西。为了运行Keycloak，我使用docker hub的Docker镜像<a class="ae ki" href="https://hub.docker.com/r/jboss/keycloak/" rel="noopener ugc nofollow" target="_blank"> jboss/keycloak </a>。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="adf7" class="me kw in ma b gy mf mg l mh mi"><strong class="ma io">For http it uses port 8080,</strong></span><span id="57db" class="me kw in ma b gy mj mg l mh mi">docker run --detach -p 8080:8080 -e KEYCLOAK_USER=admin -e KEYCLOAK_PASSWORD=admin docker.io/jboss/keycloak</span><span id="f8d1" class="me kw in ma b gy mj mg l mh mi"><strong class="ma io">For https it uses port 8443,</strong></span><span id="7015" class="me kw in ma b gy mj mg l mh mi">docker run --detach -p 8443:8443 -e KEYCLOAK_USER=admin -e KEYCLOAK_PASSWORD=admin docker.io/jboss/keycloak</span></pre><p id="8ea7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将为您创建一个帐户以及<strong class="jm io">管理员</strong>用户名和<strong class="jm io">管理员</strong>密码，您可以通过更改参数KEYCLOAK_USER= &lt; &gt;和KEYCLOAK_PASSWORD= &lt; &gt;的值来更改用户名和密码。</p><p id="a296" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在Nginx中，我已经为反向代理做了这些配置，</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="048c" class="me kw in ma b gy mf mg l mh mi">location /auth/ {<br/>                    proxy_set_header Host $http_host;<br/>                    proxy_set_header X-Real-IP $remote_addr;<br/>                    proxy_set_header X-Scheme $scheme;<br/>                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>                    proxy_set_header X-Forwarded-Proto $scheme;<br/>                    #proxy_redirect    off;<br/>                    add_header Pragma "no-cache";<br/>                    add_header Cache-Control "no-cache";<br/>                    proxy_pass <a class="ae ki" href="https://localhost:8443/auth/" rel="noopener ugc nofollow" target="_blank">https://localhost:8443/auth/</a>;<br/>                    sub_filter_once off;<br/>        }</span></pre><p id="89e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我使用https，所以我们需要SSL证书，现在我使用自签名证书，你可以从<a class="ae ki" href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-on-centos-7" rel="noopener ugc nofollow" target="_blank">这里</a>配置它。</p><p id="8358" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是在Keycloak应用服务器上运行一个管理帐户。现在，我们将进行提供商配置。以下是实现这一目标的步骤，</p><ul class=""><li id="1769" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">通过单击“添加领域”创建一个领域，然后填写领域名称。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mt"><img src="../Images/a38639574bed90b8fcc6c15fa76f958d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Msq-JbxsR80a1oOWvZUHuw.png"/></div></div></figure><ul class=""><li id="b425" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">一旦您创建了领域，您就可以在这里为您的领域创建一个客户端，</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mu"><img src="../Images/416109719e4f672d10848661191e3b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*370BeQrbjZqm_Y1JO3dwIw.png"/></div></div></figure><ul class=""><li id="c624" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">填写客户编号，您的React应用程序将进一步使用该编号。保持客户端协议为<strong class="jm io"> openid-connect </strong>。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mv"><img src="../Images/8c3b96421115cf8bb8bf222bab40a113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ru028RC8_Hf4uoanK8M1uA.png"/></div></div></figure><ul class=""><li id="4cb7" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">创建一个客户端后，您需要为该特定客户端填写如下所示的特定详细信息。专注于突出显示的字段。<strong class="jm io">访问类型</strong>，这需要是公共的，因为我们是为公共客户端进行这种配置的。<strong class="jm io">有效重定向URIs </strong>，这是您的应用程序中的uri，在从Keycloak成功进行身份验证后，您希望在其中接收令牌。<strong class="jm io"> Web Origins </strong>，在此字段中提及URL将使您能够在Keycloak应用服务器上搜索CORS，因此您不会获得任何与CORS相关的问题。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mw"><img src="../Images/5f0882ebcb302cd0a82ec2cb5772fdf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ur6A13U-fUXms28R6S3uig.png"/></div></div></figure><ul class=""><li id="a3e9" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">最后但也是最重要的配置，在下面相同的客户端配置页面的<strong class="jm io">高级设置</strong>下，您需要指定您的客户端用来在代码验证器上创建代码质询的方法。根据<a class="ae ki" href="https://tools.ietf.org/html/rfc7636#section-4.2" rel="noopener ugc nofollow" target="_blank"> PKEC RFC </a>的规定，该值应为“sha256”，如果客户(React SPA)能够使用该值，则该值也可以为“普通”。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mx"><img src="../Images/a86877075164148aba43b5196771f1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3JwY3Mf-WdloN7wCxI7RA.png"/></div></div></figure><p id="7795" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">恭喜你！！您已经成功配置了Keycloak应用服务器，使其像身份验证服务器一样正常工作。</p><h1 id="99a6" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">4.React SPA的源代码和配置</h1><p id="a7ba" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我有一个代码样本准备好了这个工作演示，如上图所示。克隆repo并安装node_modules</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="0130" class="me kw in ma b gy mf mg l mh mi">git clone <a class="ae ki" href="https://github.com/surya5954/LoginAs.git" rel="noopener ugc nofollow" target="_blank">https://github.com/surya5954/LoginAs.git</a><br/>cd LoginAs<br/>npm install</span></pre><p id="3478" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打开。您编辑器中env文件，并更新下面提到字段，</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="02b0" class="me kw in ma b gy mf mg l mh mi">REACT_APP_KEYCLOAK_ID=&lt;Client ID from Keycloak admin portal&gt;</span></pre><p id="39a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在回到我们的应用程序，让我们开始理解这个魔术背后的逻辑，</p><h2 id="0727" class="me kw in bd kx my mz dn lb na nb dp lf jv nc nd lj jz ne nf ln kd ng nh lr ni bi translated">PKCE相关配置，</h2><p id="bce8" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><strong class="jm io"> CODE_VERIFIER : </strong>按照<a class="ae ki" href="https://tools.ietf.org/html/rfc7636#section-4.1" rel="noopener ugc nofollow" target="_blank"> PKCE RFC </a>的规定，这需要是最少43位长度的URL-Safe随机字符串，使用未预留的字符[A-Z]/[A-Z]/[0-9]/-/。/ "_" / "~".</p><p id="84cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> CODE_CHALLENGE_METHOD : </strong>根据<a class="ae ki" href="https://tools.ietf.org/html/rfc7636#section-4.2" rel="noopener ugc nofollow" target="_blank"> PKEC RFC </a>的规定，该字段应为“sha256”，如果客户能够使用该字段，则该字段也可以为“普通”。</p><p id="525e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> CODE_CHALLENGE : </strong>对于“sha256”，它应该是代码验证器的Base64 URL编码的SHA-256哈希。</p><p id="f8ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> &lt;回购路径&gt;/loginas/src/config/pckeconfigs . js中，</strong></p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="2f25" class="me kw in ma b gy mf mg l mh mi">import crypto from 'crypto';</span><span id="e3e1" class="me kw in ma b gy mj mg l mh mi">// Some random 64 bit long string<br/>export const CODE_VERIFIER = 'AdleUo9ZVcn0J7HkXOdzeqN6pWrW36K3JgVRwMW8BBQazEPV3kFnHyWIZi2jt9gA';</span><span id="db35" class="me kw in ma b gy mj mg l mh mi">export const CODE_CHALLENGE_METHOD = 'S256';<br/>const base64URLEncode = (str) =&gt; {<br/>    return str.toString('base64')<br/>        .replace(/\+/g, '-')<br/>        .replace(/\//g, '_')<br/>        .replace(/=/g, '');<br/>}<br/>const getCodeChallange = (verifier) =&gt; {<br/>    return base64URLEncode(crypto.createHash('sha256')<br/>            .update(verifier).digest());<br/>}<br/>export const CODE_CHALLENGE = getCodeChallange(CODE_VERIFIER);</span></pre><p id="b3b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码生成了我们正在讨论的动态秘密，并帮助您的客户端应用程序成为Keycloak身份验证服务器眼中的合法客户端，以获取access_token。</p><h2 id="f2ff" class="me kw in bd kx my mz dn lb na nb dp lf jv nc nd lj jz ne nf ln kd ng nh lr ni bi translated">授权端点配置，</h2><p id="fa06" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">现在，我们来看看如何用PKCE构建您的授权端点调用以获得响应代码，</p><p id="0aed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> &lt;回购路径&gt;/loginas/src/container/AuthEndpointSetup/key cloak . js中，</strong></p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="2736" class="me kw in ma b gy mf mg l mh mi">const Keycloak = () =&gt; {<br/>    return queryString.stringifyUrl({<br/>        url: `<a class="ae ki" href="http://192.168.37.2/auth/realms/todo/protocol/openid-connect/auth`" rel="noopener ugc nofollow" target="_blank">http://&lt;Keycloak server hostname&gt;/auth/realms/todo/protocol/openid-connect/auth`</a>,<br/>        query: {<br/>            client_id: KEYCLOAK_ID,<br/>            redirect_uri: REDIRECT_URI,<br/>            response_type: 'code',<br/>            scope: [<br/>                'openid',<br/>                'profile',<br/>            ].join(" "),<br/>            state: JSON.stringify({ provider: 'Keycloak' }),<br/>            code_challenge: CODE_CHALLENGE,<br/>            code_challenge_method: CODE_CHALLENGE_METHOD<br/>        }<br/>    });<br/>}</span></pre><h2 id="c618" class="me kw in bd kx my mz dn lb na nb dp lf jv nc nd lj jz ne nf ln kd ng nh lr ni bi translated">从URL获取代码，</h2><p id="b5e1" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">接下来，我们需要从URL获取代码细节来构造对令牌端点的调用，</p><p id="f1ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> &lt;回购路径&gt;/loginas/src/container/Layout/Layout . js</strong>中，</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="2325" class="me kw in ma b gy mf mg l mh mi">componentDidMount() {<br/>        const [code_param] = /((\?|\&amp;)code\=)[^\&amp;]+/.exec(this.props.location.search) || [];<br/>        const [state_param] = /((\?|\&amp;)state\=)[^\&amp;]+/.exec(this.props.location.search) || [];<br/>        if (code_param != null) <br/>            let code = decodeURIComponent(code_param.replace(/(\?|\&amp;)?code\=/, ''));<br/>            let state = decodeURIComponent(state_param.replace(/(\?|\&amp;)?state\=/, ''));<br/>            const provider = JSON.parse(state).provider;<br/>            console.log(provider + "===&gt; " + code);<br/>            this.setState({ enableProgressBar: true })<br/>            const token = window.localStorage.getItem('token');<br/>            console.log(token);<br/>            if (token == null) {<br/>                this.getAccessTokenFromCode(provider, code);<br/>            } else {<br/>                this.props.history.push('/welcome/user');<br/>            }</span><span id="8dc8" class="me kw in ma b gy mj mg l mh mi">         }<br/>}</span></pre><h2 id="147d" class="me kw in bd kx my mz dn lb na nb dp lf jv nc nd lj jz ne nf ln kd ng nh lr ni bi translated">令牌端点配置，</h2><p id="7d23" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">既然我们已经从URL获得了代码，现在需要构造令牌端点URL，这是一个post调用，</p><p id="e2ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">的&lt;回购路径&gt;/loginas/src/container/TokenEndpointSetup/keycloaktoken . js中，</strong></p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="5626" class="me kw in ma b gy mf mg l mh mi">const KeycloakToken = async (code) =&gt; {<br/>    let params = {<br/>        client_id: KEYCLOAK_ID,<br/>        code: code,<br/>        grant_type: 'authorization_code',<br/>        redirect_uri: REDIRECT_URI,<br/>        code_verifier: CODE_VERIFIER,<br/>        state: JSON.stringify({ provider: 'Keycloak' }),<br/>    }</span><span id="6dfe" class="me kw in ma b gy mj mg l mh mi">const post_data = queryString.stringify(params);<br/>    let parsedUrl = URL.parse(`<a class="ae ki" href="http://192.168.37.2/auth/realms/todo/protocol/openid-connect/token`" rel="noopener ugc nofollow" target="_blank">http://&lt;Keycloak server Hostname&gt;/auth/realms/todo/protocol/openid-connect/token`</a>, true);</span><span id="c6fa" class="me kw in ma b gy mj mg l mh mi">let realHeaders = {};<br/>    realHeaders['Host'] = parsedUrl.host;<br/>    realHeaders["Content-Length"] = post_data.length;<br/>    realHeaders["Content-Type"] = 'application/x-www-form-urlencoded';</span><span id="0fe1" class="me kw in ma b gy mj mg l mh mi">const options = {<br/>        host: parsedUrl.hostname,<br/>        port: parsedUrl.port,<br/>        path: parsedUrl.pathname,<br/>        method: "POST",<br/>        headers: realHeaders<br/>    };</span><span id="18d4" class="me kw in ma b gy mj mg l mh mi">const payload = Object.assign({<br/>        body: post_data<br/>    }, options);<br/>    let response = await fetch(`<a class="ae ki" href="http://192.168.37.2/auth/realms/todo/protocol/openid-connect/token`" rel="noopener ugc nofollow" target="_blank">http://</a><a class="ae ki" href="http://192.168.37.2/auth/realms/todo/protocol/openid-connect/token`" rel="noopener ugc nofollow" target="_blank">&lt;Keycloak server Hostname&gt;</a><a class="ae ki" href="http://192.168.37.2/auth/realms/todo/protocol/openid-connect/token`" rel="noopener ugc nofollow" target="_blank">/auth/realms/todo/protocol/openid-connect/token`</a>, payload);</span><span id="97f0" class="me kw in ma b gy mj mg l mh mi">let res = await response.json();<br/>return res.access_token;</span><span id="f8d0" class="me kw in ma b gy mj mg l mh mi">}</span></pre><p id="02ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在这个post调用中，我们将那个64位长的随机字符串作为<strong class="jm io"> <em class="nj"> code_verifier </em> </strong>连同我们从URL获取的代码一起传递。</p><p id="6462" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦你有了access_token，你也会像，</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/381497448d94812057e0916489d28503.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*xp-hMnpbMODxNEPqwLaygg.gif"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk">Yay !! I have got the token</figcaption></figure><h2 id="9b60" class="me kw in bd kx my mz dn lb na nb dp lf jv nc nd lj jz ne nf ln kd ng nh lr ni bi translated">获取用户详细信息，</h2><p id="7cca" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">现在你需要做的就是像老板一样坐下来询问用户的详细信息，下面是我用来获取用户姓名和电子邮件详细信息的代码片段。虽然本例中的access_token是一个JWT令牌，所以您也可以从该令牌中获得一些关于用户的有限细节，但是我已经调用了一个userinfo API来获得一些用户细节，</p><p id="b469" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> &lt;回购路径&gt;/loginas/src/container/user details/key cloakuser . js中，</strong></p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="181f" class="me kw in ma b gy mf mg l mh mi">const KeycloakUser = async (token) =&gt; {<br/>    let userProvider;<br/>    const res = await fetch(`<a class="ae ki" href="http://192.168.37.2/auth/realms/todo/protocol/openid-connect/userinfo`" rel="noopener ugc nofollow" target="_blank">http://&lt;Keycloak server Hostname&gt;/auth/realms/todo/protocol/openid-connect/userinfo`</a>, {<br/>        method: 'get',<br/>        headers: {<br/>            Authorization: `Bearer ${token}`,<br/>        }<br/>    })<br/>    const res_obj = await res.json();<br/>    if (res_obj.sub) {<br/>        userProvider = {<br/>            name: res_obj.name,<br/>            email: res_obj.email,</span><span id="4597" class="me kw in ma b gy mj mg l mh mi">}<br/>    }<br/>    return userProvider;<br/>}</span></pre><h2 id="1930" class="me kw in bd kx my mz dn lb na nb dp lf jv nc nd lj jz ne nf ln kd ng nh lr ni bi translated">结论</h2><p id="e8ef" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">这就是直接从浏览器使用Keycloak端点进行成功身份验证所需的全部内容，不涉及后端。我希望这对您有所帮助。感谢您的阅读。</p><p id="3537" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">黑客快乐！</p></div></div>    
</body>
</html>