<html>
<head>
<title>Understanding Callback Refs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解回调引用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-callback-refs-107a21d831d7?source=collection_archive---------5-----------------------#2021-08-16">https://javascript.plainenglish.io/understanding-callback-refs-107a21d831d7?source=collection_archive---------5-----------------------#2021-08-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="89ee" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">学习反应JS</h2><div class=""/><div class=""><h2 id="2c73" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">React refs的另一种实现</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/835c0ccb86703a90d782420719512c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BsjikrXUZ1RSRa2bcGuAg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@razaanstha?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Rajan Shrestha</a> on <a class="ae lb" href="https://unsplash.com/@razaanstha?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cdb1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">React利用一个虚拟的<code class="fe ly lz ma mb b">DOM</code>来防止使用<code class="fe ly lz ma mb b">querySelectorAll()</code>或<code class="fe ly lz ma mb b">getElementById()</code>方法来强制修改特定的节点。相反，您的站点通过在<code class="fe ly lz ma mb b">state</code>中存储属性并根据需要重新呈现元素来动态响应输入。此外，对于一些需要强制修改节点的用例，引用是现成的。</p><p id="2b36" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在我之前的博客文章中，我介绍了React中refs的两个主要实现。对于类组件，ref存储为在构造函数中使用<code class="fe ly lz ma mb b">React.createRef()</code>实例化的属性。缺少自身属性的功能组件利用<code class="fe ly lz ma mb b">useRef()</code>钩子将ref存储在一个变量中。第三种也是不太常见的策略是<strong class="le ix">回调Ref </strong>。这有点奇怪，但是通过研究它们，我对React的内部工作方式有了更多的了解。</p><h1 id="1575" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">传入回调函数</h1><p id="66d2" class="pw-post-body-paragraph lc ld in le b lf mu jx lh li mv ka lk ll mw ln lo lp mx lr ls lt my lv lw lx ig bi translated">那么回调ref是如何工作的呢？<strong class="le ix">不是传递一个由</strong> <code class="fe ly lz ma mb b"><strong class="le ix">React.createRef()</strong></code> <strong class="le ix">或</strong> <code class="fe ly lz ma mb b"><strong class="le ix">useRef()</strong></code> <strong class="le ix">创建的</strong> <code class="fe ly lz ma mb b"><strong class="le ix">ref</strong></code> <strong class="le ix">，而是传递一个回调函数。这个回调函数然后接收相应的元素/节点作为参数，然后可以根据需要存储、操作或使用它。</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">A React class component utilizing a callback ref.</figcaption></figure><p id="9201" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如上所示，我们没有在构造函数中使用<code class="fe ly lz ma mb b">React.createRef()</code>，而是设置了一个名为<code class="fe ly lz ma mb b">inputRef</code>的属性，该属性最初被设置为<code class="fe ly lz ma mb b">null</code>。当组件挂载时，回调ref被执行，将所需的<code class="fe ly lz ma mb b">DOM</code>元素存储为<code class="fe ly lz ma mb b">this.inputRef</code>属性的值。</p><p id="14c0" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">注意要点:</strong></p><ul class=""><li id="065e" class="nb nc in le b lf lg li lj ll nd lp ne lt nf lx ng nh ni nj bi translated">传递给<code class="fe ly lz ma mb b">ref</code>属性的回调函数在组件挂载时立即执行。</li><li id="da21" class="nb nc in le b lf nk li nl ll nm lp nn lt no lx ng nh ni nj bi translated">存储的元素是可以通过<code class="fe ly lz ma mb b">this.inputRef</code><em class="np"><strong class="le ix">直接访问</strong>(而不是存储为</em> <code class="fe ly lz ma mb b"><em class="np">React.createRef()</em></code> <em class="np">或</em><code class="fe ly lz ma mb b"><em class="np">useRef()</em></code><em class="np"/>创建的对象的 <code class="fe ly lz ma mb b"><em class="np">.current</em></code> <em class="np">属性)。</em></li></ul><h1 id="6b9f" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">安装和卸载</h1><p id="5c8c" class="pw-post-body-paragraph lc ld in le b lf mu jx lh li mv ka lk ll mw ln lo lp mx lr ls lt my lv lw lx ig bi translated">如前所述，<strong class="le ix">当组件挂载</strong>时，任何作为ref传递的回调函数都会被执行(例如在  <em class="np"> </em> <code class="fe ly lz ma mb b">componentDidMount</code>触发之前<strong class="le ix"> <em class="np">)。在执行<code class="fe ly lz ma mb b">componentDidUpdate</code>之前，引用的元素也保证是最新的。卸载时，再次执行回调函数，这次使用<code class="fe ly lz ma mb b">null</code>而不是<code class="fe ly lz ma mb b">DOM</code>节点作为参数。</em></strong></p><h1 id="d872" class="mc md in bd me mf mg mh mi mj mk ml mm kc mn kd mo kf mp kg mq ki mr kj ms mt bi translated">用例</h1><p id="c970" class="pw-post-body-paragraph lc ld in le b lf mu jx lh li mv ka lk ll mw ln lo lp mx lr ls lt my lv lw lx ig bi translated">首先，我认为学习回调引用让我对React如何实现引用有了更好的理解。在使用<code class="fe ly lz ma mb b">createRef()</code>或<code class="fe ly lz ma mb b">useRef()</code>API时，React的解释器没有魔力。React只是利用一个回调函数将节点存储为引用对象的值<code class="fe ly lz ma mb b">.current</code>。</p><p id="740c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">就我个人而言，我只在我的一个项目中<a class="ae lb" href="https://garrett-bodley.medium.com/implementing-infinite-scroll-behavior-2dabff25901f" rel="noopener"> <strong class="le ix">实现无限滚动行为</strong> </a> <strong class="le ix"> </strong>时使用过回调引用(这启发了我更深入地研究文档并撰写本文)。你在你的项目中使用过回调引用吗？欢迎在下面的评论中分享自己的经验！</p><p id="9e1e" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="np">更多内容请看</em><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="np">plain English . io</em></a></p></div></div>    
</body>
</html>