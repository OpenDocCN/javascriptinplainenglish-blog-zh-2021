<html>
<head>
<title>React Image Loading Optimization Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React图像加载优化技术</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-image-loading-optimization-techniques-b885427bde44?source=collection_archive---------10-----------------------#2021-03-21">https://javascript.plainenglish.io/react-image-loading-optimization-techniques-b885427bde44?source=collection_archive---------10-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="580f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分:预加载，IntersectionObserver，淡入过渡，用指针事件阻止图像下载等等…</h2></div><h2 id="6b93" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">第1部分概述</h2><p id="8930" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/image-loading-in-react-js-preloading-lazy-loading-intersectionobserver-fade-in-transitions-722c24f4d5fb">第1部分</a>以创建PreloadImage组件的基本设置结束。到目前为止，该组件具有设置一个<strong class="ld ir">‘占位符’</strong>的功能，该功能将在图像加载失败时设置。除此之外，还有一个<strong class="ld ir">‘lazy’</strong>属性，它可以被设置为实例化一个组件的交集观察器，该观察器跟踪组件何时进入视口附近，并因此开始从网络加载图像。不设置lazy属性将调用<code class="fe lv lw lx ly b">setPreloader()</code>函数，该函数将在组件挂载后立即预加载图像。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/5e7de57f24ff79daeea2b42042755af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_pDFtWM3Xo_FqM6EhYDeg.jpeg"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">Persons and Videos list on the Metacules.com Home Screen</figcaption></figure><p id="7a67" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">如果你在<a class="ae lu" href="https://metacules.com" rel="noopener ugc nofollow" target="_blank">metacules.com</a>网站的主屏幕上查看人员名单，你会发现一个大约250-300人的名单。<br/>如果您正在编写代码来呈现包含图像的卡片，看起来像下面的代码，您将会遇到一些问题:</p><pre class="ma mb mc md gt mu ly mv mw aw mx bi"><span id="a2c9" class="kf kg iq ly b gy my mz l na nb">{persons &amp;&amp; persons.map(person =&gt;<br/>  &lt;div className="personCard&gt;<br/>    &lt;PreloadImage src={person.imageUrl}&gt;<br/>  &lt;/div&gt;<br/>)}</span></pre><p id="2163" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">如果你有一个300人的卡片列表，你将渲染300个div，这些div都是从网上下载图片的。可以想象，这显然对性能没有好处。</p><p id="2346" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">提高性能的一种方法是，当用户进入屏幕时，只加载在视窗中可见的图像，并将其他图像的加载设置为<strong class="ld ir"> lazy。</strong> <br/>假设你一次只能看到8张图片(过于简单),你的代码应该是这样的:</p><pre class="ma mb mc md gt mu ly mv mw aw mx bi"><span id="b974" class="kf kg iq ly b gy my mz l na nb">{persons &amp;&amp; persons.map((person, index) =&gt;<br/>  &lt;div className="personCard&gt;<br/>    &lt;PreloadImage lazy={index &gt; 8} src={person.imageUrl}&gt;<br/>  &lt;/div&gt;<br/>)}</span></pre><p id="37ed" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">然后，当您进入视图之外的所有其他组件的屏幕时，将使用交叉点观察器api来确定何时开始加载图像。</p><p id="108b" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">上面的代码仍然有点问题…因为这里有一个很大的性能问题。所以如果你还没有看到它，你一定要继续读下去；)</p><p id="3b91" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">但是让我们先来看看我想要实现的一些东西，以完成图像加载包装。</p><p id="426a" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">所以我还想实现另外两件事:</p><ol class=""><li id="80ed" class="nc nd iq ld b le mp lh mq ko ne ks nf kw ng lt nh ni nj nk bi translated">当图像加载并设置在用户界面上时，我不想有一个“硬”加载，而是一个平滑的淡入过渡。</li><li id="ad49" class="nc nd iq ld b le nl lh nm ko nn ks no kw np lt nh ni nj nk bi translated">我注意到的一件事是，在手机上，如果我长时间触摸图片，它会弹出一个窗口，就像你右击图片时弹出的窗口一样。我不想这样，因为这不是我的应用程序UI功能的一部分。</li></ol><h1 id="d505" class="nq kg iq bd kh nr ns nt kk nu nv nw kn jw nx jx kr jz ny ka kv kc nz kd kz oa bi translated">图像加载器包装组件的完整实现</h1><p id="a235" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">我的图像加载器包装器的最终实现应该是这样的:</p><pre class="ma mb mc md gt mu ly mv mw aw mx bi"><span id="8111" class="kf kg iq ly b gy my mz l na nb">class PreloadImage extends React.Component {<br/><br/>    constructor(props) {<br/>        super(props);<br/>        this.state = {<br/>            loaded: false,<br/>            src: null,<br/>            placeholder: this.props.placeholder || null,<br/>        };<br/>    }<br/><br/>    componentDidMount() {<br/>        if (this.props.lazy &amp;&amp; 'IntersectionObserver' in window) {<br/>            this.setObserver();<br/>        } else {<br/>            this.setPreloader();<br/>        }<br/>    }<br/><br/>    setObserver() {<br/>        this.observer = new IntersectionObserver((entries) =&gt; {<br/>            entries.forEach((entry) =&gt; {<br/>                if (entry.isIntersecting) {<br/>                    this.setPreloader();<br/>                    this.observer.disconnect();<br/>                }<br/>            });<br/>        });<br/><br/>        this.observer.observe(this.el);<br/>    }<br/><br/>    setPreloader() {<br/>        this.preloader = new Image();<br/><br/>        this.preloader.onload = () =&gt; {<br/>            this.setState({<br/>                loaded: true,<br/>                src: this.props.src<br/>            });<br/>        };<br/>        this.preloader.onerror = () =&gt; {<br/>            this.setState({<br/>                loaded: true,<br/>                src: this.state.placeholder<br/>            });<br/>        };<br/><br/>        this.preloader.src = this.props.src;<br/>    }<br/><br/>    componentWillUnmount() {<br/>        if (this.observer) this.observer.disconnect();<br/>        if (this.preloader) this.preloader.onload = null;<br/>    }<br/><br/>    render() {<br/>        return (<br/>            &lt;div ref={(el) =&gt; this.el = el} className= <br/>                     {this.props.wrapperClassName}&gt;<br/>                &lt;img src={this.state.src || this.state.placeholder}<br/>                     ref={(el) =&gt; this.el = el}<br/>                     onError={(e) =&gt; {<br/>                         e.target.src = this.state.placeholder;<br/>                     }}<br/>                     className={this.props.className}<br/>                     style={{<strong class="ly ir">pointerEvents</strong>: "none",<br/>                         <strong class="ly ir">opacity</strong>: this.state.loaded ? 1 : 0,<br/>                         <strong class="ly ir">transition</strong>: "opacity 300ms cubic- bezier(0.215, 0.61, 0.355, 1)",<br/>                     }}<br/>                     alt=""/&gt;<br/>            &lt;/div&gt;<br/>        );<br/>    }<br/>}<br/><br/>export default PreloadImage;</span></pre><p id="c470" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">因此，与第1部分的实现相比，有一些更新。</p><pre class="ma mb mc md gt mu ly mv mw aw mx bi"><span id="23cb" class="kf kg iq ly b gy my mz l na nb"><strong class="ly ir">pointerEvents</strong>: "none"</span></pre><p id="7ab7" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">这阻止了web上的用户通过右键单击保存图像的功能。在手机上(更重要的是UX智慧),它可以防止用户长时间触摸图像表面时出现不必要的对话框。</p><pre class="ma mb mc md gt mu ly mv mw aw mx bi"><span id="38fe" class="kf kg iq ly b gy my mz l na nb"><strong class="ly ir">opacity</strong>: this.state.loaded ? 1 : 0,                         <strong class="ly ir">transition</strong>: "opacity 300ms cubic-bezier(0.215, 0.61, 0.355, 1)",</span></pre><p id="ac32" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">这将在不透明度设置为0的卸载状态和不透明度设置为1的加载状态之间添加300毫秒的渐变过渡。</p><p id="e098" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">到目前为止，加载图像的包装类的完整实现。</p><p id="585b" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">这已经让您走了很长一段路。不幸的是，如上所述，当在大的可滚动列表中完成时，这不足以获得良好的图像加载性能。</p><p id="4889" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">如何解决这个问题，我将在第3部分讨论。</p><h1 id="22b0" class="nq kg iq bd kh nr ns nt kk nu nv nw kn jw nx jx kr jz ny ka kv kc nz kd kz oa bi translated">第3部分</h1><p id="2573" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">在下一部分中，我们将深入研究我需要考虑的事情，以确保视口外部的组件(包含这些图像)不会被预先渲染，从而降低性能。</p><p id="6cc9" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">为此，我将介绍react-window(用于水平滚动)和react-laziload(用于垂直滚动)的用法</p><p id="512a" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">链接至<a class="ae lu" href="https://rik-van-velzen.medium.com/scroll-rendering-performance-react-image-loading-optimization-techniques-17350d8f04a8" rel="noopener">第3部分</a></p><p id="3a2f" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">请跟我来，了解未来帖子的最新情况。</p><p id="efee" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">如果你有任何额外的东西要添加，改进，或者如果你想给我们的项目发送一些爱或支持，你可以购买我的咖啡或帮助基金筹集我们创建的元规则——审查的解毒剂——平台通过</p><ul class=""><li id="c7d9" class="nc nd iq ld b le mp lh mq ko ne ks nf kw ng lt ob ni nj nk bi translated"><a class="ae lu" href="https://www.buymeacoffee.com/l5LnQfk" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/l5LnQfk</a></li><li id="457f" class="nc nd iq ld b le nl lh nm ko nn ks no kw np lt ob ni nj nk bi translated"><a class="ae lu" href="https://fundrazr.com/f1ldl3" rel="noopener ugc nofollow" target="_blank">https://fundrazr.com/f1ldl3</a></li></ul><p id="0eb9" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated"><em class="oc"> Rik van Velzen是metacules的创始人，他是一名资深(Android)移动开发人员，目前是使用reactor/NodeJs的元模块平台的开发人员。<br/>您可以在社交媒体上关注我们:</em></p><p id="a3b0" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated"><em class="oc">-</em>-<a class="ae lu" href="https://twitter.com/VelzenRik" rel="noopener ugc nofollow" target="_blank">https://twitter.com/VelzenRik</a>-<br/>-<em class="oc">推特</em>:<a class="ae lu" href="https://twitter.com/metacules" rel="noopener ugc nofollow" target="_blank">https://twitter.com/metacules</a>-<em class="oc">脸书</em>:<a class="ae lu" href="https://www.facebook.com/Metaculescom-100856938688500" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/Metaculescom-100856938688500</a></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi od"><img src="../Images/46a42164fab34b6434f2049893a5045c.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*ys44JYrg9npYsCNq"/></div></figure><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/78b5a714ebb8f30bfba5c18229ccbdb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WtqnY7DQU4QproQc.jpeg"/></div></div></figure><p id="f714" class="pw-post-body-paragraph lb lc iq ld b le mp jr lg lh mq ju lj ko mr ll lm ks ms lo lp kw mt lr ls lt ij bi translated">metacules.com登陆页面截图</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="0582" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">来源:</h2><ul class=""><li id="a0a8" class="nc nd iq ld b le lf lh li ko om ks on kw oo lt ob ni nj nk bi translated"><a class="ae lu" href="https://levelup.gitconnected.com/what-is-so-special-about-intersection-observer-api-in-javascript-f2430a159fa7" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/interface-observer-API-in-JavaScript-f 2430 a 159 fa 7</a></li><li id="1afb" class="nc nd iq ld b le nl lh nm ko nn ks no kw np lt ob ni nj nk bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/image-loading-in-react-js-preloading-lazy-loading-intersectionobserver-fade-in-transitions-722c24f4d5fb">https://JavaScript . plain English . io/image-loading-in-react-js-preloading-lazy-loading-intersection observer-fade-in-transitions-722 c24 F4 D5 FB</a></li><li id="9a12" class="nc nd iq ld b le nl lh nm ko nn ks no kw np lt ob ni nj nk bi translated">https://react-window.now.sh/#/examples/list/fixed-size<a class="ae lu" href="https://react-window.now.sh/#/examples/list/fixed-size" rel="noopener ugc nofollow" target="_blank"/></li><li id="e326" class="nc nd iq ld b le nl lh nm ko nn ks no kw np lt ob ni nj nk bi translated">【https://www.npmjs.com/package/react-window T4】</li><li id="1ac7" class="nc nd iq ld b le nl lh nm ko nn ks no kw np lt ob ni nj nk bi translated">https://metacules.com~创造审查的解药</li><li id="4837" class="nc nd iq ld b le nl lh nm ko nn ks no kw np lt ob ni nj nk bi translated"><a class="ae lu" href="https://fundrazr.com/f1ldl3" rel="noopener ugc nofollow" target="_blank">https://fundrazr.com/f1ldl3</a></li></ul></div></div>    
</body>
</html>