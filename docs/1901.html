<html>
<head>
<title>How to Send Encrypted Data with Postman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Postman发送加密数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-send-encrypted-data-with-postman-6d5a052e21f5?source=collection_archive---------1-----------------------#2021-04-21">https://javascript.plainenglish.io/how-to-send-encrypted-data-with-postman-6d5a052e21f5?source=collection_archive---------1-----------------------#2021-04-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c374" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用crypto-js加密数据，用内置的Node.js加密模块解密。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8d78eb08ba16efa75161173ff320e67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HuUx469rYp7_BPh1"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@bundo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bundo Kim</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="158f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">必备:</em></strong><em class="lp">JavaScript、Node.js知识，以及</em> <a class="ae ks" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">邮差</em> </a>基础知识</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="fab5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最近，我开始与一个项目的后端交互，该项目只接受<a class="ae ks" href="https://en.wikipedia.org/wiki/Encryption" rel="noopener ugc nofollow" target="_blank">加密的</a>dat——也就是说，明文在被发送到后端之前被转换成<a class="ae ks" href="https://en.wikipedia.org/wiki/Ciphertext" rel="noopener ugc nofollow" target="_blank">密文</a>。在后端，密文被解密回明文。后端是用Java写的，所以我考虑了如何用Node.js来完成这个。</p><p id="0091" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于我以前没有做过这样的事情，我不得不做一些研究，看看这是如何做到的。一旦我发现了我要找的东西，我就必须检验我的发现。在不创建前端的情况下测试API的最快方法是使用<a class="ae ks" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Postman </a>。</p><blockquote class="lx ly lz"><p id="d61f" class="kt ku lp kv b kw kx jo ky kz la jr lb ma ld le lf mb lh li lj mc ll lm ln lo ig bi translated">根据<a class="ae ks" href="https://www.blazemeter.com/blog/how-use-postman-manage-and-execute-your-apis" rel="noopener ugc nofollow" target="_blank"> BlazeMeter </a> <strong class="kv io">的说法，Postman </strong>是一个流行的API客户端，可以让开发者轻松创建、共享、测试和记录API。这是通过允许用户创建和保存简单和复杂的HTTP/s请求，以及读取它们的响应来实现的。结果是，工作效率更高，更简单。</p></blockquote><p id="8903" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">即使我有使用Postman的经验，我也不知道如何在发出请求之前加密数据。因此，我开始了另一轮研究，并在Postman上发现了一个名为<strong class="kv io">预请求脚本的标签。</strong>顾名思义，这是一个在发送请求之前运行的脚本。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi md"><img src="../Images/53cdacd005e5843367d8f79705f3646c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q36jN3F-2E-Z0iDSIs8FVg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Orange underlined tab</figcaption></figure><p id="d522" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，Postman预装了一些流行的JavaScript包，这些包可以在处理数据的预请求脚本中使用。其中一个包是<a class="ae ks" href="https://cryptojs.gitbook.io/docs/#ciphers" rel="noopener ugc nofollow" target="_blank"> crypto-js </a>，我们将使用它来加密请求前脚本中的数据。现在让我们看看如何在下面的代码中使用<a class="ae ks" href="https://cryptojs.gitbook.io/docs/#ciphers" rel="noopener ugc nofollow" target="_blank">crypto-js</a>T26】AES规范加密数据:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Pre-request Script encryption code</figcaption></figure><p id="5df3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我想你已经让邮递员开门了。因此，导航到<strong class="kv io">预请求脚本</strong>选项卡，将上述代码复制粘贴到其中。现在，让我们单步执行代码。</p><p id="7a5a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们只需要<code class="fe mg mh mi mj b">line 1</code>上的<code class="fe mg mh mi mj b">crypto-js</code>,因为包裹存在于Postman上。对于AES(默认为AES256)加密，我们需要32字节(256位)的<code class="fe mg mh mi mj b">key</code>和16字节(128位)的<code class="fe mg mh mi mj b">iv</code>，因此在<code class="fe mg mh mi mj b">line 4</code>上，我们生成16个随机字节作为<code class="fe mg mh mi mj b">IV(Initialization Vector)</code>。</p><blockquote class="lx ly lz"><p id="bb4c" class="kt ku lp kv b kw kx jo ky kz la jr lb ma ld le lf mb lh li lj mc ll lm ln lo ig bi translated"><em class="in">初始化向量应该是不可预测的和唯一的，通常要求是随机的或伪随机的— </em> <a class="ae ks" href="https://nodejs.org/en/knowledge/cryptography/how-to-use-crypto-module/#ciphers" rel="noopener ugc nofollow" target="_blank"> <em class="in">密码</em> </a></p></blockquote><p id="db08" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe mg mh mi mj b">line 8</code>上，我们找到密钥字符串的sha-256散列，这返回32个字节(256位)用作<code class="fe mg mh mi mj b">key</code>。现在我们有了<code class="fe mg mh mi mj b">key</code>和<code class="fe mg mh mi mj b">iv</code>，我们进入<code class="fe mg mh mi mj b">encrypt</code>函数。在<code class="fe mg mh mi mj b">line 11</code>上，我们首先用<code class="fe mg mh mi mj b">JSON.stringify</code>将数据(它将是一个对象)转换成一个字符串，然后我们将结果字符串转换成一个<a class="ae ks" href="https://www.davidebarranca.com/2012/10/crypto-js-tutorial-cryptography-for-dummies/#word-array-and-encodings" rel="noopener ugc nofollow" target="_blank">字数组</a>，这样<code class="fe mg mh mi mj b">AES.encrypt</code>方法将能够处理它。</p><p id="795c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从<code class="fe mg mh mi mj b">line 12</code>到<code class="fe mg mh mi mj b">14</code>，我们将<code class="fe mg mh mi mj b">key</code>、<code class="fe mg mh mi mj b">iv</code>和<code class="fe mg mh mi mj b">val</code>(现在是一个字数组)传入AES加密方法，最后将其转换为base64，这样就完成了<code class="fe mg mh mi mj b">encrypt</code>函数的声明。</p><p id="6873" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，是我们使用<code class="fe mg mh mi mj b">encrypt</code>函数的时候了，这就是我们在<code class="fe mg mh mi mj b">line 20</code>上所做的，<code class="fe mg mh mi mj b">line 17</code>上的JSON数据将是我们的原始请求数据，作为参数传递给<code class="fe mg mh mi mj b">encrypt</code>函数，产生的base 64字符串被设置在名为<code class="fe mg mh mi mj b">“encrypted”</code>的<a class="ae ks" href="https://learning.postman.com/docs/sending-requests/variables/" rel="noopener ugc nofollow" target="_blank"> Postman局部变量</a>中。此外，<code class="fe mg mh mi mj b">IV</code>(初始化向量)必须被传递到后端，这就是我们在<code class="fe mg mh mi mj b">line 21</code>，<code class="fe mg mh mi mj b">IV</code>上所做的，被转换成一个字符串，然后被设置到另一个名为<code class="fe mg mh mi mj b">“IV”</code>的Postman局部变量上。</p><p id="0b2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们将完成我们的预请求脚本。现在让我们看看如何在请求体中使用两个Postman局部变量(“encrypted”和“IV”)。</p><p id="a1f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们切换到Postman上的<code class="fe mg mh mi mj b">body</code>选项卡，将数据格式设置为JSON。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mk"><img src="../Images/324077d7aca3ab817ced352400acdee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auk8MpSxIMSVirZQXknogw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">body tab on postman</figcaption></figure><p id="86ce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我们添加一个请求体，并从我们的预请求脚本中访问Postman局部变量，方法是将变量名用双花括号括起来，就像这样<code class="fe mg mh mi mj b"><em class="lp">{{variable_name}}</em></code>。在我们的预请求脚本中有两个局部变量(“encrypted”和“IV”)。下面让我们看看如何访问它们。</p><pre class="kd ke kf kg gt ml mj mm mn aw mo bi"><span id="c6d3" class="mp mq in mj b gy mr ms l mt mu">{</span><span id="517e" class="mp mq in mj b gy mv ms l mt mu">   "encrypted": "<em class="lp">{{encrypted}}</em>",</span><span id="6b59" class="mp mq in mj b gy mv ms l mt mu">   "IV": "<em class="lp">{{IV}}</em>"</span><span id="fd1a" class="mp mq in mj b gy mv ms l mt mu">}</span></pre><p id="335e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的代码中，我们通过用双花括号(<code class="fe mg mh mi mj b"><em class="lp">{{encrypted}}</em></code> <em class="lp"> ) </em>将<code class="fe mg mh mi mj b">“encrypted”</code>局部变量值括起来，然后将其设置为名为“encrypted”的JSON键(JSON键可以随意命名)来访问它。本地变量<code class="fe mg mh mi mj b">“IV”</code>也是如此。现在我们准备好从Postman发送加密数据，但是我们没有后端来接收它。让我们解决这个问题。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mf l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Node decryption code</figcaption></figure><p id="d75e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的Node.js后端已经设置在CodeSandbox上。现在让我们看看那边发生了什么。</p><p id="4db8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将使用内置的Node.js <code class="fe mg mh mi mj b">crypto</code>模块进行解密，使用<code class="fe mg mh mi mj b">express</code>模块处理HTTP请求。我们的下一个关注点是解密处理程序，我们<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring" rel="noopener ugc nofollow" target="_blank">析构</a>请求体(<code class="fe mg mh mi mj b">req.body</code>)并从中取出“加密”和“IV”密钥。接下来，我们找到变量“keyString”的sha256散列(与Postman上使用的keyString相同)，这相当于我们在Postman的预请求脚本上使用crypto-js所做的，但是在这种情况下，我们得到一个32字节的缓冲区作为<code class="fe mg mh mi mj b">key</code>，这个缓冲的密钥然后被用作<code class="fe mg mh mi mj b">crypto.createDecipheriv()</code>方法中的<a class="ae ks" href="https://en.wikipedia.org/wiki/Key_(cryptography)" rel="noopener ugc nofollow" target="_blank">加密密钥</a>。</p><p id="92b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们将<code class="fe mg mh mi mj b">IV</code>和<code class="fe mg mh mi mj b">encrypted</code>数据转换到一个缓冲区，并将它们传递到各自的方法中，然后运行解密。你可以在这里阅读解密是如何工作的<a class="ae ks" href="https://nodejs.org/en/knowledge/cryptography/how-to-use-crypto-module/#ciphers" rel="noopener ugc nofollow" target="_blank">。现在，我们要做的最后一件事是在返回响应之前向对象添加一个额外的属性，以验证请求在后端得到了解密。</a></p><p id="468c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们需要一种从Postman连接到CodeSandbox的方法，这将通过CodeSandbox的浏览器URL来完成。在我的例子中，它是<code class="fe mg mh mi mj b">https://m98ph.sse.codesandbox.io</code>，然后解密处理程序的路径名是<code class="fe mg mh mi mj b">/decrypt</code>，这意味着在Postman上使用的最终URL将是<code class="fe mg mh mi mj b">https://m98ph.sse.codesandbox.io/decrypt</code>。现在，邮递员应该看起来像这样。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/0742a8b343bc364d0c43c2e1ea272ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENQXK7RNElBWBmD9h2OIFA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">postman pointing at codesandbox</figcaption></figure><p id="7c88" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在剩下的就是发送一个<strong class="kv io"> POST </strong>请求，我们应该会得到类似这样的响应。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1c7e4267d3a7e6faf714e22c0aa3bb39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*8lXPg-BJRvtEI71PftAm5g.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Decryption response</figcaption></figure><p id="0929" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">万岁！我们已经成功地加密了数据，将它发送到服务器，解密它，处理它，并发回响应。希望你能得到类似这样的回答。如果没有，你可以回溯，看看你可能错过了什么。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="f0b8" class="mp mq in bd mz na nb dn nc nd ne dp nf lc ng nh ni lg nj nk nl lk nm nn no np bi translated">摘要</h2><p id="614c" class="pw-post-body-paragraph kt ku in kv b kw nq jo ky kz nr jr lb lc ns le lf lg nt li lj lk nu lm ln lo ig bi translated">总之，我们看到了如何在Postman上创建一个<code class="fe mg mh mi mj b">Pre-request Script</code>,如何为Postman局部变量设置值，以及如何在请求体上利用局部变量。我们还学习了如何在客户端用<code class="fe mg mh mi mj b">crypto-js</code>加密，在服务器端用Node.js <code class="fe mg mh mi mj b">crypto</code>模块解密。</p><p id="2d4a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，我们看到了如何将CodeSandbox用作服务器端主机，如果你问我，我会觉得这很棒。</p><h2 id="0f7a" class="mp mq in bd mz na nb dn nc nd ne dp nf lc ng nh ni lg nj nk nl lk nm nn no np bi translated">参考和有用的链接</h2><ul class=""><li id="4982" class="nv nw in kv b kw nq kz nr lc nx lg ny lk nz lo oa ob oc od bi translated"><strong class="kv io">如何使用加密模块</strong>——<a class="ae ks" href="https://nodejs.org/en/knowledge/cryptography/how-to-use-crypto-module" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/en/knowledge/cryptography/How-to-use-crypto-module</a></li><li id="7437" class="nv nw in kv b kw oe kz of lc og lg oh lk oi lo oa ob oc od bi translated"><strong class="kv io"> Crypto-js教程</strong>—<a class="ae ks" href="https://www.davidebarranca.com/2012/10/crypto-js-tutorial-cryptography-for-dummies/#word-array-and-encodings" rel="noopener ugc nofollow" target="_blank">https://www . davidebarranca . com/2012/10/Crypto-js-Tutorial-cryptography-for-dummies</a></li><li id="88fa" class="nv nw in kv b kw oe kz of lc og lg oh lk oi lo oa ob oc od bi translated"><strong class="kv io">如何使用Postman</strong>—<a class="ae ks" href="https://www.blazemeter.com/blog/how-use-postman-manage-and-execute-your-apis" rel="noopener ugc nofollow" target="_blank">https://www . blaze meter . com/blog/How-use-Postman-manage-and-execute-your-API</a></li><li id="e03f" class="nv nw in kv b kw oe kz of lc og lg oh lk oi lo oa ob oc od bi translated"><strong class="kv io">使用邮递员变量</strong>—<a class="ae ks" href="https://learning.postman.com/docs/sending-requests/variables/" rel="noopener ugc nofollow" target="_blank">https://learning . Postman . com/docs/sending-requests/variables/</a></li></ul><p id="d3f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">附言——</em></strong><em class="lp">请不要犹豫，在下面留下您的问题和建议。你也可以通过</em><a class="ae ks" href="https://twitter.com/baystizzle" rel="noopener ugc nofollow" target="_blank"><em class="lp">Twitter</em></a><em class="lp">联系我，如果你想亲自问我或者联系我。</em></p><p id="3083" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读！</p><p id="4139" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>