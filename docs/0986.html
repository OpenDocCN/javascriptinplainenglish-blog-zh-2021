<html>
<head>
<title>Clean APIs in React with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用类型脚本清除React中的API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-cleaner-api-for-react-ts-components-47d0704a508c?source=collection_archive---------1-----------------------#2021-03-02">https://javascript.plainenglish.io/a-cleaner-api-for-react-ts-components-47d0704a508c?source=collection_archive---------1-----------------------#2021-03-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/35981b38f715829892e54b3f6eba66c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tSW6AxNWNhUJcULK"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@dannyhowe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Danny Howe</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e970" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章能对如何利用TypeScript构建更好的React组件有所启发。这篇文章是致力于建立关注隐私的人工智能画廊<a class="ae jz" href="https://taggr.ai/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"/></a>的成果。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="45a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在构建<a class="ae jz" href="https://taggr.ai/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> taggr </strong> </a> <strong class="kc io">，</strong>的时候，我更深入地研究了TypeScript，到目前为止，我很喜欢在编译时注释类型和捕捉错误的新增功能，而不是在运行时关闭。</p><p id="7351" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">起初，注释每个组件和功能可能会让人感到畏惧和额外的工作，但是随着代码库的规模和复杂性的增长，好处开始显现。</p><p id="b776" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正确地输入组件和业务逻辑代码，可以为领域的实体保留唯一的真实来源，从而最大限度地减少跨应用程序层的人为错误。</p><p id="8dad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，可以从<a class="ae jz" href="https://github.com/drwpow/openapi-typescript" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>、<a class="ae jz" href="https://graphql-code-generator.com/docs/plugins/typescript" rel="noopener ugc nofollow" target="_blank"> GraphQL模式</a> …中自动生成类型脚本定义，这是一个双赢的局面🎉</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="07c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在构建React组件时，我尽量保持它们的API尽可能紧密和干净。🧹💨</p><p id="bee9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">边界清晰的组件易于重用、扩展，而且总体来说很好使用。</p><p id="d805" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们分析一个具体的例子，说明如何使用TypeScript来实现更简洁的组件API，好吗？</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="8ce6" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">不要从组件中</strong> <em class="md">暴露</em> <code class="fe me mf mg mh b"><em class="md">Prop</em></code> <em class="md">类型😧</em></h1><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b13b" class="mq lg in mh b gy mr ms l mt mu">// paragraph.tsx<br/>export type Props = {<br/>  text: string; <br/>}</span><span id="86cf" class="mq lg in mh b gy mv ms l mt mu">const Paragraph = ({text}: Props) =&gt; &lt;p&gt;{text}&lt;/p&gt;</span><span id="d9b4" class="mq lg in mh b gy mv ms l mt mu">// title.tsx<br/>// Title is now tightly coupled to paragraph.txs &gt; Props<br/>import {Props} from './paragraph' </span><span id="df3c" class="mq lg in mh b gy mv ms l mt mu">const Title = ({text}: Props) =&gt; &lt;h1&gt;{text}&lt;/h1&gt;</span></pre><h2 id="08ef" class="mq lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">为什么这样不好？</h2><ul class=""><li id="5c47" class="nh ni in kc b kd nj kh nk kl nl kp nm kt nn kx no np nq nr bi translated">当直接公开<strong class="kc io">道具</strong>类型时，没有什么能阻止其他开发者(甚至是你未来的自己😂)在应用程序的其他部分导入和扩展这些类型。这会破坏组件的封装，并在组件之间创建不必要的依赖关系。</li><li id="a09a" class="nh ni in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">对原始组件的属性类型的更改可能会破坏应用程序的其他部分💥</li><li id="919f" class="nh ni in kc b kd ns kh nt kl nu kp nv kt nw kx no np nq nr bi translated">一个混乱的API，模块导出组件和类型。这可以很快变成组件文件导出多种类型，所以要小心🧐</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="df80" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">更好的方法✅</h1><p id="98ca" class="pw-post-body-paragraph ka kb in kc b kd nj kf kg kh nk kj kk kl nx kn ko kp ny kr ks kt nz kv kw kx ig bi translated">不要直接公开组件属性类型。<strong class="kc io">不要</strong>。</p><p id="eaf0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果想要访问另一个组件的属性，这样我就不用重新声明特定于域的类型了，该怎么办？</p><p id="a077" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">组件的<strong class="kc io">属性</strong>定义了组件与应用程序其余部分(或世界)的接口🌎).</p><p id="be59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有一个<code class="fe me mf mg mh b">UserProfile</code>组件并且<strong class="kc io">道具</strong>声明了一个<code class="fe me mf mg mh b">User</code>类型，你想在你的应用程序的其他地方使用它，它应该从<code class="fe me mf mg mh b">UserProfile</code>T10中提取出来。</p><p id="44a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将特定领域的类型提取到<code class="fe me mf mg mh b">./types</code>中，以便它们可以在整个应用程序中重用。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="729a" class="mq lg in mh b gy mr ms l mt mu">// user-types.ts<br/>export interface User {<br/> name: string,<br/> age: number;<br/>};</span><span id="593f" class="mq lg in mh b gy mv ms l mt mu">// user-profile.tsx<br/>import {User} from './user-types';</span><span id="7f21" class="mq lg in mh b gy mv ms l mt mu">type Props = {<br/> user: User,<br/> date: string, // other props<br/>};</span><span id="3aa7" class="mq lg in mh b gy mv ms l mt mu">const UserProfile = ({user, date}: Props) =&gt; ...<br/>export default UserProfile;</span><span id="4712" class="mq lg in mh b gy mv ms l mt mu">// user-list.tsx<br/>import {User} from './user-types';</span><span id="d3bc" class="mq lg in mh b gy mv ms l mt mu">type Props = {<br/> users: User[],<br/>};</span><span id="4243" class="mq lg in mh b gy mv ms l mt mu">const UserList = ({users}: Props) =&gt; ...<br/>export default UserList;</span></pre><h2 id="f1c4" class="mq lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">如果我需要从其他地方访问组件的属性，该怎么办？</h2><p id="ec3a" class="pw-post-body-paragraph ka kb in kc b kd nj kf kg kh nk kj kk kl nx kn ko kp ny kr ks kt nz kv kw kx ig bi translated">它们是想要访问组件类型的有效理由，比如用<a class="ae jz" href="https://medium.com/javascript-scene/do-react-hooks-replace-higher-order-components-hocs-7ae4a08b7b58" rel="noopener"> HOC </a> s增强组件。</p><p id="e8b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们检查下一部分来解决这个问题！</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="9c59" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">属性类型查找✨</h1><p id="55f3" class="pw-post-body-paragraph ka kb in kc b kd nj kf kg kh nk kj kk kl nx kn ko kp ny kr ks kt nz kv kw kx ig bi translated">我们可以利用TypeScript类型解析来实现正确的类型查找。</p><ol class=""><li id="3747" class="nh ni in kc b kd ke kh ki kl ob kp oc kt od kx oe np nq nr bi translated">设置属性类型查找帮助程序，“GetComponentProps ”:</li></ol><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9c43" class="mq lg in mh b gy mr ms l mt mu">// utils.ts<br/>export type GetComponentProps&lt;T&gt; = T extends<br/>| React.ComponentType&lt;infer P&gt;<br/>| React.Component&lt;infer P&gt;<br/>? P<br/>: never;</span></pre><p id="2e63" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.定义我们想要扩展的组件，<code class="fe me mf mg mh b">Title</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f8f0" class="mq lg in mh b gy mr ms l mt mu">// title.tsx<br/>type Color = "RED" | "BLUE" | "GREEN";</span><span id="0318" class="mq lg in mh b gy mv ms l mt mu">type Props = {<br/> title: string;<br/> color: Color;<br/>};</span><span id="8993" class="mq lg in mh b gy mv ms l mt mu">const Title = ({ title, color }: Props) =&gt; (<br/>  &lt;h1 style={{ color }}&gt;{title}&lt;/h1&gt;<br/>);<br/>export default Title;</span></pre><p id="5b66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.伸出<code class="fe me mf mg mh b">Title</code>组件，同时保持<strong class="kc io">全类型安全</strong>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="99fd" class="mq lg in mh b gy mr ms l mt mu">// title-wrapper.tsx<br/>import Title from './title';<br/>import {GetComponentProps} from './utils';</span><span id="a25f" class="mq lg in mh b gy mv ms l mt mu">type Props = GetComponentProps&lt;typeof Title&gt; &amp; {<br/> onClick: () =&gt; void;<br/>};</span><span id="b025" class="mq lg in mh b gy mv ms l mt mu">const TitleWrapper = ({onClick, ...rest}: Props) =&gt; (<br/>  &lt;button onClick={onClick}&gt;<br/>    &lt;Title {...rest} /&gt; <br/>  &lt;/button&gt;<br/>);<br/>export default TitleWrapper;</span><span id="bd93" class="mq lg in mh b gy mv ms l mt mu">// index.ts<br/>import TitleWrapper from 'title-wrapper';</span><span id="60d5" class="mq lg in mh b gy mv ms l mt mu">// Full type safety and autocompletion! 🎉<br/>const App = () =&gt;  (<br/> &lt;TitleWrapper<br/>  title="Hello there"<br/>  color="GREEN"<br/>  onClick={() =&gt; window.alert("title pressed")} <br/> /&gt;<br/>);</span></pre><p id="a95b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们设法从<code class="fe me mf mg mh b">TitleWrapper</code>访问了<code class="fe me mf mg mh b">Title</code>的属性，没有手动暴露它们，也没有破坏封装，太棒了！🎉</p></div></div>    
</body>
</html>