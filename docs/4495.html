<html>
<head>
<title>How to Break Up an Expensive Computation Task in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中分解一个昂贵的计算任务</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-break-up-an-expensive-computation-task-in-javascript-446801d646ca?source=collection_archive---------11-----------------------#2021-09-07">https://javascript.plainenglish.io/how-to-break-up-an-expensive-computation-task-in-javascript-446801d646ca?source=collection_archive---------11-----------------------#2021-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4c4de5c80887e5a69ddce6417c12265f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_iU1nSWa6QSeiBg0zx0ig.jpeg"/></div></div></figure><p id="9865" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript是单线程语言，这意味着如果我们开始完成长时间运行的任务，它会阻止应用程序的另一部分完成。在前端方面，这意味着用户界面将被冻结，这对用户来说肯定是一个恼人的部分。在服务器端，这意味着服务器停止处理来自用户的新请求，并且变得没有响应。我们作为开发人员总是试图减轻它，并且应该记住它。</p><p id="32dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">避免这种情况的一种方法是将长时间运行任务的完成转移到单独的web workers中(在客户端)，或者用它们自己的事件循环产生单独的子流程(在服务器端)，但是还有另一种方法来完成它——使用JavaScript的异步行为。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="9b52" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">打破客户端长期运行的流程</h1><p id="8fbb" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">这里<code class="fe md me mf mg b">Promise</code>和<code class="fe md me mf mg b">requestAnimationFrame</code>一起来玩。</p><p id="354c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们想象一下，我们有一个使用CSS规则的动画矩形:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/55119d7ea7588cc4b7d85fc2c4c67a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*91VTsrv_txww0CCL3DJuXQ.gif"/></div></figure><p id="420d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还添加了一个无限循环的脚本。我相信，你知道当我们开始完成这个脚本时，页面会变得没有反应，我们在控制台中看不到应该由<code class="fe md me mf mg b">console.log</code>打印的<code class="fe md me mf mg b">Here</code>字</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="e157" class="mq lb in mg b gy mr ms l mt mu">function completeInfiniteTask(){<br/>     while(true){}<br/>}<br/>completeInfiniteTask();<br/>console.log('Here');</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/196116cda692a493498a75b190fb1c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVhZgyhV4WJMTYB0JQOzVA.png"/></div></div></figure><p id="5f8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，让我们开发<code class="fe md me mf mg b">nextFrame</code>函数，它将有可能中断这个无限循环，并为完成应用程序的另一部分腾出空间。看起来是这样的:</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="9a67" class="mq lb in mg b gy mr ms l mt mu">function nextFrame() {<br/>    return new Promise((res) =&gt; {<br/>         requestAnimationFrame(() =&gt; res())<br/>    });<br/>}</span></pre><p id="648d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，我们明确要求浏览器绘制下一个动画帧，一旦浏览器绘制了这一帧，<code class="fe md me mf mg b">Promise</code>就会被解析。</p><p id="5274" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，我们需要重写我们长期运行的任务，并在<code class="fe md me mf mg b">async</code>函数中将其输出，并定义我们希望暂时中断的确切时间。例如，我们可以在每个第5步中断这个循环:</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="68c6" class="mq lb in mg b gy mr ms l mt mu">async function completeInfiniteTask(){<br/>     let count = 0;<br/>     while(true){<br/>          if (++count % 5 === 0){<br/>               await nextFrame()<br/>          }<br/>     }<br/>}<br/>completeInfiniteTask();<br/>console.log('Here');</span></pre><p id="218d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这段时间里，JS有足够的时间同时完成长时间运行的任务并绘制动画矩形的下一帧，只是因为JS不仅是单线程语言，而且还支持异步。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/7a2f9ea65198f547fc7ebdae9df919fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Ph03mOPROfOp42yLcrJ9Rw.gif"/></div></figure><p id="961b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里<code class="fe md me mf mg b">console.log</code>几乎立即打印<code class="fe md me mf mg b">Here</code>，矩形动画没有延迟，尽管在后台JS仍然继续处理无限循环，因为每个第5步都为应用程序的其他部分处理让路。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="edce" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在服务器端中断长时间运行的流程</h1><p id="312d" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">方法实际上是相同的，但是<code class="fe md me mf mg b">requestAnimationFrame</code>在服务器端不可用，它只包含在浏览器API中。但是在这种情况下，我们可以用<code class="fe md me mf mg b">setImmediate</code>来代替:</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="23a2" class="mq lb in mg b gy mr ms l mt mu">function nextFrame() {<br/>    return new Promise((res) =&gt; {<br/>         <!-- -->setImmediate<!-- -->(() =&gt; res())<br/>    });<br/>}</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="b509" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">它可能用在什么地方？</h1><p id="c368" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">让我们想象一下，我们正在开发一个应用程序，用户上传一个CSV文件，应用程序需要解析每一行，在这个过程中，我们应该显示一个进度条。使用<code class="fe md me mf mg b">nextFrame</code>函数是一个很好的选择，在解析N行之后，我们可以中断解析过程并显示进度条的实际状态。</p><p id="e3fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法也有<code class="fe md me mf mg b">TensorFlow</code>这样的框架，允许开发者打破模型学习的长时间运行过程。</p><p id="9ea1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mw">更多内容尽在</em><a class="ae mx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>