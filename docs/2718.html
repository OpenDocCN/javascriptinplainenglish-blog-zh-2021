<html>
<head>
<title>Sharing Data between Angular Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在角度组件之间共享数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/sharing-data-b-w-angular-components-efdc858fd970?source=collection_archive---------1-----------------------#2021-06-04">https://javascript.plainenglish.io/sharing-data-b-w-angular-components-efdc858fd970?source=collection_archive---------1-----------------------#2021-06-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5c3515af598a6b650b126fb29f060188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XI32NuWta_TB_ouGZUOtwA.jpeg"/></div></div></figure><p id="c9d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Angular非常适合构建单页web应用程序、具有引人注目的动画的移动应用程序、离线工作的渐进式web应用程序、企业应用程序、电子商务应用程序等等。</p><p id="faac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在角度应用中，我们可能有许多功能/特性丰富的元件。在开发应用程序时，我们可能会遇到需要将数据从一个组件传递到另一个组件的情况。我们可以通过数据共享的概念，使用Angular提供的一些内置特性来实现这一点。</p><p id="4ef0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在任何项目中，数据共享都是一个需要理解的基本概念。这是一个常见的东西，将广泛应用于大多数项目。</p><p id="7d24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我发现以下方法最常用于数据共享。</p><p id="ea14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt"> 1。通过输入</em>共享数据</strong></p><p id="a2ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt"> 2。通过Output()和EventEmitter </em>共享数据</strong></p><p id="b6cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt"> 3。通过ViewChild </em>共享数据</strong></p><p id="65fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt"> 4。通过服务共享数据</em> </strong></p><p id="c50e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们深入了解这些方法，并了解如何实现它们。</p><h2 id="d1dc" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">通过输入共享数据</strong></h2><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/8b66723dab6dd4e330516845a4b1982c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcMzklOMks3xDq7cX8g6gQ.png"/></div></div></figure><p id="589c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法是共享数据的最常见和最简单的方法。它使用<strong class="jx io"> <em class="kt">输入</em> </strong>装饰器来允许数据通过模板传递。</p><p id="07f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">父组件</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/16423ec88e2fd7494a3f56a27f9e0f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*hw1TzRFn_n5oKRQ5C-KZwg.png"/></div></figure><p id="375c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">parent.component.html</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/a412f0557c10a17ab44441ff5d2161b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*AGH30HFiAMawpUtJXywyCw.png"/></div></figure><p id="d005" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> child.component.ts </strong></p><p id="608f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">。从角度/核心导入<strong class="jx io">输入</strong></p><p id="5c5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们用输入装饰器添加了消息属性。</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/a31bfb70e6bab890016f2c5c16456889.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*Pr9Qmh1-RF-pD8lAwjC20w.png"/></div></figure><p id="39c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">child.component.html</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/e8d30297b3e69e41085698339746946b.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*R2_p7vDpn0-wIvoix0a5iA.png"/></div></figure><h2 id="f263" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">通过Output()和EventEmitter共享数据</h2><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/f66c5e33086e5b08ea3e3da6f8914c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*EHP6vJ3lOnBNy-7yxIUKxQ.png"/></div></figure><p id="c09b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">共享数据的下一个方法是从子节点向父节点发送数据。当您希望共享由按钮点击、表单输入和其他用户事件触发的数据更改时，可以使用这种方法。</p><p id="8257" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> child.component.ts </strong></p><p id="3a64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">。从angular/core导入<strong class="jx io">输出，EventEmitter </strong>。</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/29591a7363f988d392c239ac05dbfc31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*j1X8y9o9U4yc2gS4yTa_UA.png"/></div></figure><p id="b83a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">child.component.html</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/1b6103cbce34cf19c19d9893e5b36e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*IrZRjwMsLmsE-1CRZCdt4Q.png"/></div></figure><p id="a813" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在父类中，我们创建一个函数来接收消息，并将其设置为等于事件中的消息变量。</p><p id="ab63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">父组件</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/0090e59d8101f47cfd441e4fec75f107.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*Ur0Id-AB1WFdfiM-cpsGiw.png"/></div></figure><p id="8b41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">messageEvent侦听发出的事件。父组件可以订阅子组件输出的事件，然后每当该事件发生时运行接收消息功能。</p><p id="4fba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">【parent.component.html T42】</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/73fb8b51e87b141cc9792e95297a2802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*wxtuUCiMdJzXhrTTP1MtIw.png"/></div></figure><h2 id="701c" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">通过ViewChild共享数据</h2><p id="5891" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated"><em class="kt"> ViewChild </em>是配置视图查询的属性装饰器。变更检测器在视图DOM中寻找匹配选择器的第一个元素或指令。如果视图DOM发生了变化，并且有一个新的子元素与选择器相匹配，那么属性将被更新。</p><p id="9fc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过使用ViewChild，我们可以将一个组件注入到另一个组件中，让父组件可以访问它的属性和函数。</p><p id="4d0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">child.component.html</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/15a9bfef0ec588000cc2862783e707d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*CPiismQr9fUy-O79Rk7GmA.png"/></div></figure><p id="adf6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> parent.component.ts </strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/5a010d3d27b36989a8194f35a3d5e5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*WbJiCHderCaZDdV87PukJQ.png"/></div></figure><p id="6e7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">parent.component.html</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/b51320d4111d00ce33fdeaa095a6e373.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*QWl-_Hx5Z9zLYi-ND9uYWQ.png"/></div></figure><h2 id="e1a4" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">不相关的组件:与服务共享数据</h2><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/7dde0452dfbb5904f4287897bec936fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*sxBckwxVyojMjA_B9wlmzw.png"/></div></div></figure><p id="f7b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当在没有直接连接的组件之间传递数据时，可以通过使用服务来共享数据。当我们必须保持数据同步时，我们可以使用rjs<strong class="jx io"><em class="kt">行为主题</em> </strong></p><p id="e771" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务中，我们创建了一个<em class="kt">行为主体</em>，它将保存消息的当前值。我们定义了一个currentMessage变量，它将这个数据流处理为可观察的。我们必须创建一个接下来调用<em class="kt">行为主体</em>的函数来改变它的值。父组件、子组件和同级组件都以相同的方式使用它。</p><p id="4dc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> data.service.ts </strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/fb8ab3481cbe615b666abdf3e6c5a659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*DzTFfBhSCSUPc1GZAgvxrQ.png"/></div></figure><p id="d1be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在构造函数中注入DataService，然后订阅currentMessage可观察到的值，并将其值设置为等于消息变量。现在，我们可以在这些组件中的任何一个中创建一个函数，其中消息的值被改变。当这个函数被执行时，新数据会自动将消息发送到我们订阅消息的组件。</p><p id="e31c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">组件-a.component.ts </strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/05f689bbe7dae68ec3765a1443c553ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*CmIlvyHgo19zUS1SoeonNw.png"/></div></figure><p id="30c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">Component-a.component.html</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/b83f795b6c0d3a3a83c64e4dbd0c2531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*HT7urytCPYb7gYf7EFcYXw.png"/></div></figure><p id="22df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">Component-b . Component . ts</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/55e9b07f64bfa007339c5eaf37443e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*WHq_XWaJVW3xADMrO-DZVw.png"/></div></figure><p id="2a09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">Component-b.component.html</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/0ee912a44f39a93e376d31b88483054d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*SGU0XcsZIauim5oItr5DrQ.png"/></div></figure><p id="38e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击新建消息按钮，消息将被订阅<em class="kt">行为主题</em>并自动在<em class="kt">组件a中更改/更新。</em></p><h1 id="0270" class="mo kv in bd kw mp mq mr kz ms mt mu lc mv mw mx lf my mz na li nb nc nd ll ne bi translated">结论</h1><p id="a870" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">有很多种方式在“角度”中的组件之间传递数据。在这个博客中，我介绍了角分量之间数据共享的重要性以及实现这一点的不同方法。正如您所看到的，这种方法在项目中很容易遵循和实施。<strong class="jx io">快乐编码！</strong></p><p id="857f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容参见</em> <a class="ae nf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="kt">浅显易懂</em> </a></p></div></div>    
</body>
</html>