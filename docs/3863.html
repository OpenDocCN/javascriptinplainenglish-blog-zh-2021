<html>
<head>
<title>JavaScript Var vs. Let vs. Const — A Comprehensive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Var vs . Let vs . Const——综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-var-vs-let-vs-const-a-comprehensive-guide-f4aa817c5340?source=collection_archive---------8-----------------------#2021-08-03">https://javascript.plainenglish.io/javascript-var-vs-let-vs-const-a-comprehensive-guide-f4aa817c5340?source=collection_archive---------8-----------------------#2021-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7bad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解变量声明之间的区别，避免错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d0a3da9f6a677c5abd8ca095ac1ef35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gqwSl73uJSTG4RYg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shahadat Rahman</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d242" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>相比以前的<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>有什么不同？</p><p id="c440" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在ES6之前，<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>声明是必经之路。但是由于使用<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>存在问题，创建变量的改变是不可避免的。</p><p id="104a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在比较<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>与<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>之前，我们先来讨论一下<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>是什么，它有什么问题。</p><h1 id="0e15" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">JavaScript中的变量</h1><p id="f8a0" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在JavaScript中，可以使用<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>关键字声明一个变量。</p><p id="d76c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让我们创建一个存储值10的数字变量:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="565f" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">var</strong> num = 10;</span></pre><h2 id="7f07" class="mx lx iq bd ly nc nd dn mc ne nf dp mg lf ng nh mi lj ni nj mk ln nk nl mm nm bi translated">风险值的范围</h2><p id="a40f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在JavaScript中，<strong class="ky ir"> scope </strong>指的是可以使用变量的代码区域。</p><p id="3e99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>声明的变量的范围是:</p><ul class=""><li id="635b" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><strong class="ky ir">全局范围</strong>如果声明在函数之外。</li><li id="f1e3" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir">函数作用域</strong>在函数内部声明时。</li></ul><p id="88e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解这些是什么意思，我们来看一堆例子。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="56dc" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">var</strong> num1 = 10;</span><span id="ad98" class="mx lx iq lv b gy ob mz l na nb"><strong class="lv ir">function</strong> example(){<br/>    <strong class="lv ir">var</strong> num2 = 100;<br/>}</span></pre><ul class=""><li id="133c" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">这里，变量<code class="fe ls lt lu lv b">num1</code>具有全局范围，因为它没有被函数包围。这意味着您可以在代码的任何地方访问变量<code class="fe ls lt lu lv b">num1</code>。</li><li id="8f76" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">变量<code class="fe ls lt lu lv b">num2</code>不是全局范围的，因为它是在函数<code class="fe ls lt lu lv b">example()</code>中定义的。这意味着除了函数之外，您不能从任何地方访问它</li></ul><p id="39b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解这些作用域的含义，请看这段代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="87e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，在函数<code class="fe ls lt lu lv b">example()</code>之外记录<code class="fe ls lt lu lv b">num2</code>是不可能的，并且会由于函数作用域而导致错误。</p><h2 id="2618" class="mx lx iq bd ly nc nd dn mc ne nf dp mg lf ng nh mi lj ni nj mk ln nk nl mm nm bi translated">变量的重新声明</h2><p id="fc81" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">您可以重新声明用<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>创建的变量。</p><p id="b6ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这段代码创建了一个名为<code class="fe ls lt lu lv b">number</code>的变量，然后用不同的值重新声明该变量:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="f1f2" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">var</strong> number = 100;<br/><strong class="lv ir">var</strong> number = 25;</span></pre><p id="626a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不会导致任何错误。</p><p id="47d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在特定情况下，这种行为可能是一个问题。让我们来看看这段代码:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="b6a2" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">var</strong> num = 10;</span><span id="4275" class="mx lx iq lv b gy ob mz l na nb"><strong class="lv ir">if</strong>(<strong class="lv ir">true</strong>){<br/>    <strong class="lv ir">var</strong> num = 99;<br/>    console.log(num);<br/>}</span><span id="365a" class="mx lx iq lv b gy ob mz l na nb">console.log(num);</span></pre><p id="2b55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="d589" class="mx lx iq lv b gy my mz l na nb">99</span></pre><p id="eadf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，if语句永久地改变了变量<code class="fe ls lt lu lv b">num</code>。即使在声明之外。</p><p id="e891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能会引起混淆，因为人们可能会认为if语句中的变量<code class="fe ls lt lu lv b">num</code>与全局变量<code class="fe ls lt lu lv b">num</code>被视为不同的<code class="fe ls lt lu lv b">num</code>。</p><p id="5567" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>引起的一个问题。</p><h2 id="27a0" class="mx lx iq bd ly nc nd dn mc ne nf dp mg lf ng nh mi lj ni nj mk ln nk nl mm nm bi translated">在JavaScript中提升</h2><p id="2d0a" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">JavaScript中的提升意味着在代码运行之前，变量和函数声明被移动到作用域的顶部。发生这种情况是因为JavaScript希望提前看到将要执行的代码，并为变量和函数预留空间。</p><p id="29ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提升使得在定义变量之前调用它成为可能。</p><p id="6f22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="e029" class="mx lx iq lv b gy my mz l na nb">console.log(greet);<br/><strong class="lv ir">var</strong> greet = "Hello"</span></pre><p id="bbe4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果是:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="d73c" class="mx lx iq lv b gy my mz l na nb">undefined</span></pre><p id="43ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发生这种情况是因为吊装。实际上，上面这段代码是这样工作的:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="c84f" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">var</strong> greet;</span><span id="d15e" class="mx lx iq lv b gy ob mz l na nb">console.log(greet);<br/>greet = "Hello";</span></pre><p id="e669" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括一下，使用<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>创建的所有变量都被提升到作用域的顶部，并被赋予一个值<code class="fe ls lt lu lv b"><strong class="ky ir">undefined</strong></code>。</p><p id="2fcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">吊装引入了另一个问题。让我们看一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="22be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="77aa" class="mx lx iq lv b gy my mz l na nb">Your name is James</span></pre><p id="2602" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是令人困惑的。代码声明，如果没有定义<code class="fe ls lt lu lv b">name</code>，它将创建一个变量<code class="fe ls lt lu lv b">name</code>，并将<code class="fe ls lt lu lv b">“James”</code>赋给它并返回。但是在上面的例子中，名字已经是<code class="fe ls lt lu lv b">“Charlie”</code>开头了。因此，if-check应该永远不会通过，函数<code class="fe ls lt lu lv b">getName()</code>应该返回<code class="fe ls lt lu lv b">“Charlie”</code>。</p><p id="7bdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这不是真的。由于吊装的原因，<code class="fe ls lt lu lv b">name</code>与<code class="fe ls lt lu lv b"><strong class="ky ir">undefined</strong></code>在一条线上。这意味着条件<code class="fe ls lt lu lv b">!name</code>实际上是<code class="fe ls lt lu lv b">true</code>。</p><p id="e2a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解<code class="fe ls lt lu lv b">name</code>为什么是<code class="fe ls lt lu lv b"><strong class="ky ir">undefined</strong></code>，我们先来看看上面的函数在引擎盖下由于吊装是什么样子的。注意变量<code class="fe ls lt lu lv b">name</code>在<code class="fe ls lt lu lv b">getName()</code>函数中的表现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e023" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所知，提升会将所有声明移动到作用域的顶部。在<code class="fe ls lt lu lv b">getName()</code>函数中，这意味着变量<code class="fe ls lt lu lv b">name</code>在if-check之前被重新声明，并被赋值为<code class="fe ls lt lu lv b"><strong class="ky ir">undefined</strong></code>。这就是if-check通过并返回名称<code class="fe ls lt lu lv b">“James”</code>的原因。</p><p id="2742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这真的很令人困惑，尤其是对于不知道起重的初学者。</p><p id="a792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何解决与使用<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>相关的问题。</p><h1 id="a8c2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">让JavaScript进来</h1><p id="3980" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如今，在JavaScript中声明变量的首选方式是使用<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>。这是因为它与使用<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>相比有所改进。</p><h2 id="c1eb" class="mx lx iq bd ly nc nd dn mc ne nf dp mg lf ng nh mi lj ni nj mk ln nk nl mm nm bi translated">Let有一个块范围</h2><p id="4eff" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>变量有一个<strong class="ky ir">块范围</strong>。这意味着它只能在定义它的花括号中访问。</p><p id="197f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，访问块外的<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>变量会导致错误:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="a506" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">if</strong>(<strong class="lv ir">true</strong>){<br/>    <strong class="lv ir">let</strong> num = 1;<br/>}</span><span id="cacb" class="mx lx iq lv b gy ob mz l na nb">console.log(num);</span></pre><p id="41f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="aab4" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">error: Uncaught ReferenceError: num is not defined</strong></span></pre><p id="395d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">num</code>只能在if语句中访问。不能在外部访问它。</p><p id="927d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">块作用域使您可以在不同的作用域中拥有两个同名的变量。</p><p id="b3e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="6a47" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">let </strong>num = 1;</span><span id="75aa" class="mx lx iq lv b gy ob mz l na nb"><strong class="lv ir">if</strong>(<strong class="lv ir">true</strong>){<br/>    <strong class="lv ir">let</strong> num = 20;<br/>    console.log(num);<br/>}</span></pre><p id="b2a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="2aeb" class="mx lx iq lv b gy my mz l na nb">20</span></pre><p id="37b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，不是重新声明<code class="fe ls lt lu lv b">num</code>，而是两个<code class="fe ls lt lu lv b">num</code>变量在它们自己的范围内被视为不同的变量。</p><p id="f933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得<code class="fe ls lt lu lv b">let</code>比<code class="fe ls lt lu lv b">var</code>更好的选择:在使用<code class="fe ls lt lu lv b">let</code>时，你不必担心之前是否使用过变量的名称。</p><h2 id="8723" class="mx lx iq bd ly nc nd dn mc ne nf dp mg lf ng nh mi lj ni nj mk ln nk nl mm nm bi translated">重新声明一个字母是不可能</h2><p id="ac25" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">与<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>相反，<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>变量不能在其作用域内重新声明。</p><p id="d579" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这会导致一个错误:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="8e9c" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">let</strong> number = 100;<br/><strong class="lv ir">let</strong> number = 25;</span></pre><p id="1f88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="2b5b" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">Identifier 'number' has already been declared.</strong></span></pre><p id="6909" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当然，您可以用这种方式将<strong class="ky ir">的值更新为<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>的值:</strong></p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="8387" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">let</strong> num = 100;<br/>num = 25;</span></pre><h2 id="4b63" class="mx lx iq bd ly nc nd dn mc ne nf dp mg lf ng nh mi lj ni nj mk ln nk nl mm nm bi translated">左起重</h2><p id="609e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">每个声明都在JavaScript中被挂起。这也适用于<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>变量。吊装<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>与吊装<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>的区别在于:</p><ul class=""><li id="c6b6" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">一个<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>变量被提升，使得一个值<code class="fe ls lt lu lv b"><strong class="ky ir">undefined</strong></code>被分配给它</li><li id="2a42" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">一个<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>变量根本没有用值初始化。</li></ul><p id="a35d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着在定义变量之前，不能访问用<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>创建的变量:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="c647" class="mx lx iq lv b gy my mz l na nb">console.log(greet);<br/><strong class="lv ir">let</strong> greet = "Hello"</span></pre><p id="186c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="39ac" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">error: Uncaught ReferenceError: Cannot access 'greet' before initialization</strong></span></pre><p id="bc06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回到你之前看到的<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>吊装的问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9d5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能还记得，在输出中没有看到<code class="fe ls lt lu lv b">"Charlie”</code>，而是:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="7174" class="mx lx iq lv b gy my mz l na nb">Your name is James</span></pre><p id="dfc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你已经了解了什么是<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>以及它如何使变量声明更加一致。你能猜到如何解决上述问题吗？</p><p id="9b59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以用<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>代替<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>问题就没了。</p><p id="f32a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们验证一下事实是否如此:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="fc15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="7353" class="mx lx iq lv b gy my mz l na nb">Your name is Charlie</span></pre><p id="7c62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在if-check永远不会通过，因为由于<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>的提升，在if语句之前没有给它一个值<code class="fe ls lt lu lv b"><strong class="ky ir">undefined</strong></code>。相反，如您所料，JavaScript使用在函数外部定义的<code class="fe ls lt lu lv b">name</code> <code class="fe ls lt lu lv b">“Charlie”</code>。</p><h1 id="75e9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">JavaScript中的常量</h1><p id="57da" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">声明为<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>的变量在JavaScript中保持一个常量值。</p><p id="80c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">const和<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>唯一真正的区别是<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>是不可变的。这意味着一旦定义，你永远不能改变它的值。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="bbff" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">const</strong> num = 1;<br/>num = 20;</span></pre><p id="58be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="005c" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">error: Uncaught TypeError: Assignment to constant variable.</strong></span></pre><p id="b492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个约束，<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>必须在声明时初始化。</p><p id="987a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了不可变之外，<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>的行为类似于<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>。为了使它完整，让我们看看这意味着什么。</p><h2 id="8f6b" class="mx lx iq bd ly nc nd dn mc ne nf dp mg lf ng nh mi lj ni nj mk ln nk nl mm nm bi translated">Const有一个块范围</h2><p id="fb9c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">与<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>类似，<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>有block作用域。这意味着<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>变量只能在定义它的花括号中被访问。</p><p id="d327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="5706" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">if</strong>(<strong class="lv ir">true</strong>){<br/>    <strong class="lv ir">const</strong> num = 10;<br/>    console.log(num); // works<br/>}</span><span id="7a02" class="mx lx iq lv b gy ob mz l na nb">console.log(num); // fails</span></pre><p id="df47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在不同的作用域中可以有许多同名的<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>变量，因为它们被视为不同的变量。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="9612" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">const</strong> num = 1;</span><span id="dd3a" class="mx lx iq lv b gy ob mz l na nb"><strong class="lv ir">if</strong>(<strong class="lv ir">true</strong>){<br/>    <strong class="lv ir">const</strong> num = 20;<br/>    console.log(num);<br/>}</span></pre><p id="af04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="8508" class="mx lx iq lv b gy my mz l na nb">20</span></pre><h2 id="ac64" class="mx lx iq bd ly nc nd dn mc ne nf dp mg lf ng nh mi lj ni nj mk ln nk nl mm nm bi translated">建筑吊装</h2><p id="93f5" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">提升<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>的工作方式相同。它们没有预先用<code class="fe ls lt lu lv b"><strong class="ky ir">undefined</strong></code>的值初始化，相反，它们根本没有初始化。这使得在初始化它们之前无法调用它们。</p><p id="ab2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="d8c2" class="mx lx iq lv b gy my mz l na nb">console.log(greet);<br/><strong class="lv ir">const</strong> greet = "Hello"</span></pre><p id="110e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="c82e" class="mx lx iq lv b gy my mz l na nb"><strong class="lv ir">error: Uncaught ReferenceError: Cannot access 'greet' before initialization</strong></span></pre></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="ddc5" class="lw lx iq bd ly lz ol mb mc md om mf mg jw on jx mi jz oo ka mk kc op kd mm mn bi translated">结论</h1><p id="bd20" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在JavaScript中创建变量的老派方法是使用<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>。从ES6开始，使用<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>创建变量有了更一致的方法。</p><p id="8948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code> / <code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>的区别在于:</p><ul class=""><li id="2855" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>声明是全局作用域或函数作用域，而<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>是块作用域。使用<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>或<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>你可以在它们自己的作用域中有多个同名的变量。</li><li id="6746" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>变量可以更新，<strong class="ky ir">在范围内重新声明</strong>。<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>变量可以更新，但不能重新声明；<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>变量既不能更新也不能重新声明。</li><li id="c922" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">在JavaScript中，所有声明都被提升到作用域的顶部。但是当<code class="fe ls lt lu lv b"><strong class="ky ir">var</strong></code>变量用<code class="fe ls lt lu lv b"><strong class="ky ir">undefined</strong></code>初始化时，<code class="fe ls lt lu lv b"><strong class="ky ir">let</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">const</strong></code>变量不用任何值初始化。这在某些情况下避免了混淆。</li></ul></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="f3a1" class="lw lx iq bd ly lz ol mb mc md om mf mg jw on jx mi jz oo ka mk kc op kd mm mn bi translated">进一步阅读</h1><div class="oq or gp gr os ot"><a href="https://www.codingem.com/50-buzzwords-of-web-development-and-design-in-2021/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">2021年网络开发和设计的50多个流行语</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">学习创业公司使用的网页开发和网页设计语言。这篇文章是关于…的很好的入门读物</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">www.codingem.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kp ot"/></div></div></a></div><h1 id="8905" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">参考</h1><div class="oq or gp gr os ot"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">JavaScript | MDN</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">JavaScript (JS)是一种轻量级、解释型或即时编译的编程语言，具有一流的…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">developer.mozilla.org</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph kp ot"/></div></div></a></div><p id="7496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pj">更多内容看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="pj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>