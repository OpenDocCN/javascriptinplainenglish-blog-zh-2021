<html>
<head>
<title>What the Heck Is Ref Forwarding?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ref转发是什么鬼东西？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-the-heck-is-ref-forwarding-1fc434911122?source=collection_archive---------2-----------------------#2021-09-21">https://javascript.plainenglish.io/what-the-heck-is-ref-forwarding-1fc434911122?source=collection_archive---------2-----------------------#2021-09-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="cdd3" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">理解反应</h2><div class=""/><div class=""><h2 id="5570" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">将引用传递给子组件</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/00664fe7936fe0f72ce2697bcd9f5d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*844JjUS-rPpNI71BAdicug.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Image by <a class="ae lb" href="https://pixabay.com/users/billithecat-7996303/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=4070337" rel="noopener ugc nofollow" target="_blank">Nina Garman</a> from <a class="ae lb" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=4070337" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="42c3" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">与React框架的其他部分相比，refs肯定有点古怪。React利用声明式设计模式，不鼓励直接操作<code class="fe ly lz ma mb b">DOM</code>，但是对于一些用例——例如聚焦或选择输入字段——直接的命令式代码是必要的。这就是引用的用武之地，它允许我们访问一个节点，并根据需要强制性地修改它。</p><p id="2917" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="mc"> ( </em> <strong class="le ix"> <em class="mc">先不说</em> </strong> <em class="mc">:如果你之前没有React参考经验我推荐你先阅读</em> <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/whats-a-ref-anyway-2a6979ad173f"> <em class="mc">这篇文章</em> </a> <em class="mc">再继续)</em></p><h1 id="af8f" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">(不完整的)例子</h1><p id="e2a2" class="pw-post-body-paragraph lc ld in le b lf mv jx lh li mw ka lk ll mx ln lo lp my lr ls lt mz lv lw lx ig bi translated">首先，让我们研究一个引用转发可能会派上用场的场景。下面我们有漂亮的文本输入，还有一个按钮，单击它可以选择输入的值。不幸的是，下面的例子坏了。</p><p id="7b4d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">(<strong class="le ix"> <em class="mc">先不说数字二:</em> </strong> <em class="mc">尽管我尽了最大的努力CodeSandBox和/或Medium似乎有意默认向您显示</em> <code class="fe ly lz ma mb b"><em class="mc">App</em></code> <em class="mc">文件。请务必查看</em> <code class="fe ly lz ma mb b"><em class="mc">FancyInput.js</em></code> <em class="mc">文件，了解不同实现之间的差异</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">A broken implementation :(</figcaption></figure><p id="6e62" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果我们更新我们的<code class="fe ly lz ma mb b">FancyInput</code>组件并尝试通过<code class="fe ly lz ma mb b">props</code>访问ref会怎么样？这次我们将在实际的<code class="fe ly lz ma mb b">input</code>元素上声明一个<code class="fe ly lz ma mb b">ref</code>属性，并尝试通过<code class="fe ly lz ma mb b">props.ref</code>从父组件传递<code class="fe ly lz ma mb b">ref</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">This doesn’t work either :(</figcaption></figure><p id="2f23" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">又坏了？怎么回事？</p><p id="71a2" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">让我们来看看控制台输出:</p><pre class="km kn ko kp gt nc mb nd ne aw nf bi"><span id="274a" class="ng me in mb b gy nh ni l nj nk">Warning: FancyInput: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (<a class="ae lb" href="https://reactjs.org/link/special-props" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/link/special-props</a>)<br/>    at FancyInput (<a class="ae lb" href="https://54gtm.csb.app/src/FancyInput.js:24:41" rel="noopener ugc nofollow" target="_blank">https://54gtm.csb.app/src/FancyInput.js:24:41</a>)<br/>    at div<br/>    at App (<a class="ae lb" href="https://54gtm.csb.app/src/App.js:26:38" rel="noopener ugc nofollow" target="_blank">https://54gtm.csb.app/src/App.js:26:38</a>)</span><span id="4980" class="ng me in mb b gy nl ni l nj nk">Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?<br/><br/>Check the render method of `App`.<br/>    at FancyInput (<a class="ae lb" href="https://54gtm.csb.app/src/FancyInput.js:24:41" rel="noopener ugc nofollow" target="_blank">https://54gtm.csb.app/src/FancyInput.js:24:41</a>)<br/>    at div<br/>    at App (<a class="ae lb" href="https://54gtm.csb.app/src/App.js:26:38" rel="noopener ugc nofollow" target="_blank">https://54gtm.csb.app/src/App.js:26:38</a>)</span></pre><p id="1db9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">从错误消息中可以看出，试图通过props将ref传递给子组件是行不通的。谢天谢地，我们得到了使用<code class="fe ly lz ma mb b">React.forwardRef()</code>的有用建议。</p><h2 id="35f8" class="ng me in bd mf nm nn dn mj no np dp mn ll nq nr mp lp ns nt mr lt nu nv mt it bi translated">检查文档</h2><p id="1ac8" class="pw-post-body-paragraph lc ld in le b lf mv jx lh li mw ka lk ll mx ln lo lp my lr ls lt mz lv lw lx ig bi translated">如果我们按照第一个警告中提供的<a class="ae lb" href="https://reactjs.org/warnings/special-props.html" rel="noopener ugc nofollow" target="_blank">链接</a>，我们会看到<code class="fe ly lz ma mb b">ref</code>是React内部使用的特殊属性/关键字，这意味着<strong class="le ix">任何作为</strong> <code class="fe ly lz ma mb b"><strong class="le ix">ref</strong></code> <strong class="le ix">传递给元素的值都不能通过</strong> <code class="fe ly lz ma mb b"><strong class="le ix">props</strong></code>访问。作为<code class="fe ly lz ma mb b">key</code>属性传递的任何值也是如此。</p><blockquote class="nw"><p id="19b4" class="nx ny in bd nz oa ob oc od oe of lx dk translated">JSX元素上的大多数属性都被传递给组件，但是，有两个特殊的属性(<code class="fe ly lz ma mb b">ref</code>和<code class="fe ly lz ma mb b">key</code>)被React使用，因此不会被转发给组件。—特殊道具警告</p></blockquote><p id="a1da" class="pw-post-body-paragraph lc ld in le b lf og jx lh li oh ka lk ll oi ln lo lp oj lr ls lt ok lv lw lx ig bi translated">换句话说，React在内部利用<code class="fe ly lz ma mb b">ref</code>和<code class="fe ly lz ma mb b">key</code>属性，防止它们所属的组件通过<code class="fe ly lz ma mb b">props.ref</code>或<code class="fe ly lz ma mb b">props.key</code>访问这些值。</p><blockquote class="ol om on"><p id="e539" class="lc ld mc le b lf lg jx lh li lj ka lk oo lm ln lo op lq lr ls oq lu lv lw lx ig bi translated">如果您需要在子组件中访问相同的值，那么您应该将它作为一个不同的属性来传递(例如:<code class="fe ly lz ma mb b"><em class="in">&lt;ListItemWrapper key={result.id} id={result.id} /&gt;</em></code>)。虽然这看起来有些多余，但将应用程序逻辑与协调提示分开是很重要的。— <a class="ae lb" href="https://reactjs.org/warnings/special-props.html" rel="noopener ugc nofollow" target="_blank">特殊道具警告</a></p></blockquote><p id="98d4" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这是否意味着我们可以通过给子组件一个不同的名字来传递一个<code class="fe ly lz ma mb b">ref</code>给它？嗯，是也不是。虽然<em class="mc">是</em>可能的，但是将一个引用作为一个值传递给一个唯一的属性被认为是不好的做法。这是为什么呢？</p><h1 id="4634" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">不恰当的解决方法</h1><p id="b825" class="pw-post-body-paragraph lc ld in le b lf mv jx lh li mw ka lk ll mx ln lo lp my lr ls lt mz lv lw lx ig bi translated">无论何时设计软件，记住<a class="ae lb" href="https://medium.com/codex/low-coupling-and-high-cohesion-af77df4cc005" rel="noopener"> <strong class="le ix"> <em class="mc">低耦合和高内聚</em> </strong> </a>的原则是很重要的。你的程序应该保持一个适当的关注点分离 : <em class="mc">父组件不应该需要对它们的子组件的结构有深入的了解，它们的子组件也不应该需要对父组件有全面的了解才能正常工作。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Do not do this</figcaption></figure><p id="db06" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">虽然上面的代码有效，但它导致了紧密耦合的组件，充其量也就是模糊的内聚性，这与良好的设计实践完全相反。当您第一次创建<code class="fe ly lz ma mb b">FancyInput</code>组件时，可能很容易记住使用<code class="fe ly lz ma mb b">innerRef</code>，但是如果该组件在您的应用程序中被重用了呢？如果您决定在未来的项目中回收该组件，该怎么办？当不同的开发人员在一年或更长时间后进行维护时会发生什么？</p><p id="d914" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">当我看着这些代码时，我所能想到的就是那些不幸维护、更新或以其他方式与这些代码库进行交互的人将来会遇到的所有麻烦。不太好。</p><h1 id="e414" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">首选解决方案:React.forwardRef()</h1><p id="f0be" class="pw-post-body-paragraph lc ld in le b lf mv jx lh li mw ka lk ll mx ln lo lp my lr ls lt mz lv lw lx ig bi translated">谢天谢地，React devs已经为我们的问题提供了一个解决方案。通过将我们的功能组件包装在<code class="fe ly lz ma mb b">React.forwardRef()</code>中，我们可以传递第二个参数<code class="fe ly lz ma mb b">ref</code>，此外还有<code class="fe ly lz ma mb b">props</code>，它可以在子组件中以任何必要的方式使用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">This is the correct way</figcaption></figure><p id="8e11" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">通过将<code class="fe ly lz ma mb b">FancyInput</code>包装在<code class="fe ly lz ma mb b">React.forwardRef()</code>中，我们可以获取从父组件传递来的<code class="fe ly lz ma mb b">ref</code>并在内部使用它。这将两个文件解耦，有效地分离了关注点，使我们的代码更加模块化。我们的父组件现在可以强制性地修改其子组件，而不需要详细了解子组件的内部<code class="fe ly lz ma mb b">DOM</code>结构。</p><h1 id="fa1b" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">类别组件</h1><p id="7d33" class="pw-post-body-paragraph lc ld in le b lf mv jx lh li mw ka lk ll mx ln lo lp my lr ls lt mz lv lw lx ig bi translated">React文档声明<em class="mc">“您也可以将引用转发给类组件实例。”</em>但遗憾的是没有提供任何示例代码。在仔细阅读了StackOverflow之后，我找到了一个可行的解决方案。</p><p id="69a8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">诀窍是在导出语句期间<strong class="le ix">在</strong> <code class="fe ly lz ma mb b"><strong class="le ix">React.forwardRef()</strong></code> <strong class="le ix">中包装你的类的一个实例。<code class="fe ly lz ma mb b">React.forwardRef()</code>接受一个回调函数并传递给它两个参数，<code class="fe ly lz ma mb b">props</code>和<code class="fe ly lz ma mb b">ref</code>。您可以编写一个快速助手函数来接收这两个参数，并将<code class="fe ly lz ma mb b">ref</code>传递给唯一的<code class="fe ly lz ma mb b">prop</code>(在本例中为<code class="fe ly lz ma mb b">innerRef</code>)。</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Forwarding refs using class components</figcaption></figure><p id="36a0" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">虽然类似于前一个(坏的)例子，但是这个策略与<em class="mc">的不同之处在于父组件不需要知道任何关于子组件内部结构的事情</em>。使用这种方法，从父类的角度来看，类或功能组件之间没有区别，这是一件好事。</p><p id="e317" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">为什么父组件应该关心子组件是类还是函数？这在抽象层次上有必要吗？也许有一些边缘情况需要这种信息，但是一般来说，子节点是函数还是类<em class="mc">应该</em>与父节点中发生的逻辑无关。低耦合，高内聚。</p><h1 id="ae47" class="md me in bd mf mg mh mi mj mk ml mm mn kc mo kd mp kf mq kg mr ki ms kj mt mu bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="3eda" class="or os in le b lf mv li mw ll ot lp ou lt ov lx ow ox oy oz bi translated">您不能像传递其他值一样将<code class="fe ly lz ma mb b">ref</code>传递给子组件(即通过普通的旧<code class="fe ly lz ma mb b">props</code></li><li id="b9b3" class="or os in le b lf pa li pb ll pc lp pd lt pe lx ow ox oy oz bi translated">要将一个<code class="fe ly lz ma mb b">ref</code>传递给一个子组件(要<em class="mc">转发</em>它)，必须将子组件包装在<code class="fe ly lz ma mb b">React.forwardRef()</code>中</li><li id="5744" class="or os in le b lf pa li pb ll pc lp pd lt pe lx ow ox oy oz bi translated"><code class="fe ly lz ma mb b">React.forwardRef()</code>接收一个函数作为参数，并提供两个参数<code class="fe ly lz ma mb b">props</code>和一个<code class="fe ly lz ma mb b">ref</code></li><li id="44ab" class="or os in le b lf pa li pb ll pc lp pd lt pe lx ow ox oy oz bi translated">功能组件可以直接接收这些参数，并在需要时使用它们</li><li id="6c3a" class="or os in le b lf pa li pb ll pc lp pd lt pe lx ow ox oy oz bi translated">类组件需要一个助手函数，将<code class="fe ly lz ma mb b">ref</code>映射到一个唯一的<code class="fe ly lz ma mb b">prop</code>，允许类在内部使用它。</li></ul><p id="4bc8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">你以前在自己的项目中使用过转发引用吗？你在哪里见过它们，用于什么目的？欢迎在下面的评论中分享你的个人经历。</p><p id="2b02" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="mc">更多内容请看</em><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="mc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>