<html>
<head>
<title>How to Get an Attribute Value in Angular’s Components and Directives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular的组件和指令中获取属性值</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-get-an-attribute-value-in-angulars-components-and-directives-adf77a5da939?source=collection_archive---------6-----------------------#2021-09-13">https://javascript.plainenglish.io/how-to-get-an-attribute-value-in-angulars-components-and-directives-adf77a5da939?source=collection_archive---------6-----------------------#2021-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c129" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我们将探索读取组件或指令中传递的HTML属性值的所有方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c0fd51656d5ee37d053bad3e2074c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZ8JLiJzoIgnY8WDbldgUQ.jpeg"/></div></div></figure><h1 id="ac41" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">读取HTML属性</h1><p id="dcb0" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><em class="lx">HTML中的元素有</em> <strong class="jm io"> <em class="lx">属性</em></strong><em class="lx">；这些是附加的值，它们以各种方式配置元素或调整它们的行为，以满足用户想要的标准。— </em> <a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes" rel="noopener ugc nofollow" target="_blank"> <em class="lx"> MDN文档</em> </a></p><p id="0f04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="374f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">type</code>和<code class="fe mb mc md me b">colspan</code>是HTML属性的一些例子。</p><p id="1f2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在某些情况下，您需要根据为HTML属性设置的值来处理组件或指令的行为。</p><p id="6ba8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，有一个组件叫做<code class="fe mb mc md me b">smart-input</code>。您希望为作为值传递给HTML属性的不同的<code class="fe mb mc md me b">type</code>呈现不同的布局。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="5c86" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><code class="fe mb mc md me b">ElementRef</code>阶级</h1><p id="50a4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">读取这些属性值的一种方法是通过<code class="fe mb mc md me b"><a class="ae ly" href="https://angular.io/api/core/ElementRef" rel="noopener ugc nofollow" target="_blank">ElementRef</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="66e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以上是好的，并按预期工作。但是，有一个更短的方法可用于上述角度。</p><h1 id="3128" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><code class="fe mb mc md me b">@Attribute()</code>参数装饰器</h1><p id="b09c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">可以使用参数decorator通过依赖注入将HTML属性的值传递给组件或指令构造函数。</p><p id="f87d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，对于前面的例子，为了读取<code class="fe mb mc md me b">type</code>属性，我们将做如下所示的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了上面的代码，<code class="fe mb mc md me b">smart-input</code>就会呈现</p><p id="5167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md me b">@Attribute()</code> decorator也可以用在制作<code class="fe mb mc md me b"><a class="ae ly" href="https://angular.io/api/core/FactoryProvider" rel="noopener ugc nofollow" target="_blank">FactoryProvider</a></code>的时候。</p><p id="5814" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，对于<code class="fe mb mc md me b">smart-input</code>，我们也可以编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d189" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个装饰器也被一些内置指令使用:</p><p id="d5a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是使用<code class="fe mb mc md me b">@Attribute()</code>装饰器的两个限制:</p><ol class=""><li id="57ac" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">它只适用于静态HTML属性值。不支持<a class="ae ly" href="https://angular.io/guide/attribute-binding#binding-to-an-attribute" rel="noopener ugc nofollow" target="_blank">属性绑定</a>和<a class="ae ly" href="https://angular.io/guide/property-binding" rel="noopener ugc nofollow" target="_blank">属性绑定</a>。</li><li id="1f8c" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">由于它仅适用于静态值，因此仅支持<code class="fe mb mc md me b">string</code>类型。</li></ol><p id="eb44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了克服上述限制，我们可以使用<code class="fe mb mc md me b">@Input()</code>装饰器。</p><h1 id="5bc9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><code class="fe mb mc md me b">@Input()</code>物业装修工</h1><p id="f037" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">是一个属性装饰器，用在子组件或指令中，表示属性可以从父组件接收它的值。</p><p id="2b4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，对于上面的例子，我们可以重写如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="88ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以上工作正常。与<code class="fe mb mc md me b">@Attribute()</code>不同，它支持所有数据类型，如果您使用<a class="ae ly" href="https://angular.io/guide/property-binding" rel="noopener ugc nofollow" target="_blank">属性绑定</a>或<a class="ae ly" href="https://angular.io/guide/interpolation#text-interpolation" rel="noopener ugc nofollow" target="_blank">文本插值</a>，它还会跟踪值的变化。</p><p id="d742" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还要注意，<code class="fe mb mc md me b">@Input()</code>支持静态和动态两种绑定。</p><p id="48c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">许多内置指令也使用这个装饰器。下面是几个例子:</p><p id="4f3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe mb mc md me b">@Input()</code> decorator的唯一限制是，它的值只有在组件或指令初始化后才可用，即在生命周期钩子中。</p><p id="e11b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们学习了三种读取<code class="fe mb mc md me b">smart-input</code>组件的<code class="fe mb mc md me b">type</code>值的方法，以及如何在一些内置指令和限制中使用它们。让我们再来看看主要的区别:</p><p id="1356" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">可用性</strong></p><ol class=""><li id="e847" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated"><code class="fe mb mc md me b">ElementRef</code>和<code class="fe mb mc md me b">@Attribute()</code>通过依赖注入使属性的值在<code class="fe mb mc md me b">constructor</code>中可用</li><li id="6c11" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><code class="fe mb mc md me b">@Input()</code>使值在组件/指令初始化后可用，即在<code class="fe mb mc md me b">ngOnInit</code>生命周期挂钩中。</li></ol><p id="da37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">型支架</strong></p><ol class=""><li id="05c4" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated"><code class="fe mb mc md me b">ElementRef</code>和<code class="fe mb mc md me b">@Attribute()</code>仅支持<code class="fe mb mc md me b">string</code></li><li id="e163" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><code class="fe mb mc md me b">@Input()</code>支持所有类型</li></ol><p id="2708" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">值更新</strong></p><ol class=""><li id="9ab1" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated"><code class="fe mb mc md me b">ElementRef</code>和<code class="fe mb mc md me b">@Attribute()</code>不跟踪值更新</li><li id="a091" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><code class="fe mb mc md me b">@Input()</code>如果使用了属性绑定或文本插值，则跟踪值更新</li></ol><p id="8fc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一般用法</strong></p><ol class=""><li id="762c" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">由于<code class="fe mb mc md me b">ElementRef</code>和<code class="fe mb mc md me b">@Attribute()</code>只支持<code class="fe mb mc md me b">string</code>类型，它们通常用于读取静态HTML属性的值</li><li id="96c7" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">由于<code class="fe mb mc md me b">@Input()</code>支持所有类型，并且它还跟踪更新，所以它通常用于读取传递给组件/指令的DOM属性或自定义数据</li></ol><h1 id="4968" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="ce2f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们学习了如何使用<code class="fe mb mc md me b">ElementRef</code>类、<code class="fe mb mc md me b">@Attribute()</code>和<code class="fe mb mc md me b">@Input()</code>装饰器读取组件或指令中的HTML属性值。我们还学习了它们的用法，如何在一些内置指令和限制中使用它们。</p><p id="a187" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经为上面的所有代码创建了一个<a class="ae ly" href="https://stackblitz.com/edit/angular-ivy-8cyazj?file=src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank"> stackblitz </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt ma l"/></div></figure></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="2062" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lx">原发布于</em> <a class="ae ly" href="https://indepth.dev/tutorials/angular/get-attribute-value" rel="noopener ugc nofollow" target="_blank"> https://indepth.dev </a>。</p><p id="f268" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lx">更多内容请看</em><a class="ae ly" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>