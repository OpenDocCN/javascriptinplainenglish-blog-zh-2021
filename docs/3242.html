<html>
<head>
<title>6 Lodash Utility Functions that Will Speed Up Your React App Development Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6个Lodash实用程序函数，可加快React应用程序的开发速度</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/6-lodash-utility-functions-that-will-speed-up-your-react-app-development-time-2eb722eecc9d?source=collection_archive---------6-----------------------#2021-07-02">https://javascript.plainenglish.io/6-lodash-utility-functions-that-will-speed-up-your-react-app-development-time-2eb722eecc9d?source=collection_archive---------6-----------------------#2021-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a34d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">有具体的用例以及使用Lodash的例子。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ecc53668b6290bbe034280b0782d01f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KnMVCJADkENLsHnP"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@nhoizey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicolas Hoizey</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2587" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先:<strong class="kv io">什么是Lodash？</strong>我会很简短，以防你已经知道了。</p><p id="6391" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Lodash是一个方便的<a class="ae ks" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">实用程序库</a>。它提供了一些函数来轻松处理数据类型，如对象、数组、数字或字符串。在Lodash的帮助下，您可以在一行简单的代码中执行各种任务。您不必自己实现逻辑，也不必维护这些功能。</p><p id="4ac6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">但是，所有这些贴心的助手功能在现实世界中有哪些用例呢？</strong></p><p id="2b1e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这正是我想在这篇文章中回答的。我搜索了我参与的几个React项目，并提取了Lodash的常见用例。</p><h1 id="9af2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">_.isEqual</h1><p id="e107" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">这是迄今为止使用最多的函数。它比较两个值是否相同。同样，我不是指引用，而是指价值。</p><p id="a4ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如文档中所述，支持许多数据类型:</p><blockquote class="mm mn mo"><p id="94a3" class="kt ku mp kv b kw kx jo ky kz la jr lb mq ld le lf mr lh li lj ms ll lm ln lo ig bi translated">该方法支持比较数组、数组缓冲区、布尔值、日期对象、错误对象、映射、数字、<code class="fe mt mu mv mw b">Object</code>对象、正则表达式、集合、字符串、符号和类型化数组。</p></blockquote><p id="6246" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个功能有大量的用例。您可以确定是否应该更新组件，或者是否应该进行昂贵的计算。</p><p id="7522" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在提供的示例中，您可以看到SearchInput的基本实现。它呈现一个TextField，并接受一个searchValue和一个onChange函数。</p><p id="d84d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为您希望确保SearchInput仅在searchValue已更改时调用onChange方法，所以检查事件值是否不同于searchValue属性是有意义的。如果是这样，就可以调用传递的onChange方法，例如，它可以用新的searchValue作为参数来触发API请求。如果不是这样，就没有必要触发onChange函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7fdc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我知道你可能会说实现TextField组件的库应该确保它只在值改变时才改变。但是安全总比后悔好。</p><h1 id="d176" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">_.去抖</h1><p id="c2be" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">去除函数的抖动可以极大地提高应用程序的性能。该实用程序的最佳用例是搜索字段。在这里，用户可以输入一个值，一些复杂的操作将会发生。例如API请求。如果没有去抖，每次击键都会调用这个函数，这会导致很多不必要的请求。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ab40" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的例子中，您可以看到TextFields onChange方法做了两件事。它更新文本字段本身的值，并执行<strong class="kv io"> callApi </strong>函数。该功能在每次击键时执行。但是多亏了useCallback钩子和Lodash的去抖动功能的帮助，只有在400毫秒内没有出现新的<strong class="kv io"> callApi </strong>调用时，这个函数才会被执行。</p><p id="7cf2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我还有一篇更详细的文章，是关于用一个自我实现的useDebounce钩子去抖动一个搜索字段，这个钩子去抖动值的变化。但是您也可以对函数调用本身进行去抖，以实现类似的行为。</p><div class="mz na gp gr nb nc"><a href="https://bootcamp.uxdesign.cc/how-to-reduce-the-amount-of-expensive-operations-in-text-fields-e8f39a649487" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">如何减少文本字段中昂贵的操作量</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">React组件去抖动值的实用程序</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">bootcamp.uxdesign.cc</p></div></div><div class="nl l"><div class="nm l nn no np nl nq km nc"/></div></div></a></div><h1 id="5186" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">_.设置</h1><p id="9160" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">使用set函数，您可以将对象的属性设置为新值。到目前为止，这听起来不是很特别，但是set函数会自动为您创建不存在的对象和数组，而不会抛出错误。</p><p id="f968" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们来看看它的运行情况。如果我想给用户添加一个新的复杂属性，我可以这样做，如下所示。</p><pre class="kd ke kf kg gt nr mw ns nt aw nu bi"><span id="34e4" class="nv lq in mw b gy nw nx l ny nz">const user = {<br/>  firstname: "Joi",<br/>  lastname: "Schünemann",<br/>  mediumPermissions: { write: true, read: true },<br/>};<br/>_.set(user, "articles[0].views", "over 9000");</span></pre><p id="1580" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这个，物体现在看起来像:</p><pre class="kd ke kf kg gt nr mw ns nt aw nu bi"><span id="14fb" class="nv lq in mw b gy nw nx l ny nz">const user = {<br/>  firstname: "Joi",<br/>  lastname: "Schünemann",<br/>  mediumPermissions: { write: true, read: true },<br/>  articles: [{ views: "over 9000" }],<br/>};</span></pre><p id="15f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您目前不确定属性<strong class="kv io"> articles </strong>是否已经存在，并且想要添加一些信息，这是一个不错的选择。</p><h1 id="2b71" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">_.得到</h1><p id="e674" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">get实用程序提供了从对象获取值的方法。它基本上是set函数的反过来，所以我认为它是不言自明的。</p><p id="1b82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">记住这个例子，下面将把超过9000的<strong class="kv io">返回。如果属性尚未定义，它将返回undefined。</strong></p><pre class="kd ke kf kg gt nr mw ns nt aw nu bi"><span id="c1b6" class="nv lq in mw b gy nw nx l ny nz">_.get(user, "articles[0].views")</span></pre><h1 id="bbd0" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">_.isEmpty</h1><p id="ba91" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">isEmpty函数检查传递的值是空对象还是空数组。听起来很简单，但在某些情况下，有一个快速的方法来检查这一点真的很有帮助。</p><p id="eb2f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在下面的示例中，您可以看到一个按钮，单击该按钮会将一个项目添加到列表中。基于这个列表的状态，应该呈现不同的布局。如果项目数组为空，应显示文本“无显示”，如果数组不为空，可生成不同的组件。</p><p id="3888" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了实现这种区分，我使用了Lodashs isEmtpy函数，如第9行所示。这是实现这种行为的一种简单易读的方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="e438" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">_.克隆深度睡眠</h1><p id="a180" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">这个函数深度克隆一个对象。这意味着创建了一个新的完整的新引用。让我们看看可以用这个功能做些什么。</p><p id="4dbc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我有一个用户对象，我想改变用户的一些属性。例如，名称和写权限已更改。但是我还想保留原始数据(也许以后会重置)，因此直接更改这些值是不可行的。所以我应该创建一个基于旧对象的新用户对象。</p><p id="8e70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在下面的代码示例中，我用spread操作符(…)创建了一个newUser对象，之后，我更改了newUser的名称和权限。</p><pre class="kd ke kf kg gt nr mw ns nt aw nu bi"><span id="60c8" class="nv lq in mw b gy nw nx l ny nz">const user = {<br/>  firstname: "Joi",<br/>  lastname: "Schünemann",<br/>  mediumPermissions: { write: true, read: true },<br/>};<br/>const newUser = { ...user };<br/>newUser.firstname = "Not Joi";<br/>newUser.mediumPermissions.write = false;</span></pre><p id="c990" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将导致以下结果:</p><pre class="kd ke kf kg gt nr mw ns nt aw nu bi"><span id="bd28" class="nv lq in mw b gy nw nx l ny nz">const user = {<br/>  firstname: "Joi",<br/>  lastname: "Schünemann",<br/>  mediumPermissions: { write: false, read: true },<br/>};</span><span id="d392" class="nv lq in mw b gy oa nx l ny nz">const newUser = {<br/>  firstname: "Not Joi",<br/>  lastname: "Schünemann",<br/>  mediumPermissions: { write: false, read: true },<br/>};</span></pre><p id="4103" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，名字按预期更新。旧用户名为“Joi”，新用户名为“Not Joi”。但是，当我们看一看嵌套很深的介质权限的变化时，就出现了问题。旧用户和新用户都没有写权限，即使我们只想更新新用户的权限。</p><p id="45ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我们可以假设我们没有为深度嵌套的值创建新的引用。他们仍然指的是老用户。为了克服这个问题，可以使用cloneDeep函数。</p><pre class="kd ke kf kg gt nr mw ns nt aw nu bi"><span id="a33c" class="nv lq in mw b gy nw nx l ny nz">const user = {<br/>  firstname: "Joi",<br/>  lastname: "Schünemann",<br/>  mediumPermissions: { write: true, read: true },<br/>};<br/>const newUser = _.cloneDeep(user);<br/>newUser.firstname = "Not Joi";<br/>newUser.mediumPermissions.write = false;</span></pre><p id="10be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">尝试完全相同的逻辑，但是用Lodash函数替换spread运算符，结果如下:</p><pre class="kd ke kf kg gt nr mw ns nt aw nu bi"><span id="49e9" class="nv lq in mw b gy nw nx l ny nz">const user = {<br/>  firstname: "Joi",<br/>  lastname: "Schünemann",<br/>  mediumPermissions: { write: true, read: true },<br/>};</span><span id="d67f" class="nv lq in mw b gy oa nx l ny nz">const user = {<br/>  firstname: "Not Joi",<br/>  lastname: "Schünemann",<br/>  mediumPermissions: { write: false, read: true },<br/>};</span></pre><p id="75c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">新老用户看起来完全符合预期。</p><h1 id="2d9c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="3845" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">请随意使用提供的示例进行实验。但是请记住，使用实用程序库的函数并不总是有用或必要的。在使用大量Lodash函数来实现您的结果之前，请考虑您的用例的确切实现。如果您最终一个接一个地用多个Lodash函数操作数据，可能会有更简单的解决方案。</p><p id="03b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望你喜欢我最喜欢的6个Lodash函数和具体的用例。如果您有什么问题，或者您认为我错过了Lodash函数的一个很好的用例，请问我。</p></div><div class="ab cl ob oc hr od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ig ih ii ij ik"><h2 id="0f0b" class="nv lq in bd lr oi oj dn lv ok ol dp lz lc om on mb lg oo op md lk oq or mf os bi translated">进一步阅读</h2><div class="mz na gp gr nb nc"><a href="https://bit.cloud/blog/sharing-javascript-utility-functions-across-projects-l557lr9k" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">跨项目共享JavaScript实用函数</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">所以，你已经建立了这个令人敬畏的效用函数，并花了几个小时在上面。几个月后，你意识到你需要…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">比特云</p></div></div><div class="nl l"><div class="ot l nn no np nl nq km nc"/></div></div></a></div></div><div class="ab cl ob oc hr od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ig ih ii ij ik"><p id="ead2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mp">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mp">plain English . io</em></strong></a><em class="mp">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mp">免费周报</em> </strong> </a> <em class="mp">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mp">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mp">LinkedIn</em></strong></a><em class="mp"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mp">YouTube</em></strong></a><em class="mp"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mp">不和</em> </strong> </a> <em class="mp">。对增长黑客感兴趣？检查</em> <a class="ae ks" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mp">电路</em> </strong> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>