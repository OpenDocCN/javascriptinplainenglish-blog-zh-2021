<html>
<head>
<title>A Brief Guide to Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中承诺的简要指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-brief-guide-to-promises-in-javascript-226f33f5230e?source=collection_archive---------14-----------------------#2021-05-16">https://javascript.plainenglish.io/a-brief-guide-to-promises-in-javascript-226f33f5230e?source=collection_archive---------14-----------------------#2021-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fa08ef5195bc4ff0021aeb5428e64e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-mGE9FjKkWbA22Og"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="929e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript中的<code class="fe ky kz la lb b">Promise</code>是一个在异步操作完成后返回结果的对象。承诺的结果可以是成功，也可以是失败。</p><p id="68ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">承诺有三种状态。</p><ul class=""><li id="ff18" class="lc ld in kc b kd ke kh ki kl le kp lf kt lg kx lh li lj lk bi translated">待定—承诺还没有结果。</li><li id="5428" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">履行——承诺已经完成。</li><li id="a79e" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">拒绝-承诺已被拒绝。</li></ul><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="ce6f" class="ly lz in lb b gy ma mb l mc md">let promise = new Promise((resolve, reject) =&gt; {<br/>    const number = Math.round(Math.random() * 10);<br/>    if(number &lt;= 5) {<br/>        resolve('Success');<br/>    } else {<br/>        reject(new Error('Failed'));<br/>    }<br/>});</span></pre><p id="06b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了创建一个<code class="fe ky kz la lb b">Promise</code>，我们使用带有<code class="fe ky kz la lb b">new</code>关键字的<code class="fe ky kz la lb b">Promise()</code>构造函数。<code class="fe ky kz la lb b">Promise()</code>构造函数接受一个名为“executer”的回调函数，该函数接受两个参数，即resolve和reject。</p><p id="e600" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要在executer函数获得结果时调用<code class="fe ky kz la lb b">resolve()</code>函数，在有错误时调用<code class="fe ky kz la lb b">reject()</code>函数。</p><p id="e62e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，为了使用<code class="fe ky kz la lb b">Promise</code>，我们使用<code class="fe ky kz la lb b">Promise</code>方法，如<code class="fe ky kz la lb b">then()</code>、<code class="fe ky kz la lb b">catch()</code>和<code class="fe ky kz la lb b">finally()</code>。</p><h1 id="59bd" class="me lz in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">Promise.then()</h1><p id="14ec" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated"><code class="fe ky kz la lb b">then()</code>方法可以接受两个回调函数，第一个在<code class="fe ky kz la lb b">Promise</code>被解析时执行，第二个在<code class="fe ky kz la lb b">Promise</code>被拒绝时执行。</p><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="7b20" class="ly lz in lb b gy ma mb l mc md">function getPromise(isTrue) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        if(isTrue) {<br/>            resolve('Success');<br/>        } else {<br/>            reject(new Error('Failed'));<br/>        }<br/>    });<br/>}</span><span id="b648" class="ly lz in lb b gy ng mb l mc md">getPromise(true).then(<br/>    response =&gt; console.log('Promise is resolved with result = ' + response),<br/>    error =&gt; console.log('Promise is rejected with error = ' + error.message)<br/>);<br/>// Promise is resolved with result = Success</span><span id="08df" class="ly lz in lb b gy ng mb l mc md">getPromise(false).then(<br/>    response =&gt; console.log('Promise is resolved with result = ' + response),<br/>    error =&gt; console.log('Promise is rejected with error = ' + error.message)<br/>);<br/>// Promise is rejected with error = Failed</span></pre><p id="6ec0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想分别处理成功和失败的案例，那么我们可以只对成功使用<code class="fe ky kz la lb b">then()</code>，对失败使用<code class="fe ky kz la lb b">catch()</code>。</p><h1 id="122b" class="me lz in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">Promise.catch()</h1><p id="0539" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated"><code class="fe ky kz la lb b">catch()</code>方法采用一个回调函数，当<code class="fe ky kz la lb b">Promise</code>被拒绝时执行该函数。</p><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="d9d9" class="ly lz in lb b gy ma mb l mc md">function getPromise(isTrue) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        if(isTrue) {<br/>            resolve('Success');<br/>        } else {<br/>            reject(new Error('Failed'));<br/>        }<br/>    });<br/>}</span><span id="cd80" class="ly lz in lb b gy ng mb l mc md">getPromise(false)<br/>.then(response =&gt; console.log('Promise is resolved with result = ' + response))<br/>.catch(error =&gt; console.log('Promise is rejected with error = ' + error.message))<br/>// Promise is rejected with error = Failed</span></pre><p id="7ae7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们同时在<code class="fe ky kz la lb b">then()</code>和<code class="fe ky kz la lb b">catch()</code>中处理错误，那么一旦出现错误，只有<code class="fe ky kz la lb b">then()</code>内部的错误处理程序执行，而不是<code class="fe ky kz la lb b">catch()</code>内部的处理程序。</p><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="764b" class="ly lz in lb b gy ma mb l mc md">let promise = new Promise((resolve, reject) =&gt; {<br/>    reject(new Error('An error occurred'));<br/>});</span><span id="91e7" class="ly lz in lb b gy ng mb l mc md">promise.then(null, () =&gt; console.log('Error caught inside then'))<br/>.catch(() =&gt; console.log('Error caught inside catch'))<br/>// Error caught inside then</span></pre><p id="9ca2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果在<code class="fe ky kz la lb b">then()</code>的错误处理器中出现任何错误，那么它将在<code class="fe ky kz la lb b">catch()</code>中被捕获。</p><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="9c3a" class="ly lz in lb b gy ma mb l mc md">let promise = new Promise((resolve, reject) =&gt; {<br/>    reject(new Error('Error occurred in Promise'));<br/>});</span><span id="2b8b" class="ly lz in lb b gy ng mb l mc md">promise.then(null, <br/>    err =&gt; {<br/>        console.log('Error caught inside then, message: ' + err.message);<br/>        throw new Error('Error occured in then');<br/>    })<br/>.catch(err =&gt; {<br/>    console.log('Error caught inside catch, message: ' + err.message);<br/>});</span><span id="eb42" class="ly lz in lb b gy ng mb l mc md">// Error caught inside then, message: Error occurred in Promise<br/>// Error caught inside catch, message: Error occured in then</span></pre><h1 id="7467" class="me lz in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">无极. finally()</h1><p id="557d" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated"><code class="fe ky kz la lb b">finally()</code>方法接受一个回调函数，该函数在<code class="fe ky kz la lb b">Promise</code>被解析或拒绝后执行。</p><h1 id="e630" class="me lz in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">论成功</h1><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="5c2f" class="ly lz in lb b gy ma mb l mc md">let promise = new Promise((resolve, reject) =&gt; {<br/>    resolve('Success');<br/>});</span><span id="f959" class="ly lz in lb b gy ng mb l mc md">promise.then(res =&gt; console.log(res))<br/>.catch(err =&gt; console.log(err.message))<br/>.finally(() =&gt; console.log('Executing Finally'));<br/>// Success<br/>// Executing Finally</span></pre><h1 id="b083" class="me lz in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">失败时</h1><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="2864" class="ly lz in lb b gy ma mb l mc md">let promise = new Promise((resolve, reject) =&gt; {<br/>    reject(new Error('Failed'));<br/>});</span><span id="7141" class="ly lz in lb b gy ng mb l mc md">promise.then(res =&gt; console.log(res))<br/>.catch(err =&gt; console.log(err.message))<br/>.finally(() =&gt; console.log('Executing Finally'));<br/>// Failed<br/>// Executing Finally</span></pre><h1 id="64ff" class="me lz in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">承诺链</h1><p id="9399" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated">我们可以通过链接方法<code class="fe ky kz la lb b">then()</code>、<code class="fe ky kz la lb b">catch()</code>和<code class="fe ky kz la lb b">finally()</code>一个接一个地执行一系列异步操作。</p><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="a346" class="ly lz in lb b gy ma mb l mc md">takeOrder()<br/>.then(order =&gt; makeOrder(order))<br/>.then(order =&gt; serveOrder(order))<br/>.then(status =&gt; console.log(status))<br/>.catch(err =&gt; console.log(err));</span></pre><p id="4680" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里<code class="fe ky kz la lb b">takeOrder()</code>将返回一个在第一个<code class="fe ky kz la lb b">then()</code>方法中使用的<code class="fe ky kz la lb b">Promise</code>。<code class="fe ky kz la lb b">makeOrder()</code>将返回一个将在第二个<code class="fe ky kz la lb b">then()</code>方法中消耗的<code class="fe ky kz la lb b">Promise</code>，而<code class="fe ky kz la lb b">serveOrder()</code>将再次返回一个将在第三个<code class="fe ky kz la lb b">then()</code>方法中消耗的<code class="fe ky kz la lb b">Promise</code>。如果任何承诺中出现任何错误，那么它将在<code class="fe ky kz la lb b">catch()</code>方法中被捕获。</p><h1 id="5339" class="me lz in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">Promise.all()</h1><p id="f233" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated"><code class="fe ky kz la lb b">Promise.all()</code>方法将一个可重复的承诺作为输入，并返回一个<code class="fe ky kz la lb b">Promise</code>，当所有承诺都被解析或其中任何一个被拒绝时，该方法被解析。</p><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="a0f9" class="ly lz in lb b gy ma mb l mc md">function getPromise(delay) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        setTimeout(() =&gt; {<br/>            resolve(delay + 100);<br/>        }, delay);<br/>    })<br/>}</span><span id="5c6f" class="ly lz in lb b gy ng mb l mc md">Promise.all([getPromise(1000), getPromise(3000), getPromise(2000)])<br/>.then(responses =&gt; console.log(responses))<br/>.catch(error =&gt; console.log(error));</span></pre><h1 id="77a7" class="me lz in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">承诺.竞赛()</h1><p id="3576" class="pw-post-body-paragraph ka kb in kc b kd nb kf kg kh nc kj kk kl nd kn ko kp ne kr ks kt nf kv kw kx ig bi translated"><code class="fe ky kz la lb b">Promise.race()</code>方法接受一个可重复的承诺，并返回一个<code class="fe ky kz la lb b">Promise</code>,一旦任何承诺被解析或拒绝，该方法就会被解析/拒绝。</p><pre class="lq lr ls lt gt lu lb lv lw aw lx bi"><span id="37ff" class="ly lz in lb b gy ma mb l mc md">let promise1 = new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>        resolve('Promise 1');<br/>    }, 1000);<br/>});</span><span id="7e01" class="ly lz in lb b gy ng mb l mc md">let promise2 = new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>        resolve('Promise 2');<br/>    }, 500);<br/>});</span><span id="9629" class="ly lz in lb b gy ng mb l mc md">Promise.race([promise1, promise2])<br/>.then(res =&gt; console.log(res)) // Promise 2<br/>.catch(err =&gt; console.log(err));</span></pre></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><h2 id="8fcb" class="ly lz in bd mf no np dn mj nq nr dp mn kl ns nt mr kp nu nv mv kt nw nx mz ny bi translated">你可能也喜欢</h2><ul class=""><li id="d0ad" class="lc ld in kc b kd nb kh nc kl nz kp oa kt ob kx lh li lj lk bi translated"><a class="ae jz" href="https://jscurious.com/understanding-async-and-await-in-javascript/" rel="noopener ugc nofollow" target="_blank">理解JavaScript中的异步和等待</a></li><li id="3f68" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated"><a class="ae jz" href="https://jscurious.com/callback-functions-in-javascript/" rel="noopener ugc nofollow" target="_blank">JavaScript中的回调函数</a></li><li id="b13a" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated"><a class="ae jz" href="https://jscurious.com/html-datalist-tag-for-filter-search/" rel="noopener ugc nofollow" target="_blank">用于过滤器搜索的HTML数据列表标签</a></li><li id="0c2a" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated"><a class="ae jz" href="https://jscurious.com/javascript-fetch-api-to-make-http-requests/" rel="noopener ugc nofollow" target="_blank"> JavaScript获取API进行HTTP请求</a></li><li id="aaf7" class="lc ld in kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated"><a class="ae jz" href="https://jscurious.com/20-javascript-shorthand-techniques-that-will-save-your-time/" rel="noopener ugc nofollow" target="_blank"> 20种节省你时间的JavaScript速记编码技巧</a></li></ul><p id="7bba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="oc">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="oc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>