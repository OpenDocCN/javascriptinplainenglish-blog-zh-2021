<html>
<head>
<title>How to Integrate Object Storage into your Web Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将对象存储集成到您的Web应用程序中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-integrate-object-storage-for-your-web-application-f0fc0d0de8d3?source=collection_archive---------14-----------------------#2021-04-16">https://javascript.plainenglish.io/how-to-integrate-object-storage-for-your-web-application-f0fc0d0de8d3?source=collection_archive---------14-----------------------#2021-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0aec6f51de26f53558804da9aace092c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DF7JukSxr8sdE34Z.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ruchindra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ruchindra Gunasekara</a> on Unsplash</figcaption></figure><p id="bc95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，您想创建一个web应用程序，但是您有大量的数据需要有效地组织和存储？你只需要这篇文章。</p><p id="75ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你错过了最近的技术趋势，<a class="ae kc" href="http://lakefs.io/object-storage/" rel="noopener ugc nofollow" target="_blank">对象存储</a>是一个概念，它产生于为大数据提供更好的数据存储的需求。通过这种形式的存储，数据作为“对象”存储在平面层次结构中，您可以保持数据的质量，同时使其易于通过唯一的元数据进行检索。听起来很有希望？</p><p id="099c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您已经知道这是什么，那么您可能正在尝试将它集成到您的web应用程序中。因此，在本文中，您将找到一系列代码示例来帮助您开始使用这种类型的架构，并使其更容易集成到您的应用程序中。</p><p id="fa04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在整篇文章中，我们将使用JavaScript (Node.js)作为编程语言，但是因为大多数对象存储都是S3兼容的，所以我们将依赖官方的<a class="ae kc" href="https://docs.aws.amazon.com/cdk/api/latest/python/aws_cdk.aws_s3/README.html" rel="noopener ugc nofollow" target="_blank">亚马逊S3库</a>来与这种类型的架构进行交互。这提供了一个通用性——因为我们可以改变云提供商而不必改变代码级别——并且更容易集成，不管我们使用什么语言。</p><h2 id="26ee" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">先决条件</h2><p id="d720" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">要运行这些示例，我们需要安装Node.js以及<code class="fe lz ma mb mc b">aws-sdk</code> NPM <a class="ae kc" href="https://www.npmjs.com/package/aws-sdk" rel="noopener ugc nofollow" target="_blank">模块</a>和一个新的<strong class="kf ir"> index.js </strong>文件，其内容如下:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="a1ac" class="lb lc iq mc b gy ml mm l mn mo">const AWS = require("aws-sdk");<br/>const { promises: fsPromise } = require("fs");</span></pre><h2 id="f78d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">连接到对象存储</h2><p id="d724" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">要使用代码访问对象存储，您需要一个API键及其端点。您可以在云提供商的仪表板中轻松找到这些信息。一旦有了它们，您就可以启动一个新的AWS S3客户端，该客户端将用于针对对象存储运行命令。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/84618b4b884f9bb3a13afd42ba3bd01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*akVuRfvtyeArqIaW.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=const%2520s3Client%2520%253D%2520new%2520AWS.S3%28%257B%250A%2520%2520endpoint%253A%2520%2522your_endpoint%2522%252C%250A%2520%2520secretAccessKey%253A%2520%2522your_secret_key%2522%252C%250A%2520%2520accessKeyId%253A%2520%2522your_access_key%2522%252C%250A%257D%29%253B" rel="noopener ugc nofollow" target="_blank">RAW</a></figcaption></figure><p id="f8ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有PING命令来验证您的应用程序是否可以与对象存储通信，但是作为一种变通方法，您可以通过执行一个简单的请求来测试这一点，比如列出其中的存储桶。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/0cfc96a2867dac45973ad048ef2513b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UU0CCIrlu_V-333-.png"/></div></div></figure><p id="d5f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的另一个选项是使用<code class="fe lz ma mb mc b">headBucket</code>函数。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/f14348b0d10e5eddb404f52fbd892902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dnp86MfRQNtyQw-H.png"/></div></div></figure><p id="9d11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据AWS文件:</p><p id="6609" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此操作有助于确定存储桶是否存在，以及您是否有访问它的权限。如果存储桶存在，并且您有访问它的权限，该操作将返回200 OK。否则，该操作可能会返回诸如404未找到和403禁止之类的响应。</p><h2 id="3413" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">上传文件</h2><p id="8dc8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">要上传文件，您需要3条信息:</p><ul class=""><li id="f5d4" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">目标存储桶的名称</li><li id="753a" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">对象关键字(这是用来保存对象的关键字，可以是文件名)</li><li id="bb76" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">文件的<code class="fe lz ma mb mc b">Body</code>(可以是缓冲区或流)</li></ul><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/618a6963859d742e9fc3e95ca5ab6316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RMeo80Cbr14ay_Vh.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%2520%2520const%2520buffer%2520%253D%2520await%2520fsPromise.readFile%28%2522.%252Fsea.jpg%2522%29%253B%250A%2520%2520const%2520params%2520%253D%2520%257B%250A%2520%2520%2520%2520Bucket%253A%2520bucket%252C%250A%2520%2520%2520%2520Key%253A%2520%2522sea.jpg%2522%252C%250A%2520%2520%2520%2520Body%253A%2520buffer%252C%250A%2520%2520%257D%253B%250A%250A%2520%2520await%2520s3Client.upload%28params%29.promise%28%29%253B" rel="noopener ugc nofollow" target="_blank">RAW</a></figcaption></figure><p id="11a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，这里的<code class="fe lz ma mb mc b">Key</code>匹配文件名以反映正在上传的文件，但是这里的<code class="fe lz ma mb mc b">Key</code>可以有任何字符串值。</p><h2 id="2ca7" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">上传文件夹</h2><p id="7461" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在前面的例子中，我们硬编码了对象<code class="fe lz ma mb mc b">Key</code>来匹配文件名，但是如果我们想要进行批量上传，比如上传整个文件夹，该怎么办呢？</p><p id="e550" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对象存储中，不像传统的基于文件夹的存储，没有文件夹的概念。</p><p id="719b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以通过为对象键提供前缀来模拟这种情况。</p><p id="7ab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以上传一个带有关键字<code class="fe lz ma mb mc b">my-files/image.jpg</code>的对象，然后使用这个前缀<code class="fe lz ma mb mc b">my-files</code>来模仿一个文件夹结构。</p><p id="6e6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个文件夹<code class="fe lz ma mb mc b">my-files</code>,我们想上传到我们的对象存储，我们想保持这个结构。因此，我们使用<code class="fe lz ma mb mc b">my-files/one.txt</code>、<code class="fe lz ma mb mc b">my-files/two.txt</code>和<code class="fe lz ma mb mc b">my-files/folder-two/sea.jpg</code>键上传文件，而不是使用<code class="fe lz ma mb mc b">one.txt</code>、<code class="fe lz ma mb mc b">two.txt</code>和<code class="fe lz ma mb mc b">sea.jpg</code>键上传文件。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/22b84f94fc63152f14df834c8f00cde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/0*6cpHegV2Jn0qtNk8.PNG"/></div></figure><p id="145e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">借助这两个模块，我们可以很容易地做到这一点:<a class="ae kc" href="https://www.npmjs.com/package/upath" rel="noopener ugc nofollow" target="_blank"> upath </a>和<a class="ae kc" href="https://www.npmjs.com/package/dir-fs-utils" rel="noopener ugc nofollow" target="_blank"> dir-fs-utils </a>。在这里，我们将使用它们来列出一个文件夹的全部内容，然后将路径转换为UNIX，因为这就是对象前缀应该的样子。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/bae6c7c00a121d1498bc9a21350f1949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WATrwnm2U_Ub2567.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=const%2520%257B%2520promises%253A%2520fsPromise%2520%257D%2520%253D%2520require%28%2522fs%2522%29%253B%250Aconst%2520AWS%2520%253D%2520require%28%2522aws-sdk%2522%29%253B%250A%250Aconst%2520%257B%2520DirUtils%2520%257D%2520%253D%2520require%28%2522dir-fs-utils%2522%29%253B%250Aconst%2520upath%2520%253D%2520require%28%2522upath%2522%29%253B%250A%250Aasync%2520uploadFolder%28s3Client%252C%2520folderPath%29%257B%250A%2520%2520const%2520files%2520%253D%2520await%2520DirUtils.listFolderContent%28folderPath%29%253B%250A%250A%2520%2520Promise.all%28%250A%2520%2520%2520%2520files.map%28async%2520%28filePath%29%2520%253D%253E%2520%257B%250A%2520%2520%2520%2520%2520%2520const%2520buffer%2520%253D%2520await%2520fsPromise.readFile%28filePath%29%253B%250A%250A%2520%2520%2520%2520%2520%2520const%2520params%2520%253D%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520Bucket%253A%2520bucket%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520Key%253A%2520upath.toUnix%28filePath%29%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520Body%253A%2520buffer%252C%250A%2520%2520%2520%2520%2520%2520%257D%253B%250A%250A%2520%2520%2520%2520%2520%2520await%2520s3Client.upload%28params%29.promise%28%29%253B%250A%2520%2520%2520%2520%257D%29%250A%2520%2520%29%253B%250A%257D" rel="noopener ugc nofollow" target="_blank">RAW</a></figcaption></figure><h2 id="08ae" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">上传大文件</h2><p id="a336" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">到目前为止，我们使用一个物体作为缓冲。即使这对于小文件来说完全没问题，但对于大文件来说就不行了。</p><p id="a25b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缓冲区的问题是，当文件被读取时，文件的完整内容被保存在内存中。更简单地说，如果我们有一个Node.js应用程序试图加载一个200 MB的文件，那么在上传文件时，该应用程序的RAM使用量将增加200 MB。在大多数情况下，NodeJS进程会崩溃，因为超过了最大内存使用量。</p><p id="13fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最佳实践是对大于5MB的文件使用多部分上传。</p><p id="0c67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，AWS S3图书馆现在有一个<code class="fe lz ma mb mc b">ManagedUpload</code>在幕后为我们处理这种多部分上传。我们所要做的就是提供一些选项和一个可消耗的阅读流。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/c8f23573d561191f5955bd4e7234288a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0ck9_xEVDAxvdywi.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=async%2520function%2520localToS3%28payload%252C%2520progressCb%29%2520%257B%250A%2520%2520return%2520new%2520Promise%28%28resolve%252C%2520reject%29%2520%253D%253E%2520%257B%250A%2520%2520%2520%2520const%2520stream%2520%253D%2520fs.createReadStream%28payload.filePath%29%253B%250A%250A%2520%2520%2520%2520stream%250A%2520%2520%2520%2520%2520%2520.on%28%2522error%2522%252C%2520%28err%29%2520%253D%253E%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520return%2520reject%28err%29%253B%250A%2520%2520%2520%2520%2520%2520%257D%29%250A%250A%2520%2520%2520%2520%2520%2520.on%28%2522data%2522%252C%2520%28chunk%29%2520%253D%253E%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520if%2520%28progressCb%29%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520progressCb%28chunk.length%29%253B%250A%2520%2520%2520%2520%2520%2520%2520%2520%257D%250A%2520%2520%2520%2520%2520%2520%257D%29%253B%250A%250A%2520%2520%2520%2520const%2520params%2520%253D%2520%257B%250A%2520%2520%2520%2520%2520%2520Bucket%253A%2520payload.bucket%252C%250A%2520%2520%2520%2520%2520%2520Key%253A%2520payload.fileKey%252C%250A%2520%2520%2520%2520%2520%2520Body%253A%2520stream%252C%250A%2520%2520%2520%2520%257D%253B%250A%250A%2520%2520%2520%2520const%2520options%2520%253D%2520%257B%2520partSize%253A%25205%2520*%25201024%2520*%25201024%252C%2520queueSize%253A%25204%2520%257D%253B%250A%250A%2520%2520%2520%2520payload.s3Client.upload%28params%252C%2520options%252C%2520%28err%252C%2520data%29%2520%253D%253E%2520%257B%250A%2520%2520%2520%2520%2520%2520if%2520%28err%29%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520return%2520reject%28err%29%253B%250A%2520%2520%2520%2520%2520%2520%257D%250A%2520%2520%2520%2520%2520%2520return%2520resolve%28data%29%253B%250A%2520%2520%2520%2520%257D%29%253B%250A%2520%2520%257D%29%253B" rel="noopener ugc nofollow" target="_blank">RAW</a></figcaption></figure><p id="8df9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将给定的文件分割(读取)成5 MB的块，并上传这些队列大小为4的块。这意味着将同时加载4个部分，每个部分为5 MB。从理论上讲，使用这段代码，我们上传的每个文件的RAM使用量最多会增加20 MB。</p><p id="2dfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同时，如果我们想监控这个上传进度，我们可以提供一个<code class="fe lz ma mb mc b">progressCallback</code>。请注意，在本例中，进度是在从流中读取零件时测量的。</p><h2 id="a3a1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">铲斗生命周期配置</h2><p id="4ad0" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果你正在上传一个文件到对象存储器，而你的上传由于某种原因被中断了，会发生什么？</p><p id="ad55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你加载一个缓冲区，那么这就不是问题，但是如果你进行多部分上传，那么已经上传的部分将保留在桶中，并占据那个空间。</p><p id="53cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据提供者的不同，您可能会在仪表板中看到空间已被占用，但看不到相应的对象。这是因为上传尚未完成。</p><p id="7f9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了缓解这个问题，您可以实施一些bucket生命周期配置，比如<code class="fe lz ma mb mc b">AbortIncompleteMultipartUpload</code>。</p><p id="f322" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以直接从仪表板进行配置。如果仪表板没有提供这个选项，您可以通过API来完成。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/8429b03fcb079d95afc87b3361e12a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FvqM7ihpuwC9c_Xv.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=await%2520s3Client%250A%2520%2520.putBucketLifecycle%28%257B%250A%2520%2520%2520%2520Bucket%253Abucket%252C%250A%2520%2520%2520%2520LifecycleConfiguration%253A%2520%257B%250A%2520%2520%2520%2520%2520%2520Rules%253A%2520%255B%250A%2520%2520%2520%2520%2520%2520%2520%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520AbortIncompleteMultipartUpload%253A%2520%257B%2520DaysAfterInitiation%253A%25201%2520%257D%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520Prefix%253A%2520%27%27%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520Status%253A%2520%27Enabled%27%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520%257D%252C%250A%2520%2520%2520%2520%2520%2520%255D%252C%250A%2520%2520%2520%2520%257D%252C%250A%2520%2520%257D%29%250A%2520%2520.promise%28%29%253B" rel="noopener ugc nofollow" target="_blank">RAW</a></figcaption></figure><p id="ef70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上配置将在1天后中止不完整的多部分上传。</p><h2 id="eae7" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">对象元数据</h2><p id="11de" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对象存储的最大优势之一是可以分配给对象的元数据。</p><p id="476c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个元数据可以是一个与您想要提供的信息配对的<code class="fe lz ma mb mc b">key-value</code>。</p><p id="4a60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了这些元数据，您还可以配置<code class="fe lz ma mb mc b">ACL</code>、<code class="fe lz ma mb mc b">ContentType</code>等等。默认情况下，对象上传为<code class="fe lz ma mb mc b">private</code>，并且<code class="fe lz ma mb mc b">ContentType</code>设置为<code class="fe lz ma mb mc b">application/octet-stream</code>。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/19ba22dba698512dfab24e86d1722fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DFPuBkGHe8y82hKW.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=seti&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=const%2520%257B%2520lookup%2520%257D%2520%253D%2520require%28%2522mime-types%2522%29%253B%250A%250Aconst%2520filePath%2520%253D%2520%2522.%252Fsea.jpg%2522%253B%250Aconst%2520buffer%2520%253D%2520await%2520fsPromise.readFile%28filePath%29%253B%250Aconst%2520params%2520%253D%2520%257B%250A%2520%2520Bucket%253A%2520bucket%252C%250A%2520%2520Key%253A%2520%2522sea.jpg%2522%252C%250A%2520%2520Body%253A%2520buffer%252C%250A%2520%2520ACL%253A%2520%2522public-read-write%2522%252C%250A%2520%2520ContentType%253A%2520lookup%28filePath%29%252C%250A%250A%2520%2520Metadata%253A%2520%257B%250A%2520%2520%2520%2520location%253A%2520%2522Sri%2520Lanka%2522%252C%250A%2520%2520%2520%2520dayTime%253A%2520%2522morning%2522%252C%250A%2520%2520%257D%252C%250A%257D%253B" rel="noopener ugc nofollow" target="_blank">RAW</a></figcaption></figure><h2 id="86b1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">添加内容交付网络(CDN)</h2><p id="52c5" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">大多数云提供商为他们的对象存储架构提供CDN。根据具体情况，这可以是免费的，也可以是付费的。如果您的应用程序基于交付大量静态内容，例如用户上传的照片，CDN将大大提高内容的下载速度。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/539563f795ced0ec7a6cc25bdda8d9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Sc0qYpVlbo7jR32.PNG"/></div></div></figure><h2 id="bc82" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="e97c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对象存储是存储和管理非结构化数据以提高应用程序速度的最佳方式之一，现在，在本文的帮助下，您也可以加快集成速度。</p><p id="b919" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nm">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nm">plain English . io</em></a></p></div></div>    
</body>
</html>