<html>
<head>
<title>How to Pass Data between Native and JavaScript using React Native Bridge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React Native Bridge在Native和JavaScript之间传递数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/passing-data-between-native-and-js-using-react-native-bridge-34e783c0b2f8?source=collection_archive---------3-----------------------#2021-06-05">https://javascript.plainenglish.io/passing-data-between-native-and-js-using-react-native-bridge-34e783c0b2f8?source=collection_archive---------3-----------------------#2021-06-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bf778b682798c6eed407783d6d1e28f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBuwz41_ZkZDESY1io-h7Q.jpeg"/></div></div></figure><p id="c25f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我要说的是，在JavaScript和我们的本地代码之间架起一座桥梁是React本地框架给我们的最好的灵活性之一。大多数开发人员或团队可能会遇到这样的情况:找不到合适的npm模块，或者没有足够的时间为用例创建npm模块。这里，桥的实现就派上了用场。</p><p id="1959" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们希望在React Native项目中使用任何本机API或任何其他用本机语言编写的SDK，我们可以利用React本机桥并在本机端实现它，并使用本机和JavaScript之间的桥进行双向数据流。</p><p id="8698" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如官方文件中提到的，有许多方法可以在两个世界之间传递数据。我们将看到以下3种相同的方法。</p><p id="f5a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.承诺<br/> 2。回调<br/> 3。事件发射器</p><p id="0253" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我选择了<strong class="jx io"> ConnectSDK </strong>作为原生SDK在原生端(Android和iOS)实现。Connect SDK是一个开源框架，将您的移动应用程序与多个媒体设备平台连接起来。我们将在本机端实现一些API，并将其发送到JavaScript端，同时，我们将从JavaScript端向本机端传递一些数据。</p><h1 id="d513" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">第一步</h1><p id="07fb" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在下面链接的帮助下创建一个React本地项目。</p><div class="lw lx gp gr ly lz"><a href="https://reactnative.dev/docs/environment-setup" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">设置开发环境</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">该页面将帮助您安装和构建您的第一个React本机应用程序。如果您是移动开发的新手，那么…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">反应性发展</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn jt lz"/></div></div></a></div><p id="8bca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从App.js中移除默认代码并添加您自己的组件，或者您可以添加以下代码。我添加了一个简单的堆栈导航屏幕。为此，您必须安装节点模块“@react-navigation/native”和“@react-navigation/stack”。有关react-navigation的更多详情，请点击以下链接。</p><p id="875b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">【https://reactnavigation.org/docs/getting-started/ T4】</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="49b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，尝试在android <em class="mv"> </em>中使用<em class="mv">npx react-native run-Android</em>，在ios中使用<em class="mv"> npx react-native run-ios </em>运行应用。</p><h1 id="c177" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第二步</strong></h1><p id="3ba3" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">集成ConnectSDK(如果您正在使用其他SDK，可以跳过这一步)</p><p id="83ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">安卓</strong></p><p id="59b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将这一行添加到您的应用程序build.gradle并同步gradle</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b440" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">添加必要的权限。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6892" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们必须在Android项目中创建两个java文件。一个是本地模块类，我们将在其中编写可以与JavaScript端通信的方法，另一个文件是React包，我们将在其中注册这个本地模块。然后，这个包将被添加到MainApplication.java文件中的ReactNativeHost。</p><p id="5ed9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在你的android根目录下创建ConnectSDKNative.java和ConnectSDKNativePackage.java。您可以根据您选择的SDK来命名您的模块。在各自的文件中添加以下代码行。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="65bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Android中所有的Java原生模块都需要实现<code class="fe mw mx my mz b">getName()</code>方法。此方法返回一个字符串，该字符串表示本机模块的名称。然后，可以在JavaScript中使用本机模块的名称来访问它。例如，上面的代码片段<code class="fe mw mx my mz b">getName()</code>返回<code class="fe mw mx my mz b">"ConnectSDKNative"</code>。您可以用您的模块名替换它。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f124" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将包添加到MainApplication.java get packages()列表。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0f65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在MainApplication.java添加下面一行，用于启动设备发现。</p><pre class="mp mq mr ms gt na mz nb nc aw nd bi"><span id="b551" class="ne ku in mz b gy nf ng l nh ni">DiscoveryManager.<em class="mv">init</em>(getApplicationContext());</span></pre><p id="3c15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在ConnectSDK的初始设置已经完成。</p><h1 id="a919" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">第三步</h1><p id="baef" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">设置JavaScript端</p><p id="35ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们已经完成了java和iOS原生端的集成，让我们在JavaScript端做一些UI添加。我将创建一个简单的UI，带有一个启动设备发现的按钮和一个显示发现项目的列表。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6a5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的补丁中，const { ConnectSDKNative } = native modules让JavaScript可以访问本机模块。使用它，我们可以调用将要在本地模块中编写的方法。</p><h1 id="a76d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第四步</strong></h1><p id="fb6d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">实现本机方法并将其公开给JavaScript。</p><p id="676b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前所述，我们可以根据Java和JavaScript之间的通信需求使用承诺、回调或事件发射器。</p><ol class=""><li id="a3a7" class="nj nk in jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">首先我们来看<strong class="jx io">回调</strong>的案例。对于异步方法，回调用于将数据从Java传递到JavaScript。它们还可以用于从本机异步执行JavaScript。在你的函数参数中我们只能有两个回调——一个successCallback和一个failureCallback。此外，本机模块方法调用的最后一个参数(如果是函数)被视为successCallback，而本机模块方法调用的倒数第二个参数(如果是函数)被视为failure callback。如果JS要发送任何参数，我们可以在回调之前添加它们。</li></ol><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ba13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意的一个重要细节是，本机模块方法一次只能调用一个回调。这意味着您可以调用成功回调或失败回调，但不能同时调用两者，并且每个回调最多只能调用一次。</p><p id="9d33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript方面，我们将编写代码来调用该方法并接收其回调。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="105e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.现在我们将使用<strong class="jx io">承诺</strong>。承诺可以根据成功和失败来解决和拒绝方法调用。Reject方法可以有不同的参数，如错误代码、消息、WriteableMap对象。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2a01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个控制台日志将打印使用Promise从Java端传递的消息。</p><p id="0c52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.<strong class="jx io">事件发射器</strong>是我们在Java和JavaScript之间传输数据的第三个选择。在这种情况下，我们不必创建ReactMethod并调用它。从本机端，我们将发出事件/信号，这些事件/信号将被我们在JS端编写的Javascript代码监听。由React Native给出的<em class="mv"> NativeEventEmitter </em>将帮助我们监听这些事件。它有一个<em class="mv"> addlistener </em>方法，我们将在其中指定事件名称，并捕获函数调用中的传入数据。而在Java端，<em class="mv"> RCTNativeAppEventEmitter </em>类帮助发出这些事件和数据。在Android中需要注意的另一点是，我们不能将Java数据类型直接转移到JavaScript端。我们需要用Javascript能够理解的方式包装它。react桥为我们提供了助手类，如<em class="mv"> WriteableMap </em>、<em class="mv"> WriteableArray、</em>等。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2585" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在将自定义对象添加到事件发出方法之前，我们必须将其转换为WriteableMap。您可以在本文末尾的GitHub链接中找到helper方法。此外，如果你想参考整个项目的源代码，你可以去相同的GitHub链接。</p><p id="cdad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那都是乡亲们！！这是相当多的编码，对不对？但是相信我，一旦你得到它，它真的很有趣。目前，这是只有Android集成。我正在做iOS原生代码添加。很快，我将在本文中添加这一点。</p><p id="edba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这篇文章有用，请留下一些掌声。这将是我做出更多贡献的巨大动力。祝编码愉快！</p><div class="lw lx gp gr ly lz"><a href="https://github.com/mohitau/RNBridgeAWSSample" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">mohitau/RNBridgeAWSSample</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">在GitHub上创建一个帐户，为mohitau/RNBridgeAWSSample开发做贡献。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="ns l mk ml mm mi mn jt lz"/></div></div></a></div><p id="7fab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mv">更多内容请看</em><a class="ae mo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mv">plain English . io</em></a></p></div></div>    
</body>
</html>