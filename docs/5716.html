<html>
<head>
<title>Build a simple text-to-speech app with the Web Speech API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web语音API构建一个简单的文本到语音转换应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-simple-text-to-speech-app-with-the-web-speech-api-7a6303ff4f9?source=collection_archive---------9-----------------------#2021-12-02">https://javascript.plainenglish.io/build-a-simple-text-to-speech-app-with-the-web-speech-api-7a6303ff4f9?source=collection_archive---------9-----------------------#2021-12-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/503f1fcee729ae0c0a7bc7c7f9bb513f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jyIaaluD7Qud9bUR"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@santesson89?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrea De Santis</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e6ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有没有想过构建自己的屏幕阅读器会是什么样子？有了Web Speech API，这是一个可以实现的任务。在本文中，我们将构建一个基本的文本到语音阅读器，同时探索一些我们也可以使用的其他功能。然而，这种技术也有一些丑陋的缺点，但是我们将继续探索这些缺点。现在，让我们来看看这项技术是什么，我们可以用它做什么。</p><h1 id="c1b8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">网络语音API 🗣</h1><p id="a2f5" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Web语音API是由浏览器提供的音频接口，用于处理音频输入和输出。这意味着，虽然我们将主要关注音频输出特性，作为本文的一部分，但我们也可以通过单独的<code class="fe mb mc md me b">SpeechRecognition</code>输入控制器来完成语音识别等任务。Web Speech API公开了一个<code class="fe mb mc md me b">SpeechSynthesis</code>控制器，它为我们提供了一些基本的定制选项来设置我们的音频文本阅读器。</p><h1 id="2123" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">和睦相处🤷🏽‍♂️</h1><p id="b26d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">虽然Web Speech API已经出现了一段时间，但它并不与所有浏览器兼容。事实上，目前，整个Web Speech API整体上还处于实验阶段。这意味着虽然这些解决方案现在可以工作，但是API可能会在将来发生变化，导致不必要的错误。基本上，您可以自行决定使用这个API，如果您想避免这些问题，就不要将它包含在产品代码中。在这一点上，<code class="fe mb mc md me b">SpeechSynthesis</code> API比<code class="fe mb mc md me b">SpeechRecognition</code> API支持更多的浏览器。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/a43df2a006326f67cc0150d93c9fce65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3pl40w5j991JiVXK"/></div></div></figure><h1 id="5248" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们将会建造什么</h1><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/50fd1e6b04e0b1fda6248b7db68f5de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/0*dVRfRveawn5RwFt4"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">animated text to speech player</figcaption></figure><p id="5d4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用<code class="fe mb mc md me b">SpeechSynthesis API</code>和React构建一个简单的阅读器。你可以只用JavaScript来做这个，但是这并不有趣。CodeSandbox示例的代码将在本文末尾，以防您遇到困难。该应用程序将执行以下操作:</p><ul class=""><li id="0c9b" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">显示一个播放按钮，允许用户听到音频提要</li><li id="4a65" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">展开以显示自开始读取以来经过的时间</li><li id="4c0d" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">如果再次按下播放按钮或完成阅读，则关闭</li><li id="fa2f" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">播放时显示小动画</li><li id="74ea" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">清理<code class="fe mb mc md me b">SpeechSynthesis</code>以确保它不会导致内存泄漏</li></ul><h1 id="ab00" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">入门指南</h1><p id="6072" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">本文将假设您已经安装了节点/NPM。如果您不确定，请打开终端并键入以下内容，然后检查输入后的结果:</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="76f7" class="nd kz in me b gy ne nf l ng nh">$npm -v</span></pre><p id="cfc1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这应该会显示您当前的npm版本。如果您在这里看到一个错误，那么您需要转到Node.js网站，并按照那里的安装说明进行操作。Npm将与Node打包在一起。</p><p id="07ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你们都很好，那么我们可以继续创建我们的React应用程序。让我们从创建React应用程序脚本开始。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="3dd7" class="nd kz in me b gy ne nf l ng nh">$npx create-react-app text-reader<br/># or<br/>$yarn create react-app text-reader</span><span id="7788" class="nd kz in me b gy ni nf l ng nh"># if you would like to use TypeScript<br/>$npx create-react-app my-app --template typescript</span></pre><p id="0924" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将创建一个名为<code class="fe mb mc md me b">text-reader</code>的项目，其中将包含我们所有的基本React代码以及一些示例代码。我将在我的项目中使用CodeSandbox，所以一些样板代码看起来会有所不同，但最终是一样的。要运行您的应用程序并查看它在本地环境中的加载情况，请在您的终端中运行以下脚本:</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="da2a" class="nd kz in me b gy ne nf l ng nh">$npm run start</span></pre><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/2ee00995e379b1b0da47e3bd5c568890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SIzQzWYxMf8fMixh"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">App.tsx in CodeSandbox</figcaption></figure><p id="e027" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不熟悉React，没关系，因为我们将更详细地介绍我们的步骤。现在，找到您的<code class="fe mb mc md me b">App.js</code>和<code class="fe mb mc md me b">styles.css</code>文件，用下面的代码替换组件中的所有样板代码。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="f496" class="nd kz in me b gy ne nf l ng nh">import "./styles.css";</span><span id="18a1" class="nd kz in me b gy ni nf l ng nh">export default function App() {<br/>  return (<br/>    &lt;div className="reader_wrapper"&gt;<br/>      &lt;div&gt; hello World&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="e195" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后让我们开始在我们的<code class="fe mb mc md me b">styles.css</code>中添加下面的样式</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="2a8b" class="nd kz in me b gy ne nf l ng nh">.reader_wrapper {<br/>  margin: 1em 0;<br/>  width: 100%;<br/>  border-radius: 30px;<br/>}</span></pre><p id="1926" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以上内容的主要目的只是检查我们环境中的任何错误，并确保在前进之前一切正常。接下来，我们将创建一个目录来存放我们的组件，并将一个新的<code class="fe mb mc md me b">Reader.component.js</code>文件放入其中。让我们现在做那件事。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/b00265ec9d4ad191e7edd3126152ff89.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/0*zjL4sw9BDc-FdAGQ"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">reader.component.js</figcaption></figure><p id="5627" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Reader组件内部，添加以下代码以确保其正常工作。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="019c" class="nd kz in me b gy ne nf l ng nh">const Reader = () =&gt; {<br/>  return (<br/>    &lt;h1&gt;Reader component&lt;/h1&gt;<br/>  )<br/>}</span><span id="7915" class="nd kz in me b gy ni nf l ng nh">export default Reader;</span></pre><p id="97ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后将其导入到您的<code class="fe mb mc md me b">App.js</code>文件中，以查看它在您的浏览器中的加载情况。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="bd75" class="nd kz in me b gy ne nf l ng nh">import "./styles.css";<br/>import Reader from './components/reader.component'</span><span id="0e46" class="nd kz in me b gy ni nf l ng nh">export default function App() {<br/>  return (<br/>    &lt;div className="reader_wrapper"&gt;<br/>      &lt;Reader /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="f2a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您应该可以在浏览器中看到Reader呈现的<code class="fe mb mc md me b">h1</code>文本。现在，让我们创建一个<code class="fe mb mc md me b">sample_text.md</code>文件，并加入下面的lorem ipsum文本。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="cb31" class="nd kz in me b gy ne nf l ng nh">Bacon ipsum dolor amet pork belly pancetta meatloaf alcatra sausage ham hock. Capicola ball tip landjaeger andouille tail pancetta. Corned beef t-bone tenderloin ham tongue. Landjaeger swine pork chop fatback chislic shoulder. Boudin meatball alcatra, short loin rump kevin andouille kielbasa swine t-bone ground round fatback jerky. Short loin swine cupim bresaola spare ribs. Ham hock shoulder bacon beef ribs, pastrami alcatra venison pork chop sausage pig tri-tip meatloaf chicken.</span></pre><p id="46b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将用它作为我们的小应用程序的示例文本。如果您想使用输入来收集用户反馈，您可以跳过下面的代码，在那里实现它。</p><p id="0298" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想继续使用这种方法，我们将在<code class="fe mb mc md me b">App.js</code>中添加一些代码来处理降价</p><blockquote class="nl nm nn"><p id="b0e8" class="ka kb no kc b kd ke kf kg kh ki kj kk np km kn ko nq kq kr ks nr ku kv kw kx ig bi translated"><em class="in">注意，如果您使用typescript，您将必须创建一个</em> <code class="fe mb mc md me b"><em class="in">.d.ts</em></code> <em class="in">文件，并添加以下代码来声明md类型。如果您不确定如何做到这一点，请查看本文底部的解决方案代码。</em></p></blockquote><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="70fa" class="nd kz in me b gy ne nf l ng nh">declare module '*.md' {<br/>  const value: string; // markdown is just a string<br/>  export default value;<br/>}</span></pre><p id="80c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mb mc md me b">App.js</code>中添加以下代码以获得示例代码。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="0954" class="nd kz in me b gy ne nf l ng nh">import { useEffect, useState } from 'react';<br/>import "./styles.css";<br/>import Reader from './components/reader.component'<br/>import mdText from './sample_text.md'</span><span id="3b89" class="nd kz in me b gy ni nf l ng nh">export default function App() {<br/>  const [textToRead, setTextToRead] = useState('');</span><span id="7395" class="nd kz in me b gy ni nf l ng nh">useEffect(() =&gt; {<br/>  console.log(mdText)<br/>}, []);</span><span id="8efd" class="nd kz in me b gy ni nf l ng nh">  return (<br/>    &lt;div className="reader_wrapper"&gt;<br/>      &lt;Reader /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="60b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码将注销MD文件内容的base64哈希，如下所示；</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cc56885516a91924be3dd335a5491fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/0*KDUVxrVjBLPdwN0b"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">base64 data hash</figcaption></figure><p id="d309" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法是通过HTTP协议传输数据对象的一种方式。我们需要获取它并解析数据。我们可以通过使用<code class="fe mb mc md me b">fetch API</code>很容易地做到这一点。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="aa61" class="nd kz in me b gy ne nf l ng nh">import { useEffect, useState } from 'react';<br/>import "./styles.css";<br/>import Reader from './components/reader.component'<br/>import mdText from './sample_text.md'</span><span id="37af" class="nd kz in me b gy ni nf l ng nh">export default function App() {<br/>  const [textToRead, setTextToRead] = useState('');</span><span id="7b0d" class="nd kz in me b gy ni nf l ng nh">useEffect(() =&gt; {<br/>  fetch(mdText)<br/>    .then((response) =&gt; response.text())<br/>    .then((text) =&gt; {<br/>      setTextToRead(text);<br/>    });<br/>}, []);</span><span id="5164" class="nd kz in me b gy ni nf l ng nh">  return (<br/>    &lt;div className="reader_wrapper"&gt;<br/>      &lt;Reader /&gt;<br/>      &lt;p&gt;{textToRead}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="79fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在应该在浏览器中看到markdown文本呈现。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/7815f78fd5db8634f25065b2034cff0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/0*TBEr4L_S8CfzX73h"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">lorem ipsum rendered on the page</figcaption></figure><p id="0b9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将把这个文本作为<code class="fe mb mc md me b">prop</code>传递给我们的<code class="fe mb mc md me b">Reader</code>组件。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="e965" class="nd kz in me b gy ne nf l ng nh">&lt;div className="reader_wrapper"&gt;<br/>      &lt;Reader textToRead={textToRead} /&gt;<br/>    &lt;/div&gt;</span><span id="2fbb" class="nd kz in me b gy ni nf l ng nh">interface IReader {<br/>  textToRead: string<br/>}</span><span id="83f2" class="nd kz in me b gy ni nf l ng nh">const Reader = ({ textToRead }: IReader) =&gt; {<br/>// handles in case no text is loaded<br/>  if (!textToRead) {<br/>    return (<br/>      &lt;p&gt;Awaiting Text&lt;/p&gt;<br/>    )<br/>  }<br/>  return (<br/>    &lt;h1&gt;Reader component&lt;/h1&gt;<br/>  )<br/>}</span><span id="032a" class="nd kz in me b gy ni nf l ng nh">export default Reader;</span></pre><h1 id="3d63" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">有趣的部分🎶</h1><p id="5474" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">既然基本设置已经完成，我们可以创建一个文件来存放我们的<code class="fe mb mc md me b">SpeechSynthesis</code>功能。我们希望将它分开，以保持可维护性。让我们创建一个<code class="fe mb mc md me b">speech-synth.utils.js</code>文件。您可以随意将它放入您的组件目录中，或者为它创建一个单独的utils目录。</p><p id="6506" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将直接进入该文件，并开始添加一些逻辑。第一段代码将获取我们可以使用的声音列表。如果您想创建一个允许用户选择他们想要使用的声音的特性，这将非常有用。</p><blockquote class="nl nm nn"><p id="b3ce" class="ka kb no kc b kd ke kf kg kh ki kj kk np km kn ko nq kq kr ks nr ku kv kw kx ig bi translated"><em class="in">跳过这一步可能会导致一个错误，即没有为您的语音合成提供声音。不使其异步将导致语音合成器开始尝试读取时声音可能中断或没有准备好的问题。</em></p></blockquote><p id="b8eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们添加我们的主要<code class="fe mb mc md me b">speak</code>功能。这个函数将被调用并为我们处理语音操作。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="14a7" class="nd kz in me b gy ne nf l ng nh">// the func that will be called by your component<br/>export async function speak(textToRead: string, onEndCallback: (status: string) =&gt; void, synth: SpeechSynthesis) {<br/>  if (speechSynthesis.onvoiceschanged !== undefined) {<br/>    speechSynthesis.onvoiceschanged = () =&gt; populateVoiceList<br/>  }</span><span id="6f65" class="nd kz in me b gy ni nf l ng nh">  if (synth.speaking) {<br/>    console.error("speechSynthesis.speaking")<br/>    return<br/>  }<br/>  if (textToRead !== "") {<br/>    const utterThis = new SpeechSynthesisUtterance(textToRead)<br/>    utterThis.onend = function (event) {<br/>      onEndCallback("_play")<br/>    }<br/>    utterThis.onerror = function (event) {<br/>      console.error("SpeechSynthesisUtterance.onerror")<br/>    }<br/>    // utterThis.voice = voices[0]<br/>    utterThis.pitch = pitch<br/>    utterThis.rate = rate<br/>    synth.speak(utterThis)<br/>  }</span></pre><p id="943d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于上面的代码需要注意一些事情。这些参数是用TypeScript类型编写的，以帮助识别阅读目的，如果您只是使用JavaScript，请随意删除它。但是，如果您决定使用TypeScript，可以导出以下枚举来帮助您处理状态。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="d2a6" class="nd kz in me b gy ne nf l ng nh">export enum PLAY_STATUS {<br/>  PLAY = '_play',<br/>  STOP = '_stop'<br/>}</span><span id="18a8" class="nd kz in me b gy ni nf l ng nh">// use it in components as<br/>PLAY_STATUS.PLAY;<br/>PLAY_STATUS.STOP;</span></pre><p id="6417" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，只要用适当的枚举值交换您看到的任何地方的<code class="fe mb mc md me b">_play</code>和<code class="fe mb mc md me b">_stop</code>。</p><h1 id="042a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">连接在一起</h1><p id="056e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在我们已经完成了语音合成逻辑的基本设置，我们可以将它放入我们的<code class="fe mb mc md me b">reader.component.js</code>文件中。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="77dc" class="nd kz in me b gy ne nf l ng nh">import { useState } from 'react'<br/>import { speak } from '../utils/speech-synth.utils'</span><span id="3856" class="nd kz in me b gy ni nf l ng nh">interface IReader {<br/>  textToRead: string<br/>}</span><span id="d4e8" class="nd kz in me b gy ni nf l ng nh">const Reader = ({ textToRead }: IReader) =&gt; {<br/>  const [playStatus, setPlayStatus] = useState("_play")</span><span id="beeb" class="nd kz in me b gy ni nf l ng nh">  const handleClick = () =&gt; {<br/>    speechSynthesis.cancel()<br/>      setPlayStatus(prev =&gt; {<br/>        if (prev === "_play") {<br/>				// if uncommenting code above, replace textToRead with text here<br/>          speak(textToRead, setPlayStatus, window.speechSynthesis)<br/>          return "_pause"<br/>        }<br/>        return "_play"<br/>      })<br/>  }</span><span id="50f1" class="nd kz in me b gy ni nf l ng nh">  return (<br/>    &lt;div className="loader"&gt;<br/>      &lt;div className="wrapper"&gt;<br/>        &lt;div<br/>          className="player_main_control"<br/>          onClick={() =&gt; handleClick()}<br/>          onKeyPress={() =&gt; handleClick()}<br/>          aria-hidden="true"<br/>        &gt;<br/>          &lt;div className="control_play_pause"&gt;<br/>            &lt;div className={`control_icon_${playStatus}`}&gt;<br/>              {playStatus === "_play" ? (<br/>                &lt;p&gt;stopped&lt;/p&gt;<br/>              ) : (<br/>                &lt;p&gt;playing&lt;/p&gt;<br/>              )}<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="0d48" class="nd kz in me b gy ni nf l ng nh">export default Reader;</span></pre><h1 id="5417" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">样式和动画</h1><p id="f69f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">虽然我们能够播放文本，听到语音合成并大声读出来，但没什么可看的。目前，它只有呈现播放状态的文本。我们想把这个风格化一点，并最终给它一些很酷的动画。让我们从CSS开始。我将把它们都放到<code class="fe mb mc md me b">styles.css</code>文件中，但是如果你愿意的话，可以随意为组件制作单独的样式表。让我们添加以下样式，在可点击区域周围创建一个漂亮的蓝色圆圈:</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="0080" class="nd kz in me b gy ne nf l ng nh">.wrapper {<br/>  height: 100%;<br/>  width: 8em;<br/>  margin: 0 auto;<br/>  color: var(--color-text);<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: flex-start;<br/>  position: relative;<br/>}</span><span id="a7db" class="nd kz in me b gy ni nf l ng nh">.player_main_control {<br/>  display: flex;<br/>  flex: 0 0 55px;<br/>  justify-content: center;<br/>  align-items: center;<br/>  width: 55px;<br/>  height: 55px;<br/>  margin-right: 10px;<br/>  background-color: hsla(217, 89%, 61%, 1);<br/>  color: white;<br/>  border-radius: 50%;<br/>  box-shadow: rgb(0 0 0 / 20%) 0px 2px 1px -1px,<br/>    rgb(0 0 0 / 14%) 0px 1px 1px 0px, rgb(0 0 0 / 12%) 0px 1px 3px 0px;<br/>  z-index: 1;<br/>}</span><span id="5f5d" class="nd kz in me b gy ni nf l ng nh">.control_play_pause {<br/>  width: 100%;<br/>  height: 100%;<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>  cursor: pointer;<br/>}</span><span id="d3e0" class="nd kz in me b gy ni nf l ng nh">.control_icon__play {<br/>  margin-left: 4px;<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>}</span><span id="a822" class="nd kz in me b gy ni nf l ng nh">.read_spectrum__pause {<br/>  width: 800px;<br/>  transition: 3s all ease-in;<br/>}</span><span id="585f" class="nd kz in me b gy ni nf l ng nh">.read_spectrum__play {<br/>  width: 0%;<br/>  overflow: hidden;<br/>  transition: 3s all ease-out;<br/>}</span></pre><p id="6897" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的可点击区域应该看起来像下面这样</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5b2f6a9189ac3f7e1297f7f379d2e8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/0*-HaNd2vWUCsVcOAI"/></div></figure><p id="8de2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所看到的，它看起来好一点了，但除了基本的样式之外，并没有真正解决任何问题。我们将开始为我们的“播放”动作设置默认外观。如果你有一个你喜欢的“播放”图像，请随意使用并调整它的样式，我将使用FontAwesome来获得播放按钮。让我们为FontAwesome安装React包，并将其放到我们的应用程序中。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="53ea" class="nd kz in me b gy ne nf l ng nh">$npm i @fortawesome/react-fontawesome @fortawesome/free-solid-svg-icons @fortawesome/fortawesome-svg-core</span></pre><p id="9d5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在回到我们的<code class="fe mb mc md me b">reader.component.js</code>文件，我们可以在页面顶部导入以下内容:</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="52a8" class="nd kz in me b gy ne nf l ng nh">...<br/>import { FontAwesomeIcon } from "@fortawesome/react-fontawesome"<br/>import { faPlay } from "@fortawesome/free-solid-svg-icons/faPlay"</span><span id="7dcd" class="nd kz in me b gy ni nf l ng nh">...<br/>&lt;div className="control_play_pause"&gt;<br/>            &lt;div className={`control_icon_${playStatus}`}&gt;<br/>              {playStatus === "_play" ? (<br/>                &lt;FontAwesomeIcon icon={faPlay} /&gt; // &lt;--- here<br/>                ) : (<br/>                &lt;p&gt;playing&lt;/p&gt;<br/>              )}<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;</span></pre><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9011318989ce50f523f2763ba97992db.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/0*00hWWzI-iUAwXZRT"/></div></figure><p id="a1fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了超级酷的播放按钮。有趣的事情开始了。该过程的下一步是，我们需要一个同步动作，一旦点击播放按钮，就会发生以下情况:</p><ul class=""><li id="bde8" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">一个书架伸出来，告诉我们从它开始阅读起已经过了多长时间</li><li id="566d" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">图标变成一个模拟的声谱，向用户显示它正在阅读一些东西</li></ul><p id="b0ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从动画光谱开始。</p><h1 id="f407" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">动画声谱</h1><p id="9a76" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">语音合成API非常酷，但是缺少很多我们最终想要的完整包中的关键特性。我想添加的几个功能是:</p><ul class=""><li id="431c" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">能够知道阅读一个提供的文本字符串需要多长时间</li><li id="1a46" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">获得实际光谱数据的波长流</li></ul><p id="6d9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们缺少这两个特性，它限制了我们在表现方面可以做的许多其他事情。这就是为什么我们将在光谱动画中使用SVG。</p><p id="4fb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从在我们的<code class="fe mb mc md me b">components</code>目录中创建一个<code class="fe mb mc md me b">read-spectrum.component.js</code>文件开始。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="41f2" class="nd kz in me b gy ne nf l ng nh">const ReadSpectrum = () =&gt; {<br/>  return (<br/>    &lt;div className="loader"&gt;<br/>      &lt;svg<br/>        className="wave"<br/>        data-name="Layer 1"<br/>        <br/>        viewBox="0 0 50 38.05"<br/>      &gt;<br/>        &lt;title&gt;Audio Wave&lt;/title&gt;<br/>        &lt;path<br/>          className="line_1"<br/>          data-name="Line 1"<br/>          d="M0.91,15L0.78,15A1,1,0,0,0,0,16v6a1,1,0,1,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H0.91Z"<br/>        /&gt;<br/>        &lt;path<br/>          className="line_2"<br/>          data-name="Line 2"<br/>          d="M6.91,9L6.78,9A1,1,0,0,0,6,10V28a1,1,0,1,0,2,0s0,0,0,0V10A1,1,0,0,0,7,9H6.91Z"<br/>        /&gt;<br/>        &lt;path<br/>          className="line_3"<br/>          data-name="Line 3"<br/>          d="M12.91,0L12.78,0A1,1,0,0,0,12,1V37a1,1,0,1,0,2,0s0,0,0,0V1a1,1,0,0,0-1-1H12.91Z"<br/>        /&gt;<br/>        &lt;path<br/>          className="line_4"<br/>          data-name="Line 4"<br/>          d="M18.91,10l-0.12,0A1,1,0,0,0,18,11V27a1,1,0,1,0,2,0s0,0,0,0V11a1,1,0,0,0-1-1H18.91Z"<br/>        /&gt;<br/>        &lt;path<br/>          className="line_5"<br/>          data-name="Line 5"<br/>          d="M24.91,15l-0.12,0A1,1,0,0,0,24,16v6a1,1,0,0,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H24.91Z"<br/>        /&gt;<br/>      &lt;/svg&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="615f" class="nd kz in me b gy ni nf l ng nh">export default ReadSpectrum</span></pre><p id="0ff5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个非常基本的SVG，它绘制一些相邻的线。目前，他们除了漂亮地坐在那里什么也不会做，所以我们需要添加我们的动画样式。同样，您可以将它放入您的<code class="fe mb mc md me b">styles.css</code>或者添加到组件样式表中。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="0b8c" class="nd kz in me b gy ne nf l ng nh">.loader {<br/>  width: 100%;<br/>  height: 100%;<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>  cursor: pointer;<br/>  margin-left: 0.2em;<br/>}</span><span id="130d" class="nd kz in me b gy ni nf l ng nh">.wave {<br/>  height: 55px;<br/>  width: 55px;<br/>  fill: #fff;<br/>  margin-left: 1.2em;<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>}</span><span id="d44a" class="nd kz in me b gy ni nf l ng nh">.line_1 {<br/>  -webkit-animation: pulse 1s infinite;<br/>  animation: pulse 1s infinite;<br/>  -webkit-animation-delay: 0.15s;<br/>  animation-delay: 0.15s;<br/>}</span><span id="333f" class="nd kz in me b gy ni nf l ng nh">.line_2 {<br/>  -webkit-animation: pulse 1s infinite;<br/>  animation: pulse 1s infinite;<br/>  -webkit-animation-delay: 0.3s;<br/>  animation-delay: 0.3s;<br/>}</span><span id="307d" class="nd kz in me b gy ni nf l ng nh">.line_3 {<br/>  -webkit-animation: pulse 1s infinite;<br/>  animation: pulse 1s infinite;<br/>  -webkit-animation-delay: 0.45s;<br/>  animation-delay: 0.45s;<br/>}</span><span id="2f23" class="nd kz in me b gy ni nf l ng nh">.line_4 {<br/>  -webkit-animation: pulse 1s infinite;<br/>  animation: pulse 1s infinite;<br/>  -webkit-animation-delay: 0.6s;<br/>  animation-delay: 0.6s;<br/>}</span><span id="7a1c" class="nd kz in me b gy ni nf l ng nh">.line_5 {<br/>  -webkit-animation: pulse 1s infinite;<br/>  animation: pulse 1s infinite;<br/>  -webkit-animation-delay: 0.75s;<br/>  animation-delay: 0.75s;<br/>}</span><span id="68e4" class="nd kz in me b gy ni nf l ng nh">@-webkit-keyframes pulse {<br/>  0% {<br/>    transform: scaleY(1);<br/>    transform-origin: 50% 50%;<br/>  }<br/>  50% {<br/>    transform: scaleY(0.7);<br/>    transform-origin: 50% 50%;<br/>  }<br/>  100% {<br/>    transform: scaleY(1);<br/>    transform-origin: 50% 50%;<br/>  }<br/>}</span><span id="bf38" class="nd kz in me b gy ni nf l ng nh">@keyframes pulse {<br/>  0% {<br/>    transform: scaleY(1);<br/>    transform-origin: 50% 50%;<br/>  }<br/>  50% {<br/>    transform: scaleY(0.7);<br/>    transform-origin: 50% 50%;<br/>  }<br/>  100% {<br/>    transform: scaleY(1);<br/>    transform-origin: 50% 50%;<br/>  }<br/>}</span></pre><p id="330e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以返回到我们的<code class="fe mb mc md me b">reader.component.tsx</code>文件中，导入我们新的<code class="fe mb mc md me b">read-spectrum</code>组件。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="2024" class="nd kz in me b gy ne nf l ng nh">import ReadSpectrum from './read-spectrum.component'</span></pre><p id="bea6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，在JSX内三元组的else子句中，我们可以替换“playing”文本。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="2269" class="nd kz in me b gy ne nf l ng nh">&lt;div className={`control_icon_${playStatus}`}&gt;<br/>              {playStatus === "_play" ? (<br/>                &lt;FontAwesomeIcon icon={faPlay} /&gt;<br/>                ) : (<br/>                &lt;ReadSpectrum /&gt;<br/>              )}<br/>            &lt;/div&gt;</span></pre><p id="4468" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您应该能够单击reader按钮，在阅读文本时看到SVG动画。一旦文本阅读完毕，它应该返回到播放按钮。为了更快地测试这一点，您可以返回到<code class="fe mb mc md me b">sample_text.md</code>文件并删除一些lorem ipsum文本。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e0e6d0d2eff8a199faf45476634519f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/0*k65PfghoUqtR_Ujf"/></div></figure><h1 id="a315" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">收尾😤</h1><p id="64a4" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们相当快地解决了语音合成阅读器的问题，甚至添加了一些波谱动画来模拟声音。现在我们可以添加拼图的最后一块了，那是存放逝去时间的滑出式抽屉。</p><p id="f7f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从跳转到我们的<code class="fe mb mc md me b">components</code>目录并创建一个<code class="fe mb mc md me b">read-tim.component.js</code>文件开始。请随意给它重新命名，因为我通常不太擅长给这些东西命名😅。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="7099" class="nd kz in me b gy ne nf l ng nh">import React, { useState, useEffect } from "react"</span><span id="37fd" class="nd kz in me b gy ni nf l ng nh">// counter value<br/>let totalSeconds = 0</span><span id="8457" class="nd kz in me b gy ni nf l ng nh">const ReadTime = ({ loaded }) =&gt; {<br/>  const [displayTime, setDisplayTime] = useState("00:00")</span><span id="9969" class="nd kz in me b gy ni nf l ng nh">// will use to pad our start and end when formatting our elapsed time<br/>  const pad = (val: string) =&gt; {<br/>    let valString = `${val}`<br/>    if (valString.length &lt; 2) {<br/>      return "0" + valString<br/>    } else {<br/>      return valString<br/>    }<br/>  }</span><span id="c561" class="nd kz in me b gy ni nf l ng nh">useEffect(() =&gt; {<br/>    if (loaded) {<br/>      let timer = setInterval(() =&gt; {<br/>        ++totalSeconds;<br/>        const minutes = `${parseInt(`${totalSeconds / 60}`, 10)}`;<br/>        const seconds = `${parseInt(`${totalSeconds % 60}`, 10)}`;<br/>        setDisplayTime(`${pad(minutes)}:${pad(seconds)}`);<br/>      }, 1000);</span><span id="6b85" class="nd kz in me b gy ni nf l ng nh">// important to clean up our timers to avoid memory leaks<br/>      return () =&gt; clearInterval(timer)<br/>    } else {<br/>      setDisplayTime("00:00")<br/>      totalSeconds = 0<br/>    }<br/>// we want this to run any time there a change to the loaded status<br/>// so this needs to be a dependency of our useEffect<br/>  }, [loaded])</span><span id="1024" class="nd kz in me b gy ni nf l ng nh">  return (<br/>    &lt;div<br/>      className={`read_spectrum_container ${<br/>        loaded ? 'open' : 'closed'<br/>      }`}<br/>    &gt;<br/>      &lt;div className="player_container"&gt;<br/>        &lt;p&gt;{displayTime}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="ed20" class="nd kz in me b gy ni nf l ng nh">export default ReadTime</span></pre><p id="86b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了！！现在，让我们像以前一样添加CSS。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="d7e4" class="nd kz in me b gy ne nf l ng nh">.read_spectrum_container {<br/>  position: relative;<br/>  z-index: 0;<br/>  margin-left: -2.5em;<br/>  height: 52px;<br/>  width: 100%;<br/>  position: relative;<br/>  background-color: rgb(233, 233, 233);<br/>  border-radius: 0 20px 20px 0;<br/>  display: flex;<br/>  box-shadow: rgb(0 0 0 / 20%) 0px 2px 1px -1px,<br/>    rgb(0 0 0 / 14%) 0px 1px 1px 0px, rgb(0 0 0 / 12%) 0px 1px 3px 0px;<br/>}</span><span id="ca74" class="nd kz in me b gy ni nf l ng nh">.open {<br/>  width: 100%;<br/>  transition: 0.3s all ease-out;<br/>}</span><span id="ae6a" class="nd kz in me b gy ni nf l ng nh">.closed {<br/>  width: 0%;<br/>  overflow: hidden;<br/>  transition: 0.3s all ease-in;<br/>}</span></pre><h1 id="e50e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">把它扔进锅里🍯</h1><p id="fd9c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在我们可以把它放到我们的<code class="fe mb mc md me b">reader.component.js</code>文件中。如果你一直在关注我们已经放弃的CSS样式，你会注意到一些奇怪的定位和伸缩。这个最新的将基本上有读者的主要造型和<code class="fe mb mc md me b">ReadTime</code>组件坐在一起。然后我们将使用<code class="fe mb mc md me b">margin-left: -2.5em</code>把它移到播放按钮后面一点(在它的中间)。这使得曲线很好地融合在一起，使得元素看起来像是阅读器组件的扩展。因此，让我们添加收尾工作，以完成该组件并准备发货。</p><p id="9f54" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mb mc md me b">reader.component.js</code>中，用下面的代码替换JSX，引入<code class="fe mb mc md me b">ReadTime</code>组件。</p><pre class="mg mh mi mj gt mz me na nb aw nc bi"><span id="ca02" class="nd kz in me b gy ne nf l ng nh">return (<br/>    &lt;div className="loader"&gt;<br/>      &lt;div className="wrapper"&gt;<br/>        &lt;div<br/>          className="player_main_control"<br/>          onClick={() =&gt; handleClick()}<br/>          onKeyPress={() =&gt; handleClick()}<br/>          aria-hidden="true"<br/>        &gt;<br/>          &lt;div className="control_play_pause"&gt;<br/>            &lt;div className={`control_icon_${playStatus}`}&gt;<br/>              {playStatus === '_play' ? (<br/>                &lt;FontAwesomeIcon icon={faPlay} /&gt;<br/>              ) : (<br/>                &lt;ReadSpectrum /&gt;<br/>              )}<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;ReadTime loaded={playStatus === PLAY_STATUS.STOP} /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );</span></pre><p id="555d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你应该可以看到我们所有工作的全部效果。我们有一个语音合成文本阅读器和一些很酷的动画。如果你遇到困难或者想看看解决方案的代码，我把它放在下面。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl nz oa hr ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ig ih ii ij ik"><h1 id="c91d" class="ky kz in bd la lb og ld le lf oh lh li lj oi ll lm ln oj lp lq lr ok lt lu lv bi translated">结论</h1><p id="f2d1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">虽然Web Speech API仍然是实验性的技术，但是发现我们可以将Web技术推向多远来解决我们面临的新挑战总是很有趣的。虽然我试图让这篇文章看起来容易理解，但在解决一些常见问题和限制的同时，要让它发挥作用还有很多挑战。探索技术的很大一部分是潜入兔子洞，记录它是什么和不是什么。语音合成不一定意味着阅读整个博客文章的文本。这意味着阅读短字符串文本。这种微小的差异意味着它能做什么和它能为你提供什么有很大的限制。例如，您无法使用前进或后退选项。这意味着，如果不添加处理这些情况的干扰逻辑，就不能用滑块或按钮来控制起点。您也不会被授予“这需要多长时间来读取”属性，以便您可以创建一个很酷的滑块，并知道它会停在哪里。这些限制可能意味着你选择一个不同的，更昂贵的解决方案，或者找到一个不同的方法来推出你自己的。您还可以做一些额外的优化，比如清除路由，以确保在重定向或加载新页面时语音合成被适当清除。</p><p id="a24b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，请随时分享或联系我，让我知道你的想法。</p><p id="5ba8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="no">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="no">说白了. io </em> </a> <em class="no">。在这里注册我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="no">免费周报</em> </a> <em class="no">。</em></p></div></div>    
</body>
</html>