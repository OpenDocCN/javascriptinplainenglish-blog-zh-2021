<html>
<head>
<title>How to build Auto Complete React component and improve its performance using debounce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建自动完成的反应组件并使用去抖提高其性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-auto-complete-react-component-and-improve-its-performance-using-debounce-df8a8b933371?source=collection_archive---------8-----------------------#2021-12-18">https://javascript.plainenglish.io/how-to-build-auto-complete-react-component-and-improve-its-performance-using-debounce-df8a8b933371?source=collection_archive---------8-----------------------#2021-12-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/82becff11a420924269f0cc7d6a9f116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sku9gGNsfgpW-cfnWoPOyQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://www.pexels.com/@caio?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Caio</a> from <a class="ae jz" href="https://www.pexels.com/photo/macbook-air-on-grey-wooden-table-67112/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="67e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自动完成——这意味着预测用户在像<a class="ae jz" href="https://en.wikipedia.org/wiki/Search_box" rel="noopener ugc nofollow" target="_blank">搜索栏</a>这样的UI控件中输入的内容。它有助于改善任何应用程序的用户体验。</p><p id="4cb1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将实现基于用户输入呈现文本的react组件，然后我们将使用<a class="ae jz" href="https://lodash.com/docs/" rel="noopener ugc nofollow" target="_blank"> lodash的</a>函数<a class="ae jz" href="https://lodash.com/docs/#debounce" rel="noopener ugc nofollow" target="_blank">去抖</a>来提高它的性能。</p><p id="27d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用去抖是一种强大的技术，可以提高web应用程序的任何搜索功能的性能。</p><h1 id="d8c5" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">步骤1 —建立一个react项目</strong></h1><p id="6d00" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">按照这里提到的<a class="ae jz" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank">步骤</a>在机器的任何地方设置新的react项目。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4f38" class="mk kz in mg b gy ml mm l mn mo">npx create-react-app my-app-name<br/>cd my-app-name<br/>npm start</span></pre><p id="049a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你的基本开发环境已经准备好了，在你喜欢的代码编辑器中打开项目，比如<a class="ae jz" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>。</p><p id="f723" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mp mq mr mg b">src</code>中新建一个名为<code class="fe mp mq mr mg b">components</code>的文件夹，并新建两个文件<code class="fe mp mq mr mg b">AutoComplete.js</code>和<code class="fe mp mq mr mg b">AutoComplete.css</code>。我们将使用<code class="fe mp mq mr mg b">.js</code>文件来编写组件的react代码，使用<code class="fe mp mq mr mg b">.css</code>来添加一些基本的样式。</p><p id="24e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的文件夹结构将如下所示</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5140" class="mk kz in mg b gy ml mm l mn mo">|- node_modules<br/>|- public<br/>|- src<br/>   |- components<br/>      |- AutoComplete.js<br/>      |- AutoComplete.css<br/>   |- App.js<br/>   |- index.js<br/>|- package.json</span></pre><h1 id="c0d2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">步骤2 —安装依赖关系</strong></h1><p id="2306" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将安装两个依赖项，用于构建这个组件—<a class="ae jz" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank">axios</a>&amp;<a class="ae jz" href="https://www.npmjs.com/package/lodash" rel="noopener ugc nofollow" target="_blank">lodash</a></p><p id="a862" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Axios是一个HTTP客户端，它允许我们从Node.js发出请求，并帮助我们拦截端点的请求和响应。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9f2d" class="mk kz in mg b gy ml mm l mn mo">npm i axios</span></pre><blockquote class="ms mt mu"><p id="e224" class="ka kb mv kc b kd ke kf kg kh ki kj kk mw km kn ko mx kq kr ks my ku kv kw kx ig bi translated">注意:也可以用<code class="fe mp mq mr mg b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"><em class="in">fetch</em></a></code>代替<code class="fe mp mq mr mg b"><em class="in">axios</em></code>。我选择使用<code class="fe mp mq mr mg b"><em class="in">axios</em></code>，因为我发现它非常简单。</p></blockquote><p id="1a37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a> —是一个为处理JavaScript数组、数字、对象、字符串等而开发的实用程序库。我们将使用lodash的函数——<a class="ae jz" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">去抖</a>——它在调用一些功能之前引入延迟，比如调用一个函数或请求一个API。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="343b" class="mk kz in mg b gy ml mm l mn mo">npm i lodash</span></pre><h1 id="9d03" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤3-设置您的应用组件</h1><p id="cdf1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">清除掉不必要的代码，我们将只保留我们需要的。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1fab" class="mk kz in mg b gy ml mm l mn mo">import './App.css';<br/>/*Import your new Auto complete component here*/</span><span id="bb5a" class="mk kz in mg b gy mz mm l mn mo">const App = () =&gt; {<br/>  return (<br/>     &lt;div className="App"&gt;<br/>        {/* Call your AutoComplete component here */}<br/>     &lt;/div&gt;<br/>  );<br/>}</span><span id="4c49" class="mk kz in mg b gy mz mm l mn mo">export default App;</span></pre><h1 id="bf20" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">步骤4——创建您的组件</strong></h1><p id="45a3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将从设置组件的基础开始—创建一个功能组件<code class="fe mp mq mr mg b">AutoComplete</code>，我们将使用<a class="ae jz" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>进行状态管理。</p><ol class=""><li id="b253" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">您可以使用下面显示的代码片段。该组件将使用类名<code class="fe mp mq mr mg b">wrapper</code>呈现<code class="fe mp mq mr mg b">div</code>元素。</li><li id="6111" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><code class="fe mp mq mr mg b">wrapper</code>将有两个新的子元素:一个类名为<code class="fe mp mq mr mg b">control</code>的<code class="fe mp mq mr mg b">div</code>元素和一个类名为<code class="fe mp mq mr mg b">list</code>的<code class="fe mp mq mr mg b">div</code>元素。</li><li id="7067" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><code class="fe mp mq mr mg b">control</code>将包含一个类名为<code class="fe mp mq mr mg b">input</code>的input元素，它将用户的查询作为输入。</li><li id="62fe" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我们将向API端点发送一个包含用户查询的请求，一旦响应返回，我们将用类名<code class="fe mp mq mr mg b">list</code>填充<code class="fe mp mq mr mg b">div</code>元素，并在前端显示结果。</li><li id="8ca0" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">state — <code class="fe mp mq mr mg b">userInput</code>将管理用户的输入，当<code class="fe mp mq mr mg b">input</code>控件的<code class="fe mp mq mr mg b">onChange</code>事件被触发时，将调用方法— <code class="fe mp mq mr mg b">handleOnInputChange</code>。</li></ol><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1308" class="mk kz in mg b gy ml mm l mn mo">import React, { useState } from "react";</span><span id="f716" class="mk kz in mg b gy mz mm l mn mo">export default const AutoComplete = () =&gt; {<br/>    const [userInput, setInput] = useState("");<br/>    <br/>    const handleOnInputChange = (event) =&gt; {};</span><span id="839a" class="mk kz in mg b gy mz mm l mn mo">return (<br/>   &lt;div className="wrapper"&gt;<br/>       &lt;div className="control"&gt;<br/>            &lt;input type="text" <br/>                   className="input"<br/>                   onChange={handleOnInputChange}<br/>                   value={userInput}<br/>            /&gt;<br/>       &lt;/div&gt;<br/>       &lt;div className="list"&gt;<br/>          <strong class="mg io"><em class="mv">{/*populate the list of items fetched from the endpoint*/}</em></strong><br/>       &lt;/div&gt;<br/>    &lt;/div&gt;<br/> )<br/>}</span></pre><p id="5487" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在组件的基础已经准备好了，我们将实现方法<code class="fe mp mq mr mg b">handleOnInputChange</code>并将我们的请求发送到API端点。</p><p id="4669" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了测试，我使用了Reddit的搜索API。首先，我们将为这个端点初始化一个常量变量。<a class="ae jz" href="http://reddit.com" rel="noopener ugc nofollow" target="_blank"> Reddit的</a>搜索API接受一个保存用户输入值的查询参数<code class="fe mp mq mr mg b">q</code>，即<code class="fe mp mq mr mg b">userInput</code>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6d37" class="mk kz in mg b gy ml mm l mn mo">const ITEMS_API_URL = "https://www.reddit.com/search.json";</span></pre><p id="f35b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还将添加三个新状态:</p><ol class=""><li id="d82d" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">为了存储我们收到的回复，</li><li id="9920" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><code class="fe mp mq mr mg b">isLoading</code> —标识我是否仍在等待我的回复，以及</li><li id="f85f" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><code class="fe mp mq mr mg b">error</code>在发送请求时捕捉任何错误。</li></ol><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="16eb" class="mk kz in mg b gy ml mm l mn mo">const [result, setResult] = useState([]);<br/>const [isLoading, setIsLoading] = useState(false);<br/>const [error, setError] = useState("");</span></pre><p id="cbc0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了向端点发送请求，我们将使用<code class="fe mp mq mr mg b">axios</code>，它是我们之前作为依赖项安装的。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a9b7" class="mk kz in mg b gy ml mm l mn mo">import axios from "axios";</span></pre><p id="0bd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将向我们的API发送一个请求以及用户的输入作为查询参数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="dbb9" class="mk kz in mg b gy ml mm l mn mo">const handleOnInputChange = (event) =&gt; {<br/>     const userInput = event.target.value;<br/>     setInput(userInput);<br/>     setIsLoading(true);<br/>     axios.get(`${ITEMS_API_URL}?q=${userInput}`)<br/>          .then((response) =&gt; {<br/>             setResult(response.data.data.children);<br/>             setIsLoading(false);<br/>             setError("");<br/>          }).catch(() =&gt; {<br/>             setError("An error occured. Please try again.");<br/>             setIsLoading(false);<br/>    });</span><span id="ffce" class="mk kz in mg b gy mz mm l mn mo">};</span></pre><p id="1882" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们的响应存储在<code class="fe mp mq mr mg b">result</code>状态中，我们将使用它用类名<code class="fe mp mq mr mg b">list</code>填充我们的<code class="fe mp mq mr mg b">div</code>。我们的<code class="fe mp mq mr mg b">result</code>中的每个字符串都将显示在一个单独的<code class="fe mp mq mr mg b">div</code>元素中，其类名为<code class="fe mp mq mr mg b">list-item</code>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="38ab" class="mk kz in mg b gy ml mm l mn mo">{error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;}<br/>{isLoading &amp;&amp; &lt;p className="loading"&gt;Loading...&lt;/p&gt;}<br/>&lt;div className="list"&gt;<br/>   {<strong class="mg io">result</strong>.map((item, index) =&gt; (<br/>        &lt;div className="list-item"<br/>             key={index}<br/>             id={`list-item-${index}`}<br/>        &gt;<br/>          {item.data.title}<br/>        &lt;/div&gt;<br/>   ))}<br/>&lt;/div&gt;</span></pre><p id="fe80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">向组件的元素添加一些基本样式，如下所示:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="54e0" class="mk kz in mg b gy ml mm l mn mo">.wrapper {<br/>  margin: 20px;<br/>}</span><span id="4d64" class="mk kz in mg b gy mz mm l mn mo">.list {<br/>  border: 1px solid #999;<br/>  width: calc(300px + 1rem);<br/>  background-color: #e6e6e6;<br/>}</span><span id="646a" class="mk kz in mg b gy mz mm l mn mo">.list-item {<br/>  border: 1px solid #999;<br/>  color: blue;<br/>}</span><span id="f100" class="mk kz in mg b gy mz mm l mn mo">.list div:hover {<br/>  color: black;<br/>}</span></pre><p id="337f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以使用<code class="fe mp mq mr mg b">npm start</code>命令运行应用程序，您将能够根据输入框中输入的查询来查看项目列表。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="ab gu cl no"><img src="../Images/6b32a493913d6fa3416d71265d5f9ce1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*xtzCbcyO2XNgJH3a6_IVZQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Auto suggestions as per query entered in the input box</figcaption></figure><p id="8bc1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还想在输入中显示选中的项目。因此，我们将添加一个新方法<code class="fe mp mq mr mg b">onItemSelection</code>，它将在列表项的<code class="fe mp mq mr mg b">onClick</code>事件中被调用。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ff05" class="mk kz in mg b gy ml mm l mn mo">{error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;}<br/>{isLoading &amp;&amp; &lt;p className="loading"&gt;Loading...&lt;/p&gt;}<br/>&lt;div className="list"&gt;<br/>   {result.map((item, index) =&gt; (<br/>        &lt;div className="list-item"<br/>             key={index}<br/>             id={`list-item-${index}`}<br/>             <strong class="mg io">onClick={onItemSelection}</strong><br/>        &gt;<br/>          {item.data.title}<br/>        &lt;/div&gt;<br/>   ))}<br/>&lt;/div&gt;</span></pre><p id="c0c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在选择项目时，我们希望隐藏列表并在输入框中显示所选项目:-</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="f1b9" class="mk kz in mg b gy ml mm l mn mo">const onItemSelection = (event) =&gt; {<br/>   setInput(event.target.innerText);<br/>   setResult([]);<br/>};</span></pre><p id="a2fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">如何提升性能？</strong></p><p id="468c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的实现中，我们为input元素中的每个字符触发一个API请求。为了使我们的组件更有性能，我们必须避免在每次按键时发送太多的请求！</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/5d4925b8b42a67db296ab93ed18ec10e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brw1FHWgXGNtcyjPkivRwg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The request sent on every keypress</figcaption></figure><p id="9a18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了避免这种情况，我们将<code class="fe mp mq mr mg b">debounce</code>请求并保持其超时为<code class="fe mp mq mr mg b">500ms</code>。</p><p id="3174" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在将使用之前在<code class="fe mp mq mr mg b">Step 2</code>中安装的<code class="fe mp mq mr mg b">lodash</code>实用程序库。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b1be" class="mk kz in mg b gy ml mm l mn mo">import lodash from "lodash";</span></pre><p id="f9ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更新处理程序并在去抖延迟中环绕逻辑。我们将把<code class="fe mp mq mr mg b">setInput</code>从<a class="ae jz" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">回调</a>中移出，因为我们需要立即更新输入，然后基于输入我们将进行查询。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4198" class="mk kz in mg b gy ml mm l mn mo">const handler = useCallback(lodash.debounce(handleOnInputChange, DEBOUBCE_DELAY), []);</span><span id="2cd3" class="mk kz in mg b gy mz mm l mn mo">const onChange = (event) =&gt; {<br/>  setInput(event.target.value);<br/>  handler(userInput);<br/>};</span><span id="5e4c" class="mk kz in mg b gy mz mm l mn mo">const handleOnInputChange = (userInput) =&gt; {<br/>setIsLoading(true);<br/>axios.get(`${ITEMS_API_URL}?q=${userInput}`)<br/>     .then((response) =&gt; {<br/>         setResult(response.data.data.children);<br/>         setError("");<br/>         setIsLoading(false);<br/>     }).catch(() =&gt; {<br/>         setError("An error occured. Please try again.");<br/>         setIsLoading(false);<br/> });<br/>}</span></pre><p id="1637" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，只有在用户停止输入500毫秒后，才会调用API &amp;因此减少了API调用的数量。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/a5e6ad17bfe405afff6e66db7b6879df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mTlbZDKMcxQmA9Y1dATCrw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The reduced number of requests after using debounce</figcaption></figure><p id="a51d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仅此而已。<br/>你可以在这里获得组件<a class="ae jz" href="https://github.com/mansi-manhas/react-autocomplete-autosuggestion-component/blob/main/src/components/AutoSuggestions.js" rel="noopener ugc nofollow" target="_blank">的完整源代码。</a></p><figure class="mb mc md me gt jo gh gi paragraph-image"><a href="https://www.buymeacoffee.com/mansimanhas"><div class="gh gi nr"><img src="../Images/6d60b235fcc46a4bd696b90e886419ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Dpw8-hNGI2fDmosV4E8DVQ.png"/></div></a><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Thanks for your support!</figcaption></figure><p id="6fee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mv">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mv">plain English . io</em></strong></a><em class="mv">。</em></p><p id="24a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mv">报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mv">免费周报</em> </strong> </a> <em class="mv">。关注我们上</em> <a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mv">推特</em> </strong> </a>，<a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mv">领英</em> </strong> </a> <strong class="kc io"> <em class="mv">，</em></strong><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mv">YouTube</em></strong></a><strong class="kc io"><em class="mv">，以及</em></strong><em class="mv"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mv">不和</em> </strong> </a>T47】</p><p id="d61e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="mv">用</em> </strong> <a class="ae jz" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mv">电路</em> </strong> </a> <em class="mv">为你的科技创业建立认知和采用。</em></p></div></div>    
</body>
</html>