<html>
<head>
<title>How do Constructor Functions Work in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的构造函数是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-do-constructor-functions-work-in-javascript-408c1fe4c196?source=collection_archive---------16-----------------------#2021-06-04">https://javascript.plainenglish.io/how-do-constructor-functions-work-in-javascript-408c1fe4c196?source=collection_archive---------16-----------------------#2021-06-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1eb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在JavaScript中创建新对象的许多方法之一是使用构造函数。</p><p id="2e96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1fba6cef5710e964f6d52aea0160322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CX9qYmrZL5bVhgTkof4sdg.png"/></div></div></figure><p id="b805" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有一个简单的函数，名为“Person ”,它接受姓名和年龄，如果用new关键字调用，则返回一个带有姓名和年龄的新对象。但神奇的是，我们运行一个函数并得到一个对象，即使这个函数不返回任何东西。神奇之处在于“新”的力量。不过，在此之前，让我们先来探索一些其他现象。</p><h2 id="e1be" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">如果我们只运行没有' new '关键字的函数会发生什么？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ln"><img src="../Images/bd53107dc0d481d359043fb311c274b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQQ-pb2_UMuGHy3rjooqxw.png"/></div></div></figure><p id="4843" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们首先打印姓名和年龄，正如你可能想象的那样，答案将是未定义的，因为我们没有通过这些标识符定义任何东西。而我们的假设为真，第一个日志的输出是<code class="fe lo lp lq lr b">`undefined, undefined`</code>。</p><p id="e597" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是当我们调用函数Person，将它的返回值存储在一个名为trending的变量中时，突然就定义了名字和年龄。</p><p id="a394" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你第二次尝试记录姓名和年龄，你不会再次得到undefined，而是得到undefined，JSON和14；这两个变量被定义了。这肯定与职能人员正在做的事情有关。为了确保这一点，这次让我们用不同的参数运行Person函数，看看会发生什么。</p><p id="b26e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们改变函数的参数，一切仍然工作，变量仍然被定义，但它们的值已经改变为新的参数，所以现在我们非常确定变量定义与函数调用有关，函数正在做一些有趣的事情来实现这一点。所以让我们更深入地研究一下这个函数，看看它在做什么。</p><p id="17a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数只有两行长，它只是将name参数放入this.name中，将age参数放入this.age中，那么运行这个函数如何在函数之外定义两个变量，就像使用let、var或const关键字定义它们一样。</p><p id="f8e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，这与JavaScript如何处理作用域以及它指的是什么有关。</p><p id="bac8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了说明这一点，让我们看一个简单的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ls"><img src="../Images/1038711ea472d438605d8be44abbbe90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ADxzXvGd_oRIHbAj968Bw.png"/></div></div></figure><p id="b100" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这段代码中，我们首先打印this和this.x。因为我们在全局范围内，这将引用全局对象。根据JavaScript环境的不同，它可能是window(对于浏览器)或globalThis(对于node)。在里面，你可以看到有多种类型的键-值对，但是没有键x，所以你可能已经猜到了，试图打印这个，x只会打印未定义的。</p><p id="ac9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是当你运行define_x函数时，会发生一些事情。如果你看到“this”的值，紧接着你可以看到有一个值为“10”的键“x”，这意味着函数能够从全局对象中改变一些东西。所以每当一个普通的函数被调用时，一个对象被绑定到它，这个对象可以被函数中的“this”引用。默认情况下，如果您在全局范围内，那么每当调用一个函数时，将绑定到这个函数的对象就是全局对象。在这种情况下，define_x正在访问全局对象并添加x和10的键值对，之后你可以访问this.x，但你不一定要做' this.x '，如果你只是做' x '，它会在全局对象内部查看。</p><p id="279f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们明白了Person是如何创建这两个新变量的，但我们实际上想要的是创建一个具有这些属性的新对象，那么有没有办法改变函数内部的含义呢？</p><h2 id="fc47" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">如果我们将一个函数绑定到另一个对象会发生什么？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ls"><img src="../Images/06660e3e6d5dbb2550e6600154c7edda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ciYnrxFbu2rkHfyEsn093A.png"/></div></div></figure><p id="444b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，即使在函数被调用之后，打印this.x也会给出undefined，因为我们将函数绑定到了其他东西。因为每个函数都继承自函数原型，所以所有函数都有类似bind和call的属性。我们在这里做的是，在调用函数之前，我们用不同的对象new_obj绑定它。</p><p id="c9e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它给了我们一个新的函数，这个函数被绑定到这个对象上(在这个例子中是new_obj)，然后我们运行它，这样this.x = 10在这个函数中，将引用新绑定的对象。而且我们可以通过运行console.log(new_obj)看到这是怎么回事，new_obj有属性10，但是全局对象没有。出于同样的原因，我们可以创建一个新的人，而不实际使用new关键字，而是将函数绑定到一个新创建的新鲜对象。</p><p id="5e77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lt"><img src="../Images/f755365f69079a3656553dad9586187e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ulro521ngv8myz5oaOvBPg.png"/></div></div></figure><p id="0943" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果我们都明白new在做什么，为什么不直接使用它；它将自动创建对象，并为我们绑定，这给我们实际构造函数的感觉，而实际上它所做的是创建一个从对象原型继承的新对象，然后将其绑定到Person函数，然后运行Person函数。</p><p id="3a24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lu">更多内容看</em><a class="ae lv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lu">plain English . io</em></strong></a></p></div></div>    
</body>
</html>