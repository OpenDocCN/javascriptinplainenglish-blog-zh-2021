<html>
<head>
<title>Is JavaScript Array.push() a Deep or Shallow Copy?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Array.push()是深拷贝还是浅拷贝？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/array-push-in-javascript-is-it-deep-or-shallow-copy-90cd195ec5b7?source=collection_archive---------3-----------------------#2021-08-13">https://javascript.plainenglish.io/array-push-in-javascript-is-it-deep-or-shallow-copy-90cd195ec5b7?source=collection_archive---------3-----------------------#2021-08-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ca26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天让我们讨论一个有趣的JavaScript话题。即使是JavaScript的初学者也会知道array以及在其中添加和删除值。但是我们大多数人并不试图理解所有数组函数的内部实现(有时也不可能理解每个函数的实现！！).</p><p id="00f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以今天我们来讨论一下array.push方法。如果你不知道array.push是如何工作的，这里是它的官方<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ko kp l"/></div></figure></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/9b4d29a26206fc24fe1390d6c9d1ccd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*hi7yig8dFI0tChsz.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Source — Wikipedia</figcaption></figure><p id="88c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从简单的例子开始:你能猜出下面代码片段的输出吗？</p><pre class="kj kk kl km gt le lf lg lh aw li bi"><span id="4573" class="lj lk in lf b gy ll lm l ln lo">let arr = [];<br/>let x = 10;<br/>arr.push(x);<br/>x = 20;<br/>console.log(arr); <br/>console.log(x);</span></pre><p id="5599" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很简单，<code class="fe lp lq lr lf b">arr</code>将打印10，<code class="fe lp lq lr lf b">x</code>将打印为20。</p><p id="d180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们稍微复杂一点。在不执行代码的情况下尝试猜测代码。</p><pre class="kj kk kl km gt le lf lg lh aw li bi"><span id="4520" class="lj lk in lf b gy ll lm l ln lo">var array = [];<br/>var y = {name: "test", type: "data", data: "2-27-2009"};<br/>array.push(y);<br/>y.name = "foo";<br/>console.log(array);</span></pre><p id="355d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你来自Java，c#背景你会猜测输出会是:</p><p id="67f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lp lq lr lf b">[{name: “test”, type: “data”, data: “2–27–2009”}]</code></p><p id="bcd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但实际输出是:</p><p id="b864" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lp lq lr lf b">[ { name: “foo”, type: “data”, data: “2–27–2009” } ]</code></p><p id="83c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们再调整一下，猜测一下不执行的输出，</p><pre class="kj kk kl km gt le lf lg lh aw li bi"><span id="34a3" class="lj lk in lf b gy ll lm l ln lo">var array = [];<br/>var y = {name: "test", type: "data", data: "2-27-2009"};<br/>array.push(y);<br/>array[0].name = "foo";<br/>console.log(y);<br/>console.log(array);</span></pre><p id="fe2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，输出是:</p><pre class="kj kk kl km gt le lf lg lh aw li bi"><span id="976d" class="lj lk in lf b gy ll lm l ln lo"><em class="ls">// y<br/>{ name: ‘foo’, type: ‘data’, data: ‘2–27–2009’ }</em></span><span id="6443" class="lj lk in lf b gy lt lm l ln lo"><em class="ls">// array<br/>[{ name: ‘foo’, type: ‘data’, data: ‘2–27–2009’ }]</em></span></pre><p id="e200" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到现在为止，你可能已经理解了当我们把一个对象放入一个数组中，而不是添加对象的内容，引用被复制。因此，如果您更改了对象或数组，它将修改相同的引用。所以数组和对象同时得到更新。</p><p id="0881" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在下一个问题:<strong class="jm io">array . push()是深度复制还是浅层复制？</strong></p><p id="c2d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于那些不知道什么是深度和浅度复制的人，这里有一个快速定义。</p><h2 id="016a" class="lj lk in bd lu lv lw dn lx ly lz dp ma jv mb mc md jz me mf mg kd mh mi mj mk bi translated">浅拷贝</h2><p id="4e89" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">浅层拷贝是对象的逐位拷贝。创建一个新对象，该对象具有原始对象中值的精确副本。如果对象的任何字段是对其他对象的引用，则仅复制引用地址，即仅复制存储器地址。所以，如果你改变任何一个对象，由于共享公共引用，两个对象都会改变。</p><h2 id="d0b6" class="lj lk in bd lu lv lw dn lx ly lz dp ma jv mb mc md jz me mf mg kd mh mi mj mk bi translated">深层拷贝</h2><p id="8998" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">深度复制复制所有字段，并复制这些字段所指向的动态分配的内存。当对象与其引用的对象一起被复制时，就会发生深度复制。所以，如果你改变任何一个对象，只有那个对象会被改变，因为两者都有不同的引用。</p><p id="3939" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以回答上面的问题，取决于你在推动什么。对象和数组作为指向原始对象的指针被推入。像数字或布尔这样的内置基本类型作为一个副本被推送。</p><p id="8262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们进一步扩展上面的例子，</p><pre class="kj kk kl km gt le lf lg lh aw li bi"><span id="f61b" class="lj lk in lf b gy ll lm l ln lo">var array = [];<br/>var y = {name: "test", type: "data", data: "2-27-2009"};<br/>array.push(y);<br/>y = {}; <br/>y.name = 'bar';<br/>console.log(array);<br/>console.log(y);</span></pre><p id="3cde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出是:</p><pre class="kj kk kl km gt le lf lg lh aw li bi"><span id="7a6c" class="lj lk in lf b gy ll lm l ln lo">// array <br/>[ { name: ‘test’, type: ‘data’, data: ‘2–27–2009’ } ]</span><span id="4f60" class="lj lk in lf b gy lt lm l ln lo">// y<br/>{ name: ‘bar’ }</span></pre><p id="77d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，数组值在改变“y.name”后没有改变，因为当我们初始化时</p><pre class="kj kk kl km gt le lf lg lh aw li bi"><span id="854e" class="lj lk in lf b gy ll lm l ln lo">y = {}</span></pre><p id="789e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lp lq lr lf b">y</code>指向新的引用，现在之前复制到数组的引用只被数组指向。所以，通过改变<code class="fe lp lq lr lf b">y</code>的值，数组值不会改变。</p><p id="d9ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">深度复制变量的最佳实践是什么，这样我们就不会面临这个问题？</strong></p><p id="6a7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将在下一篇文章中讨论这个问题。在那之前，祝你阅读愉快。</p><p id="a46a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">同一作者的更多文章:</strong></p><ol class=""><li id="94d3" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated"><a class="ae ki" href="https://mevasanth.medium.com/how-everything-is-object-in-javascript-a4164d7e6a2d" rel="noopener">JavaScript中的一切都是对象吗？</a></li><li id="d2e4" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/problem-with-returning-values-from-async-await-function-javascript-e99c94a47ca5">异步Await函数返回值的问题</a></li><li id="380f" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ki" href="https://mevasanth.medium.com/hoisting-in-javascript-hot-topic-for-interview-43b463a6a77?source=follow_footer---------0----------------------------" rel="noopener">JavaScript中的提升:面试热门话题</a></li><li id="eb6e" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated"><a class="ae ki" href="https://mevasanth.medium.com/memoization-in-javascript-hot-topic-for-interview-815475544ab0" rel="noopener">JavaScript中的记忆化——采访热门话题</a></li></ol><p id="9ab2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里阅读作者<a class="ae ki" href="https://mevasanth.medium.com/" rel="noopener">的所有文章。</a></p><p id="b5df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ls">更多内容请看</em><a class="ae ki" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ls">plain English . io</em></strong></a></p></div></div>    
</body>
</html>