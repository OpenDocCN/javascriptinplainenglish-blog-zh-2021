<html>
<head>
<title>How to Make Certain Properties Optional in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使某些属性在TypeScript中可选</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-certain-properties-optional-in-typescript-9b4f8e85c5de?source=collection_archive---------2-----------------------#2021-10-26">https://javascript.plainenglish.io/how-to-make-certain-properties-optional-in-typescript-9b4f8e85c5de?source=collection_archive---------2-----------------------#2021-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/22a5a275b3374eca80179c938cda4656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MuhNdDrdd88Z2pVi"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e6bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接口的声明是使一些属性可选的地方。您可以通过在属性名称旁边打一个问号来实现这一点。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f7de" class="lh li in ld b gy lj lk l ll lm">interface Person {<br/>    uuid: string;<br/>    name: string;<br/>    surname: string;<br/>    sex: string;<br/>    height: number;<br/>    age: number;<br/>    pet?: Animal;<br/>}</span><span id="7231" class="lh li in ld b gy ln lk l ll lm">interface Animal {<br/>    name: string;<br/>    age: number;<br/>}</span></pre><p id="82b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，<code class="fe lo lp lq ld b">pet</code>是一个可选属性。这很有用，但是每次你想在<code class="fe lo lp lq ld b">Person</code>的<code class="fe lo lp lq ld b">pet</code>上执行一些操作时，你需要检查它是否被声明，因为<code class="fe lo lp lq ld b">pet?: Animal;</code>是<code class="fe lo lp lq ld b">pet: Animal | undefined;</code>语法的简写。</p><h1 id="0798" class="lr li in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">小案例研究</h1><p id="480d" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">假设你想做一个像<code class="fe lo lp lq ld b">J. Doe</code>一样返回姓名首字母和姓氏的函数。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="659a" class="lh li in ld b gy lj lk l ll lm">function personShortName(name: string, surname: string): string {<em class="mt"><br/>    </em>return `${name[0]} ${surname}`;<br/>}</span><span id="5671" class="lh li in ld b gy ln lk l ll lm">const person1: Person = { /* Person properties */ };</span><span id="ffe5" class="lh li in ld b gy ln lk l ll lm">personShortName(person1.name, person1.surname);</span></pre><p id="264d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用<code class="fe lo lp lq ld b">Person</code>类型对象作为函数参数，而不是每次调用<code class="fe lo lp lq ld b">personShortName()</code>时都访问<code class="fe lo lp lq ld b">name</code>和<code class="fe lo lp lq ld b">surname</code>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8d89" class="lh li in ld b gy lj lk l ll lm">function personShortName(person: Person): string {<em class="mt"><br/>    </em>return `${person.name[0]} ${person.surname}`;<br/>}</span></pre><p id="9063" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，我们也可以使用析构来简化这个函数，如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a119" class="lh li in ld b gy lj lk l ll lm">function personShortName({name, surname}: Person): string {<em class="mt"><br/>    </em>return `${name[0]} ${surname}`;<br/>}</span></pre><p id="b502" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">似乎不错，但看看它的局限性。你需要一个<code class="fe lo lp lq ld b">Person</code>类型的对象来调用一个简单的函数。现在，如果您想在其他地方调用它，您需要创建一个新的<code class="fe lo lp lq ld b">Person</code>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="28b7" class="lh li in ld b gy lj lk l ll lm">❌ personShortName({ name: 'Robert', surname: 'Doe' })</span></pre><p id="7b93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于<code class="fe lo lp lq ld b">{ name: string, surname: string }</code>与<code class="fe lo lp lq ld b">Person</code>类型不匹配，上述示例不适用。</p><h1 id="409d" class="lr li in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">那如何实现双赢呢？</h1><p id="43cd" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">Typescript获得了一个<code class="fe lo lp lq ld b">Partial&lt;T&gt;</code>实用程序类型，该类型简单地使得<code class="fe lo lp lq ld b">T</code>的所有属性都是可选的。如果我们使用<code class="fe lo lp lq ld b">Partial&lt;Person&gt;</code>而不是<code class="fe lo lp lq ld b">Person</code>作为<code class="fe lo lp lq ld b">personShortName()</code>中的参数类型，那么前面的例子就有效了:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="95eb" class="lh li in ld b gy lj lk l ll lm">function personShortName({name, surname}: Partial&lt;Person&gt;): string {<em class="mt"><br/>    </em>return `${name[0]} ${surname}`;<br/>}</span><span id="d7dc" class="lh li in ld b gy ln lk l ll lm">️personShortName({ name: 'Robert', surname: 'Doe' });</span></pre><p id="8c3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我们这里有个副作用，<code class="fe lo lp lq ld b">{ name: string; surname; string }</code>变成了<code class="fe lo lp lq ld b">{ name: string | undefined; surname: string | undefined; }</code>。</p><p id="de14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，为了防止返回像“u. undefined”这样奇怪的结果，我们需要在函数内部执行一些类型检查，确保每个需要的变量都被定义。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ec3f" class="lh li in ld b gy lj lk l ll lm">function personShortName({name, surname}: Partial&lt;Person&gt;): string | null {<em class="mt"><br/>    </em>return name &amp;&amp; surname ? `${name[0]} ${surname}` : null;<br/>}</span></pre><p id="626c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经实现了…另一个副作用——现在我们的函数可能会返回<code class="fe lo lp lq ld b">null</code>,这可能会在其使用的地方强制进行一些额外的检查。</p><p id="f8e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是不要担心——有更好的方法。TypeScript还提供了另一个实用程序类型— <code class="fe lo lp lq ld b">Pick&lt;T, Keys&gt;</code>，它从<code class="fe lo lp lq ld b">T</code>中选择一些属性<code class="fe lo lp lq ld b">Keys</code>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="90a1" class="lh li in ld b gy lj lk l ll lm">function personShortName({ name, surname }: Pick&lt;Person, 'name' | 'surname'&gt;): string  {<br/>    return `${name[0]} ${surname}`;<br/>}</span></pre><p id="94ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样我们就实现了我们的目标——我们允许双向调用这个函数——传递一个有效的<code class="fe lo lp lq ld b">Person</code>对象或者只传递需要的变量。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="343a" class="lh li in ld b gy lj lk l ll lm">personShortName({ name: 'John', surname: 'Doe' });</span><span id="845b" class="lh li in ld b gy ln lk l ll lm">const someone: Person = { name: 'John', ... }<br/>personShortName(someone);</span></pre><h1 id="3e90" class="lr li in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">更进一步</h1><p id="b083" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">在上面的解决方案中，您无法访问<code class="fe lo lp lq ld b">personShortName</code>函数中剩余的<code class="fe lo lp lq ld b">Person</code>属性。让我们假设您想要实现一个仅在最简单的变体中使用<code class="fe lo lp lq ld b">name</code>和<code class="fe lo lp lq ld b">surname</code>的函数，但是您也想要访问其他<code class="fe lo lp lq ld b">Person</code>属性。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c329" class="lh li in ld b gy lj lk l ll lm">function personShortName(person: Person): string  {<br/>  const { name, surname, uuid } = person;<br/>  if (uuid) {<br/>    const userRole = getUserRole(uuid);<br/>    return `${name[0]} ${surname}, ${userRole}`;<br/>  } <br/>    <br/>  /* some other operations on persons params */<br/>   <br/>  return `${name[0]} ${surname}`;<br/>}</span></pre><p id="2960" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种实现不允许您直接使用带有<code class="fe lo lp lq ld b">name</code>和<code class="fe lo lp lq ld b">surname</code>的简单调用。但是当没有<code class="fe lo lp lq ld b">uuid</code>时，我们不需要所有的<code class="fe lo lp lq ld b">Person</code>属性来返回短名称。我们需要访问所有的<code class="fe lo lp lq ld b">Person</code>属性，但是应该只需要<code class="fe lo lp lq ld b">name</code>和<code class="fe lo lp lq ld b">surname</code>。也许然后让我们允许<code class="fe lo lp lq ld b">person: Person | Pick<em class="mt">&lt;</em>Person, 'name' | 'surname'<em class="mt">&gt;</em></code>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="661f" class="lh li in ld b gy lj lk l ll lm">function personShortName(person: Person | Pick&lt;Person, 'name' | 'surname'&gt;)): string  {<br/>  ❌ const { name, surname, uuid } = person;<br/>  if (uuid) {<br/>    const userRole = getUserRole(uuid);<br/>    return `${name[0]} ${surname}, ${userRole}`;<br/>  }<br/>    <br/>  /* some other operations on persons params */<br/>    <br/>  return `${name[0]} ${surname}`;<br/>}</span></pre><p id="da3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是个好主意，但还是行不通。编译器会说<code class="fe lo lp lq ld b">property uuid don't exist on type { name: string, surname: string }</code>。</p><h1 id="c98b" class="lr li in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">解决方案是结合</h1><p id="1c18" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">这种方法是一个很好的方向，因为我们已经声明我们需要一个完整的<code class="fe lo lp lq ld b">Person</code>或<code class="fe lo lp lq ld b">{ name, surname }</code>。但事实上，我们不想要整个<code class="fe lo lp lq ld b">Person</code>或<code class="fe lo lp lq ld b">{ name, surname }</code>。我们想要完成的事情是让所有的<code class="fe lo lp lq ld b">Person</code>属性<strong class="kc io">可选</strong>和<code class="fe lo lp lq ld b">name, surname</code>成为<strong class="kc io">必需</strong>。我们可以通过组合<code class="fe lo lp lq ld b">Partial&lt;T&gt;</code>和<code class="fe lo lp lq ld b">Pick&lt;T, Keys&gt;</code>实用程序类型来实现这一点。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6587" class="lh li in ld b gy lj lk l ll lm">function personShortName(person: Partial&lt;Person&gt; &amp; Pick&lt;Person, 'name' <!-- -->| <!-- -->'surname'&gt;)): string  {<br/>  const { name, surname, uuid } = person;<br/>  if (uuid) {<br/>    const userRole = getUserRole(uuid);<br/>    userRole = getUserRole(uuid);<br/>    return `${name[0]} ${surname}, ${userRole}`;<br/>  }</span><span id="e553" class="lh li in ld b gy ln lk l ll lm">  /* some other operations on persons params */</span><span id="8705" class="lh li in ld b gy ln lk l ll lm">  return `${name[0]} ${surname}`;<br/>}</span></pre><p id="0583" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的语法，<code class="fe lo lp lq ld b">Partial&lt;Person&gt; &amp; Pick&lt;Person, 'name' | 'surname'&gt;</code>给了我们这样的类型:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="911b" class="lh li in ld b gy lj lk l ll lm">person: {<br/>    uuid?: string;<br/>    name: string; &lt;- required<br/>    surname: string; &lt;- required<br/>    sex?: string;<br/>    height?: number;<br/>    age?: number;<br/>    pet?: Animal;<br/>}</span></pre><p id="1538" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过这种方式，我们可以拥有一些必需的属性，而其他的则变成可选的。希望你会觉得有用。</p><p id="1800" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mt">~ Dawid Witulski @ evonica—2021</em></p><p id="b24e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mt">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>