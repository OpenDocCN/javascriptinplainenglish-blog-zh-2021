<html>
<head>
<title>Simplify State Management in React with the useReducer Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过与用户互动简化状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simplify-state-management-in-react-with-usereducer-hook-bea33fc17018?source=collection_archive---------15-----------------------#2021-07-13">https://javascript.plainenglish.io/simplify-state-management-in-react-with-usereducer-hook-bea33fc17018?source=collection_archive---------15-----------------------#2021-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9a22" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用refactor中的“useReducer”钩子重构useState并简化状态管理。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/08325e60eaa27965579630def3b8720d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gQBT_k7dowZaS1Ls"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@yanots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Yan Ots</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5fdc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们有简单的状态管理问题时<code class="fe lp lq lr ls b">useState</code>是合适的钩子。但是，如果我们有多个状态变量在同一个事件中发生变化，管理状态有时会很复杂。在这种情况下，首选<code class="fe lp lq lr ls b">useReducer</code>挂钩。</p><p id="8d00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将看到一个简单的Todo应用程序，它使用了<code class="fe lp lq lr ls b">useState</code>并重构它来使用<code class="fe lp lq lr ls b">useReducer</code>钩子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/3aff1b2823b763c22f7e2754f0c56f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ORBLoR3o_qjm4dOXPfGFOw.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Todo list application</figcaption></figure><p id="60d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的应用程序的主要组件目前如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="bdc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们必须在应用程序中管理三种状态；<code class="fe lp lq lr ls b">todos</code>、<code class="fe lp lq lr ls b">status</code>和<code class="fe lp lq lr ls b">error</code>。<code class="fe lp lq lr ls b">status</code>状态跟踪我们的网络请求是加载成功还是返回错误响应。因此，在发出请求时，我们会同时更新<code class="fe lp lq lr ls b">error</code>和<code class="fe lp lq lr ls b">status</code>或<code class="fe lp lq lr ls b">todos</code>和<code class="fe lp lq lr ls b">status</code>。与其进行多次状态更新，不如将状态逻辑封装在一个缩减器中。</p><p id="f890" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">减速器</strong>基本上是一种随着动作进入旧状态并返回新状态的功能。我们的减速器将管理四个动作的状态更新。我们将使用switch语句有条件地处理我们的操作。我们通过<code class="fe lp lq lr ls b">action</code>参数传递所有的响应有效载荷和动作类型。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="30a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每次我们返回一个新的状态时，我们使用扩展运算符将它与先前的状态连接起来，并且只更改我们希望修改的值。我们的最终减速器功能如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a5a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们已经定义了我们的reducer函数，我们可以重构我们的主要组件来使用<code class="fe lp lq lr ls b">useReducer</code>钩子。</p><p id="644e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先要改变的是我们状态的初始化。<code class="fe lp lq lr ls b">useReducer</code>钩取我们的<code class="fe lp lq lr ls b">reducer</code>功能和初始状态。我们还破坏了状态变量和<code class="fe lp lq lr ls b">dispatch</code>函数的输出，用来触发状态变化。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="ef12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当进行状态改变时，我们通过传入动作类型和一些附加数据来使用<code class="fe lp lq lr ls b">dispatch</code>功能。</p><p id="fd7f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当todos成功从服务器中取出时，我们就是这样触发状态更新的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0e28" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用<code class="fe lp lq lr ls b">useReducer</code>替换所有<code class="fe lp lq lr ls b">useState</code>调用后，我们重构的<code class="fe lp lq lr ls b">App.js</code>文件将如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0341" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文到此为止。希望你喜欢读它。你可以在这里找到完整的源代码。</p><p id="b833" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lw">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>