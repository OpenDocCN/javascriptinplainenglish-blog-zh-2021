<html>
<head>
<title>Shuffle String: How to Solve using a Hash Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混洗字符串:如何使用哈希映射解决</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/shuffle-string-how-to-solve-using-a-hash-map-a1dfc3cdb461?source=collection_archive---------18-----------------------#2021-05-28">https://javascript.plainenglish.io/shuffle-string-how-to-solve-using-a-hash-map-a1dfc3cdb461?source=collection_archive---------18-----------------------#2021-05-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f25f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用哈希映射解决此算法问题的演练。</h2></div><p id="930e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">伙计，我真的开始喜欢哈希图了。</p><p id="de90" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种感觉很奇怪。就在几个月前，我自己几乎不能解决一个算法问题，更不用说提出一个足够有效的解决方案了。虽然我仍然认识到我需要克服的巨大差距，以达到我作为一名软件开发人员想要达到的目标，但认识到我自我发展中的这些小胜利是很重要的。</p><p id="6fe5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种感觉没有什么不同——反复使用哈希映射迫使我考虑将它作为我最近遇到的大多数算法问题的一个选项，感觉我终于<em class="ky">打开了我大脑的那一侧</em>真好。</p><p id="4da7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">沃伦，祝贺你坚持下去&amp;没有放弃。</p><p id="bb3c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">足够的积极性——让我们来解决这个洗牌的问题。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/1cfb6984e90c88e18f07914bdee06b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HbNROfaNCghCaX-v"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Let’s get shuffling</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="1756" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">问题是</h1><p id="d8ce" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated"><em class="ky">注意，这个问题在Leetcode (#1528)上。要直接尝试这个问题，请访问:</em><a class="ae mt" href="https://leetcode.com/problems/shuffle-string/" rel="noopener ugc nofollow" target="_blank"><em class="ky">https://leetcode.com/problems/shuffle-string/</em></a></p><p id="7dc2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的问题是:</p><p id="ab6e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">给定一个字符串s，和一个长度相同的整数数组下标。字符串s将被混洗，使得在第</em> <strong class="ke io"> <em class="ky"> i- </em> </strong> <em class="ky">位置的字符移动到混洗后的字符串中的索引[i]。返回混洗的字符串。</em></p><p id="5086" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，这听起来有点令人困惑——让我们从Leetcode中引入一个例子，尝试更好地形象化这个问题。</p><p id="198b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有两个输入，一个字符串和一个整数数组。假设我们的两个输入如下:</p><p id="4b27" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输入字符串:" codeleet" <br/>整数数组:[4，5，6，7，0，2，1，3]</p><p id="f7e7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么我们的预期产量是多少呢？让我们重新阅读说明中的下面一行:</p><p id="e6b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">字符串s将被混洗，使得在第</em> <strong class="ke io"> <em class="ky"> i- </em> </strong> <em class="ky">位置的字符移动到混洗后的字符串中的索引[i]。</em></p><p id="3488" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着“c”将移至第4个索引，“o”将移至第5个索引，“d”将移至第6个索引，依此类推。</p><p id="8c7b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的预期输出如下所示:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mu"><img src="../Images/403832d95472eb626d2e810c93804453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*yd3UOVoy-eKybn4FVJvajw.png"/></div></div></figure><p id="e28e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了！既然我们理解了这个问题，我们应该如何处理这个问题呢？</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="68d4" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">方法</h1><p id="dda1" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">所以我们需要以某种方式将我们的字母移动到它们相应的索引中。因为我们已经知道它们应该位于哪个数字和分配的索引，所以我们可以将它们设置为哈希表中的键值对！</p><ol class=""><li id="d644" class="mv mw in ke b kf kg ki kj kl mx kp my kt mz kx na nb nc nd bi translated">实例化一个空散列来存储我们的索引和它们对应的字符</li><li id="1904" class="mv mw in ke b kf ne ki nf kl ng kp nh kt ni kx na nb nc nd bi translated">实例化一个新的字符串，在这里我们将按照它们的混合顺序构造新组织的字符串</li><li id="205d" class="mv mw in ke b kf ne ki nf kl ng kp nh kt ni kx na nb nc nd bi translated">建立一个for循环，它将迭代我们的索引数组的长度，用我们的键值对填充我们的哈希映射——从第零个索引开始</li><li id="4370" class="mv mw in ke b kf ne ki nf kl ng kp nh kt ni kx na nb nc nd bi translated">建立第二个for循环，通过在hash映射中查找键值对来构造我们的字符串</li><li id="d270" class="mv mw in ke b kf ne ki nf kl ng kp nh kt ni kx na nb nc nd bi translated">在函数的末尾返回我们新构造的字符串</li></ol></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="5b30" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">解决方案</h1><p id="509a" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">我们试一试，一步一步来。</p><p id="6fa0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的前两步包括实例化一个空散列和新的混洗字符串，我们将在函数结束时返回。很简单！</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/3b9e2aacebdc4a2f742160e4e80a8c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*ms3xmSphl_86j3ZY2hWjfg.png"/></div></figure><p id="7989" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，一切顺利。</p><p id="cdda" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的下一步是迭代我们的索引输入数组。记住，在这一步中，我们的目标是从第零个索引开始构建散列图。因为我们在字符串输入中有我们的索引和它们对应的字符，所以我们可以将散列的键设置为索引，将它们对应的值设置为字符串输入中的字符。要获取特定索引处的字符串值，我们可以使用<strong class="ke io"> charAt() </strong> string方法。</p><p id="7379" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在我们的例子中，s.charAt(0)将返回给我们“c”。</p><p id="069a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们构建我们的散列图:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nk"><img src="../Images/b6c46e118efa77d91a53ddae6d9d5b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9lvJ_hVblx4TbgX2z_T0A.png"/></div></div></figure><p id="837d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在每次迭代中，我们都将键(索引)设置为输入字符串中相应的值。</p><p id="fad9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您在我们的console.log中看到的，我们有一个构建得很好的散列映射，它以升序排列我们的键，因此给出了我们想要的结果(“leetcode”)。</p><p id="2e2a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的最后一步是迭代我们的散列映射，并将我们的值添加到我们的newString变量中:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nl"><img src="../Images/fbe3a398866d7f05227b295d8ff0f4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kySLjI9FBc7T6DFfr-zmww.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Our final solution</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="81f0" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">结论</h1><p id="3850" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">现在你知道了！通过使用散列映射，我们可以立即将索引和它们在输入字符串中对应的字符联系在一起。通过对索引数组进行迭代，然后按照索引的顺序构建哈希表&amp;将我们的字母按照它们对应的顺序放置，最终得到我们想要的结果。</p><p id="1e1d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然散列图是解决这个问题的一种方法，但我很想听听你是如何解决这个问题的！欢迎在下方留言或直接联系我。</p><p id="84d7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下次见。</p><p id="c134" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容尽在</em><a class="ae mt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>