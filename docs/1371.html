<html>
<head>
<title>JavaScript Callbacks Explained in Plain English</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用简单的英语解释JavaScript回调</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/explaining-callbacks-in-javascript-in-plain-english-df01760ccfc3?source=collection_archive---------18-----------------------#2021-03-22">https://javascript.plainenglish.io/explaining-callbacks-in-javascript-in-plain-english-df01760ccfc3?source=collection_archive---------18-----------------------#2021-03-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/522f79d2101166c92dc826ce103e48aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*imzqI7w0WSe1k34Fp7MDdQ.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Creator: Grafner | Credit: Getty Images/iStockphoto | Copyright: Grafner</figcaption></figure><p id="2c7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript中的回调函数是<em class="kt">一个在另一个函数执行完毕后被调用的函数。</em></p><p id="9afe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于JavaScript使用事件驱动的编程模型，所以它不会等待一个函数完成执行，而是立即转移到下一个函数。回调使您可以将一个函数设置为仅在另一个函数完成执行后才执行。</p><p id="c0f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript中的函数是<em class="kt">一级对象</em>，这意味着它们可以被赋给变量，作为函数参数传递，或者可以被赋为另一个函数的返回值。任何作为参数传递给另一个函数并在外部函数中调用的函数都是回调函数。让我们看看下面的例子:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="f8b5" class="ld le in kz b gy lf lg l lh li">const hi = () =&gt; console.log('Hi');<br/>const bye = () =&gt; console.log('Bye');</span><span id="7d92" class="ld le in kz b gy lj lg l lh li">hi();<br/>bye();</span></pre><p id="cd5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，将首先执行功能<code class="fe lk ll lm kz b"><em class="kt">hi</em> </code>，然后执行功能<code class="fe lk ll lm kz b"><em class="kt">bye </em></code>。控制台中记录的结果将是，</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="7e5c" class="ld le in kz b gy lf lg l lh li">//Hi<br/>//Bye</span></pre><p id="30cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果我们的函数在做一些复杂的事情呢？让我们假设这个函数正在从服务器获取数据。根据具体情况，服务器可能需要一些时间来处理这个请求。</p><p id="33ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好地说明这个例子，我们可以使用<code class="fe lk ll lm kz b"><em class="kt">setTimeout</em></code> <em class="kt"> </em>函数，它在指定的时间后执行一段代码。我们将把函数的执行延迟1秒，就像它是一个获取请求一样。让我们看看我们的代码，</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="e95f" class="ld le in kz b gy lf lg l lh li">function hi() {</span><span id="eb03" class="ld le in kz b gy lj lg l lh li">    // Imagine function hi is fetching data from the server here</span><span id="1556" class="ld le in kz b gy lj lg l lh li">    setTimeout(function() {</span><span id="48aa" class="ld le in kz b gy lj lg l lh li">       console.log('Hi');</span><span id="b736" class="ld le in kz b gy lj lg l lh li">    }, 1000);</span><span id="da7d" class="ld le in kz b gy lj lg l lh li">}</span><span id="82b0" class="ld le in kz b gy lj lg l lh li">function bye() {</span><span id="4d09" class="ld le in kz b gy lj lg l lh li">   console.log('Bye');<br/>}<br/></span><span id="28f6" class="ld le in kz b gy lj lg l lh li">hi();</span><span id="e3bd" class="ld le in kz b gy lj lg l lh li">bye();</span></pre><p id="c5bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经将函数<code class="fe lk ll lm kz b"><em class="kt">hi</em></code> <strong class="jx io"> </strong>的执行延迟了1000毫秒(1秒)，我们在控制台中的结果是</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="a66c" class="ld le in kz b gy lf lg l lh li">//Bye<br/>//Hi</span></pre><p id="774e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在等待过程中,<code class="fe lk ll lm kz b">Bye()</code>被执行。这就是为什么Bye印在Hi之前。JavaScript不会破坏函数调用的顺序，它只是不等待函数<code class="fe lk ll lm kz b"><em class="kt">hi</em></code> <em class="kt"> </em>的响应，而是立即移动到下一个函数。</p><p id="7720" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里最重要的一点是<em class="kt">异步函数不会互相等待</em>。您无法预测哪个函数将花费最短的时间来执行。再一次，<strong class="jx io"> <em class="kt">回调使得设置一个函数仅在另一个函数执行完</em>后执行成为可能。</strong></p><h1 id="1651" class="ln le in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何创建回调</h1><p id="ed98" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">可以使用<code class="fe lk ll lm kz b"><em class="kt">callback</em></code> <em class="kt"> </em>关键字作为最后一个参数来创建自定义回调函数。然后可以在函数结束时调用。如果我们想确定我们正在传递一个函数作为参数，我们可以使用<strong class="jx io"> <em class="kt"> </em> </strong> <code class="fe lk ll lm kz b"><strong class="jx io"><em class="kt">typeof.</em></strong></code></p><p id="c44c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们打开一个控制台，写下:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="a718" class="ld le in kz b gy lf lg l lh li">const watchingNetflix = (movie) =&gt; console.log(`Watching ${movie}.`);</span></pre><p id="47b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的函数接受一个参数。您可以通过在控制台中键入以下命令来调用它:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="6c14" class="ld le in kz b gy lf lg l lh li">watchingNetflix('Friends'); </span><span id="ac06" class="ld le in kz b gy lj lg l lh li">// Watching Friends.</span></pre><p id="2fc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们给函数添加一个回调。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="bf5d" class="ld le in kz b gy lf lg l lh li">const watchingNetflix = (movie, callback) =&gt; {  <br/>  console.log(`Watching ${movie}`)      </span><span id="c3b5" class="ld le in kz b gy lj lg l lh li"> if (typeof callback === 'function');      </span><span id="0a8c" class="ld le in kz b gy lj lg l lh li"> callback();<br/>};</span><span id="d2ad" class="ld le in kz b gy lj lg l lh li">watchingNetflix('Friends', () =&gt; console.log('Watched all the seasons'));</span></pre><p id="3f9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你在控制台中输入这个代码，你会得到两条消息，第一条消息是“观看朋友”，第二条消息是“观看了所有季节”。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="fbf7" class="ld le in kz b gy lf lg l lh li">// Watching Friends</span><span id="263b" class="ld le in kz b gy lj lg l lh li">// Watched all the seasons</span></pre><p id="1fe8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lk ll lm kz b"><em class="kt">WatchingNetflix</em></code> <strong class="jx io"> <em class="kt"> </em> </strong>函数<strong class="jx io"> <em class="kt"> </em> </strong>先记录“看朋友”然后检查我们回调函数的类型，由于回调是一个函数，它得到执行并记录“看了所有季节”。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="b2c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的例子非常简单，我用它们来演示回调语法。回调函数在异步编程中变得非常方便，在异步编程中，一个函数必须等待另一个函数完成执行(例如，像等待文件加载)。</p><h2 id="d475" class="ld le in bd lo mw mx dn ls my mz dp lw kg na nb ma kk nc nd me ko ne nf mi ng bi translated">概括一下</h2><ul class=""><li id="22d4" class="nh ni in jx b jy mk kc ml kg nj kk nk ko nl ks nm nn no np bi translated">回调是作为参数传递给另一个函数的函数。</li><li id="e279" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">这种技术允许一个函数调用另一个函数。</li><li id="47af" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">回调函数可以在另一个函数完成后运行。</li></ul></div></div>    
</body>
</html>