<html>
<head>
<title>Compound Components: How to Write Flexible Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复合组件:如何在React中编写灵活的组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/compound-components-how-to-write-flexible-components-in-react-1cd6caa769fb?source=collection_archive---------5-----------------------#2021-10-25">https://javascript.plainenglish.io/compound-components-how-to-write-flexible-components-in-react-1cd6caa769fb?source=collection_archive---------5-----------------------#2021-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6599d9678cae88958e783abef24f8e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjoZUNSiji2nz3P3FlfJKA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ryanquintal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ryan Quintal</a> on <a class="ae kc" href="https://unsplash.com/s/photos/lego?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2f91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我问的第一个问题是，我为什么要关心和学习更多关于复合组件的知识？</p><h1 id="4a3a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">复合组件解决什么问题？</strong></h1><p id="ed48" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">问题是你的组件没有足够的灵活性，尤其是当你不知道或者不能预测消费者将如何使用你的组件的每一个用例的时候。</p><p id="03ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一下我们示例中的一个<code class="fe me mf mg mh b">Todo</code>组件，如下所示:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/319d0e5fd1effde1196714025aa44071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JKlcz5QiYa5nbP4UeVd4Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Todo component</figcaption></figure><p id="cb19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它包含了一个标题、输入、列表、添加和清除按钮，但是如果消费者不想要一个清除按钮呢？然后，我们可能必须给我们的<code class="fe me mf mg mh b">Todo</code>组件添加一个额外的道具，然后公开新版本，消费者必须添加一个道具<code class="fe me mf mg mh b">&lt;Todo showClearButton={false} /&gt;</code>，这可能是痛苦的，这是一些组件的唯一可选渲染。想象一下，我们想改变添加按钮的位置，让它在输入的左边，这可能是一个麻烦。</p><p id="1c73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许有一种方法可以让我们的组件消费者无需付出这种努力就能完成所有这些更改？这是本文要解决的问题。</p><p id="5d77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先说复合组件，挖点代码！</p><h1 id="8cdd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">例子</strong></h1><p id="0e82" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们有一个呈现<code class="fe me mf mg mh b">TodoHeader</code>、<code class="fe me mf mg mh b">TodoInput</code>、<code class="fe me mf mg mh b">TodoClearButton</code>、<code class="fe me mf mg mh b">TodoAddButton</code>和<code class="fe me mf mg mh b">TodoList</code>的<code class="fe me mf mg mh b">Todo</code>组件，用当前的实现可能很难改变元素在页面上的位置。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="94eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，如果没有消费者处理待办状态变更(<code class="fe me mf mg mh b">list</code>、<code class="fe me mf mg mh b">todo</code>)，这是很难做到的，因为你要么不得不使用<code class="fe me mf mg mh b">Todo</code>组件作为黑盒，只需呈现<code class="fe me mf mg mh b">&lt;Todo /&gt;</code>，要么你不得不透露实现细节并将处理变更的责任推给消费者，这并不理想，对吗？</p><p id="78ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我是待办事项列表组件的消费者，我不想担心当用户点击添加按钮时更新待办事项列表的状态，或者当用户键入某些内容时更改当前待办事项的值，这是组件本身的职责。</p><p id="ceb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的问题是像<code class="fe me mf mg mh b">onAddTodo</code>、<code class="fe me mf mg mh b">onClearTodo</code>和<code class="fe me mf mg mh b">todos</code>这样的道具从父<code class="fe me mf mg mh b">Todo</code>组件传递到其子组件，所以问题是我们如何移除它们？</p><p id="6c27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">营救的背景</strong></p><p id="14b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">答案是使用上下文，我们必须更改<code class="fe me mf mg mh b">Todo</code>组件实现来创建上下文，并且只有逻辑负责状态更改。上下文应该有<code class="fe me mf mg mh b">Todo</code>组件子组件所需的所有方法、变量</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="45d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第<code class="fe me mf mg mh b">4-5</code>行，我们有与之前的<code class="fe me mf mg mh b">Todo</code>组件版本相同的状态，然后在第<code class="fe me mf mg mh b">7-16</code>行，我们定义了<code class="fe me mf mg mh b">value</code>变量，这是我们的上下文，然后我们将它传递给任何子组件(第<code class="fe me mf mg mh b">18</code>行)</p><p id="8d74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">clearList</code> (line <code class="fe me mf mg mh b">8</code>)方法是一个很好的例子，展示了我们如何将一些额外的逻辑封装到我们的上下文中，而不仅仅是清除todos列表，我们还清除输入值。</p><p id="d519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第<code class="fe me mf mg mh b">24-28</code>行，你可以看到Todo的子组件被赋值给<code class="fe me mf mg mh b">Todo</code>变量，以在我们的主组件和它的子组件之间创建紧密耦合，记住<code class="fe me mf mg mh b">TodoAddButton</code>或任何其他内部组件不应该在<code class="fe me mf mg mh b">Todo</code>上下文之外呈现，所以这是向消费者传达我们意图的一个非常好的方式。</p><p id="f062" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看应该在新文件中定义的上下文</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="709f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个消费者可以用来获取上下文的独立钩子是一个很好的实践</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="006e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就可以用一些逻辑来检查子组件是否已经被包装在上下文提供者(<code class="fe me mf mg mh b">Todo</code>组件)中，如果没有，我们抛出一个错误，应该立即说明发生了什么。</p><p id="f9c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后缺少的部分是新的子组件实现，首先，让我们看看前面的<code class="fe me mf mg mh b">TodoAddButton</code>实现是什么样子的</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e99b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和新的</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c87c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不再传递<code class="fe me mf mg mh b">onAddTodo</code>处理程序，在新版本中我们从上下文中获得<code class="fe me mf mg mh b">addTodo</code>和<code class="fe me mf mg mh b">todo</code>。</p><p id="320e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以回到我们最初的问题。我们的消费者希望在输入的左边有一个清除按钮？给你。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/714f883d33175620df339c2d01e6e097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWwFzU_4s7v5CQrhVTCMVg.png"/></div></div></figure><p id="bf1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/40445352874925c1233e1184469defde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Acy5mtOLSMcZLVC91QdfBQ.png"/></div></div></figure><p id="1944" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在消费者可以随意改变子组件的位置</p><p id="a950" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们使我们的<code class="fe me mf mg mh b">Todo</code>组件变得灵活，并且子组件的位置是不可知的。与不使用复合组件相比，这也是一种更具声明性的方式，你可以看到消费者在呈现过程中决定想要为<code class="fe me mf mg mh b">Todo.AddButton</code>或<code class="fe me mf mg mh b">Todo.ClearButton</code>添加什么标签，或者<code class="fe me mf mg mh b">Todo.Header</code>是否应该有一些额外的样式。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/7b6892d5c44de8681ff14ae8e4a11ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwGIIsnifFcf1equVxYumw.png"/></div></div></figure><p id="6a1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不使用上下文消费者，我们可能不得不添加和传递<code class="fe me mf mg mh b">Todo.ClearButton</code>标签和<code class="fe me mf mg mh b">Todo.Header</code>边距作为<code class="fe me mf mg mh b">Todo</code>组件的属性，如<code class="fe me mf mg mh b">&lt;Todo clearButtonLabel='' headerProps={} /&gt;</code>或使用<code class="fe me mf mg mh b">renderProps</code>。在我看来，两者都比当前的解决方案差，因为需要改变<code class="fe me mf mg mh b">Todo</code>组件。</p><p id="db04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">试着自己玩</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="ms mo l"/></div></figure><p id="d5b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们总结一下使用复合组件的利与弊</p><h2 id="052a" class="mt lc iq bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">使用复合组件的优点</h2><ul class=""><li id="7d71" class="nf ng iq kf b kg lz kk ma ko nh ks ni kw nj la nk nl nm nn bi translated">改变子组件位置的简单方法。</li><li id="8c2c" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">创建可以以声明方式配置的组件(消费者可以更改标签或某些样式，而无需更改父组件实现)</li><li id="6805" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">子组件与父组件紧密耦合</li></ul><h2 id="c29d" class="mt lc iq bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">使用复合组件的缺点</h2><ul class=""><li id="f16c" class="nf ng iq kf b kg lz kk ma ko nh ks ni kw nj la nk nl nm nn bi translated">更大的复杂性</li><li id="197f" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">更多代码</li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="fe0b" class="lb lc iq bd ld le oa lg lh li ob lk ll lm oc lo lp lq od ls lt lu oe lw lx ly bi translated"><strong class="ak">总结</strong></h1><h2 id="a308" class="mt lc iq bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">什么时候我们应该考虑使用复合组件？</h2><ul class=""><li id="29e8" class="nf ng iq kf b kg lz kk ma ko nh ks ni kw nj la nk nl nm nn bi translated">每当我们处理一个复杂的组件，并且我们不能在开始时预测它的每一个用例</li></ul><p id="890a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，父组件由几个基本组件组成，这些组件不应该在父上下文之外呈现。</p><p id="a6b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Menu</code>(父)和<code class="fe me mf mg mh b">Menu.ListItem</code>(基础)，当我们实现<code class="fe me mf mg mh b">Menu.ListItem</code>时，我们的意图是总是在<code class="fe me mf mg mh b">Menu</code>中呈现这个组件，所以<code class="fe me mf mg mh b">Menu.ListItem</code>不应该被用作没有父上下文的独立组件</p><ul class=""><li id="a272" class="nf ng iq kf b kg kh kk kl ko of ks og kw oh la nk nl nm nn bi translated">当我们想让复杂的组件更灵活时</li></ul><p id="f2e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Menu</code>组件有几个不同的子组件，可以用多种方式呈现，例如不同的位置。</p><p id="463c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">允许<code class="fe me mf mg mh b">Menu</code>组件消费者更改子组件位置的最佳方式是不要在开始时选择这些组件的位置，而是在以后选择，这样消费者可以选择组件位置</p><p id="f3ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">什么时候我们不该使用复合元件？</strong></p><ul class=""><li id="89d9" class="nf ng iq kf b kg kh kk kl ko of ks og kw oh la nk nl nm nn bi translated">对于像<code class="fe me mf mg mh b">Button</code>、<code class="fe me mf mg mh b">Input</code>这样的基本组件</li><li id="d62f" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated">如果我们想阻止消费者改变儿童的位置</li></ul><p id="c5fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望我对复合组件主题有所了解，并且您可以为自己找到一些有用的用例。</p><p id="7ca6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想保持联系或询问任何你能找到我的事情</p><p id="38d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推特:<a class="ae kc" href="https://twitter.com/k_wdowik" rel="noopener ugc nofollow" target="_blank"> <em class="oi"> k_wdowik </em> </a></p><p id="4265" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><p id="636f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">github:<a class="ae kc" href="https://github.com/kwdowik" rel="noopener ugc nofollow" target="_blank">T24】kwdowikT26】</a></p><p id="6935" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">感谢阅读！</strong></p><p id="0b98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oi">更多内容看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="oi">plain English . io</em></strong></a></p></div></div>    
</body>
</html>