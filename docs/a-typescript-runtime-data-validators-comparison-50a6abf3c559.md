# TypeScript 运行时数据验证器比较

> 原文：<https://javascript.plainenglish.io/a-typescript-runtime-data-validators-comparison-50a6abf3c559?source=collection_archive---------8----------------------->

## 第 1 部分:导言

![](img/26a0a1adca064bc8c925500e12adf117.png)

# **简介**

这是一份研究报告。希望为 TypeScript 项目找到“完美的运行时数据验证器”，我列出了“完美的验证器”应该实现的设计目标，并收集了一系列验证器 **(io-ts、joi、ajv、yup、zod 和 superstruct)** 来查看这些验证器是否实现了目标，以及实现得如何。我构建了一个项目，使用每个验证器来验证相同的数据。所有的验证者必须通过相同的测试用例集，这些测试用例代表了真实项目中一系列常见的和有点复杂的验证场景。

在构建项目的过程中，我获得了对这些验证器的实践经验和见解——不仅仅是阅读材料中陈述的内容，还包括黑客攻击、变通方法和故障，以及真实的代码。本系列与您分享这些见解和经验。

在被测试的验证器中，我的偏好是什么？你可以在最后一个帖子里找到，决定你是否同意我的观点。

1.  介绍
2.  [io-ts](/a-typescript-runtime-data-validators-comparison-eeedc6b0583a)
3.  [joi](/a-typescript-runtime-data-validators-comparison-c422e431926a)
4.  [没错](/a-typescript-runtime-data-validators-comparison-15f0ea2e3265)
5.  [ajv](/a-typescript-runtime-data-validators-comparison-cdbb532f0b89)
6.  佐德
7.  [超级结构](/a-typescript-runtime-data-validators-comparison-67cb9abb599b)

# 为什么要使用验证器？

因为您正在处理不在您控制范围内的数据。在客户端，您希望确保用户输入的格式正确。在服务器端，如果没有验证，你不能相信从互联网上收到的任何东西。然而，Typescript 已经[明确表示](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals)提供运行时类型信息或运行时类型检查不在他们的目标之内。作为一名程序员，您需要或者手工编写那些重复、乏味、无聊的代码来验证您的数据，或者使用已经可用的验证器。

使用验证器不仅可以让您不用编写太多代码，还可以鼓励您将数据的所有需求放在一个地方。例如，当您的服务器从互联网上接收到有关用户的数据时，您的代码可能会在这里检查用户的电子邮件，在那里检查其出生日期。关于有效用户的标准分散在您的代码库中。当使用验证器时，首先要创建一个模式，它作为一个规范，对于任何关心数据的人来说都是一个真实的来源。

# 设计目标

## 1.一个定义，多种用途

需要关于数据形状的定义，并以各种方式使用。代码编辑器和 Typescript 编译器需要将定义作为 Typescript 类型来执行代码完成、代码辅助和类型检查。验证器需要将定义作为运行时模式来进行验证。然而，手动维护和同步关于相同数据的两组定义是低效且容易出错的。数据应该被定义一次，并且允许代码编辑器、类型脚本编译器和运行时验证器都完成它们的工作。

此外，由于数据在服务器和浏览器之间来回发送，验证器最好在两端使用相同的定义来验证相同的数据。

## 2.可组合和可扩展

数据是可组合(由更小的结构组装而成)和可扩展的(向基本结构添加额外的结构)。数据定义也应该如此。组合或扩展的数据定义不应该复制和粘贴已经存在的数据结构的定义，而是通过引用组装或扩展到其中。

## 3.丰富的功能集

运行时数据验证需要比 Typescript 的静态类型检查更丰富的功能集。例如，一个值不仅是一个字符串，而且匹配一个模式，或者一个出生日期不仅是一个日期，而且使人至少 18 岁。验证器应该提供丰富的现成特性来满足最常见的需求。

## 4.完成并中止-早期验证

完整验证检查数据的所有属性和元素，并报告所有失败。完整验证对于前端的表单验证很有用。如果用户输入了无效的电子邮件和无效的出生日期，我们希望突出显示这两个错误。中止——早期验证中止该过程，并在第一次失败时报告。这在后端很有用，在后端，服务器会快速返回一个错误代码和一条简单的消息。验证器最好支持这两种模式。

## 5.可组合和定制

一个值通常有多个验证要求。例如，可能要求字符串具有最小长度、最大长度和匹配模式。验证器应该允许组合多个验证关键字来验证一个值。此外，当验证器提供的关键字不够时，验证器应该允许添加定制的验证，以便与现成的关键字一起工作。

## 6.类型强制和默认

如果提供了类型强制，验证器可以返回从输入转换而来的不同类型的数据。例如，ISO 日期字符串可以被强制转换为日期对象。如果提供了默认值，当输入中缺少某个值时，验证器应该返回一个默认值来代替缺少的值。

## 7.可遍历模式

除了验证用途之外，如果可以遍历架构以提取有关数据的有用信息，您的代码还可以以其他方式以编程方式使用运行时架构。

## 8.标准模式

如果模式是使用标准语言(比如 JSON Schema)定义的，这可能意味着它支持更多的工具、库和产品供您选择。

# 其他考虑

除了上述目标之外，包的大小、依赖性和验证器的流行程度也值得考虑。您可以在这里找到测试验证器[的这些因素的比较。](https://www.npmtrends.com/ajv-vs-joi-vs-yup-vs-zod-vs-io-ts-vs-superstruct)

# 该项目

测试项目验证以下数据:

**人**

- name:必选，字符串，长度 3~20，匹配模式/[a-z A-Z ]+/

- dob:日期，必需，必须使该人至少年满 18 岁

- sex:可选，如果提供，则必须是值“M”、“F”或“O”之一

-密码:必需，字符串，长度> = 5

**人形**

继承 Person 的所有属性，并添加:

- repeatPassword:必须与密码相同

**驱动**

继承 Person 的所有属性，并添加:

- licenseNo:字符串，长度 3~30，匹配模式/^[a-zA-Z]+$/

**车辆**

-类型:是“汽车”还是“公共汽车”

-座位:数量，整数，> =1

-长度:数字，> 0

**舰队**

对象阵列，每个对象包括驾驶员和车辆；

```
[{driver: Driver,vehicle: Vehicle}]
```

我用一组有效和无效的样本数据创建了测试用例，然后继续构建模式，通过每个验证器传递所有的测试用例。通过这种方式，我获得了实际的经验和对每个验证器如何实现每个设计目标的见解，而不仅仅是文档中陈述的内容。

特别是，我测试了模式是否是可组合的(车队模式重用了驾驶员和车辆的模式)和可扩展的(驾驶员模式扩展了人员模式)。我测试了 Typescript 类型是否可以从已定义的模式中生成或推断，以及这些类型的外观和工作方式。我测试了验证器是否既能完成完整的验证，又能快速、提前中止验证。我检查了从完整验证返回的错误对象，以查看它们是否包含完整且有用的失败信息。我还测试了验证器是否支持数据强制，以及我是否可以遍历运行时模式来提取关于数据的有用信息。

如果你急于动手，测试项目可以在这里找到[。在检查完项目之后，运行`npm install`和`npm test`来通过所有的测试用例，然后查看](https://github.com/bingtimren/typescript-validation-study) [/solutions](https://github.com/bingtimren/typescript-validation-study/tree/main/solutions) 目录来检查每个验证器的实现细节。您还可以导入从 Typescript 代码中的架构推断或生成的 Typescript 类型，并查看代码辅助和代码完成如何与您的首选代码编辑器一起工作。尝试`npm run inspect-error`来检查从一个样本舰队对象的完整验证返回的错误对象中包含了什么。如果支持的话，尝试用`npm run inspect-result`来检查样本 Person 对象的类型强制的结果。

或者，您可以在本系列的剩余部分继续阅读我使用这些验证器的经验报告。