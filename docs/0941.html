<html>
<head>
<title>Improve React performance without memo()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高React性能，无需备忘录()</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improve-react-performance-without-memo-4d388f45d028?source=collection_archive---------7-----------------------#2021-02-27">https://javascript.plainenglish.io/improve-react-performance-without-memo-4d388f45d028?source=collection_archive---------7-----------------------#2021-02-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0838" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的前一篇文章中，我描述了一些防止react应用程序过度渲染的方法。我重点使用了<code class="fe kj kk kl km b">useMemo</code>和<code class="fe kj kk kl km b">useCallback</code>挂钩和<code class="fe kj kk kl km b">memo()</code>挂钩。仅仅一天后，丹·阿布拉莫夫的一篇名为《在你备忘录之前的T21》的优秀文章发表了。今天，我将介绍如何将他博客中的技术应用于我文章中的问题。</p><h1 id="a0ed" class="ko kp in bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">问题陈述</h1><p id="9018" class="pw-post-body-paragraph jk jl in jm b jn lm jp jq jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh ig bi translated">让我们从我在<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/preventing-redundant-re-renders-in-react-c0de7c92d0b6">上一篇文章</a>中使用的完全相同的代码开始。我使用<code class="fe kj kk kl km b">Fibonacci</code>组件来模拟一个渲染时计算量很大的组件(所以我们不想在不需要的时候重新渲染它)。</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c00e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是它最初的用法。注意，默认情况下，每次<code class="fe kj kk kl km b">text</code>值改变时<code class="fe kj kk kl km b">Fibonacci</code>组件都会被重新渲染。这是一种糟糕的、缓慢的打字体验。</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ec48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上次这个问题是用<code class="fe kj kk kl km b">React.memo()</code> HOCs解决的。这次让我们探索其他的选择！</p><h1 id="7eb1" class="ko kp in bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">下移状态</h1><p id="02da" class="pw-post-body-paragraph jk jl in jm b jn lm jp jq jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh ig bi translated">我们可以观察到<code class="fe kj kk kl km b">Demo</code>组件是<code class="fe kj kk kl km b">text</code>状态的所有者，但是只有一部分对这个状态感兴趣。让我们把这部分提取成一个单独的组件！</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3385" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重构非常简单。<code class="fe kj kk kl km b">ControlledText</code>组件被提取，现在它是<code class="fe kj kk kl km b">text</code>状态的所有者。<code class="fe kj kk kl km b">Fibonacci</code>组件不像我们键入的那样重新呈现。太好了！</p><h1 id="b767" class="ko kp in bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">缝隙模式</h1><p id="e632" class="pw-post-body-paragraph jk jl in jm b jn lm jp jq jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh ig bi translated">在Dan的文章中，这种方法被称为<em class="kn">上移内容</em>并使用了<code class="fe kj kk kl km b">children</code> prop。其实我们并不局限于<code class="fe kj kk kl km b">children</code>道具。我们可以使用任意数量的插槽！</p><p id="c44f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我如何将这种技术应用到我的初始代码中</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ca70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只要<code class="fe kj kk kl km b">bottomSlot</code>道具不变，React就不会重新渲染。大获成功！由于副作用组件<code class="fe kj kk kl km b">DemoTemplate</code>没有耦合到应该在<code class="fe kj kk kl km b">bottomSlot</code>中呈现的特定组件，任何东西都可以在那里注入。</p><p id="670f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，插槽是从容器组件注入的，因此得名<em class="kn">上移内容。</em></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/3b0758599226939c6da7a8578cbd45ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*uOlk3p5w2P9lr440KvLbWQ.jpeg"/></div></figure><p id="dd3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我认为react中的插槽模式很好地类比了OOP中的<a class="ae ki" href="https://refactoring.guru/design-patterns/template-method" rel="noopener ugc nofollow" target="_blank">模板方法</a>模式。看看吧！</p><h1 id="7ffd" class="ko kp in bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">摘要</h1><p id="6e46" class="pw-post-body-paragraph jk jl in jm b jn lm jp jq jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh ig bi translated">没有优化react性能的灵丹妙药，因此了解几种方法是有益的。是不错的首选，但请不要止步于此。使用替代方法可能会改进代码的架构。感谢阅读，希望你今天学到了新的东西！</p></div></div>    
</body>
</html>