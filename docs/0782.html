<html>
<head>
<title>Setting up Webpack for Development and Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为开发和生产设置Webpack</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/setting-up-webpack-for-the-production-and-development-3ca0b0b12ff5?source=collection_archive---------1-----------------------#2021-02-18">https://javascript.plainenglish.io/setting-up-webpack-for-the-production-and-development-3ca0b0b12ff5?source=collection_archive---------1-----------------------#2021-02-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="8c1b" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">为实际的web应用程序设置Webpack的深奥艺术。</h2><div class=""/><div class=""><h2 id="12d4" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">为现实生活中的web应用程序设置Webpack的实用指南。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/6cd9d9600980884460723b85a9b14e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JQdp7umrjg0Emcgi"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@rozetsky?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ant Rozetsky</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f243" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们都同意Webpack是市场上最好的模块捆扎机之一。然而，自己设置Webpack可能有点棘手，尤其是如果这是你第一次。可供选择的插件太多了。大多数情况下，文档对于高级开发人员来说似乎是不错的。对于开发新手来说可能有点复杂。在这篇文章中，我们将探索Webpack配置的不同部分。在这篇文章的最后，你将有一个生产就绪的Webpack配置。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><blockquote class="mf mg mh"><p id="3fed" class="lc ld mi le b lf lg jx lh li lj ka lk mj lm ln lo mk lq lr ls ml lu lv lw lx ig bi translated">对细节不感兴趣？在文章末尾找到repo和config文件的工作版本。</p></blockquote></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="9418" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">因为这篇文章不是对Webpack文档的深入研究，所以它将只涉及对实际应用有益的部分(以我的拙见)。记住这一点，让我们首先看看配置的不同部分:</p><ul class=""><li id="851e" class="mm mn in le b lf lg li lj ll mo lp mp lt mq lx mr ms mt mu bi translated"><strong class="le ix">初始设置</strong></li><li id="b716" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated"><strong class="le ix">入口点</strong></li><li id="fa3c" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated"><strong class="le ix">输出</strong></li><li id="8f98" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated"><strong class="le ix">不同的装载机</strong></li><li id="2ba4" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated"><strong class="le ix">插件</strong></li><li id="f96e" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated"><strong class="le ix">附加基本配置</strong></li><li id="74a6" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated"><strong class="le ix">开发服务器设置</strong></li></ul><p id="c7ca" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这些是任何Webpack配置的要点。这些可以在一个配置文件中，也可以分成多个文件。为了简单起见，我会将所有内容保存在一个文件中。如果你不这么认为，欢迎你即兴发挥。</p><h1 id="6e43" class="na nb in bd nc nd ne nf ng nh ni nj nk kc nl kd nm kf nn kg no ki np kj nq nr bi translated"><strong class="ak">初始设置</strong></h1><p id="5e8e" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">我通常将我的Webpack配置文件分成三个不同的部分:</p><ul class=""><li id="606e" class="mm mn in le b lf lg li lj ll mo lp mp lt mq lx mr ms mt mu bi translated">基本配置</li><li id="6e87" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated">开发配置</li><li id="95fd" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated">生产配置</li></ul><p id="1cc2" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">基本配置将包含配置的所有共享和基本组件。开发和生产配置可能会覆盖基本配置的一些部分。我们还将制作一个标记来检查是使用开发配置还是生产配置。该标志将根据NPM命令被指定为真或假。下面是基本配置的屏幕截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/2f3a02e449398f6283b5357ffe739ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQssfv7Xf-b24vvZl07XDw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Webpack Config Initial Setup</figcaption></figure><p id="c8a3" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">乍一看，这里似乎发生了很多事情。让我把它分成几部分:</p><p id="9bc9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> LAUNCH_COMMAND: </strong>这里，我们在变量中捕获NPM命令。</p><p id="1c5c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这是我们之前讨论过的旗帜。我的package.json中的生产命令是<code class="fe ny nz oa ob b">prod</code>。所以，我在比较<code class="fe ny nz oa ob b">LAUNCH_COMMAND</code>和字符串<code class="fe ny nz oa ob b">prod</code>。</p><p id="e58b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> prodEntry，devEntry: </strong>这是条件Webpack入口点。如果我们在开发环境中，我们将在生产环境中使用<code class="fe ny nz oa ob b">devEntry</code>和<code class="fe ny nz oa ob b">prodEntry</code>。我们将在文章的后面详细讨论入口点。虽然<code class="fe ny nz oa ob b">prodEntry</code>和<code class="fe ny nz oa ob b">devEntry</code>是空对象，但是现在，我们将在后面的文章中添加代码。</p><p id="65ac" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> baseConfig、devConfig和prod config:</strong><code class="fe ny nz oa ob b">baseConfig</code>是基础部分。<code class="fe ny nz oa ob b">devConfig</code>或<code class="fe ny nz oa ob b">prodConfig</code>将覆盖<code class="fe ny nz oa ob b">baseConfigs</code>的一些组件。这样，我们将创建一个新的配置对象— <code class="fe ny nz oa ob b">mainConfig</code>。然后<code class="fe ny nz oa ob b">mainConfig</code>就会导出。</p><h1 id="260d" class="na nb in bd nc nd ne nf ng nh ni nj nk kc nl kd nm kf nn kg no ki np kj nq nr bi translated"><strong class="ak">入口点(entry) </strong></h1><p id="e0e2" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">顾名思义，Webpack将<code class="fe ny nz oa ob b">entry</code>视为应用的入口点。Webpack从入口点创建一个依赖图。<code class="fe ny nz oa ob b">entry</code>的默认值为<code class="fe ny nz oa ob b">src/index.js</code>。入口点通常是一个字符串、一个对象或多个入口点的数组。如果现在还不清楚，入口点的值(可以是字符串、对象或数组)是相对于Webpack配置文件的文件路径。多个入口点用于创建不同的块。这是一种流行的技术，用于根据环境、构建目标和运行时来分离关注点。</p><p id="194e" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在上面的截图中，<code class="fe ny nz oa ob b">prodEntry</code>是多个入口点的数组。第零个索引是JS入口点。下一个入口点是CSS(我使用CSS模块，所以我以这种方式加载我的基本样式)。在<code class="fe ny nz oa ob b">devEntry</code>中，我们将向列表中添加一个项目。它通过Webpack-Dev-Server启用HMR(热模块重载)(使用WebSockets触发HMR)。</p><h1 id="468c" class="na nb in bd nc nd ne nf ng nh ni nj nk kc nl kd nm kf nn kg no ki np kj nq nr bi translated"><strong class="ak">输出(output) </strong></h1><p id="8713" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated"><code class="fe ny nz oa ob b">output</code>是Webpack配置的另一个重要且基本的组件。属性告诉Webpack将捆绑的工件和其他重要细节放在哪里。输出通常作为对象传递。而<code class="fe ny nz oa ob b">filename</code> <strong class="le ix"> </strong>是其中的必填字段。下面是我的配置文件的输出截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/d2193166745513303b79dc6511d3ffd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nL9tv6Mo5TQyzL5LhHKV1w.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">the output part of the Webpack config</figcaption></figure><p id="b286" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">以下是每家酒店的详细信息:</p><p id="4fd9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">文件名:</strong> <code class="fe ny nz oa ob b">filename</code>是设置输出工件的文件名。它可以是简单的字符串。或者动态名称(如果您正在创建多个包)。在上面的例子中，我们为不同的包使用了一个动态名称。在这里，<code class="fe ny nz oa ob b"><strong class="le ix">[name]</strong></code> <strong class="le ix"> </strong>表示每个包的名称。如果您有多个入口点，并且您将它作为数组传递，那么Webpack将动态地决定名称。如果您将不同的条目作为一个对象传递，那么相应的键将被用作包名。下一步是向包中添加哈希值:<code class="fe ny nz oa ob b"><strong class="le ix">[hash:8]</strong></code>。它会破坏浏览器缓存来加载更新的内容。有些人更喜欢<code class="fe ny nz oa ob b"><strong class="le ix">contenthash</strong></code>。它根据内容变化添加哈希。但是，到目前为止，<code class="fe ny nz oa ob b"><strong class="le ix">[hash:8]</strong></code> <strong class="le ix"> </strong>对我来说还不错。</p><p id="f539" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">组块文件名:</strong>该选项用于设置组块文件名。如果你要把你的包分成块，那么这个选项和<code class="fe ny nz oa ob b">filename </code>对包名做的一样。</p><p id="e7ac" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">路径:</strong><code class="fe ny nz oa ob b">path</code>告诉Webpack把输出文件放在哪里。在截图中，我将<code class="fe ny nz oa ob b">PATHS.build</code> <strong class="le ix"> </strong>作为输出路径。我使用一个对象来声明应用程序中使用的所有路径。这样，我可以确定真理只有一个来源。</p><p id="97c2" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> publicPath: </strong> <code class="fe ny nz oa ob b">publicPath</code>告诉Webpack如何以及从哪里提供图像或其他文件等外部资产。在上面的截图中，我正在有条件地改变它的值。如果Webpack将文件打包用于生产，那么我将使用DevOps建议的公共路径。如果是开发环境，那么我使用<code class="fe ny nz oa ob b">/</code>作为公共路径。</p><h1 id="a957" class="na nb in bd nc nd ne nf ng nh ni nj nk kc nl kd nm kf nn kg no ki np kj nq nr bi translated">不同的装载机(模块)</h1><p id="dc64" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">不同的加载器告诉Webpack如何处理特定的文件，以及对文件应用什么样的转换。Webpack本身不知道如何处理这个文件。它是一个引导Webpack的加载器，通过这种方式，我们可以控制在源代码上应用转换的内容、方式和时间。您还可以选择在特定类型文件的转换之前或之后应用加载程序(“何时”部分)。一旦文件成为一个模块，Webpack就可以把它作为项目中的一个依赖项。下面是我如何在配置中使用加载器的截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi od"><img src="../Images/516e03a37cfba0211d62a5e7da0c3ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwuCGOrmMydAXD_4PfToaw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">loader component of the config.</figcaption></figure><p id="0649" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">虽然在一个段落中涵盖所有的加载器可能有点棘手，但我会尽我所能抓住本质。您可能已经在截图中观察到一些不同颜色的矩形。这些是为了突出不同的装载机。在此配置中，我们有四个加载器:</p><ul class=""><li id="0973" class="mm mn in le b lf lg li lj ll mo lp mp lt mq lx mr ms mt mu bi translated">验证JS源代码上的eslint规则的预加载器(绿色矩形)。</li><li id="01f7" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated">一个用于转换和构建JS源代码的加载器(橙色矩形)。</li><li id="9c68" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated">一个识别图像和非源代码文件的加载器(蓝色矩形)。</li><li id="6b3e" class="mm mn in le b lf mv li mw ll mx lp my lt mz lx mr ms mt mu bi translated">捆绑CSS文件的加载器(紫色矩形)。</li></ul><p id="76f4" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">装载机语法:</strong>装载机有四个主要部分。<code class="fe ny nz oa ob b"><strong class="le ix">test</strong></code> <strong class="le ix"> </strong>决定了你要测试什么样的文件。如果未设置该值，则该规则适用于所有文件。<code class="fe ny nz oa ob b"><strong class="le ix">include</strong></code> <strong class="le ix"> </strong>告诉Webpack要包含什么目录或文件。<code class="fe ny nz oa ob b"><strong class="le ix">exclude</strong></code>(你猜对了)告诉Webpack不要对特定的目录或文件应用规则。一个<code class="fe ny nz oa ob b"><strong class="le ix">loader</strong></code> <strong class="le ix"> </strong>是帮助Webpack进行文件转换的第三方扩展。大多数情况下，您会从加载程序的创建者那里找到使用指南。</p><p id="acb4" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">预加载器:</strong>预加载器在应用实际转换之前执行“任务”。在这种情况下，我们用eslint验证JS代码。您也可以添加一些其他类型的任务，但是除了代码验证之外，我从未遇到过必须使用预加载器的情况。要使加载程序成为预加载程序或后加载程序，您将在加载程序对象中使用<strong class="le ix"> enforce </strong>属性。该属性可以是“前”或“后”,具体取决于您要执行的任务类型。</p><p id="6298" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在屏幕截图中，第一个加载程序是验证eslint规则。为此我使用了<a class="ae lb" href="https://github.com/webpack-contrib/eslint-loader" rel="noopener ugc nofollow" target="_blank"><em class="mi">eslint-loader</em></a><strong class="le ix"/>。不过Webpack现在推荐的是<a class="ae lb" href="https://webpack.js.org/plugins/eslint-webpack-plugin/" rel="noopener ugc nofollow" target="_blank"><em class="mi">eslint-web pack-plugin</em></a><strong class="le ix"/>而不是eslint-loader。下一个加载器是将最新的JS语法转换成浏览器兼容的代码。为此我使用了<a class="ae lb" href="https://webpack.js.org/loaders/babel-loader/" rel="noopener ugc nofollow" target="_blank"><em class="mi"/></a><strong class="le ix"/>。请注意，您需要设置Babel配置来使用它。下一个是<a class="ae lb" href="https://webpack.js.org/loaders/file-loader/" rel="noopener ugc nofollow" target="_blank"> <em class="mi">文件加载器</em> </a>，它将文件上的<code class="fe ny nz oa ob b">import/require()</code> <strong class="le ix"> </strong>解析成一个URL，并将文件发送到输出目录。最后一个加载器是用于CSS的。我使用三种不同的加载器来处理CSS:<a class="ae lb" href="https://webpack.js.org/plugins/mini-css-extract-plugin/" rel="noopener ugc nofollow" target="_blank"><em class="mi">mini-CSS-extract-plugin</em></a>、<a class="ae lb" href="https://webpack.js.org/loaders/css-loader/" rel="noopener ugc nofollow" target="_blank"> <em class="mi"> css-loader </em> </a>和<a class="ae lb" href="https://webpack.js.org/loaders/postcss-loader/" rel="noopener ugc nofollow" target="_blank"><em class="mi">post CSS-loader</em></a>。如果您观察到，我正在根据环境(开发或生产)有条件地更改加载程序配置。这是我的开发CSS加载器配置的截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/51f92db0509591fac3794a7644222ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FlP8TSTDqJ1eHSlBW3KHA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">css loader dev config.</figcaption></figure><p id="19d2" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我正在从配置[0]中删除hmr值。生产配置情况下的选项。我之前在配置中还有一些不同，但是现在hmr是唯一的不同。</p><h1 id="ff15" class="na nb in bd nc nd ne nf ng nh ni nj nk kc nl kd nm kf nn kg no ki np kj nq nr bi translated">插件(插件)</h1><p id="4aa2" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">插件是Webpack的支柱。插件可以改变Webpack的工作方式。例如，我使用Terser插件来缩减我的JS代码。然而，版本5提供了现成的Terser，但在较旧的Webpack版本中，您必须手动安装它。这里，我使用Treser插件来压缩JS代码，而不是Webpack提供的默认压缩程序。以下是我觉得有用的插件列表:</p><h2 id="f6fa" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated"><a class="ae lb" href="https://www.npmjs.com/package/case-sensitive-paths-webpack-plugin" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">区分大小写-路径-网页包-插件</strong> </a> <strong class="ak"> : </strong></h2><p id="da74" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">来自他们的wiki:“这个Webpack插件强制所有必需模块的完整路径与磁盘上的实际路径完全匹配。”当你的队友在不同的操作系统上工作时，这个插件很有用。通过使用这个插件，您可以放心使用的路径是区分大小写的，并且它不会在不同的操作系统上导致错误。下面是插件配置的截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oq"><img src="../Images/dd4c14fe5de6967a8714be44cbaa3ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QR-WRsbTmHwEfluKepkvTg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">case-sensitive-path-plugin config.</figcaption></figure><h2 id="f702" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated"><a class="ae lb" href="https://webpack.js.org/plugins/terser-webpack-plugin/" rel="noopener ugc nofollow" target="_blank"><strong class="ak">terser-web pack-plugin</strong></a><strong class="ak">:</strong></h2><p id="9da0" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">像我前面提到的，Terser插件缩减了es6+代码。它在幕后使用<a class="ae lb" href="https://github.com/terser/terser" rel="noopener ugc nofollow" target="_blank">精简器</a>来压缩代码。以下是我对此插件的首选配置:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi or"><img src="../Images/487cb6f0264a40902f0bd1f57a92a4d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*648rGXyL6XybnYmmNjlNVg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">terser-webpack-plugin config.</figcaption></figure><h2 id="9c4a" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated"><a class="ae lb" href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" rel="noopener ugc nofollow" target="_blank">优化-CSS-资产-web pack-插件</a>:</h2><p id="2835" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">来自他们的wiki:“它将在Webpack构建期间搜索CSS资产，并将优化\最小化CSS。”这是插件配置的截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi os"><img src="../Images/0a066fdf57ec61bcb29ef08118d81dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSbiqxrTQNn3oAOtqESiKQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">optimize-css-assets-webpack-plugin config.</figcaption></figure><h2 id="c3c0" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated"><a class="ae lb" href="https://webpack.js.org/plugins/html-webpack-plugin/" rel="noopener ugc nofollow" target="_blank"> html-webpack-plugin </a>:</h2><p id="2a11" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">这个插件将最新的构建文件注入到一个指定的HTML文件中。它会在每次构建时更新哈希值。这样，您就不必手动执行此操作。插件会在每次构建时处理它。以下是它的配置:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ot"><img src="../Images/f4b2617062d8db13eba1a64c9b772803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0j5r0QBQvM8AV8cHc7anHQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">html-webpack-plugin configs.</figcaption></figure><p id="f462" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这一次，配置分为两部分。<code class="fe ny nz oa ob b">defaultHtmlPlugConfig</code> <strong class="le ix"> </strong>是基本配置部分。<code class="fe ny nz oa ob b">additionalHtmlPlugConfig</code> <strong class="le ix"> </strong>是生产环境的附加配置。如果我们是为了生产而建造，我们就在缩小一切。</p><h2 id="49b4" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated"><a class="ae lb" href="https://webpack.js.org/plugins/define-plugin/" rel="noopener ugc nofollow" target="_blank">定义插件</a>:</h2><p id="7f0e" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">define-plugin允许您添加自定义的全局值，您可以在应用程序的任何地方使用这些值。您可以在构建过程中动态更改这些值。以下是我的自定义值的屏幕截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ou"><img src="../Images/9298d4b910e0acbe71edb11a73a290c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKDlSBdQ1KC2uWBNjZGSPw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">define-plugin configs</figcaption></figure><p id="099c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我在这里定义了四个自定义全局变量:1) <code class="fe ny nz oa ob b"><strong class="le ix">isProduction</strong></code> <strong class="le ix"> : </strong>这个布尔值决定了我是否在生产环境中。如果<code class="fe ny nz oa ob b">isProdctuion</code>是<code class="fe ny nz oa ob b">true</code>，我会禁用我应用程序中的一些日志。2) <code class="fe ny nz oa ob b"><strong class="le ix">testAPI</strong></code> <strong class="le ix"> : </strong>这个有意思。我使用这个值来选择应该点击哪个测试API服务器来获取应用程序数据。我在我的<code class="fe ny nz oa ob b">npm start</code>命令中传递一个额外的标志，就像这样<code class="fe ny nz oa ob b">npm start — api=vbox512</code>。然后我的请求处理程序中有一个映射，它将<code class="fe ny nz oa ob b">vbox512</code>解析为一个实际的URL。这样，我就不必对实际代码做任何修改。只是npm命令的一个标志就能帮我搞定一切。3) <code class="fe ny nz oa ob b"><strong class="le ix">command</strong></code> <strong class="le ix"> : </strong>是检查我用哪个npm命令运行服务器。我没有在应用程序中的任何地方使用它，但是我在某个时候使用它来确定测试API服务器。然后我们有多个测试服务器，所以从命令中传递API标志更有意义。4) <code class="fe ny nz oa ob b"><strong class="le ix">isDevelopment</strong></code> <strong class="le ix"> : </strong>类似于isProduction，但告知我们是否处于开发模式。</p><h2 id="cd57" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated">附加插件:</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ov"><img src="../Images/807af51b9cd5253b2b48b256a9d67ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E2KXxE-GhjGIU9Avyo-Ivg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">additional plugins</figcaption></figure><p id="754b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在上面的截图中，我提到了三个与dev相关的插件。<code class="fe ny nz oa ob b"><a class="ae lb" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank"><strong class="le ix">webpack-bundle-analyzer</strong></a></code>很好地可视化了你所有的应用依赖。您可以看到完整的包大小，每个依赖项的大小。这样，您可以确定是什么包裹让您的整个包裹变得如此沉重。<code class="fe ny nz oa ob b"><strong class="le ix">HotModuleReplacementPlugin</strong></code> <strong class="le ix"> </strong>是为CSS进行热模块更换。<code class="fe ny nz oa ob b"><strong class="le ix">IgnorePlugin</strong></code> <strong class="le ix"> </strong>防止为<code class="fe ny nz oa ob b">import</code>或<code class="fe ny nz oa ob b">require</code>调用生成与正则表达式或过滤函数匹配的模块。这里我们忽略了与Moment.js库捆绑在一起的语言环境。</p><p id="10a8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">以上是我在Webpack中使用的所有附加插件。我把我的插件分成三个部分:a) <code class="fe ny nz oa ob b"><strong class="le ix">devPlugins</strong></code>:这些插件只在开发环境中使用。b) <code class="fe ny nz oa ob b"><strong class="le ix">commonPlugins</strong></code>:这些都是常见的插件。并在开发和生产环境中使用。c) <code class="fe ny nz oa ob b"><strong class="le ix">prodPlugins</strong></code>:这些插件只在生产环境中使用。我是这样使用它的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ow"><img src="../Images/c7527bb770f4556eca39a91eecb82887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8Fuhv9CfNg4W6YjALvRHg.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ox"><img src="../Images/db4f1bb59a01d7adce96a41831f7f7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYnpUtXiHn29nUZRTu17ig.png"/></div></div></figure><h1 id="bc82" class="na nb in bd nc nd ne nf ng nh ni nj nk kc nl kd nm kf nn kg no ki np kj nq nr bi translated"><strong class="ak">附加基本配置:</strong></h1><p id="837c" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">有了上面的基本配置，还有一些额外的配置可以让开发人员的工作更轻松，或者以更好的方式捆绑资产。以下是附加配置的屏幕截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oy"><img src="../Images/e0128e0744b77dce730b98cfafe6910a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpY-3dul59bEXY2E5HGYiw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">additional configs.</figcaption></figure><p id="e0a3" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在我们深入每个键之前，让我告诉你这是我的<code class="fe ny nz oa ob b">baseConfigs</code>对象的一部分。现在，让我们看看每个属性的含义是什么:</p><h2 id="b28e" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated"><code class="fe ny nz oa ob b"><strong class="ak">resolve</strong></code>T14:</h2><p id="ce6c" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated"><code class="fe ny nz oa ob b">resolve</code>告诉Webpack如何解析文件或模块。module对象中的第一个属性是<code class="fe ny nz oa ob b"><strong class="le ix">extensions</strong></code> <strong class="le ix"> : </strong>该选项告诉Webpack在解析文件时查找文件扩展名的顺序。将首先解析数组中的第一个值。如果有两个文件名相同但扩展名不同的文件，Webpack将使用数组中首先列出的扩展名来解析文件。剩下的就跳过了。列表中的下一个是<code class="fe ny nz oa ob b"><strong class="le ix">modules</strong></code> <strong class="le ix"> : </strong>它告诉Webpack在解析模块时应该搜索什么目录。我在这里添加了<code class="fe ny nz oa ob b">node_modules</code>和我当前的目录。然后是<code class="fe ny nz oa ob b"><strong class="le ix">alias</strong></code> <strong class="le ix"> : </strong>当你使用相对路径导入文件时，别名非常有用。不要计算你必须从多少个目录中出来，要到达一个文件，定义别名，让Webpack来处理这种混乱。这是我如何从<code class="fe ny nz oa ob b">icons</code>目录导入一个文件:<code class="fe ny nz oa ob b">import Logo from ‘$ICONS/logo’</code>。我已经为应用程序中的所有主目录定义了别名。这就是决心。</p><h2 id="afa4" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated">优化:</h2><p id="d710" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">然而，如果您将<strong class="le ix">模式</strong>作为产品传递，Webpack(从版本4开始)会负责优化。如果您愿意，您仍然可以覆盖一些内容。这个对象中的大多数属性都是不言自明的，但是让我简单介绍一下这些属性:<code class="fe ny nz oa ob b"><strong class="le ix">minimize</strong></code> <strong class="le ix"> : </strong>是一个布尔值，它告诉Webpack是否最小化代码。<code class="fe ny nz oa ob b"><strong class="le ix">minimizer</strong></code> <strong class="le ix"> : </strong>现在，这就是我要覆盖的值。我使用Terser(用于JS)和optimizeCSSAssets(用于CSS)作为我的自定义最小化器。<code class="fe ny nz oa ob b"><strong class="le ix">splitChunks</strong></code> <strong class="le ix"> : </strong>如果你使用的是最新的Webpack，就可以避免这种情况。该选项有助于消除代码重复，并使公共部分成为一个单独的块。点击了解更多关于<a class="ae lb" href="https://webpack.js.org/plugins/split-chunks-plugin/" rel="noopener ugc nofollow" target="_blank"> splitChunk属性的信息。</a></p><h1 id="f0cb" class="na nb in bd nc nd ne nf ng nh ni nj nk kc nl kd nm kf nn kg no ki np kj nq nr bi translated"><strong class="ak">开发服务器设置</strong></h1><p id="5ebf" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">这里有一些与开发相关的设置，可以简化您的开发和调试。这是我的开发设置的截图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oz"><img src="../Images/7fa736fc8bd5cd592543a96e4f787efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgvHulQN0aj5PS4cJw_jcQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">dev settings</figcaption></figure><h2 id="ea0c" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated"><strong class="ak">开发工具:</strong></h2><p id="f4a1" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">此选项允许您选择要为开发构建哪种类型的源地图。我更喜欢<code class="fe ny nz oa ob b">eval-cheap-source-map</code>。它在浏览器中显示所有文件。这个选项有一个很长的选项列表。<a class="ae lb" href="https://webpack.js.org/configuration/devtool/#devtool" rel="noopener ugc nofollow" target="_blank">以下是此选项所有可能值的链接</a>，找到最符合您需求的。</p><h2 id="0ad5" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated">开发服务器:</h2><p id="50c8" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">我使用webpack-dev-server作为我的开发服务器。这个选项用于配置webpack-dev-server。<code class="fe ny nz oa ob b"><strong class="le ix">hot</strong></code> <strong class="le ix"> : </strong>告知Webpack启用HMR。还有另外一个属性:<code class="fe ny nz oa ob b">hotOnly</code>、<strong class="le ix">、</strong>它使HMR不需要刷新页面。我没有在我的配置中使用它，但是在开发过程中它是一个很好的选择。<code class="fe ny nz oa ob b"><strong class="le ix">open</strong></code> <strong class="le ix"> : </strong>如果open设置为<code class="fe ny nz oa ob b">true</code>，当您启动dev-server时，它会打开一个新的浏览器标签。我发现它非常有用。但是，如果你多次关闭和打开dev-server，这可能有点令人不知所措。<code class="fe ny nz oa ob b"><strong class="le ix">compress</strong></code> <strong class="le ix"> </strong>选项将<code class="fe ny nz oa ob b">gZip</code>dev-server提供的文件。<code class="fe ny nz oa ob b"><strong class="le ix">contentBase</strong></code> <strong class="le ix"> : </strong>这个选项告诉开发服务器从哪里提供静态文件。<code class="fe ny nz oa ob b"><strong class="le ix">watchContentBase</strong></code> <strong class="le ix"> : </strong>如果设置为<code class="fe ny nz oa ob b">true</code>，如果<code class="fe ny nz oa ob b">contentBase</code>目录中有变化，它会要求Webpack重新加载页面。通过将<code class="fe ny nz oa ob b"><strong class="le ix">clientLogLevel</strong></code> <strong class="le ix"> </strong>设置为不同的值，可以设置想要查看的各种日志。我更喜欢这个选项的<code class="fe ny nz oa ob b">info</code>。<code class="fe ny nz oa ob b"><strong class="le ix">historyApiFallback</strong></code> <strong class="le ix"> </strong>是一个很好的设置true的选项。假设你在web应用URL的深处(例如<code class="fe ny nz oa ob b">/users/abc/profile</code>)，你点击了刷新。默认情况下，开发服务器将返回一个404页面。但是如果你设置<code class="fe ny nz oa ob b">historyApiFallback</code> <strong class="le ix"> </strong>为真，它会显示你当前的页面。<code class="fe ny nz oa ob b"><strong class="le ix">watchOptions</strong></code> <strong class="le ix"> </strong>选项可让您设置开发过程中要监视的目录。这里有一个<a class="ae lb" href="https://webpack.js.org/configuration/watch/" rel="noopener ugc nofollow" target="_blank">链接，指向该属性的所有选项</a>。如果您设置了此选项，在出现错误或警告的情况下，开发服务器将向您显示一个<code class="fe ny nz oa ob b"><strong class="le ix">overlay</strong></code>。我更喜欢在开发过程中只看到错误。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="45a1" class="of nb in bd nc og oh dn ng oi oj dp nk ll ok ol nm lp om on no lt oo op nq it bi translated">说够了，给我看看代码</h2><p id="65fe" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">正如帖子前面所承诺的，这里是Webpack配置文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="7410" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">以下是工作回购的链接:</p><div class="pc pd gp gr pe pf"><a href="https://github.com/iiison/temp" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd ix gy z fp pk fr fs pl fu fw iw bi translated">iii son/温度</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">Permalink无法加载最新的提交信息。没有提供描述、网站或主题。你不能表演那个…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt kv pf"/></div></div></a></div></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="60d2" class="na nb in bd nc nd pu nf ng nh pv nj nk kc pw kd nm kf px kg no ki py kj nq nr bi translated">关于作者</h1><p id="ed47" class="pw-post-body-paragraph lc ld in le b lf ns jx lh li nt ka lk ll nu ln lo lp nv lr ls lt nw lv lw lx ig bi translated">Bharat自2011年以来一直是前端开发人员。他对“前端开发经验”情有独钟。他喜欢学习和教授技术。他和最可爱的女人以及珍贵的双胞胎孩子一起享受生活。</p><p id="14f1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">总的来说是个好人。在<a class="ae lb" href="https://twitter.com/iiisoni" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lb" href="https://github.com/iiison" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae lb" href="https://www.linkedin.com/in/iiison/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到他。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pa pb l"/></div></figure></div></div>    
</body>
</html>