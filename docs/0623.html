<html>
<head>
<title>Avoiding Race Conditions and Memory Leaks in React useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免React useEffect中的竞争条件和内存泄漏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/avoiding-race-conditions-and-memory-leaks-in-react-useeffect-2034b8a0a3c7?source=collection_archive---------3-----------------------#2021-02-08">https://javascript.plainenglish.io/avoiding-race-conditions-and-memory-leaks-in-react-useeffect-2034b8a0a3c7?source=collection_archive---------3-----------------------#2021-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f3dc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解如何处理“无法对卸载的组件执行反应状态更新”警告</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3360364f7b08e7258daf03d710b9a189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6qBujUd1nBKHCnF7.jpg"/></div></div></figure><p id="df29" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看一下从API请求中获取数据的实现，看看在这个组件中是否有发生竞争情况的可能性:</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="30ed" class="lp lq in ll b gy lr ls l lt lu">import React, { useEffect} from 'react';<br/>export default function UseEffectWithRaceCondition() {<br/>  const [todo, setTodo] = useState(null);<br/>  useEffect(() =&gt; {<br/>    const fetchData = async () =&gt; {<br/>      const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');<br/>      const newData = await response.json();<br/>      setTodo(newData);<br/>    };<br/>    fetchData();<br/>  }, []);<br/>  if (data) {<br/>    return &lt;div&gt;{data.title}&lt;/div&gt;;<br/>  } else {<br/>    return null;<br/>  }<br/>}</span></pre><p id="8725" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经指定了一个空数组作为对<a class="ae lv" href="https://www.wisdomgeek.com/development/web-development/react/react-hooks-and-local-storage-lets-build-a-todo-app/" rel="noopener ugc nofollow" target="_blank"> useEffect React钩子</a>的依赖。因此，我们已经确保获取请求只发生一次。但是这个组件仍然容易出现争用情况和内存泄漏。怎么会？</p><p id="1121" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果API服务器花了一些时间来响应，并且在收到响应之前卸载了组件，就会发生内存泄漏。尽管组件已被卸载，但在完成时仍会收到对请求的响应。然后将解析响应并调用setTodo。而React会抛出警告:</p><blockquote class="lw lx ly"><p id="66f2" class="ko kp lz kq b kr ks jo kt ku kv jr kw ma ky kz la mb lc ld le mc lg lh li lj ig bi translated">无法对已卸载的组件执行反应状态更新。这是不可行的，但它表明您的应用程序中存在内存泄漏。要修复此问题，请取消useEffect清理函数中的所有订阅和异步任务。</p></blockquote><p id="6786" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个信息非常简单。</p><p id="6d25" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同一问题的另一个潜在场景可能是todo列表ID作为一个属性被传入。</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="a2c6" class="lp lq in ll b gy lr ls l lt lu">import React, { useEffect} from 'react';<br/>export default function UseEffectWithRaceCondition( {id} ) {<br/>  const [todo, setTodo] = useState(null);<br/>  useEffect(() =&gt; {<br/>    const fetchData = async () =&gt; {<br/>      const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`);<br/>      const newData = await response.json();<br/>      setTodo(newData);<br/>    };<br/>    fetchData();<br/>  }, [id]);<br/>  if (data) {<br/>    return &lt;div&gt;{data.title}&lt;/div&gt;;<br/>  } else {<br/>    return null;<br/>  }<br/>}</span></pre><p id="9fbf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果钩子在请求完成之前收到了一个不同的ID，而第二个请求在第一个请求完成之前完成，那么我们就会在组件中看到第一个请求的数据。</p><h1 id="1028" class="md lq in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">竞争条件问题的潜在解决方案</h1><p id="73b2" class="pw-post-body-paragraph ko kp in kq b kr mu jo kt ku mv jr kw kx mw kz la lb mx ld le lf my lh li lj ig bi translated">有几种方法可以解决这个问题。这两种方法都利用了useEffect提供的清理功能。</p><ul class=""><li id="4756" class="mz na in kq b kr ks ku kv kx nb lb nc lf nd lj ne nf ng nh bi translated">我们可以使用一个布尔标志来确保组件被安装。这样，我们只有在标志为真时才更新状态。如果我们在一个组件中发出多个请求，我们将总是显示最后一个请求的数据。</li><li id="8ea8" class="mz na in kq b kr ni ku nj kx nk lb nl lf nm lj ne nf ng nh bi translated">每当组件被卸载时，我们可以使用AbortController取消以前的请求。但是IE不支持AbortController。所以如果我们要使用这种方法，我们需要考虑这一点。</li></ul><h1 id="5e77" class="md lq in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">使用带有布尔标志的效果清理</h1><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="124e" class="lp lq in ll b gy lr ls l lt lu">useEffect(() =&gt; {<br/>  let isComponentMounted = true;<br/>    const fetchData = async () =&gt; {<br/>      const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');<br/>      const newData = await response.json();<br/>      if(isComponentMounted) {<br/>        setTodo(newData);<br/>      }<br/>    };<br/>    fetchData();<br/>    return () =&gt; {<br/>      isComponentMounted = false;<br/>    }<br/>  }, []);</span></pre><p id="3840" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此修复依赖于useEffect的清理功能的工作方式。如果一个组件渲染多次，则在执行下一个效果之前会清除上一个效果。</p><p id="9845" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于这种工作方式，它也将正确地工作于我们的另一个多请求的例子，因为ID被改变了。在某种意义上，我们仍然有一个竞争条件，即在后台会有多个请求在运行。但是只有最后一次请求的结果才会显示在UI上。</p><h1 id="efb4" class="md lq in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">使用AbortController清除效果</h1><p id="d80d" class="pw-post-body-paragraph ko kp in kq b kr mu jo kt ku mv jr kw kx mw kz la lb mx ld le lf my lh li lj ig bi translated">尽管前面的方法可行，但它不是处理竞争条件的最佳方式。这些请求在后台进行。在后台保存过时的请求是对用户带宽的不必要消耗。浏览器还限制了并发请求的最大数量(最多6-8个)。</p><p id="8ba7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从我们之前关于如何取消HTTP获取请求的帖子中，我们知道了添加到DOM标准中的AbortController API。我们可以利用这一点来中止我们的请求本身。</p><pre class="kd ke kf kg gt lk ll lm ln aw lo bi"><span id="1d5a" class="lp lq in ll b gy lr ls l lt lu">useEffect(() =&gt; {<br/>  let abortController = new AbortController();<br/>    const fetchData = async () =&gt; {<br/>      try {<br/>        const response = await fetch('https://jsonplaceholder.typicode.com/todos/1', {<br/>            signal: abortController.signal,<br/>          });<br/>      const newData = await response.json();<br/>        setTodo(newData);<br/>      }<br/>      catch(error) {<br/>         if (error.name === 'AbortError') {<br/>          // Handling error thrown by aborting request<br/>        }<br/>      }<br/>    };<br/>    fetchData();<br/>    return () =&gt; {<br/>      <!-- -->abortController.abort();<br/>    }<br/>  }, []);</span></pre><p id="3688" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于中止请求会抛出一个错误，我们需要显式地处理它。</p><p id="c194" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个解决方案的工作原理和前面的一样。在重新渲染的情况下，清理功能在执行下一个效果之前执行。不同之处在于浏览器也取消了请求，因为我们使用的是AbortController。</p><p id="8373" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是我们在使用React的useEffect钩子发出API请求时避免竞争情况的两种方法。如果您想使用一些第三方库，这些库允许将取消请求作为一个特性，那么您可以使用Axios或react query，它们也提供了许多其他特性。</p><p id="db83" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你有任何问题，请在下面留言。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="9a56" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lz">原载于2021年2月8日</em><a class="ae lv" href="https://www.wisdomgeek.com/development/web-development/react/avoiding-race-conditions-memory-leaks-react-useeffect/" rel="noopener ugc nofollow" target="_blank"><em class="lz">【https://www.wisdomgeek.com】</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>