<html>
<head>
<title>Markdown to Angular Rendering Using Unified and Remark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Unified和Remark降低到角度渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/markdown-to-angular-rendering-using-unified-and-remark-96835bb877?source=collection_archive---------5-----------------------#2021-11-14">https://javascript.plainenglish.io/markdown-to-angular-rendering-using-unified-and-remark-96835bb877?source=collection_archive---------5-----------------------#2021-11-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="eb8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我最近开发了一个前端应用程序，它需要将markdown文档渲染成有角度的组件。使用的app是两种用户使用的。一个小组研究了几个应用中使用的模型数据库。另一组用markdown方言编写文档模板，其中包含一些引用数据库模型的自定义扩展。</p><p id="8492" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">文档必须以与应用程序的其他部分一致的风格呈现，这些部分使用了大量有棱角的材料组件。这个项目很有趣，有时也很棘手，所以我为其他可能面临同样挑战的人创建了一个示例回购。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40c66e5e09da60dc05000bb84248c309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmP3GfelHLI6JBsweJnf8g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Rendering markdown and user data into Angular Components. Image by Author</figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="9322" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应用程序开发中的每个步骤都与示例回购中的特定提交相关联。创建缩减至角度渲染器的步骤如下:</p><ol class=""><li id="ab0e" class="lf lg in jm b jn jo jr js jv lh jz li kd lj kh lk ll lm ln bi translated">创建您的应用程序(<a class="ae lo" href="https://github.com/matteson/custom-markdown/tree/71b73b4fdb173d012ce4515870d529b492982a2b" rel="noopener ugc nofollow" target="_blank">回购链接</a>)。</li><li id="1166" class="lf lg in jm b jn lp jr lq jv lr jz ls kd lt kh lk ll lm ln bi translated">使用<code class="fe lu lv lw lx b">Unified</code>和<code class="fe lu lv lw lx b">Remark</code>将markdown解析成一个语法树(<a class="ae lo" href="https://github.com/matteson/custom-markdown/tree/515f0f381ecf8d8a78c5f62f5f9d850600ed07f0" rel="noopener ugc nofollow" target="_blank"> repo link </a>)。</li><li id="e41d" class="lf lg in jm b jn lp jr lq jv lr jz ls kd lt kh lk ll lm ln bi translated">将树渲染成角度组件(<a class="ae lo" href="https://github.com/matteson/custom-markdown/tree/ee5dd55d24117e334957733048f8c41901c29ca7" rel="noopener ugc nofollow" target="_blank"> repo link </a>)。</li><li id="2273" class="lf lg in jm b jn lp jr lq jv lr jz ls kd lt kh lk ll lm ln bi translated">为您的数据添加自定义解析器(<a class="ae lo" href="https://github.com/matteson/custom-markdown" rel="noopener ugc nofollow" target="_blank"> repo link </a>)。</li></ol></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="c1e1" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated"><strong class="ak">创建您的应用</strong></h1><p id="5d96" class="pw-post-body-paragraph jk jl in jm b jn mw jp jq jr mx jt ju jv my jx jy jz mz kb kc kd na kf kg kh ig bi translated">我不会在这上面花太多时间，因为这个应用程序非常简单。我们从两个服务获取数据，一个用于数据，一个用于文档。用户可以用两个<code class="fe lu lv lw lx b">mat-select</code>元素选择数据和模板。</p><p id="ad6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我用我喜欢的布局和样式库初始化了这个应用程序:<code class="fe lu lv lw lx b">@angular/flex-layout</code>和<code class="fe lu lv lw lx b">@angular/material</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/4c9001b7040f2149d26832abc97855e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRoy0q-M8Bnb7hrmYj5f7w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Our initial app. The user selects data with the pickers. The raw data is displayed in the lower left. The rest of the post will be about rendering the data in the right panel.</figcaption></figure><h1 id="2d84" class="ly lz in bd ma mb nc md me mf nd mh mi mj ne ml mm mn nf mp mq mr ng mt mu mv bi translated">使用Unified和Remark解析Markdown</h1><p id="83c9" class="pw-post-body-paragraph jk jl in jm b jn mw jp jq jr mx jt ju jv my jx jy jz mz kb kc kd na kf kg kh ig bi translated">该功能的主要功能在<a class="ae lo" href="https://github.com/remarkjs/remark/tree/main" rel="noopener ugc nofollow" target="_blank">备注</a>中实现，是<a class="ae lo" href="https://unifiedjs.com/" rel="noopener ugc nofollow" target="_blank">统一生态系统</a>的一部分。Unified是一套通用的工具，“将语法树编译成内容，将内容编译成语法树”。我们的目标是获取非结构化的文本数据，一个markdown文件，并使用Angular组件库将其呈现为结构化内容。</p><p id="0415" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过markdown解析器注释，Unified通过将我们的markdown文件映射到一个结构化的树中，极大地提升了这个特性。我们将Unified与Angular应用程序集成所需的最小功能是一个工厂，我们可以将其用作提供者。</p><h2 id="d292" class="nh lz in bd ma ni nj dn me nk nl dp mi jv nm nn mm jz no np mq kd nq nr mu ns bi translated">统一工厂. js:</h2><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="7acf" class="nh lz in lx b gy nx ny l nz oa">import * as unified from "unified";<br/>import * as <strong class="lx io"><em class="ob">markdown </em></strong>from "remark-parse";<br/><br/>export function unifiedFactory() {<br/>  return unified()<br/>    .use(markdown)<br/>    .freeze();<br/>}</span></pre><p id="e156" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">统一的核心是处理器流水线。管道中的每一级都接受输入，对其进行转换，然后将其传递给管道中的下一级。最初，我们使用一个非常简单的管道，只有一个将markdown转换成结构化文本的阶段。</p><p id="d3ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这个管道，一个简单的降价文件，如:</p><blockquote class="oc od oe"><p id="0871" class="jk jl ob jm b jn jo jp jq jr js jt ju of jw jx jy og ka kb kc oh ke kf kg kh ig bi translated">foo bar巴兹</p></blockquote><p id="611c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将呈现为这棵树:</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="7638" class="nh lz in lx b gy nx ny l nz oa">{<br/> <strong class="lx io">“type”: “root”,</strong><br/> “children”: [<br/> {<br/><strong class="lx io"> “type”: “paragraph”,</strong><br/> “children”: [<br/> {<br/><strong class="lx io"> “type”: “text”,<br/> “value”: “foo bar baz”,</strong><br/> “position”: {“start”: {“line”: 1, “column”: 1, “offset”: 0 },<br/> “end”: {“line”: 1, “column”: 12, “offset”: 11},<br/> “indent”: []<br/> }<br/> }<br/> ],<br/> “position”: {“start”: {“line”: 1,”column”: 1,”offset”: 0 },<br/> “end”: { “line”: 1, “column”: 12, “offset”: 11 },<br/> “indent”: []<br/> }<br/> }<br/> ],<br/> “position”: { “start”: { “line”: 1,”column”: 1,”offset”: 0 },<br/> “end”: {“line”: 1,”column”: 12, “offset”: 11 }<br/> }<br/>}</span></pre><p id="90c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lu lv lw lx b">root</code>节点有一个<code class="fe lu lv lw lx b">paragraph</code>子节点，子节点又有一个<code class="fe lu lv lw lx b">text</code>子节点。这种结构化数据正是我们将降价转换成角度分量所需要的。</p><p id="6c2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了将统一管道与应用程序集成，应用程序需要it作为提供者。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="4bdc" class="nh lz in lx b gy nx ny l nz oa">...<br/>providers: [<br/>  DataService,<br/>  DocumentService,<br/>  {<br/>    provide: 'unified',<br/>    useFactory: unifiedFactory,<br/>  }<br/>],<br/>...</span></pre><p id="5660" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以提供给<code class="fe lu lv lw lx b">MarkdownComponent</code>像任何其他角度服务一样使用。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="f8a5" class="nh lz in lx b gy nx ny l nz oa">// markdown.component.ts</span><span id="3cc7" class="nh lz in lx b gy oi ny l nz oa">@Component({<br/>  selector: 'app-markdown',<br/>  templateUrl: './markdown.component.html',<br/>  styleUrls: ['./markdown.component.css']<br/>})<br/>export class MarkdownComponent {<br/><br/>  processed: any = '';<br/><br/>  @Input()<br/>  set raw(markdown: string) {<br/>    this.processed = this.unified.parse(markdown);<br/>  }<br/><br/>  constructor(<br/>    @Inject('unified') private unified: FrozenProcessor<br/>  ) { }<br/>}</span></pre><p id="2d8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该组件接受降价字符串的输入。当<code class="fe lu lv lw lx b">raw</code>被设置时，我们调用<code class="fe lu lv lw lx b">unified.parse()</code>来得到语法树。</p><p id="e3e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以为降价组件创建一个简单的显示:</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="192e" class="nh lz in lx b gy nx ny l nz oa">// markdown.component.html</span><span id="dc91" class="nh lz in lx b gy oi ny l nz oa">&lt;div class="mat-h2"&gt;Abstract Syntax Tree:&lt;/div&gt;<br/>&lt;code&gt;<br/>  {{ processed | json  }}<br/>&lt;/code&gt;</span></pre><p id="a1b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将组件连接到我们的应用程序中:</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="7193" class="nh lz in lx b gy nx ny l nz oa">...<br/>&lt;app-markdown [raw]="documents[selected_document]"&gt;&lt;/app-markdown&gt;<br/>...</span></pre><p id="3224" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它为我们提供了以下功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/1ba87ee6bdd3a7212f941867757134f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/1*u2-1Jki5sjDRPZgcPZn2IQ.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Animation of app with parsing. Changing the template triggers the app to parse markdown into an AST.</figcaption></figure><p id="ff1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用户可以选择不同的降价模板，作为响应，语法树被打印到屏幕上。这个特性的其他方面很简单。我们必须从结构化的树中渲染我们的角组件。</p><h1 id="0b30" class="ly lz in bd ma mb nc md me mf nd mh mi mj ne ml mm mn nf mp mq mr ng mt mu mv bi translated">从AST渲染角度分量</h1><p id="1294" class="pw-post-body-paragraph jk jl in jm b jn mw jp jq jr mx jt ju jv my jx jy jz mz kb kc kd na kf kg kh ig bi translated">Remark-parse将markdown视为由块部分和内联部分组成。块部分是像标题、段落、列表、表格等东西。内联部分包括纯文本、粗体文本、斜体文本、链接、图片等。</p><p id="bc80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">呈现树包括将节点树传递给呈现逻辑。我们循环遍历树中的每个子节点，递归调用呈现逻辑。我们创建一个<code class="fe lu lv lw lx b">block </code>组件和一个<code class="fe lu lv lw lx b">inline</code>组件。当我们扩展渲染逻辑的复杂性时，分离这个逻辑是有帮助的。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="d633" class="nh lz in lx b gy nx ny l nz oa">// Block component</span><span id="07c8" class="nh lz in lx b gy oi ny l nz oa">@Component({<br/>  selector: '[block]',<br/>  templateUrl: './block.component.html',<br/>  styleUrls: ['./block.component.scss'],<br/>  encapsulation: ViewEncapsulation.<em class="ob">None</em>,<br/>})<em class="ob"><br/></em>export class BlockComponent {<br/>  constructor() {}<br/><br/>  @Input('block') node: any;<br/><br/>  // AOT safe children from the node<br/>  get children() {<br/>    return 'children' in this.node ? this.node.children : [];<br/>  }<br/>}</span></pre><p id="7cac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于每个孩子，我们在一个<code class="fe lu lv lw lx b">ngSwitch</code>语句中检查类型，用类和css信息将它放在适当的<code class="fe lu lv lw lx b">div</code>中，然后将孩子传递给<code class="fe lu lv lw lx b">[inline]</code>元素。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="92cf" class="nh lz in lx b gy nx ny l nz oa">// Block HTML logic</span><span id="f17e" class="nh lz in lx b gy oi ny l nz oa">&lt;ng-container <em class="ob">*ngFor</em>="let <strong class="lx io"><em class="ob">child </em></strong>of children"&gt;<br/>  &lt;ng-container [ngSwitch]="<strong class="lx io"><em class="ob">child</em></strong>.type"&gt;<br/>    &lt;!-- Headings --&gt;<br/>    &lt;ng-container <em class="ob">*ngSwitchCase</em>="'heading'"&gt;<br/>      &lt;div class="mat-h1"<br/>        <em class="ob">*ngIf</em>="<strong class="lx io"><em class="ob">child</em></strong>.depth === 1"<br/>        [inline]="<strong class="lx io"><em class="ob">child</em></strong>"<br/>      &gt;&lt;/div&gt;<br/>      &lt;div class="mat-h2"<br/>        <em class="ob">*ngIf</em>="<strong class="lx io"><em class="ob">child</em></strong>.depth === 2"<br/>        [inline]="<strong class="lx io"><em class="ob">child</em></strong>"<br/>      &gt;&lt;/div&gt;<br/>      &lt;div class="mat-h3"<br/>        <em class="ob">*ngIf</em>="<strong class="lx io"><em class="ob">child</em></strong>.depth === 3"<br/>        [inline]="<strong class="lx io"><em class="ob">child</em></strong>"<br/>      &gt;&lt;/div&gt;<br/>    &lt;/ng-container&gt;<br/><br/>    &lt;!-- Paragraph --&gt;<br/>    &lt;p <em class="ob">*ngSwitchCase</em>="'paragraph'"<br/>      [inline]="<strong class="lx io"><em class="ob">child</em></strong>"<br/>    &gt;&lt;/p&gt;<br/><br/>    &lt;!-- Can be added: --&gt;<br/>    &lt;!-- Lists --&gt;<br/>    &lt;!-- Tables --&gt;<br/>    &lt;!-- Etc. --&gt;<br/>  &lt;/ng-container&gt;<br/>&lt;/ng-container&gt;</span></pre><p id="00da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">内联组件也有类似的模式:</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="2173" class="nh lz in lx b gy nx ny l nz oa">// Inline component </span><span id="bda1" class="nh lz in lx b gy oi ny l nz oa">@Component({<br/>  selector: '[inline]',<br/>  templateUrl: './inline.component.html',<br/>  styleUrls: ['./inline.component.scss'],<br/>  encapsulation: ViewEncapsulation.<em class="ob">None</em>,<br/>})<br/>export class InlineComponent {<br/>  constructor() {}<br/><br/>  @Input('inline') node: any;<br/><br/>  // AOT safe children from the node<br/>  get children() {<br/>    return 'children' in this.node ? this.node.children : [];<br/>  }<br/><br/>  public text_helper(value: string): string {<br/>    return value || '';<br/>  }<br/>}</span></pre><p id="0f09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于每个孩子，我们再次使用<code class="fe lu lv lw lx b">[ngSwitch]</code>循环</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="1d9f" class="nh lz in lx b gy nx ny l nz oa">// Inline HTML template</span><span id="c49d" class="nh lz in lx b gy oi ny l nz oa">&lt;ng-container <em class="ob">*ngFor</em>="let <strong class="lx io"><em class="ob">child </em></strong>of children"&gt;<br/>  &lt;ng-container [ngSwitch]="<strong class="lx io"><em class="ob">child</em></strong>.type"&gt;<br/><br/>    &lt;!-- Plain text --&gt;<br/>    &lt;ng-container <em class="ob">*ngSwitchCase</em>="'text'"&gt;<br/>      {{ text_helper(<strong class="lx io"><em class="ob">child</em></strong>.value) }}<br/>    &lt;/ng-container&gt;<br/><br/>    &lt;!-- Other types go here emph, strong, html, etc. --&gt;<br/>  &lt;/ng-container&gt;<br/>&lt;/ng-container&gt;</span></pre><p id="221a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们更新<code class="fe lu lv lw lx b">markdown.component.html</code>以将语法树传递给顶层块。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="4b26" class="nh lz in lx b gy nx ny l nz oa">&lt;div class="mat-h2"&gt;Rendered:&lt;/div&gt;<br/>&lt;div [block]="processed"&gt;&lt;/div&gt;</span></pre><p id="45d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们更新的应用程序拥有我们正在寻找的大部分功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b49e3f34218064fe062ba48392a6de0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9Fs9fWLyzvga9Y302sjIgA.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Rendering markdown as Angular components</figcaption></figure><h1 id="912e" class="ly lz in bd ma mb nc md me mf nd mh mi mj ne ml mm mn nf mp mq mr ng mt mu mv bi translated">为用户数据添加自定义解析器</h1><p id="d6e8" class="pw-post-body-paragraph jk jl in jm b jn mw jp jq jr mx jt ju jv my jx jy jz mz kb kc kd na kf kg kh ig bi translated">在我们的fixtures中，我们包含了字符串<code class="fe lu lv lw lx b">&lt;CUSTOM_MARKDOWN&gt;&lt;/CUSTOM_MARKDOWN&gt;</code>。我们可以编写一个定制的解析器，将它解释为一个特殊的标记，而不是一个字符串。解析器向语法树添加一个自定义块。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="2474" class="nh lz in lx b gy nx ny l nz oa">export function customParser(classNames = {}) {<br/>  const customMarker = new <strong class="lx io"><em class="ob">RegExp</em></strong>(`&lt;CUSTOM_MARKDOWN&gt;&lt;/CUSTOM_MARKDOWN&gt;`);<br/><br/>  function customTokenizer(eat, value, silent) {<br/>    const keep = value.match(customMarker);<br/>    if (!keep || keep.index !== 0) return;<br/><br/>    const add = eat('&lt;CUSTOM_MARKDOWN&gt;&lt;/CUSTOM_MARKDOWN&gt;');<br/><br/>    return add({<br/>      type: 'customMarkdown',<br/>      children: [],<br/>      data: {},<br/>    });<br/>  }<br/><br/>  const Parser = this.Parser;<br/><br/>  // Append our custom block to the parser<br/>  const blockTokenizers = Parser.prototype.blockTokenizers;<br/>  const blockMethods = Parser.prototype.blockMethods;<br/>  blockTokenizers.customBlock = customTokenizer;<br/>  blockMethods.splice(blockMethods.indexOf('list') + 1, 0, 'customBlock');<br/>}</span></pre><p id="72da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以在解析工厂中包含自定义解析器。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="23c3" class="nh lz in lx b gy nx ny l nz oa">import { customParser } from "./custom-parser";<br/><br/>export function unifiedFactory() {<br/>  return unified()<br/>    .use(markdown)<br/>    .use(customParser)<br/>    .freeze();<br/>}</span></pre><p id="a299" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，在开关中包含自定义角度分量。</p><pre class="kj kk kl km gt nt lx nu nv aw nw bi"><span id="c283" class="nh lz in lx b gy nx ny l nz oa">&lt;ng-container <em class="ob">*ngFor</em>="let <strong class="lx io"><em class="ob">child </em></strong>of children"&gt;<br/>  &lt;ng-container [ngSwitch]="<strong class="lx io"><em class="ob">child</em></strong>.type"&gt;<br/>  ...</span><span id="0887" class="nh lz in lx b gy oi ny l nz oa">  &lt;div <em class="ob">*ngSwitchCase</em>="'customMarkdown'"&gt;<br/>    {{get_custom()}}<br/>  &lt;/div&gt;</span><span id="8a76" class="nh lz in lx b gy oi ny l nz oa">  &lt;/ng-container&gt;<br/>&lt;/ng-container&gt;</span></pre><p id="7202" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一个演示，我们使用打印一个字符串到模板化的文档中，它依赖于在前端选择的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/aee1f84832145bc010d560d960c3a0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jMixcGMQ0pvAtlsOiZtDJQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Our feature with all the functionality we sought</figcaption></figure><h1 id="cdcd" class="ly lz in bd ma mb nc md me mf nd mh mi mj ne ml mm mn nf mp mq mr ng mt mu mv bi translated">结论</h1><p id="1465" class="pw-post-body-paragraph jk jl in jm b jn mw jp jq jr mx jt ju jv my jx jy jz mz kb kc kd na kf kg kh ig bi translated">就演示中的功能而言，这看起来像是很多工作，但这对我为之构建的团队产生了巨大的影响。关键的一点是，在规模上，这将数据源的开发与如何呈现数据源的开发分离，并使没有前端开发经验的团队能够在应用程序中编写文档视图。</p><p id="03c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我真的很高兴将来能继续与Unified和Remark合作。这是一个巨大的文本操作工具生态系统。</p><p id="06c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ob">更多内容尽在</em><a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ob">plain English . io</em></strong></a></p></div></div>    
</body>
</html>