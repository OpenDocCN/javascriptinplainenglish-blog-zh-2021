<html>
<head>
<title>Prevent Excess Rerenders in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防止React中出现过多的重复渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/preventing-redundant-re-renders-in-react-c0de7c92d0b6?source=collection_archive---------6-----------------------#2021-02-22">https://javascript.plainenglish.io/preventing-redundant-re-renders-in-react-c0de7c92d0b6?source=collection_archive---------6-----------------------#2021-02-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9f66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在开发React应用程序时，我通常不会过多考虑渲染性能。React有其著名的<a class="ae ki" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">树协调算法</a>，可以有效地更新UI。这种方法工作良好，直到它不工作，这就是这篇文章的内容。</p><p id="cb19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">渲染功能可能非常昂贵</strong></p><p id="b9fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们考虑一个显示第n个斐波那契数的组件，来模拟现实生活中在render方法中进行大量数据处理的应用程序组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ko kp l"/></div></figure><p id="b534" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它使用一个非常无效的递归算法来计算第n个斐波那契数，所以随着n的增加，它变得非常慢。假设<code class="fe kq kr ks kt b">Fibonacci</code>组件呈现在一个频繁更新的组件内部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ko kp l"/></div></figure><p id="6104" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">演示组件保持文本的状态，所以它将在每次文本改变时重新呈现。即使<code class="fe kq kr ks kt b">Fibonacci</code>组件道具没有改变，默认情况下也会被重新渲染。如何解决这个问题？</p><p id="b82f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这相当简单，只需将<code class="fe kq kr ks kt b">Fibonacci</code>组件包装在<code class="fe kq kr ks kt b">React.memo</code>中</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="f554" class="ky kz in kt b gy la lb l lc ld">export default React.memo(<!-- -->Fibonacci)</span></pre><p id="8f1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将防止react在属性不变的情况下重新渲染组件。默认情况下，React在以前的和新的属性之间执行浅层相等检查。或者，自定义比较器函数可以作为第二个参数传递。就我个人而言，我不推荐后者，请记住，运行定制的比较器函数可能成本很高(例如，一些大型对象的深度比较)。</p><p id="8790" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应用<code class="fe kq kr ks kt b">React.memo</code>解决了我们的性能问题，完美！</p><p id="6be0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">比方说，出于某种原因，我们想要计算斐波那契数列被点击的次数。这很简单，我们只需添加<code class="fe kq kr ks kt b">onClick</code>处理程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ko kp l"/></div></figure><p id="cbcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不幸的是，每次点击后都会出现小故障。看起来每次点击Fibonacci组件都会重新呈现。原因是什么？由于<code class="fe kq kr ks kt b">Demo</code>组件在其状态中保持计数，因此每次计数更新时都会重新呈现。即使<code class="fe kq kr ks kt b">Fibonacci</code>组件被包装在<code class="fe kq kr ks kt b">React.memo</code>中，onClick处理程序在每次渲染中都是不同的函数。解决方案？函数应该只创建一次，并在随后的渲染中重用。为react提供了<code class="fe kq kr ks kt b">useCallback</code>钩子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ko kp l"/></div></figure><p id="f180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，每次渲染<code class="fe kq kr ks kt b">handleFibNumberClicked</code>都会引用相同的函数，所以<code class="fe kq kr ks kt b">React.memo</code>执行的浅层等式检查将会成功。</p><p id="010e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是一种特定于反应的记忆函数的方式。相当于接下来要描述的<code class="fe kq kr ks kt b">useMemo(() =&gt; function, [...deps])</code>。</p><p id="11ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一天，产品负责人提出了一个请求，要求根据当前的主题调整组件的外观。由于主题化是一个全球性的问题，它被实现为包装应用程序的上下文提供者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ko kp l"/></div></figure><p id="40ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，改变应该很容易。我们可以用<code class="fe kq kr ks kt b">useTheme</code>钩子获得当前主题，然后应用一些CSS。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ko kp l"/></div></figure><p id="9fb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，我们现在有一个问题，委婉地说，改变主题感觉不是很爽快。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi le"><img src="../Images/3447a8a65e20c7232763c74af40c8704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*zqzxN4Tme2LQ4fXjL8CYZw.gif"/></div></figure><p id="7f7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是为什么呢？由于<code class="fe kq kr ks kt b">Fibonacci</code>组件订阅了<code class="fe kq kr ks kt b">Theme</code>上下文，所以每次上下文值改变时，它都会被重新呈现。这是有意义的，毕竟所有的CSS类都必须更新。但是假设<code class="fe kq kr ks kt b">n</code>没有改变，我们能防止重新计算fib函数结果吗？</p><p id="ff22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">幸运的是<code class="fe kq kr ks kt b">useMemo</code>虎克前来救援！改变很容易。您所需要的只是像这样包装对一个昂贵函数的调用</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="be8a" class="ky kz in kt b gy la lb l lc ld">const result = useMemo(() =&gt; fib(n), [n]);</span></pre><p id="31de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二个参数是一个依赖数组。只要数组中的值在两次渲染之间保持不变，<code class="fe kq kr ks kt b">fib</code>函数将只执行一次。请记住，在每次渲染时，react都需要创建一个依赖数组，并对相应的元素执行浅层相等检查，因此这种优化不是免费的！尽管如此，它对于记忆昂贵的计算来说还是很有意义的。</p><p id="fbcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这篇文章有助于理解<code class="fe kq kr ks kt b">React.memo</code>、<code class="fe kq kr ks kt b">useCallback</code>和<code class="fe kq kr ks kt b">useMemo</code>如何帮助解决React中的性能问题。我很高兴听到你在这方面的经验。</p><p id="6781" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一些有用的资源:</p><ul class=""><li id="5b56" class="lh li in jm b jn jo jr js jv lj jz lk kd ll kh lm ln lo lp bi translated"><a class="ae ki" href="https://github.com/facebook/react/issues/15156#issuecomment-474590693" rel="noopener ugc nofollow" target="_blank">https://github . com/Facebook/react/issues/15156 # issue comment-474590693</a></li><li id="46e7" class="lh li in jm b jn lq jr lr jv ls jz lt kd lu kh lm ln lo lp bi translated"><a class="ae ki" href="https://kentcdodds.com/blog/usememo-and-usecallback" rel="noopener ugc nofollow" target="_blank">https://kentcdodds.com/blog/usememo-and-usecallback</a></li><li id="344c" class="lh li in jm b jn lq jr lr jv ls jz lt kd lu kh lm ln lo lp bi translated"><a class="ae ki" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usememo</a></li><li id="7e8c" class="lh li in jm b jn lq jr lr jv ls jz lt kd lu kh lm ln lo lp bi translated"><a class="ae ki" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usecallback</a></li><li id="3e76" class="lh li in jm b jn lq jr lr jv ls jz lt kd lu kh lm ln lo lp bi translated"><a class="ae ki" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-api.html#reactmemo</a></li></ul></div></div>    
</body>
</html>