<html>
<head>
<title>Reverse a String with a Stack in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中用堆栈反转字符串</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reversing-a-string-using-a-stack-in-javascript-66c4883bb441?source=collection_archive---------3-----------------------#2021-03-27">https://javascript.plainenglish.io/reversing-a-string-using-a-stack-in-javascript-66c4883bb441?source=collection_archive---------3-----------------------#2021-03-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c0b42ebc60d8f01a3f1529fac5125efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcr4o3ueq7E6vS37bwMzKw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jdubs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Johnson Wang</a> on <a class="ae jz" href="https://unsplash.com/s/photos/stack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0dba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将学习如何在JavaScript中使用堆栈来反转字符串。</p><h1 id="5db8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是堆栈？</h1><p id="d573" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">堆栈是一种线性数据结构，它遵循操作执行的特定顺序。顺序是后进先出(LIFO)。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/0b19de41a95621297a1540388f082c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuKoqbyCm-eBxdLOiVNhbw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A simple visualization of a stack</figcaption></figure><p id="d82d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">栈使用<code class="fe mg mh mi mj b">push()</code>和<code class="fe mg mh mi mj b">pop()</code>分别为<em class="mk">添加</em>和<em class="mk">删除</em>元素。一个栈可以有任意多的元素，但是添加和移除元素的方式仍然是LIFO。不能对堆栈底部/之间的元素进行操作。在本文中，我们将用JavaScript实现一个基本的堆栈，并用它来反转一个字符串！</p><h1 id="98f2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实现堆栈</h1><p id="c94d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为了实现堆栈，我们将使用基于类的方法。堆栈中将使用以下方法。</p><ol class=""><li id="b9c7" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">push() —将元素添加到堆栈中。</li><li id="236f" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">pop() —移除并返回堆栈中最顶端的元素。</li><li id="80bf" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">isEmpty() —根据堆栈是否为空返回true或false。</li></ol><h2 id="468d" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">让我们为栈写代码吧！</h2><p id="6841" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">首先，让我们创建一个带有构造函数的类堆栈，该构造函数初始化一个名为elements的数组，该数组将存储元素。</p><pre class="mc md me mf gt nl mj nm nn aw no bi"><span id="f658" class="mz kz in mj b gy np nq l nr ns">class stack { <br/>    constructor(){  <br/>        this.elements = []; <br/>    }<br/>}</span></pre><p id="e591" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们添加所有的方法。</p><h2 id="1edc" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">推送方法:</h2><pre class="mc md me mf gt nl mj nm nn aw no bi"><span id="20a1" class="mz kz in mj b gy np nq l nr ns">push(element){ <br/>    this.elements.push(element) <br/>}</span></pre><h2 id="a497" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">pop方法:</h2><pre class="mc md me mf gt nl mj nm nn aw no bi"><span id="75f2" class="mz kz in mj b gy np nq l nr ns">pop(){ <br/>    if(this.elements.length === 0) return "Underflow situation"; <br/>    else return this.elements.pop();<br/>}</span></pre><h2 id="daf3" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">isEmpty方法:</h2><pre class="mc md me mf gt nl mj nm nn aw no bi"><span id="dc45" class="mz kz in mj b gy np nq l nr ns">isEmpty(){ <br/>    if(this.elements.length &gt; 0) return false;<br/>    else return true;<br/>}</span></pre><h1 id="02c3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">反转字符串概述</h1><p id="b414" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">首先也是最重要的，重要的是要形象化我们将如何反转一个字符串以使开发变得更加容易。</p><p id="cd38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">管柱的反向将遵循3个步骤:</p><ol class=""><li id="0f2f" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">字符串的每个字符将被添加(推入)到堆栈中。</li><li id="8bc9" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">在步骤1之后，堆栈将被弹出，并创建一个反向字符串。</li><li id="2208" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">返回反转的字符串。</li></ol><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/0504422d1bd432a25811869c76123093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6XFH6xupDfB28XhphPW5g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A visual representation of the algorithm</figcaption></figure><h1 id="cb25" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">代码</h1><p id="a9c8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">堆栈:</p><pre class="mc md me mf gt nl mj nm nn aw no bi"><span id="5d2b" class="mz kz in mj b gy np nq l nr ns">class Stack {<br/> <br/>    constructor(){  <br/>        this.elements = []; <br/>    }</span><span id="de2a" class="mz kz in mj b gy nt nq l nr ns">    push(element){ <br/>        this.elements.push(element) <br/>    }</span><span id="e0e3" class="mz kz in mj b gy nt nq l nr ns">    pop(){ <br/>        if(this.elements.length === 0) return "Underflow situation"; <br/>        else return this.elements.pop();<br/>    }</span><span id="fd37" class="mz kz in mj b gy nt nq l nr ns">    isEmpty(){ <br/>        if(this.elements.length &gt; 0) return false;<br/>        else return true;<br/>    }</span><span id="b44e" class="mz kz in mj b gy nt nq l nr ns">}</span></pre><p id="24bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mg mh mi mj b">reverse</code>功能:</p><pre class="mc md me mf gt nl mj nm nn aw no bi"><span id="fd3a" class="mz kz in mj b gy np nq l nr ns">function reverse(<em class="mk">str</em>){</span><span id="2cb9" class="mz kz in mj b gy nt nq l nr ns"><em class="mk">     //Creates a new stack<br/>     </em>let stack = new Stack();<br/>      <br/>     let i = 0;<br/>     let reversedStr = "";</span><span id="b70d" class="mz kz in mj b gy nt nq l nr ns"><em class="mk">     //Adds all the characters to the stack.<br/>     </em>while (i !== <em class="mk">str</em>.length) {<br/>         stack.push(<em class="mk">str</em>.charAt(i));<br/>         i++;<br/>     }<br/>   <br/>     <em class="mk">//Creates a reversed string by popping the stack.<br/>     </em>while (!stack.isEmpty()) {<br/>         reversedStr += stack.pop();<br/>     }</span><span id="84fe" class="mz kz in mj b gy nt nq l nr ns"><em class="mk">     //returns the reversed string.<br/>     </em>return reversedStr;</span><span id="17f9" class="mz kz in mj b gy nt nq l nr ns">}</span></pre><h1 id="b2e9" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试上述功能</h1><p id="940c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们测试一下这个功能。以下是一些测试案例:面包、中等、javascript。</p><pre class="mc md me mf gt nl mj nm nn aw no bi"><span id="dfb9" class="mz kz in mj b gy np nq l nr ns">Input: BrEAd             Input: MeDIum           Input: javascript</span><span id="bc02" class="mz kz in mj b gy nt nq l nr ns">Output: dAErB            Output: muIDeM          Output: tpircsavaj</span></pre><p id="5d29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">功能运行完美！</p><h1 id="302d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">时间和空间复杂性</h1><p id="b5e8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">算法的<em class="mk">时间复杂度</em>为O(n)，空间复杂度<em class="mk">也为O(n)。</em></p><h2 id="b217" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">说明</h2><p id="97e9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">空间复杂度是O(n ),因为我们将每个元素(字符串中的字符)推入并存储在堆栈中。</p><p id="553d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">时间复杂度是O(n ),因为我们访问字符串中的每个字符，并将其压入堆栈。在此之后，我们再次从堆栈中弹出每个字符，并创建反向字符串[O(n) + O(n) = O(n)]。</p></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><h1 id="3e8c" class="ky kz in bd la lb ob ld le lf oc lh li lj od ll lm ln oe lp lq lr of lt lu lv bi translated">最终代码</h1><p id="2bf9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">资源库链接:<a class="ae jz" href="https://github.com/Megh-Agarwal/reverse-string-using-stack-js" rel="noopener ugc nofollow" target="_blank">https://github . com/Megh-Agarwal/reverse-string-using-stack-js</a></p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><h2 id="25d5" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">结论</h2><p id="35ef" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">感谢您阅读这篇文章。希望你觉得有用。如果有，一定要留下评论让我知道:)</p></div></div>    
</body>
</html>