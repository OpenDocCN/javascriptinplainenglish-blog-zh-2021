<html>
<head>
<title>JavaScript-Typescript Design Patterns: Singleton and Private Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript-Typescript设计模式:单例和私有构造函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-typescript-design-patterns-singleton-and-private-constructors-1da7e268be95?source=collection_archive---------11-----------------------#2021-06-06">https://javascript.plainenglish.io/javascript-typescript-design-patterns-singleton-and-private-constructors-1da7e268be95?source=collection_archive---------11-----------------------#2021-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="2ee9" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">什么是独生子女？</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5acd04d6d799851c485bcc9d1a740a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*vpIo7zVHmmLVemsM.jpg"/></div></figure><p id="0ca7" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">Singleton的核心是一个<strong class="ks io">设计模式</strong>，它<strong class="ks io">将</strong>一个类的实例化限制为<strong class="ks io">一个对象</strong>。通常，<strong class="ks io">目标是管理全局应用程序状态。</strong>一些示例使用单例作为web应用程序的配置设置源，在客户端使用API键启动任何东西(例如，您通常<strong class="ks io">不想冒险发送多个分析跟踪调用)，并在客户端web应用程序的内存中存储数据(例如，在Flux中存储)。</strong></p><p id="ea26" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于消费代码来说，单例应该是<strong class="ks io">不可变的</strong>，并且应该不会有实例化多个单例的危险。</p><p id="ca61" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">注意:有些情况下，单例可能是不好的，而事实上，它们总是不好的。关于这方面的讨论，你可以看看这篇关于这个主题的文章</em>  <em class="lo">。</em></p><p id="1797" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看看不同场景的例子:</p><p id="499f" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">a .类型脚本和私有构造函数</p><p id="4eb5" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">→因为singleton的目的是<strong class="ks io">只创建一个实例。Typescript具有访问修饰符概念(即私有、公共和受保护)。</strong></p><p id="e8ec" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">→因此，我们可以创建一个私有构造函数并在类内部创建一个实例，而不是在外部创建实例</p><p id="58ee" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ks io">注意:</strong>在JavaScript中，我们只有一个<strong class="ks io"> public </strong>修饰符。因此，我们将在类型脚本方法之后看到一种不同的方法</p><p id="d101" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">例如。</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="9322" class="lv jl in lr b gy lw lx l ly lz">// BASE CLASS<br/>class <strong class="lr io">Department</strong> {</span><span id="2450" class="lv jl in lr b gy ma lx l ly lz">  protected employee: string[] = [];</span><span id="6ab0" class="lv jl in lr b gy ma lx l ly lz">  constructor(public name: string, protected id: string) {</span><span id="7701" class="lv jl in lr b gy ma lx l ly lz">    this.name = name;</span><span id="693b" class="lv jl in lr b gy ma lx l ly lz">  }</span><span id="c52a" class="lv jl in lr b gy ma lx l ly lz"><strong class="lr io">  describe</strong>() {</span><span id="a816" class="lv jl in lr b gy ma lx l ly lz">    console.<strong class="lr io">log</strong>(`</span><span id="f50b" class="lv jl in lr b gy ma lx l ly lz">      DEPARTMENT: ${this.name}</span><span id="7f78" class="lv jl in lr b gy ma lx l ly lz">      ID: ${this.id}</span><span id="2eed" class="lv jl in lr b gy ma lx l ly lz">     `);</span><span id="f188" class="lv jl in lr b gy ma lx l ly lz">  }</span><span id="551f" class="lv jl in lr b gy ma lx l ly lz">}</span><span id="de0d" class="lv jl in lr b gy ma lx l ly lz">// CHILD CLASS:<br/>class <strong class="lr io">AccountDepartment</strong> extends <strong class="lr io">Department</strong> {</span><span id="d47a" class="lv jl in lr b gy ma lx l ly lz">  admin: string [];</span><span id="89f7" class="lv jl in lr b gy ma lx l ly lz">  <strong class="lr io">private static instance: AccountDepartment</strong>; // initialize a static variable</span><span id="a8a2" class="lv jl in lr b gy ma lx l ly lz">  // Cannot be accessed from outside the class<br/>  <strong class="lr io">private constructor</strong>(id: string, admin: string[]) {</span><span id="5819" class="lv jl in lr b gy ma lx l ly lz">    super(id, 'Account');</span><span id="d1ea" class="lv jl in lr b gy ma lx l ly lz">    this.admin = admin;</span><span id="70c0" class="lv jl in lr b gy ma lx l ly lz">    this.id = id;</span><span id="e838" class="lv jl in lr b gy ma lx l ly lz">  }</span><span id="f1b3" class="lv jl in lr b gy ma lx l ly lz">   // Always return the same instance<br/>   static <strong class="lr io">getInstance</strong> () {</span><span id="6f11" class="lv jl in lr b gy ma lx l ly lz">    if(<strong class="lr io">AccountDepartment</strong>.instance) { // i.e. classname.variable</span><span id="12c6" class="lv jl in lr b gy ma lx l ly lz">      return this.instance;</span><span id="01a7" class="lv jl in lr b gy ma lx l ly lz">    }</span><span id="97c2" class="lv jl in lr b gy ma lx l ly lz">    return this.instance = new <strong class="lr io">AccountDepartmntt</strong>('d25', ['Max']);</span><span id="a36a" class="lv jl in lr b gy ma lx l ly lz">  }</span><span id="c5cb" class="lv jl in lr b gy ma lx l ly lz">}</span><span id="1421" class="lv jl in lr b gy ma lx l ly lz"><em class="lo">// So here only once instance is used - despite calling multiple times</em></span><span id="f90c" class="lv jl in lr b gy ma lx l ly lz">const account = <strong class="lr io">AccountDepartmntt</strong>.<strong class="lr io">getInstance</strong>();</span><span id="79f0" class="lv jl in lr b gy ma lx l ly lz">console.<strong class="lr io">log</strong>(account);</span><span id="a38d" class="lv jl in lr b gy ma lx l ly lz">const account2 = <strong class="lr io">AccountDepartmntt</strong>.<strong class="lr io">getInstance</strong>();</span><span id="4e59" class="lv jl in lr b gy ma lx l ly lz">console.<strong class="lr io">log</strong>(account2);</span><span id="c223" class="lv jl in lr b gy ma lx l ly lz"><em class="lo">// const accountingDepartmenttAC = new AccountDepartmntt('d12', ['Rana']);</em></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/6f4de3faeae76de1e999cc999b2a3445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBXTzm_gm2FI6dGVIqZ0-A.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Getting same o/p for different instance</figcaption></figure></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><p id="4c42" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ks io"> b. JavaScript:用JS创建单例的老方法</strong></p><p id="3742" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">用JavaScript编写singleton的老方法包括利用闭包和IIFE。下面是我们如何用老方法为一个假设的Flux实现编写一个(非常简单的)存储:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="1f63" class="lv jl in lr b gy lw lx l ly lz">var UserStore = (function(){<br/>  var _data = [];<br/><br/>  function add(item){<br/>    _data.push(item);<br/>  }<br/><br/>  function get(id){<br/>    return _data.find((d) =&gt; {<br/>      return d.id === id;<br/>    });<br/>  }<br/><br/>  return {<br/>    add: add,<br/>    get: get<br/>  };<br/>}());</span></pre><p id="d87f" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当解释该代码时，<code class="fe mr ms mt lr b">UserStore</code>将被设置为该<strong class="ks io">life(立即调用的函数)</strong> — <strong class="ks io">的结果，该对象公开两个函数，但不授权对数据集合的直接访问。</strong></p><p id="684f" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，这段代码比它需要的更冗长，并且也没有给我们提供我们在使用单例时所希望的不变性。稍后执行的代码可以修改任何一个公开的函数，甚至可以一起重新定义<code class="fe mr ms mt lr b">UserStore</code>。此外，修改/违规代码可能在任何地方！如果我们由于对<code class="fe mr ms mt lr b">UsersStore</code>的意外修改而发现了bug，那么在一个更大的项目中追踪它们可能会非常令人沮丧。</p><p id="c9dd" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如本·切里在<a class="ae lp" href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" rel="noopener ugc nofollow" target="_blank">的这篇文章</a>中所指出的，你可以采取更高级的措施来减轻这些负面影响。(他的目标是创建模块，这些模块恰好是单例的，但模式是相同的。)但是这些给代码增加了不必要的复杂性，同时仍然不能得到我们想要的东西。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><p id="0419" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ks io"> c. ES6现代JavaScript方式:</strong></p><p id="7214" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">→通过利用ES6的特性，主要是模块和新的<code class="fe mr ms mt lr b">const</code>变量声明，我们不仅可以用更简洁的方式编写单例，还可以更好地满足我们的需求。</p><p id="e14d" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们从最基本的实现开始。下面是对上述例子的(更清晰、更强大的)现代解释:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="4c75" class="lv jl in lr b gy lw lx l ly lz">const _data = [];<br/><br/>const UserStore = {<br/>  add: item =&gt; _data.push(item),<br/>  get: id =&gt; _data.find(d =&gt; d.id === id)<br/>}<br/><br/>Object.freeze(UserStore);<br/>export default UserStore;</span></pre><p id="e555" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">→由于我们使用了<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank"> <strong class="ks io"> Object.freeze </strong> </a>()，它的方法不能改变，也不能给它添加新的方法或属性。</p><p id="5e2f" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">→我们把<code class="fe mr ms mt lr b">UserStore</code>变成了一个对象文字。大多数时候，使用对象文字是最易读、最简洁的选择。然而，有时候你可能想利用传统课程的优势。例如，不断变化的商店都有许多相同的基本功能。利用传统的面向对象继承是在保持代码干燥的同时获得重复功能的一种方式。</p><p id="e140" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果我们想利用ES6类，实现看起来会是这样的:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="7586" class="lv jl in lr b gy lw lx l ly lz">class UserStore {<br/>  constructor(){<br/>    this._data = [];<br/>  }<br/><br/>  add(item){<br/>    this._data.push(item);<br/>  }<br/><br/>  get(id){<br/>    return this._data.find(d =&gt; d.id === id);<br/>  }<br/>}<br/><br/>const instance = new UserStore();<br/>Object.freeze(instance);<br/><br/>export default instance;</span></pre><p id="1201" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">Eg2:变得更加冗长:</p><pre class="kj kk kl km gt lq lr ls lt aw lu bi"><span id="3054" class="lv jl in lr b gy lw lx l ly lz">class UserStore {<br/>  constructor(){<br/>   if(! UserStore.instance){<br/>     this._data = [];<br/>     UserStore.instance = this;<br/>   }<br/><br/>   return UserStore.instance;<br/>  }<br/><br/> //rest is the same code as preceding example<br/><br/>}<br/><br/>const instance = new UserStore();<br/>Object.freeze(instance);<br/><br/>export default instance;</span></pre><h1 id="7b71" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结束语:</h1><p id="8a53" class="pw-post-body-paragraph kq kr in ks b kt mu kv kw kx mv kz la lb mw ld le lf mx lh li lj my ll lm ln ig bi translated">毫无疑问，许多开发人员已经在JavaScript中使用旧的单例/模块模式很多年了，他们发现这种模式非常适合他们。尽管如此，因为寻找更好的做事方法对开发人员来说是如此重要，希望我们能看到像这样更干净、更容易理解的模式获得越来越多的关注。尤其是当利用ES6+功能变得越来越容易和普遍的时候。</p><p id="cada" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这种模式是我在使用Typescript实现类时实现的。主要目标是创建单个实例。</p><blockquote class="mz na nb"><p id="cc4d" class="kq kr lo ks b kt ku kv kw kx ky kz la nc lc ld le nd lg lh li ne lk ll lm ln ig bi translated">谢谢你一直坚持到最后🙌。如果你喜欢这篇文章，或者学到了新的东西，请点击下面的分享按钮来支持我，与更多的人联系，和/或在 <a class="ae lp" href="https://twitter.com/amir__mustafa" rel="noopener ugc nofollow" target="_blank"> <em class="in"> Twitter </em> </a> <em class="in">上关注我，看看我在那里学到和分享的其他技巧、文章和东西。</em></p></blockquote><p id="b374" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">更多内容看</em> <a class="ae lp" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ks io"> <em class="lo">说白了。报名参加我们的</em> <a class="ae lp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ks io"> <em class="lo">免费周报</em> </strong> </a> <em class="lo">。在我们的</em> <a class="ae lp" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ks io"> <em class="lo">社区不和谐</em> </strong> </a> <em class="lo">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>