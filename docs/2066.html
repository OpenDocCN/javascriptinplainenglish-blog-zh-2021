<html>
<head>
<title>How to Delete Multiple Records in GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在GraphQL中删除多条记录</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-delete-multiple-records-in-graphql-ed76103e77de?source=collection_archive---------3-----------------------#2021-05-02">https://javascript.plainenglish.io/how-to-delete-multiple-records-in-graphql-ed76103e77de?source=collection_archive---------3-----------------------#2021-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5eaff7fdeb4191a976d94d94dcad53d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J35-nx4hUD-eMUMR"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ujesh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">u j e s h</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7b4b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在side hustle项目的这个GraphQL服务器上使用了非常<a class="ae jz" href="https://medium.com/novvum/graphql-code-first-and-sdl-first-the-current-landscape-in-mid-2019-699f68b31a65" rel="noopener"> SDL优先</a>的方法，在用其他框架开发了几天之后，我决定切换到<a class="ae jz" href="https://api-platform.com/docs/core/graphql/" rel="noopener ugc nofollow" target="_blank"> API平台</a>。</p><p id="68b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你确定你的资源时，它允许所有的CRUD操作都准备好，这种方式很棒。但是我不想仅仅为了满足更多的功能需求而重写其中的一些。</p><p id="9f7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其中之一是从数据表中批量删除记录，如下所示:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/4aac78dd5832baed8a9d2b4b6996c9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ljSyyH4n3sVfRf7z5enkWA.png"/></div></div></figure><p id="45b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我使用的是Vue Apollo的Composition API，它删除了一条记录:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="a896" class="li lj in le b gy lk ll l lm ln">const { mutate: someDeleteMutationCaller } = useMutation(gql`<br/>  mutation deleteMyRecordMutation ($id: ID!) {<br/>    deleteMyRecord (input: {id: $id}) {<br/>      myRecord {<br/>        id<br/>      }<br/>    }<br/>  }`);</span><span id="03c0" class="li lj in le b gy lo ll l lm ln">someDeleteMutation({id: "id of the myRecord item"});</span></pre><p id="85f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果我想一次删除多条记录，这个逻辑对我没有帮助。</p><p id="9d89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原因如下:</p><p id="5b36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个也是非常糟糕的选择是多次调用突变:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="cfed" class="li lj in le b gy lk ll l lm ln">someDeleteMutationCaller({id: "/my_record/1"});<br/>someDeleteMutationCaller({id: "/my_record/2"});<br/>someDeleteMutationCaller({id: "/my_record/3"});<br/>...<br/>someDeleteMutationCaller({id: "/my_record/100"});</span></pre><p id="d3b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是正如您所看到的，这种方法效率不高，并且有可能遇到速率限制。</p><p id="1ed9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一种选择是发送ID数组，而不是单个ID:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="622e" class="li lj in le b gy lk ll l lm ln">const { mutate: someDeleteMutationCaller } = useMutation(gql`<br/>  mutation deleteMyRecordsMutation ($ids: [ID]!) {<br/>    deleteMyRecords (input: {ids: $ids}) {<br/>      myRecord {<br/>        id<br/>      }<br/>    }<br/>  }`);</span><span id="d136" class="li lj in le b gy lo ll l lm ln">someDeleteMutationCaller({ids: ["/my_record/1", "/my_record/2", "/my_record/3"]});</span></pre><p id="8ed7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要实现这一点，您应该修改框架的原始/本机<em class="lp"> delete </em>操作，或者添加另一个操作来处理多个删除，并保留原始的删除操作来处理单个删除。</p><p id="6599" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更好的选择是让您的变异查询处理多次删除。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="c3fb" class="li lj in le b gy lk ll l lm ln">const { mutate: someDeleteMutationCaller } = useMutation(gql`<br/>  mutation deleteMyRecordMutation {<br/>    id_1: deleteMyRecord (input: {id: "/my_record/1"}) {<br/>      myRecord {<br/>        id<br/>      }<br/>    }</span><span id="fdde" class="li lj in le b gy lo ll l lm ln">    id_2: deleteMyRecord (input: {id: "/my_record/2"}) {<br/>      myRecord {<br/>        id<br/>      }<br/>    }<br/>        <br/>    id_3: deleteMyRecord (input: {id: "/my_record/3"}) {<br/>      myRecord {<br/>        id<br/>      }<br/>    }<br/>  }`);</span><span id="4373" class="li lj in le b gy lo ll l lm ln">someDeleteMutationCaller();</span></pre><p id="4c93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的问题是，我们不再能够使用变量传递给我们的查询，因为突变调用必须在每个记录ID上重复。另外，我们不能在Vue.js的setup函数之外调用useMutation方法。</p><p id="50e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们用的是mighty Vue.js，当然可以克服这个问题:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="4952" class="li lj in le b gy lk ll l lm ln">setup() {<br/>  const deleteMyRecordsMutationContext = ref([]);<br/>  <br/>  const { mutate: someDeleteMutation } = useMutation(() =&gt; {<br/>    return gql`<br/>      mutation deleteMyRecordMutation {<br/>        ${deleteMyRecordsMutationContext.value.join('\n')}<br/>      }`<br/>    });</span><span id="2ca2" class="li lj in le b gy lo ll l lm ln">return {<br/>    deleteMutationCaller () {<br/>      const myObjectIDsToDelete = [<br/>        {_id: 1, id: "/my_record/1"},<br/>        {_id: 2, id: "/my_record/2"},<br/>        {_id: 3, id: "/my_record/3"},<br/>        ...,<br/>        {_id: 100, id: "/my_record/100"}<br/>      ];<br/><br/>      deleteMyRecordsMutationContext.value = myObjectIDsToDelete.map((item) =&gt; {<br/>        <em class="lp">return</em> `<br/>          id_${item._id}: deleteMyRecord(input: {id: "${item.id}"}) {<br/>            myRecord {<br/>              id<br/>            }<br/>          }`<br/>      });</span><span id="c7f0" class="li lj in le b gy lo ll l lm ln">      someDeleteMutation();<br/>    }<br/>  } <br/>}</span></pre><p id="0df8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，变异查询的上下文将自动生成，您将能够删除数组中的所有记录，而无需更改任何一行后端代码。</p><p id="b8eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的技巧是使用函数调用，而不是将<em class="lp"> gql </em>调用直接放入<em class="lp"> useMutation </em>中。</p><p id="f6b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望这能帮助到某个人。感谢您的阅读。</p><p id="03fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lp">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lp">plain English . io</em></a></p></div></div>    
</body>
</html>