<html>
<head>
<title>Setup Node.js, EJS with TypeScript using Gulp and Webpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gulp和Webpack安装Node.js、EJS和TypeScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/setup-node-js-ejs-with-typescript-using-gulp-and-webpack-135aeb93165?source=collection_archive---------9-----------------------#2021-07-31">https://javascript.plainenglish.io/setup-node-js-ejs-with-typescript-using-gulp-and-webpack-135aeb93165?source=collection_archive---------9-----------------------#2021-07-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1458161e1324d6da16e5a0d8cdbc8c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F_XcAyjFvgTTfJIv.png"/></div></div></figure><p id="0128" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章假设你想在Node.js中使用TypeScript作为后端和前端(使用EJS模板),但是正在努力建立一个系统来将TypeScript代码转换成浏览器可以理解的后端和前端的JavaScript。</p><p id="6ee8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">源代码可以在GitHub <a class="ae kt" href="https://github.com/RohitLakh/node-ejs-with-typescript-starter-project" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="cfee" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">基本设置</h1><p id="d33a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">要继续开机自检，您需要在系统中安装节点和npm</p><p id="9551" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个节点项目</p><h1 id="afcb" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用TypeScript设置Node.js</h1><p id="7fc5" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了在Node.js中使用TypeScript，我们需要安装一些dev依赖项来帮助我们使用nodemon运行TypeScript。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7a32" class="mg kv in mc b gy mh mi l mj mk">npm i -D typescript ts-node @types/node</span></pre><p id="33a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mc b">@types</code>为包安装类型别名。</p><p id="8c62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们安装nodemon</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="691c" class="mg kv in mc b gy mh mi l mj mk">npm i -g nodemon</span></pre><p id="8d35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们安装express</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d0e6" class="mg kv in mc b gy mh mi l mj mk">npm i express</span></pre><p id="763e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还需要express的类型别名。所以让我们也安装它</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="88e2" class="mg kv in mc b gy mh mi l mj mk">npm i -D @types/express</span></pre><p id="1507" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们启动一个<code class="fe ml mm mn mc b">tsconfig.json</code></p><p id="be4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，安装基本的依赖项已经完成，让我们定义目录结构。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="36d7" class="mg kv in mc b gy mh mi l mj mk">├── node_modules/<br/>├── dist/<br/>├── src/<br/>│   ├── config/<br/>│   │   └── debug.ts<br/>│   ├── public/<br/>│   │   ├── assets<br/>│   │   └── ts/<br/>│   └── views/<br/>├── app.ts<br/>├── package-lock.json<br/>├── package.json<br/>└── tsconfig.json</span></pre><p id="750b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要写的任何代码都将在<code class="fe ml mm mn mc b">src</code>目录中，而构建将在<code class="fe ml mm mn mc b">dist</code>目录中。</p><p id="1c0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前端的打字稿会在<code class="fe ml mm mn mc b">public</code>文件夹内的<code class="fe ml mm mn mc b">ts</code>文件夹中。</p><p id="bd81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的<code class="fe ml mm mn mc b">ejs</code>模板文件将进入<code class="fe ml mm mn mc b">views</code>目录。</p><h1 id="3f8e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">配置您的tsconfig.json</h1><p id="655e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">因为我们将对node使用TypeScript，所以我们需要在<code class="fe ml mm mn mc b">tsconfig.json</code>文件中做一些修改。</p><p id="25dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这足够让我们工作了。如果你想了解tsconfig中的更多选项，请查阅<a class="ae kt" href="https://www.typescriptlang.org/tsconfig" rel="noopener ugc nofollow" target="_blank"> tsconfig文档</a></p><p id="c3a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以最终的<code class="fe ml mm mn mc b">tsconfig.json</code>看起来会像这样</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3a2a" class="mg kv in mc b gy mh mi l mj mk">{<br/>  "compilerOptions": {<br/>    "target": "es5",<br/>    "module": "commonjs",<br/>    "outDir": "./dist",<br/>    "rootDir": "./src",<br/>    "strict": true,<br/>    "noImplicitAny": true,<br/>    "moduleResolution": "node",<br/>    "esModuleInterop": true,<br/>    "skipLibCheck": true,<br/>    "forceConsistentCasingInFileNames": true<br/>  }<br/>}</span></pre><p id="4fa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们编写启动和运行服务器的代码。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="cb40" class="mg kv in mc b gy mh mi l mj mk">import express, { Application } from "express";<br/>import http from "http";<br/>import debug from "./config/debug";<br/><br/>const app: Application = express();<br/>const server: http.Server = http.createServer(app);<br/><br/>// Setting the port<br/>const port = debug.PORT;<br/><br/>// Starting the server<br/>server.listen(port, () =&gt; {<br/>    console.log(`SERVER RUNNING ON ${port}`);<br/>});</span></pre><p id="29dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在运行服务器</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b511" class="mg kv in mc b gy mh mi l mj mk">nodemon src/app.ts</span></pre><p id="fd57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你应该看看</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c0aa" class="mg kv in mc b gy mh mi l mj mk">SERVER RUNNING ON 3000</span></pre><p id="ee3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一切都很好，nodemon正在处理一切，但是现在如果您注意到没有生成<code class="fe ml mm mn mc b">dist</code>目录。让我们使用gulp生成<code class="fe ml mm mn mc b">dist</code>目录和nodemon来观察变化。两者都有助于我们自动化整个过程</p><p id="4306" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们安装gulp、gulp-typescript和del</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="88ef" class="mg kv in mc b gy mh mi l mj mk">npm i -D gulp gulp-typescript del</span></pre><p id="6747" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在在项目的根目录下创建一个<code class="fe ml mm mn mc b">gulpfile.js</code>文件</p><p id="2b9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mc b">gulpfile.js</code></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="dd3b" class="mg kv in mc b gy mh mi l mj mk">var gulp = require("gulp");<br/>var ts = require("gulp-typescript");<br/>var tsProject = ts.createProject("tsconfig.json");<br/>var del = require("del");<br/><br/><br/>// Task which would transpile typescript to javascript<br/>gulp.task("typescript", function () {<br/>    return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest("dist"));<br/>});<br/><br/>// Task which would delete the old dist directory if present<br/>gulp.task("build-clean", function () {<br/>    return del(["./dist"]);<br/>});<br/><br/>// Task which would just create a copy of the current views directory in dist directory<br/>gulp.task("views", function () {<br/>    return gulp.src("./src/views/**/*.ejs").pipe(gulp.dest("./dist/views"));<br/>});<br/><br/>// Task which would just create a copy of the current static assets directory in dist directory<br/>gulp.task("assets", function () {<br/>    return gulp.src("./src/public/assets/**/*").pipe(gulp.dest("./dist/public/assets"));<br/>});<br/><br/>// The default task which runs at start of the gulpfile.js<br/>gulp.task("default", gulp.series("build-clean","typescript", "views", "assets"), () =&gt; {<br/>    console.log("Done");<br/>});</span></pre><p id="70ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在通过以下方式运行该文件</p><p id="04db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在默认任务完成检查您的目录之后，您会看到生成了一个<code class="fe ml mm mn mc b">dist</code>目录。它应该有<code class="fe ml mm mn mc b">config</code>、<code class="fe ml mm mn mc b">public/ts,</code>、<code class="fe ml mm mn mc b">public/asset</code>、<code class="fe ml mm mn mc b">views</code>目录和<code class="fe ml mm mn mc b">app.js</code></p><p id="c49c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在使用以下命令运行服务器</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ce02" class="mg kv in mc b gy mh mi l mj mk">node dist/app.js</span></pre><p id="e4d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你应该看看</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="16e0" class="mg kv in mc b gy mh mi l mj mk">SERVER RUNNING ON 3000</span></pre><p id="4404" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使监听文件变化的服务器自动化，构建并重新运行服务器，我们需要安装另一个包。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9b8a" class="mg kv in mc b gy mh mi l mj mk">npm i -D npm-run-all</span></pre><p id="f8df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要创建一些脚本，以便让服务器监视更改，并使用新的更改重新运行服务器。</p><p id="6fe5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在package.json中，将这段代码添加到脚本对象中</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="269b" class="mg kv in mc b gy mh mi l mj mk">{<br/>    "start:gulp": "npm-run-all gulp start",<br/>    "gulp": "gulp",<br/>    "start": "node ./dist/app.js",<br/>    "dev": "nodemon --watch src -e ts,ejs --exec npm run start:gulp"<br/>}</span></pre><p id="e69a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，这是检查更改，如果发现，然后重新运行gulp命令，该命令转换类型脚本代码，然后使用start运行服务器。</p><p id="95d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你应该再次看到</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="808d" class="mg kv in mc b gy mh mi l mj mk">SERVER RUNNING ON 3000</span></pre><p id="5a43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">所以现在我们有了使用Gulp运行Node.js的TypeScript。</strong></p><h1 id="adab" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置EJS模板</h1><p id="1519" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了在Node.js中使用EJS模板，我们需要安装一些npm包。让我们安装它们</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="f042" class="mg kv in mc b gy mh mi l mj mk">npm i express-ejs-layouts ejs</span></pre><p id="9523" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在安装后，我们需要<code class="fe ml mm mn mc b">express</code>知道我们想使用EJS作为<code class="fe ml mm mn mc b">view engine</code>并添加视图的根路径，这样express就知道它们在哪里。</p><p id="f5a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将这些添加到<code class="fe ml mm mn mc b">app.ts</code></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="70ce" class="mg kv in mc b gy mh mi l mj mk">import expressLayouts from 'express-ejs-layouts';<br/><br/>// EJS setup<br/>app.use(expressLayouts);<br/><br/>// Setting the root path for views directory<br/>app.set('views', path.join(__dirname, 'views'));<br/><br/>// Setting the view engine<br/>app.set('view engine', 'ejs');</span></pre><p id="0937" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们添加一些EJS模板</p><p id="5e02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ml mm mn mc b">views</code>下创建一个新文件，命名为<code class="fe ml mm mn mc b">layout.ejs</code></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2fe9" class="mg kv in mc b gy mh mi l mj mk">&lt;!doctype html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;<br/>    &lt;title&gt;Node Typescript&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div&gt;&lt;%- body %&gt;&lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="bfb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在保存它并添加另一个文件，在与<code class="fe ml mm mn mc b">layout.ejs</code>相同的目录下命名为<code class="fe ml mm mn mc b">index.ejs</code></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4ca7" class="mg kv in mc b gy mh mi l mj mk">&lt;h1&gt;Hello world&lt;/h1&gt;<br/><br/>&lt;!-- This is the script that we would be creating later --&gt;<br/>&lt;script src="./js/scripts.js"&gt;&lt;/script&gt;</span></pre><p id="19bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并保存<code class="fe ml mm mn mc b">index.ejs</code>文件。现在，由于模板已经准备好了，我们需要一个路径来呈现这个页面。所以让我们来创造它</p><p id="4503" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在您的<code class="fe ml mm mn mc b">app.ts</code>文件中添加</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e5d5" class="mg kv in mc b gy mh mi l mj mk">import { Request, Response } from "express";<br/><br/>/* Home route */<br/>app.get("/", (req: Request, res: Response) =&gt; {<br/>	res.render("index")<br/>});</span></pre><p id="40d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在运行服务器并转到<code class="fe ml mm mn mc b">http//:localhost:3000</code>。你应该看看</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/bf6b6af88399817657ce5a6d51a32b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tHS5lzjytTnPWt1C.png"/></div></figure><p id="4595" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经完成了<code class="fe ml mm mn mc b">ejs</code>视图设置，是时候给<code class="fe ml mm mn mc b">ejs</code>模板添加一些脚本了。</p><h1 id="e098" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在express中提供静态内容</h1><p id="f4c6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在添加一些脚本之前，我们需要让express知道我们的静态内容在哪里，这样它就可以服务于它。将此添加到<code class="fe ml mm mn mc b">app.ts</code>文件中。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4bf1" class="mg kv in mc b gy mh mi l mj mk">const publicDirectoryPath = path.join(__dirname, "./public");<br/>app.use(express.static(publicDirectoryPath));</span></pre><p id="d2b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经建立了一个公共目录，让我们继续在EJS中使用TypeScript。</p><p id="ffa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在<code class="fe ml mm mn mc b">public/ts</code>目录下创建3个文件，命名为<code class="fe ml mm mn mc b">scripts.ts</code>、<code class="fe ml mm mn mc b">student.ts</code>、<code class="fe ml mm mn mc b">professor.ts</code></p><p id="22f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mc b">professor.ts</code></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="228a" class="mg kv in mc b gy mh mi l mj mk">export default class Professor {<br/>    name: string;<br/>    constructor(name: string){<br/>        this.name = name<br/>    }<br/>}</span></pre><p id="3e9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mc b">student.ts</code></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8827" class="mg kv in mc b gy mh mi l mj mk">import Professor from "./professor";<br/><br/>export default class Student {<br/>  name: string;<br/>  favProfessor: Professor;<br/>  constructor(name: string, professor: Professor) {<br/>    this.name = name;<br/>    this.favProfessor = professor;<br/>  }<br/><br/>  getFavProfessor = () =&gt; {<br/>     return this.favProfessor<br/>  }<br/><br/>}</span></pre><p id="a945" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mc b">script.ts</code></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bf6c" class="mg kv in mc b gy mh mi l mj mk">import Professor from "./professor";<br/>import Student from "./student";<br/><br/><br/>const professor: Professor = new Professor("James Mathew")<br/><br/>const student: Student = new Student("Rohit Lakhotia", professor)<br/><br/>console.log(student.getFavProfessor())</span></pre><p id="a6eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以在这里，文件<code class="fe ml mm mn mc b">professor.ts</code>包含了<code class="fe ml mm mn mc b">professor</code>类，而<code class="fe ml mm mn mc b">student.ts</code>文件包含了<code class="fe ml mm mn mc b">student</code>类，其中的方法<code class="fe ml mm mn mc b">getFavProfessor</code>得到了学生最喜欢的教授。</p><p id="e9da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而<code class="fe ml mm mn mc b">scripts.ts</code>文件导入这两个文件，并输出学生最喜欢的教授基本上试图导入和导出真实项目中会发生的类/函数。</p><p id="ec87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，由于<code class="fe ml mm mn mc b">script.ts</code>文件是起点，我们需要将它导入之前创建的EJS模板中。</p><blockquote class="mp mq mr"><p id="2b91" class="jv jw ms jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">浏览器看不懂TypeScript。</em></strong><em class="in">S</em><strong class="jx io"><em class="in">o我们需要将打字稿转换成JavaScript，以便浏览器能够理解。</em>T25】</strong></p></blockquote><p id="4fe5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用以下命令运行服务器</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="06bc" class="mg kv in mc b gy mh mi l mj mk">npm run dev</span></pre><p id="016d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果您看到<code class="fe ml mm mn mc b">dist/ts</code>目录，并检查<code class="fe ml mm mn mc b">scripts.js</code>文件，您可以看到转换后的JavaScript文件。现在让我们试着运行它。</p><p id="0957" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但在此之前，我们需要做一些改变。在<code class="fe ml mm mn mc b">index.ejs</code>中，只需改变<code class="fe ml mm mn mc b">scripts.js</code>位置，从<code class="fe ml mm mn mc b">ts</code>目录中取出脚本。所以它会像这样。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a047" class="mg kv in mc b gy mh mi l mj mk">&lt;script src="./ts/scripts.js"&gt;&lt;/script&gt;</span></pre><p id="71f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在使用以下命令运行服务器</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9422" class="mg kv in mc b gy mh mi l mj mk">npm run dev</span></pre><p id="dcb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">服务器应该立即启动，然后转到<code class="fe ml mm mn mc b">http://localhost:3000</code>并在浏览器中打开控制台，如果您看到<strong class="jx io">导出未定义</strong>。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/625aeac2b6c3397b647ce99aea981dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ifOJ4gTUIXpUMw4u.png"/></div></div></figure><p id="bf10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只需在<code class="fe ml mm mn mc b">index.ejs</code>中的脚本标签前添加此内容</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b0ec" class="mg kv in mc b gy mh mi l mj mk">&lt;script&gt;var exports = {}&lt;/script&gt;</span></pre><p id="2ce4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在试着运行它。它将显示一个新的错误，即“要求未定义”。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/93ef9f102a396d630ce0650e39360226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pGmr9yyUpyonzAln.png"/></div></div></figure><p id="8730" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为如果你看到<strong class="jx io">trans file JavaScript文件，你会看到</strong> <code class="fe ml mm mn mc b"><strong class="jx io">require</strong></code> <strong class="jx io">函数在那里，而浏览器不能理解那个</strong></p><p id="e016" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为当<strong class="jx io">传输代码时，它是根据可以处理所需功能的节点来传输的。</strong></p><p id="5136" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那现在怎么办？</p><p id="1dd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在这个<a class="ae kt" href="https://github.com/RohitLakh/node-ejs-with-typescript-starter-project" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe ml mm mn mc b">master</code>分支中找到到目前为止的源代码</p><h1 id="f78e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">拯救网络包</h1><p id="2933" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">因此，webpack是一个JavaScript捆绑器，基本上，它将您的资产转换为单个/多个捆绑包，因此您可以将捆绑包发送给最终用户，基本上减少了HTTP调用的数量。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/7ad30b466e5626c710ae581e494e75bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwJXjNoRXpvOdyyd0dMXwA.png"/></div></div></figure><p id="f743" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有两种方法来实现这一点</p><ol class=""><li id="0bba" class="mz na in jx b jy jz kc kd kg nb kk nc ko nd ks ne nf ng nh bi translated"><strong class="jx io">将生成的JavaScript捆绑成一个包</strong></li><li id="1588" class="mz na in jx b jy ni kc nj kg nk kk nl ko nm ks ne nf ng nh bi translated"><strong class="jx io">将打字稿直接捆绑成一捆</strong></li></ol><p id="24d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两个过程会给出相同的输出，但是它们在构建时间上有所不同。</p><p id="5226" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但在此之前，我们需要安装<code class="fe ml mm mn mc b">webpack</code>和<code class="fe ml mm mn mc b">webpack-cli</code></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1a9f" class="mg kv in mc b gy mh mi l mj mk">npm i -D webpack webpack-cli</span></pre><p id="e7e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这之后在根目录下创建一个新的<code class="fe ml mm mn mc b">webpack.config.js</code>文件</p><h1 id="1517" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">将生成的JavaScript捆绑成一个包</h1><p id="d709" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">因此，这里我们将从<code class="fe ml mm mn mc b">dist/public/ts</code>文件夹中已经创建的文件生成包。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/01fcbd5061bb15b3e88d775c2f572a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7BGIWivaVKXlFgimRME5Q.png"/></div></div></figure><p id="bc26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ml mm mn mc b">webpack.config.js</code>文件中添加这段代码</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="93c9" class="mg kv in mc b gy mh mi l mj mk">// The base directory that we want to use<br/>const baseDirectory = "dist";<br/><br/>module.exports = {<br/>  // The current mode, defaults to production<br/>  mode: "development",<br/><br/>  // The entry points ("location to store": "location to find")<br/>  entry: {<br/>    "public/js/scripts": [`./${baseDirectory}/public/ts/scripts`],<br/>    // "other output points" : ["other entry point"] <br/>  },<br/><br/>  // Used for generating source maps (used for debugging)<br/>  devtool: "eval-source-map",<br/><br/>  // The location where bundle are stored<br/>  output: {<br/>    filename: "[name].js",<br/>  },<br/>};</span></pre><p id="aa11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">保存文件，现在我们需要运行webpack命令来将JavaScript捆绑成一个包，但是这应该是自动的。</p><p id="a2d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在在<code class="fe ml mm mn mc b">package.json</code>文件中，添加一个新的脚本</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="154a" class="mg kv in mc b gy mh mi l mj mk">"webpack": "webpack"</span></pre><p id="99d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要在运行完gulp脚本之后运行它，所以在gulp命令之后，我们需要添加webpack。因此，最终的脚本对象看起来像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b35e" class="mg kv in mc b gy mh mi l mj mk">{<br/>    "start:gulp": "npm-run-all gulp webpack start",<br/>    "webpack": "webpack",<br/>    "gulp": "gulp",<br/>    "start": "node ./dist/app.js",<br/>    "dev": "nodemon --watch src -e ts,ejs --exec npm run start:gulp"<br/>}</span></pre><p id="f03a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在运行<code class="fe ml mm mn mc b">npm run dev</code>之前，只需转到<code class="fe ml mm mn mc b">src/views</code>目录中的<code class="fe ml mm mn mc b">index.ejs</code>，并使<code class="fe ml mm mn mc b">scripts</code>从js目录加载。</p><p id="7545" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后跑</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="90d7" class="mg kv in mc b gy mh mi l mj mk">npm run dev</span></pre><p id="da58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在服务器成功运行后，转到<code class="fe ml mm mn mc b">http://localhost:3000</code>并检查控制台，您应该会看到<code class="fe ml mm mn mc b">Professor</code>对象被控制。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/4f7f6963edb631f43b4e3104ca851254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rrFpBlYN3tFsk-TW.png"/></div></div></figure><p id="eea4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">恭喜它现在开始工作了。基本上，您可以在使用webpack的浏览器中使用TypeScript。</p><h2 id="6f95" class="mg kv in bd kw no np dn la nq nr dp le kg ns nt li kk nu nv lm ko nw nx lq ny bi translated">优势:</h2><ul class=""><li id="8c3a" class="mz na in jx b jy ls kc lt kg nz kk oa ko ob ks oc nf ng nh bi translated">与使用webpack将前端类型脚本直接转换为JavaScript相比，构建时间更短</li></ul><h2 id="ce1b" class="mg kv in bd kw no np dn la nq nr dp le kg ns nt li kk nu nv lm ko nw nx lq ny bi translated">缺点:</h2><ul class=""><li id="77e6" class="mz na in jx b jy ls kc lt kg nz kk oa ko ob ks oc nf ng nh bi translated">当您需要在浏览器控制台中调试某些东西时(因为我们生成了源映射)，您会被定向到JavaScript(带有<code class="fe ml mm mn mc b">require</code>函数的那个)，它已经从TypeScript转换过来，有时是不可读的，但它工作得很好。</li></ul><p id="1918" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在<a class="ae kt" href="https://github.com/RohitLakh/node-ejs-with-typescript-starter-project" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe ml mm mn mc b">webpack-setup-through-javascript</code>分支上找到源代码。</p><h1 id="d76d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">将类型脚本直接捆绑成一个包</h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a69902555b234e55ec648097ba4bd9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKZYH1V4LNV_zTP7NTrdtQ.png"/></div></div></figure><p id="821e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以在这里，我们将使用webpack模块直接将类型脚本转换成JavaScript，而不是捆绑通过gulp命令生成的JavaScript。</p><p id="3051" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，我们需要安装<code class="fe ml mm mn mc b">ts-loader</code>，它是webpack的一个类型脚本加载器。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2904" class="mg kv in mc b gy mh mi l mj mk">npm i -D ts-loader</span></pre><p id="983f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在在<code class="fe ml mm mn mc b">webpack.config.js</code>文件中添加他的代码</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="02c2" class="mg kv in mc b gy mh mi l mj mk">// The base directory that we want to use<br/>const baseDirectory = "src";<br/><br/>module.exports = {<br/>  // The current mode, defaults to production<br/>  mode: "development",<br/><br/>  // The entry points ("location to store": "location to find")<br/>  entry: {<br/>    "public/js/scripts": [`./${baseDirectory}/public/ts/scripts`],<br/>     // "other output points" : ["other entry point"] <br/>  },<br/>  // Using the ts-loader module<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.tsx?$/,<br/>        use: "ts-loader",<br/>        exclude: /node_modules/,<br/>      },<br/>    ],<br/>  },<br/>  resolve: {<br/>    extensions: [".tsx", ".ts", ".js"],<br/>  },<br/>  // Used for generating source maps (used for debugging)<br/>  devtool: "eval-source-map",<br/><br/>  // The location where bundle are stored<br/>  output: {<br/>    filename: "[name].js",<br/>  },<br/>};</span></pre><p id="63ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此处需要注意的事项:</p><ol class=""><li id="dbc3" class="mz na in jx b jy jz kc kd kg nb kk nc ko nd ks ne nf ng nh bi translated">现在的<code class="fe ml mm mn mc b">baseDirectory</code>是<code class="fe ml mm mn mc b">src</code></li><li id="6979" class="mz na in jx b jy ni kc nj kg nk kk nl ko nm ks ne nf ng nh bi translated">添加了一个模块和解析对象。</li></ol><p id="6118" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在如果我们运行它，它会工作，但是现在<code class="fe ml mm mn mc b">public/ts</code>目录被传输了两次，一次是用gulp任务“typescript ”,另一次是用webpack。</p><p id="91a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，为了改变这种情况，让我们转到gulpfile.js，在这里的TypeScript任务中，我们需要排除<code class="fe ml mm mn mc b">public/ts</code>目录，因为这将由webpack完成。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c606" class="mg kv in mc b gy mh mi l mj mk">tsProject.config['exclude'] = ["./src/public/ts/**/*"]</span></pre><p id="a2be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，TypeScript任务将如下所示。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4eea" class="mg kv in mc b gy mh mi l mj mk">gulp.task("typescript", function () {<br/>    tsProject.config['exclude'] = ["./src/public/ts/**/*"]<br/>    return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest("dist"));<br/>});</span></pre><p id="30da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果你通过<code class="fe ml mm mn mc b">npm run dev</code>运行服务器，你可以访问浏览器控制台并看到<code class="fe ml mm mn mc b">Professor</code>对象</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/067bcdd5f423481b38eef063ab78cf0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sOpjdAdTaFFurj5S.png"/></div></div></figure><p id="6c42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">恭喜你，你刚刚在前端使用了TypeScript。</p><h2 id="1105" class="mg kv in bd kw no np dn la nq nr dp le kg ns nt li kk nu nv lm ko nw nx lq ny bi translated">优势:</h2><ul class=""><li id="8d12" class="mz na in jx b jy ls kc lt kg nz kk oa ko ob ks oc nf ng nh bi translated">在浏览器控制台中调试代码时，您会被定向到TypeScript文件(考虑到您已经在tsconfig.json文件中启用了<code class="fe ml mm mn mc b">sourceMap: true</code>),而不是transpiled JavaScript文件。这样，您就可以确切地知道导致问题的行。</li></ul><h2 id="d6a0" class="mg kv in bd kw no np dn la nq nr dp le kg ns nt li kk nu nv lm ko nw nx lq ny bi translated">缺点:</h2><ul class=""><li id="b9f6" class="mz na in jx b jy ls kc lt kg nz kk oa ko ob ks oc nf ng nh bi translated">与前一种方法相比，构建时间稍长。</li></ul><p id="3a08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在<a class="ae kt" href="https://github.com/RohitLakh/node-ejs-with-typescript-starter-project" rel="noopener ugc nofollow" target="_blank">库</a>的分支<code class="fe ml mm mn mc b">webpack-setup-through-typescript</code>上找到源代码。</p><p id="8b61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你能做的就是当你找到需要的情况时，在两者之间转换。</p><p id="c4b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要任何帮助，请在下面的评论区告诉我</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><p id="a84b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ms">最初发表于</em><a class="ae kt" href="https://rohitlakhotia.com/blog/nodejs-ejs-typescript-using-gulp-webpack/" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://rohitlakhotia.com</em></a></p></div></div>    
</body>
</html>