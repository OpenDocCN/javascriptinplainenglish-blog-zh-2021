<html>
<head>
<title>Analysis of Hash Tables in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中哈希表的分析</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/analysis-of-hash-tables-in-javascript-a00138f8ade3?source=collection_archive---------11-----------------------#2021-07-13">https://javascript.plainenglish.io/analysis-of-hash-tables-in-javascript-a00138f8ade3?source=collection_archive---------11-----------------------#2021-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a9e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们正在进行的涉及一些核心数据结构的系列中，我们将讨论散列表，也就是通常所说的散列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/682cefe3fbb9bf04aa3d3d69c3981297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HEsSyHNsXgfICRTGrtkqaw.png"/></div></div></figure><h1 id="224e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是哈希表？</h1><p id="b4e7" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">哈希表用于存储键值对。哈希表可以被认为是这些“kvp”的集合</p><p id="ef03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当在JavaScript中实现时，我们将在实现类时使用数组。但是在一般的问题解决/编码挑战中，我建议你使用一个通用对象或者JavaScript中的预建Map对象。其他流行的语言如Java和Python也分别有预构建的散列表、hashmap和dictionary。</p><p id="4fc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么要使用哈希表？只要我们知道要寻找的特定键，它们可以快速地查找、添加和删除值。在本系列以前的迭代中，我们会将BigO符号的讨论留到最后，但是理解哈希表的优势是一个非常重要的概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/9230f0bc4438adbe5bc7958adf8e7d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NuvzZwNggiA-xlZBr7gCQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Searching through an array vs searching through a hash table</figcaption></figure><p id="2e21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我创建了上面的<a class="ae mc" href="https://github.com/maquino96/Colt-Steele-DSA-Udemy/blob/main/Code-Editor-Problems/hashExample.js" rel="noopener ugc nofollow" target="_blank">代码</a>来展示搜索数组和搜索散列表的区别。我建立了一个包含相同信息的数组和散列表。我设置了一个“searchArray”函数来遍历数组，该函数将返回我们正在搜索的颜色的十六进制键，如果没有找到，则返回一条错误消息。比较以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/2d0b58d7053fb689e35083aaa6ec8739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*omqdj0hgnXvYNqrs4iK9cA.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Results of searching through an array</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/d7892d5b58312b5e37cc1343ea33913f.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*F9N1DyOuG6czbxhTMUtR8A.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Results of searching a hash table</figcaption></figure><p id="8821" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我特意搜索了一种颜色，我知道这种颜色在列表中的索引位置更靠下，以展示在进行搜索时，一个数组有一个O(n ),而一个散列表有一个O(1)。只要我们知道要搜索的关键字，我们就可以在O(1)时间内找到相关的值。当我们处理庞大的数据集，并且需要确认数据是否存在于哈希表中时，这是非常重要的。想象一下，如果我们有一百万个条目，并且每次我们想要确认我们的数据点之一的存在时，我们必须遍历整个数组，这将是非常低效的。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="b449" class="ku kv in bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr bi translated">哈希表是如何工作的？</h1><ol class=""><li id="72d8" class="mr ms in jm b jn ls jr lt jv mt jz mu kd mv kh mw mx my mz bi translated">一个键被传递到一个哈希函数中</li><li id="5ca0" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">哈希函数将密钥转换为索引</li><li id="7081" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">与该键关联的值存储在该索引中。</li></ol><p id="ad7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这看起来很简单，但是当我们深入研究时，你可能会有这样的问题，什么是散列函数？如果在以前使用的索引中已经存储了一个键-值对，会发生什么？</p><p id="00d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">散列函数是任何可以用来映射数据的函数，它可以简单或复杂。</p><ul class=""><li id="42fb" class="mr ms in jm b jn jo jr js jv nf jz ng kd nh kh ni mx my mz bi translated">一个好的散列函数速度很快，因此要远离嵌套循环，甚至是耗时O(n)的操作</li><li id="dcb5" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">均匀分布输出(防止特定索引处的键聚集)。</li><li id="f7f2" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">确定性，意味着相同的输入每次都会产生相同的输出。</li></ul><p id="cd34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于聚类，哈希函数倾向于使用质数来设置可用索引的数量。“数学的本质”是质数阻止聚类，在谷歌上快速搜索会发现无数的答案，这些答案超出了我的文章范围，但深入探究却很有趣。</p><p id="3e5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当处理冲突时，例如在散列函数导致重复索引的情况下，有两种通用方法，分别链接和线性探测。</p><p id="f3bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单独链接:</p><ul class=""><li id="1371" class="mr ms in jm b jn jo jr js jv nf jz ng kd nh kh ni mx my mz bi translated">在数组中的每个索引处，我们可以使用更复杂的数据结构(如数组或链表)来存储值，并遍历数组/链表来找到我们的键。</li><li id="123a" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">增加的复杂性允许在同一位置有多个键值对</li></ul><p id="17b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">线性探测:</p><ul class=""><li id="342c" class="mr ms in jm b jn jo jr js jv nf jz ng kd nh kh ni mx my mz bi translated">当我们发现一个冲突时，我们在数组中搜索下一个空位</li><li id="75b9" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">受限于分配的空间，可能需要大的索引才可行。</li></ul><p id="55bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，在JavaScript实现中，我们将使用第一种方法，单独链接。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="ba8d" class="ku kv in bd kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr bi translated">哈希表摘要</h1><ul class=""><li id="0295" class="mr ms in jm b jn ls jr lt jv mt jz mu kd mv kh ni mx my mz bi translated">是键值对的集合</li><li id="5049" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">给定一个键，可以快速找到值</li><li id="6b13" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">可以快速添加新的键值对</li><li id="8283" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">将数据存储在一个大数组中，并通过散列密钥来工作</li><li id="e653" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">一个好散列应该是快速的、均匀分布的密钥，且是确定性的</li><li id="b1cd" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">分离链接和线性探测是用于处理冲突的两种策略</li></ul><p id="4c6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">BigO(最佳和一般情况):</p><ul class=""><li id="be5b" class="mr ms in jm b jn jo jr js jv nf jz ng kd nh kh ni mx my mz bi translated">插入:O(1)</li><li id="bad1" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">删除:O(1)</li><li id="dd38" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ni mx my mz bi translated">Access: O(1) —使用给定的键，访问成对的值</li></ul><p id="28f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最坏情况O(n)。主要取决于所使用的散列函数，并且理想地最小化冲突。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="ae5b" class="nj kv in bd kw nk nl dn la nm nn dp le jv no np li jz nq nr lm kd ns nt lq nu bi translated">额外资源:</h2><p id="9685" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">JavaScript中哈希表类的实现，请<a class="ae mc" href="https://github.com/maquino96/Colt-Steele-DSA-Udemy/blob/main/Course/Data%20Structures/hashTable.js" rel="noopener ugc nofollow" target="_blank">点击这里</a>。再一次，柯尔特·斯蒂尔把这些材料简化成易于理解的大块，这要归功于他。他的课程可以在<a class="ae mc" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。如需更深入的了解和该主题的一些视觉效果，请访问<a class="ae mc" href="https://visualgo.net/en/hashtable?slide=1" rel="noopener ugc nofollow" target="_blank"> Visualgo </a>。</p><p id="42fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nv">多内容于</em> <a class="ae mc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="nv">浅显易懂</em> </strong> </a></p></div></div>    
</body>
</html>