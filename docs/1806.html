<html>
<head>
<title>Content-Aware Image Resizing in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中内容感知的图像大小调整</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/content-aware-image-resizing-in-javascript-89144c1b5a5c?source=collection_archive---------10-----------------------#2021-04-16">https://javascript.plainenglish.io/content-aware-image-resizing-in-javascript-89144c1b5a5c?source=collection_archive---------10-----------------------#2021-04-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4ba75c8d0cd422efd098abb28bd8f1ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUhj1LDxtR8OIhFYnpc6pQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Background image by <a class="ae jz" href="https://unsplash.com/@sadswim?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ian Dooley</a></figcaption></figure><p id="826c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，通过这篇文章，我想做三件事:</p><ol class=""><li id="1ef6" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">为你提供一个交互式的<strong class="kc io">内容感知的大小调整器</strong>，这样你就可以调整你自己的图片大小</li><li id="6620" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">解释<strong class="kc io">缝雕算法</strong>背后的想法</li><li id="0a0a" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">解释实现算法的<strong class="kc io">动态编程方法</strong>(我们将使用TypeScript)</li></ol><h1 id="95e2" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">内容感知的图像大小调整</h1><p id="eca6" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated"><em class="mp">内容感知型图像尺寸调整</em>可能适用于改变图像比例(即在保持高度的同时减小宽度)以及不希望丢失图像的某些部分的情况。在这种情况下，进行简单的图像缩放会扭曲其中的对象。为了在改变图像比例时保持对象的比例，我们可以使用由<em class="mp"> Shai Avidan </em>和<em class="mp"> Ariel Shamir </em>引入的<a class="ae jz" href="https://perso.crans.org/frenoy/matlab2012/seamcarving.pdf" rel="noopener ugc nofollow" target="_blank">接缝雕刻算法</a>。</p><p id="c27a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的例子显示了如何使用<em class="mp">内容感知调整</em>(左图)和<em class="mp">直接缩放</em>(右图)将原始图像宽度减少50%。在这种特殊情况下，左边的图像看起来更自然，因为气球的比例得到了保留。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/8befb825ac92fd456b2e609cc3f6dd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nrFRp6S5PWP-ukx2.png"/></div></div></figure><p id="f0b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">线缝雕刻算法的思路是找到对图像内容贡献最低的<em class="mp">线缝</em>(连续的像素序列)然后<em class="mp">雕刻</em>(去除)。这个过程反复重复，直到我们得到所需的图像宽度或高度。在下面的示例中，您可能会看到热气球像素比天空像素对图像内容的贡献更大。因此，天空像素首先被移除。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2b133366ca7cb5f6d2b982e2c3f8f05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*xJtgSV2MHaa0s771.gif"/></div></figure><p id="b907" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">寻找能量最低的接缝是一项计算量很大的任务(尤其是对于大图像)。为了使seam搜索更快，可以应用<em class="mp">动态编程</em>方法(我们将在下面详细介绍实现细节)。</p><h1 id="97dc" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">对象移除</h1><p id="3b5b" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">每个像素的重要性(所谓的像素能量)是基于两个相邻像素之间的颜色(<code class="fe mw mx my mz b">R</code>、<code class="fe mw mx my mz b">G</code>、<code class="fe mw mx my mz b">B</code>、<code class="fe mw mx my mz b">A</code>)差异来计算的。现在，如果我们人为地将像素能量设置为非常低的水平(例如，通过在它们上面画一个遮罩)，线缝雕刻算法将免费为我们执行一个<strong class="kc io">对象移除</strong>。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/078a2170ee5f56aaa9b45fc119b28550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*N0GFmsyV7ttB87xY.gif"/></div></figure><h1 id="eb9d" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">JS图像雕刻器演示</h1><p id="d2bb" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我已经创建了<a class="ae jz" href="https://trekhleb.dev/js-image-carver/" rel="noopener ugc nofollow" target="_blank"> JS IMAGE CARVER </a> web应用程序(也是<a class="ae jz" href="https://github.com/trekhleb/js-image-carver" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上开源的)，你可以用它来调整你的自定义图像的大小。</p><h1 id="5845" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">更多示例</h1><p id="b5d9" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">以下是该算法如何处理更复杂背景的更多示例。</p><p id="092e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">背景上的山脉被平滑地缩小，没有可见的接缝。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/fd04f3f75a938cc0e3158622a37b02fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kEc1DYHNcvn4wn45.png"/></div></div></figure><p id="b8cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">海浪也是如此。该算法保留了波浪结构，而不会扭曲冲浪者。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/dc59636ef8723a1a6b30bde1f5875dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CcTPxAS2l6Ec4ZBK.png"/></div></div></figure><p id="093f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要记住，Seam Carving算法不是一个银弹，它可能无法调整大多数像素是边缘的图像的大小(看起来对算法很重要)。在这种情况下，它甚至开始扭曲图像的重要部分。在下面的例子中，内容感知的图像大小调整看起来非常类似于简单的缩放，因为对于该算法来说，所有像素看起来都很重要，并且它很难区分梵高的脸和背景。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/4c8fbf38407b2598532f7067fb9fa291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cfKOE0g6FyFSHVqM.png"/></div></div></figure><h1 id="a188" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">接缝雕刻算法是如何工作的</h1><p id="d177" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">假设我们有一张<code class="fe mw mx my mz b">1000 x 500 px</code>图片，我们想将它的大小更改为<code class="fe mw mx my mz b">500 x 500 px</code>以使其呈方形(假设方形比例更适合Instagram提要)。在这种情况下，我们可能希望为调整大小过程设置几个<strong class="kc io">要求:</strong></p><ul class=""><li id="9473" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx na le lf lg bi translated"><em class="mp">保留图像的重要部分</em>(即，如果在调整大小之前有5棵树，我们希望在调整大小之后也有5棵树)。</li><li id="02d6" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx na le lf lg bi translated"><em class="mp">保留图像重要部分的比例</em>(即圆形车轮不应挤压到椭圆形车轮)</li></ul><p id="7e0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了避免改变图像的重要部分，我们可以找到<strong class="kc io">连续的像素序列(接缝)</strong>，其从上到下并且对图像的内容具有最低的贡献<em class="mp">(避免重要部分)，然后移除它。接缝移除会将图像缩小1个像素。然后，我们将重复这一步，直到图像将获得所需的宽度。</em></p><p id="dffc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题是如何定义<em class="mp">像素</em>的重要性及其对内容的贡献(在最初的论文中作者使用了术语<strong class="kc io">像素</strong>的能量)。其中一种方法是将所有形成边缘的像素都视为重要像素。如果像素是边缘的一部分，则其颜色在相邻像素(左像素和右像素)之间的差异将大于不属于边缘的像素。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/bc29ebcc46e20f35c357d2f0309e8391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y9T2igQqVNTfI2zI.png"/></div></div></figure><p id="0106" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设一个像素的颜色由<em class="mp"> 4个</em>数字(<code class="fe mw mx my mz b">R</code> -红色、<code class="fe mw mx my mz b">G</code> -绿色、<code class="fe mw mx my mz b">B</code> -蓝色、<code class="fe mw mx my mz b">A</code>-α)表示，我们可以使用下面的公式来计算色差(像素能量):</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/bfd3aa3d0d9afe65dd13712180bf1576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B7yNm530QvUR-Hah.png"/></div></div></figure><p id="97ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其中:</p><ul class=""><li id="ca0e" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx na le lf lg bi translated"><code class="fe mw mx my mz b">mEnergy</code> - <em class="mp">中间<em class="mp">像素的能量</em>(重要性)</em>(<code class="fe mw mx my mz b">[0..626]</code>如果四舍五入)</li><li id="ce05" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx na le lf lg bi translated"><code class="fe mw mx my mz b">lR</code> - <em class="mp">红色</em>通道值为<em class="mp">左侧</em>像素(<code class="fe mw mx my mz b">[0..255]</code>)</li><li id="07ee" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx na le lf lg bi translated"><code class="fe mw mx my mz b">mR</code> - <em class="mp">红色</em>通道值为<em class="mp">中间</em>像素(<code class="fe mw mx my mz b">[0..255]</code>)</li><li id="f844" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx na le lf lg bi translated"><code class="fe mw mx my mz b">rR</code> - <em class="mp">红色</em>通道值为<em class="mp">右侧</em>像素(<code class="fe mw mx my mz b">[0..255]</code>)</li><li id="b89d" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx na le lf lg bi translated"><code class="fe mw mx my mz b">lG</code> - <em class="mp">绿色</em>通道值为<em class="mp">左侧</em>像素(<code class="fe mw mx my mz b">[0..255]</code>)</li><li id="0f47" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx na le lf lg bi translated">诸如此类…</li></ul><p id="1b1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的公式中，我们忽略了alpha(透明)通道，现在，假设图像中没有透明像素。稍后，我们将使用alpha通道进行遮罩和物体移除。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/3b2a27ec7a8ede508b3921f2a4425051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7N2Q0Xx-WpxHoLWl.png"/></div></div></figure><p id="066e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，既然我们知道如何找到一个像素的能量，我们可以计算所谓的<strong class="kc io">能量图</strong>，它将包含图像的每个像素的能量。在每一个调整大小的步骤中，能量图应该被重新计算(至少部分地，下面会有更多关于它的内容),并且将具有与图像相同的大小。</p><p id="4ee8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在第一个调整大小的步骤中，我们将有一个<code class="fe mw mx my mz b">1000 x 500</code>图像和一个<code class="fe mw mx my mz b">1000 x 500</code>能量图。在第二个调整大小的步骤中，我们将从图像中移除接缝，并基于新的收缩图像重新计算能量图。因此，我们将得到一个<code class="fe mw mx my mz b">999 x 500</code>图像和一个<code class="fe mw mx my mz b">999 x 500</code>能量图。</p><p id="08bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像素的能量越高，它就越有可能是边缘的一部分，这对图像内容很重要，我们就越不需要去除它。</p><p id="a2d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了可视化能量图，我们可以将较亮的颜色分配给具有较高能量的像素，将较暗的颜色分配给具有较低能量的像素。这是一个模拟的例子，展示了能量图中随机部分的样子。你可以看到代表边缘的亮线，我们希望在调整尺寸时保留它。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/3c100772990ccc1a19d49ecd3fdfec8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YAAUBDiQh_GXYXEw.png"/></div></div></figure><p id="f63b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是你在上面看到的演示图像的能量图的真实例子(用热气球)。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/caef2fde7cb8201054568134dda3fd8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IOIBCvg_b2QZyF3J.png"/></div></div></figure><p id="84b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以玩你的自定义图像，看看能量图在帖子的<a class="ae jz" href="https://trekhleb.dev/blog/2021/content-aware-image-resizing-in-javascript/" rel="noopener ugc nofollow" target="_blank">互动版本中会是什么样子。</a></p><p id="0db9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用能量图来寻找具有最低能量的接缝(一个接一个),并通过这样做来决定最终应该删除哪些像素。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/b8f027313d8457b86c14867bc39c6251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eKOfmKRGT3gdSSFQ.png"/></div></div></figure><p id="c8e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">找到具有最低能量的接缝不是一项简单的任务，需要在做出决定之前探索许多可能的像素组合。我们将应用动态规划方法来加速它。</p><p id="5410" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的例子中，你可以看到能量图中第一个能量最低的接缝。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/4c3898022d30245a567c0590a75b065b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CyTH1qeuXju-HXu1.png"/></div></div></figure><p id="db21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们减小了图像的宽度。可以采用类似的方法来降低图像高度。不过，我们需要“轮换”这种方法:</p><ul class=""><li id="992b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx na le lf lg bi translated">开始使用<em class="mp">顶部</em>和<em class="mp">底部</em>的像素邻居(而不是<em class="mp">左侧</em>和<em class="mp">右侧</em>的)来计算像素能量</li><li id="3a69" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx na le lf lg bi translated">当搜索一个矿层时，我们需要从左边的<em class="mp">移动到右边的<em class="mp">而不是从上面的<em class="mp">移动到底部的</em></em></em></li></ul><h1 id="c6cb" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">在TypeScript中实现</h1><blockquote class="nb nc nd"><p id="965d" class="ka kb mp kc b kd ke kf kg kh ki kj kk ne km kn ko nf kq kr ks ng ku kv kw kx ig bi translated"><em class="in">你可以在</em><a class="ae jz" href="https://github.com/trekhleb/js-image-carver" rel="noopener ugc nofollow" target="_blank"><em class="in">js-image-carver</em></a><em class="in">库中找到源代码和下面提到的函数。</em></p></blockquote><p id="98f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了实现该算法，我们将使用TypeScript。如果你想要一个JavaScript版本，你可以忽略(移除)类型定义和它们的用法。</p><p id="f2bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出于简单的原因，让我们只为图像<em class="mp">宽度</em>的减少实现接缝雕刻算法。</p><h1 id="328c" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">内容感知宽度调整(入口函数)</h1><p id="56a0" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">首先，让我们定义一些我们将在实现算法时使用的常见类型。</p><pre class="mr ms mt mu gt nh mz ni nj aw nk bi"><span id="300b" class="nl ln in mz b gy nm nn l no np">// Type that describes the image size (width and height).<br/>type ImageSize = { w: number, h: number };</span><span id="010f" class="nl ln in mz b gy nq nn l no np">// The coordinate of the pixel.<br/>type Coordinate = { x: number, y: number };</span><span id="ba68" class="nl ln in mz b gy nq nn l no np">// The seam is a sequence of pixels (coordinates).<br/>type Seam = Coordinate[];</span><span id="75a3" class="nl ln in mz b gy nq nn l no np">// Energy map is a 2D array that has the same width and height<br/>// as the image the map is being calculated for.<br/>type EnergyMap = number[][];</span><span id="b263" class="nl ln in mz b gy nq nn l no np">// Type that describes the image pixel's RGBA color.<br/>type Color = [<br/>  r: number, // Red<br/>  g: number, // Green<br/>  b: number, // Blue<br/>  a: number, // Alpha (transparency)<br/>] | Uint8ClampedArray;</span></pre><p id="0a9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在高层次上，该算法包括以下步骤:</p><ol class=""><li id="72ee" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">计算当前版本图像的<strong class="kc io">能量图</strong>。</li><li id="6806" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">根据能量图找到能量最低的<strong class="kc io">接缝</strong>(这是我们要应用动态规划的地方)。</li><li id="630d" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="kc io">从图像中删除能量最低的焊缝</strong>。</li><li id="ffdd" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="kc io">重复</strong>直到图像宽度减小到所需值。</li></ol><pre class="mr ms mt mu gt nh mz ni nj aw nk bi"><span id="ce04" class="nl ln in mz b gy nm nn l no np">type ResizeImageWidthArgs = {<br/>  img: ImageData, // Image data we want to resize.<br/>  toWidth: number, // Final image width we want the image to shrink to.<br/>};</span><span id="542d" class="nl ln in mz b gy nq nn l no np">type ResizeImageWidthResult = {<br/>  img: ImageData, // Resized image data.<br/>  size: ImageSize, // Resized image size (w x h).<br/>};</span><span id="2448" class="nl ln in mz b gy nq nn l no np">// Performs the content-aware image width resizing using the seam carving method.<br/>export const resizeImageWidth = (<br/>  { img, toWidth }: ResizeImageWidthArgs,<br/>): ResizeImageWidthResult =&gt; {<br/>  // For performance reasons we want to avoid changing the img data array size.<br/>  // Instead we'll just keep the record of the resized image width and height separately.<br/>  const size: ImageSize = { w: img.width, h: img.height };</span><span id="b6ea" class="nl ln in mz b gy nq nn l no np">  // Calculating the number of pixels to remove.<br/>  const pxToRemove = img.width - toWidth;<br/>  if (pxToRemove &lt; 0) {<br/>    throw new Error('Upsizing is not supported for now');<br/>  }</span><span id="4e39" class="nl ln in mz b gy nq nn l no np">  let energyMap: EnergyMap | null = null;<br/>  let seam: Seam | null = null;</span><span id="af6d" class="nl ln in mz b gy nq nn l no np">  // Removing the lowest energy seams one by one.<br/>  for (let i = 0; i &lt; pxToRemove; i += 1) {<br/>    // 1. Calculate the energy map for the current version of the image.<br/>    energyMap = calculateEnergyMap(img, size);</span><span id="ecb7" class="nl ln in mz b gy nq nn l no np">    // 2. Find the seam with the lowest energy based on the energy map.<br/>    seam = findLowEnergySeam(energyMap, size);</span><span id="644f" class="nl ln in mz b gy nq nn l no np">    // 3. Delete the seam with the lowest energy seam from the image.<br/>    deleteSeam(img, seam, size);</span><span id="95c8" class="nl ln in mz b gy nq nn l no np">    // Reduce the image width, and continue iterations.<br/>    size.w -= 1;<br/>  }</span><span id="0395" class="nl ln in mz b gy nq nn l no np">  // Returning the resized image and its final size.<br/>  // The img is actually a reference to the ImageData, so technically<br/>  // the caller of the function already has this pointer. But let's<br/>  // still return it for better code readability.<br/>  return { img, size };<br/>};</span></pre><p id="6da1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要调整大小的图像以<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData" rel="noopener ugc nofollow" target="_blank"> ImageData </a>格式传递给函数。您可以在画布上绘制图像，然后从画布中提取图像数据，如下所示:</p><pre class="mr ms mt mu gt nh mz ni nj aw nk bi"><span id="4b08" class="nl ln in mz b gy nm nn l no np">const ctx = canvas.getContext('2d');<br/>const imgData = ctx.getImageData(0, 0, imgWidth, imgHeight);</span></pre><blockquote class="nb nc nd"><p id="79f8" class="ka kb mp kc b kd ke kf kg kh ki kj kk ne km kn ko nf kq kr ks ng ku kv kw kx ig bi translated"><em class="in">用JavaScript上传和绘制图像的方法超出了本文的范围，但是您可以在</em><a class="ae jz" href="https://github.com/trekhleb/js-image-carver" rel="noopener ugc nofollow" target="_blank"><em class="in">js-image-carver</em></a><em class="in">repo中找到完整的源代码，了解如何使用React来上传和绘制图像。</em></p></blockquote><p id="b3a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们逐一分解每个步骤，实现<code class="fe mw mx my mz b">calculateEnergyMap()</code>、<code class="fe mw mx my mz b">findLowEnergySeam()</code>和<code class="fe mw mx my mz b">deleteSeam()</code>功能。</p><h1 id="6491" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">计算像素的能量</h1><p id="c0e5" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">这里我们应用上面描述的色差公式。对于左边界和右边界(当没有左邻居或右邻居时)，我们忽略邻居，并且在能量计算期间不考虑它们。</p><pre class="mr ms mt mu gt nh mz ni nj aw nk bi"><span id="4705" class="nl ln in mz b gy nm nn l no np">// Calculates the energy of a pixel.<br/>const getPixelEnergy = (left: Color | null, middle: Color, right: Color | null): number =&gt; {<br/>  // Middle pixel is the pixel we're calculating the energy for.<br/>  const [mR, mG, mB] = middle;</span><span id="f938" class="nl ln in mz b gy nq nn l no np">  // Energy from the left pixel (if it exists).<br/>  let lEnergy = 0;<br/>  if (left) {<br/>    const [lR, lG, lB] = left;<br/>    lEnergy = (lR - mR) ** 2 + (lG - mG) ** 2 + (lB - mB) ** 2;<br/>  }</span><span id="69e9" class="nl ln in mz b gy nq nn l no np">  // Energy from the right pixel (if it exists).<br/>  let rEnergy = 0;<br/>  if (right) {<br/>    const [rR, rG, rB] = right;<br/>    rEnergy = (rR - mR) ** 2 + (rG - mG) ** 2 + (rB - mB) ** 2;<br/>  }</span><span id="a3bc" class="nl ln in mz b gy nq nn l no np">  // Resulting pixel energy.<br/>  return Math.sqrt(lEnergy + rEnergy);<br/>};</span></pre><h1 id="9b83" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">计算能量图</h1><p id="d05d" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我们正在处理的图像具有<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData" rel="noopener ugc nofollow" target="_blank"> ImageData </a>格式。这意味着所有的像素(及其颜色)都存储在一个平面(<em class="mp">1D</em>)<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray" rel="noopener ugc nofollow" target="_blank">uint 8 clampedarray</a>数组中。出于可读性的目的，让我们引入两个帮助函数，它们将允许我们像使用<em class="mp"> 2D </em>矩阵一样使用Uint8ClampedArray数组。</p><pre class="mr ms mt mu gt nh mz ni nj aw nk bi"><span id="913b" class="nl ln in mz b gy nm nn l no np">// Helper function that returns the color of the pixel.<br/>const getPixel = (img: ImageData, { x, y }: Coordinate): Color =&gt; {<br/>  // The ImageData data array is a flat 1D array.<br/>  // Thus we need to convert x and y coordinates to the linear index.<br/>  const i = y * img.width + x;<br/>  const cellsPerColor = 4; // RGBA<br/>  // For better efficiency, instead of creating a new sub-array we return<br/>  // a pointer to the part of the ImageData array.<br/>  return img.data.subarray(i * cellsPerColor, i * cellsPerColor + cellsPerColor);<br/>};</span><span id="cd82" class="nl ln in mz b gy nq nn l no np">// Helper function that sets the color of the pixel.<br/>const setPixel = (img: ImageData, { x, y }: Coordinate, color: Color): void =&gt; {<br/>  // The ImageData data array is a flat 1D array.<br/>  // Thus we need to convert x and y coordinates to the linear index.<br/>  const i = y * img.width + x;<br/>  const cellsPerColor = 4; // RGBA<br/>  img.data.set(color, i * cellsPerColor);<br/>};</span></pre><p id="8fb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了计算能量图，我们遍历每个图像像素，并对其调用前面描述的<code class="fe mw mx my mz b">getPixelEnergy()</code>函数。</p><pre class="mr ms mt mu gt nh mz ni nj aw nk bi"><span id="faff" class="nl ln in mz b gy nm nn l no np">// Helper function that creates a matrix (2D array) of specific<br/>// size (w x h) and fills it with specified value.<br/>const matrix = &lt;T&gt;(w: number, h: number, filler: T): T[][] =&gt; {<br/>  return new Array(h)<br/>    .fill(null)<br/>    .map(() =&gt; {<br/>      return new Array(w).fill(filler);<br/>    });<br/>};</span><span id="3855" class="nl ln in mz b gy nq nn l no np">// Calculates the energy of each pixel of the image.<br/>const calculateEnergyMap = (img: ImageData, { w, h }: ImageSize): EnergyMap =&gt; {<br/>  // Create an empty energy map where each pixel has infinitely high energy.<br/>  // We will update the energy of each pixel.<br/>  const energyMap: number[][] = matrix&lt;number&gt;(w, h, Infinity);<br/>  for (let y = 0; y &lt; h; y += 1) {<br/>    for (let x = 0; x &lt; w; x += 1) {<br/>      // Left pixel might not exist if we're on the very left edge of the image.<br/>      const left = (x - 1) &gt;= 0 ? getPixel(img, { x: x - 1, y }) : null;<br/>      // The color of the middle pixel that we're calculating the energy for.<br/>      const middle = getPixel(img, { x, y });<br/>      // Right pixel might not exist if we're on the very right edge of the image.<br/>      const right = (x + 1) &lt; w ? getPixel(img, { x: x + 1, y }) : null;<br/>      energyMap[y][x] = getPixelEnergy(left, middle, right);<br/>    }<br/>  }<br/>  return energyMap;<br/>};</span></pre><blockquote class="nb nc nd"><p id="f4f5" class="ka kb mp kc b kd ke kf kg kh ki kj kk ne km kn ko nf kq kr ks ng ku kv kw kx ig bi translated"><em class="in">能量图将在每次尺寸调整迭代中重新计算。这意味着，如果我们需要将图像缩小500个像素(这不是最佳值),就要重新计算500次。为了在第二、第三以及更进一步的步骤中加速能量图的计算，我们可以仅对那些位于将要被去除的接缝周围的像素重新计算能量。为了简单起见，这里省略了这个优化，但是你可以在</em><a class="ae jz" href="https://github.com/trekhleb/js-image-carver" rel="noopener ugc nofollow" target="_blank"><em class="in">js-image-carver</em></a><em class="in">repo中找到示例源代码。</em></p></blockquote><h1 id="3227" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">寻找能量最低的矿层(动态规划方法)</h1><blockquote class="nb nc nd"><p id="cd89" class="ka kb mp kc b kd ke kf kg kh ki kj kk ne km kn ko nf kq kr ks ng ku kv kw kx ig bi translated"><em class="in">我之前在</em> <a class="ae jz" href="https://trekhleb.dev/blog/2018/dynamic-programming-vs-divide-and-conquer/" rel="noopener ugc nofollow" target="_blank"> <em class="in">动态编程vs分治</em> </a> <em class="in">文章中描述过一些动态编程的基础知识。有一个基于最小编辑距离问题的DP例子。你可能想检查一下，以获得更多的背景。</em></p></blockquote><p id="5400" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在需要解决的问题是在能量图上找到从上到下的路径(接缝),并且具有最小的像素能量和。</p><h2 id="bbe2" class="nl ln in bd lo nr ns dn ls nt nu dp lw kl nv nw ma kp nx ny me kt nz oa mi ob bi translated">天真的方法</h2><p id="499c" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">天真的方法是一个接一个地检查所有可能的路径。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/878e272d86f01d1c06f41cad6910997c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7lvim2VPmd2aoswf.png"/></div></div></figure><p id="2180" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上到下，对于每个像素，我们有3个选项(↙︎向左下走，向下走，↘︎向右下走)。这给了我们<code class="fe mw mx my mz b">O(w * 3^h)</code>或者简单的<code class="fe mw mx my mz b">O(3^h)</code>的时间复杂度，其中<code class="fe mw mx my mz b">w</code>和<code class="fe mw mx my mz b">h</code>是图像的宽度和高度。这种方法看起来很慢。</p><h2 id="4bbb" class="nl ln in bd lo nr ns dn ls nt nu dp lw kl nv nw ma kp nx ny me kt nz oa mi ob bi translated">贪婪的方法</h2><p id="ef50" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我们也可以尝试选择下一个像素作为能量最低的像素，希望得到的接缝能量是最小的。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/dea1f414481a3dac9014da80efc98f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HboCPDuHV91GLJQK.png"/></div></div></figure><p id="2432" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法给出的不是最坏的解决方案，但它不能保证我们会找到最佳的解决方案。在上面的图片中，你可以看到贪婪的方法最初是如何选择了<code class="fe mw mx my mz b">5</code>而不是<code class="fe mw mx my mz b">10</code>，并且错过了最佳像素链。</p><p id="3ee6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的优点是速度快，时间复杂度为<code class="fe mw mx my mz b">O(w + h)</code>，其中<code class="fe mw mx my mz b">w</code>和<code class="fe mw mx my mz b">h</code>是图像的宽度和高度。在这种情况下，速度的代价是调整大小的低质量。我们需要在第一行找到一个最小值(遍历<code class="fe mw mx my mz b">w</code>单元格)，然后我们只探索每行的3个相邻像素(遍历<code class="fe mw mx my mz b">h</code>行)。</p><h2 id="2cc6" class="nl ln in bd lo nr ns dn ls nt nu dp lw kl nv nw ma kp nx ny me kt nz oa mi ob bi translated">动态规划方法</h2><p id="70d8" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">你可能已经注意到，在简单的方法中，我们在计算结果接缝的能量时，一遍又一遍地累加相同的像素能量。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/52736d90a653dc5ebfa77d5a49e1fe5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k6-dTTN_IJQe2A6a.png"/></div></div></figure><p id="c9e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，你可以看到，对于前两个接缝，我们重复使用了较短接缝的能量(其能量为<code class="fe mw mx my mz b">235</code>)。我们不是只做一次运算<code class="fe mw mx my mz b">235 + 70</code>来计算第二条缝的能量，而是做四次运算<code class="fe mw mx my mz b">(5 + 0 + 80 + 150) + 70</code>。</p><blockquote class="nb nc nd"><p id="44e2" class="ka kb mp kc b kd ke kf kg kh ki kj kk ne km kn ko nf kq kr ks ng ku kv kw kx ig bi translated"><em class="in">我们正在重新使用前一个接缝的能量来计算当前接缝的能量，这一事实可以递归地应用于所有较短的接缝，直到最上面的第一行接缝。当我们有这种重叠的子问题时，</em> <a class="ae jz" href="https://trekhleb.dev/blog/2018/dynamic-programming-vs-divide-and-conquer/" rel="noopener ugc nofollow" target="_blank"> <em class="in">这是一个迹象</em> </a> <em class="in">一般问题</em>可能<em class="in">被动态规划方法优化。</em></p></blockquote><p id="41cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们可以<strong class="kc io">将特定像素处的当前接缝</strong>的能量保存在附加的<code class="fe mw mx my mz b">seamsEnergies</code>表中，以使其可重新用于更快地计算下一个接缝(该<code class="fe mw mx my mz b">seamsEnergies</code>表将具有与能量图和图像本身相同的大小)。</p><p id="fc80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还要记住，对于图像上的一个特定像素(即左下角的像素)，我们可能有几个先前接缝能量的<em class="mp">值。</em></p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/7e20dc2472f1ccc0928b2ca46e235856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VCsWwYWudR60APix.png"/></div></div></figure><p id="c61f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们正在寻找具有最低合成能量的接缝，所以选择具有最低合成能量的前一个接缝也是有意义的。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/8ee03a19b5c01030d677c2669f22bfb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jI3U5ksRMIpsPwOl.png"/></div></div></figure><p id="509c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一般来说，我们有三种可能的先前的似乎可供选择:</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/cddaf4b7d67b337febbb62f58b02e008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m0993CCi-pS0--r1.png"/></div></div></figure><p id="1327" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以这样想:</p><ul class=""><li id="3d5e" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx na le lf lg bi translated">单元<code class="fe mw mx my mz b">[1][x]</code>:包含从行<code class="fe mw mx my mz b">[0][?]</code>的某处开始到单元<code class="fe mw mx my mz b">[1][x]</code>结束的接缝的最低可能能量</li><li id="3b31" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx na le lf lg bi translated"><strong class="kc io">当前单元</strong> <code class="fe mw mx my mz b">[2][3]</code>:包含从行<code class="fe mw mx my mz b">[0][?]</code>的某处开始到单元<code class="fe mw mx my mz b">[2][3]</code>结束的接缝的最低可能能量。为了计算它，我们需要将当前像素<code class="fe mw mx my mz b">[2][3]</code>(来自能量图)的能量与<code class="fe mw mx my mz b">min(seam_energy_1_2, seam_energy_1_3, seam_energy_1_4)</code>相加</li></ul><p id="27e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们完全填满<code class="fe mw mx my mz b">seamsEnergies</code>表，那么最低行中的最小数字将是最低的可能焊缝能量。</p><p id="af3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们尝试填充这个表的几个单元格，看看它是如何工作的。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/a02fc405dcd0614791fec11c14c040ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vhkdzr08qUS1oAdY.png"/></div></div></figure><p id="8c13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">填写完<code class="fe mw mx my mz b">seamsEnergies</code>表格后，我们可以看到最低能量像素的能量为<code class="fe mw mx my mz b">50</code>。为了方便起见，在每个像素的<code class="fe mw mx my mz b">seamsEnergies</code>生成期间，我们不仅可以保存接缝的能量，还可以保存先前最低能量接缝的坐标。这将使我们有可能轻松地从底部到顶部重建接缝路径。</p><p id="c352" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">DP方法的时间复杂度将是<code class="fe mw mx my mz b">O(w * h)</code>，其中<code class="fe mw mx my mz b">w</code>和<code class="fe mw mx my mz b">h</code>是图像的宽度和高度。我们需要计算图像中每个像素的能量。</p><p id="2abe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是如何实现这一逻辑的示例:</p><pre class="mr ms mt mu gt nh mz ni nj aw nk bi"><span id="b13c" class="nl ln in mz b gy nm nn l no np">// The metadata for the pixels in the seam.<br/>type SeamPixelMeta = {<br/>  energy: number, // The energy of the pixel.<br/>  coordinate: Coordinate, // The coordinate of the pixel.<br/>  previous: Coordinate | null, // The previous pixel in a seam.<br/>};</span><span id="5464" class="nl ln in mz b gy nq nn l no np">// Finds the seam (the sequence of pixels from top to bottom) that has the<br/>// lowest resulting energy using the Dynamic Programming approach.<br/>const findLowEnergySeam = (energyMap: EnergyMap, { w, h }: ImageSize): Seam =&gt; {<br/>  // The 2D array of the size of w and h, where each pixel contains the<br/>  // seam metadata (pixel energy, pixel coordinate and previous pixel from<br/>  // the lowest energy seam at this point).<br/>  const seamsEnergies: (SeamPixelMeta | null)[][] = matrix&lt;SeamPixelMeta | null&gt;(w, h, null);</span><span id="0fee" class="nl ln in mz b gy nq nn l no np">  // Populate the first row of the map by just copying the energies<br/>  // from the energy map.<br/>  for (let x = 0; x &lt; w; x += 1) {<br/>    const y = 0;<br/>    seamsEnergies[y][x] = {<br/>      energy: energyMap[y][x],<br/>      coordinate: { x, y },<br/>      previous: null,<br/>    };<br/>  }</span><span id="e9dd" class="nl ln in mz b gy nq nn l no np">  // Populate the rest of the rows.<br/>  for (let y = 1; y &lt; h; y += 1) {<br/>    for (let x = 0; x &lt; w; x += 1) {<br/>      // Find the top adjacent cell with minimum energy.<br/>      // This cell would be the tail of a seam with lowest energy at this point.<br/>      // It doesn't mean that this seam (path) has lowest energy globally.<br/>      // Instead, it means that we found a path with the lowest energy that may lead<br/>      // us to the current pixel with the coordinates x and y.<br/>      let minPrevEnergy = Infinity;<br/>      let minPrevX: number = x;<br/>      for (let i = (x - 1); i &lt;= (x + 1); i += 1) {<br/>        if (i &gt;= 0 &amp;&amp; i &lt; w &amp;&amp; seamsEnergies[y - 1][i].energy &lt; minPrevEnergy) {<br/>          minPrevEnergy = seamsEnergies[y - 1][i].energy;<br/>          minPrevX = i;<br/>        }<br/>      }</span><span id="62d8" class="nl ln in mz b gy nq nn l no np">      // Update the current cell.<br/>      seamsEnergies[y][x] = {<br/>        energy: minPrevEnergy + energyMap[y][x],<br/>        coordinate: { x, y },<br/>        previous: { x: minPrevX, y: y - 1 },<br/>      };<br/>    }<br/>  }</span><span id="16b9" class="nl ln in mz b gy nq nn l no np">  // Find where the minimum energy seam ends.<br/>  // We need to find the tail of the lowest energy seam to start<br/>  // traversing it from its tail to its head (from the bottom to the top).<br/>  let lastMinCoordinate: Coordinate | null = null;<br/>  let minSeamEnergy = Infinity;<br/>  for (let x = 0; x &lt; w; x += 1) {<br/>    const y = h - 1;<br/>    if (seamsEnergies[y][x].energy &lt; minSeamEnergy) {<br/>      minSeamEnergy = seamsEnergies[y][x].energy;<br/>      lastMinCoordinate = { x, y };<br/>    }<br/>  }</span><span id="bf3b" class="nl ln in mz b gy nq nn l no np">  // Find the lowest energy energy seam.<br/>  // Once we know where the tail is we may traverse and assemble the lowest<br/>  // energy seam based on the "previous" value of the seam pixel metadata.<br/>  const seam: Seam = [];<br/>  if (!lastMinCoordinate) {<br/>    return seam;<br/>  }</span><span id="67f5" class="nl ln in mz b gy nq nn l no np">  const { x: lastMinX, y: lastMinY } = lastMinCoordinate;</span><span id="e7f0" class="nl ln in mz b gy nq nn l no np">  // Adding new pixel to the seam path one by one until we reach the top.<br/>  let currentSeam = seamsEnergies[lastMinY][lastMinX];<br/>  while (currentSeam) {<br/>    seam.push(currentSeam.coordinate);<br/>    const prevMinCoordinates = currentSeam.previous;<br/>    if (!prevMinCoordinates) {<br/>      currentSeam = null;<br/>    } else {<br/>      const { x: prevMinX, y: prevMinY } = prevMinCoordinates;<br/>      currentSeam = seamsEnergies[prevMinY][prevMinX];<br/>    }<br/>  }</span><span id="8ec1" class="nl ln in mz b gy nq nn l no np">  return seam;<br/>};</span></pre><h1 id="d77a" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">用最低能量移除接缝</h1><p id="7950" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">一旦我们找到了最低能量的接缝，我们需要从图像中移除(雕刻)形成它的像素。通过将接缝右侧的像素向左移动<code class="fe mw mx my mz b">1px</code>来进行移除。出于性能原因，我们实际上并不删除最后的列。相反，呈现组件将忽略超出调整后的图像宽度的图像部分。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/01f7b605fd698fee49c1ad3fd83fad9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fpda3YEI7eptWRA6.png"/></div></div></figure><pre class="mr ms mt mu gt nh mz ni nj aw nk bi"><span id="a783" class="nl ln in mz b gy nm nn l no np">// Deletes the seam from the image data.<br/>// We delete the pixel in each row and then shift the rest of the row pixels to the left.<br/>const deleteSeam = (img: ImageData, seam: Seam, { w }: ImageSize): void =&gt; {<br/>  seam.forEach(({ x: seamX, y: seamY }: Coordinate) =&gt; {<br/>    for (let x = seamX; x &lt; (w - 1); x += 1) {<br/>      const nextPixel = getPixel(img, { x: x + 1, y: seamY });<br/>      setPixel(img, { x, y: seamY }, nextPixel);<br/>    }<br/>  });<br/>};</span></pre><h1 id="c3c0" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">对象移除</h1><p id="6e87" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">接缝雕刻算法首先尝试去除由低能量像素组成的接缝。我们可以利用这一事实，通过手动将低能量分配给一些像素(即，通过在图像上绘制并遮蔽图像的一些区域)，我们可以让Seam Carving算法免费为我们进行<em class="mp">对象移除</em>。</p><p id="77b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目前，在<code class="fe mw mx my mz b">getPixelEnergy()</code>函数中，我们只使用了<code class="fe mw mx my mz b">R</code>、<code class="fe mw mx my mz b">G</code>、<code class="fe mw mx my mz b">B</code>颜色通道来计算像素的能量。但是还有颜色的<code class="fe mw mx my mz b">A</code> (alpha，透明度)参数我们还没有用到。我们可以使用透明通道告诉算法透明像素是我们想要移除的像素。你可以检查考虑到透明度的能量函数的<a class="ae jz" href="https://github.com/trekhleb/js-image-carver/blob/main/src/utils/contentAwareResizer.ts#L54" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><p id="6074" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是该算法如何用于对象移除。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a4ff8fb3976ecff54e68ec9b711d7f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*DGgtfeMA23vbzMTh.gif"/></div></figure><h1 id="d71e" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">问题和下一步</h1><p id="456e" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">当然，JS IMAGE CARVER web应用程序还远远不是一个生产就绪的resizer。其主要目的是以交互方式试验接缝雕刻算法。所以未来的计划是继续实验。</p><p id="d903" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://perso.crans.org/frenoy/matlab2012/seamcarving.pdf" rel="noopener ugc nofollow" target="_blank">原始论文</a>描述了接缝雕刻算法如何不仅用于图像的缩小，还用于图像<strong class="kc io">的放大。反过来，在移除对象后，放大可以用于将图像放大回其原始宽度。</strong></p><p id="10d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个有趣的实验领域可能是让算法在实时环境中工作。</p><p id="6b2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些是未来的计划，但是现在，我希望缩小图片的例子对你来说是有趣和有用的。我还希望您已经有了使用动态编程来实现它的想法。</p><p id="f5f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，祝你自己的实验好运！</p><p id="11c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mp">这篇文章有一个</em> <a class="ae jz" href="https://trekhleb.dev/blog/2021/content-aware-image-resizing-in-javascript/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">的互动版本</em> </a> <em class="mp">，你可以上传和调整你的自定义图片，并有一个代码语法高亮。</em></p><h1 id="3887" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a681" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">已经有很多关于<em class="mp"> Seam Carving算法</em>的优秀文章，但是我无法抗拒自己探索这个优雅、强大而又简单的<em class="mp">算法的诱惑，并写下我个人的使用体验。引起我注意的另一点(作为一个<a class="ae jz" href="https://github.com/trekhleb/javascript-algorithms" rel="noopener ugc nofollow" target="_blank"> javascript算法</a> repo的创建者)是这样一个事实，即<em class="mp">动态编程(DP) </em>方法可以顺利地应用于解决这个问题。如果你像我一样，还在“学习算法”的旅程中，这个算法解决方案可能会丰富你的个人DP库。</em></p><p id="edee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mp">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>