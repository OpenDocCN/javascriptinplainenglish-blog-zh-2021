<html>
<head>
<title>Hexagonal Architecture Distilled in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中提炼的六边形架构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hexagonal-architecture-distilled-in-javascript-ultimate-guide-aac2eaa6726c?source=collection_archive---------4-----------------------#2021-08-25">https://javascript.plainenglish.io/hexagonal-architecture-distilled-in-javascript-ultimate-guide-aac2eaa6726c?source=collection_archive---------4-----------------------#2021-08-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/82f3719c94cddcf65ee25519d5c024fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6Be5T5OUlYjiOnZOFHi9Q.png"/></div></div></figure><pre class="jv jw jx jy gt jz ka kb kc aw kd bi"><span id="d533" class="ke kf in ka b gy kg kh l ki kj"><strong class="ka io">This publication is currently being maintained. Topics that are under change will be indicated by [brackets].</strong> ℹ️</span></pre><p id="8ff1" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">我打算写这篇文章来清楚地分享如何理解和实现<strong class="km io"> JavaScript </strong>中的<strong class="km io">端口和适配器(六角形架构)</strong>模式。</p><p id="8fcf" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">我选择以不同的格式创建此出版物。使用<strong class="km io">六边形架构</strong>开发了一个库，实际实现了一个<strong class="km io">博客</strong>。</p><p id="1499" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">这个库的目的是展示我将要解释的概念的具体例子。</p><figure class="jv jw jx jy gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/edca33e4961ad8bb86c8ee9ffa39abbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_GB7y_7Y5VXcZPtMHY5ig.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">1.0 — Component view of the pattern.</figcaption></figure><p id="11e9" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">本文的研究工作如下:在这个页面上，我将呈现一个高层次的视图。<strong class="km io"> JavaScript </strong>中的概念和实际例子的细节将在资源库中提供:</p><div class="ln lo gp gr lp lq"><a href="https://github.com/pedromoraisf/hexagonal-architecture-distilled" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd io gy z fp lv fr fs lw fu fw im bi translated">GitHub-pedromoraisf/hexagon-architecture-elisted:理解六边形的终极指南…</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">理解JavaScript六边形架构(也称为端口和适配器)的终极指南。这是一个简单的博客…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">github.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me jt lq"/></div></div></a></div><p id="88cd" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">如果存储库中继续有任何概念，链接将位于主题的末尾。</p><h1 id="5024" class="mf kf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">摘要</h1><ul class=""><li id="e35b" class="nc nd in km b kn ne kr nf kv ng kz nh ld ni lh nj nk nl nm bi translated"><strong class="km io"> <em class="nn">简介</em> </strong></li><li id="a54b" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated"><strong class="km io"> <em class="nn">想法和动机</em> </strong> <em class="nn"> <br/>为什么是六边形？</em></li><li id="8c20" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated"><strong class="km io"> <em class="nn">可配置依赖<br/> </em> </strong> <em class="nn">可配置依赖之上的概念层<br/>用TypeScript <br/>反转和注入依赖现在，在JavaScript </em></li><li id="ef48" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated"><strong class="km io"> <em class="nn">六边形架构</em> </strong> <em class="nn"> <br/>六边形</em><strong class="km io"><em class="nn">【todo】</em></strong><em class="nn"><br/>演员</em><strong class="km io"><em class="nn">【todo】</em></strong><em class="nn"><br/>端口<br/>关于端口数量<br/>清晰的实现示例<br/>适配器<br/>用例</em><strong class="km io"><em class="nn"/>将被弃用<em class="nn"/></strong></li><li id="aa3e" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated"><strong class="km io"> <em class="nn">结论</em> </strong></li><li id="e3e1" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated"><strong class="km io"> <em class="nn">参考文献</em> </strong></li></ul><h1 id="f324" class="mf kf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">想法和动机</h1><p id="8d5d" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">由阿利斯泰尔·考克伯恩博士于2005年发布的<strong class="km io"><strong class="km io">端口和适配器</strong> <strong class="km io">架构模式</strong>提出了将应用程序从其技术中分离出来的想法——如框架、第三方实现或库等。</strong></p><p id="abb3" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">受<strong class="km io">将业务逻辑渗透到用户界面代码</strong>的启发，主要想法是定义应用程序的结构<strong class="km io">，以在不同的驱动程序</strong>上运行。因此，其中一个好处是可以更容易地测试我们的应用程序<strong class="km io"/>，能够为给定的测试策略<strong class="km io">隔离不必要的外部实现</strong>。</p><h2 id="a6d3" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">为什么是六边形？</h2><p id="d18b" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">最初的想法移到了<strong class="km io">的一侧，带来了围绕应用内部和应用外部的不对称概念</strong>，而不是我们在分层架构方法中常见的上/下或左/右。</p><p id="62c2" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">根据阿利斯泰尔·考克伯恩的说法，由于这些原因，正方形是不够的。像五边形或七边形这样的几何图形很难画——<strong class="km io">所以就画六边形吧。</strong></p><figure class="jv jw jx jy gt jo gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a9c78d858ba3f33b5dc7c3a3df98e56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*z4LnhmJYZA-Baw0C2fMqKQ.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">1.0 — The overrated Hexagon…</figcaption></figure><p id="3ce0" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">最后，在数字6，或六边形的边，对概念有一些意义的地方，争论被去神秘化。</p><h1 id="33e1" class="mf kf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">可配置依赖关系</h1><p id="d0f6" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">在我们进入概念及其实现之前，我们应该对<strong class="km io">可配置依赖模式</strong>有一个清晰的理解。</p><p id="d99d" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="km io">可配置依赖</strong>通过加入两个非常著名的行业模式来理解:<strong class="km io">依赖注入和依赖反转</strong>。在胡安·曼努埃尔·加里多·帕兹 的文章<strong class="km io"> <em class="nn">端口和适配器模式(六边形架构)中，有一章专门讲述了这个主题:<a class="ae oi" href="https://jmgarridopaz.github.io/content/hexagonalarchitecture.html#tc3" rel="noopener ugc nofollow" target="_blank">https://jmgarridopaz . github . io/content/Hexagonal Architecture . html # tc3</a>。</em></strong></p><p id="4691" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">简而言之，我们将<strong class="km io">可配置依赖</strong>视为一个对象(或函数)对一个接口(或协议)的<strong class="km io">依赖。</strong>我在前一句中添加了“功能”和“协议”这两个词，因为我们在本出版物的实现示例中将或多或少地遵循这一思想。</p><p id="65d7" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">当建立协议结构的依赖关系时，我们<strong class="km io">将该对象的依赖关系</strong> <strong class="km io">转化为另一个具体对象</strong>。然后，我们可以注入一些具体的结构，这些结构遵循协议提出的接口。</p><h2 id="c5e0" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">可配置依赖关系之上的概念层</h2><p id="81ae" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">在阿利斯泰尔·考克伯恩的原始出版物中，在“相关模式”部分，我们有最后一个(至少在撰写本文时)主题“依赖倒置(依赖注入)和SPRING”。</p><p id="cb2f" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">一些更有经验的读者，即使他们还不知道端口和适配器的概念，仅仅通过添加模式的<em class="nn">思想和动机</em>信息，以及对可配置依赖性的简要解释，可能已经预测到，为了获得这样的独立于由阿利斯泰尔·考克伯恩提出的外部技术，解决方案将是我们反转和注入依赖性。<strong class="km io">这些读者没有错。</strong></p><p id="79f4" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">显然，端口和适配器是由其他集合概念组成的，<strong class="km io">但是我敢说它的坚实基础之一是可配置的依赖关系</strong>。清楚了这一点后，我们接下来看一个在TypeScript和JavaScript中都适用的例子。</p><h2 id="1345" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">用TypeScript反转和注入依赖关系</h2><p id="ccd3" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">让我们想象我们正在为一个博客实现一个用例——不要拘泥于这个概念的字面意思。</p><p id="4234" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">这个用例旨在创建一篇博客文章。<strong class="km io">我将称之为“创造岗位”。</strong></p><p id="6f1a" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">我们知道，为了实现这个目标，我们需要在某个数据库中持久化发布(我可以将它保存在文件系统上的一个文本文件中，但是我将使用数据库作为例子)。<strong class="km io">为了反转直接的数据库依赖，我将这种依赖指向我正在开发的类中的一个属性。</strong> <strong class="km io">我姑且称之为“数据库”。</strong></p><figure class="jv jw jx jy gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oj"><img src="../Images/686a5ff9c86f1978383e1f6c6f04edb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgNbBkfupk6WK6zakvfVWg.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">1.0 —Example of decoupling a Use Case from persistence code using TypeScript Interface.</figcaption></figure><p id="bdc3" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">这个属性是通过构造函数提供的，所以如果我运行用例的“execute”方法而没有给它赋值，什么都不会起作用。因此，当实例化示例类时，<strong class="km io">我们需要给构造函数分配一个尊重“数据库”接口的对象。所以我们必须注入一个依赖项。</strong></p><h2 id="b6c2" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">现在，在JavaScript中</h2><p id="b688" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">在TypeScript中，利用面向对象语言中常见的特性，我们成功地对可配置依赖模式提供了流畅的支持。现在，如何在没有本机接口特性的语言中获得相同的结果呢？</p><p id="3289" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">在下面的例子中，我使用了<strong class="km io">高阶函数</strong>的概念，其中我们有一个更高级别的函数，它返回一个更低级别的子函数。</p><p id="a6e7" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">这里的策略是使用高阶函数作为类的“构造器”特性。在撰写本出版物时，ES2021拥有原生类功能已经有一段时间了。然而，我决定使用这个例子来更接近大多数纯粹的JavaScript开发人员的代码编写。</p><p id="17f9" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">请注意，我克服了“接口”特性的不足，<strong class="km io">构建了一个名为“数据库”的对象，包含在图</strong>的第一行中。这个对象有一个方法，当它被执行时，<strong class="km io">抛出一个错误，通知在它的执行中没有实现。</strong></p><figure class="jv jw jx jy gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ok"><img src="../Images/aef9f86bf9b0cd784f3f5a423e272191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdvIoGHuFEQeWCIlsHt9Vw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">1.1 — Example of decoupling a Use Case from persistence code using JavaScript function parameter.</figcaption></figure><p id="256e" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">这种格式包含许多问题。我将这个界面模拟归因于“数据库”参数的默认值。如果客户端注入一个不完全符合“数据库”中描述的结构的依赖项，<strong class="km io">我们就不会得到该语言的编译错误警告。</strong> <strong class="km io">这是因为JavaScript是一种解释语言，而不是编译语言。</strong></p><p id="9ed1" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">这不是模拟界面的最安全的方式，但这是我们目前在JavaScript中所拥有的。</p><p id="f77e" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">考虑到这些警告，我在TypeScript中执行了与示例相同的两个步骤，不同之处仅在于缺少“this”引用。</p><h1 id="a33e" class="mf kf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">六角形建筑</h1><h2 id="be72" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">六角形[todo]</h2><h2 id="20da" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">演员[todo]</h2><h2 id="adb1" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">港口</h2><p id="db3d" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">端口位于六边形的<strong class="km io">边缘，是从外部世界到六边形以及从六边形到外部世界的通信手段。因此，端口可以被看作是承载交互</strong>的<strong class="km io">目的的东西。</strong></p><p id="2c6e" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">因为它被描述为一个交互的目的，命名法的开头会有“for ”,表示<strong class="km io">交互将服务于</strong>。</p><p id="5e77" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">举一个任意的例子，我们可以在应用程序的<em class="nn">“左侧”</em>有一个端口，指示与六边形外部接触的<strong class="km io">目的。如果我们在谈论一个抽奖应用程序，访问六边形的端口可以是“原始随机数”。</strong></p><figure class="jv jw jx jy gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ol"><img src="../Images/01f2d11b3c73b840ef0f302224470c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUitU-Mnlj8p-qFBs7s-CA.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">1.0 — First macro view of the Hexagon with the Ports.</figcaption></figure><p id="5752" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">如果六边形内部的代码以绘制随机数为目的，需要与六边形外部的技术(例如数据库)建立连接，我们可以有一个“for-save-draw-record”端口。</p><h2 id="9521" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">关于端口的数量</h2><p id="b03e" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">在最初的出版物中，阿利斯泰尔·考克伯恩对此并不死板，他透露我们可以:</p><ul class=""><li id="699d" class="nc nd in km b kn ko kr ks kv om kz on ld oo lh nj nk nl nm bi translated">一个端口用于所有外部世界与六边形的交互，一个端口用于六边形与外部世界的交互。</li><li id="4cbe" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">用于与六边形的每次交互的不同和特定的端口，以及用于六边形与外部世界的每次交互的等效端口。</li></ul><p id="7db7" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">同样，这也表明<strong class="km io">两种情况都不理想</strong>。实际上，最终，这个<strong class="km io">将取决于工程师/建筑师的直觉</strong>。</p><p id="d845" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">在本出版物的示例存储库中，我使用了一个web端口(它更能代表外部世界与六边形的联系)，因为我们不能用JavaScript 设计一个函数接口的模拟。也许，在不同的方法中，您可以将六边形内部的代码(在本例中是用例)编写为带有方法和属性的JavaScript对象，更接近于类方法。</p><p id="e93f" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">我使用的另一个端口是<strong class="km io">，用于管理帖子</strong>。在这个港口，我收集了所有必要的操作。因为在实现中，我部分使用了<em class="nn">存储库模式</em>的概念。</p><p id="ab08" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">我不能说examples应用程序只有两个端口。如果需要扩展，它将根据对更多储存库的需求，添加更多与外界的六边形接触端口。</p><p id="7b78" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">然而，正如在原始出版物中所规定的，这是可以自由决定的。在另一个我在GitHub上开源的项目中，我遵循一种方法，在这种方法中，我为与hexagon的每次交互声明一个特定的端口，并在hexagon与外部世界的通信中进行等效。这个例子可以在下面找到:</p><div class="ln lo gp gr lp lq"><a href="https://github.com/pedromoraisf/lets-code-api/tree/main/src/hexagon/ports" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd io gy z fp lv fr fs lw fu fw im bi translated">let-code-API/src/hexagon/主通道端口</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">让我们来编写看板的代码。通过创建一个…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">github.com</p></div></div><div class="lz l"><div class="op l mb mc md lz me jt lq"/></div></div></a></div><h2 id="a666" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">清晰的实施示例</h2><p id="7c45" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">通常，可以用面向对象语言中常见的接口特性来编写端口。</p><p id="3fef" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">在这个例子中，我使用JavaScript对象，其中的属性是端口，而<strong class="km io">实现抛出一个错误，表明那里没有具体的实现，只有一个端口分界</strong>。</p><p id="e5c2" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">“可配置的依赖关系”一节描述了一个类似的例子。</p><p id="e50d" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">详细阅读示例<strong class="km io"> JavaScript </strong>实现，参见:<a class="ae oi" href="https://github.com/pedromoraisf/hexagonal-architecture-distilled/tree/main/src/hexagon/ports" rel="noopener ugc nofollow" target="_blank"> <strong class="km io">端口——六边形架构精华→ </strong> </a>。</p><h2 id="7c7a" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">适配器</h2><p id="d72e" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">在讲授这个话题时，我喜欢用下面的比喻:</p><blockquote class="oq"><p id="5a71" class="or os in bd ot ou ov ow ox oy oz lh dk translated">端口指定允许与六边形通信的语言。适配器用于将参与者的语言转换成端口指定的六边形所理解的语言。</p></blockquote><p id="0d03" class="pw-post-body-paragraph kk kl in km b kn pa kp kq kr pb kt ku kv pc kx ky kz pd lb lc ld pe lf lg lh ig bi translated">在六边形体系结构的上下文中，适配器将是端口所指定的特定技术的实现。</p><p id="a310" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">给定一个名为“保存抽签记录”的端口，我们可以实现一个MongoDB、MySQL数据库和一个用于测试的模拟。</p><figure class="jv jw jx jy gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi pf"><img src="../Images/fbefed4a48ecb5f26c21a374372210f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4q74MPzGgU7IwWdn_U2_Iw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">1.0 — View of the relationship between Hexagon, port and adapter.</figcaption></figure><p id="29fc" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="km io">在实施六边形架构时，我们需要了解的一个重要观点是，每个端口至少必须有两个适配器</strong>。</p><p id="6070" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">这是规则吗？如果我们假装不是，我们可以理解使用默认端口和适配器可能没有意义。也许你不小心制造了太多的复杂性，直接调用外部技术函数是有意义的。</p><p id="16ae" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="km io">因此，无论何时我们设计适配器的实现，我们都可以连续地得到使用端口和适配器模式是否有意义的答案。这是提示。</strong></p><p id="7c61" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">本主题指向GOF适配器模式，因此主要规范是相同的。</p><blockquote class="oq"><p id="aae8" class="or os in bd ot ou ov ow ox oy oz lh dk translated">将一个类的接口转换成客户期望的另一个接口。该适配器允许接口不兼容的类一起工作，否则这是不可能的。”</p></blockquote><p id="678d" class="pw-post-body-paragraph kk kl in km b kn pa kp kq kr pb kt ku kv pc kx ky kz pd lb lc ld pe lf lg lh ig bi translated">在我们的JavaScript上下文中，我们也可以为此使用函数。</p><p id="2f80" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">在本出版物的示例实现中，我使用了JavaScript的闭包功能和高阶函数技术将适配器注入到六边形内部的代码中。反过来，这些功能依赖于端口，端口由一个文字对象表示，没有具体的功能实现。</p><p id="9cc4" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">当我们以这种方式设计项目时，<strong class="km io">我们可以根据上下文和意图注入适配器，隔离资源</strong>。例如，如果我们的<em class="nn">六角形代码</em>需要使用网络协议来获得一些资源，在单元测试上下文中，我们可以隔离这个非常昂贵的资源，并注入一个<strong class="km io">假适配器</strong>，它返回一个与我们想要在代码中处理的内容兼容的结果。</p><p id="3e53" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">关于示例<strong class="km io"> JavaScript </strong>实现的详细阅读，请参见:<a class="ae oi" href="https://github.com/pedromoraisf/hexagonal-architecture-distilled/blob/main/src/adapters/readme.md" rel="noopener ugc nofollow" target="_blank"> <strong class="km io">适配器—六边形架构精华→ </strong> </a>。</p><h2 id="a232" class="ke kf in bd mg nw nx dn mk ny nz dp mo kv oa ob ms kz oc od mw ld oe of na og bi translated">用例<strong class="ak"><em class="pg"/>将被弃用<em class="pg"/></strong></h2><p id="c7d7" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">在<strong class="km io">阿利斯泰尔·考克伯恩的</strong>原始出版物中，代码的<strong class="km io">内部部分</strong>的引用没有作为<strong class="km io">用例</strong>给出。</p><p id="2988" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">我决定在这本出版物中整合这个概念，因为作者自己已经有效地为我们今天对<strong class="km io">用例</strong>的定义做出了贡献——阅读:<strong class="km io">编写有效的用例，作者阿利斯泰尔·考克伯恩</strong>。</p><p id="ba07" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">此外，这个概念的最初定义遵循了这样的陈述，即<strong class="km io">用例</strong>可以被描述为系统必须尊重的功能。你身份的塑造。</p><p id="6901" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">根据定义，我们拥有来自外部世界的<strong class="km io">技术</strong>，它们与通过<strong class="km io">参与者</strong>表示的<strong class="km io">用例</strong>进行交互。</p><p id="f757" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">这个观点在<strong class="km io">用例</strong>图概念中得到肯定，后来由<strong class="km io"> Ivar Jacobson </strong>在声名狼藉的<strong class="km io"> UML符号语言</strong>中提出。</p><p id="a166" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">很长一段时间以来(甚至今天)，软件行业一直保留着<strong class="km io">用例</strong>的写作，而<strong class="km io">对它们的参与者</strong>有不适当的了解。</p><p id="2f05" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">因此，我们用<strong class="km io">端口</strong>来划分<strong class="km io">参与者</strong>在代码中的某一点应该做什么。使用<strong class="km io">适配器</strong>，我们指定如何操作。</p><p id="1876" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">如果我们仔细观察，<strong class="km io"> UML用例图</strong>的<strong class="km io">参与者</strong>将是一个<strong class="km io">六边形架构</strong>的<strong class="km io">适配器</strong>的一个很好的指示。</p><p id="4d43" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">关于示例<strong class="km io"> JavaScript </strong>实现的详细阅读，请参见:<a class="ae oi" href="https://github.com/pedromoraisf/hexagonal-architecture-distilled/blob/main/src/usecases/readme.md" rel="noopener ugc nofollow" target="_blank"> <strong class="km io">用例——六角形架构精华→ </strong> </a>。</p><h1 id="64b7" class="mf kf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">结论</h1><p id="28cd" class="pw-post-body-paragraph kk kl in km b kn ne kp kq kr nf kt ku kv nt kx ky kz nu lb lc ld nv lf lg lh ig bi translated">利用<strong class="km io">端口和适配器架构模式</strong>，我们开发出健康的、可维护的、职责明确的应用程序。</p><p id="bd70" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">一个大提示:<strong class="km io">不要在没有创建单元测试的情况下使用这种架构模式。</strong></p><p id="e765" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">违背上面的判决几乎就像是死刑判决。</p><p id="f05c" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">阿利斯泰尔·考克伯恩的动机之一是开发<strong class="km io"> <em class="nn">【模拟】</em>外部技术的实现来创建<strong class="km io">真正的单元测试</strong>。测试单一概念性功能的测试。</strong></p><p id="b8f4" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">软件工程和架构中的最佳实践受到更多最佳实践的指导。</p><h1 id="bc0f" class="mf kf in bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">参考</h1><ul class=""><li id="c621" class="nc nd in km b kn ne kr nf kv ng kz nh ld ni lh nj nk nl nm bi translated">六角形建筑—<a class="ae oi" href="https://alistair.cockburn.us/hexagonal-architecture/" rel="noopener ugc nofollow" target="_blank">https://alistair.cockburn.us/hexagonal-architecture/</a></li><li id="9bd8" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">EEA目录的p—储存库<a class="ae oi" href="https://martinfowler.com/eaaCatalog/repository.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/eaaCatalog/repository.html</a></li><li id="1905" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">设计模式:可重用面向对象软件的元素。</li><li id="b1c1" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">统一软件开发过程——Ivar Jacobson，Grady Booch和James Rumbaugh。</li><li id="b317" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">干净的架构:软件结构和设计的工匠指南</li><li id="db17" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">务实的程序员——戴维·托马斯和安德鲁·亨特。</li><li id="80c2" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">面向对象软件工程:用例驱动的方法— Ivar Jacobson</li><li id="babc" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">撰写有效的用例—阿利斯泰尔·考克伯恩</li><li id="ba6d" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">http://xunitpatterns.com/SUT.html，xUnit模式—<a class="ae oi" href="http://xunitpatterns.com/SUT.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="f7a6" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">端口和适配器模式(六角形架构)，胡安·曼努埃尔·加里多·帕斯—<a class="ae oi" href="https://jmgarridopaz.github.io/content/hexagonalarchitecture.html#tc3" rel="noopener ugc nofollow" target="_blank">https://jmgarridopaz . github . io/content/Hexagonal Architecture . html</a></li><li id="931d" class="nc nd in km b kn no kr np kv nq kz nr ld ns lh nj nk nl nm bi translated">Closures—<a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Closures</a></li></ul><p id="0d20" class="pw-post-body-paragraph kk kl in km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><em class="nn">更多内容看</em><a class="ae oi" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="km io"><em class="nn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>