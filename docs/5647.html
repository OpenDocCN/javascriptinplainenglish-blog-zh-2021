<html>
<head>
<title>Build A Logger With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js构建一个日志记录器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-logger-with-node-js-7b5d3842c2c1?source=collection_archive---------2-----------------------#2021-11-26">https://javascript.plainenglish.io/build-a-logger-with-node-js-7b5d3842c2c1?source=collection_archive---------2-----------------------#2021-11-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d4f519100af78e8f92fca275c3bf0305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WAhaP8GYs20L_MxK"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="882e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">日志是记录信息的行为，通常输出到终端或文件。根据您的应用程序，您可能会因为许多不同的原因记录许多不同的事情。您可以保留API请求的日志，或者记录错误/警告，以供以后调试使用。日志是任何主要应用程序的关键部分。</p><p id="4919" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程中，我们将为Node.js构建一个简单的日志记录器，包括日志级别、缓存，并将这些日志写入控制台和磁盘。</p><h1 id="1a09" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">入门指南</h1><p id="f0d1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">首先，让我们创建一个新的Node.js项目。我使用NPM，但我也包括了所有的纱线命令。</p><ol class=""><li id="0e6e" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated"><code class="fe mk ml mm mn b">mkdir my-logger</code></li><li id="c014" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx mg mh mi mj bi translated"><code class="fe mk ml mm mn b">npm init -y</code> ( <code class="fe mk ml mm mn b">yarn init -y</code>)</li></ol><p id="1886" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程中我们不会使用任何包，所以我们可以直接进入代码。</p><h1 id="f0b4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">构造我们的记录器</strong></h1><p id="8c23" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们首先将我们的日志记录器定义为一个类。我们会在构造函数中要求一些参数。</p><ol class=""><li id="715a" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">名称—我们将用来指代记录器的名称。</li><li id="4e43" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx mg mh mi mj bi translated">目录—保存日志的目录。</li><li id="6699" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx mg mh mi mj bi translated">cacheSize——它控制在将日志写入文件之前我们保留多少日志，这很重要，这样我们就不会花费大量时间将每个日志写入文件。</li></ol><p id="05b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们将缓存定义为一个空列表。我们将很快用日志填充它。另外，如果输出目录不存在，我们将使用<code class="fe mk ml mm mn b">fs</code>模块来创建它。</p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="2714" class="nb kz in mn b gy nc nd l ne nf">const fs = require("fs");<br/>const path = require("path");</span><span id="cb38" class="nb kz in mn b gy ng nd l ne nf">class Logger {<br/>  constructor(name, dir="./logs", cacheSize=100) {<br/>    this.name = name;<br/>    if (!fs.existsSync(dir)) fs.mkdirSync(dir);<br/>    this.path = path.join(dir, `${<br/>      new Date().toISOString().replaceAll(':', '-').split('.')[0]<br/>    }-${this.name}.log`);<br/>    this.cacheSize = cacheSize;</span><span id="6a45" class="nb kz in mn b gy ng nd l ne nf">this.cache = []<br/>  }<br/>}</span></pre><h1 id="b950" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">并非所有日志都是平等创建的</strong></h1><p id="ccc8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">日志可以用于各种不同的事情，所以通常我们把它们分成不同的级别。不管平台如何，大多数记录器都使用以下级别(尽管有些级别有不同的名称)。</p><ul class=""><li id="4f1c" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx nh mh mi mj bi translated">信息—信息性消息，如开始、停止或其他重要事件</li><li id="7cf7" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx nh mh mi mj bi translated">调试—对调试应用程序有用的信息</li><li id="3bf7" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx nh mh mi mj bi translated">Trace(也称为Verbose) —调试的更详细信息，可能记录所有事件</li><li id="1c2c" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx nh mh mi mj bi translated">警告—记录不属于错误的潜在有害事件或不正确使用</li><li id="3c59" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx nh mh mi mj bi translated">错误—不要求应用程序停止的错误消息</li><li id="cf0d" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx nh mh mi mj bi translated">致命—导致整个应用程序崩溃并退出的错误消息</li></ul><p id="7d98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们添加这些不同的日志类型之前，我们需要添加一个通用的<code class="fe mk ml mm mn b">log</code>方法来避免在每种日志类型中重复我们自己。我们将我们的日志格式化为<code class="fe mk ml mm mn b">YYYY-MM-DD HH:MM:SS NAME LEVEL MESSAGE</code>，但是如果你有自己的喜好，可以随意定制。我们还需要将该消息添加到缓存中，并检查是否需要将缓存写入日志文件。</p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="643b" class="nb kz in mn b gy nc nd l ne nf">  log(level, message) {<br/>    const output = `${new Date().toISOString().replace('T',' ').split('.')[0]} ${this.name} ${level} ${message}`<br/>    console.log(output)<br/>    this.cache.push(output)</span><span id="4dde" class="nb kz in mn b gy ng nd l ne nf">if (this.cache.length &gt;= this.cacheSize) {<br/>      fs.appendFileSync(this.path, this.cache.map(l =&gt; `${l}\n`).join(''))<br/>      this.cache = []<br/>    }<br/>  }</span></pre><p id="0fb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，对于每个级别，我们可以添加一个用户可以调用的方法。</p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="3933" class="nb kz in mn b gy nc nd l ne nf">  info(message) {this.log(‘info’, message)}<br/>  debug(message) {this.log(‘debug’, message)}<br/>  trace(message) {this.log(‘trace’, message)}<br/>  warn(message) {this.log(‘warn’, message)}<br/>  error(message) {this.log(‘error’, message)}<br/>  fatal(message) {this.log(‘fatal’, message)}</span></pre><h1 id="6e15" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">用途</strong></h1><p id="f11d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们现在可以通过在我们的应用程序中创建一个日志实例来使用这些函数。</p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="f8d2" class="nb kz in mn b gy nc nd l ne nf">const logger = new Logger('my-app')</span><span id="7406" class="nb kz in mn b gy ng nd l ne nf">logger.info('App started')<br/>logger.debug('Event START triggered')<br/>logger.warn('THING Deprecated')<br/>logger.error('Logging is too cool')<br/>logger.fatal('App crashed because of X, Y and Z')</span></pre><h1 id="64d8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">安全关机</h1><p id="68dd" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在我们结束教程之前，我们需要在所有日志记录完成并且应用程序关闭后关闭日志记录器，因为我们需要将缓存中的所有日志写入文件。添加下面的方法，如果你想把它添加到你的应用中，在你的应用的关闭函数中调用它。</p><pre class="mt mu mv mw gt mx mn my mz aw na bi"><span id="6a20" class="nb kz in mn b gy nc nd l ne nf">  close() {<br/>    fs.appendFileSync(this.path, this.cache.map(l =&gt; `${l}\n`).join(''))<br/>  }</span></pre><h1 id="7421" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">结论</strong></h1><p id="7c26" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">恭喜你！您现在有了一个完整的工作日志记录器，并且可以在您的项目中使用它。日志记录非常重要，尤其是在较大的项目中，它使调试变得非常容易。</p><h1 id="cde4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">挑战</strong></h1><p id="68cb" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">对于想超越本教程的人来说，这里有一个小小的挑战。</p><ul class=""><li id="8dbc" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx nh mh mi mj bi translated">使用库添加一些颜色，如<a class="ae jz" href="https://www.npmjs.com/package/chalk" rel="noopener ugc nofollow" target="_blank">粉笔</a>。</li><li id="c726" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx nh mh mi mj bi translated">添加一种方法来过滤控制台记录的日志(例如，从控制台隐藏详细日志)。</li><li id="c2a4" class="mb mc in kc b kd mo kh mp kl mq kp mr kt ms kx nh mh mi mj bi translated">添加一些实用函数，比如计时器(查看Node.js <code class="fe mk ml mm mn b">performance.now</code>方法)。</li></ul><p id="ce0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ni">说白了。报名参加我们的</em><strong class="kc io"><em class="ni"/></strong><a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ni">免费每周简讯点击这里</em> </strong> </a> <em class="ni">。</em></strong></a></p></div></div>    
</body>
</html>