<html>
<head>
<title>How to Force a PWA to Refresh its Content</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何强制PWA刷新其内容</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-force-a-pwa-to-refresh-its-content-fef2c6ff3591?source=collection_archive---------2-----------------------#2021-12-17">https://javascript.plainenglish.io/how-to-force-a-pwa-to-refresh-its-content-fef2c6ff3591?source=collection_archive---------2-----------------------#2021-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dc48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" href="https://progressier.com?ref=medium20211217" rel="noopener ugc nofollow" target="_blank"> Progressier </a>上，我们最常被问到的一个问题与客户端缓存有关。如何确保PWA始终显示最新的数据和资产，同时充分利用缓存？</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/b31d449d4f6a85e78588984da42fd0b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHoiAy4INEiwBRKl7FyoWg.png"/></div></div></figure><p id="b442" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然PWA看起来和感觉上经常像一个本地应用程序，但从技术角度来看，它真的像其他任何网站一样工作。当用户打开一个页面时，它会加载资产(图像、脚本、样式表……)和数据(用户数据、产品数据……)。这些资源是从网络上获取的，然后由浏览器使用。</p><p id="6767" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进入<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank"> HTTP缓存</a>机制。为了让加载网站更快，浏览器会缓存这些资源。在初始加载时，图像将来自您的服务器。在接下来的加载中，它可能来自缓存。因此，如果你同时更新它，浏览器可能会显示该图像的旧版本。你如何防止这种情况发生？</p><h1 id="28cd" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">版本控制技巧</h1><p id="85b6" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">版本控制可能是强制浏览器从服务器加载资源的最简单的方法。更新资源时，在代码中请求的任何位置向资源的URL添加一个参数。例如，编辑您的客户端代码来请求<code class="fe lz ma mb mc b">domain.com/data.json?<strong class="jm io">version=2</strong></code>而不是<code class="fe lz ma mb mc b">domain.com/data.json?<strong class="jm io">version=1</strong></code>。</p><p id="f906" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">浏览器会看到这两个URL，并认为它们是完全不同的资产。所以当页面明确请求后者时，它不会使用前者的缓存版本。一个好的做法是在构建过程中将版本号(或者任何其他查询字符串)附加到关键资源上，这样您就不必在每次进行更改时都手动这么做。</p><h1 id="9d6c" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">缓存控制头</h1><p id="2268" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">当服务器成功响应HTTP请求时，它会返回资源本身(一个JavaScript文件、一个图像、一个CSV文件……)，但它还会发送标头——告诉浏览器允许或不允许对资源做什么的参数。</p><p id="f55a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些头中的一个是<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank">高速缓存控制</a>头。它的存在是为了告诉浏览器如何缓存(或不缓存)和重新验证(或不验证)特定的资源。</p><p id="a884" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您控制响应请求的服务器，您可以设置不同的<code class="fe lz ma mb mc b">Cache-Control</code>头，并告诉浏览器应该如何处理每个特定的资源。例如，将<code class="fe lz ma mb mc b">Cache-Control</code>头的值设置为<code class="fe lz ma mb mc b">no-cache</code>，禁止浏览器缓存资源。</p><p id="7a91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，这种方法只适用于你自己的资源——而不是第三方脚本、CSS库、Google字体或托管在其他地方的图片。</p><h1 id="0c23" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">网络优先战略</h1><p id="0c5e" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">说实话，<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank"> HTTP缓存</a>机制有点过时了。有了它，你真正能告诉浏览器的就是一个资源是否应该被缓存以及缓存到什么时候。</p><p id="5800" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有另一种缓存机制叫做<a class="ae ki" href="https://app.intercom.com/" rel="noopener ugc nofollow" target="_blank">缓存API </a>。而且在<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" rel="noopener ugc nofollow" target="_blank">服务人员</a>都有。Progressier 为其缓存策略制定者使用该API。您可以为每种类型的资源定义非常具体的规则，而无需编写任何代码。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi md"><img src="../Images/3dbed5fe5c279a096f8e936c62aaefd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6eDH-IcK8sBa2gFKJgseg.jpeg"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Use Network First and target all resources to prevent caching altogether</figcaption></figure><p id="8278" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<em class="kj">网络优先</em>策略，资源将总是从网络独占获取(因此，如果网络由于某种原因不可用，例如，如果用户或服务器离线，将会引发错误)。</p><p id="d30b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，大多数时候，您会希望更具体地将该策略应用于任务关键的资源，并对不太重要的资源使用更缓存友好的策略(例如<a class="ae ki" href="https://intercom.help/progressier/en/articles/5703064-what-s-a-caching-strategy" rel="noopener ugc nofollow" target="_blank">Stale-While-Revalidat</a>e)。</p><h1 id="60fd" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">假的重新加载按钮</h1><p id="3bf6" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">对于前三种方法，您实际上是在告诉浏览器，当加载页面时，应该从缓存还是从网络中检索特定的资源。</p><p id="df5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是一旦安装，打开一个PWA可能并不总是触发一个新的页面重新加载。你可以从主屏幕启动PWA，做你必须做的事情，然后启动另一个应用程序，第二天再回到PWA。</p><p id="7869" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你在此期间没有关闭应用程序或关闭手机，它不会重新加载页面，而是让你从你离开的地方继续你的会话。如果您(应用程序所有者)同时更新了资源，那么用户可能仍在使用陈旧的资源。你怎么能强迫PWA更新它的内容呢？</p><p id="28dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们在2020年1月推出冠状病毒应用程序时，用户对数据新鲜度的要求非常高。我们每15分钟自动更新一次数据，所以不让用户看到陈旧的数据是绝对重要的(否则我们会收到大量愤怒的电子邮件！).</p><p id="6953" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，我们没有等待实际的更新，而是使用了一个简单的技巧:当用户在页面上花费了超过半个小时时，我们会向他们提供一个选项来重新加载页面(他们没有其他选择，只能单击)并再次获取资源。它看起来像这样:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/7088fa20b2c5784b19d58c7e9b400ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*YJpD7UbqiFBPLcElpnWiyQ.jpeg"/></div></figure><p id="7ec2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给人一种某事正在发生的错觉是一个强有力的UX概念。在我们的例子中，目的有两个:让应用程序看起来像是不断更新的(实际上是这样——只是不是以与那个假的重新加载按钮同步的方式),避免显示陈旧的数据。</p><h1 id="b1a7" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="ebb7" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">所以你走吧。三种不同的缓存方法，以确保您的PWA保持更新和一个小UX技巧。</p><p id="a46d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">版本控制技巧可能是实现这一点的最简单的方法——不管您是否拥有所请求的资源，它都是通用的。</p><p id="c95a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这在构建过程中不太可行，您可以使用Cache-Control头(针对您拥有的资源)或Service Worker方法来精确定义缓存行为。</p><p id="6096" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你怎么想呢?你用其他方法来更新你的PWA吗？</p><p id="f678" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">更多内容看</em> <a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">说白了. io </em> </strong> </a> <strong class="jm io"> <em class="kj">。</em> </strong> <em class="kj">报名参加我们的</em> <a class="ae ki" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">免费每周简讯点击这里</em> </strong> </a> <strong class="jm io"> <em class="kj">。</em> </strong></p></div></div>    
</body>
</html>