<html>
<head>
<title>Peripheral Communication with React Native BLE (Bluetooth Low Energy)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与React本地BLE的外设通信(蓝牙低能耗)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-bluetooth-low-energy-peripheral-communication-e7cb93abf69?source=collection_archive---------0-----------------------#2021-03-07">https://javascript.plainenglish.io/react-native-bluetooth-low-energy-peripheral-communication-e7cb93abf69?source=collection_archive---------0-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/773379b23c19efd2058ea6feb8b4e92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9Oy9i6xropFrBmhsWDrmw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by <a class="kc kd ep" href="https://medium.com/u/32a8392c63cb?source=post_page-----e7cb93abf69--------------------------------" rel="noopener" target="_blank">Don GIannatti</a></figcaption></figure><p id="c692" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这个物联网时代，制作能够与硬件通信的软件不像以前那么难了。尤其是随着无线技术的许多发展更新。</p><p id="7256" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">日常生活中大量使用的最著名的无线技术之一是蓝牙。</p><p id="7df9" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">通过使用蓝牙，我们将能够跨设备共享数据，连接到耳机，从我们的智能手表中读取数据，甚至远程控制空调、电视、智能灯等。</p><p id="8702" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这是巫术！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="7a02" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">大约在2011年，最新版本的蓝牙技术被推出，它被称为蓝牙4.0或<strong class="kg ir">蓝牙低能耗</strong>。</p><p id="1491" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="lj">BLE(Bluetooth Low Energy)是由蓝牙特别兴趣小组(Bluetooth SIG)设计和营销的无线个人区域网技术，旨在医疗保健、健身、信标、安全和家庭娱乐行业的新颖应用~ </em> <a class="ae lk" href="https://en.wikipedia.org/wiki/Bluetooth_Low_Energy" rel="noopener ugc nofollow" target="_blank"> <em class="lj">维基百科</em> </a></p><p id="a759" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我不打算在这里做一个关于BLE的大学演讲，但让我快速解释一下。基本上，BLE是蓝牙技术的最新版本，提供了与其前身相同的功能，但大大降低了功耗和成本，并对许多操作系统提供了更好的本地支持。</p><p id="110c" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这篇文章中，我们将创建一个简单的react-native移动应用程序，它使用蓝牙外设并向其写入数据。</p><ul class=""><li id="4f3b" class="ll lm iq kg b kh ki kl km kp ln kt lo kx lp lb lq lr ls lt bi translated">在react-native端，我们将利用<a class="ae lk" href="https://github.com/innoveit/react-native-ble-manager" rel="noopener ugc nofollow" target="_blank">react-native-ble-manager</a>库。</li><li id="8cf6" class="ll lm iq kg b kh lu kl lv kp lw kt lx kx ly lb lq lr ls lt bi translated">这里将使用模拟外设进行测试。感谢<a class="ae lk" href="https://github.com/noble/bleno/" rel="noopener ugc nofollow" target="_blank"> Bleno </a>团队提供了一个强大的工具，让BLE外设实现变得如此容易。</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="e196" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">BLE角色与关贸总协定交易</h1><p id="840b" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">在我们开始做任何工程的东西之前，让我们先谈谈BLE的角色。我保证会速战速决。</p><p id="36c6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">BLE通信有两个关键角色:</p><ul class=""><li id="2927" class="ll lm iq kg b kh ki kl km kp ln kt lo kx lp lb lq lr ls lt bi translated">第一个角色是<strong class="kg ir">外围</strong>。血压计、智能手表、耳机都是外设的例子。外围设备通告自己，并等待中央设备与其连接。</li><li id="e17e" class="ll lm iq kg b kh lu kl lv kp lw kt lx kx ly lb lq lr ls lt bi translated">第二个作用是<strong class="kg ir">中枢。</strong>智能手机就是一个例子。中央设备将连接到外围设备，然后与之通信。</li></ul><p id="6a81" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在谈谈关贸总协定。在BLE世界…</p><p id="10e7" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="lj"> GATT是通用属性配置文件的缩写，它定义了两个蓝牙低能耗设备使用称为</em> <strong class="kg ir"> <em class="lj">服务</em> </strong> <em class="lj">和</em> <strong class="kg ir"> <em class="lj">特征</em> </strong> <em class="lj">的概念来回传输数据的方式。</em></p><p id="0bb8" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><a class="ae lk" href="https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://learn . adafruit . com/introduction-to-bluetooth-low-energy/GATT</em></a></p><p id="2a5d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">BLE的GATT事务是基于高级嵌套对象的，这些对象称为<strong class="kg ir">配置文件</strong>、<strong class="kg ir">服务</strong>和<strong class="kg ir">特征</strong>，如下图所示:</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/a3b31bd353555ea4d4f6202e78dee03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/0*VNMocZl0huJ7DWv7"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image from <a class="ae lk" href="https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt" rel="noopener ugc nofollow" target="_blank">https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt</a></figcaption></figure><ul class=""><li id="ea4b" class="ll lm iq kg b kh ki kl km kp ln kt lo kx lp lb lq lr ls lt bi translated"><strong class="kg ir">配置文件</strong>实际上并不存在于BLE外设本身，它只是一个由蓝牙SIG或外设设计者编译的预定义服务集合。</li><li id="910c" class="ll lm iq kg b kh lu kl lv kp lw kt lx kx ly lb lq lr ls lt bi translated"><strong class="kg ir">服务</strong>用于将数据分解成逻辑实体，并包含称为特征的特定数据块。一个服务可以有一个或多个特征，每个服务通过一个称为UUID的唯一数字ID来区别于其他服务，该ID可以是16位(用于官方采用的BLE服务)或128位(用于定制服务)。</li><li id="31fa" class="ll lm iq kg b kh lu kl lv kp lw kt lx kx ly lb lq lr ls lt bi translated">GATT交易中最底层的概念是<strong class="kg ir">特征</strong>，它封装了单个数据点(尽管它可能包含一组相关数据，如来自三轴加速度计的X/Y/Z值等)。).</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="eb03" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">学习期望</h1><p id="bec2" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">在高层次上，我们要做的是创建一个名为<strong class="kg ir"> Foodbank </strong>的模拟虚拟外设，然后将其托管在我们的计算机上。这个外围设备存储中央设备发送的食物信息。我们还可以阅读那里储存的食物。食物银行通常就是这么做的，储存食物，获取食物。</p><p id="3394" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">移动应用程序将显示可用的ble外围设备列表。稍后，我们将从列表中连接到我们的Foodbank外围设备，存储一个披萨并获得一个<a class="ae lk" href="https://emojipedia.org/beaming-face-with-smiling-eyes/" rel="noopener ugc nofollow" target="_blank">😁</a></p><p id="0e53" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="lj">蓝牙功能只能在实际设备上测试。它在模拟器或仿真器上不起作用。</em></p><p id="2e2e" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">好，我们开始吧！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="164d" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">Node.js中模拟的虚拟食物银行外围设备</h1><p id="1dd6" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">初始化新的Node.js项目。在上面安装名为Bleno的第三方库。</p><p id="8602" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">仅供参考，由于一些问题，我们将不会使用官方的Bleno包。相反，我们将使用由@abandonware 维护的<a class="ae lk" href="https://github.com/abandonware/bleno" rel="noopener ugc nofollow" target="_blank">分叉Bleno。</a></p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="8a7e" class="nm ma iq ni b gy nn no l np nq">mkdir food-bank-peripheral<br/>cd food-bank-peripheral<br/>npm init<br/>npm install @abandonware/bleno --save<br/>touch food-bank-characteristic.js # for storing characteristic code<br/>touch food-bank-service.js # for storing service code<br/>touch food-bank.js # for storing the main code</span></pre><p id="287e" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">剧透警告，尽管项目设置已经完成，但让它运行起来并不容易。</p><p id="d821" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们需要根据我们的操作系统设置几个本机依赖项。更多详情请看<a class="ae lk" href="https://github.com/abandonware/bleno" rel="noopener ugc nofollow" target="_blank">https://github.com/abandonware/bleno</a>。</p><h2 id="0797" class="nm ma iq bd mb nr ns dn mf nt nu dp mj kp nv nw mn kt nx ny mr kx nz oa mv ob bi translated">食物银行特征定义</h2><p id="db6d" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">接下来，让我们导航到<code class="fe oc od oe ni b">food-bank-characteristic.js</code>文件。准备<code class="fe oc od oe ni b">FoodBankCharacteristic</code>功能。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/63865cb60cef60daba0e4092e1467f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*Kh3Jy6Kqy9Lr2MosYg_DrQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">FoodBankCharacteristic definition</figcaption></figure><blockquote class="og oh oi"><p id="23a0" class="ke kf lj kg b kh ki kj kk kl km kn ko oj kq kr ks ok ku kv kw ol ky kz la lb ij bi translated">我们选择前缀为数字<strong class="kg ir"> 2000… </strong>的有效UUID字符串作为特征UUID</p></blockquote><p id="8514" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">从<code class="fe oc od oe ni b">properties: ['read', 'write']</code>语句中，我们可以假设将创建两个事件处理程序，read和write。</p><p id="787a" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在让我们创建它。在新创建的特性上设置<code class="fe oc od oe ni b">onWriteRequest</code>事件监听器。这个特定的监听器用于处理来自中央设备的写请求。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/099a7dad3fbdefe0e43b4b198a32e13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTd5FvSwVwGn3eH73S5tDg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Characteristic onWriteRequest definition</figcaption></figure><p id="8bd7" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">中心将向外围设备发送一个写请求，有效载荷是食物名称。然后我们将有效载荷存储到<code class="fe oc od oe ni b">this._storedFood</code>。</p><p id="e21f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">好了，现在让我们继续第二个监听器，即<code class="fe oc od oe ni b">onReadRequest</code>处理程序。这个处理程序将做与<code class="fe oc od oe ni b">onWriteRequest</code>监听器相反的动作。存储的食物将被用作对来自中央设备的呼叫的响应。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/c8a2d58cb844777e42fc5d8d6175c9d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pe4SrtEw3kGCG3kwRWeKUA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Characteristic onReadRequest definition</figcaption></figure><h2 id="2304" class="nm ma iq bd mb nr ns dn mf nt nu dp mj kp nv nw mn kt nx ny mr kx nz oa mv ob bi translated">食物银行服务定义</h2><p id="cee6" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">没有服务就无法访问外设，所以现在让我们创建<code class="fe oc od oe ni b">FoodBankService</code>。</p><p id="24c0" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这个服务所做的就是公开这个特征，使它可以从中央设备上使用。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/156aa0100ac809ac76b4e07cf6997dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*mHYHe6ltVUvhrIB-WbDHDw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">FoodBankService definition</figcaption></figure><blockquote class="og oh oi"><p id="498d" class="ke kf lj kg b kh ki kj kk kl km kn ko oj kq kr ks ok ku kv kw ol ky kz la lb ij bi translated">我们选择前缀为数字<strong class="kg ir"> 1000… </strong>的有效UUID字符串作为服务UUID</p></blockquote><h2 id="9246" class="nm ma iq bd mb nr ns dn mf nt nu dp mj kp nv nw mn kt nx ny mr kx nz oa mv ob bi translated">粮食银行主要代码</h2><p id="11ad" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">在这个主代码中，我们要做的是检查BLE电台的可用性。如果它在那里，那么让我们宣传我们的<strong class="kg ir">食物银行</strong>外围设备，让它对每一个最近的中央设备可用。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/4978eba4eeef19fe72d8e32c8fe3a1a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*ZPVEkN-8gQOK7ojF7LNiQA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Check BLE radio then advertise peripheral if it’s available</figcaption></figure><p id="d293" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果广告有效，那么让我们建立我们的<code class="fe oc od oe ni b">FoodBankServices</code>(以及它的<code class="fe oc od oe ni b">FoodBankCharacteristic</code>)。将代码放在<code class="fe oc od oe ni b">advertisingStart</code>事件监听器上。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c2010828a8509fa54e3b253fe329f8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*RKFVSCEBo85mtKD91bFfog.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Handle Bleno advertisingStart event</figcaption></figure><p id="4081" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">好了，外围设备到此为止。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="a1fc" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">使用React Native的移动BLE中心应用程序</h1><p id="cb14" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">现在让我们编写react-native移动应用程序。</p><blockquote class="og oh oi"><p id="0ae5" class="ke kf lj kg b kh ki kj kk kl km kn ko oj kq kr ks ok ku kv kw ol ky kz la lb ij bi translated">在这一部分，我不打算分享整个编码细节，因为它太多了。我只写下重要的步骤。</p><p id="3276" class="ke kf lj kg b kh ki kj kk kl km kn ko oj kq kr ks ok ku kv kw ol ky kz la lb ij bi translated">然而，你总是可以在本文结尾分享的Gitbub链接上看到完整的工作示例源代码。</p></blockquote><h2 id="bd22" class="nm ma iq bd mb nr ns dn mf nt nu dp mj kp nv nw mn kt nx ny mr kx nz oa mv ob bi translated">准备基本代码</h2><p id="5577" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">首先，创建一个新的BLE中央移动应用程序。你可以使用<code class="fe oc od oe ni b">react-native-cli</code>或<code class="fe oc od oe ni b">expo</code>，没关系。仅供参考，对于expo，您必须退出裸工作流，它需要使用外部本机模块。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="8b87" class="nm ma iq ni b gy nn no l np nq"># expo<br/>npm install -g expo-cli<br/>expo init BLECentralApp<br/>cd BLECentralApp<br/>expo eject</span><span id="3f6f" class="nm ma iq ni b gy or no l np nq"># react native cli<br/>npx react-native init BLECentralApp<br/>cd BLECentralApp</span></pre><p id="bff1" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">然后添加<code class="fe oc od oe ni b">react-native-ble-manager</code>、<code class="fe oc od oe ni b">convert-string</code>和<code class="fe oc od oe ni b">buffer</code>依赖项。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="c6be" class="nm ma iq ni b gy nn no l np nq">npm install --save react-native-ble-manager<br/>npm install --save convert-string<br/>npm install --save buffer</span></pre><p id="8a3c" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">对于<code class="fe oc od oe ni b">react-native-ble-manager</code>依赖项，需要一些额外的步骤。详情请见https://github.com/innoveit/react-native-ble-manager<a class="ae lk" href="https://github.com/innoveit/react-native-ble-manager" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="8065" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">之后，在场景文件中导入已安装的库。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/0a2c879456721b9632a8d116916a8b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*yk0BpjHZZLaDW58nzwSudQ.png"/></div></figure><p id="77a6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">开始用一些钩子定义和一个名为<code class="fe oc od oe ni b">startScan()</code>的函数来填充主场景函数，这个函数将触发设备扫描过程。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/6d98372decd5e49900de3a8ee7cd4075.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*co3zZgbA1yKclq5YnEDttQ.png"/></div></figure><p id="577e" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe oc od oe ni b">BleManager.scan()</code>将在我们的中央设备旁边列出任何可用的ble外设。设备列表将通过BLE发射器监听器<code class="fe oc od oe ni b">BleManagerDiscoverPeripheral</code>依次返回。</p><p id="6bf6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">下面，我们将为<code class="fe oc od oe ni b">bleEmitter</code>对象准备几个监听器处理程序，包括用于<code class="fe oc od oe ni b">BleManagerDiscoverPeripheral</code>监听器的处理程序。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/1f947801fe4a766d039dc39bed9f20a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*c1Hi732w8ZlaOD3A_kD79g.png"/></div></figure><p id="225b" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">接下来，在<code class="fe oc od oe ni b">mount</code>生命周期中，初始化BLE模块，应用BLE监听器，并验证某些电话权限(对于android)。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/28f986fb7bf755a406c2ea8e88362d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uMZT5nACWK8SAQOu4Iyog.png"/></div></div></figure><p id="4d9d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在卸载时，不要忘记删除BLE发射器监听器。</p><h2 id="63b0" class="nm ma iq bd mb nr ns dn mf nt nu dp mj kp nv nw mn kt nx ny mr kx nz oa mv ob bi translated">准备用户界面</h2><p id="3905" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">现在，让我们为我们的BLE扫描仪应用程序创建一个简单的UI，它包含以下几个部分:</p><ul class=""><li id="c6a2" class="ll lm iq kg b kh ki kl km kp ln kt lo kx lp lb lq lr ls lt bi translated">内部带有单个按钮的标题，用于触发BLE设备扫描。</li><li id="7158" class="ll lm iq kg b kh lu kl lv kp lw kt lx kx ly lb lq lr ls lt bi translated">没有可用设备时的消息。</li><li id="b31e" class="ll lm iq kg b kh lu kl lv kp lw kt lx kx ly lb lq lr ls lt bi translated">显示可用设备列表的<code class="fe oc od oe ni b">FlatList</code>。</li><li id="ac1f" class="ll lm iq kg b kh lu kl lv kp lw kt lx kx ly lb lq lr ls lt bi translated">页脚包含两个用于切换测试模式的按钮，<code class="fe oc od oe ni b">read</code>或<code class="fe oc od oe ni b">write</code>。</li></ul><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/e80515376c1474f0ab140047742670eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*TGenVXON0j4B9Z7XixI6oQ.png"/></div></figure><p id="f008" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在<code class="fe oc od oe ni b">FlatList.renderItem</code>处理器上，在列表外设部分添加<code class="fe oc od oe ni b">TouchableHighlight</code>。当点击该部分时，会触发<code class="fe oc od oe ni b">connectAndTestPeripheral()</code>功能。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/250f47ce04330d0784c51568ed8a0e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*55fUmDL9wcu8qOdbP_wXgQ.png"/></div></figure><p id="46ab" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在最有趣的部分，让我们准备<code class="fe oc od oe ni b">connectAndTestPeripheral()</code>函数。</p><p id="19b4" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这个函数中，我们将尝试连接到外围设备，然后检索服务和RSSI信息。如果需要，您可以检查返回的数据。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/eb73f6e951feba55840b06578e03b9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*M_ybv8CyOw1wm53u5r9Liw.png"/></div></figure><p id="109d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">接下来，让我们准备<code class="fe oc od oe ni b">read</code>和<code class="fe oc od oe ni b">write</code>语句。下面的代码块不一定需要放在<code class="fe oc od oe ni b">BleManager.retrieveServices()</code>回调中。只要确保它被放在<code class="fe oc od oe ni b">BleManager.connect()</code>回调中。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/89b246c43874e95155db708bac69929d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*O5Lzq2O425Tifzu0g2YgOg.png"/></div></figure><ul class=""><li id="3815" class="ll lm iq kg b kh ki kl km kp ln kt lo kx lp lb lq lr ls lt bi translated"><code class="fe oc od oe ni b">BleManager.write()</code>用于向外围设备写入数据。它接受几个强制参数:外设id、服务UUID、特征UUID和字节格式的有效负载。</li><li id="a911" class="ll lm iq kg b kh lu kl lv kp lw kt lx kx ly lb lq lr ls lt bi translated"><code class="fe oc od oe ni b">BleManager.read()</code>用于从外围设备读取数据。接受的参数与write函数相同，只是有效载荷被排除在外。</li></ul><p id="c209" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当<code class="fe oc od oe ni b">BleManager.write()</code>操作成功时，特定的请求将到达外围设备，准确地说是我们之前创建的<code class="fe oc od oe ni b">FoodBankCharacteristic.onWriteRequest()</code>处理程序。这也适用于读操作，它将到达外设上的<code class="fe oc od oe ni b">onReadRequest()</code>处理程序。</p><p id="7354" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">好了，编程的东西到此为止。现在我们来测试一下。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="042a" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">测试BLE通信</h1><p id="dbd4" class="pw-post-body-paragraph ke kf iq kg b kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx nb kz la lb ij bi translated">使用<code class="fe oc od oe ni b">node peripheral</code>启动外围设备。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pa"><img src="../Images/db34c15ece2cd90a33c7f129c582e254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SvDjh7NxzP5IwFJbTYneA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Run the Virtual Peripheral Device</figcaption></figure><p id="2438" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">然后在您的设备上运行移动应用程序。正如我前面所说，这个应用程序需要在实际的移动设备上进行测试，蓝牙功能将无法在模拟器或仿真器上工作。</p><p id="4144" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">应用程序运行后，点击扫描蓝牙设备，然后最近的外围设备列表将弹出，包括我们的食物银行外围设备。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/343086eed64600ddadb989f18a043874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukFrcfk9O2r2U3HDQJBngw.png"/></div></div></figure><p id="30be" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">点击<strong class="kg ir">商店披萨</strong>将测试模式设置为<code class="fe oc od oe ni b">write</code>，然后点击食物银行外围设备，我们将进入第二个屏幕。我们的披萨储存在食物银行外围。太好了！</p><p id="2d74" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">然后试着去拿储存的披萨。做同样的步骤，但现在点击<strong class="kg ir">获取储存的食物</strong>。外设会用存储的食物信息响应我们的read调用，就是<strong class="kg ir">披萨。</strong>因此，该消息来自外设，证明我们的react原生移动应用与外设之间的通信工作正常。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="e832" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">Github示例源代码链接<a class="ae lk" href="https://github.com/novalagung/react-native-ble-read-peripheral" rel="noopener ugc nofollow" target="_blank">https://github . com/novalagung/react-native-ble-read-peripheral</a></p></div></div>    
</body>
</html>