<html>
<head>
<title>A Deep Dive into Prisma Schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Prisma模式的深入探究</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/diving-into-prisma-schema-b278e92dff8b?source=collection_archive---------3-----------------------#2021-08-28">https://javascript.plainenglish.io/diving-into-prisma-schema-b278e92dff8b?source=collection_archive---------3-----------------------#2021-08-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a04df1d8f3ea04851c2a7593339a5b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6Heqd2AK1yxuY83wb2jIA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae jz" href="https://unsplash.com/s/photos/plan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0d91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上一篇文章中，我概述了利用Prisma进行后端开发的好处。如果你还没看过，请在这里阅读。</p><div class="ky kz gp gr la lb"><a rel="noopener  ugc nofollow" target="_blank" href="/simplifying-backend-development-with-prisma-564200f31943"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">使用Prisma简化后端开发</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">Prisma初学者演练，了解我们如何开发灵活和可伸缩的后端。</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jt lb"/></div></div></a></div><p id="7c65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管我们直接用Prisma编写了一个简单的应用程序逻辑，但我们并没有仔细研究它所涉及的大部分方面。</p><p id="d7fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我将简要介绍一下Prisma设置中的主要配置文件:<strong class="kc io">Prisma模式</strong>。</p><p id="cdfc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与上一篇文章类似，我们将关注MySQL数据库的一切工作原理。</p><p id="bbb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们之前使用的所有代码都可以在下面的库中找到。</p><div class="ky kz gp gr la lb"><a href="https://github.com/Pasi-D/Prisma-Starter/" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">GitHub - Pasi-D/Prisma-Starter:一个简单的项目，演示了使用Prisma ◭的简单性</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">一个简单的项目旨在展示使用棱镜◭的简单性。这个演示分为以下几个分支…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">github.com</p></div></div><div class="lk l"><div class="lq l lm ln lo lk lp jt lb"/></div></div></a></div><h1 id="010a" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">让我们在🤿潜水吧</h1><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/853ec78fdcc9f634a8937ee928b9366f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rYQGXpnAZ8nNHvKQVB2fw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Prisma schema we developed so far</figcaption></figure><p id="1ea2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Prisma模式有三个主要部分。</p><ol class=""><li id="cee1" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated">数据源</li><li id="937e" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated">发电机</li><li id="0f32" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated">数据模型定义</li></ol><p id="87f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看他们中的每一个。</p><h2 id="14a3" class="ni ls in bd lt nj nk dn lx nl nm dp mb kl nn no mf kp np nq mj kt nr ns mn nt bi translated"><a class="ae jz" href="https://www.prisma.io/docs/concepts/components/prisma-schema/data-sources" rel="noopener ugc nofollow" target="_blank">数据来源</a></h2><blockquote class="nu nv nw"><p id="42a8" class="ka kb nx kc b kd ke kf kg kh ki kj kk ny km kn ko nz kq kr ks oa ku kv kw kx ig bi translated">Prisma如何连接到数据库由Prisma schema中的<a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference/#datasource" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="in">data source</em></strong></a><strong class="kc io"><em class="in"/></strong>块决定。</p></blockquote><p id="a097" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> ⚠您只能在Prisma模式中指定一个</strong> <a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference/#datasource" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">数据源</strong> </a> <strong class="kc io">块。</strong></p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/7de3476adc7ae4b924a18752e4204c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyvBzlVSISzdqEMe3OgZWQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">datasource block in a nutshell</figcaption></figure><p id="7667" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了<strong class="kc io"> <em class="nx">提供者</em></strong>&amp;<strong class="kc io"><em class="nx">URL</em></strong>字段之外，还有另一个名为<strong class="kc io"><em class="nx">shadowDatabaseUrl</em></strong>的字段，它在管理迁移时很方便。我们将在以后的文章中讨论这个问题。</p><p id="88f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">截至撰写本文时，Prisma已经否决了与多个数据库提供商合作的支持。</p><h2 id="f2c9" class="ni ls in bd lt nj nk dn lx nl nm dp mb kl nn no mf kp np nq mj kt nr ns mn nt bi translated"><a class="ae jz" href="https://www.prisma.io/docs/concepts/components/prisma-schema/generators" rel="noopener ugc nofollow" target="_blank">发电机</a></h2><blockquote class="nu nv nw"><p id="da32" class="ka kb nx kc b kd ke kf kg kh ki kj kk ny km kn ko nz kq kr ks oa ku kv kw kx ig bi translated">当您运行<code class="fe oc od oe of b">npx prisma generate</code>(或<code class="fe oc od oe of b">prisma generate</code>如果您全局安装Prisma)时，将创建的资产由该块的配置决定。</p></blockquote><p id="f75d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Prisma模式可以有一个或多个生成器模块。</p><p id="c5a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下字段可以在此块中修改。</p><ul class=""><li id="4b3f" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx og na nb nc bi translated"><strong class="kc io"> provider </strong>:定义创建哪个Prisma客户端的必填字段。目前只有<code class="fe oc od oe of b">prisma-client-js</code>(即Prisma的JavaScript客户端)是Prisma唯一可用的提供商。<br/>但是，您可以在这里指定遵循Prisma的生成器规范的任何其他文件或<a class="ae jz" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>包。你可以在这里查看来自<a class="ae jz" href="https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators" rel="noopener ugc nofollow" target="_blank">的社区构建生成器列表。</a></li><li id="ee48" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx og na nb nc bi translated"><strong class="kc io">输出</strong>:可选字段，决定生成的客户的位置。默认情况下，该位置路径为<code class="fe oc od oe of b">node_modules/.prisma/client</code></li></ul><p id="135b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您将提供者指定为<code class="fe oc od oe of b">prisma-client-js</code>时，可以在生成器块中解析以下两个字段。</p><ul class=""><li id="d0ee" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx og na nb nc bi translated"><a class="ae jz" href="https://www.prisma.io/docs/concepts/components/prisma-schema/generators#binary-targets" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">binary targets</strong></a>:<code class="fe oc od oe of b">prisma-client-js</code>使用多个引擎二进制文件，这些二进制文件是可执行的二进制文件。因此，在将应用程序部署到特定平台时，使用正确的二进制文件非常重要。<br/>默认情况下，该字段值为<strong class="kc io"><em class="nx"/></strong>。对于本机二进制目标，Prisma检测当前操作系统&amp;自动为客户端指定正确的二进制目标。<br/>您可以从<a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#binarytargets-options" rel="noopener ugc nofollow" target="_blank"> Prisma schema API参考</a>中查看binaryTargets选项列表。</li><li id="bb7d" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx og na nb nc bi translated"><a class="ae jz" href="https://www.prisma.io/docs/concepts/components/preview-features/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">预览功能</strong> </a> : Prisma发布某些只在预览中的功能。它们还没有完全投入生产，但是你可以开始采用它们。Prisma客户端功能标志的完整列表&amp; Prisma模式可以在<a class="ae jz" href="https://www.prisma.io/docs/concepts/components/preview-features/client-preview-features/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。<br/> ⚠如果你希望使用<strong class="kc io"> <em class="nx">预览功能</em> </strong> (s)先与可用的Prisma版本进行交叉检查。</li></ul><h2 id="10f3" class="ni ls in bd lt nj nk dn lx nl nm dp mb kl nn no mf kp np nq mj kt nr ns mn nt bi translated"><a class="ae jz" href="https://www.prisma.io/docs/concepts/components/prisma-schema/data-model" rel="noopener ugc nofollow" target="_blank">数据模型定义</a></h2><p id="3ec7" class="pw-post-body-paragraph ka kb in kc b kd oh kf kg kh oi kj kk kl oj kn ko kp ok kr ks kt ol kv kw kx ig bi translated">让我们看一下我们在上一篇文章中完成的最后一个数据模型。</p><pre class="mq mr ms mt gt om of on oo aw op bi"><span id="6cb4" class="ni ls in of b gy oq or l os ot">model User {<br/>  id        Int     @id @default(autoincrement()) <br/>  username  String  @unique <br/>  email     String  @unique <br/>  posts     Post[] <br/>}</span><span id="f67f" class="ni ls in of b gy ou or l os ot">model Post { <br/>  id        Int     @id @default(autoincrement()) <br/>  title     String <br/>  content   String? <br/>  authorId  Int <br/>  author    User?   @relation(fields: [authorId], references: [id]) <br/>}</span></pre><blockquote class="nu nv nw"><p id="c989" class="ka kb nx kc b kd ke kf kg kh ki kj kk ny km kn ko nz kq kr ks oa ku kv kw kx ig bi translated">现在你可能已经意识到<strong class="kc io"> <em class="in">模型</em> </strong>块负责你的应用领域中的一个实体。它们被映射到表(对于关系数据库)或集合(对于非sql数据库)。</p></blockquote><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ov"><img src="../Images/94b970f8630ea07e3f6e920130a95342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqjmQ87O9uUjzKwHY1Ns2Q.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">model block.</figcaption></figure><p id="3f8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你如何命名你的Prisma模型是非常重要的。默认情况下，它以相同的名称映射到相关的数据库实体。</p><p id="d1a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference/#map-1" rel="noopener ugc nofollow" target="_blank">@@map</a></code>属性，您可以重命名底层数据库实体。</p><pre class="mq mr ms mt gt om of on oo aw op bi"><span id="075e" class="ni ls in of b gy oq or l os ot">model User { <br/>  id        Int @id @default(autoincrement())  <br/>  username  String @unique   <br/>  email     String @unique   <br/>  posts     Post[]</span><span id="71e5" class="ni ls in of b gy ou or l os ot">  @@map("user")<br/>}</span></pre><p id="f297" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过内省更新Prisma模型时，Prisma不遵循特定的约定。它将使用相同的实体名称。在这种情况下，为了在您的模型中保持相同的约定，可以使用属性<code class="fe oc od oe of b">@@map</code>。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ow"><img src="../Images/f5bc70da18b3036e13e7b47d41137703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePFDhwew8xbmZs2DMO3J3w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Its essential to keep a consistency in how you write your application models</figcaption></figure><p id="27d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于两个模型名称&amp;数据库实体名称，我们将坚持使用<a class="ae jz" href="https://techterms.com/definition/pascalcase" rel="noopener ugc nofollow" target="_blank"> pascal大小写约定</a>。</p><p id="2718" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">字段嵌套在模型块中。它们代表了我们的数据库实体的属性。<br/>类似于<code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference/#map-1" rel="noopener ugc nofollow" target="_blank">@@map</a></code>用于模型名，我们可以使用<code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference/#map" rel="noopener ugc nofollow" target="_blank">@map</a></code>属性来重命名数据库实体中映射的属性名。</p><p id="e727" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">说到字段，有两种类型</p><ul class=""><li id="0592" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx og na nb nc bi translated">标量字段</li><li id="c4df" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx og na nb nc bi translated">关系字段</li></ul><p id="2ff4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="nx">标量字段</em> </strong></p><p id="6eac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在模型中使用的一般数据类型，如<em class="nx"> Int </em>、<em class="nx"> String </em>就属于这种类型。</p><p id="07fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们之前使用的数据源连接器决定了每个Prisma标量类型如何映射到底层的本地数据库类型。</p><p id="04f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们使用的是MySQL，下面是每个标量字段的映射方式。这些字段包括某些属性，这些属性有助于调整底层数据库实体的形状。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">model field scalar types in MySQL database</figcaption></figure><p id="f1a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="nx">关系字段</em> </strong></p><p id="eda3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Prisma模型上的某些字段没有标量类型。相反，他们的类型是另一种模式。这些字段是关系字段。</p><p id="3347" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们构建的数据模型中，有一个一对多的关系，一个用户可以有多个Post记录&amp;一个Post记录有一个用户。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/a38058aedfc7025b453153f7997ffc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*aJUfI4AKHK7DHxHd8n3AHA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">author relation field in Post model</figcaption></figure><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/bf01d64ad16b72cf68c85462ce1fc2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*hSVEQLqHtnnUinIWLi4MDQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">posts relation field in User model</figcaption></figure><p id="6c07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些关系字段不会映射到基础数据库实体中。它们用于生成Prisma客户端。</p><p id="35cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oc od oe of b">@relation</code>属性只能应用于关系字段。通常，当您需要向模型中的标量字段添加外键约束时，就会用到这一点。</p><h1 id="24de" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">属性</h1><p id="c21f" class="pw-post-body-paragraph ka kb in kc b kd oh kf kg kh oi kj kk kl oj kn ko kp ok kr ks kt ol kv kw kx ig bi translated">到目前为止，我们已经看到了诸如<a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference/#map-1" rel="noopener ugc nofollow" target="_blank"> @@map，</a> @relation，@unique等属性。这些会改变字段或模型块的行为。有两种类型的属性可以添加到数据模型中。</p><ol class=""><li id="8a64" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated">字段属性—前缀为@(例如:<code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#id" rel="noopener ugc nofollow" target="_blank">@id</a></code>)</li><li id="2f73" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated">阻止属性—前缀为@@(例如:<code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#map-1" rel="noopener ugc nofollow" target="_blank">@@map</a></code>)</li></ol><p id="ea3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将看看与关系数据库一起工作的一些属性。</p><p id="081d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#id" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">@id</strong></a></code></p><p id="45e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该属性有助于将字段标记为数据库实体的唯一标识符。它映射到底层关系数据库中的<code class="fe oc od oe of b">PRIMARY KEY</code>。</p><p id="69c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#id-1" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">@@id</strong></a></code></p><p id="0dcf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了在关系数据库中创建复合主键，可以利用这一点。</p><p id="72b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以用用户名和电子邮件在用户模型中创建一个复合主键来替换id字段。</p><pre class="mq mr ms mt gt om of on oo aw op bi"><span id="3914" class="ni ls in of b gy oq or l os ot">model User { <br/>  username  String<br/>  email     String<br/>  posts     Post[]</span><span id="5dd1" class="ni ls in of b gy ou or l os ot">  @@id([username, email])<br/>}</span></pre><p id="6de7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，可以用<code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#unique" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">@@unique</strong></a></code>生成一个复合唯一键</p><pre class="mq mr ms mt gt om of on oo aw op bi"><span id="29a6" class="ni ls in of b gy oq or l os ot">model User {  <br/>  id         Int      @id @default(autoincrement()) <br/>  username   String   <br/>  email      String   <br/>  posts      Post[]  <br/> <br/>  @@unique([username, email]) <br/>}</span></pre><p id="da7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了这些属性之外，您还可以在<a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#attributes" rel="noopener ugc nofollow" target="_blank"> Prisma模式参考</a>文档中详细阅读其他属性。</p><p id="cd5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除此之外，还有属性函数。</p><p id="fe65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#autoincrement" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">autoincrement()</strong></a></code></p><p id="550f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在MySQL这样的关系数据库中，这映射到<code class="fe oc od oe of b">AUTO_INCREMENT</code>，数据库将增加数字ID值。</p><p id="f2df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#uuid" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">uuid()</strong></a></code></p><p id="9885" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将生成一个UUID字符串。</p><p id="c1a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oc od oe of b"><a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#now" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">now()</strong></a></code></p><p id="1b1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将设置当前时间戳。MySQL &amp;中的<code class="fe oc od oe of b">CURRENT_TIMESTAMP()</code>映射与<code class="fe oc od oe of b">DateTime</code> Prisma标量类型兼容。</p><p id="8626" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">属性函数的完整列表也可参考<a class="ae jz" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#attribute-functions" rel="noopener ugc nofollow" target="_blank"> Prisma模式参考</a>。</p><h2 id="b934" class="ni ls in bd lt nj nk dn lx nl nm dp mb kl nn no mf kp np nq mj kt nr ns mn nt bi translated">结论</h2><p id="d180" class="pw-post-body-paragraph ka kb in kc b kd oh kf kg kh oi kj kk kl oj kn ko kp ok kr ks kt ol kv kw kx ig bi translated">我们将从这里结束这篇文章。在下一篇文章中，我们将考虑简单的博客场景，采用一种实用的方法来建模我们的数据。</p><p id="f1b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nx">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>