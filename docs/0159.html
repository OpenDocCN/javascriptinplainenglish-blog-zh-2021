<html>
<head>
<title>Why Props References Break Optimizations in React + React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Props引用会破坏React + React Native中的优化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-why-props-references-break-optimizations-79c463ca0723?source=collection_archive---------8-----------------------#2021-01-09">https://javascript.plainenglish.io/react-native-why-props-references-break-optimizations-79c463ca0723?source=collection_archive---------8-----------------------#2021-01-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="73d3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">编写优化时要小心props引用</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1d2519ea49b9aa94b1cbb15e65ea0362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eNkiQfKMmhBIqfKSP0r69Q.jpeg"/></div></div></figure><p id="9cdb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">大部分时间反应都很快。但有时，由于繁重的计算，它会变慢，这时我们需要测量和优化我们的组件，以避免“浪费渲染”。</p><p id="7a38" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">优化是有代价的，如果做得不好，情况可能会变得更糟。在今天的博文中，我们开始了解渲染过程，了解浪费渲染的原因，解决方案&amp;它是如何被破坏的。</p><h2 id="1a27" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">目录</h2><ul class=""><li id="9b7d" class="md me in kq b kr mf ku mg kx mh lb mi lf mj lj mk ml mm mn bi translated"><strong class="kq io">什么是“渲染”？:</strong>流程概述，呈现&amp;提交阶段</li><li id="bf9d" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">标准渲染行为:</strong>渲染阶段浪费渲染的原因</li><li id="494c" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">提升渲染性能:</strong>一些技巧</li><li id="8d0f" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">新道具引用如何破坏优化:</strong>问题的细节</li><li id="8fca" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">优化道具参考:</strong>使用备忘录&amp;使用回调</li><li id="2981" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">记忆一切？</strong></li></ul><h1 id="a4b2" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">什么是“渲染”？</h1><p id="1bc6" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated"><strong class="kq io">渲染</strong>是React要求你的组件在当前的道具和状态组合下，描述部分UI是什么样子的过程。</p><h2 id="e3e6" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">流程概述</h2><p id="d913" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">在这个过程中，React将从组件树的根开始，向下循环查找标记为需要更新的组件。对于每个被标记的组件，它将调用<strong class="kq io"> render() </strong>(对于类组件)或<strong class="kq io"> FunctionComponent() </strong>(对于函数组件)，并保存渲染输出。</p><p id="1468" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">组件渲染器的输出被写入<strong class="kq io"> JSX </strong>。无论是来自<strong class="kq io"> render() </strong>还是<strong class="kq io"> FunctionComponent() </strong>，输出最终变成<strong class="kq io"> ReactElement </strong>。这些元素一起用于形成虚拟树(tempt tree)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/07548167324734419c61e074ab271c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-5em1cnHXile0O-yzytGw.png"/></div></div></figure><p id="fffc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在收集新的树之后，React将对其进行比较，收集需要应用的所有更改的列表，以使真正的树看起来像当前期望的输出。这个过程叫做<a class="ae ni" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">对账</strong> </a>。</p><p id="82d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以上是创建<strong class="kq io">主机树</strong>(树输出)的非常基本的过程。基于不同平台(web、移动设备等)，主机树可以是各种类型。丹·阿布拉莫夫在这里  <strong class="kq io">为它写了很棒的解释<a class="ae ni" href="https://overreacted.io/react-as-a-ui-runtime/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">。</strong></a></strong></p><p id="2fec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React团队将上述工作分为两个阶段:</p><ul class=""><li id="fec6" class="md me in kq b kr ks ku kv kx nj lb nk lf nl lj mk ml mm mn bi translated">“<strong class="kq io">渲染阶段</strong>”包含渲染组件和计算变化的所有工作。</li><li id="931a" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">“<strong class="kq io">提交阶段</strong>”是将这些更改应用到主机树的过程。</li></ul><h1 id="85ab" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">React Native的更多层(如果您不感兴趣，可以跳过这一步继续)</h1><p id="1759" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">React Native创建一个树层次结构来定义初始布局，并在每次布局更改时创建该树的diff，如上所示。除了React Native通过几个架构层来管理UI更新，这些层最终会转换视图应该如何呈现。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="4ceb" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">1.Yoga布局引擎</h2><p id="8871" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated"><a class="ae ni" href="https://github.com/facebook/yoga" rel="noopener ugc nofollow" target="_blank"> Yoga </a>是一个用C编写的跨平台布局引擎，通过绑定到原生视图<em class="no">(Java Android Views/Objective-C iOS ui kit)</em>来实现Flexbox。</p><p id="ceeb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React-Native中各种视图、文本和图像的所有布局计算都是通过yoga完成的，这基本上是我们的视图显示在屏幕上之前的最后一步</p><h2 id="ad1b" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">2.阴影树/阴影节点</h2><p id="b4d8" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">当react-native发送命令来呈现布局时，一组影子节点被组装来构建影子树，该影子树表示布局的可变本地侧(即:用相应的本地语言编写，Android用Java，iOS用Objective-C)，然后被翻译成屏幕上的实际视图(使用Yoga)。</p><h2 id="7989" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">3.视图管理器</h2><p id="05c5" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">ViewManger是一个接口，它知道如何将来自JavaScript的视图类型转换成它们的本地UI组件。视图管理器知道如何创建一个影子节点、一个本地视图节点和更新视图。在React-Native框架中，有许多ViewManager支持使用本地组件。例如，如果有一天您想创建一个新的定制视图并将其添加到react-native中，那么该视图必须实现ViewManager接口</p><h2 id="5255" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">4.UIManager</h2><p id="0ff4" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">UIManager是拼图的最后一块，或者实际上是第一块。JavaScript JSX声明性命令作为命令性命令发送给本机，告诉React-Native如何一步一步迭代地布局视图。因此，作为第一次呈现，UIManager将发送命令来创建必要的视图，并将随着应用程序的UI随时间的变化继续发送更新差异。</p><p id="dd31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以React-Native基本上仍然使用React的能力来计算以前和当前呈现表示之间的差异，并相应地将事件分派给UIManager。</p><h1 id="e201" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated"><strong class="ak">标准渲染行为</strong></h1><p id="43da" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">重要的是:</p><p id="651e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> React的默认行为是，当一个父组件渲染时，React会递归渲染<em class="no">其内部的所有</em>子组件！</strong></p><p id="f32d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，假设我们有一棵<strong class="kq io">A&gt;B&gt;c</strong>的组件树</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/dc3479978b528a434149fcdd7c4020b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_YysWA8NaJ1LUUGQ1yP5hg.png"/></div></div></figure><ul class=""><li id="d5de" class="md me in kq b kr ks ku kv kx nj lb nk lf nl lj mk ml mm mn bi translated">我们在<strong class="kq io"> B </strong> ( <strong class="kq io">设置状态</strong>或<strong class="kq io">设置使用状态</strong>)中触发重新渲染。</li><li id="5fdd" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">React从树的顶部开始渲染过程</li><li id="3ff4" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">React发现<strong class="kq io"> A </strong>没有被标记为需要更新，并跳过它</li><li id="3796" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">React看到<strong class="kq io"> B </strong>被标记为需要更新，并呈现它。<strong class="kq io"> B </strong>像上次一样返回<strong class="kq io"> &lt; C / &gt; </strong>。</li><li id="a070" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io"> C </strong>不是<em class="no">而是</em>最初被标记为需要更新。但是，因为其父级<strong class="kq io"> B </strong>被渲染，React现在向下移动，并且也渲染<strong class="kq io"> C </strong>。</li></ul><p id="f84a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，很可能大多数组件会像上次一样返回精确的渲染结果，因此，React不需要对真实的树进行更改。然而，React仍然需要组件自己重新渲染，并区分渲染输出。这两者都需要时间和精力，尤其是当组件很大并且计算量很大的时候。</p><p id="05b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是浪费渲染是如何发生的。</p><h1 id="068c" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated"><strong class="ak">提高渲染性能</strong></h1><p id="f324" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">渲染是React的正常预期部分。同样，如果组件的渲染输出没有改变，那么有时工作是浪费的，树的这一部分不需要更新。</p><p id="1eb1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">渲染应该总是基于组件的当前<strong class="kq io">属性和状态</strong>。如果我们提前知道道具和状态不会改变。渲染输出不会改变，那么我们可以安全地跳过该组件的渲染过程。</p><p id="85e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">说到优化，你可以让它运行得更快或者做更少的工作。大多数React优化都是为了做更少的工作。</p><blockquote class="nq"><p id="ebfe" class="nr ns in bd nt nu nv nw nx ny nz lj dk translated">请记住在任何优化之前进行测量，这样您就不会过早地进行优化。</p></blockquote><p id="5032" class="pw-post-body-paragraph ko kp in kq b kr oa jo kt ku ob jr kw kx oc kz la lb od ld le lf oe lh li lj ig bi translated">React提供了三个主要的API来跳过组件的渲染。</p><ul class=""><li id="c9e2" class="md me in kq b kr ks ku kv kx nj lb nk lf nl lj mk ml mm mn bi translated"><a class="ae ni" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">做出反应。component . should component update</strong></a><strong class="kq io">:</strong>组件生命周期发生在渲染过程的早期。(发生在更新生命周期)。如果返回<strong class="kq io">假</strong>，React将跳过渲染组件。默认情况下，它总是返回<strong class="kq io"> true </strong>，所以当你需要跳过渲染组件时，你可以添加你自己的逻辑。通常，当我们定制这个生命周期时，我们比较旧的道具，用新的道具陈述，如果没有变化，返回<strong class="kq io"> false </strong>。</li><li id="df0d" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><a class="ae ni" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">做出反应。pure component:</strong></a><strong class="kq io"/>由于道具和状态的比较是实现<strong class="kq io"> <em class="no"> shouldComponentUpdate最常见的方式。默认情况下，PureComponent </em> </strong>是实现该行为的基类。可以用<strong class="kq io">代替React。component+shouldcomponentdupdate。</strong></li><li id="9671" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><a class="ae ni" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">react . memo</strong></a><strong class="kq io">:</strong>内置<a class="ae ni" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">高阶组件</strong> </a> <strong class="kq io">。</strong>它接受您的组件并返回一个新的包装组件。包装组件的默认行为是检查是否有任何属性已经改变，如果没有，它阻止渲染。它也接受你为比较工作定制的逻辑，通常这是用来比较特定的道具，而不是所有的道具。</li></ul><p id="3000" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所有这些方法都使用一种叫做<em class="no">浅相等</em>的比较技术。这意味着检查两个不同对象中的单个字段，并查看对象内容中是否有任何差异。该技术与<strong class="kq io"> === </strong>相比，是JS引擎可以做到的一种简单快速的方式。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/6d71f4585badf326dc694642d246e66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_auVS8CZsalet-Ku-feZQ.png"/></div></div></figure><h1 id="8fd8" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated"><strong class="ak">新道具引用如何破坏优化</strong></h1><p id="ee80" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">正如我们在上面的<strong class="kq io">浅相等</strong>中所学的技术，很明显传递新对象会使比较失败，因为“===”比较<strong class="kq io">引用</strong>，即使内容没有改变。这打破了我们的优化，组件仍然呈现，但是<strong class="kq io">浪费了更多的diffing努力，</strong>通过道具比较进行diffing&amp;diffing tree。小心点！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/84f1817a4b8c933019d53922f8031f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pK9-_GaHJ6XfHgBfJNnzgQ.png"/></div></div></figure><p id="c5b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在示例中，我们将<strong class="kq io"> onClick </strong>和<strong class="kq io">数据</strong>作为道具传递给<strong class="kq io"> MemoizedChildComponent </strong>。尽管我们优化了ChildComponent，但它仍然会重新呈现每个更新的ParentComponent。因为<strong class="kq io"> MemoizedChildComponent的道具每次都会获得新的对象。</strong></p><p id="71db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们期望<strong class="kq io"> MemoizedChildComponent </strong>跳过渲染，因为它的道具内容是相同的。让我们继续，想办法解决这个问题。</p><h1 id="359f" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">优化道具引用</h1><p id="d7b2" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">类组件不必担心意外创建新的回调对象引用，因为它们可以拥有总是相同引用的实例方法。但是，他们可能需要为单独的子列表项生成唯一的回调，或者在匿名函数中捕获一个值并将其传递给子列表项。这导致了新的对象，React没有内置任何优化这些情况的功能。</p><p id="7653" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数组件，React提供了两个钩子<a class="ae ni" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> useCallback </strong> </a>(用于回调函数)和<a class="ae ni" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> useMemo </strong> </a>(用于创建对象或复杂计算等任何类型的数据)。</p><blockquote class="og oh oi"><p id="9ec8" class="ko kp no kq b kr ks jo kt ku kv jr kw oj ky kz la ok lc ld le ol lg lh li lj ig bi translated">这篇文章的目的是引出问题，而不是讲授钩子，我相信有很多资料可以很好地解释这些钩子。所以这里就不赘述了。也许在下一个帖子里，谁知道^^对不对</p></blockquote><h1 id="9835" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">回忆一切？</h1><p id="55de" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">显然<strong class="kq io">不</strong>，每一次优化都是有代价的。粗心的优化最终会使性能更差，总是先测量，通过React devtool或任何你喜欢的，找到瓶颈，然后优化。</p><p id="abab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它并不总是有益的，如果是的话，React会将它作为默认实现，对吗？:D</p><p id="8843" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Kent C. Dodds提到了一个案例，在这里<strong class="kq io">使用回调</strong>比<a class="ae ni" href="https://kentcdodds.com/blog/usememo-and-usecallback" rel="noopener ugc nofollow" target="_blank">更糟</a>。还有我最喜欢的丹的推特:</p><blockquote class="og oh oi"><p id="3828" class="ko kp no kq b kr ks jo kt ku kv jr kw oj ky kz la ok lc ld le ol lg lh li lj ig bi translated">为什么React默认不把memo()放在每个组件周围？不是更快吗？要不要做个标杆来检验？问问你自己:为什么不把Lodash memoize()放在每个函数周围？那不是让所有功能都更快了吗？我们需要一个基准吗？为什么不呢？</p></blockquote><h1 id="1cf6" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated"><strong class="ak">总结</strong></h1><p id="6443" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">好了，这篇帖子到此结束。</p><p id="eee1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">总的来说，React的渲染过程渲染子组件是因为更新了父组件，这并不坏，这就是React了解变化的方式。并且有时渲染工作是浪费的。</p><p id="91de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">跳过渲染是一种常见的优化方式，这项工作与<strong class="kq io">道具引用</strong>有很大关系。小心优化，不要过早优化。</p><p id="f28f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">道具参考的问题不止这些。最近，我喜欢Ben的<a class="ae ni" href="https://t.co/ysL6qYw1KW" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">文章</strong> </a>关于它如何影响useEffect hook中的依赖关系。</p><p id="ad40" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于任何进一步的问题或意见，让我知道。谢谢！</p></div></div>    
</body>
</html>