# React 中的受控和非受控组件—简单的方法

> 原文：<https://javascript.plainenglish.io/controlled-and-uncontrolled-components-in-react-the-easy-way-60c44597a55f?source=collection_archive---------6----------------------->

![](img/ce86edb9c33ef0b4512070fa34308557.png)

Photo by [Ferenc Almasi](https://unsplash.com/@flowforfrank?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

当开始使用 React 时，您可能经常从您的团队成员或一些网络文章中听到这两个术语。我知道当你不好意思问，不得不点头时，这变得很尴尬。不过，你现在不必担心。我会尽力向你解释它们是什么。

> *根据 React 文档—*在受控组件中，表单数据由 React 组件处理。另一种方法是不受控制的组件，表单数据由 DOM 本身处理。

*当您编写 React 组件时，组件可以从两个来源获取要显示的数据*

1.  *来自 DOM*
2.  *从道具*

> *DOM 是浏览器为显示网页而创建的符号。DOM 由节点和对象组成。*

***DOM 如何向组件发送数据？***

*您现在可能想知道 DOM 如何成为组件的数据源。为了更好的理解，我们来举个例子。*

*Uncontrolled Component*

*在上面的代码中，有一个`input`元素，其上附加了一个`ref`。对于那些不知道的人来说，可以把它看作是可以访问附加了`ref`的 DOM 节点的属性的人。现在当`App`第一次渲染时，你会看到一个空的`input`框和一个`Submit`按钮。当你向它输入一些东西时，它会记住这个值并显示出来。但是在代码中，你不会有任何关于值类型的信息。为了获得类型化的值，我们必须从 DOM 中"**提取"**数据。参见`Submit`按钮的`onClick`。它显示一个报警，其值存储在`input`框中。这里的`inputRef`用于从 DOM 中提取数据。*

***这里发生了什么？***

*DOM 维护自己的内部状态，当您在输入框中键入一些值时，它会得到更新。然后,`input`组件读取更新后的状态并显示值。所以这种类型的组件是**不受控制的**，因为 DOM 正在为组件管理数据。要访问这些数据，我们只需单击 Submit 按钮就可以从 DOM 中读取。*

*不受控制的组件允许您创建元素，而无需立即管理它们的状态。然而，这限制了你使你的 UI 成为所谓的“**反应式**”的能力*

*考虑这个场景:*您想要构建一个表单，让您的用户订阅您的博客，这样当您发布一些有趣的博客时，他们可以收到电子邮件。该表单将有一个输入框，让用户填写他们的电子邮件，并提交按钮，以确认提交。您有一个特殊的请求——只有当用户在输入框中填写了有效的电子邮件时，您才会启用提交按钮。这可以让用户在你的网站上有一个没有错误的体验。**

*让我们想想如何解决这个问题。我们必须时刻关注用户输入的电子邮件值，验证电子邮件，并动态启用按钮。所以你会写这样的东西:*

*Controlling button state with Uncontrolled Component*

*您会注意到，这还不完整。因为在`button`组件中，我们不知道如何根据邮件值动态启用按钮。另外，`refs`不触发组件的重新渲染(这就是`refs`的意思)😐 ).我们只能通过点击提交按钮来访问电子邮件值，但是如果它被禁用了，我们怎么能点击呢(哦，上帝，我们都做了些什么😅).*

*这就是我正在谈论的问题。对于不受控制的组件，您可以访问状态中的组件值，这样您就无法知道它们是何时更改的。因此，您不能让您的 UI**与不受控制的组件“反应”。这就是**控制的**部件来救援的地方。***

# ***受控组件***

***受控组件接受两个道具-***

*   ***prop1 —告知组件的当前值***
*   ***prop2 —更改该值的回调***

*****值受控部件触发回调更新值…*****

***这些组件遵循上述周期来反映数据变化。下面是**受控组件的例子:*****

***Controlled Component***

***在上面的例子中，`input`框的值是通过`value`属性传递的。`onChange`回调用于更新`input`中的变化，更新`value`道具。现在`App`组件知道了电子邮件的值，并且可以验证和执行**“反应式”**想要做的任何事情。***

*****这里发生了什么？*****

***我知道看着它可能听起来让人不知所措。但是不要担心，我会告诉你更新是如何发生的。***

1.  *****第一次呈现** —当组件第一次加载时，它会将状态中存储的初始值传递给盒子。对于`input`，`value`道具永远是真理的源泉。如果你仔细注意，我们已经传递了一些初始值给`useState()`。所以首先，当我们经过它时，它会显示`Initial Value`字符串。***
2.  *****你把整个单词**删掉——当`input`有任何变化的时候，回调总是被调用。所以当我们把整个世界删除后，`onChange`就会被调用。在`onChange`我们会收到`event`道具。当我们删除`input`框中的单词时，它触发了一个事件来调用`onChange`回调。这个`event`对象存储由`input`在删除时触发的事件(你可以在 MDN [docs](https://developer.mozilla.org/en-US/docs/Web/API/Event) 中读到事件)。为了在事件被触发时访问值`input`，我们通过`event.target.value`来访问它。现在，这个值由`setValue`函数在我们的状态中更新。当我们的状态改变时，它触发`App`重新渲染。由于这种重新渲染，传递给`input`框的`value`属性得到更新，因此我们看到了更新后的值。这发生得非常快；它看起来是实时的。***
3.  *****你输入‘a’**—如步骤 2 所述，同样的循环再次进行。`onChange` 回调将被触发并更新状态。状态改变将导致`App`重新渲染并更新`value`道具收件箱。***

***让我们回到我们面对**不受控组件的问题。**我们无法动态切换按钮的“开”或“关”。通过控制输入状态并将其作为用户类型进行验证，我们可以很容易地做到这一点。请参见下面的代码:***

***Controlling button’s state with email value***

***简而言之，**受控组件**让您能够控制传递给某个组件的数据，最终让您能够以**“反应式”**方式执行操作。***

# ***结论***

***现在，您应该已经了解了这两种类型组件的要点。现在，您可以应用这些知识来确定您想要使用哪个组件。我总是建议你知道你的组件的用途，并相应地使用它们。***

***这是我第一次尝试写博客。希望你喜欢它。请在评论中分享你的反馈。如果你喜欢它的内容，请关注更多这样有趣的博客帖子。***

****更多内容尽在*[*plain English . io*](http://plainenglish.io/)***