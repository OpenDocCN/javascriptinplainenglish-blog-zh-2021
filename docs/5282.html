<html>
<head>
<title>RxJs Challenge: Spot the Mistake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJs挑战:发现错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rxjs-challenge-spot-the-mistake-fa4fbd163135?source=collection_archive---------2-----------------------#2021-10-29">https://javascript.plainenglish.io/rxjs-challenge-spot-the-mistake-fa4fbd163135?source=collection_archive---------2-----------------------#2021-10-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d1c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我已经用RxJs流烧伤了自己(一点点),所以你不必这样做。欢迎来到RxJs上的这个简短的调试之旅，它触及了一些中级/高级流主题——无论您是否会看到错误的到来，这也是一个挑战。</strong></p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="68f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的团队在Angular + Node.js中工作。在适用的时候，我们使用适当的具有严重反应影响的OO(RxJs)。我们是务实的程序员:快速完成工作，保持简短和可维护，我们不相信银弹:总是尝试使用最合适的解决方案。</p><p id="dab6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在做游戏的后台逻辑。游戏可能会有一些机器人参与游戏。当游戏开始时(<code class="fe kp kq kr ks b">start</code>事件)，我们将每隔100毫秒为机器人生成进度事件，直到<code class="fe kp kq kr ks b">finish</code>事件。按照这些思路，实际的用例要复杂一些。</p><p id="c34d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我将简化很多:主要代码在<code class="fe kp kq kr ks b">ProgressGenerator</code>类中，只占其原始大小的一小部分。此外，在调试时，我在一个测试用例中工作，这不是特别方便，所以这里我们将有一个小的测试环境。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/1e61ae1c710a26b0ad16fb818431a034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOyzJ7yr3TAVc-vbB-4L6w.jpeg"/></div></div></figure><h1 id="1ea7" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1.初始方法</h1><p id="3fda" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">这是主要逻辑的第一个版本，这碰巧是我比较满意的第一个版本。很多东西都被省略了。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d9ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我创建了一些绿色的基本测试，然后我继续进行面向流的测试。(<a class="ae mk" href="https://rxjs.dev/guide/testing/marble-testing" rel="noopener ugc nofollow" target="_blank">大理石检测</a>，真的很厉害！)而下一个测试就破了。</p><blockquote class="ml mm mn"><p id="d410" class="jk jl mo jm b jn jo jp jq jr js jt ju mp jw jx jy mq ka kb kc mr ke kf kg kh ig bi translated"><strong class="jm io">挑战:</strong>试着找出上面代码中的错误！哪里会破？为什么呢？以及如何修复？</p></blockquote><h2 id="4f6d" class="ms lg in bd lh mt mu dn ll mv mw dp lp jv mx my lt jz mz na lx kd nb nc mb nd bi translated">运行示例</h2><p id="a6f6" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我主要是在一个不太方便的测试用例中工作，所以对于本文，我创建了这个小的测试运行器。它发出一个<code class="fe kp kq kr ks b">start</code>事件，然后在500ms内发出一个<code class="fe kp kq kr ks b">finish</code> <em class="mo"> </em>事件；它再次等待500毫秒，最后执行拆卸。</p><p id="466c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们预计在<code class="fe kp kq kr ks b">start</code>和<code class="fe kp kq kr ks b">finish</code>事件之间的每100毫秒<code class="fe kp kq kr ks b">progress$</code>会触发一次。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0545" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">省略了<code class="fe kp kq kr ks b">loadProgressGenerator</code>。简而言之，它加载了存储库中提供的5个示例之一。在此阅读<a class="ae mk" href="https://github.com/igabesz/rxjs-challenge/blob/master/src/run-example.ts" rel="noopener ugc nofollow" target="_blank">完整源代码</a>。</p><h2 id="bfbe" class="ms lg in bd lh mt mu dn ll mv mw dp lp jv mx my lt jz mz na lx kd nb nc mb nd bi translated">第一次尝试的结果</h2><p id="751e" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">剧透:不是我预想的那样。</p><pre class="ku kv kw kx gt ne ks nf ng aw nh bi"><span id="74b3" class="ms lg in ks b gy ni nj l nk nl">Starting<br/>p 0<br/>p 1<br/>p 2<br/>p 3<br/>Finished -- no "p" logs expected below this<br/>p 4<br/>p 5<br/>p 6<br/>p 7<br/>p 8<br/>Teardown</span></pre><p id="e99d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间间隔应该在<code class="fe kp kq kr ks b">Finished</code>日志之后停止——然而它没有。出事了。这意味着…调试时间！🎉</p><blockquote class="ml mm mn"><p id="1a29" class="jk jl mo jm b jn jo jp jq jr js jt ju mp jw jx jy mq ka kb kc mr ke kf kg kh ig bi translated"><strong class="jm io">挑战</strong>:如果你已经明白了一切，那么恭喜你！(很高兴是你。)如果没有，试着在笑点之前搞清楚发生了什么。</p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nm"><img src="../Images/2c2da86ac75a286be91426be8391ce16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hKf15KitHXrm6D2J"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk">Best friend during debugging and showering.</figcaption></figure><h1 id="d14a" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">2.排除故障</h1><p id="d28e" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我没有立即意识到这个错误，所以我添加了2个调试订阅和2个<em class="mo"> tap </em>操作符，来看看到底发生了什么:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8b03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是包含调试消息的日志:</p><pre class="ku kv kw kx gt ne ks nf ng aw nh bi"><span id="093f" class="ms lg in ks b gy ni nj l nk nl">Starting<br/>p 0<br/>p 1<br/>p 2<br/>p 3<br/>Finished -- no "p" logs expected below this<br/>startEnded 1<br/>p 4<br/>p 5<br/>p 6<br/>p 7<br/>p 8<br/>Teardown<br/>destroyed!</span></pre><p id="7a49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看起来<code class="fe kp kq kr ks b">startEnded 1</code>被正确地发射了，然而<code class="fe kp kq kr ks b">startEnded 2</code>和<code class="fe kp kq kr ks b">startEnded TAP</code>却没有。这就是为什么在<code class="fe kp kq kr ks b">finish</code>事件上没有完成间隔的原因。</p><p id="f589" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是相同的可观测性，对吗？后面几种情况为什么不火？而为什么音程只有<code class="fe kp kq kr ks b">destroyed$</code>流完成？(正如<code class="fe kp kq kr ks b"><em class="mo">destroyed!</em></code>消息告诉我们的)。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="nr mj l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk">I didn’t like this.</figcaption></figure><p id="9f07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我试图排除所有我能想到的愚蠢错误。然后我开始责怪RxJs，因为他们一定破坏了他们的测试工具或者其他什么……是的，当然，总是库的创建者有错。(是时候做一个快速的现实检查了。)</p><h2 id="e6eb" class="ms lg in bd lh mt mu dn ll mv mw dp lp jv mx my lt jz mz na lx kd nb nc mb nd bi translated">RxJs中间材料</h2><p id="5f29" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">让我们退后一点。是时候回到一些RxJs的基础知识了。</p><blockquote class="ml mm mn"><p id="5701" class="jk jl mo jm b jn jo jp jq jr js jt ju mp jw jx jy mq ka kb kc mr ke kf kg kh ig bi translated"><strong class="jm io">亮点1 </strong>:一个可观察的只是一个蓝图，直到有人真正订阅。</p></blockquote><p id="7f46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，我们知道这一点，无论如何这都不是问题。我们继续吧。</p><p id="f9b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，每个RxJs订阅都构建自己的从流源到订阅的操作符管道。例如，如果可观察对象中有一个生成随机数的操作符，那么两个相同的订阅将会不同。这可能有点违背直觉，尤其是当你使用局部/成员变量时，比如这里的<code class="fe kp kq kr ks b">this.startEnded$</code>流。</p><blockquote class="ml mm mn"><p id="bd4e" class="jk jl mo jm b jn jo jp jq jr js jt ju mp jw jx jy mq ka kb kc mr ke kf kg kh ig bi translated"><strong class="jm io">高亮2 </strong>:默认情况下，每个订阅都建立自己的运营商管道。</p></blockquote><p id="4ffd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以对此进行调整(<code class="fe kp kq kr ks b">share</code>操作符即将推出),但这是经验法则。</p><p id="51bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们添加第三个反应智慧的金块。它是关于<a class="ae mk" href="https://luukgruijs.medium.com/understanding-hot-vs-cold-observables-62d04cf92e03" rel="noopener">热点观察</a>。冷观察点发送相同的数据，而不管订阅时间。但是对于热点观察，如果你订阅得太晚，你很容易迟到。</p><blockquote class="ml mm mn"><p id="4295" class="jk jl mo jm b jn jo jp jq jr js jt ju mp jw jx jy mq ka kb kc mr ke kf kg kh ig bi translated"><strong class="jm io">亮点三</strong>:订阅一个热门可观察到的东西取决于你订阅的时间。</p></blockquote><p id="26ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你猜怎么着:T8是一个热门的观测对象。</p><h2 id="5c56" class="ms lg in bd lh mt mu dn ll mv mw dp lp jv mx my lt jz mz na lx kd nb nc mb nd bi translated">真正的原因</h2><p id="d9b2" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">有了这个，你就有了把这些碎片拼在一起的一切。那么让我们继续讨论结论。或者说，笑点。</p><p id="5b66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此第一个调试订阅是在构造函数时创建的。它接收<code class="fe kp kq kr ks b">start</code>和<code class="fe kp kq kr ks b">finish</code>事件。<code class="fe kp kq kr ks b">pairwise</code>第一次发射需要2个输入——注意，它在第一次输入时不发射任何东西。但在这种情况下，是可以的；这种订阅效果很好。</p><p id="ed1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是第二个订阅内置在<code class="fe kp kq kr ks b">onStart</code>调用中——第三个订阅隐藏在<code class="fe kp kq kr ks b">takeUntil(this.startEnded$)</code>操作符中。这两个都是在<code class="fe kp kq kr ks b">start</code>事件之后构建的——它们只接收<code class="fe kp kq kr ks b">finish</code>事件，并且它们管道中的<code class="fe kp kq kr ks b">pairwise</code>操作符开始等待下一个事件。但这并没有发生。</p><p id="a386" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以TL；DR:第二个订阅和<code class="fe kp kq kr ks b">takeUntil(this.startEnded$)</code>错过了<code class="fe kp kq kr ks b">start</code>事件，因此它们没有正确地检测到Started状态的结束。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ns mj l"/></div></figure><h1 id="845d" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">固定的；不变的</h1><p id="9178" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">最后，我明白了问题所在。由于第一个订阅工作正常，我们只需确保<code class="fe kp kq kr ks b">startEnded$</code>上的每个订阅都使用相同的操作符管道，对吗？因此，解决方案就在操作员的手边:<code class="fe kp kq kr ks b">share</code>。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b6d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我得到了期待已久的结果:</p><pre class="ku kv kw kx gt ne ks nf ng aw nh bi"><span id="5189" class="ms lg in ks b gy ni nj l nk nl">Starting<br/>p 0<br/>p 1<br/>p 2<br/>p 3<br/>Finished -- no "p" logs expected below this<br/>startEnded 1<br/>startEnded 2<br/>startEnded TAP<br/>Teardown</span></pre><p id="f582" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发出<code class="fe kp kq kr ks b">finish</code>事件时，时间间隔正常停止。我们只需要清理调试的东西。</p><p id="2d55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但我们仍然没有在这篇文章的结尾。前面肯定有剧情转折！</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="nt mj l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk">Beware! Plot twist ahead!</figcaption></figure><h1 id="7416" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">仍未修复</h1><p id="807f" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我删除了调试行，下面的输出再次出现:</p><pre class="ku kv kw kx gt ne ks nf ng aw nh bi"><span id="194a" class="ms lg in ks b gy ni nj l nk nl">Starting<br/>p 0<br/>p 1<br/>p 2<br/>p 3<br/>Finished -- no "p" logs expected below this<br/>p 4<br/>p 5<br/>p 6<br/>p 7<br/>p 8<br/>Teardown</span></pre><p id="c667" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不是很开心。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="nu mj l"/></div></figure><blockquote class="ml mm mn"><p id="c373" class="jk jl mo jm b jn jo jp jq jr js jt ju mp jw jx jy mq ka kb kc mr ke kf kg kh ig bi translated"><strong class="jm io">挑战</strong>:为什么又破了？</p></blockquote><p id="248a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之前的尝试之所以成功，只是因为构造函数中的调试订阅。没有订阅，就没有人及时创建管道，我们又回到了起点:订阅发生得太晚，它错过了<code class="fe kp kq kr ks b">start</code>事件，因此它不会检测到<code class="fe kp kq kr ks b">start → finish</code>转换。</p><h2 id="4049" class="ms lg in bd lh mt mu dn ll mv mw dp lp jv mx my lt jz mz na lx kd nb nc mb nd bi translated">糟糕的解决方案</h2><p id="36e1" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">那就让我们保留虚拟订阅吧，不是吗？添加一个适当的拆卸，(<code class="fe kp kq kr ks b">takeUntil(this.destroyed$)</code>)，也可能是一行谦虚的评论。是的，我们可以这样做，悄悄地埋一颗快乐的小地雷，作为给未来的你的礼物。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="nv mj l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk">A happy little landmine and Future You</figcaption></figure><p id="e9e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">务实与马虎相去甚远。务实的程序员非常讨厌糟糕的解决方案。"你爱公义，恨恶邪恶。"</p><p id="6722" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以还是找个合适的解决办法吧。</p><h1 id="acc6" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">合适的解决方案</h1><p id="287b" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">几分钟后，我得出了这个结论。它更短，使用的操作符更少，比原来的更简单。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="e5b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我看到了正确的输出:</p><pre class="ku kv kw kx gt ne ks nf ng aw nh bi"><span id="46eb" class="ms lg in ks b gy ni nj l nk nl">Starting<br/>p 0<br/>p 1<br/>p 2<br/>p 3<br/>Finished -- no "p" logs expected below this<br/>Teardown</span></pre><p id="e564" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我很高兴。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="nw mj l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk">Me rejoicing.</figcaption></figure><h1 id="7eb6" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">外卖食品</h1><p id="2881" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我又一次被溪流灼伤了。然而，这里我们有这篇文章；而这些记忆很难忘记。如果到目前为止您已经阅读了这篇文章，那么您可能已经为自己节省了几分钟的调试时间。如果你知道答案，恭喜你！请在评论中分享你的烧伤痕迹。当然是象征性的。</p><p id="41fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我最重要的几点:</p><ul class=""><li id="e83c" class="nx ny in jm b jn jo jr js jv nz jz oa kd ob kh oc od oe of bi translated">溪流可能很脏。(尽管对于许多用例来说，它们仍然比命令式的混乱要好。)</li><li id="7103" class="nx ny in jm b jn og jr oh jv oi jz oj kd ok kh oc od oe of bi translated">默认情况下，每个订阅都会构建自己的操作员管道。这并不直观，尤其是当你将Observable +管道保存在一个局部/成员变量中的时候。</li><li id="5b67" class="nx ny in jm b jn og jr oh jv oi jz oj kd ok kh oc od oe of bi translated">当你动态订阅热门节目时要小心:确保你不会迟到。</li><li id="526c" class="nx ny in jm b jn og jr oh jv oi jz oj kd ok kh oc od oe of bi translated">不要为未来的你埋下快乐的小地雷。</li><li id="96a6" class="nx ny in jm b jn og jr oh jv oi jz oj kd ok kh oc od oe of bi translated">也测试你的面向流的代码。使用<a class="ae mk" href="https://rxjs.dev/guide/testing/marble-testing" rel="noopener ugc nofollow" target="_blank">大理石测试</a>。</li></ul><h1 id="767a" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">密码</h1><p id="f5d8" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">强制GitHub链接来了:【https://github.com/igabesz/rxjs-challenge】<br/>T3</p><p id="5532" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mo">更多内容请看</em><a class="ae mk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mo">plain English . io</em></strong></a></p></div></div>    
</body>
</html>