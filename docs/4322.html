<html>
<head>
<title>Algo Alcove: Invert a Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法壁龛:倒置二叉树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algo-alcove-invert-a-binary-tree-1947cab36c46?source=collection_archive---------19-----------------------#2021-08-27">https://javascript.plainenglish.io/algo-alcove-invert-a-binary-tree-1947cab36c46?source=collection_archive---------19-----------------------#2021-08-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ae576b75deccedff9fd0f399d9c408bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W4g3WD2xZuFbnbAb"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@notethanun?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">note thanun</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="418f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎回到壁龛，后面有咖啡和不新鲜的饼干，请自便。今天，我们将看看上周关于二叉树遍历的博客的扩展，并看看一个经典的实现。</p><h1 id="61df" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">问题是</h1><blockquote class="lw lx ly"><p id="1e72" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">给定二叉树的<code class="fe md me mf mg b">root</code>，反转该树，并返回<em class="in">它的根</em>。</p></blockquote><p id="56df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题需要我们在垂直轴<em class="lz">上镜像二叉树。</em> <strong class="kc io"> <em class="lz"> </em> </strong>下面是那个样子。</p><div class="mh mi mj mk gt ab cb"><figure class="ml jo mm mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/bb6ff63968566a7c970b4759dfa3522f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*pKMa8uzz0Y9DUXfs0ur0PQ.png"/></div></figure><figure class="ml jo mr mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/9986cfdd6bcde5378965c890607d8fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*YyAJzBcE7qDbj5Y0Tj3K3A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk ms di mt mu">Before and After</figcaption></figure></div><h1 id="13e8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">思维过程</h1><p id="c8c8" class="pw-post-body-paragraph ka kb in kc b kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">如你所见，树上的每个节点都交换了左<strong class="kc io">和右</strong>子节点。您可能还会注意到，因为树是由<strong class="kc io">子树组成的，</strong>这看起来有点像递归函数:每个子树都被就地交换，它们的子树也是如此，等等。</p><p id="e5cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们听到递归时，我们应该首先想到的是<strong class="kc io">深度优先搜索</strong>，这是有意义的，因为它看起来像是沿着树的边向下并镜像它们的节点，而不是向下扫描每一层。</p><p id="e84a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在的问题是，我们将使用哪种类型的DFS？如果你还记得上周<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/the-algo-alcove-binary-tree-traversal-af0e8f7ce55e">的</a>，按顺序有<strong class="kc io">前序、</strong>后序、和<strong class="kc io">。</strong>在伪代码中，它的操作顺序应该是:</p><ul class=""><li id="21f0" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">落在一个节点上</li><li id="21cc" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">如果<strong class="kc io">为空</strong>返回</li><li id="76aa" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">否则，用它的左子交换它的右子</li><li id="bbb2" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">在左边的子树上递归调用这个函数</li><li id="673b" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">在右边的子树上递归调用这个函数</li></ul><p id="2a2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们在调用我们的递归函数之前操作数据<em class="lz">，对我来说这听起来像是<strong class="kc io">预先排序</strong>。</em></p><h1 id="2632" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">解决方案</h1><p id="22b2" class="pw-post-body-paragraph ka kb in kc b kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">首先，让我们定义一个交换函数，作为我们的主递归函数的助手。</p><pre class="mh mi mj mk gt no mg np nq aw nr bi"><span id="162c" class="ns kz in mg b gy nt nu l nv nw">const swap = (node) =&gt; {<br/>    let temp = node.right;<br/>    node.right = node.left;<br/>    node.left = temp;<br/>}</span></pre><p id="1a89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们只是使用一个<strong class="kc io"> temp </strong>变量作为右节点的占位符(虽然我们可以使用右节点，但这并不重要)，然后交换我们发送给函数的任何节点的值。</p><p id="9532" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们需要一个递归函数，它首先交换，然后在它的两个子节点上调用我们的遍历方法。</p><pre class="mh mi mj mk gt no mg np nq aw nr bi"><span id="e43d" class="ns kz in mg b gy nt nu l nv nw">const traverse = (node) =&gt; {<br/>    if (node === null) return;<br/>    swap(node);</span><span id="17b6" class="ns kz in mg b gy nx nu l nv nw">    traverse(node.left);<br/>    traverse(node.right);<br/>}</span></pre><p id="0d0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！我们现在需要做的就是将我们的根节点发送到这个主函数中，包装其他两个节点，并返回所述根节点以完成挑战。</p><pre class="mh mi mj mk gt no mg np nq aw nr bi"><span id="289e" class="ns kz in mg b gy nt nu l nv nw">const invertBinaryTree = (root) =&gt; {<br/>    const swap = (node) =&gt; {<br/>        let temp = node.right;<br/>        node.right = node.left;<br/>        node.left = temp;<br/>    }</span><span id="0763" class="ns kz in mg b gy nx nu l nv nw">    const traverse = (node) =&gt; {<br/>        if (node === null) return;<br/>        swap(node);</span><span id="3cee" class="ns kz in mg b gy nx nu l nv nw">        traverse(node.left);<br/>        traverse(node.right);<br/>    }</span><span id="6d3c" class="ns kz in mg b gy nx nu l nv nw">    traverse(root);<br/>    return root;<br/>}</span></pre><p id="1a02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">超级简单！如果我们遇到任何<strong class="kc io"> null </strong>节点，由于我们的基本情况，它们将脱离递归循环。在交换函数中，一个空节点将被它的兄弟节点替换，因为我们的temp值派上了用场。</p><p id="f002" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">说到二叉树问题，通常第一步是弄清楚它是属于<strong class="kc io">广度优先</strong>还是<strong class="kc io">深度优先</strong>的领域。如果你能找到一个连接，那么在你遍历的时候，只需要花一点心思就能弄清楚如何操作这些数据。</p><p id="6ad8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读，并在下面留下您的任何意见或问题。编码快乐！</p><p id="0b39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lz">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>