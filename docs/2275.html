<html>
<head>
<title>Exploring Long Polling, SSE, and WebSockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索长轮询、SSE和WebSockets</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/exploring-long-polling-sse-and-websockets-4a0988a3432e?source=collection_archive---------3-----------------------#2021-05-12">https://javascript.plainenglish.io/exploring-long-polling-sse-and-websockets-4a0988a3432e?source=collection_archive---------3-----------------------#2021-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c7c2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我们来看看在一个简单的通知系统中使用Node.js和React进行实时通信的不同方法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8fa051f103578e5d2f7901e3752b68f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAMMnQ_6mZHnTwVVXJmCTA.jpeg"/></div></div></figure><h1 id="37de" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">概观</h1><p id="e4e5" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这篇文章是为那些想在应用程序中添加实时特性，但不需要Firebase这样的无服务器平台或socket.io这样的库的完整功能的人准备的。长轮询、SSE(服务器发送的事件)和WebSockets提供了一个更简单、更轻量级的替代方案，内置于所有现代web浏览器中。</p><h1 id="ddd3" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">设置</h1><p id="fd7b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">客户端生成唯一标识其自身的密钥。该密钥用于对包含通知消息的服务器的请求中。</p><p id="ddc9" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">内部消息传递系统用于将消息传递给适当的端点，端点再将消息发送回客户端。我建议使用类似于Postman的工具来发送请求。</p><p id="c7db" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，出于演示的目的，我们将手动发送请求。但是，您可以将此操作视为模仿另一个试图向特定客户端发送实时数据的客户端或后端服务。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="c974" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">长轮询</h1><p id="4b86" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">首先，让我们谈谈什么是轮询。轮询的一个例子是以特定的时间间隔向服务器发送HTTP请求。</p><p id="6bd2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">换句话说，就是<em class="mj">我们到了吗？</em>消息传递解决方案。</p><p id="04b6" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这种方法有几个明显的问题:</p><ol class=""><li id="f4e4" class="mk ml in li b lj mc lm md lp mm lt mn lx mo mb mp mq mr ms bi translated">它不是实时的，因为如果我们决定每5分钟轮询一次，消息可能已经在那里停留了4分59秒。</li><li id="8431" class="mk ml in li b lj mt lm mu lp mv lt mw lx mx mb mp mq mr ms bi translated">它不是<em class="mj">高效</em>或<em class="mj">可扩展的。</em>您不断地向服务器发送新的不必要的请求(但可能不会对每个请求都打开和关闭TCP连接，这会导致更多的开销——下面会详细介绍。)</li></ol><p id="fd22" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">轮询的一个更好的替代方案是所谓的<em class="mj">长轮询</em>。客户端代码如下。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1080" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">工作流程如下:</p><ol class=""><li id="b5ed" class="mk ml in li b lj mc lm md lp mm lt mn lx mo mb mp mq mr ms bi translated">客户端向服务器发送请求</li><li id="8600" class="mk ml in li b lj mt lm mu lp mv lt mw lx mx mb mp mq mr ms bi translated">在消息可用之前，服务器不会发送响应</li><li id="613e" class="mk ml in li b lj mt lm mu lp mv lt mw lx mx mb mp mq mr ms bi translated">消息变得可用，并且响应被发送</li><li id="3138" class="mk ml in li b lj mt lm mu lp mv lt mw lx mx mb mp mq mr ms bi translated">客户端在收到响应后会立即调用同一个端点</li></ol><p id="b78d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">通过这种方式，连接尽可能长时间地挂起或保持打开，然后在收到响应时重新连接。</p><p id="08c5" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我只想说，在我们继续之前，我把这些基本的例子放在一起作为一个工作演示。没有错误处理设置，这是您在生产环境中需要的。</p><p id="b837" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这很重要，因为尽管HTTP/1.1和HTTP/2连接在默认情况下是持久的(不需要<em class="mj">连接:keep-alive </em>头)。</p><p id="335c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">持久连接意味着连接不会在每次请求和响应后关闭。但是，浏览器、服务器或某些中介(代理)可能会使请求超时。</p><h1 id="a79f" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">同ＳＯＵＴＨ-ＳＯＵＴＨ-ＥＡＳＴ</h1><p id="f147" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">SSE(服务器发送的事件)也使用HTTP协议，但是通过开放的连接将数据以块的形式发送给客户端。</p><p id="ee11" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">使用这种方法，我们需要跟踪所有打开的连接。</p><p id="5942" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">为了简单起见，我只使用一个对象，但是您也可以使用像Redis这样的内存存储。</p><p id="5cd6" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">首先，我创建了一些中间件，负责设置必要的头以及添加和删除客户端连接(响应对象)。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1bd4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><em class="mj">Content-Type:text/event-stream</em>通知客户端正在使用SSE，所以这个头是必需的。</p><p id="c4e3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如前所述，<em class="mj">连接:keep-alive </em>应该是默认的，但我还是把它留了下来。我相信<em class="mj"> Cache-Control: no-cache </em>是谨慎的，以防任何可能缓存响应的代理。</p><p id="b306" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这也是生产的需要。<em class="mj"> flushHeaders </em>方法用于将报头立即发送到客户端，因为这在第一次写入之前会被缓冲。</p><p id="ffcd" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在客户端，我们简单地创建一个新的<em class="mj"> EventSource </em>对象来订阅通知通道。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4064" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里有几种不同的方法；假设您有通知，但也有视频流(和/或任何其他实时功能)。</p><p id="1c49" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然后，您可以为每个事件侦听器设置不同的通道名称。</p><p id="5d68" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">只要确保在书面回复中包含事件字段(必须在数据之前)。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="b2d2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">SSE也有一些不错的能力，你应该知道并且可以阅读。例如，客户端将自动重新连接(设置响应中的<em class="mj">重试</em>字段<em class="mj"> </em>以更改默认值)。</p><p id="291c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">此外，您可以在响应中设置<em class="mj"> id </em>字段(添加Last-Event-ID头)。当客户端重新连接时，它会包含它收到的最后一个id。</p><p id="3747" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">有了这些信息，您就可以在服务器中创建一些逻辑来确定哪些消息需要重新发送。</p><h1 id="125c" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">WebSockets</h1><p id="4f22" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">WebSocket连接首先通过对服务器的HTTP请求建立，然后是响应。如果成功，则使用自己的WebSocket协议在客户端和服务器之间建立WebSocket连接。</p><p id="50f5" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">所有现代浏览器都支持该协议。关于WebSockets重要的一点是，与使用HTTP的长轮询和SSE不同，WebSockets是<em class="mj">全双工的，</em>这意味着客户机和服务器都可以发送和接收消息。</p><p id="bd1a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">尽管通知系统并不需要这一功能，但您可能希望构建其他可以使用它的功能。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a945" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">首先，创建一个新的web socket服务器，并允许它监听连接。客户端是初始化连接的一方。一旦客户端消息到达，我们就把它发送给客户端。</p><p id="e866" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">与SSE的设置方式类似，您可以使用不同的消息传递渠道，使用上的<em class="mj">进行订阅，使用<em class="mj">发出</em>进行发布。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="3fcc" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">结论</h1><p id="4a5b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">希望这能让您对web应用程序中实时通信的一些可用选项有一个很好的了解。</p><p id="b0ce" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">对于简单的特性，比如通知示例，我认为SSE是一个不错的选择。它相当健壮，并为您提供了可用于错误处理的有用属性。</p><p id="fc3f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">缺点是，对于这样一个小功能，您需要更多的后端逻辑。如果您觉得后端逻辑是不必要的或者可能变得太复杂，那么就使用长轮询。</p><p id="d99d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">尽管在这个简单的例子中，WebSockets可能看起来有些多余，但是它并没有使用很多代码，并且很容易理解。如果你打算增加更复杂的实时功能，比如聊天，WebSockets是你想要使用的技术类型。</p><p id="d69a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">也就是说，您可能会遇到与代理和负载平衡器相关的问题。Socket.io(一个基于WebSockets构建的库),它抽象了许多挑战，并通过回退选项(到长轮询)增加了健壮性。</p><p id="a38a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您可以在此处找到演示的回购:</p><div class="my mz gp gr na nb"><a href="https://github.com/MikeZ77/notifications-demo" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">Mike z77/通知-演示</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">这个演示的应用程序是一个使用React和Node.js/Express服务器的简单通知系统。使用独特的…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np km nb"/></div></div></a></div><p id="b282" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><em class="mj">更多内容看</em><a class="ae nq" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="mj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>