<html>
<head>
<title>How to Create Express Router Decorators with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用TypeScript创建快速路由器装饰器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-write-simple-router-decorators-for-expressjs-with-typescript-3b8340b4d453?source=collection_archive---------1-----------------------#2021-08-14">https://javascript.plainenglish.io/how-to-write-simple-router-decorators-for-expressjs-with-typescript-3b8340b4d453?source=collection_archive---------1-----------------------#2021-08-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="12b8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用TypeScript装饰器使Express服务器路由器更整洁</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f9c3a048442f646b7fd09f1b644af7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NB9wI-BxKDVLMMgMYujMQg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Express server</figcaption></figure><p id="1193" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看看如何使用TypeScript decorators使express server路由器更加整洁。</p><p id="fbb3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个故事的目标是展示如何在express服务器中创建和使用路由器装饰器。它还需要关于Express、TypeScript，尤其是TypeScript decorators的知识。</p><p id="ef7a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将使用两种装饰器来创建快速路由器:</p><ul class=""><li id="c3a3" class="lo lp in ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated">类装饰器:一个控制器装饰器，处理基本路由器信息，如<code class="fe lx ly lz ma b">path prefix, router-level middleware...</code></li><li id="ef2a" class="lo lp in ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated">Method decorator:一个处理函数decorator，它处理路由器的详细信息，如<code class="fe lx ly lz ma b">method, path, handle function...</code></li></ul><h1 id="edc2" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">流动</h1><p id="df6a" class="pw-post-body-paragraph ks kt in ku b kv my jo kx ky mz jr la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">路由器的所有信息都将存储在<strong class="ku io">控制器类</strong>的元数据中。这意味着两个decorators都将设置写入控制器类。</p><ol class=""><li id="81a4" class="lo lp in ku b kv kw ky kz lb lq lf lr lj ls ln nd lu lv lw bi translated">控制器装饰器是一个类装饰器工厂，它接受一个字符串作为参数。该字符串是路由器的<code class="fe lx ly lz ma b">base path</code>，它将存储在<code class="fe lx ly lz ma b">BASE_PATH</code> key中。</li><li id="aa65" class="lo lp in ku b kv mb ky mc lb md lf me lj mf ln nd lu lv lw bi translated">方法装饰器是一个方法装饰器工厂，我们可以通过这个装饰器配置<code class="fe lx ly lz ma b">path</code>信息。我们将为每个http方法创建一个装饰器。通常情况下，每个路由器会有多个处理程序，那么处理程序信息— <code class="fe lx ly lz ma b">path, method, handle function</code>会存储在一个数组中，这个数组也会存储在控制器类的元数据中，关键字是<code class="fe lx ly lz ma b">routers</code>。</li><li id="1097" class="lo lp in ku b kv mb ky mc lb md lf me lj mf ln nd lu lv lw bi translated">在我们的express application init函数中，我们遍历所有控制器类，获取路由器信息，并将它们注册到我们的express服务器。</li></ol><h1 id="d2c6" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">带有TypeScript的Basic Express Server</h1><p id="440a" class="pw-post-body-paragraph ks kt in ku b kv my jo kx ky mz jr la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">让我们创建一个简单的express服务器:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="5182" class="ni mh in ma b gy nj nk l nl nm"># Init nodejs project<br/>$ npm init -y<br/>$ npm install typescript ts-node-dev @types/express -D<br/>$ npm install express</span><span id="944f" class="ni mh in ma b gy nn nk l nl nm"># Init typescript project<br/>$ npx tsc -init</span></pre><p id="b216" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们的<code class="fe lx ly lz ma b">tsconfig.json</code>看起来会像:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="de0b" class="ni mh in ma b gy nj nk l nl nm">{<br/>  "compilerOptions": {<br/>    "target": "ES2018",<br/>    "module": "commonjs",<br/>    "strict": true,<br/>    "esModuleInterop": true,<br/>    "skipLibCheck": true,<br/>    "emitDecoratorMetadata": true,<br/>    "experimentalDecorators": true,<br/>    "rootDir": "./src",<br/>    "outDir": "./dist",<br/>    "forceConsistentCasingInFileNames": true<br/>  }<br/>}</span></pre><blockquote class="no np nq"><p id="f29a" class="ks kt nr ku b kv kw jo kx ky kz jr la ns lc ld le nt lg lh li nu lk ll lm ln ig bi translated"><code class="fe lx ly lz ma b">experimentalDecorators</code> —启用<a class="ae nv" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank">对装饰人员的实验支持</a></p><p id="2478" class="ks kt nr ku b kv kw jo kx ky kz jr la ns lc ld le nt lg lh li nu lk ll lm ln ig bi translated"><code class="fe lx ly lz ma b">emitDecoratorMetadata</code> —为与模块<code class="fe lx ly lz ma b"><a class="ae nv" href="https://www.npmjs.com/package/reflect-metadata" rel="noopener ugc nofollow" target="_blank">reflect-metadata</a></code>一起工作的装饰者启用发射类型元数据的实验支持。</p></blockquote></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="651c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接下来，创建一个express应用程序类。我们将所有的逻辑推送到这个类来创建一个express应用程序。</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="5c91" class="ni mh in ma b gy nj nk l nl nm">// src/application.ts<br/>import express, { Application as ExApplication } from 'express';</span><span id="ba92" class="ni mh in ma b gy nn nk l nl nm">class Application {<br/>  private readonly _instance: ExApplication;</span><span id="b412" class="ni mh in ma b gy nn nk l nl nm">  get instance(): ExApplication {<br/>    return this._instance;<br/>  }</span><span id="99ad" class="ni mh in ma b gy nn nk l nl nm">  constructor() {<br/>    this._instance = express();<br/>    this._instance.use(express.json());<br/>    this.registerRouters();<br/>  }</span><span id="04f0" class="ni mh in ma b gy nn nk l nl nm">  private registerRouters() {<br/>    this._instance.get('/', (req, res) =&gt; {<br/>      res.json({ message: 'Hello World!' });<br/>    });</span><span id="433e" class="ni mh in ma b gy nn nk l nl nm">    // TODO: register routers<br/>  }<br/>}</span><span id="190f" class="ni mh in ma b gy nn nk l nl nm">export default new Application();</span></pre><p id="7129" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们只是“公开”了应用程序的一个实例，在整个应用程序中我们只创建了一个应用程序。</p><p id="8fac" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我们将应用程序实例注册到一个服务器对象来处理所有http请求:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="2785" class="ni mh in ma b gy nj nk l nl nm">// src/server.ts<br/>import application from './application';<br/>import * as http from 'http';</span><span id="a17f" class="ni mh in ma b gy nn nk l nl nm">const PORT = process.env.PORT || 3000;</span><span id="b245" class="ni mh in ma b gy nn nk l nl nm">const server = http.createServer(application.instance);</span><span id="088a" class="ni mh in ma b gy nn nk l nl nm">server.listen(PORT, () =&gt; {<br/>  console.log(`Server is listening on :${PORT}`);<br/>});</span></pre><p id="0f27" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个文件是我们的切入点。您可以通过构建ts到js文件来启动服务器，然后像普通的js文件一样执行<code class="fe lx ly lz ma b">server.js</code>。或者使用<code class="fe lx ly lz ma b">ts-node</code>直接执行ts文件。在开发时，我建议使用<code class="fe lx ly lz ma b">ts-node-dev</code>来执行ts文件，当我们的项目有任何变化时，自动“重启”我们的应用程序。</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="cd3c" class="ni mh in ma b gy nj nk l nl nm">$ npx ts-node-dev src/server.ts<br/>[INFO] 23:28:23 ts-node-dev ver. 1.1.8 (using ts-node ver. 9.1.1, typescript ver. 4.3.5)<br/><br/>Server is listening on :3000</span></pre><p id="fa24" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在另一个终端中，尝试访问服务器:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="947c" class="ni mh in ma b gy nj nk l nl nm">$ curl --request GET \<br/>  --url <a class="ae nv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a> \<br/>  --header 'user-agent: vscode-restclient'</span><span id="bf98" class="ni mh in ma b gy nn nk l nl nm"># Response<br/>{"message":"Hello World!"}</span></pre><h1 id="62c7" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">快速装修工</h1><p id="f128" class="pw-post-body-paragraph ks kt in ku b kv my jo kx ky mz jr la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">我们使用<code class="fe lx ly lz ma b">reflect-metadata</code>包作为Polyfill来扩展对象元数据API。API支持保存和检索元数据信息。</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="5859" class="ni mh in ma b gy nj nk l nl nm">$ npm install reflect-metadata</span></pre><p id="271f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在入口点文件的开头导入聚合填充— <code class="fe lx ly lz ma b">servert.ts</code></p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="94ac" class="ni mh in ma b gy nj nk l nl nm">import 'reflect-metadata';</span><span id="6849" class="ni mh in ma b gy nn nk l nl nm">// ...</span></pre></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="0813" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们在一个公共文件中定义元数据键，这些键将在许多地方使用。</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="590a" class="ni mh in ma b gy nj nk l nl nm">// src/utils/metadata.keys.ts<br/>export enum MetadataKeys {<br/>  BASE_PATH = 'base_path',<br/>  ROUTERS = 'routers',<br/>}</span></pre><p id="badd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我们可以创建第一个装饰器—控制器装饰器:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="f863" class="ni mh in ma b gy nj nk l nl nm">// src/utils/controller.decorator.ts<br/>import { MetadataKeys } from '../metadata.keys';</span><span id="9e2b" class="ni mh in ma b gy nn nk l nl nm">const Controller = (basePath: string): ClassDecorator =&gt; {<br/>  return (target) =&gt; {<br/>    Reflect.defineMetadata(MetadataKeys.BASE_PATH, basePath, target);<br/>  };<br/>}</span><span id="bbec" class="ni mh in ma b gy nn nk l nl nm">export default Controller;</span></pre><p id="12bb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">其实，<code class="fe lx ly lz ma b">Controller</code>是一家装潢厂。它返回一个类装饰器，并接受<code class="fe lx ly lz ma b">basePath</code>字符串作为参数。装饰器只是将<code class="fe lx ly lz ma b">basePath</code>信息加入到<code class="fe lx ly lz ma b">target</code>——控制器类(原型)中。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="9fb0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">方法装饰者会更有逻辑，也更混乱。</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="1c73" class="ni mh in ma b gy nj nk l nl nm">// src/utils/handlers.decorator.ts<br/>import { MetadataKeys } from '../metadata.keys';</span><span id="931c" class="ni mh in ma b gy nn nk l nl nm">export enum Methods {<br/>  GET = 'get',<br/>  POST = 'post',<br/>}</span><span id="e12e" class="ni mh in ma b gy nn nk l nl nm">export interface IRouter {<br/>  method: Methods;<br/>  path: string;<br/>  handlerName: string | symbol;<br/>}</span><span id="59a2" class="ni mh in ma b gy nn nk l nl nm">const methodDecoratorFactory = (method: Methods) =&gt; {<br/>  return (path: string): MethodDecorator =&gt; {<br/>    return (target, propertyKey) =&gt; {<br/>      const controllerClass = target.constructor;</span><span id="6889" class="ni mh in ma b gy nn nk l nl nm">      const routers: IRouter[] =   Reflect.hasMetadata(MetadataKeys.ROUTERS, controllerClass) ?<br/>        Reflect.getMetadata(MetadataKeys.ROUTERS, controllerClass) : [];</span><span id="96e9" class="ni mh in ma b gy nn nk l nl nm">      routers.push({<br/>        method,<br/>        path,<br/>        handlerName: propertyKey,<br/>      });</span><span id="b9af" class="ni mh in ma b gy nn nk l nl nm">      Reflect.defineMetadata(MetadataKeys.ROUTERS, routers, controllerClass);<br/>    }<br/>  }<br/>}</span><span id="894f" class="ni mh in ma b gy nn nk l nl nm">export const Get = methodDecoratorFactory(Methods.GET);<br/>export const Post = methodDecoratorFactory(Methods.POST);</span></pre><p id="d72b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe lx ly lz ma b">methodDecoratorFactory</code>返回一个返回方法装饰器的工厂。</p><p id="3048" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们可以使用第一个工厂，通过提供一个<code class="fe lx ly lz ma b">method</code>枚举值，为每个http方法创建一个方法装饰器。</p><p id="98d9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">第二个工厂将<code class="fe lx ly lz ma b">path</code>值传递给最后一个方法装饰器。作为我们的策略，我们将所有路由器的信息保存在控制器类中。路由器的信息包括:</p><ul class=""><li id="bbc3" class="lo lp in ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">method</code> —第一工厂提供。</li><li id="9253" class="lo lp in ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">path</code> —二厂提供。</li><li id="1c00" class="lo lp in ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">handleName</code> —由方法装饰者提供。</li></ul><p id="75b3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">装饰器的<code class="fe lx ly lz ma b">target</code>是一个“方法”,因为它是方法装饰器的参数。但是，我们需要在类中存储信息，那么<code class="fe lx ly lz ma b">target.constructor</code>就是最终的<strong class="ku io">目标</strong>。</p><p id="9479" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们必须处理装饰者第一次被执行的情况。我们当时要准备一个空数组，然后把第一个路由器信息推送到空数组。在其他情况下，我们只是获取当前的路由器列表，然后将路由器信息附加到这个数组中。最后，只需覆盖<code class="fe lx ly lz ma b">ROUTERS</code>元数据。</p><p id="db8e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个文件中，我只是导出了<code class="fe lx ly lz ma b">Get, Post</code>decorator作为例子。</p><h1 id="2d23" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">应用装饰者</h1><p id="cd7f" class="pw-post-body-paragraph ks kt in ku b kv my jo kx ky mz jr la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">我们将使用decorators来创建一些简单的REST API。</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="ad39" class="ni mh in ma b gy nj nk l nl nm">// src/controllers/cat.controller.ts</span><span id="3de6" class="ni mh in ma b gy nn nk l nl nm">import { Request, Response } from 'express';<br/>import Controller from '../utils/decorators/controller.decorator';<br/>import { Get, Post } from '../utils/decorators/handlers.decorator';</span><span id="7ce4" class="ni mh in ma b gy nn nk l nl nm">@Controller('/cats')<br/>export default class CatController {<br/>  private cats: Array&lt;{ name: string }&gt; = [<br/>    { name: 'Tom' },<br/>    { name: 'Kitty' },<br/>  ];</span><span id="ebbd" class="ni mh in ma b gy nn nk l nl nm">  @Get('')<br/>  public index(req: Request, res: Response): void {<br/>    res.json({ cats: this.cats });<br/>  }</span><span id="0dae" class="ni mh in ma b gy nn nk l nl nm">  @Post('')<br/>  public add(req: Request, res: Response): void {<br/>    this.cats.push(req.body);<br/>    res.status(204).json();<br/>  }</span><span id="8274" class="ni mh in ma b gy nn nk l nl nm">  @Get('/:name')<br/>  public findByName(req: Request, res: Response): unknown {<br/>    const { name } = req.params;<br/>    const foundCat = this.cats.find((c) =&gt; c.name === name);<br/>    if (foundCat) {<br/>      return res.json({ cat: foundCat });<br/>    }<br/>    return res.status(404).json({ message: 'Cat not found!' });<br/>  }<br/>}</span></pre><ul class=""><li id="e013" class="lo lp in ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">CatController</code>类将<code class="fe lx ly lz ma b">/cats</code>存储为基础路由器</li><li id="ba86" class="lo lp in ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">index</code>函数处理<code class="fe lx ly lz ma b">GET /cats</code>请求—返回所有的猫</li><li id="3c57" class="lo lp in ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">add</code>函数处理<code class="fe lx ly lz ma b">POST /cats</code>请求—将一只猫添加到猫列表中</li><li id="fe5f" class="lo lp in ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">findByName</code>函数句柄<code class="fe lx ly lz ma b">GET /cats/:name</code> —根据名字找到一只猫。</li></ul><p id="153d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然后我们导出一个控制器类列表:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="065c" class="ni mh in ma b gy nj nk l nl nm">// src/controllers/index.ts</span><span id="aa1d" class="ni mh in ma b gy nn nk l nl nm">import CatController from './cat.controller';</span><span id="8b0b" class="ni mh in ma b gy nn nk l nl nm">export const controllers = [<br/>  CatController,<br/>];</span></pre></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="2150" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，回到我们的应用程序类并更新<code class="fe lx ly lz ma b">TODO: register router</code>区域:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fb25" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">控制器类列表循环:为每个控制器创建一个快速路由器。从控制器类获取路由器信息，并使用该信息创建新的路由器句柄。路由器句柄将如下所示:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="0be2" class="ni mh in ma b gy nj nk l nl nm">@Get('/:name')<br/>public findByName(...</span><span id="0f61" class="ni mh in ma b gy nn nk l nl nm">=&gt;</span><span id="fc4d" class="ni mh in ma b gy nn nk l nl nm">exRouter.get(/:name, controllerInstance.findByName.bind(controllerInstance));</span></pre><p id="4a8d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们必须为控制器函数绑定<code class="fe lx ly lz ma b">this</code>关键字，因为在函数中我们已经使用了<code class="fe lx ly lz ma b">this</code>关键字，并且我们期望<code class="fe lx ly lz ma b">this</code>是控制器。</p><p id="0015" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">记住将路由器注册到应用程序实例。在该步骤中，将使用<code class="fe lx ly lz ma b">basePath</code>设置。解释卡特彼勒控制器:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="a61b" class="ni mh in ma b gy nj nk l nl nm"><a class="ae nv" href="http://twitter.com/Controller" rel="noopener ugc nofollow" target="_blank">@Controller</a>('/cats')<br/>export default class CatController {...</span><span id="3ac0" class="ni mh in ma b gy nn nk l nl nm">=&gt;<br/>this._instance.use('/cats', exRouter);</span></pre><p id="ecdc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe lx ly lz ma b">info</code>变量仅用于打印路由器映射表:</p><pre class="kd ke kf kg gt ne ma nf ng aw nh bi"><span id="037a" class="ni mh in ma b gy nj nk l nl nm">$ npx ts-node-dev src/server.ts</span><span id="03a7" class="ni mh in ma b gy nn nk l nl nm">┌─────────┬───────────────────┬────────────────────────────┐<br/>│ (index) │        api        │          handler           │<br/>├─────────┼───────────────────┼────────────────────────────┤<br/>│    0    │    'GET /cats'    │   'CatController.index'    │<br/>│    1    │   'POST /cats'    │    'CatController.add'     │<br/>│    2    │ 'GET /cats/:name' │ 'CatController.findByName' │<br/>└─────────┴───────────────────┴────────────────────────────┘<br/>Server is listening on :3000</span></pre><p id="bbab" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">仅此而已！</p><h1 id="7314" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">结论</h1><p id="6438" class="pw-post-body-paragraph ks kt in ku b kv my jo kx ky mz jr la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">这个故事是一个应用TypeScript decorators为express应用程序创建路由器的例子。你可以基于这个故事开发你的项目，你可以创建一个认证中间件装饰器，在请求体中验证一些东西…也许我的故事会给你一些帮助。</p><p id="1800" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">本文使用的源代码发布在<a class="ae nv" href="https://github.com/codetheworld-io/ts-express-decorators" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><p id="aab7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢您的阅读！</p><p id="90a9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="nr">更多内容请看</em><a class="ae nv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="nr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>