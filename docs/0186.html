<html>
<head>
<title>The Effect of Shallow Equality in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浅相等在反应中的作用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-effect-of-shallow-equality-in-react-85ae0287960c?source=collection_archive---------7-----------------------#2021-01-11">https://javascript.plainenglish.io/the-effect-of-shallow-equality-in-react-85ae0287960c?source=collection_archive---------7-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/40b8cc5067074a11b90a8376d104a902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*s0DNf_ttX5VJUrPAXJp3xA.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Photo by <a class="ae jv" href="https://unsplash.com/@pavelherceg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pavel Herceg</a> on <a class="ae jv" href="https://unsplash.com/s/photos/shallow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="e077" class="jw jx in bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">什么是浅薄的平等？</strong></h2><p id="6785" class="pw-post-body-paragraph ks kt in ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm ig bi translated">浅相等通过迭代被比较的对象<strong class="ku io"> </strong>的关键字来验证，并且当每个对象中的一个关键字的值对于所有关键字严格相等时返回true。</p><h2 id="3ab5" class="jw jx in bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">为什么肤浅的平等很重要？</strong></h2><p id="68d4" class="pw-post-body-paragraph ks kt in ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm ig bi translated">React依赖于当前和下一个状态之间的<strong class="ku io">浅相等</strong>/props<strong class="ku io">来决定是否重新渲染。</strong>浅比是对浅等的否定。<strong class="ku io">如果shallowCompare返回true则渲染。</strong></p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Code fragment from React legacy add-on</figcaption></figure><p id="2741" class="pw-post-body-paragraph ks kt in ku b kv lt kx ky kz lu lb lc kf lv le lf kj lw lh li kn lx lk ll lm ig bi translated">当嵌套性增加时，浅层平等变得危险。我已经创建了心智模型(备忘单)来记住这些错综复杂的东西。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/11caab4db8ccaa0cefbc51f83ce31e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yzdvx-DBdojQFiEzCx3dVw.jpeg"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk"><strong class="bd md">Referential Equality vs Shallow Equality</strong></figcaption></figure><blockquote class="me mf mg"><p id="1c3b" class="ks kt mh ku b kv lt kx ky kz lu lb lc mi lv le lf mj lw lh li mk lx lk ll lm ig bi translated">Dmitri Pavlutin撰写的博客“<a class="ae jv" href="https://dmitripavlutin.com/how-to-compare-objects-in-javascript/" rel="noopener ugc nofollow" target="_blank">如何比较JavaScript中的对象</a>”中提供了关于比较JS对象的详细解释</p></blockquote><h2 id="bbad" class="jw jx in bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">React useState()中需要使用原语还是对象？</strong></h2><ul class=""><li id="e9a0" class="ml mm in ku b kv kw kz la kf mn kj mo kn mp lm mq mr ms mt bi translated">原语是初学者友好的。</li><li id="3246" class="ml mm in ku b kv mu kz mv kf mw kj mx kn my lm mq mr ms mt bi translated">一旦浅相等被彻底理解，可以使用具有一个嵌套级别(最多)的简单对象。</li><li id="8832" class="ml mm in ku b kv mu kz mv kf mw kj mx kn my lm mq mr ms mt bi translated">避免使用深度嵌套的对象。请改为规范化嵌套对象。</li></ul><blockquote class="me mf mg"><p id="9d5b" class="ks kt mh ku b kv lt kx ky kz lu lb lc mi lv le lf mj lw lh li mk lx lk ll lm ig bi translated">如果我们规范化，深度嵌套的对象可以很好地处理。更多详情，请查看<a class="ae jv" href="https://www.npmjs.com/package/normalizr" rel="noopener ugc nofollow" target="_blank"><strong class="ku io">normal izr</strong></a><strong class="ku io"/>库和相关<a class="ae jv" href="https://github.com/paularmstrong/normalizr/tree/1f6ae6ad6f3155888a41eacab3ed1e12c07a9c8b/examples/relationships" rel="noopener ugc nofollow" target="_blank">示例</a></p></blockquote><h2 id="10e5" class="jw jx in bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">有没有与React useState()用法相关的问题？</strong></h2><p id="649a" class="pw-post-body-paragraph ks kt in ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm ig bi translated">到目前为止，您已经知道每个状态变化都会触发组件呈现。考虑以下选择</p><pre class="ln lo lp lq gt mz na nb nc aw nd bi"><span id="5adf" class="jw jx in na b gy ne nf l ng nh">const<em class="mh"> </em>[<em class="mh">state</em>,<em class="mh"> setState</em>]<em class="mh"> </em>=<em class="mh"> useState</em>({<em class="mh"> name</em>:<em class="mh"> </em>'iMac',<em class="mh"> qty</em>:<em class="mh"> </em>1,<em class="mh"> price</em>:<em class="mh"> </em>1100<em class="mh"> </em>});</span><span id="d89c" class="jw jx in na b gy ni nf l ng nh">vs</span><span id="fd73" class="jw jx in na b gy ni nf l ng nh">const<em class="mh"> </em>[<em class="mh">name</em>]<em class="mh"> </em>=<em class="mh"> useState</em>('iMac');<br/>const<em class="mh"> </em>[<em class="mh">qty</em>,<em class="mh"> setQty</em>]<em class="mh"> </em>=<em class="mh"> useState</em>(<em class="mh">1</em>);<br/>const<em class="mh"> </em>[<em class="mh">price</em>,<em class="mh"> setPrice</em>]<em class="mh"> </em>=<em class="mh"> useState</em>(<em class="mh">1100</em>);</span></pre><p id="65e4" class="pw-post-body-paragraph ks kt in ku b kv lt kx ky kz lu lb lc kf lv le lf kj lw lh li kn lx lk ll lm ig bi translated">那么，当我们多次调用set*方法时会发生什么呢？</p><pre class="ln lo lp lq gt mz na nb nc aw nd bi"><span id="0649" class="jw jx in na b gy ne nf l ng nh"><em class="mh">setState</em>({<em class="mh"> name</em>:<em class="mh"> </em>'iMac',<em class="mh"> qty</em>:<em class="mh"> </em><strong class="na io"><em class="mh">2</em></strong>,<em class="mh"> price</em>:<em class="mh"> </em><strong class="na io">1200</strong><em class="mh"> </em>});</span><span id="1643" class="jw jx in na b gy ni nf l ng nh">vs</span><span id="cdb3" class="jw jx in na b gy ni nf l ng nh">setQty(2);<br/>setPrice(1200);</span></pre><p id="3a5f" class="pw-post-body-paragraph ks kt in ku b kv lt kx ky kz lu lb lc kf lv le lf kj lw lh li kn lx lk ll lm ig bi translated">来源:<a class="ae jv" href="https://stackoverflow.com/questions/53048495/does-react-batch-state-update-functions-when-using-hooks" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a></p><ul class=""><li id="1e96" class="ml mm in ku b kv lt kz lu kf nj kj nk kn nl lm mq mr ms mt bi translated">如果直接触发<strong class="ku io">，则<strong class="ku io">批量</strong>。</strong></li><li id="3ccc" class="ml mm in ku b kv mu kz mv kf mw kj mx kn my lm mq mr ms mt bi translated">如果<strong class="ku io">状态变化</strong>被异步触发(如被包裹在承诺中)，则<strong class="ku io">不会被批量</strong>；</li></ul><p id="929d" class="pw-post-body-paragraph ks kt in ku b kv lt kx ky kz lu lb lc kf lv le lf kj lw lh li kn lx lk ll lm ig bi translated">在下面的示例应用程序中，</p><ul class=""><li id="b494" class="ml mm in ku b kv lt kz lu kf nj kj nk kn nl lm mq mr ms mt bi translated">Composite:价格和数量通过一次setState调用得到更新</li><li id="c96a" class="ml mm in ku b kv mu kz mv kf mw kj mx kn my lm mq mr ms mt bi translated">个人:通过两个方法调用更新了价格和数量— setQty和setPrice</li></ul><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nm"><img src="../Images/0965dcdf4b9bed13bfb53260462444f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/1*aduByXA4M2nyX4aRlaQs_A.gif"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Rendering effect on useState</figcaption></figure><p id="a0d9" class="pw-post-body-paragraph ks kt in ku b kv lt kx ky kz lu lb lc kf lv le lf kj lw lh li kn lx lk ll lm ig bi translated">在典型的用例中，几个额外的重新渲染并不坏。但是，如果您的组件对渲染发生的次数很敏感，那么将复合对象作为一种状态会很方便。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h2 id="4721" class="jw jx in bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h2><p id="2882" class="pw-post-body-paragraph ks kt in ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm ig bi translated">我们做到了！希望你现在对什么是肤浅的平等，以及它为什么重要有了更好的理解。</p></div></div>    
</body>
</html>