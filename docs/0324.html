<html>
<head>
<title>CORS workaround to consume RSS in a React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CORS的变通方法是在反应应用程序中使用RSS</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-medium-slice-430c413adfb9?source=collection_archive---------3-----------------------#2021-01-19">https://javascript.plainenglish.io/a-medium-slice-430c413adfb9?source=collection_archive---------3-----------------------#2021-01-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6a7e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">创建“中”切片</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/afc73da89315fb0e5c9c159671e16454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zt4qOl1ZP6ub8ekOYtN1Tg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">RSS + proxy + React</figcaption></figure><p id="b9d0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这篇文章将探索一种在我的网站开发<a class="ae lo" href="https://fergusdevelopmentllc.github.io/" rel="noopener ugc nofollow" target="_blank">文件夹</a>中显示最近的Medium博客文章的方法。具体来说，在左侧，我们希望动态获得这个列表(在下图中用红色标出)。我们想显示最后5篇有<strong class="ku io">标题</strong>、<strong class="ku io">副标题</strong>、<strong class="ku io"> url </strong>、<strong class="ku io"> pubDate </strong>和<strong class="ku io"> imgUrl </strong>的博客帖子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/fa59035c8c54a03cbf938ccbcd4d1666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*u1Os1iYeH-Hq2YbMMVJVzg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae lo" href="https://fergusdevelopmentllc.github.io/" rel="noopener ugc nofollow" target="_blank">https://fergusdevelopmentllc.github.io/</a></figcaption></figure><p id="0036" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">培养基确实有<a class="ae lo" href="https://github.com/Medium/medium-api-docs" rel="noopener ugc nofollow" target="_blank"> API </a>，起初看起来很有希望。但是经过一番研究，我发现API是<strong class="ku io">只写</strong>，不可能从API中得到博文信息。该API只能用于发布新的博客条目，在此<a class="ae lo" href="https://stackoverflow.com/questions/36097527/how-to-retrieve-medium-stories-for-a-user-from-the-api" rel="noopener ugc nofollow" target="_blank"/>确认。</p><p id="4312" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">经过进一步的研究，我发现Medium确实在以下网址为博客作者提供了一个RSS源:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="ca55" class="lv lw in lr b gy lx ly l lz ma">https://medium.com/feed/@user-name</span></pre><h2 id="d98f" class="lv lw in bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">什么是RSS？</h2><p id="59f0" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">RSS(真正简单的聚合)是一种允许用户和应用程序以标准化的计算机可读格式访问网站更新的网站。</p><p id="1063" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就我而言，这个网址是<a class="ae lo" href="https://medium.com/feed/@will-carter" rel="noopener">https://medium.com/feed/@will-carter</a>。这个网址提供了我在Medium的所有活动(帖子、评论等)的RSS源。仔细查看RSS源，我们可以看到博客文章与源中的其他项目混合在一起。在研究了一点RSS之后，似乎可以过滤掉那些不是真实帖子的内容，并将博客帖子信息作为显示的目标。有关详细信息，请查看下面RSS源中突出显示的部分。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/11b63ff83216b9eae8003c4f653c89d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWJ1vf-v1wGe25c0rjQZ7Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Medium RSS feed for a user</figcaption></figure><p id="bf5c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我的投资组合是基于反应的。该计划是对RSS url进行异步请求，将该信息过滤为博客文章，并显示最后5篇文章。</p><p id="e72e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了简单起见，我们将在App.js中进行异步调用，并将检索到的帖子传递给<strong class="ku io"> FeaturedPosts </strong>组件。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="3738" class="lv lw in lr b gy lx ly l lz ma">App.js</span><span id="319e" class="lv lw in lr b gy my ly l lz ma">import './App.css'<br/>import React, { useEffect, useState } from 'react'<br/>import FeaturedPosts from './components/FeaturedPosts'<br/><strong class="lr io">import Parser from 'rss-parser'</strong></span><span id="40de" class="lv lw in lr b gy my ly l lz ma">function App() {</span><span id="9361" class="lv lw in lr b gy my ly l lz ma">  <strong class="lr io">const [posts, setPosts] = useState([])</strong><br/>  <br/>  useEffect(() =&gt; {<br/>    const parser = new Parser()</span><span id="78db" class="lv lw in lr b gy my ly l lz ma">    const filterPosts = (items, limit) =&gt; {<br/>      ...<br/>    }</span><span id="8725" class="lv lw in lr b gy my ly l lz ma">    const fetchPosts = async () =&gt; {<br/>      const url = 'https://medium.com/feed/@will-carter'<br/>      <strong class="lr io">const feed = await parser.parseURL(url)<br/>      const blogPosts = filterPosts(feed.items, 5)<br/>      setPosts(blogPosts)<br/>    </strong>}</span><span id="62ce" class="lv lw in lr b gy my ly l lz ma">    fetchPosts()</span><span id="7901" class="lv lw in lr b gy my ly l lz ma">  }, [])</span><span id="3f98" class="lv lw in lr b gy my ly l lz ma">  return (<br/>  &lt;div className="home"&gt;<br/>    &lt;main&gt;&lt;/main&gt;<br/>    &lt;aside className="left"&gt;<br/>      &lt;FeaturedPosts posts={ <strong class="lr io">posts</strong> } /&gt;<br/>    &lt;/aside&gt;<br/>  &lt;/div&gt;)<br/>}</span><span id="cf4a" class="lv lw in lr b gy my ly l lz ma">export default App</span></pre><ol class=""><li id="75e2" class="mz na in ku b kv kw ky kz lb nb lf nc lj nd ln ne nf ng nh bi translated">首先，请注意<strong class="ku io">解析器</strong>是从<strong class="ku io"> rss-parser </strong>导入的。<a class="ae lo" href="https://www.npmjs.com/package/rss-parser" rel="noopener ugc nofollow" target="_blank"> rss解析器</a>包允许从一个URL轻松解析rss。在这种情况下，RSS url是:<a class="ae lo" href="https://medium.com/feed/@will-carter" rel="noopener">https://medium.com/feed/@will-carter</a></li><li id="5a03" class="mz na in ku b kv ni ky nj lb nk lf nl lj nm ln ne nf ng nh bi translated">useState钩子用于存储检索后显示的博客文章。它被初始化为一个空数组，并将在调用feed后被填充。</li><li id="02bb" class="mz na in ku b kv ni ky nj lb nk lf nl lj nm ln ne nf ng nh bi translated">在useEffect()函数内部，进行异步调用。当返回结果RSS时，使用filterPosts函数过滤项目。</li><li id="ba3d" class="mz na in ku b kv ni ky nj lb nk lf nl lj nm ln ne nf ng nh bi translated">过滤后的帖子被设置为状态。</li><li id="b085" class="mz na in ku b kv ni ky nj lb nk lf nl lj nm ln ne nf ng nh bi translated"><strong class="ku io"> FeaturedPosts </strong>组件对状态变化做出反应，并显示帖子。</li></ol><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="cce3" class="lv lw in lr b gy lx ly l lz ma">FeaturedPosts.js</span><span id="5517" class="lv lw in lr b gy my ly l lz ma">import React from 'react'</span><span id="fa4f" class="lv lw in lr b gy my ly l lz ma">const FeaturedPosts = ({<br/>  posts = []<br/>}) =&gt; {</span><span id="a547" class="lv lw in lr b gy my ly l lz ma">return (<br/>&lt;ul&gt;<br/>  {posts.map((post, i) =&gt; {<br/>    const postDate = new Date(post.pubDate)<br/>    const options = { <br/>                      year: 'numeric', <br/>                      month: 'short',<br/>                      day: 'numeric'<br/>                     }<br/>    return (<br/>      &lt;li key={ i }&gt;<br/>        &lt;h4&gt;&lt;a href={ post.url }&gt;{ post.title }&lt;/a&gt;&lt;/h4&gt;<br/>        &lt;div&gt;&lt;a href={ post.url }&gt;{ post.subtitle }&lt;/a&gt;&lt;/div&gt;<br/>        &lt;div&gt;{ postDate.toLocaleDateString("en-US", options) }&lt;/div&gt;<br/>        &lt;a href={ post.url }&gt;&lt;img src={ post.imgUrl } /&gt;&lt;/a&gt;<br/>      &lt;/li&gt;)<br/>    })}<br/>&lt;/ul&gt;<br/>)}</span><span id="c2b5" class="lv lw in lr b gy my ly l lz ma">export default FeaturedPosts</span></pre><p id="98f3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上面的<strong class="ku io"> FeaturedPosts </strong>组件的唯一工作是将通过props发送给它的<strong class="ku io">帖子</strong>显示为一个无序列表。</p><p id="60a0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们试一试！</p><h2 id="df29" class="lv lw in bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">遭遇CORS相关问题</h2><p id="4227" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">不幸的是，由于源代码上的CORS策略，代码在这一点上遇到了错误。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/eafb34d4e14d38dbab0d2a640c446e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2i7tS7jeY4V2yYe8V2W21w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Hitting a CORS error</figcaption></figure><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="954d" class="lv lw in lr b gy lx ly l lz ma">Access to fetch at '<a class="ae lo" href="https://medium.com/feed/@will-carter'" rel="noopener">https://medium.com/feed/@will-carter'</a> from origin '<a class="ae lo" href="http://localhost:3000'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000'</a> has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource ... Failed to fetch</span></pre><p id="96e1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">发生此错误是因为除medium.com之外的域已阻止对RSS源的访问。这种cors设置很常见，经过一番研究，我发现了<a class="ae lo" href="https://cors-anywhere.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://cors-anywhere.herokuapp.com/</a>API，它允许跨源请求到任何地方。所需要做的就是将url更改为以下内容:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="afb7" class="lv lw in lr b gy lx ly l lz ma">https://cors-anywhere.herokuapp.com/https://medium.com/feed/@will-carter</span></pre><p id="b164" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">通过使用cors-anywhere作为代理，可以在FeaturedPosts组件中收集和显示RSS数据。请注意下面的url更改:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="3dec" class="lv lw in lr b gy lx ly l lz ma">const fetchPosts = async () =&gt; {<br/>  const url = '<strong class="lr io">https://cors anywhere.herokuapp.com/https://medium.com/feed/@will-carter</strong>'</span><span id="2057" class="lv lw in lr b gy my ly l lz ma">  const feed = await parser.parseURL(url)<br/>  const blogPosts = filterPosts(feed.items, 5)<br/>  setPosts(blogPosts)<br/>}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b7eb06306536cc061f98ae5da11c2310.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*xkHGtt9ai9Q0cmt0r-6mkw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Medium Post RSS data rendered</figcaption></figure><h2 id="3aed" class="lv lw in bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">创建我自己的代理</h2><p id="a8a6" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated">虽然上面的API可以工作，但最好不要依赖CORS anywhere.herokuapp.com。</p><p id="00ad" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">幸运的是，创建我们自己的代理相当容易，它做的事情与上面的cors-anywhere代理一样。<strong class="ku io">在服务器到服务器通信</strong>中不强制执行同源策略，这就是以下express web服务器工作的原因。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="dc9d" class="lv lw in lr b gy lx ly l lz ma">server.js</span><span id="9888" class="lv lw in lr b gy my ly l lz ma">const express = require('express')<br/>const request = require('request')</span><span id="ed9f" class="lv lw in lr b gy my ly l lz ma">const app = express()</span><span id="7e5a" class="lv lw in lr b gy my ly l lz ma">app.use((req, res, next) =&gt; {<br/>  res.header('<strong class="lr io">Access-Control-Allow-Origin</strong>', '*')<br/>  next()<br/>})</span><span id="9818" class="lv lw in lr b gy my ly l lz ma">app.get('<strong class="lr io">/medium</strong>', (req, res) =&gt; {<br/>  request(<br/>    { url: '<strong class="lr io">https://medium.com/feed/@will-carter</strong>' },<br/>    (error, response, body) =&gt; {<br/>      if (error || response.statusCode !== 200) {<br/>        return res.status(500).json({ type: 'error', message:<br/>      err.message })<br/>    }<br/>    <br/>    res.set('Content-Type', 'application/rss+xml')<br/>    res.send(Buffer.from(<strong class="lr io">body</strong>))<br/>  })<br/>})</span><span id="6731" class="lv lw in lr b gy my ly l lz ma">const PORT = process.env.PORT || 4050<br/>app.listen(PORT, () =&gt; console.log(`listening on ${PORT}`))</span></pre><ol class=""><li id="9701" class="mz na in ku b kv kw ky kz lb nb lf nc lj nd ln ne nf ng nh bi translated">这个代理使用express中间件将一个<strong class="ku io">Access-Control-Allow-Origin:*</strong>头应用于来自服务器的每个响应。</li><li id="49a7" class="mz na in ku b kv ni ky nj lb nk lf nl lj nm ln ne nf ng nh bi translated">当在此服务器上访问<strong class="ku io"> /medium </strong>时，它将访问位于<a class="ae lo" href="https://medium.com/feed/@will-carter" rel="noopener">https://medium.com/feed/@will-carter</a>的RSS提要，并将传递在那里找到的数据。</li></ol><p id="434b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我已经安装了这个服务器，可以访问以下网址，所有来源都允许:<a class="ae lo" href="http://138.68.23.63:4050/medium" rel="noopener ugc nofollow" target="_blank">http://138.68.23.63:4050/medium</a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/779ec567aa47fe88017a1ddb4b6cda73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*ZS8UdwGG3FX2j_n7FROiBg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">proxy for <a class="ae lo" href="https://medium.com/feed/@will-carter" rel="noopener">https://medium.com/feed/@will-carter</a></figcaption></figure><p id="133c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然后，如果我们更新App.js中的fetchPosts函数来命中我们的代理...</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="a49e" class="lv lw in lr b gy lx ly l lz ma">const fetchPosts = async () =&gt; {<br/>  const url = '<a class="ae lo" href="http://138.68.23.63:4050/medium" rel="noopener ugc nofollow" target="_blank"><strong class="lr io">http://138.68.23.63:4050/medium</strong></a><strong class="lr io">'</strong><br/>  const feed = await parser.parseURL(<a class="ae lo" href="http://138.68.23.63:4050/medium" rel="noopener ugc nofollow" target="_blank">u</a>rl)<br/>  const blogPosts = filterPosts(feed.items, 5)<br/>  setPosts(blogPosts)<br/>}</span></pre><p id="b9f7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">帖子像以前一样显示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b7eb06306536cc061f98ae5da11c2310.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*xkHGtt9ai9Q0cmt0r-6mkw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Same data, but now hitting a private proxy</figcaption></figure><p id="3703" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个帖子的react代码可以在:<br/><a class="ae lo" href="https://cors-anywhere.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://cors-anywhere.herokuapp.com/</a>找到</p><p id="f4e1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">代理代码见:【https://github.com/FergusDevelopmentLLC/medium_proxy】<a class="ae lo" href="https://github.com/FergusDevelopmentLLC/medium_proxy" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="ec68" class="lv lw in bd mb mc md dn me mf mg dp mh lb mi mj mk lf ml mm mn lj mo mp mq mr bi translated">参考</h2><p id="4d56" class="pw-post-body-paragraph ks kt in ku b kv ms jo kx ky mt jr la lb mu ld le lf mv lh li lj mw ll lm ln ig bi translated"><a class="ae lo" href="https://stackoverflow.com/questions/36097527/how-to-retrieve-medium-stories-for-a-user-from-the-api" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/36097527/how-to-retrieve-medium-stories-for-a-user-from-the-API</a></p><p id="cbbf" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae lo" href="https://medium.com/@dtkatz/3-ways-to-fix-the-cors-error-and-how-access-control-allow-origin-works-d97d55946d9" rel="noopener">https://medium . com/@ dt Katz/3-ways-to-fix-the-CORS-error-and-how-access-<br/>control-allow-origin-works-d97d 55946 d9</a></p><p id="c39d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae lo" href="https://cors-anywhere.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://cors-anywhere.herokuapp.com/</a></p></div></div>    
</body>
</html>