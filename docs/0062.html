<html>
<head>
<title>Implementing Merge Sort in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中实现合并排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-merge-sort-in-javascript-4ea74f92bbea?source=collection_archive---------19-----------------------#2021-01-04">https://javascript.plainenglish.io/implementing-merge-sort-in-javascript-4ea74f92bbea?source=collection_archive---------19-----------------------#2021-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f2a78f7c97c52bdc94ac8c42d6a657e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oCMe6_yV-jqejIGV"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@tomas_nz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tomas Sobek</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cb6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">合并排序是一种采用分治法的排序算法。这是迄今为止我所涉及的最快的排序算法，但代价是它占用了更多的空间。当您使用JavaScript的<code class="fe ky kz la lb b">.sort()</code>时，它实际上可能在幕后调用合并排序。因此，如果您不熟悉递归，您可能希望先了解一下。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="96c5" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">逐步示例</h1><h1 id="0364" class="lj lk in bd ll lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg bi translated">预期结果</h1><p id="9940" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">按升序排序<br/>输入:[4，2，5，1，3，6] <br/>输出:[1，2，3，4，5，6]</p><h1 id="5546" class="lj lk in bd ll lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg bi translated">拆分数组</h1><p id="7e61" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">合并排序的方法与我们已经研究过的许多算法大不相同。它要做的第一件事是将数组分解成1元素数组。这是<em class="mr">分而治之</em>的一部分。</p><h2 id="8f4d" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">第一步</h2><p id="8dcf" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi">[4, 2, 5, 1, 3, 6] → [4, 2, 5] [1, 3, 6]</p><h2 id="447b" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">第二步</h2><p id="fed4" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">[4，2，5]→4[2，5] <br/> [1，3，6]→1[3，6]</p><h2 id="cff6" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">第三步</h2><p id="356d" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">[4] <br/> [2，5] → [2] [5] <br/> [1] <br/> [3，6] → [3] [6]</p><h2 id="8036" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">结果</h2><p id="6394" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi">[4] [2] [5] [3] [6]</p><h1 id="a47b" class="lj lk in bd ll lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg bi translated">合并数组</h1><p id="1177" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">现在，我们已经将阵列分成了1个元素子阵列，我们的下一步是将它们放在一起，边走边排序。</p><h2 id="ee34" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">第一步</h2><p id="64c0" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">我们需要遍历我们的每个1元素数组，并将它们组合成2个已排序的元素数组。在下一步，当我们在每个数组中有更多的元素要处理时，我将更深入地讨论排序过程。<br/> [4] [2] [5] [1] [3] [6] → [2，4] [1，5] [3，6]</p><h2 id="f18e" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">第二步</h2><p id="459a" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">现在我们有了2个元素数组，让我们更仔细地看看对它们进行排序的过程。</p><p id="fa3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了合并，我们将采用两个排序的数组，并将它们合并成一个排序的数组。我们需要一个空数组，我们称之为合并数组。首先，我们有两个已经排序的数组和一个空数组。<br/> arr1 = [2，4] <br/> arr2 = [1，5] <br/>合并= []</p><p id="65e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们需要比较两个数组的第一个元素。<br/> 2 &gt; 1，因此需要将1复制到已合并的<br/> [ <strong class="kc io"> 2 </strong>，4] [ <strong class="kc io"> 1 </strong>，5] <br/>已合并= [1]</p><p id="211e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们已经将arr2中的第一个元素添加到合并后的数组中，我们需要检查arr2的第二个元素。<br/> 2 &lt; 5 <br/> [ <strong class="kc io"> 2 </strong>，4【1】，<strong class="kc io"> 5 </strong> ] <br/>合并= [1，2]</p><p id="a6c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们将检查arr1的第二个元素，因为我们已经复制了它的第一个元素。<br/> [2、<strong class="kc io"> 4 </strong> ] [1、<strong class="kc io"> 5 </strong> ] <br/>合并= [1、2、4]</p><p id="16c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">arr1中没有更多要检查的元素，所以我们只需要看看arr2中是否还有剩余的元素，然后将它们添加到merged中。<br/>合并= [1，2，4，5]</p><p id="2879" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结果:<br/> [2，4] [1，5] [3，6] → [1，2，4，5] [3，6]</p><p id="f86b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，合并时的排序过程如下所示:</p><ul class=""><li id="165c" class="ne nf in kc b kd ke kh ki kl ng kp nh kt ni kx nj nk nl nm bi translated">首先检查两个数组的第一个元素</li><li id="876e" class="ne nf in kc b kd nn kh no kl np kp nq kt nr kx nj nk nl nm bi translated">将最小的元素复制到合并的数组中</li><li id="c197" class="ne nf in kc b kd nn kh no kl np kp nq kt nr kx nj nk nl nm bi translated">检查数组中具有较小元素的下一个元素</li><li id="b49f" class="ne nf in kc b kd nn kh no kl np kp nq kt nr kx nj nk nl nm bi translated">重复，直到检查完其中一个数组中的每个元素</li><li id="30f1" class="ne nf in kc b kd nn kh no kl np kp nq kt nr kx nj nk nl nm bi translated">将另一个数组的剩余元素添加到我们的合并数组中</li></ul><h2 id="d82e" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">最后一档</h2><p id="04d3" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">现在我们只剩下两个数组，剩下要做的就是将它们合并在一起</p><p id="30cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们按照上面的步骤进行。</p><p id="404f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">arr1 = [1，2，4，5] <br/> arr2 = [3，6] <br/>合并= []</p><p id="03d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[ <strong class="kc io"> 1 </strong>，2，4，5] [ <strong class="kc io"> 3 </strong>，6] <br/> 1 &lt; 3 <br/>合并= [1]</p><p id="3104" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[1，<strong class="kc io"> 2 </strong>，4，5] [ <strong class="kc io"> 3 </strong>，6】<br/>2&lt;3<br/>合并= [1，2]</p><p id="17b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[1，2，<strong class="kc io"> 4 【T22，】5] [ <strong class="kc io"> 3 【T24，6】<br/>4&gt;3<br/>合并= [1，2，3]</strong></strong></p><p id="0c35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[1，2，<strong class="kc io"> 4 </strong>，5] [3，<strong class="kc io">6</strong><br/>4&lt;6<br/>合并= [1，2，3，4]</p><p id="7737" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[1，2，4，<strong class="kc io"> 5 </strong> ] [3，<strong class="kc io"> 6 </strong> ] <br/> 5 &lt; 6 <br/>合并= [1，2，3，4，5]</p><p id="68e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经检查了arr1中的所有元素，所以我们将检查是否有元素要添加到arr2中的merged，并添加它们。<br/>合并= [1，2，3，4，5，6]</p><p id="3468" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们只剩下一个排序后的数组。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="b56f" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">密码</h1><p id="edf8" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">让我们从合并两个有序数组的函数开始。</p><pre class="ns nt nu nv gt nw lb nx ny aw nz bi"><span id="dbfe" class="ms lk in lb b gy oa ob l oc od">function merge(arr1, arr2) {<br/>    let merged = [];</span><span id="685f" class="ms lk in lb b gy oe ob l oc od">    // index for arr1<br/>    let index1 = 0;</span><span id="d982" class="ms lk in lb b gy oe ob l oc od">    // index for arr2<br/>    let index2 = 0;</span><span id="0589" class="ms lk in lb b gy oe ob l oc od">    while (index1 &lt; arr1.length &amp;&amp; index2 &lt; arr2.length) {<br/>        if (arr1[index1] &lt; arr2[index2]) {<br/>            merged.push(arr1[index1]);<br/>            index1++;<br/>        } else {<br/>            merged.push(arr2[index2]);<br/>            index2++;<br/>        }<br/>    }</span><span id="48e4" class="ms lk in lb b gy oe ob l oc od">    while (index1 &lt; arr1.length) {<br/>        merged.push(arr1[index1]);<br/>        index1++;<br/>    }</span><span id="aaf5" class="ms lk in lb b gy oe ob l oc od">    while (index2 &lt; arr2.length) {<br/>        merged.push(arr2[index2]);<br/>        index2++;<br/>    }</span><span id="51c7" class="ms lk in lb b gy oe ob l oc od">    return merged;<br/>}</span></pre><p id="1dd8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们开始了一个<code class="fe ky kz la lb b">while</code>循环，它将一直运行，直到其中一个索引等于其各自数组的长度(这模拟了运行的行为，直到我们检查完一个数组中的所有元素)。在<code class="fe ky kz la lb b">while</code>循环中，我们将检查哪个元素更小，然后将该元素放入合并后的数组中。只有在推入数组的一个元素后，我们才增加它的索引。</p><p id="3a87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我们跳出循环，我们将添加另一个数组的剩余元素。我们不知道这将是哪个数组，所以我们设置了另外两个<code class="fe ky kz la lb b">while</code>循环。它们只有在数组中有未检查的元素时才会运行，并且会一直运行到该数组的所有元素都被添加到<code class="fe ky kz la lb b">merged</code>中。</p><p id="b7f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了一个函数来合并两个排序后的数组，我们准备好创建我们的<code class="fe ky kz la lb b">mergeSort</code>函数了。</p><pre class="ns nt nu nv gt nw lb nx ny aw nz bi"><span id="006b" class="ms lk in lb b gy oa ob l oc od">function mergeSort(arr) {<br/>    // base case<br/>    if (arr.length &lt; 2) return arr;</span><span id="106c" class="ms lk in lb b gy oe ob l oc od">    let mid = Math.floor(arr.length / 2);<br/>    let firstHalf = arr.slice(0, mid);<br/>    let secondHalf = arr.slice(mid);</span><span id="73ad" class="ms lk in lb b gy oe ob l oc od">    return merge(mergeSort(firstHalf), mergeSort(secondHalf));<br/>}</span></pre><p id="1fa3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们设置我们的基本情况，即如果数组中只有一个元素，我们需要返回该数组。如果不是，我们找到数组的中点。我们使用中点将数组分成两个独立的部分。然后，我们在每一半上递归调用<code class="fe ky kz la lb b">mergeSort</code>，最后将这两个一起调用<code class="fe ky kz la lb b">merge</code>并返回。</p><h2 id="2855" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">理解递归</h2><p id="fe57" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">如果你觉得很难思考/推理递归，这段代码可能会令人困惑。如果没有，请随意跳过这一部分。</p><p id="1336" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于递归需要理解的是，它是从基本情况开始的。它不断地将自己的函数调用添加到堆栈中，直到其中一个函数调用可以解决为止(我们的基本情况)，然后它开始向后处理之前的函数调用。</p><p id="407f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着只有当它达到了我们返回1个元素数组的基本情况时，它才会开始合并过程。让我们通过一个非常小的例子来更好地理解它。</p><p id="617d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们称之为<code class="fe ky kz la lb b">mergeSort([3, 2, 1])</code>，它会将数组分成两半，然后称之为<code class="fe ky kz la lb b">merge(mergeSort([3]), mergeSort([2, 1]))</code>。</p><p id="ca6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">mergeSort([3])</code>将返回<code class="fe ky kz la lb b">[3]</code>因为它到达了我们的基地箱所以现在我们有:<code class="fe ky kz la lb b">merge([3], mergeSort([2, 1]))</code>。</p><p id="885c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">mergeSort([2, 1])</code>将再次将我们的阵势一分为二，然后召唤<code class="fe ky kz la lb b">merge(mergeSort([2]), mergeSort([1])</code>。</p><p id="2e7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，现在作为一个整体，我们有:<code class="fe ky kz la lb b">merge([3], merge(mergeSort[2], mergeSort([1])))</code>。</p><p id="610e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们对<code class="fe ky kz la lb b">mergeSort([2])</code>的调用将到达我们的基本案例，因此现在我们有:<code class="fe ky kz la lb b">merge([3], merge([2], mergeSort([1])))</code></p><p id="e1fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们对<code class="fe ky kz la lb b">mergeSort([1])</code>的调用将到达我们的基本案例，所以现在是:<br/> <code class="fe ky kz la lb b">merge([3], merge([2], [1]))</code></p><p id="b5cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们对<code class="fe ky kz la lb b">merge([2], [1])</code>的调用将解析为给我们[1，2]。现在我们有:<code class="fe ky kz la lb b">merge([3], [2, 1])</code>。</p><p id="d7cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们得到了[1，2，3]的排序数组。</p><h1 id="6bb3" class="lj lk in bd ll lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg bi translated">时间复杂性、空间复杂性和稳定性</h1><h2 id="1112" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">时间复杂性</h2><p id="5596" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">合并排序的时间复杂度为<em class="mr">线性</em>或<strong class="kc io"> O(n log n) </strong>。这是它的最佳、最差和平均时间复杂度。为了更充分地理解为什么，我建议阅读这篇关于汗学院的文章，因为理解线性时间本身是一个足够困难的话题。理解线性时间很重要，因为它是任何比较排序类型算法产生的最佳时间复杂度。比较排序是将元素相互比较，以找到数组的顺序。因此，到目前为止，我们所做的每一个算法都是一种比较排序。</p><h2 id="ebbc" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">空间复杂性</h2><p id="dad0" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">我们的合并排序的实现并没有在适当的位置进行<em class="mr">排序，这意味着它不仅仅是在输入数组中的元素之间移动，而是必须创建自己的数组来存储排序后的元素。<strong class="kc io">需要O(n)个空间</strong>。这是因为对于每个递归调用，它将创建两个数组，每个数组的大小等于输入大小的一半。然而，这些子阵列不会同时存在于内存中(随着对<code class="fe ky kz la lb b">mergeSort()</code>的递归调用的解决，这些阵列中的每一个都将终止)。</em></p><h2 id="0102" class="ms lk in bd ll mt mu dn lp mv mw dp lt kl mx my lx kp mz na mb kt nb nc mf nd bi translated">稳定性</h2><p id="4dfd" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">合并排序是一种稳定的排序算法。简而言之，这意味着相同的值将保持它们在原始数组中的顺序。</p><h1 id="570e" class="lj lk in bd ll lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg bi translated">总之…</h1><p id="baf2" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">值得注意的是，有些合并排序的实现可能需要恒定的时间。因为它的线性时间复杂度是合并排序的一个较大的缺点，所以它可能值得研究。现在你知道了合并排序，你知道了一个更广泛使用的排序算法，祝贺你！如果你想看这篇博客中使用的代码，我已经把它放在GitHub仓库<a class="ae jz" href="https://github.com/ReginaF2012/JavaScript_MergeSort" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>