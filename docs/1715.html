<html>
<head>
<title>Useful React Tips &amp; Tricks for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对初学者有用的React提示和技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useful-react-tips-and-tricks-for-beginners-69dd7f414588?source=collection_archive---------5-----------------------#2021-04-12">https://javascript.plainenglish.io/useful-react-tips-and-tricks-for-beginners-69dd7f414588?source=collection_archive---------5-----------------------#2021-04-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/834494726a4952391cafd1e221a1ea42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1aSmsfzx96g9I-__hVRRQ.png"/></div></div></figure><p id="5ba5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一些简单的提示和技巧，供React初学者使用。其中一些是React的核心原则，一些只是帮助您进行开发的简单生活窍门。</p><h1 id="a39a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">渲染期间没有副作用</h1><p id="c297" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">无论你是使用类还是FCs，渲染体本身都不应该包含任何副作用，而且最好不要有昂贵的计算。</p><h1 id="5761" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是副作用？</h1><p id="bb4f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">副作用是函数式编程中众所周知的一个术语，指的是除了返回值之外影响函数之外的任何东西的每一个操作。如果一个函数没有任何副作用，它的输出只依赖于它的参数，那么这个函数就叫做纯函数。</p><p id="49f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于React呈现组件的方式，它可能会多次呈现组件，或者在不更新DOM的情况下呈现组件。这就是为什么组件的主体不应该包含任何副作用。在开发中尽可能增加额外的渲染来暴露任何副作用。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/07b9d61997f6a2f325d21f4debbfb0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVv1VM-HmmUqcVF2XVKmHQ.png"/></div></div></figure><p id="50e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们清理组件:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/ae1789e56aad94bd72b72244d166bad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsSPOchV0cUoiqB8jIKpfg.png"/></div></div></figure><h1 id="760b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">优化昂贵的计算</h1><p id="b38f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">每当组件中的一个值改变时，React都会重新渲染整个组件，这意味着组件的渲染应该尽可能的轻量级。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/4cf204d3f73b093857f66727bb211615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPOYNqAcZujnSBOqCv0wnA.png"/></div></div></figure><h1 id="cc7b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一个文件中的多个组件</h1><p id="28f2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">许多人和许多代码库强制执行每个文件应该只包含一个组件的规则。这通常会导致混乱和糟糕的开发体验，因为人们不想将组件分割成多个文件。</p><p id="9129" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当从数组呈现UI时，可能需要调用一个钩子。这可以通过在原始组件下创建一个新组件来轻松解决。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/0eef798df218d428b5c1b654e19d517f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dyPj4I0BWLU_NdBaLiFuLQ.png"/></div></div></figure><p id="954a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，我尝试每个文件只导出一个组件，但是在很多情况下，多个导出的组件是有意义的。</p><h1 id="3a4c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Typescript: ReactNode类型</h1><p id="ce5a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当你使用React和Typescript来定义组件的属性时，许多人使用string作为类型来将内容传递给React将在内部呈现的组件。但是React可以呈现的不仅仅是字符串。ReactNode是一个类型别名，包含React可以呈现的所有类型。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/0bcb0263dd04cbdcc2e350990459553a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HrW7Is6Mnr3ODqiYTbs2A.png"/></div></div></figure><p id="ad2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">警告:ReactNode将允许你传递React不能渲染和抛出的对象。</p><p id="e1c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将允许我们传递React可以显示的任何值，而不仅仅是一个字符串:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/00908de376aa821bd1392693234cfd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cr7xCKkP1KH5BxPHsMWvNQ.png"/></div></div></figure><h1 id="3f5c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">用以前的状态设置状态</h1><p id="2fb4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在大多数情况下，你不需要状态钩子的前一个状态来设置它的值，但是如果你需要的话，你应该依赖于作用域中的值。不仅你不能经常接触到它，而且它可能已经过时了。</p><p id="c3b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设想一个场景，您需要一次更新两次状态(例如在onClick事件中)。如果您只是调用setState两次，而没有使用函数来获得新的状态，React将放弃第一次setState调用，因为作用域在JS中是如何工作的。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/dff5f48ad0267420cb63159297683cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqYwiLKtZO6aJlKKCcNjGw.png"/></div></div></figure><h1 id="ab5e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">JSX的Console.log</h1><p id="1861" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">React几乎可以渲染任何东西，包括undefined。这意味着你可以在JSX调用任何没有返回值的函数。您通常不希望这样做，因为这些函数通常会带来副作用，但是对于调用console.log来说，这是非常理想的。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/cbcd76fd9d1de98a6821634009ffc322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huhaylgTIpUIfe_VwA_VqQ.png"/></div></div></figure><h1 id="43b3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">传播不是深度复制</h1><p id="44df" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">ES6带来了将属性从一个对象复制到另一个对象的能力。尽管这是一个很棒的特性，React也非常依赖它，但它实际上经常被误解。这不是一个深刻的副本。如果复制带有对象的特性，则仅复制对象引用，而不复制对象本身，并且对象将共享它。这叫做浅拷贝。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/1a2df6f96a96c853f889099224f4b0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csVeyWv2QNcI08ufiN6-zg.png"/></div></div></figure><p id="7810" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着如果你变异了一个，另一个也会变异。当您在React中设置状态时，您希望避免它。您可以复制整个对象及其所有子对象，这很慢，并且您需要一个外部库(例如lodash)，或者您可以只嵌套spread操作符，这只会创建您需要的副本。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/e58ef63fd6c7bc2735340fa9ea6338c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vn50t7gCh7Je1E1XxELaSw.png"/></div></div></figure><h2 id="d7a5" class="mi ku in bd kv mj mk dn kz ml mm dp ld kg mn mo lh kk mp mq ll ko mr ms lp mt bi translated">结论</h2><p id="e296" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">就这些了，非常感谢你阅读这篇文章。如果你有任何反馈，一定要在评论里告诉我。</p><p id="873f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mu">更多内容看</em><a class="ae mv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mu">plain English . io</em></strong></a></p></div></div>    
</body>
</html>