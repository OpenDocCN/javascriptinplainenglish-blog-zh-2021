<html>
<head>
<title>What You Need to Know About React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React 18你需要知道的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-you-need-to-know-about-react-18-54070f6bc4a1?source=collection_archive---------0-----------------------#2021-06-11">https://javascript.plainenglish.io/what-you-need-to-know-about-react-18-54070f6bc4a1?source=collection_archive---------0-----------------------#2021-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7fbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">脸书团队已经发布了React 18特性的未来计划</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96be810d47a131335988e4023638bd9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbyoOJS-uT7qf8DS-kzG0Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">courtesy to evening kid</figcaption></figure><p id="fbf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">脸书团队公布了React-18 的计划。React提供了许多令人兴奋的现成特性。这些不仅增强了用户体验，也让开发者的生活更加轻松。所以，这是这次将要发布的三个主要特性。</p><h1 id="828c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">1.自动配料</h1><p id="3948" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">批处理是React将多个状态更新分组到一个重新渲染中以获得更好的性能。</p><p id="d2ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果在同一个click事件中有两个状态更新，React总是将它们批处理到一个重新渲染中。如果运行以下代码，您将看到每次单击时，尽管您设置了两次状态，React仅执行一次渲染:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/0a00120d6bd272c7a843cdf7f6f8d3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVf7N2p07uLre8Q1D5PhHQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">code snippet for state change</figcaption></figure><p id="d47c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这对性能非常好，因为它避免了不必要的重新渲染。它还防止您的组件呈现“半成品”状态，其中只有一个状态变量被更新，这可能会导致错误。这可能会让你想起，当你点第一道菜时，餐馆服务员并不跑去厨房，而是等你吃完。</p><p id="fca5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，React对于何时批量更新并不一致。例如，如果您需要获取数据，然后更新上面的<code class="fe md me mf mg b">handleClick</code>中的状态，那么React将<em class="mh">而不是</em>批量更新，并执行两个独立的更新。</p><p id="c580" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为React过去只在浏览器事件(如click)的期间批量更新<em class="mh">，但是这里我们在事件已经被处理(在获取回调中)之后更新状态<em class="mh">:</em></em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/e381c10afc4682548346e3b0bfd6ba84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyZQADj2fm9c6UHOajZQDg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">code snippet state change in fetch</figcaption></figure><p id="1c36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在自动批处理中(升级到React 18之后)，不管状态来自哪里，它总是会被重新渲染一次。</p><h1 id="fbf5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">不想批怎么办？</h1><p id="55b1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在这种情况下，您必须使用flushSync来重新呈现该组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/049fec300da21d1f727f798161532d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZLFyNcvoUlyFXCjgrgN4g.png"/></div></div></figure><h1 id="61b4" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">2.SSR对悬念的支持</h1><p id="6a18" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这基本上是服务器端渲染(SSR)逻辑的扩展。在典型的React SSR应用程序中，会发生以下步骤:</p><ul class=""><li id="f6b2" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">服务器获取需要在UI上显示的相关数据</li><li id="ea09" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">服务器将整个应用程序呈现为HTML，并作为响应发送给客户端</li><li id="5f03" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">客户端下载JavaScript包(除了HTML)</li><li id="a448" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">在最后一步，客户端将javascript逻辑连接到HTML(这就是所谓的水合)</li></ul><p id="4c65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">典型的SSR应用程序的问题是，在下一步开始之前，整个应用程序的每一步都必须立即完成。这使得你的应用程序在初始加载时有点慢，没有反应。</p><p id="8da3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React 18正试图解决这个问题。<suspense> component已经发生了革命性的变化，它将应用程序分解成更小的独立单元，这些单元将经历上述每个步骤。这样一旦用户看到了内容，它就变成了交互式的。</suspense></p><h1 id="7e77" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">3.过渡</h1><p id="ac47" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这是一个即将发布的令人难以置信的功能。它让用户解决了大屏幕频繁更新的问题。例如，考虑在筛选数据列表的输入字段中键入内容。您需要将字段的值存储在state中，以便可以过滤数据并控制输入字段的值。您的代码可能如下所示:</p><pre class="kj kk kl km gt my mg mz na aw nb bi"><span id="12f6" class="nc la in mg b gy nd ne l nf ng">// Update the input value and search results<br/>setSearchQuery(input);</span></pre><p id="969d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，每当用户键入一个字符，我们就更新输入值并使用新值搜索列表并显示结果。对于大屏幕更新，这可能会导致页面在所有内容渲染时出现延迟，使键入或其他交互感觉缓慢且无响应。即使列表不太长，列表项本身也可能很复杂，每次击键都不同，可能没有明确的方法来优化它们的呈现。</p><p id="faed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从概念上来说，问题是有两个不同的更新需要发生。第一次更新是紧急更新，更改输入字段的值，并可能更改它周围的一些UI。第二个是显示搜索结果的不太紧急的更新。</p><pre class="kj kk kl km gt my mg mz na aw nb bi"><span id="9337" class="nc la in mg b gy nd ne l nf ng">// Urgent: Show what was typed<br/>setInputValue(input);<br/><br/>// Not urgent: Show the results<br/>setSearchQuery(input);</span></pre><p id="5f7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">新的<code class="fe md me mf mg b">startTransition</code> API通过让您能够将更新标记为“转换”来解决这个问题:</p><pre class="kj kk kl km gt my mg mz na aw nb bi"><span id="3c1d" class="nc la in mg b gy nd ne l nf ng">import { startTransition } from 'react';<br/></span><span id="f4c4" class="nc la in mg b gy nh ne l nf ng">// Urgent: Show what was typed<br/>setInputValue(input);</span><span id="fc29" class="nc la in mg b gy nh ne l nf ng">// Mark any state updates inside as transitions<br/>startTransition(() =&gt; {<br/>  // Transition: Show the results<br/>  setSearchQuery(input);<br/>});</span></pre><h1 id="e33b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">React 18工作组</h1><p id="d91d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">脸书创建了一个由著名图书馆的作者和维护者组成的<a class="ae ky" href="https://github.com/reactwg/react-18" rel="noopener ugc nofollow" target="_blank">工作组</a>。他们一直在讨论这些功能，以获得早期反馈。这些讨论是公开的，任何感兴趣的人都可以参与。以下是我一直关注的链接:</p><ul class=""><li id="6992" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/4" rel="noopener ugc nofollow" target="_blank">https://github.com/reactwg/react-18/discussions/4</a></li><li id="2a2d" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/41" rel="noopener ugc nofollow" target="_blank">https://github.com/reactwg/react-18/discussions/41</a></li><li id="45dd" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/21" rel="noopener ugc nofollow" target="_blank">https://github.com/reactwg/react-18/discussions/21</a></li></ul><p id="5c0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的一面是React 18没有任何突破性的变化，因此将我们当前的存储库升级到最新版本只需要很少甚至没有代码变化。我们可以享受他们的酷功能。</p><p id="4484" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您阅读这个故事。</p><h1 id="ae36" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">参考资料:</h1><ul class=""><li id="30ad" class="mk ml in jm b jn lx jr ly jv ni jz nj kd nk kh mp mq mr ms bi translated">https://www.youtube.com/watch?v=Cp7RYtp-NKo&amp;t = 617s</li><li id="448e" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=bpVRWrrfM1M&amp;t=185s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=bpVRWrrfM1M&amp;t = 185s</a></li></ul><p id="2920" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mh">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mh">plain English . io</em></a></p></div></div>    
</body>
</html>