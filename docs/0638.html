<html>
<head>
<title>What is the difference between Type and Interface in TypeScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中类型和接口的区别是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-the-difference-between-type-and-interface-in-typescript-d41719acad22?source=collection_archive---------3-----------------------#2021-02-09">https://javascript.plainenglish.io/what-is-the-difference-between-type-and-interface-in-typescript-d41719acad22?source=collection_archive---------3-----------------------#2021-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="kl">TLDR；</em> </strong> <code class="fe km kn ko kp b"><em class="kl">interface</em></code> <em class="kl">是一种描述数据的方式</em><strong class="jp ir"><em class="kl"/></strong><em class="kl">，比如一个物体。与接口不同，</em> <code class="fe km kn ko kp b"><em class="kl">type</em></code> <em class="kl">可以为任何类型引入名称，包括原语、联合和交集类型。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/ee2ff3b7cfa66413d1d246935f0d921d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*kbVT8dxX798OTnps"/></div></figure><h1 id="80c4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是接口？</h1><p id="6c8c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">界面看起来像这样:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">The definition and usage of a newly created interface “Human”</figcaption></figure><p id="3d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们定义了一个名为<code class="fe km kn ko kp b">Human</code>的接口，然后用它创建了一个变量<code class="fe km kn ko kp b">james</code>。接口在某种程度上是有用的，因为我们可以始终确保我们创建的对象具有相同的形状(属性)。如果我们碰巧用接口<code class="fe km kn ko kp b">Human</code>创建了一个不同形状的变量，TypeScript会显示一个错误。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">TypeScript error when the variable doesn’t match the defined interface</figcaption></figure><p id="1192" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">够简单吗？很好，我们继续。</p><h1 id="7700" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是类型？</h1><p id="a986" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当创建一个<code class="fe km kn ko kp b">type</code>时，你实际上并没有创建一个新的<em class="kl">类型</em>，你是在为一个类型创建一个新的<strong class="jp ir">名称</strong>，这就是为什么它被称为<a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases" rel="noopener ugc nofollow" target="_blank">类型别名</a>。</p><p id="8eec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在你感到困惑之前，这里有一个类比:</p><p id="ae0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本有一台笔记本电脑，但他不称之为笔记本电脑，而是称之为他的 <strong class="jp ir"> <em class="kl">代码制作者</em> </strong> <em class="kl">，因为本就是那样的急躁。</em></p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="81bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面我们可以看到，type <code class="fe km kn ko kp b">Laptop</code>和<code class="fe km kn ko kp b">CodeMaker</code>的属性完全一样。为什么我们需要创造另一种具有完全相同属性的类型，就因为本想像其他人一样称它为“代码制造者”而不是笔记本电脑？这不太公平。</p><p id="5c90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">约翰说:“如果本把他的笔记本电脑叫做<strong class="jp ir"><em class="kl"/></strong><em class="kl">，那么我想把我的笔记本电脑叫做</em><strong class="jp ir"><em class="kl"/></strong><em class="kl">”。</em></p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">This does not look very efficient at all…</figcaption></figure><p id="6b50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，在你开始尖叫“说重点！”别担心，我快到了。所以现在我们有三个不同的名字，本质上描述同一件事。让我们简化一下，做一些<code class="fe km kn ko kp b">type</code>能做而<code class="fe km kn ko kp b">interface</code>不能做的事情。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9595" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ben和John不需要定义<code class="fe km kn ko kp b">Laptop</code> 3次，他们可以创建<code class="fe km kn ko kp b">Laptop</code>的类型别名，并随意命名。当然，即使他们给他们的笔记本电脑取了不同的名字，它毕竟还是一台笔记本电脑。所以下面这条线是完全合法的。</p><pre class="kr ks kt ku gt mi kp mj mk aw ml bi"><span id="310e" class="mm kz iq kp b gy mn mo l mp mq">const benAndJohnsLaptops: Laptop[] = [bensLaptop, johnsLaptop]</span></pre><p id="9ab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">与总是引入命名对象类型的接口声明不同，一个</em> <strong class="jp ir"> <em class="kl">类型别名声明</em> </strong> <em class="kl">可以引入任何类型的名称，包括原语、并集和交集类型。</em></p><p id="2d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以给<a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank">原始类型</a>一个类型别名，这是<code class="fe km kn ko kp b">interface</code>做不到的。以以下示例为例:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Creating a type alias for a primitive type</figcaption></figure><h1 id="8dd5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">接口与类型</h1><p id="1f7f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下面是接口可以做什么和类型可以做什么的快速分解。</p><h2 id="8000" class="mm kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">1.两者都支持继承，尽管语法不同</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="ada2" class="mm kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">2.接口支持合并声明，而类型不支持</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="42bc" class="mm kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">3.类型支持为基元类型、联合和元组创建别名。接口不</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="01cb" class="mm kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">那么…我什么时候应该使用<strong class="ak">界面</strong>以及什么时候应该使用<strong class="ak">类型</strong>？</h2><p id="69ef" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">首先想想你想先实现什么，然后决定用哪一个。你需要遗产吗？接口。需要为基本类型创建别名吗？键入。需要<a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html" rel="noopener ugc nofollow" target="_blank">合并申报</a>吗？接口。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="1136" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是否帮助您理解了接口和类型之间的区别？请一定在评论中告诉我。如果我没有，让我知道我错过了什么，我会尽力而为。</p><h2 id="c2ec" class="mm kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">进一步阅读</h2><ul class=""><li id="2888" class="nj nk iq jp b jq lw ju lx jy nl kc nm kg nn kk no np nq nr bi translated"><a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/interfaces.html" rel="noopener ugc nofollow" target="_blank">打字稿文档-界面</a></li><li id="d6c9" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#interfaces-vs-type-aliases" rel="noopener ugc nofollow" target="_blank">类型脚本-接口与类型别名的比较</a></li></ul></div></div>    
</body>
</html>