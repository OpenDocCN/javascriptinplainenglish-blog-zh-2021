<html>
<head>
<title>Next.js 11, Module Federation, and SSR — A brave new world</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js 11、模块联盟和SSR——一个勇敢的新世界</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-11-module-federation-and-ssr-a-whole-new-world-6da7641a25b4?source=collection_archive---------0-----------------------#2021-07-24">https://javascript.plainenglish.io/next-js-11-module-federation-and-ssr-a-whole-new-world-6da7641a25b4?source=collection_archive---------0-----------------------#2021-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cdf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个11和模块联盟的服务器端渲染已经准备好了！额外收获:我们在联邦应用程序上实现了“热”(实时)重载！</p><p id="2d48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在next.js应用程序中实现模块联合是一条漫长而痛苦的道路——但我们最终能够消除大部分痛苦。</p><p id="740f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我第一次可以自信地说，我们已经能够在Next.js中实现全面的模块联合——不仅是客户端，还有服务器端！</p><p id="8152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个月前，我们演示了代码流的概念，想法是让Node像浏览器一样工作，下载远程块，并在其进程下执行它们。这是无缝和简单的，但带来了一些安全问题，在next.js的情况下，我们无法“热重新加载”生产，这些所需的块会被“卡住”,您的主机应用程序需要重新启动，以便重新获取更新的新远程块。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/654d78abd0bb92fda920282ad63e7f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*igm7orS9Yr33inZajjLbKw.jpeg"/></div></figure><h1 id="dadd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">向多服务器渲染问好！</h1><p id="7f25" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">模块联盟小组想出了一个更容易接受的解决方案来解决联盟SSR问题。我们的解决方案不仅仅适用于Next.js应用程序——但本文将重点关注在one Next.js上下文中利用我们的新系统</p><p id="1650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Jacob概述了底层架构的更多细节</p><div class="lw lx gp gr ly lz"><a href="https://www.ebey.me/blog/webpack-federation-ssr" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">Webpack联盟SSR | ebey.me</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">Webpack模块联盟已经成为微前端领域的游戏规则改变者，允许多个SPA作为一个整体运行…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">www.ebey.me</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kr lz"/></div></div></a></div><blockquote class="mo mp mq"><p id="46e0" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated">巨大的功劳，大声喊出来<a class="mv mw ep" href="https://medium.com/u/bada389d427c?source=post_page-----6da7641a25b4--------------------------------" rel="noopener" target="_blank">雅各布·伊比。</a>这一架构背后的关键部分和策划者</p></blockquote><p id="656c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多服务器渲染就像它听起来的那样，远程接受来自主机应用程序的道具，并在它们的原点执行渲染，发送回预渲染的HTML。整个过程非常快，如果你把它放在CDN后面，速度会更快。因为渲染一个组件只需要大约10毫秒到20毫秒，我们的解析器在更大的有效负载上只增加了5到7毫秒的开销。</p><p id="c150" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们从远程源获得标记，我们的解析器将HTML转换回React，如果您在远程组件中传递主机源的子组件，这些子组件将重新连接到主机渲染树和渲染上下文。因此，他们仍然能够参与渲染周期中发生的任何特定于应用程序的上下文。</p><p id="e135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的重要一点是，我们能够在任何远程组件的起点同时异步呈现这些组件，因此RTT瀑布不会开始形成，响应时间与最慢的响应一样快——就像<code class="fe mx my mz na b">Promise.all</code></p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="7911" class="nf ku iq na b gy ng nh l ni nj">import {<br/>  getOrCreateFederatedComponentCtx,<br/>  federatedComponentsContext,<br/>  federatedComponent,<br/>} from "nextjs-shared";<br/><br/>import remotes from "../remotes";<br/><br/>const Header = federatedComponent("home", "./header");<br/><br/>function MyApp({ Component, pageProps, federatedComponentsCtx, shellData }) {<br/>  return (<br/>    &lt;federatedComponentsContext.Provider<br/>      value={getOrCreateFederatedComponentCtx(<br/>        { remotes },<br/>        federatedComponentsCtx<br/>      )}<br/>    &gt;<br/>      &lt;Header items={shellData.header.menu} /&gt;<br/>      &lt;Component {...pageProps} /&gt;<br/>    &lt;/federatedComponentsContext.Provider&gt;<br/>  );<br/>}</span></pre><h2 id="920e" class="nf ku iq bd kv nk nl dn kz nm nn dp ld jy no np lh kc nq nr ll kg ns nt lp nu bi translated">水合作用和避免闪烁</h2><p id="f0f5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">用户体验需要无缝，所以我们不能在水合过程中发生任何闪烁。为了实现这一点，我们利用了一种类似于react-lazy-hydration的机制，其中我们只在启动时将部分来自HTML的react树合并到交互式react中。这保留了现有的标记，并抑制了任何可能发生的水合作用问题。一旦Webpack启动并且联邦代码被执行，SSR的远程模块就被合并成一个联邦react组件。</p><p id="7723" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我广泛使用反应-惰性-水合来提高性能，卸载昂贵的组件，这样它们只在达到TTI或即将滚动到交叉点观察器的视图中时才被水合。所以对联邦SSR应用类似的策略对我来说是完全可以接受的，而且非常有效。</p><h2 id="6379" class="nf ku iq bd kv nk nl dn kz nm nn dp ld jy no np lh kc nq nr ll kg ns nt lp nu bi translated">模块联合和区块刷新又回来了！</h2><p id="b4f8" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">来自社区的一个很大的要求是，像react-loadable或loadable-components这样的包不能“清洗”和呈现所使用的联合Javascript标签和样式表。当远程容器启动时，会导致额外的RTT，并且必须立即下载这些额外的JS块。</p><p id="67ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的新解决方案解决了这个问题，在我们最新的架构设计下，服务器端呈现的联邦模块也清除了它们的JS和CSS块。世界秩序已经恢复了！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/a77ab3e8f7a683e6e050353b00241ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*cdKeu-y-2y54mgy-sMdWUQ.png"/></div></figure><p id="f259" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然其他第三方不支持联合块刷新，但当使用我们的“fetchFederatedComponent”函数时，刷新将按预期发生，并且我们独立处理联合块的刷新。如果您使用代码分割，请继续为您的内部块使用可加载组件，但是您将能够使用我们的联邦函数在SSR期间将那些关键资产呈现给DOM。</p><p id="edfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将CSS和js块放入next.js上下文中，这样next就一直知道这些额外的脚本——确保在再水合过程中没有闪烁，没有额外的RTT来减缓您的加载时间。</p><h2 id="bb2f" class="nf ku iq bd kv nk nl dn kz nm nn dp ld jy no np lh kc nq nr ll kg ns nt lp nu bi translated">让Module Federation和Next.js玩得开心</h2><p id="6b2b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Next.js不支持开箱即用的模块联合，您需要依赖来自提供支持的模块联合组的<a class="ae nw" href="https://app.privjs.com/buy/packageDetail?pkg=@module-federation/nextjs-mf" rel="noopener ugc nofollow" target="_blank">插件</a>。据我所知，近期没有计划看到Next.js支持模块联盟开箱即用，当它到来时，SSR支持将变得可用的可能性很小。在撰写本文时，我相信MF Group是唯一拥有在Next平台上提供“无限制”功能的技术的组织。</p><p id="220c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nw" href="https://app.privjs.com/buy/packageDetail?pkg=@module-federation/nextjs-mf" rel="noopener ugc nofollow" target="_blank"> nextjs-mf </a>插件启用了<strong class="jp ir">客户端</strong>上的模块联合，无论SSR如何，你都需要它来使联合工作。</p><div class="lw lx gp gr ly lz"><a href="https://app.privjs.com/buy/packageDetail?pkg=@module-federation/nextjs-mf" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">PRIVJS |将您的代码货币化</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">使用create-react-app创建的网站</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">app.privjs.com</p></div></div></div></a></div><h1 id="11c5" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Next.js应用程序上的模块联合案例</h1><p id="5ac3" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Next.js不是模块化的，它非常单一，主要关注更快的单一构建。但这种模式是不可持续的，Next Zones试图接近一个更加模块化的设置，但你仍然被锁定在页面垂直方向，并且在切换区域时无法逃脱整个页面的重新加载。</p><p id="4381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">联邦使我们能够使Next.js高度模块化。您可以开发一个MegaNav，它可以独立于应用程序的其余部分进行部署，或者以一种更细粒度和自治的方式来划分团队。团队可以拥有组件，并且不被链接到一个页面，这些组件可以很容易地跨其他页面分布，而不需要重新部署整个Next.js实例或多个实例。你不必依赖npm包作为分发共享代码的方式，也不必依赖第三方供应商的ESI等模式来获得某种模块化。</p><p id="42d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着服务器端渲染的解决，利用模块联合来更有效地驯服和扩展Next.js没有任何缺点。</p><h2 id="32a7" class="nf ku iq bd kv nk nl dn kz nm nn dp ld jy no np lh kc nq nr ll kg ns nt lp nu bi translated">没有页面重新加载！！</h2><p id="e1c8" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Next Zones的想法是正确的，但现在是时候告别在应用程序之间跳转时的页面重载了，取而代之的是欢迎联合页面路由。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nx"><img src="../Images/1b33609c60402c5144458d2c5a56be5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuCj3vRa0tez7fxYV74rNg.jpeg"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk">And the 97 lighthouse score speaks for itself</figcaption></figure><p id="5200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的核心概念是，您留在宿主应用程序上，而不是将页面联合到该应用程序中，而不是重新加载，并从另一个应用程序中SSR另一个页面。SSR是要花钱的，它避免了页面刷新，相反，利用客户端路由简单地从另一个应用程序中提取页面更快、更便宜，而且用户体验更好。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="9d5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使这成为可能，我们利用了模块联合的机制，next.js是一个无所不包的路由。</p><p id="b9fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在Github上有一个全向分布式路由的原始例子。</p><div class="lw lx gp gr ly lz"><a href="https://github.com/module-federation/module-federation-examples/tree/master/nextjs" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">主模块-联合/模块-联合-示例处的模块-联合-示例/nextjs</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">Next.js中的模块联合依赖于@module-federation/nextjs-mf，除非您可以访问它，否则它不会工作…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="oi l mk ml mm mi mn kr lz"/></div></div></a></div><p id="37e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个应用程序都通过模块联合来公开一个路由映射，而CatchAll页面将所有远程路由映射联合在一起，然后使用一些简单的模式识别来查看当前路径是否与从特定远程路由的任何现有映射匹配，如果匹配，我们调用该远程并获取联合页面—如果我们无法解析路由，或者如果由于任何原因出现JS错误， CatchAll route简单地执行一个<code class="fe mx my mz na b">window.location.reload()</code>,通过您的应用程序基础设施将用户弹回，或者将他们带到另一个没有映射的SSR路由、外部URL或404页面。</p><p id="1db9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种机制以及我们为Next.js设计的联邦插件确保了即使联邦页面有错误，Next.js路径也不会有错误，保证了页面之间的导航总是有效的，并且在最坏的情况下退回到页面重新加载。</p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="39b0" class="nf ku iq na b gy ng nh l ni nj">// [...slug].js<br/>import { createFederatedCatchAll } from "nextjs-shared"; export default createFederatedCatchAll(["checkout", "home"]);</span></pre><p id="015a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及createFederatedCatchAll背后的魔力</p><pre class="km kn ko kp gt nb na nc nd aw ne bi"><span id="1fd6" class="nf ku iq na b gy ng nh l ni nj">export function createFederatedCatchAll(remotes) {<br/>  const FederatedCatchAll = (initialProps) =&gt; {<br/>    const [lazyProps, setProps] = React.useState({});<br/><br/>    const { FederatedPage, render404, renderError, needsReload, ...props } = {<br/>      ...lazyProps,<br/>      ...initialProps,<br/>    };<br/><br/>    React.useEffect(async () =&gt; {<br/>      if (needsReload) {<br/>        const federatedProps = await FederatedCatchAll.getInitialProps(props);<br/>        setProps(federatedProps);<br/>      }<br/>    }, []);<br/><br/>    if (render404) {<br/>      // <em class="mr">TODO: Render 404 page<br/>      </em>return React.createElement("h1", {}, "404 Not Found");<br/>    }<br/>    if (renderError) {<br/>      // <em class="mr">TODO: Render error page<br/>      </em>return React.createElement("h1", {}, "Oops, something went wrong.");<br/>    }<br/><br/>    if (FederatedPage) {<br/>      return React.createElement(FederatedPage, props);<br/>    }<br/><br/>    return null;<br/>  };<br/><br/>  FederatedCatchAll.getInitialProps = async (ctx) =&gt; {<br/>    const { err, req, res, AppTree, ...props } = ctx;<br/><br/>    if (err) {<br/>      // <em class="mr">TODO: Run getInitialProps for error page<br/>      </em>return { renderError: true, ...props };<br/>    }<br/><br/>    if (!<strong class="na ir"><em class="mr">process</em></strong>.browser) {<br/>      return { needsReload: true, ...props };<br/>    }<br/><br/>    try {<br/>      const matchedPage = await matchFederatedPage(remotes, ctx.asPath);<br/><br/>      const remote = matchedPage?.value?.remote;<br/>      const mod = matchedPage?.value?.module;<br/><br/>      if (!remote || !mod) {<br/>        // <em class="mr">TODO: Run getInitialProps for 404 page<br/>        </em>return { render404: true, ...props };<br/>      }<br/><br/>      <strong class="na ir"><em class="mr">console</em></strong>.log("loading exposed module", mod, "from remote", remote);<br/>      try {<br/>        if (!<strong class="na ir"><em class="mr">window</em></strong>[remote].__initialized) {<br/>          <strong class="na ir"><em class="mr">window</em></strong>[remote].__initialized = true;<br/>          await <strong class="na ir"><em class="mr">window</em></strong>[remote].init(__webpack_share_scopes__.default);<br/>        }<br/>      } catch (initErr) {<br/>        <strong class="na ir"><em class="mr">console</em></strong>.log("initErr", initErr);<br/>      }<br/><br/>      const FederatedPage = await <strong class="na ir"><em class="mr">window</em></strong>[remote]<br/>        .get(mod)<br/>        .then((factory) =&gt; factory().default);<br/>      <strong class="na ir"><em class="mr">console</em></strong>.log("FederatedPage", FederatedPage);<br/>      if (!FederatedPage) {<br/>        // <em class="mr">TODO: Run getInitialProps for 404 page<br/>        </em>return { render404: true, ...props };<br/>      }<br/><br/>      const modifiedContext = {<br/>        ...ctx,<br/>        query: matchedPage.params,<br/>      };<br/>      const federatedPageProps =<br/>        (await FederatedPage.getInitialProps?.(modifiedContext)) || {};<br/>      return { ...federatedPageProps, FederatedPage };<br/>    } catch (err) {<br/>      <strong class="na ir"><em class="mr">console</em></strong>.log("err", err);<br/>      // <em class="mr">TODO: Run getInitialProps for error page<br/>      </em>return { renderError: true, ...props };<br/>    }<br/>  };<br/><br/>  return FederatedCatchAll;<br/>}</span></pre><h1 id="fa1e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">对联邦SSR感兴趣？联系我们！</h1><p id="9299" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们的SSR实现不是开源的，并且花费了大量的时间和精力来开发，对于任何对利用我们的技术感兴趣的公司，我们很乐意举办研讨会或咨询，模块联盟组接受客户。我们是模块联邦的创造者</p><p id="87c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以联系:<a class="ae nw" href="mailto:Zackary.l.jackson@gmail.com" rel="noopener ugc nofollow" target="_blank">zackary.l.jackson@gmail.com</a>，或者通过Twitter<a class="ae nw" href="https://twitter.com/ScriptedAlchemy" rel="noopener ugc nofollow" target="_blank">ScriptedAlchemy</a>/<a class="ae nw" href="https://twitter.com/ebey_jacob" rel="noopener ugc nofollow" target="_blank">ebey _ Jacob</a>，或者直接预订一个研讨会:</p><div class="lw lx gp gr ly lz"><a href="https://calendly.com/scripted-alchemy/next-js-federated-ssr-workshop" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">Next.js联合SSR研讨会- Zack Jackson</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">Workshop plus对源代码的私人访问，该源代码包含Next.js - 8上的联合SSR的参考架构…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">calendly.com</p></div></div><div class="mi l"><div class="oj l mk ml mm mi mn kr lz"/></div></div></a></div><h2 id="0569" class="nf ku iq bd kv nk nl dn kz nm nn dp ld jy no np lh kc nq nr ll kg ns nt lp nu bi translated">进一步阅读</h2><div class="lw lx gp gr ly lz"><a href="https://plainenglish.io/blog/which-database-should-you-use-for-your-next-js-app" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">Next.js应用程序应该使用什么数据库？</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">如果你在2022年要开发一个全栈应用，选择流行的Next.js会让你有95%的机会…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">简明英语. io</p></div></div><div class="mi l"><div class="ok l mk ml mm mi mn kr lz"/></div></div></a></div></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="0288" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mr">更多内容看</em> <a class="ae nw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mr">说白了。报名参加我们的</em> <a class="ae nw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mr">免费周报</em> </strong> </a> <em class="mr">。关注我们关于</em> <a class="ae nw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mr">推特</em> </strong> </a>，<a class="ae nw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mr">LinkedIn</em></strong></a><em class="mr">，</em><a class="ae nw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mr">YouTube</em></strong></a><em class="mr">，</em> <a class="ae nw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mr">不和</em> </strong> </a> <em class="mr">。对增长黑客感兴趣？检查</em> <a class="ae nw" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mr">电路</em> </strong> </a> <em class="mr">。</em></strong></a></p></div></div>    
</body>
</html>