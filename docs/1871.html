<html>
<head>
<title>ReactBits: Clearable Input with Autofocus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactBits:自动对焦的清晰输入</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reactbits-clearable-input-with-autofocus-bad64462ab4?source=collection_archive---------20-----------------------#2021-04-19">https://javascript.plainenglish.io/reactbits-clearable-input-with-autofocus-bad64462ab4?source=collection_archive---------20-----------------------#2021-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5793" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">小型可重复使用的组件</h2></div><p id="f131" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天，我开始了一系列的短文，我将称之为ReactBits，在这些短文中，我将张贴一些具有一些特定要求的小组件，您可以适应在您的项目中使用，但更重要的是，知道如何实现它们以及这样做可能面临的挑战，第一个如标题所示，具有自动对焦的清晰输入。</p><h2 id="b5bf" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">要求</h2><ul class=""><li id="0d64" class="lu lv iq kh b ki lw kl lx ko ly ks lz kw ma la mb mc md me bi translated">一个<strong class="kh ir">输入</strong>，里面有一个<strong class="kh ir">清除</strong>按钮</li><li id="a8ee" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">只有当<strong class="kh ir">输入</strong>不为空并且被聚焦时，才会显示<strong class="kh ir">清除</strong>按钮。</li><li id="07ac" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">使用<strong class="kh ir">清除</strong>按钮清除<strong class="kh ir">输入</strong>后，它应保持焦点，以便用户可以继续书写。</li></ul><h2 id="c203" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">模拟的</h2><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/26d32a737b7c763fa79c36990871190d.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*KiL1EeGW-y1LCWxFNXMSbg.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Very simple mock</figcaption></figure><h2 id="6407" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">计划</h2><p id="1f79" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">对于这个组件，我们将使用一个内部状态，这样我们可以控制<strong class="kh ir">清除</strong>按钮的可见性，我们还将使用焦点的引用。为了清楚起见，我将包括控制输入值的状态和<code class="fe mz na nb nc b">onChange</code>处理程序，在生产项目中，这应该在父项目中完成。</p><h2 id="3ee0" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">初始代码</h2><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/38f0da149a35db201358ec3dea0b3d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRYFjMzTQ65Le25bocFFPQ.png"/></div></div></figure><p id="b531" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在前面的代码中，我们创建了<strong class="kh ir">输入</strong>和<strong class="kh ir">清除</strong>按钮，我们还有自己的处理函数<code class="fe mz na nb nc b">handleChange</code>和<code class="fe mz na nb nc b">handleClear</code>来设置和移除<strong class="kh ir">输入</strong>的值。</p><h2 id="1ff6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">显示清除按钮</h2><p id="94b9" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">作为对等需求，这应该只在输入有一个值并且它被聚焦时才显示。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ni"><img src="../Images/9457f9a32e503dd0131bc65eda96abc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmfVce3dITz_HpT-H6KR8Q.png"/></div></div></figure><p id="d386" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们引入了一个新的状态变量<code class="fe mz na nb nc b">showClear</code>，我们添加了一个新的处理程序<code class="fe mz na nb nc b">handleFocus</code>，当<strong class="kh ir">输入</strong>获得焦点时，我们将状态变量设置为<code class="fe mz na nb nc b">true</code>，然后我们使用状态变量<code class="fe mz na nb nc b">value</code>和<code class="fe mz na nb nc b">showClear</code>来决定我们是否应该显示<strong class="kh ir">清除</strong>按钮。</p><h2 id="65ea" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">参考</h2><p id="be7f" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们遗漏了两件事，当<strong class="kh ir">输入</strong>失去焦点时隐藏<strong class="kh ir">清除</strong>按钮，当点击<strong class="kh ir">清除</strong>按钮时保持<strong class="kh ir">输入</strong>焦点。为此，我们将使用引用。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nj"><img src="../Images/c9970c17efd2e19f34d0fecc6c1c54fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhtsJy8HRoep58xgcHpNUA.png"/></div></div></figure><p id="43dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建了两个引用，一个用于<strong class="kh ir">输入</strong>本身，另一个用于容器，用于在点击<strong class="kh ir">清除</strong>按钮时保持焦点，我们只需添加:</p><pre class="ml mm mn mo gt nk nc nl nm aw nn bi"><span id="4f72" class="lb lc iq nc b gy no np l nq nr">inputRef.current.focus()</span></pre><p id="4848" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mz na nb nc b">handleClear</code>处理程序中再次设置焦点，因为当我们单击<strong class="kh ir">清除</strong>按钮时，焦点现在就在按钮上。</p><p id="caf5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一点，也可能是本文最复杂的一点，就是检测组件何时失去焦点(看我怎么没说<strong class="kh ir">输入</strong>而是整个组件，这就是我在容器中设置引用的原因)， 为此，我们将使用<code class="fe mz na nb nc b">useEffect</code>钩子来检测容器(<strong class="kh ir"> div </strong>)何时已经被呈现(参见我们如何在钩子的依赖数组中传递<code class="fe mz na nb nc b">containerRef</code>变量)以向其添加事件监听器，这将把<code class="fe mz na nb nc b">showClear</code>状态变量改为false，以隐藏<strong class="kh ir">清除</strong>按钮。</p><p id="1c65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mz na nb nc b">useEffect</code>钩子中，当组件被卸载时，我们有一个移除事件监听器的返回。</p><h2 id="b519" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="0e69" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">这是一个小组件，我们必须使用3个最常用的钩子<code class="fe mz na nb nc b">useEffect</code>、<code class="fe mz na nb nc b">useRef</code>和<code class="fe mz na nb nc b">useSate</code>来实现它，我们还使用Typescript来查看如何对事件进行类型化，这是许多文档所缺乏的。</p><p id="9b38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，这是原始代码，以防你想更深入地检查它。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b0e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读。</p><p id="0fdd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nu">更多内容请看</em><a class="ae nv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nu">plain English . io</em></strong></a></p></div></div>    
</body>
</html>