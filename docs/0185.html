<html>
<head>
<title>What Is Flux Architecture In React Native?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中的Flux架构是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-flux-architecture-in-react-native-d886ce978cf0?source=collection_archive---------6-----------------------#2021-01-11">https://javascript.plainenglish.io/what-is-flux-architecture-in-react-native-d886ce978cf0?source=collection_archive---------6-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="89aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于在React Native中使用通量模式，您需要知道的是</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bf3bf23c8654151e8c47718d540b5e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AyJgvE5WvRVOXsjK.png"/></div></div></figure><h1 id="a7a6" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">通量架构</h1><p id="bbda" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Flux Architecture只是一个在React中构建用户界面的架构。为了理解<strong class="ll ir"> <em class="mf">通量架构</em> </strong>我们需要首先开始什么是React中的<strong class="ll ir">单向数据流</strong>模式，这将引导我们进行通量。这里你需要理解两个关键点，那就是如何分离代码，以及如何使用<strong class="ll ir"> <em class="mf"> Flux </em> </strong>将一个应用拆分成几个部分。这些连接在一起模式负责现代移动应用程序中的一切。</p><h1 id="7934" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">什么是单向数据流模式？</h1><p id="3478" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了理解通量架构，我们需要知道我们为什么需要它。观察从<strong class="ll ir">模型-视图-控制器</strong> (MVC)模式切换到Flux的<strong class="ll ir">脸书</strong>，在那里我们将业务模型从视图标记和编码逻辑中分离出来。逻辑由一个称为控制器的函数封装，它将工作委托给服务。</p><h1 id="ae22" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">React中单向数据绑定的问题</h1><p id="8b36" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在单向数据绑定中，<strong class="ll ir">视图</strong>层由一个组件维护，只有组件可以更新视图。由于产生的本机代码由组件<strong class="ll ir"> <em class="mf">计算，呈现</em> </strong>功能并显示给最终用户。</p><p id="e4a7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">而如果<strong class="ll ir">视图</strong>层需要响应用户的动作，它只能调度由组件处理的事件，它只能直接改变状态或道具。</p><p id="b3f8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="mf">下图将更好地理解这一概念；</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/ad3fd58034533d0da28112ce86135972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1nOjcORSK2goAY7evL0_Q.png"/></div></div></figure><ul class=""><li id="109e" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated"><strong class="ll ir"> App </strong>块表示原生视图层的状态，组件被隐含成三个部分:<strong class="ll ir"> Props，state，</strong>Renderfunction&amp;事件监听器。</li><li id="f7cd" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">当道具或状态发生变化时，观察者调用<strong class="ll ir">渲染</strong>函数来更新本地视图。一旦用户执行了一个动作，事件监听器就会分派并接收一个事件。</li></ul><blockquote class="na nb nc"><p id="02eb" class="lj lk mf ll b lm mg jr lo lp mh ju lr nd mi lu lv ne mj ly lz nf mk mc md me ij bi translated"><strong class="ll ir">但是在双向绑定的情况下，App层不需要调度事件，它可以直接修改组件的状态</strong></p></blockquote><p id="55b4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">此外，使用单向数据绑定是不够的，因为我们很容易陷入模拟双向数据绑定的陷阱。</p><p id="e31e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">因此，这里的大问题是:我们能否将它用于更大的应用程序，答案是否定的。要解决这个问题，我们需要一个可预测的模型，保证我们可以快速发现过程中发生了什么，尤其是为什么会发生。</p><blockquote class="na nb nc"><p id="5a2e" class="lj lk mf ll b lm mg jr lo lp mh ju lr nd mi lu lv ne mj ly lz nf mk mc md me ij bi translated">如果事件发生在整个应用程序中，开发人员必须花费大量时间来找出是什么导致了检测到的错误。</p></blockquote><p id="b08d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">这就是</strong> <em class="mf">通量架构</em> <strong class="ll ir">发挥作用的地方:</strong></p><h1 id="6cd2" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">流量</h1><p id="f3a2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">主要原理是应用程序视图层通过将动作对象发送到<strong class="ll ir">调度程序来响应用户动作，</strong>调度程序的角色是将每个动作发送到订阅的商店。我们可以有尽可能多的商店，每个商店都可以对用户的行为做出不同的反应。</p><p id="6c21" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">例如:</strong></p><ul class=""><li id="a897" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">假设您正在构建一个基于<strong class="ll ir">购物车的</strong>应用程序，用户可以点击屏幕向购物车添加一些商品，相应的动作是<strong class="ll ir"> <em class="mf"> dispatched </em> </strong>并且您的购物车商店对其做出反应。最后，视图层用新状态更新。</li></ul><p id="3cc5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了增强<strong class="ll ir"> MVC模式</strong>，让我们提醒自己它是什么样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/7b3e1d483aa782295938dfecbcf144ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Hvt_ASganrlRyHFuuTR9w.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk"><strong class="bd nl">MVC Pattern</strong></figcaption></figure><ul class=""><li id="7b49" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated"><strong class="ll ir">动作:</strong>用户的动作，如按钮点击、滚动或导航改变。</li><li id="62e6" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated"><strong class="ll ir">控制器:</strong>负责处理动作和显示适当的本地视图的一块。</li><li id="dc08" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated"><strong class="ll ir">模型:</strong>一种保存从视图中分离出来的信息的数据结构。</li><li id="9827" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">视图:这是最终用户看到的，视图描述了所有的标记代码，这些代码可以在以后进行样式化。视图有时可以与样式结合在一起，被称为一个整体。</li></ul><blockquote class="na nb nc"><p id="68b1" class="lj lk mf ll b lm mg jr lo lp mh ju lr nd mi lu lv ne mj ly lz nf mk mc md me ij bi translated"><strong class="ll ir">但是随着应用程序的增长，你的小架构将会如下所示:</strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/9a9c26348535cdbcb882b10bed1981d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Zng-OMWePGRPNOdAv35oQ.png"/></div></div></figure><p id="c320" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这种方法并不坏，即使这种架构在某种程度上以自己的方式工作。但是，当您试图识别一个bug，却发现自己无法定位哪里以及为什么会出错时，问题就出现了。</p><p id="615f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">更精确地说，你将失去对信息流的控制，并且你将结束于这样一种情况，即如此多的过程正在发生，而同时你不能容易地发现什么是失败的原因以及它为什么会发生。如果你看上面的图表，你会发现模型-视图通信中数据双向流动的问题<strong class="ll ir"> <em class="mf">(它是双向的)。</em> </strong></p><ul class=""><li id="7558" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">为了解决这个问题，我们可以提供<strong class="ll ir">单向</strong>数据流，这将有效地使架构可预测，如果我们的控制器只有一系列输入数据，我们应该提供一个新的视图状态，这将更加清晰。</li><li id="6750" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">单元测试可以提供一系列数据，比如输入和输出断言。</li></ul><blockquote class="na nb nc"><p id="6da0" class="lj lk mf ll b lm mg jr lo lp mh ju lr nd mi lu lv ne mj ly lz nf mk mc md me ij bi translated">现在我们来看看<strong class="ll ir"> Flux数据流:</strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/e64e30ca4ffdbe8d78d2dcc2beaf1f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oU6WgXnQMYvI8YOcUd_rpg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk"><strong class="bd nl">Flux Data Flow</strong></figcaption></figure><p id="aef8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这里所有的数据经过<strong class="ll ir">调度器</strong>，然后发送到注册商店<strong class="ll ir">回调</strong>。最后，存储内容被映射到一个视图。随着应用程序的增长，这种模式也会变得复杂(类似于双向数据流的情况，但是这里我们的视图被组合成用户看到的最终视图)。</p><p id="a9e9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果有什么变化，另一个动作会被发送到商店。这是一种简单得多的方法，我们可以跟踪哪个操作导致了商店中不必要的变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/2f6acd59fee14f781b9e53facfe022f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAkFB3jLa_9HaabXptGjTw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk"><strong class="bd nl">Flux Data Flow (After Application Grows )</strong></figcaption></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="1e76" class="kr ks iq bd kt ku nw kw kx ky nx la lb jw ny jx ld jz nz ka lf kc oa kd lh li bi translated">在React本地应用中实现Flux</h1><p id="2407" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了进一步理解这个概念，我们将使用由<strong class="ll ir">脸书</strong>提供的Flux库创建一个简单的任务应用程序，包括我们根据新的Flux流创建应用程序所需的所有部分。</p><p id="3218" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">要在React-Native项目中安装Flux:</p><p id="5d4f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> <em class="mf">纱线添加通量不可变</em> </strong></p><p id="fca9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">因此，首先，我们需要创建<strong class="ll ir">分派器</strong>、<strong class="ll ir">任务存储库</strong>和<strong class="ll ir">任务动作。</strong></p><ul class=""><li id="f31b" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">一个<strong class="ll ir">分派器</strong>将被用来分派动作，我们需要首先创建动作。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/e02ed464300fc6bedf0b68d43526b6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HG_Gf9fhPmr8v6mK6yAaQ.png"/></div></div></figure><ul class=""><li id="7703" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">按照文档建议，我将首先创建操作类型:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/2c97397b9e93ec560b71cdfb2189a61c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWCfqc0T9ByHkPJqEcoGfw.png"/></div></div></figure><ul class=""><li id="e1b8" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">所以现在我们已经创建了类型，我们将遵循creator的操作。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/979d53d525b11b7e0ee667fe6fd07f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HRefJiB8-rMrN9hqxMRU_g.png"/></div></div></figure><ul class=""><li id="dff1" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">现在我们已经创建了动作和调度它们的工具，剩下的就是创建将对<strong class="ll ir">动作做出反应的<strong class="ll ir">存储</strong>。让我们创建TodoStore</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/7393f5d7545e1a1b9ba0dc70f70b25a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlvFtGpYqF83emp0RbRsXg.png"/></div></div></figure><ul class=""><li id="bce8" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">为了创建商店，我们从<strong class="ll ir"> <em class="mf"> flux/utils </em> </strong>中导入<strong class="ll ir"> ReduceStore </strong>，并且应该扩展该类以提供必要的<strong class="ll ir"> <em class="mf"> API </em> </strong>方法。</li><li id="24f7" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">另外，让我们为<strong class="ll ir"> ADD-TASK </strong>创建<strong class="ll ir"> reduce </strong>用例，同样的流程可以调整为您想要创建的任何其他动作类型:</li><li id="7621" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">到目前为止，我们已经创建了Flux architecture的所有部分(<strong class="ll ir">动作、调度器、存储&amp;视图)</strong>，我们可以将它们连接在一起。为此，我们有flux/utils，它提供了一个方便的容器工厂方法。</li><li id="4b49" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">为了清楚起见，我删除了“喜欢”计数器:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/279eaafbd8e9de36453f3968db5f222b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWDKnfRvomY5DsLhEP4s6w.png"/></div></div></figure><ul class=""><li id="a8b8" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">现在，我们的应用程序配备了Flux架构工具:</li><li id="8bc6" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">最后一步是重构所有的原则。</li><li id="8591" class="mm mn iq ll b lm mv lp mw ls mx lw my ma mz me mr ms mt mu bi translated">要做到这一点，直接向视图&amp;初始化<strong class="ll ir"> JSON </strong>数据，创建一个添加任务表单，该表单在提交时发送一个<strong class="ll ir">添加-TAKS </strong>动作。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/7393f5d7545e1a1b9ba0dc70f70b25a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlvFtGpYqF83emp0RbRsXg.png"/></div></div></figure><ul class=""><li id="bdbe" class="mm mn iq ll b lm mg lp mh ls mo lw mp ma mq me mr ms mt mu bi translated">现在我们需要使用输入组件，因为我们将创建一个负责整个特性的单独文件(我们将为<strong class="ll ir">名称</strong>和<strong class="ll ir">描述</strong>创建状态，一个<strong class="ll ir"> handleSubmit </strong>函数调度<strong class="ll ir"> ADD_TASK </strong>动作，一个<strong class="ll ir"> render </strong>函数带有表单视图标记)。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/3b018e1038fe94d29da6af81952fe76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEGzpw8tLa2KX7oH0DY5Lg.png"/></div></div></figure></div></div>    
</body>
</html>