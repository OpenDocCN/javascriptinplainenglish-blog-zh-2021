# web 测试变得更容易了吗？

> 原文：<https://javascript.plainenglish.io/has-web-testing-become-easier-about-cypress-interception-and-the-value-in-testing-640920196676?source=collection_archive---------18----------------------->

## **关于柏树，拦截和测试中的价值**

![](img/a6d23298d43c594acbf6eacf08a23c22.png)

Photo by [David Travis](https://unsplash.com/@dtravisphd?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

大约两年前，我在 Medium 上写了一篇[文章](https://medium.com/@cdohotaru/principles-of-end-to-end-web-testing-7fa7d27d7826)，其中我谈到了网站测试生态系统的各个方面。从页面对象模式、单元、集成和端到端测试之间的差异，到一系列的技巧和窍门，以及从我参与的项目中学到的一些经验教训。我当时写的所有内容仍然有效，文章获得的持续流量——这种兴趣让我非常高兴，因为测试既复杂又非常重要——让我考虑写一篇后续文章。一些新的测试库——[Cypress](https://www.cypress.io/)——为自己在这个领域建立了良好的声誉，并带来了一些非常有趣的概念，这也促使我这样做。

那么，我们要谈什么？在这第一部分，我计划很快写第二部分；一旦准备好了，我会放一个链接。—我们将保持事情相当抽象，谈论概念。

正如 Cypress 团队所说，Web 已经发展了，现在是测试的时候了。我们将谈论现状，而不是——对于我们中的一些当时编写代码的人来说——有些痛苦，甚至可能不是那么有趣的 web 应用程序的历史。我们将重申测试作为面向未来的低维护工具的价值，最后我们将看看 Cypress 带来了什么，为什么我认为这是 web 测试变得更加容易的重要原因之一。我们开始吧！

## **单页应用有问题吗？**

你能想象脸书网站在你添加一张新的假日照片时重新加载页面，同时在聊天中询问你的朋友他/她是否可以被标记吗？如果当你和同事一起编辑文档时，Google Sheets 页面会重新加载，这对你有用吗？

如果答案是肯定的，那么你可能有非常丰富的想象力。

SPAs 的模式从单纯的 JavaScript 池机制发展成了大量非常专业的库，并被越来越多的 web 应用程序所接受。但今天令人震惊的复杂性也是如此。

一方面有很多代码。即使对于中等规模的 web 应用程序，仅用户界面组件及其状态管理就有数万行代码也并不罕见。另一方面，后端的一些复杂性已经转移到前端，或者说必须复制到前端。

越来越多的公司开始使用组件库(一组用于构建整个用户界面的组件，使其具有相同的外观和感觉)。这种方法几乎没有什么新东西，除了现在比以往任何时候都更容易构建自己的或者使用现有的。构建/借用一次，随处重用。当然，这样做有很多好处，随着时间的推移，越来越多的代码以这些库为核心。缺点是:一个简单的错误就能让你的用户界面瘫痪。

所有这些一起让我们享受了这么多关于互联网的美好事物，但这一切是如何测试的呢？我们如何确保用户在使用我们的应用时获得质量和安全性？这并不是试图成为——当然也不可能是——一个关于测试的详尽的教程，但是希望它的内容能够提供一些指导。

## **测试单页应用**

在我之前的文章中，我们使用了一个购物网站来处理一些例子。让我们继续使用这个例子。

一个常见的场景是类似登录和购买商品这样的核心功能:

*   注册
*   转到产品列表—我确定我的产品在那里，所以我不需要搜索它
*   将产品放入购物车
*   继续结帐
*   焦急地等待交付(不需要测试)

如果我们要用更传统的测试库来测试这个核心业务场景，比如 [Selenium](https://www.selenium.dev/) 或 [NightwatchJs](https://nightwatchjs.org/) ，步骤应该是这样的:

*   创建所需的页面对象(登录、产品列表、购物车、结账)
*   为登录创建一个测试帐户或使用一个专用帐户
*   播种或以某种方式填充产品列表
*   编写用户旅程测试:登录->选择产品->添加到购物篮->去结帐
*   断言旅程中每一步的条件

现在让我们看看如何用 Cypress 带来的一些新概念来实现这一点。以下是一些可能的步骤

*   创建所需的页面对象(登录、产品列表、购物车、结账)
*   拦截登录、产品列表、添加到购物篮和结帐请求(稍后将详细介绍拦截)
*   编写用户旅程测试:登录->选择产品->添加到购物篮->去结帐
*   断言旅程中每一步的条件

嗯，我们有 4 个步骤，而不是 5 个。这是赛普拉斯的胜利吗？我想是的。先说拦截，事后再回到例子。

## **柏树拦截**

顾名思义，拦截是在测试运行时，在浏览器的网络级别发生的拦截。拦截的内容和返回的内容取决于您的设置。请求和响应都可以被嘲笑。如果请求被嘲笑，就不会有任何东西通过你的服务器。虽然这看起来是个问题，但实际上却带来了一些机会。

Cypress 有一个很好的文档，如果你想了解什么是拦截，这里有一个 [*的链接。*](https://docs.cypress.io/api/commands/intercept.html#Comparison-to-cy-route)

Cypress 通过包装运行测试的浏览器来工作——或者用他们自己的话说:“在同一个循环中”。通过这种方式，它可以访问浏览器 API，这允许它除了进行其他整洁的事情之外，还可以进行拦截，例如打开开发人员工具进行调试。更多详情请上 [*首页*](https://www.cypress.io/how-it-works)

在上面的登录案例中，代码可能如下所示:

`cy.intercept(‘/login’, { fixture: ‘successfulLogin.json’ })`

你怎么看这个？Cypress，请拦截一个要在浏览器中加载的当前域上“登录”的请求(可通过 baseUrl 配置选项配置)并返回“successfulLogin.json”的内容作为其响应。赛普拉斯会很乐意这么做的。“successfulLogin.json”的内容可能是成功登录请求的 json 响应——以保持文件名的真实性——以及配置文件信息和执行 API 请求的令牌(如何在 Json 中放置有效的令牌是一个不同的故事，因为它因项目而异，但因为 Cypress 只是 JavaScript，所以您有很多选择)。如果您愿意的话，它也可以包含一个用于测试该场景的无效登录响应，只是不要忘记在文件名中反映出来。

从存根的角度来看，通常有两种选择:仅对某些请求使用模拟响应(可能是那些复杂的种子请求，例如:登录和结帐)或完全模拟所有响应。

*我相信我们还会看到一些最佳实践。拦截作为一个概念只是在去年(2020 年)才成为 Cypress 核心产品的一部分——在实验之前。我们需要多做一点试验，看看什么最有效。话虽如此，以下是我目前的做法。*

我更喜欢在需要时选择调用 API 换句话说，让请求传递给我的服务器，见下面的例子——为此，我需要一个有效的身份验证令牌。所以通常不会拦截登录。

一般来说，其余部分都可以拦截。然而，规则相当宽松。这取决于所测试的功能以及设置测试用例的复杂程度。我们需要记住，拦截很容易在组织模拟时变得混乱。

但是，还有一个方面，当我们在前面看这些步骤时，可能已经变得很明显了:拦截意味着我们不进行端对端测试，而只进行集成测试。这不是问题吗？

## **集成、端到端和测试金字塔**

正如我们之前谈到的，单页应用架构中的许多逻辑已经被转移或复制到前端。除此之外，由于用户体验的不断改善和功能的增加，导致这种架构中的错误的可能性在前端比后端高得多(当然，谷歌搜索用户界面可能不同意这一点，也不同意许多其他类型的项目，但我正在构建网络应用程序，所以一些想法主观上根植于这种体验)。也就是说，随着时间的推移，API 趋于稳定，但前端不断变化，以适应新的设备、分辨率、显示数据的方式，甚至可能是新的模式，比如[先离线](http://offlinefirst.org/)。

如果我们加上测试金字塔概念告诉我们应该有很多单元测试，一些集成测试和很少的端对端测试这一事实，就会开始产生偏差。

在前一篇[文章](https://medium.com/@cdohotaru/principles-of-end-to-end-web-testing-7fa7d27d7826)中，我也谈到了测试金字塔，但主要集中在编写端到端测试的技巧上。说实话，那时我还不知道赛普拉斯或者其他的解决方案来进行集成测试，至少对于前端来说，写起来很容易。我见过臃肿的测试架构，其中有很多对状态管理部分的嘲笑，或者是对通常需要修改的 SPa 后端的嘲笑。这些调整相当脆弱，只会惹恼工程师，让他们更加关注端对端或单元测试，将沙漏测试“金字塔”推向极端。这就是为什么我如此兴奋地看到这种破坏性拦截概念在赛普拉斯的产品。从这个角度来看，我们生活在一些激动人心的时代。

从实际的角度来看，您通过拦截绕过了许多复杂的设置，您只需要保持您的 HTML 选择器是最新的。用户界面动作必须导致*这些请求*和*这些用户界面更新*(我们将在第二部分看到清晰的例子，但是黑盒概念应该已经可见)。你的 web 应用程序使用的所有动作、缩减器、状态管理或者任何行话都没有被触及，但是它已经被测试过了。

但是让我们回到集成和端到端的问题上来。我们已经知道了好的实践:测试金字塔。我们知道前端的变化比后端更快/更多。现在我们也有了一个简单的解决方案。让我们回到例子。

至少在理论上，你可以只编写带有截取的测试。但我认为这有点过了。无论如何，您需要一个阶段环境和端到端测试。因此，最好有一个登录自己的机制——仍然在这里的电子商店示例中——这样您就有可能使用一些真实的数据。所以在我们的例子中:

*   我们可以登录并访问令牌来使用 API
*   拦截那些更容易被嘲笑而不是播种的请求
*   让与我们的测试无关的请求到达服务器

以下是一些可以被拦截的请求示例:

*   可能大多数测试的产品列表
*   购物车的内容
*   用户配置文件
*   也许结账过程本身

这些拦截中的每一个都使得编写测试变得容易，而这在以前需要花费大量的时间来设置。想象一下设置各种用户、产品和购物车的 API 请求的数量。或者如果你已经有了，你可能对测试维护很熟悉，因为有人在测试环境中以某种方式改变了测试中的数据，各种测试失败了，因为他们可以找到硬编码的数据。

现在，您可以在开发人员工具中打开 Network 选项卡的情况下点击 UI，然后简单地将请求的响应复制并粘贴到 Json 或 JavaScript fixtures 中。那容易吗！

![](img/7d503e5a479f3023294d4824e72d4565.png)

Photo by [Daniel von Appen](https://unsplash.com/@daniel_von_appen?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

## 可测试性是干净架构的一个特征

章节标题已经说明了这一点。如果你很难测试它，你不能假装你有一个干净的架构。在好的实践中:一个干净的架构是可测试的。每个人都可以随心所欲地阅读这句话，但是对我来说，这句话应该是这样的:*一个干净的架构很容易测试。雇佣一支工程师大军几乎可以实现任何目标——或者说我们被告知如此——但不一定容易也不一定便宜。*

现在，端到端测试使架构更易测试了吗？可能不是直接的，因为你基本上是在一个盒子里测试一个完成的功能。也许你会从哪些测试更脆弱或更容易出错中获得一些见解，但这并不是真正的驱动力。除非你真的在计划中包括测试。如果你在技术故障/计划期间在你的团队中谈论:“我们如何实现它，以便它是可测试的？”，那你就开了个好头。

我看到集成测试更像是一个驱动程序。尤其是当您想要拦截/模仿 API 时。他们正在仔细检查哪一个和如何写是最好的，以便问题能以最佳方式解决。但是必须满足与上述相同的条件:必须在规划中提前讨论。

我们可以问自己，作为一个玩笑，什么先出现:一个可测试的架构还是一个测试用例？

现在，无论你是否将测试视为更易测试的架构的驱动力，有一件事将会发生:你写的测试越多，你就越能写出可测试的代码，从而实现可测试的架构。从长远来看，这可能是测试投资的最佳收益。你开始把每一个问题都看成一个乐高拼图，你开始问自己和你的团队各种各样的问题:

*   大局是什么(问题/功能)？
*   参与者是什么(可能有一些**数据**，由 **API** 通过友好的 **UI** 提供)
*   什么是机制/管道(事物需要如何连接才能工作)？我可以使用一些已知的模式吗？
*   对于每一个管道和实际上是积木的演员(组成一个图形的拼图的碎片)？
*   有哪些可以出现问题的薄弱点？事情变得复杂的地方。
*   与可能稳定的功能相比，我们期望在哪里扩展功能？
*   我应该如何设计各个部分，以便我可以实现良好的可测试性？

从最后一点开始——在你在黑板上画出上述问题的答案后——事情会按照你知道的模式发展:

*   这个拼图块很复杂，我无法打破它，所以我最好把它分离出来，并为它编写单元测试
*   这些组件是耦合的，它们属于一起，但是我可以在这里写一个集成测试
*   但是这两个组件不需要如此耦合，这样我可以单独测试它们，只编写一个或两个测试来检查它们一起工作
*   如果我在这个层次上测试这个和这个——单元或者集成——我只需要 2 个端到端的测试来覆盖整个画面
*   依此类推，直到你所实现的(经过多年的大量实践，这不是一个 2 小时的计划会议)是一个好的可测试架构以及一个大的测试覆盖率

测试非常重要，不仅是因为它本身，还因为它有塑造你的技能和思维方式的力量。这其中有巨大的价值，像 Cypress 这样的工具已经使一些事情比以前容易得多。

以下是这篇文章的一些要点:

*   Cypress 带来了拦截特性，作为一种非侵入性的、低投资的工具，可以轻松地实现 web 应用程序的集成测试(甚至是遗留的)；它允许项目的大部分作为黑盒进行测试
*   使用截取工具，你的测试金字塔有很好的机会看起来像一个三角形而不是沙漏
*   测试——在任何级别、单元、集成和端到端——都是开发解决软件问题的工程师眼光的伟大工具

谢谢你陪我到最后！在下一部分中，我们将看一个小例子，并对构建 Cypress 测试系统时可以做出的一些决定进行评论。敬请期待！

![](img/f845433e86b534102dccbbf9a52af59c.png)

Photo by [Wilhelm Gunkel](https://unsplash.com/@wilhelmgunkel?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

*词汇注释:*

我在这里用嘲弄、存根和拦截来表达相同的意思，并把它们加以区别以避免重复。也就是说，拦截的响应被硬编码为一个给定值。

*我使用 seed 和 setup(一个测试),意思是创建测试运行所需的数据。*