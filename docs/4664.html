<html>
<head>
<title>Build Your Own Blog Portfolio with Web Components: Data Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Web组件构建自己的博客组合:数据流</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-your-own-blog-portfolio-with-web-components-data-flow-6c1a8f09c252?source=collection_archive---------2-----------------------#2021-09-17">https://javascript.plainenglish.io/build-your-own-blog-portfolio-with-web-components-data-flow-6c1a8f09c252?source=collection_archive---------2-----------------------#2021-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e89d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分—属性、特性、生命周期回调</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7bf8bdca1fd6d2e09c1355a377da5422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JoiXoTqJ3YqbV7TOPOIatQ.png"/></div></div></figure><p id="836d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为开发人员，我们都知道应该尽可能地重用代码。重复代码是软件错误的主要原因之一，避免重复代码至关重要。Web组件帮助我们创建具有封装功能的可重用标记结构。</p><p id="1873" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一系列文章中，我们将通过将Web组件应用于一个示例来学习它们的基础和高级特性。我们将逐步开发一个投资组合，展示任何媒体用户的媒体文章。</p><ol class=""><li id="7d5f" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/showcase-your-medium-articles-with-web-components-part-1-basics-d2c6618e9482">用Web组件构建自己的博客组合<em class="lx">:基础</em> </a></li><li id="ba51" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm lt lu lv lw bi translated">用Web组件构建自己的博客组合:属性、道具、生命周期回调</li><li id="690d" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/@mariusbongarts11/build-your-own-blog-portfolio-with-web-components-webpack-4f35c8e5d2a9" rel="noopener">用Web组件构建自己的博客组合<em class="lx"> : W </em> ebpack </a></li><li id="3b3d" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/@mariusbongarts11/build-your-own-blog-portfolio-with-web-components-typescript-adfbcd917d96" rel="noopener">使用Web组件构建自己的博客文件夹<em class="lx"> : </em>类型脚本</a></li><li id="dc19" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/@mariusbongarts11/build-your-own-blog-portfolio-with-web-components-lit-library-2701dffc735f" rel="noopener">用Web组件构建自己的博客文件夹:Lit Library </a></li></ol></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="dea1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上一篇文章中，我们已经了解了Web组件的三种主要技术:<strong class="kt ir">自定义元素</strong>、<strong class="kt ir">阴影DOM </strong>和<strong class="kt ir"> HTML模板</strong>。</p><p id="7d96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">掌握它们是实现本文中的应用程序的基础。如果你不熟悉这些技术，我强烈推荐你先看一下<a class="ae ln" href="https://medium.com/@mariusbongarts11/showcase-your-medium-articles-with-web-components-part-1-basics-d2c6618e9482" rel="noopener">之前的文章</a>。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="50ac" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">Web组件—简短概述</h1><p id="7bb4" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">Web组件使我们能够完全独立于前端框架/库进行开发，因为它们是基于官方web标准的，并且受到所有主流浏览器的支持。这并不一定意味着我们应该抛弃所有的框架/库。相反，这意味着我们可以外包应用程序的某些部分，以便在React、Angular、VueJS等中重用它们。…框架将更像是一个将数据传递给其组件的包装器。</p><p id="a32c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">亲自尝试一下，将这段代码片段传递给任何web应用程序或任何网站:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Embedded web component</figcaption></figure><p id="d2d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将看到的是我们将在本文中构建的中型投资组合。看看<a class="ae ln" href="https://mariusbongarts.github.io/medium-portfolio-1/" rel="noopener ugc nofollow" target="_blank">现场演示</a>或者<a class="ae ln" href="https://codepen.io/marius2502/pen/gORmqJz" rel="noopener ugc nofollow" target="_blank"> CodePen </a>。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="6389" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">体系结构</h1><p id="74ac" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">在我们继续实现中型产品组合的第一个组件之前，我们将更仔细地看看我们的应用程序的<strong class="kt ir">架构</strong>。这个统一建模语言(UML)图定义了我们的应用程序的各个部分。它包含三个接口(蓝色)、一个超类(橙色)和七个<strong class="kt ir">自定义元素</strong>类(绿色)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/81b1112ca69160ec965b137de7650a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8S1R43Ui8b_ueKnjmf8GQ.png"/></div></div></figure><p id="f84d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们关注一下我们的<strong class="kt ir">自定义元素</strong>(绿色)。</p><p id="ccff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的<strong class="kt ir">入口点</strong>是<em class="lx"> MediumPortfolio </em>类，它定义了我们的<code class="fe no np nq nr b">medium-portfolio</code>定制元素。该组件获取我们的数据，并将其传递给<em class="lx"> MediumArticles </em>和<em class="lx"> MediumHeader </em>组件。</p><p id="2ff3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lx"> MediumArticles </em>组件负责通过为每篇文章呈现多达10个<em class="lx"> MediumArticleCard </em>组件来显示我们的文章。</p><p id="3d69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，<em class="lx"> MediumCategoryChips </em>和<em class="lx"> MediumCategoryChip </em>组件以芯片的形式显示多达5个类别。此外，我们将在文章上方显示一个带有<em class="lx">媒体变量</em>的<em class="lx">媒体标题</em>。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="27cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么现在，事不宜迟，让我们深入代码来构建我们的中型投资组合。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns ni l"/></div></figure></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="047f" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">入口组件</h1><p id="69f5" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">看看我们的<code class="fe no np nq nr b">MediumPortfolio</code>类，这是我们应用程序的<strong class="kt ir">入口点</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Entry Component</figcaption></figure><p id="a90a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里发生了很多事情。让我们一步一步来看。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h2 id="aa56" class="nt ml iq bd mm nu nv dn mq nw nx dp mu la ny nz mw le oa ob my li oc od na oe bi translated">生命周期回调</h2><p id="c2cd" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">在我们的<code class="fe no np nq nr b">medium-portfolio</code>组件中，你可以看到我们再次在构造函数中首先调用了<code class="fe no np nq nr b">super</code>。此外，我们定义了<code class="fe no np nq nr b">connectedCallback</code>方法，这是您可以为定制元素定义的<strong class="kt ir">生命周期回调</strong>之一。这些是在元素生命周期的不同点执行的。</p><p id="d660" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次将定制元素追加到DOM中时，都会调用<code class="fe no np nq nr b">connectedCallback</code>。如果你熟悉Angular，可以把这个比作<code class="fe no np nq nr b">ngOnInit</code>回调。React开发人员可以使用<code class="fe no np nq nr b">componendDidMount</code>和VueJS开发人员的<code class="fe no np nq nr b">mounted</code>回调作为参考。</p><p id="d15d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是引用来自<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks" rel="noopener ugc nofollow" target="_blank"> MDN </a>的所有回访的概述:</p><blockquote class="of og oh"><p id="aaa5" class="kr ks lx kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated"><code class="fe no np nq nr b"><em class="iq">connectedCallback</em></code>:"每次将自定义元素追加到文档连接的元素中时调用。这将在每次移动节点时发生，并且可能在元素的内容被完全解析之前发生。</p><p id="e471" class="kr ks lx kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated"><code class="fe no np nq nr b"><em class="iq">disconnectedCallback</em></code>:"每次自定义元素从文档的DOM断开时调用。"</p><p id="5dc0" class="kr ks lx kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated"><code class="fe no np nq nr b"><em class="iq">adoptedCallback</em></code>:“每次将定制元素移动到新文档时调用。”</p><p id="6946" class="kr ks lx kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated"><code class="fe no np nq nr b"><em class="iq">attributeChangedCallback</em></code>:"每次添加、删除或更改定制元素的属性时调用。在静态get <code class="fe no np nq nr b"><em class="iq">observedAttributes</em></code>方法中指定了哪些要注意变化的属性"</p></blockquote><h2 id="f398" class="nt ml iq bd mm nu nv dn mq nw nx dp mu la ny nz mw le oa ob my li oc od na oe bi translated">获取数据</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/3684a15ce2a54b61c6b933291034d84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*yTkIvBl4I26r7cTK4PJb8Q.png"/></div></figure><p id="bdc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用<code class="fe no np nq nr b">connectedCallback</code>从<code class="fe no np nq nr b"><a class="ae ln" href="https://https://medium.com/feed/@mariusbongarts11" rel="noopener ugc nofollow">https://</a>medium.com/feed/@mariusbongarts11</code>获取<em class="lx"> RssFeed </em>来加载它。</p><p id="5f37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个URL以XML格式返回任何用户的最近十篇文章。此外，我们使用<a class="ae ln" href="https://rss2json.com/" rel="noopener ugc nofollow" target="_blank"> rss2json </a> API获取json格式的数据。我们的结果对象包含我们的文章和一个feed对象，它为我们提供作者的信息，我们将在我们的标题中显示这些信息。为了有一个到媒体用户的链接，我们将映射我们的<em class="lx">文章</em>也有一个<code class="fe no np nq nr b">userLink</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Fetching our data</figcaption></figure><h2 id="75f0" class="nt ml iq bd mm nu nv dn mq nw nx dp mu la ny nz mw le oa ob my li oc od na oe bi translated">属性</h2><p id="f1ae" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">为了让我们的产品组合为每个媒体用户服务，我们通过向应用程序传递属性来定制我们的应用程序。然后，我们可以通过在自定义元素中调用<code class="fe no np nq nr b">getAttribute</code>来读取它们。</p><p id="138c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的应用程序中，我们允许开发人员定义这三个属性:</p><ul class=""><li id="91f3" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm om lu lv lw bi translated"><code class="fe no np nq nr b">username</code>:从中加载文章的中等用户名</li><li id="91f5" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm om lu lv lw bi translated"><code class="fe no np nq nr b">maxArticles</code>:设置显示文章数量的选项</li><li id="5832" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm om lu lv lw bi translated"><code class="fe no np nq nr b">hideHeader</code>:隐藏标题组件的选项</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="28ad" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">展示文章</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/64d32876d944dc342c3462083f56755a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-S7oMynXoB7Q3WSHmLTUw.png"/></div></div></figure><p id="8c64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有四个组件负责呈现我们的实际文章。<em class="lx">中物品</em>、<em class="lx">中物品卡</em>、<em class="lx">中物品卡</em>和<em class="lx">中物品卡</em>类。我们的每个组件都需要一些数据，这些数据需要由父元素传递。</p><p id="4bb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们弄清楚如何将我们的文章数组传递给我们的<em class="lx"> MediumArticles </em>组件。</p><h2 id="1195" class="nt ml iq bd mm nu nv dn mq nw nx dp mu la ny nz mw le oa ob my li oc od na oe bi translated">属性与特性</h2><p id="dbe8" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">要将数据传递给自定义元素，我们有两种选择:</p><ul class=""><li id="b423" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm om lu lv lw bi translated">属性</li><li id="760f" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm om lu lv lw bi translated">性能</li></ul><p id="bc91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">属性和特性之间的区别一开始可能会令人困惑。所以让我来解释一下。</p><p id="6e29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">属性</strong></p><p id="5649" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">属性是通过HTML向自定义元素传递数据的最简单方法。在添加我们的<code class="fe no np nq nr b">medium-portfolio</code>定制元素时，我们已经这样做了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Attributes</figcaption></figure><p id="a319" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将一些字符串属性传递给自定义元素，自定义元素可以使用<code class="fe no np nq nr b">getAttribute()</code>函数访问这些属性。那些属性和我们已经知道的属性没有什么不同:<code class="fe no np nq nr b">class</code>、<code class="fe no np nq nr b">src</code>、<code class="fe no np nq nr b">alt</code>等等</p><p id="bcf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在静态<code class="fe no np nq nr b">observeAttributes</code>和<code class="fe no np nq nr b">attributeChangedCallback</code>的帮助下，我们也可以很容易地监听属性的变化。</p><blockquote class="of og oh"><p id="9fa7" class="kr ks lx kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">" attributes是一个由<strong class="kt ir">字符串</strong>组成的键/值对，它表示关于该属性的任何信息。"— <a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="f781" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着，我们只能将字符串传递给HTML属性。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="d5c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lx">问:但是我们如何传递我们的</em> <code class="fe no np nq nr b"><em class="lx">articles</em></code> <em class="lx">数组对象呢？</em></p><p id="73ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lx">答:我们可以序列化我们的对象，并将其作为字符串传递</em></p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><blockquote class="of og oh"><p id="8750" class="kr ks lx kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">将丰富的数据属性反映到属性是不必要的开销，需要序列化和反序列化相同的JavaScript对象—<a class="ae ln" href="https://developers.google.com/web/fundamentals/web-components/best-practices" rel="noopener ugc nofollow" target="_blank">developers . Google</a>e</p></blockquote><p id="7494" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想强调的是，这是一种丑陋且效率低下的方式，因为将一个大对象序列化为一个字符串的代价很高，并且任何对象引用都会在这个字符串化过程中丢失。</p><p id="d243" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不过，让我向您展示我们如何使用<code class="fe no np nq nr b">JSON.stringify</code>来实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1379" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…但是有一个更好的方法—属性。</p><p id="43ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">属性</strong></p><p id="0938" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然可以使用HTML传递属性，但另一方面，属性只能使用JavaScript传递。</p><blockquote class="oo"><p id="c787" class="op oq iq bd or os ot ou ov ow ox lm dk translated">"目标是只接受丰富的数据(对象，数组)作为属性."— <a class="ae ln" href="https://developers.google.com/web/fundamentals/web-components/best-practices" rel="noopener ugc nofollow" target="_blank"> developers.google </a></p></blockquote><p id="19c6" class="pw-post-body-paragraph kr ks iq kt b ku oy jr kw kx oz ju kz la pa lc ld le pb lg lh li pc lk ll lm ij bi translated">要设置一个元素的属性，我们可以查询它并像这样设置它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3d8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了对属性更改做出反应，我们可以在自定义元素中定义<strong class="kt ir"> getter </strong>和<strong class="kt ir"> setter </strong>，以便在文章可用时呈现我们的HTML:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b891" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">丑陋的方式</strong></p><p id="e81d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你有任何前端框架/库的经验，你可能习惯于直接在模板中设置属性。这就是为什么我们将在下面的文章中使用小而快的HTML模板库<a class="ae ln" href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank"> lit </a>库。这允许我们直接在模板中传递属性。</p><p id="225b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">知道了这一点，让我们以丑陋的，但在我看来更可读的方式来完成我们的<code class="fe no np nq nr b">medium-articles</code>部分。请记住，我们稍后会清理这个问题，这个解决方案并不是最有效的。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="0990" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们映射我们的<code class="fe no np nq nr b">articles</code>并将一个<em class="lx">字符串化的</em>和<em class="lx"> URL编码的</em>属性传递给我们的<code class="fe no np nq nr b">medium-article-card</code>元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c776" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了编码和解码我们的对象，我们使用这些辅助函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="47aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的<em class="lx"> MediumArticleCard中，</em>我们可以轻松地解码我们的对象，并使用<strong class="kt ir"> getter </strong>使其可访问。现在，我们可以轻松地在组件中呈现所有需要的信息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f2ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们的<code class="fe no np nq nr b">medium-articles</code>和<code class="fe no np nq nr b">medium-article-card</code>利用影子DOM来保持标记和样式与页面上的其他代码分离。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="3955" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">显示类别筹码</h1><p id="b65b" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">媒体上的每篇文章最多可以有五个标签，它们将在我们的<code class="fe no np nq nr b">article</code>对象中表示为一个<code class="fe no np nq nr b">categories</code>字符串数组。</p><p id="52c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的<code class="fe no np nq nr b">medium-article</code>元素中，我们像这样将<code class="fe no np nq nr b">categories</code>传递给<code class="fe no np nq nr b">medium-category-chips</code>元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="03e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看我们的<em class="lx">媒体类别芯片</em>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5abf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，我们附加了一个影子DOM来封装我们的组件。此外，我们解码我们的<code class="fe no np nq nr b">categories</code>字符串数组以迭代它，并为每个芯片呈现一个<code class="fe no np nq nr b">medium-category-chip</code>。在元素内部，我们显示相关类别的文本。</p><p id="e8c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您密切关注了<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/showcase-your-medium-articles-with-web-components-part-1-basics-d2c6618e9482">上一篇文章</a>，您可能已经注意到我们的MediumCategoryChip使用了一个<code class="fe no np nq nr b">template</code>标签，并且它定义了一个<code class="fe no np nq nr b">slot</code>，允许我们在其中显示文本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="08f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个组件的特殊部分在开头。我们创建一个带有<strong class="kt ir">槽</strong>的<code class="fe no np nq nr b">template</code>元素。如你所知，<strong class="kt ir"> HTML模板</strong>允许我们声明可重用的片段<strong class="kt ir"> </strong>，这些片段<strong class="kt ir"> </strong>保存不立即呈现的HTML内容。</p><p id="9225" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的<code class="fe no np nq nr b">render</code>函数中，我们使用模板作为基础创建了其内容的克隆。这里，<a class="ae ln" href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank"> lit </a>将在下面的文章中简化创建和克隆模板的过程。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="ba8f" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">显示标题</h1><p id="226a" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">我们还想显示一个标题，显示作者的标题和头像。这两个信息都可以从<code class="fe no np nq nr b">Feed</code>界面读取。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3906fc32ead8c7ccabc4fbaeb9a3b357.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*jrK0_BiZy49D-X6dCRK7ug.png"/></div></figure><p id="7514" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使我们的Web组件更加灵活，我们允许通过将<code class="fe no np nq nr b">hideHeader</code>属性传递给我们的entry组件来隐藏标题。如果没有设置HTML属性，<code class="fe no np nq nr b">getAttribute</code>函数将返回<code class="fe no np nq nr b">null</code>。这意味着我们需要有条件地呈现我们的<code class="fe no np nq nr b">medium-header</code>，只要这个getter解析为false:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e66d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的<code class="fe no np nq nr b">medium-portfolio</code>中，我们可以使用三元运算符有条件地生成我们的<code class="fe no np nq nr b">medium-header</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Conditional rendering</figcaption></figure><p id="80cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们只需要将所需的属性传递给我们的<code class="fe no np nq nr b">medium-header</code>组件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e347" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并且<code class="fe no np nq nr b">medium-header</code>组件将图像URL提供给<code class="fe no np nq nr b">medium-avatar</code>组件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="f092" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">下一步是什么？</h1><p id="e95c" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">在本文中，我们开始实现我们的应用程序，并学习了属性、特性和生命周期回调。</p><p id="33a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一篇文章中，我们将使用构建工具<strong class="kt ir"> webpack </strong>捆绑我们的代码。之后，我们将使用<strong class="kt ir"> Typescript </strong>并重构我们的应用程序以使用<a class="ae ln" href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> lit </strong> </a>。</p><ol class=""><li id="57a0" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/showcase-your-medium-articles-with-web-components-part-1-basics-d2c6618e9482">用Web组件构建自己的博客组合<em class="lx">:基础</em> </a></li><li id="44e4" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm lt lu lv lw bi translated"><strong class="kt ir">用Web组件构建自己的博客组合:属性、道具、生命周期回调</strong></li><li id="dc28" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm lt lu lv lw bi translated">使用Web组件构建自己的博客组合<em class="lx"> : W </em> ebpack </li><li id="db97" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/@mariusbongarts11/build-your-own-blog-portfolio-with-web-components-typescript-adfbcd917d96" rel="noopener">用Web组件建立自己的博客组合<em class="lx"> : </em>打字稿</a></li><li id="6226" class="lo lp iq kt b ku ly kx lz la ma le mb li mc lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/@mariusbongarts11/build-your-own-blog-portfolio-with-web-components-lit-library-2701dffc735f" rel="noopener">用Web组件构建自己的博客组合:Lit Library </a></li></ol></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="dee4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你能遵循这些步骤。我总是很乐意回答问题，也乐于接受批评。请随时联系我😊</p><p id="8c53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">也可以看看<a class="ae ln" href="https://github.com/MariusBongarts/medium-portfolio-1" rel="noopener ugc nofollow" target="_blank"> Github库</a>。</p><p id="ec28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lx">关注我不要错过下一篇文章</em> </strong>🙏</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="685b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">关于作者</h1><p id="2f44" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">Marius Bongarts是埃森哲互动公司的软件工程分析师。他还创建了<a class="ae ln" href="https://chrome.google.com/webstore/detail/web-highlights-+-bookmark/hldjnlbobkdkghfidgoecgmklcemanhm" rel="noopener ugc nofollow" target="_blank"> Web Highlights扩展</a>，允许用户在标签和目录的帮助下组织文本亮点和书签。</p><p id="c37f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过<strong class="kt ir"/><a class="ae ln" href="https://www.linkedin.com/in/marius-bongarts-6b3638171/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">LinkedIn</strong></a><strong class="kt ir">与我联系。</strong></p><p id="e566" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://medium.com/@mariusbongarts/membership" rel="noopener"> <strong class="kt ir">这里是无限制访问介质上每一个内容的链接</strong> </a>。如果你用这个链接注册，我会赚一小笔钱，不需要你额外付费。</p><div class="pe pf gp gr pg ph"><a href="https://medium.com/@mariusbongarts/membership" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">通过我的推荐链接加入Medium-Marius bong arts</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">medium.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv kp ph"/></div></div></a></div></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt ph"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-build-the-medium-text-highlighter-as-a-chrome-extension-with-web-components-b3feccddcd01"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">如何用Web组件构建一个中型文本荧光笔作为Chrome扩展</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">我一直喜欢中型荧光笔，它出现在选择文章中的文本时。我认为这将是很好的…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pq l"><div class="pw l ps pt pu pq pv kp ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a rel="noopener  ugc nofollow" target="_blank" href="/5-skills-you-dont-get-around-to-learn-as-a-fullstack-developer-409f13c394c7"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">作为全栈开发人员，你应该马上学会的5项技能</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">现在就学习吧，你会后悔错过的</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pq l"><div class="px l ps pt pu pq pv kp ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a rel="noopener  ugc nofollow" target="_blank" href="/when-you-should-duplicate-code-b0d747bc1c67"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">何时应该复制代码</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">复制比错误的抽象要便宜得多</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pq l"><div class="py l ps pt pu pq pv kp ph"/></div></div></a></div><p id="1132" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lx">更多内容请看</em><a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>