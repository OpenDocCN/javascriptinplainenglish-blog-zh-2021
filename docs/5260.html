<html>
<head>
<title>Let’s Understand Immutability.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来理解不变性。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-immutability-d00ed097e020?source=collection_archive---------9-----------------------#2021-10-26">https://javascript.plainenglish.io/understanding-immutability-d00ed097e020?source=collection_archive---------9-----------------------#2021-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="63aa" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">在面向对象和函数式编程中，<strong class="jq io">不可变对象</strong>是一个对象，它的状态在创建后不能被修改。这与可变对象不同，可变对象可以在创建后进行修改。— <a class="ae km" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h2 id="6658" class="kn ko in bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">为什么是不变性？</h2><p id="70cf" class="pw-post-body-paragraph jn jo in jq b jr lj jt ju jv lk jx jy kw ll kb kc la lm kf kg le ln kj kk kl ig bi translated">想象你在一个仓库工作。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/05860c0b6f4921826eba6b67958bb6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gAE6J0ygdYym9Yax"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Photo by <a class="ae km" href="https://unsplash.com/@sulyok_imaging?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adrian Sulyok</a> on <a class="ae km" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d710" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">我们来看两个案例。</p><p id="033a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">案例1:仓库有可变的货架来摆放产品。没什么特别的。</p><ul class=""><li id="de58" class="me mf in jq b jr js jv jw kw mg la mh le mi kl mj mk ml mm bi translated">你把<strong class="jq io">蓝色棒棒糖</strong>放在架子<code class="fe mn mo mp mq b">#66</code>里。</li><li id="ff6c" class="me mf in jq b jr mr jv ms kw mt la mu le mv kl mj mk ml mm bi translated">第二天，你来拿一些蓝色的棒棒糖，却震惊地看到各种颜色的棒棒糖被扔进了一个架子<code class="fe mn mo mp mq b">#66</code>。</li><li id="4b8f" class="me mf in jq b jr mr jv ms kw mt la mu le mv kl mj mk ml mm bi translated">当被问及此事时，经理说，'<em class="jp">是的，齿条</em> <code class="fe mn mo mp mq b"><em class="jp">#66</em></code> <em class="jp">对吗？那个棒棒糖架！</em>’</li></ul><p id="3d4b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">经理不知道架子<code class="fe mn mo mp mq b">#66</code>是专为蓝色棒棒糖准备的！</p><p id="30cd" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">这种情况在现实生活中经常发生。我们把钥匙放在某个地方。有人把钥匙的位置从架子改成了抽屉。这造成了混乱。</p><p id="e017" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">我们对现实生活中的易变性无能为力。但是在软件项目的数字生活中，我们可以让货架不变。</p><p id="da4d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">案例二:仓库有不可变的货架摆放产品。一旦创建，没有人可以变异机架包括你！</p><ul class=""><li id="a93b" class="me mf in jq b jr js jv jw kw mg la mh le mi kl mj mk ml mm bi translated">你把<strong class="jq io">的蓝色棒棒糖</strong>放在<code class="fe mn mo mp mq b">#66</code>的架子上。</li><li id="850f" class="me mf in jq b jr mr jv ms kw mt la mu le mv kl mj mk ml mm bi translated">66号货架将继续拥有相同的<strong class="jq io">蓝色棒棒糖</strong>，直到它被销毁。</li></ul><p id="6bb5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">不再困惑！</p><p id="fea2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">但是等等！</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c5d7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">如果我们根本不能改变货架，我们如何访问货架<code class="fe mn mo mp mq b">#66</code>中的物品？采摘棒棒糖将减少大小，这是一个突变，对不对？</p><h2 id="1e04" class="kn ko in bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我们创造越来越多的货架！</h2><p id="25bd" class="pw-post-body-paragraph jn jo in jq b jr lj jt ju jv lk jx jy kw ll kb kc la lm kf kg le ln kj kk kl ig bi translated">看下面的物体。</p><pre class="lp lq lr ls gt my mq mz na aw nb bi"><span id="0f31" class="kn ko in mq b gy nc nd l ne nf">const <strong class="mq io">rack66</strong> = {<br/>  bluelollipops: {<br/>    count: 1200<br/>  }<br/>}</span></pre><p id="a68e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">而且，当我们需要拿出<code class="fe mn mo mp mq b">100</code>棒棒糖时，我们会做下面的事情。</p><pre class="lp lq lr ls gt my mq mz na aw nb bi"><span id="e997" class="kn ko in mq b gy nc nd l ne nf">const updatedCount = rack66.bluelollipops.count - 100</span><span id="6889" class="kn ko in mq b gy ng nd l ne nf">const <strong class="mq io">rack66a</strong> = {<br/>  bluelollipops:{<br/>    count: updatedCount<br/>  }<br/>}</span><span id="5246" class="kn ko in mq b gy ng nd l ne nf">console.log(rack66a) // will have bluelollipops.count as 1100.</span></pre><blockquote class="nh"><p id="3ede" class="ni nj in bd nk nl nm nn no np nq kl dk translated">我们创建一个带有预期突变的新对象，而不是突变一个现有的对象。</p></blockquote><p id="d53f" class="pw-post-body-paragraph jn jo in jq b jr nr jt ju jv ns jx jy kw nt kb kc la nu kf kg le nv kj kk kl ig bi translated"><code class="fe mn mo mp mq b">rack66</code>和<code class="fe mn mo mp mq b">rack66a</code>将继续具有下面的值，直到它们被垃圾收集。</p><pre class="lp lq lr ls gt my mq mz na aw nb bi"><span id="8f95" class="kn ko in mq b gy nc nd l ne nf">// Object: <strong class="mq io">rack66</strong><br/>{<br/>  bluelollipops:{<br/>    count: 1200<br/>  }<br/>}</span><span id="e9af" class="kn ko in mq b gy ng nd l ne nf">// Object: <strong class="mq io">rack661</strong><br/>{<br/>  bluelollipops:{<br/>    count: 1100<br/>  }<br/>}</span></pre><p id="ae00" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">不再有惊喜！</em> </strong></p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="5dc0" class="kn ko in bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">表演呢？</h2><p id="c862" class="pw-post-body-paragraph jn jo in jq b jr lj jt ju jv lk jx jy kw ll kb kc la lm kf kg le ln kj kk kl ig bi translated">上面的例子方便地使用了一个平凡的对象。如果我们想用一个巨大的物体会怎么样？看下面的例子。</p><pre class="lp lq lr ls gt my mq mz na aw nb bi"><span id="a645" class="kn ko in mq b gy nc nd l ne nf">const hugeObj = {<br/>  time: 1635268451<br/>  remainingItems: {// an obnoxious number of properties.}<br/>}</span></pre><p id="4f93" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">而且我们要每毫秒更新一次<code class="fe mn mo mp mq b">hugeObj.time</code>对象！</p><pre class="lp lq lr ls gt my mq mz na aw nb bi"><span id="c86d" class="kn ko in mq b gy nc nd l ne nf">const hugeObj1 = {<br/>  time: 1635268452<br/>  remainingItems: {// an obnoxious number of properties.}<br/>}</span><span id="346a" class="kn ko in mq b gy ng nd l ne nf">const hugeObj2 = {<br/>  time: 1635268453<br/>  remainingItems: {// an obnoxious number of properties.}<br/>}</span><span id="5a8d" class="kn ko in mq b gy ng nd l ne nf">and so on.</span></pre><p id="27cf" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">现在会发生什么？</p><ul class=""><li id="c377" class="me mf in jq b jr js jv jw kw mg la mh le mi kl mj mk ml mm bi translated"><code class="fe mn mo mp mq b">hugeObj</code>大小为1MB。</li><li id="5c9f" class="me mf in jq b jr mr jv ms kw mt la mu le mv kl mj mk ml mm bi translated">创建对象的频率:每小时1000*60*60。也就是每小时3.6 TB。</li></ul><p id="f632" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">那么，上述想法是如何理智的呢？</p><h2 id="56bf" class="kn ko in bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结构共享</h2><p id="747c" class="pw-post-body-paragraph jn jo in jq b jr lj jt ju jv lk jx jy kw ll kb kc la lm kf kg le ln kj kk kl ig bi translated">不可变数据结构支持一种叫做结构共享的技术。</p><p id="a215" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">以上<code class="fe mn mo mp mq b">hugeObj</code>、<code class="fe mn mo mp mq b">hugeObj1</code>、<code class="fe mn mo mp mq b">hugeObj2</code>互为版本。因此，我们可以<strong class="jq io">重用</strong>对象的未更改部分，而不是创建整个对象。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nw"><img src="../Images/3a4064138ffcd0721870277de0b78a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-O1kKzqj7Gde28bXYEXdWQ.png"/></div></div></figure><p id="a6fe" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">这解决了性能问题。</p><h2 id="e5bf" class="kn ko in bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">优势</h2><ul class=""><li id="858d" class="me mf in jq b jr lj jv lk kw nx la ny le nz kl mj mk ml mm bi translated"><strong class="jq io">简单调试:</strong>每个变异都有自己的数据版本，而<em class="jp">哪个代码产生了意外数据是罪魁祸首。</em></li><li id="d45a" class="me mf in jq b jr mr jv ms kw mt la mu le mv kl mj mk ml mm bi translated"><strong class="jq io">并行执行</strong>:多线程环境可以处理相同的数据。</li><li id="cc19" class="me mf in jq b jr mr jv ms kw mt la mu le mv kl mj mk ml mm bi translated"><strong class="jq io">缓存</strong>:我们可以放心地缓存数据，因为我们知道它不会改变。</li><li id="e83d" class="me mf in jq b jr mr jv ms kw mt la mu le mv kl mj mk ml mm bi translated"><strong class="jq io">快照的时间线</strong>:我们可以创建一个时间线，记录应用程序在一段时间内的状态变化。Redux Devtools用这个。</li></ul><p id="0268" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">这就是永恒性。</p></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><p id="636c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">继续阅读immerJS，它使不变性变得更加简单。</p><div class="oh oi gp gr oj ok"><a href="https://karthickragavendran.medium.com/fix-a-pain-point-like-immerjs-e4a4e4a63441" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">修复ImmerJS这样的痛点</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">通过简单地修改当前的树来创建下一个不可变的状态树——Immer</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">karthickragavendran.medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ly ok"/></div></div></a></div><p id="5748" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated">谢谢你。下次见。</p><p id="4311" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kw ka kb kc la ke kf kg le ki kj kk kl ig bi translated"><em class="jp">更多内容看</em> <a class="ae km" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq io"> <em class="jp">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>