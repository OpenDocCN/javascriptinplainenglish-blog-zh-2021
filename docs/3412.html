<html>
<head>
<title>When Does ‘useState’ Prepare the New Value?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“使用状态”何时准备新值？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/when-does-usestate-prepare-the-new-value-1bd228f24d39?source=collection_archive---------12-----------------------#2021-07-10">https://javascript.plainenglish.io/when-does-usestate-prepare-the-new-value-1bd228f24d39?source=collection_archive---------12-----------------------#2021-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="615b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">从官方React源代码的精简版了解useState钩子的工作流程。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/aa8706bc581f2227a1b91b07e83a2759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lqCDjx5-IOPJDlrp"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><pre class="kd ke kf kg gt kt ku kv kw aw kx bi"><span id="a21d" class="ky kz in ku b gy la lb l lc ld">const Title = () =&gt; {<br/>  const [state, setState] = useState(initialState)<br/>}</span></pre><p id="d5ba" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">我从<code class="fe ma mb mc ku b">preact</code>和<code class="fe ma mb mc ku b">brahmos</code>库中读到了一些<code class="fe ma mb mc ku b">useState</code>的实现。我以为我理解了<code class="fe ma mb mc ku b">useState</code>的行为，直到我最终阅读了<code class="fe ma mb mc ku b">ReactFiberHooks.old.js</code>下的官方版本。当然，这不是一个容易的阅读，无论如何，我咬紧牙关，在其他阅读源代码的人的帮助下:)</p><blockquote class="md me mf"><p id="3688" class="le lf mg lg b lh li jo lj lk ll jr lm mh lo lp lq mi ls lt lu mj lw lx ly lz ig bi translated">这里提到的内容已经发表在我的书《以正确的方式设计React Hooks》中，在<a class="ae ks" href="https://www.amazon.com/Designing-React-Hooks-Right-Way-dp-1803235950/dp/1803235950/ref=mt_other?_encoding=UTF8&amp;me=&amp;qid=1640158953" rel="noopener ugc nofollow" target="_blank">亚马逊</a>出售。</p></blockquote><p id="8f65" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">为了理解官方的源代码，让我把它剥离一点，这样我们就可以遵循关键的工作流程，而不必在许多存储库中浏览数百行代码。</p><h1 id="7706" class="mk kz in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">从源代码中学习</h1><p id="29cd" class="pw-post-body-paragraph le lf in lg b lh nb jo lj lk nc jr lm ln nd lp lq lr ne lt lu lv nf lx ly lz ig bi translated"><code class="fe ma mb mc ku b">useState</code>的框架版本可以写在下面，根据<code class="fe ma mb mc ku b">mount</code>标志，它可以去<code class="fe ma mb mc ku b">mountState</code>或<code class="fe ma mb mc ku b">updateState</code>。</p><pre class="kd ke kf kg gt kt ku kv kw aw kx bi"><span id="d0c5" class="ky kz in ku b gy la lb l lc ld">function useState(initialState) {<br/>  if (mount) {<br/>    return mountState(initialState)<br/>  } else {<br/>    return updateState(initialState)<br/>  }<br/>}</span></pre><p id="9bdb" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">任何组件都需要先安装，然后根据更改进行更新。我们可以通过查看当前渲染的<em class="mg">纤维</em>的可用性来找出这个标志<code class="fe ma mb mc ku b">mount</code>，它本质上是正在进行的工作<em class="mg">纤维</em>。</p><pre class="kd ke kf kg gt kt ku kv kw aw kx bi"><span id="746c" class="ky kz in ku b gy la lb l lc ld">let mount = currentlyRenderingFiber === null <br/>  || currentlyRenderingFiber.memoizedState === null</span></pre><p id="4c02" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">本文不打算讨论纤程，所以可以说这个标志是在进入渲染函数之前给出的。</p><h2 id="b6d1" class="ky kz in bd ml ng nh dn mp ni nj dp mt ln nk nl mv lr nm nn mx lv no np mz nq bi translated">安装挂钩</h2><p id="83d0" class="pw-post-body-paragraph le lf in lg b lh nb jo lj lk nc jr lm ln nd lp lq lr ne lt lu lv nf lx ly lz ig bi translated">如果在mount下，我们首先创建一个<em class="mg">钩子。</em></p><pre class="kd ke kf kg gt kt ku kv kw aw kx bi"><span id="d129" class="ky kz in ku b gy la lb l lc ld">function mountState(initialState) { <br/>    hook = mountWorkInProgressHook()<br/>    if (typeof initialState === 'function') {<br/>      initialState = intialState()<br/>    }<br/>    hook.memoizedState = initialState<br/>    hook.queue = {<br/>      pending: null,<br/>      dispatch: null,<br/>    }<br/>    hook.queue.dispatch = dispatchAction.bind(<br/>      null,<br/>      currentlyRenderingFiber,<br/>      hook.queue<br/>    )<br/>  <br/>    return [hook.memoizedState, hook.queue.dispatch]  <br/>}</span></pre><p id="0548" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">之后，我们将使用<code class="fe ma mb mc ku b">initialState</code>初始化内存化状态。如果它以reducer函数格式提供，我们将其转换为<code class="fe ma mb mc ku b">() =&gt; initialState</code>。</p><h2 id="a2e3" class="ky kz in bd ml ng nh dn mp ni nj dp mt ln nk nl mv lr nm nn mx lv no np mz nq bi translated">派遣行动</h2><p id="6438" class="pw-post-body-paragraph le lf in lg b lh nb jo lj lk nc jr lm ln nd lp lq lr ne lt lu lv nf lx ly lz ig bi translated">调度操作是在装载期间设置的。这里使用<code class="fe ma mb mc ku b">bind</code>将当前渲染的纤程和当前钩子队列绑定到这个函数，同时将<code class="fe ma mb mc ku b">action</code>作为唯一的输入参数。</p><pre class="kd ke kf kg gt kt ku kv kw aw kx bi"><span id="c0f5" class="ky kz in ku b gy la lb l lc ld">function dispatchAction(fiber, queue, action) {<br/>  const update = {<br/>    action<br/>    next: null<br/>  }<br/>  <br/>  const pending = <strong class="ku io">queue.pending</strong><br/>  if (pending === null) {<br/>    update.next = update;<br/>  } else {<br/>    update.next = pending.next<br/>    pending.next = update<br/>  }<br/>  queue.pending = update</span><span id="c07c" class="ky kz in ku b gy nr lb l lc ld">  <strong class="ku io">scheduleUpdateOnFiber</strong>(fiber)<br/>}</span></pre><p id="58c1" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">除了将这个动作添加到<code class="fe ma mb mc ku b">queue.pending</code>之外，调度的另一个工作是通知纤程更新，这是通过<em class="mg"> React调度器</em>提供的一个函数来完成的。本质上，在这个调用之后，如果系统不忙，它将重新呈现这个<em class="mg">纤程</em>，因此它将再次进入组件函数，并且它将通过<code class="fe ma mb mc ku b">updateWorkInProgressHook</code>更新这个钩子，我们将在下一节介绍。</p><h2 id="adfb" class="ky kz in bd ml ng nh dn mp ni nj dp mt ln nk nl mv lr nm nn mx lv no np mz nq bi translated">更新挂钩</h2><p id="d457" class="pw-post-body-paragraph le lf in lg b lh nb jo lj lk nc jr lm ln nd lp lq lr ne lt lu lv nf lx ly lz ig bi translated">在每个未来的渲染中，我们首先克隆一个我们在mount下建立的<em class="mg">钩子</em>。</p><pre class="kd ke kf kg gt kt ku kv kw aw kx bi"><span id="798c" class="ky kz in ku b gy la lb l lc ld">function updateState(initialState) {<br/>    hook = updateWorkInProgressHook()<br/>    const queue = hook.queue</span><span id="1a89" class="ky kz in ku b gy nr lb l lc ld">    let updates = queue.pending<br/>    queue.pending = null</span><span id="a9e4" class="ky kz in ku b gy nr lb l lc ld">    if (updates != null) {<br/>      const first = updates.next<br/>      let newState = currentHook.memoizedState<br/>      let update = first<br/>      do {<br/>        const action = update.action<br/>        newState = basicStateReducer(newState, action)<br/>        update = update.next<br/>      } while (update !== null &amp;&amp; update !== first)<br/>        <br/>      if (!Object.is(newState, hook.memoizedState)) {<br/>        markWorkInProgressReceivedUpdate()<br/>      }<br/>      <br/>      hook.memoizedState = newState<br/>    }<br/>  <br/>    return [hook.memoizedState, hook.queue.dispatch]  <br/>}</span></pre><p id="9869" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">如果<code class="fe ma mb mc ku b">queue.pending</code>可用，它将经历来自<code class="fe ma mb mc ku b">dispatchAction</code>的每次更新，并将每个动作逐一应用到新状态。如果新的状态是不同的，我们标记它，这样这个纤程就需要更新到DOM。然后我们将状态存储回<em class="mg">钩子</em>。我们还将<code class="fe ma mb mc ku b">pending</code>重置为<code class="fe ma mb mc ku b">null</code>，这样下一次渲染就不会再选择这些更新了。</p><blockquote class="md me mf"><p id="6699" class="le lf mg lg b lh li jo lj lk ll jr lm mh lo lp lq mi ls lt lu mj lw lx ly lz ig bi translated">状态需要不同才能进入<em class="in">反应渲染器</em>。所以这里调用了render函数，但是我们没有得到DOM更新。</p></blockquote><h2 id="2c0b" class="ky kz in bd ml ng nh dn mp ni nj dp mt ln nk nl mv lr nm nn mx lv no np mz nq bi translated">工作流程草图</h2><p id="f3ac" class="pw-post-body-paragraph le lf in lg b lh nb jo lj lk nc jr lm ln nd lp lq lr ne lt lu lv nf lx ly lz ig bi translated">工作流程可以用下面的草图来概括。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/d7a854447a69424bf270ddb15010a820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUuKQaA5-NXsF41I2UciVQ.png"/></div></div></figure><h1 id="2104" class="mk kz in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">状态更新</h1><p id="79cb" class="pw-post-body-paragraph le lf in lg b lh nb jo lj lk nc jr lm ln nd lp lq lr ne lt lu lv nf lx ly lz ig bi translated">最令人惊讶的是，在互联网上有很多关于<em class="mg"> JavaScript闭包</em>如何成为我们不能在当前渲染中获得最新值的原因的讨论。因此人们对<em class="mg">关闭</em>争论颇多。但实际上，<em class="mg">关闭</em>可能不是原因。当然，我们使用<em class="mg">闭包</em>来访问该值，如下例所示。但是谁说过你可以在当前渲染中得到最新的值呢？谁说值应该总是指向正确的值，除非是指针。因此，除非你创建一个指向钩子内部<code class="fe ma mb mc ku b">memoizedState</code>的指针，否则你永远不会得到最新的值:)</p><pre class="kd ke kf kg gt kt ku kv kw aw kx bi"><span id="e970" class="ky kz in ku b gy la lb l lc ld">function Title() {<br/>  const [count, setCount] = useState(0)<br/>  <br/>  const onClick = () =&gt; {<br/>    setTimeout(() =&gt; {<br/>      setCount(count + 1)<br/>      console.log('clicked', count)<br/>    }, 3000)<br/>  }<br/>  <br/>  console.log('rendered', count) <br/>  ...<br/>}</span></pre><p id="6ba4" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">从我们对官方源代码的研究来看，它明确指出，在典型的路径中，新状态不是在调度期间预先计算的。</p><blockquote class="md me mf"><p id="0d06" class="le lf mg lg b lh li jo lj lk ll jr lm mh lo lp lq mi ls lt lu mj lw lx ly lz ig bi translated">实际上React做了相当多的优化，在一个途径中，它可以通过在调度期间进行预先计算来及早进行救助，并将其存储在<code class="fe ma mb mc ku b">eagerState</code>属性下。但是这个值也是无处可抢的。</p></blockquote><p id="3351" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">因此<em class="mg">关闭</em>与否，<strong class="lg io">在新的渲染开始之前，潜在的新状态并不存在。如果你在当前渲染中费心去想那个，那是白费力气！有一种方法可以帮助你朝着正确的方向思考，那就是使用reducer版本。</strong></p><pre class="kd ke kf kg gt kt ku kv kw aw kx bi"><span id="b953" class="ky kz in ku b gy la lb l lc ld">setState(v =&gt; v + 1)</span></pre><p id="9865" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">使用上述格式有几个优点。除了允许您访问钩子下的<code class="fe ma mb mc ku b">memorizedState</code>,它还暗示这是一个不会马上被调用的“回调”。更不用说<code class="fe ma mb mc ku b">setState</code>函数不会在任何地方返回新值:)</p><p id="abdc" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">另一种帮助方式是使用诸如<code class="fe ma mb mc ku b">dispatchState</code>之类的名字来代替<code class="fe ma mb mc ku b">setState</code>。在内部，我们已经看到<em class="mg">的反应</em>称之为调度。</p><h1 id="648c" class="mk kz in bd ml mm mn mo mp mq mr ms mt jt mu ju mv jw mw jx mx jz my ka mz na bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="7a54" class="pw-post-body-paragraph le lf in lg b lh nb jo lj lk nc jr lm ln nd lp lq lr ne lt lu lv nf lx ly lz ig bi translated"><code class="fe ma mb mc ku b">useState</code>正式版不准备<code class="fe ma mb mc ku b">setState</code>时的新值。相反，它会等待下一次渲染时做出决定。你甚至可以说，没有新的渲染，就没有新的状态。</p><p id="4a2f" class="pw-post-body-paragraph le lf in lg b lh li jo lj lk ll jr lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated"><em class="mg">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg io"><em class="mg">plain English . io</em></strong></a></p></div></div>    
</body>
</html>