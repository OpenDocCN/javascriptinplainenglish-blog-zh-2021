<html>
<head>
<title>Introducing OrchaJS: A TypeScript-Native Client-Server Facilitator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OrchaJS简介:一个类型脚本原生的客户机-服务器服务商</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introducing-orchajs-a-typescript-native-client-server-facilitator-f5654efe258d?source=collection_archive---------13-----------------------#2021-04-12">https://javascript.plainenglish.io/introducing-orchajs-a-typescript-native-client-server-facilitator-f5654efe258d?source=collection_archive---------13-----------------------#2021-04-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/1fd88b1de067d46cfa3cee25b8cd9567.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4D5IGnYkoU_OY3q6tNyOrQ.png"/></div></figure><p id="db8e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">促进客户端和服务器之间的无缝通信；不仅在运行时，而且贯穿整个开发过程。</p><blockquote class="kp kq kr"><p id="6b8b" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">事不宜迟，下面是回购:<a class="ae kw" href="https://github.com/jczacharia/orcha" rel="noopener ugc nofollow" target="_blank">https://github.com/jczacharia/orcha</a><br/>注:回购内包含一个<a class="ae kw" href="https://github.com/jczacharia/orcha/tree/master/libs/todo-example-app" rel="noopener ugc nofollow" target="_blank">功能齐全的示例待办事宜app </a>。<br/>此外，这里是用户认证启动器repo，您可以使用它来启动自己的Orcha项目:<a class="ae kw" href="https://github.com/jczacharia/orcha-user-auth-starter" rel="noopener ugc nofollow" target="_blank">https://github.com/jczacharia/orcha-user-auth-starter</a></p></blockquote><h1 id="cdaa" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">什么是OrchaJS？</strong></h1><p id="eced" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">OrchaJS是一个框架，用于安全、可靠和高效地构建可扩展的web应用程序，这些应用程序需要真实世界、高度相关的领域建模<strong class="jt io"> </strong>和基本功能，如<strong class="jt io">用户认证、文件上传、分页和实时更新</strong>。同时提供前所未有的开发者体验。</p><p id="542d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">简而言之，OrchaJS使用特定于项目的monorepository来存放项目的前端和后端。这意味着领域建模、业务规则/计算和通信协议保存在一个共享文件夹中，客户端和服务器库都可以使用，为您的项目领域创建了一个单一的事实来源。这反过来促进了在开发和生产的所有阶段客户机和服务器之间的健壮通信。</p><p id="59a4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在我们进入技术细节之前，我想说明它的局限性，这样你就知道会发生什么了。</p><h1 id="d858" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">限制</h1><p id="2247" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">由于OrchaJS是用TypeScript编写的，这意味着只能使用TypeScript库和框架。此外，由于OrchaJS是一个框架，它最适合新项目。当前兼容的技术有(但不限于):</p><ul class=""><li id="f910" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated"><a class="ae kw" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"/></a>(客户端)</li><li id="e116" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><a class="ae kw" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"/></a>(服务器)</li><li id="41f9" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><a class="ae kw" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io">字体</strong> </a> (ORM)</li><li id="8571" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><a class="ae kw" href="https://nx.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> Nx </strong> </a>(单库)</li></ul><h1 id="ec5a" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一头扎进去</h1><p id="5bfd" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">当开始一个新项目时，建议首先规划领域模型及其关系。使用Orcha的高级TypeScript泛型，使用一对一、一对多、多对一和多对多关系创建域模型:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Example for Orcha Domain Modeling. <a class="ae kw" href="https://github.com/jczacharia/orcha/tree/master/libs/todo-example-app/shared/domain/src/lib/domain" rel="noopener ugc nofollow" target="_blank">Link To Example Project Domain Models</a></figcaption></figure><blockquote class="kp kq kr"><p id="1af7" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">注意:Orcha包含一个<code class="fe my mz na nb b">IManyToMany</code>类型，但是不建议直接使用多对多关系，而是创建一个单独的实体，通过使用一对多和多对一关系将两个实体链接在一起(如上所示)。这有一个额外的好处，就是可以将列添加到链接的实体中。</p></blockquote><p id="650e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请注意每个关系属性如何以两种方式描述它与另一个实体的关系:</p><ul class=""><li id="b720" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated">第一个模板参数是关系实体，</li><li id="a563" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">第二个模板参数是指回实体的关系实体的属性。</li></ul><p id="bd53" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">例如，用户模型中的<code class="fe my mz na nb b">todos</code>属性描述了与Todo模型中的<code class="fe my mz na nb b">user</code>属性的一对多关系:</p><pre class="mo mp mq mr gt nc nb nd ne aw nf bi"><span id="062c" class="ng ky in nb b gy nh ni l nj nk">// On User model<br/>todos: IOneToMany&lt;Todo, 'user'&gt;;</span><span id="8007" class="ng ky in nb b gy nl ni l nj nk">// One user has many todos.</span><span id="2010" class="ng ky in nb b gy nl ni l nj nk">// On Todo model<br/>user: IManyToOne&lt;User, 'todos'&gt;;</span></pre><p id="5991" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一旦您为您的领域模型建立了单一的事实来源，您就可以在前端自由地使用这些模型。对于后端，还需要一个步骤来创建要在数据库中使用的实体。下面是一个使用TypeORM创建<code class="fe my mz na nb b">UserEntity</code>和<code class="fe my mz na nb b">UserRepository</code>的例子:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Settings up Entity and Repository <a class="ae kw" href="https://github.com/jczacharia/orcha/tree/master/libs/todo-example-app/server/core/domain/src/lib/tag" rel="noopener ugc nofollow" target="_blank">Link to Files</a></figcaption></figure><p id="459a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">注意,<code class="fe my mz na nb b">IOrchaTypeormRepository</code>基类实现了所有的内置函数，可以轻松地读写数据库中的数据。</p><p id="eb7b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一旦描述了您的域模型，您就可以创建一个<em class="ks">编排</em>来定义您想要在您的实体上执行的<em class="ks">操作</em>。</p><h2 id="f396" class="ng ky in bd kz nm nn dn ld no np dp lh kc nq nr ll kg ns nt lp kk nu nv lt nw bi translated">什么是手术？</h2><p id="de9e" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">操作<strong class="jt io"> </strong>通过HTTP POST端点将服务器暴露给外界。每个操作应该描述一个<em class="ks">动作</em>。该操作可以读取或改变数据。</p><h2 id="8f9a" class="ng ky in bd kz nm nn dn ld no np dp lh kc nq nr ll kg ns nt lp kk nu nv lt nw bi translated">什么是配器？</h2><p id="a558" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">流程编排将相关的操作组合在一个父端点下。一个端点看起来如下:<code class="fe my mz na nb b">/orcha/&lt;orchestration name&gt;/&lt;operation name&gt;</code>。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Todo Orchestration Example. <a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/shared/domain/src/lib/domain/todo/todo.orchestration.ts" rel="noopener ugc nofollow" target="_blank">Link To File</a></figcaption></figure><p id="d8bf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">IOperation</code>中的第一个模板参数是您希望从该操作中返回的基本实体或模式。第二个模板参数是数据传输对象(DTO ),它描述了执行所需的操作参数。dto还包括验证以确保数据完整性。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Validating DTO example. <a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/shared/domain/src/lib/domain/todo/todo.dtos.ts" rel="noopener ugc nofollow" target="_blank">Link To File</a></figcaption></figure><p id="26a8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通过像这样描述您的域模型和操作，您可以创建一个Orcha查询，它定义了从一个操作返回的实体模式，包括任何需要的关系连接。</p><h2 id="d544" class="ng ky in bd kz nm nn dn ld no np dp lh kc nq nr ll kg ns nt lp kk nu nv lt nw bi translated">什么是Orcha查询？</h2><p id="28ac" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">Orcha查询是一种基于TypeScript的简单而有效的方法，用来描述从给定操作返回的数据，包括连接数据库中的关系数据。每个Orcha查询由键-值对组成，其中每个键对应于一个<code class="fe my mz na nb b">true</code>值(表示实体上的一个原语字段)或一个对象(表示与另一个实体的关系)。</p><p id="bf6e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">创建Orcha查询时，开发人员可以对他们想要的数据进行严格的类型化和方便的智能感知:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nx mt l"/></div></figure><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Describing the response schema for Todo Operations using our Many-to-Many example. <a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/shared/domain/src/lib/domain/todo/todo.queries.ts" rel="noopener ugc nofollow" target="_blank">Link To File</a></figcaption></figure><p id="682a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在描述了从给定操作返回的数据模式之后，接下来是设置客户机和服务器编排:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Client Orchestration. <a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/client/shared/data-access/src/lib/todo/todo.orchestration.ts" rel="noopener ugc nofollow" target="_blank">Link To File</a></figcaption></figure><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Server Orchestration (Unsecure). <a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/server/orcha/src/lib/todo/todo.orchestration.ts" rel="noopener ugc nofollow" target="_blank">Link To File</a></figcaption></figure><blockquote class="kp kq kr"><p id="47a4" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">注意，<code class="fe my mz na nb b">token</code>是一个额外的字段，它是通过客户端拦截器添加的。<a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/client/shared/data-access/src/lib/auth.interceptor.ts" rel="noopener ugc nofollow" target="_blank">看到这里。</a>您还可以在这里看到通用操作<a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/common/src/lib/orchestration.ts" rel="noopener ugc nofollow" target="_blank">的通用HTTP主体模式。</a></p></blockquote><h2 id="15bf" class="ng ky in bd kz nm nn dn ld no np dp lh kc nq nr ll kg ns nt lp kk nu nv lt nw bi translated">等等，您说这些查询对象是从客户端发送来连接数据库上的关系数据并从服务器返回的，这难道不意味着坏人可以在查询中注入无关的数据来获取敏感数据吗？</h2><p id="9e2a" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">没错，但是OrchaJS有一个安全特性可以防止这种情况。因为Orcha查询保存在客户机和服务器之间的共享文件夹中，所以从客户机发送的查询可以在服务器上进行验证，并检查是否有任何无关的数据，如键和值。</p><p id="8c1b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下面是我们利用查询验证的例子:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Server Orchestration (Secure). <a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/server/orcha/src/lib/todo/todo.orchestration.ts" rel="noopener ugc nofollow" target="_blank">Link To File</a></figcaption></figure><p id="7ad7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果一个坏的参与者试图将另一个键注入到查询对象中，那么将会抛出一个未经授权的错误。这样，私有数据很容易被控制。</p><h2 id="2f21" class="ng ky in bd kz nm nn dn ld no np dp lh kc nq nr ll kg ns nt lp kk nu nv lt nw bi translated">好吧，那么这和服务器业务逻辑有什么关系呢？</h2><p id="078e" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">从<code class="fe my mz na nb b">ClientOrchestration</code>发出的呼叫将在<code class="fe my mz na nb b">ServerOrchestration</code>上接收。一旦服务器操作收到调用，查询、令牌(如果需要)和DTO就被发送到服务器的业务逻辑部分。下面是Todo服务中读取和更新Todo实体的一个示例:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Todo Service. <a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/server/core/services/src/lib/todo/todo.service.ts" rel="noopener ugc nofollow" target="_blank">Link to File</a></figcaption></figure><p id="b0ef" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请注意如何在存储库方法中直接使用Orcha查询(如<code class="fe my mz na nb b">this.todo.findOneOrFail</code>的第二个参数)，以便在整个开发过程中获得Orcha的便利。</p><h2 id="fc08" class="ng ky in bd kz nm nn dn ld no np dp lh kc nq nr ll kg ns nt lp kk nu nv lt nw bi translated">从客户端服务发出调用怎么样？</h2><p id="7695" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">通过依赖注入简单地使用<code class="fe my mz na nb b">TodoOrchestration</code>,然后启动期望的操作。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Example Client Operation Calls via Service <a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/libs/todo-example-app/client/shared/data-access/src/lib/todo/todo.effects.ts" rel="noopener ugc nofollow" target="_blank">Link To File</a></figcaption></figure><p id="d687" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Orcha查询<code class="fe my mz na nb b">TodoQueryModel</code>通过TypeScript泛型进行解析，因此Intellisense将告诉您预期的类型，此外，如果您在客户端应用程序的任何其他地方使用了任何省略的字段，编译器将会抛出编译时错误。</p><h1 id="fe22" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">集成测试</h1><p id="4855" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">Orcha自带集成测试。进行调用与使用客户端编排是一样的，只是增加了令牌字段。下面是一个用户身份验证的示例:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae kw" href="https://github.com/jczacharia/orcha/blob/master/apps/api-e2e/src/specs/user/user-e2e.spec.ts" rel="noopener ugc nofollow" target="_blank">Link To File</a></figcaption></figure><h2 id="b057" class="ng ky in bd kz nm nn dn ld no np dp lh kc nq nr ll kg ns nt lp kk nu nv lt nw bi translated">不错！如果我想使用这个框架创建一个可伸缩的web应用程序，那么高层架构是什么样的？</h2><p id="6adf" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">以下是最佳实践文件夹结构的示例:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/9e4970e58151bbcddc2f2f66c7c4b71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*W1Gx6BB6IQbqEF5FofOYXA.png"/></div></figure><p id="557b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">自下而上描述每个文件夹:</p><p id="9d4a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">包含所有与项目和平台无关的代码。</p><p id="ffb2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">shared/domain</code>存放所有模型、查询、业务规则/计算、编排接口和任何其他领域相关的设计数据。</p><p id="4a6c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">server/orcha</code>容纳所有调用应用服务业务逻辑的服务器编排。</p><p id="10c1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">server/domain-services</code>容纳所有实体及其相应的存储库。<a class="ae kw" href="https://github.com/jczacharia/orcha/tree/master/libs/todo-example-app/server/core/domain/src/lib" rel="noopener ugc nofollow" target="_blank">看到这里。</a></p><p id="bf3a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">server/application-services</code>容纳了所有的业务逻辑(大部分服务器代码将放在这里)。</p><p id="0693" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">client/shell</code>包含所有可路由组件。</p><p id="4c61" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">client/shared/util</code>包含所有与项目无关的、特定于客户的代码。</p><p id="6c8f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">client/shared/ui</code>容纳所有哑元件。</p><p id="2041" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe my mz na nb b">client/shared/data-access</code>包含所有状态管理代码(NgRx首选)、客户端编排、智能组件和任何其他特定于客户端的域代码。</p><p id="128b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果您的项目需要您想从<code class="fe my mz na nb b">client/shell</code>中分离出来的附加特性，您可以通过在<code class="fe my mz na nb b">client</code>下添加一个特性文件夹来实现，如下所示:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/cde1cc6055d8b02eeaa827e6a22ee5a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*HFmbWmGv9W27v-_swSS5XA.png"/></div></figure><h2 id="ff52" class="ng ky in bd kz nm nn dn ld no np dp lh kc nq nr ll kg ns nt lp kk nu nv lt nw bi translated"><strong class="ak">为什么我会选择这个而不是GraphQL？</strong></h2><p id="b14a" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">因为OrchaJS完全是用TypeScript编写的，所以在整个开发过程中，您可以获得完整的类型安全特性，而不需要任何代码生成或不可靠的Intellisense。</p><p id="ab87" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此外，Orcha查询不仅用于客户机和服务器之间，还通过Orcha存储库直接与数据库通信，从而能够向数据库请求您想要的数据，包括关系数据。</p><h1 id="728d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="e2af" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">如果你对这个新颖的框架感兴趣，那么请尝试一下，并给出一些反馈！</p><p id="159b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你已经做到这一步，那么你可能有兴趣成为一名贡献者！OrchaJS目前由我开发和维护，但我正在寻找开发人员来帮助开发，维护和编写文档和集成测试。</p><p id="e97b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">干杯！</p><p id="175d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="ks">更多内容看</em> <a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="ks">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>