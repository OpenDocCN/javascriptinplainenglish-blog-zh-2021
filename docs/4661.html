<html>
<head>
<title>How to Extend the JavaScript Error Constructor?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何扩展JavaScript错误构造函数？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-extend-the-javascript-error-constructor-ce66c5656eb2?source=collection_archive---------17-----------------------#2021-09-16">https://javascript.plainenglish.io/how-to-extend-the-javascript-error-constructor-ce66c5656eb2?source=collection_archive---------17-----------------------#2021-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/de0baa471c391aed78e90b2b0322d1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z7TCKx003YK-z8sq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@unstable_affliction?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ivan Bandura</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="595e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在我们的JavaScript应用程序中抛出错误，我们通常通过一个对象，它是<code class="fe lb lc ld le b">Error</code>构造函数的实例。</p><p id="f113" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用我们自己的构造函数扩展JavaScript <code class="fe lb lc ld le b">Error</code>构造函数。</p><h1 id="8d85" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建我们自己的构造函数</h1><p id="e139" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">扩展内置<code class="fe lb lc ld le b">Error</code>构造函数的一种方法是创建我们自己的构造函数，从<code class="fe lb lc ld le b">Error</code>构造函数获取数据。</p><p id="f466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9a49" class="mq lg iq le b gy mr ms l mt mu">function MyError(message) {<br/>  this.name = 'MyError';<br/>  this.message = message;<br/>  this.stack = (new Error()).stack;<br/>}<br/>MyError.prototype = new Error();<br/>throw new MyError('error occurred')</span></pre><p id="2cd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了接受<code class="fe lb lc ld le b">message</code>参数的<code class="fe lb lc ld le b">MyError</code>构造函数。</p><p id="1269" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lb lc ld le b">message</code>设置为<code class="fe lb lc ld le b">message</code>属性的值。</p><p id="dccf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从<code class="fe lb lc ld le b">Error</code>实例的<code class="fe lb lc ld le b">stack</code>属性中获得堆栈跟踪。</p><p id="ee9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lb lc ld le b">MyError.prototype</code>设置为新的<code class="fe lb lc ld le b">Error</code>实例，这样<code class="fe lb lc ld le b">MyError</code>实例也是<code class="fe lb lc ld le b">Error</code>实例。</p><p id="d622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构造函数中，我们设置了<code class="fe lb lc ld le b">name</code>,当一个错误被抛出时，它将被记录。</p><p id="fca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们抛出一个带有关键字<code class="fe lb lc ld le b">throw</code>的<code class="fe lb lc ld le b">MyError</code>实例。</p><p id="4b97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦抛出错误，我们应该在日志中看到它。</p><p id="dba6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们记录<code class="fe lb lc ld le b"> myError instanceof Error </code>和<code class="fe lb lc ld le b">myError instanceof MyError</code>，我们应该会看到两者都是<code class="fe lb lc ld le b">true</code>，因为我们将<code class="fe lb lc ld le b">MyError.prototype</code>设置为一个新的<code class="fe lb lc ld le b">Error</code>实例。</p><h1 id="ea87" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用Class语法和extends关键字扩展错误构造函数</h1><p id="1c72" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">ES6中增加了class语法，这样我们就可以轻松地创建继承构造函数的构造函数。</p><p id="3500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在语法糖的下面，原型继承仍然像我们在前面的例子中一样被使用。</p><p id="eec0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了扩展<code class="fe lb lc ld le b">Error</code>构造函数，我们编写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="21f7" class="mq lg iq le b gy mr ms l mt mu">class MyError extends Error {<br/>  constructor(message) {<br/>    super(message);<br/>    this.name = 'MyError';<br/>  }<br/>}</span><span id="f2ca" class="mq lg iq le b gy mv ms l mt mu">const myError = new MyError('error occurred')<br/>console.log(myError instanceof Error)<br/>console.log(myError instanceof MyError)<br/>throw myError</span></pre><p id="5b02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用关键字<code class="fe lb lc ld le b">extends</code>创建了<code class="fe lb lc ld le b">MyError</code>类，从而创建了<code class="fe lb lc ld le b">Error</code>类的子类。</p><p id="9aa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">constructor</code>接受<code class="fe lb lc ld le b">message</code>参数，我们通过调用<code class="fe lb lc ld le b">super</code>将其传递给<code class="fe lb lc ld le b">Error</code>构造函数。</p><p id="e755" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还在构造函数中设置了自己的<code class="fe lb lc ld le b">name</code>属性。</p><p id="6c50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用和以前一样的方法实例化<code class="fe lb lc ld le b">MyError</code>类。</p><p id="f5ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在<code class="fe lb lc ld le b">Error</code>和<code class="fe lb lc ld le b">MyError</code>上使用<code class="fe lb lc ld le b">instanceof</code>操作符，我们会看到它们都是<code class="fe lb lc ld le b">true</code>。</p><p id="e35c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们抛出一个错误时，我们看到的消息和以前一样。</p><h1 id="3325" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="0126" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用常规的原型继承或类语法来创建我们自己的构造函数，它从<code class="fe lb lc ld le b">Error</code>构造函数继承数据。</p><p id="d160" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>