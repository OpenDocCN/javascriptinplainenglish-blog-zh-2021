<html>
<head>
<title>Demystifying ‘var,’ ‘let’ and ‘const’ in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开JavaScript中“var”、“let”和“const”的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-var-let-and-const-in-javascript-9a241615d3a1?source=collection_archive---------15-----------------------#2021-09-14">https://javascript.plainenglish.io/demystifying-var-let-and-const-in-javascript-9a241615d3a1?source=collection_archive---------15-----------------------#2021-09-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0e5052474a21713df1d06db762293d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATtUW0s_CNSCbKicychxag.png"/></div></div></figure><p id="895b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript是一种动态类型语言。动态类型语言是这样的语言，其中变量的类型完全取决于存储在变量中的值的类型。例如，如果值的类型是字符串，那么变量的类型也应该是字符串。</p><p id="cfdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前有三种方法可以在JavaScript中声明变量。它们是——var，let和const。这三者在用途、范围或提升方面都互不相同。让我们借助一个例子来理解其中的每一个。</p><h1 id="1bd9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">案例一— var</h1><h2 id="cd4f" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">使用</h2><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c049" class="lr ku in mi b gy mm mn l mo mp"><br/>“use strict”<br/>var variableWithVar = 5;<br/>var variableWithVar;<br/>console.log(variableWithVar); // Prints 5<br/></span></pre><p id="af9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> var </strong>是一个特殊的关键字，用于声明如上所示的变量。即使在严格模式下，重复的变量声明也不会导致任何错误(<strong class="jx io">使用严格的</strong>)，并且值不会丢失，除非给该变量赋一个新值。</p><h2 id="7789" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">范围</h2><p id="bbae" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">就作用域而言，<strong class="jx io"> var </strong>声明如果在函数内部声明，则是函数作用域，否则，它将被视为全局变量，存储在全局对象内部。这些还被添加到全局环境记录的内部名称列表<strong class="jx io"> [[VarNames]] </strong>中。函数作用域的变量是那些只能在声明它们的函数内部访问的变量。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c401" class="lr ku in mi b gy mm mn l mo mp"><br/>// Example One<br/>function varScope() {<br/> var variableWithVar = 1;<br/> console.log(“Inside Function”, variableWithVar);<br/>}<br/>varScope() // Prints ‘Inside Function’ 1<br/>console.log(“Outside Function”, variableWithVar) // ReferenceError: variableWithVar is not defined<br/></span><span id="e273" class="lr ku in mi b gy mv mn l mo mp"><br/>// Example Two<br/>var variableGlobal = 5;<br/>function varScopeTwo() {<br/> console.log(“Inside Function”, variableGlobal);<br/>}<br/>varScopeTwo() // Prints ‘Inside Function 5’<br/></span></pre><p id="4b78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，示例一是一个明确的例子，说明了<strong class="jx io"> var </strong>是函数作用域，而示例二是一个明确的例子，说明了<strong class="jx io"> var </strong>是全局变量。<br/> <br/> <strong class="jx io">吊装</strong></p><p id="aa72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在提升方面，所有使用<strong class="jx io"> var </strong>关键字声明的变量都会被提升。提升的概念是所有的声明语句都将被移动到顶部，甚至在任何代码被执行之前。重要的是要记住，只有变量声明会被提升，而不是它们的值。提升后的所有变量声明将被赋值<strong class="jx io"> undefined，</strong>因此，建议在使用之前声明变量。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="9e5c" class="lr ku in mi b gy mm mn l mo mp"><br/>console.log(variableWithVar); // Prints ‘undefined’<br/>var variableWithVar = 5;<br/></span></pre><p id="3d69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，首先，Javascript解析代码，在此期间，所有的声明语句都将被挂起。在这种情况下，<strong class="jx io"> var variableWithVar </strong>将被移到顶部，并被赋予值<strong class="jx io"> undefined </strong>。因为不再有声明语句，所以它转到代码执行阶段，执行<strong class="jx io"> console.log() </strong>语句。在执行时，它在全局内存中搜索变量<strong class="jx io"> variableWithVar </strong>。一旦找到它，它就将该值作为参数传递给<strong class="jx io"> console.log() </strong>方法。由于<strong class="jx io"> variableWithVar </strong>的值未定义，它打印<strong class="jx io">未定义的</strong></p><h1 id="f567" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">案例二——让</h1><h2 id="326e" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">使用</h2><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e45d" class="lr ku in mi b gy mm mn l mo mp"><br/>let variableWithLet = 5;<br/>console.log(variableWithLet); <br/>let variableWithLet;</span><span id="0913" class="lr ku in mi b gy mv mn l mo mp">// Output<br/>/*<br/>SyntaxError: Identifier ‘variableWithLet’ has already been declared. (3:4)<br/>*/<br/></span></pre><p id="9600" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> let </strong>是一个特殊的关键字，用于声明如上所示的变量。重复的变量声明会抛出错误，如上面的代码片段所示。使用<strong class="jx io"> let </strong>声明的变量可以重新赋值，类似于<strong class="jx io"> var </strong>。</p><h2 id="e535" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">范围</h2><p id="e23d" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">就范围而言，<strong class="jx io">让</strong>声明是块范围的。借助<strong class="jx io"> {} </strong>表示块。块范围的变量是那些只能在声明它们的块内部访问的变量。简单地说，任何块(<strong class="jx io"> {} </strong>)都变成了一个块范围，如果块内的任何变量都是用<strong class="jx io"> let </strong>声明的。与<strong class="jx io"> var </strong>不同，<strong class="jx io"> let </strong>不会在全局对象中创建属性。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="59a4" class="lr ku in mi b gy mm mn l mo mp"><br/>// Example One<br/>function exampleOne() {<br/> let one = 1;<br/> console.log(one);<br/>}<br/>exampleOne() // Prints 1<br/>console.log(one) // ReferenceError: one is not defined<br/></span></pre><p id="091c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，<strong class="jx io">示例一个</strong>是一个函数，其中函数体出现在<strong class="jx io"> {} </strong>中。在这个函数中使用<strong class="jx io"> let </strong>声明任何变量都会使它成为块范围的。<strong class="jx io"> console.log(one) </strong>当我们试图在<strong class="jx io"> exampleOne </strong>块外访问变量<strong class="jx io"> one </strong>时抛出错误。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="56e6" class="lr ku in mi b gy mm mn l mo mp"><br/>// Example Two<br/>{<br/> let one = 1;<br/> console.log(one) // Prints 1<br/>}<br/>console.log(one) // Prints ReferenceError: one is not defined<br/></span></pre><p id="78e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面代码片段是一个清晰的例子，它显示了<strong class="jx io"> let </strong>将任何块(<strong class="jx io"> {} </strong>)转换为作用域块，其中使用<strong class="jx io"> let </strong>声明的任何变量只能在该块内部访问，而不能在其他任何地方访问。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ec31" class="lr ku in mi b gy mm mn l mo mp"><br/>// Example Three<br/>function letScope() {<br/> let outsideOne = 1;<br/> if(true) {<br/> let insideOne = 2;<br/> console.log(insideOne) // Prints 2<br/> console.log(outsideOne) // Prints 1<br/> }<br/> console.log(insideOne) // Prints ReferenceError: insideOne is not defined<br/>}<br/>letScope()<br/></span></pre><p id="a31f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，在执行<strong class="jx io"> letScope() </strong>函数时，函数中的<strong class="jx io"> if(){} </strong>语句变成了块范围，因为块中的变量是使用<strong class="jx io"> let声明的。</strong><strong class="jx io">console . log(inside one)</strong>打印<strong class="jx io"> 2 </strong>，因为<strong class="jx io"> insideOne </strong>在同一个范围内。<strong class="jx io">console . log(outside one)</strong>按照词法作用域的规则打印<strong class="jx io"> 1 </strong>，其中子函数可以访问其父函数的变量。在执行出现在<strong class="jx io"> if </strong>块外的<strong class="jx io"> console.log(insideOne) </strong>语句时，当我们试图访问<strong class="jx io"> if </strong>块外的<strong class="jx io"> insideOne </strong>变量时，Javascript抛出一个引用错误。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e3e2" class="lr ku in mi b gy mm mn l mo mp"><br/>// Example Four<br/>var one = 1;<br/>let two = 2;<br/>console.log(this.one) // Prints 1;<br/>console.log(this.two) // Prints undefined;<br/></span></pre><p id="2e9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码片段是一个清晰的例子，它表明<strong class="jx io"> let </strong>没有在全局对象中创建属性。</p><h2 id="d53b" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">提升</h2><p id="43fb" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">在提升方面，所有使用<strong class="jx io"> let </strong>关键字声明的变量都会被提升。在提升过程中，所有的<strong class="jx io">让</strong>声明移动到代码的顶部。与<strong class="jx io">变量</strong>不同，<strong class="jx io">让</strong>变量不能被使用(读/写)，直到它们被完全初始化。只有当它们被初始化为一个值时，它们才被完全初始化。在初始化之前访问<strong class="jx io">让</strong>变量抛出一个参考错误。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="247b" class="lr ku in mi b gy mm mn l mo mp"><br/>console.log(one); // ReferenceError: one is not defined<br/>let one = 1;<br/></span></pre><p id="9fe8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">假设</strong>变量在<strong class="jx io">时间死区(TDZ) </strong>内，直到它们被完全初始化。<strong class="jx io">时间死区</strong>是变量被声明但不可访问的时间段，因为它们没有设置值。当<strong class="jx io">让</strong>变量被提升时就会发生这种情况。另一方面，<strong class="jx io"> var </strong>变量在提升期间默认设置为未定义的<strong class="jx io">值。</strong></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8029" class="lr ku in mi b gy mm mn l mo mp"><br/>{ <br/> // TDZ of one starts<br/> console.log(two); // Prints undefined<br/> console.log(one); // Prints ReferenceError: Cannot access ‘one’ before initialisation<br/> var two = 1;<br/> let one = 2; // TDZ of one ends<br/>}<br/></span></pre><p id="72b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，Javascript引擎解析代码，将所有变量声明移到最上面— <strong class="jx io"> var two = undefined </strong>和<strong class="jx io"> let one </strong>。这标志着TDZ的开始，因为变量<strong class="jx io"> one </strong>没有完全初始化为一个值。现在，随着javascript进入执行阶段，它为<strong class="jx io"> console.log(two) </strong>语句打印出<strong class="jx io">未定义的</strong>，并为<strong class="jx io"> console.log(one) </strong>抛出一个错误，因为<strong class="jx io">让</strong>变量在完全初始化之前不能被访问。</p><h1 id="f79f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">案例三——常数</h1><p id="5f5b" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated"><strong class="jx io">用法</strong></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a58b" class="lr ku in mi b gy mm mn l mo mp"><br/>const variableWithConst = 5;<br/>console.log(variableWithConst); // Prints 5<br/>variableWithConst = 6;<br/>console.log(variableWithConst); // Prints TypeError: Assignment to constant variable.<br/></span></pre><p id="b448" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> const </strong>是一个特殊的关键字，用于声明如上所示的变量。重复的变量声明和重新赋值给一个<strong class="jx io">常量</strong>变量会分别抛出一个引用和类型错误，如上所示。</p><h2 id="87b3" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">范围</h2><p id="cdc7" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">就作用域而言，<strong class="jx io"> const </strong>声明也是块作用域，与<strong class="jx io"> let </strong>相同。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ef16" class="lr ku in mi b gy mm mn l mo mp"><br/>// Example One<br/>function exampleOne() {<br/> const one = 1;<br/> console.log(one);<br/>}<br/>exampleOne() // Prints 1<br/>console.log(one) // ReferenceError: one is not defined<br/></span></pre><p id="7611" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，<strong class="jx io"> exampleOne </strong>是一个函数，其中函数体出现在<strong class="jx io"> {} </strong>中。在这个函数中使用<strong class="jx io"> const </strong>声明任何变量都会使它成为块范围的。<strong class="jx io"> console.log(one) </strong>抛出错误，因为我们试图在<strong class="jx io"> exampleOne </strong>的块外访问变量<strong class="jx io"> one </strong>。</p><h2 id="881a" class="lr ku in bd kv ls lt dn kz lu lv dp ld kg lw lx lh kk ly lz ll ko ma mb lp mc bi translated">提升</h2><p id="67fb" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">在提升方面，所有使用<strong class="jx io"> const </strong>关键字声明的变量都会被提升，与<strong class="jx io"> let </strong>相同。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3bc0" class="lr ku in mi b gy mm mn l mo mp"><br/>console.log(one); // ReferenceError: one is not defined<br/>const one = 1;<br/></span></pre><p id="1f2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">常量</strong>变量也被称为在<strong class="jx io">时间死区(TDZ) </strong>内，直到它们被完全初始化，这与<strong class="jx io"> let </strong>的完全相同。当<strong class="jx io">常量</strong>变量被提升时会发生这种情况。</p><p id="a5bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这清楚了var、let和const声明在用法、范围和提升方面是如何工作的。如果你觉得这篇文章有用，请展示你的爱，并通过你的社交媒体与你的同伴分享，他们可以最大限度地利用这篇文章。请随时通过<a class="ae mw" href="https://twitter.com/ajojm" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae mw" href="https://www.linkedin.com/in/ajojohn/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或电子邮件与我联系。</p><p id="8c3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">直到我们再次见面，<strong class="jx io">Mallu Dev</strong>结束👋干杯！🥂</p><p id="298b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mx">更多内容请看</em><a class="ae mw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>