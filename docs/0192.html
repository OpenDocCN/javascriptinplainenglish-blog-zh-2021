<html>
<head>
<title>How to Apply the Single Responsibility Principle in your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在你的代码中应用单一责任原则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-apply-the-single-responsibility-principle-in-your-code-3d674cb4d895?source=collection_archive---------13-----------------------#2021-01-11">https://javascript.plainenglish.io/how-to-apply-the-single-responsibility-principle-in-your-code-3d674cb4d895?source=collection_archive---------13-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a6dd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">单一责任原则(SRP)及其在Angular</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/797374e5fb1f068547f6c9c09ef4521f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qEoZsho16hrx5BYi"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@thomascpark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Thomas Park</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="84cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有遇到过这样一个类或方法，它有太多的东西让你感到头晕？</p><p id="6413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单一责任原则(SRP)是一种最佳实践方法，它规定一个函数、方法或类应该有一个主要的特定目的。</p><p id="64c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拥有有很多用途的类或函数会使你的代码难以阅读、理解、难以跟踪错误，并且难以长期维护。</p><p id="67db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建更小的类、函数或模块来满足特定的目的将会产生更健壮、更易维护的代码。此外，您的代码变得更容易进行单元测试。</p><p id="ba44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本指南中，我们将了解如何通过将一个有多种用途的组件文件重构为一个有特定用途的文件来编写满足单一责任原则的代码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c6b6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">个案研究</h1><p id="b67b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面的代码是一个<strong class="ky ir"> <em class="mw">的反面例子。</em> </strong> <em class="mw"> </em>组件代码定义AppComponent，启动app，定义英雄模型对象，从服务器加载英雄，有货币转换功能<em class="mw"> </em>都在同一个文件里。<em class="mw"> </em>更糟糕的是，它包含HTML模板代码<em class="mw">。</em></p><p id="24bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的反例改编自《Angular style guide》，你可以在这里找到原代码<a class="ae kv" href="https://angular.io/guide/styleguide" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7399" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">重构代码</h1><p id="bd58" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">上面的组件代码显然有很多工作要做。如果有人看到这些代码，他们会感到有点不知所措。但是如果我们把它分解成更小的部分，从长远来看，它将提高可读性和可维护性。</p><p id="4346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的目标是创建有一个主要目的的类，并且擅长它们执行的功能。</p><p id="3f79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在下面概述的五个主要步骤中重构代码。</p><h1 id="6df1" class="lz ma iq bd mb mc mz me mf mg na mi mj jw nb jx ml jz nc ka mn kc nd kd mp mq bi translated">1.将模板代码与组件分开</h1><p id="77f9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了改进上面组件中的代码，我们首先必须通过创建一个名为<strong class="ky ir"><em class="mw">app . component</em></strong>的文件，将模板代码移除到它自己的文件中。<strong class="ky ir"> <em class="mw"> html </em> </strong>模板文件的代码如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="fb91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，模板代码目前只有两行代码，如果这段代码中有任何错误的话。找出哪里出了问题肯定会非常容易。</p><h1 id="7c54" class="lz ma iq bd mb mc mz me mf mg na mi mj jw nb jx ml jz nc ka mn kc nd kd mp mq bi translated">2.创建一个专用的模型类</h1><p id="5f86" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">负组件类也为英雄定义了一个模型。不幸的是，这种模型可能会在很多地方被使用，例如在管道或服务中。因此，最好将它放在一个单独的模型类中。</p><p id="2af7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">万一模型改变了，你就能准确地知道在哪里进行调整，而不会篡改其他类。我们的模型类如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="1f04" class="lz ma iq bd mb mc mz me mf mg na mi mj jw nb jx ml jz nc ka mn kc nd kd mp mq bi translated">3.将服务用于共享业务逻辑</h1><p id="5b09" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在Angular中，我们倾向于为业务逻辑使用一种服务，这种服务必然会在应用程序的几个组件中共享。一个典型的例子是从服务器获取数据。</p><p id="4c87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在反面示例组件中，组件代码中有一个从服务器获取数据的函数。</p><p id="60f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将创建一个单独的Angular服务，它的唯一目的是从服务器获取英雄列表，而不是这样做。</p><p id="a438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">英雄以数组的形式返回，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="15a6" class="nj ma iq nf b gy nk nl l nm nn">const HEROES: Hero[] = [<br/>  { id: 1, name: 'Bombasto', earnings:34},<br/>  { id: 2, name: 'Tornado', earnings:43},<br/>  { id: 3, name: 'Magneta', earnings:33 }<br/>];</span></pre><p id="6902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该服务将被命名为<strong class="ky ir"> <em class="mw"> hero.service.ts </em> </strong>，如下所示。我们甚至删除了之前存在的不必要的注释，因为代码很容易理解。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="45cf" class="lz ma iq bd mb mc mz me mf mg na mi mj jw nb jx ml jz nc ka mn kc nd kd mp mq bi translated">4.使用管道进行格式化</h1><p id="ee27" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我包括了一个荒谬的货币转换函数，但它只是为了强调一点。模板中需要快速转换或格式化的东西最好放在管道中。管道非常擅长快速数据转换。</p><p id="a5d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将进一步重构组件代码，删除货币转换函数，并将它放在一个专用的管道类中。</p><p id="e442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，从下面的代码中可以看出。管道有一个主要用途:兑换货币。具体来说，从美元到挪威克朗。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ae4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在可以在应用程序模板的任何地方使用这个管道，方法是如下调用它。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4fb7" class="nj ma iq nf b gy nk nl l nm nn">&lt;div&gt; {{earnings | currencyConverter}} &lt;/div&gt;</span></pre><h1 id="f34c" class="lz ma iq bd mb mc mz me mf mg na mi mj jw nb jx ml jz nc ka mn kc nd kd mp mq bi translated">5.创建一个专用模块</h1><p id="113f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们现在将为组件文件中的模块逻辑创建一个专用的模块文件。</p><p id="fa4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了Angular，你应该瞄准模块化应用。为了实现这一点，Angular使用了一个名为NgModules的模块化系统。对于大型应用程序，每个特定的特性都应该放在自己的模块中。</p><p id="b082" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于模块化应用程序，您还可以利用延迟加载来实现更快的应用程序加载时间。想了解更多Angular中的懒加载，可以看一下<a class="no np ep" href="https://medium.com/u/5bcfd37b5075?source=post_page-----3d674cb4d895--------------------------------" rel="noopener" target="_blank"> Sai gowtham </a> <a class="ae kv" href="https://codeburst.io/how-to-implement-lazy-loading-in-angular-bb2a670b34d" rel="noopener" target="_blank">的一篇文章这里</a>。</p><p id="1a35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，App模块的主要目的是引导应用程序。它也恰好是整个应用程序的根模块。我们的专用模块类代码如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="7cfb" class="lz ma iq bd mb mc mz me mf mg na mi mj jw nb jx ml jz nc ka mn kc nd kd mp mq bi translated">重构的组件</h1><p id="dc19" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们已经重构了组件，这就是最终产品的样子。我们从大约53行代码减少到大约18行。有了这样几行代码，就更容易理解组件代码中发生了什么。</p><p id="82ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该组件的主要功能是订阅英雄列表，并将其显示在相应的模板文件中。重构后的组件如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5648" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">最后的想法</h1><p id="ce52" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本指南中，我们从一个巨大的组件开始，它正在做大量的事情，并使用单一责任原则(SRP)作为我们的指南，将其重构为一个具有特定用途的组件。</p><p id="eef5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建可读的、可维护的代码需要做很多工作，但是应用单一责任原则将对实现可靠的代码大有帮助。</p></div></div>    
</body>
</html>