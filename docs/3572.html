<html>
<head>
<title>React Hooks — All That You Ever Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks —您需要知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hooks-all-that-you-need-to-ever-know-d197109e99da?source=collection_archive---------4-----------------------#2021-07-18">https://javascript.plainenglish.io/react-hooks-all-that-you-need-to-ever-know-d197109e99da?source=collection_archive---------4-----------------------#2021-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d994" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我开始将我们以前的产品从使用类过渡到使用功能组件和钩子时，我面临了一些挑战，花了一些时间来理解它的细微差别。</p><p id="879a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是react中钩子世界的一个快速浏览，以及在开始使用钩子之前你需要知道的一些基本知识。</p><p id="b2d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经尝试了积累所有最常用的钩子，以及如何在一个地方构建定制钩子，这样你就不必搜索多个地方来知道在什么场景中使用哪个钩子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ba7930626f4304146d0a980217ca4868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W1rdpQ1PT75-8tUd.png"/></div></div></figure><blockquote class="kx ky kz"><p id="d2b7" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">什么时候使用功能组件和类？</strong></p></blockquote><p id="10b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的组件除了接受一些道具和渲染之外没有更多的功能，就选择功能性。你可以把这些看作是纯粹的函数，因为在给定相同的道具的情况下，它们的渲染和行为总是相同的。还有，他们不关心生命周期方法，也没有自己的内部状态。</p><p id="0e66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为它们是轻量级的，所以将这些简单的组件编写为功能组件是非常标准的。</p><p id="04fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的组件需要更多的功能，比如保持状态，那就用类来代替。</p><blockquote class="kx ky kz"><p id="e859" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">不同类型的反应钩</strong></p></blockquote><ol class=""><li id="93c7" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir">使用状态()</strong></li></ol><p id="bc1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在类组件中，您必须在类内部创建一个构造函数，并在那里定义状态变量。然后使用setState方法来设置它的值。</p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="81d1" class="ls lt iq lo b gy lu lv l lw lx">constructor(props) {<br/><br/>   super(props);<br/><br/>   this.state = {<br/><br/>     count: 1<br/><br/>   };</span></pre><p id="750b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后你会称之为</p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="73fe" class="ls lt iq lo b gy lu lv l lw lx">this.setState({<br/><br/>     count: count + 1<br/><br/>   });</span></pre><p id="065c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果使用useState钩子，可以显著减少代码行。首先，你不需要任何构造函数。可以直接定义为<br/> <code class="fe ly lz ma lo b"> const [count, setCount] = useState(1);</code></p><p id="7549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">useState()</strong>方法返回一对状态变量的当前值和一个函数，在它的帮助下我们可以更新这个值。</p><p id="ca14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里计数是状态变量。setCount是您用来设置该变量的值的方法，1是您将其初始化为的默认值。</p><p id="aefb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你想设置这个状态变量的值时，可以直接调用<br/> <code class="fe ly lz ma lo b">setCount(count + 1);</code></p><p id="4fd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。useEffect() </strong></p><p id="cf26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Effects挂钩<strong class="jp ir"> useEffect </strong>，增加了从函数组件执行副作用的能力(比如从API获取数据、设置订阅以及手动更改React组件中的DOM)。</p><p id="2cd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的作用与React类中的<strong class="jp ir">componentid mount</strong>、<strong class="jp ir">componentid update</strong>和<strong class="jp ir">componentid unmount</strong>相同。</p><p id="309e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<em class="la"> useEffect </em>钩子，它告诉React组件在渲染后需要做一些事情。React会记住你传递的函数，在DOM操作后调用它。</p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="5e08" class="ls lt iq lo b gy lu lv l lw lx">// defining  state variable<br/><br/> const [book, setBookProperties] = useState({ name: "Alchemist", author: "Paulo Coelho" });</span></pre><blockquote class="kx ky kz"><p id="a23b" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">使用useEffect作为组件安装</strong></p></blockquote><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="2f74" class="ls lt iq lo b gy lu lv l lw lx">useEffect(() =&gt; {<br/>   console.log("calling useEffect when book is changed");<br/>   setName({ name: "Hippie", author: "Paulo Coelho" });<br/><br/> }, []);</span></pre><p id="ec26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，<em class="la"> useEffect </em>被用作类组件中的<em class="la"> componentDidMount </em>方法。当我们将第二个参数作为空参数传递时，我们明确提到在组件加载时只调用useEffect方法一次。即使值发生变化，它也不会再次触发。</p><blockquote class="kx ky kz"><p id="dfd0" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">使用效果作为组件更新</strong></p></blockquote><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="249e" class="ls lt iq lo b gy lu lv l lw lx">useEffect(() =&gt; {<br/>   console.log("calling useEffect when book is changed");<br/>   setName({ name: "Hippie", author: "Paulo Coelho" });<br/><br/> }, [book]);</span></pre><p id="57c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，<em class="la"> useEffect </em>被用作类组件中的<em class="la"> componentDidUpdate </em>方法。当我们传递第二个参数时，我们明确地提到每当传递的第二个参数的值改变时调用useEffect方法。所以在这种情况下，只要属性书发生变化，就会调用useEffect</p><blockquote class="kx ky kz"><p id="d124" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">使用useEffect作为组件将卸载</strong></p></blockquote><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="9ff5" class="ls lt iq lo b gy lu lv l lw lx">useEffect(() =&gt; { setName({ name: "Hippie", author: "Paulo Coelho" });</span><span id="8080" class="ls lt iq lo b gy mb lv l lw lx">return () =&gt; { console.log("Cleaning up...") };<br/> }, [book]);</span></pre><p id="7b33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，<em class="la"> useEffect </em>被用作类组件中的<em class="la"> componentWillUnmount </em>方法。当我们从useEffect方法返回时，这段代码将在组件即将被卸载时被触发。所以我们可以在这里添加清理代码。</p><blockquote class="kx ky kz"><p id="623b" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir"> useEffect </strong>可以不返回任何内容，也可以返回一个在两种情况下执行的函数</p><p id="9c1c" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">-在useEffect下次运行之前</p><p id="47e8" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">-当组件卸载时。</p></blockquote><p id="a30e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。useContext() </strong></p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="bc65" class="ls lt iq lo b gy lu lv l lw lx">const value = useContext(MyContext);</span></pre><p id="dae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以用来在父组件中设置一个上下文值，而不必将值传递给每个子组件，我们可以很容易地从上下文中获取值。</p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="3014" class="ls lt iq lo b gy lu lv l lw lx">const themes = {<br/>  light: {<br/>    foreground: "#000000",<br/>    background: "#eeeeee"<br/>  },<br/>  dark: {<br/>    foreground: "#ffffff",<br/>    background: "#222222"<br/>  }<br/>};<br/><br/>const ThemeContext = React.createContext(themes.light);<br/><br/>function App() {<br/>  return (<br/>    &lt;ThemeContext.Provider value={themes.dark}&gt;<br/>      &lt;Toolbar /&gt;<br/>    &lt;/ThemeContext.Provider&gt;<br/>  );<br/>}<br/><br/>function Toolbar(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ThemedButton /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>function ThemedButton() {<br/>  const theme = useContext(ThemeContext);  return (    &lt;button style={{ background: theme.background, color: theme.foreground }}&gt;      I am styled by theme context!    &lt;/button&gt;  );<br/>}</span></pre><p id="8c79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当组件上方最近的<code class="fe ly lz ma lo b">&lt;MyContext.Provider&gt;</code>更新时，这个钩子将触发一个重新呈现器，把最新的上下文<code class="fe ly lz ma lo b">value</code>传递给那个<code class="fe ly lz ma lo b">MyContext</code>提供者。即使祖先使用了<code class="fe ly lz ma lo b"><a class="ae mc" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">React.memo</a></code>或<code class="fe ly lz ma lo b"><a class="ae mc" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate</a></code>，使用<code class="fe ly lz ma lo b">useContext</code>重新呈现仍然会从组件本身开始。[ <a class="ae mc" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="2fc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 4。useReducer() </strong></p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="34e3" class="ls lt iq lo b gy lu lv l lw lx">const [state, dispatch] = useReducer(reducer, initialArg, init);</span></pre><p id="91e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这和Redux很像。它接受一个类型为<code class="fe ly lz ma lo b">(state, action) =&gt; newState</code>的缩减器，并通过一个<code class="fe ly lz ma lo b">dispatch</code>方法返回当前状态。</p><p id="fb9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您的复杂状态逻辑涉及多个子值或者下一个状态依赖于前一个状态时，<code class="fe ly lz ma lo b">useReducer</code>通常比<code class="fe ly lz ma lo b">useState</code>更好。<code class="fe ly lz ma lo b">useReducer</code>还允许你优化触发深度更新的组件的性能，因为<a class="ae mc" href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" rel="noopener ugc nofollow" target="_blank">你可以向下传递</a> <code class="fe ly lz ma lo b"><a class="ae mc" href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" rel="noopener ugc nofollow" target="_blank">dispatch</a></code> <a class="ae mc" href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" rel="noopener ugc nofollow" target="_blank">而不是回调</a>。[ <a class="ae mc" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">链接</a></p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="10ca" class="ls lt iq lo b gy lu lv l lw lx">function init(initialCount) {  return {count: initialCount};}<br/>function reducer(state, action) {<br/>  switch (action.type) {<br/>    case 'increment':<br/>      return {count: state.count + 1};<br/>    case 'decrement':<br/>      return {count: state.count - 1};<br/>    case 'reset':      <br/>      return init(action.payload);    <br/>    default:<br/>      throw new Error();<br/>  }<br/>}<br/><br/>function Counter({initialCount}) {<br/>  const [state, dispatch] = useReducer(reducer, initialCount, init);  return (<br/>    &lt;&gt;<br/>      Count: {state.count}<br/>      &lt;button<br/>        onClick={() =&gt; dispatch({type: 'reset', payload: initialCount})}&gt; Reset &lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="9d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 5。使用Dispatch() </strong></p><p id="de6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以在react-redux应用程序中使用。</p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="cb04" class="ls lt iq lo b gy lu lv l lw lx">const dispatch = useDispatch()</span></pre><p id="31f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个钩子从Redux存储中返回对<code class="fe ly lz ma lo b">dispatch</code>函数的引用。您可以根据需要使用它来调度操作。如果你已经有一个redux应用程序，这是调度动作最简单的方法。【<a class="ae mc" href="https://react-redux.js.org/api/hooks" rel="noopener ugc nofollow" target="_blank">链接</a></p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="ce4d" class="ls lt iq lo b gy lu lv l lw lx">import React from 'react'<br/>import { useDispatch } from 'react-redux'</span><span id="3e68" class="ls lt iq lo b gy mb lv l lw lx">export const CounterComponent = ({ value }) =&gt; {<br/>  const dispatch = useDispatch()</span><span id="9985" class="ls lt iq lo b gy mb lv l lw lx">return (<br/>    &lt;div&gt;<br/>      &lt;span&gt;{value}&lt;/span&gt;<br/>      &lt;button onClick={() =&gt; dispatch({ type: 'increment-counter' })}&gt;<br/>        Increment counter<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>})</span></pre><blockquote class="kx ky kz"><p id="fc03" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">【useDispatch()和useReducer()的区别</p><p id="43c7" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">这两者都提供了一个<code class="fe ly lz ma lo b">dispatch</code>功能来将动作分派给redux存储，但是<code class="fe ly lz ma lo b">useReducer</code>不<strong class="jp ir">也不</strong>更新redux存储。<code class="fe ly lz ma lo b">useReducer</code>是一个常规的react钩子，允许组件以函数的方式应用本地状态更新，类似于Redux使用的模式，Redux是一个非常常见的<em class="iq">全局</em>应用程序状态管理库。把<code class="fe ly lz ma lo b">useReducer</code>看成Redux的组件状态版本，也就是app状态。</p><p id="1414" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><code class="fe ly lz ma lo b">useDispatch</code>是由<code class="fe ly lz ma lo b">react-redux</code>提供的一个钩子，它消耗一个redux上下文(包含存储/状态)，类似于<code class="fe ly lz ma lo b">connect</code>高阶组件在包装一个组件时提供的功能。[ <a class="ae mc" href="https://stackoverflow.com/a/60984143/629908" rel="noopener ugc nofollow" target="_blank">链接</a></p></blockquote><p id="fa55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.useStore() </p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="4771" class="ls lt iq lo b gy lu lv l lw lx">const dispatch = useStore()</span></pre><p id="014d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个钩子返回一个对传递给<code class="fe ly lz ma lo b">&lt;Provider&gt;</code>组件的相同Redux存储的引用。[ <a class="ae mc" href="https://react-redux.js.org/api/hooks#usestore" rel="noopener ugc nofollow" target="_blank">链接</a></p><blockquote class="kx ky kz"><p id="e869" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">这个钩子应该不会经常使用。首选<code class="fe ly lz ma lo b">useSelector()</code>。</p></blockquote><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="9113" class="ls lt iq lo b gy lu lv l lw lx">import React from 'react'<br/>import { useStore } from 'react-redux' <br/>export const CounterComponent = ({ value }) =&gt; {  <br/>    const store = useStore()   <br/>    return &lt;div&gt; { store.getState() } &lt;/div&gt;<br/>}</span></pre><p id="8b55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">7 .使用选择器()</p><p id="be4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">允许您访问功能组件中的冗余状态值。</p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="0086" class="ls lt iq lo b gy lu lv l lw lx">const result: any = useSelector(selector: Function, equalityFn?: Function)</span></pre><p id="cc1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择器在概念上大致相当于 <code class="fe ly lz ma lo b"><a class="ae mc" href="https://react-redux.js.org/using-react-redux/connect-mapstate" rel="noopener ugc nofollow" target="_blank">connect</a></code>的<code class="fe ly lz ma lo b"><a class="ae mc" href="https://react-redux.js.org/using-react-redux/connect-mapstate" rel="noopener ugc nofollow" target="_blank">mapStateToProps</a></code> <a class="ae mc" href="https://react-redux.js.org/using-react-redux/connect-mapstate" rel="noopener ugc nofollow" target="_blank">自变量。将以整个Redux存储状态作为唯一参数来调用选择器。每当函数组件呈现时，选择器都将运行(除非它的引用自组件的前一次呈现以来没有改变，以便钩子可以在不重新运行选择器的情况下返回缓存的结果)。<code class="fe ly lz ma lo b">useSelector()</code>还将订阅Redux store，并在调度操作时运行您的选择器。[ </a><a class="ae mc" href="https://react-redux.js.org/api/hooks" rel="noopener ugc nofollow" target="_blank">链接</a></p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="aebc" class="ls lt iq lo b gy lu lv l lw lx">const favoriteBooks = useSelector( <br/>(state) =&gt; state.bookData.favoriteBooks )</span></pre><blockquote class="kx ky kz"><p id="f145" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">区别选择器传递给</strong> <code class="fe ly lz ma lo b"><strong class="jp ir">useSelector()</strong></code> <strong class="jp ir">和</strong> <code class="fe ly lz ma lo b"><strong class="jp ir">mapState</strong></code> <strong class="jp ir">功能</strong></p><p id="a5e3" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">-选择器可以返回任何值作为结果，而不仅仅是一个对象。选择器的返回值将作为<code class="fe ly lz ma lo b">useSelector()</code>钩子的返回值。</p><p id="859a" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">-当调度一个动作时，<code class="fe ly lz ma lo b">useSelector()</code>将对先前的选择器结果值和当前结果值进行参考比较。如果它们不同，组件将被强制重新渲染。如果它们相同，组件将不会重新呈现。</p><p id="e98b" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">-选择器功能没有<em class="iq">而不是</em>接收到一个<code class="fe ly lz ma lo b">ownProps</code>参数。然而，道具可以通过关闭或使用curried选择器来使用。</p><p id="38e6" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><code class="fe ly lz ma lo b">- useSelector()</code>默认使用严格的<code class="fe ly lz ma lo b">===</code>引用相等检查，而不是浅层相等(在connect中使用)。</p><p id="c6b1" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>—您可以在一个功能组件中多次调用<code class="fe ly lz ma lo b">useSelector()</code>。对<code class="fe ly lz ma lo b">useSelector()</code>的每次调用都会创建一个对Redux store的单独订阅。由于React Redux v7中使用的React更新批处理行为，导致同一个组件中的多个<code class="fe ly lz ma lo b">useSelector()</code>返回新值的调度操作应该只导致一次重新渲染。</p></blockquote><p id="a351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 8。useMemo() </strong></p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="7fb8" class="ls lt iq lo b gy lu lv l lw lx">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span></pre><p id="2843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传递一个“创建”函数和一组依赖项。<code class="fe ly lz ma lo b">useMemo</code>仅当其中一个依赖关系发生变化时，才会重新计算记忆值。这种优化有助于避免每次渲染时进行昂贵的计算。</p><blockquote class="kx ky kz"><p id="2f54" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong> —记住传递给<code class="fe ly lz ma lo b">useMemo</code>的函数在渲染时运行。不要做任何渲染时通常不会做的事情。</p></blockquote><p id="c96d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 9。useCallback() </strong></p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="8f5b" class="ls lt iq lo b gy lu lv l lw lx">const memoizedCallback = useCallback(<br/>  () =&gt; {<br/>    doSomething(a, b);<br/>  },<br/>  [a, b],<br/>);</span></pre><p id="42d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传递内联回调和依赖项数组。<code class="fe ly lz ma lo b">useCallback</code>将返回回调的记忆化版本，只有当其中一个依赖关系改变时，该版本才会改变。这在向依赖引用相等的优化子组件传递回调以防止不必要的渲染时很有用(例如<code class="fe ly lz ma lo b">shouldComponentUpdate</code>)。</p><p id="8e37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ly lz ma lo b">useCallback(fn, deps)</code>相当于<code class="fe ly lz ma lo b">useMemo(() =&gt; fn, deps)</code>。</p><p id="8f50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 10。定制挂钩</strong></p><p id="312a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用自定义钩子，你可以删除冗余的代码逻辑。此外，您可以继续在自定义挂钩中使用其他挂钩函数，如useState()或useSelector()等，这样可以使这些方法更具可扩展性。</p><p id="1e0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">自定义钩子是一个JavaScript函数，名字以“</strong> <code class="fe ly lz ma lo b"><strong class="jp ir">use</strong></code> <strong class="jp ir">”开头，可以调用其他钩子。</strong></p><p id="0764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如</p><p id="e2ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个自定义挂钩来切换布尔值</p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="f0ed" class="ls lt iq lo b gy lu lv l lw lx">const useToggle = (initialState = false) =&gt; {      <br/>   const [state, setState] = useState(initialState);        <br/>   const toggle = useCallback(() =&gt; setState(state =&gt; !state), []);        return [state, toggle]}</span></pre><p id="6767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当你想使用这个钩子的时候，你可以像下面一样简单地使用它</p><pre class="km kn ko kp gt ln lo lp lq aw lr bi"><span id="18ed" class="ls lt iq lo b gy lu lv l lw lx">const [isTextChanged, setIsTextChanged] = useToggle();</span></pre><blockquote class="kx ky kz"><p id="6961" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">一些非常酷的预烤鱼钩和好的读物</p></blockquote><p id="52be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mc" href="https://usehooks.com/" rel="noopener ugc nofollow" target="_blank">https://usehooks.com/</a></p><p id="4b00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mc" href="https://blog.bitsrc.io/writing-your-own-custom-hooks-4fbcf77e112e" rel="noopener ugc nofollow" target="_blank">https://blog . bitsrc . io/writing-your-own-custom-hooks-4 fbcf 77 e 112 e</a></p><div class="md me gp gr mf mg"><a href="https://www.freecodecamp.org/news/how-to-create-react-hooks/" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">如何构建自己的React钩子:一步一步的指南</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">自定义React挂钩是一个重要的工具，可以让您向React应用程序添加特殊的、独特的功能。在…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">www.freecodecamp.org</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu kv mg"/></div></div></a></div><p id="6704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="la">更多内容看</em><a class="ae mc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="la">plain English . io</em></strong></a></p></div></div>    
</body>
</html>