<html>
<head>
<title>How To Add A Rails Console To Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何向Node.js添加Rails控制台</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-a-rails-console-to-node-b038d27a9379?source=collection_archive---------14-----------------------#2021-09-07">https://javascript.plainenglish.io/how-to-add-a-rails-console-to-node-b038d27a9379?source=collection_archive---------14-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="92fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从命令行访问模型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b8ed85d9f403d524facad28268f82993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_GgAhhgYlbXJLkOS1s0-Q.png"/></div></div></figure><p id="4dd8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rails控制台是一个非凡的工具，也是我在转向Node时最怀念的。然而，当问及如何给Node添加一个类似Rails的控制台时，<a class="ae ln" href="https://stackoverflow.com/questions/14549846/equivalence-of-rails-console-for-node-js" rel="noopener ugc nofollow" target="_blank">答案可能是… <em class="lo">模糊的</em> </a>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lp"><img src="../Images/62a0dd21f7a8990eff7d3b47bd770761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Zy6AgZb-mwjVPTSjSsf1w.png"/></div></div></figure><p id="bfaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您不熟悉Rails控制台，它允许您在REPL中从命令行与模型进行交互。我的脚本将允许我们加载我们所有的模型，并重新加载它们以获得更改。这不像真实的东西那么强大，但是它仍然可以加速后端的原型制作。</p><h1 id="78fa" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">设置</h1><p id="3450" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">下面是相关的目录结构:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="10bd" class="ms lr iq mo b gy mt mu l mv mw">app/<br/>  ∟&gt; console.js<br/>  ∟&gt; src/ <br/>    ∟&gt; models/<br/>      ∟&gt; knex.js <br/>      ∟&gt; User.js <br/>      ∟&gt; Note.js</span></pre><p id="839b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应该注意的是，我的设置将每个单独的模型类从它们自己的文件中导出，目录中没有其他文件，比如测试或索引。如果您的设置不同，您可能需要修改下面的脚本。但是，差不了多少，所以不用担心。此外，它们连接到什么DB，或者您为您的模型使用什么库都没有关系(我使用的是<a class="ae ln" href="https://knexjs.org" rel="noopener ugc nofollow" target="_blank"> Knex.js，</a>您不必这样做)。只要您能够以某种方式导出模型，这就很好。</p><h1 id="3ff5" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">控制台文件</h1><p id="5b79" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">如你所见，它不长，也没有外部依赖性。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="5eed" class="ms lr iq mo b gy mt mu l mv mw"><em class="lo">const</em> <strong class="mo ir">fs</strong> = <em class="lo">require</em>('<em class="lo">fs</em>');<br/><em class="lo">const</em> <strong class="mo ir">path</strong> = <em class="lo">require</em>('<em class="lo">path</em>');<br/><em class="lo">const</em> <strong class="mo ir">repl</strong> = <em class="lo">require</em>('<em class="lo">repl</em>')</span><span id="fe19" class="ms lr iq mo b gy mx mu l mv mw"><em class="lo">const</em> <strong class="mo ir">modelDir</strong> = <strong class="mo ir">path</strong>.join(<strong class="mo ir">__dirname</strong>, '<em class="lo">src</em>', '<em class="lo">models</em>');</span><span id="2c44" class="ms lr iq mo b gy mx mu l mv mw"><em class="lo">const</em> <strong class="mo ir">loadModels</strong> = (<strong class="mo ir">context</strong>) =&gt; {<br/>  <strong class="mo ir">Object</strong>.keys(<strong class="mo ir">require</strong>.cache).forEach(<strong class="mo ir">key</strong> =&gt; {<br/>    <em class="lo">delete</em> require.cache[<strong class="mo ir">key</strong>];<br/>  });</span><span id="464c" class="ms lr iq mo b gy mx mu l mv mw">  <strong class="mo ir">fs</strong>.readdirSync(<strong class="mo ir">modelDir</strong>, '<em class="lo">utf8</em>').forEach(<strong class="mo ir">name</strong> =&gt; {<br/>    <em class="lo">const</em> <strong class="mo ir">filePath</strong> = <strong class="mo ir">path</strong>.join(<strong class="mo ir">modelDir</strong>, <strong class="mo ir">name</strong>);<br/>    <strong class="mo ir">context</strong>[<strong class="mo ir">name</strong>.slice(0,-3)] = <em class="lo">require</em>(<strong class="mo ir">filePath</strong>);<br/>  });<br/>}</span><span id="18c5" class="ms lr iq mo b gy mx mu l mv mw"><em class="lo">const</em> <strong class="mo ir">replServer</strong> = <strong class="mo ir">repl</strong>.start('&gt;&gt;&gt;');<br/><strong class="mo ir">loadModels</strong>(replServer.context);</span><span id="59d9" class="ms lr iq mo b gy mx mu l mv mw"><strong class="mo ir">replServer</strong>.defineCommand('<em class="lo">re</em>', {<br/>  help: '<em class="lo">Reload the models without resetting the environment</em>',<br/>  action() {<br/>    <strong class="mo ir">loadModels</strong>(replServer.context);<br/>    <strong class="mo ir">this</strong>.displayPrompt();<br/>  },<br/>});</span></pre><p id="e86f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要运行此命令，请使用以下命令:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="ec32" class="ms lr iq mo b gy mt mu l mv mw">node --experimental-repl-await ./console.js</span></pre><p id="85ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除非使用节点16 ，否则<code class="fe my mz na mo b"><a class="ae ln" href="https://nodejs.org/docs/latest-v14.x/api/repl.html#repl_await_keyword" rel="noopener ugc nofollow" target="_blank">--experimental-repl-await</a></code> <a class="ae ln" href="https://nodejs.org/docs/latest-v14.x/api/repl.html#repl_await_keyword" rel="noopener ugc nofollow" target="_blank">是必需的，这也是我们使用顶级<code class="fe my mz na mo b">await</code>的原因。有了所有这些设置，您就有了一个Rails控制台:</a></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="c8a9" class="ms lr iq mo b gy mt mu l mv mw">$ node --experimental-repl-await ./console.js<br/>&gt;&gt;&gt; <em class="lo">await</em> <strong class="mo ir">User</strong>.getAll()<br/><em class="lo">[<br/>  User { getNotes: [AsyncFunction: getNotes], id: 1, name: 'Tim' },<br/>  User { getNotes: [AsyncFunction: getNotes], id: 2, name: 'Sara' },<br/>  User { getNotes: [AsyncFunction: getNotes], id: 3, name: 'Bill' },<br/>  User { getNotes: [AsyncFunction: getNotes], id: 4, name: 'tom' }<br/>]</em><br/>&gt;&gt;&gt; <em class="lo">const</em> <strong class="mo ir">bill</strong> = <em class="lo">await</em> <strong class="mo ir">User.</strong>get(3);<br/><em class="lo">undefined</em><br/>&gt;&gt;&gt; <strong class="mo ir">bill</strong><br/><em class="lo">User { getNotes: [AsyncFunction: getNotes], id: 3, name: 'Bill' }</em><br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; .re // To reload the models and get changes</span></pre><h1 id="ccfb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">分解剧本</h1><p id="5e56" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">有3个主要部分:</p><ol class=""><li id="3ead" class="nb nc iq kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">加载模型</li><li id="28f6" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">启动服务器</li><li id="107f" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">将reload命令添加到REPL</li></ol><h2 id="835b" class="ms lr iq bd ls np nq dn lw nr ns dp ma la nt nu mc le nv nw me li nx ny mg nz bi translated">加载模型</h2><p id="6bf6" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">让我们来看看<code class="fe my mz na mo b">loadModels(context)</code>:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="a1e0" class="ms lr iq mo b gy mt mu l mv mw"><em class="lo">const</em> <strong class="mo ir">loadModels</strong> = (<strong class="mo ir">context</strong>) =&gt; {<br/>  <strong class="mo ir">Object</strong>.keys(<strong class="mo ir">require</strong>.cache).forEach(<strong class="mo ir">key</strong> =&gt; {<br/>    <em class="lo">delete</em> require.cache[<strong class="mo ir">key</strong>];<br/>  });</span><span id="5cf9" class="ms lr iq mo b gy mx mu l mv mw"><strong class="mo ir">  fs</strong>.readdirSync(<strong class="mo ir">modelDir</strong>, '<em class="lo">utf8</em>').forEach(<strong class="mo ir">name</strong> =&gt; {<br/>    <em class="lo">const</em> <strong class="mo ir">filePath</strong> = <strong class="mo ir">path</strong>.join(<strong class="mo ir">modelDir</strong>, <strong class="mo ir">name</strong>);<br/>    <strong class="mo ir">context</strong>[<strong class="mo ir">name</strong>.slice(0,-3)] = <em class="lo">require</em>(<strong class="mo ir">filePath</strong>);<br/>  });<br/>}</span></pre><p id="a637" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，那辆<code class="fe my mz na mo b">context</code>是<code class="fe my mz na mo b">replServer</code>的。你可以把它想象成另一辆<code class="fe my mz na mo b">global</code>，<code class="fe my mz na mo b">context</code>上的任何东西在REPL都是顶级的。我们希望我们的模型在那里，这样我们就可以只做<code class="fe my mz na mo b">User</code>而不是类似<code class="fe my mz na mo b">whatever.models.User</code>的事情。</p><p id="1b21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能想知道我们在用<code class="fe my mz na mo b">require.cache</code>做什么。通常，<code class="fe my mz na mo b">require</code>只从磁盘加载一次，然后缓存结果。这对提高生产速度很有好处，但对我们的目的来说并不理想。为了让我们确保每次运行<code class="fe my mz na mo b">require</code>时都得到一个包含最新变更的新加载，我们需要删除缓存。最简单的(只有？)方法是滚动键并删除它们。</p><p id="7093" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，对于实际需要的位。目标是将所需的模块保存到<code class="fe my mz na mo b">context[ModelName]</code>。我只是遍历指定目录中存在的任何文件，去掉名称中的<code class="fe my mz na mo b">.js</code>，并将它们保存到<code class="fe my mz na mo b">context</code>。这将允许我访问我的<code class="fe my mz na mo b"><a class="ae ln" href="https://knexjs.org" rel="noopener ugc nofollow" target="_blank">knex</a></code> <a class="ae ln" href="https://knexjs.org" rel="noopener ugc nofollow" target="_blank">进行原始查询</a>，以及我的<code class="fe my mz na mo b">User</code>和<code class="fe my mz na mo b">Note</code>类。上面的工作与我的设置，但如果你的出口不同于我的，修改你认为合适的。</p><h2 id="622a" class="ms lr iq bd ls np nq dn lw nr ns dp ma la nt nu mc le nv nw me li nx ny mg nz bi translated">启动我们的REPL服务器</h2><p id="c627" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">这很简单，如果你想知道更多，我推荐你阅读官方的节点REPL文档。我们所做的就是启动服务器，将它保存到一个变量中，然后将我们的模型添加到<code class="fe my mz na mo b">context</code>中。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="5347" class="ms lr iq mo b gy mt mu l mv mw"><em class="lo">const</em> <strong class="mo ir">replServer</strong> = <strong class="mo ir">repl</strong>.start('&gt;&gt;&gt;');<br/><strong class="mo ir">loadModels</strong>(replServer.context);</span></pre><p id="ee39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">唯一值得注意的是，你可以用一个字符串<a class="ae ln" href="https://nodejs.org/docs/latest-v14.x/api/repl.html#repl_repl_start_options" rel="noopener ugc nofollow" target="_blank">指定REPL提示</a>，如果你传递一个带有属性的对象，你甚至可以做更多的事情。</p><h2 id="3ff4" class="ms lr iq bd ls np nq dn lw nr ns dp ma la nt nu mc le nv nw me li nx ny mg nz bi translated">将reload命令添加到REPL</h2><p id="4e93" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">REPLs有一些内置命令，您可以通过键入<code class="fe my mz na mo b">.help</code>来查看它们:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="bbba" class="ms lr iq mo b gy mt mu l mv mw">&gt;&gt;&gt; .help<br/>.break    Sometimes you get stuck, this gets you out<br/>.clear    Alias for .break<br/>.editor   Enter editor mode<br/>.exit     Exit the REPL<br/>.help     Print this help message<br/>.load     Load JS from a file into the REPL session<br/>.save     Save all evaluated commands in this REPL session to a file</span></pre><p id="384b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们希望添加一个reload命令，以便在我们做出任何更改时可以快速更新我们的模型。你需要做的就是使用<code class="fe my mz na mo b">defineCommand</code>。它接受一个字符串作为命令名，以及一个带有关键字<code class="fe my mz na mo b">help</code>和<code class="fe my mz na mo b">action</code>的对象。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="d3d9" class="ms lr iq mo b gy mt mu l mv mw"><strong class="mo ir">replServer</strong>.defineCommand('<em class="lo">re</em>', {<br/>  help: '<em class="lo">Reload the models without resetting the environment</em>',<br/>  action() {<br/>    <strong class="mo ir">loadModels</strong>(replServer.context);<br/>    <strong class="mo ir">this</strong>.displayPrompt();<br/>  },<br/>});</span></pre><p id="12a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，字符串<code class="fe my mz na mo b">re</code>(很短，因为您会经常键入它，但您可以称之为完整的<code class="fe my mz na mo b">reloadModels</code>)在字符串中不需要<code class="fe my mz na mo b">.</code>。你只需在控制台中输入<code class="fe my mz na mo b">.re</code>。如果用户键入<code class="fe my mz na mo b">.help</code>命令，就会列出<code class="fe my mz na mo b">help</code>属性。当我们键入<code class="fe my mz na mo b">.re</code>时，<code class="fe my mz na mo b">action</code>属性实际上被调用。我们在函数中所做的就是调用<code class="fe my mz na mo b">loadModels</code>，然后重新显示提示。如果不重新显示，在<code class="fe my mz na mo b">.re</code>之后运行的命令将缺少<code class="fe my mz na mo b">&gt;&gt;&gt;</code>，看起来有点奇怪。<em class="lo">不要对属性使用箭头函数，我们需要</em> <code class="fe my mz na mo b"><em class="lo">this</em></code> <em class="lo">不要乱用。</em></p><p id="f605" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样！这就够了。如果你遇到什么问题，请告诉我。</p><p id="cc18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大家编码快乐，</p><p id="33c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">麦克风</p><p id="2b04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lo">更多内容请看</em><a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="lo">plain English . io</em></strong></a></p></div></div>    
</body>
</html>