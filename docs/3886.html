<html>
<head>
<title>Execution Context: Understanding JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">执行上下文:理解JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/execution-context-understanding-javascript-9f70302c50be?source=collection_archive---------10-----------------------#2021-08-04">https://javascript.plainenglish.io/execution-context-understanding-javascript-9f70302c50be?source=collection_archive---------10-----------------------#2021-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f3945fadc53c7c273d132b77e69116f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tums41FARnW23dtyXsi86w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@florianolv" rel="noopener ugc nofollow" target="_blank">Florian Olivo</a> on Unsplash</figcaption></figure><blockquote class="ka"><p id="3e92" class="kb kc in bd kd ke kf kg kh ki kj kk dk translated">执行上下文是我们在使用JavaScript时需要了解的核心概念之一。理解执行上下文将有助于理解其他概念，如提升、范围链、范围、闭包和事件循环。</p></blockquote><p id="f200" class="pw-post-body-paragraph km kn in ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li kk ig bi translated">让我们从定义开始</p><blockquote class="lj lk ll"><p id="dc1e" class="km kn lm ko b kp ln kr ks kt lo kv kw lp lq kz la lr ls ld le lt lu lh li kk ig bi translated">E <!-- -->执行环境是JavaScript代码执行和评估的环境。简单地说，JavaScript中的一切都发生在执行上下文中。</p></blockquote><p id="c752" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><strong class="ko io">执行上下文的类型</strong></p><p id="9ca6" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><strong class="ko io">全局执行上下文</strong>:全局EC是默认的执行上下文。为什么违约？因为JS代码一运行，GEC就被创建了。</p><p id="5648" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">试试这个:创建一个. js文件并运行它。尽管这个文件没有包含一行代码，GEC还是被创建了。</p><p id="4e07" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">GEC执行这两项任务:</p><ul class=""><li id="ba19" class="lv lw in ko b kp ln kt lo kx lx lb ly lf lz kk ma mb mc md bi translated">它为Node.js创建一个全局对象，为浏览器创建一个窗口对象。</li><li id="3b12" class="lv lw in ko b kp me kt mf kx mg lb mh lf mi kk ma mb mc md bi translated">将Windows对象引用到“this”关键字。</li></ul><p id="c856" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><strong class="ko io">函数执行上下文</strong>:每当一个函数被调用时，一个全新的EC被创建。每个函数都有自己的EC，因此可以有任意数量的FEC。</p><p id="700b" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">在浏览器上下文中，如果代码以<em class="lm">的严格模式值执行，则此</em>未定义，<em class="lm"> </em>否则它是函数执行上下文中的窗口<em class="lm"> </em>对象。</p><p id="2758" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><strong class="ko io"> Eval函数</strong> <strong class="ko io">执行上下文</strong>:在Eval函数内部执行的代码得到自己的执行上下文。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="e102" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><strong class="ko io">执行上下文分两个阶段创建</strong></p><ul class=""><li id="a56f" class="lv lw in ko b kp ln kt lo kx lx lb ly lf lz kk ma mb mc md bi translated"><strong class="ko io">内存创建阶段</strong>:在这个阶段，内存被分配给变量和函数，并存储在键值对中。</li><li id="4f75" class="lv lw in ko b kp me kt mf kx mg lb mh lf mi kk ma mb mc md bi translated"><strong class="ko io">代码执行阶段</strong>:该阶段逐行执行代码并赋值。</li></ul><p id="b645" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><em class="lm">为了更好的理解，我们来看一个小程序，我们来潜水</em></p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/5061976aa751ba0f8c0f793e4fabfaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTssLyt-xUSYxNqQ4ncPPg.png"/></div></div></figure><p id="d1a6" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">我们已经知道EC分为两个阶段，第一个是内存创建，第二个是代码执行。</p><p id="2396" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">在第一阶段，JS逐行浏览代码，并为变量和函数分配内存。</p><p id="6220" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">对于变量，JS指定了一个特殊的关键字undefined。在函数的情况下，函数的整个代码被复制和赋值。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/9449e4ebc10b1f89402a3dffe1407bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*ZPw9Nwa9KvQw5yp1_A-wIw.png"/></div></figure><p id="c473" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">我来详细说明一下。内存被分配给所有的全局函数和变量。</p><p id="bc60" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><em class="lm">名字被分配了一个未定义的特殊关键字。</em></p><p id="31c5" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><em class="lm">打印名称是整个代码分配给它的功能。</em></p><p id="92a8" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><em class="lm"> displayName也是一个变量，因此，未定义被分配给它。</em></p><p id="46c8" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><strong class="ko io">在第二阶段</strong>，JS再次逐行运行代码。现在代码正在执行，所有的计算和评估都将在这里进行。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/45208491cd8eb28d826b63744f3fb4ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*Pr9TvY4tNYI4FRytF9wgOQ.png"/></div></figure><p id="7915" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">一旦JS遇到printName()的函数调用，就会在GEC内部创建一个全新的EC，如上图所示。同样，将遵循FEC的创建和执行阶段的整个流程。</p><p id="a7f1" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">现在，当JS遇到return关键字时，它返回调用函数的程序的控制权，这是GEC，我们得到的输出为<em class="lm"> John Doe </em>。</p><p id="2efe" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">整个程序执行完毕后，GEC被删除了。这里需要理解的一个重要概念是<strong class="ko io">调用栈</strong>。</p><blockquote class="lj lk ll"><p id="fb00" class="km kn lm ko b kp ln kr ks kt lo kv kw lp lq kz la lr ls ld le lt lu lh li kk ig bi translated">C <!-- -->所有栈维护EC的执行顺序。</p></blockquote><p id="b5db" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">调用堆栈遵循LIFO(后进先出)</p><p id="d013" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">在下图中，我们可以看到上面代码的调用堆栈。</p><p id="efd7" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">在调用堆栈中，我们有两个EC，一个是FEC，另一个是GEC。您也可以在浏览器中尝试这样做，方法是执行inspect并导航到source选项卡。</p><p id="630d" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">不要忘记添加断点😇。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/29077eac6197af0a37f890b8a408ee29.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*kskKt9HMr_hGojMA05byMA.png"/></div></figure><h2 id="5a86" class="my mz in bd na nb nc dn nd ne nf dp ng kx nh ni nj lb nk nl nm lf nn no np nq bi translated">结论</h2><p id="4cf9" class="pw-post-body-paragraph km kn in ko b kp nr kr ks kt ns kv kw kx nt kz la lb nu ld le lf nv lh li kk ig bi translated">我们已经了解了什么是电子商务，电子商务有多少种类型。我们还通过一个例子了解了电子商务的两个非常重要的阶段以及它们是如何工作的。了解这些话题不仅扩展了我们的知识，还让我们知道事物是如何运作的。</p><p id="688b" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><em class="lm">我这篇文章的灵感来自阿克谢·塞尼的Namastey JavaScript教程，它对我理解JS和成为一名更好的程序员帮助很大。</em></p><p id="e34c" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><em class="lm">如果您觉得本文有帮助，请点击👏按钮并在下面随意评论！</em></p><p id="3b7c" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">如果我忘记了要补充的东西或者只是一条建议，请联系我。</p><p id="2cd1" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">请务必看看我的其他文章</p><p id="ff62" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><a class="ae jz" href="https://medium.com/@amnah.k/virtual-dom-and-react-1232be73e028" rel="noopener">虚拟DOM:为什么在React js中</a></p><p id="b0d5" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><a class="ae jz" href="https://chatbotsmagazine.com/lets-know-supervised-and-unsupervised-in-an-easy-way-9168363e06ab" rel="noopener ugc nofollow" target="_blank">让我们简单了解一下有人监督和无人监督</a></p><p id="d7da" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated">聊天机器人:下一件大事</p><p id="d44e" class="pw-post-body-paragraph km kn in ko b kp ln kr ks kt lo kv kw kx lq kz la lb ls ld le lf lu lh li kk ig bi translated"><em class="lm">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ko io"><em class="lm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>