<html>
<head>
<title>The React UseRef Hook Explained With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React UseRef钩子举例说明</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-react-useref-hook-explained-with-examples-3bc759c0b105?source=collection_archive---------6-----------------------#2021-01-29">https://javascript.plainenglish.io/the-react-useref-hook-explained-with-examples-3bc759c0b105?source=collection_archive---------6-----------------------#2021-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d695" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过实例了解React中的UseRef挂钩。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2e00032c05965cdc7a8004a3afe9604d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rp5PJMP1LtmLiwVQpReFuQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image created with ❤️️ By <a class="ae kv" href="https://mehdiouss315.medium.com/" rel="noopener">author</a>.</figcaption></figure><h1 id="3f98" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="34b2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">React提供了一系列挂钩，允许您向组件添加特性。这些钩子使得在功能组件中封装有状态行为和副作用变得更加容易，从而增加可读性并使用更少的代码。</p><p id="36dc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我们将通过一些实例来了解React UseRef钩子。让我们开始吧。</p><h1 id="0510" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是UseRef钩子？</h1><p id="b646" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">React中的钩子<code class="fe mp mq mr ms b">useRef()</code>返回一个具有属性<code class="fe mp mq mr ms b">current</code>的对象，我们可以像访问对象一样访问该属性。该属性被初始化为函数<code class="fe mp mq mr ms b">useRef()</code>中传递的参数。返回的对象将在组件的整个生存期内保持不变。</p><p id="5115" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">钩子<code class="fe mp mq mr ms b">useRef()</code>接受一个参数，这个参数是初始化返回对象中属性<code class="fe mp mq mr ms b">current</code>的值。</p><p id="f8cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了使用钩子<code class="fe mp mq mr ms b">useRef</code>，你必须首先从React包中导入它。</p><p id="2700" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6a1a" class="mx kx iq ms b gy my mz l na nb">import React, <strong class="ms ir">{ useRef }</strong> from 'react';</span></pre><p id="2922" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，您可以毫无问题地使用挂钩了:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="19d8" class="mx kx iq ms b gy my mz l na nb">const myRef = <strong class="ms ir">useRef(0)</strong>;</span><span id="9f2a" class="mx kx iq ms b gy nc mz l na nb">console.log(myRef);<br/>// { current: 0 }</span></pre><p id="f26d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如你在上面的例子中看到的，我们已经创建了一个名为<code class="fe mp mq mr ms b">myRef</code>的ref，并将其默认值设置为0。在这种情况下，返回对象中的属性<code class="fe mp mq mr ms b">current</code>的值将为0。您可以通过在控制台中打印<code class="fe mp mq mr ms b">myRef</code>来检查。</p><p id="db86" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使<code class="fe mp mq mr ms b">useRef</code>强大的是它在渲染之间持续存在的事实。它与<code class="fe mp mq mr ms b">useState</code>非常相似，但它不会导致组件在更改时重新呈现。为了让事情更清楚，我们来看一些实际的例子。</p><p id="9155" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设您想要计算组件重新渲染的次数。在这种情况下，您可以使用<code class="fe mp mq mr ms b">useState</code>挂钩或<code class="fe mp mq mr ms b">useRef</code>挂钩。</p><p id="b700" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nd">状态:</em></p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9954" class="mx kx iq ms b gy my mz l na nb">function StateExample() {<br/>  const [count, setCount] = <strong class="ms ir">useState(0)</strong>;<br/><br/>  useEffect(() =&gt; {<br/>    <strong class="ms ir">setCount</strong>(prevCount =&gt; prevCount + 1);<br/>  });<br/><br/>  return &lt;div&gt;{<strong class="ms ir">count</strong>}&lt;/div&gt;;<br/>}</span></pre><p id="63cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nd">参考:</em></p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="8189" class="mx kx iq ms b gy my mz l na nb">function RefExample() {<br/>  const count = <strong class="ms ir">useRef(0)</strong>;<br/><br/>  useEffect(() =&gt; {<br/>    <strong class="ms ir">count.current = count.current + 1;</strong><br/>  });<br/><br/>  return &lt;div&gt;{<strong class="ms ir">count.current</strong>}&lt;/div&gt;;<br/>}</span></pre><p id="5b42" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这两个例子都将显示组件重新渲染的次数。然而，在状态示例中，组件将无限地重新呈现自己，因为我们在这种情况下设置状态。另一方面，ref示例将只运行一次，因为它不会导致组件在更改时重新呈现。</p><h1 id="0507" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">UseRef的使用案例</h1><p id="bca4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">React中钩子<code class="fe mp mq mr ms b">useRef</code>最常见的用例之一是引用DOM元素。</p><p id="a69f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于每个DOM元素都有一个属性<code class="fe mp mq mr ms b">ref</code>，我们可以使用钩子<code class="fe mp mq mr ms b">useRef </code>来设置对该元素的引用。</p><p id="48b5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是一个例子，每当我们单击一个按钮时，它就关注一个输入元素:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="5583" class="mx kx iq ms b gy my mz l na nb">const Reference = ()=&gt; {<br/>  const inputRef = <strong class="ms ir">useRef(null)</strong><br/><br/>  const focusInput = () =&gt; {<br/>    inputRef.current.focus()<br/>  }<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;input <strong class="ms ir">ref={inputRef}</strong> /&gt;<br/>      &lt;button onClick={focusInput}&gt;Focus on the Input&lt;/button&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="1144" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">refs的另一个用例是跨组件呈现持久化的存储。例如，使用refs，我们可以存储状态变量的前一个值。</p><p id="95f1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是一个例子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="ce11" class="mx kx iq ms b gy my mz l na nb">const Reference = ()=&gt; {<br/>  const [name, setName] = useState('Mehdi')<br/>  const previousName = useRef(null)<br/><br/>  useEffect(() =&gt; {<br/>    previousName.current = <strong class="ms ir">name;</strong><br/>  }, <strong class="ms ir">[name]</strong>)<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;input value={name} onChange={e =&gt; setName(e.target.value)} /&gt;<br/>      &lt;div&gt;{previousName.current} =&gt; {name}&lt;/div&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="0b16" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以上示例将在每次名称更改时更新<code class="fe mp mq mr ms b">previousName</code> ref，以便它始终存储名称变量的上一个值。</p><h1 id="849b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="1a1f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">钩子<code class="fe mp mq mr ms b">useRef</code>是你需要知道的重要且有用的反作用钩子之一。它允许您直接访问DOM元素，并在渲染之间保存数据，而不会导致组件在变化时无限地重新渲染。</p><p id="5f53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">谢谢你阅读这篇文章，我希望你觉得它有用。</p><h1 id="4841" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">更多阅读</h1><p id="a488" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="nd">如果你对JavaScript和web开发相关的更有用的内容感兴趣，你也可以</em> <a class="ae kv" href="https://mehdiouss.ck.page/" rel="noopener ugc nofollow" target="_blank"> <em class="nd">订阅</em> </a> <em class="nd">我的时事通讯。</em></p><p id="a936" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nd">以下链接中还有一篇有用的文章可以查看:</em></p><div class="ne nf gp gr ng nh"><a href="https://medium.com/javascript-in-plain-english/fetching-data-with-useeffect-in-react-604ed53edffe" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">在反应中使用UseEffect获取数据</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">通过真实世界的例子了解反应使用效果。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div></div></div>    
</body>
</html>