<html>
<head>
<title>How to Use Versioning in NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在NestJS中使用版本控制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-versioning-in-nestjs-45d7c413e72b?source=collection_archive---------1-----------------------#2021-05-08">https://javascript.plainenglish.io/how-to-use-versioning-in-nestjs-45d7c413e72b?source=collection_archive---------1-----------------------#2021-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e6dd9e4aabd09f3d4d454f2d5d5b582f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0RUcAMHvyQ_RZNX0_-N-Q.png"/></div></div></figure><p id="cade" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">更新(2021年7月24日):本文被更新为使用最新版本的NestJS包。</strong></p><p id="df80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在开发REST APIs时，需要进行重大变更的情况并不少见，这可能会影响端点的契约或行为。</p><p id="3f6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">做出突破性改变的问题是消费者将会受到影响，无论他们是否需要快速改变他们的应用程序来解决你的突破性改变，或者有以前没有发生的意外行为。不管影响如何，如果不支持以前的版本，做出突破性的改变是不现实的。</p><p id="6250" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是版本控制的由来。版本控制允许您拥有同时处于活动状态的不同版本的端点。它允许开发人员创建一个包含重大变更的新版本，同时仍然能够支持以前的版本。这使得消费者可以根据自己的时间表进行升级，总体上减少了麻烦。</p><p id="371b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">NestJS是一个用于构建<a class="ae kt" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>服务器端应用程序的框架。在本文中，我不会涉及什么是NestJS以及为什么使用它的细节，但是我建议查看他们的<a class="ae kt" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank">文档</a>！</p><p id="b1ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">版本控制已经添加到2021年7月发布的NestJS的v8中，因此我们将在本文的示例中使用该版本。</p><p id="b731" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在NestJS中，支持3种版本控制类型:</p><ol class=""><li id="eef0" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><code class="fe ld le lf lg b">URI Versioning</code>:版本在请求的URI内传递</li><li id="d04e" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><code class="fe ld le lf lg b">Header Versioning</code>:自定义请求头将指定版本</li><li id="e833" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated"><code class="fe ld le lf lg b">Media Type Versioning</code>:<code class="fe ld le lf lg b">Accept</code>请求头将指定版本</li></ol><p id="34b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于本文的重点，我们将使用<code class="fe ld le lf lg b">Media Type Versioning</code>。</p><h2 id="5d95" class="lm ln in bd lo lp lq dn lr ls lt dp lu kg lv lw lx kk ly lz ma ko mb mc md me bi translated">设置NestJS应用程序</h2><p id="6756" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">这一节将带您通过版本控制所需的设置来设置一个新的NestJS应用程序。</p><p id="a5ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，确保您已经安装了node v10.13.0或更高版本，以及npm，它应该与node一起自动安装。</p><p id="f4f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将安装并使用NestJS CLI来生成新的应用程序。</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="aa65" class="lm ln in lg b gy ms mt l mu mv">$ npm i -g @nestjs/cli<br/>$ nest new nest-versioning-demo</span></pre><p id="11eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选择您喜欢的软件包管理器，并等待安装依赖项。</p><p id="c1c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用以下命令启动该应用程序:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="c007" class="lm ln in lg b gy ms mt l mu mv">$ npm start</span></pre><p id="fc8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并使用以下命令验证它已经启动并正在运行:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="4d0d" class="lm ln in lg b gy ms mt l mu mv">$ curl localhost:3000<br/>Hello World!</span></pre><h2 id="174a" class="lm ln in bd lo lp lq dn lr ls lt dp lu kg lv lw lx kk ly lz ma ko mb mc md me bi translated">在NestJS应用程序中启用版本控制</h2><p id="09b3" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">为了使用版本控制，您必须在应用程序上启用该功能。这将启用整个应用程序的版本控制，包括所有控制器和路由。</p><p id="dee4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新您的<code class="fe ld le lf lg b">main.ts</code>文件以包含<code class="fe ld le lf lg b">enableVersioning(...)</code>函数调用:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="375f" class="lm ln in lg b gy ms mt l mu mv">import { VersioningType } from '@nestjs/common';<br/>import { NestFactory } from '@nestjs/core';<br/>import { AppModule } from './app.module';</span><span id="c6aa" class="lm ln in lg b gy mw mt l mu mv">async function bootstrap() {<br/>  const app = await NestFactory.create(AppModule);<br/>  app.enableVersioning({<br/>    type: VersioningType.MEDIA_TYPE,<br/>    key: 'v=',<br/>  });</span><span id="fab9" class="lm ln in lg b gy mw mt l mu mv">  await app.listen(3000);<br/>}</span><span id="f8d1" class="lm ln in lg b gy mw mt l mu mv">bootstrap();</span></pre><p id="acc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ld le lf lg b">enableVersioning</code>函数接受一个对象参数，该参数包含要使用的版本类型以及该类型所需的任何配置。</p><p id="dbca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于本文，我们将使用前面描述的媒体类型版本控制。我们可以使用<code class="fe ld le lf lg b">VersioningType</code>枚举(从<code class="fe ld le lf lg b">@nestjs/common</code>引入)来表明这一点。媒体类型版本控制需要一个额外的配置，<code class="fe ld le lf lg b">key</code>，它应该存在于<code class="fe ld le lf lg b">Accept</code>头中，作为我们应该用于版本的值的前缀。</p><p id="e9db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于本文，我们将使用键<code class="fe ld le lf lg b">v=</code>，我们的<code class="fe ld le lf lg b">Accept</code>标题将看起来像<code class="fe ld le lf lg b">Accept: application/json;v=1</code>或<code class="fe ld le lf lg b">Accept: application/json;v=2</code>。</p><h2 id="a017" class="lm ln in bd lo lp lq dn lr ls lt dp lu kg lv lw lx kk ly lz ma ko mb mc md me bi translated">添加版本化路径</h2><p id="d3b0" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">在为我们的应用程序启用版本控制之后，下一步是添加一个版本控制的路由。</p><p id="0ea6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行以下命令来生成新的控制器:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="1a16" class="lm ln in lg b gy ms mt l mu mv">$ nest g controller Hello</span></pre><p id="4a27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文件生成后，更新<code class="fe ld le lf lg b">src/hello/hello.controller.ts</code>文件以包含以下方法:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="e6ff" class="lm ln in lg b gy ms mt l mu mv">import { Controller, Get } from '@nestjs/common';</span><span id="baf2" class="lm ln in lg b gy mw mt l mu mv">@Controller('hello')<br/>export class HelloController {<br/>  @Get()<br/>  getHelloV1() {<br/>    return 'Hello World V1!';<br/>  }</span><span id="2ab8" class="lm ln in lg b gy mw mt l mu mv">  @Get()<br/>  getHelloV2() {<br/>    return 'Hello World V2!';<br/>  }<br/>}</span></pre><p id="ecc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们现在运行应用程序并向<code class="fe ld le lf lg b">localhost:3000/hello</code>发出请求，我们将会看到响应<code class="fe ld le lf lg b">Hello World V1!</code>，而不管我们在<code class="fe ld le lf lg b">Accept</code>头中发送的版本。这是因为我们还没有告诉NestJS哪个版本应该使用哪个函数，所以默认为第一个。</p><p id="c351" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要指定版本，我们有两个选项:</p><ol class=""><li id="ee2a" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">指定整个控制器的版本</li><li id="e311" class="ku kv in jx b jy lh kc li kg lj kk lk ko ll ks kz la lb lc bi translated">指定特定路线/功能的版本</li></ol><p id="daa6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将从向路线添加一个版本开始。为此，我们使用<code class="fe ld le lf lg b">@Version</code>装饰器(从<code class="fe ld le lf lg b">@nestjs/common</code>导入)。更新<code class="fe ld le lf lg b">src/hello/hello.controller.ts</code>文件以包含功能的相应版本:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="fb29" class="lm ln in lg b gy ms mt l mu mv">import { Controller, Get, Version } from '@nestjs/common';</span><span id="75c2" class="lm ln in lg b gy mw mt l mu mv">@Controller('hello')<br/>export class HelloController {<br/>  @Version('1')<br/>  @Get()<br/>  getHelloV1() {<br/>    return 'Hello World V1!';<br/>  }</span><span id="4594" class="lm ln in lg b gy mw mt l mu mv">  @Version('2')<br/>  @Get()<br/>  getHelloV2() {<br/>    return 'Hello World V2!';<br/>  }<br/>}</span></pre><p id="1b18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以向两个版本化路由发出请求，并验证返回的响应:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="860d" class="lm ln in lg b gy ms mt l mu mv">$ curl localhost:3000/hello -H "Accept: application/json;v=1"<br/>Hello World V1!<br/>$ curl localhost:3000/hello -H "Accept: application/json;v=2"<br/>Hello World V2!</span></pre><p id="ca49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这样，我们有了一条版本化的路线！</p><p id="b547" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:如果请求没有版本，或者版本没有匹配的路由，应用程序将响应404 Not Found。</p><h2 id="a2be" class="lm ln in bd lo lp lq dn lr ls lt dp lu kg lv lw lx kk ly lz ma ko mb mc md me bi translated">添加版本化控制器</h2><p id="1fe9" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">除了将一个版本应用于特定的路由之外，我们还可以将一个版本应用于整个控制器和该控制器中的所有路由。</p><p id="38cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，我们将生成两个新的控制器:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="fb95" class="lm ln in lg b gy ms mt l mu mv">$ nest g controller HolaV1<br/>$ nest g controller HolaV2</span></pre><p id="52e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文件生成后，我们将更新两个控制器以使用相同的<code class="fe ld le lf lg b">hola</code>路径，并添加它们各自的版本。</p><p id="404e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ld le lf lg b">src/hola-v1/hola-v1.controller.ts</code>:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="3f7b" class="lm ln in lg b gy ms mt l mu mv">import { Controller, Get } from '@nestjs/common';</span><span id="22cf" class="lm ln in lg b gy mw mt l mu mv">@Controller({<br/>  path: 'hola',<br/>  version: '1',<br/>})<br/>export class HolaV1Controller {<br/>  @Get()<br/>  getHola() {<br/>    return 'Hola Mundo V1!';<br/>  }<br/>}</span></pre><p id="e4da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ld le lf lg b">src/hola-v2/hola-v2.controller.ts</code>:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="ccf4" class="lm ln in lg b gy ms mt l mu mv">import { Controller, Get } from '@nestjs/common';</span><span id="c079" class="lm ln in lg b gy mw mt l mu mv">@Controller({<br/>  path: 'hola',<br/>  version: '2',<br/>})<br/>export class HolaV2Controller {<br/>  @Get()<br/>  getHola() {<br/>    return 'Hola Mundo V2!';<br/>  }<br/>}</span></pre><p id="3cab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以向两个版本控制器发出请求，并验证返回的响应:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="570b" class="lm ln in lg b gy ms mt l mu mv">$ curl localhost:3000/hola -H "Accept: application/json;v=1"<br/>Hola Mundo V1!<br/>$ curl localhost:3000/hola -H "Accept: application/json;v=2"<br/>Hola Mundo V2!</span></pre><p id="1486" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，我们现在有版本化的控制器了！</p><p id="3baf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">增加版本中立路线</strong></p><p id="b3da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于不需要版本控制的场景，NestJS有一个“版本中立”的模式，这表明不管请求中的版本是什么，或者如果请求中没有版本，都应该使用特定的函数。</p><p id="e3c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:对于URI版本化，版本中立路由将没有包含在URI中的版本。因此，如果在版本中立路由上发送版本，NestJS将无法匹配到URI。</p><p id="97dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于版本中立，我们将生成一个新的控制器:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="63af" class="lm ln in lg b gy ms mt l mu mv">$ nest g controller Health</span></pre><p id="e543" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了表明控制器或路由是版本中立的，我们将使用从<code class="fe ld le lf lg b">@nestjs/common</code>导入的<code class="fe ld le lf lg b">VERSION_NEUTRAL</code>符号。我们还将向控制器添加一个GET路由:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="40fd" class="lm ln in lg b gy ms mt l mu mv">import { Controller, Get, VERSION_NEUTRAL } from '@nestjs/common';</span><span id="7afe" class="lm ln in lg b gy mw mt l mu mv">@Controller({<br/>  path: 'health',<br/>  version: VERSION_NEUTRAL,<br/>})<br/>export class HealthController {<br/>  @Get()<br/>  getHealth() {<br/>    return 'Healthy!';<br/>  }<br/>}</span></pre><p id="6f3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了验证版本中立路线，我们可以在有版本和没有版本的情况下对其进行测试:</p><pre class="mk ml mm mn gt mo lg mp mq aw mr bi"><span id="7124" class="lm ln in lg b gy ms mt l mu mv">$ curl localhost:3000/health -H "Accept: application/json;v=1"<br/>Healthy!<br/>$ curl localhost:3000/health<br/>Healthy!</span></pre><p id="03b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们也有了版本中立的路线！</p><h2 id="ba04" class="lm ln in bd lo lp lq dn lr ls lt dp lu kg lv lw lx kk ly lz ma ko mb mc md me bi translated">结论</h2><p id="4921" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">在本文中，我们展示了如何在NestJS应用程序上启用版本控制，并创建版本控制的路由、控制器和版本中立的控制器。</p><p id="a5d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">版本控制是API框架中一个非常有用的特性，可以对不断变化的需求做出反应，做出突破性的改变，同时仍然能够支持消费者可能使用的先前版本。NestJS的这一新特性增加了将它用于Node.js REST API的许多理由。</p><p id="9640" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这篇文章对您使用NestJS的旅程有所帮助！</p><p id="c85a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>你可以在GitHub 上查看一个示例版本应用程序<a class="ae kt" href="https://github.com/rich-w-lee/nest-versioning-demo" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6d7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mx">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mx">plain English . io</em></a></p></div></div>    
</body>
</html>