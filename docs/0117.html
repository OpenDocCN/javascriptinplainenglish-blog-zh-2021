<html>
<head>
<title>How To Reload a Page Whenever a User Makes a Change with React/Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在用户使用React/Redux进行更改时重新加载页面</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-redux-reload-a-page-when-a-user-makes-a-change-7661a3e1b8ed?source=collection_archive---------2-----------------------#2021-01-07">https://javascript.plainenglish.io/react-redux-reload-a-page-when-a-user-makes-a-change-7661a3e1b8ed?source=collection_archive---------2-----------------------#2021-01-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c07a04abf555ad833689e53f98a16b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3J-_ctmq4rfhAPg-42T8wg.png"/></div></div></figure><p id="61be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你有你的反应组件。你知道如何用Redux给他们提供数据。您创建了一个组件，该组件在您的API中创建/更新/删除一个项目，并将它放在显示来自您的API的项目的页面中。如何让整个页面在用户每次修改时重新加载以显示更新的数据？Redux状态和<code class="fe kt ku kv kw b">useEffect()</code>依赖数组。</p><p id="272e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的例子中，可以只使用React将数据从我们的计数器传递到父元素，以获得几乎相同的计数器效果，但是使用Redux state和React <code class="fe kt ku kv kw b">useEffect()</code>依赖数组在某些方面更容易，并且适用于更多的情况。</p><p id="6987" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文假设您对API、React、Redux和Node有基本的了解。我用<code class="fe kt ku kv kw b">create-react-app</code>启动了这个应用程序，并且正在使用功能组件和钩子。你可以在<a class="ae kx" href="https://github.com/abbeyperini/ReactReload" rel="noopener ugc nofollow" target="_blank">这个资源库</a>里找到所有的代码。我在用React (v17.0.1)，Redux (v4.0.5)，<a class="ae kx" href="https://www.npmjs.com/package/react-redux" rel="noopener ugc nofollow" target="_blank"> react-redux </a> (v7.2.2)，和<a class="ae kx" href="https://www.npmjs.com/package/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a> (v2.3.0)。对于这个例子，我使用了<a class="ae kx" href="https://dog.ceo/dog-api/documentation/breed" rel="noopener ugc nofollow" target="_blank"> Dog API </a>来获取随机的柴犬图片进行显示。</p><p id="30b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在测试了API端点之后(在这个例子中是在带有<a class="ae kx" href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=en" rel="noopener ugc nofollow" target="_blank"> JSONView </a>的浏览器中)，我开始为Dog API GET请求设置我的动作类型和动作创建者。多亏了redux-thunk，我能够创建异步操作。对于这个小例子，我将获取请求留在了动作创建器中。</p><p id="0095" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是动作创建器的结果，带加载动作，后面会很重要。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="a806" class="lg lh in kw b gy li lj l lk ll">&gt; shibaActions.js</span><span id="144b" class="lg lh in kw b gy lm lj l lk ll"><strong class="kw io">function</strong> shibesRequested() { return { type: shibaConstants.SHIBES_REQUESTED } }</span><span id="b504" class="lg lh in kw b gy lm lj l lk ll"><strong class="kw io">function</strong> success(result) { return { type: shibaConstants.SHIBES_FETCHED, payload: result } }</span><span id="3c58" class="lg lh in kw b gy lm lj l lk ll"><strong class="kw io">function</strong> failure(error) { return { type: shibaConstants.SHIBE_FETCH_FAIL, payload: error } }</span></pre><p id="117e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来是减速器:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="4083" class="lg lh in kw b gy li lj l lk ll">&gt; shibaReducer.js</span><span id="d222" class="lg lh in kw b gy lm lj l lk ll">const reducer = (state = initialState, action) =&gt; {<br/>    switch(action.type) {<br/>        case shibaConstants.SHIBES_REQUESTED:<br/>            return {<br/>                ...state,<br/>                shibasLoading: true,<br/>                shibasFetched: false<br/>            }<br/>        case shibaConstants.SHIBES_FETCHED:<br/>            return {<br/>                ...state,<br/>                shibasLoading: false,<br/>                shibasFetched: true,<br/>                shibas: action.payload<br/>            }<br/>        case shibaConstants.SHIBE_FETCH_FAIL:<br/>            return {<br/>                ...state,<br/>                shibasLoading: false,<br/>                shibasFetched: false<br/>            }<br/>        default:<br/>            return state<br/>    }<br/>}</span></pre><p id="4ac3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我初始化存储。composeEnhancers中的第一项启用了<a class="ae kx" href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en" rel="noopener ugc nofollow" target="_blank"> Redux开发工具</a>，这个设置允许使用开发工具和中间件(在本例中，redux-thunk)。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="3094" class="lg lh in kw b gy li lj l lk ll">&gt; index.js</span><span id="c638" class="lg lh in kw b gy lm lj l lk ll">import { compose, createStore, applyMiddleware } from 'redux';<br/>import { Provider } from 'react-redux';<br/>import thunk from 'redux-thunk';<br/>import reducer from './store/shibaReducer';</span><span id="1f37" class="lg lh in kw b gy lm lj l lk ll">const rootReducer = reducer;<br/>const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;<br/>const store = createStore(rootReducer, composeEnhancers(applyMiddleware(thunk)));</span><span id="bc1a" class="lg lh in kw b gy lm lj l lk ll">ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;Provider store={store}&gt;<br/>      &lt;App /&gt;<br/>    &lt;/Provider&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="e6ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到我们的组件上！我设置App.js来显示基于本地州的数字的柴犬图片。如果这是一个真正的应用程序，我会花时间为每张图片创建一个唯一的键和alt文本。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="dc8e" class="lg lh in kw b gy li lj l lk ll">&gt; App.js</span><span id="4f61" class="lg lh in kw b gy lm lj l lk ll">import { connect } from 'react-redux';<br/>import { shibaActions } from './store/shibaActions';<br/>import Counter from './components/Counter';</span><span id="251a" class="lg lh in kw b gy lm lj l lk ll">function App(props) {<br/>  const [number, setNumber] = useState(1);</span><span id="651a" class="lg lh in kw b gy lm lj l lk ll">useEffect(() =&gt; {<br/>    props.fetchShibes(number)<br/>  }, []);</span><span id="06ad" class="lg lh in kw b gy lm lj l lk ll">if (!props.shibes || !props.shibes[0]) {<br/>    return (&lt;h1 className="heading"&gt;Loading!&lt;/h1&gt;)<br/>  } else {<br/>    <br/>    let shibaImages = props.shibes.map(shiba =&gt; {<br/>      return (<br/>        &lt;img className="image" src={shiba} alt="shiba" key={shiba}&gt;<br/>        &lt;/img&gt;<br/>      );<br/>    })<br/>  <br/>    return (<br/>      &lt;div className="App"&gt;<br/>        {shibaImages}<br/>        &lt;Counter /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="34ae" class="lg lh in kw b gy lm lj l lk ll">const mapStateToProps = (state) =&gt; {<br/>  return {<br/>    shibes: state.shibas<br/>  }<br/>}</span><span id="d723" class="lg lh in kw b gy lm lj l lk ll">const mapDispatchToProps = (dispatch) =&gt; {<br/>  return {<br/>    fetchShibes: (num) =&gt; dispatch(shibaActions.fetchShibes(num))<br/>  }<br/>}<br/>export default connect(mapStateToProps, mapDispatchToProps)(App);</span></pre><p id="635d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">空的<code class="fe kt ku kv kw b">useEffect()</code>依赖数组(函数后的括号)意味着页面不会无限期地重新呈现，也不会由组件依赖项的更新触发重新呈现。<strong class="jx io">注意:</strong> <a class="ae kx" href="https://medium.com/better-programming/understanding-the-useeffect-dependency-array-2913da504c44" rel="noopener"> Denny Scott </a>和React团队建议不要使用空的依赖数组，因为它们会隐藏bug。</p><p id="4818" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我的shibes已经显示出来了，我将启动计数器组件。因为这个API没有POST、UPDATE或DELETE端点，所以计数器将更改传递给动作创建者中的GET请求url的值<code class="fe kt ku kv kw b">num</code>。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="ab20" class="lg lh in kw b gy li lj l lk ll"><strong class="kw io">let</strong> url = `https://dog.ceo/api/breed/shiba/images/random/${num}`;</span></pre><p id="bfb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我更新了我的动作类型、动作创建者和缩减者。在这个小例子中，我对每一个都使用了一个文件，但是我通常会有多个reducers并使用<code class="fe kt ku kv kw b">combineReducers()</code>钩子。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="0269" class="lg lh in kw b gy li lj l lk ll">&gt; shibaActions.js</span><span id="657c" class="lg lh in kw b gy lm lj l lk ll">function addOne(num) {<br/>      return dispatch =&gt; {<br/>        let number = num + 1;<br/>        dispatch(add(number))<br/>      }</span><span id="3d39" class="lg lh in kw b gy lm lj l lk ll">  function add(number)  { return { type: shibaConstants.ADD_ONE,  <br/>  payload: number } }<br/>}</span><span id="1ef0" class="lg lh in kw b gy lm lj l lk ll">function subOne(num) {<br/>      return dispatch =&gt; {<br/>          let number = num - 1;<br/>          dispatch(sub(number))<br/>      }</span><span id="3f90" class="lg lh in kw b gy lm lj l lk ll">  function sub(number) { return { type: shibaConstants.SUB_ONE, <br/>  payload: number } }     <br/>}</span><span id="8cf1" class="lg lh in kw b gy lm lj l lk ll">&gt; shibaReducer.js</span><span id="dd22" class="lg lh in kw b gy lm lj l lk ll">case shibaConstants.ADD_ONE:<br/>   return {<br/>       ...state,<br/>       counter: action.payload<br/>   }<br/>case shibaConstants.SUB_ONE:<br/>   return {<br/>       ...state,<br/>       counter: action.payload<br/>   }</span></pre><p id="b7b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我也把计数器加到初始状态，这样总有1 shibe。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="b373" class="lg lh in kw b gy li lj l lk ll">&gt; shibaReducer.js</span><span id="adbd" class="lg lh in kw b gy lm lj l lk ll"><strong class="kw io">const</strong> initialState = {shibasLoading: false, shibasFetched: false, counter: 1};</span></pre><p id="8d44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是计数器组件本身——非常简单。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="9c1e" class="lg lh in kw b gy li lj l lk ll">&gt; Counter.js</span><span id="c757" class="lg lh in kw b gy lm lj l lk ll">import React from 'react';<br/>import { connect } from 'react-redux';<br/>import { shibaActions } from '../store/shibaActions';</span><span id="944d" class="lg lh in kw b gy lm lj l lk ll">function Counter(props) {<br/>    const handleOnAdd = () =&gt; {<br/>        props.addOne(props.counter)<br/>    }</span><span id="0122" class="lg lh in kw b gy lm lj l lk ll">const handleOnSub = () =&gt; {<br/>        props.subOne(props.counter)<br/>    }</span><span id="7ef5" class="lg lh in kw b gy lm lj l lk ll">return (<br/>        &lt;div className="container-counter"&gt;<br/>            &lt;h1 className="heading"&gt;Counter!&lt;/h1&gt;<br/>            &lt;button onClick={handleOnAdd}&gt;+&lt;/button&gt;<br/>            &lt;p&gt;{props.counter}&lt;/p&gt;<br/>            &lt;button onClick={handleOnSub}&gt;-&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span><span id="9845" class="lg lh in kw b gy lm lj l lk ll">const mapStateToProps = (state) =&gt; {<br/>    return {<br/>        counter: state.counter<br/>    }<br/>}</span><span id="3440" class="lg lh in kw b gy lm lj l lk ll">const mapDispatchToProps = (dispatch) =&gt; {<br/>    return {<br/>        addOne: (num) =&gt; dispatch(shibaActions.addOne(num)),<br/>        subOne: (num) =&gt; dispatch(shibaActions.subOne(num))<br/>    }<br/>}</span><span id="a539" class="lg lh in kw b gy lm lj l lk ll">export default connect(mapStateToProps, mapDispatchToProps)(Counter);</span></pre><p id="106c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，为了让我们的页面在每次按钮点击更改计数器时重新加载，我们必须返回到App.js。我们将使用<code class="fe kt ku kv kw b">mapStateToProps()</code>来访问页面组件中的计数器，并在我们调度<code class="fe kt ku kv kw b">fetchShibes()</code>时传递它而不是本地状态<code class="fe kt ku kv kw b">number</code>。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="5446" class="lg lh in kw b gy li lj l lk ll">&gt; App.js</span><span id="03f4" class="lg lh in kw b gy lm lj l lk ll">// const [number, setNumber] = useState(1);</span><span id="97d2" class="lg lh in kw b gy lm lj l lk ll">useEffect(() =&gt; {<br/>    props.fetchShibes(props.counter)<br/>  }, [props.counter]);</span></pre><p id="95c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在上面看到的，我们要让页面重新加载按钮更改，唯一要做的事情是将计数器状态放在<code class="fe kt ku kv kw b">useEffect()</code>依赖括号中(React团队建议将状态分配给变量，而不是在依赖数组中使用props.state)。再加上一点点造型，我们就有了一个基本的小柴犬柜台。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/0f9947cf8cc95e408dd479103171e257.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/1*BtBcVZWJLSj0jzGc5DmklA.gif"/></div></figure><p id="df4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让页面基于异步动作重新加载只是稍微困难一些——您可以使用类似上面的<code class="fe kt ku kv kw b">shibasLoading</code>的加载状态。如果您只使用最终结果状态，比如<code class="fe kt ku kv kw b">shibasFetched</code>，那么页面将只基于第一个成功的请求重新加载。所以如果你有一个用户在你的API中添加了很多东西，它只会显示第一个。</p><p id="b5ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个概念也有助于在应用程序中创建错误消息。在将<code class="fe kt ku kv kw b">shibasFetched</code>和<code class="fe kt ku kv kw b">shibasLoading</code>状态对象添加到<code class="fe kt ku kv kw b">mapStateToProps()</code>之后，我更新了我的App.js文件。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="ac5c" class="lg lh in kw b gy li lj l lk ll">&gt; App.js</span><span id="ec7f" class="lg lh in kw b gy lm lj l lk ll">if (!props.shibes || !props.shibes[0]) {<br/>    return (<br/>      &lt;div&gt;<br/>        {(props.shibasLoading || !props.shibasFetched) &amp;&amp; &lt;h1  <br/>        className="heading"&gt;Loading!&lt;/h1&gt;}<br/>        {!props.shibasLoading &amp;&amp; !props.shibasFetched &amp;&amp; <br/>        &lt;h1&gt;Something went wrong - shibas not loaded.&lt;/h1&gt;}<br/>      &lt;/div&gt;<br/>    )<br/>  } else {<br/>    <br/>    let shibaImages = props.shibes.map(shiba =&gt; {<br/>      return (<br/>        &lt;img className="image" src={shiba} alt="shiba" key={shiba}&gt;<br/>        &lt;/img&gt;<br/>      );<br/>    })<br/>  <br/>    return (<br/>      &lt;div className="App"&gt;<br/>        {!props.shibasLoading &amp;&amp; !props.shibasFetched &amp;&amp; <br/>        &lt;h2&gt;Something went wrong - shibas not loaded.&lt;/h2&gt;}<br/>        &lt;Counter /&gt;<br/>        {shibaImages}<br/>      &lt;/div&gt;<br/>    );<br/>  }</span></pre><p id="ebc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用JSX条件逻辑和Redux状态，我们可以根据异步请求的状态显示不同的错误消息。</p><h1 id="3e39" class="lo lh in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="ae0f" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">在我自己努力弄明白之后，我努力创建了一个简单的例子，展示了如何使用<code class="fe kt ku kv kw b">useEffect()</code>钩子根据其他组件所做的改变来重新加载组件。</p><p id="747d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在一个应用程序中有很多方法可以使用它，基本概念本身允许你做一些有趣的事情，比如使用JSX条件逻辑定制错误消息。</p><p id="ab0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这对你有所帮助，或者给你留下了一个问题，请给我留言！</p></div></div>    
</body>
</html>