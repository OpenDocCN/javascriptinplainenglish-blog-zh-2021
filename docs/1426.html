<html>
<head>
<title>TypeScript: Type Safe Date Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:键入安全日期字符串</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/type-safe-date-strings-66b6dc58658a?source=collection_archive---------0-----------------------#2021-03-26">https://javascript.plainenglish.io/type-safe-date-strings-66b6dc58658a?source=collection_archive---------0-----------------------#2021-03-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f1ed58c5b4dcd8b047409eaf7680ecb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h2INfHt8d5Eqd52z"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@hudsoncrafted?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Debby Hudson</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="38c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，TypeScript 4.1发布了，随之而来的是<strong class="kc io">模板文字类型</strong>。</p><p id="67b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模板文字类型不仅让开发人员有机会声明某个变量应该是字符串类型，而且还允许开发人员声明字符串的格式。</p><h2 id="7b00" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">用例是什么，你如何实现它？</h2><p id="1e12" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如果你在问自己上面的问题，你很幸运！本文旨在展示一个这样的例子！看哪；键入安全日期字符串！</p><p id="eb2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，让我们来看看如何实现这一点的可能实现。</p><p id="e9a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们首先假设我们的应用程序有两个基本日期字符串，DateYMString和DateYMDString。这些分别在格式<code class="fe lw lx ly lz b">YYYY-MM</code>和<code class="fe lw lx ly lz b">YYYY-MM-DD</code>上。我们假设有效年份是1900年到2099年之间的任何年份。虽然这个约束现在看起来有点武断，但是我将在示例之后解释为什么这些界限确实是必要的。</p><p id="69f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将基于更小的模块化模板文字类型来构造我们的类型<code class="fe lw lx ly lz b">DateYMString</code>和<code class="fe lw lx ly lz b">DateYMDString</code>。让我们首先考虑我们最终想要的类型:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="8052" class="ky kz in lz b gy mi mj l mk ml">export type DateYMString = `${YYYY}-${MM}`;<br/>export type DateYMDString = `${DateYMString}-${DD}`;</span></pre><p id="2722" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然您以前可能没有见过这种类型的脚本语法，但是这个例子应该足够简单。我们已经声明它们由我们尚未声明的<code class="fe lw lx ly lz b">YYYY</code>(年)、<code class="fe lw lx ly lz b">MM</code>(月)和<code class="fe lw lx ly lz b">DD</code>(日)模板文字类型组成。</p><h1 id="c10b" class="mm kz in bd la mn mo mp ld mq mr ms lg mt mu mv lj mw mx my lm mz na nb lp nc bi translated">基本类型</h1><p id="741b" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">那么这些类型看起来怎么样呢？我们知道它们每个都由数字组成，但是我们还没有任何指定数字的类型。先说最基本的:任意数。</p><p id="32de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了尽量接近正则表达式的语法，我们将类型<code class="fe lw lx ly lz b">d</code>声明如下:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="0f0a" class="ky kz in lz b gy mi mj l mk ml">type d = 1|2|3|4|5|6|7|8|9|0;</span></pre><p id="dd9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意<code class="fe lw lx ly lz b">d</code>在它的类型声明中使用实际的数字，而不是包含数字的字符串。在实现时，我发现这并没有什么不同，尽管我也明白可以进行一个论证来显式地将它们声明为字符串。我让读者来决定是否用或不用<code class="fe lw lx ly lz b">"</code>来声明每个数字，以表示它们的严格用法。对于这个例子，我们将保持原样。</p><p id="d965" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">声明了基本数字类型后，我们可以如下声明<code class="fe lw lx ly lz b">YYYY</code>:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="c8e6" class="ky kz in lz b gy mi mj l mk ml">type YYYY = `19${d}${d}` | `20${d}${d}`;</span></pre><p id="2019" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当声明一个YYYY类型的变量不是1900–2099范围内的字符串时，我们现在会得到一个类型错误。</p><p id="8b56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们要声明<code class="fe lw lx ly lz b">MM</code>。我们希望月份数字始终为两位，并且在范围<code class="fe lw lx ly lz b">01</code>到<code class="fe lw lx ly lz b">12</code>内。为此，我们声明如下:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="d437" class="ky kz in lz b gy mi mj l mk ml">type oneToNine = 1|2|3|4|5|6|7|8|9;</span><span id="e0af" class="ky kz in lz b gy nd mj l mk ml">type MM = `0${oneToNine}` | `1${0|1|2}`;</span></pre><p id="73a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们想要重用下面的<code class="fe lw lx ly lz b">oneToNine</code>,所以我们将它声明为自己的类型。同样，声明一个类型为<code class="fe lw lx ly lz b">MM</code>的变量，当它不是一个值在01和12之间的字符串时，会产生错误。</p><p id="04d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们最终的基本模板文字类型，我们将<code class="fe lw lx ly lz b">DD</code>声明如下:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="63a7" class="ky kz in lz b gy mi mj l mk ml">type DD = `${0}${oneToNine}` | `${1|2}${d}` | `3${0|1}`;</span></pre><p id="18ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个热心的读者现在会注意到，如果我们把<code class="fe lw lx ly lz b">DD</code>和<code class="fe lw lx ly lz b">MM</code>按原样组合，无效的日期可能会变成有效的类型。例如2月31日。</p><p id="9161" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是正确的。更复杂的类型可能能够检测到这一点，但是本文仅仅是对常见用例的模板文字类型的介绍，当然编写足够复杂的类型来检测所有无效日期不在此范围之内。也许改天吧。当然，我甚至不确定这是否可能，因为尽管模板文字字符串对于类型来说非常复杂，但它们不如正则表达式强大。</p><h1 id="dbce" class="mm kz in bd la mn mo mp ld mq mr ms lg mt mu mv lj mw mx my lm mz na nb lp nc bi translated">决赛成绩</h1><p id="e871" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">让我们回到开始的地方:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="474e" class="ky kz in lz b gy mi mj l mk ml">export type DateYMString = `${YYYY}-${MM}`;<br/>export type DateYMDString = `${DateYMString}-${DD}`;</span></pre><p id="499c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着<code class="fe lw lx ly lz b">YYYY</code>、<code class="fe lw lx ly lz b">MM</code>和<code class="fe lw lx ly lz b">DD</code>的声明，我们看到我们已经完成了声明。</p><p id="5d98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过声明以下变量来测试我们的类型:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="a92c" class="ky kz in lz b gy mi mj l mk ml">const validYM: DateYMString = "1987-03";</span><span id="beca" class="ky kz in lz b gy nd mj l mk ml">const invalidYM: DateYMString = "1999-23";</span><span id="ac83" class="ky kz in lz b gy nd mj l mk ml">const validYMD: DateYMDString = "2004-03-19";</span><span id="2940" class="ky kz in lz b gy nd mj l mk ml">const unfortunatelyValidYMD: DateYMDString = "1977-02-30";</span><span id="5270" class="ky kz in lz b gy nd mj l mk ml">const invalidYMD: DateYMDString = "1988-01-32";</span></pre><p id="8a0f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们看到两个无效的日期字符串出现了类型错误。不幸的是，如上所述，我们还可以看到<code class="fe lw lx ly lz b">unfortunatelyValidYMD</code>没有发出类型错误警告，这是这个实现的一个弱点。</p><p id="5fd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但至少我们引入了一定程度的类型安全，至少在字符串本身的格式方面，这对于保持应用程序的一致性非常重要。</p><h1 id="e8a5" class="mm kz in bd la mn mo mp ld mq mr ms lg mt mu mv lj mw mx my lm mz na nb lp nc bi translated">而且</h1><p id="eda7" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">讨论并没有到此结束。记忆力好的读者可能想知道为什么我们如此限制年份，而好奇的读者可能想进一步发展这一想法，为包含时间和日期的字符串创建类型检查。</p><p id="75a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您将<code class="fe lw lx ly lz b">YYYY</code>的定义改为如下，您应该能够立即理解原因:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="c628" class="ky kz in lz b gy mi mj l mk ml">type YYYY = `${d}${d}${d}${d}`;</span></pre><p id="20e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在看到在<code class="fe lw lx ly lz b">DateYMString</code>的声明中有一个错误，声明如下:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="e980" class="ky kz in lz b gy mi mj l mk ml">Expression produces a union type that is too complex to represent.(2590)</span></pre><p id="7773" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原来TypeScript只处理最多有100，000种不同类型的联合类型。</p><p id="0721" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出于同样的原因，我们也知道在DateYMDString的末尾添加字符串类型会很快达到这个上限。</p><p id="7604" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么这种情况的解决方案是什么呢？</p><p id="6d6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好问题。</p><p id="3a84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">老实说，我不确定。DateYMDString涵盖了我需要它来涵盖的案例，并且目前正在我正在开发的一个生产应用程序中使用。</p><p id="9845" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我可以想象一个类对象，其中日期和时间是具有不同类型检查的不同字段，但是问题变成了如何创建这些对象。如果将它们从单个字符串中分离出来，然后再转换成新的类型，那么肯定没有现实的方法来确保类型的一致性。如果谁有什么好的建议，请在评论里留下。</p><h1 id="4a5c" class="mm kz in bd la mn mo mp ld mq mr ms lg mt mu mv lj mw mx my lm mz na nb lp nc bi translated">结论</h1><p id="67f3" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">模板文字类型是TypeScript的一个令人兴奋的新增功能，它的用例可能无法立即识别。本文旨在展示一个这样的用例，对于今天的JavaScript生态系统的好的日期库来说，这可能不是非常必要的，但是至少在我们的项目中，我们发现了这些<strong class="kc io">类型的安全日期字符串</strong>的良好用途，如果您觉得它们对您的项目也有用，请不要犹豫使用它们。</p></div></div>    
</body>
</html>