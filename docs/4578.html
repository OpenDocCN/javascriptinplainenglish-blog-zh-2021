<html>
<head>
<title>How to Convert Node.js Code from JavaScript to TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Node.js代码从JavaScript转换为TypeScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-convert-node-js-code-from-javascript-to-typescript-8e7d031a8f49?source=collection_archive---------1-----------------------#2021-09-13">https://javascript.plainenglish.io/how-to-convert-node-js-code-from-javascript-to-typescript-8e7d031a8f49?source=collection_archive---------1-----------------------#2021-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/917be5f1200439a4fcb3cacde3d53464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eX32sidkE5hMsVhw"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@baciutudor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tudor Baciu</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ca89" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="dd9f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">本指南包含大量关于如何开始将现有JavaScript项目转换为TypeScript的信息。</p><h2 id="9a96" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">循序渐进的方法…</h2><p id="5a5f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">本文从建立一个项目(仍然是JavaScript)开始，该项目带有一个TypeScript“编译无错误”设置(将所有文件保留为。js)。一步一步来，我们将解决发现的问题，并最终成为只支持打字稿的(。仅限ts)。</p><p id="6438" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">我建议阅读这份文件两遍。首先建立一个所有待办事项的列表，其次实际处理它们。有很多事情非常重要(“这应该在文件的最顶端”)，但这并不真正可行。</p><h2 id="c37d" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">一些打字稿基础</h2><p id="bbe0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果您从未使用过TypeScript，这将是一个额外的挑战。有几个重要的“提及”需要完成:</p><ul class=""><li id="fb1c" class="mn mo in la b lb mi lf mj lj mp ln mq lr mr lv ms mt mu mv bi translated">TypeScript只存在于“编译”时，在运行时它仍然是JavaScript</li><li id="a7d3" class="mn mo in la b lb mw lf mx lj my ln mz lr na lv ms mt mu mv bi translated">TypeScript并不真正编译，它转换文件。</li><li id="9492" class="mn mo in la b lb mw lf mx lj my ln mz lr na lv ms mt mu mv bi translated">类型脚本传输程序被命名为“tsc”</li><li id="443f" class="mn mo in la b lb mw lf mx lj my ln mz lr na lv ms mt mu mv bi translated">node(node.exe)只能运行JavaScript代码，但是通过添加“插件”ts-node，实现了类型脚本支持。</li><li id="a666" class="mn mo in la b lb mw lf mx lj my ln mz lr na lv ms mt mu mv bi translated">VSCode对TypeScript有很好的支持，ESLint也是(用正确的插件)</li></ul><p id="6cb6" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">最重要的可能是:<em class="nb">运行</em>代码和<em class="nb">传输</em>代码是两回事。你需要让两个世界都工作。</p><p id="5757" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果你想签出一个工作(空)项目，那么签出<a class="ae jz" href="https://github.com/tomnil/emptyts" rel="noopener ugc nofollow" target="_blank">https://github.com/tomnil/emptyts</a>。</p><h2 id="35de" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">类型…</h2><p id="b376" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">虽然有解决常见类型脚本问题的技巧，但这里几乎没有关于如何实际编写类型的信息。尽管如此，一些建议还是很重要的。</p><p id="8219" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">任何</strong></p><p id="2706" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">Any基本上禁用变量的类型检查(read:make it“JavaScript”)。<code class="fe nc nd ne nf b">any</code>应该避免，但在某些情况下非常有用。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="cc0d" class="lw kb in nf b gy no np l nq nr">let a : any = {}<br/>a.name = "Sarah";   // TypeScript checking is disabled here</span></pre><p id="c1d6" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">未知</strong></p><p id="35b5" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><code class="fe nc nd ne nf b">unknown</code>和<code class="fe nc nd ne nf b">any</code>是“远程好友”，但是<code class="fe nc nd ne nf b">unknown</code>不允许通过他们的名字访问属性。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="4153" class="lw kb in nf b gy no np l nq nr">let myBox: unknown = {};       // OK!<br/>myBox = { foo: "bar" };        // OK!<br/>console.log(myBox.foo);        // Error<br/>myBox.foo = "FooBar";          // Error</span></pre><p id="0801" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">对象</strong></p><p id="9e63" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">两种方式都可行:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="6552" class="lw kb in nf b gy no np l nq nr">let user1: <strong class="nf io">{ Name: string, Age: number };</strong><br/>user1 = { Name: "John", Age: 16 };<br/>console.log(user1.Name);</span><span id="5516" class="lw kb in nf b gy ns np l nq nr"><strong class="nf io">type User = { Name: string, Age: number };</strong><br/>let user2: User = { Name: John", Age: 16 };<br/>console.log(user2.Name);</span></pre><p id="95b7" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">现在，基本的东西都在路上了，让我们开始转换。</p><h1 id="230d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">建立工具链</h1><p id="39dc" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">为了能够使用TypeScript，必须有许多工具。还有许多工具可以让它变得更容易:)</p><h2 id="27eb" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">tsc +类型脚本</h2><p id="2203" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">首先对<code class="fe nc nd ne nf b">tsc</code>(trans piler)和<code class="fe nc nd ne nf b">typescript </code>本身进行全局安装。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="63f8" class="lw kb in nf b gy no np l nq nr">npm install tsc -g</span><span id="531e" class="lw kb in nf b gy ns np l nq nr">npm install typescript --save-dev</span></pre><h2 id="bb02" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">ts节点</h2><p id="2d65" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">ts-node是添加支持直接运行TypeScript的模块(即；<em class="nb">非</em> <strong class="la io"> <em class="nb"> </em> </strong>先编自。ts到。js然后运行. js. ts-node就可以运行了。ts直接)。</p><p id="9706" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">该工具必须安装在本地。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="a19e" class="lw kb in nf b gy no np l nq nr">npm install ts-node --save-dev</span></pre><h2 id="2965" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">类型同步(可选)</h2><p id="35a4" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这是一个很好的工具，可以自动下载所有你引用的模块的定义文件(它不是内置在你引用的模块中的)。使用npm安装。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="e1dd" class="lw kb in nf b gy no np l nq nr">npm install -g typesync</span></pre><h2 id="9bb2" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">eslint(可选)</h2><p id="0996" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">eslint同样重要，但不在本文讨论范围内。</p><h1 id="9d5d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">为TypeScript配置项目</h1><h2 id="2c4f" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">创建tsconfig.json</h2><p id="b81b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在项目的根目录下，创建<code class="fe nc nd ne nf b">tsconfig.json</code>。从以下内容开始:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="a520" class="lw kb in nf b gy no np l nq nr">{<br/>  "compilerOptions": { /* Docs: <a class="ae jz" href="https://www.typescriptlang.org/tsconfig" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/tsconfig</a> */<br/>    "target": "ES2020",<br/>    "module": "commonjs",<br/>    "outDir": "bin",<br/>    "rootDir": "src",<br/>    "strict": true,<br/>    "noImplicitAny": false,<br/>    "strictNullChecks": true,<br/>    "checkJs": true,<br/>    "allowJs": true,<br/>    "moduleResolution": "node",<br/>    "types": [<br/>      "node"<br/>    ],<br/>    "lib": [<br/>      "es6"<br/>    ],<br/>    "esModuleInterop": true,<br/>    "skipLibCheck": true,<br/>    "forceConsistentCasingInFileNames": true,<br/>    "allowUnreachableCode": true,<br/>     "useUnknownInCatchVariables": false,  // TypeScript 4.4+ only!<br/>},<br/>  "include": [<br/>    "src/**/*.ts",<br/>    "src/**/*.js"<br/>  ],<br/>  "exclude": [<br/>    "node_modules",<br/>    "&lt;node_internals&gt;/**",<br/>  ]<br/>}</span></pre><p id="eee7" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">相应地更改include和exclude(注意，这些设置将<strong class="la io"> <em class="nb">而不是</em> </strong>被一些工具使用，除非环境变量<code class="fe nc nd ne nf b">TS_NODE_FILES</code>被设置为<code class="fe nc nd ne nf b">true</code>)。</p><h2 id="0e6d" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">关于配置设置的一些快速注释</h2><p id="baff" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><strong class="la io">《目标》:“es 2020”</strong></p><p id="9f56" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果你在做后端开发，那么尽可能使用新的EcmaScript版本是最合理的。</p><p id="0efb" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io"> "rootDir": "src" </strong></p><p id="3995" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果您遵循大多数标准，您的源代码在“src”中</p><p id="b72d" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io"> "outDir": "out" </strong></p><p id="5417" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">Typescript是围绕从/src/文件夹到目标目录/out/的“编译”(实际上是传输)而构建的。</p><p id="fbd7" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">本指南避免使用/out/文件夹，因为它会降低开发和调试过程的速度。按原样运行代码(如。ts)的效率要高得多。但是，必须设置“outDir”。</p><p id="6b5a" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">“allow js”——传输javascript文件</strong></p><p id="8bf2" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果需要，打开<code class="fe nc nd ne nf b">allowJs</code>和<code class="fe nc nd ne nf b">checkJs</code>。要处理的js文件。ts文件。此外，确保两者。ts和。js包含在<code class="fe nc nd ne nf b">include</code>部分。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="8564" class="lw kb in nf b gy no np l nq nr">"include": [<br/>        "src/**/*.ts",<br/>        "src/**/*.js"<br/>    ],</span></pre><p id="c2b3" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">"<strong class="la io">useunknowincatchpavariables</strong>"</p><p id="a28b" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">这是从TypeScript 4.4开始的新设置。默认情况下，它被设置为true，这意味着catch中的<code class="fe nc nd ne nf b">error</code>将是<code class="fe nc nd ne nf b">unknown</code>，并且默认情况下不可能访问<code class="fe nc nd ne nf b">.message</code>。</p><p id="a25e" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">简单的解决方法是(，目前，将<code class="fe nc nd ne nf b">useUnknownInCatchVariables</code>设置为<code class="fe nc nd ne nf b">false</code>，或者进行适当的修复。有关此主题的更多信息，请参见下文。</p><h2 id="6f60" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">。gitignore出文件夹</h2><p id="d54e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">使用git？修改<code class="fe nc nd ne nf b">.gitignore</code>以从<code class="fe nc nd ne nf b">tsc</code>中排除<code class="fe nc nd ne nf b">out</code>文件夹和临时文件。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="8bb4" class="lw kb in nf b gy no np l nq nr">out/<br/># TS -incremental file<br/>tsconfig.tsbuildinfo<br/>node_modules</span></pre><h2 id="a599" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">从搜索结果中删除文件夹“out”</h2><p id="7089" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">英寸vscode/settings.json，使用以下设置:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="09cc" class="lw kb in nf b gy no np l nq nr">{<br/>  "search.exclude": {<br/>     "**/node_modules": true,<br/>     "**/package-lock.json": true,<br/>     "**/package.json": true,<br/>     "out/**": true // Don't search the TypeScript "out" folder<br/>   }<br/>}</span></pre><h2 id="0cb3" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">vscode:重新加载窗口以确保正确加载tsconfig.json</h2><p id="d583" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">vscode将处理<code class="fe nc nd ne nf b">tsconfig.json</code>，但此时重新加载vscode可能是个好主意:按<code class="fe nc nd ne nf b">ctrl-shift-p</code>并搜索命令“开发人员:重新加载窗口”。</p><h1 id="2d2f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">添加现有类型</h1><p id="9834" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">从npm注册表安装的模块类型可以通过四种不同的方式进行解析:</p><ul class=""><li id="503e" class="mn mo in la b lb mi lf mj lj mp ln mq lr mr lv ms mt mu mv bi translated">这些类型包含在模块所有者中</li><li id="a910" class="mn mo in la b lb mw lf mx lj my ln mz lr na lv ms mt mu mv bi translated">这些类型可以单独安装</li><li id="ee40" class="mn mo in la b lb mw lf mx lj my ln mz lr na lv ms mt mu mv bi translated">手动编写缺少的类型</li><li id="ebbf" class="mn mo in la b lb mw lf mx lj my ln mz lr na lv ms mt mu mv bi translated">将模块设置为“任意”</li></ul><p id="6598" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><code class="fe nc nd ne nf b">typesync</code>是一个很酷的工具，可以检测缺失的类型(如果没有找到，用npm安装它)</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="9d71" class="lw kb in nf b gy no np l nq nr">&gt; typesync</span><span id="9c98" class="lw kb in nf b gy ns np l nq nr">📦 projectname — package.json (1 new typings added, 0 unused typings removed)<br/>└─ + @types/<strong class="nf io">packagename1</strong></span><span id="7ccd" class="lw kb in nf b gy ns np l nq nr">✨  Go ahead and run npm install or yarn to install the packages that were added.</span><span id="3b70" class="lw kb in nf b gy ns np l nq nr">&gt; npm install</span></pre><p id="50dd" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果找不到需要的类型，只有两种方法可以解决。要么自己编写类型，要么将整个<em class="nb">模块声明为any。后者通常是最容易的:在根目录下创建一个名为“declarations.d.ts”的文件，并允许它只包含<strong class="la io">和</strong>“declare module”语句(<strong class="la io">没有其他内容</strong>，否则它将停止工作)。</em></p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="3fd8" class="lw kb in nf b gy no np l nq nr">declare module 'excel4node';</span></pre><p id="5774" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果你想要一些关于如何写类型的信息，去看看https://github.com/DefinitelyTyped/DefinitelyTyped。</p><h2 id="e804" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">设置变量的类型</h2><p id="bf5c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如上所述，本指南不是打字稿指南。但是给个提示大概是好事吧。有三种方法可以将类型分配给变量:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="c051" class="lw kb in nf b gy no np l nq nr">type User = { Name: string, Age: number };</span><span id="6367" class="lw kb in nf b gy ns np l nq nr">let a : User | undefined = undefined;<br/>let b = &lt;User&gt;{ Name: "Karin", Age: 40 };   // Type Assertion<br/>let c = { Name: "Karin", Age: 40 } as User; // Type Assertion</span></pre><h1 id="fce6" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">传输文件并决定如何修复错误</h1><p id="14e8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在第一个TypeScript transpile中，您当前的javascript文件几乎肯定会生成大量的警告和错误。在尝试切换到TypeScript之前，很可能必须修复现有javascript文件中的许多问题。从命令行运行:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="2f05" class="lw kb in nf b gy no np l nq nr">tsc -b -v</span></pre><p id="1a85" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">…或者，如果您喜欢使用文件监视器以增量方式运行<code class="fe nc nd ne nf b">tsc</code>:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="b049" class="lw kb in nf b gy no np l nq nr">tsc --build --verbose --incremental --watch</span><span id="9912" class="lw kb in nf b gy ns np l nq nr"># or shorter:</span><span id="502a" class="lw kb in nf b gy ns np l nq nr">tsc -b -v -i -w</span></pre><p id="f2fd" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">逐个解决错误时，让编译器在窗口中以监视模式运行。</p><h2 id="df96" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">固定顺序</h2><p id="1102" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果可能的话，从“最深”层次的代码开始，即从磁盘/互联网加载数据的代码。基本上，如果<code class="fe nc nd ne nf b">LoadWeatherDataFromRemoteAPI()</code>返回<code class="fe nc nd ne nf b">{ Temparature: 25 }</code>，这个函数应该是这样的:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="022b" class="lw kb in nf b gy no np l nq nr">function <!-- -->LoadWeatherDataFromRemoteAPI() : { Temparature: number } {<br/> // ... code for fetching here<!-- --> <br/>}</span></pre><p id="b6ed" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">这个主题将在下面详细讨论(包括如何处理承诺/等待/异步)。</p><h2 id="76d0" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">JsDoc机会</h2><p id="0f39" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">TypeScript transpiler理解JsDoc注释，vscode识别它们，但是一旦转换完成，一些(很多？)是不需要的。TypeScript应该为类型获胜(并且可以选择为其他内容保留JsDoc)</p><p id="df19" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果您的代码在这一点上完全缺乏JsDoc，那么将它作为中间解决方案来编写/生成可能会有所帮助。它<em class="nb">将</em>帮助你解决错误，但也是朝着错误的方向迈出的一步。一旦转换完成，这个新编写的JsDoc可能会被删除。JsDoc示例:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e8dd79ebafa2e59b855d996d78783093.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*-oj5COgxAr0DrsKwav6IFA.png"/></div></figure><p id="3ad1" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">和变量使用<code class="fe nc nd ne nf b">/** @type { <em class="nb">thetype </em>} */</code></p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/903ce8d133aec35fd95db84986dda9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/1*0SanGiXQofDGQpyB6yaazw.gif"/></div></figure><h2 id="91d5" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">自动编写文档/解析类型</h2><p id="2805" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">考虑下面的JavaScript代码。该函数缺少参数类型:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="f230" class="lw kb in nf b gy no np l nq nr">function RandomNumber(iTo) {<br/>    return Math.round(Math.random() * iTo + 0.5);<br/>}</span></pre><p id="1952" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">自动推断类型是可能的:)但是我强烈建议在文件被重命名为<code class="fe nc nd ne nf b">.ts</code>之后<em class="nb">进行推断，因为它将编写真正的类型脚本代码(而不是jsDoc)。阅读下面关于这个话题的更多内容。</em></p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/6721cc6beaa67a26fe40c3c49f2221f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*x6dx0hBwBVl-6eP_EgAqnQ.gif"/></div></div></figure><h1 id="1488" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决错误</h1><p id="24a7" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">同时将文件保存为。js，有可能解决很多问题。现在，如果您已经决定重命名为。ts，没关系。先看重命名部分:)</p><h2 id="f4f7" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">运算符“xyz”不能应用于“string”和“number”类型。</h2><p id="7d95" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">看起来很简单，不要混合类型。:)</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="0cd8" class="lw kb in nf b gy no np l nq nr">// Incorrect type set<br/>let a="0";<br/>console.log(a+1);   // Disallowed, a is a string</span><span id="2feb" class="lw kb in nf b gy ns np l nq nr">// toFixed converts to string!<br/>const a = 3.1415926;<br/>const b = a.toFixed(2);<br/>const c = 2 * b;     // Disallowed, b is a string</span></pre><h2 id="6b90" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">fs.readFileSync和JSON.parse问题</h2><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="e004" class="lw kb in nf b gy no np l nq nr">Argument of type 'Buffer' is not assignable to parameter of type 'string'.ts(2345)</span></pre><p id="d802" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">解决方案:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="882e" class="lw kb in nf b gy no np l nq nr"># Change from:<br/>let result1 = JSON.parse(fs.readFileSync(fileName));</span><span id="a9e8" class="lw kb in nf b gy ns np l nq nr">To:<br/>let result2 = JSON.parse(fs.readFileSync(fileName, 'utf-8'));</span></pre><h2 id="34c7" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">如果没有别的，就忽略这个错误</h2><p id="7e72" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">嗯，现在可能有一些很难修复的错误。只需用<code class="fe nc nd ne nf b">@ts-ignore</code>标记该行即可(也许可以将其添加到backlog中，以便稍后修复):</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="4428" class="lw kb in nf b gy no np l nq nr">process.on('unhandledRejection', (error) =&gt; {<br/>    //@ts-ignore<br/>    logger.info("Unhandled exception - internal error. Stacktrace=" + error.stack);<br/>});</span></pre><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/6562c0e79efc90bdbdd34483ed9d962a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7kEvL6XPcPf3E4yNj9mAgQ.gif"/></div></div></figure><h1 id="e0f6" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">关于全局变量和Express的特殊注释</h1><p id="6d21" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">并非所有项目都包含全局变量或使用Express。本节专门讨论与此相关的问题。</p><h2 id="19bc" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">声明全局</h2><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="207d" class="lw kb in nf b gy no np l nq nr">error TS2339: Property ‘myVariable’ does not exist on type ‘Global &amp; typeof globalThis’.</span></pre><p id="2edc" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">解决方案:在一个<strong class="la io"> .d.ts </strong>文件中，定义对象。这里有一些解决这个问题的例子:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="5dd6" class="lw kb in nf b gy no np l nq nr">var myVariable: boolean;<br/>    var myClass1: Object;<br/>    var myClass2: any;<br/>    var myObject3: { Name: string, Username: string };<br/>    var myObject3Array: { Name: string, Username: string }[];<br/>}</span></pre><p id="f51e" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">通常你会看到下面的风格作为建议，但上面的风格将与tsc一起工作，同时用智能感知运行代码<em class="nb">和</em>。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="a19f" class="lw kb in nf b gy no np l nq nr">declare global {<br/>    namespace NodeJS {<br/>        interface Global {<br/>            myVariable: boolean,<br/>            myClass1: Object,<br/>            myClass2: any,<br/>            myObject3: { Name: string, Username: string },<br/>            myObject3Array: { Name: string, Username: string }[],<br/>        }<br/>    }<br/>}</span></pre><p id="8e75" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">无论哪种方式，请使用最适合您的方式。</p><h2 id="d0fb" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">表达</h2><p id="d98e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">将类型Express类型添加为(不要忘记导入Express):</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="cd67" class="lw kb in nf b gy no np l nq nr">import Express from "express";</span><span id="5204" class="lw kb in nf b gy ns np l nq nr">app.get(`/ping`, (req: <strong class="nf io">Express.Request</strong>, res: <strong class="nf io">Express.Response</strong>) =&gt; {<br/>   return res.json({ result: "pong"});<br/>});</span></pre><p id="0504" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">例如，如果您希望在<code class="fe nc nd ne nf b">Express.Request</code>上有额外的属性，您可能会得到如下错误:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="1579" class="lw kb in nf b gy no np l nq nr">error TS2339: Property ‘User’ does not exist on type ‘Request&lt;ParamsDictionary&gt;’.</span></pre><p id="e9f8" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">解决方案是修改全局名称空间(参见上面的另一个例子)。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="0c29" class="lw kb in nf b gy no np l nq nr">declare global {<br/>  namespace Express {<br/>    interface Request {<br/>      User: { Name: string }<br/>    }<br/>  }<br/>}</span></pre><h1 id="c57a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">尝试按原样运行项目</h1><p id="835b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果您成功运行tsc，并且没有任何错误，那么项目<em class="nb">可能</em>会在此时运行。同样，<em class="nb">编译</em>代码和<em class="nb">运行</em>代码是两回事。</p><h2 id="005e" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">从命令行</h2><p id="342b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们将避免使用构建步骤“编译”(read:trans pilling)到/out/ destination目录，最好设置所有工具按原样运行typescript。</p><p id="78bf" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">运行代码而不传输很容易，只需在start命令中包含ts-node:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="6e55" class="lw kb in nf b gy no np l nq nr"># Faster startup<br/>node.exe <strong class="nf io">-r ts-node/register/transpile-only</strong> ./src/index.js</span><span id="dd76" class="lw kb in nf b gy ns np l nq nr"># Or use:<br/>node.exe <strong class="nf io">-r ts-node/register</strong> ./src/index.js</span><span id="ac91" class="lw kb in nf b gy ns np l nq nr"># Read more at: <a class="ae jz" href="https://github.com/TypeStrong/ts-node" rel="noopener ugc nofollow" target="_blank">https://github.com/TypeStrong/ts-node</a></span></pre><p id="cb08" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">没有成功？想要一个工作项目？在github上查看<a class="ae jz" href="https://github.com/tomnil/emptyts" rel="noopener ugc nofollow" target="_blank"> emptyts </a>项目。</p><h2 id="3464" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">直接从vscode调试</h2><p id="d12e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在，我们还没有配置vscode。您需要进行额外的更改才能使其工作。打开“launch.json”并使用以下内容。修改参数以匹配启动文件的名称。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="ccfb" class="lw kb in nf b gy no np l nq nr">{<br/> // Detailed docs:<br/> // <a class="ae jz" href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging" rel="noopener ugc nofollow" target="_blank">https://code.visualstudio.com/docs/nodejs/nodejs-debugging</a><br/> "version": "0.2.0",<br/> "configurations": [<br/><strong class="nf io">  {<br/>   "name": "Debug typescript",<br/>   "type": "node",<br/>   "request": "launch",<br/>   "smartStep": false,<br/>   "sourceMaps": true,<br/>   "args": [<br/>    "${workspaceRoot}/src/index.ts"<br/>   ],<br/>   "runtimeArgs": [<br/>    "-r",<br/>    "ts-node/register/transpile-only"<br/>   ],<br/>   "cwd": "${workspaceRoot}",<br/>   "protocol": "inspector",<br/>   "internalConsoleOptions": "openOnSessionStart",<br/>   "env": {<br/>    "TS_NODE_FILES": "true" // Respect include/exclude in tsconfig.json =&gt; will read declaration files  (ts-node --files src\index.ts)<br/>   },<br/>   "skipFiles": [<br/>    "&lt;node_internals&gt;/*",<br/>    "&lt;node_internals&gt;/**",<br/>    "&lt;node_internals&gt;/**/*",<br/>    "${workspaceRoot}/node_modules/**",<br/>    "${workspaceRoot}/node_modules/**/*"<br/>   ],<br/>   "outputCapture": "std",<br/>   "stopOnEntry": false<br/>  }</strong><br/> ]<br/>}</span></pre><p id="3a7e" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">按“ctrl-shift-p”调出命令面板。搜索并选择“调试:选择并开始调试”。在出现的菜单中，选择“调试类型脚本”(如上所述)。</p><p id="7229" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">提示:断点是通过在一行上按F9来切换的。</p><h2 id="dbe8" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">Nodemon？ts-node？</h2><p id="77af" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果您想运行nodemon，请查看<a class="ae jz" href="https://github.com/tomnil/emptyts" rel="noopener ugc nofollow" target="_blank"> emptyts </a>项目，那里有相关文档。</p><h1 id="809d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">将require更改为import，将module.exports更改为export</h1><p id="6114" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">确切地说，如何编写导入和导出语句超出了本指南的范围，但是值得一提。此外，这可能不适用于您的项目。</p><p id="b7f5" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">请理解:仅仅解决需求是不够的，<em class="nb">需求和导出都需要完成。</em></p><h2 id="7cb7" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">将“要求”替换为“进口”。</h2><p id="b899" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">示例:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="01f0" class="lw kb in nf b gy no np l nq nr">const stack = require('callsite');<br/>const winston = require('winston');<br/>const path = require("path");<br/>require('winston-daily-rotate-file')</span></pre><p id="3a43" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">会变成:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="401c" class="lw kb in nf b gy no np l nq nr">import stack from 'callsite';<br/>import winston from 'winston';<br/>import * as path from 'path';<br/>import 'winston-daily-rotate-file';</span></pre><p id="d6cd" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">搜索并替换</strong></p><p id="cb3b" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">不可能成功地进行搜索和替换，因为导入的工作方式略有不同。从修复一些常见的需求开始，比如<code class="fe nc nd ne nf b">fs</code>和<code class="fe nc nd ne nf b">path</code>。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="4965" class="lw kb in nf b gy no np l nq nr">Search: const fs = require("fs");<br/>Replace: import * as fs from 'fs';</span><span id="f292" class="lw kb in nf b gy ns np l nq nr">Search: const path = require("path");<br/>Replace: import * as path from 'path';</span></pre><p id="ec28" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">因为require在幕后施展了一些魔法，而import没有:不可能从require到import直接进行搜索/替换。根据模块的使用方式，可以使用以下任何一种:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="d732" class="lw kb in nf b gy no np l nq nr">// Entire module<br/>import * as xyz from 'xyz';<br/>import xyz from 'xyz';</span><span id="c3ea" class="lw kb in nf b gy ns np l nq nr">// Specific object<br/>import { User } from 'xyz';</span><span id="b5e6" class="lw kb in nf b gy ns np l nq nr">// Both<br/>import xyz, { User} from 'xyz';</span></pre><p id="614e" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">现在，这很可能会失败，但至少可以避免一些手动编写。按“ctrl-shift-h ”,并确保勾选“regex”:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="aaf4" class="lw kb in nf b gy no np l nq nr">Search: ^\w+\s+(\w+)\s+=\s+require\((["'].*["'])\);{0,2}$<br/>Replace: import * as $1 from $2;</span></pre><p id="4fee" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">检查tsc的输出并尝试修复一些明显的问题，但请注意<strong class="la io">在修复导出之前不可能解决所有问题。所以继续读下去吧…</strong></p><h2 id="c8fb" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">将“module.exports”替换为“export”</h2><p id="3573" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">示例:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="c20c" class="lw kb in nf b gy no np l nq nr">module.exports.Function1 = Function1;<br/>module.exports.Function2 = Function2;<br/>module.exports.Function3 = Function3;</span><span id="8da9" class="lw kb in nf b gy ns np l nq nr">// or:<br/>module.exports = { Function1, Function2, Function3}</span></pre><p id="3523" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">变成了:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="7974" class="lw kb in nf b gy no np l nq nr">export { Function1, Function2, Function3 }</span><span id="8c19" class="lw kb in nf b gy ns np l nq nr"># Or use export before the function keyword:</span><span id="837a" class="lw kb in nf b gy ns np l nq nr">export function CreateOrder() {<br/>    // Do work<br/>}</span><span id="7292" class="lw kb in nf b gy ns np l nq nr"># If you want a default export, use: </span><span id="2658" class="lw kb in nf b gy ns np l nq nr">export default { Function1, Function2, Function3 }</span></pre><h2 id="478e" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">修复“module.exports”</h2><p id="4f67" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">嗯，这很难。没有简单的方法来进行搜索和替换。需要大量的手工修复。试试这个:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="96da" class="lw kb in nf b gy no np l nq nr">Search: (module\.exports\s=\s)(.*)$<br/>Replace: export default $2</span></pre><p id="3804" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">现在修复tsc报告的问题。</p><h2 id="c634" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">package.json可能面临的挑战</h2><p id="0280" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果将<code class="fe nc nd ne nf b">type</code>设置为<code class="fe nc nd ne nf b">module</code>，可能会让事情变得更糟。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="a57d" class="lw kb in nf b gy no np l nq nr">{<br/>	"name": "my project1",<br/>	"version": "1.0.0",<br/>	"private": true,<br/>	"type": "module",<br/>	 ...<br/>}</span></pre><p id="2ded" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">没有成功？想要一个工作项目？在Github上查看<a class="ae jz" href="https://github.com/tomnil/emptyts" rel="noopener ugc nofollow" target="_blank"> emptyts </a>项目。</p><h1 id="00f6" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">重命名所有文件。js到。分时（同timesharing）</h1><p id="b6c8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这就是有趣的地方。重命名文件将禁用一些功能，并启用许多其他功能。</p><p id="7733" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">重命名中的所有源文件。js到。ts，使用您选择的工具。还要把launch.json(以及其他地方)从<code class="fe nc nd ne nf b">index.js</code>开始改成<code class="fe nc nd ne nf b">index.ts</code></p><p id="debb" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">重要提示</strong>:重命名后重启VSCode。</p><p id="b5ba" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">重命名后，TypeScript的每个检查都将被激活。大概VSCode和<code class="fe nc nd ne nf b">tsc</code>都会报告新的错误。其中一些问题很容易解决，而其他问题甚至可能需要重新设计代码。尽管如此，您仍然可以让TypeScript退回到旧的javascript特性——这在许多情况下可能是可以的(只需使用<code class="fe nc nd ne nf b">// @ts-ignore</code>)。将一个项目变成100%的TypeScript不是一蹴而就的。:)</p><h2 id="9d8a" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">删除导入语句的文件扩展名</h2><p id="aad8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果您引用了包含扩展名的完整路径的文件，您可能会在运行代码的<em class="nb">上失败，但是在使用tsc传输文件时<em class="nb">不会失败。</em></em></p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="461c" class="lw kb in nf b gy no np l nq nr"># Bad<br/>import MeasureTime from "./include/measuretime.js";</span><span id="1596" class="lw kb in nf b gy ns np l nq nr"># Good<br/>import MeasureTime from "./include/measuretime";</span></pre><p id="2ea6" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">搜索/替换为:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="fbed" class="lw kb in nf b gy no np l nq nr">Search:   (import.*)['|"](.*).js['|"]<br/>Replace:     $1 '$2'</span></pre><h2 id="07b7" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">从传输文件中排除文件夹</h2><p id="13b4" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果您有与“src”相同级别的文件夹，可能会出现以下错误:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="6b5e" class="lw kb in nf b gy no np l nq nr">TS6059: File ‘abc’ is not under ‘rootDir’</span></pre><p id="4bd3" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">通过排除“tsconfig.json”中的文件夹来排除文件夹，但确保设置了<code class="fe nc nd ne nf b">TS_NODE_FILES</code>(如果为真，将使用包含/排除)</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="c21a" class="lw kb in nf b gy no np l nq nr">"include": [<br/>	"src/**/*.js",<br/>	"src/**/*.ts"<br/>],<br/>"exclude": [<br/>	"test",<br/>	"bin",<br/>	"out",<br/>	"additionalFolderToSkip"<br/>]</span></pre><h1 id="3d29" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">推断类型(也称为自动文档)</h1><p id="8895" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><strong class="la io">这部分文档包含了最好的提示:)</strong>考虑下面的代码。我们很容易理解FindUser接受一个参数userID，通过查看代码，您和TypeScript都知道它是一个字符串。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="1b55" class="lw kb in nf b gy no np l nq nr">const user = FindUser("John");<br/>if (user)<br/>    console.log(`User found. Name=${user.Name}`);</span><span id="a233" class="lw kb in nf b gy ns np l nq nr">function FindUser(userID) {     // No type on param or return</span><span id="3ab8" class="lw kb in nf b gy ns np l nq nr">    if (userID === "John")<br/>       return { Name: "John", Age: 99 };<br/>    else<br/>        return undefined;<br/>}</span></pre><p id="e4a5" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">..但如果是这样会更好:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="6b3d" class="lw kb in nf b gy no np l nq nr">function FindUser(userID<strong class="nf io">: string</strong>)<strong class="nf io"> : { Name: string, Age: number } | undefined</strong> {     // We're clear on expectations!</span><span id="d65c" class="lw kb in nf b gy ns np l nq nr">    ... code follows</span><span id="3ff1" class="lw kb in nf b gy ns np l nq nr">}</span></pre><p id="6311" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">要么手写，<strong class="la io">要么使用以下技巧</strong>:</p><p id="7efe" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">要推断参数，点击<strong class="la io">一个参数</strong>并允许黄色建议出现“从用法推断参数”。这将检查代码，确定参数的类型。有时结果不正确，所以检查它是否有意义。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/139488bab93393dd9d63a577c16e5ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*luVeLx9NueZXwB0odlesUg.gif"/></div></div></figure><p id="dcd5" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">现在返回参数<em class="nb">也可以</em>被推断出来。设置光标光标需要在<strong class="la io">函数名称</strong>处，并按ctrl + shift + r。可选地使用命令调色板并搜索“重构…”。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/db5a54b65155d7d9bbae6e102b5c0e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*spATDXT5mCkBBIU0BLAVVg.gif"/></div></div></figure><p id="4147" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">最后一个技巧是对返回参数使用这种样式。这种构造代码的方式确保了该类型只编写一次。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="cc34" class="lw kb in nf b gy no np l nq nr">function FindUser(userID: string): typeof result {</span><span id="e4ed" class="lw kb in nf b gy ns np l nq nr">  let result: { Name: string, Age: number } | undefined = undefined;</span><span id="a1ae" class="lw kb in nf b gy ns np l nq nr">  if (userID === "John")<br/>    result = { Name: "John", Age: 99 };</span><span id="028e" class="lw kb in nf b gy ns np l nq nr">  return result;</span><span id="4068" class="lw kb in nf b gy ns np l nq nr">}</span></pre><p id="4783" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">或者使用这种风格，但是返回承诺的方法将具有挑战性:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="85ad" class="lw kb in nf b gy no np l nq nr">function FindUser(userID: string): { Name: string, Age: number } | undefined {</span><span id="1dc2" class="lw kb in nf b gy ns np l nq nr">    let result: ReturnType&lt;typeof FindUser&gt; = undefined;</span><span id="7740" class="lw kb in nf b gy ns np l nq nr">    if (userID === "John")<br/>        result = { Name: "John", Age: 99 };</span><span id="088d" class="lw kb in nf b gy ns np l nq nr">    return result;</span><span id="444d" class="lw kb in nf b gy ns np l nq nr">}</span></pre><h1 id="3725" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决中的错误。ts文件</h1><h2 id="1a82" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">对象可能“未定义”</h2><p id="6de2" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">由于<code class="fe nc nd ne nf b">tsconfig.json</code>指定了<code class="fe nc nd ne nf b">strickNullChecks: true</code>，那么TypeScript将为所有没有特别检查未定义的代码给出错误。这会导致以下错误:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="d350" class="lw kb in nf b gy no np l nq nr">TS2532: Object is possibly 'undefined'.</span></pre><p id="28cf" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">例如:可能找不到所寻找的用户。SendResetPasswordLink()将因此失败。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="5776" class="lw kb in nf b gy no np l nq nr"># Bad code<br/>let user = userlist.find("admin");<br/>user.SendResetPasswordLink();  // No check if user is undefined</span><span id="d43c" class="lw kb in nf b gy ns np l nq nr"># Correct code:<br/>let user = userlist.find("admin");<br/>if (user)<br/>   user.SendResetPasswordLink();</span></pre><h2 id="a716" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">函数参数</h2><p id="8be4" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">所有参数都必须使用或指定为可选。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="d869" class="lw kb in nf b gy no np l nq nr">TS2554: Expected 2 arguments, but got 1.</span></pre><p id="eb42" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">示例:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="cdb3" class="lw kb in nf b gy no np l nq nr">let user = FindUser("admin");<br/>function FindUser(userName: string, region: string) {<br/>    // ... implementation here<br/>}</span></pre><p id="c519" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">解决方案是用两个参数调用，使区域可选或有一个默认值:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="62be" class="lw kb in nf b gy no np l nq nr">function FindUser(userName: string, region?: string) {<br/>    // ... region can now be a string | undefined.<br/>}</span><span id="c988" class="lw kb in nf b gy ns np l nq nr">function FindUser(userName: string, region= "Europe") {<br/>    // ... region can now be a string <br/>}</span></pre><h2 id="0e31" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">异步函数和关键字Promise</h2><p id="10f1" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果你写一个异步函数，函数的返回值必须是一个承诺。考虑这个函数:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="0e14" class="lw kb in nf b gy no np l nq nr">function UserExists(userID: string): boolean {<br/>    return (userID === "John");<br/>}</span></pre><p id="3880" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果需要异步，那么返回参数将从<code class="fe nc nd ne nf b">boolean</code>变为<code class="fe nc nd ne nf b">Promise&lt;boolean&gt;</code>。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="73ea" class="lw kb in nf b gy no np l nq nr"><strong class="nf io">async </strong>function UserExists(userID: string): <strong class="nf io">Promise&lt;boolean&gt;</strong> {<br/>    // Additional code here requiring it to be async.. :)<br/>    return (userID === "John");<br/>}</span></pre><h2 id="5842" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">现在很多对象不都是“任何”吗？</h2><p id="37c9" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">嗯，是的。<code class="fe nc nd ne nf b">let a;</code>基本等于<code class="fe nc nd ne nf b">let a : any;</code></p><p id="6087" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">这意味着您可以对该对象做任何您想做的事情(就像在JavaScript中一样)，但这并不是我们真正想要的类型脚本。我们希望控制和<em class="nb">知道我们在做什么。</em></p><p id="6ae1" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果你想禁用<code class="fe nc nd ne nf b">any</code>，那么打开<code class="fe nc nd ne nf b">tsconfig.json</code>，将<code class="fe nc nd ne nf b">noImplicitAny</code>从<code class="fe nc nd ne nf b">false</code>改为<code class="fe nc nd ne nf b">true</code>，享受错误:)</p><h2 id="7778" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">在TypeScript中使用{}。</h2><p id="b8dd" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这在JavaScript中可能行得通，但在TypeScript中却很烦人。变量将被声明为<code class="fe nc nd ne nf b">{}</code>，仅此而已。示例:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="d508" class="lw kb in nf b gy no np l nq nr">let myBox = {};<br/>myBox.contents = "fruit";<br/># ^^^ Will render "<!-- -->TS2339: Property 'contents' does not exist on type '{}'."</span></pre><p id="032d" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果您确实想使用{}，那么您至少可以通过三种不同的方式来解决这个问题:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="4c83" class="lw kb in nf b gy no np l nq nr"># Set the type (Works since contents is optional)<br/>let myBox1: { contents?: string } = {};<br/>myBox1.contents = "fruit";</span><span id="c846" class="lw kb in nf b gy ns np l nq nr"># Better<br/>let myBox2: { contents: string };   // Variable is unused<br/>myBox2 = { contents: "fruit" };</span><span id="4658" class="lw kb in nf b gy ns np l nq nr"># Or in this case, best (the type for myBox3 is inferred automatically)<br/>let myBox3 = { contents: "fruit" };</span><span id="31b6" class="lw kb in nf b gy ns np l nq nr"># Basically turn of type checking (not recommended)<br/>let myBox4 : any = {};<br/>myBox4.contents = "fruit";</span></pre><h2 id="7386" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">类型“xyz”不可分配给类型“never”(第1部分)</h2><p id="eb93" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">举个例子。对已经在对象中定义的数组进行推送将会产生此错误。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/4e8db99b52eb5b815ce8824c7e603667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izbc_2VIPKSNhHEAP0hl-w.png"/></div></div></figure><p id="8fe6" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">另一个更简单的例子:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="7ac9" class="lw kb in nf b gy no np l nq nr">let users = [];<br/>users.push("John");</span></pre><p id="3fe2" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">将导致:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="8aec" class="lw kb in nf b gy no np l nq nr">TS2345: Argument of type 'string' is not assignable to parameter of type 'never'.</span></pre><p id="859b" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">解决方案是指定类型:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="1381" class="lw kb in nf b gy no np l nq nr">let users<strong class="nf io">: string[</strong>] = [];<br/>users.push("John");</span></pre><p id="65f5" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">如果在进行修复时类型未知，请执行以下操作:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="a784" class="lw kb in nf b gy no np l nq nr">let users: any[] = [];</span><span id="65f1" class="lw kb in nf b gy ns np l nq nr">// or, if possible, use unknown. It's a stronger type</span><span id="a0d3" class="lw kb in nf b gy ns np l nq nr">let result : unknown[] = [];</span></pre><h2 id="18d9" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">类型“xyz”不可分配给类型“never”..(第二部分)</h2><p id="4390" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">对于带有数组的对象，这个问题至少有三种不同的解决方案。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="bf36" class="lw kb in nf b gy no np l nq nr">const payload = {<br/>    name: "Tomas",<br/>    accessrights: []       // Will become "never[]"<br/>};</span><span id="f9a9" class="lw kb in nf b gy ns np l nq nr">payload.accessrights.push("Admin"); </span><span id="01d3" class="lw kb in nf b gy ns np l nq nr">// Error: "Argument of type 'string' is not assignable to parameter of type 'never'."</span></pre><p id="2dde" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">解决方案1 —内嵌类型</strong></p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="6242" class="lw kb in nf b gy no np l nq nr">const payload:<strong class="nf io"> {<br/>    name: string,<br/>    accessrights: string[]<br/>} </strong>= {<br/>    name: "Tomas",<br/>    accessrights: []<br/>};</span></pre><p id="5b28" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">解决方案2—定义类型(或接口)</strong></p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="ed0b" class="lw kb in nf b gy no np l nq nr"><strong class="nf io">type ThePayload = { name: string, accessrights: string[] }<br/></strong>// interface IThePayload { name: string, accessrights: string[] }</span><span id="52cd" class="lw kb in nf b gy ns np l nq nr">const payload<strong class="nf io">: ThePayload</strong> = {<br/>    name: "Tomas",<br/>    accessrights: []<br/>};</span></pre><p id="faf1" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">解决方案3—类型推理</strong></p><p id="2e2c" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">这是最快的实现，但是它给出的代码可读性较差:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="8078" class="lw kb in nf b gy no np l nq nr">const payload: ThePayload = {<br/>    name: "Tomas",<br/>    accessrights: <strong class="nf io">&lt;string[]&gt;</strong>[]<br/>};</span></pre><h2 id="c0e3" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">日期和毫秒</h2><p id="b91b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">您不能执行这样的操作:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="d5ad" class="lw kb in nf b gy no np l nq nr">let t1 = new Date();<br/>let t2 = new Date();<br/>console.log(t2 - t1);</span></pre><p id="198f" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">使用TypeScript，您需要精确和具体:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="daec" class="lw kb in nf b gy no np l nq nr">let t1 = new Date().getTime();<br/>let t2 = new Date().getTime();<br/>console.log(t2 - t1);</span></pre><h2 id="2b77" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">类型不同/ TypeScript很智能</h2><p id="9c8c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">考虑下面的代码。a是字符串，b可以是字符串<em class="nb">或者</em>未定义。第三行的作业是怎么发生的？</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="5f2d" class="lw kb in nf b gy no np l nq nr">let a: string;<br/>const b: string | undefined = "Banana";<br/>a = b;</span></pre><p id="9f47" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">嗯，打字稿很聪明。不知道b是一个字符串。悬停在b上给出:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0240b8bf42af4a867f57f65febefd0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/1*uKiV8YnMTppDPbu2E4l_fg.gif"/></div></figure><p id="f704" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">If语句是形象化这一点的最佳方式。Foo显然可以是一个字符串或未定义的，但在if语句后它只能是一个字符串:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/3e75e646864cf36c2cf7b40ee541a1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wUSSj7tbR3gWBGkQTAepwA.gif"/></div></div></figure><h1 id="101b" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">目的地代码应该有多严格？</h1><p id="589c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">嗯，那是见仁见智的问题。以下设置控制大部分严格性:</p><h2 id="a64d" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">tsconfig.json — strictNullChecks</h2><p id="d7d8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">使用此设置，所有代码都需要正确处理未定义的。</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="1cef" class="lw kb in nf b gy no np l nq nr">function GetTemparature(): <strong class="nf io">number | undefined</strong> {<br/>    // A piece of code should return the temparature,<br/>    // but that occasionally returns undefined<br/>}</span><span id="f32f" class="lw kb in nf b gy ns np l nq nr">const temp = GetTemparature();<br/>if (temp &gt; 50)  <strong class="nf io">// Error, temp may be undefined</strong><br/>    console.log("It's hot.");</span></pre><h2 id="2c2e" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">ts config . JSON-useunknowincatchpavariables</h2><p id="9e1a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果该设置开启，必须正确处理<code class="fe nc nd ne nf b">catch</code>中使用的变量:</p><p id="e657" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">错误代码:</strong></p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="9903" class="lw kb in nf b gy no np l nq nr">try {<br/>   // Some bad code that generates an exception<br/>} catch (error) {<br/>   console.log(error.message);  // Fail!</span></pre><p id="21ea" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">好代码:</strong></p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="645e" class="lw kb in nf b gy no np l nq nr">try {<br/>   // Some bad code that generates an exception<br/>} catch (error) {<br/><strong class="nf io">   if (error instanceof Error)<br/>       </strong>console.log(error.message);  // OK!<br/>}</span></pre><h2 id="c2eb" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">tsconfig.json — noImplicitAny</h2><p id="ceb0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">设置为true时，不允许使用<code class="fe nc nd ne nf b">any</code>:</p><pre class="ng nh ni nj gt nk nf nl nm aw nn bi"><span id="a659" class="lw kb in nf b gy no np l nq nr">const user: <strong class="nf io">any </strong>= { name: "Tomas", Foo: "Bar" };</span></pre><h2 id="29dc" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">//@ ts-忽略</h2><p id="289d" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">即使以上所有设置都打开了，仍然可以忽略这些错误。一个完全转换的代码库应该争取没有到很少<code class="fe nc nd ne nf b">// @ts-ignore</code>。</p><p id="d57d" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated">当然，还有更多转换的技巧，但我希望这个指南能给你一些提示。</p><p id="3013" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><strong class="la io">享受</strong>:)</p><p id="2460" class="pw-post-body-paragraph ky kz in la b lb mi ld le lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv ig bi translated"><em class="nb">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>