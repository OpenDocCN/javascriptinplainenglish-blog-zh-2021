<html>
<head>
<title>How to Structure Angular Apps in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年如何架构Angular Apps</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-structure-angular-apps-in-2021-a0bdd481ad0d?source=collection_archive---------0-----------------------#2021-04-10">https://javascript.plainenglish.io/how-to-structure-angular-apps-in-2021-a0bdd481ad0d?source=collection_archive---------0-----------------------#2021-04-10</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/55607418da17e88dabc36e2d3cdcb190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Of4lqmoYAS_G6gtA"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Photo by <a class="ae kd" href="https://unsplash.com/@kaleidico?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kaleidico</a> on <a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="ke kf kg"><p id="7d2c" class="kh ki kj kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ik bi translated"><strong class="kk is">编辑-2 </strong>:更新图表，添加注释。</p><p id="2836" class="kh ki kj kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ik bi translated"><strong class="kk is">编辑-1 </strong>:添加github repo的图表和示例。</p></blockquote><p id="1dee" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">有许多方法可以构建一个有角度的应用程序。但这就是我如何构建我的应用程序，以获得广泛的灵活性、可伸缩性和较小的初始包大小。</p><figure class="lk ll lm ln gu js gi gj paragraph-image"><div class="gi gj lj"><img src="../Images/8b3e9237f4a3a85c298b16dead21f9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*fyvCBbsujxq7-_P1XaW8fg.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig-1: Preferred Directory Structure</figcaption></figure><ul class=""><li id="236f" class="lo lp ir kk b kl km kp kq lg lq lh lr li ls lf lt lu lv lw bi translated"><strong class="kk is">核心</strong>:app启动绝对必不可少的东西。</li><li id="54e0" class="lo lp ir kk b kl lx kp ly lg lz lh ma li mb lf lt lu lv lw bi translated"><strong class="kk is">特性</strong>:业务逻辑。包含特定业务功能的模块、组件、服务和其他角度构建块(如果需要)。</li><li id="20eb" class="lo lp ir kk b kl lx kp ly lg lz lh ma li mb lf lt lu lv lw bi translated"><strong class="kk is">分享</strong>:组件哑到疼！</li><li id="afd8" class="lo lp ir kk b kl lx kp ly lg lz lh ma li mb lf lt lu lv lw bi translated"><strong class="kk is">页面</strong>:带惰性加载模块的路由组件。</li></ul><h1 id="8b21" class="mc md ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">核心</h1><p id="f10f" class="pw-post-body-paragraph kh ki ir kk b kl na kn ko kp nb kr ks lg nc kv kw lh nd kz la li ne ld le lf ik bi translated">核心目录是放置单体服务、注入令牌、常量、应用配置、管道、拦截器、防护、认证服务、实用程序等的地方。这将在应用程序范围内使用。如果有特定于应用程序本身、部署、CI/CD、API和开发人员的东西，很可能属于核心。</p><figure class="lk ll lm ln gu js gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/a9c981514dafb8a71b4f6e1f78f792ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*30ov1jG1FD2iCrYM1EhAXQ.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig-1: Example Core directory</figcaption></figure><h1 id="4a0f" class="mc md ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">特征</h1><p id="7f8f" class="pw-post-body-paragraph kh ki ir kk b kl na kn ko kp nb kr ks lg nc kv kw lh nd kz la li ne ld le lf ik bi translated">商业特征存在于这个目录中。根据每个特征制作一个模块。该模块可以包含组件、指令、管道、服务、接口、枚举、实用程序等等。我们的想法是保持事物的紧密联系。所以，一个只在<code class="fe ng nh ni nj b">Speakers</code>模块中使用的管道不应该被定义在全局作用域或<code class="fe ng nh ni nj b">Core</code>内部。这同样适用于该模块所需的任何其他角形积木。</p><figure class="lk ll lm ln gu js gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/38336c24b07d51d29b25e606f0d9938b.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*jtBp2qQEWEraCVJX6FSSgg.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig-2: An example feature module</figcaption></figure><p id="be21" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">组件以模块名为前缀，例如，如果模块名是<code class="fe ng nh ni nj b">SpeakersModule</code>，组件将被命名为<code class="fe ng nh ni nj b">SpeakerAbcComponent, SpeakerXyzComponent</code>等。</p><p id="65da" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated"><strong class="kk is">保持目录中的组件树平坦</strong>。这意味着，如果<code class="fe ng nh ni nj b">SpeakerListComponent</code>是父节点而<code class="fe ng nh ni nj b">SpeakerListItemComponent</code>是子节点，不要在<code class="fe ng nh ni nj b">speaker-list</code>目录中创建<code class="fe ng nh ni nj b">speaker-list-item</code>组件。前缀命名应该清楚地表明这种关系。这样做的目的是能够一眼看出模块中驻留了什么组件。</p><p id="517d" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">功能模块可以导入其他功能，显然是从共享模块中导入。</p><h1 id="a210" class="mc md ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">共享的</h1><p id="4654" class="pw-post-body-paragraph kh ki ir kk b kl na kn ko kp nb kr ks lg nc kv kw lh nd kz la li ne ld le lf ik bi translated">将共享模块视为用户界面组件的迷你库。它们并不特定于某一个业务功能。他们应该是超级愚蠢的，你可以拿走所有的组件，放入另一个角度项目，并期待工作(给定的依赖性得到满足)。您可能已经知道包装其他库提供的用户界面组件，如Material、ng-zorro-antd、ngx-bootstrap等。是一个很好的练习。它保护您免受其API更改的影响，并允许您在需要时替换底层库。共享模块中的组件是进行这种包装的好地方。</p><figure class="lk ll lm ln gu js gi gj paragraph-image"><div class="gi gj nl"><img src="../Images/e3b20427e624d44dc7aae33ec444821f.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*LW_9qLJJindskhLrYAzaag.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig-3: Example Shared Directory</figcaption></figure><p id="39cf" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated"><strong class="kk is">不要制造一个巨大的</strong> <code class="fe ng nh ni nj b"><strong class="kk is">SharedModule</strong></code>，而是将每个原子特征粒化成它自己的模块(见图3)。允许交叉导入原子共享模块，但尽量减少。为了带来一个小库的味道，你甚至可以给目录&amp;模块加上你的角度应用的自定义前缀(默认为<code class="fe ng nh ni nj b">app</code>)。</p><h1 id="f34b" class="mc md ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">页</h1><p id="57d1" class="pw-post-body-paragraph kh ki ir kk b kl na kn ko kp nb kr ks lg nc kv kw lh nd kz la li ne ld le lf ik bi translated">Pages目录是这个结构中最有趣的部分。把它想象成一个<em class="kj">水槽</em>，功能模块落入其中，但是没有出来(即没有导出的成员)。在这些模块中，除了页面之外，您不声明任何组件。</p><figure class="lk ll lm ln gu js gi gj paragraph-image"><div class="gi gj nm"><img src="../Images/8189849a97a99c30f6ca960fc64f8761.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*FtkqkPQqFpLnREJRjlev7Q.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig-4: Example Page Module</figcaption></figure><p id="3762" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">页面控制器没有业务逻辑。他们仅仅是展示者，协调来自业务功能模块的组件。比方说——主页。它将包含一个标题，一个英雄部分，文章，评论，联系等。部分—全部来自各自的功能模块！</p><pre class="lk ll lm ln gu nn nj no np aw nq bi"><span id="3dea" class="nr md ir nj b gz ns nt l nu nv"><a class="ae kd" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>    declarations: [HomePageComponent],<br/>    imports: [<br/>        CommonModule,<br/>        <strong class="nj is">ArticlesModule,<br/>        CommentsModule,<br/>        ContactModule,<br/>        HeadersModule,</strong><br/>        HomePageRoutingModule,<br/>    ],<br/>})<br/>export class HomePageModule {}</span></pre><p id="796f" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">虚构的<em class="kj">主页. component.ts </em>可能是什么样子:</p><pre class="lk ll lm ln gu nn nj no np aw nq bi"><span id="36ec" class="nr md ir nj b gz ns nt l nu nv"><em class="kj">&lt;!-- Component from HeaderModule --&gt;</em><br/><strong class="nj is">&lt;app-header-default&gt;&lt;/app-header-default&gt;</strong></span><span id="533c" class="nr md ir nj b gz nw nt l nu nv">&lt;main class="container"&gt;<br/>    &lt;app-hero-content&gt;&lt;/app-hero-content&gt;</span><span id="7bfa" class="nr md ir nj b gz nw nt l nu nv">    <em class="kj">&lt;!-- Component from ArticleModule --&gt;</em><br/>    <strong class="nj is">&lt;app-article-list&gt;&lt;/app-article-list&gt; </strong></span><span id="35fb" class="nr md ir nj b gz nw nt l nu nv">    <em class="kj">&lt;!-- Component from CommentModule --&gt;</em><br/>    <strong class="nj is">&lt;app-comment-list-latest&gt;&lt;/app-comment-list-latest&gt;</strong></span><span id="4305" class="nr md ir nj b gz nw nt l nu nv">    <em class="kj">&lt;!-- Component from ContactModule --&gt;</em><br/>    <strong class="nj is">&lt;app-contact-form&gt;&lt;/app-contact-form&gt;</strong><br/>&lt;/main&gt;</span><span id="b5b1" class="nr md ir nj b gz nw nt l nu nv"><em class="kj">&lt;!-- Component from FooterModule --&gt;</em><br/><strong class="nj is">&lt;app-footer-default&gt;&lt;/app-footer-default&gt;</strong></span></pre><p id="5d66" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">他们可以从特定于页面的服务中获取帮助，该服务只为该页面组合数据和状态。<strong class="kk is">针对页面组件提供服务，不在</strong> <code class="fe ng nh ni nj b"><strong class="kk is">root</strong></code>。否则，即使在您离开页面后，这种状态也可能持续存在，因为页面组件将被破坏，而页面服务不会被破坏。</p><pre class="lk ll lm ln gu nn nj no np aw nq bi"><span id="3272" class="nr md ir nj b gz ns nt l nu nv">// home-page.service.ts</span><span id="0ece" class="nr md ir nj b gz nw nt l nu nv">@Injectable()<br/>export class HomePageService {}</span><span id="897e" class="nr md ir nj b gz nw nt l nu nv"><br/>// home-page.component.ts</span><span id="8c7b" class="nr md ir nj b gz nw nt l nu nv">@Component({<br/>    ...<br/>    providers: [HomePageService]<br/>}<br/>export class HomePageComponent {<br/>    constructor(private homePageService: HomePageService){}<br/>}</span></pre><p id="d432" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">页面模块最重要的目的是每个模块都被延迟加载，以使应用程序性能更好、更精简。</p><blockquote class="nx"><p id="b0f3" class="ny nz ir bd oa ob oc od oe of og lf dk translated"><strong class="ak">每个页面模块都是惰性加载的！</strong></p></blockquote><p id="850e" class="pw-post-body-paragraph kh ki ir kk b kl oh kn ko kp oi kr ks lg oj kv kw lh ok kz la li ol ld le lf ik bi translated"><strong class="kk is"> Pro-tip: </strong>如果您为每个模块定义了一个页面组件，那么您可以要求进一步减小初始束大小。这种做法也将所有路线组织在一个更容易管理的单一来源(即<code class="fe ng nh ni nj b">AppRoutingModule</code>)中。然后，您的<em class="kj"> app-routing.module.ts </em>文件可能如下所示:</p><pre class="lk ll lm ln gu nn nj no np aw nq bi"><span id="383a" class="nr md ir nj b gz ns nt l nu nv">const appRoutes: Routes = [<br/>    {<br/>        path: '',<br/>        loadChildren: () =&gt; import('./pages/home-page/home-page.module').then((m) =&gt; m.HomePageModule),<br/>    },<br/>    {<br/>        path: 'home',<br/>        redirectTo: '',<br/>        pathMatch: 'full',<br/>    },<br/>    {<br/>        <strong class="nj is">path: 'products/:id',  // &lt;-------- NOTE 1. Child route</strong><br/>        loadChildren: () =&gt;<br/>            import('./pages/product-details-page/product-details-page.module').then((m) =&gt; m.ProductDetailsPageModule),<br/>    },<br/>    {<br/>        <strong class="nj is">path: 'products',     // &lt;--------- NOTE 2. Parent route</strong><br/>        loadChildren: () =&gt;<br/>            import('./pages/product-list-page/product-list-page.module').then((m) =&gt; m.ProductListPageModule),<br/>    },<br/>    {<br/>        path: 'checkout/pay',<br/>        loadChildren: () =&gt;<br/>            import('./pages/checkout-payment-page/checkout-payment-page.module').then((m) =&gt; m.CheckoutPaymentPageModule),<br/>    },<br/>    {<br/>        path: 'checkout',<br/>        loadChildren: () =&gt; import('./pages/checkout-page/checkout-page.module').then((m) =&gt; m.CheckoutPageModule),<br/>    },<br/>    {<br/>        path: '**',<br/>        loadChildren: () =&gt; import('./pages/not-found-page/not-found-page.module').then((m) =&gt; m.NotFoundPageModule),<br/>    },<br/>]</span></pre><p id="5407" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated"><strong class="kk is"> <em class="kj">备注1 &amp; 2 </em> </strong> <em class="kj">:由于路由声明是自顶向下解析的，所以一定要在父路径之前声明子路径。这将确保正确提取延迟加载块。否则，如果您首先定义父路由，那么访问任何子路由也会不必要地加载父路由的模块块。您可以在DevTools中看到不同之处。这是我的实验，当我把父路由放在第一位(图5.1)和子路由放在第一位(图5.2)并访问http://mysite.com/products/1.</em></p><figure class="lk ll lm ln gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj om"><img src="../Images/84bd97f0a55fd21005014220c474261e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lx88QtJmqNxqnR6kGDBmIw.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig-5.1: When /products declared <strong class="bd on">BEFORE</strong> /products/:id in routes config</figcaption></figure><figure class="lk ll lm ln gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj oo"><img src="../Images/9a21e496486c494d9ff9b958d32298f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NE60QsDCRQHy_w2jufYlog.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig-5.2: When /products declared <strong class="bd on">AFTER</strong> /products/:id in routes config</figcaption></figure><h1 id="8627" class="mc md ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">结论</h1><p id="6b3a" class="pw-post-body-paragraph kh ki ir kk b kl na kn ko kp nb kr ks lg nc kv kw lh nd kz la li ne ld le lf ik bi translated">如果你以这种方式构建你的角度应用，它就会变成线性的。下图总结了—</p><figure class="lk ll lm ln gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj op"><img src="../Images/4e115af429550ceb2a3fe2d1d4553277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwIAQ6JhPX-9d-C4zYxlDw.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig-6: Structure of Modules and Directories at a Glance</figcaption></figure><p id="0a63" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">请看这里的应用示例:<a class="ae kd" href="https://github.com/touhidrahman/structure-ng-app-2021" rel="noopener ugc nofollow" target="_blank">touhidrahman/structure-ng-app-2021</a></p><h1 id="5980" class="mc md ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">奖金</h1><p id="ebbe" class="pw-post-body-paragraph kh ki ir kk b kl na kn ko kp nb kr ks lg nc kv kw lh nd kz la li ne ld le lf ik bi translated">将目录路径添加到您的<em class="kj"> tsconfig.json </em>文件中，以便您的应用程序中的导入路径更短更好:</p><pre class="lk ll lm ln gu nn nj no np aw nq bi"><span id="e2ae" class="nr md ir nj b gz ns nt l nu nv">// tsconfig.json<br/>{<br/>    "compilerOptions": {<br/>        "baseUrl": "./",<br/>        <strong class="nj is">"paths": {<br/>            "</strong><a class="ae kd" href="http://twitter.com/core" rel="noopener ugc nofollow" target="_blank"><strong class="nj is">@core</strong></a><strong class="nj is">/*": ["src/app/core/*"],<br/>            "</strong><a class="ae kd" href="http://twitter.com/features" rel="noopener ugc nofollow" target="_blank"><strong class="nj is">@features</strong></a><strong class="nj is">/*": ["src/app/features/*"],<br/>            "</strong><a class="ae kd" href="http://twitter.com/shared" rel="noopener ugc nofollow" target="_blank"><strong class="nj is">@shared</strong></a><strong class="nj is">/*": ["src/app/shared/*"],<br/>            "</strong><a class="ae kd" href="http://twitter.com/environment" rel="noopener ugc nofollow" target="_blank"><strong class="nj is">@environment</strong></a><strong class="nj is">/*": ["src/environments/*"]<br/>        },</strong><br/>        "outDir": "./dist/out-tsc",<br/>    ...<br/>}</span></pre><p id="b6aa" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">现在，您的导入将被别名化为<code class="fe ng nh ni nj b">import { Nice } from '@features/nice</code>而不是<code class="fe ng nh ni nj b">import { Ugly } from './../../path/to/ugly</code>。</p><p id="a958" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">感谢阅读！</p><p id="efd5" class="pw-post-body-paragraph kh ki ir kk b kl km kn ko kp kq kr ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated"><em class="kj">更多内容请看</em><a class="ae kd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk is"><em class="kj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>