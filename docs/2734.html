<html>
<head>
<title>Introduction to Sets in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的集合简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-sets-in-javascript-4fca20b8ba9b?source=collection_archive---------17-----------------------#2021-06-04">https://javascript.plainenglish.io/introduction-to-sets-in-javascript-4fca20b8ba9b?source=collection_archive---------17-----------------------#2021-06-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/07a041de62acecaa23b4dae039a2f039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*reuqmZTWD0eUqtio"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@dsmacinnes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Danielle MacInnes</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9e30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JavaScript中，集合仍然相对较新，我仍然没有看到人们充分利用它们。</p><p id="14cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将探索集合的特性，并研究一些集合可以让我们的生活更容易的例子。</p><h1 id="c6d1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一般概念</h1><p id="7298" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">集合是保持插入顺序的元素集合，并且只允许唯一的元素。如果您在一行中插入五个1，将只插入一个。插入时，使用<code class="fe mb mc md me b">===</code>比较元素，决定是否插入。</p><p id="92f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要意识到这个事实，因为完全相同但具有不同引用的对象实际上会被插入，因为它们是通过引用进行比较的。</p><h1 id="0099" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">向集合添加值</h1><p id="23a6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们如何创建一个集合？最简单的方法是使用Set构造函数。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="86ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以使用返回并存储在<code class="fe mb mc md me b">mySet</code>中的内容来访问一个可以帮助我们添加值的方法。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b14a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以调用集合的<code class="fe mb mc md me b">add</code>方法，并传递一个值，该值将尝试将其添加到集合中，假设它当前还不存在。这个方法确实返回了<code class="fe mb mc md me b">this</code>上下文，所以我们也能够像下面一样将<code class="fe mb mc md me b">add</code>链接在一起。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9953" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">链接允许将多个值背靠背相加，并且还要注意，在这个例子中，我们已经重复插入了3次，但是我们的最终结果仍然是相同的。这是很好的能够链，但如果你有一个清单的价值，以插入到一个集，我们有更好的方法来实现这一点。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8992" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们有一个数据列表，并且正在初始化一个集合，我们可以直接传入数组。这非常方便。如果我们已经有了集合，并且需要插入一个项目数组，仔细检查这些例子，我们必须使用循环，或者如果数组长度已知，使用链接来完成。我们不能使用数组上的扩展运算符来执行<code class="fe mb mc md me b">add</code>方法的插入。</p><h1 id="943e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从集合中移除值</h1><p id="777c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">与<code class="fe mb mc md me b">add</code>相反，我们也提供<code class="fe mb mc md me b">delete</code>方法。它需要一个参数，这个参数就是您想要删除的项目。Set将使用<code class="fe mb mc md me b">===</code>比较来尝试匹配该值。如果找到，该项目将从集合中移除，并且<code class="fe mb mc md me b">true</code>将从功能中返回。如果不匹配，则对集合没有影响，并返回false。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d948" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，在使用集合中的对象和删除时要小心。集合试图匹配一个引用，所以再次传递一个不同引用的匹配对象将不会对集合产生影响，并且<code class="fe mb mc md me b">delete</code>返回false。让我们看看这个案例，以确保我们完全理解这一点。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3fb3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，因为我们是内联定义对象，每个对象都有一个单独的引用，因此集合不能匹配这两个对象。如果我们需要删除一个值列表，与<code class="fe mb mc md me b">add</code>不同的是，不会返回<code class="fe mb mc md me b">this</code>上下文，因为我们返回的是值是否被删除。这导致将多个删除链接在一起会失败。为此，我们必须使用for循环。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9fbf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们一个一个地看一下。链接失败是因为我们之前讨论过，我们没有得到返回给我们的<code class="fe mb mc md me b">this</code>上下文。当我们尝试使用一个项目数组和spread操作符进行删除时，我们得到了奇怪的函数<code class="fe mb mc md me b">true</code>,就好像集合被修改了一样，但是快速查看一下就可以发现它并没有改变。最后，循环遍历我们的项，并简单地对每个项调用delete，这样做是可行的，并做出了预期的更改。如果您需要删除集合中的所有内容，该怎么办？</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3d07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们能够简单地调用<code class="fe mb mc md me b">clear</code>方法一次从集合中删除所有项目。这比遍历并删除所有内容要方便得多。</p><h1 id="d48e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">查找元素是否在集合中</h1><p id="8bd8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">查找一个元素是否存在于一个集合中就像使用提供的<code class="fe mb mc md me b">has</code>方法一样简单。该方法也使用与<code class="fe mb mc md me b">delete</code>相同的<code class="fe mb mc md me b">===</code>比较。根据值是否匹配，它返回true或false。这其实是一个非常有帮助的方法。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8931" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为第一个例子，是相当不言自明的。最后一个例子演示了我们在delete中看到的同样的问题，即引用已经改变，因此不匹配。</p><h1 id="1ea0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">遍历集合</h1><p id="f97d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">集合是元素的有序列表。对我来说，仅仅因为事物的本质是有序的，就表明应该有方法以这种有序的方式来看待元素。我们有几种方法可以用器械包实现这一点，我们将一一介绍。这些方法是<code class="fe mb mc md me b">values</code>、<code class="fe mb mc md me b">entries</code>和<code class="fe mb mc md me b">forEach</code>。先说<code class="fe mb mc md me b">values</code>。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="078e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，<code class="fe mb mc md me b">values</code>方法返回一个迭代器。这意味着我们能够继续调用迭代器上的<code class="fe mb mc md me b">next</code>方法，并且我们将继续获得一个带有两个属性的对象，value和done。虽然done不等于true，但迭代器中仍有值要查看。在第一组例子中，我们手动调用下一个方法。在第二个集合中，您会看到一个使用while循环迭代迭代器的常见实现。现在我们来看一下<code class="fe mb mc md me b">entries</code>方法。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="299a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">语法非常类似于<code class="fe mb mc md me b">values</code>方法，它也返回一个集合迭代器。这里的主要区别是条目，而不仅仅是值，以<code class="fe mb mc md me b">[value, value]</code>的形式返回一个数组。您可能想知道为什么，因为拥有两次该值几乎没有任何用处。</p><p id="44a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据MDN文档:<em class="ml">" entries()方法返回一个新的Iterator对象，该对象包含一个数组，该数组包含</em> <code class="fe mb mc md me b"><em class="ml">Set</em></code> <em class="ml">对象中每个元素的[value，value]，按插入顺序排列。对于</em> <code class="fe mb mc md me b"><em class="ml">Set</em></code> <em class="ml">对象来说没有</em> <code class="fe mb mc md me b"><em class="ml">key</em></code> <em class="ml">像在</em> <code class="fe mb mc md me b"><em class="ml">Map</em></code> <em class="ml">对象中。但是，为了保持API类似于</em> <code class="fe mb mc md me b"><em class="ml">Map</em></code> <em class="ml">对象，每个条目在这里的键和值都是相同的，因此返回一个数组</em> <code class="fe mb mc md me b"><em class="ml">[value, value]</em></code> <em class="ml"/></p><p id="e630" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这绝对是迭代器方法中最没用的，很难想象需要这种方法的情况。现在我们来看看<code class="fe mb mc md me b">forEach</code>。</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="cd5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">The forEach</code> method是迭代方法中比较有用的一种，因为感觉比较熟悉。</p><p id="5ad7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意回调函数的API实际上类似于<code class="fe mb mc md me b">entries</code> API。第一个和第二个参数，它们类似于entries数组中的位置0和1。这意味着它们实际上总是相同的。这是一个类似的论点，这个位置表示键，以保持API类似于Map构造函数，并且由于集合中没有键，所以提供值来代替。</p><h1 id="2f58" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="7df2" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在你知道了集合的API。在JavaScript中，它们是非常有用的数据结构。如果需要使数组具有唯一性，可以考虑将其转换为集合，然后再转换回数组。这将删除所有重复的值(记住我们关于在这方面处理对象的对话)。</p><p id="e47f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设你有两个数组。一个是允许执行某些操作的用户标识列表，另一个是用户列表。现在我们需要过滤用户列表，只包括id在第一个列表中的用户。一种方法是每次查看数组以确定id是否存在。这导致运行时间复杂度为O(N ),这是不理想的。如果您将id数组转换成一个集合，那么您可以调用<code class="fe mb mc md me b">has</code>方法。</p><p id="0065" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于关于集合的文档，我们可以了解到以下内容:“<em class="ml">集合对象必须使用散列表或其他机制来实现，平均来说，这些机制提供的访问时间与集合中的元素数量呈次线性关系。”</em></p><p id="a516" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">集合实际上是作为散列表实现的，这意味着使用这种技术会导致常量时间查找，从而将运行时复杂性降低到O(N)。</p><p id="5631" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当集合可以帮助您的代码时，还有许多其他情况可以发现。如果您发现自己在考虑使用一个对象，但是当您引用它时，您只关心值是否未定义，那么您也可以从使用集合中受益。</p><p id="a7e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ml">plain English . io</em></strong></a></p></div></div>    
</body>
</html>