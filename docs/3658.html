<html>
<head>
<title>5 useEffect Infinite Loop Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5使用效果无限循环模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-useeffect-infinite-loop-patterns-2dc9d45a253f?source=collection_archive---------0-----------------------#2021-07-23">https://javascript.plainenglish.io/5-useeffect-infinite-loop-patterns-2dc9d45a253f?source=collection_archive---------0-----------------------#2021-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/acd767c9a35c399550321175d9e6775d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IKJgMYMfKSvzvUB84C-fg.png"/></div></div></figure><p id="91f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般来说，无限循环被认为是不好的做法。但是在<a class="ae kt" href="https://stackoverflow.com/questions/224204/why-use-infinite-loops" rel="noopener ugc nofollow" target="_blank">一些边缘情况下</a>，你没有任何选择，只能选择一个无限循环。了解React的无限循环模式很有好处。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/c034c68ae9aa1647137d9a067847f622.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/0*D1OnmtizHqj5_PWg.png"/></div></figure><p id="0b8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当无限循环不停地运行时，最终浏览器会终止代码运行的标签。所以不要在没有任何断点的情况下使用<code class="fe kz la lb lc b">Infinite Loop</code>。</p><h1 id="db4f" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用效果</h1><p id="003c" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">useEffect钩子允许我们在一个组件中执行副作用。当钩子被引入react 16时，<code class="fe kz la lb lc b">useEffect</code>钩子比任何其它钩子获得更大的牵引力。因为它提供了<code class="fe kz la lb lc b">componentDidMount</code>、<code class="fe kz la lb lc b">componentDidUpdate</code>和<code class="fe kz la lb lc b">componentWillUnmount</code>生命周期方法的组合功能。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/c45281f00a2adb58767bd3e6cb1e9398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/0*1KlPFvEoyTyfZ4dY"/></div></figure><p id="450a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">useEffect钩子触发回调函数，仅当依赖关系被改变时。并且它使用<code class="fe kz la lb lc b">shallow</code>比较来比较钩子的值。</p><p id="5356" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以把它当作一块能量石，这是一块非常强大的石头，如果你处理不当，它会毁了你。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/50f7482bb5143364798fc16496451194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wCqH7qdfHIiNdbla"/></div></div></figure><h2 id="e717" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">没有依赖性</h2><p id="4f90" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">没有依赖关系的useEffect通常被认为是一种不好的做法，所以要尽量避免。</p><p id="9e51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑下面的代码，它将永远调用API。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="35d8" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">发生什么事了？</h2><p id="664c" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">如果useEffect仅在依赖关系改变时触发回调，为什么我们在这里以无限循环结束。</p><p id="f993" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要考虑React 的另一个重要的<strong class="jx io">咒语，那就是“当状态或道具改变时，组件将重新渲染”。</strong></p><p id="0dfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这段代码中，我们使用<code class="fe kz la lb lc b">setData</code>设置状态值，如果网络调用成功，它将触发组件重新呈现。由于useEffect没有可比较的值，所以它将调用回调。</p><p id="22a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并且Fetch将再次触发<code class="fe kz la lb lc b">setData</code>和<code class="fe kz la lb lc b">setData</code>将触发组件重新渲染等等。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/b2fb9dd331c4dba10e7740304300ec10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqBTU4z7inqygcjxHifvuw.png"/></div></div></figure><h2 id="be3d" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">如何解决这个问题？</h2><p id="c4de" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">我们需要将依赖项指定为空数组。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="cbe2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据官方文件，<a class="ae kt" href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" rel="noopener ugc nofollow" target="_blank">省略依赖关系</a>是<strong class="jx io">不安全的</strong></p><h1 id="6bfc" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">作为依赖项运行</h1><p id="e0ca" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">useEffect使用浅层对象比较来确定数据是否被更改。由于奇怪的JavaScript条件系统😈。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4e83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们考虑下面的代码</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2aa5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数<code class="fe kz la lb lc b">getData</code>作为依赖项传递。</p><p id="3111" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你运行这段代码时，它会抛出<code class="fe kz la lb lc b">Maximum update depth exceeded</code>，这意味着这段代码有一个无限循环。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/c0f408a54460027e6619acee5725c396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DNAYYFk7mPEILg2y"/></div></div></figure><h2 id="991a" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">发生什么事了？</h2><p id="7802" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">因为useEffect使用浅层比较来比较值。函数的浅层比较将总是给出假值。</p><h2 id="5e3a" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">怎么修？</h2><p id="0b60" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">为了解决这个问题，我们需要使用另一个名为<code class="fe kz la lb lc b">useCallback</code>的无限石。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/d3591cdd6232a77e941d60f931a3be6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jlC0mlJ4Sx0FKCDvFALddA.png"/></div></div></figure><p id="463f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">useCallback</code>返回一个<a class="ae kt" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">内存化的</a>版本的回调，它只在依赖关系改变时才会改变。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="0514" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">作为依赖项的数组</h1><p id="9c4b" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">正如你可能知道的，两个的浅层比较总是假的，所以作为数组传递依赖关系也会导致<code class="fe kz la lb lc b">Infinite Loop</code></p><p id="f869" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们考虑下面的代码</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="cf2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，数组<code class="fe kz la lb lc b">dep</code>作为useEffect的依赖项传递。</p><p id="a049" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您运行此代码时，浏览器控制台将引发此错误。</p><h2 id="904a" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">发生什么事了？</h2><p id="4c7e" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">两个数组的浅比较总是假的，所以<code class="fe kz la lb lc b">useEffect</code>总会触发回调。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/700bd78d3234917da185072060fb5ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/0*xKjAD3xLopnANcld.png"/></div></figure><h2 id="4515" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">怎么修？</h2><p id="6eaa" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">因为<code class="fe kz la lb lc b">useCallback</code>返回是一个函数，我们不能使用它。</p><p id="4d53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，你猜怎么着？</p><p id="6322" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要使用另一个名为<code class="fe kz la lb lc b">useRef</code>的钩子</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/50163c6283f6ec4d0bee98c679bb7deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XaRNyHElsXvqXDYqBWtRJg.png"/></div></div></figure><p id="5f7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">useRef</code>返回一个可变对象，其中<code class="fe kz la lb lc b">.current</code>具有初始值。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="abdb" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">作为依赖项的对象</h1><p id="1f1f" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">你可能会猜测两个对象的浅层比较总是假的，所以<code class="fe kz la lb lc b">useEffect</code>将总是触发回调。</p><p id="9d67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们考虑这个代码</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c594" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">data</code>作为useEffect的依赖项传递</p><p id="1038" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您运行这段代码时，您的浏览器控制台将会抛出一个无限循环错误。</p><h2 id="8922" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">这里发生了什么事？</h2><p id="e906" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">对象的浅层比较总是为假，所以它将触发useEffect的回调。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/19466240506232368ed31c4f62374e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/0*fvpb4DiYIe3tLyHK.png"/></div></figure><h2 id="bdd9" class="mi le in bd lf mj mk dn lj ml mm dp ln kg mn mo lr kk mp mq lv ko mr ms lz mt bi translated">怎么修？</h2><p id="a012" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">如果我们记住了依赖关系，我们就打破了无限循环。那么<strong class="jx io">怎么做呢？</strong></p><p id="1e1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，我们将使用另一个名为<code class="fe kz la lb lc b">useMemo</code>的无限宝石</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/84bbed59b9f951f15545ad08fb34729e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_s2ytfg27m6cyxynSG2oQ.png"/></div></div></figure><p id="0a7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">useMemo</code>仅当依赖关系发生变化时，才会重新计算记忆值。</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="e1d0" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">错误的依赖性</h1><p id="1ffa" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">错误的依赖与<code class="fe kz la lb lc b">React</code>无关，甚至与<code class="fe kz la lb lc b">javascript</code>无关。当使用了错误的依赖项时，我们必须承担责任。</p><p id="fa2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们考虑一下代码</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6f81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望没有必要解释这个问题模式及其修复。如果你想要解释和修正，请在评论中告诉我。</p><blockquote class="na nb nc"><p id="bad2" class="jv jw nd jx b jy jz ka kb kc kd ke kf ne kh ki kj nf kl km kn ng kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>有很多方法可以避免React组件内部的无限循环，我只提到了几种方法。</p></blockquote><p id="e1d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总是使用<a class="ae kt" href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react-hooks</a>或create-react-app，它将帮助你在这些问题进入生产服务器之前发现它们。</p><p id="d96b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一家公司由于无限循环，一周内损失了72k。</p><div class="nh ni gp gr nj nk"><a href="https://blog.tomilkieway.com/72k-1/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">我们花了72K美元测试Firebase + Cloud Run，几乎破产[第1部分]</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">这是一个故事，讲述了我们在推出第一款产品之前是如何接近倒闭的，我们是如何生存下来的，以及…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">blog.tomilkieway.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jt nk"/></div></div></a></div><p id="de0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以要一直特别照顾我们的力量石(<code class="fe kz la lb lc b">useEffect</code>)。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/bbc3dbae1793d43c51fa458a64bffb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xrigT-rtRhqECf06Chg9sA.gif"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk"><a class="ae kt" href="https://www.nerdyviews.com/2019/06/infinity-gauntlet-keychain.html" rel="noopener ugc nofollow" target="_blank">https://www.nerdyviews.com/2019/06/infinity-gauntlet-keychain.html</a></figcaption></figure><p id="6185" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另外，请看看我最近写的关于React的文章。</p><ol class=""><li id="f144" class="oe of in jx b jy jz kc kd kg og kk oh ko oi ks oj ok ol om bi translated"><a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/usequery-instead-of-fetch-while-calling-an-api-ef12964457c5">调用API时用Query代替Fetch】</a></li><li id="076e" class="oe of in jx b jy on kc oo kg op kk oq ko or ks oj ok ol om bi translated"><a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/why-you-should-use-useswr-instead-of-usestate-when-calling-apis-8b6de5dc18fc">为什么在调用API时应该使用useSWR而不是Use state</a></li><li id="7ca7" class="oe of in jx b jy on kc oo kg op kk oq ko or ks oj ok ol om bi translated"><a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/a-detailed-guide-to-using-axios-in-your-react-app-7396f79fb4c2">在React应用中使用Axios的详细指南</a></li></ol><p id="ecbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nd">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nd">plain English . io</em></strong></a></p></div></div>    
</body>
</html>