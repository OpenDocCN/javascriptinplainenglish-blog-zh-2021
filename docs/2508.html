<html>
<head>
<title>JavaScript Classes without the Syntactical Sugar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有语法糖的JavaScript类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-classes-without-the-syntactical-sugar-f894e4cf78b8?source=collection_archive---------13-----------------------#2021-05-23">https://javascript.plainenglish.io/javascript-classes-without-the-syntactical-sugar-f894e4cf78b8?source=collection_archive---------13-----------------------#2021-05-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8c52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript不是基于类的语言，它是基于对象(原型)的。但是我们可以和班级一起工作，对吗？所以问题是——这是怎么做到的？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec7e12d5624a500a126b855789aec16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQsSfgXVm22jx8Z1zR08wA.jpeg"/></div></div></figure><p id="9367" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这项新功能是随JavaScript的ECMAScript 2015版本一起发布的。对于那些喜欢使用类的人来说，这是语法上的糖。</p><p id="0ea0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面你会看到一个简单的类，我们会看看，这个类的各个部分是如何在没有类语法的情况下实现的。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="e4ad" class="kz la in kv b gy lb lc l ld le">class User {<br/>  constructor(name, image) {<br/>    this.name = name;<br/>    this.image = image;<br/>    this.rights = [];<br/>  } <br/>  <br/>  addRights(identifier) {<br/>    this.rights.push(identifier);<br/>  }<br/>  <br/>  hasRights(identifier) {<br/>    return this.rights.includes(identifier);<br/>  }<br/>}</span><span id="7b28" class="kz la in kv b gy lf lc l ld le">const user = new User('admin', 'image.jpg');<br/>console.log(user);</span></pre><p id="6244" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果您在<a class="ae lg" href="http://codepen.io" rel="noopener ugc nofollow" target="_blank"> codepen.io </a>上运行上面的代码，并在开发工具中打开控制台，您会看到下面的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lh"><img src="../Images/aa38ea0eb75b25e8964f7d36b1fef817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGuO1qTrz6B1BneoOW6wxw.png"/></div></div></figure><p id="1a91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="li">用户</em>对象保存我们在类的<em class="li">构造函数()</em>中初始化的属性。<em class="li">用户</em>对象继承了一个包含我们类的函数的对象，这个对象继承了全局<em class="li">对象的所有东西。</em></p><p id="8b42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们在没有类语法的情况下构建它…</p><p id="7230" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们构建一个构造函数。这些是“普通的”函数，当它们被前缀new调用时，它们就变成了构造函数。</p><p id="3721" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们遵循惯例，用大写字母书写函数名。</p><p id="4132" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="li"> this </em>关键字指的是我们调用new User()时用这个函数创建的对象。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="e874" class="kz la in kv b gy lb lc l ld le">function User(name, image) {<br/> this.name = name;<br/> this.image = image;<br/> this.rights = [];<br/>}</span></pre><p id="ea13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将方法添加到<em class="li"> User.prototype </em>中，这样我们从用户构造函数中创建的每个对象都将继承我们预定义的方法。</p><p id="bff0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将方法附加到我们的<em class="li"> User.prototype </em>确保我们对于从我们的<em class="li"> User </em>构造函数创建的所有对象只有一个它们的副本。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="d093" class="kz la in kv b gy lb lc l ld le">User.prototype.addRights = function (identifier) {<br/>  this.rights.push(identifier);<br/>};</span><span id="2a7e" class="kz la in kv b gy lf lc l ld le">User.prototype.hasRights = function (identifier) {<br/>  return this.rights.includes(identifier);<br/>};</span></pre><p id="d24e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用new关键字，我们创建一个新的User实例，方法与之前使用class语法时相同。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="caa7" class="kz la in kv b gy lb lc l ld le">const user = new User("admin", "image.jpg");</span><span id="92db" class="kz la in kv b gy lf lc l ld le">console.dir(user);<br/>// same output as above in the screenshot</span></pre><p id="b231" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在可以用同样的方式处理这个用户对象，就像我们用类语法创建它一样。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="809e" class="kz la in kv b gy lb lc l ld le">user.addRights('super-admin');<br/>const hasSuperAdminRights = user.hasRights('super-admin');</span><span id="99c0" class="kz la in kv b gy lf lc l ld le">console.log(hasSuperAdminRights);<br/>// outputs: &gt; true</span></pre><h2 id="f78b" class="kz la in bd lj lk ll dn lm ln lo dp lp jv lq lr ls jz lt lu lv kd lw lx ly lz bi translated">从另一个类继承功能</h2><p id="e061" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">我们创建了一个新类BaseUser，并用BaseUser扩展了User。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="2a22" class="kz la in kv b gy lb lc l ld le"><strong class="kv io">class BaseUser {<br/>  constructor() {<br/>    this.id;<br/>  }<br/>}</strong></span><span id="a49a" class="kz la in kv b gy lf lc l ld le">class User <strong class="kv io">extends BaseUser</strong> {<br/>  constructor(name, image) {<br/>    super();<br/>    <br/>    this.name = name;<br/>    this.image = image;<br/>    this.rights = [];<br/>  } <br/>  <br/>  addRights(identifier) {<br/>    this.rights.push(identifier);<br/>  }<br/>  <br/>  hasRights(identifier) {<br/>    return this.rights.includes(identifier);<br/>  }<br/>}</span></pre><p id="5a4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们如何用我们的原型方法实现这一点？</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="e55c" class="kz la in kv b gy lb lc l ld le"><strong class="kv io">function BaseUser() {<br/>  this.id;<br/>}</strong></span><span id="9ef0" class="kz la in kv b gy lf lc l ld le">function User(name, image) {<br/>  BaseUser.call(this);<br/>  this.name = name;<br/>  this.image = image;<br/>  this.rights = [];<br/>}</span><span id="cef4" class="kz la in kv b gy lf lc l ld le"><strong class="kv io">User.prototype = BaseUser.prototype;</strong></span><span id="33d3" class="kz la in kv b gy lf lc l ld le">User.prototype.addRights = function (identifier) {<br/>  this.rights.push(identifier);<br/>};</span><span id="83bd" class="kz la in kv b gy lf lc l ld le">User.prototype.hasRights = function (identifier) {<br/>  return this.rights.includes(identifier);<br/>};</span></pre><p id="388f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以在用户对象中使用新的属性id</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="6323" class="kz la in kv b gy lb lc l ld le">const user = new User(“admin”, “image.jpg”);<br/>user.id = 1;</span><span id="2e93" class="kz la in kv b gy lf lc l ld le">console.dir(user);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/94099eaa990471340e0cc986a0a1479e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONPpV21EglM5Vbm4JHL0gw.png"/></div></div></figure><p id="afc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望您喜欢这篇文章，并在使用类时更好地理解JavaScript是如何工作的。</p><p id="caff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的反馈，请随意开始对话并发表评论。:)</p><p id="b203" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="li">更多内容请看</em><a class="ae lg" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="li">plain English . io</em></a></p></div></div>    
</body>
</html>