<html>
<head>
<title>Redis: A Comprehensive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis:综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/redis-a-hands-on-introduction-a181b43a32c1?source=collection_archive---------10-----------------------#2021-08-09">https://javascript.plainenglish.io/redis-a-hands-on-introduction-a181b43a32c1?source=collection_archive---------10-----------------------#2021-08-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="862f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过与Node.js、Express &amp; Redis建立电子商务网站，熟悉Redis</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/30c081965ca17e304645e0c51e0ea429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VmcD28OFT_LIF6i3.jpg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Adapted from a photo by <a class="ae ks" href="https://unsplash.com/@pf91_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Patrick</a> on <a class="ae ks" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="893d" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae ks" href="#88ee" rel="noopener ugc nofollow"> <strong class="ak">概述</strong> </a></h2><h2 id="ec5f" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae ks" href="#4787" rel="noopener ugc nofollow">再世</a></h2><ul class=""><li id="766d" class="lp lq in lr b ls lt lu lv lc lw lg lx lk ly lz ma mb mc md bi translated"><a class="ae ks" href="#b8ba" rel="noopener ugc nofollow"> <strong class="lr io">安装Redis </strong> </a></li><li id="287f" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="#84a4" rel="noopener ugc nofollow"> <strong class="lr io">再版GUI </strong> </a></li></ul><h2 id="daae" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae ks" href="#7586" rel="noopener ugc nofollow">设置应用</a></h2><ul class=""><li id="9cc0" class="lp lq in lr b ls lt lu lv lc lw lg lx lk ly lz ma mb mc md bi translated"><a class="ae ks" href="#c973" rel="noopener ugc nofollow"> <strong class="lr io">安装依赖项</strong> </a></li><li id="dd8d" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="#f7eb" rel="noopener ugc nofollow"> <strong class="lr io">连接至再世</strong> </a></li></ul><h2 id="949c" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae ks" href="#72fb" rel="noopener ugc nofollow"> <strong class="ak">在Redis中缓存</strong> </a></h2><h2 id="1fa9" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae ks" href="#8ecf" rel="noopener ugc nofollow"> <strong class="ak">再版为NoSQL文献数据库</strong> </a></h2><h2 id="37c8" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae ks" href="#a604" rel="noopener ugc nofollow"> <strong class="ak">通过Redis进行会话管理</strong> </a></h2><ul class=""><li id="b682" class="lp lq in lr b ls lt lu lv lc lw lg lx lk ly lz ma mb mc md bi translated"><a class="ae ks" href="#28ab" rel="noopener ugc nofollow"> <strong class="lr io">存储会话数据</strong> </a></li><li id="cdf1" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="#27c8" rel="noopener ugc nofollow">储物购物车 </a></li></ul><h2 id="3588" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae ks" href="#4e9f" rel="noopener ugc nofollow">剩余路线</a></h2><ul class=""><li id="e829" class="lp lq in lr b ls lt lu lv lc lw lg lx lk ly lz ma mb mc md bi translated"><a class="ae ks" href="#6fae" rel="noopener ugc nofollow"> <strong class="lr io">添加&amp;移除推车物件</strong> </a></li><li id="1873" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="#b3ab" rel="noopener ugc nofollow">加工大车 </a></li><li id="c7c9" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><a class="ae ks" href="#d1fe" rel="noopener ugc nofollow"> <strong class="lr io">删除用户</strong> </a></li></ul><h2 id="9e96" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae ks" href="#797d" rel="noopener ugc nofollow">结论</a></h2></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="88ee" class="mq ku in bd kv mr ms mt ky mu mv mw lb jt mx ju lf jw my jx lj jz mz ka ln na bi translated">概观</h1><p id="209b" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">如果你正在阅读这篇文章，我想你至少已经查阅了<strong class="lr io"> Redis、</strong>的定义，并且正在寻找一种更实际的方法来处理它。简单地说，</p><blockquote class="no np nq"><p id="cea7" class="nb nc nr lr b ls ns jo nd lu nt jr ne nu nv ng nh nw nx nj nk ny nz nm nn lz ig bi translated">Redis是缓存、会话管理、游戏、引导板、实时分析、地理空间、叫车、聊天/消息、媒体流和酒吧/sub应用的热门选择。</p></blockquote><p id="dd39" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">Redis最适合于快速数据检索。这是通过Redis的内存存储实现的。大多数数据库存储发生在磁盘或固态硬盘上。因此，数据库操作需要往返于磁盘。相比之下，内存中的数据驻留在服务器的随机存取存储器中，不受同样的约束，提供亚毫秒级的响应时间，因此支持大量的操作。</p><p id="6dfc" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">本入门教程的目的是为Redis支持的一些数据结构和操作提供一种实用的方法。我们将使用<strong class="lr io"> NodeJS </strong>和<strong class="lr io"> Express </strong>构建一个简单的电子商务网站。</p><p id="be67" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">本教程的范围最初仅限于Redis的会话管理，但是很明显Redis的多功能性可以用来实现应用程序的大部分功能。我们将在以下情况下使用Redis:</p><ul class=""><li id="38a7" class="lp lq in lr b ls ns lu nt lc oa lg ob lk oc lz ma mb mc md bi translated">缓存API响应。</li><li id="fbfa" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated">作为应用程序用户的NoSQL文档数据库。</li><li id="12c7" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated">会话管理。</li><li id="09c2" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated">存储用户的购物车。</li></ul><p id="dcfa" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">完成后，访问我们应用程序的客户应该能够:</p><ul class=""><li id="a9b4" class="lp lq in lr b ls ns lu nt lc oa lg ob lk oc lz ma mb mc md bi translated">查看可用项目列表。</li><li id="6111" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated">注册并登录。</li><li id="2607" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated">在购物车中添加和删除商品；并查看他们购物车中的内容。</li><li id="8b85" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated">完成或取消购买，在此过程中清空购物车。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi od"><img src="../Images/4ab2878c6ac6f24d7b491705bb115edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WRcNftsM4H6Mp1PJ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Store front-end.</figcaption></figure></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="4787" class="mq ku in bd kv mr ms mt ky mu mv mw lb jt mx ju lf jw my jx lj jz mz ka ln na bi translated">雷迪斯</h1><p id="ee72" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">我们将安装以下组件来启动和运行Redis:</p><ul class=""><li id="936e" class="lp lq in lr b ls ns lu nt lc oa lg ob lk oc lz ma mb mc md bi translated">Docker :一个开发、运输和运行应用程序的开放平台。我们将在Docker容器中运行Redis服务器。</li><li id="b7f8" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><strong class="lr io"> Redis </strong> : <strong class="lr io"> </strong>开源键值存储，起到数据结构服务器的作用。</li><li id="14f1" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><strong class="lr io"> RedisInsight </strong> : Redis GUI可以可视化数据，也可以在不使用shell的情况下执行命令，不过也可以使用CLI。</li></ul><h2 id="b8ba" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">装置</h2><p id="fe5d" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">如果您已经安装了Redis，请跳到<a class="ae ks" href="#84a4" rel="noopener ugc nofollow"> Redis GUI </a>部分。不需要Docker知识。只需在<a class="ae ks" href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04" rel="noopener ugc nofollow" target="_blank"> Ubuntu(第一步&amp;第二步)</a>、<a class="ae ks" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> Mac </a>或<a class="ae ks" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank"> Windows </a>上安装Docker即可。然后从Docker Hub中提取Redis映像。</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="9525" class="kt ku in of b gy oj ok l ol om">docker pull redis</span></pre><p id="b4ec" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">使用别名<code class="fe on oo op of b">redis</code>启动Redis容器，别名<code class="fe on oo op of b">redis</code>由<code class="fe on oo op of b">--name</code>选项提供。Docker守护进程使用<code class="fe on oo op of b">-p</code>标志<code class="fe on oo op of b">6379</code>将容器映射到Redis的默认端口，最后使用<code class="fe on oo op of b">-d</code>标志启动守护进程。</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="1164" class="kt ku in of b gy oj ok l ol om">docker run --name redis -p 6379:6379 -d redis</span></pre><p id="06c9" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">检查容器是否正在运行:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="19ec" class="kt ku in of b gy oj ok l ol om">docker ps</span></pre><p id="c9fc" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">预期输出应类似于:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="ef0b" class="kt ku in of b gy oj ok l ol om">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS              PORTS                                       NAMES<br/>fabcb755ad52   redis     "docker-entrypoint.s…"   10 days ago   Up About a minute   0.0.0.0:6379-&gt;6379/tcp, :::6379-&gt;6379/tcp   redis</span></pre><p id="4a7f" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">要停止容器一起运行:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="00a8" class="kt ku in of b gy oj ok l ol om">docker stop redis</span></pre><p id="1e17" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">要再次启动Redis容器:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="85a0" class="kt ku in of b gy oj ok l ol om">docker start redis</span></pre><h2 id="84a4" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">Redis GUI</h2><p id="a239" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">通过执行以下命令并等待下载完成，在Docker容器中运行RedisInsight:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="838e" class="kt ku in of b gy oj ok l ol om">docker run -v redisinsight:/db -p 8001:8001 redislabs/redisinsight:latest</span></pre><p id="0b42" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">确保上一步中的Redis实例也在运行，然后在浏览器中导航到<a class="ae ks" href="http://localhost:8001" rel="noopener ugc nofollow" target="_blank"> http://localhost:8001 </a>。您应该会看到类似的页面:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oq"><img src="../Images/0de8f20f7472ff7aa4abdcac9273b20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8CICKtvLXH3XjmK8.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">RedisInsight in the browser</figcaption></figure><p id="04a7" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">选择<code class="fe on oo op of b"><strong class="lr io">I already have a database</strong></code> <strong class="lr io"> </strong>然后选择<strong class="lr io"> </strong> <code class="fe on oo op of b"><strong class="lr io">Connect to a Redis Database</strong></code>。</p><p id="9704" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">通过运行以下命令获取Redis容器的IP地址，用作<code class="fe on oo op of b"><strong class="lr io">Host*</strong></code>的值:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="0a12" class="kt ku in of b gy oj ok l ol om">docker container inspect -f "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}" redis</span></pre><p id="38d1" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">如果您使用Docker之外的其他方法安装Redis，请使用<code class="fe on oo op of b">localhost</code>作为<code class="fe on oo op of b"><strong class="lr io">Host*</strong></code>的值。填充字段。</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="4f05" class="kt ku in of b gy oj ok l ol om"><strong class="of io">Host*</strong>: &lt;IPAddress&gt;<br/><strong class="of io">Port*</strong>: 6379<br/><strong class="of io">Name*</strong>: &lt;EnterAName&gt;</span></pre><p id="e766" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">您应该在主页上看到创建的数据库。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi or"><img src="../Images/f2c0ed2e2a53c84bc4e9ddc1a8462eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZRP0XyehRRaQBu0n.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">RedisInsight with database added.</figcaption></figure><p id="9994" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">选择数据库为我们提供了Redis实例的概述。导航到<code class="fe on oo op of b"><strong class="lr io">BROWSE</strong></code>下的<code class="fe on oo op of b"><strong class="lr io">Browser</strong></code>，这是可以检查存储值的地方。我们还可以在<code class="fe on oo op of b"><strong class="lr io">CLI</strong></code>选项卡中执行Redis命令。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi os"><img src="../Images/74ec255c3841ab257f4df1f829ac7644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rokh2p31yPuUZv_F.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">RedisInsight data store.</figcaption></figure></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="7586" class="mq ku in bd kv mr ms mt ky mu mv mw lb jt mx ju lf jw my jx lj jz mz ka ln na bi translated">安装应用程序</h1><h2 id="c973" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">设置</strong></h2><p id="7abf" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">我假设您已经安装了NodeJS。将下面的<a class="ae ks" href="https://github.com/StphnLwnga/redis-cart" rel="noopener ugc nofollow" target="_blank">库</a>、<code class="fe on oo op of b">cd</code>克隆到目录中，并安装依赖项。我们将使用<a class="ae ks" href="https://www.sitepoint.com/a-beginners-guide-to-pug/" rel="noopener ugc nofollow" target="_blank"> PugJS </a>作为模板引擎。</p><p id="23d1" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">这是app的一个骨架。相关的代码和解释将在下面介绍。</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="502e" class="kt ku in of b gy oj ok l ol om">npm i</span></pre><p id="6565" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">要启动应用程序:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="9608" class="kt ku in of b gy oj ok l ol om">npm start</span></pre><p id="14fa" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">导航到<a class="ae ks" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>会把我们带到应用程序的主页。为了限制本教程的范围，省略了真实电子商务网站的许多复杂性。</p><p id="05a5" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">我们有三视图。这是展示商品的主页。在用户页面上，我们将能够创建一个用户，查看最近创建的用户，并以任何用户的身份登录。最后，我们可以查看购物车的内容，并继续完成或取消订单。</p><p id="c8e9" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">为了存储会话数据，应用程序最初将依赖于<code class="fe on oo op of b">express-session</code>的默认会话存储— <code class="fe on oo op of b">MemoryStore</code>，据开发者称，</p><blockquote class="no np nq"><p id="a027" class="nb nc nr lr b ls ns jo nd lu nt jr ne nu nv ng nh nw nx nj nk ny nz nm nn lz ig bi translated">……是不是<strong class="lr io">故意</strong>不是为生产环境设计的。在大多数情况下，它会泄漏内存，不会扩展到单个进程之外，并且用于调试和开发。</p></blockquote><p id="74a6" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">在会话管理部分，我们将讨论如何在Redis中存储会话数据。</p><p id="5dd5" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">启用<code class="fe on oo op of b">app.js</code>内的会话中间件。Require <code class="fe on oo op of b">express-session</code>并将其添加到中间件数组中。我们还将启用即时消息。要设置flash消息传递，我们还要编辑中间件函数，该函数设置<code class="fe on oo op of b">res.locals</code>中的<code class="fe on oo op of b">cartCount</code>属性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./app.js 👉🏾 </strong>Enabling session middleware.</figcaption></figure><p id="d183" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">如果应用程序已经在运行，输入<code class="fe on oo op of b">rs</code>和⏎.</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h2 id="f7eb" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">连接Redis</h2><p id="7c7c" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">我们将使用<code class="fe on oo op of b"><strong class="lr io">ioredis</strong></code>初始化一个Redis客户端。将以下内容添加到<code class="fe on oo op of b">app.js</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><code class="fe on oo op of b"><strong class="ak">./app.js </strong></code><strong class="ak">👉🏾 </strong>Establishing Redis connection.</figcaption></figure><p id="2d36" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">通过将Redis客户端对象作为属性保存在<code class="fe on oo op of b">config</code>中，我们使它在整个应用程序中都可用。重启应用程序。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="72fb" class="mq ku in bd kv mr ms mt ky mu mv mw lb jt mx ju lf jw my jx lj jz mz ka ln na bi translated">贮藏</h1><p id="4c53" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">我们商店的存货目前是空的。我们将向外部服务查询商店的商品。我们将使用<a class="ae ks" href="https://fakestoreapi.com/" rel="noopener ugc nofollow" target="_blank"> Fake Store API </a>来生成清单并将结果缓存在Redis中，从而减少对API的请求数量。</p><p id="db2d" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">每一项都将存储为Redis散列数据类型。哈希是由与值相关联的字段组成的映射，适合于表示对象。Redis中的哈希可能看起来像:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="04c1" class="kt ku in of b gy oj ok l ol om">"object-type:id" field1 value1 field2 value2 ... fieldN valueN</span></pre><p id="72ba" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">第一个条目表示哈希的键，其中包含字段和值。<em class="nr">例如</em>带有SKU <code class="fe on oo op of b">100</code>的项目可以在Redis中表示为:</p><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="4e6f" class="kt ku in of b gy oj ok l ol om">"item:100" name "Jordan Series 0.1" price 115.00 ...</span></pre><p id="b04d" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">这里是Redis支持的其他数据类型的概述。</p><p id="d7a5" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">我们还将在一个单独的列表中索引项目id。每个项目的一个<code class="fe on oo op of b">TTL</code>(生存时间)，并且项目id列表也将被设置。当密钥的<code class="fe on oo op of b">TTL</code>过期时，它们会自动从Redis中删除。我们将把<code class="fe on oo op of b">TTL</code>设置为1小时进行演示。</p><p id="6a2c" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">将以下内容添加到<code class="fe on oo op of b">data/items.js</code>并重启服务器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./data/items.js 👉🏾 </strong>Querying API &amp; caching response in Redis.</figcaption></figure><pre class="kd ke kf kg gt oe of og oh aw oi bi"><span id="a29a" class="kt ku in of b gy oj ok l ol om">rs</span></pre><p id="6cdd" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated"><code class="fe on oo op of b"><strong class="lr io">axios</strong></code> <strong class="lr io"> </strong>用于发出<code class="fe on oo op of b">HTTP</code>请求。<code class="fe on oo op of b"><strong class="lr io">dayjs</strong></code> <strong class="lr io"> </strong>是一个日期时间库我们将用它来显示时间相关的信息。<code class="fe on oo op of b">Items</code>是一个将<code class="fe on oo op of b">config</code>对象作为参数的函数。<code class="fe on oo op of b">config</code>对象包含Redis客户端对象。将在<code class="fe on oo op of b">data/index.js</code>文件中调用<code class="fe on oo op of b">Items</code>函数，并将其导出至路线。<code class="fe on oo op of b">ioredis</code>与回调和承诺一起工作。我们使用了承诺，因此在<code class="fe on oo op of b">try…catch</code>块中使用了<code class="fe on oo op of b">async/await</code>。<code class="fe on oo op of b">ioredis</code>方法映射到同名的Redis命令。您可以在 处查看所有使用过的<a class="ae ks" href="https://redis.io/commands" rel="noopener ugc nofollow" target="_blank"> <strong class="lr io">命令。</strong></a></p><p id="d447" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">我们首先检查项目id列表的<code class="fe on oo op of b">item:itemList</code>键是否仍然存在或者已经过期。如果过期，对Redis' <code class="fe on oo op of b">EXISTS</code>命令的响应是<code class="fe on oo op of b">0</code>，之后向API发出请求。响应是一个item对象数组。Redis事务允许在一个步骤中执行一组命令。通过在客户机上调用<code class="fe on oo op of b">MULTI</code>命令，对事务上的命令进行排队，最后用<code class="fe on oo op of b">EXEC</code>命令执行它们，从而创建一个事务。在<code class="fe on oo op of b">Items</code>函数中，<code class="fe on oo op of b">transaction</code>是在收到API响应后创建的。我们遍历数组，使用析构赋值语法来解包每个<code class="fe on oo op of b">item</code>的属性，并为每个属性排列以下命令:</p><ul class=""><li id="9ffc" class="lp lq in lr b ls ns lu nt lc oa lg ob lk oc lz ma mb mc md bi translated"><code class="fe on oo op of b">HSET</code> <strong class="lr io">👉🏾</strong>哈希方法，采用两个参数、哈希的密钥(<code class="fe on oo op of b">item:id</code>)和要存储在哈希中的字段-值对的对象。</li><li id="99dd" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><code class="fe on oo op of b">EXPIRE</code> <strong class="lr io">👉🏾</strong>在作为参数提供的键上设置以秒为单位的<code class="fe on oo op of b">TTL</code>。</li><li id="fb29" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><code class="fe on oo op of b">RPUSH</code> <strong class="lr io">👉🏾</strong>将值插入列表末尾的列表方法。如果列表不存在，则创建该列表。</li></ul><p id="66e2" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">处理完所有项目后，<code class="fe on oo op of b">item:itemList</code>键的一个<code class="fe on oo op of b">EXPIRE</code>命令也会排队，最后在<code class="fe on oo op of b">transaction</code>上调用<code class="fe on oo op of b">EXEC</code>命令，操作依次执行。事务是原子的<em class="nr">，即</em>要么处理所有命令，要么什么都不处理。如果<code class="fe on oo op of b">EXISTS</code>命令响应为<code class="fe on oo op of b">1</code>，则不执行<code class="fe on oo op of b">if</code>块。</p><p id="c78c" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">我们在一个键上调用<code class="fe on oo op of b">TTL</code>命令来获取和显示我们数据的时间相关信息。</p><p id="dfb9" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated"><code class="fe on oo op of b">Items</code>函数的默认动作是从Redis中检索条目。我们首先使用list方法<code class="fe on oo op of b">LRANGE</code>从<code class="fe on oo op of b">item:itemList</code>获取所有的条目id，该方法接受一个列表键、一个开始和一个停止索引。<code class="fe on oo op of b">-1</code>表示列表中的最后一个元素。我们创建另一个事务<code class="fe on oo op of b">itemPipeline</code>，并将每个条目ID的<code class="fe on oo op of b">HGETALL</code>命令排队。<code class="fe on oo op of b">HGETALL</code>检索存储在指定键的散列的所有字段和值。<code class="fe on oo op of b">EXEC</code>在事务上调用命令。结果是一个包含一些<code class="fe on oo op of b">null</code>值的数组，我们使用<code class="fe on oo op of b">flat</code>和<code class="fe on oo op of b">filter</code>数组方法过滤掉这些值。</p><p id="2ef3" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">API请求和Redis操作封装在<code class="fe on oo op of b">console.time()</code>调用中，让我们了解每批操作需要多长时间。</p><p id="e3ce" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">在<code class="fe on oo op of b">routes/index.js</code>内部，让我们导入<code class="fe on oo op of b">Items</code>并渲染主页中的项目。添加以下内容。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/index.js 👉🏾 Loading items from Redis.</strong></figcaption></figure><p id="af48" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">重新启动服务器。您应该会看到主页上显示的项目。我们还可以在<a class="ae ks" href="http://localhost:8001" rel="noopener ugc nofollow" target="_blank"> RedisInsight </a>中的<code class="fe on oo op of b"><strong class="lr io">Browser</strong></code> <strong class="lr io"> </strong>选项卡中可视化存储的哈希。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/cbc1e072d16f2a2482fc93b427950dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DNecxfA3FT2YeTDh.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Redis Hashes</figcaption></figure><p id="0dd7" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">在终端中，应该可以看到不同操作的时间相关信息。值得注意的是，与从Redis ( <code class="fe on oo op of b">retrieved-from-cache</code>)获取相同数据相比，从API ( <code class="fe on oo op of b">querying-api</code>)获取数据所花费的时间。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="8ecf" class="mq ku in bd kv mr ms mt ky mu mv mw lb jt mx ju lf jw my jx lj jz mz ka ln na bi translated">文档数据库</h1><p id="dc05" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">根据定义，Redis是一个NoSQL数据库，我们可以用它像MongoDB一样将数据存储为文档。尽管将用户保存为散列更有意义，但为了展示Redis的能力，我们将用户保存为JSON字符串。在填写<strong class="lr io">管理用户</strong>页面上的表单时，一个<code class="fe on oo op of b">POST</code>请求被发送到<code class="fe on oo op of b"><em class="nr">/users</em></code> <em class="nr"> </em>路由。让我们来定义路线。在<code class="fe on oo op of b">routes/users.js</code>中编辑以下内容。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/users.js 👉🏾 </strong>User sign up route.</figcaption></figure><p id="81cc" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">Redis客户机对象是从<code class="fe on oo op of b">config</code>对象导入和解包的。表单字段值是从请求正文中解析出来的。<code class="fe on oo op of b"><strong class="lr io">bcrypt</strong></code>和<code class="fe on oo op of b"><strong class="lr io">crypto</strong></code>分别用于散列密码和生成用户ID。要添加用户，我们创建一个事务，然后将以下命令排队:</p><ul class=""><li id="3874" class="lp lq in lr b ls ns lu nt lc oa lg ob lk oc lz ma mb mc md bi translated"><code class="fe on oo op of b">SET</code> <strong class="lr io">👉🏾</strong>设置一个键来保存作为第二个参数提供的字符串值。</li><li id="fae9" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><code class="fe on oo op of b">LPUSH</code> <strong class="lr io">👉🏾</strong>在<code class="fe on oo op of b">user:userList</code>前添加用户ID。</li><li id="a3bd" class="lp lq in lr b ls me lu mf lc mg lg mh lk mi lz ma mb mc md bi translated"><code class="fe on oo op of b">GET</code> <strong class="lr io">👉🏾</strong>返回一个键值</li></ul><p id="f419" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">用<code class="fe on oo op of b">EXEC</code>处理命令，并从响应中提取结果。我们可以在RedisInsight中查看注册用户。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/7567e8e8705b313cbac33a38b1bc85cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2A6dqjtDIjkxffMd.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">User in RedisInsight</figcaption></figure><p id="33cb" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">为了显示注册用户的列表，当一个<code class="fe on oo op of b">GET</code>请求被发送到<code class="fe on oo op of b"><em class="nr">/users</em></code> <em class="nr">时，从Redis中检索用户数据。</em>编辑<code class="fe on oo op of b">routes/users.js</code>中的路线。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/users.js</strong><code class="fe on oo op of b"><strong class="ak"> </strong></code><strong class="ak">👉🏾 </strong>Get users’ list</figcaption></figure><p id="8867" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">与检索所有项目类似，用户id列表是用<code class="fe on oo op of b">LRANGE</code>获得的。执行一个事务，该事务带有针对列表中每个用户ID键的<code class="fe on oo op of b">GET</code>命令。从响应中解析用户，并呈现在<code class="fe on oo op of b">users</code>视图中。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="a604" class="mq ku in bd kv mr ms mt ky mu mv mw lb jt mx ju lf jw my jx lj jz mz ka ln na bi translated">会话管理</h1><p id="bad8" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">由于会话数据仍存储在<code class="fe on oo op of b">MemoryStore</code>中，应用程序无法同时支持多个用户会话，并且该数据仅在该会话期间有效。使用与<code class="fe on oo op of b">express-session</code>兼容的外部存储器应该允许持久存储和多个会话。</p><p id="becb" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated"><code class="fe on oo op of b"><strong class="lr io">connect-redis</strong></code>使用现有Redis客户端为Express应用程序提供外部会话存储。我们用作为参数传递的<code class="fe on oo op of b">session</code>中间件创建一个<code class="fe on oo op of b">connect-redis</code>实例。Redis客户机然后被传递给<code class="fe on oo op of b">session</code>中间件。</p><p id="798b" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">需要<code class="fe on oo op of b">app.js</code>里面的<code class="fe on oo op of b">connect-redis</code>，编辑<code class="fe on oo op of b">middlewares</code>数组中的<code class="fe on oo op of b">session</code>条目。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./app.js 👉🏾 </strong>Transfer session storage to Redis.</figcaption></figure><p id="1753" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">重新启动服务器，会话数据现在以JSON字符串的形式保存在Redis的键-值对中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/78cebd6f296f99f6328023c3b3928b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pu6CHZXyGq2qvwbO.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Session data saved in Redis.</figcaption></figure><h2 id="28ab" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">存储会话数据</h2><p id="ac11" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">用户数据也将作为会话数据的一部分存储。为了简单起见，我们将通过单击用户表中的用户来模拟用户登录。所选用户的ID存储为会话变量，匹配的用户数据从Redis的中间件函数中检索。当前登录的用户数据通过<code class="fe on oo op of b">res.locals</code>在整个应用程序中可用。</p><p id="9d05" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">我们将在<code class="fe on oo op of b">routes/users.js</code>中的用户创建路径下定义登录用户的路径。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/users.js 👉🏾 </strong>Login a user route.</figcaption></figure><p id="0d5b" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">让我们在<code class="fe on oo op of b">app.js</code>中实现用户抓取。将以下内容添加到中间件函数中，我们在其中设置了flash消息传递和初始的<code class="fe on oo op of b">cartCount</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./app.js 👉🏾 </strong>Middleware to fetch current user on select.</figcaption></figure><p id="32e5" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">我们现在应该能够在用户之间切换了。在本教程开始时，当启用会话中间件时，cookie的<code class="fe on oo op of b">maxAge</code>属性被设置为1小时，之后Redis中的会话密钥<code class="fe on oo op of b">TTL</code>也被设置为相同的时间，之后会话过期，用户被注销。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h2 id="27c8" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">保存购物车</h2><p id="b5ff" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">让我们让已登录的用户能够进行购买。通过编辑<code class="fe on oo op of b">routes/index.js</code>中的路线，启用<strong class="lr io">立即购买</strong>功能。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/index.js 👉🏾 </strong>Create and save user’s cart in Redis.</figcaption></figure><p id="c6e6" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">如果用户没有登录或者查询到不存在的项目，他们将被重定向到主页。从<code class="fe on oo op of b">res.locals</code>对象中检索当前用户的ID。它将被用作购物车钥匙的一部分。项目ID是URL中的路由参数。</p><p id="a5b9" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">购物车数据保存为一个散列，以<code class="fe on oo op of b">cart:userID</code>为关键字，每个<code class="fe on oo op of b">item:itemID</code>为字段，商品数量为值。Redis' <code class="fe on oo op of b">HINCRBY</code>命令接受3个参数、键、一个字段和该字段的增量值。如果该键不存在，则用默认值<code class="fe on oo op of b">0</code>创建。</p><p id="7e41" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">购物车中的商品保存在Redis中，但是这不会反映在前端。为此，我们将从用户的购物车中获取商品id并合计它们的值，然后在初始化它的中间件函数中更新<code class="fe on oo op of b">res.locals.cartCount</code>。在<code class="fe on oo op of b"><em class="nr">/users/:userId/cart</em></code>路线中，我们将从Redis获取实际的商品进行显示。</p><p id="c3c0" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">将以下内容添加到<code class="fe on oo op of b">if (req.session.userId)</code>模块内<code class="fe on oo op of b">app.js</code>的中间件功能中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./app.js 👉🏾 </strong>Tally the items in a user’s cart.</figcaption></figure><p id="db9d" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">让我们编辑<code class="fe on oo op of b">routes/users.js</code>中的<code class="fe on oo op of b"><em class="nr">/users/:userId/cart</em></code> <em class="nr"> </em>路线<em class="nr"> </em>以获得实际项目。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/users.js</strong> <strong class="ak">👉🏾 </strong>Retrieve the cart items.</figcaption></figure><p id="1ad3" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">用户ID是从route参数中解析出来的，我们检查当前用户是否可以访问该购物车。我们遍历<code class="fe on oo op of b">res.locals.cartData</code>数组，获取相关的商品信息，以及购物车中的商品数量，并将这些数据放入<code class="fe on oo op of b">cartData</code>数组。总价也被计算出来并呈现给<code class="fe on oo op of b">cart</code>视图。购物车数据可以在RedisInsight中查看。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/cc090d549f95cccba52d012c6b15fe8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*48BKc4KghLtcQQFY.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Cart view.</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/de9db8f5b79d25d4c8cd06d3d37e19d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JvVUtEKUYewfkcKD.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Cart data in Redis.</figcaption></figure></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="4e9f" class="mq ku in bd kv mr ms mt ky mu mv mw lb jt mx ju lf jw my jx lj jz mz ka ln na bi translated">定义剩余的路线</h1><h2 id="6fae" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">添加和删除购物车商品</h2><p id="b476" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">让我们为购物车中的<code class="fe on oo op of b">➕️</code>和<code class="fe on oo op of b">➖️</code>按钮添加功能。编辑<code class="fe on oo op of b">routes/users.js</code>内的路线。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/users.js</strong> <strong class="ak">👉🏾 </strong>Add &amp; Remove items from the cart.</figcaption></figure><p id="9cbd" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">从URL解析用户ID和项目ID路由参数，并且存储在关键字<code class="fe on oo op of b">cart:userId</code>处的散列中的字段<code class="fe on oo op of b">itemId</code>的值增加或减少。使用与第一次将<a class="ae ks" href="#a5b9" rel="noopener ugc nofollow">物品添加到</a>购物车时相同的命令— <code class="fe on oo op of b">HINCRBY</code>。Redis命令用于增加和减少值是相同的，除了最后一个参数——字段递增的值；<code class="fe on oo op of b">1</code>增加，<code class="fe on oo op of b">-1</code>减少。我们现在应该能够在购物车中添加和删除商品了。</p><p id="2469" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">然而，在减少项目计数时，数量可以减少到<code class="fe on oo op of b">0</code>及以下。Redis不知道购物车商品应该只能是正整数。我们将在会话中间件中处理这个问题，在检索购物车中的商品id列表后，如果一个<code class="fe on oo op of b">itemId</code>字段的值小于1，我们将使用<code class="fe on oo op of b">HDEL</code>命令从购物车中删除它，该命令从存储在指定键的散列中删除一个字段。编辑<code class="fe on oo op of b">app.js</code>中的中间件功能。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./app.js</strong> <strong class="ak">👉🏾 </strong>Limit cart item counts to positive integers.</figcaption></figure><h2 id="b3ab" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">处理购物车</h2><p id="9f0a" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">我们可以继续模拟真实购物车中会发生什么。如果购买完成，订单数据可能会被发送到一个更健壮的数据库。无论是完成还是取消订单，购物车都是空的。在<code class="fe on oo op of b">routes/users.js</code>中编辑以下路线。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/users.js</strong> <strong class="ak">👉🏾 </strong>Empty the cart.</figcaption></figure><p id="f9c9" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated"><code class="fe on oo op of b">DEL</code>命令用于清空购物车。它从存储区中移除指定的密钥。</p><h2 id="d1fe" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">删除用户</h2><p id="5152" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">最后，让我们启用<strong class="lr io">管理用户</strong>页面中的<code class="fe on oo op of b">🗑</code>按钮。在<code class="fe on oo op of b">routes/index.js</code>中编辑删除用户路由。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><strong class="ak">./routes/users.js</strong> <strong class="ak">👉🏾 </strong>Delete user.</figcaption></figure><p id="6a31" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">我们创建一个事务，并在执行删除命令之前对其进行排队。<code class="fe on oo op of b">DEL</code>命令接受一个键列表来删除用户的购物车和数据。使用<code class="fe on oo op of b">LREM</code>命令从<code class="fe on oo op of b">user:userList</code>中删除用户ID，该命令接受3个参数、列表的键、计数(要删除的出现次数)和要从列表中删除的元素。当count设置为<code class="fe on oo op of b">0</code>时，该元素的所有出现都将从列表中删除。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="797d" class="mq ku in bd kv mr ms mt ky mu mv mw lb jt mx ju lf jw my jx lj jz mz ka ln na bi translated">结论</h1><p id="5a23" class="pw-post-body-paragraph nb nc in lr b ls lt jo nd lu lv jr ne lc nf ng nh lg ni nj nk lk nl nm nn lz ig bi translated">Redis是一个多功能的存储服务器，有许多使用案例。它在缓存技术领域大放异彩，显著提高了应用程序的性能。不同的数据结构为保存和查询数据提供了强大的方法，这是普通的键值缓存无法实现的。</p><p id="e6b8" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">本文的目的并不是建议将Redis作为数据库的TVA它确实有局限性。虽然我们也使用Redis文档数据库，但它缺乏内置加密；没有基于角色的帐户控制；并且在大规模云部署中进行部署可能会很困难。此外，牺牲更好的性能是增加内存使用，使用的内存存储几乎是相同数据在磁盘上占用的两倍。</p><p id="4795" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated">希望这是Redis的一个有用的入门。谢谢你坚持到最后。欢迎在评论中提出建议和改进。快乐黑客👍🏾️.</p><p id="06d8" class="pw-post-body-paragraph nb nc in lr b ls ns jo nd lu nt jr ne lc nv ng nh lg nx nj nk lk nz nm nn lz ig bi translated"><em class="nr">更多内容请看</em><a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lr io"><em class="nr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>