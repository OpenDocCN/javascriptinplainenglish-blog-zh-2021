<html>
<head>
<title>The Comprehensive Guide to React’s Virtual DOM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React虚拟DOM综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-the-virtual-dom-comprehensive-guide-acd19c5e327a?source=collection_archive---------4-----------------------#2021-05-15">https://javascript.plainenglish.io/react-the-virtual-dom-comprehensive-guide-acd19c5e327a?source=collection_archive---------4-----------------------#2021-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="297b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">对抗浪费的DOM操作、协调和差分算法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3715a0c827661173943c1bf48671e85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyoU7X-SMyT8xQD1PjrRGw.png"/></div></div></figure><h1 id="58f0" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">真正的DOM</h1><p id="71d0" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">首先，DOM代表“<strong class="li io">文档对象模型</strong>”。用简单的话来说，DOM代表了应用程序的UI。每当应用程序UI的状态发生变化时，DOM就会更新以反映这种变化。现在的问题是频繁地操纵DOM会影响性能，使它变慢。</p><h1 id="2bae" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">是什么让DOM操作变得缓慢？</h1><p id="101c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">DOM被表示为一个树形数据结构。因此，对DOM的更改和更新非常快。但是在更改之后，更新的元素及其子元素必须重新呈现以更新应用程序UI。UI的重新渲染或重新绘制是它变慢的原因。因此，UI组件越多，DOM更新就越昂贵，因为每次DOM更新都需要重新渲染。</p><p id="6249" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">DOM操作是现代交互式网络的核心。不幸的是，它也比大多数JavaScript操作慢很多。大多数JavaScript框架更新DOM的次数比它们必须更新的次数多得多，这一事实使得这种缓慢变得更糟糕。</p><p id="f36a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">举个例子，假设你有一个包含十个条目的列表。你核对第一项。大多数JavaScript框架会重建<em class="mh">整个列表</em>。这比必要的工作量多了十倍！只有一个项目发生了变化，但其余九个项目完全按照之前的方式重建。</p><p id="573f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">重建列表对web浏览器来说没什么大不了的，但是现代网站可以使用大量的DOM操作。低效更新已经成为一个严重的问题。为了解决这个问题，React的人们推广了一种叫做虚拟DOM的东西。</p><h1 id="29ff" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">虚拟世界</h1><p id="4762" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在React中，对于每个DOM对象，都有一个对应的“虚拟DOM对象”。虚拟DOM对象是DOM对象的一个<em class="mh">表示</em>，就像一个轻量级副本。虚拟DOM对象具有与真实DOM对象相同的属性，但是它缺乏真实对象直接改变屏幕内容的能力。</p><blockquote class="mi"><p id="c5a9" class="mj mk in bd ml mm mn mo mp mq mr mb dk translated">虚拟DOM (VDOM)是一个编程概念，其中UI的理想或“虚拟”表示保存在内存中，并通过ReactDOM等库与“真实”DOM同步。这个过程叫做<a class="ae ms" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">对账</a>。</p></blockquote><p id="a215" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">操作DOM很慢。操纵虚拟DOM要快得多，因为屏幕上不会绘制任何东西。把操纵虚拟DOM想象成编辑蓝图，而不是在实际的房子里移动房间。</p><h2 id="d8a3" class="my kp in bd kq mz na dn ku nb nc dp ky lp nd ne la lt nf ng lc lx nh ni le nj bi translated">虚拟DOM如何更快？</h2><p id="a8b5" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">当新元素被添加到UI时，一个虚拟DOM被创建，它被表示为一棵树。每个元素都是这个树上的一个节点。如果这些元素的状态发生变化，就会创建一个新的虚拟DOM树。然后将该树与先前的虚拟DOM树进行比较或“区别”。</p><p id="cd52" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">一旦完成，虚拟DOM就会计算出对真实DOM进行这些更改的最佳方法。这确保了对真实DOM的操作最少。因此，降低了更新真实DOM的性能成本。</p><p id="9556" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">下图显示了虚拟DOM树和区分过程。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/c1ac65c1ab59e8dfe3ff74be28c6d2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ps8GIxbQspLkXXDC"/></div></div></figure><p id="a0cd" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">红色圆圈代表发生变化的节点。这些节点表示状态已经改变的UI元素。然后计算虚拟DOM树的先前版本和当前虚拟DOM树之间的差异。然后重新呈现整个父子树，以给出更新后的UI。然后，这个更新的树被批量更新到真正的DOM。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c56f6c8df1992484e33724e7e21630fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*InX4By1HRVlNV2qqAMXtMA.jpeg"/></div></figure><h1 id="983f" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">React如何使用虚拟DOM？</h1><p id="f951" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在，您已经对什么是虚拟DOM，以及它如何帮助您的应用程序的性能有了相当的了解，让我们来看看React如何利用虚拟DOM。</p><h2 id="9174" class="my kp in bd kq mz na dn ku nb nc dp ky lp nd ne la lt nf ng lc lx nh ni le nj bi translated"><strong class="ak"> 1。React遵循可观察的模式并监听状态变化。</strong></h2><p id="78ed" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在React中，每个UI都是一个组件，每个组件都有一个状态。当组件的状态改变时，React更新虚拟DOM树。一旦更新了虚拟DOM，React就会将虚拟DOM的当前版本与虚拟DOM的先前版本进行比较。这个过程叫做<strong class="li io">区分</strong>。</p><p id="b45f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">一旦React知道哪些虚拟DOM对象已经改变，那么React只更新真实DOM中的那些对象。与直接操作真正的DOM相比，这使得性能大大提高。这使得React作为一个高性能的JavaScript库脱颖而出。</p><h2 id="b984" class="my kp in bd kq mz na dn ku nb nc dp ky lp nd ne la lt nf ng lc lx nh ni le nj bi translated"><strong class="ak"> 2。React遵循批量更新机制来更新真实的DOM </strong>。</h2><p id="b628" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">因此，导致性能提高。这意味着对真实DOM的更新是成批发送的，而不是每次状态改变都发送更新。</p><p id="f22e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">UI的重绘是最昂贵的部分，React高效地确保了真正的DOM只接收批量更新来重绘UI。</p><h2 id="ed4f" class="my kp in bd kq mz na dn ku nb nc dp ky lp nd ne la lt nf ng lc lx nh ni le nj bi translated">3.React遵循e <strong class="ak">效率</strong>差分算法</h2><p id="a000" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React基于两个假设实现启发式O(n)算法:</p><ol class=""><li id="1bf0" class="nm nn in li b lj mc lm md lp no lt np lx nq mb nr ns nt nu bi translated">两种不同类型的元素会产生不同的树。</li><li id="a95f" class="nm nn in li b lj nv lm nw lp nx lt ny lx nz mb nr ns nt nu bi translated">开发者可以用一个<code class="fe oa ob oc od b">key</code>道具提示哪些子元素在不同的渲染中是稳定的。</li></ol><p id="c380" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在实践中，这些假设对于几乎所有实际用例都是有效的。</p><p id="7beb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当区分两棵树时，React首先比较两个根元素。根据根元素的类型，行为会有所不同。</p><p id="c36c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io">不同类型的元素</strong></p><ul class=""><li id="dcf1" class="nm nn in li b lj mc lm md lp no lt np lx nq mb oe ns nt nu bi translated">每当根元素具有不同的类型时，React将拆除旧树并从头开始构建新树。</li><li id="811f" class="nm nn in li b lj nv lm nw lp nx lt ny lx nz mb oe ns nt nu bi translated">当拆除一棵树时，旧的DOM节点被破坏。组件实例接收<code class="fe oa ob oc od b">componentWillUnmount()</code>。当构建新的树时，新的DOM节点被插入到DOM中。组件实例接收<code class="fe oa ob oc od b">UNSAFE_componentWillMount()</code>，然后接收<code class="fe oa ob oc od b">componentDidMount()</code>。与旧树相关联的任何状态都将丢失。</li><li id="ba18" class="nm nn in li b lj nv lm nw lp nx lt ny lx nz mb oe ns nt nu bi translated">根目录下的任何组件也将被卸载，其状态将被销毁。例如，在区分时:</li></ul><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="275f" class="my kp in od b gy oj ok l ol om">&lt;div&gt;<br/>  &lt;Counter /&gt;<br/>&lt;/div&gt;<br/><br/>&lt;span&gt;<br/>  &lt;Counter /&gt;<br/>&lt;/span&gt;</span></pre><p id="3480" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这将摧毁旧的<code class="fe oa ob oc od b">Counter</code>并重新安装一个新的。</p><p id="e743" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io">相同类型的元素</strong></p><p id="6f64" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当比较两个相同类型的React DOM元素时，React会查看两者的属性，保持相同的底层DOM节点，并且只更新已更改的属性。例如:</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="7d8e" class="my kp in od b gy oj ok l ol om">&lt;div className="before" title="stuff" /&gt;</span><span id="8aee" class="my kp in od b gy on ok l ol om">&lt;div className="after" title="stuff" /&gt;</span></pre><p id="dca8" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">通过比较这两个元素，React知道只修改底层DOM节点上的<code class="fe oa ob oc od b">className</code>。</p><p id="0cc1" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当更新<code class="fe oa ob oc od b">style</code>时，React也知道只更新改变的属性。例如:</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="c081" class="my kp in od b gy oj ok l ol om">&lt;div style={{color: 'red', fontWeight: 'bold'}} /&gt;</span><span id="1285" class="my kp in od b gy on ok l ol om">&lt;div style={{color: 'green', fontWeight: 'bold'}} /&gt;</span></pre><p id="ddbd" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在这两个元素之间转换时，React知道只修改<code class="fe oa ob oc od b">color</code>样式，而不修改<code class="fe oa ob oc od b">fontWeight</code>。</p><p id="185e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">处理完DOM节点后，React然后在子节点上递归。</p><p id="79ec" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io">递归在子节点上<br/> </strong>默认情况下，当递归在一个DOM节点的子节点上时，React只是同时迭代两个子节点列表，并在有差异时生成一个变异。</p><p id="658e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">例如，当在子元素的末尾添加元素时，在这两棵树之间进行转换效果很好:</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="c428" class="my kp in od b gy oj ok l ol om">&lt;ul&gt;<br/>  &lt;li&gt;first&lt;/li&gt;<br/>  &lt;li&gt;second&lt;/li&gt;<br/>&lt;/ul&gt;</span><span id="d89d" class="my kp in od b gy on ok l ol om">&lt;ul&gt;<br/>  &lt;li&gt;first&lt;/li&gt;<br/>  &lt;li&gt;second&lt;/li&gt;<br/>  &lt;li&gt;third&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="bf2b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">React会匹配两个<code class="fe oa ob oc od b">&lt;li&gt;first&lt;/li&gt;</code>树，匹配两个<code class="fe oa ob oc od b">&lt;li&gt;second&lt;/li&gt;</code>树，然后插入<code class="fe oa ob oc od b">&lt;li&gt;third&lt;/li&gt;</code>树。</p><p id="ea17" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果你天真地实现它，在开头插入一个元素会有更差的性能。例如，这两棵树之间的转换效果很差:</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="5997" class="my kp in od b gy oj ok l ol om">&lt;ul&gt;<br/>  &lt;li&gt;Duke&lt;/li&gt;<br/>  &lt;li&gt;Villanova&lt;/li&gt;<br/>&lt;/ul&gt;</span><span id="902a" class="my kp in od b gy on ok l ol om">&lt;ul&gt;<br/>  &lt;li&gt;Connecticut&lt;/li&gt;<br/>  &lt;li&gt;Duke&lt;/li&gt;<br/>  &lt;li&gt;Villanova&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="f63a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">React将变异每个子树，而不是意识到它可以保持<code class="fe oa ob oc od b">&lt;li&gt;Duke&lt;/li&gt;</code>和<code class="fe oa ob oc od b">&lt;li&gt;Villanova&lt;/li&gt;</code>子树完整。这种低效率可能是一个问题。</p><p id="b439" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io">使用<br/>键</strong>为了解决这个问题，React支持一个<code class="fe oa ob oc od b">key</code>属性。当子树有键时，React使用键来匹配原始树中的子树和后续树中的子树。例如，在上面低效的例子中添加一个<code class="fe oa ob oc od b">key</code>可以提高树转换的效率:</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="a5ed" class="my kp in od b gy oj ok l ol om">&lt;ul&gt;<br/>  &lt;li key="2015"&gt;Duke&lt;/li&gt;<br/>  &lt;li key="2016"&gt;Villanova&lt;/li&gt;<br/>&lt;/ul&gt;</span><span id="5bfb" class="my kp in od b gy on ok l ol om">&lt;ul&gt;<br/>  &lt;li key="2014"&gt;Connecticut&lt;/li&gt;<br/>  &lt;li key="2015"&gt;Duke&lt;/li&gt;<br/>  &lt;li key="2016"&gt;Villanova&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="bbea" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在React知道带有键<code class="fe oa ob oc od b">'2014'</code>的元素是新的元素，带有键<code class="fe oa ob oc od b">'2015'</code>和<code class="fe oa ob oc od b">'2016'</code>的元素刚刚移动了。</p><p id="4c8a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">实际上，找到一把钥匙通常并不难。您将要显示的元素可能已经有了一个惟一的ID，所以键可能只是来自您的数据:</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="b254" class="my kp in od b gy oj ok l ol om">&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;</span></pre><p id="d587" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果不是这样，您可以向您的模型添加一个新的ID属性，或者散列内容的某些部分来生成一个键。该键只需在其同级中是唯一的，而不是全局唯一的。</p><p id="56a4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">最后，您可以将数组中某项的索引作为键传递。如果商品从来没有重新订购过，这种方法可以很好地工作，但是重新订购会很慢。</p><p id="01cf" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当索引用作键时，重新排序还会导致组件状态出现问题。组件实例基于它们的键被更新和重用。如果键是一个索引，移动一个项会改变它。因此，像不受控制的输入这样的东西的组件状态可能会以意想不到的方式混淆和更新。</p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><p id="000a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">简单来说:<em class="mh">“你告诉React你希望UI处于什么状态，它确保DOM匹配那个状态。最大的好处是，作为开发人员，您不需要知道如何在幕后进行属性操作、事件处理或手动DOM更新。”</em></p><p id="e955" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">所有这些细节都是从React开发者那里抽象出来的。您所需要做的就是在需要时更新组件的状态，其余的由React负责。这确保了使用React时卓越的开发人员体验。</p><p id="b788" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">由于“虚拟DOM”更多的是一种模式，而不是一种特定的技术，人们有时会说它有不同的含义。在React world中，术语“虚拟DOM”通常与React元素相关联，因为它们是表示用户界面的对象。然而，React也使用称为“纤程”的内部对象来保存关于组件树的附加信息。它们也可以被认为是React中“虚拟DOM”实现的一部分。纤程是React 16中新的协调引擎。它的主要目标是支持虚拟DOM的增量呈现。</p><h1 id="eeb7" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">虚拟DOM看起来像什么？</h1><p id="907a" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">“虚拟DOM”这个名字倾向于增加这个概念实际上是什么的神秘性。事实上，虚拟DOM只是一个普通的Javascript对象。</p><p id="d99d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">让我们重温一下我们之前创建的DOM树:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/68f596b9e27b6bede509a0ae1a3b69ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*hAG5o2zjqb2QEEtMc8awWA.png"/></div></figure><p id="dcb6" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这个树也可以表示为一个Javascript对象。</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="a6a5" class="my kp in od b gy oj ok l ol om">const vdom = {<br/>    tagName: "html",<br/>    children: [<br/>        { tagName: "head" },<br/>        {<br/>            tagName: "body",<br/>            children: [<br/>                {<br/>                    tagName: "ul",<br/>                    attributes: { "class": "list" },<br/>                    children: [<br/>                        {<br/>                            tagName: "li",<br/>                            attributes: { "class": "list__item" },<br/>                            textContent: "List item"<br/>                        } // end li<br/>                    ]<br/>                } // end ul<br/>            ]<br/>        } // end body<br/>    ]<br/>} // end html</span></pre><p id="70d1" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们可以把这个对象想象成我们的虚拟DOM。像最初的DOM一样，它是我们的HTML文档的基于对象的表示。但是因为它是一个普通的Javascript对象，所以我们可以自由地、频繁地操作它，而不需要接触实际的DOM，直到我们需要的时候。</p><p id="2329" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">更常见的是使用虚拟DOM的小部分，而不是对整个对象使用一个对象。例如，我们可以处理一个<code class="fe oa ob oc od b">list</code>组件，它对应于我们的无序列表元素。</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="b872" class="my kp in od b gy oj ok l ol om">const list = {<br/>    tagName: "ul",<br/>    attributes: { "class": "list" },<br/>    children: [<br/>        {<br/>            tagName: "li",<br/>            attributes: { "class": "list__item" },<br/>            textContent: "List item"<br/>        }<br/>    ]<br/>};</span></pre><h2 id="13ef" class="my kp in bd kq mz na dn ku nb nc dp ky lp nd ne la lt nf ng lc lx nh ni le nj bi translated">在虚拟世界的掩护下</h2><p id="927e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">既然我们已经看到了虚拟DOM的样子，那么它是如何解决DOM的性能和可用性问题的呢？</p><p id="18dc" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">正如我提到的，我们可以使用虚拟DOM挑选出需要对DOM进行的特定更改，并单独进行这些特定的更新。让我们回到无序列表的例子，进行和使用DOM API一样的修改。</p><p id="d42e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们要做的第一件事是复制虚拟DOM，包含我们想要做的更改。因为我们不需要使用DOM APIs，所以我们实际上可以创建一个新的对象。</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="aea0" class="my kp in od b gy oj ok l ol om">const copy = {<br/>    tagName: "ul",<br/>    attributes: { "class": "list" },<br/>    children: [<br/>        {<br/>            tagName: "li",<br/>            attributes: { "class": "list__item" },<br/>            textContent: "List item one"<br/>        },<br/>        {<br/>            tagName: "li",<br/>            attributes: { "class": "list__item" },<br/>            textContent: "List item two"<br/>        }<br/>    ]<br/>};</span><span id="ad07" class="my kp in od b gy on ok l ol om">const copy = {<br/>    tagName: "ul",<br/>    attributes: { "class": "list" },<br/>    children: [<br/>        {<br/>            tagName: "li",<br/>            attributes: { "class": "list__item" },<br/>            textContent: "List item one"<br/>        },<br/>        {<br/>            tagName: "li",<br/>            attributes: { "class": "list__item" },<br/>            textContent: "List item two"<br/>        }<br/>    ]<br/>};</span></pre><p id="9290" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这个<code class="fe oa ob oc od b">copy</code>用于创建原始虚拟DOM(在本例中为<code class="fe oa ob oc od b">list</code>)和更新后的虚拟DOM之间的“差异”。差异可能如下所示:</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="a32e" class="my kp in od b gy oj ok l ol om">const diffs = [<br/>    {<br/>        newNode: { /* new version of list item one */ },<br/>        oldNode: { /* original version of list item one */ },<br/>        index:/* index of element in parent's list of child nodes */<br/>    },<br/>    {<br/>        newNode: { /* list item two */ },<br/>        index: { /* */ }<br/>    }<br/>]</span></pre><p id="f336" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这个diff提供了如何更新实际DOM的说明。一旦收集了所有的差异，我们就可以批量修改DOM，只做需要的更新。</p><p id="7ebc" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">例如，我们可以遍历每个diff，并根据diff指定的内容添加一个新子元素或更新一个旧元素。</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="1500" class="my kp in od b gy oj ok l ol om">const domElement = document.getElementsByClassName("list")[0];</span><span id="d460" class="my kp in od b gy on ok l ol om">diffs.forEach((diff) =&gt; {</span><span id="3155" class="my kp in od b gy on ok l ol om">    const newElement = document.createElement(diff.newNode.tagName);<br/>    /* Add attributes ... */<br/>    <br/>    if (diff.oldNode) {<br/>        // If there is an old version, replace it with the new version<br/>        domElement.replaceChild(diff.newNode, diff.index);<br/>    } else {<br/>        // If no old version exists, create a new node<br/>        domElement.appendChild(diff.newNode);<br/>    }<br/>})</span></pre><p id="3617" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">请注意，这是虚拟DOM如何工作的一个真正简化和精简的版本，有很多情况我没有在这里介绍。</p><h2 id="e2b0" class="my kp in bd kq mz na dn ku nb nc dp ky lp nd ne la lt nf ng lc lx nh ni le nj bi translated">虚拟DOM和框架</h2><p id="7e34" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">更常见的是通过框架使用虚拟DOM，而不是像我在上面的例子中展示的那样直接与它交互。</p><p id="725d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">React和Vue等框架使用虚拟DOM概念对DOM进行更高性能的更新。例如，我们的<code class="fe oa ob oc od b">list</code>组件可以用下面的方式在React中编写。</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="4d49" class="my kp in od b gy oj ok l ol om">import React from 'react';<br/>import ReactDOM from 'react-dom';</span><span id="30bf" class="my kp in od b gy on ok l ol om">const list = React.createElement("ul", { className: "list" },<br/>    React.createElement("li", { className: "list__item" }, "List item")<br/>);</span><span id="3280" class="my kp in od b gy on ok l ol om">ReactDOM.render(list, document.body);</span></pre><p id="91cd" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果我们想更新我们的列表，我们可以重写整个列表模板，并再次调用<code class="fe oa ob oc od b">ReactDOM.render()</code>，传入新的列表。</p><pre class="kd ke kf kg gt of od og oh aw oi bi"><span id="3d85" class="my kp in od b gy oj ok l ol om">const newList = React.createElement("ul", { className: "list" },<br/>    React.createElement("li", { className: "list__item" }, "List item one"),<br/>    React.createElement("li", { className: "list__item" }, "List item two");<br/>);</span><span id="fdad" class="my kp in od b gy on ok l ol om">setTimeout(() =&gt; ReactDOM.render(newList, document.body), 5000);</span></pre><p id="7f99" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因为React使用虚拟DOM，所以即使我们重新呈现整个模板，也只更新实际发生变化的部分。如果我们在变更发生时查看我们的开发人员工具，我们将看到变更的特定元素和元素的特定部分。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/e8e5f93ee485727f3207227eea491c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yrzOyqu5rlbOaETmOOwTcQ.gif"/></div></div></figure><h1 id="c3fc" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">结论</h1><p id="e428" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">虚拟DOM肯定会存在一段时间。它提供了一种很好的方法来将应用程序的逻辑从DOM元素中分离出来，从而减少了在DOM操作中产生意外瓶颈的可能性。其他库也在用同样的方法前进，进一步巩固了作为web应用程序首选策略之一的概念。</p><p id="bd42" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">被称为<code class="fe oa ob oc od b">Dirty Model Checking</code>的<code class="fe oa ob oc od b">Angular</code>所使用的方法，可以说是普及了SPAs(单页应用)概念的框架。值得一提的是，<code class="fe oa ob oc od b">dirty model checking</code>和<code class="fe oa ob oc od b">virtual DOM</code>是<em class="mh">而不是</em>互斥。它们都是针对同一个问题的解决方案，但处理方式不同。一个<code class="fe oa ob oc od b">MVC</code>框架可以很好地实现这两种技术。在React的例子中，它只是没有多大意义——React毕竟主要是一个<code class="fe oa ob oc od b">View</code>库。</p><p id="ba23" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">希望这能让你对“虚拟DOM”感觉舒服一点。</p><p id="178f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">感谢您的阅读。</p><p id="7861" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><em class="mh">更多内容请看</em><a class="ae ms" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="mh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>