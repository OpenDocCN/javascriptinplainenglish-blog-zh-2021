<html>
<head>
<title>React Fragments: What and Why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应片段:什么和为什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-fragments-what-and-why-bee7afa1e0ff?source=collection_archive---------18-----------------------#2021-07-16">https://javascript.plainenglish.io/react-fragments-what-and-why-bee7afa1e0ff?source=collection_archive---------18-----------------------#2021-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a5054c69ed3d776de842fcb6c5e56587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y0DblgrEgGEGFRZ4.jpg"/></div></div></figure><p id="9063" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React片段是React 16.2中发布的一个特性。它们已经存在了一段时间，但相对来说使用较少。让我们来探讨一下这个特性存在的原因。</p><h1 id="c49d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是反应碎片？</h1><p id="6c09" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">React片段是React的一个语法补充，它允许包装或分组多个HTML元素，而不需要任何额外的DOM节点。当一个React组件需要返回多个元素时，我们通常会遇到这种情况。</p><p id="90f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">传统的方法是将它们包装在div元素中，因为React组件只能返回一个元素。这种行为会导致无用的额外标记，还会增加div层，使DOM树变得沉重。</p><p id="9793" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在单个组件中呈现3个子组件的传统解决方案是:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7603" class="mf ku in mb b gy mg mh l mi mj">const App = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ChildA /&gt;<br/>      &lt;ChildB /&gt;<br/>      &lt;ChildC /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="741a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于片段，这可以是:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0e2f" class="mf ku in mb b gy mg mh l mi mj">const App = () =&gt; {<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;ChildA /&gt;<br/>      &lt;ChildB /&gt;<br/>      &lt;ChildC /&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>}</span></pre><p id="5c35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>反应过来。片段也可以用空标签代替，如&lt; &gt; &lt; / &gt;。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9070" class="mf ku in mb b gy mg mh l mi mj">const App = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;ChildA /&gt;<br/>      &lt;ChildB /&gt;<br/>      &lt;ChildC /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><h1 id="5dc0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么反应碎片？</h1><p id="04f4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">片段有3个典型的用例。</p><h1 id="50f2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">1.返回元素组</h1><p id="9f59" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是片段的典型用例。如上所述，使用片段避免了额外的div容器，这些容器会使DOM变得沉重，并且在设计样式时经常会引起问题。</p><h1 id="67e7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">2.条件渲染</h1><p id="210b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">片段使得有条件地呈现元素组变得更加容易，而不需要任何额外的标记。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c700" class="mf ku in mb b gy mg mh l mi mj">const Login = ({isLoggedIn, name}) =&gt; {<br/>    {isLoggedIn ? (<br/>        &lt;&gt;<br/>          &lt;h3&gt;Welcome {name}&lt;/h3&gt;<br/>          &lt;p&gt;<br/>            You are logged in!<br/>          &lt;/p&gt;<br/>        &lt;/&gt;<br/>      ) : (<br/>        &lt;&gt;<br/>          &lt;h3&gt;Login&lt;/h3&gt;<br/>              &lt;input type="text" id="username" /&gt;<br/>              &lt;input type="password" id="password" /&gt;<br/>              &lt;input type="submit" value="Login" /&gt;<br/>        &lt;/&gt;<br/>      )}<br/>}</span></pre><h1 id="fbf1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">3.使用键控片段渲染数组</h1><p id="c2ac" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">碎片可以有关键道具！这是另一个强大的功能，有时非常方便。但是这不能和空标签一起使用。</p><p id="5e55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这在呈现列表时很有帮助，例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="76be" class="mf ku in mb b gy mg mh l mi mj">const Glossary = ({items}) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      {items.map(item =&gt; (<br/>        // Without the `key`, React will fire a key warning<br/>        &lt;React.Fragment key={item.id}&gt;<br/>          &lt;dt&gt;{item.term}&lt;/dt&gt;<br/>          &lt;dd&gt;{item.description}&lt;/dd&gt;<br/>        &lt;/React.Fragment&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><h1 id="dea5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">优势</h1><ul class=""><li id="976d" class="mk ml in jx b jy lr kc ls kg mm kk mn ko mo ks mp mq mr ms bi translated">React片段速度更快，内存消耗更少(DOM节点更少)。这在具有深树结构的应用程序中很有帮助。</li><li id="1e8a" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">由于没有创建额外的div，样式有时会更容易。有时一些库依赖于父子关系，中间的div会导致布局问题。</li><li id="f7af" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">DOM更容易检查，因为它不那么杂乱。</li></ul><p id="8cf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是关于React fragments的所有信息！</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="1580" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nf">原载于2021年7月16日</em><a class="ae ng" href="https://www.wisdomgeek.com/development/web-development/react/react-fragments-what-and-why/" rel="noopener ugc nofollow" target="_blank"><em class="nf">【https://www.wisdomgeek.com】</em></a><em class="nf">。</em></p><p id="cbca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nf">更多内容请看</em><a class="ae ng" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nf">plain English . io</em></a><em class="nf">。报名参加我们的</em> <a class="ae ng" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">免费每周简讯</em> </a> <em class="nf">。在我们的</em> <a class="ae ng" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nf">社区不和谐</em> </a> <em class="nf">获取独家写作机会和建议。</em></p></div></div>    
</body>
</html>