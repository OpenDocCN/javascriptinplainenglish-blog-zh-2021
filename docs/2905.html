<html>
<head>
<title>Let’s Build a Continuous Delivery and Branching Process with Github Actions, Vercel and Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用Github Actions、Vercel和Heroku构建一个连续的交付和分支流程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-continuous-delivery-and-branching-process-with-github-actions-vercel-and-heroku-a7d9a803f4e2?source=collection_archive---------8-----------------------#2021-06-13">https://javascript.plainenglish.io/lets-build-a-continuous-delivery-and-branching-process-with-github-actions-vercel-and-heroku-a7d9a803f4e2?source=collection_archive---------8-----------------------#2021-06-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="86c1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">对于JavaScript应用程序(第二部分)</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/725790fdc88241be71130498ef69a81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tr3B5AmLhSQpsBl2PY2SyQ.jpeg"/></div></div></figure><p id="7eb3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本出版物是《用Github Actions、Vercel和Heroku为JavaScript应用程序构建持续交付+分支流程》的延续。1/2]  ，我们在这里为示例中使用的项目web堆栈的<strong class="kq io">连续交付</strong>建模了一个工作流。如果你没看过之前的帖子，建议你看一下。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="d6fb" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">总结和目标</h1><p id="182d" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">在前一篇文章中，我描述了这个策略的目标和动机。</p><p id="ddd9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将对贯穿项目分支活动的流程进行建模，在云中创建一个隔离且安全的预览。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/261936fe11ac26e8a048b58dfcffad20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYcM6j_TfXnLqS3brpNqBw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">1.0 — Detailed view of the branching strategy with production of cloud artifacts, initially published in the article before this one.</figcaption></figure><p id="520d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们添加了<strong class="kq io">部署步骤</strong>作业，根据我们当前工作的分支，用动态API URL设置<strong class="kq io">VUE _应用程序_应用程序接口</strong>环境变量。</p><p id="70a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们将通过在API中应用一个<strong class="kq io">部署步骤</strong>作业来完成整个工作流程，为托管在<strong class="kq io"> Heroku </strong>上的应用程序生成动态URL。</p><h1 id="3e82" class="ls lt in bd lu lv mu lx ly lz mv mb mc jt mw ju me jw mx jx mg jz my ka mi mj bi translated">将部署作业添加到Heroku</h1><p id="fa3d" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">和上一篇文章一样，我会把这个话题分成两部分。</p><p id="68dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我们将获得动作输入所需的秘密。</p><p id="f37b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将在<strong class="kq io">部署步骤</strong>中添加所需输入的秘密。随后，我们将声明动作将响应的分支，并构建动态URL。</p><p id="b30b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">点击下面的链接可以访问样本库:</p><div class="mz na gp gr nb nc"><a href="https://github.com/pedromoraisf/monoyarn" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">pedromoraisf/单线</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">结果做了EP 1 da série系列全栈-什么也没有了💫。维加·克里坎多·阿奎。o项目…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq km nc"/></div></div></a></div><h2 id="ac97" class="nr lt in bd lu ns nt dn ly nu nv dp mc kx nw nx me lb ny nz mg lf oa ob mi oc bi translated">搜索秘密并添加到Github秘密</h2><p id="25be" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">进入Heroku仪表盘 中的<a class="ae lk" href="https://dashboard.heroku.com/account/applications" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">应用设置地址，点击<strong class="kq io">“创建授权”</strong>生成授权令牌。有了它，该行动将有权处理我们帐户内的申请。</strong></a></p><p id="d0db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">之后，在<strong class="kq io"> Github </strong>上的<strong class="kq io">【设置】</strong>下的标签<strong class="kq io">【秘密】</strong>中添加新的秘密变量。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi od"><img src="../Images/cd43d319dda4e5afb35e34c96b4b333d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qk92CR4c2nW8QI0kh1J2rw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">2.0 — Variables added to Github Secrets.</figcaption></figure><p id="ad81" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们将新生成的令牌命名为<strong class="kq io"> HEROKU_API_KEY </strong>和<strong class="kq io"> HEROKU_EMAIL </strong>在我们的<strong class="kq io"> Heroku </strong>帐户中注册的电子邮件。</p><h2 id="0fd6" class="nr lt in bd lu ns nt dn ly nu nv dp mc kx nw nx me lb ny nz mg lf oa ob mi oc bi translated">将作业添加到工作流</h2><p id="50df" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">下面的工作流程可以在<strong class="kq io">的<em class="oe"> monorepo </em>根内的文件中找到。github/workflows/pipeline-server . yml</strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">3.0 — Workflow Server Github Actions.</figcaption></figure><p id="fb21" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从<strong class="kq io">线32 </strong>开始，是<strong class="kq io">部署-步骤</strong>工作。在这项工作中，我们将应用与动态URL生成和与网络工作流同步的<strong class="kq io">连续交付</strong>的脚本。</p><p id="2725" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在继续之前，尽管它列在参考资料中，但是负责<strong class="kq io"> Heroku </strong>集成任务的动作的链接就在下面。</p><div class="mz na gp gr nb nc"><a href="https://github.com/AkhileshNS/heroku-deploy" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">AkhileshNS/heroku-部署</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">这是一个非常简单的GitHub操作，允许您部署到Heroku。该操作通过运行以下内容来实现…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="oh l nn no np nl nq km nc"/></div></div></a></div><p id="40ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">和上一篇文章一样，我在<strong class="kq io">第34行</strong>中声明<strong class="kq io">部署步骤</strong>需要<strong class="kq io">测试程序</strong>成功完成才能开始。</p><p id="2901" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我再次使用<a class="ae lk" href="https://github.com/rlespinasse/github-slug-action" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">rlespinasse/Github-slug-action</strong></a>动作来创建由<strong class="kq io"> Github动作</strong>在上下文中提供的环境变量的slug版本。</p><p id="bbb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io">第42行</strong>的中，我将刚刚保存的秘密添加到强制输入<strong class="kq io">“heroku _ API _ key”</strong>和<strong class="kq io">“heroku _ email”</strong>中。</p><p id="c404" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io">“分支”</strong>输入的<strong class="kq io">行46 </strong>中，我声明工件将从哪个分支生成。为此，我使用了<strong class="kq io"> Github Actions </strong>提供的上下文<strong class="kq io"> "github.ref" </strong>。</p><p id="2bc8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">魔法发生在<strong class="kq io"> "heroku_app_name" </strong>第<strong class="kq io">行第44 </strong>行。我声明动态API URL的方式与我在上一篇文章中在<strong class="kq io">VUE _应用程序_API </strong>中创建环境变量的方式相同，充实了策略。</p><p id="96e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">简而言之，每次我们<strong class="kq io">分支</strong>出来开发，<a class="ae lk" href="https://github.com/rlespinasse/github-slug-action" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">rlespinasse/github-slug-action</strong></a>action都会提供它的slug版本。最后，将使用该地址创建或更新适当的<strong class="kq io"> Heroku </strong>应用程序。</p><p id="cc1c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:如果分支名称是<strong class="kq io"> feat/cd </strong>，那么生成的URL将是<strong class="kq io">https://pedromoraisf-monoyarn-feat-cd.herokuapp.com</strong>。</p><h1 id="08f5" class="ls lt in bd lu lv mu lx ly lz mv mb mc jt mw ju me jw mx jx mg jz my ka mi mj bi translated">查看结果</h1><p id="29c2" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">在<strong class="kq io">服务器</strong>文件夹中进行一些更改，并将其发送到<strong class="kq io"> Github </strong>上的存储库，管道开始配置的进程。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/04a1b79a09641a877a35486f9ba04524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6px5yYwc23TFHg_HMsz8Q.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">4.0 — deployment-step details.</figcaption></figure><p id="f974" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过点击生成输出的<strong class="kq io">行113 </strong>的地址，我们可以看到我们生产中的工件。</p><p id="cef9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们可以在web堆栈上平稳地开发与API通信的特性，并且地址将正常匹配——在分支和生产工件中。</p><h1 id="c9f3" class="ls lt in bd lu lv mu lx ly lz mv mb mc jt mw ju me jw mx jx mg jz my ka mi mj bi translated">结论</h1><p id="2adf" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">完成这两集后，我们有了一个完整的<strong class="kq io">连续交付环境，分支</strong>使用<strong class="kq io"> Github Actions、Vercel和Heroku </strong>。</p><p id="a4f3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们从分支中的自动化可靠预览中获益，这既可以用作快速批准，也可以用于某些关键特性的扩展开发。</p><h1 id="e240" class="ls lt in bd lu lv mu lx ly lz mv mb mc jt mw ju me jw mx jx mg jz my ka mi mj bi translated">参考</h1><ul class=""><li id="c50d" class="oj ok in kq b kr mk ku ml kx ol lb om lf on lj oo op oq or bi translated"><a class="ae lk" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank">韦尔塞尔</a></li><li id="0a43" class="oj ok in kq b kr os ku ot kx ou lb ov lf ow lj oo op oq or bi translated"><a class="ae lk" href="https://heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku </a></li><li id="8b1c" class="oj ok in kq b kr os ku ot kx ou lb ov lf ow lj oo op oq or bi translated"><a class="ae lk" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a></li><li id="be16" class="oj ok in kq b kr os ku ot kx ou lb ov lf ow lj oo op oq or bi translated"><a class="ae lk" href="https://docs.github.com/pt/actions/reference/encrypted-secrets" rel="noopener ugc nofollow" target="_blank"> Github秘密</a></li><li id="cc33" class="oj ok in kq b kr os ku ot kx ou lb ov lf ow lj oo op oq or bi translated"><a class="ae lk" href="https://github.com/amondnet" rel="noopener ugc nofollow" target="_blank">在网络中</a> / <a class="ae lk" href="https://github.com/amondnet/vercel-action" rel="noopener ugc nofollow" target="_blank"> vercel-action </a></li><li id="133a" class="oj ok in kq b kr os ku ot kx ou lb ov lf ow lj oo op oq or bi translated"><a class="ae lk" href="https://github.com/rlespinasse" rel="noopener ugc nofollow" target="_blank">rlespinasse</a>/<a class="ae lk" href="https://github.com/rlespinasse/github-slug-action" rel="noopener ugc nofollow" target="_blank">github-slug-action</a></li></ul><p id="e381" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="oe">更多内容请看</em><a class="ae lk" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="oe">plain English . io</em></strong></a></p></div></div>    
</body>
</html>