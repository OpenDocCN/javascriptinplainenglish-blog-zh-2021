<html>
<head>
<title>What is Async/Await and How to Use It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Async/Await以及如何使用它</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-async-await-and-how-to-use-it-20ef88bb0f1?source=collection_archive---------17-----------------------#2021-07-20">https://javascript.plainenglish.io/what-is-async-await-and-how-to-use-it-20ef88bb0f1?source=collection_archive---------17-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4a9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">async/await</code>是JavaScript的一个特性，它允许你编写看起来很像同步代码的异步代码，实际上，它是由JavaScript承诺驱动的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/338d64653c3cd1c15df3e86422b8eddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*3RcBjR-vK3pLZYs6n8lNMw.png"/></div></figure><p id="c6c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Async/Await只是让写承诺变得更加容易。如果你想学习如何使用承诺，请看这里。</p><p id="ddbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的建议是尽可能使用<strong class="jp ir">异步等待</strong>。它使你的代码更加清晰易读。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/6b6af1d38b3086c908334db50872a336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*BVgzQAd-QdFb67Jr.jpg"/></div></figure><h2 id="da53" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">使用Async() </strong></h2><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="c266" class="kz la iq ko b gy lw lx l ly lz">async myName(){<br/>    return "Haboob"<br/>}</span><span id="62f3" class="kz la iq ko b gy ma lx l ly lz">or</span><span id="d755" class="kz la iq ko b gy ma lx l ly lz">const myName =&gt; async() =&gt; {<br/>    return "Haboob"<br/>}</span></pre><p id="4fe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数前面的单词“async”意味着一件简单的事情:函数总是返回一个承诺。其他值自动包装在已解析的承诺中。</p><p id="e7e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果您调用上面的方法，您将看到在then()块中成功返回的值，以及在catch()块中的任何错误</p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="56eb" class="kz la iq ko b gy lw lx l ly lz">myName().then(alert); // Haboob</span></pre><h2 id="fb1f" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">使用Await </strong></h2><p id="867f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">关键字<code class="fe kl km kn ko b">await</code>让JavaScript等待，直到承诺完成并返回结果。</p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="600e" class="kz la iq ko b gy lw lx l ly lz">const getFirstName = async (userId) =&gt; {<br/>  //let's say this takes a few seconds<br/>  return "Bob";<br/>};<br/><br/>const getLastName = async (userId) =&gt; {<br/>  //let's say this takes a few seconds<br/>  return "Ross";<br/>};<br/><br/>const getUserFullName = async (userId) =&gt; {<br/>  const firstName = await getFirstName(userId);<br/>  const lastName = await getLastName(userId);<br/>  return `${firstName} ${lastName}`; // Bob Ross<br/>};</span></pre><p id="b630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">await</code>字面上暂停函数执行，直到承诺解决，然后用承诺的结果恢复它。这不会消耗任何CPU资源，因为JavaScript引擎可以同时做其他工作:执行其他脚本、处理事件等。</p><p id="39d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这只是一个比<code class="fe kl km kn ko b">promise.then</code>更优雅的获得承诺结果的语法。而且，更容易读写。</p><blockquote class="mg"><p id="3658" class="mh mi iq bd mj mk ml mm mn mo mp kk dk translated"><code class="fe kl km kn ko b"><strong class="ak"><em class="mq">await</em></strong></code> <strong class="ak"> <em class="mq">只在一个</em> </strong> <code class="fe kl km kn ko b"><strong class="ak"><em class="mq">async</em></strong></code> <strong class="ak"> <em class="mq">函数</em> </strong> <em class="mq">里面起作用。</em></p></blockquote><p id="b3f9" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">如果你试图在一个非异步的顶级代码中使用await，你可以像这样把它包装在一个异步块中。 </p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="70ab" class="kz la iq ko b gy lw lx l ly lz">(async () =&gt; {   <br/>  let response = await fetch('/getUserInfo/user.json');   <br/>  let user = await response.json();   ... }<br/>)();<br/></span></pre><h2 id="5dd2" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">用异步/等待处理错误</strong></h2><p id="5425" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">理想情况下，您可以像在常规代码中一样使用try-catch来处理错误。</p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="1f21" class="kz la iq ko b gy lw lx l ly lz">async function getRandomUserInfo() {    <br/>  try {     <br/>    let response = await fetch('/get-random-user-info');     <br/>    let user = await response.json();   <br/>  } <br/>  catch(err) {     <br/>    // catches errors both in fetch and response.json<br/>     alert(err);   <br/>  } <br/>}</span></pre><p id="8efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不想使用try-catch，也可以使用。catch()方法提供了带有函数调用的承诺</p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="d4ac" class="kz la iq ko b gy lw lx l ly lz">getRandomUserInfo().catch(alert);</span><span id="378e" class="kz la iq ko b gy ma lx l ly lz">or</span><span id="4db6" class="kz la iq ko b gy ma lx l ly lz">var response = <!-- -->await fetch('/get-random-user-info')<!-- -->.catch((err) =&gt; { console.error(err); });</span></pre><h2 id="1f51" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">什么时候用try-catch vs .then()/。catch() </strong></h2><p id="a86f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">当我们使用<code class="fe kl km kn ko b">async/await</code>时，我们很少需要<code class="fe kl km kn ko b">.then()</code>，因为<code class="fe kl km kn ko b">await</code>处理等待我们的事情。而且我们可以用普通的<code class="fe kl km kn ko b">try..catch</code>代替<code class="fe kl km kn ko b">.catch</code>。</p><p id="7841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在代码的顶层，当我们在任何<code class="fe kl km kn ko b">async</code>函数之外时，我们在语法上不能使用<code class="fe kl km kn ko b">await</code>，所以通常的做法是添加<code class="fe kl km kn ko b">.then/catch</code>来处理最终结果或下降错误，如上面方法<em class="mw"> getRandomUserInfo </em>所示</p><h2 id="2549" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">使用await with Promises </strong></h2><p id="2488" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">您可以将await与所有promise方法一起使用。</p><p id="a016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它甚至可以与Promise.all()一起工作</p><p id="1077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mw">通过</em> <a class="ae kx" href="https://sicpic.medium.com/always-keep-your-promises-fee1487fff16" rel="noopener"> <em class="mw">点击此处</em> </a>了解更多关于承诺的信息</p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="7fa6" class="kz la iq ko b gy lw lx l ly lz">try {<br/>  let userData = await Promise.all([   <br/>    fetch(/get-user-status),   <br/>    fetch(/get-user-info) ]<br/>  );<br/>}<br/>catch(err) {     <br/>    // catches errors from both fetch<br/>     alert(err);   <br/>}</span></pre><p id="9a56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在出错的情况下，它像往常一样传播，从失败的承诺到<code class="fe kl km kn ko b">Promise.all</code>，然后变成一个异常，我们可以使用<code class="fe kl km kn ko b">try..catch</code>在块周围捕捉它。</p><p id="c044" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也将减少您的时间，因为promise中的所有请求都将并行运行。</p><p id="b9bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个g <a class="ae kx" href="https://dev.to/christopherkade/the-dangers-of-async-await-3p5g" rel="noopener ugc nofollow" target="_blank"> ood源来查看性能增益。</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/45a3bee56a36c122993dbf47118eaff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*mgxlFFfglZZjAuQv.jpg"/></div></figure><h2 id="5e55" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">示例—使用async/await重写Promise代码</strong></h2><p id="0118" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">下面是一些使用默认承诺编写的代码</p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="e0ea" class="kz la iq ko b gy lw lx l ly lz">function getRandomUserData() {<br/>  return getUserData(<!-- -->/get-random-user-info<!-- -->) // returns a promise<br/>    .catch(e =&gt; {<br/>      return getFallbackData(<!-- -->/get-fallback-user-info<!-- -->)  // returns a promise<br/>    })<br/>    .then(userData =&gt; {<br/>      return grabImportantUserData(userData)  // returns a promise<br/>    })<br/>}</span></pre><p id="3392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们使用async-await将它转换成代码</p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="c107" class="kz la iq ko b gy lw lx l ly lz">async function getRandomUserData() {<br/>  let userData<br/>  try {<br/>    userData = await getUserData(<!-- -->/get-random-user-info<!-- -->)<br/>  } catch(e) {<br/>    userData = await getFallbackData(<!-- -->/get-fallback-user-info<!-- -->)<br/>  }<br/>  return grabImportantUserData(userData)<br/>}</span></pre><h2 id="d19d" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">动态导入</strong></h2><p id="63fe" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">使用await时，您甚至可以进行动态导入。</p><p id="28bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果模块导出了单独的方法</strong></p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="e7b2" class="kz la iq ko b gy lw lx l ly lz">let {getFirstName, getLastName} = await import('./name.js');</span><span id="22fe" class="kz la iq ko b gy ma lx l ly lz">getFirstName()<br/>getLastName()</span></pre><p id="51ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果模块被默认导出</strong></p><pre class="kq kr ks kt gt ls ko lt lu aw lv bi"><span id="caac" class="kz la iq ko b gy lw lx l ly lz">let obj = await import('./name.js');</span><span id="5366" class="kz la iq ko b gy ma lx l ly lz">let getFullName = obj.default()</span><span id="73fe" class="kz la iq ko b gy ma lx l ly lz">getFullName()</span></pre><h2 id="0ecf" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">伟大链接了解更多</strong></h2><p id="9688" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><em class="mw">https://www . log in radius . com/blog/async/callback-vs-promises-vs-async-await/</em></p><p id="0c5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mw">https://javascript.info/async-await</em></p><p id="1d6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mw">https://morioh.com/p/eecf27783d7b</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/62873ab77964c575afbda436b9450422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*WDQZA4ZfpPmTQqerowZHjQ.png"/></div></figure><p id="5907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mw">更多内容请看</em><a class="ae kx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>