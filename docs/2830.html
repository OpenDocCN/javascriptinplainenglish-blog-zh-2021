<html>
<head>
<title>Under the Hood: React Virtual DOM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下:反应虚拟DOM</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/under-the-hood-react-virtual-dom-99a76f0d5493?source=collection_archive---------8-----------------------#2021-06-09">https://javascript.plainenglish.io/under-the-hood-react-virtual-dom-99a76f0d5493?source=collection_archive---------8-----------------------#2021-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b2df63ec84608d236adc9817cf92a0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvWUyiaOF-TGPjObNz7jOA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nateggrant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nate Grant</a> on <a class="ae kc" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5850" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">React的虚拟DOM是什么？</h1><p id="86e1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">React的官方文档说:</p><blockquote class="lz ma mb"><p id="1be1" class="lb lc mc ld b le md lg lh li me lk ll mf mg lo lp mh mi ls lt mj mk lw lx ly ij bi translated">虚拟DOM (VDOM)是一个编程概念，其中UI的理想或“虚拟”表示保存在内存中，并通过ReactDOM等库与“真实”DOM同步。这个过程叫做和解。</p></blockquote><p id="dc58" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">实际上，虚拟DOM只是React元素(普通对象)的一个有组织的集合，它以一种更容易维护和更新的方式模仿浏览器DOM。</p><p id="5660" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">让我们后退一步，看看React元素的例子。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2862" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">JSX负责将熟悉的HTML语法转换成React元素。没有JSX，这只是:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c1d1" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">下面是在引擎盖下创建的React元素。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4a31" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">你看，它真的只是一个普通的物体。进一步理解这个概念，我们看一个简单的函数组件。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e864" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">下面是没有JSX的同一个按钮组件:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a647" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">当按钮组件被评估时…</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="398d" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">React元素只是底层组件实例的描述。它们不是真正的组件。</p><p id="c0e5" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">我相信你可以想象一个成熟的React应用程序的React元素对象可以有多大。</p><h2 id="55c6" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">为什么这很重要？</h2><p id="63ea" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">理解这个概念很重要，因为这就是虚拟DOM的样子React元素的虚拟树。每次应用程序更新时，都会重新创建虚拟树，并与之前的树进行比较。如果对应用程序的更改(即状态更改)需要每次都渲染<em class="mc"> real </em> DOM，这将非常耗费性能。但是有了虚拟DOM，React可以计算出发生了什么变化，并且只更新发生了变化的内容。这种区分算法是React的支柱，它被称为<em class="mc">协调</em>。</p><h1 id="27c2" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">调和与渲染</h1><p id="ed88" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">协调和渲染是两个独立的过程。和解几乎是虚拟DOM的全部内容。当一个新的虚拟元素树生成时，它被传递到一个渲染环境，这取决于应用程序的目标。如果目标是浏览器web应用程序，那么呈现环境就是DOM，因此虚拟树通过React DOM呈现为DOM节点。对于本机应用程序(iOS或Android)，虚拟树通过React Native呈现为本机视图。</p><p id="95f1" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">协调算法处理差异过程，并计算出所需的最小更改，而渲染器利用这些信息来实际渲染应用程序。</p><p id="5c77" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">这也是React如此强大的原因之一。React DOM、React Native和任何其他渲染引擎都能够使用相同的协调器，同时能够生活在自己单独的域中，以他们想要的方式消费虚拟DOM树。</p><h1 id="67a5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">和解是如何进行的？</h1><p id="8602" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当您的一个组件获得其props的更新或其状态改变时，协调器触发。这为该组件(“根”元素)及其所有子组件触发了一个<code class="fe nd ne nf ng b">render</code>,生成了一个新的React元素虚拟树。然后，从两棵树的根开始，将旧树与新树进行区分/比较。根据根元素的类型，行为会有所不同。</p><h2 id="ebcb" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">不同类型的元素</h2><p id="b660" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当协调器发现这两个根元素不同时，它会从头开始重新创建整个树。</p><p id="757a" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">让我们看看下面的例子。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5889" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">如果它更新到以下内容:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fbe2" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">调解器将拆掉整棵树，重建一切。根组件及其所有子组件将被卸载。此外，所有状态都将在此过程中丢失。</p><h2 id="46c2" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">相同类型的元素</h2><p id="4a1e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当区分相同类型的元素时，React足够聪明，知道只有元素的属性发生了变化。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e827" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">假设我们将<code class="fe nd ne nf ng b">.active</code>类添加到<code class="fe nd ne nf ng b">&lt;ul&gt;</code>中，以便在需要时显示它。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ca84" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">React将保留呈现的DOM元素，只更新节点的class属性。对元素的样式属性的更新也是如此。</p><h2 id="54a6" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">子元素、列表和键</h2><p id="4198" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一旦根元素被区分，协调器就沿着树向下遍历到子元素。React遍历子列表，检查是否有任何更改，如果有，就更新虚拟DOM。</p><p id="62b7" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">然而，React遇到了相同类型的子元素的问题，这通常发生在列表中。以下面这个为例:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1825" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">如果我们将列表更改为以下内容:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8718" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">React将无法意识到它可以保留<code class="fe nd ne nf ng b">&lt;li&gt;Banana&lt;/li&gt;</code>和<code class="fe nd ne nf ng b">&lt;li&gt;Orange&lt;/li&gt;</code>，而只是将<code class="fe nd ne nf ng b">&lt;li&gt;Apple&lt;/li&gt;</code>添加到这个列表中，从而导致糟糕的性能。这也是为什么当未能在控制台中为相同类型的每个子级添加一个键时，您会看到此警告消息:</p><blockquote class="lz ma mb"><p id="9e16" class="lb lc mc ld b le md lg lh li me lk ll mf mg lo lp mh mi ls lt mj mk lw lx ly ij bi translated">警告:数组或迭代器中的每个子元素都应该有一个唯一的“key”属性。</p></blockquote><p id="d9af" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">这就是<em class="mc">键</em>的用武之地。</p><p id="f2f4" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">键允许React将以前树中的子元素匹配到新树中。因此，如果我们将上面的示例转换为使用键:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="123e" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">它更改为以下内容:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="562b" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">React知道添加了一个带有键<code class="fe nd ne nf ng b">apple</code>的新子元素，它可以保留带有<code class="fe nd ne nf ng b">banana</code>和<code class="fe nd ne nf ng b">orange</code>的元素。</p><p id="e8a9" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">理想情况下，子元素应该有唯一且永不改变的键。不，我不是说仅仅使用索引。事实上，<strong class="ld ir">你应该负责任地使用索引作为键，否则你可能会搬起石头砸自己的脚。你可以有很多选择。模型的ID和对象中某个属性的散列值是用作键的非常好的候选对象。</strong></p><h2 id="7289" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">用索引做键有什么问题？</h2><p id="60e9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了更好地理解这个问题，这里有一个例子:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b58d" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">从上面我们可以看到，我们使用<code class="fe nd ne nf ng b">.map()</code>遍历产品，并使用索引<code class="fe nd ne nf ng b">i</code>作为每个孩子的键。生成的DOM树将是:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="27a0" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">当新产品被添加到产品系列中时…</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f5d8" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">接下来会发生什么:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f01c" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">没问题吧？但是如果新产品被<strong class="ld ir">加在</strong>前面会怎么样呢？</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="537d" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">发生的事情并不完全是React想要的。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ea34" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">你看，带有关键字<code class="fe nd ne nf ng b">0</code>的<code class="fe nd ne nf ng b">&lt;li&gt;</code>元素突然将其子元素从<code class="fe nd ne nf ng b">Croissant — €1.99</code>更改为<code class="fe nd ne nf ng b">Ciabatta — €2.99</code>，协调器会将其视为一个完全不同的元素，因此卸载旧元素并挂载一个新元素。同样的事情也发生在列表中的其他项目上，导致了糟糕的性能。</p><p id="5c35" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">一个简单的改变就能解决这个问题。我们不使用迭代器的索引作为键，而是使用产品的ID。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b67e" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">对于原始产品数组，生成的DOM树如下所示:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6c61" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">当<code class="fe nd ne nf ng b">Ciabatta</code>被添加到产品数组中时，React现在知道它可以保留带有键<code class="fe nd ne nf ng b">1154</code>和<code class="fe nd ne nf ng b">1155</code>的<code class="fe nd ne nf ng b">&lt;li&gt;</code>元素，并且在列表的开头添加了一个新元素，因此只创建了一个新元素。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="4c36" class="mr ke iq bd kf ms mt dn kj mu mv dp kn lm mw mx kr lq my mz kv lu na nb kz nc bi translated">负责任地使用索引作为键</h2><p id="321a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我不是说不能用索引做键，事实上也有一些例外。以下是一些关于何时可以在列表中使用索引作为键的有用指南:</p><ul class=""><li id="02a3" class="nh ni iq ld b le md li me lm nj lq nk lu nl ly nm nn no np bi translated">当你完全确定你的列表项目没有任何变化时；</li><li id="516d" class="nh ni iq ld b le nq li nr lm ns lq nt lu nu ly nm nn no np bi translated">列表未被筛选或重新排序；</li><li id="b7f7" class="nh ni iq ld b le nq li nr lm ns lq nt lu nu ly nm nn no np bi translated">最后，当列表项没有自己的id时。</li></ul><h1 id="642f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="9028" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">理解虚拟DOM和协调过程可以帮助您构建快速且健壮的用户界面。虚拟DOM和协调算法隐藏了React应用程序每次更新时发生的大量复杂性，同时仍然保持React的目标，即允许开发人员编写快速和高性能的应用程序。</p><h1 id="d6c5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">相关阅读</h1><ul class=""><li id="25f0" class="nh ni iq ld b le lf li lj lm nv lq nw lu nx ly nm nn no np bi translated"><a class="ae kc" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">反应中的对账</a></li><li id="4ab3" class="nh ni iq ld b le nq li nr lm ns lq nt lu nu ly nm nn no np bi translated"><a class="ae kc" href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" rel="noopener ugc nofollow" target="_blank">反应组件、元素和实例</a></li><li id="a2c6" class="nh ni iq ld b le nq li nr lm ns lq nt lu nu ly nm nn no np bi translated"><a class="ae kc" href="https://github.com/acdlite/react-fiber-architecture" rel="noopener ugc nofollow" target="_blank">反应纤维架构</a></li><li id="9459" class="nh ni iq ld b le nq li nr lm ns lq nt lu nu ly nm nn no np bi translated"><a class="ae kc" href="https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318" rel="noopener">索引作为一个键是一个反模式</a></li></ul></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="7f21" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated">请不要忘记<strong class="ld ir">鼓掌</strong>如果你发现这是有用的，并<strong class="ld ir">关注</strong>我更多这样的文章。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/82627e1cd7a59167ac47977cf30550b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2ilkoOR5ytmxNTZqx9NhSA.gif"/></div></div></figure><p id="1be5" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mg lo lp lq mi ls lt lu mk lw lx ly ij bi translated"><em class="mc">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mc">plain English . io</em></a></p></div></div>    
</body>
</html>