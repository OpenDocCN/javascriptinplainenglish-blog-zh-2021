<html>
<head>
<title>Double Your React Coding Speed With This Simple Trick</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这个简单的技巧，您的反应编码速度将翻倍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/double-your-react-coding-speed-with-this-simple-trick-ca2e47d1bf97?source=collection_archive---------0-----------------------#2021-01-22">https://javascript.plainenglish.io/double-your-react-coding-speed-with-this-simple-trick-ca2e47d1bf97?source=collection_archive---------0-----------------------#2021-01-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a387b693c59c0b1c5c37528948062e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFJmDzqM8803SUtMp8qDmA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Small reusable building blocks</figcaption></figure><p id="ec8b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你和React or或者React Native一起工作，感觉你的编码速度很慢，花时间去捕捉错误，而不是添加新的特性，处理长的源文件并且很难找到东西，并且一遍又一遍地实现相同的逻辑，如果你把你的代码重构成<strong class="kb io">可重用的</strong>构建块，你的编码速度会加倍。</p><blockquote class="kx"><p id="5d07" class="ky kz in bd la lb lc ld le lf lg kw dk translated">有了可重用的React组件(和钩子),构建令人敬畏的东西是微不足道的。这就像把乐高积木拼在一起。👍</p><p id="b92a" class="ky kz in bd la lb lc ld le lf lg kw dk translated">— <a class="lh li ep" href="https://medium.com/u/e986f7cdb458?source=post_page-----ca2e47d1bf97--------------------------------" rel="noopener" target="_blank">科里豪斯</a>，<a class="ae lj" href="https://medium.com/@housecor/designing-reusable-react-components-1cbeb897b048" rel="noopener">设计可重复使用的反应元件</a></p></blockquote><h1 id="bbf5" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">你将如何学习</h1><p id="0037" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">我们将看看像您这样的开发人员编写的反应组件。<strong class="kb io">我们将一步一步重构</strong>使其更上一层楼。期待收到<strong class="kb io">许多真知灼见</strong>，这会提高你的反应编码速度。</p><blockquote class="kx"><p id="2525" class="ky kz in bd la lb lc ld le lf lg kw dk translated">重构，重构，重构——这很正常；您必须多次更改代码；这是一个自然的学习过程。</p><p id="cec2" class="ky kz in bd la lb lc ld le lf lg kw dk translated">— <a class="lh li ep" href="https://medium.com/u/ac4e83345a52?source=post_page-----ca2e47d1bf97--------------------------------" rel="noopener" target="_blank">托马斯·埃格林斯卡斯</a>，<a class="ae lj" href="https://medium.com/free-code-camp/mindset-lessons-from-a-year-with-react-1de862421981#3bb9" rel="noopener">与React共事一年后，我学到的最重要的一课是</a></p></blockquote><ul class=""><li id="804d" class="mn mo in kb b kc mp kg mq kk mr ko ms ks mt kw mu mv mw mx bi translated">本文将包含大量的反应代码。不要害怕代码。花点时间阅读和理解它。<strong class="kb io">如果您在评论</strong>中有任何问题请随意提问，我将10次回复10次。</li><li id="5e2e" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">这是一篇大文章。内容全面。请随意将本文保存在您的标签中<strong class="kb io">并尝试多次阅读</strong>。</li><li id="f6f3" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">即使代码将在React Native中，您也可以很容易地使用本文来提高您的React技能。</li></ul><p id="3c56" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">祝你好运，玩得开心！</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="33ed" class="lk ll in bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated">我们将重构的原始反应组件</h1><p id="a4f3" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">像您这样的开发人员编写的简单组件。它的功能是什么:</p><ul class=""><li id="eebd" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">从后端获取浏览器列表</li><li id="1912" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">正在加载时，在屏幕上显示“加载”状态</li><li id="7866" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">以卡片列表的形式显示加载的浏览器</li><li id="c3f3" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">当用户按下一张卡片时，它会显示一个带有详细浏览器描述的模态窗口</li></ul><h2 id="459f" class="ns ll in bd lm nt nu dn lq nv nw dp lu kk nx ny ly ko nz oa mc ks ob oc mg od bi translated">这个代码看起来像你的代码吗？</h2><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h1 id="aadc" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">这个组件的优点是什么</h1><ul class=""><li id="b1c2" class="mn mo in kb b kc mi kg mj kk on ko oo ks op kw mu mv mw mx bi translated">它的工作原理，例如:列表将被下载并显示给具有上述所有功能的用户。</li><li id="e5cb" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">它使用反作用钩。</li></ul><h1 id="19d8" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">这个组件的缺点是什么</h1><p id="6776" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">该组件是一个<strong class="kb io">整体</strong>，例如:该组件被设计和制造成只在一个应用程序中的一个地方使用一次。</p><p id="6f33" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">记住这句口头禅:</strong></p><blockquote class="kx"><p id="84ed" class="ky kz in bd la lb lc ld le lf lg kw dk translated">成为快速开发人员的艺术是编写<strong class="ak">可重用</strong>构件的艺术。</p></blockquote><p id="fb39" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk or km kn ko os kq kr ks ot ku kv kw ig bi translated"><strong class="kb io">你的组件和功能越可重用，你就越快。这给了你巨大的优势</strong>:</p><ul class=""><li id="c94e" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">你花在输入代码上的时间更少了。可重用的组件/功能可以隐藏大量的代码，并且可以使用100次。并且您只需要实现它们一次。想象一下，每次使用“fetch(URL)”时都要实现HTTP协议，这会降低您的速度。</li><li id="d002" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">你花在输入代码上的时间甚至更少。将新特性添加到一个地方比添加到10个不同的地方要快。如果你重用你的构建模块，你就有一个地方来添加你的功能。在一个地方添加一个特性，在任何地方都可以得到结果。</li><li id="7f11" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">你花在捕捉bug上的时间更少了。您将使用已经尝试和测试过的构建块。新代码需要测试，但旧代码可以信任。</li><li id="a966" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated"><strong class="kb io">你花更少的时间阅读代码</strong>。如果您重用一个构建块，它可以节省您理解代码的时间。从熟悉的部分构建程序很容易。</li><li id="860c" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">你花在阅读代码上的时间就更少了。分离的可重复使用的构建模块可以在不同的文件中移动，这样你就可以使用更小的模块，屏幕上的代码也不会那么混乱。这将提高你对代码的理解。</li></ul><blockquote class="kx"><p id="4df6" class="ky kz in bd la lb ou ov ow ox oy kw dk translated">作为一名开发人员，通常会花更多的时间来弄清楚代码是做什么的，而不是实际编写代码。</p><p id="c241" class="ky kz in bd la lb lc ld le lf lg kw dk translated">–<a class="lh li ep" href="https://medium.com/u/f9f631989d8e?source=post_page-----ca2e47d1bf97--------------------------------" rel="noopener" target="_blank">Alexis Mangin</a>，<a class="ae lj" href="https://medium.com/@alexmngn/why-react-developers-should-modularize-their-applications-d26d381854c1" rel="noopener">React开发者为什么要模块化他们的应用？</a></p></blockquote><ul class=""><li id="ed1b" class="mn mo in kb b kc mp kg mq kk mr ko ms ks mt kw mu mv mw mx bi translated">你为你的可重用构建模块编写更少的测试。测试让你的生活像蜂蜜一样甜，但是用一块巨石，你会发现自己一次又一次地测试同样的逻辑。更多可重用的构建模块=更少的测试。</li></ul><blockquote class="oz pa pb"><p id="3d8b" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">Monolith =慢速编码</p><p id="4848" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated"><strong class="kb io">可重用</strong>积木=快速编码</p></blockquote><h1 id="2fa8" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">如何让这100行代码更加可重用</h1><p id="6438" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">让我们先尝试一些非常基本和简单的东西，然后再学习高级的东西。我们如何能够在多个地方使用这100条线路？</p><h1 id="7c68" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated"><strong class="ak">将常量移动到组件的道具上</strong></h1><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="491d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将URL常量移动到props，并且已经可以使用不同的URL重用浏览器组件。重用影响肯定很小，但是很容易实现。</p><p id="042a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">热身？那我们试试真正酷的东西吧。</p><h1 id="007a" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">分离业务逻辑和视图逻辑</h1><blockquote class="kx"><p id="960e" class="ky kz in bd la lb lc ld le lf lg kw dk translated">当UI组件不知道网络、业务逻辑或应用程序状态时，生活会更简单。给定相同的属性，总是呈现相同的数据。</p><p id="1687" class="ky kz in bd la lb lc ld le lf lg kw dk translated">——<a class="lh li ep" href="https://medium.com/u/c359511de780?source=post_page-----ca2e47d1bf97--------------------------------" rel="noopener" target="_blank">埃里克·艾略特</a>，<a class="ae lj" href="https://medium.com/javascript-scene/the-missing-introduction-to-react-62837cb2fd76" rel="noopener">反应过来</a>的失踪介绍</p></blockquote><p id="4383" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk or km kn ko os kq kr ks ot ku kv kw ig bi translated"><strong class="kb io">这是本文</strong>最重要的部分。如果你只能学会一件事，那就顺其自然吧:</p><blockquote class="kx"><p id="cdf2" class="ky kz in bd la lb lc ld le lf lg kw dk translated">成为快速反应开发人员的艺术是将业务逻辑与视图逻辑分离的艺术。</p></blockquote><p id="b345" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk or km kn ko os kq kr ks ot ku kv kw ig bi translated">哇，如此复杂的尖峰！别害怕，我会指引你。</p><p id="1cd7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">业务逻辑:</strong>做决策和存储状态的东西，例如:上面的&lt; Browsers / &gt; body中的一切都返回。</p><p id="bf9b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">视图逻辑:</strong>在屏幕上显示状态并读取用户输入的所有内容，例如:返回的所有内容(…)</p><p id="dbeb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们向前迈出一小步，将我们的组件分成两部分，然后检查它将如何使我们的代码更加可重用。</p><p id="2d82" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">我们将做什么:</strong></p><ul class=""><li id="b96d" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">为我们的业务逻辑创建了一个自定义的React hook useBrowsers()</li><li id="346a" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">为我们的视图逻辑创建了一个React组件<BrowsersList/></li></ul><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9cfa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好吧，我们正在前进，我们的代码远非完美，但它变得更加可重用:</p><ul class=""><li id="b953" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">我们可以将<BrowsersList/>用于不同的数据源。以前，我们只能使用来自远程HTTP端点的数据；但是现在我们可以从内存/光盘/或任何其他地方获得它。</li><li id="a8ca" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">我们可以在不同的屏幕上使用useBrowsers()，甚至不使用任何屏幕。例如，我们可以在具有不同设计的不同应用程序中使用useBrowsers()。</li></ul><p id="881d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但这种分裂远非完美！<strong class="kb io">我们仍然可以让这些代码更加可重用。</strong></p><blockquote class="oz pa pb"><p id="55e5" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">可重用的构建模块=快速编码</p></blockquote><h1 id="cfc7" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">将你的代码分成许多小的可重复使用的文件</h1><p id="5ac6" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">重要的事情先来。将整块分割成两部分为重构提供了新的可能性。如果把我们的代码分成不同的文件/模块，我们可以使我们的程序更具可读性(你也更快)。这将允许我们孤立地考虑每个模块<strong class="kb io">。</strong>并使每个模块更具可读性和可重用性。</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/76957f86f7031c4ba459750554a8775d.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*-LLd7xhbdkUXPhmM4WTH1A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Typical React project file structure</figcaption></figure><p id="4949" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一个典型的React项目文件结构:</p><ul class=""><li id="92be" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">index.js从Browsers.jsx导出<Browsers/></li><li id="7957" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">“组件”和“挂钩”文件夹存储与<Browsers/>组件相关的构建模块。</li><li id="5d6d" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">jsx还可以将演化成一个包含相关“钩子”、“组件”和索引的文件夹</li></ul><p id="c8ea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> React项目文件结构是递归树</strong>。</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/abe61ccf8a2648e6191044b168f3d6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*58OHUtd_g1O1vg-URWu5Jg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Possible recursive React project structure</figcaption></figure><p id="9293" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在David Gilbertson的文章中阅读更多关于React项目结构的信息:</p><div class="ph pi gp gr pj pk"><a href="https://medium.com/hackernoon/the-100-correct-way-to-structure-a-react-app-or-why-theres-no-such-thing-3ede534ef1ed" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd io gy z fp pp fr fs pq fu fw im bi translated">构建React应用程序的100%正确的方法(或者为什么没有这样的东西)</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">当涉及到构造一个React应用程序时，理想的结构是这样的，它允许你用…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">medium.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py jt pk"/></div></div></a></div><p id="eafb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们检查我们的BrowsersList.jsx</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="c21b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">啊，是啊，代码少多了。感觉不那么杂乱。现在我们可以专注于重构这部分代码了。</p><blockquote class="oz pa pb"><p id="c2a0" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">减少屏幕上的混乱=快速编码</p></blockquote><p id="9817" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是在我们提高这个组件的可重用性之前，让我先解决当前设计的一个大问题。</p><h1 id="7438" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated"><strong class="ak">大问题与</strong>许多可重复使用的小文件</h1><p id="5b30" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">查看我们的<BrowsersList/>功能签名:</p><ul class=""><li id="3947" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">如果我们重命名一些属性，例如，将“changeDescription”重命名为“setSelectedBrowser”，或者将“Description”重命名为“Browser”</li><li id="da29" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">或者是否会删除一些道具</li><li id="3f45" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">或者会增加新的道具</li></ul><p id="4756" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后每个我们用<BrowsersList/>的地方都会破！</p><p id="442d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">每次更改组件的签名时，都会破坏代码中使用该组件的每个位置。而且你会经常改变签名，很难在第一天就做出一个完美的签名，例如:<strong class="kb io">设计经常出现在你的打字代码</strong>中。因为我们专注于制造大量高度可重用的组件，我们将在许多地方获得突破。</p><p id="3693" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您的IDE不能通过自动重构来重命名这样的属性。你将需要手工做它。手动检查每个使用场所。这是慢速编码。</p><p id="b28f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最糟糕的是，我们将会得到休息，而自己却不知道。抓住机会的唯一方法是:</p><ul class=""><li id="cc7d" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">运行我们的应用</li><li id="9c1d" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">手动导航到损坏的组件</li><li id="41e1" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">撞车了</li><li id="0516" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">阅读崩溃文本</li><li id="c303" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">修复错误，然后重试</li></ul><p id="83ef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一项缓慢而乏味的任务。这就是令人讨厌的bug进入生产的方式。这种情况经常发生。</p><p id="0128" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">检查我们的Browsers.jsx，是不是坏了？</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="5852" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">谁知道呢！为了确保这一点，我们需要打开BrowsersList.jsx和useBrowsers.js并手动比较参数。</p><p id="e81c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个代码是不是被破解了？</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="5304" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">是的。useBrowsers.js中的“descripton”少了“I”，这是个错别字。</p><p id="23f4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">许多初级开发人员花费大量时间调试他们的应用</strong>，试图找出哪个道具坏了，或者哪个道具收到了不正确的数据(字符串而不是数字)。但是这个问题有一个快速的解决方案。</p><h1 id="1708" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">用JavaScript停止慢速编码，用TypeScript开始快速编码</h1><p id="c248" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">现在是2021年，每个React / React本地开发人员都应该使用TypeScript。没有任何理由不使用TypeScript。</p><blockquote class="kx"><p id="e675" class="ky kz in bd la lb lc ld le lf lg kw dk translated">这看起来可能很吓人</p><p id="20a9" class="ky kz in bd la lb lc ld le lf lg kw dk translated">对我们来说，TypeScript的好处大大超过了它确实存在的缺点。我们最关注的是额外的培训费用。</p><p id="48ef" class="ky kz in bd la lb lc ld le lf lg kw dk translated">这个问题最明显的解决方案是逐步引入特性——您可以简单地启用TypeScript，而无需更改任何代码，添加一些简单的类型声明。最后，我们的经验是，使用最基本的TypeScript可以获得很多好处。</p><p id="1c82" class="ky kz in bd la lb lc ld le lf lg kw dk translated">— <a class="lh li ep" href="https://medium.com/u/23626b04abce?source=post_page-----ca2e47d1bf97--------------------------------" rel="noopener" target="_blank">菲利克斯·里瑟伯格</a>，<a class="ae lj" href="https://slack.engineering/typescript-at-slack/" rel="noopener ugc nofollow" target="_blank">空闲时打字稿</a></p></blockquote><h1 id="3d7e" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">酷炫的打字稿功能</h1><p id="e2e4" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated"><strong class="kb io">更少的虫子。更少的错误=更快的编码</strong></p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="pz oj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">TypeScript saves you from bugs</figcaption></figure><p id="d419" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们发现了我们的“I”错别字:</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/b3b52f47d96e82a24921e787c4d7cf41.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*DtOdpqZw4uGc6cH2Vj2YhA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">TypeScript Magic highlights errors</figcaption></figure><p id="7744" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您的IDE将收到React props的自动完成特性。当您使用带有未知属性的第三方组件时，这尤其可以节省您的时间:</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/48cbe14407a21ea3dad94cec5a97d833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*fVSUqnm6iDu237qM4_848g.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">TypeScript Magic autocompletes props</figcaption></figure><p id="d7e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">您的创意将获得“重构名称”功能。这会节省你重命名道具的时间。一个道具的所有使用都将在一次点击中自动重命名。</strong></p><p id="a8d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">您再也不会忘记添加空/未定义的检查。</strong></p><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi qc"><img src="../Images/f2403c662111219e79b1a6d6210b892d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnNWWoGzvySn7Zc_Qdvv1A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">? — means that the parameter can be undefined</figcaption></figure><p id="7435" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">当然，如果我们试图将无效数据放入我们的道具中，我们会得到一个错误高亮:</strong></p><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi qd"><img src="../Images/7a9e6df900efe59316bd8859a42a6f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UT3X-rdtFNKfn_cEBks_VQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">TypeScript Magic checks if props are correct</figcaption></figure><p id="2e99" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">TypeScript很容易为您节省大量时间和调试代码的压力。</p><blockquote class="oz pa pb"><p id="9367" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">JavaScript =慢速编码</p><p id="9a68" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">快速编码</p></blockquote><h1 id="238e" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">快速系统设计的第一步:定义你的类型。</h1><p id="3209" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated"><em class="oq">这不是一个全面的TypeScript教程。如果你觉得卡住了，请参考</em><a class="ae lj" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank"><em class="oq">typescriptlang.org</em></a><em class="oq">然后回来。</em></p><p id="a9fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们回到我们的<BrowsersList/>组件，为它的props定义一些类型(不要忘记把你的文件从。jsx到。tsx)。</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="52ea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">并更新我们的useBrowsers()签名:</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a1e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，TypeScript将验证useBrowsers()和BrowsersList <strong class="kb io">是否兼容</strong>。如果我们改变BrowsersList属性，我们将得到一个错误。仅此一点就保证了产品中的bug大大减少。</p><blockquote class="oz pa pb"><p id="9521" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">更少的错误=更快的编码</p></blockquote><h1 id="81f2" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">快速系统架构</h1><p id="a03c" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">BrowsersListProps目前看起来很乱:</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><ul class=""><li id="daad" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">组件应显示加载状态。在类型定义中使用一行。</li><li id="bcc8" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">应该显示浏览器列表[]。在类型定义中使用一行。</li><li id="a07e" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">应该显示一个带有详细浏览器描述的模式窗口。<strong class="kb io">在类型定义中使用4行</strong>。这些行限制我们在模态窗口中显示“描述”字段。而且<strong class="kb io">感觉</strong>我们可能需要在这种模式下显示更多的浏览器字段。请记住，<strong class="kb io">更改组件签名非常昂贵/缓慢。</strong></li></ul><p id="03c2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以做一个幸运的猜测，缩短我们的类型定义，重构“模态窗口”特性以使用浏览器类型。</p><p id="deed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这将降低道具的复杂性:</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/1be3ebf146999f73a2a91f0f60ad63bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*EE3YEG5EPaEMpVZuqg1fWQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">TypeScript Magic checks if a signature is correct</figcaption></figure><p id="f70f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个小的重构练习应该向您展示TypeScript的另一个显著特征:快速系统设计。</p><p id="4b4c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">编写类型非常容易。它们实际上很小(4行类型与60行实际组件),但是包含了大量关于系统的信息。因此，您可以编写一些类型并设计您的程序，而无需实际编写任何代码。这为您节省了大量的<strong class="kb io">架构</strong>时间。这允许你的设计从使用中<strong class="kb io">浮现</strong>，并且快速浮现。</p><blockquote class="oz pa pb"><p id="5303" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">任何系统设计的第一步:定义你的类型。</p><p id="1bb3" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">使用TypeScript类型的架构和规划=快速编码</p></blockquote><h1 id="9a08" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated"><strong class="ak">定义好类型后，你可以开始填充组件的主体</strong></h1><p id="1ebe" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">让我们修复我们的<BrowsersList/>,让它处理一个新的BrowsersListProps签名。我们可以重构<BrowserItem/>，这样就只需要2个道具，而不是过多的道具。这将使代码可读性更强，速度更快。</p><blockquote class="oz pa pb"><p id="fb8e" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">如果你的组件有很多道具，这是一个很好的重构暗示</p></blockquote><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="181e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个组件已经看起来可读性很强，不那么可怕了。</p><blockquote class="oz pa pb"><p id="642d" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">减少屏幕上的混乱=快速编码</p></blockquote><h1 id="1715" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">从<BrowsersList/>中提取可重用的<UIFriendlyList/>逻辑</h1><p id="bf0d" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">仅仅通过观察一个组件，开发人员就能获得许多不同的感受。比如我感觉<BrowsersList/>中的“显示列表的加载状态”就是一个很酷的功能。太酷了，以至于它很有可能被用在许多不同的组件中。</p><p id="2975" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们有所进展。我们发现了一些黄金。这可能是我们的应用程序的一个非常有用和可重用的功能。但是目前，<strong class="kb io">与&lt; BrowsersList / &gt;组件耦合在一起，我们不能在不同的地方重用它。让我们修理它。</strong></p><p id="59c4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们想做一个新的<UIFriendlyList/>，用它代替简单的<FlatList/>。该<UIFriendlyList/>将具有显示装载状态的能力。</p><p id="91a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">像往常一样，我们首先定义一些类型:</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><ul class=""><li id="9bcc" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">“T”是一个类型参数。带参数的类型称为<a class="ae lj" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>。“UIFriendlyList &lt; T &gt;的“T”与函数“foo(arg)”的“arg”是相同的。如果你想从另一个类型构造你的类型，你可以使用泛型。更多信息请查看罗斯·布拉特的这篇文章:</li></ul><div class="ph pi gp gr pj pk"><a href="https://rossbulat.medium.com/typescript-generics-explained-15c6493b510f" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd io gy z fp pp fr fs pq fu fw im bi translated">解释了类型脚本泛型</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">了解什么是泛型以及如何在Typescript中使用泛型</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">rossbulat.medium.com</p></div></div><div class="pt l"><div class="qf l pv pw px pt py jt pk"/></div></div></a></div><ul class=""><li id="a1be" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">“&amp;”是<a class="ae lj" href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types" rel="noopener ugc nofollow" target="_blank">交集</a>。“类型X = A &amp; B”意味着X将包含A <strong class="kb io">和</strong> B。</li></ul><p id="335c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">检查此动力移动:</p><ul class=""><li id="308e" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">我们为我们的属性UIFriendlyListProps定义了类型。</li><li id="3e82" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">我们定义了一个<a class="ae lj" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>类型，例如:列表可以包含任何类型的内部条目。</li><li id="3037" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">UIFriendlyListProps用我们的“加载状态”特性扩展了React本机库中的FlatListProps</li><li id="23b8" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">所以我们从FlatListProps和{loading？:布尔}</li></ul><p id="66cd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">多酷啊。</p><p id="7546" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我对这个设计很满意，让我们制作这个组件的主体，并将其移动到另一个文件UIFriendlyList.jsx中</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="29eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还添加了一个空状态。因此用户可以确定列表是空的，并且没有等待数据到达。非常友好的用户界面功能。</p><blockquote class="oz pa pb"><p id="aae3" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated"><UIFriendlyList/>是一个高度可重用的组件，将来肯定会节省我们的时间。有了这个组件，我们成为了一个反应更快的开发人员。</p></blockquote><p id="8822" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，让我们检查一下我们的<BrowsersList/>:</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="cc6c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这就是我所说的。这个组件比<a class="ae lj" href="https://gist.github.com/aleksejkozin/98ebb0c3fc826c23bbd9afc30cfda24f" rel="noopener ugc nofollow" target="_blank">原来的BrowsersList </a>更容易理解。我们得到了一个可重复使用的&lt; UIFriendlyList / &gt;,这肯定会节省我们的时间。我们可以更进一步，假设我们想要重用ModalWindow+List逻辑，但让我们就此打住。</p><p id="6e77" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个“提取可复用部件”的过程，<strong class="kb io">永无止境，耗费时间</strong>。如果你觉得你可以在另一个地方度过更有成效的时间，你应该停下来。</p><blockquote class="kx"><p id="4e70" class="ky kz in bd la lb lc ld le lf lg kw dk translated">我们人类倾向于将编写代码作为一种拖延的形式。通过解决未来的假设问题来推迟解决我们现在的难题。</p><p id="c6ac" class="ky kz in bd la lb lc ld le lf lg kw dk translated">—<a class="lh li ep" href="https://medium.com/u/c2cca5f47e14?source=post_page-----ca2e47d1bf97--------------------------------" rel="noopener" target="_blank">Justin Travis Waith-Mair</a>，<a class="ae lj" href="https://medium.com/the-non-traditional-developer/stop-writing-reusable-react-components-bd649cba2700" rel="noopener">停止编写可重用的React组件</a></p></blockquote><p id="6e64" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk or km kn ko os kq kr ks ot ku kv kw ig bi translated">我们已经完成了视图逻辑，是时候检查useBrowsers()钩子中的业务逻辑了。</p><h1 id="20cf" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">重构useBrowsers()钩子中的业务逻辑</h1><blockquote class="kx"><p id="624f" class="ky kz in bd la lb lc ld le lf lg kw dk translated">就像组件一样，我们可以创建定制的可重用钩子。这使得代码可读性更好，因为代码库被分成了更小的、可重用的块</p><p id="1327" class="ky kz in bd la lb lc ld le lf lg kw dk translated">–<a class="lh li ep" href="https://medium.com/u/9cf5c71f047d?source=post_page-----ca2e47d1bf97--------------------------------" rel="noopener" target="_blank">Bikash Paneru</a>，<a class="ae lj" href="https://medium.com/better-programming/how-to-write-better-functional-components-in-react-bc974f777145" rel="noopener">如何在React中写出更好的功能组件</a></p></blockquote><p id="7269" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk or km kn ko os kq kr ks ot ku kv kw ig bi translated">让我们重构useBrowsers()以返回一个有效的BrowsersListProps对象。我还重构了“loading”:现在它会在fetch之前设置为“true”，之后设置为“false”。</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0802" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看起来很好，但我们可以更深入，提取一个可重复使用的构建模块。这种“获取URL并将结果存储在一个状态中，同时显示加载”的事情看起来像是一个高度可重用的构建块。我们希望<strong class="kb io">将</strong>从useBrowsers()中分离出来。</p><p id="056e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">像往常一样，让我们从定义一些类型开始。我们希望使用useFetch()钩子，它可以在一个状态中存储获取的数据，还可以指示加载。我们还想将从端点获取的数据定义为FetchBrowsersResults:</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2654" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看起来不错，现在让我们定义useFetch()主体并将其移动到专用文件useFetch.ts:</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4be8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我还添加了一个获取异常警报。因此，用户将看到错误描述。</p><blockquote class="oz pa pb"><p id="247e" class="jz ka oq kb b kc kd ke kf kg kh ki kj pc kl km kn pd kp kq kr pe kt ku kv kw ig bi translated">useFetch()是一个高度可重用的函数，将来肯定会节省我们的时间。有了这个功能，我们成为了一个反应更快的开发者。</p></blockquote><p id="be30" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在让我们重构useBrowsers()钩子:</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="7ee0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">与<a class="ae lj" href="https://gist.github.com/aleksejkozin/98ebb0c3fc826c23bbd9afc30cfda24f" rel="noopener ugc nofollow" target="_blank">最初的useBrowsers() </a>相比，它要小得多，也容易理解。</p><p id="19ae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我看不出还有什么可重用的逻辑可以从这个组件中提取。所以让我们更进一步。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="250f" class="lk ll in bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated">如何成为一名反应更快的开发人员的4个简单技巧。</h1><p id="473b" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">我们已经完成了主要部分，让我们放松一下。我会给你4个简单的建议。</p><h1 id="a863" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">1.永远不要手工格式化你的代码</h1><p id="6052" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">您的IDE应该为您提供“自动重新格式化代码”功能。您的React项目应该包含. eslintrc.js和. prettierrc.js文件。他们配置林挺(红线)和代码风格。您应该可以通过按热键来应用这些梯框:</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/0fca16391636ac15ae249acb8e0471e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*jiIU0WZ3VOLuy1dFe9Az4w.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Auto reformat feature</figcaption></figure><h1 id="2b5c" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">2.切勿手动导入模块</h1><p id="8cff" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">您的IDE应该为您提供“自动导入”功能。从不键入"../../../"手动输入，或者手动输入/删除导入来浪费您的时间。</p><p id="a034" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">检查“自动导入”功能的运行情况:</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/e797397b522f49d3c303e7a0347bfcf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*eapGXA5jNR4V9Bu1pPp4Dw.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Add all missing imports feature</figcaption></figure><h1 id="c7ce" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">3.像专业人士一样跳来跳去</h1><p id="83b9" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">如果你用小的可重用部件来构建你的项目，你将会有许多小的可重用文件和组件。你很快就会明白，用“鼠标和打开的标签”导航和“在文件列表中选择一个文件”变得几乎不可能。</p><p id="86f9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">检查这个微型移动应用程序的巨大文件结构:</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/07ac29fa011a40fde67f1071c65d78e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*PCxuY8zGDrJ6ar64_wTRxg.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The huge file structure of a React app</figcaption></figure><p id="2e5d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你知道试图在你的标签中找到正确的文件的痛苦吗？</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi qh"><img src="../Images/d4abf1315150a25d6198ea36475298c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JQfsu1xFcxmQ17zU0_BFg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">10 tabs open, where is the file I’m looking for?</figcaption></figure><p id="1aa9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您的IDE应该为您提供这些有用的工具:</p><ul class=""><li id="e6a5" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">通过搜索字符串跳转到文件</li><li id="7415" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">通过搜索字符串跳转到组件</li><li id="f7d8" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">跳转到以前打开的文件</li><li id="8978" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">跳转到光标下的组件定义</li><li id="82cb" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">跳转到组件使用</li></ul><p id="47e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">研究你的IDE的热键。这会让你的开发者体验像黄油一样顺滑。</p><h1 id="5d8d" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">4.使用林挺ESLint</h1><p id="ae8f" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">每个React开发者都知道错误的useEffect/Memo/Callback hook依赖的痛苦。他们总是很难发现错误:</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi qi"><img src="../Images/30e6a12cd473f06c54e38d71f6177c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVg5aFSVvf6VYDhosHdaqw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Finding these errors without linting is very hard</figcaption></figure><p id="d934" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">ESLint允许毫不费力地缓存这些错误。</p><blockquote class="kx"><p id="655a" class="ky kz in bd la lb lc ld le lf lg kw dk translated">eslint和typescript等开发工具有助于在大型团队中维护代码库。一个好的开发人员知道如何编码。一个优秀的开发人员知道如何在团队中工作。</p><p id="717a" class="ky kz in bd la lb lc ld le lf lg kw dk translated">— <a class="lh li ep" href="https://medium.com/u/97cb4df60473?source=post_page-----ca2e47d1bf97--------------------------------" rel="noopener" target="_blank">罗曼·阮</a>，<a class="ae lj" href="https://blog.usejournal.com/architecting-your-react-application-5af9cd65a891" rel="noopener ugc nofollow" target="_blank">设计您的React应用程序。需要注意的发展和商业前景</a></p></blockquote><p id="87fb" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk or km kn ko os kq kr ks ot ku kv kw ig bi translated">所有这些功能在Webstorm IDE中都可以使用。我推荐你使用Webstorm进行TypeScript React开发。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="454d" class="lk ll in bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated">结论:制作可重复使用的积木的艺术</h1><blockquote class="kx"><p id="b417" class="ky kz in bd la lb lc ld le lf lg kw dk translated">成为快速开发人员的艺术是编写<strong class="ak">可重用</strong>构件的艺术。</p></blockquote><p id="8872" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk or km kn ko os kq kr ks ot ku kv kw ig bi translated">要想快速，您需要:</p><ul class=""><li id="605d" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">将业务逻辑与视图逻辑分开</li><li id="4efc" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">使用TypeScript会遇到较少的错误</li><li id="d170" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">使用类型脚本启用强大的IDE功能:林挺、名称重构、自动完成</li><li id="f519" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">在为快速架构设计编写代码之前定义类型脚本类型</li><li id="1dcb" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">将你的代码分成许多小的可重复使用的文件以减少混乱</li><li id="79b5" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">要求您的IDE格式化代码并导入模块</li><li id="3c33" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">使用热键在文件间跳转</li><li id="c083" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">练习重构</li></ul><p id="bc82" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们已经成功重构了我们的<browsers/>组件。检查最初的浏览器组件:这是一个巨大的、难以理解的整体。像这样的代码感觉很重，会降低我们的速度。</p><p id="9c71" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看着这个轻如鸿毛的美女:</p><figure class="oe of og oh gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8b79" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们制作了一个易于理解的component + extracted 2个非常方便的高度可重用的部分:</p><ul class=""><li id="4d26" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">useFetch()</li><li id="f2d4" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated"><UIFriendlyList/></li></ul><p id="51cd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以在应用程序的不同地方使用这些部件，甚至可以在不同的应用程序中使用。这肯定会加快我们的开发过程。</p><h1 id="ad06" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv ok lx ly lz ol mb mc md om mf mg mh bi translated">摆弄文章中的代码</h1><p id="164d" class="pw-post-body-paragraph jz ka in kb b kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw ig bi translated">检查Codesandbox游戏中的<a class="ae lj" href="https://codesandbox.io/s/browsers-refactor-00x9b" rel="noopener ugc nofollow" target="_blank">最终结果</a>以进行游戏并了解更多信息。这段代码是用React编写的，与本文中的React原生代码有所不同。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="ad59" class="lk ll in bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated">下一步是什么</h1><ul class=""><li id="c129" class="mn mo in kb b kc mi kg mj kk on ko oo ks op kw mu mv mw mx bi translated">大量阅读</li><li id="bd2a" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">多多练习</li><li id="ec36" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">提问。<strong class="kb io">特别是</strong>在这篇文章下的评论区</li></ul><p id="10e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">最后也是最重要的:</strong></p><ul class=""><li id="594c" class="mn mo in kb b kc kd kg kh kk np ko nq ks nr kw mu mv mw mx bi translated">自动测试React组件</li><li id="9088" class="mn mo in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">实践TDD</li></ul><p id="8a3a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">测试部分跳进去会觉得很混乱，但是会让你的生活甜得像棒棒糖。查看伊恩·威尔逊的这篇文章，这是开始你的测试之旅的好地方:</p><div class="ph pi gp gr pj pk"><a href="https://medium.com/free-code-camp/how-to-build-sturdy-react-apps-with-tdd-and-the-react-testing-library-47ad3c5c8e47" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd io gy z fp pp fr fs pq fu fw im bi translated">如何用TDD和React测试库构建健壮的React应用</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">当我开始学习React时，有一件事让我很纠结，那就是用一种既有用又…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">medium.com</p></div></div><div class="pt l"><div class="qj l pv pw px pt py jt pk"/></div></div></a></div></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="975c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">每天训练你的手艺，假以时日，你会成为大师。</p><p id="e7fd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">祝你好运，玩得开心！</p></div></div>    
</body>
</html>