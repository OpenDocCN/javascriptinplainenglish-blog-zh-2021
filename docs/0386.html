<html>
<head>
<title>Let’s Build a MERN Stack E-Commerce Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们建立一个MERN堆栈电子商务网络应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-an-e-commerce-website-with-mern-stack-part-2-designing-the-models-e231b2454aba?source=collection_archive---------2-----------------------#2021-01-23">https://javascript.plainenglish.io/build-an-e-commerce-website-with-mern-stack-part-2-designing-the-models-e231b2454aba?source=collection_archive---------2-----------------------#2021-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8158" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分:设计模型</h2></div><h2 id="79ad" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在第二部分中，我们将使用Mongoose设计所有需要的模型，通过我们的Express应用程序连接到MongoDB数据库。</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/ed190bc13c1e058e6f7ab3802d4efdb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U3ivvpxqXy-fnXBl"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@robertocortese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roberto Cortese</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="755b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">朋友们好！这是我们最近开始的MERN堆栈系列的第二部分。在第一部分，我们都学习了如何建立项目，并对项目中要用到的各种东西进行了解释。</p><p id="6f0a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果你还没有读第一部分，这里有第一部分的链接</p><div class="ml mm gp gr mn mo"><a href="https://shubhamstudent5.medium.com/build-an-e-commerce-website-with-mern-stack-part-1-setting-up-the-project-eecd710e2696" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">用MERN堆栈构建一个电子商务网站——第1部分(设置项目)</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">让我们使用MERN堆栈(MongoDB，Express，React和Node)建立一个简单的电子商务网站，用户可以在其中添加项目…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">shubhamstudent5.medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ll mo"/></div></div></a></div></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="4f40" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在第二部分中，我们将开始为我们的应用程序构建模型。我们使用<strong class="lu ir"> MongoDB </strong>作为数据库来存储我们所有的数据。我们将使用<strong class="lu ir">mongose</strong>连接到MongoDB数据库，这将使我们的工作更容易构建数据库模式，然后基于该模式构建模型。</p><p id="4aae" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">为了保持简洁，我们将在根文件夹中创建一个名为<strong class="lu ir"> <em class="nk"> models </em> </strong>的新文件夹。</p><p id="8bac" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">然后，我们将在其中创建四个文件，分别代表我们的四个模型— <strong class="lu ir">用户、商品、购物车</strong>和<strong class="lu ir">订单。</strong></p><blockquote class="nl nm nn"><p id="c4f2" class="ls lt nk lu b lv lw jr lx ly lz ju ma no mb mc md np me mf mg nq mh mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>我们不需要给我们的模式一个惟一的id参数，因为一旦我们在其中保存了任何文档，MongoDB就会自动提供一个惟一的ID。</p></blockquote><p id="bf17" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，我们现在将逐一研究每个模型的细节。先说<strong class="lu ir"> <em class="nk">用户</em> </strong>型号。</p><h2 id="47a9" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">用户模型</h2><p id="288d" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">因此，我们现在将创建我们的第一个模型——<strong class="lu ir"><em class="nk">用户</em> </strong>模型。这将定义存储用户数据的模型。我们将首先在之前创建的<strong class="lu ir"><em class="nk">‘models’</em></strong>文件夹中创建一个<strong class="lu ir"> User.js </strong>文件。</p><p id="efe6" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，我们将首先在我们的文件中要求<em class="nk">mongose</em>。我们还需要一个<strong class="lu ir"> <em class="nk"> isEmail </em> </strong>验证器，它来自我们在第一部分中安装的<strong class="lu ir">【验证器】</strong>依赖项。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="889d" class="ob kg iq nx b be oc od l oe of">const mongoose = require('mongoose');<br/>const Schema = mongoose.Schema;<br/>const { isEmail } = require('validator');</span></pre><p id="6369" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">然后我们继续从我们之前定义的<strong class="lu ir">模式</strong>中创建我们的<strong class="lu ir"> <em class="nk">用户模式</em> </strong>。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="6330" class="ob kg iq nx b be oc od l oe of">const UserSchema = new Schema({<br/>    name: {<br/>        type: String,<br/>        required: true<br/>    },<br/>    email: {<br/>        type: String,<br/>        required: [true,'Please enter an email'],<br/>        unique: true,<br/>        lowercase: true,<br/>        validate: [isEmail, 'Please enter a valid email']<br/>    },<br/>    password: {<br/>        type: String,<br/>        required: [true, 'Please enter a valid password'],<br/>        minlength: [6, 'Minimum password length must be 6 characters']<br/>    },<br/>    register_date: {<br/>        type: Date,<br/>        default: Date.now<br/>    }<br/>})</span></pre><p id="8c92" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">所以，在你看到了构建<em class="nk">用户模式的代码之后，</em>我们现在可以通过把它分解成小部分来讨论它，并且理解每件事是如何有意义的。</p><p id="0918" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">该模式中有各种字段，每个字段都有自己的类型和属性。这些是我们应用程序中的每个用户都会有的参数或字段。所以，让我们一个接一个地看看每一个领域</p><ol class=""><li id="c4be" class="og oh iq lu b lv lw ly lz ko oi ks oj kw ok mk ol om on oo bi translated"><strong class="lu ir"> name </strong> —它将包含使用我们应用程序的用户的姓名。这个字段将是字符串数据类型，因为它必须存储用户名。这是一个必填字段，在我们的应用程序中，每个用户都应该有一个名字。</li><li id="2436" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir">电子邮件</strong> —它将包含在我们网站注册的用户的电子邮件。它将再次成为字符串数据类型。我们希望电子邮件是独一无二的，所以我们把独一无二变成了真实。我们还想用小写存储电子邮件，所以我们把它设为true。当然，电子邮件是必填字段，我们还附加了一个自定义错误消息，以便在没有提供电子邮件时触发。此外，我们检查提供的电子邮件地址是否实际上是电子邮件格式；为此，我们使用了之前需要的<strong class="lu ir"> <em class="nk"> </em> </strong> <em class="nk"> isEmail </em>验证器，并附上了一条定制的错误消息。</li><li id="f531" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir">密码</strong> —该字段用于存储用户的密码。它将是字符串数据类型，并且是每个用户的必填字段。我们还设置了最小长度限制，因此不允许密码短于该长度。我们也可以设置最大长度，但我们不在这里这样做。</li><li id="1821" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir"> register_date </strong> —该字段存储用户首次在我们的网站上注册的日期。它默认为当前日期，因此用户不必明确提及。</li></ol><blockquote class="nl nm nn"><p id="ed4a" class="ls lt nk lu b lv lw jr lx ly lz ju ma no mb mc md np me mf mg nq mh mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>我们不会以纯文本格式存储密码，因为如果有人入侵我们的数据库，密码很容易被破解。因此，为了安全起见，我们将使用<strong class="lu ir"> bcrypt </strong>库来散列我们的密码，然后将散列后的密码保存在数据库中。我们将在控制器文件中进行哈希运算，而不是在模型文件中，但我仍然在这里提到了这一点，以便您以更好的方式理解它。当我们实际散列它时，我们将进入细节。</p></blockquote><p id="6196" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">现在，既然我们已经构建了我们的<em class="nk">用户模式</em>，我们可以基于我们创建的模式构建<strong class="lu ir">用户</strong>模型。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="085e" class="ob kg iq nx b be oc od l oe of">module.exports = User = mongoose.model('user',UserSchema);</span></pre><p id="0277" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我们导出创建的<em class="nk">用户</em>模型，我们将这个集合称为<em class="nk">‘用户’</em>。因此，在数据库中，MongoDB将对其进行复数化，并将集合名称保存为<strong class="lu ir"><em class="nk">‘users’。</em>T29】</strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">User Model</figcaption></figure><h2 id="f02d" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">项目模型</h2><p id="b930" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">我们需要创建的下一个模型是<em class="nk">项目</em>模型。在这里，我们将为商店中用户将要购买的商品设计模式。我们将保持我们的项目模式简单，不会包括<em class="nk">图像。你当然可以添加产品图片或任何你想添加的额外字段。</em></p><p id="b896" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">但是对于这个系列，我们将只有这五个字段— <strong class="lu ir">标题、描述、类别、价格和日期_添加</strong>。</p><p id="0e51" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我们将在models文件夹内名为<strong class="lu ir"> <em class="nk"> Item.js </em> </strong>的文件中构建我们的<em class="nk">项</em>模型。我们首先需要<em class="nk">mongose</em>并创建模式对象。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="0541" class="ob kg iq nx b be oc od l oe of">const mongoose = require('mongoose');<br/>const Schema = mongoose.Schema;</span></pre><p id="98bc" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">接下来，我们将开始设计我们的<strong class="lu ir">项目模式</strong>。它有五个字段，将建立在我们之前定义的模式之上。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="0b75" class="ob kg iq nx b be oc od l oe of">const ItemSchema = new Schema({<br/>    title: {<br/>        type: String,<br/>        required: true<br/>    },<br/>    description: {<br/>        type: String,<br/>        required: true<br/>    },<br/>    category:{<br/>        type: String,<br/>        required: true<br/>    },<br/>    price: {<br/>        type: Number,<br/>        required: true<br/>    },<br/>    date_added: {<br/>        type: Date,<br/>        default: Date.now<br/>    },<br/>});</span></pre><p id="bd4d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">这个模式中有五个字段，每个字段都有自己的类型和属性。这些将是我们的应用程序中的每一项都会有的参数或字段。所以，让我们一个接一个地看看每一个领域</p><ol class=""><li id="86cf" class="og oh iq lu b lv lw ly lz ko oi ks oj kw ok mk ol om on oo bi translated"><strong class="lu ir">标题</strong> —存储我们商店中商品或产品的标题。它属于字符串数据类型，并且是必填字段。</li><li id="0b48" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir">描述</strong> —存储物品或产品的详细信息或描述。它也是字符串数据类型，也是必填字段。</li><li id="8b50" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir">类别</strong> —它存储我们商店中商品或产品的类别。它表示一个项目属于哪个类别。它也是字符串数据类型，并且是必填字段。</li><li id="3d87" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir">价格</strong> —它存储我们商店中产品或物品的价格。它是数字数据类型，因为价格将以数字表示。这是一个必填字段，因为我们需要每个产品都有一个价格。</li><li id="8665" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir"> date_added </strong> —存储商品或产品添加到我们商店的日期。它是自动设置的，因为我们将当前日期作为默认值。</li></ol><p id="57ff" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">现在，既然我们已经构建了我们的<em class="nk"> ItemSchema </em>，我们可以基于我们创建的模式构建<strong class="lu ir"> Item </strong>模型。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="086a" class="ob kg iq nx b be oc od l oe of">module.exports = Item = mongoose.model('item',ItemSchema);</span></pre><p id="5a82" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我们导出创建的<em class="nk">项目</em>模型，我们将这个集合称为'<em class="nk">项目'</em>。因此，在数据库中，MongoDB将对其进行复数化，并将集合名称保存为<strong class="lu ir"><em class="nk">‘items’。</em> </strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Item Model</figcaption></figure><h2 id="0715" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">推车型号</strong></h2><p id="3ed0" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">我们将构建的下一个模型是购物车模型。这是我们在web应用程序中存储任何用户购物车的模型。购物车包含用户添加到购物车中的所有商品。</p><p id="984e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">因此，我们的<strong class="lu ir"> <em class="nk"> CartSchema </em> </strong>将包含以下内容——userId、items和总账单。</p><p id="3401" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我们将在models文件夹内名为<strong class="lu ir"> <em class="nk"> Cart.js </em> </strong>的文件中构建我们的<em class="nk"> Cart </em>模型。我们首先需要<em class="nk">mongose</em>并创建模式对象。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="82c8" class="ob kg iq nx b be oc od l oe of">const mongoose = require('mongoose');<br/>const Schema = mongoose.Schema;</span></pre><p id="475a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">接下来，我们将开始设计我们的<strong class="lu ir"> CartSchema </strong>。它有三个字段，将建立在我们之前定义的模式之上。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="2c35" class="ob kg iq nx b be oc od l oe of">const CartSchema = new Schema({<br/>    userId: {<br/>        type: String,<br/>    },<br/>    items: [{<br/>        productId: {<br/>            type: String,<br/>        },<br/>        name: String,<br/>        quantity: {<br/>            type: Number,<br/>            required: true,<br/>            min: [1, 'Quantity can not be less then 1.'],<br/>            deafult: 1<br/>        },<br/>        price: Number<br/>    }],<br/>    bill: {<br/>        type: Number,<br/>        required: true,<br/>        default: 0<br/>    }<br/>});</span></pre><p id="8382" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">这个模式有三个主字段和四个子字段(在items字段的内部)，每个字段都有自己的类型和属性。这些将是我们的应用程序中的每一项都会有的参数或字段。所以，让我们一个接一个地看看每一个领域</p><ol class=""><li id="7f21" class="og oh iq lu b lv lw ly lz ko oi ks oj kw ok mk ol om on oo bi translated"><strong class="lu ir">用户标识</strong> —存储购物车所有者用户的唯一标识，即登录并向购物车添加物品的用户。我们将存储这些信息，以便为该特定用户识别正确的购物车。</li><li id="3679" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir">项目</strong>-该字段包含用户添加到其购物车中的所有项目。它将有各种子字段，如<strong class="lu ir">产品标识</strong> <em class="nk"> </em>(添加到购物车中的产品或物品的唯一标识)、<strong class="lu ir">名称<em class="nk"> </em> </strong>(添加的物品的名称)、<strong class="lu ir">数量</strong>(该物品在购物车中的添加数量，默认为1，最小数量也只能是一个)和<strong class="lu ir">价格</strong>(添加到购物车中的物品的成本)。</li><li id="8f07" class="og oh iq lu b lv op ly oq ko or ks os kw ot mk ol om on oo bi translated"><strong class="lu ir">清单</strong> —该字段存储购物车中所有商品的总成本。它属于数字数据类型，并且是必填字段，当购物车为空时，默认值为0。</li></ol><p id="fd8f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">现在，由于我们已经构建了<em class="nk"> CartSchema </em>了，我们可以基于我们创建的模式构建<strong class="lu ir"> Cart </strong>模型。</p><pre class="lc ld le lf gt nw nx ny bn nz oa bi"><span id="e37f" class="ob kg iq nx b be oc od l oe of">module.exports = Cart = mongoose.model('cart',CartSchema);</span></pre><p id="bead" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">我们导出创建的<em class="nk"> Cart </em>模型，我们将这个集合称为<em class="nk">【Cart】</em>。因此，在数据库中，MongoDB将对其进行复数化，并将集合名称保存为<strong class="lu ir"><em class="nk">“cards”。</em> </strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Cart Model</figcaption></figure><h2 id="41d3" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">订单模型</h2><p id="c20e" class="pw-post-body-paragraph ls lt iq lu b lv nr jr lx ly ns ju ma ko nt mc md ks nu mf mg kw nv mi mj mk ij bi translated">订单模型由我们应用程序中的所有用户订单组成。它的设计方式与cart模型非常相似，所有字段都与Cart模型相同，因为Cart项目将成为订单。</p><blockquote class="nl nm nn"><p id="1826" class="ls lt nk lu b lv lw jr lx ly lz ju ma no mb mc md np me mf mg nq mh mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>用户结账付款后，购物车中的所有商品都会转化为订单，购物车将被清空。</p></blockquote><p id="afcc" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">不过，订单模型有一个额外的字段。这个额外的字段是<em class="nk">添加的</em>字段，它将自动存储订单创建时的日期。</p><p id="7ab1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">由于所有字段都与Cart模型相同，因此我们不再赘述了，因为这是多余的。</p><p id="1417" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">下面是Order Model文件的代码，我们将在名为<strong class="lu ir"> Order.js </strong>的文件中创建该文件，该文件位于<em class="nk"> models </em>文件夹中。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Order Model</figcaption></figure><p id="e758" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">所以，这就是我们应用程序中的所有模型。我们现在将结束第二部分，因为我们已经完成了在应用程序中使用的所有模型的构建。</p><p id="2d52" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在下一部分，我们将处理路由和控制器。此外，我们将在下一部分处理一些定制的中间件功能。</p><div class="ml mm gp gr mn mo"><a rel="noopener  ugc nofollow" target="_blank" href="/lets-build-a-mern-stack-e-commerce-web-app-d619f3374d73"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">让我们构建一个MERN Stack电子商务网络应用程序</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">第3部分:构建身份验证和项目路由及控制器</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mx l"><div class="ow l mz na nb mx nc ll mo"/></div></div></a></div><p id="4edd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果你想访问这个项目的完整代码，请访问这个项目的<a class="ae lr" href="https://github.com/shubham1710/MERN-E-Commerce" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><p id="ada0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">希望你喜欢这部分教程。我希望你今天学到了新的有趣的东西。</p><p id="a506" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">如果你有任何建议或有任何疑问，请通过评论这篇文章让我知道。我很想得到你们所有人的反馈！</p><p id="47a2" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">完成本系列后，还有更多的文章可供阅读:</p><div class="ml mm gp gr mn mo"><a href="https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-overview-part-1-1f847d53753f" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">使用Django Rest框架构建博客网站——概述(第1部分)</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">让我们使用Django Rest框架构建一个简单的博客网站，以了解DRF和REST APIs是如何工作的，以及我们如何添加…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="ox l mz na nb mx nc ll mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a href="https://towardsdatascience.com/build-a-social-media-website-using-django-setup-the-project-part-1-6e1932c9f221" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">使用Django构建一个社交媒体网站——设置项目(第1部分)</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">在第一部分中，我们集中在设置我们的项目和安装所需的组件，并设置密码…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="oy l mz na nb mx nc ll mo"/></div></div></a></div></div></div>    
</body>
</html>