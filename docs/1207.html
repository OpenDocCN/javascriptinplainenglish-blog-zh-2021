<html>
<head>
<title>10 Entry Level React Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个入门级React面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-entry-level-react-interview-questions-5a8ea74e2130?source=collection_archive---------0-----------------------#2021-03-14">https://javascript.plainenglish.io/10-entry-level-react-interview-questions-5a8ea74e2130?source=collection_archive---------0-----------------------#2021-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0c636fb432749f94722f8cd6161e0fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xD06OCT91OUVOVzx2vzd5A.png"/></div></div></figure><p id="8b9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">面试是获得一份工作的直接途径，其方式比你想象的要多。你可能会问不止一种方法？是啊！面试不仅仅是让你展示你的技能和你知道的东西，也是一个很好的方式来看看你不知道什么，这个行业的人在要求什么，你应该更专注于什么。</p><p id="c982" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一部分，我将讨论5个React和5个JavaScript问题。</p><p id="3237" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我想给你10个问题和相对简短但全面的答案，供入门级开发者参考，我个人认为这是最重要的问题之一。还是那句话，这些只是我的看法，所以要有所保留。</p><h2 id="0abd" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">1.什么是虚拟DOM，它是如何工作的？</h2><p id="b602" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">到目前为止，这个问题被问得最多。我确实有一篇关于React如何工作的文章，其中我深入讨论了虚拟DOM<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/how-react-works-under-the-hood-277356c95e3d">https://JavaScript . plain English . io/how-React-works-under-the-hood-277356 c 95 E3 d</a>，但是为了更简短的回答，你可以这样说:虚拟DOM是DOM的虚拟表示，其中更新是轻量级的。它的工作方式是将其状态与更新前拍摄的虚拟DOM快照进行比较。比较新旧版本，React精确地计算出哪些对象发生了变化，并只更新那些对象。这个过程叫做diffing。</p><p id="14da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总而言之，下面是DOM更新时React中发生的步骤:</p><ol class=""><li id="2a17" class="ls lt in jx b jy jz kc kd kg lu kk lv ko lw ks lx ly lz ma bi translated">它拍摄当前状态的快照。</li><li id="5d30" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">虚拟DOM得到更新</li><li id="fe15" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">它将当前状态与之前拍摄的快照进行比较</li><li id="9fa5" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">React计算出哪些对象发生了变化</li><li id="997d" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">反应过来变化的<em class="mg">只有那个</em>物体</li><li id="0a84" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">真正的DOM现在得到了更新。</li></ol><h2 id="32d0" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">2.说出一些最重要的生命周期挂钩及其目的。(这是新React挂钩的替代方案)</h2><p id="ac7e" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">让我们按顺序概括一下。我将突出我认为最重要和最常用的。</p><p id="793b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">关于渲染:</strong></p><ol class=""><li id="d618" class="ls lt in jx b jy jz kc kd kg lu kk lv ko lw ks lx ly lz ma bi translated">构造器</li><li id="a4c2" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">静态getDerivedStateFromProps—<br/>use effect(()=&gt;{ }，[props1，props2])</li><li id="31bd" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">提供；给予</li><li id="bf90" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated"><em class="mg">componentidmount—use effect(()=&gt;{ }，[]) </em></li></ol><p id="60e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">重新渲染时:</strong></p><ol class=""><li id="e874" class="ls lt in jx b jy jz kc kd kg lu kk lv ko lw ks lx ly lz ma bi translated">静态getDerivedStateFromProps—<br/>use effect(()=&gt;{ }，[props1，props2])</li><li id="64b5" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">shouldComponentUpdate()—use memo()</li><li id="f24a" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">提供；给予</li><li id="9aea" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">getsnapshotbeforupdate()-自定义挂钩以保持以前的状态</li><li id="1c0f" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">componentDidUpdate—use effect(()= &gt; { })</li></ol><p id="8a0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">卸载:</strong></p><p id="ad52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ComponentWillUnmount—use effect(()= &gt; return { }，[])</p><h2 id="746c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">3.为什么我们在React中使用箭头函数，它们能解决什么问题？</h2><p id="c485" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><em class="mg">这个</em>关键字在箭头函数中的工作方式不同。它们不绑定自己的<em class="mg"> this，</em>相反，它们从父作用域继承一个，这被称为“词法作用域”。如果我们不使用箭头函数，我们需要将这个绑定到父节点，这通常是在构造函数中完成的。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7b3a" class="kt ku in mm b gy mq mr l ms mt">import React from 'react';<br/>class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.clickHandler = this.clickHandler.bind(this);<br/>  }<br/><br/>  clickHandler() {<br/>    console.log( this )<br/>  }<br/><br/>  render() {<br/>    return &lt;button onClick={this.clickHandler}&gt;Click Me&lt;/button&gt;<br/>  }<br/>}</span><span id="67a2" class="kt ku in mm b gy mu mr l ms mt">import React from 'react';<br/>class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>  }<br/><br/>  clickHandler = () =&gt; {<br/>    console.log( this )<br/>  }<br/><br/>  render() {<br/>    return &lt;button onClick={this.clickHandler}&gt;Click Me&lt;/button&gt;<br/>  }<br/>}</span></pre><p id="f5b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用箭头函数可读性更强，值得推荐。</p><h2 id="51e3" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">4.React中的键是什么，我们为什么需要它们？</h2><p id="d3b3" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">简而言之，密钥用于React for diffing算法。在键的帮助下，React可以判断哪个DOM节点发生了变化，并只更新那个节点。当映射数组时，它们是必不可少的。<br/> <code class="fe mv mw mx mm b">&lt;ul&gt;<br/> &lt;li&gt;New York&lt;/li&gt;<br/> &lt;li&gt;London&lt;/li&gt;<br/>&lt;/ul&gt;</code></p><p id="80d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mv mw mx mm b">&lt;ul&gt;<br/> &lt;li&gt;New York&lt;/li&gt;<br/> &lt;li&gt;London&lt;/li&gt;<br/> &lt;li&gt;Tbilisi&lt;/li&gt;<br/>&lt;/ul&gt;</code></p><p id="0ad7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，因为我们在数组的末尾插入了一个新元素，所以它会很好地工作，因为React只是遍历列表，并在发现差异时生成一个变异。请记住，React在更新之前会拍摄快照，因此它会查看以前的列表。</p><p id="24b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果我们在数组的开头插入一个新元素会发生什么呢？<br/> <code class="fe mv mw mx mm b">&lt;ul&gt;<br/> &lt;li&gt;New York&lt;/li&gt;<br/> &lt;li&gt;London&lt;/li&gt;<br/>&lt;/ul&gt;</code></p><p id="7d95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mv mw mx mm b">&lt;ul&gt;<br/> &lt;li&gt;Tbilisi&lt;/li&gt;<br/> &lt;li&gt;New York&lt;/li&gt;<br/> &lt;li&gt;London&lt;/li&gt;<br/>&lt;/ul&gt;</code></p><p id="30b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React将在开头插入城市Tbilisi，但它还会变异其他所有元素，因为它不知道它们是相同的。</p><p id="d192" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是钥匙来救援的地方。使用键，React可以将原始列表与新列表进行匹配，并且只更新必要的元素。<br/>这就是为什么总是建议对键使用唯一的id。</p><h2 id="5488" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">5.为什么应该使用React而不是真正的JavaScript框架，比如Angular？</h2><p id="7be4" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">与Angular或Vue不同，React只是一个库，当然有它的利弊。关注优点:</p><p id="ef02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React更加轻量级，允许创建动态应用程序。此外，由于React基本上是带有一些JSX的JS，因此更容易上手。<br/>使用VDOM，使web应用程序执行速度更快。</p><p id="4133" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React使用单向数据流，这意味着数据从上到下流动。这使得调试错误更加容易。</p><p id="6dad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">chrome有许多扩展，使得React应用程序的工作和调试更加容易。下面是我最喜欢的三个:组件、Redux和React上下文。还有其他的，但是这些是我在几乎每个应用程序中使用的主要工具。</p><p id="bf69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为没有JavaScript就没有React，所以你肯定会在面试中遇到一些JavaScript问题。以下是其中的一些。</p><h2 id="2295" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">6.JavaScript中有哪些不同的数据类型？</h2><p id="41a8" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><strong class="jx io">原始数据类型:</strong> <br/> undefined —未定义类型<br/> Boolean —布尔类型<br/> Number —数字类型<br/> String —字符串类型<br/>BigIng—bigint类型<br/> Symbol —符号类型<br/> null —对象类型</p><p id="8416" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有我们应该提到的非原始数据类型，如对象、数组、映射、集合。</p><h2 id="b357" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">7.var和let有什么区别？</h2><p id="e2c4" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><code class="fe mv mw mx mm b">var</code>大多用在ES6推出之前。var和let的主要区别在于作用域规则。由<code class="fe mv mw mx mm b">var</code>关键字声明的变量的作用域是直接函数体(因此是函数作用域),而<code class="fe mv mw mx mm b">let</code>变量的作用域是直接<em class="mg">包围由<code class="fe mv mw mx mm b">{ }</code>表示的</em>块(因此是块作用域)。</p><p id="c4a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将<code class="fe mv mw mx mm b">let</code>关键字引入到语言中的原因是函数作用域令人困惑，并且是JavaScript中错误的主要来源之一。</p><h2 id="1543" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">8.“==”和“===”有什么区别？</h2><p id="4ff8" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">==只比较值，as ===也比较值和类型。</p><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/9bd26918d76e283e5f2f5d559d3a2b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*QJaTG0pii7O80VADp19N8A.png"/></div></figure><h2 id="7ee3" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">9.<strong class="ak">空</strong>和<strong class="ak">未定义</strong>有什么区别？</h2><p id="be43" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">它们都代表空值，但区别在于当你定义了一个变量但没有给它赋值时，它会自动变成未定义的，但对于null，你必须给它赋值。另一个区别是，正如我们在数据类型问题中讨论的，未定义的类型是未定义的，而空的类型是对象。</p><p id="3c46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回到我们的“==”和“===”答案，我们肯定知道，因为null和undefined是不同的类型，它们严格来说并不相等，但是让你吃惊的是，它们大致相等。</p><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/5b41017a02fc9226c9720d94fdbabfc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*EUuydR3Cuf9D6XyXh8Em_w.png"/></div></figure><h2 id="2917" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">10.异步是什么意思？</h2><p id="a3b7" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">正常情况下，一个给定程序的代码直接运行，一次只发生一件事。如果一个函数依赖于另一个函数的结果，它必须等待另一个函数完成并返回，在此之前，从用户的角度来看，整个程序实际上是停止的。</p><p id="e453" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步技术非常有用，尤其是在web编程中。当web应用程序在浏览器中运行时，它会执行大量代码，而不会将控制权返回给浏览器，浏览器可能看起来像是被冻结了。这叫做<strong class="jx io">阻挡</strong>；浏览器被阻止继续处理用户输入和执行其他任务，直到web应用程序返回对处理器的控制。</p><p id="cf40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步通过不等待其他操作完成来解决这个问题。想象一下:你正在做意大利面。你把水放在炉子上，等着水开始沸腾。这并不意味着在那之前你不能做任何事，对吗？你可以开始准备调料，摆放盘子，或者做任何你想做的事情。水开始沸腾后，你回去把意大利面放进去。这就是异步函数的工作方式。</p></div></div>    
</body>
</html>