<html>
<head>
<title>Building A Static Site Generator With Deno</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Deno构建静态站点生成器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-static-site-generator-with-deno-61132446353d?source=collection_archive---------5-----------------------#2021-02-10">https://javascript.plainenglish.io/building-a-static-site-generator-with-deno-61132446353d?source=collection_archive---------5-----------------------#2021-02-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/87648bfbc38fce49464072d2628d0429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*lm5fyLvxd5VKjfbd.png"/></div></figure><div class=""/><div class=""><h2 id="6acf" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过Deno轻松使用TypeScript和Markdown来构建静态站点生成器</h2></div><p id="b26d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">构建静态web内容是绝对必要的。如果你在过去10年中的任何时候都积极参与web开发，你很可能会遇到静态站点生成器，如<a class="ae lf" href="https://jekyllrb.com/" rel="noopener ugc nofollow" target="_blank">杰基尔</a>或<a class="ae lf" href="https://www.gatsbyjs.com/" rel="noopener ugc nofollow" target="_blank">盖茨比</a>。甚至像<a class="ae lf" href="https://wordpress.com/" rel="noopener ugc nofollow" target="_blank"> Wordpress </a>这样的CMS系统也执行相当多的静态内容生成。</p><p id="42eb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">多亏了现代的JavaScript，你不必成为一个编程奇才来构建奇特的静态站点生成器。事实上，你可以用<em class="lg">很少的代码</em>完成很多事情。这就是我们在这篇博文中要做的事情，我们将使用一种叫做<strong class="kl iv"> Deno </strong>的令人惊叹的新技术。</p><p id="18bf" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">此外，我们将使用TypeScript，<strong class="kl iv">但是等等！本教程不需要预先的打字技能。如果你对JavaScript很熟悉，那就绝对没问题。事实上，如果您还没有接触过打字稿，您可以用它来尝试一下。</strong></p><h2 id="6b86" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">什么是德诺？</h2><p id="fb9b" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">关于<a class="ae lf" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl iv"> Deno </strong> </a>这里我就不赘述了，不过你可以把它想成<code class="fe mf mg mh mi b">Node.js</code>的精神继承者，也是node最初的创造者打造的。</p><p id="5e39" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这是一个安全的JavaScript运行时，支持类型脚本、代码格式化、测试、顶级异步和更多开箱即用的功能。</p><p id="0200" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe mf mg mh mi b">deno</code>和<code class="fe mf mg mh mi b">node</code>的一个巨大区别是没有包管理器。deno包不是在一个单独的文件中指定包或第三方依赖项，而是用基于url的导入语句在代码中指定<strong class="kl iv"/>，如下所示:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="620f" class="lh li iu mi b gy mr ms l mt mu">import { parse } from 'https://deno.land/std@0.85.0/datetime/mod.ts'</span></pre><p id="6ee8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">运行程序时，会检查、安装和缓存这些依赖项。</p><p id="33d6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">为了安全起见，当使用deno运行时，可以使用标志来确定脚本的文件权限和网络访问级别，如下所示:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="cbac" class="lh li iu mi b gy mr ms l mt mu">deno run --allow-read mod.ts</span></pre><h2 id="e770" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">装置</h2><p id="51b0" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">注意:如果你已经安装了deno，你可以跳过这一步。</p><p id="28f5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">要首次安装deno，请使用以下任一选项:</p><p id="9ce5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">MacOS或Linux (Shell)</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6b1d" class="lh li iu mi b gy mr ms l mt mu">curl -fsSL https://deno.land/x/install/install.sh | sh</span></pre><p id="503b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">苹果电脑(brew)</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="c7b8" class="lh li iu mi b gy mr ms l mt mu">brew install deno</span></pre><p id="d0cf" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">Windows操作系统</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="9975" class="lh li iu mi b gy mr ms l mt mu">iwr https://deno.land/x/install/install.ps1 -useb | iex</span></pre><p id="0047" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lg">注意:本教程的剩余部分将使用适用于MacOS/Linux的shell命令，但是所有的编码指令对于Windows都是一样的。</em></p><h2 id="2277" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">我们将会产生什么</h2><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/155450914c8670cbdf6809f222dbb6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mWK_JUzmf7Zndogv.gif"/></div></div></figure><p id="ee3f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们的目标是用TypeScript编写一个deno脚本，该脚本将单个<code class="fe mf mg mh mi b">.md</code>文件作为输入，并生成以下内容:</p><ul class=""><li id="20a3" class="na nb iu kl b km kn kp kq ks nc kw nd la ne le nf ng nh ni bi translated">带有导航栏、内容区和页脚的网站布局</li><li id="8416" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">遵循网站结构的文件夹和<code class="fe mf mg mh mi b">index.html</code>文件(1层深度)</li><li id="4e61" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">所有导航链接中的有效<code class="fe mf mg mh mi b">href</code>值</li><li id="eed7" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">在每个页面中链接的生成的样式表</li><li id="adc6" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">一个SVG表情图标，链接在每一页</li></ul><h2 id="667f" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">以编程方式思考网站</h2><p id="31c5" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">如果你还在学习你的网站基础知识，静态网站生成器是一个非常棒的项目，可以帮助你加强这些技能。一旦你完成这个，你会发现天空是无限的。构建自己的功能性CMS、自动生成的文档或自动化营销网站的维护不会太遥远。</p><h2 id="80b2" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">让我们来构建我们的Deno Markdown站点生成器</h2><p id="d97a" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated"><em class="lg">注意:这篇博文的所有源代码都可以在</em> <code class="fe mf mg mh mi b"><a class="ae lf" href="https://github.com/nafeu/deno-md-site" rel="noopener ugc nofollow" target="_blank"><em class="lg">github.com/nafeu/deno-md-site</em></a></code>获得</p><p id="e144" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">首先创建一个新的项目文件夹和<code class="fe mf mg mh mi b">main.ts</code>文件:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6796" class="lh li iu mi b gy mr ms l mt mu">mkdir deno-md-site<br/>cd deno-md-site<br/>touch main.ts</span></pre><p id="7f7c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在你选择的编辑器中打开<code class="fe mf mg mh mi b">main.ts</code>，现在，添加以下评论:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cc57" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这就是脚本的结构，因此很容易理解。我们将在各节之间跳转，更新常量，并在需要时添加依赖项。</p><h2 id="3206" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">步骤0。抓取CLI参数</h2><p id="ed58" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">当我们运行我们的脚本时，我们将提供一个<code class="fe mf mg mh mi b">.md</code>文件(文件名)的路径和一个构建我们网站的路径，要访问这些命令行参数，我们可以像这样使用<code class="fe mf mg mh mi b">Deno.args</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="9672" class="lh li iu mi b gy mr ms l mt mu">/* Step 0: Grab CLI arguments */<br/>const filename = Deno.args[FIRST_ITEM_INDEX];<br/>const buildPath = Deno.args[SECOND_ITEM_INDEX] || './build';</span></pre><p id="c2cd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">你会注意到我们在这里使用了两个常量，<code class="fe mf mg mh mi b">FIRST_ITEM_INDEX</code>和<code class="fe mf mg mh mi b">SECOND_ITEM_INDEX</code>，我们还没有声明它们，所以让我们先在常量部分这样做:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="e4dd" class="lh li iu mi b gy mr ms l mt mu">/* Section: Constants */<br/>const FIRST_ITEM_INDEX = 0;<br/>const SECOND_ITEM_INDEX = 1;</span></pre><p id="4be0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如果没有提供参数，我们希望记录一条消息通知用户，然后退出脚本，否则继续。我们可以通过添加以下内容来做到这一点:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="555a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，如果我们测试我们的脚本，我们应该看到以下内容:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="cc70" class="lh li iu mi b gy mr ms l mt mu">$ deno run main.ts<br/>Please specify .md file</span></pre><p id="c114" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">有了两个参数，我们得到:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="61b5" class="lh li iu mi b gy mr ms l mt mu">$ deno run main.ts testFile testDir<br/>Building site with 'testFile' into 'testDir'</span></pre><h2 id="6d87" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">定义我们的解决方案</h2><p id="ac74" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">在我们继续之前，有几件事我们需要考虑清楚。我们应该考虑哪些默认值？我们是否遗漏了一些依赖关系？如何用<code class="fe mf mg mh mi b">types</code>来明确我们要解决的问题？</p><p id="b415" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们将以下内容添加到我们的<strong class="kl iv">接口和全局</strong>部分:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="72e0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在这里，我们说，我们希望我们的脚本侧重于一个对象类型<code class="fe mf mg mh mi b"><strong class="kl iv">Page</strong></code>，它将有:</p><ul class=""><li id="0f8f" class="na nb iu kl b km kn kp kq ks nc kw nd la ne le nf ng nh ni bi translated">一个页面的字符串<code class="fe mf mg mh mi b">path</code>(想想网站中页面的链接，而不是文件系统中的路径)</li><li id="d388" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">一个字符串<code class="fe mf mg mh mi b">name</code>将会是我们页面的标题</li><li id="3edf" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">一个字符串<code class="fe mf mg mh mi b">html</code>，它将包含该页面的所有HTML</li></ul><p id="ac72" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们想考虑一个额外的对象<code class="fe mf mg mh mi b"><strong class="kl iv">Layout</strong></code>,它可以存储类似可重用页脚的信息。最后，我们定义了一个数组<code class="fe mf mg mh mi b">pages</code>，它存储了<code class="fe mf mg mh mi b"><strong class="kl iv">Page</strong></code>对象并实例化了我们的<strong class="kl iv">布局</strong>对象。</p><p id="f700" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在我们已经设置好了这些，我们将导入一些额外的依赖项。我们将从https://deno.land/x/markdown<a class="ae lf" href="https://deno.land/x/markdown" rel="noopener ugc nofollow" target="_blank">进口<code class="fe mf mg mh mi b">Marked</code>从https://deno.land/std</a><a class="ae lf" href="https://deno.land/std" rel="noopener ugc nofollow" target="_blank">进口<code class="fe mf mg mh mi b">ensureFileSync</code>。这些将帮助我们分别解析markdown以及创建/保存文件和目录路径。</a></p><p id="178c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们可以像这样导入它们:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="8a60" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">第一步。解析降价文件中的元数据和组件</h2><p id="fe9b" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">使用<code class="fe mf mg mh mi b">utf-8</code>编码选项创建一个新的<code class="fe mf mg mh mi b">TextDecoder</code>，并在运行脚本时读取我们指定的文件内容:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4511" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在我们可以访问我们的文件内容了，但是等等…这个文件里面到底有什么呢？让我们后退一步，决定如何使用markdown进行模板化。</p><h2 id="6c71" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">决定模板机制</h2><p id="79be" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">让我们保持简单的规则:</p><ul class=""><li id="b02e" class="na nb iu kl b km kn kp kq ks nc kw nd la ne le nf ng nh ni bi translated">使用<a class="ae lf" href="https://jekyllrb.com/docs/front-matter/" rel="noopener ugc nofollow" target="_blank"> YAML前台事件</a>来声明一个网站标题，可选的css样式和一个可选的表情符号图标</li><li id="18a4" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">使用三个加号(<code class="fe mf mg mh mi b">+++</code>)来分隔页面和布局组件</li><li id="bb6c" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">使用三个加号下面的格式<code class="fe mf mg mh mi b">/[PAGE_PATH]:[PAGE_TITLE]</code>分别表示页面的路径和标题</li><li id="4cfb" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">对页面路径/标题声明下的页面内容使用常规的降价</li><li id="2ab2" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">格式<code class="fe mf mg mh mi b">/home:Home</code>下的强制主页</li></ul><p id="4f79" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们可以用<code class="fe mf mg mh mi b">touch example.md</code>创建一个示例<code class="fe mf mg mh mi b">.md</code>文件，并用以下内容填充它:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="5d1f" class="lh li iu mi b gy mr ms l mt mu">---<br/>title: Deno Markdown Site<br/>styles: &gt;<br/>  body { color: #22a6b3; }<br/>favicon: 🦕<br/>---<br/>/home:Home<br/><br/># Home<br/><br/>Hello world!<br/><br/>+++<br/>/about:About<br/><br/># About<br/><br/>Built for learning.<br/><br/>+++<br/>layout:footer<br/><br/>deno-md-site</span></pre><p id="df8d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在在我们的<code class="fe mf mg mh mi b">main.ts</code>文件中，让我们拆分<code class="fe mf mg mh mi b">+++</code>上的文件内容，创建一个名为<code class="fe mf mg mh mi b">COMPONENT_DELIMITER</code>的常量:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="8d89" class="lh li iu mi b gy mr ms l mt mu">/* Section: Constants */<br/>const FIRST_ITEM_INDEX = 0;<br/>const SECOND_ITEM_INDEX = 1;<br/>const COMPONENT_DELIMITER = '+++';</span></pre><p id="bd2f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们将在<code class="fe mf mg mh mi b">Step 1</code>中的<code class="fe mf mg mh mi b">fileContent.split(...)</code>中使用该常量:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8de2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如果您临时添加<code class="fe mf mg mh mi b">console.log(components)</code>并使用<code class="fe mf mg mh mi b">deno run --allow-read main.ts example.md</code>运行脚本，您应该会看到以下内容:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b742" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们可以看到，这个数组中有<code class="fe mf mg mh mi b">3</code>个条目，带有前置内容(标题、样式和图标)的<strong class="kl iv">主页</strong>，关于页面的<strong class="kl iv">，以及<strong class="kl iv">页脚</strong>布局组件。这些商品都是有效的降价商品，这对我们来说非常重要。</strong></p><p id="8be5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们使用<code class="fe mf mg mh mi b">Marked</code>库从第一个项目中提取前面的内容:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7e6a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在这个实例中，<code class="fe mf mg mh mi b">Marked.parse(...)</code>接受有效的降价，进行一些处理，然后返回一些值。从这些值中，我们选择只解构一个名为<code class="fe mf mg mh mi b">meta</code>的字段，然后为了便于阅读，我们将该字段重命名为<code class="fe mf mg mh mi b">frontMatter</code>。</p><p id="741a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们添加<code class="fe mf mg mh mi b">console.log({ title, styles, favicon })</code>，然后使用以下代码运行我们的脚本:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="8029" class="lh li iu mi b gy mr ms l mt mu">deno run --allow-read --unstable main.ts example.md</span></pre><p id="b5b4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lg">注意:我们使用标志</em> <code class="fe mf mg mh mi b"><em class="lg">--allow-read</em></code> <em class="lg">来允许我们的文件系统和</em> <code class="fe mf mg mh mi b"><em class="lg">--unstable</em></code> <em class="lg">中的读操作，因为Deno的一些标准库还不是100%稳定。</em></p><p id="cb91" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们应该看到:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fb3e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">太好了！现在我们知道如何分割模板化的markdown文件并提取有用的信息。我们可以继续构建其余的页面。</p><h2 id="d627" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">第二步。从组件构建页面数据</h2><p id="53a6" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">让我们使用<code class="fe mf mg mh mi b">Marked</code>从我们的markdown生成HTML标记，将以下内容添加到<code class="fe mf mg mh mi b">Step 2</code>:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="11a8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe mf mg mh mi b">Marked.parse(...)</code>返回一个<code class="fe mf mg mh mi b">content</code>字段，它包含了我们在这里要解构的HTML。我们可以使用一个临时的<code class="fe mf mg mh mi b">console.log(...)</code>语句来查看它的结果。再次运行脚本，我们应该有:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e71f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">厉害！我们终于可以处理一些生成的标记了。对于每个组件，您可以看到第一个标记是一个段落标记，带有页面的路径和标题。我们用正则表达式把这些拉出来。</p><h2 id="28fa" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">使用简单的正则表达式提取标记</h2><p id="3760" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated"><em class="lg">注意:我不是正则表达式专家，我通常使用</em> <code class="fe mf mg mh mi b"><a class="ae lf" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"><em class="lg">regex101.com</em></a></code> <em class="lg">来帮助我构建模式。</em></p><p id="7dbd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">给定示例文本</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="0ac5" class="lh li iu mi b gy mr ms l mt mu">&lt;p&gt;/home:Home&lt;/p&gt;<br/>&lt;h1 id="home"&gt;Home&lt;/h1&gt;<br/>&lt;p&gt;Hello world!&lt;/p&gt;</span></pre><p id="c2f1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们想从第一个标签中拉出<code class="fe mf mg mh mi b">/home</code>和<code class="fe mf mg mh mi b">Home</code>。同样的，我们想把<code class="fe mf mg mh mi b">layout</code>和<code class="fe mf mg mh mi b">footer</code>从</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="311d" class="lh li iu mi b gy mr ms l mt mu">&lt;p&gt;layout:footer&lt;/p&gt;<br/>&lt;p&gt;deno-md-site&lt;/p&gt;</span></pre><p id="f09a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们可以把这些值看作是我们的<strong class="kl iv">组件类型值</strong>，为了提取它们，我们可以使用以下模式:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ddae" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这可以细分如下:</p><ul class=""><li id="346b" class="na nb iu kl b km kn kp kq ks nc kw nd la ne le nf ng nh ni bi translated">匹配<code class="fe mf mg mh mi b">&lt;tag&gt;[GROUP_1]\:[GROUP_2]&lt;/tag&gt;</code>的第一个实例</li><li id="06b3" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">&lt;\S&gt;</code>和<code class="fe mf mg mh mi b">&lt;\/\S&gt;</code>将匹配开始和结束标签</li><li id="4c1f" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">(.*?)\:(.*?)</code>将把<code class="fe mf mg mh mi b">&lt;tag&gt;</code>到<code class="fe mf mg mh mi b">:</code>再到<code class="fe mf mg mh mi b">:</code>到<code class="fe mf mg mh mi b">&lt;/tag&gt;</code>之间的任何一个分别匹配到<em class="lg">捕获组</em>中</li><li id="f61e" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">第一个<code class="fe mf mg mh mi b">(.*?)</code>捕获组给出一个<strong class="kl iv">组件类型</strong>，可以是</li><li id="3736" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">以<code class="fe mf mg mh mi b">/</code>开始的<strong class="kl iv">页面路径</strong></li><li id="dd7d" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">单词<strong class="kl iv">布局</strong>表示这是一个布局组件</li><li id="c988" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">第二个<code class="fe mf mg mh mi b">(.*?)</code>捕获组给出一个<strong class="kl iv">分量值</strong>，可以是</li><li id="4896" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><strong class="kl iv">页面标题</strong>为<strong class="kl iv">页面路径</strong></li><li id="6c49" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">特定的布局组件(即<strong class="kl iv">页脚</strong></li><li id="039b" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">\S</code>匹配任何非空白字符</li><li id="c255" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">使用<code class="fe mf mg mh mi b">g</code>全局模式标志意味着我们将匹配给定的全部文本</li></ul><p id="83c2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们将这个模式添加到我们的常数中</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="53a5" class="lh li iu mi b gy mr ms l mt mu">/* Section: Constants */<br/>const FIRST_ITEM_INDEX = 0;<br/>const SECOND_ITEM_INDEX = 1;<br/>const COMPONENT_DELIMITER = '+++';<br/>const COMPONENT_TYPE_PATTERN = /&lt;\S&gt;(.*?)\:(.*?)&lt;\/\S&gt;/g;</span></pre><p id="ce34" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">然后让我们更新<code class="fe mf mg mh mi b">Step 2</code>如下:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="52f6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这里我们使用html <code class="fe mf mg mh mi b">content</code>并使用<code class="fe mf mg mh mi b">content.matchAll(COMPONENT_TYPE_PATTERN)</code>来获取我们所有的<code class="fe mf mg mh mi b">matchedComponentType</code>信息。然后我们使用数组析构和<code class="fe mf mg mh mi b">const [, path, name]</code>来忽略第一项(这将是我们的完全匹配),然后将<code class="fe mf mg mh mi b">path</code>和<code class="fe mf mg mh mi b">name</code>从匹配的组中取出。</p><p id="5238" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">由于我们正在记录<code class="fe mf mg mh mi b">path</code>和<code class="fe mf mg mh mi b">name</code>，再次运行脚本应该会得到:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="be35" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，我们还需要每个组件的实际HTML内容，首先，让我们声明另一个模式，如下所示:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="dcd7" class="lh li iu mi b gy mr ms l mt mu">const HTML_CONTENT_PATTERN = /\n(.*)/gs;</span></pre><p id="f63b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这是一个简单得多的模式，可以分解如下:</p><ul class=""><li id="5b84" class="na nb iu kl b km kn kp kq ks nc kw nd la ne le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">\n(.*)</code>匹配第一个换行符(<code class="fe mf mg mh mi b">\n</code>)之后的所有内容</li><li id="61b8" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">(...)</code>创建一个捕获组</li><li id="9586" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">.*</code>意味着它将匹配任何字符序列</li><li id="f3a7" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">使用<code class="fe mf mg mh mi b">s</code>全局模式标志意味着一个换行符也在<code class="fe mf mg mh mi b">.</code>的范围内匹配</li><li id="95d6" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated">使用<code class="fe mf mg mh mi b">g</code>全局模式标志意味着我们将匹配给定的全部文本</li></ul><p id="09d8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">所以给定文本</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="c22d" class="lh li iu mi b gy mr ms l mt mu">&lt;p&gt;/home:Home&lt;/p&gt;<br/>&lt;h1 id="home"&gt;Home&lt;/h1&gt;<br/>&lt;p&gt;Hello world!&lt;/p&gt;</span></pre><p id="4ceb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们希望将我们的HTML页面内容提取为</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="b716" class="lh li iu mi b gy mr ms l mt mu">&lt;h1 id="home"&gt;Home&lt;/h1&gt;<br/>&lt;p&gt;Hello world!&lt;/p&gt;</span></pre><p id="4d86" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们用新的模式更新我们的常数</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="1f4c" class="lh li iu mi b gy mr ms l mt mu">/* Section: Constants */<br/>const FIRST_ITEM_INDEX = 0;<br/>const SECOND_ITEM_INDEX = 1;<br/>const COMPONENT_DELIMITER = '+++';<br/>const COMPONENT_TYPE_PATTERN = /&lt;\S&gt;(.*?)\:(.*?)&lt;\/\S&gt;/g;<br/>const HTML_CONTENT_PATTERN = /\n(.*)/gs;</span></pre><p id="05c3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">并更新<code class="fe mf mg mh mi b">Step 2</code>来使用新的模式提取HTML</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="38c6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们还将<code class="fe mf mg mh mi b">html</code>添加到日志语句中，运行脚本应该会给我们:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3e7e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">缺德！现在我们有了组件，我们可以将它们存储到适当的变量<code class="fe mf mg mh mi b">layout</code>和<code class="fe mf mg mh mi b">pages</code>中，我们在前面的<code class="fe mf mg mh mi b">Interfaces and Globals</code>部分已经声明了。将我们的最终更新添加到<code class="fe mf mg mh mi b">Step 2</code>:</p><p id="c641" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">声明另一个常量<code class="fe mf mg mh mi b">LAYOUT_PREFIX</code>并像这样添加它:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="d4d8" class="lh li iu mi b gy mr ms l mt mu">/* Section: Constants */<br/>const FIRST_ITEM_INDEX = 0;<br/>const SECOND_ITEM_INDEX = 1;<br/>const COMPONENT_DELIMITER = '+++';<br/>const COMPONENT_TYPE_PATTERN = /&lt;\S&gt;(.*?)\:(.*?)&lt;\/\S&gt;/g;<br/>const HTML_CONTENT_PATTERN = /\n(.*)/gs;<br/>const LAYOUT_PREFIX = 'layout';</span></pre><p id="5ab2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们将使用<code class="fe mf mg mh mi b">LAYOUT_PREFIX</code>来帮助我们决定返回的<code class="fe mf mg mh mi b">path</code>是否是布局组件，然后我们将组件值映射到<code class="fe mf mg mh mi b">layout</code>对象或者将整个组件推入<code class="fe mf mg mh mi b">pages</code>数组。</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3ed5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如果我们此时记录<code class="fe mf mg mh mi b">layout</code>和<code class="fe mf mg mh mi b">pages</code>并运行脚本，我们应该会看到:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3781" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">很可爱吧？</p><h2 id="f396" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">第三步。为HTML内容生成模板</h2><p id="5269" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">现在我们已经有了所有的内容，我们需要为我们的站点构建所有其他必要的HTML。我们将创建一系列模板助手函数:</p><p id="9503" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在我们开始之前，让我们再添加两个常量<code class="fe mf mg mh mi b">HOME_PATH</code>和<code class="fe mf mg mh mi b">STYLESHEET_PATH</code>:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6b31" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这些将帮助我们前进，让我们添加一个帮助器方法<code class="fe mf mg mh mi b">isHomePath</code>来帮助我们决定我们正在处理的组件是否是主页:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5af9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">然后让我们添加一个助手，它接受一个字符串<code class="fe mf mg mh mi b">path</code>，决定我们是否在主页上，然后返回一个样式表的最终路径(我们将很快生成):</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5ade" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在对于一些模板，让我们添加一个模板助手来构建一个作为svg的favicon:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a3ba" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">因为表情符号favicon是可选的，如果我们得到一个，我们渲染它，如果没有，我们默认为🦕。现在让我们为导航创建一个<code class="fe mf mg mh mi b">&lt;div&gt;</code>,如下所示:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7330" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这需要一个字符串<code class="fe mf mg mh mi b">currentPath</code>，循环遍历我们在<code class="fe mf mg mh mi b">pages</code>变量中的每个<code class="fe mf mg mh mi b">page</code>，并映射一组<code class="fe mf mg mh mi b">&lt;a&gt;</code>标签，如果<code class="fe mf mg mh mi b">currentPath</code>和页面<code class="fe mf mg mh mi b">path</code>匹配，其中将有一个额外的类<code class="fe mf mg mh mi b">selected</code>。<code class="fe mf mg mh mi b">href</code>也是由页面是否是主页决定的。这个方法构造了类似于:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="50d7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们也可以像这样快速声明一个页脚模板:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f3b5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这只是检查我们先前声明的<code class="fe mf mg mh mi b">layout</code>映射，看看是否存在一个页脚，如果存在，就把它的HTML拉入一个div。在我们的场景中，它会给我们:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="1794" class="lh li iu mi b gy mr ms l mt mu">&lt;div id="footer"&gt;<br/>  &lt;p&gt;deno-md-site&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="f173" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们将这两个助手都添加到<code class="fe mf mg mh mi b">Step 3</code>中，这样我们就有了:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2024" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在对于我们的主要html内容来说，这是<code class="fe mf mg mh mi b">index.html</code>文件本身的基本结构。让我们创建另一个名为<code class="fe mf mg mh mi b">getHtmlByPage</code>的模板助手，它接受类型<code class="fe mf mg mh mi b">Page</code>作为输入:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="803f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在这里，您可以看到我们使用了所有之前声明的与我们的目标相关的助手和变量。</p><ul class=""><li id="db73" class="na nb iu kl b km kn kp kq ks nc kw nd la ne le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">${name}</code>是当前<strong class="kl iv">页面的名称</strong></li><li id="2a47" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">${title}</code>是我们整个网站的标题(即。<code class="fe mf mg mh mi b">Deno Markdown Site</code>)</li><li id="ee9e" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">${getStylesheetHref(path)}</code>将我们链接到一个样式表(我们稍后将再次构建它)</li><li id="5879" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">${getNavigation(path)}</code>生成导航div</li><li id="3ac5" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><code class="fe mf mg mh mi b">${html}</code>是当前页面的HTML</li></ul><p id="ff80" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们最后的<code class="fe mf mg mh mi b">Step 3</code>部分应该是这样的</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0b3b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">一切都在慢慢变好。我们要做的最后一件事是生成我们的<code class="fe mf mg mh mi b">index.html</code>文件和它们相关的文件夹。</p><h2 id="3be0" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">第四步。将页面构建到。具有适当路径的html文件</h2><p id="3a76" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">这一步相对简单，我们知道<code class="fe mf mg mh mi b">pages</code>变量中的每个<code class="fe mf mg mh mi b">page</code>都有我们所有的HTML内容和一个<code class="fe mf mg mh mi b">path</code>。例如，路径可以看起来像<code class="fe mf mg mh mi b">/</code>或<code class="fe mf mg mh mi b">/about</code>等。基于这些值，让我们定义<strong class="kl iv">输出路径</strong>，这将是写入index.html文件的实际文件系统路径:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8cc1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">还记得我们在脚本前面从CLI参数中获取的<code class="fe mf mg mh mi b">buildPath</code>吗？在这里，我们可以将它与页面路径缝合在一起，得到我们的<strong class="kl iv">输出路径</strong>。使用临时的<code class="fe mf mg mh mi b">console.log(...)</code>，我们可以运行脚本并得到:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="eb24" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们更新<code class="fe mf mg mh mi b">Step 4</code>，现在将这些文件保存到我们的文件系统中，为了确保我们在文件中包含正确的内容，我们使用我们的<code class="fe mf mg mh mi b">getHtmlByPage</code>模板助手:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dec7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在这里，<code class="fe mf mg mh mi b"><a class="ae lf" href="https://deno.land/std@0.74.0/fs#ensurefile" rel="noopener ugc nofollow" target="_blank">ensureFileSync</a></code>确保文件存在。如果指定的路径包含不存在的目录，则创建这些目录。在我们确认文件路径存在后，<code class="fe mf mg mh mi b">Deno.writeFileSync</code>将<code class="fe mf mg mh mi b">getHtmlByPage</code>用于我们选择的<strong class="kl iv">页面</strong>对象，并为其生成所有必要的HTML内容(根据我们的模板)。</p><p id="ba10" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">此外，由于我们正在<strong class="kl iv">将</strong>写入我们的文件系统，我们必须使用<code class="fe mf mg mh mi b">--allow-write</code>标志，测试脚本如下:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c422" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这将生成一个具有以下结构的<code class="fe mf mg mh mi b">build</code>目录:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="7bc2" class="lh li iu mi b gy mr ms l mt mu">build<br/>├── about<br/>│   └── index.html<br/>└── index.html</span></pre><h2 id="4127" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">第五步。建立额外的资产文件</h2><p id="59a0" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">我们的最后一步是生成额外的资产文件，并确保它们也保存在我们构建的适当位置。在这个例子中，我们只有两个额外的资产，一个样式表(<code class="fe mf mg mh mi b">styles.css</code>)和一个favicon ( <code class="fe mf mg mh mi b">favicon.svg</code>)。我们可以这样创建它们:</p><figure class="mj mk ml mm gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c417" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，当我们运行脚本时，我们的目录结构是</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="469d" class="lh li iu mi b gy mr ms l mt mu">build<br/>├── about<br/>│   └── index.html<br/>├── favicon.svg<br/>├── index.html<br/>└── styles.css</span></pre><h2 id="bacc" class="lh li iu bd lj lk ll dn lm ln lo dp lp ks lq lr ls kw lt lu lv la lw lx ly lz bi translated">预览我们的网站</h2><p id="76fb" class="pw-post-body-paragraph kj kk iu kl b km ma jv ko kp mb jy kr ks mc ku kv kw md ky kz la me lc ld le ig bi translated">首先让我们<code class="fe mf mg mh mi b">cd build</code>进入我们的构建文件夹。运行本地web服务器有多种选择，请选择以下最适合您的选项:</p><ul class=""><li id="32ad" class="na nb iu kl b km kn kp kq ks nc kw nd la ne le nf ng nh ni bi translated"><strong class="kl iv"> Python 2 </strong> : <code class="fe mf mg mh mi b">python -m SimpleHTTPServer 8001</code></li><li id="db0a" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><strong class="kl iv"> Python 3 </strong> : <code class="fe mf mg mh mi b">python3 -m http.server 8001</code></li><li id="24fd" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><strong class="kl iv"> PHP </strong> : <code class="fe mf mg mh mi b">php -S localhost:8001</code></li><li id="5240" class="na nb iu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni bi translated"><strong class="kl iv">浏览器同步</strong>(节点包):<code class="fe mf mg mh mi b">npm install -g browser-sync; browser-sync --port 8001</code></li></ul><p id="210b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">然后，如果我们在本地浏览器中打开<code class="fe mf mg mh mi b">localhost:8001</code>，我们应该会看到:</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/022eca97967d7bc5d992f30ae47ee135.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/0*kp6-ZQw0eVBh6YHY.gif"/></div></figure><p id="4ee2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">就是这样，如果你想尝试一个更高级的样式示例，可以在<code class="fe mf mg mh mi b"><a class="ae lf" href="https://github.com/nafeu/deno-md-site" rel="noopener ugc nofollow" target="_blank">github.com/nafeu/deno-md-site</a></code>查看这个<code class="fe mf mg mh mi b"><a class="ae lf" href="https://raw.githubusercontent.com/nafeu/deno-md-site/main/example-site.md" rel="noopener ugc nofollow" target="_blank">example-site.md</a></code>。</p><p id="69a0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">感谢您阅读完本教程，我希望它对您有所帮助，并且您已经开启了对更聪明的静态站点生成的想象。编码快乐！</p></div></div>    
</body>
</html>