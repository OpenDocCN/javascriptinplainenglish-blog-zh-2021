<html>
<head>
<title>Angular meets RxJS: Higher-order observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度交会rjs:高阶可观测值</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-meets-rxjs-higher-order-observables-632e560ce2d0?source=collection_archive---------5-----------------------#2021-03-11">https://javascript.plainenglish.io/angular-meets-rxjs-higher-order-observables-632e560ce2d0?source=collection_archive---------5-----------------------#2021-03-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4ae9eef0247c9c7a8d22c1db01f90e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4sOJqYGABsL5PsOi"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@regeris?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Reger</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5b65" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="5c53" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">本文属于一个名为<strong class="la io">Angular meeting RxJS</strong>的系列，在这个系列中，我尽我所能在“Angular”的上下文中解释使用“RxJS”的反应式编程。</p><h1 id="e3f6" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">目录</h1><p id="f5fa" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-basic-concepts-f178d8fe0e02">基本概念</a> <br/> <a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3"> RxJS科目</a><br/>T8】RxJS运算符(第1部分)<br/>T11】RxJS运算符(第2部分) <br/> <a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-e64caa5f72e7" rel="noopener"> RxJS运算符(第3部分)</a><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d">【take直至】和【async】pipe</a><br/>高阶可观测值<br/>T21【错误处理】T23】RxJS调度器(即将到来)【T2</p><h1 id="be78" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">在本文中</h1><p id="1e7a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">正如我们在关于<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e">“rjs”运算符</a>的文章中看到的，“JavaScript”中的高阶函数是接受参数中的另一个函数或返回一个函数。可观测性也存在同样的概念。在本文中，我们将了解为什么理解它们是绝对重要的，以及如何使用它们来简化和保护管道。</p><h1 id="810f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">形势</h1><p id="b38e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们以一个常见的情况作为本文的基础。假设您正在构建一个“中型”克隆，以允许人们写一些文章。“中”的一个很好的特性是它定期自动保存您的文档。</p><p id="6f3c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">为了模拟REST API，我将使用“<a class="ae jz" href="https://www.npmjs.com/package/json-server" rel="noopener ugc nofollow" target="_blank">JSON-server</a>”NPM包。如果您不知道，它是一个非常有用的包，提供了一个基于“JSON”文件的REST API。</p><p id="e670" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面是设置它所需的步骤，如果您不想在您的计算机上复制本文的示例，您可以跳过这些步骤。</p><p id="d923" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">通过运行以下命令，从全局安装“json-server”开始:</p><blockquote class="mb mc md"><p id="cc91" class="ky kz me la b lb lw ld le lf lx lh li mf ly ll lm mg lz lp lq mh ma lt lu lv ig bi translated">纱线全局添加JSON-服务器</p></blockquote><p id="895f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">完成后，创建一个名为“db.json”的文件，其内容如下:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="850f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">接下来，在您创建上述文件的文件夹中打开一个终端，并运行以下命令:</p><blockquote class="mb mc md"><p id="7800" class="ky kz me la b lb lw ld le lf lx lh li mf ly ll lm mg lz lp lq mh ma lt lu lv ig bi translated">json-server db.json - watch</p></blockquote><p id="9578" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这将启动“JSON”服务器，并允许您在URL“http://localhost:3000”访问REST API。它会根据“db.json”文件的结构自动生成路线。例如，您可以通过浏览URL“<a class="ae jz" href="http://localhost:3000/documents" rel="noopener ugc nofollow" target="_blank">localhost:3000/documents</a>”来获取所有文档，也可以通过浏览URL“<a class="ae jz" href="http://localhost:3000/documents/1" rel="noopener ugc nofollow" target="_blank">localhost:3000/documents/1</a>”来按id获取文档。</p><p id="cd67" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">为了能够调用这个REST API，要执行的最后一步是在我们的“app.module”文件中导入“HttpClientModule ”:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="c1d3" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题是</h1><p id="de0f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在，我们已经设置了项目，让我们实现autosave特性。为了简单起见，REST API调用将简单地更新字段“lastUpdate ”,而不是文档的内容。</p><p id="ee08" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">根据我们到目前为止所学的一切，我们可以试着像这样编写autosave函数:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="mb mc md"><p id="14c9" class="ky kz me la b lb lw ld le lf lx lh li mf ly ll lm mg lz lp lq mh ma lt lu lv ig bi translated">如果你想知道什么是“BaseComponent”和“this.destroy$”，可以看看<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d">这篇文章</a>。</p></blockquote><p id="df9a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里的想法是使用"<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e"> interval </a>"操作符创建一个可观察对象，以便每秒发出一次值(在现实生活中，您可能希望不那么频繁地保存文档)。我们使用“<a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d" rel="noopener"> takeUntil </a>”操作符，以便在组件被销毁时取消订阅可观察对象。最后，我们简单地将每个值映射到HTTP客户机的“put”函数返回的可观察值，该函数用于更新“db.json”文件中的文档。</p><p id="e65d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们执行这段代码，几秒钟后调用URL "<a class="ae jz" href="http://localhost:3000/documents/1" rel="noopener ugc nofollow" target="_blank">localhost:3000/documents/1</a>"来查看文档是否得到了更新。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/df9b438719b1e9cb5545336df45a704c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VONI0LLeBEEOoqfUhLcw6Q.png"/></div></div></figure><p id="a646" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">嗯，它没有，但是，如果你看看控制台，你会看到两个“文件保存！”日志已经写好了，那么这里发生了什么呢？</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/01408d2353368f6935bb4fda4da16ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjsdf6h9Qyo4tTkMsTviow.png"/></div></div></figure><p id="3135" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">理解发生了什么的一个好方法是记录在“subscribe”方法中收到的值，而不是消息“Document saved！”也许这能给我们一些线索。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/3de3562b97ebeca6c0b9d091999f50b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0sTMn93zQ6OjtxzOnLzsg.png"/></div></div></figure><p id="7a6e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这很有意思……通常情况下，当你使用“json-server”调用一个“PUT”路由时，这个会返回更新后的对象，那么为什么我们会收到一个observable而不是这个对象呢？嗯，这很简单，"<a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-60d8b2140d20" rel="noopener"> map </a>"操作符发出由源可观测值发出的值的投影，所以在这里，对于由"<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e">区间</a>"发出的每个值，"<a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-60d8b2140d20" rel="noopener"> map </a>"操作符返回由" HttpClient "的" put "函数返回的可观测值。</p><p id="859d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">然而,“HttpClient”返回的observables是<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-basic-concepts-f178d8fe0e02">冷的</a>,这意味着它们不会做任何事情，直到您订阅它们，在这种情况下，我们不做，所以对REST API的调用实际上从未被触发。你可以通过查看“谷歌开发者控制台”中“网络”部分的“XHR”标签很容易地确认这一点:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/ca7b15654e649ce69256000811d6c156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bp6P5f6bGnzv117jjc01rw.png"/></div></div></figure><p id="5f7f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">除了“ng serve”发出的自动刷新你页面的调用之外，我们没有看到任何其他调用。</p><h1 id="dba5" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">穷人的解决方案</h1><p id="a5f0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这很烦人，但这真的是个问题吗？事实上，我们可以很容易地解决这个问题:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0cde" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们简单地更新了代码，在内部可观察对象上调用“subscribe ”,如果你运行你的代码，它就会工作。“db.json”文件中的文档每秒都会更新，每个人都很高兴。</p><p id="76e0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">然而，不要被愚弄，这是一种暴行，你绝不能使用它。实际上，在上面的例子中，这样做还是很安全的，因为一旦从服务器返回响应，由“put”函数返回的可观察对象就完成了。</p><p id="552e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，想象你订阅了一个不完整的内在可观察物。使用上面的解决方案将意味着每次“区间”发出一个值，对一个新的内部可观察对象进行新的订阅。更糟糕的是，订阅对象没有被存储，所以即使您想取消这个订阅，也无法取消。现在，您可以通过使用某种订阅数组来解决这个问题，您可以在需要的时候清理它，但是这样您就开始有一个非常复杂的代码来管理内部订阅，您需要确保正确地执行它以避免内存泄漏。此外，每当您想要使用这种模式时，拥有这种逻辑会非常麻烦(相信我，这是非常常见的……)。</p><p id="6944" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面的代码可以说明上面的解释:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="89d5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这里，我们首先创建一个每秒可观测的发射值。然后，每次发出一个值，我们将它映射到另一个每秒发出的可观察值，并在控制台中显示“foo ”,我们订阅它。我们还在控制台中记录“bar ”,每次输出观察值发出一个值。最后，3.5秒后，我们通过在订阅上调用“unsubscribe”来取消订阅输出observable。几秒钟后这段代码的结果是这样的:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/df7012a8ec1f4b57e2ed46d738b0146f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yC7Qqk-FnsOJ6w-QQWjFhg.png"/></div></div></figure><p id="ae33" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">当发出源可观测值的第一个值时，在控制台中记录第一个“柱”。在那一刻，创建了对内部可观察对象(第二个间隔)的订阅，这就是为什么一秒钟后，我们在控制台中记录了另一个“bar”(通过源可观察对象)和一个“foo”(通过内部可观察对象)。一秒钟后，我们得到第三个“bar”和另外两个“foo”(因为现在有两个活动的内部订阅)。然后,“setTimeout”触发并终止对输出可观察对象的订阅，然而，一些“foo”继续记录在控制台中。这仅仅是因为杀死源订阅并没有杀死内部订阅，因为我们没有存储它们，我们甚至不能这样做，所以只要您的应用程序运行，这三个创建的内部订阅就会一直发出。欢迎内存泄漏…</p><h1 id="0aef" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">合并地图</h1><p id="eaaf" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">既然我们已经看到了如何不正确地解决这个问题，我们将看看本文的第一个高阶映射操作符:“mergeMap”。在解释它如何工作以及如何使用它来实现我们的autosave特性之前，让我们使用它来更新前面的代码:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="eb57" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们在这里所做的唯一更改是用“mergeMap”替换“map ”,并删除了对“subscribe”方法的调用。让我们看看输出中的差异。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/5ca6a252d90256dc5d55aa7dab85fd1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bx8x2KTqFXIwuy_tQWfnOw.png"/></div></div></figure><p id="a616" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里需要注意两件重要的事情:</p><ol class=""><li id="f786" class="mq mr in la b lb lw lf lx lj ms ln mt lr mu lv mv mw mx my bi translated">这些值不会按照相同的顺序发出。</li><li id="ba18" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv mv mw mx my bi translated">一旦主订阅被终止，就不再发出值。</li></ol><p id="c10d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">第二点非常重要，因为这正是我们想要的:<strong class="la io">不必手动管理内部订阅</strong>。但现在的问题是:</p><blockquote class="mb mc md"><p id="4adf" class="ky kz me la b lb lw ld le lf lx lh li mf ly ll lm mg lz lp lq mh ma lt lu lv ig bi translated">为什么“foo”值已经被发出，因为我们没有订阅内部可观察值？</p></blockquote><p id="d1e0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">而答案是“mergeMap”。以下是该运算符的工作方式:</p><p id="6251" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">基本上，当你将一个可观察对象返回到“mergeMap”时，它会自动订阅它，并在后台管理结果订阅。然后，它简单地将内部可观察对象发出的值发送到输出对象上。“mergeMap”的主要特点是，它将处理所有内部订阅，并在其中一个内部observables发出时立即发出值。让我们逐步分解上面的代码，以真正理解发生了什么，并确保我们相互理解，让我们定义三个术语:</p><ul class=""><li id="573a" class="mq mr in la b lb lw lf lx lj ms ln mt lr mu lv ne mw mx my bi translated"><strong class="la io">源可观察对象</strong>:这是主要的可观察对象，你调用“管道”方法来返回…</li><li id="a7e2" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv ne mw mx my bi translated"><strong class="la io">输出可观测值</strong>:这是“管道”函数返回的可观测值。</li><li id="cf49" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv ne mw mx my bi translated"><strong class="la io">内部可观察对象</strong>:通过“mergeMap”等操作符从“pipe”函数中订阅的可观察对象。</li></ul><p id="0184" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">那么，前面的代码是如何执行的呢…</p><ul class=""><li id="ce33" class="mq mr in la b lb lw lf lx lj ms ln mt lr mu lv ne mw mx my bi translated">一秒钟后，源可观测值发出它的第一个值。</li><li id="59d4" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv ne mw mx my bi translated">“mergeMap”操作符接收该值并订阅内部可观察值。每当它刚刚订阅的内部可观察对象发出一个值时，它还调用“管道”函数在控制台中记录值“foo”。</li></ul><blockquote class="mb mc md"><p id="aba1" class="ky kz me la b lb lw ld le lf lx lh li mf ly ll lm mg lz lp lq mh ma lt lu lv ig bi translated"><strong class="la io">重要的是要明白，源可观测值发出的值被“合并映射”丢弃。事实上，操作符将只发出它所订阅的内部可观察对象发出的值。这意味着在输出可观察对象上发出的第一个值不是在一秒钟之后，而是在两秒钟之后，因为源可观察对象的第一个值是在一秒钟之后发出的，但是内部可观察对象的值(实际上是在输出可观察对象上发出的值)是在一秒钟之后发出的。</strong></p></blockquote><ul class=""><li id="7583" class="mq mr in la b lb lw lf lx lj ms ln mt lr mu lv ne mw mx my bi translated">“mergeMap”订阅内部可观察对象一秒钟后，这个发出一个值，于是“tap”被执行(这也是“foo”出现在控制台的原因)，然后，这个值在输出可观察对象上发出(这也是“bar”出现的原因)。</li></ul><blockquote class="mb mc md"><p id="5220" class="ky kz me la b lb lw ld le lf lx lh li mf ly ll lm mg lz lp lq mh ma lt lu lv ig bi translated">此时,“mergeMap”有一个活动的内部订阅，它每秒发出一个值。</p></blockquote><ul class=""><li id="a877" class="mq mr in la b lb lw lf lx lj ms ln mt lr mu lv ne mw mx my bi translated">在内部可观察对象发出第一个值的同时，源可观察对象发出第二个值。这一个没有记录在控制台上，因为发生了与前面相同的过程:“mergeMap”丢弃了该值，但是订阅了第二个内部可观察对象，该对象在一秒钟后发出一个值。并且一秒钟后，还有第一个内部可观察对象发出一个新值，这就是为什么“foo”和“bar”在控制台上被记录了两次。</li><li id="2826" class="mq mr in la b lb mz lf na lj nb ln nc lr nd lv ne mw mx my bi translated">到目前为止，代码执行了三秒钟，因此当“setTimeout”在500 ms后执行并终止订阅时，“mergeMap”操作符也终止了其内部订阅，这就是控制台中不再记录任何内容的原因。</li></ul><p id="0767" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果你更喜欢大理石图而不是解释，这里有一个解释上面的代码。注意，我在这里没有考虑取消订阅，所以从图中可以观察到的源是不完整的。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/7d7240fefde83f27cb7e9ed8684d3ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4ms4yYFwYeDAXZIKJ55xQ.png"/></div></div></figure><p id="7be2" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">请注意，在图中，这些值似乎是作为数组发出的，但事实并非如此，它们是独立发出的。只是我无法用图表正确地说明这一点。</p><p id="f836" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果您理解了以下解释，您应该能够预测以下代码的输出:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d9ad" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果您不希望看到记录的值事件，尽管三秒钟后由“<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-60d8b2140d20"> take </a>”操作符完成了源可观测性，您可能应该再次阅读上面的解释:-)</p><h1 id="3f5f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">回到自动保存功能</h1><p id="356b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">既然我们已经解释了高阶可观测量背后的思想，那么让我们看看如何使用下面的操作符来实现我们的autosave特性:“mergeMap”、“switchMap”、“concatMap”和“exhaustMap”。</p><p id="8756" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这些操作符基本上服务于相同的目的，它们唯一的区别是管理内部订阅的方式以及何时取消订阅。</p><p id="f5c6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">为了清楚地解释区别，我们将以稍微不同的方式启动“json-server ”:</p><blockquote class="mb mc md"><p id="2f60" class="ky kz me la b lb lw ld le lf lx lh li mf ly ll lm mg lz lp lq mh ma lt lu lv ig bi translated">JSON-server db . JSON-watch-delay 1500</p></blockquote><p id="e78d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们添加了“延迟”参数来模拟服务器延迟。基本上，所有的调用都会以1.5秒的延迟返回它们的答案。</p><h2 id="4850" class="ng kb in bd kc nh ni dn kg nj nk dp kk lj nl nm ko ln nn no ks lr np nq kw nr bi translated">合并地图</h2><p id="291a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">嗯，我们已经谈了很多了。我们唯一没有提到的是内部订阅的处理方式。实际上，这并不复杂，“mergeMap”维护着它订阅的所有内部观测值。这是非常重要的一点，因为如果不考虑的话，它可能会导致内存泄漏。</p><p id="e6a6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">使用此运算符的autosave功能的版本如下:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d04d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">查看这段代码发生了什么的一个有趣方法是查看Google开发人员控制台中的network选项卡。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/57e0004a23d9a9cdca5e11f5cf6793a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-djFHRlVD1K0tEZQJ9VQrQ.png"/></div></div></figure><p id="b495" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这里，我们可以看到，无论另一个调用是否正在进行，对REST API的调用每秒都在进行。我在一个特定的时刻拍摄了这个截图，以说明即使一个调用当前处于挂起状态(由于服务器延迟)，下一个调用仍然会被触发。</p><p id="38d1" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">总之，“合并映射”只是订阅内部的可观察对象，并在它们到来时在输出对象上发出它们的值。</p><p id="4b3f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">该操作符的通用大理石图如下:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/226780446f2a064dbf6a462bfbde5bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjl4G4ocM5r3ZLNqrbv0Iw.png"/></div></div></figure><h2 id="e323" class="ng kb in bd kc nh ni dn kg nj nk dp kk lj nl nm ko ln nn no ks lr np nq kw nr bi translated">开关图</h2><p id="6b6e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">“switchMap”和“mergeMap”的区别在于<strong class="la io">在给定时间</strong>只能存在一个内部订阅。事实上，当“switchMap”订阅一个内部可观察对象时，它会在订阅新的内部可观察对象之前取消订阅之前的内部订阅(如果有的话)。让我们看看如果在上面的代码中用“switchMap”替换“mergeMap”会发生什么。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/13a1dc53ed40e93206ff5544cbde8e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSBOoI3w8vdyqwNRKhXPfw.png"/></div></div></figure><p id="7048" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如您所见，没有请求通过，因为它们在结束前就被取消了。事实上，当源可观察对象的第一个值发出时，“switchMap”订阅由“HttpClient”的“put”函数返回的内部可观察对象。然后，一秒钟后，当源可观察对象发出第二个值时，第一个内部可观察对象尚未完成，因为请求至少需要1.5秒，因此，“switchMap”取消了内部订阅，这实际上取消了HTTP请求，这就是控制台显示“(已取消)”的原因。</p><p id="1eed" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这是一个非常好的解决方案，可以确保输出的可观察值总是对应于最后一个内部可观察值。该运算符的图表如下所示:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/d65026196396085de05422d51b7c2021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-GXBb8zlAmwJzOUfGoj-A.png"/></div></div></figure><h2 id="370e" class="ng kb in bd kc nh ni dn kg nj nk dp kk lj nl nm ko ln nn no ks lr np nq kw nr bi translated">耗尽图</h2><p id="18fe" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这个其实就是“switchMap”的翻版。事实上，当在源可观察对象上发出新值时，只要当前的内部订阅没有完成，“穷举映射”就忽略新发出的值，而不是取消当前的内部订阅(如果有的话)。这意味着在一个给定的时间内总是只有一个内部订阅，但是在订阅一个新的内部observables之前,“exhaustMap”总是等待它完成。</p><p id="6b15" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在我们的示例中，将“switchMap”替换为“exhaustMap”会产生以下结果:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/b7147bf99ece76525bf1e11fd65e487f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mN3_3mwp61vSHmm0sfRnFg.png"/></div></div></figure><p id="a38e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">您可以在“Time”列中看到，每个请求需要1.5秒，并且在执行另一个请求时没有其他请求。请求之间半秒钟的间隔表明发出请求时发出的值被丢弃。这将给出下图:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/deda0ba2a79addb78e6a9ee36538e74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BF8p4EsX49oUb_NRY5EDcg.png"/></div></div></figure><h2 id="07bc" class="ng kb in bd kc nh ni dn kg nj nk dp kk lj nl nm ko ln nn no ks lr np nq kw nr bi translated">串联图</h2><p id="2fa9" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我把“concatMap”留到了最后，因为它是一个非常复杂的操作符…开个玩笑(我知道，我很搞笑…)。“concatMap”只是在订阅新的内部可观察对象之前等待当前内部可观察对象完成。在我们的代码中使用它会产生一个几乎类似于“exhaustMap”的结果。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/24e9ecf2c201a51a5ed251539f88131c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLv0KBwUX_UPldUPDEY5zw.png"/></div></div></figure><p id="d9d5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这种行为与前一种行为的唯一区别是，前一种行为一完成，请求就开始。使用“穷举法”，当一个请求正在进行时，内部的可观察对象被忽略，我们在每个请求之间有一个间隙。有了“串联图”，不同的内部可观测量被简单地排队并尽快发出。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/61efce958838696f4bd9d21e53b288a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4nL_hDkaT8LG_zXdlurng.png"/></div></div></figure><h1 id="2dd3" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">最后的想法</h1><p id="8745" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">唷！这是一个漫长而复杂的问题…高阶可观测量是一个非常复杂的话题，如果你想在使用“RxJS”时真正感到舒适，你必须掌握这个话题，所以如果你没有完全理解它，不要犹豫，发表评论，要求一些澄清，我会更新文章，让它更清楚。</p><p id="048d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-error-handling-8fad48721e49" rel="noopener">下一篇文章</a>将关注使用“RxJS”管理错误的方法。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><a href="https://www.buymeacoffee.com/ssougnez"><div class="gh gi nv"><img src="../Images/6d60b235fcc46a4bd696b90e886419ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Dpw8-hNGI2fDmosV4E8DVQ.png"/></div></a></figure></div></div>    
</body>
</html>