<html>
<head>
<title>ReasonReact: Introduction and First Impressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原因反应:介绍和第一印象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reasonreact-introduction-and-first-impressions-fb329d394119?source=collection_archive---------28-----------------------#2021-01-04">https://javascript.plainenglish.io/reasonreact-introduction-and-first-impressions-fb329d394119?source=collection_archive---------28-----------------------#2021-01-04</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="0166" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">用ReasonML(一种强类型函数式语言)构建React应用程序</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/f297ddba5d5d25421f4f6d68b797d922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r5tVB7_SKUgqB3Kg"/></div></div></figure><p id="87af" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">最近我一直在试验<a class="ae lo" href="http://reasonml.github.io" rel="noopener ugc nofollow" target="_blank"> ReasonML </a>(也称为BuckleScript或<a class="ae lo" href="http://rescript-lang.org" rel="noopener ugc nofollow" target="_blank"> ReScript </a>)，这是一种基于<a class="ae lo" href="http://ocaml.org" rel="noopener ugc nofollow" target="_blank"> OCaml </a>的功能性强类型语言。ReasonML吸引人的一点是，它是一种强类型语言，像JavaScript一样容易学习，但没有JavaScript的许多古怪之处。用ReasonML编写的代码很容易被转换成JavaScript，所以React是一个框架，让你用React构建React应用。</p><h1 id="8d41" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">构建示例应用程序</h1><p id="574d" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">ReasonReact中的ReasonML代码使用作为BuckleScript/ReScript平台一部分的工具转换为JavaScript，您可以使用npm轻松安装:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="2b4a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后，您只需使用简单的<strong class="ku is"> bsb </strong>命令创建一个ReasonReact应用程序，就像您如何使用<strong class="ku is"> create-react-app </strong>命令创建一个基本的JavaScript React应用程序一样:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="944d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后，您可以像这样构建并运行编译器:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="59bb" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这将启动一个开发编译器，它将不断地把你的ReasonML代码编译成JavaScript。这意味着，如果您更改了任何代码，它将自动被编译器选中并进行转换。您使用一个单独的命令来运行实际上为web浏览器提供应用程序的服务器:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="e07c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这将导致如下所示的结果:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mo"><img src="../Images/2131bacfa5ab3bd11541d838201bb142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*-Pc_biZgdnQeFvGLmvilgw.png"/></div></figure><h1 id="7d66" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">index.re文件</h1><p id="52fd" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">像大多数React应用一样，有一个<strong class="ku is">index.html</strong>文件，它是提供给客户端的实际基本HTML。该文件指向<strong class="ku is"> Index.bs.js </strong>文件，是<strong class="ku is"> index.re </strong>文件的编译版本。index.re文件定义了这个示例应用程序的整体结构。在顶部，它首先在DOM中构建一个样式元素:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="8591" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在<strong class="ku is">示例中写出的样式样式</strong>是一个文字字符串，所以这里没有真正复杂的魔法。接下来，该文件定义了一个名为<strong class="ku is"> makeContainer </strong>的函数，该函数同样构建了包含示例中定义的原因组件的<strong class="ku is"> div </strong>元素:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="787b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">该函数创建DOM元素并返回<strong class="ku is">内容</strong>元素，这是ReasonML组件将被附加的位置。每次调用这个函数时，都会将另一个组件装入DOM。最后，我们调用这个函数来挂载一些ReasonML组件:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="803a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">对<strong class="ku is">react DOM . render</strong>的调用与您可能习惯的<strong class="ku is"> ReactDOM.render </strong>调用非常相似。通常我们只使用ReactDOMRe.render方法一次，挂载一个包含所有其他组件的主组件，但这只是一个包含非常简单组件的示例应用程序。</p><h1 id="9cdb" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">合理的组件</h1><p id="5f1c" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">示例应用程序中有几个示例组件，但它们通常都以相同的方式工作。我将浏览一下<strong class="ku is"> BlinkingGreeting.re </strong>文件，因为它是所有文件中最简单的。原因反应组件从一个简单的函数定义开始:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="ded9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">第一行是对该函数的注释，表明该函数是一个React组件。第二行类似于我们在JavaScript React中定义功能组件的方式。<strong class="ku is"> ~children </strong>参数就是您所期望的——这个组件的子组件。文件中的下一行是对React的<strong class="ku is"> useState </strong>钩子的调用:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="7092" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">对于在JavaScript中使用过useState钩子的人来说，这应该很熟悉。唯一的区别是，它不仅仅是传递给调用的一个值，而是被赋予一个匿名函数调用来返回值。接下来是对<strong class="ku is"> useEffect </strong>的调用，它允许开发人员在组件挂载后运行一些代码:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="1270" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">注意，我们实际上调用了一个名为<strong class="ku is"> useEffect0 </strong>的函数。我们这样做有一个技术上的奇怪之处，但基本上是关于useEffect的第二个可选参数，它通常是一个数组。然而，ReasonML中的数组必须包含所有相同类型的元素，所以我们调用一个带有元组的函数，它允许不同类型的项。然而，由于类型安全，函数参数中的元组是固定长度的，因此每个长度都有一个函数，最长为7 (useEffect0不接受元组arg，useEffect1接受长度为1的元组，useEffect2接受长度为2的元组，等等。).这里的useEffect设置了一个区间，基本上是调用<strong class="ku is"> setShow </strong>来翻转显示状态变量。像普通的React一样，useEffect的返回是一个清理函数，它在组件卸载时清除间隔。</p><p id="de0f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">接下来，该文件根据闪烁文本是否可见来设置样式:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="cefc" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在ReasonML中，if/else的结果值可以返回给一个变量，所以这里创建了一个样式，当文本应该显示时不透明度为1，当文本应该隐藏时不透明度为0。</p><p id="3edf" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">整个组件函数的返回值是应该呈现的HTML:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><p id="d5e7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">ReasonML中没有return语句，所以函数中最后的表达式就是返回值。这类似于JavaScript React应用程序中返回的JSX。</p><h1 id="c9d9" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">显著的差异</h1><p id="abaf" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">除了显而易见的原因ML与JavaScript的语法差异(在很大程度上，这些差异非常接近，任何JavaScript开发人员都应该能够很快发现它们)，还有一些关键的差异值得一提:</p><ul class=""><li id="6cdc" class="mp mq ir ku b kv kw ky kz lb mr lf ms lj mt ln mu mv mw mx bi translated">不像在JavaScript JSX中，你不能在JSX中包含原始文本并期望它会被转换成HTML中的文本。相反，原始文本和数字必须换行。</li></ul><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mm mn l"/></div></figure><ul class=""><li id="7e10" class="mp mq ir ku b kv kw ky kz lb mr lf ms lj mt ln mu mv mw mx bi translated">属性和子属性不需要花括号，但是如果你愿意，你可以使用它们。</li><li id="a79d" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">不支持JSX道具跨页(<code class="fe nd ne nf ng b">&lt;Foo {...bar} /&gt;</code>)，但支持子跨页(<code class="fe nd ne nf ng b">&lt;Foo&gt;...baz&lt;/Foo&gt;</code>)。</li><li id="a87c" class="mp mq ir ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">JSX属性可以一语双关，所以<code class="fe nd ne nf ng b">&lt;Foo title={title} /&gt;</code>可以简单写成<code class="fe nd ne nf ng b">&lt;Foo title /&gt;</code>。</li></ul><h1 id="a5bb" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">第一印象</h1><p id="6603" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">一旦你安装了工具并开始用ReasonML编码，我想你会发现它令人耳目一新。从JavaScript到ReasonML的调整相当顺利，类型安全确实有助于确保如果您的代码编译，它可能会正确工作。</p><p id="7da0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">开发工具也支持react istration，但不如JavaScript支持得好。我的WebStorm应用程序有一个ReasonML插件，它确实提供了代码完成和语法突出显示，但错误不一定会显示出来，迫使我依赖编译器输出来查看事情是否正确。错误消息有时有助于快速定位错误，但是如果你还在学习推理，你可能会陷入困境，不知道问题是什么。</p><p id="89cb" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">对我来说，迁移到React的最大好处是ReasonML给我带来的优势——一种类型安全的语言，没有JavaScript和TypeScript的怪癖。我还在学习这种语言，刚刚开始用它来构建项目，所以仍然有一些我在JavaScript中已经学得很好的东西，我将不得不在ReasonML中解决。一旦我对它有了更多的了解，我会回到这个话题上来。</p></div></div>    
</body>
</html>