<html>
<head>
<title>LeetCode Algorithm Series: Happy Number</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法系列:快乐数字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-series-happy-number-1bdea90dde7?source=collection_archive---------19-----------------------#2021-07-23">https://javascript.plainenglish.io/leetcode-algorithm-series-happy-number-1bdea90dde7?source=collection_archive---------19-----------------------#2021-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d8e459d631b7b3ee50193af98319c632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lef4_aZjg8tvMCa7TfkPww.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@nhillier?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nick Hillier</a> on <a class="ae jz" href="https://unsplash.com/s/photos/numbers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5e38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题来自于Leetcode的<em class="ky">哈希表</em>探索卡<em class="ky">实际应用—哈希集</em>章节下。</p><p id="130b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io">快乐数字</strong>中:</p><blockquote class="kz la lb"><p id="43bb" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">写一个算法，判断一个数字<code class="fe lf lg lh li b">n</code>是否快乐。</p><p id="a456" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">一个<strong class="kc io">喜数</strong>是由以下过程定义的数:<br/> -从任意正整数开始，用其位数的平方和代替该数。<br/> -重复该过程，直到数字等于1(它将停留在该位置)，否则<strong class="kc io">在不包括1的周期</strong>中无限循环。<br/> -该过程<strong class="kc io">以1 </strong>结束的那些数字是快乐的。</p><p id="b3a8" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">返回<code class="fe lf lg lh li b">true</code> <em class="in">如果</em> <code class="fe lf lg lh li b">n</code> <em class="in">是喜数，返回</em> <code class="fe lf lg lh li b">false</code> <em class="in">如果不是</em>。</p></blockquote><p id="9fa6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="d72d" class="lr ls in li b gy lt lu l lv lw"><strong class="li io">Input:</strong> n = 19<br/><strong class="li io">Output:</strong> true<br/><strong class="li io">Explanation:</strong><br/>1^2 + 9^2 = 82<br/>8^2 + 2^2 = 68<br/>6^2 + 8^2 = 100<br/>1^2 + 0^2 + 0^2 = 1</span></pre><p id="d995" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看一下这个例子，我有一个数字，为了确定它是否快乐，我想计算这个数字平方的和，看看这个和是否等于1。</p><p id="06a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我开始做这个问题时，首先我必须弄清楚如何得到这个总数。既然给了我一个数字，我需要一种方法把它分解成数字。对于JavaScript，我需要先把它变成一个字符串。在拆分返回一个数组的字符串化数字之后，我可以遍历该数组，并使用<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">将它们改回数字。地图()方法</strong> </a>。</p><p id="5de5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，我需要一笔款子，JavaScript有一个方便的<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">。reduce()方法</strong> </a> <strong class="kc io"> </strong>可以迭代一个数组，返回1个聚合结果。在reduce方法中，我可以改变它正在迭代的当前元素，这样我就可以得到总数的平方，而不是数字。</p><p id="990d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，在这种情况下，将初始值设置为0很重要，否则reduce会将数组中的第一个元素作为初始值，然后它会从下一个元素开始迭代。这是一个问题，因为数组中的第一个数字永远不会被平方。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="1588" class="lr ls in li b gy lt lu l lv lw">const a = n.toString().split("");<br/>const b = a.map(x =&gt; parseInt(x))<br/>const sum = b.reduce((total, x) =&gt; total + x**2, 0)</span></pre><p id="6da1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我有了一种方法来得到数字的平方和，我需要弄清楚如何重复这个过程，直到得到1。首先，我想到了使用while循环，然而，只有当我已经知道这是一个令人高兴的数字时，它才会起作用。如果这不是一个令人愉快的数字，循环将无限运行。这让我们不得不使用递归。</p><p id="57f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ky">免责声明</em> </strong> <em class="ky">:我是递归方面的新手，可能解释不太完美。</em></p><p id="78e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，使用递归，我们在函数内部调用函数并返回值。每个递归函数都需要一个基本情况，否则函数将停止运行，否则我们会再次陷入无限循环的情况。</p><p id="0947" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">先简单说一下，一个不快乐的数字是什么样的？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b252" class="lr ls in li b gy lt lu l lv lw"><strong class="li io">Input:</strong> n = 2<br/><strong class="li io">Output:</strong> false<br/><strong class="li io">Explanation:</strong><br/>0^2 + 2^2 = 04<br/>0^2 + 4^2 = 16<br/>1^2 + 6^2 = 37<br/>3^2 + 7^2 = 58<br/>5^2 + 8^2 = 89<br/>8^2 + 9^2 = 145<br/>1^2 + 4^2 + 5^2 = 42<br/>4^2 + 2^2 = 20<br/>2^2 + 0^2 = 04</span></pre><p id="b175" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你注意到什么了吗？第一行和最后一行是一样的！我又得到了一笔4，我知道如果我继续用4的话会是什么样。所以一个不快乐的数字会无限延续下去。那么我该如何应对呢？</p><p id="80da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我决定我需要一种方法来跟踪我遇到的数字，如果我得到一个已经是我以前见过的数字的总和，我会知道我在一个不快乐的数字的循环中，我只是返回false。</p><p id="6a61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将这种跟踪+递归的方法放在一起:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="4b77" class="lr ls in li b gy lt lu l lv lw">var isHappy = function(n, hash = {}) {<br/>    if (n !== 1) {<br/>        if (hash[n]) {<br/>            return false<br/>        }<br/>        hash[n] = 1<br/>        const a = n.toString().split("");<br/>        const b = a.map(x =&gt; parseInt(x))<br/>        const sum = b.reduce((total, x) =&gt; total + x**2, 0)<br/>        return isHappy(sum, hash)<br/>    }<br/>    return true<br/>};</span></pre><p id="4405" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的函数接受一个数字和一个对象。这个对象是我用来记录我看到的数字的，数字参数是我要传递的新的和。</p><p id="5115" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分解我的代码:</p><ol class=""><li id="b3e8" class="lx ly in kc b kd ke kh ki kl lz kp ma kt mb kx mc md me mf bi translated">首先检查传入的数字是否等于1。如果是，则立即返回true。如果没有，那么我们跳转到If语句块</li><li id="4b9d" class="lx ly in kc b kd mg kh mh kl mi kp mj kt mk kx mc md me mf bi translated">如果这个数不等于1，我们就检查我以前是否遇到过这个数。如果有，则立即返回false。</li><li id="73b9" class="lx ly in kc b kd mg kh mh kl mi kp mj kt mk kx mc md me mf bi translated">如果我没有遇到那个数字，我把它添加到我的对象中，然后使用我之前开发的代码得到我的下一个数字，数字平方的和，我生成我的新数字</li><li id="9f2b" class="lx ly in kc b kd mg kh mh kl mi kp mj kt mk kx mc md me mf bi translated">由于当前数字不等于1，也不是我以前遇到过的数字，所以仍然有可能原来的数字是正确的，所以我将新数字传递给我的函数和更新后的对象(这里称为hash)。</li><li id="e62f" class="lx ly in kc b kd mg kh mh kl mi kp mj kt mk kx mc md me mf bi translated">类似于一个循环，我们再次从代码的顶部开始往下读，直到我们遇到数字等于1的基本情况(或者在某个时刻，我们将遇到相同的数字并退出，因为我们返回false)</li></ol><p id="b831" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在LeetCode上运行这个，运行时间是<strong class="kc io">68毫秒</strong>，比提交的<strong class="kc io"> 98.79% </strong>要好。</p><p id="d3b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我很想知道我的代码如何改进，或者你是如何解决这个算法的。请关注未来更多的LeetCode解决方案！</p><p id="11d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">LeetCode系列:</p><blockquote class="kz la lb"><p id="cd3d" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">1.<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复的</a> <br/> 2。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca" rel="noopener">合并排序后的数组</a>3<br/>。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-height-checker-2cb703879529" rel="noopener">高度检查器</a> <br/> 4。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-palindrome-3cd94c4b00cc" rel="noopener">有效回文</a> <br/> 5。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-happy-number-1bdea90dde7" rel="noopener">快乐数字</a> <br/> 6。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7" rel="noopener">最长常用前缀</a> <br/> 7。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-climbing-stairs-c308255dcb9e" rel="noopener">爬楼梯</a> <br/> 8。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7" rel="noopener">有效括号</a> <br/> 9。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-pascals-triangle-253856454598" rel="noopener">帕斯卡三角形</a> <br/> 10。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-maximum-subarray-776252f61ea0" rel="noopener">最大副拉</a></p></blockquote><p id="7960" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>