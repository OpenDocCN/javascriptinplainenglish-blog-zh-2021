<html>
<head>
<title>Building a Pokedex with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React构建Pokedex</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-pokedex-with-react-part-3-d4681db83ecb?source=collection_archive---------11-----------------------#2021-03-15">https://javascript.plainenglish.io/building-a-pokedex-with-react-part-3-d4681db83ecb?source=collection_archive---------11-----------------------#2021-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b9e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分:构建路由器和显示页面</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/12357899c1b3cd5b82e195399931c4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJ9MT5MV8pRfBtClFh8SHw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Pokemon Fan Art — <a class="ae kv" href="https://funnyjunk.com/channel/vidyagaems/Pokemon+fan+art/xgBMMkt/" rel="noopener ugc nofollow" target="_blank">https://funnyjunk.com/channel/vidyagaems/Pokemon+fan+art/xgBMMkt/</a></figcaption></figure><p id="2521" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，你们在这里做第三部分。如果你参加聚会迟到了，你可以跟着第一部分<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/building-a-pokedex-with-react-7b7410db441a">和第二部分</a><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/building-a-pokedex-with-react-d3381b968ce2">一起去。在这一期中，我们将添加React-Router并获取我们的个人口袋妖怪数据，以便我们可以呈现一个显示页面。React-Router是一个客户端路由库，我们可以在React中使用它来帮助我们的URL反映UI中的变化，它是我们在这个SPA中使用的一个重要工具。我写了一篇关于React-Router链接的博客</a><a class="ae kv" href="https://medium.com/weekly-webtips/react-client-side-routing-90873b96b429" rel="noopener">这里</a>。文件指出:</p><blockquote class="ls lt lu"><p id="ed72" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">“React Router使您的用户界面与URL保持同步。它有一个简单的API，内置了强大的功能，如惰性代码加载、动态路径匹配和位置转换处理。让URL成为你的第一个想法，而不是事后的想法。”</p></blockquote><p id="b44a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们导入包:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="9de2" class="me mf iq ma b gy mg mh l mi mj">yarn add react-router-dom </span></pre><p id="6b62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加后，我们就可以开始使用它了。我们需要两条路线。一个给我们所有的口袋妖怪导航到我们的网站，第二个当有人点击口袋妖怪卡查看更多信息。我们的路线将位于我们的<code class="fe mk ml mm ma b">App.js</code>中，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="01f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里需要注意的一点是，我们从React-Router导入了一些东西，但主要是利用了交换机和路由器，它们将按照文档中的说明完成以下工作:</p><blockquote class="ls lt lu"><p id="32ef" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">当一个<code class="fe mk ml mm ma b">&lt;Switch&gt;</code>被渲染时，它搜索它的<code class="fe mk ml mm ma b">children</code> <code class="fe mk ml mm ma b">&lt;Route&gt;</code>元素来找到一个其<code class="fe mk ml mm ma b">path</code>与当前URL匹配的元素。当它找到一个时，它渲染那个<code class="fe mk ml mm ma b">&lt;Route&gt;</code>并忽略所有其他的。这意味着你应该把更具体(通常更长)的<code class="fe mk ml mm ma b">&lt;Route&gt;</code> s放在不太具体的s之前。</p></blockquote><p id="3a2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来我们需要做的是将我们的卡变成一张<code class="fe mk ml mm ma b">&lt;Navlink /&gt;</code>。React-Router给了我们两种手段<code class="fe mk ml mm ma b">&lt;Link/&gt;</code>和<code class="fe mk ml mm ma b">&lt;Navlink /&gt;</code>。两者之间唯一显著的区别在于造型。更多信息，你可以在这里查看文档<a class="ae kv" href="https://reactrouter.com/web/api/NavLink" rel="noopener ugc nofollow" target="_blank">。让我们将它导入到我们的<code class="fe mk ml mm ma b">PokemonCard.js</code>中。这是导入语句:</a></p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0042" class="me mf iq ma b gy mg mh l mi mj">import { NavLink } from 'react-router-dom';</span></pre><p id="12b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在将带有<code class="fe mk ml mm ma b">‘card’</code>的<code class="fe mk ml mm ma b">className</code>的包装<code class="fe mk ml mm ma b">div</code>改为<code class="fe mk ml mm ma b">&lt;Navlink&gt;</code>元素。你仍然希望它缠绕在<code class="fe mk ml mm ma b">&lt;h3&gt;</code>和<code class="fe mk ml mm ma b">&lt;img&gt;</code>上。您还需要添加一个<code class="fe mk ml mm ma b">to=`/pokemon/${props.id}`</code>，我们将使用<code class="fe mk ml mm ma b">id</code>的<code class="fe mk ml mm ma b">props</code>将正确的口袋妖怪id插入到我们的URL中。我们还需要确保我们将道具传递给那个组件，但是我们需要一些新的道具。我们目前的道具只是让我们访问一个名字和另一个网址，其中有关于那个特殊口袋妖怪的更多信息。这意味着我们必须再次获取新的URL，将数据保存到state中，并将该状态传递给我们的新组件<code class="fe mk ml mm ma b">Pokemon.js</code>。<code class="fe mk ml mm ma b">Pokemon.js</code>应该是功能组件。</p><h2 id="da47" class="me mf iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">获取特定数据</h2><p id="9aff" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">让我们在我们的<code class="fe mk ml mm ma b">services</code>目录中创建一个名为<code class="fe mk ml mm ma b">pokemon.js</code>的新文件。在这个文件中，我们将编写可导出的函数来处理获取请求的开始。这看起来与我们的第一个获取请求几乎相同。以下是我的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="45ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最大的不同是我们给这个函数传递了一个<code class="fe mk ml mm ma b">pokeId</code>,以确保我们的URL显示正确的口袋妖怪id。就这样，我们把这个函数导入到<code class="fe mk ml mm ma b">PokemonCard.js</code>中，导入<code class="fe mk ml mm ma b">useState</code>和<code class="fe mk ml mm ma b">useEffect</code>。我们将需要<code class="fe mk ml mm ma b">useState</code>并设置状态，以将这些新属性传递给我们的<code class="fe mk ml mm ma b">Pokemon.js</code>组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a0db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个状态，包含了关于口袋妖怪的所有更详细的信息。但是等等，我们如何将道具传递给一个<code class="fe mk ml mm ma b">&lt;Navlink&gt;</code>元素呢？我们在<code class="fe mk ml mm ma b">&lt;Navlink&gt;</code>元素的<code class="fe mk ml mm ma b">to=''</code>语句中这样做。这是一个关于它如何工作的非常有用的博客。以下是我们的Navlink代码:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="8934" class="me mf iq ma b gy mg mh l mi mj">&lt;NavLink className='card'<br/>to={{ pathname: `/pokemon/${props.id}`, pokemon: { ...pokemon } }}<br/>&gt;</span></pre><p id="f422" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们现在可以通过<code class="fe mk ml mm ma b">location</code>访问以下数据。在<code class="fe mk ml mm ma b">Pokemon.js</code>中，您可以使用<code class="fe mk ml mm ma b">console.log()</code>进行测试。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="fc27" class="me mf iq ma b gy mg mh l mi mj">console.log(props.location.pokemon)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6c3c30771eec69d889d21bd341d21ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*y5qERocEEHTRhVqZnx_5-g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">console.log</figcaption></figure><h2 id="79f0" class="me mf iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">使用我们的数据</h2><p id="a999" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">哇！看看那些可爱的口袋妖怪数据！我知道我想让这个页面看起来几乎像一个真正的口袋妖怪卡，或者至少是类似的东西。所以我想得到下面的数据并将其销毁。析构是一个JavaScript特性，它允许我们从一个数组或对象中提取多段数据，并将它们赋给自己的变量。由于我们的数据的性质，每次我们想要访问一个新的属性时，我们都必须键入<code class="fe mk ml mm ma b">props.location.pokemon.someProperty</code>,这是重复且耗时的。作为黑客，我们很懒，想做最少的工作。我们也希望我们的代码非常简洁易读。析构是一个很好的工具。关于解构的更多信息，请看这个<a class="ae kv" href="https://medium.com/@lcriswell/destructuring-props-in-react-b1c295005ce0" rel="noopener">博客</a>。我们的析构道具应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="bb35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以在JSX中简单地使用道具名称，而不必输入长长的道具链。</p><p id="871d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回头看看之前的<code class="fe mk ml mm ma b">console.log()</code>数据，我们可以看到我们的三个属性是数组中的嵌套对象。因此，我们必须在数据中进行映射，并找到我们希望显示的对象的键/值对。下面是我为<code class="fe mk ml mm ma b">Pokemon.js</code>编写的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="86ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深入研究一下我们的一张地图，以了解到底发生了什么。在我们的能力数组中，我们映射并定位数组中的每个能力对象。在每一个能力对象中，我们都有一个能力键，它让我们可以访问这个名字的值。使用括号符号(<a class="ae kv" href="https://rossbulat.medium.com/react-native-working-with-objects-aff45bff6832" rel="noopener">这里</a>是一个关于在React中使用对象的有用博客)，我们可以访问该值，并在能力数组中显示每个能力对象的值。有了那个，我们应该可以点击一个口袋妖怪卡片，看到各种新的数据！太棒了。但是如果我们刷新页面会发生什么呢？？？哦不！一切都坏了。</p><h2 id="913a" class="me mf iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">重构</h2><p id="7c0a" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我很想说我把这一切都计划成一个学习的机会，但我没有。哈哈，这只是我一路上忘记的事情。唉，这对我们所有人来说都是一次很好的学习经历！一切都崩溃了，因为我们不再能够访问id来传递给我们的fetch请求，那么我们该如何做呢？</p><p id="830e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先将我们的<code class="fe mk ml mm ma b">useState</code>和<code class="fe mk ml mm ma b">useEffect</code>移动到实际的<code class="fe mk ml mm ma b">Pokemon.js</code>中。一旦我们这样做了，我们将能够停止在我们的析构中使用<code class="fe mk ml mm ma b">props.location.pokemon</code>。我们将使用一个名为<code class="fe mk ml mm ma b">useLocation</code>的React-Router钩子来代替。<code class="fe mk ml mm ma b">useLocation</code>钩子由React-Router提供给我们，需要导入到我们的<code class="fe mk ml mm ma b">Pokemon.js</code>文件的顶部。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="e19b" class="me mf iq ma b gy mg mh l mi mj">import { useLocation } from 'react-router-dom';</span></pre><p id="fad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们<code class="fe mk ml mm ma b">console.log(location)</code>，我们看到我们有一个看起来像这样的物体:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d5b9980535d533bdb9b8b93fd6a2a50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*nexmvV1gjzwva-U5K98UTQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">console.log(location)</figcaption></figure><p id="b4be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，酷。我们知道，当我们获取时，我们当前正在内插<code class="fe mk ml mm ma b">id</code>，但是如果我们只是使用<code class="fe mk ml mm ma b">pathname</code>来内插我们的URL，那么在刷新时，我们将传入当前的<code class="fe mk ml mm ma b">location.pathname</code>而不是<code class="fe mk ml mm ma b">id</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d46c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们改变我们的获取来获取<code class="fe mk ml mm ma b">pathname</code>而不是<code class="fe mk ml mm ma b">id</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6c91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会得到一些映射属性(能力，属性和类型)的错误。我们将不能析构这些属性，因为我们必须短路(这在本系列的第一篇博客中已经讨论过了)。这是我们<code class="fe mk ml mm ma b">Pokemon.js</code>的最终代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="50d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们就有了口袋妖怪展示页面的所有数据！这真是太棒了！它看起来很粗糙，但是很实用。敬请期待一些造型。我希望让这些看起来像实际的口袋妖怪卡，并根据类型改变背景颜色。我们还将增加一些生活质量的改善，如后退按钮，以便用户可以返回到所有口袋妖怪的页面。希望这是有帮助的，你和我一起建立这个有乐趣！😁</p><p id="c892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是Github上<a class="ae kv" href="https://github.com/Jordeks/personal-pokedex" rel="noopener ugc nofollow" target="_blank">库</a>的链接。</p><p id="57b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="lv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>