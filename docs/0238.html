<html>
<head>
<title>Why You Should Know Bubble Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该知道冒泡排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-should-know-how-to-bubble-sort-752f09b5e51c?source=collection_archive---------20-----------------------#2021-01-13">https://javascript.plainenglish.io/why-you-should-know-how-to-bubble-sort-752f09b5e51c?source=collection_archive---------20-----------------------#2021-01-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cc2f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">因为知道了就不会用了</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/bf5376627a740299fbc9863759f4b13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*jm4rUEmyxPVXVe8ArE91oQ.png"/></div></figure><p id="cee0" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">冒泡排序</strong>，是一个简单的算法，它反复遍历列表，比较相邻的元素，如果它们的顺序不对，就交换它们。重复遍历列表，直到列表被排序。这种比较算法是以较小或较大的元素“冒泡”到列表顶部的方式命名的。</p><p id="d82a" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这种简单的算法在大型或真实世界中表现不佳，主要用作教育工具。诸如<a class="ae lg" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank">快速排序</a>、<a class="ae lg" href="https://en.wikipedia.org/wiki/Timsort" rel="noopener ugc nofollow" target="_blank">时间排序</a>或<a class="ae lg" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank">合并排序</a>等更高效的算法被内置于Python和Java等流行编程语言中的排序库所使用。</p><p id="85d0" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">虽然冒泡排序是理解和实现起来最简单的排序算法之一，但是它的<a class="ae lg" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"><em class="lh">O</em>(<em class="lh">n</em>2)</a>复杂性意味着它的效率在包含少量元素的列表上会显著降低。即使在简单的<em class="lh"> O </em> ( <em class="lh"> n </em> 2)排序算法中，像<a class="ae lg" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">插入排序</a>这样的算法通常要高效得多。</p><p id="5941" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">由于其简单性，冒泡排序经常被用来向计算机科学的入门学生介绍算法或排序算法的概念。</p><h1 id="5e40" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">分步示例</h1><pre class="kd ke kf kg gt ma mb mc md aw me bi"><span id="5212" class="mf lj in mb b gy mg mh l mi mj"><strong class="mb io"><em class="lh">First Pass</em></strong><br/>( <strong class="mb io">5</strong> <strong class="mb io">1</strong> 4 2 8 ) → ( <strong class="mb io">1</strong> <strong class="mb io">5</strong> 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 &gt; 1.<br/>( 1 <strong class="mb io">5</strong> <strong class="mb io">4</strong> 2 8 ) → ( 1 <strong class="mb io">4</strong> <strong class="mb io">5</strong> 2 8 ), Swap since 5 &gt; 4<br/>( 1 4 <strong class="mb io">5</strong> <strong class="mb io">2</strong> 8 ) → ( 1 4 <strong class="mb io">2</strong> <strong class="mb io">5</strong> 8 ), Swap since 5 &gt; 2<br/>( 1 4 2 <strong class="mb io">5</strong> <strong class="mb io">8</strong> ) → ( 1 4 2 <strong class="mb io">5</strong> <strong class="mb io">8</strong> ), Now, since these elements are already in order (8 &gt; 5), algorithm does not swap them.</span><span id="3139" class="mf lj in mb b gy mk mh l mi mj"><strong class="mb io"><em class="lh">Second Pass</em></strong><br/>( <strong class="mb io">1</strong> <strong class="mb io">4</strong> 2 5 8 ) → ( <strong class="mb io">1</strong> <strong class="mb io">4</strong> 2 5 8 )<br/>( 1 <strong class="mb io">4</strong> <strong class="mb io">2</strong> 5 8 ) → ( 1 <strong class="mb io">2</strong> <strong class="mb io">4</strong> 5 8 ), Swap since 4 &gt; 2<br/>( 1 2 <strong class="mb io">4</strong> <strong class="mb io">5</strong> 8 ) → ( 1 2 <strong class="mb io">4</strong> <strong class="mb io">5</strong> 8 )<br/>( 1 2 4 <strong class="mb io">5</strong> <strong class="mb io">8</strong> ) → ( 1 2 4 <strong class="mb io">5</strong> <strong class="mb io">8</strong> )</span><span id="d493" class="mf lj in mb b gy mk mh l mi mj">Now, the array is already sorted, but the algorithm does not know if it is completed. The algorithm needs one <strong class="mb io">whole</strong> pass without <strong class="mb io">any</strong> swap to know it is sorted.</span><span id="f0e5" class="mf lj in mb b gy mk mh l mi mj"><strong class="mb io"><em class="lh">Third Pass</em></strong><br/>( <strong class="mb io">1</strong> <strong class="mb io">2</strong> 4 5 8 ) → ( <strong class="mb io">1</strong> <strong class="mb io">2</strong> 4 5 8 )<br/>( 1 <strong class="mb io">2</strong> <strong class="mb io">4</strong> 5 8 ) → ( 1 <strong class="mb io">2</strong> <strong class="mb io">4</strong> 5 8 )<br/>( 1 2 <strong class="mb io">4</strong> <strong class="mb io">5</strong> 8 ) → ( 1 2 <strong class="mb io">4</strong> <strong class="mb io">5</strong> 8 )<br/>( 1 2 4 <strong class="mb io">5</strong> <strong class="mb io">8</strong> ) → ( 1 2 4 <strong class="mb io">5</strong> <strong class="mb io">8</strong> )</span></pre><h1 id="3b7c" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">分步编码示例</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/d92de8763c22f55e1b3d32c2c5d84e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCi5VDj-lQAXkPwZ0ZLVsA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Step 1</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mu"><img src="../Images/005f2fd73aec5f66edbfdd79dd8350b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztqkPIEDSr4vCh9lZcMg2A.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Step 2</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mv"><img src="../Images/02ace9a0a0223ec98307649caf4271bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8SgjIYG6mFobyRadfLgtw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Step 3</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mw"><img src="../Images/313cce86206d2ed064daaa88e54a2fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTcMC5FqbFV7BXY7QlmyvQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Step 4</figcaption></figure><h2 id="4316" class="mf lj in bd lk mx my dn lo mz na dp ls kt nb nc lu kx nd ne lw lb nf ng ly nh bi translated">冒泡排序的优化版本</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ni"><img src="../Images/1b43196f2606d08dcfcc8a7b52121b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gb9IgWgcmVoSr_JTUDExaA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Checking if the first loop(i) pass at least one time without swapping, then prevent unnecessary loops</figcaption></figure><p id="f744" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">更普遍的情况是，在一次扫描中，可能会有一个以上的元素被放置在它们的最终位置。特别是，在每一遍之后，最后一次交换之后的所有元素都被排序，并且不需要再次检查。这允许跳过许多元素，导致在最坏的情况下比较计数提高了50%。</p><h1 id="1673" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">表演</h1><p id="b757" class="pw-post-body-paragraph kk kl in km b kn nj jo kp kq nk jr ks kt nl kv kw kx nm kz la lb nn ld le lf ig bi translated">冒泡排序的最坏情况和平均复杂度为<a class="ae lg" href="https://en.wikipedia.org/wiki/Big_o_notation" rel="noopener ugc nofollow" target="_blank"><em class="lh">о</em></a>(<em class="lh">n</em>2)，其中<em class="lh"> n </em>是被排序的项目数。大多数实用的排序算法具有更好的最坏情况或平均复杂度，通常是<em class="lh">O</em>(<em class="lh">n</em>log<em class="lh">n</em>)。甚至其他的<em class="lh">о</em>(<em class="lh">n</em>2)排序算法，比如<a class="ae lg" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">插入排序</a>，一般都比冒泡排序运行的更快，也不会更复杂。因此，冒泡排序不是一种实用的排序算法。</p><p id="0fac" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">冒泡排序优于大多数其他算法，甚至优于<a class="ae lg" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank">快速排序</a>，但优于<a class="ae lg" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">插入排序</a>的唯一显著优势是，检测列表是否被有效排序的能力内置于算法中。当列表已经排序时(最好的情况)，冒泡排序的复杂度只有<em class="lh"> O </em> ( <em class="lh"> n </em>)。相比之下，大多数其他算法，甚至那些具有更好的<a class="ae lg" href="https://en.wikipedia.org/wiki/Average-case_complexity" rel="noopener ugc nofollow" target="_blank">平均情况复杂度</a>的算法，在集合上执行它们的整个排序过程，因此更加复杂。然而，<a class="ae lg" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">插入排序</a>不仅具有这一优势，而且在基本排序的列表上(具有少量的<a class="ae lg" href="https://en.wikipedia.org/wiki/Inversion_(discrete_mathematics)" rel="noopener ugc nofollow" target="_blank">反转</a>)表现更好。此外，如果需要这种行为，可以在算法运行前通过检查列表将其添加到任何其他算法中。</p><p id="226e" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在大集合的情况下，应该避免冒泡排序。在逆序收集的情况下，这将是无效的。</p><h1 id="95b0" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">奖金</h1><p id="7516" class="pw-post-body-paragraph kk kl in km b kn nj jo kp kq nk jr ks kt nl kv kw kx nm kz la lb nn ld le lf ig bi translated">前谷歌首席执行官埃里克·施密特在一次采访中问当时的总统候选人巴拉克·奥巴马排序一百万整数的最佳方式，奥巴马停顿了一下，然后回答道:“我认为冒泡排序是错误的。”</p></div></div>    
</body>
</html>