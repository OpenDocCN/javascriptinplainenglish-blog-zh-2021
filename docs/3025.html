<html>
<head>
<title>TypeScript: Conditional Subtypes Using ‘as clause’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:使用“as子句”的条件子类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-conditional-subtypes-using-as-clause-2dd9896d67dc?source=collection_archive---------11-----------------------#2021-06-19">https://javascript.plainenglish.io/typescript-conditional-subtypes-using-as-clause-2dd9896d67dc?source=collection_archive---------11-----------------------#2021-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9f13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用Typescript的映射类型和"<em class="ki"> as子句"</em>,有条件地创建子类型。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7ea2e56fa1e62720863374ef4af74f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UROfn26fkxqT6Bk_jGOw1w.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">cottonbro</a> from <a class="ae kz" href="https://www.pexels.com/photo/boy-in-white-t-shirt-sitting-on-chair-in-front-of-computer-4709285/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><h1 id="f142" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">问题陈述</h1><p id="b1f8" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">在一个项目中，我遇到了一个用例，我需要从一个父类型中派生出一个子类型，只包含预定义类型的键。</p><p id="615b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们举个例子，假设我有一个名为<strong class="jm io"> Address的类型。</strong></p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="2480" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">Address</strong> = {<br/>id: string,<br/>name: string,<br/>surname: string,<br/>country: string,<br/>state: string,<br/>landmark: string,<br/>pincode: number,<br/>isHomeAddress: boolean,<br/>isRentedAddress: boolean<br/>}</span></pre><p id="41ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，现在我想从上面的地址类型中创建一个子类型，它应该只包含boolean类型的键。</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="9d9c" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">AddressBoolean</strong> ={<br/>isHomeAddress: boolean,<br/>isRentedAddress: boolean<br/>}</span></pre><h1 id="e367" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">解决方案</strong></h1><p id="2cb0" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">TypeScript <em class="ki">映射的类型</em>在解决这类问题时很方便，您可以通过转换给定的类型来创建新的类型。</p><p id="ef48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在回到解决我们的问题。</p><p id="9ab0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们的父类型为:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="1ae6" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">Address</strong> = {<br/>id: string,<br/>name: string,<br/>surname: string,<br/>country: string,<br/>state: string,<br/>landmark: string,<br/>pincode: number,<br/>isHomeAddress: boolean,<br/>isRentedAddress: boolean,<br/>}</span></pre><p id="477a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的预期结果应该是</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="e154" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">AddressBoolean</strong> = {<br/>isHomeAddress: boolean,<br/>isRentedAddress: boolean,<br/>}</span></pre><p id="2cb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们一步一步解决这个问题。</p><h2 id="d3e3" class="mi lb in bd lc mn mo dn lg mp mq dp lk jv mr ms lo jz mt mu ls kd mv mw lw mx bi translated"><strong class="ak"> 1)移除不需要的类型</strong></h2><p id="5a48" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">首先，我们会将地址中不需要的类型标记为<em class="ki"> never </em> type。</p><p id="0f8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们对它使用条件类型。</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="85bd" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">RequiredTypes&lt;T, C&gt;</strong> = {<br/>[Key in keyof T]: T[Key] extends C ? T[Key] : never<br/>}</span></pre><p id="2804" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码将检查地址类型中的哪种类型扩展了条件(C)。它会将<em class="ki"> never </em>类型分配给所有其他不符合我们条件的键。</p><blockquote class="my mz na"><p id="1700" class="jk jl ki jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated">永不<em class="in">类型是永不不能有任何值的类型。与typescript的任何类型<em class="in">相反，这意味着不能给它赋值。</em></em></p></blockquote><p id="63a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用法</strong></p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="f04a" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">MarkAsNever</strong> = RequiredTypes&lt;Address, boolean&gt;</span></pre><p id="1801" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ne nf ng me b">MarkAsNever</code>类型看起来像这样</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="d0dc" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">MarkAsNever</strong> = {<br/>Id: never,     <br/>name: never,     <br/>surname: never,     <br/>country: never,     <br/>state: never,     <br/>landmark: never,     <br/>pincode: never,     <br/>isHomeAddress: boolean,     <br/>isRentedAddress: boolean, <br/>}</span></pre><p id="610b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，除了<code class="fe ne nf ng me b">isHomeAddress</code>和<code class="fe ne nf ng me b">isRentedAddress</code>之外，RequiredTypes类型已经将“从不”分配给了地址的所有其他键。</p><h2 id="4c19" class="mi lb in bd lc mn mo dn lg mp mq dp lk jv mr ms lo jz mt mu ls kd mv mw lw mx bi translated">2)删除never类型的键</h2><p id="474f" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">现在我们到了最后一步，那就是移除没有<em class="ki">的类型。为此，我们将使用<em class="ki">作为typescript 4.1中引入的子句</em>。</em></p><p id="1122" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于子句有一个很好的特性，你可以通过条件属性产生never来过滤掉密钥。</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="ffeb" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">RemoveNeverField&lt;T&gt;</strong> = { <br/>  [P in keyof T as T[P] extends never ? never : P]: T[P] <br/>};</span></pre><p id="d9ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们循环遍历T的所有键，如果键的类型是<em class="ki"> never </em>，我们的条件将返回never，这将被<em class="ki"> as子句自动忽略。</em>所以，到最后，我们只会拥有非never键。</p><p id="f307" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用法</strong></p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="9a4c" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">OnlyBoolean</strong> = RemoveNeverField&lt;onlyBoolean&gt;</span></pre><p id="11e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在<code class="fe ne nf ng me b">OnlyBoolean</code>型会是下面这个样子。就像我们想要的那样。👌</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="835c" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">OnlyBoolean</strong> = {     <br/>  isHomeAddress: boolean,     <br/>  isRentedAddress: boolean, <br/>}</span></pre><h2 id="c786" class="mi lb in bd lc mn mo dn lg mp mq dp lk jv mr ms lo jz mt mu ls kd mv mw lw mx bi translated">让我们总结一下所有需要的步骤</h2><p id="8d91" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi">1</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="bd24" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">RequiredTypes&lt;T, C&gt;</strong> = {   <br/>   [Key in keyof T]: T[Key] extends C ? T[Key] : never <br/>}</span></pre><p id="cbf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">2</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="ed9d" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">RemoveNeverField&lt;T&gt;</strong> = { <br/>  [P in keyof T as T[P] extends never ? never : P]: T[P] <br/>};</span></pre><p id="9c5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以进一步缩短语法。通过直接使用<code class="fe ne nf ng me b">RemoveNeverField</code>中的<code class="fe ne nf ng me b">RequiredTypes</code>代码，创建一个新的类型，比如说<code class="fe ne nf ng me b">PickByType</code>。</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="83c3" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">PickByType&lt;T, C&gt;</strong> = RemoveNeverField&lt;{ <br/>    [Key in keyof T]: T[Key] extends C ? T[Key] : never <br/>}&gt;</span></pre><p id="fed3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用法</strong></p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="6692" class="mi lb in me b gy mj mk l ml mm">PickByType&lt;Address, boolean&gt;</span></pre><p id="c066" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，您可以利用联合(|)类型并忽略父类型地址中的多个类型。</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="c939" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">PickTwo</strong> = PickByType&lt;Address, boolean | number&gt;</span></pre><p id="76ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，输出将是</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="98a3" class="mi lb in me b gy mj mk l ml mm">type <strong class="me io">PickTwo</strong> = {<br/>    pincode: number;<br/>    isHomeAddress: boolean;<br/>    isRentedAddress: boolean;<br/>}</span></pre></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="5e96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">恭喜🎉我们已经创建了我们的类型，它可以基于作为条件提供的类型生成一个子类型。</p><p id="1f7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你今天学到了一些新东西。</p><p id="44eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">最初发表于</em><a class="ae kz" href="https://asyncawait.co/typescript-conditional-subtypes-using-as-clause" rel="noopener ugc nofollow" target="_blank">https://async await . co/typescript-conditional-subtype-using-as-clause</a></p><p id="2bb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容尽在</em><a class="ae kz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">plain English . io</em></strong></a></p></div></div>    
</body>
</html>