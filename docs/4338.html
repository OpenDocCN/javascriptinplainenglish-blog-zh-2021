<html>
<head>
<title>Should a React Context Be That Expensive?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React上下文应该这么贵吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/should-a-context-provider-be-that-expensive-7cafa3727507?source=collection_archive---------3-----------------------#2021-08-29">https://javascript.plainenglish.io/should-a-context-provider-be-that-expensive-7cafa3727507?source=collection_archive---------3-----------------------#2021-08-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5a9d187186d7170cdc55ea807bf0ab4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SW3wAyrH7U0qgjiM"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c487" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React context提供了一种方法，这样我们就可以在纤程树中共享一个值。在给定名称上下文的情况下，它将这个值存储在一个单独的存储中，而不是与纤程一起存储。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="43cf" class="lh li in ld b gy lj lk l ll lm">const Context = React.createContext(0)</span></pre><p id="b397" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在上下文给了我们一种不同的组件，叫做<code class="fe ln lo lp ld b">ContextProvider</code>。就像<code class="fe ln lo lp ld b">FunctionComponent</code>、<code class="fe ln lo lp ld b">ClassComponent</code>、<code class="fe ln lo lp ld b">MemoComponent</code>、<code class="fe ln lo lp ld b">ContextProvider</code>都有自己的更新机制。</p><p id="6440" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们到达一个<code class="fe ln lo lp ld b">FunctionComponent</code>时，它渲染并协调它的子节点，然后继续第一个子节点，继续由一个分派(或调度)引起的渲染工作。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/eff8589baf922a2bda4d73df348dabd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*KTeWdYqEVa5-iYLP-80G1A.png"/></div></figure><p id="90ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于一个典型的分派，比如在<code class="fe ln lo lp ld b">useState</code>的情况下，当渲染开始时，它会遍历根的顶部，找到状态发生变化的源纤程，结束一条由红线指示的路径。</p><p id="9b3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而一个<code class="fe ln lo lp ld b">ContextProvider</code>做的还不止这些。</p><h2 id="1901" class="lh li in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">联合更新</h2><p id="4252" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">假设有三个消费者，在没有上下文的情况下，我们将不得不进行多次分派，将每个消费者纤维视为源纤维。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/44f8ecf2d753b605c4fce9c1bf02dd54.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*gK3Ozacq-v9p54IhxgK_pA.png"/></div></figure><p id="fce0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这正是上下文提供者所要填充的，但是它做得更被动一些。假设提供程序安装在更高的级别，用黑色圆圈表示。当更新开始时，它会执行搜索。</p><p id="2b94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">搜索是递归地查找所有的消费者，这样就不会遗漏提供者下面的任何消费者。对于每个匹配的消费者，它被标记为要呈现(不久之后)。标记过程几乎与单个派遣作业中的过程一样，但是是为每个消费者完成的。</p><p id="08c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么我们说更新一个上下文值是昂贵的。</p><p id="f0df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看一个例子，其中两个消费者Child和Child2位于一个提供者之下。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/6fd48759e61b23938349a625ca7bf5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOBWdrZTMWIWciRaKhs60w.png"/></div></div></figure><p id="534a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当提供商发生变化时(例如由于Branch2)，提供者下面的所有子元素都呈现，而不仅仅是消费者。</p><h2 id="f61f" class="lh li in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">过度渲染</h2><p id="5f05" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">那么React在这里如何发挥聪明呢？有一些，但不多。该应用程序以及分支机构(例如。支路1，未示出)。但是如果我们不小心(通常我们不小心)，提供者更新可能会导致类似于挂载中发生的情况的强制重新呈现。</p><p id="c896" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比方说，我们能为孩子和孩子做的不多。但是我们想看看是否可以避免提供者和Child2之间的渲染。这是我们可以添加一个<code class="fe ln lo lp ld b">React.memo</code>到标题的地方，它是Child2的祖先，是提供者的子元素。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/eb45a8cc7fb07df8f543c791ed566044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZPW95aJbBathr8pWuRu4g.png"/></div></div></figure><p id="1fc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在单个分派的情况下，从根到源光纤之间的光纤被拉出，如深灰色所示。你仍然可以看到这个应用程序的颜色。</p><p id="9670" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，在联合更新的情况下，React未能挽救从提供者到Child2的路径。这是因为一旦提供者获得更新，根据设计，它必须协调和呈现所有子节点。一旦开始，火车就不能停下来，除非有另一个机制。有关更多信息，请参见文章【React如何基于更改进行渲染。</p><p id="f3a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，<code class="fe ln lo lp ld b">React.memo</code>使用了一个技巧来回收丢失的优化。因此，我们可以认为根有一个内置的<code class="fe ln lo lp ld b">React.memo</code>，所以它自然会被保释出来，但对于提供者来说，这并不是自动烘焙的。</p><h2 id="bb60" class="lh li in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">摘要</h2><p id="2695" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">总而言之，上下文为我们提供了共享变量和为所有消费者触发联合更新的方法。如果提供者和孩子之间的路径没有优化，代价可能会很高，因为React不会在幕后为您处理这一点。</p><h2 id="e9dd" class="lh li in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">附录</h2><p id="2307" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">如果这一切都有意义，我们应该能够将<code class="fe ln lo lp ld b">ContextProvider</code>和<code class="fe ln lo lp ld b">memo</code>结合在一起，以确保所有的孩子都能自动获得救助。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="597a" class="lh li in ld b gy lj lk l ll lm">function Branch2() {<br/>  const [count, setCount] = useState(0)<br/>  const onClick = () =&gt; { setCount(c =&gt; c + 1) }<br/>  return (<br/>    &lt;AContext.Provider value={count}&gt;<br/>        &lt;div onClick={onClick}&gt;{count}&lt;/div&gt;<br/>        &lt;AMemo /&gt;<br/>    &lt;/AContext.Provider&gt;<br/>  )<br/>}</span></pre><p id="5065" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们用一个<code class="fe ln lo lp ld b">AMemo</code>包装所有的儿童消费者，它使用了我们根据本文的想法构建的自定义组件，【useMemo可以用来跳过儿童渲染吗？</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2cbd" class="lh li in ld b gy lj lk l ll lm">const AMemo = memoChild(() =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Child /&gt;<br/>      &lt;Title /&gt;<br/>    &lt;/&gt;<br/>  )<br/>})</span></pre><p id="e548" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们有了与单个调度案例中的根到源光纤相同的行为。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/868e84fd39fe4af6585ac39f37abcda7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbwVZ1-ekFs0yMhg4XP6-g.png"/></div></div></figure><p id="184b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上图不就是上下文提供者的默认行为吗？有了这种行为，我们还会认为上下文提供者很昂贵吗？</p><p id="3d5f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>