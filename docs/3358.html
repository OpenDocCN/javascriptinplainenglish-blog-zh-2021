<html>
<head>
<title>I Made A JavaScript Single Page Application And This Is What I Learned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我做了一个JavaScript单页应用程序，这是我学到的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-made-a-javascript-single-page-application-and-this-is-what-i-learned-838f16a4c67?source=collection_archive---------8-----------------------#2021-07-08">https://javascript.plainenglish.io/i-made-a-javascript-single-page-application-and-this-is-what-i-learned-838f16a4c67?source=collection_archive---------8-----------------------#2021-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e8ac3630b119711de144f057ea25ec0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jp4LsxtIv7h9zhr_8TrYSw.jpeg"/></div></div></figure><p id="6b2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在熨斗学校软件工程项目的倒数第二个项目中，我必须创建一个单页面应用程序，用JavaScript处理前端，用Rails作为后端的API。这些是我想传达给其他正在用这个框架构建东西的人的重要信息。</p><ol class=""><li id="8057" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io"> JavaScript fetch调用和Rails批量赋值</strong></li></ol><p id="a5d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于从JavaScript前端向Rails后端发送信息，了解Rails中批量赋值的工作方式非常重要。了解如何在fetch调用中构造body参数可以使创建模型及其子模型的新实例变得更加容易。为了举例，我们假设模型是:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="7bc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">列表有标题，项目有名称。为了创建一个新的列表和多个条目，我们需要使用fetch()方法，并确保我们告诉它我们使用的是POST方法。body参数是神奇的地方。如果您还记得上面的列表类，它有<code class="fe li lj lk ll b">accepts_nested_attributes_for</code>类方法。这将定义一个名为<code class="fe li lj lk ll b">items_attributes</code>的属性写入器，然后可以在list_params方法中使用，比如:<code class="fe li lj lk ll b">params.require(:list).permit(:title, items_attributes: [:name])</code>。考虑到这一点，在前端，fetch()调用的主体应该是结构化的，以便Rails可以获取这些信息，并通过批量赋值一次创建所有内容。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="7df4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果操作正确，您可以将fetch()调用发送到<code class="fe li lj lk ll b">/lists</code>，并在控制器方法列表#create中创建一个新列表和与之关联的5个新项目，并将它们一次性保存到数据库中。这些关于Rails的知识有助于向后端发送信息，但是如何接收信息并将其用于前端应用程序呢？</p><p id="a939" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.<strong class="jx io">用序列化器渲染Rails】</strong></p><p id="dffe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们要检索一组列表及其相关条目，它们被收集在Rails的列表控制器中。然后它们被呈现在JSON中，这样前端就可以使用这些信息在DOM中显示。最有效的方法是创建一个序列化程序类，以便只允许您想要的数据，而不会有任何多余的数据。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="a829" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在控制器中收集列表后，可以使用ListSerializer呈现它们:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="663f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将在JSON中的<code class="fe li lj lk ll b">/lists</code>地址呈现数据库中的所有列表，供前端收集。请注意，它包括了相关条目的列表以及条目的id和name属性，但不包括列表数据库中的<code class="fe li lj lk ll b">:created_at</code>和<code class="fe li lj lk ll b">:updated_at</code>列。由于列表模型使用的是<code class="fe li lj lk ll b">has_many :items</code>关联，因此它获得了<code class="fe li lj lk ll b">List.items</code>关联方法，然后我们可以在ListSerializer类中使用该方法来呈现项目和列表。</p><p id="2ca2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一切都很好，只要你能很好地按照它们被创建的顺序来呈现它们，但是如果你想让它们以另一种方式排序，比如字母顺序，那该怎么办呢？首先，创建一个实例方法来处理列表模型中的排序:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="a7db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以使用<code class="fe li lj lk ll b">items_sorted</code>方法并将其放入ListSerializer。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="899c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些项目现在将按字母顺序呈现！只要您在序列化程序中使用方法名，任何对关联进行排序的实例方法都适用于此。这对于一些人来说可能是显而易见的，但这是我在为我的项目摆弄数据时发现的。从Rails呈现数据时，将数据组织好要比试图用JavaScript在前端组织数据容易得多。</p><p id="16d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.<strong class="jx io">遇到困难时，不要忘记先检查简单的东西</strong></p><p id="c521" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一个例子，我将呈现一个个人轶事。我要传达的内容对许多读者来说可能是显而易见的。在大多数情况下，我不会落入我将很快揭示的陷阱，但有时我仍然发现自己跳过了一些小事，试图找到一个过于复杂的解决方案来解决一个令人尴尬的简单问题。事实上，在这个项目中，我被它烧伤了，最后在电脑前扯了很长时间的头发。当我最终意识到这个问题，以及它是多么的简单时，我真的笑出声来，因为我让它持续了这么久。这是一个令人羞愧的考验，对于大多数阅读这篇文章的人来说，这可能是非常明显的，但我觉得在编写代码时经常出现，值得一提。</p><p id="e87b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我已经编写了代码来提交一个由输入和选择元素组成的表单元素。这意味着一个事件监听器连接到一个按钮上，当点击这个按钮时，它会调用一个fetch()方法将表单信息发送到后端Rails API，创建必要的模型并将它们保存到数据库中，然后用JSON呈现这些新模型，这些新模型可以在前端抓取并显示在DOM中。问题是当点击提交按钮时，模型将被创建并保存在后端，但页面上不会显示任何内容。因为问题似乎只出在前端，所以我立即跳转到promise fulfillment then()方法和我在其中创建并调用的函数，以在页面上显示模型数据。我看不出有任何问题，控制台中也没有任何错误来告诉我发生了什么问题。我修改了处理DOM的函数，但毫无效果，并反复阅读了从fetch()调用开始的代码，直到我眼花缭乱。</p><p id="1440" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好好休息一下后(另一个明显但有用的提示！)我最终决定从提交按钮上的事件监听器开始查看这个序列的最开始。这时，我注意到在事件监听器的回调函数中，我没有使用<code class="fe li lj lk ll b">preventDefault()</code>。因为我没有使用标准的HTML表单提交，也没有在表单元素本身中提供动作，所以这个函数对于阻止页面正常提交表单数据是必要的。一旦我纠正了这一点，我又尝试了所有的东西，然后“击鼓*”。还是不行。然而，并没有全部丢失，因为我现在在控制台中得到一个“变量未定义”的错误。在查找错误引用的代码行时，我立即注意到我拼错了一个变量，我用它作为函数调用的参数。两个非常小而简单的错误花费了比应该花费的更多的时间来修复。这里的教训是不要忘记从简单开始。试图跳过简单的事情几乎是本能地发生的，无论是因为你认为那些事情太简单而不能搞砸，还是因为问题一定出在事情更复杂的地方。简单的事情几乎不需要任何时间来检查，所以即使问题不在那里，你也不会因为先检查那里而损失太多。</p><p id="e2ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像任何编码项目一样，这是一次学习的经历，而且我在很多方面都觉得受益匪浅。我为自己能够创造的东西感到自豪，但同时也对自己作为开发人员的优势和劣势有了新的关注。当我进入熨斗计划的最后一部分时，我对自己取得的进步感觉良好，并对我将从事的所有未来项目感到兴奋。</p><p id="184c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lm">更多内容尽在</em><a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>