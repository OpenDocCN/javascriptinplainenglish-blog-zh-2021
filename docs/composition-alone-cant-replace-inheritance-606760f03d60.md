# 单纯的构图不能代替继承

> 原文：<https://javascript.plainenglish.io/composition-alone-cant-replace-inheritance-606760f03d60?source=collection_archive---------2----------------------->

![](img/75bdd023bf35998ae5b074f65af6e08f.png)

在小吃部，你可以听到一些同事在争论制表符和空格。在你左边的某个地方，你的团队领导，Amanda，正在自言自语，她试图对她一直在研究的算法进行推理。但是你什么都没注意到，你在状态中。几个月后，这个游戏工作室将发布下一个最热门的游戏，“独角兽大战怪物”，而这个游戏甚至还没有怪物！今天结束时，这种情况将会改变。

你往后一靠，想想这个游戏将包含的各种各样的怪物。粘液、骷髅、小丑老板等等——它们都非常相似，但它们都有独特的特征——尤其是那个小丑老板，他有一个令人讨厌的习惯，就是在战斗中制作过场动画(你就是无法说服利益相关者放弃这个习惯)。不需要天才就能意识到这种任务非常适合继承，所以，你开始敲打你的指关节，开始敲打一些怪物类。

Your “monster classes”, written in JavaScript

搞定了。您签入它，提交它进行代码审查，然后就到此为止。

第二天当你到达办公室时，你那高傲的、无所不知的同事正在你的办公桌前等着你。

“早上好！”

“早上好，史蒂夫”，当你笨拙地从他身边挤过去坐下时，你小声嘀咕着。

“我审阅了你的代码”，他说，眼里闪着光芒。

你可以看到这个对话已经在往不好的方向发展了。他的专业经验只有你的十分之一，并且喜欢通过给人们讲授最新的编程时尚来弥补这一点。

“你知道，”他继续说，“你真的应该更喜欢组合而不是继承。”

“加油！”你反驳，“‘喜欢’不代表‘一直用’，这才是继承的完美工作！OOP 是建立在继承的基础上的，如果你在这里不使用它，那么你应该在什么时候使用它？”

灯光变暗。一台投影仪打开了。他开始了现场培训会议。

不要再这样了…

# 人为什么要用继承？

让我们从讨论为什么开发人员首先要实现继承开始。通过互联网的快速搜索显示，人们对继承应该如何使用和不应该如何使用充满了不同的、往往是相互矛盾的观点。对于某些人来说，继承就是代码重用。[对其他人来说](https://www.quora.com/Why-do-we-use-Inheritance-in-programming)，“继承不是重用现有的代码。相反，它是关于被现有的代码所使用”(也称为多态性)。代码重用和多态性似乎是选择继承的最常见的原因，但也有一些人找到了其他独特的理由来喜欢它，[例如](https://stackoverflow.com/questions/32515743/what-is-the-main-purpose-of-inheritance-in-oop)，在不修改基类的情况下随时添加新功能的能力。

也许人们选择继承的部分原因是因为继承本身就是集多种工具于一身。正如一篇文章所说:

*当一只狗从一种动物那里继承了
1。Dog 类重用了 Animal 类的代码，
2。动物类型的变量 x 既可以指狗，也可以指动物，
3。Eat()将根据 x 引用的对象类型选择 Eat 方法。
在面向对象的行话中，这些特性被称为代码重用、多态和动态调度。*

在接下来的时间里，我将继续演示替换继承的这些不同方面的许多方法。在这个过程中，我会偶尔提到替代解决方案优于继承的一些原因。继承缺陷的详尽列表将被认为超出了本讨论的范围。

# 替代代码重用技术

## 经典作文

让我们通过讨论最常被引用的继承替代方法之一“组合”来开始这个话题。重要的是要认识到，组合本身不能取代继承，它只是众多可用工具中的一个代码重用工具。

通过组合实现代码重用意味着将类之间的任何公共逻辑分离到一个可以在它们之间共享的名称空间中。[经典示例](https://en.wikipedia.org/wiki/Composition_over_inheritance)通过将这个通用逻辑移到一个单独的类中，你可以用一种非常面向对象的方式来实现这一点，如下所示:

An alternative, complete example of classic composition can be viewed [here](https://github.com/theScottyJam/inheritance-alternatives-code-samples/tree/main/classic%20composition).

## 助手功能

在上面的例子中，除了核心的 OO 哲学要求所有东西都必须在一个类中的事实之外，真的没有任何必要让`MonsterBehaviors`单独在一个类中。如果你不同意这种哲学，并且如果它有意义，那么你可以随意用一组帮助函数替换这个类。这在技术上不再是“组合”了，因为您没有将实例组合在一起，但是原则上，达到了相同的目标。

## 公共助手

虽然继承的代码重用方面确实可以通过目前介绍的工具来替换，但是您可能会发现这些解决方案很乏味或者过于重复。也许您可以尊重上面例子的明确性，但是很容易看出，随着共享功能数量的增加，这个系统不能很好地扩展。

一个简单的解决方案是将您的助手逻辑公开，而不是私有。如果您使用的是传统的组合解决方案，那么让您的助手实例成为一个公共属性。如果您遵循助手函数解决方案，那么公开公开您的助手函数。现在，您不需要在每个类上重新定义这些共享函数，因为最终用户可以简单地直接利用您的助手逻辑。

上面的例子实际上展示了如何将私有和公共帮助函数混合在一起。可以混合搭配不同的解决方案来最大限度地满足您的需求。在这种情况下，我们不想公开暴露`attack()`助手，因为最终用户不需要直接调用该函数。

## 战略模式

使用继承时，通常的做法是创建希望子类重写的方法，但是有一种更好的方法来定制类的行为。不要期望子类覆盖你的方法，允许你的构造函数通过参数接受这些自定义行为，然后使用这些参数自定义你的类的行为。换句话说，在您希望用户需要定制实例行为的地方创建有意的“挂钩”。

这是一个非常干净的解决方案。

策略模式可以以多种不同的方式使用。在上面的例子中，我们走极端，完全删除了 slime、skeleton 和小丑类，所以只有一个可定制的`Monster`类。出于演示目的，我们还将展示如何向特定类型的 monster 添加自定义方法。注意`clownBehavior`如何用`uniqueClownBehavior()`方法提供一个`customBehaviors`对象。任何拥有小丑实例的人都可以通过调用`clownInstance.behaviors.uniqueClownBehavior()`来利用这个方法。

这不是使用策略模式的唯一方式，它还可以与我们之前讨论过的其他代码重用技术混合和匹配，例如，您会注意到我们之前在“经典组合”示例中使用过它，但没有显式地调用它——`MonsterBehaviors`类在构造函数中采用了一个策略，一个`dropLoot`函数。

## 限制性继承

虽然前面的解决方案都很好，但它们通常需要改变类的形状，这可能并不适用于所有场景。有时候，你只是想让你所有的共享方法都存在于同一个对象上，就像你通过继承得到的一样。如果你已经到了这一步，并且你觉得没有一个可供选择的选项适合你的代码库，那么也许是时候达到继承了，但是，我们将对你使用它的方式设置一些严格的限制。

让我来介绍一下“限制继承”的四条 **P.A.I.L.** 规则。

1.  继承是一个**私有的**实现细节。不要让其他任何人知道你在使用继承(在可能的范围内)。这意味着，不要公开暴露你的基类，让人们看到从它继承了什么类(例如通过 JavaScript 中的`instanceof`)。您使用继承纯粹是为了代码重用，而不是为了公共层次结构。
2.  保持你的基类**抽象**。虽然从具体的类继承可能很诱人，但是你会发现这样做鼓励了导致可读性更差的代码的实践。例如，从具体类继承可能会迫使您重写一些方法，而让两个类都从第三个抽象类继承则可以让您将有问题的方法排除在抽象类之外。
3.  隔离你的基类和子类。你的基类和子类应该完全忽略其他类提供的属性。子类应该*永远不要*覆盖基类的方法或者甚至访问从基类继承的属性，并且基类应该*永远不要*期望子类提供缺失的方法实现。为什么？因为有更容易实现这些交互的替代方法。如果基类和子类需要交互，它们可以通过共享的帮助器，或者通过让基类使用策略模式(通过在其构造函数中接受自定义行为)来实现。
4.  传承是**最后的**手段。只有在没有其他选项足够好的情况下，才使用受限继承。继承应该是一个被遗忘在工具棚角落里的积满灰尘的工具，因为根据你所从事的工作，可能会有几年的使用间隔。

这种限制形式的继承与你在学校学到的继承非常不同，但是如果你开始遵循上面的规则，你很快就会发现你从来不需要继承的其他方面。你甚至会发现这些限制是一种解放，因为它们指导你如何避免继承的主要陷阱。

*   [致命的死亡钻石？](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem)不需要有多层限制继承。假设您发现有两个基类，A 类和 B 类，它们共享许多共同的功能。不用创建一个新的继承层，只需将公共函数移到一个新的基类 C 中，你的子类就可以使用多重继承，例如，继承 A 和 C，或者 B 和 C，或者三者。没有致命的死亡钻石。
*   [脆弱的基地问题？](https://en.wikipedia.org/wiki/Fragile_base_class)方法覆盖是基类变得脆弱的主要原因。如果您隔离您的类属性，那么您的基类应该不会比一组共享的助手函数更脆弱。
*   紧耦合？继承的问题不在于你与基类紧密耦合，而在于你经常引入不必要的耦合。这四条规则将迫使您在有意义的时候使用继承之外的其他工具，这反过来将耦合保持在实现预期效果所绝对需要的范围内。

下面是如何在我们的 monster 类上使用受限继承。

An alternative, complete example of restricted inheritance can be viewed [here](https://github.com/theScottyJam/inheritance-alternatives-code-samples/tree/main/restricted%20inheritance).

请注意上面的例子是如何利用我们所学的许多原则来遵循我们对继承的限制的。例如，最初的非限制性继承解决方案为`attack()`函数提供了默认实现，并期望`Clown`类覆盖它。为了避免方法覆盖的复杂性，我们转而依赖于我们之前学过的一种技术——辅助函数。公共逻辑被放在任何子类都可以访问的位置，然后每个子类在共享帮助函数的帮助下创建自己的`attack()`方法。因此，您会注意到子类从不与从基类继承的任何资源直接交互。

为了允许定制其他基类行为，策略模式也已经投入使用。最初的无限制继承解决方案让基类直接访问子类提供的`dropLoot()`函数。在这个解决方案中，我们依赖子类来显式地将`dropLoot()`函数传递给构造函数。

# 继承的其他方面

代码重用当然是继承的一个重要方面，这就是为什么本文的前半部分完全致力于探索代码重用的替代方法。现在我们将改变思路，关注继承的其他方面，以及对于这些其他用例有什么替代的解决方案。

## 多态和动态调度

人们选择在类型安全语言(如 TypeScript)中使用继承的一个主要原因是因为他们需要多态性。简单回顾一下，多态性是一个原则，它让您编写可以与各种不同的对象类型交互的代码，而不必在处理它时显式地挑出每一个单独的类型。有各种不同的方法来实现多态性，子类化只是其中之一。子类多态的一个具体例子是接受任何动物的函数，然后对接受的动物调用`speak()`方法。如果你收到一只狗，它会叫；如果你收到一只猫，它会喵喵叫，以此类推。

动态调度是允许多态性发生的机制。动态分派仅仅意味着您不能查看源代码中的特定方法调用，也不能准确地知道哪个方法被调用。任何时候你对一个对象执行多态操作，比如`enemy.kill()`，动态调度就必须发挥作用。直到运行时你才能知道哪个“kill”方法被调用，因为这取决于你要对付的敌人的类型。

虽然继承可以让你实现多态和动态调度，但是接口也可以，在这点上它们和继承一样有能力。只要让你的代码接收任何实现特定接口的东西，然后当你调用一个方法的接收值时，它将多态地使用正确的方法实现。

依赖接口实现多态性给了代码额外的自由度，而不受限制的继承却给了你额外的自由度。它解放了你，让你以你认为最好的方式重用代码。如果您的代码开始变得难以处理，您可以选择在不进行重大更改的情况下加入受限继承。如果在任何时候你觉得抛弃继承并显式定义每个函数会更有可读性，因为，也许这些类的实现细节之间真的没有太多的共同点，那么，你也可以这样做。如果您从一开始就选择使用不受限制的继承，那么您将被锁定在使用继承来实现代码重用，即使它不是这项工作的最佳工具，这仅仅是因为您公开了您的继承层次结构，让人们编写依赖于该层次结构的代码。

如果您使用的是 JavaScript 这样的非类型化语言，那么一切都会改变。你没有接口，也没有子类多态性。您所拥有的就是鸭式输入，所以只要您的每个类都有相同的 API，那么您就可以开始了。创建继承关系不会为这种语言提供任何额外的多态性。

## 运行时层次检查

虽然非类型化语言不会从继承中获得任何额外的多态好处，但通过语言公开的任何显式检查，类型化和非类型化语言都能够公开声明它们是特定类的子类(例如，在 JavaScript 中，您可以使用`instanceof`操作符)。在没有继承的情况下，仍然有可能提供等效的“运行时层次结构检查”行为，只需将唯一的标记嵌入到任何声称实现您的假设接口的类中。如果哨兵存在，那么他们实现你的接口。

JavaScript 中的一个例子:

如果您熟悉 JavaScript 中的[符号](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)，您可以使用它们来隐藏 monsterSentinel 属性。

对于那些担心有人可以声称支持怪物“接口”而实际上并不支持它的人，请注意这个问题并不是非类型化语言所独有的。一个接口不仅仅是函数签名的集合，每个函数都有特定的行为，这是类型检查器不能强制执行的。一个不存在的方法和一个总是抛出错误的方法一样好，但是只有前者会被类型检查器捕获。任何用类型化语言实现接口的人都只是声称提供了预期的行为，你所能做的就是信任他们。当然，类型安全是首选，但是由于使用非类型化语言，我们已经丧失了这种特权，这就是为什么我们不得不对类似接口的行为使用哨兵。

## 继承以避免更新现有代码

有些人喜欢继承的想法，因为这意味着当需求改变时，您可以扩展一个类来满足您的新需求，而无需修改原始类。原则上听起来很有趣，但是许多伟大的思想家反对这种模式，而且理由很充分。例如，Joshua Bloch 的书《有效的 Java》指出*“为继承设计一个类需要很大的努力，并且对类有很大的限制。[…]这个问题的最佳解决方案是禁止在没有被设计和记录为安全子类化的类中进行子类化"*。换句话说，如果你没有明确地为子类设计，那么通过 Java 的“final”关键字禁止它。如果你从不禁止继承，那么你将不可避免地以一个脆弱的基础问题结束——改变你的任何面向公众的类变得困难，因为你不知道当人们从你的方法继承时，他们是如何重写你的方法的。[这篇文章](https://programming.guide/java/when-to-create-a-final-class.html)列出了当你的类不是“最终的”时你会遇到的一些危险，例如，你不能重构一个私有方法并让它开始调用你的一个公共方法，因为有人可能会以一种意想不到的方式覆盖那个公共方法。

在像 JavaScript 这样的语言中，你没有选择，一切都是可继承的。你的下一个最佳选择是一个适用于任何语言的好原则——避免给人们一个想要继承的理由。不要把你的类设计成可继承的，你可以通过设计一个把策略作为参数的类来获得同样多的能力。策略模式不仅实现了您可能希望从“可继承的”类中获得的相同目标，而且它还有一个额外的好处，就是成为一个更有组织的解决方案。你应该期望定制的逻辑出现在哪些地方，这一点非常清楚，而且很容易阻止人们定制其他真正不应该触及的区域。

最后要注意的是，使用继承来避免对内部类进行急需的更新确实为你赢得了遵守[开闭](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)原则的印象分。开闭原则是关于试图*设计*类，这些类对于扩展是开放的，对于修改是封闭的。一旦你离开设计阶段，进入维护阶段，这个原则就不再有指导作用了。当需要更新一个类时，就更新它。

# 结论

史蒂夫关掉投影仪，开始整理思绪。

“总结一下我们今天早上学到的:我们看到人们选择获得无限制遗产有各种不同的原因。我们还看到了许多替代解决方案，它们通常更加明确，对不断变化的需求具有弹性，并且在重构后不容易出错。有时这些好处是以一点额外的冗长为代价的，这取决于你选择的路线。但是，关键的一点是，总有一种有效的替代方法可以替代不受限制的继承……嗯，除非[某个特定的 API](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) 强迫你以不受限制的方式使用继承。”

“那么，有什么问题吗？”

“不”，你回答。

“你今天学到什么了吗？”

“我当然有。”

“太好了！我想我的演讲是成功的。”

当史蒂夫开始收集他的东西时，你心里想，那肯定是。你已经成功地教会了我，如果我需要使用继承，那么我最好确保让别人审查我的代码。

# 人们选择继承的其他原因

继承是一个庞大而复杂的工具，因为各种原因而被使用。我在上面的文章中试图解决继承的最重要的方面，但是我知道它遗漏了很多，所以我决定写一些额外的内容来解决这些漏洞。如果您觉得主要文章没有解决您喜欢继承的一个原因，请随意浏览下面的部分，看看是否有任何附加内容吸引了您的眼球。

## 作为设计工具的继承

也许面向对象编程背后的一些魅力在于它提供了一套工具来帮助你设计你的项目。坐下来，想想你手头的问题，把它变成一个分类法，然后用 UML 图把你的整个项目写在纸上，这难道不是很专业吗？当然，当它有意义的时候，在那里扔一些继承。

问题是，在设计阶段，您不能总是知道哪个代码重用工具是最合适的。你不知道有多少代码，有多重复，直到你把它们都写出来。因此，您真正可以计划的继承的唯一方面是它的多态方面，但是，您已经有了可以处理多态的接口。为什么要在一行代码还没写完的时候就把自己锁在某种代码重用的风格里呢？我们能不能不考虑围绕激进的代码重用工具的项目设计不成熟的重构？

哦，是因为这是一种关系吗？这自然意味着继承？

## is-a vs has-a

总的来说，在决定何时使用继承时，一个经常引用的经验法则是检查一个对象是否是-无论什么，或者它是否有-无论什么。例如，因为 employee 是一个人，所以 employee 类应该继承 Person 类，因为 employee 有薪水，所以 employee 类应该有薪水属性。

这听起来是个好建议，非常符合“OOP 原则和现实世界的东西是一对一的关系”的思维定势，但是现实比这个理想要混乱得多，许多人已经指出了这个经验法则的一些问题。关于这一点，StackOverflow 上有一个很大的讨论[，其中目前被接受的答案警告说，盲目地遵循 is-a/has-a 启发式可能会导致你违反一个更重要的原则，](https://stackoverflow.com/questions/453738/inheritance-or-composition-rely-on-is-a-and-has-a) [Liskov 替换](https://en.wikipedia.org/wiki/Liskov_substitution_principle)。例如，即使一个正方形是一个矩形，如果你的 rectangle 类有`setWidth()`和`setHeight()`方法，那么你的正方形将不能从 rectangle 继承，因为它也不能提供有意义的`setWidth()` / `setHeight()`定义(神奇地让`setWidth()`更新你的矩形的高度没有意义*没有意义*也没有意义，当`setWidth()`被调用时把你的正方形变成矩形也没有意义)。

另一位 StackOverflow 用户指出，is-a 关系可以重新表述为 has-a 关系，例如，不要说`HourlyEmployee`是-a`Employee`，而是重新表述为`Employee`具有-小时支付类型，瞧，现在是 has-a 关系。

在相关的讨论中有许多相互矛盾的观点，但是我认为一个公平的观点是“is-a vs has-a”更适合作为一个经验法则，告诉你什么时候应该*而不是*使用继承。换句话说，如果没有 is-a 关系，就不要使用继承。

## 扩展内置

避免从内置的数据结构中继承，这样只会给自己带来不必要的维护噩梦。不可能编写一个未来兼容尚未创建的特性的子类。例如，JavaScript 委员会正计划为所有数组添加一个`[groupBy](https://github.com/tc39/proposal-array-grouping)`方法。有一个问题[公开讨论如何处理那些扩展了`Array`内置类的人。与其他数组方法不同，比如`map()`或`filter()`，新的`groupBy()`方法将返回多个新数组，很难知道每个数组是应该通过子类的构造函数创建，还是作为普通的 JavaScript `Array`。双方都有有效的论据，不同类型的`Array`子类需要不同的行为。过去，他们曾试图明确地为子类化内置提供良好的支持，但现在他们大多已经放弃了这个想法，甚至正在考虑](https://github.com/tc39/proposal-array-grouping/issues/4)[一些旨在使子类化内置更容易的功能](https://github.com/tc39/proposal-rm-builtin-subclassing)，部分原因是不可能以未来兼容的方式支持这些功能。

这里提到的问题超出了内置类的范围。他们展示了为什么从其他人的类继承是天生脆弱的。任何基类中的新添加总是会给现有的子类带来问题，因为那些子类没有围绕这些附加特性进行设计。

## 但是其他人使用了无限制继承，并且成功了！

也许您正在思考 UI 组件如何经常使用继承？或者说 Java 的内置类型是如何依赖继承的？许多这样的设计决策都是在继承风靡一时的时候做出的，它们的效果还不错，但这并不意味着它是最好的选择。他们同样可以选择使用接口，以及他们选择的任何其他代码重用方法。

*更多内容请看*[***plain English . io***](http://plainenglish.io/)