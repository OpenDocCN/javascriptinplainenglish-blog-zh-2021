<html>
<head>
<title>Why is the Virtual DOM So Fast?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">虚拟DOM为什么这么快？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-is-the-virtual-dom-so-fast-cf7630643349?source=collection_archive---------11-----------------------#2021-05-11">https://javascript.plainenglish.io/why-is-the-virtual-dom-so-fast-cf7630643349?source=collection_archive---------11-----------------------#2021-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5142" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当您开始了解前端世界时，您几乎会立即发现“虚拟DOM”这个术语。但是是什么让它这么快呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a59ec75983782a51a60f15e268f549c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttQkGfkCMYZKgNctGuPiMA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@marcsm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Marc Sendra Martorell</a> on <a class="ae kv" href="https://unsplash.com/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a36d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您开始了解前端世界时，您几乎会立即发现“虚拟DOM”这个术语。</p><p id="54c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数流行的前端框架都使用它，并希望用它来证明自己的速度。</p><p id="3f1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是是什么让它这么快呢？</p><p id="fc36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是什么让真正的DOM如此缓慢和低效？</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5aa0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">了解浏览器呈现</h1><p id="a063" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个主题相当复杂，但是您需要了解一些基础知识来理解DOM。</p><p id="056c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们假设我们从服务器请求一个简单的HTML/CSS页面；这里不需要JS。</p><p id="c843" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们收到HTML/CSS形式的响应后，会发生这样的情况:</p><h2 id="4a16" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">1.解析HTML</h2><p id="56eb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">浏览器解析HTML文件，并将其作为高效的树结构存储在内存中。</p><p id="750f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种表示被称为DOM——文档对象模型。您可以通过打开DevTools并选择“Elements”选项卡来查看它。</p><p id="e367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">明确一下，DOM不是HTML！它只是一个HTML和XML文件的接口。</p><h2 id="d54a" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">2.解析CSS</h2><p id="c835" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这一步包括解析CSS——并将其存储为树形结构。它被称为CSSOM。</p><h2 id="3eb5" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">3.创建渲染树</h2><p id="cba0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当你结合DOM和CSSOM，你得到一个渲染树。它是由HTML节点和它们的样式组成的，它代表了在浏览器中呈现的内容。</p><p id="f04a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不会包括每一个HTML节点——例如<code class="fe ni nj nk nl b">&lt;head&gt;</code>，但也包括带有<code class="fe ni nj nk nl b">display: none;</code>的元素。只有那些在屏幕上看得见的。</p><h2 id="8257" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">4.布局阶段</h2><p id="1e58" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个阶段的目的是计算渲染树中每个节点的位置。浏览器将从根开始遍历树。</p><p id="c7d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以想象，这个过程可能会很昂贵，因为它必须对树中的每个节点进行大量的计算。</p><p id="7f65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个阶段的最后，浏览器知道每个元素的确切位置和大小。</p><h2 id="f864" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">5.油漆阶段</h2><p id="6f08" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最后，我们可以填充布局阶段后得到的空骨架。</p><p id="ec6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器不得不遍历视口中每个需要填充的像素。听起来很贵，对吧？</p><p id="fae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，确实是。这绝对是计算量最大的一步。</p><p id="2fa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在DevTools的“Performance”选项卡下检查布局和绘画阶段。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f604" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们算一下</h1><p id="9974" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">你可能已经知道，树形结构非常有效。我们拥有的算法可以毫不费力地遍历巨大的树。</p><p id="cfb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">这样做真的很便宜。</strong>这就是第1-3步的全部内容。</p><p id="7512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，第4步和第5步可能会非常昂贵，因为我们有额外的步骤来操作屏幕上的每个像素。这些算法是有效的，但与树形结构相比仍然很慢。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="f94c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，我们最初的页面渲染会花费更长的时间，虚拟DOM也帮不了我们太多。我们在屏幕上还没有任何东西，对吗？</p><p id="fc02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是后来，当我们进行更新时，虚拟DOM将经历步骤1-3。它会将新的渲染树与之前的渲染树进行比较，并仅对修改后的节点执行步骤4–5。</p><p id="d96b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么它这么快！</p><p id="b649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它不需要从头开始做一整个过程。它将只重新渲染(步骤4和5)修改过的节点！</p><p id="d47c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最棒的是——你不需要管它。你神奇的FE工具会帮你做到。</p><p id="3639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在React的官方文档中读到关于<a class="ae kv" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank">优化性能的内容，你会发现:</a></p><blockquote class="nm nn no"><p id="616b" class="kw kx np ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">“在内部，React使用了几种巧妙的技术来最小化更新UI所需的代价高昂的DOM操作的数量。对于许多应用程序来说，使用React将会产生一个快速的用户界面，而不需要做很多工作来专门优化性能。”</p></blockquote><p id="f454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以不要做不必要的优化。大多数时候，这些优化背后的复杂性会导致代码运行速度变慢。</p><p id="b655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">热爱并赞美VDOM。</p><p id="2aed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="np">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="np">plain English . io</em></a></p></div></div>    
</body>
</html>