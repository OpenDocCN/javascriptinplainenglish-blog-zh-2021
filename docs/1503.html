<html>
<head>
<title>What is Bubble Sort?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是冒泡排序？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-bubble-sort-3b7916e5bfcf?source=collection_archive---------18-----------------------#2021-03-30">https://javascript.plainenglish.io/what-is-bubble-sort-3b7916e5bfcf?source=collection_archive---------18-----------------------#2021-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a391" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">冒泡排序可能是最简单的排序算法。它在规模上效率很低，但是写起来很快，并且在少数元素上运行良好。</p><p id="ca90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">冒泡排序是对排序算法的极好介绍。</p><p id="64d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们稍后讨论更复杂的搜索算法时，它也是一个有用的参考。</p><p id="85a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将这个数组按升序排序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/72a1f49b6d7874fcae039a9a4e6c966c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*m8iG4AJ6sXXqjJNL81XUfg.png"/></div></figure><h1 id="2fe5" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">步骤1:比较元素对</h1><p id="2754" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">我们将依次遍历每一对元素。</p><p id="8c1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果一对元素的顺序不对，我们将交换它们。</p><p id="033f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们走吧…</p><p id="daab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一对已经是正确的顺序，所以我们可以忽略它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/be32216f6c8f9a074a98819dd062dbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*C4niERonO8qRNxcqhZCdfw.png"/></div></figure><p id="01f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一对。这些元素的顺序是错误的，所以我们将交换它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/10d56ad94f73e1ac95bea032d7a9a807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Ipxfc1adoYqYjeDCdeq9Lg.png"/></div></figure><p id="2aeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后是最后一对，也需要交换:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ebc9eb977908a9cf70672341b1c5ec58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*LFsx3AHC5h70ks8r6FnZ2w.png"/></div></figure><p id="5626" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在已经遍历了所有的线对，所以我们第一次遍历数组就完成了。</p><p id="e61c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是阵列在第一遍的开始和结束时的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/793b9137463e8771177e3ab50b396a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*VHdupor5WynatU2puZwLIw.png"/></div></figure><p id="53c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意最大值9是如何在数组中向上移动到正确的位置的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1d80b1843a95b21f9cae6909c7584556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*RqnkMNLkD8d00Wo48c8VMg.png"/></div></figure><p id="1366" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它已经“冒泡”到正确的位置，因此被称为“冒泡排序”。</p><h1 id="43b5" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">重复</h1><p id="b4bd" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">我们的第一次传递将最高的元素9移动到正确的位置。</p><p id="ce14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每次我们重复这个循环，我们移动<em class="lt">下一个最高的元素</em>到位。</p><p id="2637" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们重复这个过程——依次比较每一对并在需要时交换它们——直到数组完全排序。</p><p id="aeca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">列表中有4个元素，这意味着我们需要重复循环3次。</p><p id="9cd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么是3？因为一旦3个元素在数组中的正确位置，剩下的一个也必须是正确的。</p><p id="11df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果数组中元素的数量是<code class="fe lu lv lw lx b">n</code>，我们需要的循环数是<code class="fe lu lv lw lx b">n-1</code>。</p><p id="5bd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是每次通过后数组的状态。每个循环后的排序元素会突出显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ki"><img src="../Images/279cb2055e7dcf6908e897cda202c358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*fHzw38CUgvEnFzRjHF9Fcg.png"/></div></div></figure><p id="28e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是这个算法的JavaScript代码:</p><pre class="kj kk kl km gt mc lx md me aw mf bi"><span id="a400" class="mg kr in lx b gy mh mi l mj mk">// We need to repeat the algorithm n-1 times<br/>for (let loop = 0; loop &lt; array.length - 1; loop++) {<br/><br/>  // Loop through each pair of elements<br/>  for (let pair = 0; pair &lt; array.length - 1; pair++) {<br/><br/>    // Is this pair the wrong way around?<br/>    if (array[pair] &gt; array[pair + 1]) {   <br/><br/>      // Make the swap (using temporary variable)<br/>      let tmp = array[pair]<br/>      array[pair] = array[pair + 1]<br/>      array[pair + 1] = tmp<br/>    }<br/><br/>  }<br/>}</span></pre><p id="fda0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不过，我们可以通过一些优化来改进这个基本算法。</p><h1 id="df08" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">优化#1</h1><p id="5501" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">还记得算法的第一遍是如何让9上升到正确的位置的吗？</p><p id="ee62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第一遍之后，我们知道最后一个元素被正确放置，所以我们可以在下一次循环中忽略它。第二遍之后，对倒数第二个元素进行排序，依此类推。</p><p id="7014" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将修改代码，忽略第一次循环后的最后一个元素，第二次循环后的最后一个<em class="lt">和两个</em>，依此类推。</p><p id="beac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将使我们的算法稍微快一点。</p><p id="cf22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是更新后的代码:</p><pre class="kj kk kl km gt mc lx md me aw mf bi"><span id="18fe" class="mg kr in lx b gy mh mi l mj mk">for (let loop = 0; loop &lt; array.length - 1; loop++) {<br/>  for (let pair = 0; pair &lt; array.length - loop - 1; pair++) {<br/>    if (array[pair] &gt; array[pair + 1]) {<br/>      let tmp = array[pair]<br/>      array[pair] = array[pair + 1]<br/>      array[pair + 1] = tmp<br/>    }<br/>  }<br/>}</span></pre><h1 id="fc95" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">优化#2</h1><p id="14e9" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">想象我们的算法被传递了一个这样的数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2286a8426487c420e3e943ad1d759ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*pjCjqXauol7eLUaKED58CA.png"/></div></figure><p id="8d0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个数组已经排序了，我们的排序算法循环三次完全是浪费时间。</p><p id="3c9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将引导我们进行下一步优化；如果我们在没有交换任何元素的情况下完成了一个循环，我们知道数组已经排序了，我们可以提前停止。</p><p id="f904" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们开始冒泡排序之前，如果数组已经排序(或接近排序),这可以节省大量时间。</p><p id="0eaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加这些代码后，我们最终的冒泡排序算法如下所示:</p><pre class="kj kk kl km gt mc lx md me aw mf bi"><span id="5f5c" class="mg kr in lx b gy mh mi l mj mk">for (let loop = 0; loop &lt; array.length - 1; loop++) {</span><span id="3002" class="mg kr in lx b gy ml mi l mj mk">  let hasSwapped = false;<br/>  <br/>  for (let pair = 0; pair &lt; array.length - loop - 1; pair++) {<br/>    if (array[pair] &gt; array[pair + 1]) {<br/>      let tmp = array[pair]<br/>      array[pair] = array[pair + 1]<br/>      array[pair + 1] = tmp      <br/>      hasSwapped = true;<br/>    }<br/>  }<br/>  <br/>  if (!hasSwapped) {<br/>    // No swaps, the array is now sorted<br/>    break;<br/>  }<br/>}</span></pre><h1 id="31c4" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">想了解更多？</h1><p id="86a3" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">查看这些链接:</p><ul class=""><li id="c328" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated"><a class="ae mv" href="https://visualgo.net/en/sorting" rel="noopener ugc nofollow" target="_blank">冒泡排序的可视化表示</a></li><li id="7b9e" class="mm mn in jm b jn mw jr mx jv my jz mz kd na kh mr ms mt mu bi translated"><a class="ae mv" href="http://techieme.in/improving-bubble-sort/" rel="noopener ugc nofollow" target="_blank">一篇关于上述改进的更详细的文章</a></li></ul><p id="8487" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lt">订阅我的</em> <a class="ae mv" href="https://www.baseclass.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="lt">通迅</em> </a> <em class="lt">先收到这个。</em></p></div></div>    
</body>
</html>