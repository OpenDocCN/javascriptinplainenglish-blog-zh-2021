<html>
<head>
<title>The Difference Between JavaScript Null and Undefined Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript空数据类型和未定义数据类型的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/same-same-but-different-javascript-null-and-undefined-data-types-7b62b4b37eb8?source=collection_archive---------8-----------------------#2021-05-02">https://javascript.plainenglish.io/same-same-but-different-javascript-null-and-undefined-data-types-7b62b4b37eb8?source=collection_archive---------8-----------------------#2021-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="90d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JavaScript程序中，<em class="kl"> null </em>和<em class="kl"> undefined </em>有时会被松散地使用，并且可以互换<em class="kl">。</em>然而，它们是不同的数据类型，了解它们之间的差异和相似之处有助于避免错误并节省排除错误的时间。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/95a485d2b6e3bc9a6e9ee401ba035c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRMslxlKQV_GwX95hG5xNg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Photo by <a class="ae lc" href="https://unsplash.com/@dylanshaw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Dylan Shaw</a> on <a class="ae lc" href="https://unsplash.com/s/photos/sheep?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ld"><img src="../Images/f13dc7be10bfd26d7d53078f3b91421d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-i91v7hXn2qINUigOVWfQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Uncaught TypeError: Cannot read property ‘text’ of undefined.</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi le"><img src="../Images/d0a3f9394290d6d03ee001374bc80ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTATI6rx3JZshJNjajpopw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Uncaught TypeError: Cannot read property ‘style’ of null.</figcaption></figure><p id="c598" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在编码时还没有至少一次遇到浏览器控制台上打印的不可原谅的未捕获的<strong class="jp ir">类型错误</strong> <em class="kl"> ' </em>无法读取<strong class="jp ir">未定义的</strong> <em class="kl"> ' </em>或“无法读取<strong class="jp ir"> null </strong>的属性”请举手？</p><p id="d16f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有没有问过为什么你会看到它们或者<em class="kl"> null </em>和<em class="kl"> undefined有什么区别？在我作为软件工程师的经历中，我遇到过一些。然而，理解每种数据类型的特性有助于我调试和避免这些问题。一旦我理解了它们的定义，它们的相似之处，它们的不同之处，更重要的是，当它们出现在我的程序中时，我就开始构建更多的防御性程序。</em></p><p id="9bfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>，当一个操作因为一个值不是预期的类型而无法正常执行时，在程序执行过程中会抛出一个<strong class="jp ir"> TypeError </strong>。在这种情况下，操作无法处理类型为<em class="kl">未定义</em>和<em class="kl"> null的值。这篇博客试图定义这些价值观，并强调它们最重要的区别和相似之处。</em></p><h2 id="ffb3" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">空</h2><p id="be35" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">JavaScript<em class="kl">null</em>——在其他语言中也称为nill、NULL、None是一个通常表示缺少值的关键字。奇怪的是，在“null”上使用<em class="kl"> typeof </em>操作符来标识其数据类型会返回一个“object”。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi md"><img src="../Images/b094f119441782aefdc48cf9c969de3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkYE_P09ojim5-0EZ60IJw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">typeof null returns ‘object’</figcaption></figure><p id="9cee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为传统的原因，而<a class="ae lc" href="https://web.archive.org/web/20160331031419/http://wiki.ecmascript.org:80/doku.php?id=harmony:typeof_null" rel="noopener ugc nofollow" target="_blank">修复它</a>可能会出乎意料地破坏现有站点。尽管有这个小问题，但将<em class="kl"> null </em>视为表示“无对象”的特殊对象值仍然是有用的，有时会将其分配给变量或属性，但它也可以在函数中用作返回值，以在没有任何内容要返回时明确指示“无值”或“无对象”。</p><h2 id="353d" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">不明确的</h2><p id="6cb9" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><em class="kl">未定义</em>是代表原始数据值<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank">未定义</a>的全局属性。现在，让我们来分解一下定义。作为一个全局属性意味着它的值在程序中的任何地方都是可访问的，在这种情况下，它将被系统用来表示没有值。<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined#description" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>指出了系统返回<code class="fe me mf mg mh b">undefined</code>的三种方式。首先，当一个变量还没有赋值时。其次，当在方法或语句中被求值的变量没有赋值时。第三，当函数不返回值时。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，<em class="kl"> undefined </em>与<em class="kl"> null </em>一样表示缺少值。但是，与<em class="kl"> null不同的是，</em>的数据类型是‘undefined’，这意味着<em class="kl"> undefined </em>是其自身类型的唯一成员。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mk"><img src="../Images/01de7b12e00c0a120d14eb3e2041a104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSUkdguAptxzK83JYIDvzQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">typeof undefined returns ‘undefined’</figcaption></figure><h2 id="0a83" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">差异和相似之处</h2><p id="f608" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">两种数据类型— <em class="kl"> null </em>和<em class="kl"> undefined — </em>是JavaScript 7原语数据类型的一部分，包括字符串、数字、bigint、布尔、符号、undefined和null。原始数据代表语言实现的原子级别。所有原始数据类型都是不可变的，这意味着它们不是对象，因此没有<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Glossary/Method" rel="noopener ugc nofollow" target="_blank">方法</a>。在这种情况下，<em class="kl"> null </em>和<em class="kl"> undefined </em>都没有任何属性或方法。</p><blockquote class="ml mm mn"><p id="bcad" class="jn jo kl jp b jq jr js jt ju jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj kk ij bi translated">JavaScript 7原始数据类型有字符串、数字、bigint、布尔、符号、未定义和null。</p></blockquote><p id="6618" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述,<em class="kl"> null </em>是一种原始数据类型，通常被视为其自身类型的唯一成员。然而，与<em class="kl"> undefined </em>相反，它不是一个全局属性——在任何地方都可以访问——因此必须在需要时有意地将其赋给一个变量。<em class="kl">空值</em>可分配给变量，以指示<em class="kl">数字</em>、<em class="kl">字符串</em>和<em class="kl">对象</em>的“无值”。</p><p id="5ddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据类型<em class="kl">未定义</em>和<em class="kl">空</em>在许多方面都相似，因此很容易被误用。它们都代表着价值的缺失。然而，这种缺失的性质有些不同。<em class="kl"> null </em>用于<strong class="jp ir">明确地</strong>有目的地表示缺少值，而<em class="kl">未定义的</em>可以通过JavaScript返回<strong class="jp ir">隐含的</strong>来表示意外的或类似错误的缺少值。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种数据类型之间的另一个重要相似之处在于，在布尔运算中，两者都被视为<strong class="jp ir">虚假的</strong>。我们将在下一节探讨这一概念。</p><h2 id="eed6" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated"><em class="mr">空</em>和<em class="mr">未定义</em>均为假</h2><p id="e5ff" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><em class="kl"> null </em>和<em class="kl"> undefined </em>都是<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank"> falsy </a>，但是它们不一样——我们已经看到它们是不同的数据类型，有区别的值。验证这个命题的一种方法是使用JavaScript等式运算符对其进行评估。</p><p id="da93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript有<em class="kl">等式运算符</em>和<em class="kl">严格等式运算符</em>。等式运算符<code class="fe me mf mg mh b">==</code>试图在比较不同类型的操作数并返回布尔结果之前对其进行转换。当使用<code class="fe me mf mg mh b">==</code>运算符比较null和undefined时，JavaScript将<em class="kl"> null </em>和<em class="kl"> undefined </em>转换并返回true。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Example showing that the equality operator considers null and undefined to be equal.</figcaption></figure><p id="e038" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与此相反，<em class="kl">严格相等运算符</em> <code class="fe me mf mg mh b"><em class="kl">===</em></code>检查数据类型，并不尝试转换操作数。因此，如果操作数属于不同的数据类型——如前所示，null和未定义的数据类型是不同的——标识运算符<code class="fe me mf mg mh b">===</code>将返回“false”。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">The strict equality operator === distinguishes null and undefined.</figcaption></figure><p id="811d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道这些操作员<code class="fe me mf mg mh b">==</code>和<code class="fe me mf mg mh b">===</code>会返回不同的结果对于理解如何构建更多的防御程序是至关重要的。</p><h2 id="404f" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">检查程序中的null和未定义</h2><p id="40f1" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果需要检查某个变量或者某个函数的返回值是<em class="kl">空</em>还是<em class="kl">未定义</em>，可以增加等式运算符<code class="fe me mf mg mh b">==</code>(而不是严格的等式或者身份运算符<code class="fe me mf mg mh b">===</code>)来验证该条件。每当<em class="kl">未定义</em>或<em class="kl">空</em>可能发生时，通常当无法预期这些值的出现时，添加该检查来捕捉是有用的。</p><p id="ac82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> undefined </em>由系统隐式返回，因此在程序中并不总是能够避免它的出现。同样的想法也适用于<em class="kl"> null </em>。有时，null 被有意地分配给一个变量来表示没有值，但是在程序的后面被重新分配给另一个值。如果有所欠缺，并且没有进行第二次赋值，那么无论何时计算该变量，都将返回“null”。在这两种情况下，为了避免<strong class="jp ir">类型错误</strong>，识别值的出现总是有用的——“null”和“undefined”。</p><p id="4735" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码块是一个简单的例子，它说明了在实践中如何计算<em class="kl"> null </em>或<em class="kl"> undefined </em>以及为什么在试图捕捉“null”和“undefined”值时使用相等运算符<code class="fe me mf mg mh b">==</code>而不是严格的相等运算符<code class="fe me mf mg mh b">===</code>更有用。在<code class="fe me mf mg mh b">lines 7 — 13</code>中，函数<code class="fe me mf mg mh b">evaluateNullOnly</code>带一个参数<code class="fe me mf mg mh b">example</code>，在<code class="fe me mf mg mh b">line 8</code>中，评估其值和类型是否严格等于‘空’。在这种情况下，只有在<code class="fe me mf mg mh b">line 2</code>中初始化的<code class="fe me mf mg mh b">variableOne</code>通过该测试。因此，当调用<code class="fe me mf mg mh b">line 24</code>中的<code class="fe me mf mg mh b">evaluateNullOnly</code>并将其作为参数传递给<code class="fe me mf mg mh b">variableOne</code>时，系统解释器将只执行<code class="fe me mf mg mh b">line 9</code>并输出<code class="fe me mf mg mh b">'The value is null’</code>。相反，被赋值为“未定义”的<code class="fe me mf mg mh b">variableTwo</code>将使测试<code class="fe me mf mg mh b">example === null</code>失败，返回“falsy”并导致执行<code class="fe me mf mg mh b">lines 10 — 12</code>中的else条件。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">A simple example illustrates how the evaluation of <em class="mr">null</em> or <em class="mr">undefined </em>works in practice.</figcaption></figure><p id="b5de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与前面的函数不同，在<code class="fe me mf mg mh b">line 16</code>中，函数<code class="fe me mf mg mh b">evaluateNullorUndefined</code>使用等式运算符<code class="fe me mf mg mh b">==</code>来评估分配给参数<code class="fe me mf mg mh b">example</code>的值是否为‘空’。正如我们已经看到的，相等运算符认为<em class="kl"> null </em>和<em class="kl"> undefined </em>相等。因此，<code class="fe me mf mg mh b">variableOne</code>和<code class="fe me mf mg mh b">variableTwo</code>在作为参数传递给函数<code class="fe me mf mg mh b">evaluateNullOrUndefined</code>时都会返回the。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="7652" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">摘要</h2><p id="fb21" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><em class="kl"> null </em>和<em class="kl"> undefined </em>数据类型有很多相似之处。对于布尔运算，它们都被视为<em class="kl">假值</em>，并且都表示没有值。由于这些相似之处，它们有时可以互换使用。然而，假设它们是同一个东西是错误的，不知道如何区分它们会在程序中引入bug。</p><p id="d3bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，<em class="kl"> undefined </em>表示系统级的意外缺值错误，而<em class="kl"> null </em>表示程序级的正常缺值。其他一些差异包括:</p><ul class=""><li id="a265" class="mz na iq jp b jq jr ju jv jy nb kc nc kg nd kk ne nf ng nh bi translated">理论上，<em class="kl"> null </em>是一个关键字，而<em class="kl"> undefined </em>是一个全局属性。</li><li id="b53a" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">在Javascript程序中，所有数据都有一个类型，null的类型是“object”，undefined的类型是“undefined”。</li><li id="372b" class="mz na iq jp b jq ni ju nj jy nk kc nl kg nm kk ne nf ng nh bi translated">必须显式使用空值，而未定义的值<em class="kl">通常是隐式返回的值。</em></li></ul><p id="481f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些人喜欢尽可能避免程序中的“null”和“undefined ”,但无论如何，构建检查这些值是否存在的防御性代码是很重要的，这样程序就可以继续执行，而不会在预期有值时因错误而暂停，这意味着不是<em class="kl"> null </em>和/或<em class="kl"> undefined — </em>。</p><p id="5d11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">捕捉这些值的一种方法是使用<code class="fe me mf mg mh b">==</code>相等操作符，而不是严格的相等操作符<code class="fe me mf mg mh b">===</code>。这是因为相等运算符认为<em class="kl"> null </em>和<em class="kl"> undefined </em>相等，而严格相等运算符会区分它们。</p><p id="5755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="kl">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>