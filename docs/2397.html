<html>
<head>
<title>How to Detect the Closing of a Browser Tab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测浏览器标签的关闭</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-detect-the-closing-of-a-browser-tab-94eee00a4e39?source=collection_archive---------0-----------------------#2021-05-18">https://javascript.plainenglish.io/how-to-detect-the-closing-of-a-browser-tab-94eee00a4e39?source=collection_archive---------0-----------------------#2021-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bf13195537a509f8cbb2a837c8158fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YMzPg-dM5GgZf5kY4Bamw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@remotarjobs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Remotar Jobs</a> on <a class="ae jz" href="https://unsplash.com/s/photos/browser?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="976b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有时候，你需要在用户关闭标签页之前做一些事情。它可能是清除cookies或发送API调用。</p><p id="8ccd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，在JavaScript/TypeScript中，没有直接/标准的方法来识别用户是否关闭了标签和/或浏览器窗口。我惊讶地发现没有直接的方法可以做到这一点。在本文中，您将学习一种有效检测页面重新加载、标签关闭和浏览器关闭动作的方法，并区分它们。</p><p id="103d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">下面我将展示的例子是使用角度10。如果您使用另一个框架或JavaScript，语法会有所不同，但理论是相同的。</em></p><h1 id="5405" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">卸载前</h1><p id="5a72" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">JavaScript提供了一个名为beforeunload的事件处理程序。每当从客户端删除/卸载资源时，都会调用此事件。</p><p id="091a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着每当用户重新加载页面、关闭选项卡或浏览器窗口时，都会触发此事件。如果你正在寻找的正是这一点，这就足够了。然而，对于大多数应用程序，我们需要区分“关闭”(标签或窗口)和“重新加载”。让我们看看我们能做些什么。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="636b" class="ml la in mh b gy mm mn l mo mp">// Angular Example for beforeunload event handler<br/>@HostListener('window:beforeunload', ['$event'])<br/>beforeunloadHandler(event): void {<br/>  // Do something<br/>}</span></pre><h1 id="17f8" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">1)识别页面重载</h1><p id="758a" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">到目前为止，我们知道页面重载也会触发beforeunload事件。当事件被触发时，我们不知道是什么触发了它(重新加载、标签关闭或浏览器关闭)。在该事件处理程序中，我们需要确定页面是否被重新加载。</p><p id="5474" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以使用NavigationTiming API识别页面重新加载。你可以在这里阅读关于<a class="ae jz" href="https://www.w3.org/TR/navigation-timing/" rel="noopener ugc nofollow" target="_blank">的所有内容。</a></p><p id="fa2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，window.performance.navigation已被弃用，因此您应该避免使用它。请改用NavigationTiming API提供的属性。</p><p id="b7f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据NavigationTiming的文档，我们需要在导航条目类型数组中查找导航类型“reload”。为了简单起见，我们将避免使用循环。让我们编码</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c775" class="ml la in mh b gy mm mn l mo mp">let pageReloaded = window.performance<br/>                 .getEntriesByType('navigation')<br/>                 .map((nav) =&gt; (nav as any).type)<br/>                 .includes('reload');</span></pre><p id="c304" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像那样，现在pageReloaded携带了页面是否重载的布尔值。您可能希望将它放在beforeunload事件处理程序中。</p><p id="e532" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注:</strong> <em class="ky">我们没有使用循环的原因有很多。我在这篇</em> <a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/why-you-should-stop-using-loops-88a6a789106e"> <em class="ky">文章</em> </a> <em class="ky">中详细阐述了为什么不应该使用循环。如果您使用的是JavaScript而不是TypeScript，唯一的变化就是在map中使用arrow函数。</em></p><h1 id="fc04" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak"> 2)检测标签关闭</strong></h1><p id="02b9" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">与页面重新加载不同，没有标准的方法来检测选项卡是否关闭。然而，我们可以利用本地存储来实现这一点。</p><p id="dc3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">浏览器中的本地存储由同一个域共享。这意味着你可以在浏览器中打开多个标签，比如说从<a class="ae jz" href="http://www.google.com" rel="noopener ugc nofollow" target="_blank">www.google.com</a>开始，它们都共享同一个本地存储。</p><p id="960d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个想法很简单，我们可以为一个特定的域计算浏览器中打开的标签总数。在1处实例化，它将在每次打开新选项卡(实例化新页面)时增加1，在选项卡关闭时减少1(使用beforeunload事件处理程序)。</p><p id="bbe4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong> <em class="ky">对于选项卡关闭，我们需要确保在页面重新加载时不会减少选项卡计数。我们已经在第1点中看到了如何检测页面重载。</em></p><p id="6749" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一下代码</p><p id="629e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2.1)增加标签数</strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="4c70" class="ml la in mh b gy mm mn l mo mp">ngOnInit() {<br/>  // We need to parse into integer since local storage can only<br/>  // store strings.<br/>  let tabCount = parseInt(localStorage.getItem("windowCount"));</span><span id="f096" class="ml la in mh b gy mq mn l mo mp">  // Then we instantiate tabCount if it doesn't already exist<br/>  // OR Increment by 1 if it already exists<br/>  tabCount = Number.isNaN(tabCount) ? 1 : ++tabCount;<br/>  <br/>  // Set the count on local storage<br/>  localStorage.setItem('tabCount', tabCount.toString());<br/>}</span></pre><p id="5b46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2.2)减少标签计数</strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ef84" class="ml la in mh b gy mm mn l mo mp">@HostListener('window:beforeunload', ['$event'])<br/>beforeunloadHandler(event): void {<br/>  if(!pageReloaded) { // The pageReloaded boolean we set earlier<br/>    let tabCount = parseInt(localStorage.getItem('tabCount'));<br/>    --tabCount;<br/>    localStorage.setItem('tabCount', tabCount.toString());<br/>  }<br/>}</span></pre><p id="bacd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像这样，我们现在可以知道标签何时关闭。每次我们的标签数减少1，标签就会被关闭。你现在可以做任何你想做的事情。</p><p id="1532" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有一种方法可以在浏览器中获取所有打开的标签页。使用<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/windows/getAll" rel="noopener ugc nofollow" target="_blank"> window.getAll() </a>我们可以实现完全一样的东西，甚至更多。但是，最新的Firefox和Safari版本不支持它。它还需要用户的许可。就我们的目的而言，使用本地存储方法更合适(因为window.getAll()是异步的),并且它使事情变得简单。</p><p id="ba62" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们更进一步。我们现在将检测它是浏览器关闭还是标签关闭。</p><p id="b517" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong> <em class="ky">如果你想要的只是检测一个标签页或者浏览器是否被关闭，并且不区分它们，你甚至不需要保存一个标签页计数。如果您点击beforeunload事件处理程序并且pageReloaded布尔值为false，则确认选项卡或窗口已关闭。</em></p><h1 id="9015" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak"> 3)检测到浏览器关闭</strong></h1><p id="fe1e" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">要理解浏览器关闭，我们需要先了解浏览器是如何关闭的。</p><p id="469a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用户关闭浏览器窗口时，浏览器中的每个标签都会被一个接一个地关闭(根据我的实验，Chrome在轻负载到平均负载时的延迟大约为1毫秒)。</p><p id="ce34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们知道浏览器关闭将触发beforeunload事件处理程序。由于每个标签页会一个接一个地关闭，我们可以试着捕捉两个连续标签页关闭之间的延迟。<strong class="kc io">如果关闭延迟是一分钟(1毫秒-50毫秒)，那就是我们浏览器正在关闭的信号。</strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="292e" class="ml la in mh b gy mm mn l mo mp">isBrowserClosed() {<br/>  var localStorageTime = parseInt(localStorage.getItem('storageTime'));<br/>  var currentTime = new Date().getTime();<br/>  var timeDifference = currentTime - localStorageTime;</span><span id="3c99" class="ml la in mh b gy mq mn l mo mp">  if (timeDifference &lt; 50) {<br/>    //Browser is being closed<br/>    // Do something before browser closes.<br/>  }<br/>}</span></pre><p id="7a75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong> <em class="ky">为了准确检测浏览器关闭，如果当前时间和onbeforeunload上的存储时间相差太大，我们需要更新storageTime。下面的代码就是一个例子。</em></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ece0" class="ml la in mh b gy mm mn l mo mp">@HostListener('window:beforeunload', ['$event'])<br/>beforeunloadHandler(event): void {<br/>  if(!pageReloaded) { // The pageReloaded boolean we set earlier<br/>    if (storageTime === null || storageTime === undefined<br/>        || (storageTime - new Date().getTime()) &gt; 1000) {<br/>      // If storageTime is null, undefined or is older than 1 second<br/>      // we update the storage time.<br/>    }<br/>  }<br/>}</span></pre><p id="88c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个小技巧也降低了我们因为客户端硬件性能差而错过浏览器关闭事件的概率。</p><p id="8551" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在客户端硬件性能非常差的情况下，最坏的情况是每个beforeunload事件都被检测为tab关闭。</p><h1 id="e1b3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="71df" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">基于目前所见，我们可以将检测方法归结为三点:</p><ol class=""><li id="dc26" class="mr ms in kc b kd ke kh ki kl mt kp mu kt mv kx mw mx my mz bi translated">如果导航条目具有重新加载导航类型，则用户重新加载了页面。</li><li id="dc57" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx mw mx my mz bi translated">如果选项卡计数减少，则用户关闭了一个选项卡。</li><li id="be3b" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx mw mx my mz bi translated">如果标签计数减少且存储时间差小于50ms，则用户<em class="ky">可能</em>关闭了浏览器。</li></ol><p id="6ae6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在第三点中说可能是因为我们的瓶颈是客户端的硬件性能。即使我们采取了额外的措施来确保准确的结果，我们仍然有可能错过它。也就是说，在大多数情况下，这就足够了。</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="d404" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">我希望你喜欢这本书。</strong></p><p id="0c13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">我的名字是毗湿奴·萨西德哈兰，我写技术文章、代码和讲故事。我的目标是把复杂的概念简化成简单的东西，并用通俗易懂的语言解释它。我也分享激励过我的真实生活故事。</strong></p><p id="143f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">如果你喜欢这篇文章，你可能也会喜欢:</strong></p><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/why-you-should-stop-using-loops-88a6a789106e"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">为什么应该停止使用循环</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">如果你和我一样，你在JavaScript中使用for和while循环的时间最长。我是说如果它得到了…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jt np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/explaining-javascripts-this-keyword-in-simple-terms-238e26b1d0df"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">用简单的术语解释JavaScript的“this”关键字</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">“this”关键字在JavaScript中可能有不同的含义，这取决于调用它的位置。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od jt np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/promises-in-typescript-27d887a8d380"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">打字稿中的承诺</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">想象一下，你去店主那里买糖果。你要一颗糖，店主答应了(即给你一颗糖)</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ny l"><div class="of l oa ob oc ny od jt np"/></div></div></a></div><p id="0485" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ky">plain English . io</em></a></p></div></div>    
</body>
</html>