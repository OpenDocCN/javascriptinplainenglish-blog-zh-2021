<html>
<head>
<title>Add Infinite Scrolling to a Vue.js 3 App with the Intersection Observer API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用交叉点观察器API为Vue.js 3应用程序添加无限滚动</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/add-infinite-scrolling-to-a-vue-js-3-app-with-the-intersection-observer-api-706c169947c3?source=collection_archive---------24-----------------------#2021-07-23">https://javascript.plainenglish.io/add-infinite-scrolling-to-a-vue-js-3-app-with-the-intersection-observer-api-706c169947c3?source=collection_archive---------24-----------------------#2021-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1c2f892bbfb2f6d16ef6f68474572a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4Ayxe9OZI2XRMGke"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@galen_crout?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Galen Crout</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f5eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无限滚动是我们必须经常添加到Vue 3应用程序中的东西。</p><p id="3fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用交叉点观察器API为Vue 3应用程序添加无限滚动。</p><h1 id="d960" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用交叉点观察器API添加无限滚动</h1><p id="dcea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">交叉点API让我们可以在Vue 3应用中轻松添加无限滚动。</p><p id="bb0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们为最后一个元素分配一个ref，并观察该元素何时显示在屏幕上。</p><p id="8178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当数组改变时，我们将ref重新分配给最后添加的元素。</p><p id="a1be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bdab" class="mn lc iq mj b gy mo mp l mq mr">&lt;template&gt;<br/>  &lt;div<br/>    v-for="(a, i) of arr"<br/>    :key="a"<br/>    :ref="i === arr.length - 1 ? 'last' : undefined"<br/>  &gt;<br/>    {{ a }}<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="9ec0" class="mn lc iq mj b gy ms mp l mq mr">&lt;script&gt;<br/>export default {<br/>  name: "App",<br/>  data() {<br/>    return {<br/>      page: 1,<br/>      arr: Array(30)<br/>        .fill()<br/>        .map((_, i) =&gt; i),<br/>      observer: undefined,<br/>    };<br/>  },<br/>  methods: {<br/>    async addObserver() {<br/>      await this.$nextTick();<br/>      const options = {<br/>        root: document,<br/>        rootMargin: "20px",<br/>        threshold: 1,<br/>      };</span><span id="3f0c" class="mn lc iq mj b gy ms mp l mq mr">      const callback = (entries) =&gt; {<br/>        if (entries[0].isIntersecting) {<br/>          this.arr = [<br/>            ...this.arr,<br/>            ...Array(30)<br/>              .fill()<br/>              .map((_, i) =&gt; i + 30 * (this.page - 1)),<br/>          ];<br/>          this.page++;<br/>        }<br/>      };<br/>      this.observer = new IntersectionObserver(callback, options);<br/>      this.observer.observe(this.$refs.last);<br/>    },<br/>  },<br/>  mounted() {<br/>    this.addObserver();<br/>  },<br/>  watch: {<br/>    arr: {<br/>      deep: true,<br/>      handler() {<br/>        this.addObserver();<br/>      },<br/>    },<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="7f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一系列从组件模板中的<code class="fe mt mu mv mj b">arr</code>数组呈现的div。</p><p id="b06f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过检查项目的索引是否与<code class="fe mt mu mv mj b">arr.length — 1</code>相同来设置<code class="fe mt mu mv mj b">ref</code>道具。</p><p id="00f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，那么它是最后一项，所以我们给它分配一个ref。</p><p id="501a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们不会给它分配一个引用。</p><p id="5db7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">data</code>方法返回<code class="fe mt mu mv mj b">page</code>数字和<code class="fe mt mu mv mj b">arr</code>数组以及要渲染的数据。</p><p id="d41a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">methods</code>对象中，我们有<code class="fe mt mu mv mj b">addObserver</code>方法来添加交叉点观察器，并使用它来观察我们指定了ref的元素何时出现在屏幕上。</p><p id="915b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们调用<code class="fe mt mu mv mj b">$nextTick</code>来确保元素被渲染。</p><p id="8c4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们设置检测交叉点的选项。</p><p id="bf8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">root</code>是包含我们所关注的项目的元素。</p><p id="12b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">rootMargin</code>是确定项目何时被视为在屏幕上的边距。</p><p id="eeda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">threshold</code>是要显示的元素的阈值。它是元素出现在屏幕上的部分。它是一个介于0和1之间的数字。</p><p id="7b27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们使用了<code class="fe mt mu mv mj b">callback</code>函数来检查<code class="fe mt mu mv mj b">isIntersecting</code>属性，以查看最后一个元素是否出现。</p><p id="5f1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有，那么我们通过在数组中放入更多的条目来更新数组<code class="fe mt mu mv mj b">arr</code>。</p><p id="c8f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还更新了<code class="fe mt mu mv mj b">page</code>值。</p><p id="f0c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们用<code class="fe mt mu mv mj b">callback</code>和<code class="fe mt mu mv mj b">options</code>创建<code class="fe mt mu mv mj b">IntersectionObserver</code>实例。</p><p id="1836" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在它上面调用<code class="fe mt mu mv mj b">observe</code>,这个元素被赋予了ref，看着它出现在屏幕上。</p><p id="dd34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在组件已安装并且<code class="fe mt mu mv mj b">arr</code>数组发生变化时调用该方法。</p><p id="7447" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在组件被渲染之后,<code class="fe mt mu mv mj b">mounted</code>钩子运行，因此我们可以获得分配了ref的元素，并观察它出现在屏幕上。</p><p id="26e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们向下滚动时，我们应该会看到更多的项目出现。</p><h1 id="5128" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6ef1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以轻松地使用交叉点观察器API将无限滚动轻松地添加到我们的Vue 3应用程序中。</p><p id="8810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容尽在</em><a class="ae kc" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>