<html>
<head>
<title>Deep Dive Into Tree-Shaking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度潜入摇树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deep-dive-into-tree-shaking-ba2e648b8dcb?source=collection_archive---------3-----------------------#2021-07-23">https://javascript.plainenglish.io/deep-dive-into-tree-shaking-ba2e648b8dcb?source=collection_archive---------3-----------------------#2021-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aa132b380c2659eacb48a66e5489e165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7cwtYw0Xa4mcev1JEmXKw.png"/></div></div></figure><p id="7cfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript世界中，术语“树摇动”指的是删除死代码的<strong class="jx io">。</strong>但是这个术语并不局限于JavaScript，“摇树”这个词来自于20世纪90年代的Lisp社区。</p><p id="c1c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阿克塞尔·劳施迈尔 ，他把自己变成了印第安纳·琼斯，并在推特上找到了这个词的确切来源。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="701b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我第一次听到这个话题的时候，我非常兴奋地学习摇树。所以我谷歌了一下。</p><p id="69fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据<a class="ae kt" href="https://en.wikipedia.org/wiki/Tree_shaking" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，dart中使用了摇树算法来移除死代码。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi la"><img src="../Images/ebe68fe8261c0e3d2592bd081a9041d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngEul2nNjoEYrC9qK_8oBQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae kt" href="https://en.wikipedia.org/wiki/Tree_shaking" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Tree_shaking</a></figcaption></figure><p id="e87e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我冲进<a class="ae kt" href="https://github.com/dart-lang/site-www/search?q=tree-shaking&amp;unscoped_q=tree-shaking" rel="noopener ugc nofollow" target="_blank"> Dart GitHub repo </a>发现了这个。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/fff875bb5cfe661f610cc8a426a91669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xegdgcOCYGhlov1Qfgam6A.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae kt" href="https://github.com/dart-lang/site-www/search?q=tree-shaking&amp;unscoped_q=tree-shaking" rel="noopener ugc nofollow" target="_blank">https://github.com/dart-lang/site-www/search?q=tree-shaking&amp;unscoped_q=tree-shaking</a></figcaption></figure><p id="0b49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">谢谢谷歌！</strong></p><p id="e086" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">StackOverflow有一个关于摇树的问题，有一个很好的答案。</p><div class="lg lh gp gr li lj"><a href="https://stackoverflow.com/questions/45884414/what-is-tree-shaking-and-why-would-i-need-it" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd io gy z fp lo fr fs lp fu fw im bi translated">什么是树摇动，为什么我需要它？</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">我看到你有三个问题:1.什么是树摇动？2.有什么必要呢？3.还有，你怎么用？树…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">stackoverflow.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx jt lj"/></div></div></a></div><p id="fd7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，我意识到只有几篇文章是关于摇树和它的方法论的。</p><p id="07cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在阅读了大量关于树摇动的文章后，我决定写一篇关于3种不同方法的文章。</p><ol class=""><li id="4b3a" class="ly lz in jx b jy jz kc kd kg ma kk mb ko mc ks md me mf mg bi translated">进口摇树</li><li id="5409" class="ly lz in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">环境变量摇树</li><li id="68db" class="ly lz in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">CSS摇树</li></ol><h1 id="0039" class="mm mn in bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">为什么叫摇树？</h1><p id="b7a8" class="pw-post-body-paragraph jv jw in jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">让我们以下面的代码为例:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/d60b7565e26a9fb48c8fe746f5db0d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRhVrGdSC53TIgd2uMmbKw.png"/></div></div></figure><p id="0833" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">https://bit.ly/2UaKxTV<a class="ae kt" href="https://bit.ly/2UaKxTV" rel="noopener ugc nofollow" target="_blank">REPL</a></p><p id="6949" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文件<code class="fe nq nr ns nt b">main.js</code>使用了两个文件中的3个方法(<code class="fe nq nr ns nt b">square</code> <code class="fe nq nr ns nt b">cube</code> <code class="fe nq nr ns nt b">log</code>)，这些文件有一些额外的方法，这些方法没有被使用，也不会运行。因此，这些代码是<strong class="jx io">死代码</strong>我们需要删除它们。</p><p id="b953" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了便于理解，我们需要将这些依赖转换成一棵树或者技术上的抽象语法树。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/dc992dc5fc89a971ef173ebb9753b3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLs-D7X4pRhlAaGgPQyoJQ.png"/></div></div></figure><p id="34bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们假设这些依赖图是一棵有分支、主干等的普通树。如果你觉得很难把这些图想象成一棵树，没关系，我会为你做的。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/f5c55e7faf9e9ef6de4f3374a8b725e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSGarX2X9GrQAxLm1Xl8mg.png"/></div></div></figure><p id="c7f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好多了！</p><p id="d34a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在用红色标记所有失效代码，用蓝色代码更好理解。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/acce408947ca0aaea5f75eee636c71bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3Hv2BfLIY1MvPZJiczUvA.png"/></div></div></figure><p id="31e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们使劲摇晃一棵树，所有的枯枝都会倒下，这也是我们在代码库中需要做的事情。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/f56845365793d514d8162618e77c8aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiI19kqvrINDVunzcuNktA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Tree-Shaking</figcaption></figure><p id="57f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好，现在让我们摇摇树。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/970056245500b85472dd7c88d1bbd331.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*I0oJCROpUlmji3b2"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae kt" href="https://tenor.com/view/tree-shaking-shaking-cutting-trees-leaves-gif-15973840" rel="noopener ugc nofollow" target="_blank">https://tenor.com/view/tree-shaking-shaking-cutting-trees-leaves-gif-15973840</a></figcaption></figure><h1 id="ef3c" class="mm mn in bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated"><strong class="ak">进口摇树</strong></h1><p id="b9cf" class="pw-post-body-paragraph jv jw in jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">摇树的概念从20世纪90年代就存在了，但是由于ES静态导入，我们最近才在JavaScript中使用它。</p><p id="a1a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ES静态导入或和谐导入允许从不同的文件导入特定的函数或变量。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/a05f09e6aa5b8d8a2cfd69d907b2dc4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sN2IOX6nRwLLIYCY.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae kt" href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" rel="noopener ugc nofollow" target="_blank">https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/</a></figcaption></figure><p id="19b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想了解更多关于es-modules的信息，请查看这篇关于<a class="ae kt" href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" rel="noopener ugc nofollow" target="_blank"> Mozilla Hacks </a>的文章，作者是<a class="nx ny ep" href="https://medium.com/u/d3391efe481a?source=post_page-----ba2e648b8dcb--------------------------------" rel="noopener" target="_blank">林克拉克</a>。</p><p id="c37a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们使用相同的代码来表示树。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/c9cf1750497a9107f92d2d9b97de5479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxMnT9AlrUESzAwxDildJg.png"/></div></div></figure><p id="9e80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文件<code class="fe nq nr ns nt b">main.js</code>是我们的入口模块，在这个页面中，我们只使用了8个方法中的3个。而且所有的方法都是纯函数，意味着它没有任何额外的依赖和副作用。</p><p id="2b6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们删除所有未使用的方法，我们的最终输出将如下所示。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/daa5357b5ebe9ba12ef4e89f4921ab8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrcUOUycoKTccIb1xBdadw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">With Tree-Shaking</figcaption></figure><p id="739a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果没有发生树抖动，最终输出将是这样的。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/8bed5031804ed0ddd6bf2be53f22c29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95NpMrPNhqjjJMzKraLfMQ.png"/></div></div></figure><h2 id="7d7e" class="oc mn in bd mo od oe dn ms of og dp mw kg oh oi na kk oj ok ne ko ol om ni on bi translated"><strong class="ak">如何删除死代码</strong></h2><p id="6336" class="pw-post-body-paragraph jv jw in jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">现在是价值百万的问题:“如何删除死代码？”</p><p id="3478" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数现代构建工具都会进行树抖动来减小最终包的大小。通过分析它们，我们可以了解它们是如何工作的。</p><p id="d17e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般来说，树抖动将移除没有连接到根节点的节点(方法/变量)。</p><p id="8089" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我进一步解释一下。</p><p id="c92b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们回到语法树(在头脑中将代码转换成语法树)。如果抽象语法树中没有使用方法或变量，这些函数将不会连接到根节点。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/26190485365504c89b3c33342ff9c3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/0*qEMSoUA0LZmSXBU3.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae kt" href="https://www.gatevidyalay.com/tree-data-structure-tree-terminology/" rel="noopener ugc nofollow" target="_blank">https://www.gatevidyalay.com/tree-data-structure-tree-terminology/</a></figcaption></figure><p id="20ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要做的就是删除没有连接到根节点的节点。大多数打包程序使用一种算法来查找并删除死代码，这种算法类似于<a class="ae kt" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="noopener ugc nofollow" target="_blank">标记和扫描</a>算法。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi op"><img src="../Images/e36443042b9bca456678d24ea2ceeb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/0*9DDxZfEbj2KFu4YS.gif"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae kt" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a></figcaption></figure><p id="53b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">垃圾收集器中通常使用标记和清除算法来识别活的和死的对象，并从内存中移除死的对象。</p><p id="1fd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae kt" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank">汇总捆绑器</a>中默认启用树抖动，因此我们可以在<a class="ae kt" href="https://rollupjs.org/repl" rel="noopener ugc nofollow" target="_blank">汇总REPL </a>上测试我们的代码</p><p id="1b87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下输出由es-build的汇总生成。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="oq kz l"/></div></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi or"><img src="../Images/74ec2fc00882b51b40103f14ceddbc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5WYpZbopdrWBiWBK2tGmg.png"/></div></div></figure><h2 id="5768" class="oc mn in bd mo od oe dn ms of og dp mw kg oh oi na kk oj ok ne ko ol om ni on bi translated">如果函数使用另一个函数呢？</h2><p id="6fd2" class="pw-post-body-paragraph jv jw in jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">让我们通过添加依赖项来改变我们的方法<code class="fe nq nr ns nt b">square</code>。在使用<code class="fe nq nr ns nt b">isNumber</code>方法的<code class="fe nq nr ns nt b">square</code>方法中增加了一个验证方法。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi os"><img src="../Images/f88b2645f870a599f9dd718e417f2028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HB9dtig66yxqnAKVesZtsg.png"/></div></div></figure><p id="2642" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们的最终输出也应该包括<code class="fe nq nr ns nt b">isNumber</code>方法。</p><p id="dacb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">汇总输出。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="oq kz l"/></div></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ot"><img src="../Images/6bab20a92942be7d518569b4a4e1122d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7yDlJEa1jstNpUKAmbZVg.png"/></div></div></figure><p id="dade" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打包程序可以识别依赖的方法，并将它们包含在最终的构建中。</p><p id="fbc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>导入树抖动也可以用commonJS格式完成，但es导入格式的效果更好。</p><p id="0a3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多信息:请参考本报告:<a class="ae kt" href="https://github.com/rollup/plugins/tree/master/packages/commonjs" rel="noopener ugc nofollow" target="_blank">https://github . com/roll up/plugins/tree/master/packages/commonjs</a></p><h2 id="e93a" class="oc mn in bd mo od oe dn ms of og dp mw kg oh oi na kk oj ok ne ko ol om ni on bi translated">上课摇树</h2><p id="08b5" class="pw-post-body-paragraph jv jw in jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">和一个班一起摇树就是另一回事了！</p><p id="3307" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们通过使用包含静态方法的类来重构代码(非静态方法也可以)。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ou"><img src="../Images/527b36a473820b183c5587a743c3113b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsreqhMa6KBRIfkKpJ2k9g.png"/></div></div></figure><p id="9397" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在抽象树中，类将连接到其方法的根节点。</p><p id="e405" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以即使我们没有使用所有的方法，它们也会被包含在最终的构建中。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="oq kz l"/></div></figure><p id="cd73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样的事情也适用于对象。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ot"><img src="../Images/538bef395deeb3c36a1f138123727f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtTsnHDp35bjT9j7CK4inw.png"/></div></div></figure><p id="f5d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当编写模块化代码时，为特定的代码创建一个抽象的思维图，这样你就知道最终的输出。</p><h1 id="ed6e" class="mm mn in bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated"><strong class="ak">环境变量</strong></h1><p id="33a5" class="pw-post-body-paragraph jv jw in jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">环境变量在运行时不会改变，所以大多数绑定器会根据值进行树抖动。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="oq kz l"/></div></figure><p id="b523" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在构建过程中。</p><p id="b61a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果<code class="fe nq nr ns nt b">NODE_ENV</code>是<code class="fe nq nr ns nt b">true</code>，则不需要else部分，因此打包程序会将其移除。没有必要使用<code class="fe nq nr ns nt b">if-check</code>,因为它永远是真的。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="oq kz l"/></div></figure><p id="85b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果<code class="fe nq nr ns nt b">NODE_ENV</code>是<code class="fe nq nr ns nt b">false</code>，捆绑做同样的事情。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="oq kz l"/></div></figure><p id="532c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果配置会在运行时改变，考虑将它们转换成环境变量，并根据值使用<code class="fe nq nr ns nt b">if-checks</code>。</p><h1 id="6684" class="mm mn in bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">CSS摇树</h1><p id="6f6b" class="pw-post-body-paragraph jv jw in jx b jy nk ka kb kc nl ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated">我们不能直接对CSS应用标记扫描算法。是的，CSS很难做。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/50bd566892eb792dfab2a9a966591f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/0*mU13cuheQVb2-4Yx"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae kt" href="https://www.reddit.com/r/ProgrammerHumor/comments/8tnztu/backend_developer_doing_css/" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/ProgrammerHumor/comments/8tnztu/backend_developer_doing_css/</a></figcaption></figure><p id="e873" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">做CSS对前端和后端开发来说都很难，因为有很多方法可以做同样的事情。</p><p id="8b4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">幸运的是！一些现代的CSS框架将帮助我们解决这个问题，他们也在JavaScript的帮助下做了树摇动。</p><h2 id="4285" class="oc mn in bd mo od oe dn ms of og dp mw kg oh oi na kk oj ok ne ko ol om ni on bi translated">净化</h2><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ow"><img src="../Images/76d9b9ef5ad400306d95b10342d9abfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KomaeHQjyhsO8VQx.jpg"/></div></div></figure><p id="a185" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://purgecss.com/" rel="noopener ugc nofollow" target="_blank"> Purge </a>是一套工具，用于检测并删除未使用的CSS。它可以和<code class="fe nq nr ns nt b">webpack</code> <code class="fe nq nr ns nt b">postCSS</code> <code class="fe nq nr ns nt b">grunt</code> <code class="fe nq nr ns nt b">gulp</code> <code class="fe nq nr ns nt b">gatsby</code>一起使用</p><p id="bcfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">webpack的示例配置文件。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="oq kz l"/></div></figure><p id="e3ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些现代的CSS框架会清理“引擎盖下”来提高它们的性能。</p><h2 id="9a7c" class="oc mn in bd mo od oe dn ms of og dp mw kg oh oi na kk oj ok ne ko ol om ni on bi translated">顺风摇树</h2><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ox"><img src="../Images/10551f46e8acf5deee0502dfc0c08e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VT6n_MUrhKN8T_Bm"/></div></div></figure><p id="fe6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">顺风</a>搭载了数吨性能特征，其中之一就是<strong class="jx io">摇树。</strong></p><p id="b831" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">清除使用这个正则表达式<code class="fe nq nr ns nt b">/[^&lt;&gt;"'`\s]*[^&lt;&gt;"'`\s:]/g</code>来获取类名，所以当您有条件地构造类名时，请构造一个完整的字符串，而不是部分字符串。</p><p id="697b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不要这样做:</p><pre class="ku kv kw kx gt oy nt oz pa aw pb bi"><span id="0eb4" class="oc mn in nt b gy pc pd l pe pf">&lt;div class="text-{{  error  ?  'red'  :  'green'  }}-600"&gt;&lt;/div&gt;</span></pre><p id="dae9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请改为执行以下操作:</p><pre class="ku kv kw kx gt oy nt oz pa aw pb bi"><span id="d888" class="oc mn in nt b gy pc pd l pe pf">&lt;div class="{{  error  ?  'text-red-600'  :  'text-green-600'  }}"&gt;&lt;/div&gt;</span></pre><p id="5b86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要启用清除，您需要在配置文件中指定路径。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="oq kz l"/></div></figure><p id="31d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">详情请查阅<a class="ae kt" href="https://tailwindcss.com/docs/optimizing-for-production" rel="noopener ugc nofollow" target="_blank">公文</a></p><p id="46cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你能稍微理解一下摇树的概念。如果你想知道，请使用以下链接。</p><ol class=""><li id="3a20" class="ly lz in jx b jy jz kc kd kg ma kk mb ko mc ks md me mf mg bi translated"><a class="ae kt" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">网络包中的摇树</a>(官方文档)</li><li id="f412" class="ly lz in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated"><a class="ae kt" href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking" rel="noopener ugc nofollow" target="_blank">用树摇动减少JavaScript有效负载</a> (Chrome Dev文章)</li><li id="e194" class="ly lz in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated"><a class="ae kt" href="https://www.smashingmagazine.com/2021/05/tree-shaking-reference-guide/" rel="noopener ugc nofollow" target="_blank">摇树:参考指南</a>(粉碎杂志文章)</li><li id="a82d" class="ly lz in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated"><a class="ae kt" href="https://twitter.com/iamakulov/status/1353650650438119424" rel="noopener ugc nofollow" target="_blank"> /*# __PURE__*/ </a>(一个关于PURE的非常棒的推特帖子)</li></ol><p id="f4e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对这篇文章有任何疑问/建议，请留下评论。</p><p id="cb01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有，看看我最近的文章</p><ol class=""><li id="fad1" class="ly lz in jx b jy jz kc kd kg ma kk mb ko mc ks md me mf mg bi translated"><a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/where-to-store-the-json-web-token-jwt-4f76abcd4577">您应该将JSON网络令牌存储在哪里(JWT)？</a></li><li id="eea7" class="ly lz in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated"><a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/how-memory-management-works-in-javascript-f07ccd544190">JavaScript内存管理入门指南</a></li><li id="9ee7" class="ly lz in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated"><a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/usequery-instead-of-fetch-while-calling-an-api-ef12964457c5">调用API时使用查询代替获取</a></li></ol><p id="9217" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">开心树摇❤️ </strong></p><p id="6aa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="pg">更内容见于</em> <a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="pg">普通英语中</em></strong></a></p></div></div>    
</body>
</html>