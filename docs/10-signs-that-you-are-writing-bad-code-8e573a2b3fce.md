# 你正在编写糟糕代码的 10 个迹象

> 原文：<https://javascript.plainenglish.io/10-signs-that-you-are-writing-bad-code-8e573a2b3fce?source=collection_archive---------1----------------------->

## 大多数程序员甚至不知道他们正在编写糟糕的代码

![](img/221e8cc4e50426d7f33023f030a06bbc.png)

Photo by [Maria Teneva](https://unsplash.com/@miteneva?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

如果你是一名程序员，我相信你会使用 Github 之类的东西来存储你的代码。看看你一年前或者更久以前写的旧代码就知道了。我确信你会惊讶于从现在到你写代码的这段时间里你已经提高了多少。

我自己也经历过这种情况，我遇到的每个程序员都是这么说的。我一直在想，我的余生会不会发生这种事？答案是**没有**但是大多数高级程序员都说，对于一个程序员来说，这种情况会发生很长时间。但是，通过了解如何避免编写糟糕的代码，您可以轻松地跳过几年来实现改进，而不是缓慢地改进。

大多数初级或新程序员(甚至一些有经验的程序员)不知道如何区分好代码和坏代码。如果代码运行，他们继续前进。由于大多数程序员独自工作，他们从来不知道自己写的是糟糕的代码。但是，只要付出一点努力，就有很大的空间可以做得更好。

但是首先，你必须知道你写的是不是糟糕的代码。今天，我将谈论一些在行业中被认为是糟糕的编码实践的迹象。让我们开始吧。

# 到处复制代码

每一个不尝试写干净代码的程序员都会遇到这种情况。如果你想知道你是不是他们中的一员，那么继续阅读这个场景。

假设你在一个类或函数中写了十行代码。那很好。现在，在同一个项目的另一个类或另一个功能中，你必须做同样的事情，那么你的即时反应会是什么？您可以复制这十行代码并粘贴到需要的地方，而不是编写一个单独的函数来完成这项任务。

我的问题是，什么时候你会考虑写一个单独的函数，而不是复制粘贴？因为复制粘贴比写函数容易。

如果我不得不在一个项目中再次使用相同的代码行，我每次都会编写函数。它有几个好处。

1.  当你必须使用相同的代码行时，它可以节省时间(这就是为什么我们使用函数，不是吗？)
2.  代码简单易懂。
3.  更干净的代码。
4.  您可以在其他项目中轻松使用这些功能。
5.  易于识别和清除垃圾代码。

# 使相同的功能表现不同

一致性是一个好程序员的品质。你必须遵循一个模式。作为程序员，你要写很多函数。如果你用不同的方式编写相同类型的函数，下一个程序员将很难读懂你的代码。

我给你举个例子。假设您已经编写了两个不同的函数来验证一些数据。一个功能是验证用户的生日，另一个功能是验证用户的个人资料图片。

正常情况下，如果输入与数据匹配，布尔函数将返回 true。否则为假。

现在想象一下，如果生日与输入匹配，第一个布尔函数返回 true。那么您显然会认为，如果输入图像与用户的图片匹配，第二个函数将返回 true。但是如果输入与用户的照片匹配，第二个布尔函数将返回 false(相信我！一些自私不负责任的程序员就是这么做的)。

为了便于理解，我举了一个非常简单的例子，但这适用于每个函数和方法。

如果你是写不一致代码的程序员，你应该知道这是不专业的。你还必须确保你的开发伙伴和同事也能轻松阅读你的代码。

# 硬编码

我不知道你怎么想，但是我讨厌硬编码。但这很容易发现，也很容易预防。看看这段代码。

```
for(int i=0; i<50; i++){//Do something
}
```

在极少数情况下，您必须努力编码。因为以我的经验来看，一切都是多变的，几乎一切都在变。您可以很容易地初始化一个变量并将值赋给该变量。像这样:

```
int n=50;//or you can write a function to initialize n
for(int i=0; i<n; i++){//Do something
}
```

我喜欢动态解决方案。如果你想改变一个静态解决方案的一小部分，你必须每次都更新应用程序。现在大部分项目都使用云服务。如果您的项目使用一些云服务，最好从云和它的标准获取数据。

```
int n= fethDataFromCloud();
for(int i=0; i<n; i++){//Do something
}
```

一些程序员在测试阶段使用硬代码，但有时会因为截止日期和其他一些原因而懒得在生产阶段修改它。但是请不要这样做。以后会给你增加更多的压力和任务。

# 复杂条件

我说的复杂条件是什么意思？我们来讨论一个例子。

```
First case:
if(a || b && c)||f && x==y){
}Second case:if(x==y){
  if(a){}
  else if(b){}
  else{}
}
```

上面的两个例子不会给出相同的输出。我的观点是，嵌套的条件句有时很容易读懂(不总是，但大多数时候)。

不要为了省 2/3 行而试图写复杂的条件句。如果你不得不多写两行，但它变得很容易理解，那么就写吧。这也是避免意外错误或行为的方法。

# 内置特性和工具

我不明白为什么有些开发人员不使用内置特性和工具。如果你真的要打发时间浪费雇主的钱，那么请你做点别的。不要惩罚项目和阅读你代码的开发人员。

99/100 次，从时间和记忆复杂性的角度来看，你的功能会变得不那么有效。许多程序员在编写自己的函数之前，可能甚至不知道有一个很好的内置函数。

这也是为什么大部分高级程序员建议初学者和初级程序员在编写自己的函数之前，先在网上搜索 5 分钟。

> 额外的好处是，即使你没有发现任何内置函数，你也可能会学到其他程序员是如何做到的。永远记住写代码是程序员的一小部分。阅读代码也是非常重要的一部分。

# 把命名变成一个谜语游戏

你可以通过一个项目中函数和类的命名来了解一个程序员的经历。

我们来看一个简单的例子→ getABC()。

你能告诉我它是做什么的吗？没人能。如果你这样写函数名，下一个看你代码的程序员肯定会诅咒你。因为他们可能不得不阅读函数的每一行来理解它做什么。

看这个名字→ getUserNameFromDB()。它清楚地告诉我们方法的输出。

一些程序员把名字缩写得太多，以至于很难理解它的完整版本。`handleBtnClick`、`getConfig`或者`parseInfo`都很好理解。但是`hndleBtnClk`、`getCnfg`都太短了。

我仍然记得我大学生活中的一件事。我的一个课程老师因为在 Java 实验室拼错了一个函数名而被扣分。我问他为什么这么做？我回答了这个问题，它运行得很好。他对我说他这么做是为了让我以后记住。

> 我变得很难过，发现这个解释不合逻辑。我知道你可能不会读这篇文章，先生，但非常感谢你的教训。

# 到处使用全局变量

引入局部变量是有原因的，对吗？当任务可以使用局部变量完成时，请尽量避免使用全局变量。

为什么？原因有很多。我告诉你一些要点。

1.  您会得到更少的错误和意想不到的结果。
2.  如果出现错误，很容易找到错误。
3.  如果你因为某种原因不得不重构代码，那就简单多了。
4.  当你到处使用全局变量时，其他程序员阅读你的代码会困难百倍。

如果你到处使用全局变量，那么你是一个糟糕的编码者。如果你因此受到冒犯，我很抱歉。但这是真的！

# 编写非常复杂的代码

有时候程序员喜欢用复杂的方式写一段代码，但是相信我，这不会让你成为一个优秀的程序员。以我个人的经验，超过 60–70%的程序员有一些编码爱好，他们喜欢用复杂的方式而不是标准的方式做一些事情。

“神秘”不好。“容易”很好。有一次我问一个程序员为什么要这么做？他回答我说，这样公司对他来说就可靠了，他的工作也有了保障。但这是一个非常错误的想法，非常错误的概念。

请不要让你的同事和同事因为你的“爱好”或复杂的代码而受苦。通过编写简单易读的代码，您可以为其他开发人员节省时间。

不使用任何注释或不维护任何文档也会使您的代码难以理解。有时复杂的代码通过适当的注释变得更容易理解。

# 顺序功能/方法

如果你的函数是连续的，那么这是糟糕的编码的标志。像这样:

开始()

开始()

正在准备()

.

.

结束()

其他程序员怎么知道他们必须在 begin()函数之前调用 start()函数呢？如果是这样，那么在 begin()函数内部调用 start()函数。

一个功能应该独立工作。使用模板方法模式是避免这些情况的解决方案。

# 完全不考虑时间或记忆的复杂性

我经常看到程序员使用本来可以避免的嵌套循环。但是“完成工作或者运行代码就够了”的心态让程序员变得懒惰和低效。当团队不欣赏好代码或不关心这些问题时，程序员就不太关心时间和内存复杂度。

但这是一种习惯。如果你写了高效的代码，它将成为你的力量。如果不这样，你就改变不了格局，以后肯定会吃亏。

很多程序员甚至不太了解内存复杂度。如果没有，请学习。这也会在编码面试中对你有所帮助。

# 最后几句话

成为一名优秀的程序员可能需要一些时间。但是你越避免这些实践，你的代码就越干净、越好。不要告诉自己，随着时间的推移，一切都会好的。要写出好的代码，你不一定要成为火箭科学家。

*更多内容看*[***plain English . io***](http://plainenglish.io/)