<html>
<head>
<title>How to Send Messages Between Electron Windows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在电子窗口之间发送消息</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/messaging-between-electron-windows-a646b0af7d8d?source=collection_archive---------6-----------------------#2021-03-04">https://javascript.plainenglish.io/messaging-between-electron-windows-a646b0af7d8d?source=collection_archive---------6-----------------------#2021-03-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f8d9aaab81e03e57d5d84ed5a8bf8c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RCH9UgnVuXn_rQZy"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@miteneva?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maria Teneva</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1d45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在多个窗口中的React应用程序之间复制剪贴板数据。</p><p id="3206" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Electron中的多个窗口不共享相同的数据模型，必须使用进程间通信来共享数据。</p><p id="c512" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管所有的窗口都来自同一个应用程序，但每个窗口都是一个包含唯一Chromium web视图的<code class="fe ky kz la lb b">BrowserWindow</code>实例。在窗口之间发送消息类似于web浏览器中的选项卡或窗口。</p><p id="cc5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在web浏览器中，您可以使用广播频道进行通信。</p><p id="b26a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义通道后，发布的消息将为侦听器调度事件:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="ea7a" class="lk ll in lb b gy lm ln l lo lp">const channel = new BroadcastChannel("mychannel");</span><span id="5f3d" class="lk ll in lb b gy lq ln l lo lp">// Send a message:<br/>channel.postMessage("Hello, world");</span><span id="486b" class="lk ll in lb b gy lq ln l lo lp">// Receive a message:<br/>channel.onmessage = (event) =&gt; {<br/>  console.log(event);<br/>});</span></pre><p id="2134" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在electronic中，通过将消息从呈现进程发送到主进程，利用了类似的策略。然后，主进程向所有渲染窗口发送消息。</p><h2 id="89ce" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">剪贴板示例</h2><p id="630c" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">例如，考虑我们想要在窗口之间共享的高级剪贴板数据。每个窗口可能运行独特的应用程序；或者，同一个应用的多个实例。</p><p id="9c95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将继续我的多窗口电子应用程序帖子:</p><div class="mn mo gp gr mp mq"><a href="https://jasonsturges.medium.com/multiple-window-electron-app-9dbffde8ce95" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">多窗口电子应用程序</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">轻松打开多个窗口类似于Visual Studio代码的文件≫新窗口。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">jasonsturges.medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne jt mq"/></div></div></a></div><p id="b569" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在那个例子中，新窗口可以通过<em class="nf">文件≫新窗口</em>打开，这有效地创建了完全相同的React应用的新实例。</p><h2 id="f004" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">发送数据</h2><p id="40a2" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">从任何窗口的web内容中，将数据有效载荷序列化到JSON，并通过<code class="fe ky kz la lb b">ipcRenderer</code>将其发送到所需的通道。在这个例子中，客户端将使用<code class="fe ky kz la lb b">clipboard-send</code>发送剪贴板数据。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="a9fa" class="lk ll in lb b gy lm ln l lo lp">const { ipcRenderer } = require('electron');</span><span id="0fb6" class="lk ll in lb b gy lq ln l lo lp">const copy = (data) =&gt; {<br/>  const json = JSON.stringify(data);<br/>  ipcRenderer.send("clipboard-send", json);<br/>}</span></pre><p id="474a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在主线程(<code class="fe ky kz la lb b">main.dev.js</code>)中，在<code class="fe ky kz la lb b">ipcMain</code>上创建一个监听器来处理从任何窗口的渲染器进程分派的<code class="fe ky kz la lb b">clipboard-send</code>通道事件。然后，通过发送<code class="fe ky kz la lb b">clipboard-receive</code>通道事件将该数据转发回所有窗口:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="0e4a" class="lk ll in lb b gy lm ln l lo lp">const { ipcMain<strong class="lb io"><em class="nf"> </em></strong>} = require('electron');<br/><br/>ipcMain.on('clipboard-send', (event, json) =&gt; {<br/>  windows.forEach(window =&gt; {<br/>    window.send('clipboard-receive', json);<br/>  });<br/>});</span></pre><h2 id="3697" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">接收数据</h2><p id="f8b1" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">现在主线程向所有窗口发送消息，每个窗口都需要监听<code class="fe ky kz la lb b">clipboard-receive</code>通道上的事件:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="b775" class="lk ll in lb b gy lm ln l lo lp">const { ipcRenderer } = require('electron');</span><span id="d99a" class="lk ll in lb b gy lq ln l lo lp">let clipboard = {};</span><span id="383b" class="lk ll in lb b gy lq ln l lo lp">ipcRenderer.on('clipboard-receive', (event, json) =&gt; {<br/>  if (!json) return;</span><span id="a161" class="lk ll in lb b gy lq ln l lo lp">  const data = JSON.parse(json);<br/>  clipboard = data;<br/>});</span></pre><p id="9416" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个窗口的渲染器线程现在可以反序列化数据负载，并将其缓存在本地剪贴板中。</p><p id="505a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整生命周期:</p><ul class=""><li id="4189" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">一个窗口的渲染器线程向主线程发送消息</li><li id="575c" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">主线程将消息回显到所有窗口</li><li id="a25b" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">所有窗口都接收带有数据负载的事件</li></ul><h2 id="22ee" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">新窗口</h2><p id="239b" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">这里是数据广播后创建的窗口。继续剪贴板的例子，让我们说:</p><ul class=""><li id="a7e1" class="ng nh in kc b kd ke kh ki kl ni kp nj kt nk kx nl nm nn no bi translated">一个窗口将数据复制到剪贴板</li><li id="e404" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">一个新窗口打开了</li><li id="0237" class="ng nh in kc b kd np kh nq kl nr kp ns kt nt kx nl nm nn no bi translated">用户试图粘贴到新窗口中—该窗口自消息广播后创建以来没有收到任何事件。</li></ul><p id="3168" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，您可以在主渲染器中创建本地缓存；然后，在创建新窗口时自动发送剪贴板数据。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="1ca2" class="lk ll in lb b gy lm ln l lo lp">const { ipcMain } = require('electron');</span><span id="c385" class="lk ll in lb b gy lq ln l lo lp">let clipboardCache;</span><span id="12fd" class="lk ll in lb b gy lq ln l lo lp">export const createWindow = async () =&gt; {<br/>  let newWindow = new BrowserWindow();<br/>  // ...</span><span id="51fa" class="lk ll in lb b gy lq ln l lo lp">  newWindow.webContents.on('did-finish-load', () =&gt; {<br/>    // Send clipboard data<br/>    newWindow.send('clipboard-receive', clipboardCache);<br/>  });<br/>}</span></pre><h2 id="0f82" class="lk ll in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">把所有的放在一起</h2><p id="5514" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">在窗口中显示的JavaScript代码中，例如React应用程序，向主线程发送和接收事件。这类似于客户端和服务器之间的通信:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="aa44" class="lk ll in lb b gy lm ln l lo lp">const { ipcRenderer } = require('electron');</span><span id="9536" class="lk ll in lb b gy lq ln l lo lp">// Local clipboard cache<br/>let clipboard = {};</span><span id="6fe9" class="lk ll in lb b gy lq ln l lo lp">// Send clipboard data to the main thread<br/>const copy = (data) =&gt; {<br/>  const json = JSON.stringify(data);<br/>  ipcRenderer.send("clipboard-send", json);<br/>};</span><span id="6baa" class="lk ll in lb b gy lq ln l lo lp">// Listen for incoming clipboard data<br/>ipcRenderer.on('clipboard-receive', (event, json) =&gt; {<br/>  if (!json) return;<br/>  <br/>  const data = JSON.parse(json);<br/>  clipboard = data;<br/>});</span><span id="20e8" class="lk ll in lb b gy lq ln l lo lp">// Do something with the clipboard data<br/>const paste = () =&gt; {<br/>  if (!clipboard) return;</span><span id="f681" class="lk ll in lb b gy lq ln l lo lp">  // ...<br/>};</span></pre><p id="7bab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在主线程(<code class="fe ky kz la lb b">main.dev.js</code>)中，加入前面的多个例子:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="abc0" class="lk ll in lb b gy lm ln l lo lp">const { ipcMain<strong class="lb io"><em class="nf"> </em></strong>} = require('electron');</span><span id="2bbc" class="lk ll in lb b gy lq ln l lo lp"><strong class="lb io">// Clipboard cache<br/>let clipboard;</strong></span><span id="61ab" class="lk ll in lb b gy lq ln l lo lp">const windows = new Set();</span><span id="89ba" class="lk ll in lb b gy lq ln l lo lp">export const createWindow = async () =&gt; {<br/>  if (<br/>    process.env.NODE_ENV === 'development' ||<br/>    process.env.DEBUG_PROD === 'true'<br/>  ) {<br/>    await installExtensions();<br/>  }</span><span id="6f04" class="lk ll in lb b gy lq ln l lo lp">  let x, y;</span><span id="28ca" class="lk ll in lb b gy lq ln l lo lp">  const currentWindow = BrowserWindow.getFocusedWindow();</span><span id="a343" class="lk ll in lb b gy lq ln l lo lp">  if (currentWindow) {<br/>    const [currentWindowX, currentWindowY] = currentWindow.getPosition();<br/>    x = currentWindowX + 24;<br/>    y = currentWindowY + 24;<br/>  }</span><span id="d316" class="lk ll in lb b gy lq ln l lo lp">  let newWindow = new BrowserWindow({<br/>    show: false,<br/>    width: 1200,<br/>    height: 812,<br/>    x,<br/>    y,<br/>    webPreferences: {<br/>      nodeIntegration: true<br/>    }<br/>  });</span><span id="4098" class="lk ll in lb b gy lq ln l lo lp">  newWindow.loadURL(`file://${__dirname}/app.html`);</span><span id="fab2" class="lk ll in lb b gy lq ln l lo lp">  newWindow.webContents.on('did-finish-load', () =&gt; {<br/>    if (!newWindow) {<br/>      throw new Error('"newWindow" is not defined');<br/>    }<br/>    if (process.env.START_MINIMIZED) {<br/>      newWindow.minimize();<br/>    } else {<br/>      newWindow.show();<br/>      newWindow.focus();<br/>    }</span><span id="10a7" class="lk ll in lb b gy lq ln l lo lp"><strong class="lb io">    // Send clipboard data to new window<br/>    newWindow.send('clipboard-receive', clipboard);</strong></span><span id="af4b" class="lk ll in lb b gy lq ln l lo lp">  });</span><span id="726f" class="lk ll in lb b gy lq ln l lo lp">  newWindow.on('closed', () =&gt; {<br/>    windows.delete(newWindow);<br/>    newWindow = null;<br/>  });</span><span id="1371" class="lk ll in lb b gy lq ln l lo lp">  newWindow.on('focus', () =&gt; {<br/>    const menuBuilder = new MenuBuilder(newWindow);<br/>    menuBuilder.buildMenu();<br/>  });</span><span id="f743" class="lk ll in lb b gy lq ln l lo lp">  windows.add(newWindow);<br/>  return newWindow;<br/>};</span><span id="81de" class="lk ll in lb b gy lq ln l lo lp">app.on('activate', () =&gt; {<br/>  // On macOS it's common to re-create a window in the app when the<br/>  // dock icon is clicked and there are no other windows open.<br/>  if (windows.size === 0) createWindow();<br/>});</span><span id="2ec5" class="lk ll in lb b gy lq ln l lo lp"><strong class="lb io"><br/>// Echo clipboard data back to all windows:<br/>ipcMain.on('clipboard-send', (event, json) =&gt; {<br/>  clipboard = json;</strong></span><span id="9a6b" class="lk ll in lb b gy lq ln l lo lp"><strong class="lb io">  windows.forEach(window =&gt; {<br/>    window.send('clipboard-receive', json);<br/>  });<br/>});</strong></span></pre></div></div>    
</body>
</html>