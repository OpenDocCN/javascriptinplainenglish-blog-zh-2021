<html>
<head>
<title>JavaScript Prototypes in Plain English</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单英语的JavaScript原型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-prototypes-in-plain-english-305781fbd979?source=collection_archive---------8-----------------------#2021-10-25">https://javascript.plainenglish.io/javascript-prototypes-in-plain-english-305781fbd979?source=collection_archive---------8-----------------------#2021-10-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/ce29a92be30b86693480eaafe4d1084c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*3h7SiZSKp08yGBAzpB8apA.png"/></div><figcaption class="is it gj gh gi iu iv bd b be z dk"><em class="iw">Image by </em><a class="ae ix" href="https://pixabay.com/users/jozefm84-10215106/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5033990" rel="noopener ugc nofollow" target="_blank"><em class="iw">Jozef Mikulcik </em></a><em class="iw">from </em><a class="ae ix" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5033990" rel="noopener ugc nofollow" target="_blank"><em class="iw">Pixabay</em></a></figcaption></figure><div class=""/><p id="5698" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">初学者很难理解的JavaScript概念之一是原型，尤其是对于来自基于类的编程语言的程序员来说。</p><p id="21d5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">你可能会问，“现代JavaScript没有<code class="fe kv kw kx ky b">class</code>关键字吗？”</p><p id="235d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">是的，确实如此，但这只是对原型的“糖衣”,理解原型是如何工作的可以在调试JavaScript代码时减轻你的压力。</p><p id="fec4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">JavaScript很奇怪，但是在我看来理解它就不会那么奇怪了(如果你相信我的观点很重要的话:)。</p><h1 id="d481" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">从为什么开始</h1><p id="14f5" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">类和原型是不同的，但是它们有一个共同的想法:它们允许我们重用代码。一个类定义了一个“蓝图”,用于创建一个包含类中定义的字段的对象。</p><p id="48f2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">有了这个“蓝图”，我们可以根据需要创建任意多的对象。我们很快就会看到，尽管原型的工作方式不同，但它们也允许我们重用代码。</p><h1 id="950a" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">对象及其成员</h1><p id="5777" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">考虑以下对象:</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="1197" class="mk la ja ky b gy ml mm l mn mo">var song = {<br/>  title: "Bed of Stones",<br/>  artiste: "Asa",<br/>  getDescription : () =&gt; {<br/>    return "Best song on earth"<br/>  }<br/>}</span></pre><p id="a438" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">这个对象的成员是<code class="fe kv kw kx ky b">title</code>、<code class="fe kv kw kx ky b">artiste</code>和<code class="fe kv kw kx ky b">getDescription</code>。引用一个函数的成员被称为方法(在这个例子中是<code class="fe kv kw kx ky b">getDescription</code>，而其他的被认为是对象的属性。然而，将所有成员称为属性是很常见的。</p><h1 id="73d5" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">原型</h1><p id="2824" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">原型是作为另一个对象的基本对象的对象。</p><p id="f58d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">这到底是什么意思？</p><p id="6512" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">请记住，对象包含成员，因此如果我们将<code class="fe kv kw kx ky b">song.title</code>解释为从<code class="fe kv kw kx ky b">song</code>对象请求<code class="fe kv kw kx ky b">title</code>成员，那么原型就是<em class="mp">另一个对象</em>如果我们正在处理的对象没有该成员，我们可以向其请求成员。</p><p id="f6a8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">一个对象通过一个内部属性被绑定到它的原型，大多数浏览器都将其公开为<code class="fe kv kw kx ky b">__proto__</code>。</p><p id="dd65" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">默认情况下，每次创建一个内置类型的新实例，比如<code class="fe kv kw kx ky b">Array</code>或<code class="fe kv kw kx ky b">Object</code>，这些实例都会自动拥有一个全局对象的实例作为它们的原型。</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="57b3" class="mk la ja ky b gy ml mm l mn mo">var song = {<br/>  title: "Bed of Stones",<br/>  artiste: "Asa"<br/>}<br/>console.log(typeof song.__proto__) // prints "object"</span></pre><p id="45dc" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">该原型对象也包含成员，其中一些成员如下图所示:</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/38febdd88acb9a1126d50fd96077f025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*lkOKlLm_5NhF0h92"/></div></figure><p id="80b9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">当我们写作时，</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="24a0" class="mk la ja ky b gy ml mm l mn mo">song.toString()</span></pre><p id="4aad" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">JavaScript引擎将首先为<code class="fe kv kw kx ky b">toString</code>检查<code class="fe kv kw kx ky b">song</code>对象的成员，如果没有找到，它将检查song对象的原型。在本例中，它在那里找到了<code class="fe kv kw kx ky b">toString</code>属性。</p><h1 id="d8ac" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">对象成员的类型</h1><p id="7ce0" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">从上一节来看，这意味着一个对象可以有两种类型的成员:</p><ol class=""><li id="038a" class="mr ms ja jz b ka kb ke kf ki mt km mu kq mv ku mw mx my mz bi translated">实例成员也称为自己的成员</li><li id="f2ea" class="mr ms ja jz b ka na ke nb ki nc km nd kq ne ku mw mx my mz bi translated">原型成员</li></ol><p id="4564" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">JavaScript提供了区分两者的方法。例如，我们可以写</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="7edb" class="mk la ja ky b gy ml mm l mn mo">console.log(song.hasOwnProperty("title")) //prints true console.log(song.hasOwnProperty("artiste")) //prints true console.log(song.hasOwnProperty("toString")) //prints false</span></pre><p id="1906" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><code class="fe kv kw kx ky b">hasOwnProperty(fieldName)</code>询问JavaScript引擎<code class="fe kv kw kx ky b">fieldName</code>是否是正在讨论的对象的实例成员。</p><p id="d3e2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">另一方面，JavaScript中的<code class="fe kv kw kx ky b">in</code>操作符检查实例和原型成员</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="2de5" class="mk la ja ky b gy ml mm l mn mo">console.log("title" in song) //true console.log("artiste" in song) //true console.log("toString" in song) //true</span></pre><p id="69fb" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><strong class="jz jb">小测验</strong> : <em class="mp">我们如何在</em> <code class="fe kv kw kx ky b"><em class="mp">song</em></code> <em class="mp">对象上访问</em> <code class="fe kv kw kx ky b"><em class="mp">hasOwnProperty</em></code> <em class="mp">，即使它没有在上面定义？</em></p><h1 id="1b72" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">原型链</h1><p id="c221" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">如前所述，默认情况下，JavaScript中的所有对象都有来自全局对象的原型。我们说它们是对象的实例。</p><p id="df63" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">JavaScript提供了不同的方法来让我们自己设置对象的原型。不建议将新对象直接分配给<code class="fe kv kw kx ky b">__proto__</code>属性。并不是所有的浏览器都支持它。</p><h1 id="a707" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Object.create()</h1><p id="f93c" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">考虑下面的代码片段:</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="c3e2" class="mk la ja ky b gy ml mm l mn mo">var song = {<br/>  title: "Bed of Stones",<br/>  artiste: "Asa"<br/>}</span><span id="6c6a" class="mk la ja ky b gy nf mm l mn mo">// creates a new object which prototype is 'song'<br/>var media = Object.create(song)<br/>console.log(Object.getPrototypeOf(media)) // [object Object] { //artiste: "Asa", title: "Bed of Stones" }</span></pre><p id="d502" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><code class="fe kv kw kx ky b">Object.create(song)</code>将创建一个新对象，并将其原型设置为<code class="fe kv kw kx ky b">song</code>对象。除了通过<code class="fe kv kw kx ky b">__proto__</code>属性读取一个对象的原型，我们还可以使用<code class="fe kv kw kx ky b">Object.getPrototypeOf</code>，如示例所示。</p><p id="4daa" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">您可以将另一个对象传递给<code class="fe kv kw kx ky b">Object.create</code>来将特定的实例属性添加到正在创建的对象中。例如:</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="53b3" class="mk la ja ky b gy ml mm l mn mo">// creates a new object that has this structure { type: "Mp3"} and // whose prototype is the song object<br/>var media = Object.create(song, { type: {value: "Mp3" } })</span><span id="a69c" class="mk la ja ky b gy nf mm l mn mo">console.log(media.type) // prints "Mp3"<br/>console.log(media.title) // prints "Bed of Stones"</span></pre><figure class="mc md me mf gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/840db23a5a0dc722382ab91f734965b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*07Kyn3Zq7gkHEOQD"/></div></div></figure><h1 id="999d" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">构造函数</h1><p id="236e" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">使用自定义原型创建对象的另一种方法是使用构造函数。严格地说，任何函数都可以用作构造函数，但是按照惯例，构造函数的名字以大写字母开头。</p><p id="a796" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">要创建构造函数的实例，可以在函数调用中使用<code class="fe kv kw kx ky b">new</code>关键字，例如:</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="9469" class="mk la ja ky b gy ml mm l mn mo">function Bar() {}</span><span id="1d7b" class="mk la ja ky b gy nf mm l mn mo">var bar = new Bar() // creates a new object</span></pre><p id="afa6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">当使用关键字<code class="fe kv kw kx ky b">new</code>时，JavaScript将关键字<code class="fe kv kw kx ky b">this</code>隐式分配给正在创建的新对象。所以我们可以使用<code class="fe kv kw kx ky b">this</code>来引用正在创建的对象:</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="8adb" class="mk la ja ky b gy ml mm l mn mo">function Bar() {<br/>  this.name = "bar"<br/>}</span><span id="9566" class="mk la ja ky b gy nf mm l mn mo">var bar = new Bar()<br/>console.log(bar.name) // "bar"</span></pre><h1 id="925e" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">构造函数<code class="fe kv kw kx ky b">prototype</code>属性</h1><p id="8ed6" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">JavaScript中的每个函数都有特殊属性<code class="fe kv kw kx ky b">prototype</code>。你可能会问，既然函数也是对象，<code class="fe kv kw kx ky b">prototype</code>属性和<code class="fe kv kw kx ky b">__proto__</code>属性是一样的吗？</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d2c1485f147d1f28fd08cb64292add53.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/0*gMIY3J9HfbzsB0Oe"/></div></figure><p id="a250" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">是啊。构造函数的<code class="fe kv kw kx ky b">prototype</code>属性指向的对象不是该函数的原型。那是什么呢？</p><p id="590b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">还记得我提到过构造函数可以用来创建一个新对象…并设置新对象的原型吗？新对象的原型是构造函数<code class="fe kv kw kx ky b">prototype</code>属性指向的对象。</p><p id="4e87" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">让我用另一种方式重新表述。</p><ul class=""><li id="ecbf" class="mr ms ja jz b ka kb ke kf ki mt km mu kq mv ku nm mx my mz bi translated">每个函数都有一个<code class="fe kv kw kx ky b">prototype</code>属性</li><li id="abc6" class="mr ms ja jz b ka na ke nb ki nc km nd kq ne ku nm mx my mz bi translated">您可以使用<code class="fe kv kw kx ky b">new</code>关键字来创建该函数的一个对象(也称为实例)</li><li id="fa19" class="mr ms ja jz b ka na ke nb ki nc km nd kq ne ku nm mx my mz bi translated">对象的原型被设置为构造函数的<code class="fe kv kw kx ky b">prototype</code>属性</li></ul><figure class="mc md me mf gt ip gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/444f6d03411032a42f6896693a8e1e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/0*OIjKjRf1LaZf2wRl"/></div></figure><p id="7378" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">让我用下面的代码片段来总结一下:</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="c22e" class="mk la ja ky b gy ml mm l mn mo">function Song(title, artiste) {<br/>  this.title = title<br/>  this.artiste = artiste<br/>}</span><span id="3a23" class="mk la ja ky b gy nf mm l mn mo">Song.prototype.getDescription = function() {<br/>  return this.title + " by " + this.artiste<br/>}</span><span id="a5af" class="mk la ja ky b gy nf mm l mn mo">var song1 = new Song("Bed of Stones", "Asa")<br/>var song2 = new Song("We all Lose Sometimes", "Brymo")</span><span id="3d5c" class="mk la ja ky b gy nf mm l mn mo">console.log(song1.title) // "Bed of Stones"<br/>console.log(song2.artiste) // "Brymo"<br/>console.log(song2.getDescription()) // "We all Lose Sometimes by Brymo"</span></pre><figure class="mc md me mf gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi no"><img src="../Images/c01a194f67ccf7d2d889ebda4a48d674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A0M73N6bIRgibr0T"/></div></div></figure><p id="472d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><code class="fe kv kw kx ky b">song1</code>和<code class="fe kv kw kx ky b">song2</code>共享同一个原型链。注意<code class="fe kv kw kx ky b">Song.prototype</code>有一个属性<code class="fe kv kw kx ky b">constructor</code>，它是由JavaScript创建的，指向构造函数，在本例中是<code class="fe kv kw kx ky b">Song</code>。</p><p id="b43f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">上图已经简化，<code class="fe kv kw kx ky b">Song</code>本身有一个<code class="fe kv kw kx ky b">__proto__</code>属性，下图显示了它:</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/c76051e25328639d744fe5a950d9247a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_yrb2FUwMNmz4k7n"/></div></div></figure><h1 id="d19c" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="44b6" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">哇哦。你已经走了这么远。尼斯尼斯:)我们已经讨论了所有我认为是必要的，为了理解和更好地调试JavaScript程序的原型。</p><p id="5c8a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">如果你发现任何错误，请指出来。</p><p id="e6f4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">快乐编码</p><h1 id="f641" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">奖励:实例of vs类型of</h1><p id="df45" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">假设我们有</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="5e84" class="mk la ja ky b gy ml mm l mn mo">function Bar() {<br/>  this.name = "bar"<br/>}</span><span id="1f89" class="mk la ja ky b gy nf mm l mn mo">var bar = new Bar()</span></pre><p id="12ae" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">当我们写作时</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="7d80" class="mk la ja ky b gy ml mm l mn mo">console.log(bar instanceof Bar) // prints true</span></pre><p id="e5c8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><code class="fe kv kw kx ky b">bar instanceof Bar</code>意味着我们在向JavaScript引擎提问，</p><blockquote class="nq nr ns"><p id="fb10" class="jx jy mp jz b ka kb kc kd ke kf kg kh nt kj kk kl nu kn ko kp nv kr ks kt ku ig bi translated"><em class="ja"/><code class="fe kv kw kx ky b"><em class="ja">Bar.prototype</em></code><em class="ja">是否存在于</em> <code class="fe kv kw kx ky b"><em class="ja">bar</em></code> <em class="ja">原型链的任何地方？</em></p></blockquote><p id="a084" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">在这种情况下，答案是肯定的。</p><p id="2b46" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><code class="fe kv kw kx ky b">instanceof</code> operator测试构造函数的prototype属性是否出现在对象的原型链中。</p><p id="1045" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">你能猜到这会打印出什么吗？</p><p id="7562" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">答案还是<code class="fe kv kw kx ky b">true</code>，因为<code class="fe kv kw kx ky b">Object.prototype</code>存在于<code class="fe kv kw kx ky b">bar</code>的原型链中</p><h1 id="b3bd" class="kz la ja bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">运算符的类型</h1><p id="e3f6" class="pw-post-body-paragraph jx jy ja jz b ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku ig bi translated">typeof运算符返回指示操作数类型的字符串。返回的字符串可以是<code class="fe kv kw kx ky b">"symbol"</code>、<code class="fe kv kw kx ky b">"bigint"</code>、<code class="fe kv kw kx ky b">"number"</code>、<code class="fe kv kw kx ky b">"string"</code>、<code class="fe kv kw kx ky b">"boolean"</code>、<code class="fe kv kw kx ky b">"object"</code>、<code class="fe kv kw kx ky b">"function"</code>或“未定义”中的任意一个</p><p id="3f81" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">示例:</p><pre class="mc md me mf gt mg ky mh mi aw mj bi"><span id="5ea4" class="mk la ja ky b gy ml mm l mn mo">typeof 12 === 'number'; // returns true</span></pre></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="927e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><em class="mp">最初发布于</em><a class="ae ix" href="https://solathecoder.hashnode.dev/javascript-prototypes-in-plain-english-ckv2oc9300shhsss13muzachv" rel="noopener ugc nofollow" target="_blank"><em class="mp">https://sola the code . hash node . dev</em></a><em class="mp">。</em></p><p id="ee0c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><em class="mp">更多内容请看</em><a class="ae ix" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jz jb"><em class="mp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>