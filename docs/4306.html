<html>
<head>
<title>Epic React — React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Epic React — React挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/epic-react-react-hooks-ceb04b8ec513?source=collection_archive---------3-----------------------#2021-08-27">https://javascript.plainenglish.io/epic-react-react-hooks-ceb04b8ec513?source=collection_archive---------3-----------------------#2021-08-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="69c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发现自己深入探究肯特·c·多兹的React Hooks的来龙去脉。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/127b4e3d948a2334441a37db67e602be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lmWVKjCKw6yqxKkAIKUMng.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Hooks</figcaption></figure><p id="7636" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开发人员必须根据状态来决定他们希望在应用程序中使用的组件类型的日子已经一去不复返了。如果状态-类组件，否则-功能。这是React v16.8.0发布之前的传统商标。当前情景—钩子像风暴一样席卷市场。那为什么不是我们？</p><p id="1655" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ky">热烈欢迎。</em>欢迎来到<em class="ky">史诗反应</em>系列的第二篇文章，在这里，我将写&amp;开篇，讲述我在课程中学到的东西——<em class="ky">史诗反应</em>——作者不是别人，正是大师本身——<strong class="jm io">肯特·c·多兹</strong>。如果你碰巧错过了这个系列的第一次阅读，那么一定要读一读</p><div class="kz la gp gr lb lc"><a rel="noopener  ugc nofollow" target="_blank" href="/epic-react-react-fundamentals-cf76b6cedaf1"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">Epic React — React基础知识</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">这是你的老朋友肯特·c·多兹的课程——史诗般的反应。在…的第一部分呈现一段阅读</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><p id="b95e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">介绍性的闲聊到此为止，让我们写点真正的生意吧。</p><h1 id="fb0b" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">钩住</h1><p id="fc8a" class="pw-post-body-paragraph jk jl in jm b jn mp jp jq jr mq jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh ig bi translated">如果你以反应著称，那么你知道——陈述。数据存储。都是关于它的。Hooks是由脸书React团队开发的API，使用状态(数据存储)和其他生命周期方法(执行动作)的功能，可用于类组件到功能组件。<em class="ky">让生活代码更简单。</em></p><p id="e028" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">那是什么意思</strong>是——现在你不局限于使用类组件了。你可以从中选择，因为它们几乎有相同的特点。</p><p id="3955" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这并不意味着</strong>你应该避免使用类组件，或者在已经开发的应用程序中用functional替换它们。React两者都支持。没有人处于被否决的边缘。</p><blockquote class="mu"><p id="6db2" class="mv mw in bd mx my mz na nb nc nd kh dk translated">没有从React中移除类的计划——我们都需要继续发布产品，并且负担不起重写。我们建议在新代码中尝试钩子。~脸书开发团队</p></blockquote><p id="4198" class="pw-post-body-paragraph jk jl in jm b jn nf jp jq jr ng jt ju jv nh jx jy jz ni kb kc kd nj kf kg kh ig bi translated">这不是一个隐藏的事实/关于热门话题的争论— <em class="ky">功能性Vs类</em>组件。你可以走进这个热狗，了解更多信息——</p><div class="kz la gp gr lb lc"><a href="https://betterprogramming.pub/react-class-vs-functional-components-2327c7324bdd" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">反应类别与功能组件</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">类和功能组件的定义、道具、纯组件、内部状态、生命周期和性能</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">better编程. pub</p></div></div><div class="ll l"><div class="nk l ln lo lp ll lq ks lc"/></div></div></a></div><p id="becf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们决定使用钩子，那么让我们看看主人(肯特)在他的部分有什么—</p><p id="cc42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一节详细解释了钩子的类型以及如何使用它们。在本节结束时，您将看到自己正在构建高级<em class="ky">井字游戏</em>。请注意，这并不像你想象的那么简单。完全头脑风暴。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/4123fe8de34779b3a64c72ae3c3696cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JL4c885HzoqtLCbXqMDs7w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Dark theme hits another level, isn’t it?</figcaption></figure><p id="42cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们走吧？</p><ol class=""><li id="556c" class="nm nn in jm b jn jo jr js jv no jz np kd nq kh nr ns nt nu bi translated"><strong class="jm io">使用状态</strong></li></ol><p id="ccd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先也是最重要的钩子。一个特殊的钩子——用来存储任何数据。类似于您在类组件中所做的事情— <em class="ky"> this.state </em></p><p id="1686" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关键点-</p><ul class=""><li id="0344" class="nm nn in jm b jn jo jr js jv no jz np kd nq kh nv ns nt nu bi translated"><strong class="jm io">参数</strong> —接受单个参数</li><li id="232c" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">返回</strong> —一个数组，包含传递的初始值(单个参数)和一个更新函数来改变该值。<em class="ky">控制台日志&amp;想知道数组如何包含不同的数据类型——却发现数组是JavaScript中类似列表的对象</em>。</li><li id="2b63" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">约定</strong> —给更新器函数加上前缀<code class="fe ob oc od oe b">set</code>，例如，setName，setData。</li><li id="a32e" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io"> Render </strong> —针对值的任何变化重新渲染组件，除非它没有被卸载</li></ul><p id="827a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<strong class="jm io">使用效果</strong></p><p id="6807" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React将组件呈现给DOM后运行自定义代码的函数。就当是对<code class="fe ob oc od oe b">componentDidMount</code>、<code class="fe ob oc od oe b">componentDidUpdate</code>和<code class="fe ob oc od oe b">componentWillUnmount</code>的替代吧。但它们并不等同于彼此。</p><p id="7c63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关键点-</p><ul class=""><li id="7ba2" class="nm nn in jm b jn jo jr js jv no jz np kd nq kh nv ns nt nu bi translated"><strong class="jm io">参数</strong> —接受2个参数，回调&amp;依赖项(数组)。</li><li id="0596" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">回调</strong> —包含副作用逻辑。在React完成更改后正确执行</li><li id="7cbc" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">依赖关系</strong> —决定何时运行副作用逻辑的可选数组。每次渲染都不传递数组来运行逻辑。</li><li id="5aea" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">返回</strong> —除了清除功能，什么都不做。</li><li id="48df" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io"> HTTP requests </strong> —不要在useEffect回调函数前面放置<code class="fe ob oc od oe b">async</code>关键字来运行任何异步任务(这是一个常见的副作用)。这个不行，w <em class="ky"> hy？</em>因为async/await返回一个承诺&amp; useEffect不排除清理。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="37f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<strong class="jm io"> useRef </strong></p><p id="12ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建引用的钩子。访问特定值或DOM元素的引用。</p><p id="e3f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关键点-</p><ul class=""><li id="6d1e" class="nm nn in jm b jn jo jr js jv no jz np kd nq kh nv ns nt nu bi translated"><strong class="jm io">参数</strong> —接受初始值作为单个参数。</li><li id="36c2" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">返回</strong> —具有特殊属性<code class="fe ob oc od oe b">current</code>的对象(或ref)。您可以通过<code class="fe ob oc od oe b">ref.current</code>访问或更新该值。</li><li id="cea8" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io"> DOM </strong> —直接引用DOM交互的节点元素。&amp;然后你可以在节点元素上做所有你以前用<code class="fe ob oc od oe b">ref.current</code>做的事情。例如，<code class="fe ob oc od oe b">ref.current.click()</code>为按钮，<code class="fe ob oc od oe b">ref.current.value</code>为输入值，等等。</li><li id="a78a" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">必看的</strong> —坚持下来了。<em class="ky">含义？</em>组件重新渲染之间保持不变。&amp;与更新<code class="fe ob oc od oe b">state</code>不同，更新<code class="fe ob oc od oe b">ref</code>不会触发组件重新渲染。</li></ul><p id="b90f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">参考与状态差异</strong>:</p><ul class=""><li id="63db" class="nm nn in jm b jn jo jr js jv no jz np kd nq kh nv ns nt nu bi translated">更新一个<code class="fe ob oc od oe b">state</code>会触发组件重新渲染，而<code class="fe ob oc od oe b">ref</code>不会。</li><li id="509f" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><code class="fe ob oc od oe b">ref</code>为同步，<code class="fe ob oc od oe b">state</code>为异步。</li></ul><p id="34c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些主要包括在课程的第二部分练习&amp;额外的学分练习中。显然，你只能通过在代码库中实际弹奏来掌握它们。但是还有一些东西，作者在这两者之间提到了—</p><p id="0fee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般要点-</p><ul class=""><li id="427f" class="nm nn in jm b jn jo jr js jv no jz np kd nq kh nv ns nt nu bi translated"><strong class="jm io">惰性状态初始化</strong> —一般来说，这是一种延迟创建某些东西(对象、值或任何进程)直到第一次需要它的策略。用于改善某些情况下的性能问题。你可以在这里读到更详细的<a class="ae ne" href="https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="2015" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">提升状态</strong> —决定状态在应用程序中的理想位置，以便所需的组件可以访问它。在这种情况下，当两个相近的兄弟想要访问数据时，可以方便地将状态提升到它们相近的父节点。</li><li id="5c3d" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">共同定位状态</strong> —将状态放在需要的地方&amp;避免全局状态，除非必要。简单地说——如果只有一个子组件(甚至不是初始化状态的父组件)需要状态中的特定数据，那么父组件中绝对没有必要有状态。在特定子组件中移动数据状态块是明智的。明智的你自己关于州共管<a class="ae ne" href="https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster" rel="noopener ugc nofollow" target="_blank">这里</a>。</li><li id="81fd" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">错误边界</strong>——这不是什么新鲜事。错误是我们的亲戚&amp;无论我们如何努力，我们都应该错过。Kent讲述了如何通过创建自定义类组件来处理这些错误。<em class="ky">阶级？</em> React 16后来为类组件引入了“错误边界”的概念。现在，你知道为什么了吧？对于泛函来说，它不起作用，而且对于这种情况没有任何挂钩。<em class="ky">我是不是忘了告诉你，在泛函的类组件中使用的一些方法是没有等价的？</em>e . x .<code class="fe ob oc od oe b">getSnapshotBeforeUpdate</code><code class="fe ob oc od oe b">componentDidCatch</code><code class="fe ob oc od oe b">getDerivedStateFromError</code>还有我们说的<code class="fe ob oc od oe b">error boundary</code>。这些看起来像外星人，不是吗？但它们确实存在。返回到错误边界，该边界用于捕捉子组件中任何位置的错误，记录这些错误，并显示一个回退UI。用户体验不佳。</li><li id="8cc6" class="nm nn in jm b jn nw jr nx jv ny jz nz kd oa kh nv ns nt nu bi translated"><strong class="jm io">反应错误边界</strong> —如果你不愿意用类组件构建错误边界，那么，这里有一个npm <a class="ae ne" href="https://github.com/bvaughn/react-error-boundary" rel="noopener ugc nofollow" target="_blank">包</a>。这提供了一个简单且可重用的包装器，您可以用它来包装您的组件。组件层次结构中的任何呈现错误都可以得到很好的处理(从react-error-boundary文档的直接来源)。</li></ul><p id="bb15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧好吧。感觉真好。确实如此。但这只是预告片。<em class="ky">图片abhi baki hai dost </em>(朋友，电影还没结束呢！).其余的挂钩(非常重要&amp;危险)将在课程的下一部分讲述。名为——高级挂钩。是的，你们都被<strong class="jm io">史诗般的反应给迷倒了。</strong></p><p id="31b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是React钩子的车间仓库—</p><div class="kz la gp gr lb lc"><a href="https://github.com/kentcdodds/react-hooks" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">GitHub - kentcdodds/react-hooks:学习React Hooks！🎣 ⚛</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">学习React钩子的来龙去脉。我将带你深入了解React挂钩，并向你展示你需要什么…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="oh l ln lo lp ll lq ks lc"/></div></div></a></div><p id="ff72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是什么？</p><p id="ba18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">拿起一杯咖啡，进入反应状态。</p><p id="f684" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同时，你可以在这里找到我的承诺—</p><div class="kz la gp gr lb lc"><a href="https://github.com/TidbitsJS" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">TidbitsJS -概述</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">很高兴见到你，我是Sujata Gunale又名TidbitsJS🤓自学开发者👩‍💻从事Web开发📝正在写作…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="oi l ln lo lp ll lq ks lc"/></div></div></a></div><p id="5fa1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ky">哈夫塔亚👋</em></strong></p><p id="8c1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ky">更多内容请看</em><a class="ae ne" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>