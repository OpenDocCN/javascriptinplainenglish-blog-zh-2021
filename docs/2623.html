<html>
<head>
<title>Using a Pure JavaScript Library in React: Utilizing Information from the Library to Re-Render a Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中使用纯JavaScript库:利用库中的信息重新呈现组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-a-pure-javascript-library-in-react-utilizing-information-from-the-library-to-re-render-a-8e6fab5a9449?source=collection_archive---------3-----------------------#2021-05-30">https://javascript.plainenglish.io/using-a-pure-javascript-library-in-react-utilizing-information-from-the-library-to-re-render-a-8e6fab5a9449?source=collection_archive---------3-----------------------#2021-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7f5c6a5f6dac4024b3001b27eb61a05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yfYJZYAB57bVK0vuuTXE3g.png"/></div></div></figure><p id="af18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的文章中一个非常常见的主题是使用状态和/或状态钩子的正确方法。直接改变状态是一个大禁忌。如果我们在没有创建新对象的情况下改变状态，我们可能会失去功能并导致一些奇怪的行为。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/63db1d23347eef6a3fbf1e0ec0e19a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*3eZ-44jWjUnUlA9dJhze0g.gif"/></div></figure><p id="6ef4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，如果我们想在React应用中使用纯JavaScript库呢？纯JavaScript不使用状态。那么，在库不能利用状态或道具的情况下，我们如何使用这个库，获取更新的信息，并呈现我们的React组件呢？在本文中，我们将查看一个纯JavaScript日期/时间选择器，找到一种从库中获取所需信息的方法，并更新我们的React组件。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/714f0a9ec025607daf90fcd9159e5371.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*kkl3zgQYC8zzQ5bpOt5YDw.png"/></div></figure><p id="365e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用<a class="ae kz" href="https://github.com/mtrdesign/mtr-datepicker" rel="noopener ugc nofollow" target="_blank"> MTR Datepicker </a>，一个纯JavaScript编写的库来选择日期和时间。我不会去如何安装地铁日期选择器，只会简单地谈及它的使用。更详细的安装和使用说明，你可以点击查看<a class="ae kz" href="https://github.com/mtrdesign/mtr-datepicker" rel="noopener ugc nofollow" target="_blank"> GitHub。</a></p><p id="cd7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的目标是从MTR Datepicker中获取选定的时间和日期，并使用该信息定制确认按钮。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi la"><img src="../Images/198308f2a234faa24e435305b04969a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRv3LghZiBAfj5hLdfrjpw.png"/></div></div></figure><p id="d762" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在安装和设置了MTR Datepicker之后，我们应该会看到类似这样的东西。⬇️</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/165c901494d443195adbababfc36281f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*y2seL-rLwBNTGWDN3adKeA.png"/></div></figure><p id="7dfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们想要的只是日期选择器，而不需要确认按钮来显示日期和时间，我们可以就此打住。这将返回工作日期选择器。因为我们希望我们的应用程序感觉更加定制化，所以我们需要做更多的工作。</p><p id="56d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们首先从日期选择器中获取时间和日期，并将它们存储在状态变量中。这样，每当变量改变时，都会触发重新渲染。由于DatePicker是一个功能组件，我们将使用<code class="fe lc ld le lf b">useState </code>钩子来完成这个任务。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/de2125d7b300e963f22ae9d00d5f7b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*gddxMqoBgy3XzbGOixL8MA.png"/></div></figure><p id="eda9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，由于MTR Datepicker是一个纯JavaScript库，不能利用state或props，并且如果我们决定将MTR DatePicker转换为React组件，它会中断(如果我们将库中的日期和时间变量转换为状态变量，它会无休止地循环)，我们需要一种方法在日期和/或时间改变时更新我们的状态变量(日期和时间)。在这种情况下，我们将进行脏检查。它被称为脏检查，因为它运行定期检查，而不是直接监听属性更改。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/c9ca790948f3a70b8bb6f2e3fbb41593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*FLOCUVU-RHOBk3eosN-ATw.png"/></div></figure><p id="b67c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们只是检查日期或时间是否每秒改变一次。如果有任何变化，我们更新相应的状态变量，这将触发组件的重新呈现。应该可以了，对吧？不完全是，原因如下。每次组件重新呈现时，我们的<code class="fe lc ld le lf b">datePicker </code>变量都会创建一个新的MtrDatepicker对象。这导致了一个死循环，破坏了我们的组件。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/785f42f236958d167acc0f5927a0f25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8OBeSlCiWI7X67yNYP71EA.gif"/></div></div></figure><p id="68b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决这个问题，我们可以使用<code class="fe lc ld le lf b">useMemo</code>钩子。<code class="fe lc ld le lf b">useMemo</code>钩子简单地返回它所传递的“创建”函数的存储值。它还需要一组依赖项。<code class="fe lc ld le lf b">useMemo</code>只有当其中一个依赖关系改变时，才会重新计算记忆的值。这里我们将把依赖数组留空，因为我们出于任何原因都不想创建新的MtrDatepicker对象。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/7cdc72bca963af89c2a1083427b16e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*1IxCqit8xrgM_pcGtdkH1w.png"/></div></figure><p id="175b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们只需添加带有日期和时间变量的确认按钮。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/320c166db521c741d010fc3fee55bd19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMKI-J6zyDcSn6zyzvUQyw.png"/></div></div></figure><p id="fc98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！遵循最佳实践总是最好的，但我认为知道何时遵循规则以及何时可以变通规则也同样重要。这只是一个例子，在这种情况下，让一些东西工作可能需要一些创造力…我们可以不按按钮，或者我们可以放弃MTR日期选择器，使用一个更加反应友好的库，但这将使它失去所有的乐趣！编码快乐！</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ll"><img src="../Images/0e7ef3c684e5d00d40b71378dad89322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dmefX6M9U0S7TmIY3mOOww.gif"/></div></div></figure><p id="982c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lm">更多内容尽在</em><a class="ae kz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lm">plain English . io</em></a></p></div></div>    
</body>
</html>