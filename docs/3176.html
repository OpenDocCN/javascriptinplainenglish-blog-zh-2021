<html>
<head>
<title>Build An API With Node.js, Express, And TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js、Express和TypeScript构建一个API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-typescript-express-server-in-minutes-7d34c306f60?source=collection_archive---------4-----------------------#2021-06-28">https://javascript.plainenglish.io/create-a-typescript-express-server-in-minutes-7d34c306f60?source=collection_archive---------4-----------------------#2021-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f0fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用Express和TypeScript构建下一个Node.js API</p><p id="4d64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经开发了一个网站数周或数年，你可能已经构建了一些应用程序，为你的网站后端提供标准的CRUD(创建、读取、更新、删除)功能。这些后端服务的核心往往非常相似，所以为什么不创建一个可重用的样板/模板来帮助您立即启动并运行呢？</p><p id="7a4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">剧透提示:</strong>这篇文章会给你样板，或者给你一些如何写快递申请的想法，让他们做得更好！如果您是Express或TypeScript新手，这将是一个用大量代码示例深入框架和语言的好机会。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02bf6e9309c7b458737d54bb75e43224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BRIFRWQQQ3a2kN_D"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Source: <a class="ae ky" href="https://www.pexels.com/photo/person-using-macbook-pro-574077/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="83f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">按照本文的思路，<a class="ae ky" href="https://github.com/MR-DS-20/express-template" rel="noopener ugc nofollow" target="_blank">从GitHub </a>克隆代码。如果您有任何更改或建议，请随时参与项目合作。</p><p id="1cab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里将解释样板文件:</p><ul class=""><li id="ac20" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">环境</li><li id="cfbb" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">应用和服务器</li><li id="d9dd" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">路由器和控制器</li><li id="0d55" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">模型</li></ul><p id="3f25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">样板文件的文件结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h1 id="4e47" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建环境文件</h1><p id="c308" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">有几种方法可以引入应用程序的变量和设置。项目中的<code class="fe ms mt mu mv b">dotenv</code> npm包和<code class="fe ms mt mu mv b">.env</code>文件是一个很好的方法。不过，这可能不是最干净的打字稿方式。您可以创建一个环境函数，这将允许您根据部署阶段或其他变量进行文件替换。</p><p id="b31e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="f290" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数查看从执行节点的shell传递来的<code class="fe ms mt mu mv b">ENVIRONMENT</code>变量，并加载适当的文件。在函数的声明中，可以看到<code class="fe ms mt mu mv b">env: () =&gt; IEnv</code>。这是在声明该函数将返回一个类型为<code class="fe ms mt mu mv b">IEnv</code>的对象，该对象是一个如下所示的接口:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="266a" class="na lq in mv b gy nb nc l nd ne">export interface IEnv {<br/>    port: number;<br/>    db:{<br/>        name: string;<br/>        user: string;<br/>        pw: string;<br/>        account: string;<br/>    };<br/>    apiPath: string;<br/>    staticPath: string;<br/>}</span></pre><p id="6d08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用env函数时，使用接口将为您提供Typescript的类型检查功能。本质上，当你使用这个对象的值时，你会得到自动完成的建议，如果你犯了一个错误，你的IDE会为你突出显示它。</p><p id="376d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您的<code class="fe ms mt mu mv b">dev.ts</code>文件可能看起来像这样，以保存您在开发时使用的变量:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="72bc" class="na lq in mv b gy nb nc l nd ne">export const ENV:IEnv = {<br/>    port:8082,<br/>    apiPath: '/api/v1',<br/>    staticPath: 'public',<br/>    db:{<br/>        name: 'COLLECTION_NAME',<br/>        user:'UNAME',<br/>        pw: 'P@%%W()RD',<br/>        account: '@mongo-account',<br/>    },<br/>}</span></pre><p id="1a96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住将它添加到您的<code class="fe ms mt mu mv b">.gitignore</code>文件中，这样它就不会被提交到存储库中，您的凭证也会保持安全。</p><h1 id="7772" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建应用程序实例</h1><p id="f768" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">拥有一个处理express应用程序的所有配置的类有助于保持服务器文件的整洁和易读，还可以确保应用程序类可重用，因为它没有任何与特定项目相关的内容。</p><p id="1602" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通读一下这个文件，<a class="ae ky" href="https://github.com/MR-DS-20/express-template/blob/master/src/application.ts" rel="noopener ugc nofollow" target="_blank"> application.ts </a>。构造函数部分如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="78fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该类处理所有express应用程序的构造配置，并将应用程序呈现为公共的，随时可供使用。</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="35c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Express服务器(索引)文件可能会很快失控，需要重构才能保持可维护性。这种方法从一开始就确保了可维护性。下面是<code class="fe ms mt mu mv b">server.ts</code>文件的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="8920" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很干净，对吧？使用简单的import语句添加新路由器，并将它们放入阵列中。在单独的文件中处理中间件。由app类处理的MongoDB连接逻辑。</p><p id="7e3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您正在查看那一行<code class="fe ms mt mu mv b">dbConString ? app...: console...;</code>并且不确定发生了什么，它是一个三元运算符，其功能本质上类似于if-else语句。它的语法是<code class="fe ms mt mu mv b">(ifTrue) ? (doThis) : (elseThis);</code>。</p><h1 id="1e4f" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建模型</h1><p id="ee77" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">通常，路由器、控制器和型号之间可能存在一对一的关系。然而，根据您的使用情况，您可以在一个路由器中使用多个控制器，或者在一个控制器中使用多个型号。</p><p id="3505" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种意义上的模型表示MongoDB中的一个集合。如果你正在寻找一个免费的托管数据库解决方案，请前往<a class="ae ky" href="http://cloud.mongodb.com" rel="noopener ugc nofollow" target="_blank">cloud.mongodb.com</a>。</p><p id="3c4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请参见下文，了解如何定义模式(声明字段及其类型)和模型(提供与数据库交互的方法)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="17b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ms mt mu mv b">BaseModel</code>是一个助手类，它接受模型并提供通用函数，如<code class="fe ms mt mu mv b">create()</code>或<code class="fe ms mt mu mv b">delete()</code>，一旦您的应用程序中有几个模型，这些函数将大大减少重复代码的数量。</p><p id="c9d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，您必须为每个模型编写<code class="fe ms mt mu mv b">model.findById(id).exec()</code>,并且您将为所有不同的读/写操作这样做。相反，扩展<code class="fe ms mt mu mv b">BaseModel</code>，你就不必为你的任何模型编写它们。继续学习控制器，看看如何实现这一点。<a class="ae ky" href="https://github.com/MR-DS-20/express-template/blob/master/src/models/base.model.ts" rel="noopener ugc nofollow" target="_blank">点击此处查看基础模型文件</a></p><h1 id="0a8f" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建控制器</h1><p id="a0b7" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">控制器可以在来自路由器的请求和与模型交互的逻辑之间创建一个分离，帮助您遵守单一责任原则。</p><p id="804f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了帮助减少重复，这里的建议是采用与模型相似的方法，创建一个<code class="fe ms mt mu mv b">BaseController</code>类，处理所有需要的通用CRUD函数。</p><p id="9ccd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的摘录是<a class="ae ky" href="https://github.com/MR-DS-20/express-template/blob/master/src/controllers/base.controller.ts" rel="noopener ugc nofollow" target="_blank"> base.controller.ts </a>文件的开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="622e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ms mt mu mv b">jsonRes()</code>和<code class="fe ms mt mu mv b">errRes()</code>函数提供了一个简单的可重用方法来适当地完成HTTP响应。现在，这个类可以为每个控制器扩展，其中可以实现独特的逻辑。下面的例子是一种使用<code class="fe ms mt mu mv b">BaseController</code>类和适当的模型类创建控制器的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="d62a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在你看到尖括号(&lt;，&gt;)的<code class="fe ms mt mu mv b">putFunction()</code>中，一个类型被传入。这种类型启用了Typescript的强大功能，有助于加快开发速度。</p><p id="80a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您调用<code class="fe ms mt mu mv b">findById()</code>或任何返回文档的方法时，您会得到一个承诺，它包含文档，但也为您提供了许多对给定文档执行的数据库功能。</p><p id="f6e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">传入该类型会告诉编译器和IDE正在发生什么，因此当您处理该对象时，您会看到可用的方法。<a class="ae ky" href="https://github.com/MR-DS-20/express-template/blob/master/src/interfaces/example.interface.ts" rel="noopener ugc nofollow" target="_blank">点击此处查看接口是如何构建的</a>。请继续阅读，更好地了解这是如何在路由器中实现的。</p><p id="6534" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您不确定<code class="fe ms mt mu mv b">this.model</code>或<code class="fe ms mt mu mv b">this.create</code>是如何工作的，因为您看不到它们的声明，请记住它们是在BaseController类中声明的。</p><p id="2300" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">控制器的功能接受快速请求和响应对象，因为它们是路由调用时从快速路由器传递的对象。</p><h1 id="e530" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">路由器</h1><p id="1b3f" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">这是发送到应用程序HTTP请求与路由器匹配的地方。基于类的方法创建express应用程序的能力在这里大放异彩，因为您可以用最少的努力为所有模型编写路线。请参见下面的example.router.ts文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="df01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前两个路由是在控制器中声明的，因为需要一些定制逻辑，然而，删除和获取路由使用由<code class="fe ms mt mu mv b">BaseController</code>类声明的函数，所以不需要额外的编码。</p><p id="6d4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将这些路由器导入您的服务器，您就可以开始了！</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="f9eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这已经给了你一些关于如何改进Node.js Express服务器的想法，我欢迎任何关于如何改进它的建议。编码快乐！</p><p id="c3b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nm">更多内容看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="nm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>