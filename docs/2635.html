<html>
<head>
<title>Build a CRUD application using Express and MongoDB Atlas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express和MongoDB Atlas构建CRUD应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-crud-application-using-express-and-mongodb-atlas-444f2a7f122b?source=collection_archive---------4-----------------------#2021-05-31">https://javascript.plainenglish.io/build-a-crud-application-using-express-and-mongodb-atlas-444f2a7f122b?source=collection_archive---------4-----------------------#2021-05-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cb1c0d0080e4d95ffaace2669c798038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7G8o-xU8gshk0B3HTmE5kg.jpeg"/></div></div></figure><p id="ea84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，您将学习如何使用Express和MongoDB构建CRUD应用程序。</p><p id="3315" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我会尽可能的简单。为了帮助你节省时间，我决定写这篇文章。让我们看看它是如何工作的！</p><h2 id="7796" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">创建一个MongoDB Atlas帐户</h2><p id="29df" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">过程很简单。前往<a class="ae lr" href="https://www.mongodb.com/cloud/atlas/lp/try2?utm_source=google&amp;utm_campaign=gs_footprint_row_search_core_brand_atlas_desktop&amp;utm_term=mongdb%20atlas&amp;utm_medium=cpc_paid_search&amp;utm_ad=e&amp;utm_ad_campaign_id=12212624584&amp;gclid=CjwKCAjw-e2EBhAhEiwAJI5jg-59YS1MbxYolznxDSKFG-YL8jrSaFPBw5TpFt3s2uu2Axz5FMyULBoCNVoQAvD_BwE" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>并创建一个新账户。如果已经完成，您可以登录现有帐户。</p><p id="4e58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建您的帐户或登录后，在您的控制面板上单击“创建新集群”按钮。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/efcc4925f00d2f733d02bc3fcfdb03bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VOseIDHl00-tyt9a2pIhiA.jpeg"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">MongoDB dashboard</figcaption></figure><p id="f339" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应该会出现一个新页面，询问您创建新集群的详细信息。请注意，如果您已经创建了一个集群，那么第二个集群将会花费您很多钱。如果那是你的第一次，那么它是免费的。继续并点击“创建集群”按钮。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/0aa5ad09b743545af86fb302244e6907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSaiZwzJo-E46Hcb_U4WTg.jpeg"/></div></div></figure><h1 id="259b" class="mc ku in bd kv md me mf ky mg mh mi lb mj mk ml le mm mn mo lh mp mq mr lk ms bi translated">创建您的数据库</h1><p id="4b2b" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">下一步是创建数据库。为此，您需要创建一个数据库用户。在您的仪表板上，单击“数据库访问”按钮。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/3f57bf1f686b92993b27c5a27ac1dda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hL_vom8i8yOohAd587mZyA.jpeg"/></div></div></figure><p id="e2b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">定义一个用户名和密码，然后点击“添加用户”按钮。确保用户对您的数据库有读写权限。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/32a91804e36e361315179d7216bed6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GiS3vhuR4JeU7u6GqHpVwg.jpeg"/></div></div></figure><h1 id="386b" class="mc ku in bd kv md me mf ky mg mh mi lb mj mk ml le mm mn mo lh mp mq mr lk ms bi translated">将您的IP地址列入白名单</h1><p id="58da" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">为了连接到您的本地项目，将您的IP地址列入白名单是一个必要的步骤。为此，请单击“网络访问”选项卡。</p><p id="25af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以将您当前的IP地址列入白名单，或者允许来自任何地方的访问。在这种情况下，只需选择将您当前的IP地址列入白名单。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/35fc96b2ad59bfe403ace4d062f8f983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvECygDor1puEU78oXIAJg.jpeg"/></div></div></figure><h1 id="3e18" class="mc ku in bd kv md me mf ky mg mh mi lb mj mk ml le mm mn mo lh mp mq mr lk ms bi translated">与本地设置的连接</h1><p id="2903" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">是时候设置与本地项目的连接了。</p><p id="346b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用<a class="ae lr" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>创建一个服务器。服务器将帮助我们创建、读取、更新或删除项目。基本上，CRUD操作。</p><p id="570b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，我创建了一个新的空文件夹，我称之为blog，因为我们将创建博客文章。打开我的新文件夹，从我的终端使用命令<em class="mw"> npm init -y </em>创建一个名为<em class="mw"> server.js </em>的文件和一个<em class="mw"> package.json </em>文件:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="f7d5" class="kt ku in my b gy nc nd l ne nf">npm init -y // to create a package.json file</span></pre><p id="dbe6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我可以安装需要的软件包了</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="ef02" class="kt ku in my b gy nc nd l ne nf">npm i express mongoose nodemon dotenv</span></pre><p id="3025" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些软件包如下:</p><ul class=""><li id="bb37" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated">设置服务器的步骤</li><li id="1be2" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">m<a class="ae lr" href="https://www.npmjs.com/package/mongoose" rel="noopener ugc nofollow" target="_blank">on选择</a>与我的MongoDB Atlas数据库以及任何本地数据库进行交互</li><li id="99f6" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><a class="ae lr" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank"> Nodemon </a>在我的应用程序中检测到更改时重启服务器。</li><li id="9681" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><a class="ae lr" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>创造。我们的MongoDB凭证的env文件</li></ul><p id="996a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的文件夹结构现在是:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="12f0" class="kt ku in my b gy nc nd l ne nf">blog<br/>--node_modules<br/>--app.js <br/>--package.json<br/>--package-lock.json </span></pre><p id="0b6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在您的<em class="mw"> app.js </em>文件中，让我们设置express服务器:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="6511" class="kt ku in my b gy nc nd l ne nf">//app.js </span><span id="80ab" class="kt ku in my b gy nu nd l ne nf">const express = require("express");</span><span id="8406" class="kt ku in my b gy nu nd l ne nf">const app = express();</span><span id="04f7" class="kt ku in my b gy nu nd l ne nf">app.listen(3000, () =&gt; {<br/>  console.log("Listening at port 3000");<br/>});</span></pre><h2 id="96bb" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">与MongoDB Atlas的联系</h2><p id="9b7c" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">现在我们将应用程序与MongoDB Atlas连接起来。为此，我们创建一个名为<em class="mw"> connection.js </em>的文件来建立连接。在这个文件中，我们会有这样的代码:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a81a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来分解一下:</p><ul class=""><li id="ffda" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated">我们需要dotenv模块来避免暴露我们的凭证</li><li id="b8af" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">用连接参数定义一个对象。这对于连接到我们的MongoDB Atlas服务器非常有用。</li><li id="1533" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">现在我们有了一个URI变量。这保存了您的MongoDB Atlas连接URL。我马上告诉你去哪里拿你的。</li><li id="f6ae" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">接下来，我们建立服务器和MongoDB Atlas之间的连接。这是通过命令<em class="mw">mongose . connect()</em>完成的。连接是异步操作。所以我们用一个<em class="mw">来处理。然后()</em>如果连接建立或<em class="mw">。catch() </em>如果他们在我们的连接中有问题。</li><li id="f26c" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">最后，我们使用<em class="mw">模块导出我们的连接对象。</em></li></ul><h2 id="8e87" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">如何获得您的MongoDB URI:</h2><p id="372e" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">要得到你的URI，很简单。在您的仪表板(MongoDB Atlas)中，单击“连接”，然后“连接到应用程序”。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/24f748c84d097761ad02bc5e26da22ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jj3TBQhBYiPL2TVy-XVgWw.jpeg"/></div></div></figure><p id="171f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这应该会弹出来:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/6fa741358f63aa21d8f90efaa72c99cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_OOzfcYRzMfjbAVFA4Qig.jpeg"/></div></div></figure><p id="be8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在connection.js文件中使用URI，其中<password>是实际MongoDB数据库用户密码的占位符。然后，可以在nodeJS文件夹中创建一个. env文件，如下所示:</password></p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="86ae" class="kt ku in my b gy nc nd l ne nf">//.env </span><span id="9dcf" class="kt ku in my b gy nu nd l ne nf">MONGO_USERNAME=your_username<br/>MONGO_PASSWORD=your_password</span></pre><p id="8b59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意你的<em class="mw">。env </em>(注意点号)文件应该在你的根路径中。到目前为止，您的文件夹结构应该是这样的:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="ed38" class="kt ku in my b gy nc nd l ne nf">blog<br/>--node_modules<br/>--app.js<br/>-- .env<br/>--package.json<br/>--package-lock.json</span></pre><p id="0935" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们用<em class="mw">替换用户名和<password>值。env </password></em>值如下:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="1463" class="kt ku in my b gy nc nd l ne nf">`mongodb+srv://${process.env.MONGO_USERNAME}:${process.env.MONGO_PASSWORD}<a class="ae lr" href="http://twitter.com/cluster0" rel="noopener ugc nofollow" target="_blank">@cluster0</a>.s11qz.mongodb.net/blog?retryWrites=true&amp;w=majority`</span></pre><h2 id="3eca" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">将连接导出到app.js</h2><p id="033f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">设置连接后，可以将其导入app.js文件中:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="a2cf" class="kt ku in my b gy nc nd l ne nf">const express = require("express");<br/>const connection = require("./connection");<br/>const app = express();</span><span id="a493" class="kt ku in my b gy nu nd l ne nf">app.listen(3000, () =&gt; {<br/>  console.log("Listening at port 3000");<br/>});</span></pre><p id="e3bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们定义一个命令来启动应用程序。在您的<em class="mw"> package.json </em>文件中(“脚本”部分)，添加命令“start ”,如下所示:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="2b98" class="kt ku in my b gy nc nd l ne nf">"scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "start": "nodemon app.js"<br/>  },</span></pre><p id="cf9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mw"> package.json </em>文件应该是这样的:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8fba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，通过打开终端并键入命令来运行应用程序:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="7b61" class="kt ku in my b gy nc nd l ne nf">npm start</span></pre><p id="e35b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一切顺利，您的控制台中应该会出现一条消息，内容如下</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="6fab" class="kt ku in my b gy nc nd l ne nf">connected to database</span></pre><p id="e8c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个过程是异步的，所以在您看到它之前，预计需要几秒钟。如果没有建立连接，它将返回一个包含详细信息的错误。</p><p id="ac6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以重试该过程，并检查您的用户名和密码是否与您创建的用户的用户名和密码相匹配。如果您忘记了您的凭证，有一个简单的方法可以在“数据库访问”选项卡中更改它们(在MongoDB Atlas dashboard中)。</p><h1 id="908d" class="mc ku in bd kv md me mf ky mg mh mi lb mj mk ml le mm mn mo lh mp mq mr lk ms bi translated">CRUD操作</h1><p id="c1a3" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">现在我们已经建立了数据库，是时候创建我们的博客文章了。为此，我们创建了一个Post模型。这个帖子模型是帮助我们从数据库中创建或阅读博客帖子的蓝图。</p><p id="67d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在您的根文件夹中，创建一个<em class="mw"> postModel.js </em>文件。您的文件夹结构应该如下所示:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="ed13" class="kt ku in my b gy nc nd l ne nf">blog<br/>--node_modules<br/>--.env<br/>--app.js <br/>--connection.js<br/>--package.json<br/>--package-lock.json<br/>--postModel.js</span></pre><p id="6ddc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在您的<em class="mw"> postModel.js </em>中，有您为Mongodb数据库创建新帖子的模型。它应该是这样的:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d95f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们做了以下事情:</p><ul class=""><li id="90de" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated">创建一个带有标题和内容的模式</li><li id="04db" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">设置使用此模式的发布模型</li><li id="64de" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">导出文章，在你的<em class="mw"> app.js </em>文件中使用</li></ul><p id="10cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当您准备创建或更新您的博客帖子时，您可以使用这个帖子模型。</p><h1 id="de67" class="mc ku in bd kv md me mf ky mg mh mi lb mj mk ml le mm mn mo lh mp mq mr lk ms bi translated">创建您的路线</h1><p id="6a88" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">在<em class="mw"> app.js </em>文件中，服务器现在正在运行，但是没有路由。为此，我们可以创建路由来创建、读取、更新或删除项目。以下是不同的操作:</p><h2 id="36c3" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">创建帖子</h2><p id="826c" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">在进行任何操作之前，我们需要将模型导入到app.js文件中。我们还需要设置我们的express服务器，以便它可以接收参数并解析它们。下面是app.js导入语句的更新版本:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="a32b" class="kt ku in my b gy nc nd l ne nf">//app.js </span><span id="1dbf" class="kt ku in my b gy nu nd l ne nf">const express = require("express");<br/>const connection = require("./connection");<br/>const postModel = require("./postModel.js");<br/>const app = express();<br/>app.use(express.urlencoded({ extended: true }));<br/>app.use(express.json());</span><span id="4dac" class="kt ku in my b gy nu nd l ne nf">..<br/>//rest of the code</span></pre><p id="fa4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CRUD操作的第一部分是创建一个新的职位。为此，我们添加了一条新路线:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="a764" class="kt ku in my b gy nc nd l ne nf">app.post("/", async (req, res) =&gt; {<br/>  const { title, content } = req.body;<br/>  try {<br/>    const newPost = await postModel.create({<br/>      title,<br/>      content,<br/>    });<br/>    res.json(newPost);<br/>  } catch (e) {<br/>    res.status(500).send(e);<br/>  }<br/>});</span></pre><p id="c178" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来分解一下:</p><ul class=""><li id="f56a" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated">当向我们的服务器发出post请求时，它会被解析以检索内容和标题。</li><li id="451a" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">然后，我们将后期制作包装成一个try…catch。这允许我们处理异步操作以及任何可能发生的错误。</li><li id="104d" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">一旦使用postModel创建了新的post，它应该将它作为JSON数据返回给客户机。</li></ul><h2 id="266c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">阅读或获取帖子</h2><p id="022d" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">为了从数据库中获取所有帖子，我们定义了这条路径:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="9a6d" class="kt ku in my b gy nc nd l ne nf">app.get("/", async (req, res) =&gt; {<br/>  try {<br/>    const posts = await postModel.find();<br/>    res.json(posts);<br/>  } catch (e) {<br/>    console.log(e);<br/>  }<br/>});</span></pre><p id="aca1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个异步请求，所以我们使用try…catch并将<em class="mw"> async </em>关键字添加到回调函数中。这给了你一个数组，其中包含了所有JSON格式的博客文章。</p><p id="0e66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还定义了从服务器读取或获取一个帖子的路径:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="92bb" class="kt ku in my b gy nc nd l ne nf">app.get("/:id", async (req, res) =&gt; {<br/>  const { id } = req.params;<br/>  try {<br/>    const post = await postModel.findById(id);<br/>    res.json(post);<br/>  } catch (e) {<br/>    res.status(500).send(e);<br/>  }<br/>});</span></pre><p id="2985" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将从params中获取id，并根据id找到帖子。</p><h2 id="8985" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">更新帖子</h2><p id="ee48" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">要更新帖子，您可以在上传和修补请求之间进行选择。在这种情况下，我们使用PUT请求:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="571b" class="kt ku in my b gy nc nd l ne nf">app.put("/:id", async (req, res) =&gt; {<br/>  const { id } = req.params;<br/>  const { title, content } = req.body;<br/>  try {<br/>    const post = await postModel.findByIdAndUpdate(id, { title, content });<br/>    res.json(post);<br/>  } catch (e) {<br/>    res.status(500).send(e);<br/>  }<br/>});</span></pre><p id="225b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码从params中提取<em class="mw"> id </em>，并使用<a class="ae lr" href="https://mongoosejs.com/docs/api.html" rel="noopener ugc nofollow" target="_blank"> <em class="mw">。findByIdandUpdate() </em> </a>方法，在用新标题和内容更新项目之前，通过id查找项目。然后，它将数据作为JSON发回。</p><h2 id="a070" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">删除帖子</h2><p id="6f93" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">最后，删除一篇文章遵循相同的过程，但是我们使用<em class="mw">。删除()</em>:</p><pre class="lt lu lv lw gt mx my mz na aw nb bi"><span id="fd69" class="kt ku in my b gy nc nd l ne nf">app.delete("/:id", async (req, res) =&gt; {<br/>  const { id } = req.params;<br/>  try {<br/>    const post = await postModel.findById(id);<br/>    await post.remove();<br/>    res.json("deleted");<br/>  } catch (e) {<br/>    res.status(500).send(e);<br/>  }<br/>});</span></pre><p id="7fae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">整个app.js文件现在变成了:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e89b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mw">更多内容请看</em><a class="ae lr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mw">plain English . io</em></a></p></div></div>    
</body>
</html>