<html>
<head>
<title>The Ultimate Guide to Using Controlled vs Uncontrolled Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中使用受控和非受控组件的终极指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-ultimate-guide-to-using-controlled-vs-uncontrolled-components-in-react-a3d1f5058503?source=collection_archive---------7-----------------------#2021-03-08">https://javascript.plainenglish.io/the-ultimate-guide-to-using-controlled-vs-uncontrolled-components-in-react-a3d1f5058503?source=collection_archive---------7-----------------------#2021-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ee47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将从理论和实践两个方面来看看在React中使用受控或不受控组件的区别。我们将尝试看看使用其中一种来对抗另一种的好处，以及一些初学者可能陷入的陷阱。如果你不熟悉React组件，我建议你看一下React官方文档和教程。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/b4b79289d7df237ce948d04daaea3560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*Ni67bJzr-zF6IIDanD3J7w.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Not all uncontrolled things are cute</figcaption></figure><p id="4b2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于React中受控和不受控输入的争论可以在新web开发人员的旅程中很早就开始。您可能会遇到很多文章说一种方法比另一种方法更好，这可能是真的，取决于用例。看起来受控组件在React社区得到了广泛的推荐，而且理由很充分。甚至在<a class="ae ky" href="https://reactjs.org/docs/uncontrolled-components.html#:~:text=In%20a%20controlled%20component%2C%20form,form%20values%20from%20the%20DOM." rel="noopener ugc nofollow" target="_blank">非受控部件的官方文件</a>中，第一句话就是:</p><blockquote class="kz la lb"><p id="31a7" class="jn jo kl jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">在大多数情况下，我们建议使用<a class="ae ky" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">控制组件</a>来实现表单。</p></blockquote><p id="3ca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们深入这个主题，了解这两种方法之间的区别。为了能够做到这一点，我们需要回忆一下DOM是什么。</p><h2 id="4748" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated"><strong class="ak">好的DOM，坏的DOM和丑陋的DOM </strong></h2><p id="5a3b" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">DOM是处理HTML和XML文档的接口。它表示一个树状结构的文档。它是浏览器用来组织如何在网页上向用户显示元素的主要工具。您可以通过检查页面来访问任何网页的DOM。你会看到HTML元素，如div、文本字段、按钮和图像，它们以树形结构组织:它们有父元素、子元素和兄弟元素。实际上，DOM中的这些家族关系转化为网页上的位置关系。</p><p id="1eed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DOM与HTML非常相似，但与网页的HTML源文档并不完全相同。您可以自己检查一下:检查页面DOM和查看页面源代码可能会有很大的不同。您可能会在DOM中找到在源代码中找不到的元素，反之亦然。这是因为HTML元素可以由Javascript创建、删除和修改。例如，单击页面中的按钮可以使HTML源文件中不存在的图像出现。但是，您会在DOM中找到这个图像。</p><p id="68a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，你在网页上找到的所有元素都存在于DOM中。网页上的Javascript动态修改DOM，修改会立即反映在屏幕上。</p><p id="54f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Javascript控制DOM的能力给了我们在受控组件和非受控组件之间进行选择的机会。</p><p id="0ab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">受控组件或输入是其值依赖于组件的反应状态的组件，而非受控组件是其值被直接控制或存储在DOM中并且只能从DOM访问的组件。</p><p id="2ba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更好地理解这种差异，让我们来看看以受控和非受控方式实现的同一个表单。</p><h2 id="139e" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated"><strong class="ak">非受控输入示例</strong></h2><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e928" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个不受控制的文本输入的例子。它是不受控制的，因为第10行输入包含的值不受Javascript控制。这意味着没有代码告诉DOM给这个input元素一个特定的值。</p><p id="9634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当用户在这个输入中书写时，文本被存储在DOM中。为了能够在React应用程序中使用它，开发人员需要从DOM中提取它。这可以使用<code class="fe mf mg mh mi b">ref</code>属性来完成。</p><h2 id="a1cf" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated"><strong class="ak">受控输入示例</strong></h2><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个受控实现的例子中，您可以看到我们的输入元素的<code class="fe mf mg mh mi b">value</code>被React设置为总是等于状态变量<code class="fe mf mg mh mi b">name</code>。实际上，当用户在文本输入中输入时，处理程序<code class="fe mf mg mh mi b">onChange</code>被触发，并将调用函数<code class="fe mf mg mh mi b">handleNameChange</code>，变量<code class="fe mf mg mh mi b">event</code>包含输入的文本。该函数将文本存储在状态变量<code class="fe mf mg mh mi b">name</code>中。由于<code class="fe mf mg mh mi b">name</code>与输入的<code class="fe mf mg mh mi b">value</code>属性相关联，因此这些更改将反映在页面的输入框中。</p><h2 id="c7b2" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated"><strong class="ak">只需选择一个并在您的应用中采用它</strong></h2><p id="ff59" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">那么应该用哪一个呢？嗯，如果你真的明白你在做什么，这两者都很好。只要有可能，你可以尝试使用受控组件，因为它给你的表单提供了更多的灵活性。这两种方法都允许您至少检索一次输入，并在提交时验证它。除此之外，受控组件还能够:</p><ul class=""><li id="6758" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">即时现场验证</li><li id="db77" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">有条件地禁用提交按钮</li><li id="53d3" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">强制输入格式</li><li id="5dc5" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">一条数据的多个输入</li></ul><h2 id="280b" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated"><strong class="ak">运行时在受控和非受控之间切换</strong></h2><p id="6af1" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">即使您以受控的方式编写输入表单，React实际上也可以自动切换到不受控的行为，将输入值存储在DOM中。您将在web控制台中看到以下错误:</p><pre class="kn ko kp kq gt mx mi my mz aw na bi"><span id="85cf" class="lf lg iq mi b gy nb nc l nd ne"><strong class="mi ir">Warning</strong>: A component is changing a controlled input of type text to be uncontrolled. Input elements should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component.</span></pre><p id="a6f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，当控制输入属性的状态变量变为<code class="fe mf mg mh mi b">undefined</code>时，就会发生这种情况。这通常是由于开发错误。原则上，绑定到输入值的变量永远不应该是未定义的。如果状态变量在逻辑上不包含任何内容，用空字符串<code class="fe mf mg mh mi b">''</code>替换<code class="fe mf mg mh mi b">undefined</code>。</p><p id="99ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">受控组件和非受控组件之间没有优先选择。初学者可能会发现不受控制的组件更容易处理，因为它们的实现类似于HTML。但是一旦你对React有了更多的经验，我建议你转向受控组件。</p><p id="8f70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有兴趣将React应用程序迁移到生产环境中，请查看以下指南:</p><div class="nf ng gp gr nh ni"><a href="https://medium.com/swlh/react-and-node-js-build-a-full-stack-app-from-development-to-production-in-5-minutes-a03bc019df6b" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">React和Node.js:在5分钟内构建从开发到生产的全栈应用</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">在本文中，我将向您展示如何创建一个从开发到生产的全栈Web应用程序。我将展示…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ks ni"/></div></div></a></div><p id="6566" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要了解关于Webpack的更多信息，web pack是现代Javascript技术的支柱，请看下面的教程:</p><div class="nf ng gp gr nh ni"><a href="https://levelup.gitconnected.com/the-ultimate-webpack-tutorial-understanding-the-wizard-behind-the-magic-of-modern-javascript-a0efd12a2cdc" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">终极Webpack教程:理解现代Javascript魔力背后的向导</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">在本文中，我们将了解什么是webpack，以及它的魔力如何革新了Javascript库和框架，如…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw ks ni"/></div></div></a></div><p id="ba87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关Refs和DOM的更多信息，您可以查看React官方文档中的<a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p></div></div>    
</body>
</html>