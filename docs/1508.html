<html>
<head>
<title>Functional Programming: Closures and Memoization in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:JavaScript中的闭包和记忆化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-programming-closures-and-memoization-in-javascript-f7fd45424316?source=collection_archive---------2-----------------------#2021-03-31">https://javascript.plainenglish.io/functional-programming-closures-and-memoization-in-javascript-f7fd45424316?source=collection_archive---------2-----------------------#2021-03-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9b59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章的目的是解释如何在JavaScript中实现闭包和记忆化。当我编码时，我学得更好，如果你像我一样，那么你一定会喜欢这篇文章。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a905ef15124e34f9dff4c6b8c9a4852f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u4Qbid377VrP7ko6"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@mr_vero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Irvan Smith</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="048e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在我们进入主题之前，让我们总结一下我们所知道的函数式编程——什么是闭包，当我们使用术语记忆化时，我们实际上指的是什么？</p><blockquote class="lg lh li"><p id="0407" class="jk jl lj jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated"><strong class="jm io">功能编程</strong></p></blockquote><p id="e7b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数式编程是一种<strong class="jm io"> <em class="lj">声明式</em> </strong>类型的编程风格。这是一种编程范式，在这种范式中，我们试图以纯数学函数的方式绑定一切。它的主要焦点是“解决什么”,而命令式风格的主要焦点是“如何解决”。</p><p id="3815" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数式编程基于Lambda演算。它的基本工作原理是，函数在JavaScript中被视为一等公民。函数也可以是高阶函数。高阶函数是将其他函数作为参数并返回另一个函数的函数。</p><blockquote class="lg lh li"><p id="7fde" class="jk jl lj jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated"><strong class="jm io">关闭</strong></p></blockquote><p id="fbff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使在父函数已经执行之后，当子函数保持父作用域的环境时，就会创建闭包。这是MDN网站上的更多内容。</p><div class="ln lo gp gr lp lq"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd io gy z fp lv fr fs lw fu fw im bi translated">关闭</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">闭包是捆绑在一起(封闭的)的函数与对其周围状态的引用的组合</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">developer.mozilla.org</p></div></div><div class="lz l"><div class="ma l mb mc md lz me ks lq"/></div></div></a></div><blockquote class="lg lh li"><p id="8b62" class="jk jl lj jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated"><strong class="jm io">记忆化</strong></p></blockquote><p id="39de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记忆化是缓存的一种特殊形式。缓存是一种通过在内存中保存非常具体的信息来加速程序的方法。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="d88b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们用一个例子来证明它:</p><p id="1a4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个简单的函数，将80加到一个数上并返回它。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="7a08" class="mk ml in mg b gy mm mn l mo mp">function addTo80(num) {<br/>   return num + 80;<br/>}</span><span id="a36c" class="mk ml in mg b gy mq mn l mo mp">console.log(addTo80(5));            // Computes and returns 85<br/>console.log(addTo80(5));            // Computes and returns 85<br/>console.log(addTo80(5));            // Computes and returns 85</span><span id="bbdb" class="mk ml in mg b gy mq mn l mo mp">Output:<br/>85<br/>85<br/>85</span></pre><p id="5527" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述程序将计算相同的函数3次，并返回结果。现在，这是一个非常简单的函数，执行起来可能不会占用太多内存和时间。但是请考虑一个更复杂的函数，它一次又一次地执行相同的任务。例如，使用递归找到斐波纳契数列<a class="ae ky" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">的第100个元素。这就是记忆化真正有效的地方，它可以节省大量的计算时间。</a></p><p id="ec21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对上面的例子进行改进，让我们创建另一个函数memoizedAddto80()并获取一个缓存对象，该对象在计算出特定参数的值后保存数据(在内存中)。让我们看看实际情况:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="0afc" class="mk ml in mg b gy mm mn l mo mp">function addTo80(num) {<br/>   return num + 80;<br/>}</span><span id="69ca" class="mk ml in mg b gy mq mn l mo mp">let cache = {};<br/>function memoizedAddTo80(num) {<br/>  if (num in cache) {<br/>    return cache[num]; <br/>  } else {<br/>    console.log('Calculating...');<br/>    cache[num] = num + 80;<br/>    return cache[num];<br/>  }<br/>}</span><span id="8dd9" class="mk ml in mg b gy mq mn l mo mp">// Computes and stores 85 in cache<br/>console.log(memoizedAddTo80(5));</span><span id="8dba" class="mk ml in mg b gy mq mn l mo mp">// Returns memoized data from memory<br/>console.log(memoizedAddTo80(5));</span><span id="7b4a" class="mk ml in mg b gy mq mn l mo mp">// Returns memoized data from memory<br/>console.log(memoizedAddTo80(5));</span><span id="ac46" class="mk ml in mg b gy mq mn l mo mp">// Output:<br/>Calculating...<br/>85<br/>85<br/>85</span></pre><p id="59fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码片段会将结果计算一次为85，然后将其存储在缓存对象中，如下所示:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="af71" class="mk ml in mg b gy mm mn l mo mp">cache: {<br/>   5: 85<br/>}</span></pre><p id="a3a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，下一次调用memoizedAddTo80(5)时，它将在内存中查找并直接返回它，因为它之前已经被计算过了。与再次执行相同的操作相比，这个操作真的很快。</p><p id="054c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">等等，这里有几个你可能会想到的问题:</p><ol class=""><li id="68f9" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated">创建一个可以在应用程序中的任何地方更改的全局对象缓存，我们没有污染全局名称空间吗？</li><li id="f17e" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated"><em class="lj">哪里在使用封闭？</em></li></ol><p id="2ef9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，你猜对了！我们确实污染了全局名称空间，而且闭包仍然没有运行。</p><p id="449d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们重构代码来实现和解决上面列出的两个问题:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="4eca" class="mk ml in mg b gy mm mn l mo mp">function addTo80(num) {<br/>   return num + 80;<br/>}</span><span id="32f4" class="mk ml in mg b gy mq mn l mo mp">function memoizedAddTo80() {<br/> let cache = {};<br/> return function(num) {<br/>    if (num in cache) {<br/>      return cache[num]; <br/>    } else {<br/>      console.log('Calculating...');<br/>      cache[num] = num + 80;<br/>      return cache[num];<br/>    } <br/>  }<br/>}</span><span id="2398" class="mk ml in mg b gy mq mn l mo mp">const memoized = memoizedAddTo80();</span><span id="d384" class="mk ml in mg b gy mq mn l mo mp">// Computes and stores 85 in cache<br/>console.log(memoized(5));</span><span id="fd62" class="mk ml in mg b gy mq mn l mo mp">// Returns memoized data from memory<br/>console.log(memoized(5));</span><span id="a266" class="mk ml in mg b gy mq mn l mo mp">// Returns memoized data from memory<br/>console.log(memoized(5));</span><span id="f8b9" class="mk ml in mg b gy mq mn l mo mp">// Output:<br/>Calculating...<br/>85<br/>85<br/>85</span></pre><p id="4b6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，这一次我们将全局对象缓存移到memoizedAddTo80()函数中，以防止全局名称空间污染。问题1解决。现在谈谈问题2。</p><p id="12d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还记得闭包吗？</p><blockquote class="lg lh li"><p id="4419" class="jk jl lj jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated">即使在父函数已经执行之后，当子函数保持父作用域的环境时，就会创建闭包。</p></blockquote><p id="a931" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从memoizedAddTo80()函数内部，我们返回另一个函数，它跟踪父函数中使用的缓存对象。这是行动中的终结。内部函数可以访问外部函数的属性(缓存对象)的状态。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="5ee2" class="mk ml in mg b gy mm mn l mo mp">return function(num) {<br/>    if (num in cache) {<br/>      return cache[num]; <br/>    } else {<br/>      console.log('Calculating...');<br/>      cache[num] = num + 80;<br/>      return cache[num];<br/>    } <br/>  }</span></pre><p id="c6e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，这个内部函数可以被调用任意多次，它将只执行一次，并且在调用多次时返回内存化的数据。</p><p id="dcb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是所有内容的演示:</p><div class="ln lo gp gr lp lq"><a href="https://replit.com/@akashkriplani/Closures-and-Memoization#index.js" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd io gy z fp lv fr fs lw fu fw im bi translated">闭包和记忆</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">akashkriplani的Node.js repl</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">replit.com</p></div></div><div class="lz l"><div class="nf l mb mc md lz me ks lq"/></div></div></a></div><p id="83b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lj">又有了。我希望这篇文章对你有用。感谢您的阅读。请随时提供您的意见、建议和任何其他可能有帮助的反馈。</em> </strong></p><p id="0032" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://javascript.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lj">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>