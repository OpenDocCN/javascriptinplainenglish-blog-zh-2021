<html>
<head>
<title>How to Set Up an API with JWT, req.User and Route Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何设置一个与JWT的API，请求。用户和路由安全性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-set-up-an-api-with-jwt-req-user-and-route-security-52f8da08cda6?source=collection_archive---------3-----------------------#2021-09-27">https://javascript.plainenglish.io/how-to-set-up-an-api-with-jwt-req-user-and-route-security-52f8da08cda6?source=collection_archive---------3-----------------------#2021-09-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/49899f86931266ca9305310abe7903c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DB8xdKp5VWAG-6dC"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@frenchriera?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anthony Riera</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5d33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">阅读完本文后，您将理解如何在Node.js/TypeScript中创建一个API，其函数如下:</p><ul class=""><li id="f4cd" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">在调用<code class="fe lh li lj lk b">/login</code>时，生成并返回一个承载/JWT给用户</li><li id="9666" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">使用中间件解码认证报头(承载/JWT)</li><li id="41a9" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">修改Express名称空间以添加对<code class="fe lh li lj lk b">req.User</code>的支持</li><li id="ed16" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">增加路线的安全性(例如，“只有<code class="fe lh li lj lk b">Admin</code>可以访问这条路线”)</li></ul><p id="26be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="lq"> PS:最后有一个工作git的链接。</em>T12】</strong></p><h1 id="864c" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">基本快速设置</h1><p id="e316" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">对于已经被记录了一千次的东西，很少有令人兴奋的事情，但我们需要度过这一部分:</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="7c0b" class="nc ls in lk b gy nd ne l nf ng">import Express from 'express';<br/>import http from 'http';<br/>import cors from 'cors';</span><span id="288c" class="nc ls in lk b gy nh ne l nf ng">const PORT = process.env.PORT !== undefined ? parseInt(process.env.PORT) : 3001;</span><span id="b063" class="nc ls in lk b gy nh ne l nf ng">let app: Express.Application | undefined = undefined;</span><span id="c9db" class="nc ls in lk b gy nh ne l nf ng">app = Express();</span><span id="bb28" class="nc ls in lk b gy nh ne l nf ng">app.use(cors({ exposedHeaders: 'Authorization' }));<br/>app.use(Express.urlencoded({ extended: true }));<br/>app.use(Express.json());</span><span id="aeec" class="nc ls in lk b gy nh ne l nf ng"><strong class="lk io">// -----&gt; MORE CODE WILL BE ADDED HERE! &lt;--------</strong></span><span id="8fa1" class="nc ls in lk b gy nh ne l nf ng">http.createServer(app).listen(PORT, () =&gt; console.log(`Webserver running at <a class="ae jz" href="http://localhost:${PORT}/`" rel="noopener ugc nofollow" target="_blank">http://localhost:${PORT}/`</a>));</span></pre><p id="857c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按照显示的顺序在上面显示的行中添加所有路线。将剩余的代码添加到其他地方。一些项目应该在它们自己的文件中。</p><h1 id="69e6" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">解码JWT</h1><p id="abf1" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">在路由的早期，应该找到解码报头的功能。如果存在真正的匿名路由(比如<code class="fe lh li lj lk b">/robots.txt</code>，那么这个函数应该在那之后出现)。</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="e06e" class="nc ls in lk b gy nd ne l nf ng">app.use(function JWTDecoderMiddleware(req: Express.Request, res: Express.Response, next: Express.NextFunction) {</span><span id="c07d" class="nc ls in lk b gy nh ne l nf ng">  const authorization = req.headers.authorization;<br/>  if (authorization &amp;&amp; authorization.startsWith("Bearer ")) {<br/>     const u = DecodeJWT(authorization.substring(7));<br/>     if (u)<br/>        req.User = u;<br/>     else<br/>        console.log("jwt found, but it was not valid.");<br/>  }</span><span id="2616" class="nc ls in lk b gy nh ne l nf ng">next();<br/>    });</span></pre><p id="75eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数依赖于两个因素:正在修改的全局名称空间使<code class="fe lh li lj lk b">req.User</code>可用，以及<code class="fe lh li lj lk b">DecodeJWT</code>-函数(见下文)</p><h2 id="dae5" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">“用户”、“承载者”和“访问级别”类型</h2><p id="507a" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">在继续之前，需要几个类型。在API端，我们将有某种类型的用户登录，并且需要处理其类型/接口。</p><p id="ae45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一个，来人。它将被发送到<em class="lq">客户端</em>并由客户端存储(以加密的JWT格式)。基本上，任何不敏感的东西都可以存储在JWT中，只要注意用户可以<em class="lq">轻松</em>解密JWT(但是<strong class="kc io">他们不能修改它</strong>)。在https://jwt.io/<a class="ae jz" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">检查JWT</a>。</p><p id="f4d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">types ts</strong></p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="0a74" class="nc ls in lk b gy nd ne l nf ng">export type User = {<br/>    ID: string,<br/>    Name: string,<br/>    AccessLevel: AccessLevel,</span><span id="da84" class="nc ls in lk b gy nh ne l nf ng">    /** Never ever store an clear-text pw like this! */<br/>    Password: string<br/>}</span><span id="3c84" class="nc ls in lk b gy nh ne l nf ng"><br/>export type Bearer = {<br/>    Name: string,<br/>    ID: string,<br/>    AccessLevel: AccessLevel<br/>}</span><span id="d134" class="nc ls in lk b gy nh ne l nf ng">export type AccessLevel = "Admin" | "User" | "Anonymous";</span></pre><p id="55eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">❕ <strong class="kc io">以安全的方式存储用户凭证，不要像这个演示一样使用明文密码。</strong></p><p id="b6a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> global.d.ts </strong></p><p id="f775" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意<code class="fe lh li lj lk b">global.d.ts</code>的命名。在<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/typescript-and-global-variables-in-node-js-59c4bf40cb31">https://JavaScript . plain English . io/typescript-and-global-variables-in-node-js-59 C4 BF 40 CB 31</a>中阅读有关全局变量的更多信息</p><p id="7e62" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在添加<code class="fe lh li lj lk b">Express.User</code>的同时，我们添加了我们打算使用的环境变量的类型:</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="91f7" class="nc ls in lk b gy nd ne l nf ng">import { User } from './types';</span><span id="6d04" class="nc ls in lk b gy nh ne l nf ng">declare global {</span><span id="55e4" class="nc ls in lk b gy nh ne l nf ng"><strong class="lk io">    namespace Express {<br/>        interface Request {<br/>            User: User<br/>        }<br/>    }</strong></span><span id="9de5" class="nc ls in lk b gy nh ne l nf ng">    namespace NodeJS {<br/>        interface ProcessEnv {<br/>          JWTENCRYPTIONKEY: string;<br/>          NODE_ENV: 'development' | 'production';<br/>          PORT: string;  // All environment variables are strings<br/>       }<br/>    }<br/>}</span><span id="e260" class="nc ls in lk b gy nh ne l nf ng">export { };</span></pre><p id="d8b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">❕确保你要么使用<code class="fe lh li lj lk b">.env</code>要么设置环境变量。</p><h2 id="c8b0" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">DecodeJWT函数</h2><p id="48e6" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">为了验证JWT没有被篡改，API必须定义一个密钥。基本上解码为:</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="67c1" class="nc ls in lk b gy nd ne l nf ng">import * as jsonwebtoken from "jsonwebtoken";</span><span id="4df1" class="nc ls in lk b gy nh ne l nf ng">export function Decode&lt;T extends object&gt;(iJWT: string): T | undefined {<br/>    try {<br/>        return jsonwebtoken.verify(iJWT,<br/>                process.env.JWTENCRYPTIONKEY) as T;<br/>    } catch (e) {<br/>        return undefined;<br/>    }<br/>}</span><span id="e451" class="nc ls in lk b gy nh ne l nf ng">export function DecodeJWT(jwt: string): User | undefined {</span><span id="2f36" class="nc ls in lk b gy nh ne l nf ng">    const decoded = Decode&lt;<strong class="lk io">Bearer</strong>&gt;(jwt);<br/>    if (decoded)<br/>        return Users.find(u =&gt; u.ID === decoded.ID);<br/>}</span></pre><h2 id="3eb3" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">用户？</h2><p id="54c1" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">我们需要一些用户。</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="addb" class="nc ls in lk b gy nd ne l nf ng">const Users: User[] = [<br/>   { ID: "root", Name: "root", AccessLevel: "Admin", Password: "Banana1" },<br/>   { ID: "foo", Name: "Foo", AccessLevel: "User", Password: "Bar" }<br/>];</span></pre><p id="d5a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">❕ <strong class="kc io">以安全的方式存储用户的凭证，不要像在这个演示中那样使用明文密码。</strong></p><h1 id="dd50" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">路线/</h1><p id="4f89" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">让我们添加一些路线，从<code class="fe lh li lj lk b">/</code>开始。</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="0060" class="nc ls in lk b gy nd ne l nf ng">app.get('/', function (req: Express.Request, res: Express.Response){<br/>     res.status(200).json({<br/>         "Foo": "Bar",<br/>         "Time": new Date().toISOString()<br/>     });<br/> });</span></pre><h1 id="5c52" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">路由/登录</h1><p id="1812" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">这条路线将采用<code class="fe lh li lj lk b">{ "username": "Foo", "password" : "Bar" }</code>并试图找到一个匹配凭证的用户。如果找到，则生成一个JWT并发送给被调用方。</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="b587" class="nc ls in lk b gy nd ne l nf ng">app.post('/login', function (req: Express.Request, res: Express.Response) {</span><span id="89ff" class="nc ls in lk b gy nh ne l nf ng">    console.log(`U=${req.body.username}, Pwd=&lt;hidden&gt;`);</span><span id="58b6" class="nc ls in lk b gy nh ne l nf ng">    const jwt = Login(req.body);<br/>    if (jwt) {<br/>      res.append('Authorization', jwt);<br/>      res.status(200).json({ Success: true, JWT: jwt });<br/>    }<br/>    else<br/>       res.status(200).json({ Success: false });</span><span id="508a" class="nc ls in lk b gy nh ne l nf ng">});</span></pre><h2 id="e1ba" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">注册</h2><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="bce9" class="nc ls in lk b gy nd ne l nf ng">export function Login(arg: { username: string, password: string }): string | undefined {</span><span id="17ab" class="nc ls in lk b gy nh ne l nf ng">    const user = Users.find(u =&gt; u.Name === arg.username <br/>     &amp;&amp; u.Password === arg.password);<br/>    if (user) {</span><span id="6466" class="nc ls in lk b gy nh ne l nf ng">        const result: Bearer = {<br/>            ID: user.ID,<br/>            Name: user.Name,<br/>            AccessLevel: user.AccessLevel<br/>        };</span><span id="8b94" class="nc ls in lk b gy nh ne l nf ng">       return Encode(result);</span><span id="cfe8" class="nc ls in lk b gy nh ne l nf ng">    }<br/>}</span></pre><h2 id="0c49" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">编码功能</h2><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="4840" class="nc ls in lk b gy nd ne l nf ng">export function Encode&lt;T extends object&gt;(iPayLoad: T, iTimeoutSeconds = 3600 * 10): string {<br/>    return jsonwebtoken.sign(<br/>                     iPayLoad, <br/>                     process.env.JWTENCRYPTIONKEY, <br/>                     { expiresIn: iTimeoutSeconds }<br/>                   );<br/>}</span></pre><h1 id="3bd9" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">到目前为止，一切顺利。</h1><p id="f389" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">至此，我们已经实现了一个正在运行的web服务器，它公开了<code class="fe lh li lj lk b">/</code>、<code class="fe lh li lj lk b">/login</code>，可以解码任何有效的JWT，并通过它返回一个用户。</p><p id="207b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在事情变得有点复杂了。:)</p><h1 id="fc21" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">HasAccessLevel —作为函数实现</h1><p id="fb50" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">检查访问级别可以通过函数或中间件来完成。</p><h2 id="344a" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">/me —具有检查访问级别的功能</h2><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="03b7" class="nc ls in lk b gy nd ne l nf ng">app.get('/me', function (req: Express.Request, res: Express.Response) {</span><span id="434c" class="nc ls in lk b gy nh ne l nf ng">  <strong class="lk io"> if (!HasAccessLevel(req, res, ["User", "Admin"])) <br/>      return;  // Response has already been sent</strong></span><span id="cdf3" class="nc ls in lk b gy nh ne l nf ng">   res.status(200).json({ "UserName": req.User.Name });</span><span id="8563" class="nc ls in lk b gy nh ne l nf ng">});</span></pre><h2 id="68d8" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">HasAccessLevel函数</h2><p id="1c1c" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">AccessLevel是一个类型，定义为<code class="fe lh li lj lk b">type AccessLevel = "Admin" | "User" | "Anonymous</code>。</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="2cb4" class="nc ls in lk b gy nd ne l nf ng">function HasAccessLevel(req: Express.Request, res: Express.Response, iReqLevel: AccessLevel[] = []): boolean {</span><span id="c1c4" class="nc ls in lk b gy nh ne l nf ng">    let result = false;<br/>    if (req.User)  // Has the middleware decoded the jwt properly?<br/>        // Yes, does the user match?<br/>        result = iReqLevel.includes(req.User.AccessLevel);<br/>    else<br/>       // No, but maybe "Anonymous" can access this function?<br/>       result = iReqLevel.includes("Anonymous");</span><span id="ae92" class="nc ls in lk b gy nh ne l nf ng"><br/>     // Not allowed to access? Send 401!<br/>     if (!result) {<br/>        res.status(401).json(<br/>                { Success: false, Error: "Access denied" });<br/>        res.end();<br/>    }</span><span id="a243" class="nc ls in lk b gy nh ne l nf ng">    return result;<br/>}</span></pre><h1 id="ef09" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">HasAccessLevelMiddleware —作为中间件实现</h1><h2 id="6d7c" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">/我—使用中间件</h2><p id="f4a0" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">中间件必须有三个参数，但是使用下面的语法可以很容易地避免这一点:</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="78b9" class="nc ls in lk b gy nd ne l nf ng">app.get('/me2',<br/>       <strong class="lk io">(rq, rs, n) =&gt; HasAccessLevelMiddleware(rq, rs, n, ["User", "Admin"]),</strong> <br/>   (req: Express.Request, res: Express.Response) =&gt; {</span><span id="138b" class="nc ls in lk b gy nh ne l nf ng">    // Will only get here if HasAccessLevelMiddleware allows it<br/>    res.status(200).json({ "UserName": req.User.Name });</span><span id="3414" class="nc ls in lk b gy nh ne l nf ng">});</span></pre><h2 id="fa8a" class="nc ls in bd lt ni nj dn lx nk nl dp mb kl nm nn mf kp no np mj kt nq nr mn ns bi translated">HasAccessLevelMiddleware</h2><p id="60cb" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">中间件决定是否调用<code class="fe lh li lj lk b">next()</code>。</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="ab6a" class="nc ls in lk b gy nd ne l nf ng">export function HasAccessLevelMiddleware(req: Express.Request, res: Express.Response, next: Express.NextFunction, iReqLevel: AccessLevel[] = []): void {</span><span id="8dab" class="nc ls in lk b gy nh ne l nf ng">    let hasAccess = false;<br/>    if (req.User)  // Has the middleware decoded the jwt properly?<br/>       hasAccess = iReqLevel.includes(req.User.AccessLevel);<br/>    else<br/>       hasAccess = iReqLevel.includes("Anonymous");</span><span id="c8cc" class="nc ls in lk b gy nh ne l nf ng"><strong class="lk io">    if (hasAccess)<br/>       next();   // Continue executing</strong><br/>    else {<br/>       res.status(401).json({ Success: false, Error: "Denied" });<br/>       res.end();<br/>    }<br/>}</span></pre><h1 id="572a" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">错误处理程序</h1><p id="65be" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">最后，添加错误处理程序。错误处理程序有四个参数，其中第一个是<code class="fe lh li lj lk b">err</code>。要让TypeScript大放异彩，最好将err定义为<code class="fe lh li lj lk b">Error &amp; { status: number, message: string }</code>。<code class="fe lh li lj lk b">Error</code>是内置的错误对象，Express增加了<code class="fe lh li lj lk b">status</code>和<code class="fe lh li lj lk b">message</code>。</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="bd3b" class="nc ls in lk b gy nd ne l nf ng">app.use(function (<strong class="lk io">err: Error &amp; { status: number, message: string }</strong>, req: Express.Request, res: Express.Response, next: Express.NextFunction) {</span><span id="002e" class="nc ls in lk b gy nh ne l nf ng">console.error(err.status);<br/>  console.error(err.message);<br/>  console.error(err.stack);<br/>  res.status(500).json({ Error: "Internal error" });<br/>  res.end();</span><span id="ffa4" class="nc ls in lk b gy nh ne l nf ng">});</span></pre><h1 id="31ce" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">卷曲</h1><p id="dbe4" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">这些命令是在Windows上编写的，进行必要的调整以在其他平台上运行:</p><pre class="mu mv mw mx gt my lk mz na aw nb bi"><span id="0bfd" class="nc ls in lk b gy nd ne l nf ng"># Login as user "Foo"</span><span id="cbc0" class="nc ls in lk b gy nh ne l nf ng">curl -X POST -H "Content-Type: application/json" -d "{\"username\":\"Foo\",\"password\":\"Bar\"}" http://localhost:3001/login</span><span id="3adb" class="nc ls in lk b gy nh ne l nf ng"># Grab token from body or headers and do:</span><span id="d0f3" class="nc ls in lk b gy nh ne l nf ng">set TOKEN=eyJhbGciOiJIUzI1NiIsIn.....</span><span id="bef4" class="nc ls in lk b gy nh ne l nf ng"># Use the token</span><span id="91de" class="nc ls in lk b gy nh ne l nf ng">curl -H "Authorization: Bearer %TOKEN%" http://localhost:3001/me</span></pre><h1 id="b1f1" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">Git回购</h1><p id="ff86" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">按下VSCode中的<code class="fe lh li lj lk b">F5</code>(或<code class="fe lh li lj lk b">nodemon</code>，或运行<code class="fe lh li lj lk b">node</code>)即可运行回购。阅读更多关于https://github.com/tomnil/expressplate的信息</p><h1 id="692d" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">享受:)</h1><p id="d318" class="pw-post-body-paragraph ka kb in kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated"><em class="lq">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>