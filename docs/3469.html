<html>
<head>
<title>JavaScript: Why ‘var’ is the Greatest Evil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:为什么“var”是最大的恶魔</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-why-var-is-the-greatest-evil-var-vs-let-vs-const-96c0baa2517b?source=collection_archive---------9-----------------------#2021-07-13">https://javascript.plainenglish.io/javascript-why-var-is-the-greatest-evil-var-vs-let-vs-const-96c0baa2517b?source=collection_archive---------9-----------------------#2021-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0bb4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中“var”、“let”和“const”的区别——详细解释。</h2></div><p id="6e3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的<a class="ae lb" href="https://www.youtube.com/watch?v=FNh2JCiFXIg" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>看这个教程！</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="b78d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么不用' var '？当你看到这篇文章的标题时，你可能会问这个问题。没错！关键字<code class="fe lj lk ll lm b">var</code>可能是这种语言最令人头疼的特性之一。多年来，随着ES6中<code class="fe lj lk ll lm b">let</code>和<code class="fe lj lk ll lm b">const</code>关键词的引入，人们从此爱上了<code class="fe lj lk ll lm b">let</code>和<code class="fe lj lk ll lm b">const</code>关键词。让我们来看看为什么。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ln"><img src="../Images/1029f85ae952cbff0a2764f7788982c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rtof6jzfjGXzje8x"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@sammywilliams?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sammy Williams</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="75af" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">理解范围</h1><p id="bce4" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">在我们继续之前，让我们简单地看一下什么是作用域。</p><p id="edcc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，作用域可以定义为包含在一对花括号<code class="fe lj lk ll lm b">{}</code>内的代码块(object除外，它也是由一对<code class="fe lj lk ll lm b">{}</code>创建的)。每当我们看到一对花括号，我们就可以假设我们进入了一个新的范围。</p><p id="c237" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="9dd3" class="mz lz iq lm b gy na nb l nc nd"><em class="ne">// an if statement</em><br/>if(condition){<br/>    <em class="ne">//....</em><br/>}</span><span id="5670" class="mz lz iq lm b gy nf nb l nc nd"><em class="ne">// for loop</em><br/>for (let index = 0; index &lt; array.length; index++) {</span><span id="3300" class="mz lz iq lm b gy nf nb l nc nd">}</span><span id="9765" class="mz lz iq lm b gy nf nb l nc nd"><em class="ne">// function</em><br/>function something(){</span><span id="5257" class="mz lz iq lm b gy nf nb l nc nd">}</span><span id="92c0" class="mz lz iq lm b gy nf nb l nc nd"><em class="ne">// or just a random pair of curly braces for the sake of creating a new scope</em><br/>{<br/>    <em class="ne">// some code</em></span><span id="a1ac" class="mz lz iq lm b gy nf nb l nc nd">}</span></pre><p id="a615" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以将作用域想象成一个半隔离的房间:作用域内创建的任何东西都留在作用域内。但是，我们需要遵守一些规则:</p><ol class=""><li id="4622" class="ng nh iq kh b ki kj kl km ko ni ks nj kw nk la nl nm nn no bi translated">在作用域中创建的变量留在作用域内。一旦我们退出作用域，在作用域内创建的变量将会被丢弃到永恒的虚空中😛。</li><li id="69dd" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">我们可以访问父作用域中的变量，但是父作用域不能访问子作用域中的变量。</li><li id="f01c" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated"><code class="fe lj lk ll lm b">var</code>变量有💩不要遵守这些规则。</li></ol><p id="7626" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:功能作用域与标准作用域稍有不同。稍后将详细介绍。</p><h1 id="2e7c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><code class="fe lj lk ll lm b">var</code>怎么会出问题？</h1><p id="24b3" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">现代JavaScript有3种方式定义变量，即使用<code class="fe lj lk ll lm b">var</code>、<code class="fe lj lk ll lm b">let</code>和<code class="fe lj lk ll lm b">const</code>关键字。</p><p id="a77d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有以下代码:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="00fc" class="mz lz iq lm b gy na nb l nc nd">let a = 'a';<br/>var b = 'b';<br/>const c = 'c';</span><span id="bd0e" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    let a = 2;<br/>    var b = 2;<br/>    const c = 2;<br/>}</span><span id="97d4" class="mz lz iq lm b gy nf nb l nc nd"><em class="ne">// What are we going to see here??</em><br/>console.log(a);<br/>console.log(b);<br/>console.log(c);</span></pre><p id="5709" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您希望在控制台日志中看到什么？答案可能会让你吃惊:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="b008" class="mz lz iq lm b gy na nb l nc nd"><em class="ne">// ....</em></span><span id="c7f9" class="mz lz iq lm b gy nf nb l nc nd">console.log(a); <em class="ne">// expect: a</em><br/>console.log(b); <em class="ne">// expect: 2</em><br/>console.log(c); <em class="ne">// expect: c</em></span></pre><h2 id="308f" class="mz lz iq bd ma nu nv dn me nw nx dp mi ko ny nz mk ks oa ob mm kw oc od mo oe bi translated">这是怎么回事？</h2><p id="9088" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们来分析一下。这又回到了规则1:</p><blockquote class="of og oh"><p id="54b6" class="kf kg ne kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated"><em class="iq">在作用域中创建的变量留在作用域内。</em></p></blockquote><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="a3fd" class="mz lz iq lm b gy na nb l nc nd">let a = 'a';<br/>var b = 'b';<br/>const c = 'c';</span><span id="6e97" class="mz lz iq lm b gy nf nb l nc nd"><em class="ne">// we are creating a scope here in the if statement</em><br/>if(true){<br/>    <em class="ne">// variables created using the 'let' and 'const' keywords </em><br/>    <em class="ne">// stays inside the scope, and will be destroyed once we exit the scope</em></span><span id="0715" class="mz lz iq lm b gy nf nb l nc nd">    <em class="ne">// here we are redeclaring variable 'a' and 'c'. So 'a' and 'c' are not</em><br/>    <em class="ne">// related to their counterparts above at all!</em></span><span id="1ca2" class="mz lz iq lm b gy nf nb l nc nd">    <em class="ne">// However this rule does not apply to 'var' variables. </em><br/>    <em class="ne">// So redeclaring variable 'b' will override the value of the variable 'b' </em><br/>    <em class="ne">// above.</em><br/>    let a = 2;<br/>    var b = 2;<br/>    const c = 2;<br/>}<br/><em class="ne">// Hence, variable 'a' and 'c' here are referring to the variables </em><br/><em class="ne">// declared before the if statement. </em></span><span id="b414" class="mz lz iq lm b gy nf nb l nc nd"><em class="ne">// Variable 'b' got rewritten in the if statement</em><br/>console.log(a);<br/>console.log(b);<br/>console.log(c);</span></pre><p id="2adc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">👊这演示了<code class="fe lj lk ll lm b">var</code>变量最危险的行为之一:<code class="fe lj lk ll lm b"><strong class="kh ir">var</strong></code> <strong class="kh ir">不是范围安全的。</strong></p><p id="a5af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再来说说<code class="fe lj lk ll lm b">var</code>的另一个危险行为:吊装。</p><h1 id="afa6" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">提升</h1><p id="c403" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">提升机在英语中是“升起”的意思。在JavaScript中，提升意味着将变量移动到代码的最开头。默认情况下，所有<code class="fe lj lk ll lm b">var</code>变量都被提升。</p><p id="29c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，下面的代码:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="bbeb" class="mz lz iq lm b gy na nb l nc nd">if(true){<br/>    var hey = "ya";<br/>}</span></pre><p id="6ebb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对JavaScript来说会是这样的:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="7194" class="mz lz iq lm b gy na nb l nc nd">var hey;</span><span id="38c4" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    hey = "ya"<br/>}</span></pre><p id="2014" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是吊装的意思。实际上，将变量移到脚本的顶部。</p><h1 id="0c4c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">JavaScript如何读取变量？</h1><p id="8c50" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">在我们继续之前，让我们了解JavaScript如何处理变量。</p><p id="786f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中创建变量实际上有两个步骤。<strong class="kh ir">申报</strong>和<strong class="kh ir">分配</strong>。</p><p id="5c47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">声明</strong>就是只声明一个变量，没有值。赋值意味着给变量赋值。</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="e840" class="mz lz iq lm b gy na nb l nc nd"><em class="ne">// declaring the variable 'abc'</em><br/>let abc;<br/><em class="ne">// assigning value to variable 'abc'</em><br/>abc = 123;<br/><em class="ne">// Normally we carry out declaration and assignment in 1 go.</em><br/>let hey = 'ya';</span></pre><p id="93ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，这里是JavaScript如何读取变量的值。</p><ol class=""><li id="5306" class="ng nh iq kh b ki kj kl km ko ni ks nj kw nk la nl nm nn no bi translated">当JavaScript看到一个变量时，它将首先尝试在当前范围内查找该变量。</li><li id="7795" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">如果在当前范围内没有找到该变量，那么JavaScript将在父范围内查找。</li><li id="2096" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">如果在父作用域中没有找到该变量，那么JavaScript将在祖父作用域中查找，等等…</li></ol><p id="ce33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些例子:</p><p id="acb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">情景一:</strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="991b" class="mz lz iq lm b gy na nb l nc nd">let abc = 123;</span><span id="9353" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    <em class="ne">// Here, Js will try to find the declaration of 'abc' in </em><br/>    <em class="ne">// the current scope.</em></span><span id="6558" class="mz lz iq lm b gy nf nb l nc nd">    <em class="ne">// There is none, so JS will proceed to the parent scope. </em><br/>    <em class="ne">// In the parent scope, the variable 'abc' is declared and has a value of 123.</em><br/>    console.log(abc); <em class="ne">// expect: 123</em><br/>}</span></pre><p id="60a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">情景二:</strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="4f3b" class="mz lz iq lm b gy na nb l nc nd">let abc = 123;</span><span id="6d5c" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    let abc = 456;</span><span id="132b" class="mz lz iq lm b gy nf nb l nc nd">    <em class="ne">// Again, JS will try to find the declaration of 'abc' in the current scope.</em><br/>    <em class="ne">// There is a declaration, and its value is 456</em><br/>    console.log(abc); <em class="ne">// expect: 456</em><br/>}<br/><em class="ne">// We are now reading 'abc' on the parent scope. </em><br/><em class="ne">// So we are getting the value 123</em><br/>console.log(abc); <em class="ne">// expect: 123</em></span></pre><p id="1c19" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">情景三:</strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="db9f" class="mz lz iq lm b gy na nb l nc nd">let abc = 123;</span><span id="36f7" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    <em class="ne">// There is a declaration in the current scope, but it is declared</em><br/>    <em class="ne">// after JS's attempt to read it. We can't read a value before we </em><br/>    <em class="ne">// declare it.</em></span><span id="bb20" class="mz lz iq lm b gy nf nb l nc nd">    <em class="ne">// Therefore we see an error</em><br/>    console.log(abc);  <em class="ne">// expect error</em><br/>    let abc = 456;<br/>}</span></pre><h1 id="6316" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">那么吊装和这个有什么关系呢？把所有的放在一起</h1><p id="c590" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">因为默认情况下<code class="fe lj lk ll lm b">var</code>变量被提升，所以让我们再看一遍上面的场景，但是使用<code class="fe lj lk ll lm b">var</code>。</p><p id="379f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">情景一:</strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="d437" class="mz lz iq lm b gy na nb l nc nd"><em class="ne">// This works like before, JS will try to read the variable from the parent scope</em><br/>var abc = 123;<br/>if(true){<br/>    console.log(abc); <em class="ne">// expect: 123</em><br/>}</span></pre><p id="e94e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">情景二:</strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="2543" class="mz lz iq lm b gy na nb l nc nd">var abc = 123;</span><span id="b960" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    var abc = 456;<br/>    console.log(abc); <em class="ne">// expect: 456</em><br/>}<br/><em class="ne">// We are getting 456 this time!!</em><br/>console.log(abc); <em class="ne">// expect: 456</em></span></pre><p id="4db2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">😦好了，冷静下来。这正是吊装提出的问题。对于JavaScript，上面的代码看起来像:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="b5a0" class="mz lz iq lm b gy na nb l nc nd">var abc;<br/>abc = 123;</span><span id="f54b" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    <em class="ne">// we are overwriting the global variable abc.</em><br/>    abc = 456;<br/>    console.log(abc); <em class="ne">// expect: 456</em><br/>}<br/><em class="ne">// value of 'abc' has been changed by the if statement scope</em><br/>console.log(abc); <em class="ne">// expect: 456</em></span></pre><p id="73b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">场景3: </strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="91d0" class="mz lz iq lm b gy na nb l nc nd">var abc = 123;</span><span id="0395" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    console.log(abc);  <em class="ne">// expect: 123</em><br/>    var abc = 456;<br/>}</span></pre><p id="bdd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">😦😦好吧，让我们再冷静一次。这是JavaScript看到的:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="ee0f" class="mz lz iq lm b gy na nb l nc nd">var abc;<br/>abc = 123;</span><span id="1eae" class="mz lz iq lm b gy nf nb l nc nd">if(true){<br/>    console.log(abc);  <em class="ne">// expect: 123</em><br/>    abc = 456;<br/>}</span></pre><p id="af89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">奖金方案:</strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="0e4b" class="mz lz iq lm b gy na nb l nc nd">console.log(abc); <em class="ne">// expect: undefined</em><br/>var abc = 123;</span></pre><p id="b7bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，希望你不要再惊讶了。JavaScript是这样看的:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="2154" class="mz lz iq lm b gy na nb l nc nd">var abc;<br/>console.log(abc);<br/>abc = 123;</span></pre><h1 id="db07" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><code class="fe lj lk ll lm b">Var</code>在全球范围内</h1><p id="3ff8" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">在浏览器中，全局范围被称为<code class="fe lj lk ll lm b">window</code>对象。这里是<code class="fe lj lk ll lm b">var</code>变量的另一个奇怪行为:所有的<code class="fe lj lk ll lm b">var</code>变量都被添加到了<code class="fe lj lk ll lm b">window</code>对象中。</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="ec9f" class="mz lz iq lm b gy na nb l nc nd">var abc = 123;<br/>let heya = 123;</span><span id="eaf8" class="mz lz iq lm b gy nf nb l nc nd">console.log(window.abc); <em class="ne">// expect: 123</em><br/>console.log(window.heya); <em class="ne">// expect: undefined</em></span></pre><h1 id="bebc" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><code class="fe lj lk ll lm b">Var</code> vs <code class="fe lj lk ll lm b">Let</code> vs <code class="fe lj lk ll lm b">Const</code>一言以蔽之</h1><ul class=""><li id="43af" class="ng nh iq kh b ki mq kl mr ko ol ks om kw on la oo nm nn no bi translated">Var不是作用域安全的。</li><li id="7bfc" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la oo nm nn no bi translated">Var变量被吊起来。</li><li id="a02e" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la oo nm nn no bi translated">默认情况下，Var变量被添加到全局<code class="fe lj lk ll lm b">window</code>对象中。</li><li id="7f81" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la oo nm nn no bi translated">一旦声明，我们不能重新分配<code class="fe lj lk ll lm b">const</code>变量。</li></ul><h1 id="dd0b" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">功能范围及<code class="fe lj lk ll lm b">Var</code>吊装</h1><p id="8847" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">函数作用域是由函数提供的作用域。与其他作用域不同，<code class="fe lj lk ll lm b">var</code>在函数作用域中声明的变量不会被提升到全局作用域，而是被提升到函数的最开始。</p><p id="dccc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">场景1: </strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="0ff8" class="mz lz iq lm b gy na nb l nc nd">var abc = 123;</span><span id="73e6" class="mz lz iq lm b gy nf nb l nc nd">function print(){<br/>    console.log(abc); <em class="ne">// expect: undefined</em><br/>    var abc = 567;</span><span id="1d37" class="mz lz iq lm b gy nf nb l nc nd">}</span><span id="5e14" class="mz lz iq lm b gy nf nb l nc nd">print();<br/>console.log(abc); <em class="ne">// expect: 123</em></span></pre><p id="770a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript认为这是:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="57dd" class="mz lz iq lm b gy na nb l nc nd">var abc;<br/>abc = 123;</span><span id="c948" class="mz lz iq lm b gy nf nb l nc nd">function print(){<br/>    var abc;<br/>    console.log(abc); <em class="ne">// expect: undefined</em><br/>    abc = 567;<br/>}</span><span id="9978" class="mz lz iq lm b gy nf nb l nc nd">print();<br/><em class="ne">// abc is referred to the variable defined in the global scope.</em><br/>console.log(abc); <em class="ne">// expect: 123</em></span></pre><p id="d0ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">场景二:</strong></p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="22d2" class="mz lz iq lm b gy na nb l nc nd">var abc = 123;</span><span id="c5a0" class="mz lz iq lm b gy nf nb l nc nd">function print(){<br/>    console.log(abc); <em class="ne">// expect: 123</em><br/>    abc = 567;</span><span id="f8f7" class="mz lz iq lm b gy nf nb l nc nd">}</span><span id="2830" class="mz lz iq lm b gy nf nb l nc nd">print();<br/>console.log(abc); <em class="ne">// expect: 567</em></span></pre><p id="ef3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该很简单。JavaScript是这样看的:</p><pre class="lc ld le lf gt mv lm mw mx aw my bi"><span id="3dfe" class="mz lz iq lm b gy na nb l nc nd">var abc;<br/>abc = 123;</span><span id="34a4" class="mz lz iq lm b gy nf nb l nc nd">function print(){<br/>    <em class="ne">// Since there is no local 'abc'</em><br/>    <em class="ne">// we are getting the variable from the global scope.</em><br/>    console.log(abc); <em class="ne">// expect: 123</em><br/>    <em class="ne">// changing the value of 'abc'</em><br/>    abc = 567;<br/>}<br/>print();<br/><em class="ne">// after running the print() function,</em><br/><em class="ne">// value of abc is changed.</em><br/>console.log(abc); <em class="ne">// expect: 567</em></span></pre><p id="8c29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样！总之，永远不要使用<code class="fe lj lk ll lm b">var</code>因为它是一段(咒骂语编辑)😅。</p><p id="5202" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ne">多内容于</em> <a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ne">通俗易懂</em> </strong> </a></p></div></div>    
</body>
</html>