# 如何降低 JavaScript 中 For 循环的速度

> 原文：<https://javascript.plainenglish.io/javascript-slow-down-for-loop-9d1caaeeeeed?source=collection_archive---------2----------------------->

## JavaScript 快速

## 是的，由于一个简单的技巧，这是可能的。

![](img/c68a13a3e1fc80969b1adc40f69fba8b.png)

Photo by [Charlotte Coneybeer](https://unsplash.com/@she_sees?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

For 循环是必不可少的。他们帮助我们编程序列。但是它们有一个问题 for 循环尽可能快地运行。如果我们遍历一个数组，这当然是可取的。

但是，如果我们这样做，例如，在循环中请求，这可能会导致问题。如果每个循环的执行时间间隔是固定的，比如每秒一次，那就好了。

我将向您展示如何做到这一点——下面是如何为一个 for 循环计时。

# 首先——它是如何不起作用的

如果你正在寻找直接解决问题的方法，请随意跳过这一部分。如果你想学习一些关于 JS 的知识，那就呆一会儿。
我想解释为什么普通的解决方案不起作用。

感谢 setTimeout，d 我们可以指定某个代码应该只在 x-time 之后执行。这听起来像是解决我们问题的方法。只需将超时时间放入 for 循环中，循环就不会那么快了:

当我们运行带有 *setTimeout* 的代码时，会发生以下情况:
1 秒内什么也没发生；然后所有的日志会在一瞬间出现。这并不是我们所希望的。

之所以这样，是思维上的一个小错误。似乎超时并不适用于每个元素——是的，它适用。

但是我们忘记了 JavaScript 是如何执行代码的。该循环立即创建所有超时，而不是按顺序创建。当然，这非常快——所以所有超时都有几乎相同的**开始时间**。时间一到，日志就被创建了——一次完成。

当我们最低限度地重写代码时，我们会看到同样的效果。

根据这个想法，这在其他一些编程语言中也是可行的。
循环开始创建超时。只有当它被执行时，它才会继续——至少在其他编程语言中是这样。然而，在 JavaScript 中，超时被创建，代码继续立即执行。
所以 JavaScript 创建了两个并行运行的流。

# 如何适当降低 for 循环的速度

因此，有了 *setTimeout，*它就不能正常工作了。救助是一个简单的承诺。

我们通过函数调用 Promise。它以毫秒为单位获取 *setTimeout* 应该接收的时间。超时之后，超时所做的只是执行 resolve 函数。这意味着承诺实现了——它可以继续。我们可以简化上面显示的代码:

诺言准备好了。现在我们可以将它添加到 for 循环中:

日志每秒执行一次。所以要输出循环的所有数字，我们需要 100 秒。所以我们成功地减缓了 for 循环。

感谢您的阅读！

## [加入我的时事通讯，了解最新消息](http://eepurl.com/hacY0v)