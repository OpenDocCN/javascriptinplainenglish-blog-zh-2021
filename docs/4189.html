<html>
<head>
<title>How to Client-Side-Render a Component in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Next.js中客户端呈现组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-client-side-rendering-56a3cae65148?source=collection_archive---------1-----------------------#2021-08-20">https://javascript.plainenglish.io/next-js-client-side-rendering-56a3cae65148?source=collection_archive---------1-----------------------#2021-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2ac7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及为什么这真的有用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b687240b9ec912b611c4d6e33772fddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwKQXOxAsri-rQInS5NVTQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="94cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整个SSR与CSR的讨论感觉就像一个结了的案子。</p><p id="b343" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SSR赢了，是大多数人的想法。总的来说，我同意这一点。尽管如此，我们仍在清理我们制造的混乱。尽管如此，并不是所有的东西都可以在服务器上呈现。</p><p id="454d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你在阅读这个标题的时候问自己“我为什么想要这个”,那就这样吧。不与SSR一起工作的组件是，为什么你会想要这个。</p><p id="864e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在React.js中遇到了样式和图形库的问题。它们在Next.js中不起作用——嗯，只要我们不在Next中客户端呈现它们，它们就不起作用。下面是如何做到这一点。</p><p id="8c6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实际上，诀窍很简单:当我们在服务器上呈现某些东西时，<code class="fe lr ls lt lu b">window</code>对象对我们的代码是不可用的。为什么？嗯，因为<code class="fe lr ls lt lu b">window</code>对象当然是浏览器专有的。</p><p id="0eed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们可以在Next.js中访问这个特殊的对象，所以我们检查我们是否在服务器上。因此，如果服务器端呈现正在发生，我们可以保存在这样的变量中:</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="f27f" class="lz ma iq lu b gy mb mc l md me">const SSR = typeof window === 'undefined'</span></pre><p id="4652" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们的JSX的服务器端渲染正在发生，SSR为<em class="mf">真</em>。要仅在客户端呈现某些内容，请使用此变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="bd5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们只是正常地渲染段落，这将是我们的服务器端渲染应用程序发送给我们的HTML结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/eb5db9cc967115645785aaecd6f1bd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sbC2NSKQDKXHaFwCkNpng.png"/></div></div></figure><p id="214a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当使用上面的代码时，为了只在客户机上呈现该段落，我们收到如下响应:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/3a244ad2b100c91cd5bd473c546e3f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGfC3R9z5UyJvdPh-nStUA.png"/></div></div></figure><p id="be39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然是“你好，世界！”仍然出现在DOM中——但这需要一些时间，因为它是通过客户端JavaScript呈现的。</p><p id="4efa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们在Next.js中实现客户端渲染的简单方法。</p><p id="878b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">感谢您的阅读！</strong> <br/>更多关于Next.js:</p><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/next-js-tricks-6dd97ee66c7c"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">添加到工具箱中的5个有用的Next.js技巧</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">构建脚本、加载外部JavaScript、重定向等等。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mv l"><div class="mw l mx my mz mv na kp mm"/></div></div></a></div><p id="4cf4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mf">更多内容请看</em><a class="ae nb" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="mf">plain English . io</em></strong></a></p></div></div>    
</body>
</html>