<html>
<head>
<title>JavaScript — Function currying and it’s variations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript——函数曲线及其变体</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-function-currying-and-its-variations-b8ad620397bf?source=collection_archive---------7-----------------------#2021-03-27">https://javascript.plainenglish.io/javascript-function-currying-and-its-variations-b8ad620397bf?source=collection_archive---------7-----------------------#2021-03-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/73cf0079865d31737e378e62438731a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jzXe1Q6rJOBM3V9P_tLNg.jpeg"/></div></div></figure><h2 id="5ada" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">功能电流定义:</strong></h2><p id="2430" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated"><em class="lm">“curry ing”是一个函数编程的过程，在这个过程中，我们可以将一个有多个参数的函数转换成一系列嵌套的函数。它返回一个新的函数，该函数预期内联下一个参数。”</em></p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="51ae" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">让我们从一个简单的例子开始，我们将编写一个函数，将两个数字相加并返回总和。</p><pre class="ln lo lp lq gt ly lz ma mb aw mc bi"><span id="265b" class="jv jw in lz b gy md me l mf mg">function add(a, b){<br/>   return a + b;<br/>}<br/>let output = add(10,20);<br/>console.log(output) // output will be 30</span></pre><p id="0277" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">正如大多数人所知，上面是一个简单的函数，它接受2个参数，将其相加并返回总和。当我们提前知道两个参数并想计算其和时，这个函数就可以了。</p><p id="c591" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">如果我们有一个场景，其中两个参数在代码块的两个不同的地方是已知的，该怎么办？一旦这两个数字都可用，我们就调用add函数？有很少的方法可以解决这个问题，我们可以使用JavaScript bind来达到同样的目的，但是最优选的方法是使用<strong class="kt io">来讨好</strong>。</p><p id="45bb" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">让我们修改上面的例子，使其在程序的两个不同部分接受两个参数。</p><pre class="ln lo lp lq gt ly lz ma mb aw mc bi"><span id="5243" class="jv jw in lz b gy md me l mf mg">function add(a){<br/>  return function(b){<br/>    return a + b;<br/>  }<br/>}</span><span id="45f5" class="jv jw in lz b gy mh me l mf mg">let fnCall = add(10);<br/>console.log(fnCall(20)); //output will be 30</span></pre><p id="7041" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">仔细观察上面的代码片段，我们有一个外部函数add，它接受一个参数，当您调用它时，它将返回一个接受另一个参数的函数。通过JavaScript闭包属性，内部函数将可以访问传递给add函数的变量“a”。如果您不知道什么是结束，请阅读我关于它的文章(<a class="ae mi" href="https://mevasanth.medium.com/javascript-clousures-tricky-interview-topic-3e129435083e" rel="noopener">JavaScript clo高利贷——棘手的采访主题</a>)</p><p id="02d8" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">现在每当我们得到第二个参数，我们就调用内部函数，其引用出现在变量fnCall上，因此上面代码的输出将是<strong class="kt io"> 30 </strong>。</p><p id="ea25" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">现在让我们看看它的一个小偏差，这是在面试中经常被问到的问题。</p><p id="8ab6" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">写一个加两个数字的函数，函数调用应该是这样的——<strong class="kt io">add(10)(20)。</strong></p><p id="1d28" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">不要惊慌，这也是函数currying，在一段时间内调用两个嵌套的函数。代码片段如下所示。</p><pre class="ln lo lp lq gt ly lz ma mb aw mc bi"><span id="914e" class="jv jw in lz b gy md me l mf mg">function add(a){<br/>  return function(b){<br/>    return a + b;<br/>  }<br/>}</span><span id="1f9b" class="jv jw in lz b gy mh me l mf mg">let output = add(10)(20);<br/>console.log(output); //output will be 30</span></pre><h2 id="3151" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">功能趋利的主要用例是什么？</strong></h2><ol class=""><li id="bb56" class="mj mk in kt b ku kv ky kz ke ml ki mm km mn ll mo mp mq mr bi translated">正如您已经看到的，当函数所需的参数在代码中的不同位置可用时，我们可以使用函数currying。</li><li id="a17a" class="mj mk in kt b ku ms ky mt ke mu ki mv km mw ll mo mp mq mr bi translated">最适合执行与数学函数相关的数学运算，这涉及到像<strong class="kt io"> f(g(x)) ( </strong>我将在<strong class="kt io">下面为它写一个例子)。</strong></li><li id="f5ce" class="mj mk in kt b ku ms ky mt ke mu ki mv km mw ll mo mp mq mr bi translated">函数currying也可以扩展到接受无限个参数(显然直到内存中有空间可供计算)。当我们必须执行一个特定的任务时，这很有帮助，不管传递给函数的参数是什么，然后我们可以使用函数currying。(下面有一个相同的例子)</li></ol><h2 id="f24b" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">使用函数currying编写数学函数</strong></h2><pre class="ln lo lp lq gt ly lz ma mb aw mc bi"><span id="9ec3" class="jv jw in lz b gy md me l mf mg">const f = x =&gt; x + x<br/>const g = y =&gt; y * y</span><span id="182f" class="jv jw in lz b gy mh me l mf mg">let output =  f(g(10))<br/>console.log(output) //output will be 200</span></pre><p id="b951" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">在上面的代码块中，我们编写了两个名为<strong class="kt io">“f”、“g”的函数。</strong>当我们编写函数调用f(g(10))时，我们将值10传递给函数g()，该函数将传递的参数相乘，因此值将是10*10 = 100。</p><p id="d179" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">这个100作为参数传递给函数f()，传递的值加在函数f()内部，所以输出是100 + 100 = <strong class="kt io"> 200。</strong>根据您执行的数学计算，这可以嵌套到任何层次结构中。</p><p id="1f38" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">注意:对于那些想知道<strong class="kt io"> const g = y = &gt; y * y </strong>如何将y的值相乘并返回的人，这是arrow函数的默认行为，当你没有指定括号时，值被计算并返回。如果您添加了花括号，则应该手动返回该值。</p><h2 id="8ce6" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">扩展currying以在函数中添加无限个数字</strong></h2><p id="74f1" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">让我们扩展上面的函数add，这样它可以接受无限个参数，将它们相加并返回总和。</p><p id="0486" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated"><strong class="kt io">对于ex函数调用应该是这样的:</strong></p><p id="64f9" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated"><code class="fe mx my mz lz b">add(10)(20)(30)()</code></p><p id="5b46" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated"><code class="fe mx my mz lz b">add(10)(20)(30)(40)(50)(60)()</code></p><p id="1d6f" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated"><code class="fe mx my mz lz b">add(10)(20)()</code>等。</p><h2 id="43ee" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">这是JavaScript面试中最常见也是最棘手的面试问题之一。</strong></h2><p id="6b97" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">在所有这些不同的函数调用的情况下，你的currying函数应该能够计算总和。当你看到这个问题时，你的思维应该是递归的，这里函数调用的分隔符是最后一个空括号，在递归术语中，这是基本情况。</p><p id="8523" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">函数currying中没有内置的属性来处理这种情况，我们需要结合currying和递归的概念来解决这个问题。工作代码片段如下。</p><pre class="ln lo lp lq gt ly lz ma mb aw mc bi"><span id="13e2" class="jv jw in lz b gy md me l mf mg">function add(a){<br/>  return function(b){<br/>    if(b){<br/>      return add(a+b)<br/>    }else{<br/>      return a<br/>    }<br/>  }<br/>}<br/>let output1 = add(10)(20)();<br/>let output2 = add(10)(20)(30)(40)();<br/>console.log(output1); //output will be 30<br/>console.log(output2); //output will be 100</span></pre><p id="61af" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">在上面的递归代码中，我们一直运行这个函数，直到我们遇到一个空括号，如果不是，那么我们将计算这个和，并把它存储在变量a中，变量a在最后返回。</p><h2 id="a950" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">给读者的困惑</strong></h2><p id="1bb8" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">现在你知道了如何一起使用递归和currying。现在一些高明的面试官会问你一个类似下面的问题。</p><p id="fa7d" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">编写一个函数add，它在被调用时给出总和，如下所示，</p><p id="e652" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated"><code class="fe mx my mz lz b">add(10)(20)</code></p><p id="8f39" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated"><code class="fe mx my mz lz b">add(10,20)</code></p><p id="6ab3" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">正如你所观察到的，第一个是你如何调用currying函数，第二个是你如何调用一个普通的函数，所以你写的函数应该两种方式都有。</p><p id="c636" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">这个问题我不回答，给你个提示。使用JavaScript arguments属性，它将为您提供传递给函数的一组参数，并在条件中使用它来区分函数是像currying还是像normal function一样被调用。</p><p id="fe92" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated"><strong class="kt io">同一作者的其他有趣文章</strong></p><ol class=""><li id="505e" class="mj mk in kt b ku lt ky lu ke na ki nb km nc ll mo mp mq mr bi translated"><a class="ae mi" href="https://mevasanth.medium.com/how-everything-is-object-in-javascript-a4164d7e6a2d" rel="noopener">JavaScript中的一切都是对象吗？</a></li><li id="0cf6" class="mj mk in kt b ku ms ky mt ke mu ki mv km mw ll mo mp mq mr bi translated"><a class="ae mi" href="https://mevasanth.medium.com/hoisting-in-javascript-hot-topic-for-interview-43b463a6a77?source=follow_footer---------0----------------------------" rel="noopener">JavaScript吊装:访谈热点</a></li><li id="1835" class="mj mk in kt b ku ms ky mt ke mu ki mv km mw ll mo mp mq mr bi translated"><a class="ae mi" href="https://mevasanth.medium.com/memoization-in-javascript-hot-topic-for-interview-815475544ab0" rel="noopener">JavaScript中的记忆化——采访热门话题</a></li></ol><p id="d640" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated">点击<a class="ae mi" href="https://mevasanth.medium.com/" rel="noopener">此处</a>查看作者所有文章。</p><p id="66ba" class="pw-post-body-paragraph kr ks in kt b ku lt kw kx ky lu la lb ke lv ld le ki lw lg lh km lx lj lk ll ig bi translated"><em class="lm">更多内容请看</em><a class="ae mi" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt io"><em class="lm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>