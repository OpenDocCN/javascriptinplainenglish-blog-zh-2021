<html>
<head>
<title>From Zero to Dijkstra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到迪克斯特拉</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/from-zero-to-dijkstra-10a19301f299?source=collection_archive---------6-----------------------#2021-07-09">https://javascript.plainenglish.io/from-zero-to-dijkstra-10a19301f299?source=collection_archive---------6-----------------------#2021-07-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3e4b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第3部分:图表</h2></div><p id="78f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你一直追溯到本博客系列的第1部分，你会记得我们最初学习优先级队列的全部原因是为了解决Dijkstra算法。Dijkstra算法的要点是找出图上任意两点之间的最短路径。所以，瞧，我们已经到达了我们的基本数据结构:<strong class="ke io">图。</strong></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/449b6dc4d958315efbac6d54439b9c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xwrOZFZCxBtsgwHs"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@thomaskinto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Thomas Kinto</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ac8f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在编程中，图是一个简单的数据结构，包含了<strong class="ke io">顶点</strong>和它们的连接。就像地图上的道路如何连接城市并可以向许多方向分支一样，图节点可以根据需要连接到任意多或任意少的其他节点。</p><p id="b954" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有<strong class="ke io">加权的</strong>和<strong class="ke io">未加权的</strong>图，这意味着连接，或者我们将称之为<strong class="ke io">边</strong>，可以保持一个值，也可以不保持。例如，州地图将被加权，因为连接城市的道路之间有距离。正如你可能猜到的，Dijkstra的算法处理的是加权图，但是我们将从一个未加权的图开始。</p><h1 id="741c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">此博客的目标</h1><ul class=""><li id="d3d8" class="mh mi in ke b kf mj ki mk kl ml kp mm kt mn kx mo mp mq mr bi translated">创建一个<strong class="ke io">图形</strong>类</li><li id="b482" class="mh mi in ke b kf ms ki mt kl mu kp mv kt mw kx mo mp mq mr bi translated">将<strong class="ke io">顶点</strong>和<strong class="ke io">边</strong>添加到图形中</li><li id="0a22" class="mh mi in ke b kf ms ki mt kl mu kp mv kt mw kx mo mp mq mr bi translated">移除顶点和边</li><li id="feff" class="mh mi in ke b kf ms ki mt kl mu kp mv kt mw kx mo mp mq mr bi translated"><strong class="ke io">遍历</strong>图形</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/484babf0326e8d020d692dc091697b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*3cQBrnFRcgK9z9WpXsOYwQ.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Example Graph</figcaption></figure><p id="88ac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个简单的图表。你可以看到图上的每个点都至少与另外一个点相连。如果我们为此构建一个Javascript类，我们将如何跟踪每个顶点和边呢？答案比你想象的要简单。我们可以使用一个<strong class="ke io">邻接表</strong>。</p><h1 id="b099" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">邻接表</h1><p id="0a6d" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">跟踪每个顶点及其连接的一个简单方法是使用邻接表。这是一个普通的Javascript对象，其中每个键是一个顶点，值是一个数组，保存所有它们的直接连接。这里有一个例子:</p><pre class="la lb lc ld gt nb nc nd ne aw nf bi"><span id="1998" class="ng lq in nc b gy nh ni l nj nk">this.adjacencyList = <br/>{<br/>    A: [B, C],<br/>    B: [A, D],<br/>    C: [A, D, E],<br/>    D: [B, C, E],<br/>    E: [C, D]<br/>}</span></pre><p id="6efb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们需要添加一个顶点或边，我们可以简单地添加另一个键，或者将另一个值推入邻接表。所以我们的图构造器实际上变成了一个邻接表。我们可以通过遍历对象来检查顶点，也可以通过检查相应的数组来检查边。</p><pre class="la lb lc ld gt nb nc nd ne aw nf bi"><span id="38ca" class="ng lq in nc b gy nh ni l nj nk">class Graph {<br/>    constructor() {<br/>        this.adjacencyList = {};<br/>    }<br/>}</span></pre><p id="68b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！添加顶点和边的操作并不困难。要添加一个顶点，我们检查它是否已经存在于邻接表中，如果不存在，我们用一个空数组的值将它添加到我们的对象中。要添加边，我们需要两个顶点，并将它们的值放入彼此的数组中。</p><pre class="la lb lc ld gt nb nc nd ne aw nf bi"><span id="2a67" class="ng lq in nc b gy nh ni l nj nk">addVertex(vertex) {<br/>    if (!this.adjacencyList[vertex]) this.adjacencyList[vertex] = []<br/>}</span><span id="8d7b" class="ng lq in nc b gy nl ni l nj nk">addEdge(v1, v2) {<br/>    this.adjacencyList[v1].push(v2);<br/>    this.adjacencyList[v2].push(v1);<br/>}</span></pre><p id="1c13" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要从我们的图中删除一个顶点，先删除一条边会更容易。我们可以对数组使用<strong class="ke io"> filter </strong>函数来从相邻数组中移除每个顶点。然后，要删除一个顶点，我们可以使用<strong class="ke io"> removeEdge() </strong>函数来删除顶点列表中的每条边，并通过使用Javascript对象的经常被遗忘的<strong class="ke io"> delete </strong>属性来完全删除顶点。</p><pre class="la lb lc ld gt nb nc nd ne aw nf bi"><span id="fa42" class="ng lq in nc b gy nh ni l nj nk">removeEdge(v1, v2) {</span><span id="e9b5" class="ng lq in nc b gy nl ni l nj nk">    this.adjacencyList[v1] = this.adjacencyList[v1].filter(el =&gt; el !== v2)</span><span id="d9da" class="ng lq in nc b gy nl ni l nj nk">    this.adjacencyList[v2] = this.adjacencyList[v2].filter(el =&gt; el !== v1);</span><span id="4106" class="ng lq in nc b gy nl ni l nj nk">}</span><span id="d67d" class="ng lq in nc b gy nl ni l nj nk">removeVertex(vertex) {<br/>    while(this.adjacencyList[vertex].length) {<br/>        const adjacentVertex = this.adjacencyList[vertex].pop();<br/>        this.removeEdge(vertex, adjacentVertex);<br/>    }<br/>    delete this.adjacencyList[vertex];<br/>}</span></pre><h1 id="cb3e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">遍历图形</h1><p id="a224" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">现在有趣的部分来了。有很多方法可以遍历一个图(广度优先/深度优先，递归/迭代)，但是我们只选择一种并坚持下去。如果你愿意，你可以查一下其他选项。最终的结果是一样的，我们将有一个数组，包含图上的每个顶点，从一个点开始。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/484babf0326e8d020d692dc091697b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*3cQBrnFRcgK9z9WpXsOYwQ.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Example Graph</figcaption></figure><p id="5472" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的示例图中，我们可以从<strong class="ke io"> A、</strong>开始，并访问它的每个邻居。然后，我们将访问它们的每个邻居，依此类推，将每个新顶点推入一个<strong class="ke io">结果</strong>数组，直到我们已经看到每个顶点。</p><p id="105e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“但是我们怎么知道什么时候结束了呢？”你可能会问。我们可以有一个<strong class="ke io">堆栈</strong>(遵循先入后出的顺序)来跟踪我们正在查看的顶点，并有一个<strong class="ke io">访问过的</strong>对象来轻松检查我们以前是否访问过一个顶点，以免遇到重复的顶点。</p><p id="1f16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从初始化我们的一些值开始。</p><pre class="la lb lc ld gt nb nc nd ne aw nf bi"><span id="fc82" class="ng lq in nc b gy nh ni l nj nk">DepthFirst(start) {<br/>    let stack = [start];<br/>    let result = [];<br/>    let visited = {};<br/>    let currentElement;</span><span id="1d04" class="ng lq in nc b gy nl ni l nj nk">    visited[start] = true;</span></pre><p id="1ea6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们用起始顶点初始化了堆栈，在这种情况下，让我们使用<strong class="ke io"> A </strong>。我们还有我们的<strong class="ke io">结果</strong>数组和我们的<strong class="ke io">访问过的</strong>对象。因为我们已经访问了我们的<strong class="ke io"> start </strong>，我们可以将被访问对象中的start的值设置为<strong class="ke io"> true </strong>。我们还设置了一个<strong class="ke io"> currentElement </strong>变量，它将在我们每次访问一个顶点时发生变化。</p><p id="7c6f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们应该初始化一个循环，直到堆栈为空才会结束。我们将从<strong class="ke io">开始</strong>并拜访每一个邻居。我们应该检查它们是否被访问过，如果没有，将它们添加到堆栈中。然后，我们将它们的“已访问”值设置为<strong class="ke io"> true </strong>，这样我们就不会返回。最后，当循环重新开始时，我们应该在堆栈中有一个新的顶点来重复这个过程。</p><pre class="la lb lc ld gt nb nc nd ne aw nf bi"><span id="c789" class="ng lq in nc b gy nh ni l nj nk">while(stack.length) {<br/>    currentElement = stack.pop();<br/>    result.push(currentElement);</span><span id="59ca" class="ng lq in nc b gy nl ni l nj nk">    this.adjacencyList[currentElement].forEach(neighbor =&gt; {<br/>        if (!visited[neighbor]) {<br/>            visited[neighbor] = true;<br/>            stack.push(neighbor);<br/>        }<br/>    })<br/>}</span><span id="fba6" class="ng lq in nc b gy nl ni l nj nk">return result;</span></pre><p id="04dd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！循环的每次迭代从堆栈中弹出一个元素，并将其添加到我们的结果数组中。然后，我们查看该元素的邻接数组中的每个邻居，如果它是未访问的，它将被设置为已访问并添加到堆栈中。如果每个邻居都被访问过，循环将跳过并弹出堆栈中的另一个元素。最终，每个元素都将被访问，堆栈将为空，结束循环，我们返回我们的<strong class="ke io">结果</strong>数组。</p><p id="f57d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我们到目前为止一起展示的所有东西:</p><div class="la lb lc ld gt ab cb"><figure class="nm le nn no np nq nr paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><img src="../Images/ea4c81ca751cf33d517996e076a24a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*XZA6eikaHGoiCdVC9goM2A.png"/></div></figure><figure class="nm le ns no np nq nr paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><img src="../Images/f30db1ab5076e0e7943e03d30651b85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*MvHnummv2uzRBA0HTjikqA.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk nt di nu nv">Graph construction, add/remove, and traversal</figcaption></figure></div><h1 id="1567" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">加权图</h1><p id="e312" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">就像优先级队列和二进制堆一样，从无权重图到有权重图的跨越并不是一件难事。唯一改变的是，每个顶点不再是一个值，而是一个包含值和权重的对象。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nw"><img src="../Images/370d33f77274efdba6fc79b9782e3f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OppaqOwYq0VJOEWQpkWZ5A.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Weighted Graph</figcaption></figure><p id="b3c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所做的改变是我们的<strong class="ke io"> addEdge() </strong>函数现在接受一个权重，我们将这个权重添加到一个对象中，以推入每个顶点的邻接数组。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/2e853d2ec6f541ba02131f0c46635f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*ETMx32pGeDu1cQCerQBM1Q.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Weighted Graph</figcaption></figure><p id="2270" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我们添加了一些权重的示例图。从<strong class="ke io"> A </strong>到<strong class="ke io"> E </strong>的最短距离是多少？你也许可以很容易地通过一些排列，看到它来自A-C-D-E，但是如果我们的图是由成千上万的顶点和边组成的呢？这就是Dijsktra的用武之地。</p><p id="e2c0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，那将是一个完全不同的博客。加入我的下一部分，我们最终解决Dijkstra的算法。一如既往，如果你有任何问题，请留言。</p><p id="d53e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读和快乐编码！</p><p id="3a08" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nx">更多内容请看</em><a class="ae ky" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>