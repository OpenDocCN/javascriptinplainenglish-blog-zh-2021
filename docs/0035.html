<html>
<head>
<title>What Will WebAssembly Change on the Web?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebAssembly在Web上会有什么变化？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/webassembly-javascript-b3eefb1f0228?source=collection_archive---------9-----------------------#2021-01-03">https://javascript.plainenglish.io/webassembly-javascript-b3eefb1f0228?source=collection_archive---------9-----------------------#2021-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1fab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">机会、用例&amp;这对我们热爱的JavaScript意味着什么</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/dd5f09072dfbf2a90d556823ab533e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxDfGjirrjAeu83ql-7iog.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Photo by <a class="ae kr" href="https://unsplash.com/@spanic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Damir Spanic</a> on <a class="ae kr" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>, edited by the author</figcaption></figure><p id="8ecf" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">WebAssembly在这里。并且它在实践中是有用的。像Figma这样的公司已经在生产中应用它了。</p><p id="98e0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是这对JavaScript意味着什么呢？WebAssembly目前能做什么？又有哪些大的机会？</p><p id="9300" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可以在这里找到答案，玩得开心！</p><h1 id="8df7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">流行框架的巨大机遇</h1><p id="c9a6" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">当一项新技术出现时，它通常会引起对旧技术的存在性恐惧。但是不要担心——web assembly肯定不会取代我们心爱的框架，比如React(是的，它是一个库，但你明白这一点)、Vue和Angular。事实是，他们可以从WebAssembly中受益匪浅。</p><p id="0240" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们以React.js为例来看看这一点。当想到与WebAssembly结合的React时，一件事浮现在脑海中:用WebAssembly编写组件。也许有一天。我要提前说一声——不，可能不会是这样。以下是更有可能发生的情况。</p><p id="184a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在React中，有一种东西我们称之为<strong class="ku ir">和解</strong>。Angular和Vue也有类似的地方。底层算法确保DOM中的元素可靠地更新，并且只在需要时更新。我们可以用一个点击事件来改变状态，受影响的部分被更新——这是所有框架都熟悉的机制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/39afc0509276358d23c7964d91fae08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/1*2vfPDSWRCro_f0NE1HfMZw.gif"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Source: the author</figcaption></figure><p id="a13e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面是它的简化工作方式。当呈现页面时，React.js创建一个元素树。这棵树被放在DOM中——用户看到了一些东西。如果状态或道具发生变化，它们会被再次渲染，从而创建一个新的树。现在，我们有两棵树。</p><p id="ef31" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">移除DOM中的元素并重新呈现它们非常耗时。因此，React.js试图尽可能精确地找出这两棵树的不同之处。通过这种方式，可以在大树中更新单个元素——因为，毕竟，替换一整棵树是很紧张的。</p><p id="bf56" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你肯定会问自己，这些比较是否也非常昂贵？是的，他们是。如果该算法不使用启发式(表面简化)，它将具有O(n)的大O复杂度。</p><p id="c443" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着，对于1000个元素，要进行10亿次比较。</p><p id="2d52" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">感谢上帝，算法没有以这种方式实现——但仍然有大量的工作要做。WebAssembly开始发挥作用了。</p><p id="4030" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">WebAssembly为框架带来了巨大的潜在机会。通过外包复杂的算法获得更好的性能——在使用框架时，我们不会注意到很大的不同。巨大的计算工作量可以通过WebAssembly更快地完成。</p><p id="bbfd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过JavaScript，字节码可以在正确的地方流动。因此，框架代码的JS样板文件可以保留。单个任务交给WebAssembly。</p><p id="a84a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">用C ++或C写组件——可能没人想这么做。<br/>如果只外包计算密集型任务，我们可以继续用JavaScript编写组件。</p><h2 id="7066" class="mm lp iq bd lq mn mo dn lu mp mq dp ly lb mr ms ma lf mt mu mc lj mv mw me mx bi translated">普通JS与框架的新视角</h2><p id="a80e" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">使用框架非常有趣。尽管这基本上是过度杀戮。是的，DOM操作的抽象和大量的代码包绝对是一个性能限制。因此，在许多情况下，只依赖普通的JS是有意义的——特别是对于简单的应用程序。</p><p id="7106" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有了框架引擎中的WebAssembly，可能会有显著的性能提升。由于字节码只是内置的，所以在用框架编写代码时，一切都可能保持不变。</p><p id="0f6b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">与WebAssembly一样，流传输相应字节码的可能性也可以为初始加载和执行带来性能提升。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="a2fa" class="lo lp iq bd lq lr nf lt lu lv ng lx ly jw nh jx ma jz ni ka mc kc nj kd me mf bi translated">前端如此，后端也是如此</h1><p id="f177" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Node已经相当快了。然而，一些模块被写成所谓的<strong class="ku ir">本地模块</strong>。原生模块通常用C++和C编写。这两种语言是性能的同义词，这就是为什么它们被用于在Node.js中实现计算密集型的东西。</p><p id="468a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是写一个原生模块并不好玩。任何看过Node.js文档的人都知道这是一项复杂的工作。<br/> WebAssembly可能会有所帮助。这些模块的代码可以被编译成字节码，从而直接执行。</p><p id="9644" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">目前，WebAssembly只缺乏访问系统的能力。在Node.js世界中，文件系统和对套接字和HTTP的访问是有意义的。</p><p id="6f7c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">后端WebAssembly的好处是我们不必太担心兼容性。虽然在不同的浏览器中处理WASM仍然有所不同，但是我们可以从Node.js开始</p><p id="cabe" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你想在Node.js中试用WebAssembly，可以在这里找到教程<a class="ae kr" href="https://medium.com/javascript-in-plain-english/assemblyscript-4c68a3c3ecf7" rel="noopener">。</a></p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="d22e" class="lo lp iq bd lq lr nf lt lu lv ng lx ly jw nh jx ma jz ni ka mc kc nj kd me mf bi translated">保持简单愚蠢</h1><p id="fbf1" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">是的，JavaScript是一个迷因。不幸的是，网络开发者有时会被取笑。JavaScript甚至不是一种像样的编程语言。对于曾经用C++、Rust或Java编写过<em class="nk"> Hello World </em>的人来说，取笑网络语言似乎是礼貌的一部分。</p><p id="1fd7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">即使JavaScript没有其他语言的复杂，但它表明了一件事——简单有时是最好的。</p><p id="267f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">对于大多数web应用程序，JavaScript已经足够了。复杂对象、函数重载和指针通常是多余的。</p><p id="aef0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">与其他编程语言相比，我们通常更擅长使用JavaScript。一旦从JS切换到C++或Java之类的语言，您会立即注意到您有更多的东西要写。</p><p id="6ae0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Web汇编代码最终是用不太高级的语言编写的。C++，C还有Rust和Golang都比较流行。在使用我用C代码生成的WebAssembly时，我注意到一件事:在95%的情况下，使用WebAssembly不会给应用程序带来性能优势。</p><p id="fb60" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">对于下拉菜单、表单、后端请求和JavaScript的许多其他用例，web组装是不值得的。</p><p id="3995" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">相反，设置和编写代码要复杂得多。WebAssembly已经被用于渲染2D画布或3D动画。例如，Figma依赖于WebAssembly。然而，对于互联网上的大多数网站来说，这完全是矫枉过正。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="d46a" class="lo lp iq bd lq lr nf lt lu lv ng lx ly jw nh jx ma jz ni ka mc kc nj kd me mf bi translated">你无法越过JavaScript——至少现在还不行</h1><p id="1a8d" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">WebAssembly非常强大，但是有一点它还不能做到:独立访问DOM。JavaScript仍然必须用于此。</p><p id="0e42" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们还需要一个JavaScript API来运行WebAssembly。</p><p id="1918" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因此，直接访问DOM是不可能的，只能间接访问。我们可以从JavaScript调用web组装方法，反之亦然。</p><p id="2d51" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">缺少DOM访问让许多对WebAssembly感兴趣的人感到失望。但是有计划可以通过WASM直接访问网络应用编程接口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/9f0bb494046d542e106c53c30970d76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5K2eKIQHhgC1qthL-nu-OA.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Source: <a class="ae kr" href="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts" rel="noopener ugc nofollow" target="_blank">developer.mozilla.org</a></figcaption></figure><p id="8c85" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">本质上，WebAssembly旨在接管JavaScript的大型计算任务。然而，可能的DOM访问会发生很大的变化。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="f7ce" class="lo lp iq bd lq lr nf lt lu lv ng lx ly jw nh jx ma jz ni ka mc kc nj kd me mf bi translated">总结</h1><p id="2d22" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">WebAssembly已经存在。但是它还没有取代JavaScript。</p><p id="a9f1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当然，它将在某些地方取代JS代码，但是如果没有JS，它可能永远不会完全工作。在我看来，这不是坏消息。</p><p id="d65f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为JavaScript通常正是我们在网络上需要的。在95%的网站上，网页组装并不是一个可行的选择。到目前为止，它主要用于2D和3D应用。</p><p id="d04d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">用Node.js或React、Vue和Angular等框架编写JS代码可能仍将是标准。唯一的区别可能是，WebAssembly随后会在幕后接管计算密集型算法。</p><p id="9a3e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我个人对此感到非常兴奋。复杂应用程序在浏览器中可用的趋势可能会更加强劲。</p><p id="6155" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">感谢您的阅读——如果您想试用WebAssembly，请查看:</p><div class="nq nr gp gr ns nt"><a href="https://medium.com/javascript-in-plain-english/assemblyscript-4c68a3c3ecf7" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">Testosterones上的TypeScript什么是AssemblyScript？</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">轻松开始使用WebAssembly</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh kl nt"/></div></div></a></div><h2 id="1bd3" class="mm lp iq bd lq mn mo dn lu mp mq dp ly lb mr ms ma lf mt mu mc lj mv mw me mx bi translated"><a class="ae kr" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank">加入我的免费简讯，了解最新消息</a></h2></div></div>    
</body>
</html>