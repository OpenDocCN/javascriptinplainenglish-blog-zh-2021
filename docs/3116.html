<html>
<head>
<title>Making a Web-Based Flappy Bird Clone with p5.js | Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用p5.js制作基于Web的Flappy Bird克隆体|第2部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/making-a-web-based-flappy-bird-clone-with-p5-js-part-2-c554254881b1?source=collection_archive---------14-----------------------#2021-06-24">https://javascript.plainenglish.io/making-a-web-based-flappy-bird-clone-with-p5-js-part-2-c554254881b1?source=collection_archive---------14-----------------------#2021-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/76f346c8e4d0ec32b885df850db8c5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*V35iN2RCMU_pOcLX8xK9mA.png"/></div></figure><h2 id="3138" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">概述</h2><p id="c0f9" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">这是系列教程的第2部分，我将带您了解如何使用p5.js制作flappy bird克隆体。在第1部分中，我介绍了p5.js的基本概念，并向您展示了如何将背景对象渲染到p5.js画布中。如果您尚未完成第1部分<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-web-based-flappy-bird-clone-with-p5-js-part-1-2913fde25c8a">,您可以在此处</a>找到它。如果你是来继续的，那我们就开始吧。</p><h2 id="9496" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">地面物体——假装无限</h2><p id="8bcd" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">首先，让我们来看看地面物体。在Flappy Bird中，地面实际上是水平向后移动的物体，这就造成了鸟向前飞的错觉。现在棘手的部分是如何让地面看起来可以无限延伸。</p><p id="3a5d" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">让我们想想我们能做这件事的所有方法。我们真的可以有一个穿过屏幕的无限大的地面吗？嗯，也许吧，但是你需要一个非常长的图像。可以想象，一个无限长的图像在任何游戏中都不是很实用。那么我们如何让一个有限的物体无限地走下去呢？我们实际上不需要太多，因为我们在第1部分中定义的框架不是无限的，我们可以隐藏框架外发生的事情。</p><p id="6570" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">第一种我们可以伪造无限的方法是我们可以从两个地面物体开始，它们都和画布一样宽。第一个完全在屏幕上开始，第二个在屏幕外紧挨着第一个。然后我们可以开始移动地面，直到第二个完全适合屏幕，第一个离开屏幕。然后，我们可以删除第一个，然后在第二个后面的屏幕上添加一个新的，然后无限重复。</p><figure class="lo lp lq lr gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4480" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">这很好，但我们可以做得更好。想想看，我们真的需要去掉第一个吗？那是一大堆我懒得做的烦人的数组操作。我们能不能只让第一个一过屏幕就出现在后面？你当然可以，这正是我们要做的。</p><figure class="lo lp lq lr gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="241a" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">创建一个名为Ground.js的新文件，不要忘记将脚本包含在HTML文件中——在索引脚本之前。</p><p id="554b" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">在index.js中，让我们定义GROUND_HEIGHT全局变量，因为我们将在其他几个地方使用该变量。我们还将在预加载函数中加载地面图像——在本例中，我将其定义为BASE_IMG。</p><pre class="lo lp lq lr gt lu lv lw lx aw ly bi"><span id="b613" class="jr js in lv b gy lz ma l mb mc">// index.js<br/>const WIN_WIDTH = 400;<br/>const WIN_HEIGHT = WIN_WIDTH * 1.62;<br/>const GROUND_HEIGHT = 110;</span><span id="9ec9" class="jr js in lv b gy md ma l mb mc">let BG_IMG;<br/>let BASE_IMG;</span><span id="5d6b" class="jr js in lv b gy md ma l mb mc">function preload() {<br/> BG_IMG = loadImage("assets/bg.png");<br/> BASE_IMG = loadImage("assets/base.png");<br/>}</span></pre><p id="0111" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">现在要制作实际的地面对象，在Ground.js中如下定义该对象:</p><pre class="lo lp lq lr gt lu lv lw lx aw ly bi"><span id="37fc" class="jr js in lv b gy lz ma l mb mc">// Ground.js</span><span id="d1db" class="jr js in lv b gy md ma l mb mc">function Ground() {<br/> this.velocity = 5;<br/> this.x1 = 0;<br/> this.x2 = width; <br/> this.y = height — GROUND_HEIGHT;<br/>// width and height references the canvas's dimension provided my p5</span><span id="4494" class="jr js in lv b gy md ma l mb mc">this.update = () =&gt; {<br/> this.x1 -= this.velocity;<br/> this.x2 -= this.velocity;<br/> if (this.x1 &lt;= -width) {<br/>  this.x1 = width;<br/> }<br/> if (this.x2 &lt;= -width) {<br/>  this.x2 = width;<br/> }<br/> };</span><span id="2b50" class="jr js in lv b gy md ma l mb mc">this.show = () =&gt; {<br/> // Just as before, we must explicitly tell p5 to render the ground object <br/> image(BASE_IMG, this.x1, this.y, width, BASE_IMG.height);<br/> image(BASE_IMG, this.x2, this.y, width, BASE_IMG.height);<br/> };<br/>}</span></pre><p id="2b1c" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">地面的y属性(或垂直位置)是画布的高度减去地面的高度。这是因为p5定义了一个坐标系统，其中y位置越大，物体越低——我知道这有点奇怪。还应该注意，x位置越大，对象在画布上就越靠右。</p><p id="6f8c" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">在show函数中，通过调用p5提供的image函数来渲染地面。这里，我们同时显示两幅图像。正如你可能看到的，从我们调用函数的方式，只有每个对象的x位置被更新，而所有其他变量保持不变。</p><p id="3c1b" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">在update函数中——它也将在每个渲染周期运行——通过减去一个我们称为velocity的变量来更新x位置。请注意，速度不一定是5，只是根据我自己的实验，我认为5似乎是一个很好的速度，但你当然可以通过改变这个变量来进行自己的实验。有趣的逻辑是，如果一个地面对象完全离开了屏幕，我们只需通过将x位置设置为等于屏幕的宽度来使它更新回屏幕的另一侧。</p><pre class="lo lp lq lr gt lu lv lw lx aw ly bi"><span id="3dff" class="jr js in lv b gy lz ma l mb mc">// index.js</span><span id="d5ae" class="jr js in lv b gy md ma l mb mc">...</span><span id="4edf" class="jr js in lv b gy md ma l mb mc">let BG_IMG;<br/>let BASE_IMG;</span><span id="5fd9" class="jr js in lv b gy md ma l mb mc">let ground; //the global ground variable</span><span id="074c" class="jr js in lv b gy md ma l mb mc">function preload() {<br/> BG_IMG = loadImage("assets/bg.png");<br/> BASE_IMG = loadImage("assets/base.png");<br/>}</span><span id="5ca8" class="jr js in lv b gy md ma l mb mc">function setup() {<br/> createCanvas(WIN_WIDTH, WIN_HEIGHT);<br/> ground = new Ground(); // Initialize the new ground here<br/>}</span><span id="2953" class="jr js in lv b gy md ma l mb mc">function draw() {<br/> background(BG_IMG);</span><span id="8142" class="jr js in lv b gy md ma l mb mc"> ground.update(); <br/> ground.show();<br/>}</span></pre><figure class="lo lp lq lr gt jo"><div class="bz fp l di"><div class="me lt l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">What you should have now</figcaption></figure><h2 id="e0f8" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">管道物体——假装无限的另一种方式</h2><p id="f894" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">现在让我们移动到管道对象。同样，在这里我们也想假装无穷大，因为只要游戏没有结束，管道就会一直出现。当然，我们可以使用与地面类似的策略。然而，在这里，我们将在不同的高度初始化管道，以使游戏更有趣，所以让我们使用前面讨论的第一个策略，当管道移出屏幕时，我们将立即删除管道，并将一个“新”管道添加到我们的管道数组中。</p><pre class="lo lp lq lr gt lu lv lw lx aw ly bi"><span id="7cc0" class="jr js in lv b gy lz ma l mb mc">// Pipe.js<br/>function Pipe() {<br/> this.SCALE = 1.75;<br/> this.velocity = 5; //velocity should be the same as the ground<br/> this.gap = 200; // distance between the top and bottom pipe</span><span id="c2ed" class="jr js in lv b gy md ma l mb mc"> this.x = width;<br/> this.y = random(200, 400); <br/> <br/>//The height that the pipe will have should be random and it's x position will start out from the right of the screen</span><span id="a343" class="jr js in lv b gy md ma l mb mc"> this.scaledWidth = this.SCALE * PIPE_UP_IMG.width;<br/> this.scaledHeight = this.SCALE * PIPE_UP_IMG.height;</span><span id="9455" class="jr js in lv b gy md ma l mb mc"> this.topPosition = this.y — this.scaledHeight — this.gap;</span><span id="88d7" class="jr js in lv b gy md ma l mb mc"> this.show = () =&gt; {<br/>  image(PIPE_UP_IMG, this.x, this.y, this.scaledWidth, this.scaledHeight);<br/> <br/>  image(PIPE_DOWN_IMG, this.x, this.topPosition, this.scaledWidth, this.scaledHeight);<br/> };</span><span id="28e9" class="jr js in lv b gy md ma l mb mc"> this.update = () =&gt; {<br/>  this.x = this.x — this.velocity;<br/> };</span><span id="b384" class="jr js in lv b gy md ma l mb mc"> this.isOff = () =&gt; {<br/>  return this.x &lt; -this.scaledWidth;<br/> };<br/>}</span></pre><p id="a168" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">在Pipe.js中，我们包含了更新单个管道对象的逻辑。show函数只显示顶部和底部管道，而update方法只是将管道向左移动速度量。最后，我们定义一个isOff方法来告诉我们这个特定的管道是否已经移动到屏幕左侧。</p><p id="cc2c" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">现在我们已经封装了一个管道的逻辑，接下来我们可以展示多个管道。在这个特殊的例子中，我在索引文件中编写了这个逻辑，但是您可以将这个相同的逻辑提取到一个名为Pipes.js之类的单独文件中。</p><pre class="lo lp lq lr gt lu lv lw lx aw ly bi"><span id="8330" class="jr js in lv b gy lz ma l mb mc">// index.js</span><span id="dc4a" class="jr js in lv b gy md ma l mb mc">...<br/>let PIPE_UP_IMG;<br/>let PIPE_DOWN_IMG;</span><span id="cea4" class="jr js in lv b gy md ma l mb mc">let ground; //the global ground variable<br/>pipes = []; // the global pipes array</span><span id="126b" class="jr js in lv b gy md ma l mb mc">function preload() {<br/> ...<br/> PIPE_UP_IMG = loadImage("assets/pipeUp.png");<br/> PIPE_DOWN_IMG = loadImage("assets/pipeDown.png");<br/>}</span><span id="8d7a" class="jr js in lv b gy md ma l mb mc">function setup() {<br/> createCanvas(WIN_WIDTH, WIN_HEIGHT).touchStarted(jumpEvent);<br/> ground = new Ground(); // Initialize the new ground here<br/>}</span><span id="f281" class="jr js in lv b gy md ma l mb mc">function draw() {<br/> background(BG_IMG);</span><span id="c451" class="jr js in lv b gy md ma l mb mc"> pipesUpdate() <br/> pipes.forEach(pipe =&gt; pipe.show()) <br/> //pipes must be shown before the ground so that the ground is rendered on top of the pipe</span><span id="e3a2" class="jr js in lv b gy md ma l mb mc"> ground.update(); <br/> ground.show();<br/>}</span><span id="0853" class="jr js in lv b gy md ma l mb mc">function pipesUpdate() {<br/> if (frameCount % 60 === 0) {<br/>  const pipe = new Pipe();<br/>  pipes.push(pipe);<br/> }</span><span id="c09a" class="jr js in lv b gy md ma l mb mc"> pipes.forEach((pipe, idx) =&gt; {<br/>  pipe.update();<br/>  if (pipe.isOff()) {<br/>   pipes.splice(idx, 1);<br/>  }<br/>}</span></pre><p id="fe86" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated">在pipesUpdate函数中，您可以看到if语句，其中我向数组添加了一个新管道。frameCount是一个p5对象，它跟踪从画布初始化开始已经渲染了多少帧。这只是一种让添加新管道的时间间隔保持不变的方式，60帧的倍数似乎对我来说最合适，但是您可以尝试这个值</p><figure class="lo lp lq lr gt jo"><div class="bz fp l di"><div class="mj lt l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Now we should have this</figcaption></figure><h2 id="7a07" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">未完待续…</h2><p id="a6e3" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">好的，接下来是鸟本身，这将比我们在这里做的要复杂一些。你可以在这里找到第三部<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/making-a-web-based-flappy-bird-clone-with-p5-js-part-3-32d4e96b8737"/>。</p><p id="366a" class="pw-post-body-paragraph kn ko in kp b kq lj ks kt ku lk kw kx ka ll kz la ke lm lc ld ki ln lf lg lh ig bi translated"><em class="mk">更多内容尽在</em><a class="ae li" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kp io"><em class="mk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>