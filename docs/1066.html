<html>
<head>
<title>Stop using margin, use Spacer component instead!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用边距，改用间隔组件！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-using-margin-use-spacer-component-instead-953d9b2dbacc?source=collection_archive---------0-----------------------#2021-03-06">https://javascript.plainenglish.io/stop-using-margin-use-spacer-component-instead-953d9b2dbacc?source=collection_archive---------0-----------------------#2021-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="90a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中处理组件间距的更好方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8104f3e0c6ca708a0e0a22550f661d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXyAVPhi4IOe8eGepv32rg.png"/></div></div></figure><p id="da2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在为UI布局编码时，我们需要一些东西来表示元素之间的间距，是的，我们已经使用<code class="fe ln lo lp lq b">margin</code>很长时间了。</p><p id="144c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，当使用像<code class="fe ln lo lp lq b">React</code>这样的基于组件的框架时，我们可能需要重新考虑<code class="fe ln lo lp lq b">margin</code>是否仍然是最好的选择。</p><p id="38e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是我的想法:</p><h1 id="b1fc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">保证金的问题</h1><p id="7cf7" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">首先，我会说在组件的顶层使用<code class="fe ln lo lp lq b">margin</code>不好，因为它打破了组件的隔离。</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="9e81" class="ms ls iq lq b gy mt mu l mv mw">// A React component with margin set on top-level<br/>const MyComponent = () =&gt; {<br/>  return &lt;div style="margin: 1rem"&gt;...&lt;/div&gt;;<br/>};</span></pre><ul class=""><li id="a3aa" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">这里的<code class="fe ln lo lp lq b">margin</code>不仅影响组件本身，还影响其他组件<strong class="kt ir"/>(例如，它正在推离旁边的另一个组件/元素)</li><li id="becf" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">如果我们想把这个组件放在不同的上下文或布局中，<code class="fe ln lo lp lq b">margin</code>会妨碍resuse</li></ul><p id="396b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，在组件内部使用<code class="fe ln lo lp lq b">margin</code>怎么样(不在顶层)？乍一看，这似乎很好，但是当您出于某种原因(例如，重用/隔离/简化/性能)提取现有组件的一部分来组装一个新组件时，它会将我们再次带回到在顶层使用<code class="fe ln lo lp lq b">margin</code>的问题:(</p><p id="d314" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">解决方案:垫片组件</strong></p><p id="a4d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与其将组件或元素之间的空白空间视为<strong class="kt ir">边距</strong>，不如假设它们实际上是<strong class="kt ir">组件</strong>——专门用来表示空白空间的组件，我们可以称之为<code class="fe ln lo lp lq b">Spacer</code>。</p><p id="444e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于UI编程来说，这并不是全新的东西，而是已经在许多UI框架中广泛使用的东西(尤其是在移动设备上):</p><ul class=""><li id="ff28" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated"><a class="ae nl" href="https://benmcmahen.com/using-spacer-in-swiftui/" rel="noopener ugc nofollow" target="_blank">iOS中的间隔符(SwiftUI) </a></li><li id="abf6" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae nl" href="https://developer.android.com/jetpack/compose/tutorial" rel="noopener ugc nofollow" target="_blank">安卓中的间隔(Jetpack Compose) </a></li><li id="4e9e" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae nl" href="https://api.flutter.dev/flutter/widgets/Spacer-class.html" rel="noopener ugc nofollow" target="_blank">颤振中的垫片</a></li></ul><p id="0e59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么不为Web / React开发一个呢？我们来了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b2ed0ea097d9952b260205259f1c7e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*gDP3PsLEssoWZKE2LbJDCg.png"/></div></figure><p id="4c45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们将间距抽象为一个确定的组件，我们就不会有使用<code class="fe ln lo lp lq b">margin</code>破坏隔离的问题！所有组件都不需要关心它们周围所需的间距——父组件将通过使用<code class="fe ln lo lp lq b">Spacer</code>组件来处理这些，这使得每个组件都是真正独立的和可重用的。</p><p id="c4dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个简单的例子是使用<code class="fe ln lo lp lq b">Spacer</code>来表示文章各部分之间的垂直间距:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="29be" class="ms ls iq lq b gy mt mu l mv mw">&lt;Article&gt;<br/>    &lt;Header /&gt;<br/>    &lt;Spacer y={2} /&gt;<br/>    &lt;Section1 /&gt;<br/>    &lt;Spacer y={1} /&gt;<br/>    &lt;Section2 /&gt;<br/>    &lt;Spacer y={2} /&gt;<br/>    &lt;Footer /&gt;<br/>&lt;/Article&gt;</span></pre><p id="3693" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组件<code class="fe ln lo lp lq b">Spacer</code>的一个可能实现(基于Material-UI的样式化系统)可能是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Spacer component based on the styled system of Material-UI</figcaption></figure><p id="3a6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">也就是说，您可以将<code class="fe ln lo lp lq b">width</code>、<code class="fe ln lo lp lq b">height</code>或<code class="fe ln lo lp lq b">flexBasis</code>指定为要乘以<code class="fe ln lo lp lq b">theme.spacing</code>的值(与<code class="fe ln lo lp lq b">Box</code>的其他间隔道具相同)</p><p id="623c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">更进一步:在内部使用垫片布局组件</strong></p><p id="4ffa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有很多机会，我们可能希望使组件/元素之间的间距均匀，并且用相同的<code class="fe ln lo lp lq b">props</code>放入许多<code class="fe ln lo lp lq b">Spacer</code>组件是不优雅的。在这种情况下，容器组件肯定会有所帮助。</p><p id="38ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我们可能有一个<code class="fe ln lo lp lq b">Flexbox</code>组件作为容器，它接受一个间隔属性来配置插入到其子项之间的<code class="fe ln lo lp lq b">Spacer</code>组件(其他一些文章可能会将其改写为<code class="fe ln lo lp lq b">Stack</code>组件)。</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="526d" class="ms ls iq lq b gy mt mu l mv mw">&lt;Article&gt;<br/>  &lt;Flexbox flexDirection="column" spacing={1}&gt;<br/>    &lt;Header /&gt;<br/>    &lt;MainContent1 /&gt;<br/>    &lt;MainContent2 /&gt;<br/>    &lt;Footer /&gt;<br/>  &lt;/Flexbox&gt;<br/>&lt;/Article&gt;</span></pre><p id="d950" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组件<code class="fe ln lo lp lq b">Flexbox</code>的一个可能实现(基于Material-UI的样式化系统)可能是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Flexbox component based on the styled system of Material-UI</figcaption></figure><p id="0a4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">奖励:flexbox中的动态间距</strong></p><p id="85a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了使组件独立和可重用之外，<code class="fe ln lo lp lq b">Spacer</code>组件还为我们带来了一个从<code class="fe ln lo lp lq b">margin</code>中无法轻易获得的好处flexbox中的动态间距。</p><p id="0edd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是将空间转化为组件的自然结果——我们现在可以将它们视为flexbox项目，它们可以<code class="fe ln lo lp lq b">grow</code>和<code class="fe ln lo lp lq b">shrink</code>！</p><p id="3b17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，假设我们有下面的布局(图中的数字表示盒子的宽度):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b667f68ed9dfc539fd900cd36d39d6b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*TsDWHwh8AGp8P2rCISMILQ.png"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Original layout</figcaption></figure><p id="fb65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定条件:</p><ul class=""><li id="6d16" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">两个左侧项目的宽度是固定的</li><li id="e890" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">可以收缩正确的项目和间距</li><li id="e051" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">我们希望在调整容器大小时，间距缩小的速度比正确的项目快两倍。</li></ul><p id="4d46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很容易得到这样的结果:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="2554" class="ms ls iq lq b gy mt mu l mv mw">&lt;Flexbox&gt;<br/>  &lt;Box flexBasis={100} flexShrink={0} /&gt;<br/>  &lt;Box flexBasis={100} flexShrink={0} /&gt;<br/>  &lt;Spacer flexBasis={200} flexShrink={2} /&gt;<br/>  &lt;Box flexBasis={200} flexShrink={1} /&gt;<br/>&lt;/Flexbox&gt;</span></pre><p id="8da9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">据此，当右侧<code class="fe ln lo lp lq b">Box</code>收缩到150时，<code class="fe ln lo lp lq b">Spacer</code>也会收缩到100。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5ae186bc7d13326b6f57c118212296ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*x3hrdK0lVUjKVZU14_WT7g.png"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">Shrinked layout</figcaption></figure><h1 id="a88b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated"><strong class="ak">结论</strong></h1><p id="5f22" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">让我们停止使用<code class="fe ln lo lp lq b">margin</code>！</p><p id="d8c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它打破了组件的隔离，使它们更难在不同的上下文中重用。</p><p id="6955" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">Spacer</code>组件和基于它的布局组件(如<code class="fe ln lo lp lq b">Flexbox</code> / <code class="fe ln lo lp lq b">Stack</code>)将解决这些问题，当您希望在间距上有更大的灵活性时，它们可以带来额外的好处！</p><h1 id="00e6" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">原始帖子后的更新</h1><ol class=""><li id="fc64" class="mx my iq kt b ku mj kx mk la nv le nw li nx lm ny nd ne nf bi translated"><a class="ae nl" href="https://css-tricks.com/almanac/properties/g/gap/" rel="noopener ugc nofollow" target="_blank"> Flexbox现在有了一个</a> <code class="fe ln lo lp lq b"><a class="ae nl" href="https://css-tricks.com/almanac/properties/g/gap/" rel="noopener ugc nofollow" target="_blank">gap</a></code> <a class="ae nl" href="https://css-tricks.com/almanac/properties/g/gap/" rel="noopener ugc nofollow" target="_blank">属性来定义其子元素</a>之间的间距，但是目前还不是所有主流浏览器都支持(没有IE，没有Safari &lt; 14.1)。一旦它被现代浏览器和用户广泛采用，在大多数用例中使用<code class="fe ln lo lp lq b">gap</code>和<code class="fe ln lo lp lq b">flexbox</code>应该是推荐的解决方案。<br/>(提示:如果您使用<code class="fe ln lo lp lq b">Flexbox</code>组件方法，那么将来从<code class="fe ln lo lp lq b">&lt;Spacer/&gt;</code>切换到<code class="fe ln lo lp lq b">gap</code>应该很容易，因为这只是内部实现的变化，当您有额外和/或特殊的需求来表示组件之间的间距时，<code class="fe ln lo lp lq b">&lt;Spacer /&gt;</code>仍然有用)</li><li id="1d9c" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm ny nd ne nf bi translated">关于性能，无论是否使用空的div元素，避免长列表项的性能问题的基本方法是虚拟化(或“在窗口中呈现”)——如果不虚拟化，长列表会损害性能；如果您确实进行了虚拟化，那么为什么要在一个简短的列表中增加几个DOM元素呢？</li></ol><h1 id="fc4c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">相关文章</h1><ul class=""><li id="e362" class="mx my iq kt b ku mj kx mk la nv le nw li nx lm nc nd ne nf bi translated"><a class="ae nl" href="https://mxstbr.com/thoughts/margin/" rel="noopener ugc nofollow" target="_blank">被认为有害的余量</a>(作者<a class="ae nl" href="https://mxstbr.com/" rel="noopener ugc nofollow" target="_blank">马克斯·斯托伊伯</a>，styled-component的合著者)</li><li id="ed84" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae nl" href="https://www.coryetzkorn.com/blog/dont-fear-empty-divs/" rel="noopener ugc nofollow" target="_blank">不要害怕空壳</a>(科里·埃茨科恩)</li><li id="8cba" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae nl" href="https://ishadeed.com/article/spacing-in-css/#spacer-components" rel="noopener ugc nofollow" target="_blank">CSS中的间距</a>(Ahmad Shadeed)</li><li id="91f3" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae nl" href="https://visly.app/blogposts/layout-isolated-components" rel="noopener ugc nofollow" target="_blank">布局-隔离组件</a>(埃米尔·舍兰德)</li><li id="f3a6" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">处理UI组件库中的间距(Chris Pearce)</li></ul></div></div>    
</body>
</html>