<html>
<head>
<title>Common JavaScript Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的JavaScript面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/common-javascript-interview-questions-8af095ed24f0?source=collection_archive---------9-----------------------#2021-05-28">https://javascript.plainenglish.io/common-javascript-interview-questions-8af095ed24f0?source=collection_archive---------9-----------------------#2021-05-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/0a1735503215afbad5bc2254544ab177.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*8AcIyzgCiPl6P7-nKGLOGw.png"/></div></figure><h2 id="e2d6" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问:作用域、闭包和回调是如何一起工作的(ES6)？</h2><p id="7572" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated"><strong class="kp io">范围</strong>指的是我们代码中变量的可访问性。范围主要有两种:<strong class="kp io">全局</strong>和<strong class="kp io">局部</strong>。</p><p id="4397" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated"><strong class="kp io">全局作用域的</strong>变量在函数外部用<em class="ln"> var </em>、<em class="ln"> const、</em>或<em class="ln"> let </em>声明，可以从代码中的任何地方访问。JavaScript中只有一个级别的全局范围。</p><p id="5b3b" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated"><strong class="kp io">局部范围</strong>有两级范围:<strong class="kp io">功能</strong>和<strong class="kp io">块</strong>。</p><p id="9ef3" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">每次创建函数时，都会创建一个<strong class="kp io">闭包</strong>。它封装了函数内部的变量，创建了一个<strong class="kp io">局部作用域</strong>，同时允许访问函数外部作用域中的变量。单独声明的函数不能访问另一个函数的作用域。</p><p id="9410" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated"><strong class="kp io">函数级</strong> <strong class="kp io">作用域</strong>变量在函数内用<strong class="kp io"> </strong> <em class="ln"> var </em>声明。该级别中的变量可用于该函数及其任何嵌套函数。</p><p id="a699" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">具有<strong class="kp io">块级范围</strong>的变量只能用<em class="ln"> const </em>或<em class="ln"> let声明。</em>这些变量被限定在创建它们的块(即函数、if语句或循环)范围内，不能在该块之外访问。嵌套的函数和块可以访问它们。</p><p id="0354" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated"><strong class="kp io">回调</strong>是作为参数传递给另一个函数的函数。回调中声明的变量将不能在父函数的作用域(或任何外部作用域)中使用。回调函数可以访问父函数的所有变量。</p><h2 id="e212" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问:var，let，const有什么区别？</h2><p id="acb8" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">你知道会这样，对吗？很长一段时间以来，<em class="ln"> var </em>是JavaScript中声明变量的唯一方式。直到ES6 (ES2015)才推出<em class="ln"> let </em>和<em class="ln"> const </em>。<strong class="kp io">var<em class="ln">var</em>有很多问题，现在认为最好不要使用它— </strong>让我们找出原因。</p><p id="0d04" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">在用<em class="ln"> var </em>声明一个变量之后，JavaScript将允许您通过简单地用另一个值再次声明它来覆盖同一个变量。如果我们用<em class="ln"> let </em>或<em class="ln"> const </em>来尝试，我们会得到一个语法错误。用<em class="ln"> var </em>创建的变量，如果在声明之前被调用，也不会抛出错误，它只是被<em class="ln"> undefined </em>。而用<em class="ln"> const </em>或<em class="ln"> let </em>创建的变量在声明前被调用将抛出引用错误。用<em class="ln"> const </em>或<em class="ln"> let </em>声明的变量被认为是块范围的，只能在创建它们的块内访问。如果在一个块中用<em class="ln"> var </em>声明了一个变量，那么它将可以在父块之外被访问(如果块不运行，该变量将是<em class="ln">未定义的</em>)。</p><p id="972f" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">但是<em class="ln">常量</em>和<em class="ln">常量</em>有什么不同呢？它们在各方面都很相似，除了<em class="ln"> const </em>不允许你在变量创建后重新声明它。你仍然可以改变变量的属性，就像你可以用<em class="ln"> let </em>一样。最佳实践是始终使用<em class="ln">常量</em>，除非您需要重新声明变量的值，然后使用<em class="ln"> let </em>。</p><h2 id="552f" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问:JavaScript是一种单线程、同步编程语言，但也是异步的……这是怎么回事？</h2><p id="4113" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">JavaScript是单线程的，这意味着代码一次只能执行一条语句。这是因为JavaScript只有一个执行代码的调用堆栈，并且必须完成该代码的执行，直到进入下一个。堆栈顶部的代码(一个<a class="ae lo" href="https://www.geeksforgeeks.org/stack-data-structure/" rel="noopener ugc nofollow" target="_blank"> <em class="ln">堆栈</em> </a>数据结构)将首先运行，直到堆栈为空。如果一段代码运行了很长时间，就说它阻塞了堆栈，阻止它继续运行下一段代码。阻塞堆栈将冻结页面的加载，直到代码完成并且堆栈继续运行。这赋予了JavaScript同步的特性。</p><p id="5913" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">JavaScript也有异步能力，这是由运行它的浏览器中的引擎赋予的。使用像fetch这样的Web APIs，或者最近的<a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> promises </a>，我们可以在后台运行任务，而我们的调用栈仍然是一次执行一段代码。当一段异步(async)代码运行时，它实际上被发送到一个单独的容器，在那里它可以做一些工作(例如，一个获取数据的HTTP请求)，然后进入一个单独的回调队列(一个<a class="ae lo" href="https://www.geeksforgeeks.org/queue-data-structure/" rel="noopener ugc nofollow" target="_blank"> <em class="ln">队列</em> </a>数据结构)，一旦所有的同步JavaScript都已运行，它将在那里等待进入调用堆栈。然后可以将数据加载到页面上。这可以防止代码工作时调用堆栈被阻塞。<em class="ln">进一步阅读，参见我的文章:</em><a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/what-is-the-javascript-event-loop-84d21ef276ee"><em class="ln">JavaScript事件循环如何工作</em> </a> <em class="ln">。</em></p><h2 id="e4e6" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问:函数声明和函数表达式有什么区别？</h2><p id="371a" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">当声明一个JavaScript函数时，使用<em class="ln">函数</em>语法(类似于声明一个变量时如何使用<em class="ln"> const </em>)。在实际执行任何代码之前，函数声明在编译时被提升到代码的顶部。这允许在任何时候在代码中的任何地方调用函数声明；本质上，它是全球性的。</p><p id="e9e5" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">当我们使用表达式来构造函数时，就创建了函数表达式——如果函数在“=”的右边或者在“()”的内部。函数表达式是在运行时而不是编译时计算的，这意味着我们只有在它们运行时才能访问它们。因此，如果我们试图在函数在调用堆栈中运行之前调用函数表达式，我们将会得到一个错误。像回调这样的函数表达式允许我们在不必要的情况下，防止我们的全局作用域被过多的函数弄得混乱不堪。</p><h2 id="603c" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问:<em class="lp">空</em>和<em class="lp">未定义</em>有什么区别？</h2><p id="166f" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">Null是不存在的值，必须赋值。它代表了有意义的价值的有意缺失。Undefined表示变量已经声明，但尚未赋值。Undefined的类型为<em class="ln"> undefined。</em> Null有… <em class="ln"> object的类型？</em>没错！最初创建JavaScript时，一个错误导致null具有object类型，现在修复它会破坏太多东西。Null仍被视为原始值。</p><p id="81f1" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">只需看看这种疯狂的行为(来自MDN):</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="1ccd" class="jr js in lv b gy lz ma l mb mc">typeof null          // "object" (not "null" for legacy reasons)<br/>typeof undefined     // "undefined"<br/>null === undefined   // false<br/>null  == undefined   // true<br/>null === null        // true<br/>null == null         // true<br/>!null                // true<br/>isNaN(1 + null)      // false<br/>isNaN(1 + undefined) // true</span></pre><p id="2506" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated"><em class="ln">更多内容尽在</em><a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ln">plain English . io</em></a></p></div></div>    
</body>
</html>