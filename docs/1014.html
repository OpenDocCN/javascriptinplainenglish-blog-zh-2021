<html>
<head>
<title>Firebase Admin SDK with GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带GraphQL的Firebase Admin SDK</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/firebase-admin-sdk-with-graphql-d8bc3ef11a5c?source=collection_archive---------12-----------------------#2021-03-03">https://javascript.plainenglish.io/firebase-admin-sdk-with-graphql-d8bc3ef11a5c?source=collection_archive---------12-----------------------#2021-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/af8ef0ec10aa349a826043d9449eb678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CsXOyQaac6WUFZMYuai0Bw.png"/></div></figure><p id="9113" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">谷歌的人热衷于改善开发者体验。多年来，他们想出了各种各样的工具和技术来使原本复杂的流程变得简单得多，Firebase就是其中之一。Firebase在前端开发人员中非常受欢迎，因为它基本上消除了拥有独立后端的需要。从身份验证，到实时数据库，再到文件存储，您可以真正拥有一个健壮的后端，而无需从头开始构建。但这并不意味着你不能。Firebase确实为后端服务提供了一个名为<strong class="jt io"> Firebase Admin SDK </strong>的解决方案。在本文中，我们将使用GraphQL和Firebase Admin SDK构建一个后端notes应用程序。</p><h1 id="c520" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">安装和设置</h1><p id="b309" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">安装<a class="ae ls" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>如果你还没有的话。在您的终端中，键入</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="580b" class="mc kq in ly b gy md me l mf mg">npm init -y</span></pre><p id="398d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这将使用package.json文件为您创建一个新的Node.js项目。现在安装项目所需的依赖项列表。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b8c7" class="mc kq in ly b gy md me l mf mg">npm install express graphql express-graphql firebase-admin cors</span></pre><p id="837c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">安装完成后，在文件夹中创建3个文件</p><ul class=""><li id="3233" class="mh mi in jt b ju jv jy jz kc mj kg mk kk ml ko mm mn mo mp bi translated"><strong class="jt io"> index.js : </strong>主服务器文件</li><li id="3bda" class="mh mi in jt b ju mq jy mr kc ms kg mt kk mu ko mm mn mo mp bi translated"><strong class="jt io">Firebase-config . js:</strong>Firebase助手</li><li id="10ff" class="mh mi in jt b ju mq jy mr kc ms kg mt kk mu ko mm mn mo mp bi translated"><strong class="jt io">serviceaccountkey . JSON:</strong>Firebase服务帐户密钥</li></ul><p id="46c6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">还要为我们的模式和解析器创建两个单独的文件夹，并在这些文件夹中创建它们各自的Schema.js和Resolvers.js文件。</p><p id="4021" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你的文件夹结构应该是这样的。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2cbd0b82090b689b848b1641c8202727.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*5EOK_07WB13jO4l9kH2jVA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Folder structure</figcaption></figure><p id="7058" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">暂时将所有这些文件保留为空，等我们创建了firebase项目后，我们会再回来处理它们。</p><h2 id="8b29" class="mc kq in bd kr na nb dn kv nc nd dp kz kc ne nf ld kg ng nh lh kk ni nj ll nk bi translated"><strong class="ak">步骤2:创建Firebase项目</strong></h2><p id="693c" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated"><a class="ae ls" href="https://console.firebase.google.com/u/0/" rel="noopener ugc nofollow" target="_blank">此</a>链接将带您进入firebase控制台页面。如果您尚未登录您的google帐户，请先登录。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/9e72220495a12ed7cfbda17c63c9bffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kuh_-XsCwW3xsLdKil2yDQ.png"/></div></div></figure><ul class=""><li id="665b" class="mh mi in jt b ju jv jy jz kc mj kg mk kk ml ko mm mn mo mp bi translated">点击<strong class="jt io">创建一个项目。</strong></li><li id="5cf3" class="mh mi in jt b ju mq jy mr kc ms kg mt kk mu ko mm mn mo mp bi translated">为您的项目添加一个<strong class="jt io">名称</strong>。</li><li id="fb70" class="mh mi in jt b ju mq jy mr kc ms kg mt kk mu ko mm mn mo mp bi translated">为您的项目启用google analytics(可选)</li></ul><p id="5ae8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您的项目现在已经准备好了。下面的页面是您的项目仪表板。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nq"><img src="../Images/d34dd8a5118d90099d0ae847042a5c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwQ8MlOrnp2luu-YbTWNRA.png"/></div></div></figure><p id="3fd4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在你的仪表盘左上角，你会发现<strong class="jt io">项目概述</strong>旁边的<strong class="jt io">项目设置齿轮图标</strong>。点击图标，进入<strong class="jt io">项目设置</strong>。</p><p id="9848" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在你的项目设置中，你会发现一个<strong class="jt io">服务账户标签。点击选项卡，你会找到你的<strong class="jt io"> Firebase Admin SDK配置</strong>。默认情况下会选择Node.js选项，所以保持原样。</strong></p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nr"><img src="../Images/c58ce0d3c2ceb7f24f387e5d5c73b2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFQF9Ksag04th8KcJDIiiw.png"/></div></div></figure><p id="7323" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">将您在Firebase admin SDK部分看到的配置代码(类似于上面的截图)复制到项目中的<strong class="jt io"> firebase-config.js </strong>文件中。将“<strong class="jt io">路径/到/service account key . JSON”</strong>替换为“<strong class="jt io">”。/serviceAccountKey.json "。</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7da8" class="mc kq in ly b gy md me l mf mg">const admin = require("firebase-admin");<br/>const serviceAccount = require("./serviceAccountKey.json");</span><span id="8856" class="mc kq in ly b gy ns me l mf mg">const app = admin.initializeApp({<br/>  credential: admin.credential.cert(serviceAccount),<br/>});</span><span id="c8fb" class="mc kq in ly b gy ns me l mf mg">const dataStore = app.firestore()<br/>module.exports = {dataStore}</span></pre><p id="e312" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我还将从这个文件中导出firebase的数据存储服务，这样我们就可以在应用程序中的任何地方使用它。</p><p id="ab0d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在仪表板的同一个项目设置页面中，单击<strong class="jt io">生成新的私钥</strong>。将自动下载一个json文件，其中包含您的SDK信息。这个json文件有一组保存私有配置信息的键值对。</p><p id="f4a8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在Node.js项目文件夹中，将这个json文件的所有内容复制到<strong class="jt io"> serviceAccountKey.json文件中。</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b0d5" class="mc kq in ly b gy md me l mf mg">{<br/>  "type": "YOUR_TYPE",<br/>  "project_id": "YOUR_PROJECT_ID",<br/>  "private_key_id": "YOUR_PRIVATE_KEY_ID",<br/>  "private_key": "YOUR_PRIVATE_KEY",<br/>  "client_email": "YOUR_CLIENT_EMAIL",<br/>  "client_id": "YOUR_CLIENT_ID",<br/>  "auth_uri": "YOUR_AUTH_URI",<br/>  "token_uri": "YOUR_TOKEN_URI",<br/>  "auth_provider_x509_cert_url": "YOUR_AUTH_PROVIDER_CERT_URL",<br/>  "client_x509_cert_url": "YOUR_CLIENT_CERT_URL"<br/>}</span></pre><p id="5885" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">至此，我们正式完成了项目设置。</p><p id="72d9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">第三步:构建我们的应用<br/> </strong>我们将要构建的应用基本上是Google Keep的低级克隆(<a class="ae ls" href="https://ak-gkeep.netlify.app/" rel="noopener ugc nofollow" target="_blank">现场演示</a>)。打开您之前创建的index.js文件，复制以下代码。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="32e1" class="mc kq in ly b gy md me l mf mg">const express = require('express')<br/>const { graphqlHTTP } = require('express-graphql')<br/>const cors = require('cors')<br/>const { schema } = require('./schema/Schema')<br/>const { root } = require('./resolvers/Resolver')<br/>const { dataStore } = require('./firebase-config')</span><span id="5c98" class="mc kq in ly b gy ns me l mf mg">const PORT = process.env.PORT || 5000<br/>const app = express();</span><span id="2d3d" class="mc kq in ly b gy ns me l mf mg">app.use(cors());<br/>app.use('/graphql', graphqlHTTP({<br/>  schema: schema,<br/>  rootValue: root,<br/>  graphiql: true,<br/>}));</span><span id="ba3b" class="mc kq in ly b gy ns me l mf mg">app.listen(PORT, () =&gt; console.log(`Open ${PORT}/graphql`));</span></pre><p id="4fce" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们通过传入我们的<strong class="jt io">模式</strong>和<strong class="jt io">解析器</strong>来配置graphqlHTTP，并且还将<strong class="jt io"> graphiql </strong>设置为true，这将让我们在类似邮递员的操场上测试我们的API。</p><p id="fd81" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">模式</strong>基本上是我们应用程序的骨架。它用于为我们的后端服务创建<strong class="jt io">定义。这些定义在创建解析器时用作参考。</strong></p><p id="fabe" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">解析器为模式中定义的所有后端服务处理业务逻辑。一旦你看到一个例子，你会得到一个更好的画面。</p><h2 id="6d49" class="mc kq in bd kr na nb dn kv nc nd dp kz kc ne nf ld kg ng nh lh kk ni nj ll nk bi translated">(计划或理论的)纲要</h2><p id="abb7" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">GraphQL中的Schema本质上是用来为我们的应用程序构建一个框架。它建立了强有力的定义，这使得预测请求和响应类型变得更加容易。让我们看看我们的Schema.js文件</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a76b" class="mc kq in ly b gy md me l mf mg">const { buildSchema } = require('graphql');</span><span id="cd1f" class="mc kq in ly b gy ns me l mf mg">const schema = buildSchema(`<br/>  type Query {<br/>    note(id : ID!) : Note!<br/>    notes : [Note]!<br/>  }</span><span id="a1f3" class="mc kq in ly b gy ns me l mf mg">  type Mutation {<br/>    addNote(title: String!, description: String) : Note!<br/>    editNote(id: ID!, title: String, description : String) : SemiNote<br/>    deleteNote(id: ID!) : ID!<br/>    changeColor(id: ID!, color : String!) : String!<br/>    setIsPinned(id: ID!, isPinned: Boolean!) : Boolean!<br/>  }</span><span id="2282" class="mc kq in ly b gy ns me l mf mg">  type Note {<br/>    id: ID!<br/>    title : String!<br/>    description: String<br/>    color : String<br/>    isPinned : Boolean<br/>  }</span><span id="c674" class="mc kq in ly b gy ns me l mf mg">  type SemiNote{<br/>    id: ID<br/>    title : String<br/>    description : String<br/>  }<br/>`);</span><span id="fc3d" class="mc kq in ly b gy ns me l mf mg">module.exports = { schema }</span></pre><p id="3f92" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">每个模式本质上都有两个主要部分，<strong class="jt io">查询</strong>和<strong class="jt io">突变</strong>。查询用于获取项目，而变异用于添加/更新/删除项目。还有<strong class="jt io">类型</strong>，让你定义自己的自定义类型。在我们的例子中，我们有一个带有5个属性的主<strong class="jt io">注释</strong>类型。(id、标题、描述、颜色和标识。)</p><p id="f077" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">查询</strong> <em class="nt"> </em> <br/> <strong class="jt io">备注</strong>:返回特定id的备注。<br/> <strong class="jt io">注释</strong>:返回整个数组的注释。</p><p id="f693" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">突变</strong> <br/> <strong class="jt io"> addNote </strong>:通过传入title(string)&amp;description(string)<br/><strong class="jt io">edit note</strong>:修改注释(id)的标题或描述或两者都修改<br/> <strong class="jt io"> deleteNote </strong>:删除注释(id)。<br/> <strong class="jt io"> changeColor </strong>:编辑注释(id)的颜色(字符串)属性<br/> <strong class="jt io"> setIsPinned </strong>:编辑注释(id)的IsPinned(布尔)属性</p><h2 id="40b9" class="mc kq in bd kr na nb dn kv nc nd dp kz kc ne nf ld kg ng nh lh kk ni nj ll nk bi translated">下决心者</h2><p id="4bff" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">我们的模式定义的业务逻辑在解析器中处理。在Resolvers文件夹中，打开resolvers.js并粘贴以下代码。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7606" class="mc kq in ly b gy md me l mf mg">const { dataStore } = require('../firebase-config')</span><span id="321a" class="mc kq in ly b gy ns me l mf mg">const root = {<br/>  note: ({ id }) =&gt; notes.find(note =&gt; note.id == id),</span><span id="8be3" class="mc kq in ly b gy ns me l mf mg">  notes: async () =&gt; {<br/>    const notes = []<br/>    const snapshot = await dataStore.collection('notes').get();<br/>    snapshot.forEach(note =&gt; notes.push({ id: note.id, ...note.data()<br/>    }));<br/>    return notes;<br/>  },</span><span id="4c24" class="mc kq in ly b gy ns me l mf mg">  addNote: async ({ title, description }) =&gt; {<br/>    const newNoteRef = await dataStore.collection('notes').doc()<br/>    const note = { id: newNoteRef.id, title, description, color: "transparent", isPinned: false }<br/>    await newNoteRef.set(note)<br/>    return note<br/>  },</span><span id="d550" class="mc kq in ly b gy ns me l mf mg">  editNote: async ({ id, ...args }) =&gt; {<br/>    await dataStore.collection('notes').doc(id).update({ ...args });<br/>    return { id: id, ...args }<br/>  },</span><span id="3979" class="mc kq in ly b gy ns me l mf mg">  deleteNote: async ({ id }) =&gt; {<br/>    await dataStore.collection('notes').doc(id).delete()<br/>    return id;<br/>  },</span><span id="c9e3" class="mc kq in ly b gy ns me l mf mg">  changeColor: async ({ id, color }) =&gt; {<br/>    await dataStore.collection('notes').doc(id).update({ color: color });<br/>    return color;<br/>  },</span><span id="d101" class="mc kq in ly b gy ns me l mf mg">  setIsPinned: async ({ id, isPinned }) =&gt; {<br/>    await dataStore.collection('notes').doc(id).update({ isPinned: isPinned });<br/>    return isPinned;<br/>  },<br/>};</span><span id="4fb0" class="mc kq in ly b gy ns me l mf mg">module.exports = { root }</span></pre><p id="8145" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于模式文件中定义的所有查询/变异，我们都有它们对应的解析器。</p><p id="4fe6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">注释</strong>:该解析器将一个id作为参数，<strong class="jt io">在firebase store </strong> <strong class="jt io">中搜索具有该id的注释</strong>。(notes.find)</p><p id="0ab9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">注释</strong>:这个解析器简单地从firebase存储中返回注释列表。(dataStore.collection('notes ')。get())</p><p id="c1e7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> addNote </strong>:这个解析器首先创建一个带有引用id的空注释。(dataStore.collection('notes ')。doc() = " <strong class="jt io"> doc </strong>"这里指的是firebase中的文档，它只是存储在数据库中的一个典型的数据对象。)<br/><strong class="jt io">标题和描述</strong>(由用户提供)连同初始<strong class="jt io">颜色</strong>值、初始<strong class="jt io">固定状态</strong>和一个<strong class="jt io">随机id </strong>被映射到先前创建的引用。然后这个文档被<strong class="jt io">存储到firebase存储器</strong>。</p><p id="a2d7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> editNote </strong>:这个解析器最多带3个参数，id(必填)、标题和描述。它首先<strong class="jt io">获取具有匹配id </strong>的笔记，然后<strong class="jt io">用它们各自的值更新标题和描述</strong>，这些值在firebase存储中作为参数传递。(dataStore.collection("notes ")。文档(id)。更新({args}))</p><p id="3057" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> deleteNote </strong>:这个解析器获取一个id，然后<strong class="jt io">删除firebase存储中具有匹配id </strong>的注释。<br/>datastore . collection(" notes ")。文档(id)。删除()</p><p id="df5a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> changeColor </strong>:这个解析器类似于editNote解析器。它将一个id作为参数，<strong class="jt io">用匹配的id更新便笺的颜色属性</strong>。</p><p id="2ae1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> setIsPinned : </strong>同样，与editNote类似，这个解析器将一个id作为参数，<strong class="jt io">用匹配的id更新一个注释的IsPinned属性</strong>。</p><p id="bad5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是我们所有的解决方案。现在打开您的终端并运行npm start。因为我们在index.js文件中设置的端口是5000，所以在浏览器上打开localhost:5000/graphql。</p><p id="1dc1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你现在看到的页面是graphiql游乐场。您可以在这里测试所有的查询和变异。下面，我已经添加了一个所有查询和变异的例子。随意调整传递到这些操作中的数据。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="bbae" class="mc kq in ly b gy md me l mf mg">{<br/>  notes {<br/>    id<br/>    title<br/>    description<br/>    color<br/>    isPinned<br/>  } <br/>}</span><span id="72f0" class="mc kq in ly b gy ns me l mf mg">{<br/>  note(id:"1OFXc2SBszVlkt1Y4JzE") {<br/>    title<br/>    description<br/>  } <br/>}</span><span id="2247" class="mc kq in ly b gy ns me l mf mg">mutation{<br/>  addNote(title:"testsdasd3Ig", description:"testasd3desc"){<br/>    id<br/>    title<br/>  }<br/>}</span><span id="42fa" class="mc kq in ly b gy ns me l mf mg">mutation{<br/>  deleteNote(id:"1OFXc2SBszVlkt1Y4JzE")<br/>}</span><span id="6fe1" class="mc kq in ly b gy ns me l mf mg">mutation{<br/>  editNote(id:"t1",  title :"Hahaha"){<br/>    id<br/>  }<br/>}</span><span id="fb24" class="mc kq in ly b gy ns me l mf mg">mutation{<br/>  setIsPinned(id:"x2cotRZLLxNJLpGqC3PY", isPinned:false)<br/>}</span><span id="737b" class="mc kq in ly b gy ns me l mf mg">mutation{<br/>  changeColor(id:"x2cotRZLLxNJLpGqC3PY", color:"#fff")<br/>}</span></pre><p id="ea5a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">确保你正在添加的<strong class="jt io">id</strong>存在于你的firebase商店中<strong class="jt io">。说到firebase，一旦你从你的操场上运行任何变异，你可以在仪表盘部分查看你的云firestore。将会有一个新的收藏，叫做有一些记录的笔记。</strong></p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nu"><img src="../Images/63fc2d4a5bf12e173d12c82462a3a0b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2X8HiWduVajIqzWItETHpA.png"/></div></div></figure><p id="6419" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">仅此而已。现在，您有了一个Node.js + GraphQL应用程序，它通过基本的CRUD操作连接到firebase数据存储。如果你对这个项目有任何疑问，请随时写在评论里。干杯！</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="ec69" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">参考链接:</p><p id="5263" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae ls" href="https://ak-gkeep.netlify.app/" rel="noopener ugc nofollow" target="_blank">工作演示</a><br/><a class="ae ls" href="https://github.com/AkileshRao/gkeep-clone/tree/master/server" rel="noopener ugc nofollow" target="_blank">Github repo</a><br/><a class="ae ls" href="https://akileshrao19.medium.com/google-keep-clone-with-vue-js-graphql-firebase-90b8b43a3903" rel="noopener">该应用的前端教程</a><br/><a class="ae ls" href="https://firebase.google.com/docs" rel="noopener ugc nofollow" target="_blank">Firebase Docs</a><br/><a class="ae ls" href="https://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank">graph QL Docs</a></p></div></div>    
</body>
</html>