<html>
<head>
<title>What is the best way to call a REST API from JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从JavaScript调用REST API的最佳方式是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-the-best-way-to-call-a-rest-api-from-javascript-79a901414447?source=collection_archive---------5-----------------------#2021-03-03">https://javascript.plainenglish.io/what-is-the-best-way-to-call-a-rest-api-from-javascript-79a901414447?source=collection_archive---------5-----------------------#2021-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aa2dcff32e08cd55d68a080480e52f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqY0soG39kOp2d1G6p4xpQ.png"/></div></div></figure><p id="0690" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您有没有想过进行JavaScript REST API调用的最佳且干净的方式是什么？在一个大项目中，你会做上百个这样的东西？</p><p id="4ea6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的项目中，这个问题问得太晚了，因为已经写了很多代码。最好早点知道选择哪种方法，这样你以后就不会那么头疼了。</p><p id="d40d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能知道，从JavaScript调用API有很多选项。其中有<strong class="jx io"> XMLHttpRequest </strong>、<strong class="jx io"> jQuery </strong>、<strong class="jx io"> fetch </strong>等等一个。我将在这里讨论<strong class="jx io"> fetch </strong>方法，因为它在我们的代码中看起来更干净。</p><p id="894a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<strong class="jx io">获取</strong>非常简单。http请求通常如下所示:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="49b5" class="lc ld in ky b gy le lf l lg lh">fetch(‘<a class="ae li" href="https://jsonplaceholder.typicode.com/todos/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1</a>’)<br/>  .then(response =&gt; response.json())<br/>  .then(json =&gt; console.log(json));</span></pre><p id="2641" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，发出get请求非常简单。但是当我们想要发出一个<strong class="jx io"> post </strong>请求时会发生什么呢？让我们看看:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a554" class="lc ld in ky b gy le lf l lg lh">fetch(‘<a class="ae li" href="https://jsonplaceholder.typicode.com/todos/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1</a>’,<br/>    {method: “POST”, body: JSON.stringify(data)})<br/>  .then(response =&gt; response.json())<br/>  .then(json =&gt; console.log(json));</span></pre><p id="4ebd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事情已经开始变得相当糟糕了。类似的，<strong class="jx io">放</strong>和<strong class="jx io">删除</strong>的方法看起来也会一样。</p><p id="8e24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，我们需要做点什么。首先，让我们假设我的基础rest api url类似于<a class="ae li" href="https://my-url/v1/" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://my-URL/v1/</em></a>，如果我想从服务器获取所有用户，我必须调用<a class="ae li" href="https://my-url/v1/" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://my-URL/v1</em></a><em class="lj">/users</em>。如你所见，我在代码中会一直使用<a class="ae li" href="https://my-url/v1/" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://my-URL/v1/</em></a>。所以，如果我必须发出数百个请求，我的代码就会被这个字符串污染。</p><p id="eba0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，如果将来我要对我的应用程序进行升级，并且我也需要将我的rest基本url从<em class="lj"> v1 </em>升级到<em class="lj"> v2 </em>会发生什么？我将不得不在应用程序中到处搜索并替换那些字符串。</p><h2 id="9be6" class="lc ld in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated"><strong class="ak">第一选项</strong></h2><p id="adc8" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">我的第一个选择是创建一个<em class="lj"> main.js </em>，我将在每个<em class="lj">中导入它。在这个文件中，我将声明我的基本url字符串。让我们看看它会是什么样子:</em></p><p id="0de1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lj"> main.js </em></p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="bd68" class="lc ld in ky b gy le lf l lg lh">const baseUrl = ‘<a class="ae li" href="https://my-url/v1/" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://my-url/v1/</em></a>’;</span></pre><p id="e49b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lj"> users.js </em></p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="da04" class="lc ld in ky b gy le lf l lg lh">fetch(baseUrl + ‘users’)<br/>  .then(response =&gt; response.json())<br/>  .then(json =&gt; console.log(json));</span></pre><p id="71f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它现在看起来更好，但我仍然会重复代码，并会有<em class="lj">。然后(…) </em>和<em class="lj"> baseUrl </em>常量在我的项目中随处可见。所以，我想做一些更普通的事情。另外，如果我想在我的请求中添加一些身份验证头，会发生什么呢？代码将如下所示:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="8bf9" class="lc ld in ky b gy le lf l lg lh">const baseUrl = ‘<a class="ae li" href="https://my-url/v1/" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://my-url/v1/</em></a>’;</span><span id="b00f" class="lc ld in ky b gy mg lf l lg lh">const authHeaders = {Authorization: ‘Bearer ‘ +<br/>  $.cookie(‘jwtToken’), ‘Content-Type’: ‘application/json’};</span><span id="8f86" class="lc ld in ky b gy mg lf l lg lh">fetch(baseUrl + ‘users’, {method:’GET’, headers: authHeaders)<br/>  .then(response =&gt; response.json())<br/>  .then(json =&gt; console.log(json));</span></pre><p id="b53b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，当我需要更多的选项时，代码会很快变得令人讨厌。</p><h2 id="6abb" class="lc ld in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated"><strong class="ak">最佳选项</strong></h2><p id="1d65" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">对我来说最好的选择是下面这个。在我的<em class="lj"> main.js </em>文件中，我将为<strong class="jx io"> put、post、get </strong>和<strong class="jx io"> delete </strong>定义四个方法，并在我的代码中的任何地方将它们直接用于<em class="lj">窗口</em>对象。因此，在我的<em class="lj"> main.js </em>文件中，我会有以下内容:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ab10" class="lc ld in ky b gy le lf l lg lh">const urlLocation =’<a class="ae li" href="https://my-url/v1/" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://my-url/v1/</em></a>’;</span><span id="75d4" class="lc ld in ky b gy mg lf l lg lh">const authHeaders = {Authorization: ‘Bearer ‘ +<br/>  $.cookie(‘jwtToken’), ‘Content-Type’: ‘application/json’};</span><span id="9954" class="lc ld in ky b gy mg lf l lg lh">window.postJson = function (url, data) {<br/>  return fetch(urlLocation + url, {method: “POST”, headers:<br/>    authHeaders, body: JSON.stringify(data)}).then((res) =&gt; res.json());</span><span id="3b8e" class="lc ld in ky b gy mg lf l lg lh">}</span><span id="df32" class="lc ld in ky b gy mg lf l lg lh">window.getJson = function (url) { <br/>  return fetch(urlLocation + url, {method: “GET”, headers: authHeaders})<br/>    .then((res) =&gt; res.json()); <br/>  }</span><span id="a8ae" class="lc ld in ky b gy mg lf l lg lh">window.deleteJson = function (url) { <br/>  return fetch(urlLocation + url, {method: “DELETE”, headers: authHeaders})<br/>    .then((res) =&gt; res.json()); <br/>  }</span><span id="182a" class="lc ld in ky b gy mg lf l lg lh">window.putJson = function (url) { <br/>  return fetch(urlLocation + url, {method: “PUT”, headers: authHeaders})<br/>    .then((res) =&gt; res.json()); <br/>  }</span></pre><p id="7de6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的项目中，如果我需要发出一个get调用来获得所有用户，我所要做的就是:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a30d" class="lc ld in ky b gy le lf l lg lh">const alUsers = await getJson(allUsers+'users').then( (res) =&gt; { return res; } );</span></pre><p id="0126" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您所看到的，这是一种更干净、更易于维护的rest api调用方式。现在，我把所有的逻辑都放在一个地方，我可以很容易地改变我的基本url位置或者添加/删除标题。</p><p id="b842" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> PS: </strong>如果你曾经需要一个运行时间监控工具，只需检查<a class="ae li" href="https://robomiri.com" rel="noopener ugc nofollow" target="_blank"> RoboMiri </a>。最好的免费正常运行时间监测服务。</p></div></div>    
</body>
</html>