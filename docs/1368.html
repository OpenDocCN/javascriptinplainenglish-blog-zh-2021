<html>
<head>
<title>Building Endpoints in Express with Test-Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用测试驱动开发在Express中构建端点</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-endpoints-in-express-js-with-test-driven-development-8b1800d355fc?source=collection_archive---------15-----------------------#2021-03-22">https://javascript.plainenglish.io/building-endpoints-in-express-js-with-test-driven-development-8b1800d355fc?source=collection_archive---------15-----------------------#2021-03-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="249d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">针对初学者的简单演练，用于改进您构建的API。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/55fe10a788a01dc2e1d9bba37746f4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oVizX9igpPn_8XMI"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="02ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们都知道良好测试的重要性。这使得我们的代码更可靠，更易于维护。现在想想你构建的最后一个项目，想想你有多少测试覆盖率。75%?50%?…10%?当涉及到我的个人项目时，我肯定会因忽视测试而感到内疚。我告诉自己，我会回去添加测试，因为我知道我的应用程序只能受益，但我很少这样做。相反，我会继续下一个项目。</p><p id="b488" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是测试驱动开发(TDD)真正闪光的地方。这是同时获得高质量代码和高测试覆盖率的最简单的方法。</p><p id="ebc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">按照罗伯特“鲍勃叔叔”马丁的说法，TDD有三条规则:</p><ol class=""><li id="3d60" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">除非是为了通过失败的单元测试，否则不允许编写任何生产代码。</li><li id="332a" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">不允许你写更多足以失败的单元测试。</li><li id="9acf" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">除了通过一个失败的单元测试所必需的，你不允许写更多的产品代码。</li></ol><p id="62d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些规则迫使我们保持代码的简单性，并真正理解我们要做什么以及如何去做，在我们开始写任何代码之前。我们必须了解我们希望我们的代码做得足够好，以便为该功能编写一个测试。只有在我们写完一个测试之后，我们才能真正地写代码，而且只能写通过测试所必需的代码。</p><p id="7016" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一种简单的思考TDD的方法是分三个阶段:红色→绿色→重构。我们编写一个我们想要的功能的测试，运行那个测试，它失败了(红色)。然后，我们去构建必要的功能，使测试通过(绿色)。最后，我们可以重构我们的代码。</p><h1 id="de74" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated"><strong class="ak">计划</strong></h1><p id="7238" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">我们的应用程序是一个简单的博客平台。我们将编写一个端点，一个GET端点，它将从我们的数据库中返回所有的文章。在本文中，我不打算设置数据库或与它交互的方法，但它们会出现在代码中，我会尽力解释它们。</p><h2 id="5c1f" class="nb mf in bd mg nc nd dn mk ne nf dp mo lc ng nh mq lg ni nj ms lk nk nl mu nm bi translated"><strong class="ak">科技</strong></h2><p id="d778" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">快速—后端框架</p><p id="ac80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Mocha —测试框架</p><p id="ea6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Chai断言库</p><p id="71bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">超级测试— HTTP断言库</p><p id="f852" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Knex —数据库连接</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h2 id="6888" class="nb mf in bd mg nc nd dn mk ne nf dp mo lc ng nh mq lg ni nj ms lk nk nl mu nm bi translated"><strong class="ak">第一步。编写一个初始测试</strong></h2><p id="ba01" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">这个测试应该简单地检查一个端点是否存在，以及它是否正确响应。</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="9d79" class="nb mf in nv b gy nz oa l ob oc">describe('GET /articles/', () =&gt; {<br/>    it('responds with articles', () =&gt; {<br/>        return supertest(app).get('/api/articles').expect(200)<br/>    })<br/>})</span></pre><p id="3a6d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，我们并没有检查端点是否真的响应了这里的文章。我们只是测试端点是否存在，并给出正确的HTTP响应200。</p><p id="2fb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们现在运行测试，它将失败:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f943b17559bb702b5bc95343cc232988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*5M-UeeXPzWG9Uz_3tGHOog.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Failing Test. We get a 404 Not Found response, since our endpoint isn’t built yet.</figcaption></figure><p id="de3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太好了！这就是我们想要的。我们还没有编写端点，所以我们的测试是正确的“失败”。记住，红色→绿色→重构。</p><h2 id="8596" class="nb mf in bd mg nc nd dn mk ne nf dp mo lc ng nh mq lg ni nj ms lk nk nl mu nm bi translated"><strong class="ak">第二步。使测试通过</strong></h2><p id="fe56" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">现在，我们只需要构建能够通过测试的端点。在这一点上，我们所做的就是让端点存在。它实际上不会做什么，只是给出一个200 OK的响应。请记住，我们正在编写足够的代码来使我们的单个失败单元测试通过，仅此而已！</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="36b2" class="nb mf in nv b gy nz oa l ob oc">app.get('/articles', (req, res) =&gt; {<br/>    res.status(200).send('stuff')<br/>})</span></pre><p id="7baa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再次运行我们的测试。它过去了！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/58c793a4221397a324cd8d38098256ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*j2fsL-gc8lVFXMliocVlqQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Passing Test! Our endpoint exists, and gives the response we’re looking for.</figcaption></figure><p id="3a05" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是我们的端点现在没有做任何事情。它只给出一个200的响应，以及一个表示“东西”的字符串。我们的测试通过了，但是我们的端点实际上并没有像我们希望的那样返回文章。</p><h2 id="2c14" class="nb mf in bd mg nc nd dn mk ne nf dp mo lc ng nh mq lg ni nj ms lk nk nl mu nm bi translated"><strong class="ak">第三步。重构以测试实现</strong></h2><p id="b322" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">是时候重构和扩展我们的测试，以涵盖我们希望从这个端点获得的全部功能了。</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="d60b" class="nb mf in nv b gy nz oa l ob oc">describe('GET /articles/', () =&gt; {<br/>    it ('responds with articles', () =&gt;{<br/>        const testArticles = makeArticlesArray()<br/>        return supertest(app).get('/api/articles')<br/>               .expect(200, testArticles)<br/>    })<br/>})</span></pre><p id="054d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有几个新东西！我们使用了一个助手函数，它创建了一个伪文章数组，可以从我们的测试数据库中插入和返回这些文章。设置测试数据库和数据库连接超出了本文的范围，所以只需知道<code class="fe of og oh nv b">makeArticlesArray()</code>创建了一个我们期望从端点返回的文章数组。</p><p id="719b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再次运行测试，我们看到它失败了:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/81c80a951804545f858b79a73de718d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*C51VGwYfDK2wXTEg87TOSg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Our test fails again, this time because we don’t get the content we expect in the response body.</figcaption></figure><p id="3989" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一次，我们的测试失败了，因为它期望一个200 OK响应，并得到一个404 Not Found响应。这一次，我们得到了200 OK的响应，但是响应体的内容并不是我们所期望的。我们期望得到一个对象数组，每个对象代表一篇文章。相反，我们得到了一个空对象。</p><h2 id="6e5e" class="nb mf in bd mg nc nd dn mk ne nf dp mo lc ng nh mq lg ni nj ms lk nk nl mu nm bi translated"><strong class="ak">第四步。使重构后的测试通过</strong></h2><p id="3662" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">我们现在回到红色。我们必须改变我们的端点，以便它实际上响应我们期望的数据。</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="a6d5" class="nb mf in nv b gy nz oa l ob oc">app.get('/articles', (req, res) =&gt; {<br/>    const db = req.app.get('db')<br/>    ArticlesService.getAllArticles(db)<br/>    .then((articles)=&gt; res.json(articles)<br/>})</span></pre><p id="f2b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">哇，更大的变化！事情是这样的。第2行<strong class="kv io"> </strong>正在建立到我们数据库的连接。第3行是我们构建的使用Knex从数据库中检索所有文章的方法。当我们从数据库取回文章时，我们使用<code class="fe of og oh nv b">res.json()</code>方法以JSON格式将其发送回客户端。</p><p id="dc47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在一个完整的应用程序中，我们将建立一个测试数据库，并在运行测试之前用虚拟数据填充它，测试将在调用端点时接收虚拟数据。但是，这超出了本文的范围。</p><p id="c308" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们再次运行我们的测试。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/a822f34e4b69690e9c670a2dc687c170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*JHqp-k0Y1-cRzD5CITehVQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Our test is back to passing</figcaption></figure><p id="64e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太好了！我们的测试通过了。</p><p id="2c36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们已经建立了一个简单的端点，让我们可以访问我们博客平台上的所有文章，我们可以放心，它工作正常，因为我们的测试已经通过了。如果我们的代码以任何方式改变，打破了这个端点，这个测试将失败，我们将更容易在它进入生产并给我们的用户带来问题之前捕捉到它。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="782c" class="me mf in bd mg mh ok mj mk ml ol mn mo jt om ju mq jw on jx ms jz oo ka mu mv bi translated">结论</h1><p id="57f6" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">这是一个相对简单的例子。在“现实生活”中，您可能不会将事情分解得太多，而是简单地从头开始编写完整的测试，然后创建完全实现的端点来通过测试。此外，您还需要担心我们在这里跳过的东西，比如数据库连接。但是希望，这说明了测试驱动开发的红色→绿色→重构循环，并且稍微揭开了这个过程。</p><p id="1681" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你喜欢这篇文章，觉得它有帮助，或者不同意它，我很乐意听到你的反馈。我在Medium上写了很多，并且一直在寻求改进。我还在Twitter上写了一堆关于我在技术领域的日常建设和学习的文章！这里可以关注我<a class="ae ks" href="https://twitter.com/ARColeburn" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>