<html>
<head>
<title>Understanding GraphQL through REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过REST了解GraphQL</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-graphql-through-rest-a35f58a88d2c?source=collection_archive---------8-----------------------#2021-01-23">https://javascript.plainenglish.io/understanding-graphql-through-rest-a35f58a88d2c?source=collection_archive---------8-----------------------#2021-01-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/8670ba656705aed0e9ff37419e0f804b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JUMbgaJZS-q-b5wD.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">REST and GraphQL data fetching</figcaption></figure><div class=""/><div class=""><h2 id="8fc7" class="pw-subtitle-paragraph jz jb jc bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过比较两种API规范来了解REST和GraphQL。</h2></div><p id="83f4" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">为了理解为什么GraphQL会继续获得关注，理解它打算改进什么会越来越有帮助。软件工程的美妙之处之一是不断地渴望改进提供给我们的东西。GraphQL试图用REST来做到这一点。最后，您将了解REST API(应用程序编程接口)端点的示例，GraphQL查询如何与这些REST端点相关，以及GraphQL存在的原因。让我们开始吧。</p><h1 id="943b" class="ln lo jc bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">理解休息</h1><p id="a92b" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated"><a class="ae mk" href="https://www.codecademy.com/articles/what-is-rest" rel="noopener ugc nofollow" target="_blank"> REST </a>代表具象状态转移。</p><p id="8626" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">这种架构以<code class="fe ml mm mn mo b">stateless</code>和能够<code class="fe ml mm mn mo b">separate concern between client and server</code>而闻名。</p><h2 id="cce5" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">无国籍的</h2><p id="640f" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">从这个意义上说，无状态意味着服务器不需要知道客户机的状态来执行一个动作。</p><h2 id="a19e" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">关注点分离</h2><p id="023c" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">客户端和服务器分离允许开发人员在不影响客户端代码的情况下更改服务器，反之亦然。</p><h2 id="78f6" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">沟通</h2><p id="e264" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">当与其他API规范进行比较时，真正使REST与众不同的是客户机和服务器的通信方式。REST是在90年代后期与HTTP(超文本协议传输)1.1一起开发的。正因为如此，REST能够利用HTTP的优势。为了说明这种交流，我将使用一个包含流派和书籍的通用模型。</p><figure class="nc nd ne nf gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nb"><img src="../Images/265add094c3e86058e57defa8c851931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ecIt4zMFgcUPZepD.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Genre and Book Model</figcaption></figure><p id="a024" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我们将回顾通过REST API接收和更新数据源。</p><h2 id="5772" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">从REST API接收信息</h2><p id="0a01" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">得到<code class="fe ml mm mn mo b">/genres</code></p><p id="d43e" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">当客户访问这个端点时，他们将被返回一个流派列表。</p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="a861" class="mp lo jc mo b gy nk nl l nm nn">[<br/>  {<br/>    "id": 1,<br/>    "name": "Mystery"<br/>  },<br/>  {<br/>    "id": 2,<br/>    "name": "Romance"<br/>  }<br/>]</span></pre><p id="6254" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">类似于流派，书籍也是如此</p><p id="9867" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">获取<code class="fe ml mm mn mo b">/books</code></p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="b9c4" class="mp lo jc mo b gy nk nl l nm nn">[<br/>  {<br/>    "id": 1,<br/>    "title": "The lost man",<br/>    "author": "Jane Harper",<br/>    "img": "/img/jh-tlm.png"<br/>  },<br/>  {<br/>    "id": 2,<br/>    "title": "And then there were none",<br/>    "author": "Agatha Christie",<br/>    "img": "/img/ac-attwn.png"<br/>  }<br/>]</span></pre><p id="8446" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">如您所见，这是一个非常可预测和可扩展的过程。如果我们上面的模型改变为包含另一个模型，比如<code class="fe ml mm mn mo b">Libraries</code>，我们可以很容易地添加那个端点，继续前进。</p><h2 id="9a15" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">休息时的CRUD操作</h2><p id="5ab5" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">在创建处理CRUD(创建、替换、更新和销毁)操作的服务时，我们将创建以下内容</p><ul class=""><li id="06b7" class="no np jc kt b ku kv kx ky la nq le nr li ns lm nt nu nv nw bi translated">发布<code class="fe ml mm mn mo b">/genres</code></li></ul><p id="0440" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">创造一种新的风格</p><ul class=""><li id="e25e" class="no np jc kt b ku kv kx ky la nq le nr li ns lm nt nu nv nw bi translated">放<code class="fe ml mm mn mo b">/genres</code></li></ul><p id="415b" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">更新现有流派</p><ul class=""><li id="245c" class="no np jc kt b ku kv kx ky la nq le nr li ns lm nt nu nv nw bi translated">删除<code class="fe ml mm mn mo b">/genres</code></li></ul><p id="8060" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">移除或删除现有的流派</p><p id="4788" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在REST API开发中，利用所提供的HTTP方法使得与这些可用端点的通信变得非常可预测。</p><h2 id="74d6" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">摘要</h2><p id="12d1" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">REST API背后的一般思想是让一切都成为端点。如果您需要在请求中添加或删除一些信息，以减轻客户端浏览器的负担，您可以轻松地做到这一点，而无需向客户端提供太多关于幕后发生的事情的信息。最重要的是，REST的目标是快速、可靠和可预测，同时利用所有HTTP。</p><h1 id="db03" class="ln lo jc bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">GraphQL是什么？</h1><p id="addd" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated"><a class="ae mk" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>是一种查询API的语言。不够？别急，更多的来了。</p><p id="9dd4" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">与REST API相反，GraphQL提供了一个HTTP端点和一个从<code class="fe ml mm mn mo b">understandable description of the data available</code>到<code class="fe ml mm mn mo b">type specification</code>的端点。这赋予了客户端<code class="fe ml mm mn mo b">request what they need and nothing more</code>的能力。这种查询语言更接近数据源，使前端开发人员能够更多地访问可用的模型和它们之间的关系。有了这个，他们就能够<code class="fe ml mm mn mo b">get many resources in a single request</code>。</p><h2 id="bd2e" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">类型规格和自我文档</h2><p id="b85d" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">不同于REST端点为每个端点返回不同的返回类型，GraphQL依靠类型和字段来告诉您的客户端什么是可能的。</p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="26b0" class="mp lo jc mo b gy nk nl l nm nn">type Query {<br/>  books: [Book]<br/>  genres: [Genre]<br/>}</span><span id="bdb1" class="mp lo jc mo b gy nx nl l nm nn">type Book {<br/>  id: Int<br/>  title: String<br/>  author: String<br/>  img: String<br/>}</span><span id="2f92" class="mp lo jc mo b gy nx nl l nm nn">type Genre {<br/>  id: Int<br/>  name: String<br/>  books: [Book]<br/>}</span></pre><p id="be27" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">这样，任何需要API来开发客户端代码的人都可以参考开发人员工具来查看所有可能的查询，这要归功于类型规范和自文档化。</p><h2 id="a80e" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">请求所需要的，仅此而已</h2><p id="f1e0" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">在我们的流派和书籍数据源中，当我们请求一本书时，我们总是会得到所有可用的关键字。</p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="bf51" class="mp lo jc mo b gy nk nl l nm nn">[<br/>  {<br/>    "id": 1,<br/>    "title": "The lost man",<br/>    "author": "Jane Harper",<br/>    "img": "/img/jh-tlm.png"<br/>  },<br/>  {<br/>    "id": 2,<br/>    "title": "And then there were none",<br/>    "author": "Agatha Christie",<br/>    "img": "/img/ac-attwn.png"<br/>  }<br/>]</span></pre><p id="ee92" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">有了GraphQL，我们可以添加和删除键，只格式化前端需要的数据。比方说，我们正在创建一个只需要标题和图像的页面，我们可以创建一个查询来完成这个任务。</p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="2299" class="mp lo jc mo b gy nk nl l nm nn">query {<br/>  books {<br/>    title<br/>    img<br/>  }<br/>}</span></pre><p id="67e2" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">如果没有<code class="fe ml mm mn mo b">author</code>和<code class="fe ml mm mn mo b">id</code>键，这将返回相同的结果。</p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="80a4" class="mp lo jc mo b gy nk nl l nm nn">[<br/>  {<br/>    "title": "The lost man",<br/>    "img": "/img/jh-tlm.png"<br/>  },<br/>  {<br/>    "title": "And then there were none",<br/>    "img": "/img/ac-attwn.png"<br/>  }<br/>]</span></pre><h2 id="de2d" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">在单个请求中获取许多资源</h2><p id="f9ad" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">在上面的REST例子中，如果我们想同时获得流派和书籍，我们有几个选项。</p><ol class=""><li id="18a2" class="no np jc kt b ku kv kx ky la nq le nr li ns lm ny nu nv nw bi translated">向<code class="fe ml mm mn mo b">/genres</code>和<code class="fe ml mm mn mo b">/books</code>发出多个请求</li></ol><ul class=""><li id="ed4a" class="no np jc kt b ku kv kx ky la nq le nr li ns lm nt nu nv nw bi translated">这将迫使客户端自己解决这些关系。</li></ul><p id="34e0" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">2.将图书关系添加到<code class="fe ml mm mn mo b">/genres</code>端点。</p><ul class=""><li id="86ba" class="no np jc kt b ku kv kx ky la nq le nr li ns lm nt nu nv nw bi translated">唯一的负面影响是，现在任何时候你想获取流派，你都不得不包含书籍，这是上面提到的过度获取的问题。</li></ul><p id="dc74" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">3.创建一个新的端点或添加一个选项，允许获取流派和书籍。</p><ul class=""><li id="fc2d" class="no np jc kt b ku kv kx ky la nq le nr li ns lm nt nu nv nw bi translated">这是最常见的，因为它不会干扰连接到API的现有前端应用程序。</li></ul><p id="427e" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">GraphQL的目标是通过类型规范使所有关系可用，而不是为每个端点规划关系和响应。</p><h2 id="dd2e" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">版本控制</h2><p id="1da9" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">前端和后端团队之间的沟通可能会很困难。在更改端点的例子中，您需要与前端团队沟通，以确保他们为任何重大更改做好准备。使用GraphQL可以很容易地添加或删除与上述类型相关的字段。</p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="e72f" class="mp lo jc mo b gy nk nl l nm nn">type Book {<br/>  id: Int<br/>  title: String<br/>  author: String @deprecated<br/>  authoredBy: Author<br/>  img: String<br/>}</span><span id="bcb8" class="mp lo jc mo b gy nx nl l nm nn">type Author {<br/>  firstName: String<br/>  lastName: String<br/>}</span></pre><p id="d31a" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">这可能会减少团队之间需要的沟通，减少下游的突发变更。</p><h1 id="f487" class="ln lo jc bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">基础知识</h1><h2 id="659f" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">查询与突变</h2><p id="f72f" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">到目前为止，上面的例子都是查询。查询和突变替换端点，以全部解析为一个端点<code class="fe ml mm mn mo b">POST /graphql</code>。这个端点可以更改，但始终一致的是所有内容都是POST请求。过了这个时间，你要么发送一个查询变量，要么发送一个变异变量。为了便于阅读，所使用的格式总是隔开的，并且是从经常使用的开发工具(如GraphiQL)中复制的。<a class="ae mk" href="https://countries.trevorblades.com/" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个用来查询国家的GraphiQL的例子。试试吧！</p><h2 id="31ff" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">询问</h2><p id="e951" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">在REST API中，查询都与GET请求相关。查询是GraphQL的主要焦点，也是它的独特之处。不是点击REST端点<code class="fe ml mm mn mo b">GET /books</code>，而是使用单个端点<code class="fe ml mm mn mo b">POST /graphql</code>并发送一个查询变量。这里有一个例子。</p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="1262" class="mp lo jc mo b gy nk nl l nm nn">query {<br/>  books {<br/>    id<br/>    title<br/>  }<br/>}</span></pre><h2 id="438b" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">变化</h2><p id="afc8" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">GraphQL中的PUT、POST和DELETE端点等价物是突变。</p><p id="9441" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><code class="fe ml mm mn mo b">POST /book?name=Storyteller</code></p><pre class="nc nd ne nf gt ng mo nh ni aw nj bi"><span id="d85a" class="mp lo jc mo b gy nk nl l nm nn">mutation {<br/>  createBook(<br/>      {<br/>          name: 'Storyteller'<br/>      }<br/>  ){<br/>      // what you want to return<br/>      id<br/>      name<br/>  }<br/>}</span></pre><p id="3094" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">上面的一个关键区别是，不管是突变还是查询，我们总是需要解析<code class="fe ml mm mn mo b">// what you want to return</code>部分中的响应。对我来说，这似乎仍然很尴尬，因为你通常只想知道创作书籍是成功还是失败。例如，由客户端决定如何处理，而不是由REST端点返回一个id。</p><h1 id="981c" class="ln lo jc bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">为什么您应该了解GraphQL</h1><h2 id="ccff" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">简史</h2><p id="ee2c" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">GraphQL由脸书的内部团队制作，但在2015年发布到开源社区。大约在2012年的某个时候，脸书团队想要解决他们在REST API中发现的一些问题。移动应用程序由于大量过度提取数据而变得越来越慢。他们在多个客户端应用程序之间共享API，改变一个端点会被认为是对一个客户端应用程序的重大改变。</p><h2 id="c11f" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">它还在增长</h2><figure class="nc nd ne nf gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nb"><img src="../Images/e58d7ecf89a33a1ac60392bc216fa7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*84p_dsWHvibrf-yX.png"/></div></div></figure><p id="2f0f" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在JS 2019 调查的<a class="ae mk" href="https://2019.stateofjs.com/data-layer/graphql/#graphql_experience" rel="noopener ugc nofollow" target="_blank">状态中，JavaScript社区中大约6%的开发者仍然不熟悉它，但其余大多数人表示对它感兴趣。自2015年开源社区成立以来，它一直在逐步成长。开源社区真的已经运行了这个API规范，并且正在构建更多的工具来进一步发展这个东西。</a></p><h2 id="52af" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">连接到多个数据源</h2><p id="276e" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">我习惯于使用直接连接到数据库的API创建一个三层应用程序，因此重新启动API来利用GraphQL的好处可能看起来像是一次大的检修。事实并非如此，事实上，该社区有极好的资源来利用您已经存在的REST API来生成GraphQL层。因此，使用您的REST API、数据库或现有的GraphQL API，您可以为所有应用创建一个统一的端点。</p><h2 id="0a2a" class="mp lo jc bd lp mq mr dn lt ms mt dp lx la mu mv lz le mw mx mb li my mz md na bi translated">支持</h2><p id="fa78" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">脸书哪儿也不去，他们制造了伟大的工具，帮助开源社区创造伟大的东西。如果你是一个React开发者，你应该知道这一切！开源也在工具方面大展拳脚，使之成为更好的开发者体验。我最喜欢的一个是<a class="ae mk" href="https://graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> graphql-code-generator </a>，我们可以在创建模式后自动生成类型脚本类型和类型-graphql类型。</p><h1 id="3612" class="ln lo jc bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">第二部分。使用REST API创建GraphQL API</h1><p id="f9a8" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">如果你有兴趣学习使用REST API作为你的数据源来创建一个graph QL API<a class="ae mk" href="https://medium.com/javascript-in-plain-english/create-a-graphql-api-wrapper-for-your-rest-api-7873c63fcce2" rel="noopener">请继续阅读</a>第二部分，在那里你会用JavaScript创建你自己的<a class="ae mk" href="http://covid-act-now-graphql.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">新冠肺炎GraphQL API </a>。</p><h1 id="10cb" class="ln lo jc bd lp lq lr ls lt lu lv lw lx ki ly kj lz kl ma km mb ko mc kp md me bi translated">摘要</h1><p id="c4be" class="pw-post-body-paragraph kr ks jc kt b ku mf kd kw kx mg kg kz la mh lc ld le mi lg lh li mj lk ll lm ig bi translated">REST和GraphQL是共享数据的有用规范。REST是可伸缩的、无状态的，并且非常擅长分离关注点。GraphQL试图建立在REST的不足之上，REST需要多次请求来获取客户端、版本控制和手动文档所需的所有信息。我们学习了REST和GraphQL之间的基本区别，以及它们的各种术语，比如查询和突变。GraphQL的增长得益于开源软件开发和开发者体验满意度。如果您还没有，请尝试一下。</p></div></div>    
</body>
</html>