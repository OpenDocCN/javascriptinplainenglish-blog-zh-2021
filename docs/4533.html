<html>
<head>
<title>Demystifying JavaScript Code Execution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘JavaScript代码执行</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-javascript-code-execution-b9f99b98485b?source=collection_archive---------15-----------------------#2021-09-09">https://javascript.plainenglish.io/demystifying-javascript-code-execution-b9f99b98485b?source=collection_archive---------15-----------------------#2021-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9608ebbe1147e59e91f5b1afccc13c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_xPtCvl6Qd7Jfc4S"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@cebbbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Robin Ebbinghaus</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="12bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript是一种<strong class="kc io">单线程</strong>、<strong class="kc io">动态类型化、</strong>和<strong class="kc io">词汇作用域</strong>语言。我知道这对你来说可能听起来像术语，但是让我们试着通过分解来理解它。</p><p id="82f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">单线程</strong>是指JavaScript在给定时间内只能执行一条语句。换句话说，JavaScript是一种<strong class="kc io">同步语言</strong>。</p><p id="0307" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">动态类型化</strong>意味着变量的类型完全取决于存储在变量内部的值的类型。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ec58" class="lh li in ld b gy lj lk l ll lm"><br/>var variableOne = 1;<br/>console.log(typeof variableOne) // Prints “number”<br/>variableOne = “Hello”;<br/>console.log(typeof variableOne) // Prints “string”<br/></span></pre><p id="18dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码片段清楚地展示了变量的类型是如何根据被赋值的值而变化的。</p><p id="5f07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">词汇作用域</strong>是子函数访问变量直到其父作用域的能力，反之亦然。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/3cca8a72f3b21599915ee4a00138a7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRC-ZqLBLMNGylAgNsEzkg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Scope chain</figcaption></figure><p id="d2ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上图是词法作用域的清晰表示，其中<strong class="kc io">函数C </strong>可以访问<strong class="kc io">函数C、函数B、函数A和全局函数中存在的所有变量；</strong> <strong class="kc io">函数B </strong>可以访问<strong class="kc io">函数B、函数A和全局函数</strong>中存在的所有变量；<strong class="kc io">函数A </strong>可以访问<strong class="kc io">函数A和全局函数</strong>中的所有变量，而<strong class="kc io">全局函数</strong>只能访问<strong class="kc io">全局函数</strong>中的变量。这清楚地证明了子函数可以访问父函数的范围，而父函数不能访问子函数的范围。</p><p id="6ff5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在继续之前，让我首先介绍理解JavaScript代码执行所需的两个重要组件。</p><p id="c031" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">执行上下文</strong> —这些是每当Javascript引擎执行代码时创建的部分。有两个执行上下文——<strong class="kc io">全局执行上下文</strong>和<strong class="kc io">函数执行上下文</strong>。</p><p id="2be5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">全局执行上下文</strong>是引擎开始执行代码时创建的第一个上下文。这被称为<strong class="kc io">全局()</strong>或<strong class="kc io">主()</strong>函数。<strong class="kc io">函数执行上下文</strong>是在代码中遇到函数调用语句时创建的上下文。这两种上下文都有两个阶段——创建阶段和执行阶段。创建阶段是JavaScript创建一个<strong class="kc io">全局对象的阶段——在浏览器的情况下是窗口，在Node.js </strong>的情况下是全局，一个类型为<strong class="kc io"> object </strong>的变量，称为<strong class="kc io"> this </strong>，引用<strong class="kc io">全局对象</strong>，并分配一个<strong class="kc io">内存堆</strong>存储所有变量和函数声明，其中变量的值被设置为<strong class="kc io"> undefined </strong>。函数执行上下文的创建阶段略有不同。代替<strong class="kc io">全局对象，</strong>创建了<strong class="kc io">参数对象</strong>，该对象引用了传递给函数的所有参数。执行阶段是Javascript逐行执行代码的阶段。这也是变量被赋予实际值并执行代码中所有函数调用的阶段。</p><p id="b1b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">调用栈</strong> —这是Javascript管理全局和函数执行上下文的部分。从名字本身就很清楚这一段是用<strong class="kc io">栈</strong>的原理工作的。当Javascript开始执行代码时，第一个上下文(全局执行上下文)被推入堆栈。此后，每当遇到函数调用时，它就将该函数的函数执行上下文推入堆栈。类似地，每当一个函数完成时，该函数的函数执行上下文将从堆栈中弹出。当调用堆栈完全为空时，代码执行停止。</p><p id="55db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们试着理解Javascript代码执行的端到端流程。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1059" class="lh li in ld b gy lj lk l ll lm">var counter = 0;<br/>function increment() {<br/> counter++<br/>}</span><span id="096e" class="lh li in ld b gy lo lk l ll lm">function addNumberToCounter(number) {<br/> var result = counter + number;<br/> console.log(result);<br/>}</span><span id="29cd" class="lh li in ld b gy lo lk l ll lm">increment();<br/>addNumberToCounter(5);</span></pre><p id="1170" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，Javascript引擎创建一个全局执行上下文，并开始创建阶段。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/852bc7d7dbad8cd45dd63bd136f97d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iikzTn7_mNUkYF_n2UhOvg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Creation Phase</figcaption></figure><p id="064a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个阶段，JavaScript引擎解析代码，识别所有变量和函数声明，并将它们存储在内存堆中，所有变量的值都设置为<strong class="kc io"> undefined </strong>。</p><p id="d3a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建阶段结束后，它开始执行阶段。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/2c769bef26c8ab7e47132f298eb81038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FjqXslaaTCnIHjUytBQ2vA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Execution Phase</figcaption></figure><p id="b8cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，JavaScript引擎开始逐行执行代码。在我们的例子中，它将从<strong class="kc io"> var counter = 0 </strong>开始。当它遇到这个语句时，它检查内存中是否存在该变量，并根据语句将值设置为0。执行完这条语句后，它移动到下一行，在我们的例子中是<strong class="kc io">函数increment(){…} </strong>。因为这是一个声明语句，所以它跳过了整个功能块(第3–6行)。这里需要注意的一点是，函数只有在被调用时才会被执行。因为下一行也是一个函数声明，所以它跳过了整个函数块(第7到10行)。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/cbbe1ee7e29e0850b4918ae5fa4b36c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xL2QJ9ycCtXLs63Y6uqnpA.png"/></div></div></figure><p id="1765" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当它遇到标识符<strong class="kc io">增量</strong>时，它检查该标识符是否存在于存储器中，并执行存储在存储器中的功能代码。当引擎在标识符后遇到<strong class="kc io"> () </strong>时，它识别函数执行。当调用该函数时，它会创建一个函数执行上下文，并将其推送到调用堆栈。在创建阶段，arguments对象被创建，<strong class="kc io">这个</strong>变量将引用全局对象(窗口)并检查函数代码中是否存在任何其他声明语句。在这个阶段之后，执行阶段开始。当它遇到语句<strong class="kc io"> counter++ </strong>时，它检查该变量是否存在于函数执行上下文的本地内存中。当它没有找到变量时，它向上移动一级，这是全局执行上下文，并搜索变量<strong class="kc io">计数器</strong>。当它找到变量时，它获取值并执行<strong class="kc io"> ++ </strong>操作，这将变量的当前值增加1。现在，计数器变量将被更新为新值1。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/a8e0802bc00fc0fa08b834f4bf9c559f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiuyXiU6tdwU70HaRCju7w.png"/></div></div></figure><p id="4218" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着函数中所有语句的执行，增量函数的函数执行上下文从调用堆栈中弹出并销毁。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/f9685686b2f4d38a9c6aa6857d078384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suxmKk-SeTOGJdzDqNWCEg.png"/></div></div></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/642760ec15972001f510b180cd2c69ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ytti0JGVqTj6GqWynycHEA.png"/></div></div></figure><p id="739d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，引擎返回到当前位于调用堆栈顶部的全局执行上下文。它移动到下一行并执行下一个函数调用(addNumberToCounter(number))，类似于increment函数。这里唯一的区别是addNumberToCounter(number)函数由传递给该函数的参数值5组成。在创建阶段，创建arguments对象，它将包含传递给函数的所有参数。在这种情况下，number将是arguments对象中的一个值。在执行阶段，它在函数执行上下文的本地存储器中检查变量“result”。当它存在时，它将计算表达式<strong class="kc io"> counter + number </strong>，其中它分别从全局和本地内存中获取counter和number的值。评估结果6将被分配给存在于本地存储器中的结果变量。然后，它移到下一行并执行<strong class="kc io"> console.log(result) </strong>语句。这将打印该函数本地存储器中的<strong class="kc io">结果</strong>的值。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/f9685686b2f4d38a9c6aa6857d078384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suxmKk-SeTOGJdzDqNWCEg.png"/></div></div></figure><p id="f41e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦执行阶段结束，函数执行上下文(<strong class="kc io">addNumberToCounter(number)</strong>)从堆栈中弹出，销毁并移回全局执行上下文。当引擎确定不再有要执行的行时，它从调用堆栈中弹出全局执行上下文并销毁执行上下文。</p><p id="b4f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">#谢谢你！</p><p id="7722" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你觉得这篇文章有用，请表达你的爱，并通过你的社交媒体与你的同伴分享，这样其他人可以最大限度地利用它。请随时通过Twitter、LinkedIn或电子邮件与我联系。</p><p id="367a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">直到我们再次见面，<strong class="kc io">Mallu Dev</strong>结束👋干杯！🥂</p><p id="53a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ls">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ls">plain English . io</em></strong></a></p></div></div>    
</body>
</html>