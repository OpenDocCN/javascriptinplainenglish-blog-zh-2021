<html>
<head>
<title>Docker Builds for NestJS Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于NestJS应用程序的Docker构建</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/more-on-docker-build-for-nestjs-projects-d1237eefea2?source=collection_archive---------10-----------------------#2021-05-15">https://javascript.plainenglish.io/more-on-docker-build-for-nestjs-projects-d1237eefea2?source=collection_archive---------10-----------------------#2021-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="041f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Docker构建自己的NestJS项目的另一种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/53b8a639927a5ba6401fcb33bb76f887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_sFAexDy8Vqtr_tYBEPvA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Thanks to <a class="ae kv" href="https://unsplash.com/photos/_PcWGCSoqRg" rel="noopener ugc nofollow" target="_blank">Andrey</a></figcaption></figure><h2 id="70ba" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是NestJS？</h2><p id="571a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">NestJS是一个为NodeJS开发者构建后端应用程序的不可思议的框架，它主要使用了普通的ExpressJS，不仅如此。该框架非常统一且对企业友好。如果您有兴趣了解更多关于NestJS的内容，请阅读我写的关于如何用NestJS 编写<a class="ae kv" href="https://makinhs.medium.com/creating-a-rest-api-series-with-nestjs-part-01-scaffolding-and-basic-cli-usage-30ace19c5bb8" rel="noopener"> REST API的文章</a></p><h2 id="592c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Docker build有什么问题？</h2><p id="c7e0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">当使用容器运行应用程序时，尤其是使用NodeJS应用程序时，您通常希望构建速度更快，并且不会消耗太多内存。使用NestJS进行基本构建时，不需要太多的关注就可以轻松达到1gb，这将消耗您的CI/CD管道中的时间以及大量的内存浪费。如果你想快速解决这个问题，你可以看看我以前写的关于NestJS 的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/create-reduced-docker-images-in-your-nestjs-application-b25ab32a840d"> docker图片的文章。</a></p><p id="8958" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">当我说一个基本的docker文件时，我的意思是这样的:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a5cb" class="kw kx iq mr b gy mv mw l mx my">FROM node:14.15.0-alpine3.10<br/><br/>USER 2000<br/>RUN mkdir -p /home/node/app/node_modules &amp;&amp; chown -R 2000:2000 /home/node/app<br/><br/>WORKDIR /home/node/app<br/>COPY --chown=2000:2000 . /home/node/appRUN yarn installRUN yarn build<br/><br/>EXPOSE 3000<br/><br/>ENTRYPOINT ["node"]<br/>CMD ["/home/node/app/dist/main.js"]</span></pre><p id="7858" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这将创建大约900mb的图像。</p><p id="87ef" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对于简单的解决方案，基于我以前的文章，您可以开始使用multi build来构建您的项目，最新的方法如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ec15" class="kw kx iq mr b gy mv mw l mx my">FROM node:16-alpine3.11 AS <em class="mz">BUILD_IMAGE<br/><br/></em>RUN apk update &amp;&amp; apk add yarn curl bash make &amp;&amp; rm -rf /var/cache/apk/*<br/><br/>RUN curl -sfL https://install.goreleaser.com/github.com/tj/node-prune.sh | bash -s -- -b /usr/local/bin<br/><br/>WORKDIR /usr/src/app<br/><br/># install dependencies<br/>RUN yarn --frozen-lockfile<br/><br/>COPY . .<br/><br/>RUN yarn install<br/>RUN yarn build<br/><br/>RUN npm prune --production<br/><br/>RUN /usr/local/bin/node-prune<br/><br/>FROM node:16-alpine3.11<br/><br/>USER 1000<br/>RUN mkdir -p /home/node/app/<br/>RUN mkdir -p /home/node/app/node_modules<br/>RUN mkdir -p /home/node/app/dist<br/><br/>RUN chown -R 1000:1000 /home/node/app<br/>RUN chown -R 1000:1000 /home/node/app/node_modules<br/>RUN chown -R 1000:1000 /home/node/app/dist<br/><br/>WORKDIR /home/node/app<br/><br/>COPY --from=<em class="mz">BUILD_IMAGE </em>/usr/src/app/dist /home/node/app/dist<br/>COPY --from=<em class="mz">BUILD_IMAGE </em>/usr/src/app/node_modules /home/node/app/node_modules<br/><br/>EXPOSE 3000<br/>ENTRYPOINT ["node"]<br/>CMD ["/home/node/app/dist/main.js"]</span></pre><p id="e452" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">看起来很棒，最终的图像大约有156mb。但是我们能提高建造的速度吗？</p><p id="64d6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">经过一些研究，我想在建筑过程中有三个图像，但以不同的方式运行:</p><ul class=""><li id="11bb" class="na nb iq lu b lv ml ly mm lf nc lj nd ln ne mk nf ng nh ni bi translated">一个干净的图像，带有我比较喜欢的节点图像(我个人比较喜欢<a class="ae kv" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">官方节点——高山</a>)。从我们的首选基础映像，我们然后安装所有需要的库来运行我们的项目，包括在我们的情况下节点修剪。</li><li id="3fc7" class="na nb iq lu b lv nj ly nk lf nl lj nm ln nn mk nf ng nh ni bi translated">第二个映像安装了我们所需的node_modules，我们可以将其用作“映像依赖项”</li><li id="37ee" class="na nb iq lu b lv nj ly nk lf nl lj nm ln nn mk nf ng nh ni bi translated">最后一个映像将构建项目并准备运行它。</li></ul></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="e77f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">干净的形象</h2><p id="b721" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">为了创建一个干净的映像，我将添加一个公共的<a class="ae kv" href="https://hub.docker.com/repository/docker/makinhs/nestjs-base" rel="noopener ugc nofollow" target="_blank"> docker存储库</a>。它将包含:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4169" class="kw kx iq mr b gy mv mw l mx my">FROM node:16-alpine3.11 AS <em class="mz">base_image<br/><br/></em>RUN apk update &amp;&amp; apk add yarn curl bash make &amp;&amp; rm -rf /var/cache/apk/*<br/><br/>RUN curl -sfL https://install.goreleaser.com/github.com/tj/node-prune.sh | bash -s -- -b /usr/local/bin</span></pre><p id="31a5" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">然后，为了构建，我将已经指向我的名为<a class="ae kv" href="https://hub.docker.com/repository/docker/makinhs/nestjs-base" rel="noopener ugc nofollow" target="_blank"><strong class="lu ir"><em class="mz">makin hs/nestjs-base</em></strong></a>的公共存储库</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c410" class="kw kx iq mr b gy mv mw l mx my">docker build -t makinhs/nestjs-base .</span></pre><p id="8e44" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">很好，这张图片将有助于避免在构建NestJS项目时出现python警告问题，以及在项目运行后安装node-prune以供执行。推送到我的存储库很简单，因为:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1f6a" class="kw kx iq mr b gy mv mw l mx my">docker push makinhs/nestjs-base:latest</span></pre><blockquote class="nv nw nx"><p id="d696" class="ls lt mz lu b lv ml jr lx ly mm ju ma ny mn mc md nz mo mf mg oa mp mi mj mk ij bi translated">请记住，你不会被允许推到我的仓库，但你可以使用这个作为你的基础图像，因为它是公开的；)源文件可以在这里找到<a class="ae kv" href="https://github.com/makinhs/docker-nestjs-base/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="fc1c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">酷，接下来呢？从属关系！</p><h2 id="689f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置依赖关系图像</h2><p id="01ef" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">根据具体情况，可以避免这一步，但是对于我来说，作为概念验证，我希望有一个包含所有必需的node_modules的映像。对于依赖项，我将使用这个<a class="ae kv" href="https://github.com/makinhs/docker-nestjs-dependencies" rel="noopener ugc nofollow" target="_blank"> git库</a>。我想要构建的项目也属于这个<a class="ae kv" href="https://github.com/makinhs/nestjs-api-tutorial/tree/003-docker" rel="noopener ugc nofollow" target="_blank">仓库</a>。暂时，我将从我的NestJS项目中复制package.json，并将其用作我的依赖关系映像存储库的基础。最终，我们的package.json会有这样的内容</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="bb91" class="kw kx iq mr b gy mv mw l mx my">{<br/>  "name": "docker-nestjs-dependencies",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "repository": {<br/>    "type": "git",<br/>    "url": "git+https://github.com/makinhs/docker-nestjs-dependencies.git"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "bugs": {<br/>    "url": "https://github.com/makinhs/docker-nestjs-dependencies/issues"<br/>  },<br/>  "homepage": "https://github.com/makinhs/docker-nestjs-dependencies#readme",<br/>  "scripts": {<br/>    "prebuild": "rimraf dist",<br/>    "build": "nest build",<br/>    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",<br/>    "start": "nest start",<br/>    "start:dev": "nest start --watch",<br/>    "start:debug": "nest start --debug --watch",<br/>    "start:prod": "node dist/main",<br/>    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",<br/>    "test": "jest",<br/>    "test:watch": "jest --watch",<br/>    "test:cov": "jest --coverage",<br/>    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",<br/>    "test:e2e": "jest --config ./test/jest-e2e.json"<br/>  },<br/>  "dependencies": {<br/>    "@nestjs/common": "^7.5.1",<br/>    "@nestjs/config": "^0.6.1",<br/>    "@nestjs/core": "^7.5.1",<br/>    "@nestjs/mapped-types": "^0.2.0",<br/>    "@nestjs/platform-express": "^7.5.1",<br/>    "@nestjs/typeorm": "^7.1.5",<br/>    "bcrypt": "^5.0.0",<br/>    "class-transformer": "^0.3.2",<br/>    "class-validator": "^0.13.1",<br/>    "pg": "^8.5.1",<br/>    "reflect-metadata": "^0.1.13",<br/>    "rimraf": "^3.0.2",<br/>    "rxjs": "^6.6.3",<br/>    "typeorm": "^0.2.30"<br/>  },<br/>  "devDependencies": {<br/>    "@nestjs/cli": "^7.5.1",<br/>    "@nestjs/schematics": "^7.1.3",<br/>    "@nestjs/testing": "^7.5.1",<br/>    "@types/express": "^4.17.8",<br/>    "@types/jest": "^26.0.15",<br/>    "@types/node": "^14.14.6",<br/>    "@types/supertest": "^2.0.10",<br/>    "@typescript-eslint/eslint-plugin": "^4.6.1",<br/>    "@typescript-eslint/parser": "^4.6.1",<br/>    "eslint": "^7.12.1",<br/>    "eslint-config-prettier": "7.1.0",<br/>    "eslint-plugin-prettier": "^3.1.4",<br/>    "jest": "^26.6.3",<br/>    "prettier": "^2.1.2",<br/>    "supertest": "^6.0.0",<br/>    "ts-jest": "^26.4.3",<br/>    "ts-loader": "^8.0.8",<br/>    "ts-node": "^9.0.0",<br/>    "tsconfig-paths": "^3.9.0",<br/>    "typescript": "^4.0.5"<br/>  },<br/>  "jest": {<br/>    "moduleFileExtensions": [<br/>      "js",<br/>      "json",<br/>      "ts"<br/>    ],<br/>    "rootDir": "src",<br/>    "testRegex": ".*\\.spec\\.ts$",<br/>    "transform": {<br/>      "^.+\\.(t|j)s$": "ts-jest"<br/>    },<br/>    "collectCoverageFrom": [<br/>      "**/*.(t|j)s"<br/>    ],<br/>    "coverageDirectory": "../coverage",<br/>    "testEnvironment": "node"<br/>  }<br/>}</span></pre><p id="9dd6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">请记住，这是我从我的NestJS项目中获得的，可以在这里找到<a class="ae kv" href="https://github.com/makinhs/nestjs-api-tutorial/blob/003-docker/package.json" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9a1c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在让我们使用以下内容创建docker文件:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2592" class="kw kx iq mr b gy mv mw l mx my">FROM makinhs/nestjs-base:latest AS <em class="mz">dependencies<br/><br/></em>WORKDIR /usr/src/app<br/><br/># install dependencies<br/>RUN yarn --frozen-lockfile<br/><br/>COPY . .<br/><br/>RUN yarn install</span></pre><p id="819f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">为了发送public，我将存储在这个<a class="ae kv" href="https://hub.docker.com/repository/docker/makinhs/nestjs-dependencies" rel="noopener ugc nofollow" target="_blank"> public repository </a>中，名称设置为makinhs/nestjs-dependencies。</p><blockquote class="nv nw nx"><p id="d955" class="ls lt mz lu b lv ml jr lx ly mm ju ma ny mn mc md nz mo mf mg oa mp mi mj mk ij bi translated">别忘了加上<strong class="lu ir">。使用node_modules来防止构建问题。</strong></p></blockquote><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2fdc" class="kw kx iq mr b gy mv mw l mx my">docker build -t makinhs/nestjs-dependencies .</span></pre><p id="6f42" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这是NodeJS应用程序的缺陷…这个带有node_modules的映像包含大约1gb。如果您的项目不经常添加新的依赖项，为什么不在某个地方设置这个庞然大物呢？这就是为什么在这篇文章中，我试图达到中间依赖图像，以加快建设过程。推到码头的将是:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7bdc" class="kw kx iq mr b gy mv mw l mx my">docker push makinhs/nestjs-dependencies</span></pre><blockquote class="nv nw nx"><p id="3123" class="ls lt mz lu b lv ml jr lx ly mm ju ma ny mn mc md nz mo mf mg oa mp mi mj mk ij bi translated">我现在不关心docker标签，但是在你的项目中，你真的需要在这个意义上更有条理。</p></blockquote></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="a5ab" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">统一各个部分并构建我们的项目</h2><p id="8cde" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">现在，在我们的NestJS项目中，我们将对docker文件进行更新，以尝试和测试构建:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f107" class="kw kx iq mr b gy mv mw l mx my">FROM makinhs/nestjs-dependencies:latest AS <em class="mz">BUILD_IMAGE<br/><br/></em>WORKDIR /usr/src/app<br/><br/>COPY . .<br/><br/>RUN yarn build<br/><br/>RUN npm prune --production<br/><br/>RUN /usr/local/bin/node-prune<br/><br/>FROM makinhs/nestjs-base:latest<br/><br/>USER 1000<br/>RUN mkdir -p /home/node/app/<br/>RUN mkdir -p /home/node/app/node_modules<br/>RUN mkdir -p /home/node/app/dist<br/><br/>RUN chown -R 1000:1000 /home/node/app<br/>RUN chown -R 1000:1000 /home/node/app/node_modules<br/>RUN chown -R 1000:1000 /home/node/app/dist<br/><br/>WORKDIR /home/node/app<br/><br/>COPY --from=<em class="mz">BUILD_IMAGE </em>/usr/src/app/dist /home/node/app/dist<br/>COPY --from=<em class="mz">BUILD_IMAGE </em>/usr/src/app/node_modules /home/node/app/node_modules<br/><br/>EXPOSE 3000<br/>ENTRYPOINT ["node"]<br/>CMD ["/home/node/app/dist/main.js"]</span></pre><p id="97dd" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">请注意，我们使用依赖关系映像来构建映像，然后运行node-prune，并在运行回我们的基本映像后，只获取所需的文件，以最终维持一个简短的构建(请记住，依赖关系得到了大约1gb，我们希望避免这种情况)。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8a26" class="kw kx iq mr b gy mv mw l mx my">docker build -t nestjs-api .</span></pre><p id="9b6b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">您的最终图像大小约为200mb o/</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="99b1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在本文中，我试图提供一个构建NestJS项目的不同方法的概念证明。如果您的项目非常小，并且您可以避免将依赖项用作外部映像，那么这可能会过于复杂。在下一篇文章中，我将提供与一些CI的集成，并使用这个版本的方法与我以前的统一方法进行性能构建测试。</p><p id="6404" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这篇文章更多的是一个概念的证明，而不是指导你建立形象的最佳方法。我对采用这种方法很好奇，但仍然有实际的CI/CD性能测试，并且有一个额外的层来处理package.json依赖关系，这需要在管道中实现一些自动化来避免问题。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><ul class=""><li id="f4f7" class="na nb iq lu b lv ml ly mm lf nc lj nd ln ne mk nf ng nh ni bi translated">带有更新Dockerfile的NestJS分支可以在<a class="ae kv" href="https://github.com/makinhs/nestjs-api-tutorial/tree/003-docker-2" rel="noopener ugc nofollow" target="_blank">这里</a>找到</li><li id="4fb8" class="na nb iq lu b lv nj ly nk lf nl lj nm ln nn mk nf ng nh ni bi translated">依赖项Dockerfile可以在<a class="ae kv" href="https://github.com/makinhs/docker-nestjs-dependencies" rel="noopener ugc nofollow" target="_blank">这里</a>找到</li><li id="2ee3" class="na nb iq lu b lv nj ly nk lf nl lj nm ln nn mk nf ng nh ni bi translated">基本图像Dockerfile可以在<a class="ae kv" href="https://github.com/makinhs/docker-nestjs-base" rel="noopener ugc nofollow" target="_blank">这里</a>找到</li></ul><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/create-reduced-docker-images-in-your-nestjs-application-b25ab32a840d"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">使用NestJS创建REST API第4部分——快速添加一个缩减了图像大小的Dockerfile文件</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">从+900MB到200MB不到五分钟的阅读量！如果你和NestJS一起工作，这篇文章是必须的…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><p id="3342" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><em class="mz">更多内容请看</em><a class="ae kv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lu ir"><em class="mz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>