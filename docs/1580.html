<html>
<head>
<title>Why JavaScript is Bad At Math</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么JavaScript不擅长数学</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-javascript-is-bad-at-math-9b8247640caa?source=collection_archive---------3-----------------------#2021-04-05">https://javascript.plainenglish.io/why-javascript-is-bad-at-math-9b8247640caa?source=collection_archive---------3-----------------------#2021-04-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f093" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">以及如何克服它的局限性</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cbf52e58f6178be1965c6ce593dd1212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aZXd40cSX8ZUq1Ii"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@antoine1003?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Antoine Dautry</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="103c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">给你提个简单的问题:0.1 + 0.7是多少？</p><p id="3eb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你的回答是0.8，恭喜你！你的加法能力比几种计算机编程语言都要好。不，真的。以下是JavaScript对同一问题的回答:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/38ca5e7c4e711bc8fe56b62038b8e097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-O78_Ned8Uw3hfhLbPtryA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Nice try JavaScript, but not quite.</figcaption></figure><p id="89bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript并不孤单；如果您在其他几种编程语言中执行相同的加法，您将得到类似的略微不正确的答案。那么，为什么对于所有可以在代码中执行的复杂操作，某些简单的计算会出错呢？答案在于JavaScript如何在内存中存储数值。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="cef3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们深入了解这些值是如何存储在内存中的之前，我们需要先谈谈数字，以及我们表示它们的不同方式。</p><p id="c6d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可以说，在它们最简单的形式中，有整数，例如<code class="fe lx ly lz ma b">5</code>。这种类型的数字没有小数值。</p><p id="d7ef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后是分数，如<code class="fe lx ly lz ma b">1/5</code>。这意味着<code class="fe lx ly lz ma b">1</code>被分成了<code class="fe lx ly lz ma b">5</code>块，通常用值<code class="fe lx ly lz ma b">0.2</code>来表示。我们认为这是一个有限的表示，意味着它停止了。如果我们改为考虑<code class="fe lx ly lz ma b">1/3</code>，这是一个<em class="mb">无限的</em>表示，因为我们可以无限地写<code class="fe lx ly lz ma b">0.3333333333</code>等等来表示这个分数。</p><p id="0692" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里需要做一个区分。我们将<code class="fe lx ly lz ma b">1/5</code>表示为<code class="fe lx ly lz ma b">0.2</code>是一个十进制<em class="mb">数，这意味着它是以<em class="mb">为基数10 </em>写成的。我们会回来的。</em></p><p id="0cae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还有一种表示数字的方式，称为“标准形式”，或“科学符号”。在标准形式中，我们将数字分为两部分:首先，数字本身，一个数字在一个基数点之前，其他数字在它之后，然后是一个要乘以它的值，包括一个基数<em class="mb">和一个指数<em class="mb">的</em>，它将返回初始数字的完整形式。</em></p><p id="255b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可能会从很大或很小的数字中熟悉这个。例如，地球的质量可以写成<code class="fe lx ly lz ma b">5.9724 x 10²⁴ kg</code>，这是一种不用完整写出<code class="fe lx ly lz ma b">5,972,400,000,000,000,000,000,000 kg</code>的便捷方式。这里<code class="fe lx ly lz ma b">10</code>是<em class="mb">基数</em>，而<em class="mb">指数</em>是<code class="fe lx ly lz ma b">24</code>，即基数的幂。这些数字乘以基数的幂的指数被称为<a class="ae ks" href="https://en.wikipedia.org/wiki/Significand" rel="noopener ugc nofollow" target="_blank"> <em class="mb">符号和</em> </a>，或者<em class="mb">尾数，</em>并且这些的数量被称为<em class="mb">精度</em>，所以在上面的例子中我们有一个<code class="fe lx ly lz ma b">5</code>的精度。</p><p id="18b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以用这种方式写出任何数字，而不仅仅是非常大或非常小的数字；如果我们想用这种方式表示数字<code class="fe lx ly lz ma b">1</code>，我们可以把它写成<code class="fe lx ly lz ma b">1.0 x 10⁰</code>。如果我们使用负指数，我们也可以用这种方式表示分数，所以如果我们愿意，我们可以将<code class="fe lx ly lz ma b">1/5</code>表示为<code class="fe lx ly lz ma b"> 2.0 x 10-¹</code>。</p><p id="2a02" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以这种方式书写的数字被称为“浮点数”，指的是移动的基点。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="ffae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以上浮点数的例子使用<em class="mb">作为10 </em>的基数(十进制数)。我们也可以用这种方法用其他基数表示数字。我们对<em class="mb">基数2 </em>(二进制数)特别感兴趣，因为(剧透警报！)这就是JavaScript如何将数字存储在内存中，以及如何引入某些值的不精确性。</p><p id="404d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们将数字<code class="fe lx ly lz ma b">1</code>表示为底数10中的<code class="fe lx ly lz ma b">1.0 x 10⁰</code>，那么底数2中的数字会是多少？嗯，二进制中的<code class="fe lx ly lz ma b">1</code>实际上和十进制中的相同——无论哪种方式，我们只使用数字<code class="fe lx ly lz ma b">1</code>。但是我们现在的基数是<code class="fe lx ly lz ma b">2</code>，而不是<code class="fe lx ly lz ma b">10</code>，所以将数字<code class="fe lx ly lz ma b">1</code>表示为基数2中的浮点数就是<code class="fe lx ly lz ma b">1.0 x 2⁰</code>。</p><p id="6a90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看另一个例子。如果我们取<code class="fe lx ly lz ma b">1/2</code>，用十进制表示，这和说<code class="fe lx ly lz ma b">5/10</code>是一样的。所以为了将<code class="fe lx ly lz ma b">1/2</code>用标准的形式表示出来，我们可以写<code class="fe lx ly lz ma b">5.0 x 10–¹</code>。那么，这在二进制文件中会是什么样子呢？</p><p id="6d04" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好了，开始我们需要把我们的分数转换成二进制:<code class="fe lx ly lz ma b">1/10</code>(二进制中，<code class="fe lx ly lz ma b">10</code>代表<code class="fe lx ly lz ma b">2</code>，和<code class="fe lx ly lz ma b">2⁰/2¹</code>一样，可以化简为<code class="fe lx ly lz ma b">2-¹</code>。因此，在标准形式中，我们将其表示为<code class="fe lx ly lz ma b">1.0 x 2-¹</code>。如果你真的执行这个乘法，你会得到<code class="fe lx ly lz ma b">0.1</code>，这就是<code class="fe lx ly lz ma b">1/2</code>用二进制表示的方式。</p><p id="10ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再举个例子，我们来看<code class="fe lx ly lz ma b">3/4</code>。为了把它转换成二进制，我们有了<code class="fe lx ly lz ma b">11/1000</code>，当我们实际做除法时，这意味着<code class="fe lx ly lz ma b">0.11</code>就是<code class="fe lx ly lz ma b">3/4</code>被写成二进制分数的方式。为了将它转换成浮点，我们将把它写成<code class="fe lx ly lz ma b">1.1 x 2-¹</code>。</p><p id="b0b0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也可以将<code class="fe lx ly lz ma b">3/4</code>表示为<code class="fe lx ly lz ma b">11 x 2-²</code>，或者<code class="fe lx ly lz ma b">0.011 x 2¹</code>。然而，惯例是在基数点之前有一个整数，其余的整数跟在它后面。以这种方式编写的浮点数被认为是<em class="mb">规格化的</em>。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="42b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">到目前为止，一切顺利。我们将<code class="fe lx ly lz ma b">1/2</code>的有限二进制表示作为规范化的浮点数。当我们看分数时，我们的问题开始出现，我们不能用这种形式的有限数字来表示。</p><p id="a2ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们以<code class="fe lx ly lz ma b">1/10</code>为例。在10进制中，我们可以把它写成<code class="fe lx ly lz ma b">1.0 x 10-¹</code>。为了将其从分数转换成浮点数，分子<em class="mb"/>(分数的顶部)变成有效数，分母<em class="mb"/>(分数的底部)被调整为由有效数乘以的基数和指数来表示。</p><p id="7e04" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，当我们试图在base 2中进行同样的转换时，我们遇到了障碍。要把<code class="fe lx ly lz ma b">1/10</code>转换成二进制小数，我们可以把这个写成<code class="fe lx ly lz ma b">1/1010</code>。然而，我们没有办法从2的任意次方得到数字10；2次方数字序列跳过它(2，4，8，16，等等。).因此，在基数为2的情况下，任何分母不能从2的幂得到的分数都将被不精确地存储。</p><p id="5d97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么，我们如何将<code class="fe lx ly lz ma b">1/10</code>存储为浮点二进制数呢？我们必须尽可能接近它。在这种情况下，我们使用指数来计算正确的小数位数，并使用有效数字来尽可能接近二进制的<code class="fe lx ly lz ma b">1/10</code>；在这种情况下<code class="fe lx ly lz ma b">1.10011001100110011001101 × 2-⁴</code>，与<code class="fe lx ly lz ma b">0011</code>无限重复。</p><p id="8382" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这类似于在十进制中我们不能将<code class="fe lx ly lz ma b">1/3</code>有限地表示为一个有限的数。在10进制中，只有那些分母可以被消去到10次方序列中的数字的分数才能被精确地写成十进制数，这就是为什么像<code class="fe lx ly lz ma b">1/3</code>、<code class="fe lx ly lz ma b">1/6</code>或<code class="fe lx ly lz ma b">1/9</code>这样的分数是无限的。十进制中我们能得到的最接近<code class="fe lx ly lz ma b">1/3</code>的是<code class="fe lx ly lz ma b">0.33333333</code>无限重复。同样的问题发生在base 2中，原因完全相同；<code class="fe lx ly lz ma b">1/3</code>为二进制浮点数会是<code class="fe lx ly lz ma b">1.01010101010101010101010 x 2-²</code>，无限重复。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="a23e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么这一切是如何转化为JavaScript数字有时不精确的呢？</p><p id="6171" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript将数字作为浮点二进制数存储在内存中，这就是用这种格式表示<code class="fe lx ly lz ma b">1/10</code>或<code class="fe lx ly lz ma b">1/3</code>的原因。JavaScript根据IEEE 754标准存储数字，IEEE 754标准是由电气和电子工程师协会建立的浮点运算标准，特别是双精度格式。</p><p id="793a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以这种方式存储的数字总是以2为基数存储。数字以2为基数存储的原因是，一位(计算机可用的最小内存)只能存储两个值:<code class="fe lx ly lz ma b">0</code>和<code class="fe lx ly lz ma b">1</code>，这有助于存储二进制数。</p><p id="459c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">双精度IEEE754格式意味着一个数字正好使用64位在内存中存储一个数值。在这64位中，1位用于存储<strong class="kv io">符号</strong>，11位用于存储<strong class="kv io">指数</strong>，52位用于存储<strong class="kv io">小数</strong>(有效数字)。所有这些给了我们每个数字的2⁶⁴潜在价值(大约18万亿分之一)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mc"><img src="../Images/12bd1e00e8762509dfa163fecb981405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKDJ_h252f-Dumjd_b92MQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The breakdown of a number stored in Double Precision IEEE754 format</figcaption></figure><p id="5818" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们更详细地看看这些:</p><ul class=""><li id="f28b" class="md me in kv b kw kx kz la lc mf lg mg lk mh lo mi mj mk ml bi translated"><strong class="kv io">符号</strong>决定数字是正数还是负数。</li><li id="4c7a" class="md me in kv b kw mm kz mn lc mo lg mp lk mq lo mi mj mk ml bi translated"><strong class="kv io">指数</strong>保存基数的递增数。这11位给我们从<code class="fe lx ly lz ma b">0</code>到<code class="fe lx ly lz ma b">2047</code>的<code class="fe lx ly lz ma b">2048</code>值存储在这里。基数永远是<code class="fe lx ly lz ma b">2</code>，不需要指定这个。没有符号来确定指数本身是正的还是负的；相反，它以<em class="mb">偏移</em>的形式存储，这意味着从存储的指数中减去数字<code class="fe lx ly lz ma b">1023</code>。同样地，<code class="fe lx ly lz ma b">1023</code>存储<code class="fe lx ly lz ma b">0</code>的值，负指数存储在<code class="fe lx ly lz ma b">1</code>和<code class="fe lx ly lz ma b">1022</code>之间(当考虑偏差时，<code class="fe lx ly lz ma b">-1022</code>和<code class="fe lx ly lz ma b">-1</code>)，正指数存储在<code class="fe lx ly lz ma b">1023</code>和<code class="fe lx ly lz ma b">2046</code>之间(当考虑偏差时，<code class="fe lx ly lz ma b">0</code>和<code class="fe lx ly lz ma b">1023</code>)。指数全为0或全为1的情况保留给特殊数字<code class="fe lx ly lz ma b">Infinity</code>和<code class="fe lx ly lz ma b">NaN</code>(由分数中跟随它们的数字区分)。这种与符号结合的编码是JavaScript解释<code class="fe lx ly lz ma b">-Infinity</code>和<code class="fe lx ly lz ma b">Infinity</code>的方式，也导致JavaScript具有不同的值<code class="fe lx ly lz ma b">+0</code>和<code class="fe lx ly lz ma b">-0</code>。</li><li id="07ff" class="md me in kv b kw mm kz mn lc mo lg mp lk mq lo mi mj mk ml bi translated"><strong class="kv io">分数</strong>(有效位)由52位组成，但是假设这些数字都是<em class="mb">规格化的</em>，那么可以省略基点之前的初始<code class="fe lx ly lz ma b">1</code>，因此实际上有53位可以存储这些数字。</li></ul><p id="5b15" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您想亲自看看不同的数字是如何以这种格式编码的，这个<a class="ae ks" href="https://www.h-schmidt.net/FloatConverter/" rel="noopener ugc nofollow" target="_blank">浮点转换器工具</a>是一个很好的起点(它使用单精度而不是双精度，但想法是非常相同的)。</p><p id="a97b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">值得一提的是，虽然64位精度为我们提供了大范围的数字，但也有局限性。如果您试图使用一个大于该存储器允许的数，它将溢出<em class="mb"> </em>并导致一个无穷大的值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/352517ff3f3296cf6f0999e5f1b694f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0jmlPIj9LBNCGUzjD7vYg.png"/></div></div></figure></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="01bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于我们不能以这种方式以有限形式存储某些分数(例如<code class="fe lx ly lz ma b">1/10</code>和<code class="fe lx ly lz ma b">1/3</code>)，这就是为什么当我们尝试使用这些分数进行计算时，JavaScript会给出稍微偏离的结果——实际上我们看到的是<em class="mb">舍入误差</em>。这些舍入误差以一个称为<em class="mb"> ulps </em>的单位(最后一位的单位)来衡量——有关这方面的更多信息可在本文中找到。</p><p id="cdb2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于在JavaScript中存储浮点数的双精度格式有效地为我们提供了53位的有效精度，因此舍入误差非常小。然而，当我们看到这样的结果时，这对我们没有帮助:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/1328914ee772ffb067166598da41f24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QKkhJEOS31hkgeFCGqgZg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Frustrating.</figcaption></figure><p id="9899" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这有道理；这相当于检查<code class="fe lx ly lz ma b">0.3333333 + 0.666666 = 1</code>。<code class="fe lx ly lz ma b">0.1</code>和<code class="fe lx ly lz ma b">0.2</code>也是类似的不精确表示，所以不会完全加起来就是<code class="fe lx ly lz ma b">0.3</code>。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><p id="4406" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们明白了问题的原因，我们该如何解决这个问题呢？</p><p id="12f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个建议是将数字存储为整数，而不是分数，然后根据需要执行任何必要的操作。例如，在电子商务中，以美分而不是美元存储价格，然后在前端计算美元价格。这当然比让你的客户偶尔看到<code class="fe lx ly lz ma b">$10.00</code>和<code class="fe lx ly lz ma b">$25.99</code>的组合价格显示为<code class="fe lx ly lz ma b">$35.989999999999995</code>要好。如果你使用这种方法，请记住不是所有的货币都有和美元一样的分数系统，所以你不必对所有的货币执行相同的操作；例如，日元只使用整数，没有小数值。</p><p id="93f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你想产生一个整数，并需要消除不精确，另一个选择是使用内置的数学方法，如:</p><ul class=""><li id="f5ee" class="md me in kv b kw kx kz la lc mf lg mg lk mh lo mi mj mk ml bi translated"><code class="fe lx ly lz ma b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round" rel="noopener ugc nofollow" target="_blank">Math.round()</a></code>，将任意数字四舍五入到最接近的整数。</li><li id="5076" class="md me in kv b kw mm kz mn lc mo lg mp lk mq lo mi mj mk ml bi translated"><code class="fe lx ly lz ma b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor" rel="noopener ugc nofollow" target="_blank">Math.floor()</a></code>，将任意数字向下舍入到最接近的整数。</li><li id="5f4a" class="md me in kv b kw mm kz mn lc mo lg mp lk mq lo mi mj mk ml bi translated"><code class="fe lx ly lz ma b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil" rel="noopener ugc nofollow" target="_blank">Math.ceil()</a></code>，将任意数字向上舍入到最接近的整数。</li><li id="42c4" class="md me in kv b kw mm kz mn lc mo lg mp lk mq lo mi mj mk ml bi translated"><code class="fe lx ly lz ma b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc" rel="noopener ugc nofollow" target="_blank">Math.trunc()</a></code>，这将删除任何小数(Internet Explorer不支持)。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7767" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您也可以使用<code class="fe lx ly lz ma b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed" rel="noopener ugc nofollow" target="_blank">toFixed(n)</a></code>方法，其中n是您想要包含的小数位数。类似的还有<code class="fe lx ly lz ma b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision" rel="noopener ugc nofollow" target="_blank">toPrecision(n)</a></code>，其中n表示精度的级别。如果使用它们，请记住它们都返回字符串，因此在对它们执行任何进一步的操作之前，需要将它们转换回数字。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="05d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，有许多JavaScript库是专门为处理浮点数而设计的，比如<a class="ae ks" href="https://github.com/guipn/sinful.js/wiki/API#math" rel="noopener ugc nofollow" target="_blank">sinsic . js</a>和<a class="ae ks" href="https://mathjs.org/docs/datatypes/fractions.html" rel="noopener ugc nofollow" target="_blank"> math.js </a>。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="e5cf" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">结论</h1><p id="b12c" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">最后，让我们回到最初的0.1 + 0.7的例子，看看我们如何使用这些方法来得到我们可能期望的结果。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ecf4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mb">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>