<html>
<head>
<title>Let’s Revisit Natural Sorting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们重温一下JavaScript中的自然排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/revisiting-natural-sorting-in-javascript-68b8e8c6f2af?source=collection_archive---------9-----------------------#2021-10-12">https://javascript.plainenglish.io/revisiting-natural-sorting-in-javascript-68b8e8c6f2af?source=collection_archive---------9-----------------------#2021-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/50ebdb03bff0d221d77347ab93312bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klajm53LVDoX9oG1qeaGlA.jpeg"/></div></div></figure><p id="0f1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个故事中，我重温了我的自然排序旧算法，将其与原生JavaScript实现进行了比较，并发现了有趣的差异。</p><h1 id="d18d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">自然分类</h1><p id="0933" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我在这里引用维基百科的定义:</p><blockquote class="lw lx ly"><p id="564d" class="jv jw lz jx b jy jz ka kb kc kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ks ig bi translated">在计算中，<strong class="jx io">自然排序顺序</strong>(或<strong class="jx io">自然排序</strong>)是按照<a class="ae md" href="https://en.wikipedia.org/wiki/Alphabetical_order" rel="noopener ugc nofollow" target="_blank">字母顺序</a>对字符串进行的<a class="ae md" href="https://en.wikipedia.org/wiki/Collation" rel="noopener ugc nofollow" target="_blank">排序，除了多位数被自动处理，即，就像它们是单个字符一样。</a></p></blockquote><h1 id="b6f9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Webpack版本</h1><p id="f71b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">有很多使用自然排序的用例，但是作为开发人员，一个有趣的用例是列出产品的版本。</p><p id="18d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在您的JS项目中尝试这个命令:<code class="fe me mf mg mh b">npm view webpack versions</code>(您可以将<em class="lz"> webpack </em>更改为您感兴趣的任何库)。</p><p id="3deb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它返回一个巨大的按自然顺序排序的字符串列表。下面是输出中的两个片段(连接在一起):</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3a28" class="mq ku in mh b gy mr ms l mt mu">‘4.9.1’, ‘4.9.2’, ‘4.10.0’, ‘4.10.1’, ‘5.0.0-alpha.8’, ‘5.0.0-alpha.9’, ‘5.0.0-alpha.10’, ‘5.0.0-alpha.11’</span></pre><p id="3156" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，这个列表是自然顺序的！具体来说，<em class="lz"> 4.9.2 </em>显示在<em class="lz"> 4.10.0 </em>之前，即使<code class="fe me mf mg mh b">'4.9.2' &lt; '4.10.0'</code>为假。对于5 . 0 . 0-α9和5 . 0 . 0-α10也发生同样的情况</p><p id="4b85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很明显，在这个用例中，字母顺序是完全不够的。在浏览器控制台中尝试以下操作:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="483d" class="mq ku in mh b gy mr ms l mt mu">[‘4.9.1’, ‘4.9.2’, ‘4.10.0’, ‘4.10.1’, ‘5.0.0-alpha.8’, ‘5.0.0-alpha.9’, ‘5.0.0-alpha.10’, ‘5.0.0-alpha.11’].sort()</span></pre><p id="5349" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0934" class="mq ku in mh b gy mr ms l mt mu">[‘4.10.0’, ‘4.10.1’, ‘4.9.1’, ‘4.9.2’, ‘5.0.0-alpha.10’, ‘5.0.0-alpha.11’, ‘5.0.0-alpha.8’, ‘5.0.0-alpha.9’]</span></pre><h1 id="1a19" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">整理</h1><p id="f252" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">每个排序都是两个因素的结果:排序算法和比较函数(比较器)。</p><p id="da8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有大量关于排序算法的文献，JavaScript的<em class="lz"> sort </em>方法选择最适合被排序的数组类型的方法。</p><p id="c455" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该算法定义了如何构造排序后的数组，但是它不知道数组元素之间的顺序关系。</p><p id="a9b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顺序完全由比较函数定义:给定两个数组元素，比如说<em class="lz"> a </em>和<em class="lz"> b，</em>决定<em class="lz"> a </em>是大于、等于还是小于<em class="lz"> b </em>的函数(对于每种情况，它分别返回1、0或-1)。</p><h1 id="fae1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">JavaScript中的自然排序</h1><p id="2d41" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在JavaScript中，支持自然排序比较作为<em class="lz">区域设置</em>比较的一个选项。</p><p id="fc04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，区域比较处理这样一个事实，即在德语字母表中<em class="lz">的</em>紧跟在<em class="lz"> a、</em>之后，而在瑞典语字母表中，它在<em class="lz"> z </em>之后。</p><p id="dee2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">比较器的行为由两个参数决定:地区代码和选项的<em class="lz">集合</em>。</p><p id="d115" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在可用选项中，例如有<em class="lz">区分大小写</em>(<em class="lz">A</em>等于或不同于<em class="lz"> A </em>)或<em class="lz">忽略标点符号</em>(T10)b？等于或不同于<em class="lz"> b)。</em></p><p id="6c7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过指定<em class="lz">数字</em>选项得到一个自然排序比较器。我们不关心任何特殊的字母顺序，所以我们将使用<em class="lz">未定义的</em>本地代码。</p><p id="ad62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用区域设置比较有两种方式:</p><ul class=""><li id="607c" class="mv mw in jx b jy jz kc kd kg mx kk my ko mz ks na nb nc nd bi translated">字符串方法<em class="lz"> localeCompare。</em>比较函数是在每次调用时构建的，因此这个选项对于排序大型集合来说效率很低。</li><li id="58a4" class="mv mw in jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated">国际机场。允许定义比较函数引用的排序器构造函数:</li></ul><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2492" class="mq ku in mh b gy mr ms l mt mu">natOrdCmp = new Intl.Collator(undefined, {numeric: true}).compare</span></pre><p id="0d0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个比较函数允许我们取回<em class="lz">自然的</em>版本列表:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="edc6" class="mq ku in mh b gy mr ms l mt mu">[‘4.10.0’, ‘4.10.1’, ‘4.9.1’, ‘4.9.2’, ‘5.0.0-alpha.10’, ‘5.0.0-alpha.11’, ‘5.0.0-alpha.8’, ‘5.0.0-alpha.9’].sort(natOrdCmp)</span></pre><h1 id="799d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">微笑比哭泣少</h1><p id="23c7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">显然微笑比悲伤更有价值。然而，natOrdCmp('😃','😢)给出-1。</p><p id="bcad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">表情符号(只有<em class="lz">基本</em>表情符号)是字符(或者更好的Unicode <em class="lz">代码点</em>)，在UTF16中由两个16位<em class="lz">代码单元编码。</em>对应的两个<em class="lz">码位</em>属于Unicode特殊<em class="lz">码位</em>的范围，称为<em class="lz">代理</em>(它们不代表任何可见的char)。</p><p id="ec00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">表情符号属于一个<em class="lz">补充Unicode平面</em>。在UTF16中，所有辅助平面由两个16位<em class="lz">代码单元</em>编码，而<em class="lz">基本多语言平面(</em> BMP)的<em class="lz">代码点</em>也包括代理，使用单个<em class="lz">代码单元</em>编码。</p><p id="b829" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代理的行为类似于BMP的其他16位<em class="lz">字符</em>:它们由chartAt方法(或者现代语法&lt;字符串&gt;【index】)返回，并且它们有一个相应的数字字符代码。所以后面将要描述的算法也适用于BMP范围之外的字符。</p><p id="cf74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">'😃[0] = '\uD83D' …'😃[1] = '\uDE03' …'😃[2] =未定义</p><h1 id="589b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">自然排序比较的基本算法</h1><p id="075e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了介绍自然排序的实现，我从字母比较函数开始，并添加了<em class="lz">数字</em>特异性。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="56c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前缀的测试基于这样的事实，例如<code class="fe me mf mg mh b">'abc'[3]</code>是<code class="fe me mf mg mh b">undefined</code></p><h2 id="b627" class="mq ku in bd kv nl nm dn kz nn no dp ld kg np nq lh kk nr ns ll ko nt nu lp nv bi translated">单词中的比较算法</h2><p id="f61b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">算法来源于开头提到的明确定义:</p><ol class=""><li id="0bb5" class="mv mw in jx b jy jz kc kd kg mx kk my ko mz ks nw nb nc nd bi translated">只要给定位置的两个字符都不是数字，就遵循字母顺序。</li><li id="82ca" class="mv mw in jx b jy ne kc nf kg ng kk nh ko ni ks nw nb nc nd bi translated">当有两个数且位数不相等时，位数最少的数最小。</li><li id="3d51" class="mv mw in jx b jy ne kc nf kg ng kk nh ko ni ks nw nb nc nd bi translated">如果数字的位数相同，则按字母顺序排列。</li></ol><p id="234b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第2点)仅当我们排除了<em class="lz">前导零的可能性时才有效。我将在专门的部分讨论这一点。</em></p><h2 id="80f5" class="mq ku in bd kv nl nm dn kz nn no dp ld kg np nq lh kk nr ns ll ko nt nu lp nv bi translated">测试是否为数字</h2><p id="6bb9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">测试一个字符是否是一个数字非常简单，它是一个<em class="lz">单表达式</em>函数:</p><p id="a471" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe me mf mg mh b">const isDigit = c =&gt; c&gt;='0' &amp;&amp; c&lt;='9'</code></p><p id="fd75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为太简单了，底层的性能问题就更明显了:我们在比较字符串。这将在下面几行中更好地讨论。</p><h2 id="ceca" class="mq ku in bd kv nl nm dn kz nn no dp ld kg np nq lh kk nr ns ll ko nt nu lp nv bi translated">位数</h2><p id="9469" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">计算从给定位置开始的位数的简单函数:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="113f" class="mq ku in bd kv nl nm dn kz nn no dp ld kg np nq lh kk nr ns ll ko nt nu lp nv bi translated">组装算法</h2><p id="285a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在下面的代码中，上面给出的<em class="lz"> alphaCmp </em>算法已经被修改，增加了第6到18行。它们实现了上述算法的第2点和第3点。</p><p id="ea80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第6行区分数字和字母的比较。</p><p id="16b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第7–10行实现了第2点。</p><p id="8520" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第12–15行实现了第3点。</p><p id="e54d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第17行跳过数字(减一防止<em class="lz">为</em>递增)</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="138b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">性能性能性能</h1><p id="82c3" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">首先要考虑的是，比较算法不太可能成为我们应用程序的瓶颈，但是尝试改进它可以细化在类似情况下要实现的策略。</p><p id="59d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们减少求和的次数:我们用计算第一个非数字字符的索引的<em class="lz"> skipDigit，</em>函数替换<em class="lz"> numDigit </em>函数。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk">v</figcaption></figure><p id="fcdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用此功能，可以删除第13、14行的总和并简化第17行。</p><p id="4453" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个更大的改进是用相应的整数字符代码(代码单元的值)替换方括号访问操作符产生的所有<em class="lz">一个字符长的</em>字符串:<code class="fe me mf mg mh b">'abc'.charCodeAt(0) instead of 'abc'[0]</code>:使用数字97比使用字符串‘a’更有效。</p><p id="e454" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显然，我们还需要重新定义isDigit:</p><p id="7b8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe me mf mg mh b">const isDigit = c =&gt; c&gt;=48 &amp;&amp; c&lt;=57</code></p><p id="91c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么算法变成:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b391" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在前缀测试(第6行和第28行)起作用了，因为例如<code class="fe me mf mg mh b">'abc'.charCodeAt(3)</code>是<code class="fe me mf mg mh b">NaN</code></p><h1 id="41a2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">处理前导零</h1><p id="fa09" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">一组字符串中包含的数字组可以以一个或多个零开始。</p><p id="99e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常添加零是为了使数字部分具有相同的长度。</p><p id="21d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，包含日期的字符串的月份和日期部分总是2位数长:<code class="fe me mf mg mh b">‘picture2021-03-02', ‘picture2021-04-02', 'picture2021-04-12’</code></p><p id="7f58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用字母比较可以正确地对这类字符串进行排序。</p><p id="9372" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果字符串还包含可变长度的数字部分，则上述比较算法会给出正确的顺序。</p><p id="aa0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果包含前导零的数字部分可以有不同的长度，事情就有点复杂了。这个案子会在另一个故事里报道。</p><h1 id="dfa1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">算法比较</h1><h2 id="4935" class="mq ku in bd kv nl nm dn kz nn no dp ld kg np nq lh kk nr ns ll ko nt nu lp nv bi translated">效率</h2><p id="c07a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了比较这些算法，我们取了webpack版本的整个列表(在故事写完的时候大约有800个),并把它分配给一个向量<em class="lz"> v </em>。然后用<a class="ae md" href="https://medium.com/swlh/vector-shuffling-a-javascript-functional-implementation-70e973c5b58f" rel="noopener">这个故事</a>中描述的算法对向量进行洗牌。</p><p id="563f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe me mf mg mh b">v = shuffle(v)</code></p><p id="1761" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们可以对向量进行10000次排序(这需要超过3200万次比较):</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="62f9" class="mq ku in mh b gy mr ms l mt mu">for (z=0;z&lt;10000;z++) v1[z] = [...v]<br/>console.time();<br/>for (z=0;z&lt;10000;z++) v1[z].sort(natOrdCmp)<br/>console.timeEnd()`</span></pre><p id="ac1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用向量v的不同洗牌测试比较算法，获得的平均时间如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="74d6" class="mq ku in mh b gy mr ms l mt mu">natOrdCmp  17400 ms<br/>natOrdCmp1 19040 ms<br/><strong class="mh io">natOrdCmp2  5150 ms</strong></span></pre><h2 id="24bf" class="mq ku in bd kv nl nm dn kz nn no dp ld kg np nq lh kk nr ns ll ko nt nu lp nv bi translated">石墨烯簇</h2><p id="8b84" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">字素簇是定义单个字符的一组码点。一些表情符号是可以包含多达8个代码单元的集群。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2680" class="mq ku in mh b gy mr ms l mt mu">['ä'.length, 'ä'.length]</span></pre><p id="db33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果在<code class="fe me mf mg mh b">[2,1]</code>中(您可以在浏览器控制台中复制并粘贴前面的文字来验证结果)。</p><p id="2abd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关键是第一个<em class="lz">是一个由字符<em class="lz"> a </em>和音调符号修饰符组成的簇:它有两个代码单元长。</em></p><p id="f1ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">字符可以用不同的方式编码。<strong class="jx io"><em class="lz">natOrdCmp</em>函数</strong> <strong class="jx io">识别不同的编码是同一个字符</strong>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="476d" class="mq ku in mh b gy mr ms l mt mu"><em class="lz">natOrdCmp</em>(String.fromCharCode(228), ‘a’ + String.fromCharCode(776))</span></pre><p id="c7e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">评估为0，<strong class="jx io">而<em class="lz"> natOrdCmp1 </em>和<em class="lz"> natOrdCmp2 </em>将不同的编码作为不同的字符</strong>进行管理。</p><h2 id="5c9f" class="mq ku in bd kv nl nm dn kz nn no dp ld kg np nq lh kk nr ns ll ko nt nu lp nv bi translated">前导零</h2><p id="1309" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">尽管如前所述，这个主题将在另一个故事中讨论，但在这里强调一下带有<em class="lz">等于</em>数字段(即表示相同的整数)并包含前导零的字符串是如何不被JavaScript本地比较器排序的是很重要的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6e00" class="mq ku in mh b gy mr ms l mt mu">['2-alfa','002-alfa','002-beta','2-beta'].sort(natOrdCmp)</span></pre><p id="6631" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">保持向量<strong class="jx io">不变</strong>，而<strong class="jx io">期望结果</strong>为:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6733" class="mq ku in mh b gy mr ms l mt mu">['2-alfa','2-beta','002-alfa','002-beta']</span></pre><p id="9366" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lz">更多内容请看</em><a class="ae md" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="lz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>