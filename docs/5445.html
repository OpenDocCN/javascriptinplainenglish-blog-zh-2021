<html>
<head>
<title>Immutability in JavaScript: Why it’s Important and How to Use it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的不变性:为什么它很重要以及如何使用它</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/immutability-in-javascript-why-its-important-and-how-to-use-it-e7c4125cc58f?source=collection_archive---------6-----------------------#2021-11-10">https://javascript.plainenglish.io/immutability-in-javascript-why-its-important-and-how-to-use-it-e7c4125cc58f?source=collection_archive---------6-----------------------#2021-11-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0395" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不变性在现代JavaScript中是一个超级热门的话题，其背后的原因当然是函数式编程范式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/19be5408e8aa497fe7c6c115f7df33bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*SaOzls4suPxmYf1Jzibpcw.png"/></div></figure><p id="32a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不可变数据与函数方法紧密相连，在函数方法中，任何突变都被认为是不必要的副作用。但是首先，让我们深入了解可变性和不可变性的细节。</p><h1 id="103d" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是可变性？</h1><p id="a4e9" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">为了让事情变得清晰，如果代码是可变的，这没有什么错JavaScript的数组API是可变的，这没有什么错。然而，误用可变性会对你的软件产生副作用。让我们看看下面的示例代码:</p><pre class="kj kk kl km gt lt lu lv lw aw lx bi"><span id="7f26" class="ly kr in lu b gy lz ma l mb mc">const person = {<br/>   name: 'Rodrigo',<br/>   email: 'email@email.com'<br/>} </span><span id="893b" class="ly kr in lu b gy md ma l mb mc">// Make a copy of person object <br/>const newPerson = person; </span><span id="e199" class="ly kr in lu b gy md ma l mb mc">// Changing the email of the new person <br/>newPerson.email = 'somethingelse@email.com'; </span><span id="0fa0" class="ly kr in lu b gy md ma l mb mc">console.log(newPerson === person); // true <br/>console.log(person);    //  { name: 'Rodrigo', email: 'somethingelse@email.com' } <br/>console.log(newPerson); //  { name: 'Rodrigo', email: 'somethingelse@email.com' }</span></pre><p id="f193" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以看到，我们正在将对象(person)复制到另一个对象(newPerson ),并在newPerson上做了一点小小的更改。这里的问题是，这种变化反映在两个对象中。</p><p id="0543" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发生这种情况是因为当你在JS中将一个对象赋给一个变量时，你实际上是在给它赋一个内存引用，所以当你这样做时:</p><pre class="kj kk kl km gt lt lu lv lw aw lx bi"><span id="0f3d" class="ly kr in lu b gy lz ma l mb mc">const newPerson = person;</span></pre><p id="68c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你只是复制了那个引用，而不是真正的值。两个变量指向同一个地方。</p><h1 id="81e8" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">变得不可改变</h1><p id="3fb8" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">不变性是维护对象状态的艺术，使开发变得简单、可追踪、可测试并减少任何可能的副作用。主要思想是:更新不应该改变对象，而是用更新的数据创建一个新对象。</p><p id="8d12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与其传递对象并对其进行变异，不如创建一个全新的对象:</p><pre class="kj kk kl km gt lt lu lv lw aw lx bi"><span id="9c5a" class="ly kr in lu b gy lz ma l mb mc">const person = { name: 'Rodrigo', email: 'email@email.com' } <br/>const newPerson = Object.assign(<br/>  {}, <br/>  person, <br/>  { email: 'somethingelse@email.com' }<br/>);</span><span id="f6c6" class="ly kr in lu b gy md ma l mb mc">console.log(newPerson === person); // false </span><span id="3595" class="ly kr in lu b gy md ma l mb mc">console.log(person)    // { name: 'Rodrigo', email: 'email@email.com' } <br/>console.log(newPerson) // { name: 'Rodrigo', email: 'somethingelse@email.com' }</span></pre><p id="ed25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是嘿，我们用的是ES6，难道不能换一种方式吗？当然可以！我们可以使用Spread运算符！看一看:</p><pre class="kj kk kl km gt lt lu lv lw aw lx bi"><span id="0cf7" class="ly kr in lu b gy lz ma l mb mc">const person = { name: 'Rodrigo', email: 'email@email.com' } <br/>const newPerson = { ...person, email: 'somethingelse@email.com' } </span><span id="79c6" class="ly kr in lu b gy md ma l mb mc">console.log(newPerson === person); // false - really different objects<br/>console.log(person)    // { name: 'Rodrigo', email: 'email@email.com' } <br/>console.log(newPerson) // { name: 'Rodrigo', email: 'somethingelse@email.com' }</span></pre><p id="2114" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">整洁，对不对？同样的结果，甚至更干净的代码。首先，我们创建一个新的对象，将{}赋值给一个变量，然后使用“spread”操作符(…)将person中的所有属性复制到新对象中。然后，我们定义一个新的“电子邮件”属性来覆盖旧的属性。请注意，在这种情况下，顺序很重要，如果在传播person对象之前定义了email: 'somethingelse@email.com '，它将被来自person对象的email的值覆盖。</p><h1 id="f5bf" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">数组</h1><p id="0a2d" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">首先，我们来看一个如何改变数组的小例子:</p><pre class="kj kk kl km gt lt lu lv lw aw lx bi"><span id="42e5" class="ly kr in lu b gy lz ma l mb mc">const fruits = [ 'Orange', 'Apple' ];<br/>const newFruits = characters newFruits.push('Banana');</span><span id="0e06" class="ly kr in lu b gy md ma l mb mc">console.log(fruits === newFruits) // true :-(</span></pre><p id="84ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数组的工作方式与对象相同，所以您也可以使用spread操作符在数组上实现不可变。你可以这样使用它:</p><pre class="kj kk kl km gt lt lu lv lw aw lx bi"><span id="e151" class="ly kr in lu b gy lz ma l mb mc">const fruits = [ 'Orange', 'Apple' ];<br/>const newFruits = [ ...fruits, 'Banana' ];</span><span id="ffea" class="ly kr in lu b gy md ma l mb mc">console.log(fruits === newFruits) // false <br/>console.log(fruits)    // [ 'Orange', 'Apple' ] <br/>console.log(newFruits) // [ 'Orange', 'Apple', 'Banana' ]</span></pre><p id="e04d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，您可以使用简单的现代JavaScript轻松实现不变性！最后，这都是关于常识和理解你的代码实际上做什么。如果你不小心编程，JavaScript可能是不可预测的。</p><p id="bf15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="me">更多内容看</em><a class="ae mf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="me">plain English . io</em></strong></a></p></div></div>    
</body>
</html>