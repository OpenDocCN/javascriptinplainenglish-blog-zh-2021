<html>
<head>
<title>Working with JSON — Using Fetch API with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JSON —通过React使用Fetch API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/working-with-json-using-fetch-api-with-react-3223b67d1e7a?source=collection_archive---------16-----------------------#2021-01-19">https://javascript.plainenglish.io/working-with-json-using-fetch-api-with-react-3223b67d1e7a?source=collection_archive---------16-----------------------#2021-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a352ee04697ebb8fb23e41538325b882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rLjwqL9e9NK1AB0f"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jeremyperkins?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeremy Perkins</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1bff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JSON代表JavaScript对象符号。</p><p id="bcb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一种流行的数据交换格式，有许多用途。</p><p id="d233" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何将JSON与React和Fetch API结合使用。</p><h1 id="4272" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用React发出HTTP请求</h1><p id="f308" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">React是一个视图库，所以它不附带任何进行HTTP请求的方法。</p><p id="5a26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们必须使用自己的HTTP客户端库。</p><p id="6d1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天，大多数现代浏览器都带有Fetch API。</p><p id="3b6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把它和<code class="fe me mf mg mh b">useEffect</code>挂钩一起使用。</p><p id="e05d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a98e" class="mq lc iq mh b gy mr ms l mt mu">import React, { useEffect, useState } from "react";</span><span id="dfa2" class="mq lc iq mh b gy mv ms l mt mu">export default function App() {<br/>  const [answer, setAnwser] = useState();</span><span id="d07d" class="mq lc iq mh b gy mv ms l mt mu">  const getAnswer = async () =&gt; {<br/>    const res = await fetch("https://yesno.wtf/api");<br/>    const answer = await res.json();<br/>    setAnwser(answer);<br/>  };</span><span id="b316" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    getAnswer();<br/>  }, []);<br/>  return &lt;div className="App"&gt;{JSON.stringify(answer)}&lt;/div&gt;;<br/>}</span></pre><p id="56e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">fetch</code>函数向端点发出GET请求。</p><p id="1d2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个解析为数据的承诺，然后我们调用<code class="fe me mf mg mh b">json</code>从JSON获取数据。</p><p id="896a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">setAnswer</code>来设置<code class="fe me mf mg mh b">answer</code>状态。</p><p id="d064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数中的空数组意味着我们只在组件挂载时运行回调。</p><p id="18ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过编写以下代码将<code class="fe me mf mg mh b">getAnswer</code>函数移动到它自己的钩子中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5ccd" class="mq lc iq mh b gy mr ms l mt mu">import React, { useEffect, useState } from "react";</span><span id="4ca0" class="mq lc iq mh b gy mv ms l mt mu">const useAnswer = () =&gt; {<br/>  const [answer, setAnwser] = useState();</span><span id="f0aa" class="mq lc iq mh b gy mv ms l mt mu">  const getAnswer = async () =&gt; {<br/>    const res = await fetch("https://yesno.wtf/api");<br/>    const answer = await res.json();<br/>    setAnwser(answer);<br/>  };</span><span id="1d10" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    getAnswer();<br/>  }, []);<br/>  return answer;<br/>};</span><span id="fc47" class="mq lc iq mh b gy mv ms l mt mu">export default function App() {<br/>  const answer = useAnswer();<br/>  return &lt;div className="App"&gt;{JSON.stringify(answer)}&lt;/div&gt;;<br/>}</span></pre><p id="2f3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将所有逻辑从API端点转移到它自己的钩子上。</p><p id="7f6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以保持我们的组件非常干净，没有副作用。</p><p id="7583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用Fetch API发出POST请求，我们可以编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4022" class="mq lc iq mh b gy mr ms l mt mu">import React, { useEffect, useState } from "react";</span><span id="2d2a" class="mq lc iq mh b gy mv ms l mt mu">const makeRequest = async (data) =&gt; {<br/>  const res = await fetch("https://jsonplaceholder.typicode.com/todos", {<br/>    method: "POST",<br/>    mode: "cors",<br/>    cache: "no-cache",<br/>    credentials: "same-origin",<br/>    headers: {<br/>      "Content-Type": "application/json"<br/>    },<br/>    body: JSON.stringify(data)<br/>  });<br/>  const response = await res.json();<br/>  return response;<br/>};</span><span id="38f9" class="mq lc iq mh b gy mv ms l mt mu">export default function App() {<br/>  const submit = async () =&gt; {<br/>    const res = await makeRequest({<br/>      title: "delectus aut autem",<br/>      completed: false<br/>    });<br/>    console.log(res);<br/>  };</span><span id="0804" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={submit}&gt;add todo&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="5fcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了<code class="fe me mf mg mh b">makeRequest</code>函数，该函数使用URL调用<code class="fe me mf mg mh b">fetch</code>，向an对象发出带有请求选项的请求。</p><p id="a7ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">method</code>属性是请求方法。</p><p id="858d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">mode</code>是请求模式。<code class="fe me mf mg mh b">'cors'</code>提出跨来源请求。</p><p id="ee90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">cache</code>设置为<code class="fe me mf mg mh b">'no-cache'</code>禁用缓存。</p><p id="b19e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">credentials</code>设置cookies的来源。</p><p id="453e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">headers</code>拥有我们想要发送的HTTP请求头。</p><p id="b5af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">body</code>有HTTP请求体。</p><p id="0f3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们点击“添加待办事项”按钮时，然后<code class="fe me mf mg mh b">submit</code>函数使用<code class="fe me mf mg mh b">makeRequest</code>函数发出请求。</p><p id="c78c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后返回响应数据，并从控制台日志中记录从<code class="fe me mf mg mh b">makeRequest</code>函数返回的承诺。</p><h1 id="561d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="03b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们用Fetch API在React应用程序中发出HTTP请求。</p><p id="520c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>