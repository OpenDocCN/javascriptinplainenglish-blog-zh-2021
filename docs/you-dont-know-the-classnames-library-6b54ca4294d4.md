# 您不知道类名库

> 原文：<https://javascript.plainenglish.io/you-dont-know-the-classnames-library-6b54ca4294d4?source=collection_archive---------12----------------------->

![](img/7515cdfaf322091fca8cc139532c7c47.png)

让我从一开始就反驳这篇文章的标题，说你可能非常了解`classNames`图书馆。

最初由[杰德沃森](https://github.com/JedWatson)创建的这个小小的[开源](https://github.com/JedWatson/classnames)库不过是一个多用途的字符串*“连接符”。*目前每周下载超过**600 万次**，它和最常用的用户界面库 React 一起流行起来。

![](img/3b67cd4e390da79baf842648bb290ccc.png)

classNames and React popularity growth

顾名思义，它主要用于处理 CSS 类名(在 React 和任何其他基于 **JSX 的** UI 框架中非常常见)，尽管您可以将其用于任何类型的字符串连接。

# 小巧的 NPM 包装的新奇之处

但你很可能什么都知道。毕竟，考虑到类名和 React 的受欢迎程度，你很有可能以前使用过它。但是是的关于这种流行。

在 NPM，看到小包装有高得离谱的下载数据并不罕见。你很可能[已经听说过 NPM 包的故事](https://www.google.com/search?q=tiny%20package%20breaks%20npm)甚至只有不到 20 行代码，因为最微小的改变就破坏了互联网。以 [is-promise](https://www.npmjs.com/package/is-promise) 为例——每周下载量约为 1000 万次(主要来自其高度受欢迎的依赖者)——其最大的 CJS 版本有 5 行代码(LOCs):

现在，这种依赖可能看起来很可怕，这是理所当然的。关于黑洞`node_modules`文件夹的笑话是真实的，这是有原因的。即使您可能不直接依赖这样的包，您依赖的包也可能这样做，一个，或者更可能是多个级别。

类名并没有那么小，它的“核心”版本大约有 50 个 LOCs，总数在 200 到 300 之间(所有版本+类型脚本类型)。这就是我认为的包依赖的“合理”阈值。此外，该图书馆非常稳定，多年来证明了自己。

# 类名语法

类名库的有用性来自它的语法。它只不过是一个函数，将不同类型的值作为参数，并基于它们输出一个字符串。

自述文件很好地展示了这种多功能性:

这个库的简单性和多功能性可能是你没有真正考虑过的事情——你只是使用它，让它在你的项目中运行数千甚至数百万次。

## 表演

这可能会导致对性能的一些担忧。

作者意识到了这一点，这在自述文件中有明确说明:

*“我们非常重视这个软件包的稳定性和性能，因为它每天在世界各地的浏览器中运行数百万次。更新在发布前会经过彻底的性能影响审查，我们有一套全面的测试套件。”*

然而，很明显，函数调用永远不会比一个简单的字符串更快，尽管这看起来像是一个微优化，但这也是代码可读性的问题。

因此，重要的是不要陷入一个循环洞，并且知道何时以及如何负责任地使用这个库。在更简单的情况下，看看普通字符串、ES6 模板文字或条件操作符是否能完成这项工作。不要浪费性能，也不要过度优化。

## 多才多艺

除了在必要的时候使用类名之外，正确使用它还有很多好处。这里最大的因素是**多功能性**，这通常会导致您在给定的场景中采用次优的方式。

如上所述，您可以提供任意多的参数，忽略这些参数中的假值，连接字符串，递归地展平和处理数组，如果对象的值为真，则连接对象的键。

您可以使用这些属性不一定是为了提高**性能**，而是为了提高代码的可读性*“编写舒适性”*(也就是*“开发体验”*)。至于一些建议:

以上只是我自己想出来的几个小技巧，我个人用的。通常使用不必要的数组，或者将基类放入右边带有难看的`true`的对象属性名中，或者通过属性值类似于`condition`、`!condition`的对象在类集合之间切换。这些问题都不是特别令人不安，但值得记住的是，还有一些改进的空间。

# 类名替代版本

您可能不知道，classNames 本身有两个不同的版本。两者都服务于相同的一般目的，但也提供了额外的功能。

## 重复数据删除

顾名思义，*重复数据删除*版本处理生成的字符串中的重复项。它删除重复的子字符串，并且只考虑最后为特定子字符串提供的设置。

由于重复数据删除的复杂性，这个版本据说比慢了**5 倍。正因为如此，我不建议你把它用在你的`className`上，除非你有非常具体的理由。但是，它对于一般的字符串连接仍然很有用。**

## 约束

第二个版本面向 **CSS 模块**的用户。当导入 CSS 类的对象时，这个版本允许您“绑定”它们，这样您就可以通过它们的自定义名称而不是真实名称来引用它们。

这种方法可以为您节省一些输入—不需要总是从导入的对象中访问属性。然而，它确实引入了一些额外的性能损失(尽管确实很小)，会使新来者感到困惑，需要创建一个新的类名函数的“实例”，并且会导致您失去潜在的自动完成和其他类型的编辑器支持([包含的类型脚本类型](https://github.com/JedWatson/classnames/blob/master/bind.d.ts)非常通用)。

也就是说，你应该只在有很多 CSS 模块导入的类需要处理的时候才使用这个版本(顺便说一下，这不符合“人体工程学”)

# 只需使用 [clsx](https://www.npmjs.com/package/clsx)

现在，作为一个免费的提示，在你可能拨打的数千次`classNames`电话中，至少有 2 次的性能，只要切换到`clsx`就可以了。这是一个类似于`classNames`的图书馆，但是更加新鲜，而且 loc 更少。

该 API 与`classNames`相同，但是没有额外的版本(反正你可能也不需要)。虽然性能提升可能并不明显，但这仍然意味着速度仍然存在，大量的调用可以很快增加更多。

# 想法？

写一整篇关于单功能实用程序库的文章感觉有点疯狂。然而，考虑到`classNames`有多受欢迎，它被使用的频率有多高，以及它是多么的不引人注意，我认为它值得深入研究一下。这样的小型库和开源工具推动了今天的 Web，因此，不断尝试您的依赖项、充分了解它们并知道如何优化它们是非常重要的。

反正就是这样了！我希望你喜欢这次疯狂的旅程，也许——只是也许——今天学到了一些新东西。如果是这样，请在评论中告诉我。请务必在[推特](https://twitter.com/areknawo)、[脸书](https://www.facebook.com/areknawoblog)上**关注我**，或者通过我的[时事通讯](https://areknawo.com#newsletter)了解更多像这样疯狂的网络开发者故事和一些更理智的故事！哦，也许**开始用[代码编写自己的](https://codewrite.io)**！

感谢你的阅读，祝你命名愉快。