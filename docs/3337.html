<html>
<head>
<title>The Art of Using var, let, and const in JavaScript — A Slightly Unconventional Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用var、let和const的艺术——一种稍微有点非传统的方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-art-of-using-var-let-and-const-d3a819a391a0?source=collection_archive---------4-----------------------#2021-07-07">https://javascript.plainenglish.io/the-art-of-using-var-let-and-const-d3a819a391a0?source=collection_archive---------4-----------------------#2021-07-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e3ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">更好的代码不需要明确的解释</em> </strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/a489683e60d7cbd1efe322d3ed8c557b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivrCHJL1XCsHhacVkZpFyA.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Image from : <a class="ae kz" href="https://images.wallpaperscraft.com/image/artist_waves_colorful_129158_2048x1152.jpg" rel="noopener ugc nofollow" target="_blank">https://images.wallpaperscraft.com/</a></figcaption></figure><h1 id="bfcb" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我为什么要写这个？</h1><p id="cd37" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我看过很多关于这个话题的帖子和视频，但是，我决定写下我自己的观点。因为我看过的大多数文章都说，</p><blockquote class="md me mf"><p id="de95" class="jk jl ki jm b jn jo jp jq jr js jt ju mg jw jx jy mh ka kb kc mi ke kf kg kh ig bi translated">1.避免使用<code class="fe mj mk ml mm b">var</code></p><p id="4ea9" class="jk jl ki jm b jn jo jp jq jr js jt ju mg jw jx jy mh ka kb kc mi ke kf kg kh ig bi translated">2.<code class="fe mj mk ml mm b">let</code>是新的<code class="fe mj mk ml mm b">var</code></p></blockquote><p id="af67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我有不同的方法。我对<code class="fe mj mk ml mm b">let </code>和<code class="fe mj mk ml mm b">const </code>的介绍有不同看法。我同意<code class="fe mj mk ml mm b">var </code>在某些特定情况下有一些问题，但是我们用了<code class="fe mj mk ml mm b">var </code>将近20年。</p><p id="0e61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，我相信我们仍然可以在某些情况下使用<code class="fe mj mk ml mm b">var</code>来获得更可读的代码。<code class="fe mj mk ml mm b">let </code>和<code class="fe mj mk ml mm b">const </code>也有它们的用法。首先，我们将看到每个人的行为。然后我们会看到如何使用它们来获得更可读的代码。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="232f" class="la lb in bd lc ld mu lf lg lh mv lj lk ll mw ln lo lp mx lr ls lt my lv lw lx bi translated"><strong class="ak"> 1。var </strong></h1><ol class=""><li id="8abf" class="mz na in jm b jn ly jr lz jv nb jz nc kd nd kh ne nf ng nh bi translated"><code class="fe mj mk ml mm b"><em class="ki">var </em></code> <em class="ki">变量附加到封闭函数范围。</em></li></ol><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3a9fb7c74eee13e0695c137b3eb8c1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*iQZ_N6UlwwWGkihpHRN8WQ.jpeg"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">var attaches itself to enclosing scope. Image from : <a class="ae kz" href="https://clipground.com/images/onto-clipart-12.jpg" rel="noopener ugc nofollow" target="_blank">https://clipground.com</a></figcaption></figure><blockquote class="md me mf"><p id="ac72" class="jk jl ki jm b jn jo jp jq jr js jt ju mg jw jx jy mh ka kb kc mi ke kf kg kh ig bi translated">定义为<code class="fe mj mk ml mm b">var </code>的变量不仅可以在定义它们的块内访问。而且，也可以在块外访问它们。这是因为<code class="fe mj mk ml mm b">var </code>变量将自己附加到<code class="fe mj mk ml mm b">function </code>作用域或<code class="fe mj mk ml mm b">global </code>作用域。<code class="fe mj mk ml mm b">var </code>仅将功能块和全局上下文视为作用域。</p></blockquote><p id="5527" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我来说明我的意思。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c558" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行上述代码时，您可能会遇到错误。相反，您将在控制台上记录0 1 2 3 4 5和6。记录数字6是因为当执行从<code class="fe mj mk ml mm b">for </code>循环退出时，I的值是6。尽管I被定义在for循环块内部，我们仍然可以从外部访问它。那是因为<code class="fe mj mk ml mm b">var</code>。</p><p id="e8f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> 2。</em> <code class="fe mj mk ml mm b"><em class="ki">var</em></code> <em class="ki">将受到吊装</em>的影响</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nl"><img src="../Images/e5e5519460a2308aaf252e53f144291b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x2r7mUjDsRFpu8rB"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@fasbytes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fas Khan</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d988" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当JavaScript引擎运行程序时，它将提升所有的<code class="fe mj mk ml mm b">var </code>变量。因此，我们可以在给变量赋值之前使用它们。为了理解这一点，让我们看看下面的代码片段。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="43e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码将运行没有任何错误，这是因为提升。</p><p id="5bac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> 3。我们可以在同一个范围内多次重新声明同一个变量。</em></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="10ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述代码将在控制台上记录“efg”。因为<code class="fe mj mk ml mm b"><strong class="jm io">var </strong></code> <strong class="jm io">变量可以在同一个作用域内重新声明。</strong></p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="0272" class="la lb in bd lc ld mu lf lg lh mv lj lk ll mw ln lo lp mx lr ls lt my lv lw lx bi translated">2.让</h1><p id="702c" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">声明为<code class="fe mj mk ml mm b">let </code>的变量的行为类似于其他语言中的变量。所以，我不打算浪费时间详细解释它们。让我们简单地看看他们。</p><ol class=""><li id="ce65" class="mz na in jm b jn jo jr js jv nm jz nn kd no kh ne nf ng nh bi translated">范围仅限于定义它的块。</li></ol><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="538a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，如果我们运行上面的代码片段，我们将得到一个<code class="fe mj mk ml mm b">RefferenceError </code>。因为没有直接在<code class="fe mj mk ml mm b">start </code>函数内部声明变量。</p><p id="4c54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<code class="fe mj mk ml mm b">let</code>不受吊装影响。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e643" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种情况下，你会得到一个<code class="fe mj mk ml mm b">RefferanceError</code>。因为我们不能在声明之前使用let变量。</p><p id="4eaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.我们不能在同一个范围内重新声明一个变量。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="733e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，您将得到一个<code class="fe mj mk ml mm b">SyntaxError</code>，因为您不能在相同的范围内使用相同的变量名。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="dd7a" class="la lb in bd lc ld mu lf lg lh mv lj lk ll mw ln lo lp mx lr ls lt my lv lw lx bi translated"><code class="fe mj mk ml mm b"><strong class="ak">3. const</strong></code></h1><p id="e63f" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">关于<code class="fe mj mk ml mm b">const </code>令人困惑的是它的名字。我们通常用<code class="fe mj mk ml mm b">const</code>来表示常数。但在这里，情况并不完全如此。<code class="fe mj mk ml mm b">const </code>这里在JavaScript中的意思是<strong class="jm io">你不能在第一次赋值后给变量赋值。但是，你可以改变它们。</strong></p><pre class="kk kl km kn gt np mm nq nr aw ns bi"><span id="4e86" class="nt lb in mm b gy nu nv l nw nx">const fisrtName = “abc”;<br/>fisrtName = “efg”;// TypeError</span></pre><p id="f676" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您已经猜到的，这将抛出一个<code class="fe mj mk ml mm b">TypeError</code>。</p><p id="a710" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，棘手的部分来了。</p><pre class="kk kl km kn gt np mm nq nr aw ns bi"><span id="f941" class="nt lb in mm b gy nu nv l nw nx">const myArray=[1,2,3];</span><span id="5d79" class="nt lb in mm b gy ny nv l nw nx">myArray[0]=2;</span><span id="df98" class="nt lb in mm b gy ny nv l nw nx">console.log(myArray) //[2,2,3]</span></pre><p id="c78c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，上面的代码完全没问题。正如我前面说过的，你不能给一个<code class="fe mj mk ml mm b">const</code>变量赋值。但是你可以改变它们。</p><p id="3403" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除上述行为外，<code class="fe mj mk ml mm b">const </code>与<code class="fe mj mk ml mm b">let</code>相同。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="8669" class="la lb in bd lc ld mu lf lg lh mv lj lk ll mw ln lo lp mx lr ls lt my lv lw lx bi translated"><strong class="ak">应用</strong><code class="fe mj mk ml mm b"><strong class="ak">var</strong></code><strong class="ak"/><code class="fe mj mk ml mm b"><strong class="ak">let,</strong></code><strong class="ak"/><code class="fe mj mk ml mm b"><strong class="ak">const</strong></code><strong class="ak">(美工)</strong></h1><p id="d33f" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">现在，我们知道了<code class="fe mj mk ml mm b">var</code>、<code class="fe mj mk ml mm b">let</code>和<code class="fe mj mk ml mm b">const</code>的行为。让我们看看如何通过在合适的地方使用它们来改进我们的代码。</p><h2 id="236e" class="nt lb in bd lc nz oa dn lg ob oc dp lk jv od oe lo jz of og ls kd oh oi lw oj bi translated"><code class="fe mj mk ml mm b"><strong class="ak">var</strong></code></h2><blockquote class="ok"><p id="067a" class="ol om in bd on oo op oq or os ot kh dk translated">可以使用var来声明属于整个函数的变量。</p></blockquote><pre class="ou ov ow ox oy np mm nq nr aw ns bi"><span id="58e6" class="nt lb in mm b gy nu nv l nw nx">function foo(){</span><span id="7a04" class="nt lb in mm b gy ny nv l nw nx">       var name="abc"</span><span id="0a58" class="nt lb in mm b gy ny nv l nw nx">       …</span><span id="b10c" class="nt lb in mm b gy ny nv l nw nx">       …</span><span id="53f8" class="nt lb in mm b gy ny nv l nw nx">       console.log(name)</span><span id="1138" class="nt lb in mm b gy ny nv l nw nx">}</span></pre><p id="bf7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，您在语义上告诉读者这个变量可以在<code class="fe mj mk ml mm b">function</code>中的任何地方使用。</p><blockquote class="md me mf"><p id="0912" class="jk jl ki jm b jn jo jp jq jr js jt ju mg jw jx jy mh ka kb kc mi ke kf kg kh ig bi translated">当你在<code class="fe mj mk ml mm b">function</code>的其他地方使用一些变量时，<code class="fe mj mk ml mm b">function </code>可能会中断。避免对他们使用<code class="fe mj mk ml mm b">var </code>。</p></blockquote><p id="9e1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，您知道<code class="fe mj mk ml mm b">var </code>变量可以在相同的范围内再次声明。如果你有更长的函数—</p><blockquote class="ok"><p id="18f9" class="ol om in bd on oo op oq or os ot kh dk translated">您可以在函数中用相同的值再次声明相同的变量。这样，你就不需要一直走到变量被声明的地方，也不需要看到被赋值的值。</p></blockquote><h2 id="831c" class="nt lb in bd lc nz oz dn lg ob pa dp lk jv pb oe lo jz pc og ls kd pd oi lw oj bi translated"><code class="fe mj mk ml mm b"><strong class="ak">let</strong></code></h2><blockquote class="ok"><p id="75e0" class="ol om in bd on oo op oq or os ot kh dk translated">您可以使用let来声明只应在几行内使用的变量。因为在其他地方使用它可能会破坏代码。</p></blockquote><pre class="ou ov ow ox oy np mm nq nr aw ns bi"><span id="6460" class="nt lb in mm b gy nu nv l nw nx">function foo(){</span><span id="0cd7" class="nt lb in mm b gy ny nv l nw nx">       let name=”abc”;</span><span id="f7c1" class="nt lb in mm b gy ny nv l nw nx">       console.log(name)</span><span id="c321" class="nt lb in mm b gy ny nv l nw nx">}</span></pre><p id="1f19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，如果你担心有人会在<code class="fe mj mk ml mm b">function</code>的其他地方使用这个变量</p><blockquote class="ok"><p id="69cd" class="ol om in bd on oo op oq or os ot kh dk translated">你也可以通过在两个花括号内声明变量来确定作用域。</p></blockquote><pre class="ou ov ow ox oy np mm nq nr aw ns bi"><span id="0fcf" class="nt lb in mm b gy nu nv l nw nx">function foo(){</span><span id="baab" class="nt lb in mm b gy ny nv l nw nx">     {let name=”abc”</span><span id="6b99" class="nt lb in mm b gy ny nv l nw nx">     console.log(name)}</span><span id="d7be" class="nt lb in mm b gy ny nv l nw nx">}</span></pre><p id="9d9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，块内的name变量在块外是不可见的。这种行为将阻止程序员在其他地方使用该变量。</p><blockquote class="ok"><p id="bfda" class="ol om in bd on oo op oq or os ot kh dk translated">您可以在块外声明另一个同名的变量。这将防止我们的代码名称冲突。</p></blockquote><pre class="ou ov ow ox oy np mm nq nr aw ns bi"><span id="eb70" class="nt lb in mm b gy nu nv l nw nx">function foo(){</span><span id="804b" class="nt lb in mm b gy ny nv l nw nx">       {let name=”abc”;<br/>       console.log(name)}//abc<br/>       let name=”xyz”<br/>       console.log(name)//xyz</span><span id="2038" class="nt lb in mm b gy ny nv l nw nx">}</span></pre><h2 id="a234" class="nt lb in bd lc nz oa dn lg ob oc dp lk jv od oe lo jz of og ls kd oh oi lw oj bi translated"><code class="fe mj mk ml mm b"><strong class="ak">const</strong></code></h2><p id="99af" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">当我们看到<code class="fe mj mk ml mm b">const</code>时，常量这个词会在我们的脑海中闪现</p><blockquote class="ok"><p id="f95a" class="ol om in bd on oo op oq or os ot kh dk translated">我们应该只对原始类型使用const，例如，数字、字符串。因为当声明为const时，原语的行为与真实世界的常量相同。</p></blockquote><p id="627c" class="pw-post-body-paragraph jk jl in jm b jn pe jp jq jr pf jt ju jv pg jx jy jz ph kb kc kd pi kf kg kh ig bi translated">这样，我们可以确保当其他程序员看我们的代码时，他/她理解的是正确的。</p><pre class="kk kl km kn gt np mm nq nr aw ns bi"><span id="10d2" class="nt lb in mm b gy nu nv l nw nx">function foo(){</span><span id="505e" class="nt lb in mm b gy ny nv l nw nx">    const age=21;</span><span id="fce6" class="nt lb in mm b gy ny nv l nw nx">    const names=[“abc”,”xyz”];</span><span id="9f0c" class="nt lb in mm b gy ny nv l nw nx">}</span></pre><p id="7559" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，在上面的代码中，将<code class="fe mj mk ml mm b">array </code>声明为<code class="fe mj mk ml mm b">const </code>是一个问题。Tt更不可能把一个新数组重新赋值给同一个变量。由于<code class="fe mj mk ml mm b">const</code>在数组上的行为不同，这使得代码可读性更差。即使我们将<code class="fe mj mk ml mm b">arrays </code>声明为<code class="fe mj mk ml mm b">const</code>，它们也不是常量。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="ce20" class="la lb in bd lc ld mu lf lg lh mv lj lk ll mw ln lo lp mx lr ls lt my lv lw lx bi translated"><strong class="ak">结论</strong></h1><p id="2e3a" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">与其用另一个行为完全不同的东西来代替某样东西，不如用它们来使我们的代码更容易理解。我在文章中只提到了几个场景。如果您发现任何其他用例，请在评论部分随意提及。因为我想在这个话题上发现更多。</p><p id="6563" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢大家！</p><p id="16ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容看</em> <a class="ae kz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>