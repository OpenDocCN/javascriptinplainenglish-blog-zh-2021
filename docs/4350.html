<html>
<head>
<title>React-Query: You Might Not Need State Management🤷🏽‍♂️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-Query:您可能不需要状态管理🤷🏽‍♂️</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-query-you-may-not-need-state-management-%EF%B8%8F-15de0837a569?source=collection_archive---------5-----------------------#2021-08-30">https://javascript.plainenglish.io/react-query-you-may-not-need-state-management-%EF%B8%8F-15de0837a569?source=collection_archive---------5-----------------------#2021-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/f5ad8fdecdfdd812928ffe742353db2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*IJBBRmlBuUSnlhZN"/></div></figure><h2 id="280a" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TL；速度三角形定位法(dead reckoning)</h2><blockquote class="kn ko kp"><p id="99c3" class="kq kr ks kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kt io"> react-query </strong>通常被称为“缺失数据取数库”。它是服务器状态的，能够管理缓存数据，在后台异步更新过时数据。它可能是全局状态管理库(如Redux或MobX)处理数据的良好替代品。这个故事的核心在<a class="ae lp" href="#fe93" rel="noopener ugc nofollow"><strong class="kt io">基本用法</strong></a>一节。下面显示的代码示例可从<a class="ae lp" href="https://codesandbox.io/s/react-query-basics-c2yom" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></blockquote></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="282e" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">目录</h2><blockquote class="kn ko kp"><p id="5670" class="kq kr ks kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">*) <a class="ae lp" href="#332f" rel="noopener ugc nofollow">简介</a> <br/> *) <a class="ae lp" href="#b35d" rel="noopener ugc nofollow">概念</a> <br/> *) <a class="ae lp" href="#fe93" rel="noopener ugc nofollow">基本用法<br/></a>*)<a class="ae lp" href="#4a2e" rel="noopener ugc nofollow">a . use Query</a><br/>*)<a class="ae lp" href="#16a9" rel="noopener ugc nofollow">b . use mutation</a><br/>*)<a class="ae lp" href="#841c" rel="noopener ugc nofollow">c .查询失效</a> <br/> *) <a class="ae lp" href="#8a1d" rel="noopener ugc nofollow">预取</a> <br/> *) <a class="ae lp" href="#740f" rel="noopener ugc nofollow">结论</a> <br/> *) 【T34</p></blockquote></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="332f" class="lx js in bd jt ly lz ma jw mb mc md jz me mf mg kd mh mi mj kh mk ml mm kl mn bi translated">介绍</h1><p id="c0c1" class="pw-post-body-paragraph kq kr in kt b ku mo kw kx ky mp la lb ka mq le lf ke mr li lj ki ms lm ln lo ig bi translated">将全局状态模式与像Redux、MobX或Context API这样的库一起使用有很多优点，但缺点在于数据类型的不同。有存储应用程序信息的数据，例如，黑暗模式，也有经常被操作的数据，例如产品列表和产品详细信息。这两种类型的数据可以被称为<strong class="kt io">客户端状态</strong>和<strong class="kt io">服务器状态</strong>。</p><p id="703b" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">我经常发现自己需要30分钟来连接redux样板代码，直到它可以使用。我使用带有TypeScript模板的create-react-app，它还需要一个额外的库，如redux-thunk或redux-saga，用于处理异步流程。</p><p id="21c6" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">客户端状态和服务器状态之间最显著的区别是，服务器状态来自两个来源，即后端和前端，这意味着应用程序必须始终同步，以便状态或数据保持更新。总是提出请求不是最好的做法。我们需要一个工具，可以显示旧的状态，但也可以在后台更新。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="b35d" class="lx js in bd jt ly lz ma jw mb mc md jz me mf mg kd mh mi mj kh mk ml mm kl mn bi translated">概念</h1><p id="becc" class="pw-post-body-paragraph kq kr in kt b ku mo kw kx ky mp la lb ka mq le lf ke mr li lj ki ms lm ln lo ig bi translated"><code class="fe mt mu mv mw b">react-query</code>通常被称为缺失的react取数据库。是的，这个库是前面描述的问题的解决方案。使用react-query允许我们非常容易地异步获取、更新和缓存数据。</p><p id="cd66" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated"><code class="fe mt mu mv mw b">react-query</code>有三个核心概念:</p><ul class=""><li id="8afa" class="mx my in kt b ku kv ky kz ka mz ke na ki nb lo nc nd ne nf bi translated"><strong class="kt io">查询</strong>:查询是对异步数据源的声明性依赖，与<strong class="kt io">唯一键相关联。</strong></li><li id="1172" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><strong class="kt io">突变</strong>:就像查询一样，区别在于对服务器的处理。对于修改数据创建/更新/删除，通常建议使用突变。</li><li id="34e9" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><strong class="kt io">查询失效</strong>:查询失效后，我们可以对某个查询进行后台更新。当用户对某个产品做了一些更改，而您可能想在更新后立即重新获取该产品时，这是非常有用的。</li></ul><figure class="nl nm nn no gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi gj"><img src="../Images/b8359e15c8a1de4386b3ee1345369a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_avuXAu1XDBxA6C1NSNWQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">react-query data behavior</figcaption></figure><p id="7e0d" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated"><code class="fe mt mu mv mw b">react-query</code>有其状态的术语:</p><ul class=""><li id="9230" class="mx my in kt b ku kv ky kz ka mz ke na ki nb lo nc nd ne nf bi translated"><strong class="kt io">获取</strong>:从服务器获取数据的开始过程，要么解析数据，要么返回错误。</li><li id="33ea" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><strong class="kt io">新鲜数据</strong>:刚刚成功取数返回的数据。</li><li id="8465" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><strong class="kt io">陈旧数据</strong>:新数据在某个时间会变成陈旧数据(过期)，表示需要在后台更新数据。自动重取陈旧数据的许多方法之一是窗口重聚焦，或者我们可以在查询中配置重取间隔。</li><li id="b15a" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><strong class="kt io">不活动数据</strong>:数据表示不再使用，在一定时间内会被删除。</li><li id="298c" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><strong class="kt io">已删除数据</strong>:该流程会在一定量的非活动数据后运行。可以为每个查询配置时间，也可以是全局时间。</li></ul></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="fe93" class="lx js in bd jt ly lz ma jw mb mc md jz me mf mg kd mh mi mj kh mk ml mm kl mn bi translated">基本用法</h1><p id="d4cb" class="pw-post-body-paragraph kq kr in kt b ku mo kw kx ky mp la lb ka mq le lf ke mr li lj ki ms lm ln lo ig bi translated">在使用这个库时，有几个钩子是最常用的。但是在我们开始之前，我们需要通过<code class="fe mt mu mv mw b">QueryClient</code>实例将我们的组件连接到react-query，并用<code class="fe mt mu mv mw b">QueryClient</code>提供者包装我们的组件。</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">connect react-query to our component</figcaption></figure><p id="0bb0" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated"><code class="fe mt mu mv mw b">react-query</code>提供了一个有用的调试工具来检测错误，你可以直接从<code class="fe mt mu mv mw b">react-query/devtool</code>导入<code class="fe mt mu mv mw b">ReactQueryDevTools</code>。可以传递给ReactDevTools的一些属性:</p><ul class=""><li id="14af" class="mx my in kt b ku kv ky kz ka mz ke na ki nb lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">initialIsOpen: boolean</strong></code> <strong class="kt io"> </strong>:默认为<code class="fe mt mu mv mw b">false</code>，设置为true，启动app时自动打开开发工具。</li><li id="45ab" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">position?: “top-left" | “top-right" | “bottom-left" | “bottom-right"</strong></code> <strong class="kt io"> : </strong>默认为“左下”。</li></ul><p id="05b6" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">注意:不要担心将<code class="fe mt mu mv mw b">ReactQueryDevTools</code>排除在生产构建之外，默认情况下，当<code class="fe mt mu mv mw b">process.env.NODE_ENV === ”production”</code>出现时，它不会包含在生产捆绑包中。</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">wire up react-query dev-tool</figcaption></figure></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="4a2e" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">a.使用查询</h2><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">a</figcaption></figure><p id="f4d1" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">这个钩子有一些非常有用的返回值，其中一些是:</p><ul class=""><li id="0736" class="mx my in kt b ku kv ky kz ka mz ke na ki nb lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">data: TData</strong></code>:如果<strong class="kt io"> queryFn </strong>成功，则返回结果数据。</li><li id="ab11" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">error: null | TError</strong></code>:否则返回错误，是一个值依赖于<strong class="kt io"> queryFn </strong> throw的对象。</li><li id="426f" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">isLoading: boolean</strong></code>:如果查询正在进行或者没有相关的缓存数据，则设置为true。</li></ul><p id="4812" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">这个挂钩还需要传递两个参数:</p><ul class=""><li id="39db" class="mx my in kt b ku kv ky kz ka mz ke na ki nb lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">queryKey</strong></code> <strong class="kt io"> </strong>:用来唯一标识和缓存你的查询，可以是任何一种数据类型。最简单的是String，或者如果涉及特定的信息，例如联系人的详细信息，您可能希望使用Array作为键。</li><li id="0bda" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">queryFn</strong></code>:基于承诺解析数据，功能类似fetch或Axios。</li></ul><p id="676f" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">一般来说，该API用于获取信息的过程，对于数据操作，建议使用<strong class="kt io"> useMutation </strong>。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="16a9" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">b.使用突变</h2><p id="884d" class="pw-post-body-paragraph kq kr in kt b ku mo kw kx ky mp la lb ka mq le lf ke mr li lj ki ms lm ln lo ig bi translated">与<code class="fe mt mu mv mw b">useQuery</code>钩子不同，这个查询通常用于数据操作创建/更新/删除。这个钩子返回几个函数和值，但是我们只关注<code class="fe mt mu mv mw b">mutate: (variables: TVariables, { onSuccess, onSettled, onError})</code>,因为它用得最多，为了简单起见。这个钩子也接受几个函数和回调:</p><ul class=""><li id="01a2" class="mx my in kt b ku kv ky kz ka mz ke na ki nb lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">mutationFn: (variables: TVariables) =&gt; Promise&lt;TData&gt; Required</strong></code>:与查询函数相同，不同的是该函数通过调用mutate来接收变量:TVariables。</li><li id="7d6a" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">onSuccess: (data: TData, variables: TVariables, context?: TContext) =&gt; Promise&lt;unknown&gt; | void</strong></code>:变异成功且包含变异结果时的回调函数。</li><li id="5068" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><code class="fe mt mu mv mw b"><strong class="kt io">onError: (err: TError, variables: TVariables, context?: TContext) =&gt; Promise&lt;unknown&gt; | void</strong></code>:变异抛出错误且包含变异结果时的回调函数。</li></ul><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="841c" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">c.查询无效</h2><p id="9cbc" class="pw-post-body-paragraph kq kr in kt b ku mo kw kx ky mp la lb ka mq le lf ke mr li lj ki ms lm ln lo ig bi translated">执行查询失效以指示查询或相关数据是旧数据并且需要更新，首先它将相关查询标记为陈旧，然后自动重新获取。有几种方法可以使对它们的查询失效，分别是<strong class="kt io">失效时间</strong>和<strong class="kt io">失效请求</strong>方法。</p><p id="f8a1" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">为了使查询失效，可以将它传递给<code class="fe mt mu mv mw b">useQuery</code>钩子作为一个选项:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a274" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">或者我们可以从<strong class="kt io"> QueryClient </strong>实例中使用<strong class="kt io">invalidate equeries</strong>方法:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7b60" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">我们也可以在进行变异后使用<strong class="kt io">invalidate equeries</strong>方法:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="8a1d" class="lx js in bd jt ly lz ma jw mb mc md jz me mf mg kd mh mi mj kh mk ml mm kl mn bi translated">预取</h1><p id="d680" class="pw-post-body-paragraph kq kr in kt b ku mo kw kx ky mp la lb ka mq le lf ke mr li lj ki ms lm ln lo ig bi translated">想象一下，如果你有一个电子商务应用程序，并且你有一个预览功能，当你悬停在它上面时，直接显示关于产品的最少信息。如果是这种情况，您可能需要对数据进行预取，以获得更好的UX。</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="740f" class="lx js in bd jt ly lz ma jw mb mc md jz me mf mg kd mh mi mj kh mk ml mm kl mn bi translated">结论</h1><p id="d25c" class="pw-post-body-paragraph kq kr in kt b ku mo kw kx ky mp la lb ka mq le lf ke mr li lj ki ms lm ln lo ig bi translated">react-query可以提供更多有影响力的功能，包括<strong class="kt io">并行查询</strong>、<strong class="kt io">依赖查询</strong>、<strong class="kt io">分页查询</strong>和<strong class="kt io">无限查询</strong>、<strong class="kt io">等</strong>。前面提到的所有<code class="fe mt mu mv mw b">react-query</code>都是最常用的。<code class="fe mt mu mv mw b">react-query</code>管理缓存数据并执行异步流程，如运行后台更新。它还取代了Redux等用来管理数据的所有样板代码。</p><p id="d4bf" class="pw-post-body-paragraph kq kr in kt b ku kv kw kx ky kz la lb ka ld le lf ke lh li lj ki ll lm ln lo ig bi translated">所以，我们碰到一个问题:<code class="fe mt mu mv mw b">react-query</code>会取代像Redux、MobX或Context API这样的全局状态管理模式工具吗？好吧，如果上下文是关于管理需要在一定时间内更新以保持数据新鲜的数据，我更倾向于回答是的，你可以组合它。但是对于仅在客户端状态上的全局状态管理，使用它作为协议，以便组件可以通信，例如主题化。但是如果你的应用程序更像“页面生成器”，客户端状态经常同步变化，那么你应该坚持全局状态管理模式。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="afaf" class="lx js in bd jt ly lz ma jw mb mc md jz me mf mg kd mh mi mj kh mk ml mm kl mn bi translated">参考</h1><ul class=""><li id="2939" class="mx my in kt b ku mo ky mp ka nz ke oa ki ob lo nc nd ne nf bi translated">林斯利·坦纳。"官方文件"<em class="ks">反应过来查询react-query.tanstack.com/overview.</em></li><li id="d017" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated">尼古拉斯·桑托斯。"对服务器状态的查询和管理做出反应."<em class="ks">开发社区</em>，开发社区，2020年9月29日，DEV . to/root strap/react-query-and-management-of-server-state-8ol。</li><li id="70f4" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated">多米尼克·多尔夫梅斯特。"反应查询和打字稿."<em class="ks">特克多多的博客</em>，2021年5月16日，tkdodo.eu/blog/react-query-and-type-script.</li><li id="bd71" class="mx my in kt b ku ng ky nh ka ni ke nj ki nk lo nc nd ne nf bi translated"><a class="ae lp" href="https://tsh.io/blog/react-query-tutorial/" rel="noopener ugc nofollow" target="_blank">开发者Dawid Piela Frontend等人《下一件大事！对服务器状态数据管理的查询作出反应。<em class="ks">软件屋</em>，2021年5月14日，tsh.io/blog/react-query-tutorial/.</a></li></ul></div></div>    
</body>
</html>