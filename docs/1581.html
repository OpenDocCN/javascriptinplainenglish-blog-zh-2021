<html>
<head>
<title>Build a Peer-to-Peer (P2P) Image Sharing App with WebRTC and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WebRTC和React构建一个点对点(P2P)图像共享应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-p2p-image-sharing-app-with-webrtc-and-react-fe6b3d1976d5?source=collection_archive---------4-----------------------#2021-04-05">https://javascript.plainenglish.io/build-a-p2p-image-sharing-app-with-webrtc-and-react-fe6b3d1976d5?source=collection_archive---------4-----------------------#2021-04-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fd4466ed83df9cd40e5a7fceddd8e803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NnZIXstTuu-qUj33"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Priscilla Du Preez</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="da8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">WebRTC使得在两个浏览器之间传输文件成为可能，消除了在共享之前将文件上传到服务器的需要。数据不存储在中间服务器中，这使得传输快速而安全。在本文中，我们将构建一个简单的React应用程序，允许用户使用WebRTC彼此直接共享图像。</p><p id="5dc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将构建的演示:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/e06ad71f00940d110e327db1ddac2b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*XpA4DRFT2_mMHZ0-EVhbJw.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The final app</figcaption></figure><p id="f74c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要一个信令服务器。这用于在对等体之间建立连接。信令服务器不处理媒体流量，它只负责使用户能够在网络中找到彼此，建立连接，重置和关闭连接。</p><p id="6301" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从创建一个带有Express服务器和套接字的新项目开始。IO，因为我们希望我们的信令服务器使用WebSocket连接。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d402" class="li lj in le b gy lk ll l lm ln">$ yarn init</span><span id="d223" class="li lj in le b gy lo ll l lm ln">$ yarn add express socket.io username-generator</span></pre><p id="39db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在创建一个<code class="fe lp lq lr le b">index.js</code>文件，作为我们应用程序的入口点。首先导入库并设置我们的服务器:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="28d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，我们的服务器需要监听来自客户端的事件，并发出另一个事件作为响应。我们在一个名为<code class="fe lp lq lr le b">SOCKET_EVENT</code>的变量中定义所有这些事件</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0499" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还需要一个变量来存储所有连接的用户。我们在<code class="fe lp lq lr le b">users</code>对象上这样做。在<code class="fe lp lq lr le b">username-generator</code>库的帮助下，我们还为所有连接的用户分配随机的用户名。</p><p id="f3af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还定义了两个助手函数，<code class="fe lp lq lr le b">usersList</code>将<code class="fe lp lq lr le b">users</code>对象转换成一个数组，而<code class="fe lp lq lr le b">logger</code>只用于登录控制台，因此我们可以看到里面发生了什么。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1c16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，现在是主要部分，在同伴之间建立联系。我们在这里基本上做的是中继来自两个用户的消息，以便他们可以建立对等连接。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7da8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务器部分已经完成，我们可以继续前进到前端。我们首先创建一个新的react应用程序:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="6117" class="li lj in le b gy lk ll l lm ln">$ create-react-app pic-share </span></pre><p id="b3f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还需要添加一些额外的包。<code class="fe lp lq lr le b">simple-peer</code>使得使用WebRTC API更加容易。我们也将使用布尔玛的造型。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="f470" class="li lj in le b gy lk ll l lm ln">$ yarn add simple-peer react-bulma-components react-dropzone socket.io-client</span></pre><p id="94fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有与WebRTC相关的逻辑都将放在<code class="fe lp lq lr le b">App.js</code>文件中。我们将在这里使用一些自定义组件，这些组件可以从<a class="ae jz" href="https://github.com/eyuelberga/pic-share" rel="noopener ugc nofollow" target="_blank">源代码</a>中获得。让我们定义我们需要开始的所有状态和引用。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2b1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要监听从信令服务器发出的事件并处理它们。让我们在一个效果挂钩上这样做。注意，我们为第二个参数提供了一个空数组，因为我们不希望它在每次更新时都运行。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3db6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们定义方法来处理应用程序的主要功能，即发送、接受和拒绝请求。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="dffc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用户发送请求时，会向用户发送一个信号。发送方一直等到建立连接，然后开始发送图像。当发送完所有卡盘时，用户发送<code class="fe lp lq lr le b">EOF</code>指示文件结束。在接收器端，用户接收所有的卡盘并将它们组合成一个斑点，形成完整的图像。</p><p id="e5c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们最终的<code class="fe lp lq lr le b">App.js</code>文件看起来会像这样:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="36ec" class="li lj in bd lu lv lw dn lx ly lz dp ma kl mb mc md kp me mf mg kt mh mi mj mk bi translated">结论</h2><p id="1cdf" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">这篇文章到此为止，希望你喜欢阅读它。查看<a class="ae jz" href="https://github.com/eyuelberga/pic-share" rel="noopener ugc nofollow" target="_blank">源代码</a>和<a class="ae jz" href="https://pic-p2p-share.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">演示</a>，请在评论区分享您的意见或建议。</p><p id="f6ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>