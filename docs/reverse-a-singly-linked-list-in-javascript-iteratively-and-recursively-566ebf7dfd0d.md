# 在 JavaScript 中反转一个单链表(迭代和递归)

> 原文：<https://javascript.plainenglish.io/reverse-a-singly-linked-list-in-javascript-iteratively-and-recursively-566ebf7dfd0d?source=collection_archive---------14----------------------->

## 如何以迭代和递归的方式反转 JavaScript 中的单链表？

![](img/2197f5a2b22c508eddc2a78ad25b14a4.png)

Photo by [JJ Ying](https://unsplash.com/@jjying?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

如果你申请软件工程师职位(尤其是在大型 FAANG 类型的公司),你可能会遇到的一个常见的面试问题是反转链表。

如果你熟悉什么是链表，这个问题看起来就像是小菜一碟。别这么快！

反转链表包括几个不同的步骤，需要按照特定的顺序来实现。所以让我们从什么是链表开始，看看你在野外最有可能遇到的链表类型。

# 什么是链表？

链表是一种数据结构。它是线性存储的元素或节点的集合，每个节点包含一个引用列表中下一个节点的指针，因此将整个节点集合相互链接。这是概念的基本概述。现在有几种类型的链表，如单向链表和双向链表。这里我们将只实现第一个。

**单链表**是节点的集合，每个节点持有一个下一个指针，引用下一个节点，直到最后一个节点的下一个指针指向空。

```
{1, next} => {2, next} => {3, next} => {4, next} => null
```

**双向链表**也是一个节点集合，虽然它们像单向链表一样有一个指向下一个节点的指针，但是它们也有一个指向前一个节点的指针。

```
{prev, 1, next} <=> {prev, 2, next} <=> {prev, 3, next} => null
```

# 迭代方法

要迭代反转一个单链表，我们必须调整每个节点的节点指针，使其指向链表中的前一个节点。由于单链表只有带有下一个指针的节点，我们需要在当前遍历的每个节点之前手动跟踪前一个节点。

为了解决这个问题，我们应该就地操作节点指针，而不是创建一个新的链表。

下面是我们的单链表节点的外观:

现在我们有了一个我们将要处理的视觉效果，让我们在下面的`reverse()`函数中实现我们的解决方案。

在第 5-7 行，我们设置了几个指针来跟踪当前节点、当前节点之前的前一个节点和当前节点之后的下一个节点。然后，对于第 10–15 行，我们通过在每次迭代期间调整节点指针来执行反转，以就地反转链表。当反转完成时，我们从循环中脱离。在第 17–18 行，我们将头部重置为单链表原始顺序的最后一个节点，并返回对新头部的引用。

```
Before: {1, next} => {2, next} => {3, next} => {4, next} => nullAfter:  {4, next} => {3, next} => {2, next} => {1, next} => null
```

# 递归方法

我们已经看到了如何迭代地反转一个链表，现在让我们来看看如何递归地反转一个单链表。

我们将从头节点开始反转列表，然后递归地向下遍历调用堆栈，直到到达最后一个节点。当我们到达最后一个节点时，我们可以通过调整每个节点的 next 指针来遍历调用堆栈，从而反转列表。一旦我们回到顶部，因为我们保存了对最后一个节点(新的头)的引用，我们就可以返回它，给我们一个完全相反的列表。

第 3–5 行是我们的退出条件，当我们完成链表的反转时，我们将在这里返回新的头。那么第 6–9 行是我们算法的核心。第 6 行是我们在调用堆栈中向下移动的地方，直到我们到达列表的末尾。第 7 & 8 行是我们调整下一个指针来反转链接的地方，第 9 行是我们返回调用栈和评估结果`reversedHead`的地方。

下图可能有助于理解这一逻辑。它表示调用堆栈如何出现在这个问题中:

```
 -----------------CALL STACK------------------- -(head)(reversedHead)------------------------- ----------(head)(reversedHead)---------------- -------------------(head)(reversedHead)------- ---------------------------------------(head)-
```

在上面的视图中，每一行代表为每个递归函数调用创建的堆栈框架。头的顶部引用是当它第一次被传入我们的`recursivelyReverseList()`函数时。最后一行代表我们到达列表末尾时的基本情况。然后，当返回调用堆栈并引用新的列表头时，就会发生相反的情况。

# 摘要

学习如何反转链表是学习常见面试问题的一个很好的练习。它可能会绊倒你很多次(就像我一样！)但是如果你坚持下去，你可能会对这个基本的数据结构有更好的理解。

# 资源

*   [反转链表—迭代法](https://www.youtube.com/watch?v=sYcOK51hl-A)
*   [使用递归反转链表](https://www.youtube.com/watch?v=KYH83T4q6Vs&t=39s)
*   [如何反转单链表终极解释](https://www.youtube.com/watch?v=O0By4Zq0OFc)

*更多内容请看*[***plain English . io***](http://plainenglish.io/)