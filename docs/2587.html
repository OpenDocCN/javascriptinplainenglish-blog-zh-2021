<html>
<head>
<title>6 Reasons Why Your React Native Application is Slow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本地应用反应缓慢的6个原因</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-performance-dos-and-don-t-c3de8739e0a8?source=collection_archive---------2-----------------------#2021-05-28">https://javascript.plainenglish.io/react-native-performance-dos-and-don-t-c3de8739e0a8?source=collection_archive---------2-----------------------#2021-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1e78" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何改善。反应本地性能做什么和不做什么</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/11f056d2d19abbb7c491fee624bcd9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SbygmYYoiEzS5esw"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="953b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反应本机应用程序在大多数时候真的很慢。大量的列表、图像、资产、API响应和多重渲染、剖析、记忆、延迟加载，在改进应用程序性能的过程中，我遇到了这么多术语。</p><p id="2fc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">深入理解应用程序速度慢的原因并不是一件容易的事情，您也不能轻易地追溯出是哪个模块造成了性能问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="d415" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">衡量绩效？</h2><p id="da73" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">测量React本机应用程序性能的最佳方法是使用Perf monitor了解JS线程及其每秒帧数。React native依靠一个Native桥来对话android和ios软件的Native层。JS bridge和本机软件之间的每个对话都被视为一个单独的框架。</p><p id="8a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何类型的用户活动，如触摸事件和API响应以及UI中基本组件的呈现，都会直接影响帧速率和JS线程。所以你的API响应需要更多的时间，JS线程会被阻塞，更多的帧会被丢弃，因此用户会感觉应用程序很慢或滞后。</p><p id="f8d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API或组件渲染的任何响应超过100毫秒将使帧速率降低12。因此，您必须注意在react应用程序中的特定时间和位置应该调用哪个特定的API。</p><p id="952a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多开发人员仍然认为功能组件比类组件慢，所以他们倾向于在整个应用程序中进行转换。嗯，这只是一个神话，没有这样的研究或坚实的理由可以支持这个假设，这只是预测。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="fc9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，这里是你的反应原生应用程序慢的原因。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="2d8e" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">1.减少重新渲染</h2><p id="cf06" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这种情况下，降低帧速率的主要问题。大多数情况下，更新全局上下文会使用该上下文重新呈现最深的后代。</p><blockquote class="mx my mz"><p id="a4c3" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated">每当提供者的<code class="fe ne nf ng nh b">value</code>属性改变时，作为提供者后代的所有消费者都将重新呈现。</p></blockquote><p id="e7e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这句台词在<a class="ae kv" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank"> React-docs </a>里面提到过。即使父组件的子组件A没有更新它的任何状态或属性，如果树中的任何组件将更新上下文API，它也将被重新呈现。</p><p id="f353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用分析来计算渲染次数。通过简单地将<strong class="ky ir"> onRender </strong>回调函数附加到主要组件上，你可以检查每个组件的渲染次数。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="1b14" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">2.使用记忆</h2><p id="11bf" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">避免重新渲染就是记住组件。记忆化基本上是缓存数据，只有当他的状态或道具改变时才重新渲染。记忆化有助于组件不重新呈现，即使其附近的父组件属性或状态发生变化。</p><p id="9a4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<strong class="ky ir">使用记忆</strong>和<strong class="ky ir">使用回调</strong>钩子你可以记忆组件。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="f40c" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">3.使用纯组件</h2><p id="862e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">任何组件将是静态的，如图像，标题，标题应被视为一个纯粹的组件。尝试使这些组件成为一个纯粹的组件，这样可以避免多次渲染。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="0b8e" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">4.没有延迟加载和分页</h2><p id="938f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果您处理大量的数据和资产，总是喜欢添加分页和延迟加载。惰性加载有助于仅呈现视图中的组件，而分页有助于仅获取所需数量的数据。这两个过程都提高了性能。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="fa8a" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">5.停止过度提取数据</h2><p id="862b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果你处理实时图表，例如，股票市场，你倾向于在前端获取不需要的数据。过度获取不必要的数据将增加API响应时间，并最终降低帧速率，这又会导致性能问题。仅获取所需的数据将再次提高性能。</p><p id="65db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前端做到这一点的一种方法是使用GraphQL wrapper over REST API。这个包装器从GraphQL客户端调用REST API，帮助API只返回所需的数据。</p><div class="ni nj gp gr nk nl"><a rel="noopener  ugc nofollow" target="_blank" href="/calling-rest-api-inside-graphql-queries-e715c0f2da44"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">在GraphQL查询中调用REST API</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">您不需要将我们的后端从REST切换到GraphQL，而是在Graph QL中获取REST查询。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nl"/></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="fdad" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">6.在滚动视图上使用平面列表</h2><p id="8270" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我已经讲述了为什么Flatlist比React Native中的ScrollView组件更好。Flatlist提供了延迟加载、分页功能，你可以使用简单的技巧，比如useMemo和flatlist中的纯组件，这样你就可以避免重新渲染。这些小变化大大提高了性能。</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/nerd-for-tech/flatlist-is-still-underrated-796130a8b8f2" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">Flatlist仍然被低估了</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">也许你使用Flatlist的方式是错误的，这里有一些提示和技巧</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz kp nl"/></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="60f9" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">摘要</h2><ul class=""><li id="8829" class="ob oc iq ky b kz ms lc mt lf od lj oe ln of lr og oh oi oj bi translated">避免重新渲染</li><li id="247f" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">使用记忆化和纯组件来避免不必要的渲染</li><li id="22cb" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">添加延迟加载和分页来提高性能。</li><li id="89b4" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">在前端实现GraphQL over REST API，以避免数据的过量提取。</li><li id="5d9c" class="ob oc iq ky b kz ok lc ol lf om lj on ln oo lr og oh oi oj bi translated">在ScrollView组件上使用Flatlist</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="dfea" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">结论</h2><p id="6daa" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我希望这个故事会有所帮助，因为我花了近一个月的时间来研究和了解为什么我的React本机应用程序很慢。更多这样的故事，请跟我来。直到，下一次，有一个美好的一天，人们。</p><pre class="kg kh ki kj gt op nh oq or aw os bi"><span id="e45c" class="lz ma iq nh b gy ot ou l ov ow">For more reach our website 💻 <a class="ae kv" href="http://ihatereading.in/" rel="noopener ugc nofollow" target="_blank">iHateReading</a></span></pre><p id="a240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="na">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="na">plain English . io</em></strong></a></p></div></div>    
</body>
</html>