<html>
<head>
<title>Building a Nodemon Clone from Scratch in 20 lines of JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用20行JavaScript代码从头开始构建Nodemon克隆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nodemon-clone-node-js-9d69c2c5593b?source=collection_archive---------2-----------------------#2021-09-10">https://javascript.plainenglish.io/nodemon-clone-node-js-9d69c2c5593b?source=collection_archive---------2-----------------------#2021-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="33ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在了解子进程、CLI和文件更改时</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca603c59ddb4230829b8d3d643231a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hINuB0xeBcrvw2XSwxl4-A.png"/></div></div></figure><p id="ab84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Nodemon是构建Node.js的一个非常有用的工具。全局安装的包可以执行Node应用程序——每当我们更改应用程序的代码时，Nodemon都会以极快的速度重新启动它。这使得用Node开发服务器变得特别容易。但是Nodemon是如何工作的呢？让我们通过构建一个克隆体来找出答案。</p><h1 id="3461" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">我们克隆人背后的想法</h1><p id="ca07" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果您想直接进入代码，请随意跳过这一部分。我写这篇文章是为了向您介绍子进程背后的思想。</p><p id="b4d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我提到的，Nodemon做了以下事情:每当JavaScript文件发生变化时，它都会重新启动Node.js实例。所以首先，我们需要弄清楚Nodemon实际上是如何运行代码的。我想到了两种方法:</p><p id="5775" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，Nodemon <strong class="kt ir">可以</strong>在幕后使用虚拟机。我<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/node-js-vm-5727c269f8ec">写了更多关于Node.js内置模块的细节，它允许我们在虚拟环境中执行js代码。然而，还有一个更简单的选择:子进程。</a></p><p id="aa02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的第二个想法，Nodemon如何在幕后工作，是一个子进程。如您所知，当运行Node.js实例时，它会在您的操作系统上创建一个进程。Node.js可以很容易地创建更多的进程，从而执行其他节点实例。</p><p id="680a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当Node.js应用程序使用/创建子进程时，您可以看到它。为什么？因为它创建了更多的进程，我们可以在列出所有进程时看到。在windows上，这可以通过任务管理器实现。在macOS上，我使用活动监视器。</p><p id="e6e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用一个小服务器启动Nodemon，我证实了我的怀疑:Nodemon运行一个子进程，如你所见:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/2157d15c046be5dd2c4f8b1c48519027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-0AAvOCQ8ZiiL0giKuD6A.png"/></div></div></figure><p id="2ae5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，为了构建一个合适的Nodemon克隆，我们应该使用一个子进程。让我们开始写代码。</p><h1 id="b4cf" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">编写我们的Nodemon克隆</h1><p id="6a49" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在Node.js. <br/>中创建一个子进程比听起来容易，有几种方法可以做到。最舒服的是<code class="fe mm mn mo mp b">fork</code>——它专注于运行另一个节点实例，而不是我们想要的任何东西。</p><p id="e647" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的Nodemon克隆的目标是运行一个节点应用程序，像Express server一样，作为子进程。因此，我创建了一个基本的server.js，作为试验品:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="6c37" class="mu lo iq mp b gy mv mw l mx my">const app = require('express')()</span><span id="1c16" class="mu lo iq mp b gy mz mw l mx my">app.get('/', (req, res) =&gt; {<br/>  res.send('hello')<br/>})</span><span id="171d" class="mu lo iq mp b gy mz mw l mx my">app.listen(8080)</span></pre><p id="993c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将这个<code class="fe mm mn mo mp b">server.js</code>作为子进程运行很容易。创建另一个JS文件，并用以下代码填充它:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="9ef1" class="mu lo iq mp b gy mv mw l mx my">const { fork } = require('child_process')</span><span id="90a0" class="mu lo iq mp b gy mz mw l mx my">const child = fork('./server.js')</span></pre><p id="5cc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您执行另一个JS文件，也就是我们的Nodemon克隆时，Express服务器就启动并运行了——作为一个子进程。</p><p id="1eac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，一切都很好——但是当发生变化时重启应用程序会怎么样呢？</p><h2 id="fc5d" class="mu lo iq bd lp na nb dn lt nc nd dp lx la ne nf lz le ng nh mb li ni nj md nk bi translated">介绍chokidar</h2><p id="f05d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">每当代码发生变化时，Nodemon都会重新启动我们想要运行的应用程序。这也包括目录中的所有其他文件。也就是说，Nodemon默认监视当前目录的任何变化——choki Dar可以帮助我们做到这一点。</p><p id="0c2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个包可以用<code class="fe mm mn mo mp b">npm install chokidar</code>安装，默认情况下会监视一个提供的目录。</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="76f0" class="mu lo iq mp b gy mv mw l mx my">const watcher = chokidar.watch('./', {<br/>  ignoreInitial: true,<br/>})</span><span id="d471" class="mu lo iq mp b gy mz mw l mx my">watcher.on('all', () =&gt; {<br/>  console.log('a file changed!')<br/>})</span></pre><p id="ce70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行这个命令时，每当我们更改当前目录中的文件时，都会得到一个console.log。但是重启呢？要终止子进程，我们可以运行:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="49c5" class="mu lo iq mp b gy mv mw l mx my">const child = fork('./server')<br/>child.kill()</span></pre><p id="8531" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了重启，我们用一个正在运行的实例覆盖子变量。因此，我们将<code class="fe mm mn mo mp b">const</code>改为<code class="fe mm mn mo mp b">let</code>，并实现重启功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a4e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是一个非常基本的Nodemon-clone。当您运行克隆(我将其命名为<code class="fe mm mn mo mp b">nodemon-clone.js</code>)时，它将启动<code class="fe mm mn mo mp b">server.js</code>——并在所有文件更改时快速重启。</p><h1 id="8f10" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">让它更方便</h1><p id="a3ba" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">到目前为止，我们希望用Nodemon克隆执行的文件是硬编码的。此外，我们需要执行Nodemon克隆本身——而原始包是一个全局CLI。让我们的克隆也成为一个灵活和方便的CLI，所以它看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4fc1cd826ba57244037d9ac4fb4dc002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/1*KB9SB2j1WTOrm2l6v34vrg.gif"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">IDK why this GIF is running so slowly</figcaption></figure><p id="610f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我已经做了一个<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/node-js-cli-cef1e080b8a9">教程</a>关于创建Node.js CLI，所以一个节点程序，可以在你的机器上的任何地方执行，通过它的名字进入你的终端。没那么难。首先，我们需要为此润色我们的package.json。确保main和bin条目指向Nodemon克隆的主文件。在我的例子中，我将文件<code class="fe mm mn mo mp b">nodemon-clone.js</code>重命名为<code class="fe mm mn mo mp b">index.js</code>:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="cdf5" class="mu lo iq mp b gy mv mw l mx my">"bin": "./index.js",<br/>"main": "./index.js",</span></pre><p id="a6e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，确保package.json中的name条目是您喜欢的名称—那里的值是我们在控制台中称之为它的命令。我选择“nodemon-clone”作为名称值，并建议您也这样做。</p><p id="90be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们需要获取提供的文件作为代码中的参数。因此，当我们输入<code class="fe mm mn mo mp b">nodemon-clone app.js</code>时,“app.js”就是我们想要提供的文件。这可以通过<code class="fe mm mn mo mp b">process.argv</code>实现。另一个小变化是文件的第一行—必须是<em class="ns"> #！/usr/bin/env节点。</em>以下是更新后的完整代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="03c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要使该文件作为全局命令可用，请在目录中运行<code class="fe mm mn mo mp b">npm link</code>。现在，我们完成了！</p><p id="81d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了进行测试，您可以在机器上的任何地方创建Express server示例。当您在终端中移动到同一个目录时，您可以运行<code class="fe mm mn mo mp b">nodemon-clone &lt;your-file&gt;.js</code>——它应该工作正常。</p><p id="eb3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果想看完整代码:<a class="ae mk" href="https://github.com/LouisPetrik/nodemon-clone" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>。感谢您的阅读！</p><p id="50a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是Node.js的更多内容:</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/node-js-development-server-8365a9bf449b"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">如何用Node.js从零开始搭建网站开发服务器</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">在每次代码更改时重新加载页面</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="of l"><div class="og l oh oi oj of ok kp nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/node-js-vm-5727c269f8ec"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">探索节点虚拟机模块的可能性</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">理解上下文、执行和用例</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="of l"><div class="ol l oh oi oj of ok kp nw"/></div></div></a></div><p id="2501" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ns">更多内容看</em><a class="ae mk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ns">plain English . io</em></strong></a></p></div></div>    
</body>
</html>