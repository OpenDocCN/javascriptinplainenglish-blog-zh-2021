<html>
<head>
<title>How to Get a Sequence in Order With No Duplicate Consecutive Items</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何得到一个没有重复连续项目的有序序列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-get-a-sequence-in-order-with-no-duplicate-consecutive-items-9c2f433d7e90?source=collection_archive---------8-----------------------#2021-06-11">https://javascript.plainenglish.io/how-to-get-a-sequence-in-order-with-no-duplicate-consecutive-items-9c2f433d7e90?source=collection_archive---------8-----------------------#2021-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/00f9926c435dfc2b9b30a0f4c2910f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itrcUCxgb1die1IkgTkWpw.png"/></div></div></figure><p id="575a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个请求。实现函数uniqueInOrder，该函数将一个序列作为参数，并返回一个项目列表，该列表不包含任何相邻的具有相同值的元素，并保留元素的原始顺序。</p><p id="fd18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我发现这实际上是另一个Codewars挑战。你可以在这里找到挑战<a class="ae ku" href="https://www.codewars.com/kata/54e6533c92449cc251001667/javascript" rel="noopener ugc nofollow" target="_blank"><em class="kt"/></a><em class="kt">。</em></p><p id="2950" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">免责声明:</strong>解决这个问题的方法有很多。这些是我写的或者我觉得聪明的一些答案，解释了它们为什么/如何工作</p><p id="e2ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> TLDR: </strong>在帖子底部解释最佳解决方案，在每个部分底部解释实际解决方案</p><h1 id="671c" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">问题是</h1><p id="a1a4" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">创建一个函数，该函数接受一个字符串或数组，并返回一个项目列表，其中不包含任何相邻的具有相同值的元素，并保留元素的原始顺序。</p><p id="44ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">示例:</strong></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="b691" class="mh kw in md b gy mi mj l mk ml">uniqueInOrder('AAAABBBCCDAABBB') // ['A', 'B', 'C', 'D', 'A', 'B']<br/>      uniqueInOrder('ABBCcAD') // ['A', 'B', 'C', 'c', 'A', 'D'] <br/>      uniqueInOrder([1,2,2,3,3]) // [1,2,3] <br/>      uniqueInOrder(['hello', 'Hello', 'Hello', 'Hello', 'dev', 'dev', 'world', 'World', 'dev', 'world']) // ['hello', 'Hello', 'dev', 'world', 'World', 'dev', 'world']<br/>      uniqueInOrder([1, 1, 2, 2, 3, 3, 1, 1, 1]) // [1,2,3,1]</span></pre><h1 id="4646" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">解决办法</h1><ul class=""><li id="cd20" class="mm mn in jx b jy lt kc lu kg mo kk mp ko mq ks mr ms mt mu bi translated">解决方案1</li><li id="584f" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">为最终数组创建变量</li><li id="24c4" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">循环输入</li><li id="e211" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">如果当前项与最后一项不匹配，则将它推到最后一个数组上，否则继续循环</li><li id="ebb9" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">循环后返回最后一个数组</li><li id="4c98" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">解决方案2</li><li id="da9f" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">将输入扩展到数组中(如果是字符串)</li><li id="7822" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">通过检查之前的索引是否与当前项目相同来进行筛选</li></ul><h1 id="a173" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">解决方案1。可读性更强</h1><p id="eaed" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">创建一个接受和输入的函数</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="db94" class="mh kw in md b gy mi mj l mk ml">function uniqueInOrder(input) {<br/>    //create a variable for a final array<br/>    //loop through input <br/>    //if the current item doesn’t match the last one push it onto the final array otherwise continue the loop<br/>    //after the loop return the final array <br/>}</span></pre><p id="9997" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个变量，让我们把所有的东西都放进去，这个变量就是我们最后返回的数组。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="e2fc" class="mh kw in md b gy mi mj l mk ml">function uniqueInOrder(input) {<br/>    let finalArray = []<br/>    //loop through input <br/>    //if the current item doesn’t match the last one push it onto the final array otherwise continue the loop<br/>    //after the loop return the final array <br/>}</span></pre><p id="783d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用for循环遍历传递给函数的数组。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ac54" class="mh kw in md b gy mi mj l mk ml">function uniqueInOrder(input) {<br/>    let finalArray = []<br/>    for (let i = 0; i &lt; input.length; i++) {<br/>    //if the current item doesn’t match the last one push it onto the final array otherwise continue the loop<br/>    }<br/>    //after the loop return the final array <br/>}</span></pre><p id="d3b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了查看我们是否在刚才的项目上，我们将检查finalArray。因为我们在遍历时会将所有内容都推送到那个数组，所以如果数组中的最后一项与当前项相同，那么它就是一个重复的连续项。否则它不是，我们想添加它。您会注意到我们正在检查finalArray.length -1，因为我们正在检查索引，而索引是0索引的，这意味着它们从0而不是1开始。为了得到最后一个索引，我们需要从长度中减去1，因为索引总是比长度低1(长度不是0索引)。如果它不是重复的，我们将把该项推到最后一个数组上。这将把该项放在最终数组的末尾。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9c3b" class="mh kw in md b gy mi mj l mk ml">function uniqueInOrder(input) {<br/>    let finalArray = []<br/>    for (let i = 0; i &lt; input.length; i++) {<br/>        if (input[i] != finalArray[finalArray.length - 1]) {<br/>            finalArray.push(input[i])<br/>        }   <br/>    }<br/>    //after the loop return the final array <br/>}</span></pre><p id="3578" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们只需要返回最后一个数组，我们已经把所有的东西都放进去了</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c7ca" class="mh kw in md b gy mi mj l mk ml">function uniqueInOrder(input) {<br/>    let finalArray = []<br/>    for (let i = 0; i &lt; input.length; i++) {<br/>        if (input[i] != finalArray[finalArray.length - 1]) {<br/>            finalArray.push(input[i])<br/>        }   <br/>    }<br/>    return finalArray<br/>}</span></pre><h1 id="52f3" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">解决方案2。代码行更少，性能更高</h1><p id="022f" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">我们将再次创建一个接受和输入的函数</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="14f2" class="mh kw in md b gy mi mj l mk ml">function uniqueInOrder(input){<br/>    //spread input into an array (in case it is a string)<br/>    //filter by checking if the index before it was the same as the current item<br/>}</span></pre><p id="8d4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将把输入扩散到一个数组中，如果我们得到一个字符串，它将被转换成一个数组，这样我们就可以对它进行T2过滤。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8ca5" class="mh kw in md b gy mi mj l mk ml">function uniqueInOrder(input){<br/>    [...input]<br/>}</span></pre><p id="e1ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们将通过检查当前项之前的索引是否与其相同来过滤数组。如果是，它会过滤掉。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="129d" class="mh kw in md b gy mi mj l mk ml">function uniqueInOrder(input){<br/>    return [...input].filter((item, index) =&gt; item !== input[index - 1])<br/>}</span></pre><h1 id="76ac" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h1><p id="d4de" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">尽管解决方案2的性能更好，但我认为解决方案1更容易阅读。尽管解决方案2并不难理解。如果你对在<a class="ae ku" href="https://jsbench.me/" rel="noopener ugc nofollow" target="_blank"> jsbench </a>上测试的性能感兴趣，这里是我使用上述测试案例的结果。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/ce72f86fe7cd923b03bccf7d4644b669.png" data-original-src="https://miro.medium.com/v2/5ffadf025ea3ff12ea6b65fc"/></div></figure><p id="ee7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你玩得开心！请在评论区留下您的回购链接。也让我知道你是喜欢多日挑战还是真的讨厌它们！如果你有任何你希望看到完成的挑战，也请在下面的评论中留下，你可能会看到它出现！如果您希望每天早上通过电子邮件收到挑战，并在发布解决方案时收到通知，请在此订阅<a class="ae ku" href="https://lp.constantcontactpages.com/su/p9lFW6y/ChallengeSignUp" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7b37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">原贴于</em><a class="ae ku" href="https://hellodevworld.com/365-days-of-coding/how-to-get-a-sequence-in-order-with-no-duplicate-consecutive-items" rel="noopener ugc nofollow" target="_blank"><em class="kt">hellodevworld.com</em></a></p></div></div>    
</body>
</html>