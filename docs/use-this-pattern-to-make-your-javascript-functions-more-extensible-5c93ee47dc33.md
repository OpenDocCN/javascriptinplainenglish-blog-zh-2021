# 使用这种模式使您的 JavaScript 函数更具可扩展性

> 原文：<https://javascript.plainenglish.io/use-this-pattern-to-make-your-javascript-functions-more-extensible-5c93ee47dc33?source=collection_archive---------7----------------------->

![](img/424345287f028064b1b2d35c5bd01253.png)

Photo by [Florian Klauer](https://unsplash.com/@florianklauer?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

## 使用 ES6 对象析构使你的代码更容易理解

我最近发现自己处于这样一种情况，我必须向代码库中多个地方使用的函数添加一个额外的参数。由于参数的顺序，当我需要调用函数时，在末尾添加另一个参数将意味着传递不必要的值，但是在中间添加参数将意味着破坏我已经在调用它的实例。我处于进退两难的境地。

让我们来看一个例子:

这是一个发布一些数据的简单函数，可以选择覆盖基本 URL 来访问不同的 API。大多数情况下，您会在没有`baseUrl`参数的情况下调用它，因为您会碰到应用程序的 API:

但是在某些情况下，您会与第三方 API 集成并发送不同的值:

假设有一个需求，要求添加一些定制的头，例如一个承载令牌来验证请求。您可以在函数末尾添加另一个参数:

但是这并不理想，因为这意味着您每次都必须通过`baseUrl`,即使您很少需要覆盖它。所以另一个选择是在`baseUrl`前添加新的参数:

但是接下来——你猜对了——所有实际需要覆盖`baseUrl`的实例都需要重构。

# 完全回避这个问题

和往常一样，最好的解决方案是通过向函数传递一个对象来避免这个问题。使用 ES6 对象析构，我们可以很容易地只将我们想要的参数传递给函数，额外的好处是能够准确地看到您传递的参数。

让我们以上面的例子为例，对其进行重构:

我们所做的只是析构参数——我们仍然可以像以前一样分配默认值。

现在，当您调用该函数时，您可以只传递您需要的内容:

这里我们没有通过`baseUrl`,但是函数仍然像预期的那样工作。看看代码有多清晰——您现在可以确切地看到传递了什么，而不必参考函数中参数的顺序来确定什么是什么！

遵循这种模式意味着您可以省去一些麻烦，也意味着您的代码更清晰、更容易理解。希望你会发现它很有用，如果你有任何问题，请在下面留言！