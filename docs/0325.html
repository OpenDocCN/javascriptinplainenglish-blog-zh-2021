<html>
<head>
<title>How to use Apollo GraphQL with Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何配合Angular使用Apollo GraphQL</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-of-apollo-angular-with-angular-522bcebf7bc8?source=collection_archive---------4-----------------------#2021-01-19">https://javascript.plainenglish.io/use-of-apollo-angular-with-angular-522bcebf7bc8?source=collection_archive---------4-----------------------#2021-01-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/688a82f8322b88fa9feef3e4ca8842d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwDFo-KMUiadqU4G5gRAKg.jpeg"/></div></div></figure><p id="0e1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Apollo-Angular </strong>是一个灵活的<em class="kt"> GraphQL </em>客户端，你可以使用它从前端客户端项目或本地平台向使用<em class="kt"> GraphQL </em>构建的服务器发送查询。我们也可以说，它是一种能够在我们的客户端项目和<em class="kt"> GraphQL </em>服务器之间传输信息的结构。</p><p id="3371" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将谈谈<em class="kt">阿波罗Angular </em>在<em class="kt"> Angular </em>项目中的安装、结构和使用。</p><p id="93dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将解释它们，假设你熟悉<em class="kt"> Angular </em>和<em class="kt"> GraphQL </em>结构，并且熟悉使用<em class="kt"> Visual Studio代码</em>。</p><p id="3053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为前端，我更喜欢<em class="kt">棱角</em> ( <em class="kt">棱角11) </em>。不过<em class="kt"> Apollo Angular </em>可以用在其他JavaScript框架和原生平台上。</p><p id="2029" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为服务器，我将使用我之前在<em class="kt"> Node.js </em>中创建的<em class="kt"> GraphQL </em> -server。你可以从<a class="ae ku" href="https://azizkale.medium.com/building-graphql-server-with-node-js-c31ee3f54761" rel="noopener">这个链接</a>访问关于这个服务器的设置和机制的文章，如果你愿意，你可以从<a class="ae ku" href="https://github.com/azizkale/Web-Server-in-NodeJS-with-GraphQL" rel="noopener ugc nofollow" target="_blank">这个github链接</a>下载服务器代码作为一个项目。</p><p id="2a5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们首先创建一个<em class="kt">角度</em>项目。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6210" class="le lf in la b gy lg lh l li lj">ng new apollo-angular-in-angular</span></pre><p id="805b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">稍后，我创建一个名为<code class="fe lk ll lm la b"><em class="kt">myservice</em></code>的<em class="kt">服务</em>，在这里我将定义向服务器发送查询的函数。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="0244" class="le lf in la b gy lg lh l li lj">ng g s myservice</span></pre><h2 id="6f07" class="le lf in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">将Apollo Angular加入项目</h2><p id="8bcd" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">用<strong class="jx io">角度示意图</strong>很容易设置。为此，在命令提示符或终端中导航到项目目录<em class="kt">Apollo-angular-in-angular</em>，并编写以下命令。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4f48" class="le lf in la b gy lg lh l li lj">ng add apollo-angular</span></pre><p id="c45c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安装将自动完成。在安装过程中，它会询问您要连接的服务器的URL。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/531610582587475a068abfe5787ecc3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R13jO_zhSwj9m6_fW3cgxQ.jpeg"/></div></div></figure><p id="22cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我在本地运行服务器，所以我输入<strong class="jx io"> http: // localhost: 4000 / </strong>。众所周知，4000是<em class="kt"> GraphQL </em>的默认端口。</p><p id="99bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过此设置，<em class="kt">阿波罗角度</em>作为<strong class="jx io">独立模块</strong>添加到项目中。这个文件可以在<em class="kt"> /src/app/下找到。</em>在VS代码的源代码控制标签中，你可以看到安装时添加了哪些文件和依赖项。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/07c52ad5b22bfb9c5fd1253d74715ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oo39WOJeKqkkuyj7VoeAyw.jpeg"/></div></div></figure><p id="8142" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在安装过程中输入的服务器URL在<strong class="jx io"> graphql.module.ts </strong>文件中。需要时，您可以手动更改该文件的URL。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/bc70ed8b4e678f6f68859e178228b68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5uB7cJDK5goryxaw9xcCBA.jpeg"/></div></div></figure><p id="f676" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您也可以使用<strong class="jx io"> npm安装</strong>手动安装，无需<em class="kt">角度示意图</em>。但我不想在这里提及，以免文章拉长。你可以在它的<a class="ae ku" href="https://apollo-angular.com/docs/get-started/#installation-without-angular-schematics" rel="noopener ugc nofollow" target="_blank">官方网站</a>获得关于这个的进一步信息。</p><h2 id="6d28" class="le lf in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">Angular Apollo中的查询函数</h2><p id="5d9e" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">查询函数是在<em class="kt"> GraphQL </em>中<em class="kt">解析器</em>下定义的函数，对应<em class="kt">C</em><strong class="jx io"><em class="kt">R</em></strong><em class="kt">UD运算</em>的<strong class="jx io"> R </strong> ead】。</p><p id="a1ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将名为<em class="kt"> Apollo </em>的包包含到名为<strong class="jx io"> myservice.service.ts </strong>的<em class="kt">服务</em>文件中，并将<em class="kt">注入到<em class="kt">构造器</em>中。然后我写下下图中的代码。</em></p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/48639b6edf342a8d2fd8fed7a7bd6588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oM7zc0qEzf0ro7-jlZEL1A.jpeg"/></div></div></figure><p id="f3c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于我们将在<em class="kt"> Angular </em>侧使用的函数，其参数和类型已在<em class="kt"> GraphQL </em>服务器上预先指定，因此除了该函数，我们不能使用任何其他API。</p><p id="8b23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">名为<strong class="jx io"> USERS </strong>的变量是函数<strong class="jx io"> users </strong>的模式，该模式在<em class="kt"> GraphQL </em>中<em class="kt">解析器</em>下定义。因为它是一个查询函数，我们用一个<strong class="jx io">查询</strong>关键字创建了它的模式。这个功能是一个带给所有用户的功能。我们可以随意调用或不调用函数的字段。</p><p id="b8f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> gql </strong>是一个标签，它将客户端的函数模式解析成<em class="kt"> GraphQL </em>文档。</p><p id="9a83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<em class="kt"> getUser </em>函数中，我们用<strong class="jx io"> watchQuery </strong>方法调用数据。该方法返回一个<strong class="jx io"> QueryRef </strong>对象，该对象的<strong class="jx io"> valueChange </strong>属性是一个<strong class="jx io">可观察的</strong>。</p><p id="2768" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> GraphQL </em>中查询函数返回的结果也可以用<strong class="jx io">调用。查询</strong>方法而不是<strong class="jx io">。watchQuery </strong>方法。<strong class="jx io">。查询</strong>方法只调用一次数据。但是这个<strong class="jx io">。例如，如果另一个查询导致对象在Apollo客户端的全局缓存中更新，那么watchQuery </strong> observable也可以更新。</p><p id="be9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们将我们调用到客户端的数据作为<strong class="jx io"><em class="kt">my service . service . ts</em></strong>文件中的<em class="kt"> Observable </em>分配到<strong class="jx io"><em class="kt">app . component . ts</em></strong>文件中的数组中。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/974b2a0b02e0b94425e59c874f9ba2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omDK7aH3pJEyWx9ORm5alw.jpeg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Note that we need to write data.data.users to access the array in the object that returned from the server. Here users is the name of the Query function in GraphQL. It has nothing to do with the array’s name in the component.</figcaption></figure><p id="ac7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在组件中，我们得到了数据，这些数据在<em class="kt">服务</em>中被称为可观察的，我们订阅了这些数据，并将其分配给一个<em class="kt">数组</em>。同样，为了不拉长文章，我将数据带到组件并在控制台上观察结果。我不编辑app.component.html文件<strong class="jx io">。为此，我在<strong class="jx io"> app-routing.module.ts </strong>文件中将<strong class="jx io"> AppComponent </strong>设为默认值。这样，每次我更新在<strong class="jx io"> http://localhost: 4200 </strong>运行的<em class="kt"> Angular </em>项目的网页时，我都能在控制台上看到结果。</strong></p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/5ca90e5fbb3d0a045ced3a7f826fda63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OH-6TtWZX7ZOH13tNXU-qg.jpeg"/></div></div></figure><h2 id="5e50" class="le lf in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">Apollo Angular中带参数的函数</h2><p id="fdda" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">现在，我们将向服务器发送一个查询，其中包含一个需要参数的函数。在服务器上定义的名为<strong class="jx io"> user </strong>的函数，根据用户的id调用用户，适合于此。首先，让我们在<strong class="jx io"><em class="kt">my service . service . ts</em></strong>中定义它的模式，并将其赋给一个变量:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="3dbd" class="le lf in la b gy lg lh l li lj">const USER = gql`<br/>  query User($id: ID!) {<br/>    user(id: $id) {<br/>      id<br/>      username<br/>      city<br/>      posts {<br/>        id<br/>        title<br/>      }<br/>    }<br/>  }<br/>`;</span></pre><p id="16b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然是查询，我们再次使用了<strong class="jx io">查询</strong>关键字。与另一个不同，我们看到这个模式中有参数。首先写参数的类型，然后(在最后一行)写它们自己。</p><p id="8020" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们编写用这个模式构建函数:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="a8a1" class="le lf in la b gy lg lh l li lj">getUser(id: any): Observable&lt;any&gt; {<br/>  return this.apollo.watchQuery&lt;any&gt;({<br/>    query: USER,<br/>    variables: {<br/>      id: id,<br/>    },<br/>  }).valueChanges;<br/>}</span></pre><p id="5596" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与前面的函数不同，这个函数也有一个参数。另一个不同是<strong class="jx io">变量</strong>对象。我们将这个对象的参数发送给服务器。</p><p id="058e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们将我们调用给<em class="kt">服务</em>的数据赋给<strong class="jx io"><em class="kt">app . component . t</em></strong><em class="kt">s</em>中的一个变量:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="517b" class="le lf in la b gy lg lh l li lj">getUser(id: any) {<br/>  this.myservice.getUser(id).subscribe((data) =&gt; {<br/>    this.user = data.data.user;<br/>    console.log(this.user);<br/>  });<br/>}</span></pre><p id="dae7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将来自<em class="kt">服务</em>的数据分配给我在<em class="kt">组件</em>中定义的用户变量。因为我没有使用接口来触发函数，所以我将它们写入<strong class="jx io"> ngOnInit() </strong>。在这里，我给出了参数所需的值。我再次观察控制台上的结果。在最后一种情况下，<strong class="jx io"> ngOnInit() </strong>应该是这样的:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="21de" class="le lf in la b gy lg lh l li lj">ngOnInit(): void {<br/>  this.getUsers();<br/>  this.getUser(1); // it gets the user whose id equals 1<br/>}</span></pre><h2 id="2a8e" class="le lf in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">角阿波罗中的变异函数</h2><p id="54ee" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated"><em class="kt">创建</em>、<em class="kt">更新</em>和<em class="kt">删除</em>功能<strong class="jx io"> CRUD </strong>在<em class="kt">graph QL</em>中的<em class="kt">突变</em>类型中定义。让我们看看如何从<em class="kt">角度</em>侧发送这种类型的查询。我就举一个<em class="kt">创造</em>的例子。</p><p id="3d03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我在<strong class="jx io"><em class="kt">my service . service . t</em></strong><em class="kt">s</em>文件中定义了模式和函数:</p><p id="1b51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">架构:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="bc48" class="le lf in la b gy lg lh l li lj">const ADD_USER = gql`<br/>  mutation addUser($id: ID!, $username: String!, $city: String!) {<br/>    addUser(id: $id, username: $username, city: $city) {<br/>     id<br/>     username<br/>     city<br/>   }<br/>  }<br/>`;</span></pre><p id="491d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">功能:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8e0b" class="le lf in la b gy lg lh l li lj">addUser(id: any, username: string, city: string): Observable&lt;any&gt; {<br/>  return this.apollo.mutate({<br/>    mutation: ADD_USER,<br/>    variables: {<br/>      id: id,<br/>      username: username,<br/>      city: city,<br/>    },<br/>  });<br/>}</span></pre><p id="3c78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我转到<em class="kt"> app.component.ts，然后</em>调用服务中的函数:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="7e7b" class="le lf in la b gy lg lh l li lj">addUser(id: any, username: string, city: string) {<br/>  this.myservice.addUser(id, username, city).subscribe((data) =&gt; {<br/>    console.log(data.data.addUser);<br/>  });<br/>}</span></pre><p id="9486" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了触发该函数，我再次将其写入<strong class="jx io"> ngOnInit() </strong>，并在此处输入该函数的参数值:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4443" class="le lf in la b gy lg lh l li lj">ngOnInit(): void {<br/>  this.getUsers();<br/>  this.getUser(1);<br/>  this.addUser(5, 'aziz kale', 'ankara');<br/>}</span></pre><p id="c4ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您运行该函数时，它将返回添加的用户。您也可以在控制台上看到这一点。</p><h2 id="4106" class="le lf in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">包扎</h2><p id="4eb2" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">我们看到了如何从使用<strong class="jx io">的<strong class="jx io"> Angular </strong>向使用<strong class="jx io"> GraphQL </strong>构建的服务器发送查询。我们已经完成了两个带参数和不带参数的<strong class="jx io">查询</strong>函数示例和一个<strong class="jx io">变异</strong>函数示例。</strong></p></div></div>    
</body>
</html>