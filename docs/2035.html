<html>
<head>
<title>Types of Software Design Patterns You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的软件设计模式的类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-software-design-patterns-fe8a9f9ecabb?source=collection_archive---------5-----------------------#2021-04-29">https://javascript.plainenglish.io/what-are-software-design-patterns-fe8a9f9ecabb?source=collection_archive---------5-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8526" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论是初学者还是专家。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/6e6df90396c3498ba793a57bd2a17a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*ayrM33bNKGrPSsJ1.png"/></div></figure><p id="f140" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您是一名程序员，或者刚开始从事软件开发和编程，您迟早会遇到术语“软件设计模式”</p><h1 id="ad8b" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是软件设计模式？</h1><p id="75fc" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它是一个通用的、可重用的解决方案，适用于不同的软件设计问题。这些模板识别系统中的问题，并通过反复试验为开发人员长期面临的一般问题提供适当的解决方案。</p><p id="3e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">软件设计模式有很多很多，而且会越来越多的出现。在这篇文章中，我将谈论所谓的经典模式中最著名的。</p><h1 id="1b89" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么要使用设计模式？</h1><p id="21b7" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">信息技术产业的巨大发展导致了软件开发实践的发展。之前要求所有软件都要完成后才能测试，导致问题的产生。</p><p id="d04b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了节省时间并避免在开发完成后回到开发阶段，在开发阶段引入了测试实践。</p><p id="4ec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种做法用于识别代码中的错误条件和问题，这些错误条件和问题当时可能并不明显。简而言之，设计模式帮助你确定你的代码的有效性，因为它们是有效的解决方案，并且已经被许多开发者测试过，不容易出错。</p><h1 id="2f0f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设计模式的类型</h1><p id="aa94" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最常用的设计模式分为三大类。每个设计模式总共由23个设计模式组成。四个主要类别是:</p><ul class=""><li id="9647" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">创造模式</li><li id="a874" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">结构模式</li><li id="411e" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">行为模式</li></ul><h1 id="fe2d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创造模式</h1><p id="641b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">创建模式提供了各种对象创建机制，这些机制以适合具体情况的方式增加了现有代码的灵活性和重用性。这给了程序更多的灵活性来决定应该为给定的用例创建哪些对象。</p><h2 id="12da" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">这些是创造模式:</h2><h2 id="ea68" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">抽象工厂</h2><p id="57f2" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在这种模式中，接口创建相关对象的集合或系列，而不指定类名。</p><h2 id="e076" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">构建器模式</h2><p id="35ab" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它允许使用相同的建筑规范生产不同类型和表示的对象。它用于通过组合简单对象来逐步创建复杂对象。对象的最终创建取决于创建过程的各个阶段，但独立于其他对象。</p><h2 id="3f91" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">工厂方法</h2><p id="7711" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">提供在超类中创建对象的接口，但允许子类改变所创建对象的类型。通过公共接口提供隐式对象实例化。</p><h2 id="b75a" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">原型</h2><p id="aa5c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它允许您复制现有的对象，而无需让您的代码依赖于它们的类。它用于通过使用对象副本将修改保持在最低限度来限制内存/数据库操作。</p><h2 id="837f" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">一个</h2><p id="a434" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这种设计模式将一个类的实例化限制为一个对象。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="c732" class="kt ku iq bd kv kw nd ky kz la ne lc ld le nf lg lh li ng lk ll lm nh lo lp lq bi translated">结构模式</h1><p id="9fbb" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它们提供了关于类组成和对象结构的有效解决方案和标准。继承的概念用于组合接口，并定义组合对象以获得新功能的方式。</p><h2 id="6a09" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">适配器</h2><p id="b1b7" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它用于链接两个不兼容的接口并使用它们的功能。适配器允许类以其他方式协同工作，而这些方式是不兼容接口所不能做到的。</p><h2 id="ece0" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">桥</h2><p id="5f87" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在这个模式中，main和interface implementer类有一个结构上的改变，但它们之间没有任何影响。这两个类可以独立开发，只用一个接口作为桥梁连接起来。</p><h2 id="6680" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">复合材料</h2><p id="6de1" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它用于将对象作为单个对象进行分组。它允许您将对象组成树结构，然后像处理单个对象一样处理这些结构。</p><h2 id="df88" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">装饰者</h2><p id="e373" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这种模式限制了在向对象添加新功能时对其结构的修改。初始类保持不变，而装饰类提供了额外的功能。</p><h2 id="84d1" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">外表</h2><p id="256c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">为库、框架或任何其他复杂的类集提供简化的接口。</p><h2 id="55a4" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">轻量级</h2><p id="aa25" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Flyweight模式用于通过减少对象创建来减少内存使用和提高性能。该模式寻找已经存在的相似对象进行重用，而不是创建新的相似对象。</p><h2 id="1cb7" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">代理人</h2><p id="4ee6" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它用于创建可以表示其他类或对象的函数的对象，接口用于访问这些功能</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="964a" class="kt ku iq bd kv kw nd ky kz la ne lc ld le nf lg lh li ng lk ll lm nh lo lp lq bi translated">。行为模式</h1><p id="dcc2" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">行为模式处理类对象之间的通信。它们用于检测已经存在的通信模式的存在，并且可以操纵这些模式。这些设计模式特别与对象之间的通信相关。</p><h2 id="195f" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">责任链</h2><p id="6db8" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">责任链设计模式是一种行为模式，它避免了将请求的发送者耦合到接收者，给予多个对象响应请求的能力。</p><h2 id="650b" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">命令</h2><p id="3c0d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">将请求转换为包含该请求所有信息的单独对象。这种转换允许您用不同的请求参数化方法，延迟或排队请求的执行，并支持不可撤消的操作。</p><h2 id="dfc2" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">解释者</h2><p id="4abf" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">用于在创建指示解释上下文的界面时评估语言或表达式。</p><h2 id="03ba" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">迭代程序</h2><p id="bf53" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它的实用程序提供了对集合对象中许多元素的顺序访问，而无需执行任何相关的信息交换。</p><h2 id="4f67" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">调解人</h2><p id="3ada" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这种模式在整个类中提供了简单的通信，支持多个类之间的通信。</p><h2 id="843b" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">纪念品</h2><p id="0942" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Memento模式允许您遍历集合的元素，而不暴露它们的底层表示。</p><h2 id="d685" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">观察者</h2><p id="956c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它允许定义一个订阅机制来通知各种对象关于任何发生在被观察对象上的事件。</p><h2 id="bf82" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">状态</h2><p id="c9ff" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在状态模式中，类的行为随其状态而变化，因此由上下文对象表示。</p><h2 id="1421" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">战略</h2><p id="d74f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">它允许你定义一系列的算法，但是它们在一个单独的类中，并且使它们的对象可以互换。</p><h2 id="6a2b" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">模板方法</h2><p id="2303" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">与具有相似性的组件一起使用，您可以实现一个代码模板来测试这两个组件。只要稍加修改，代码就可以更改。</p><h2 id="0fc5" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">访问者</h2><p id="7a1f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">访问者模式旨在定义一个新的操作，而不修改现有的对象结构。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="6d0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多类型的软件设计模式允许我们更容易地创建我们的代码，并使用已经测试过并保证有效的代码结构。</p><p id="e3ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论什么时候，当你使用别人创建的代码时，使用设计模式将帮助我们发现问题并改进代码。</p><p id="4c31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ni" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nj">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>