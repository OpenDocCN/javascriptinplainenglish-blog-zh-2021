<html>
<head>
<title>Validate Your React App's User Session with the Focus Event Listener</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用焦点事件监听器验证React应用程序的用户会话</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/validate-your-apps-session-on-focus-892f610f7e23?source=collection_archive---------5-----------------------#2021-10-17">https://javascript.plainenglish.io/validate-your-apps-session-on-focus-892f610f7e23?source=collection_archive---------5-----------------------#2021-10-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7ef19b9368c925f4b8dc6281e0680513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQURSxQ8LwEugssoZd21Ew.jpeg"/></div></div></figure><p id="7e5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我最近实现了一个特性，当用户在一段时间后返回页面时，它会检查用户的会话有效性。</p><p id="6ea3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们收到一些客户服务票，跟随着相同的旅程时，就有了对这个特性的需求。</p><ol class=""><li id="fd9c" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">用户登录并正常使用网站</li><li id="bd9d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在使用这个网站后，他们会换标签和做其他事情</li><li id="eb1c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">随着时间的流逝，它们又回到了我们的账上</li><li id="71b3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">他们在站点中进行的触发API请求的第一次交互将用户注销</li></ol><p id="29be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的网站使用JWT与我们的后端认证，他们在1小时后到期。JWT存储在浏览器中，并随每个请求一起发送。成功的请求返回替换现有令牌的刷新令牌。这允许用户与我们的网站持续互动超过一个小时。</p><p id="7692" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，如果他们离开网站超过1小时并返回，浏览器中的令牌将会过期。如果使用过期的令牌发出请求，我们将返回一个错误。当返回未授权的错误时，前端应用程序将自动注销用户。</p><p id="82d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结局是对的，但是体验不怎么样。我需要清理最后一步，用户应该在回到标签页后立即注销，而不是在他们提出新的请求后。</p><p id="8d43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我对这个问题的完整解决方案如下。我将在本文的剩余部分一步一步地阅读每一部分。</p><p id="7094" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的例子使用了<a class="ae lh" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae lh" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux Toolkit </a>和<a class="ae lh" href="https://reach.tech/router/" rel="noopener ugc nofollow" target="_blank"> Reach Router </a></p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="lm ln l"/></div></figure><pre class="li lj lk ll gt lo lp lq lr aw ls bi"><span id="1991" class="lt lu in lp b gy lv lw l lx ly">useEffect(() =&gt; {    <br/>    window.addEventListener("focus", onFocus)    <br/>    return () =&gt; {           <br/>      window.removeEventListener("focus", onFocus)    <br/>    }  <br/>}, [])</span></pre><p id="c014" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当这个组件第一次加载时，我用我的onFocus函数在窗口上注册了一个<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/Events" rel="noopener ugc nofollow" target="_blank">焦点事件列表器</a>。</p><p id="18da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">return语句确保在删除组件时删除焦点事件侦听器。</p><pre class="li lj lk ll gt lo lp lq lr aw ls bi"><span id="b680" class="lt lu in lp b gy lv lw l lx ly">const onFocus = () =&gt; dispatch(session.effects.checkSessionOnFocus(location))</span></pre><p id="9e52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个函数触发一个状态动作，检查存储的令牌的有效性。我在我的状态中异步运行这个检查，因为在令牌过期的情况下，需要正确关闭一些第三方库。</p><p id="a28d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了方便客户，我将路由库提供的<code class="fe lz ma mb lp b">location</code>对象传递给我的效果。这使我可以在他们退出时在应用程序中注册他们的位置。如果他们立即重新登录，我可以将他们重定向到他们原来的位置，而不是让他们返回到我的默认认证路由。</p><p id="ef09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后要考虑我的功能组件的位置。</p><pre class="li lj lk ll gt lo lp lq lr aw ls bi"><span id="9a67" class="lt lu in lp b gy lv lw l lx ly">&lt;App&gt;<br/>  &lt;Provider&gt;<br/>    &lt;Router&gt;<br/>       &lt;AuthenticatedRoutes&gt;<br/>         &lt;WindowFocusHandler /&gt; &lt;-- has access to store and router<br/>       &lt;/AuthenticatedRoutes&gt;<br/>    &lt;/Router&gt;<br/>  &lt;/Provider&gt;<br/>&lt;/App&gt;</span></pre><p id="0fd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想确保在呈现该组件时，我需要的所有资源都可用。对我来说，它必须进入我的商店、我的路由器和我的应用程序的认证部分。</p></div></div>    
</body>
</html>