# 异步 JavaScript 的传奇:生成器

> 原文：<https://javascript.plainenglish.io/the-saga-of-async-javascript-generators-40b517029b68?source=collection_archive---------5----------------------->

## 通过对生成器的 ES6 介绍，理解异步在现代 JavaScript 中是如何工作的。

![](img/842d9cb0bd4e918ae3fdf25a442b8f87.png)

Photo by [Juanjo Jaramillo](https://unsplash.com/@juanjodev02?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

## 介绍

现代 JavaScript 程序中最复杂的事情之一是异步性。我们已经看了一些现有的模式，如[回调](https://enlear.academy/the-saga-of-async-javascript-callbacks-6f56b3490f4d)、 [Thunks](/the-saga-of-async-javascript-thunks-3606f7de0123) 和[承诺](/the-saga-of-async-javascript-promises-8ddef2477c24)。尽管他们设法解决了一些关键问题，但所有这些模式都有一个主要的共同点——它们看起来不像同步代码。我们如何编写和推理异步代码之间一直存在差异。这听起来像是一个不真实的愿望，但时间证明我们可以真正接近它。

# 我们将学到什么

在今天的文章中，我们将谈论**发电机**。这是 ES6 中引入的一种新功能。起初，当我们看它时，它与异步编程的关系并不明显。对你们中的许多人来说，这很可能看起来很奇怪。但是当我们慢慢地浏览解释和例子时，我们最终会明白为什么我们需要在代码中使用它们。你会发现是什么让**发电机**真正脱颖而出，它们为我们解决了什么问题。最后，希望你能够自信地阐述**生成器**，并证明它们在你的代码中的使用

# 运行到完成语义

JavaScript 中的所有普通函数都有一个共同的显著特征。当编写同步代码时，我们知道当我们的函数开始执行时，它将一直运行到最后，并在任何其他函数有机会执行之前完成。在任何给定的第二时间，只有一个功能能够主动执行。这也意味着没有什么可以先发制人地中断我们的功能来运行其他东西。可以完美描述上述所有内容的学术术语是**运行至完成语义**。这有助于我们不用担心两个函数互相干扰或者破坏我们的共享内存。通过 JavaScript 中的这个“规则”,我们能够以一种纯粹的单线程方式推理我们的代码。

# 发电机不是那样的

**发电机**是一种非常不同类型的东西。他们**根本不符合这条从运行到完成**的规则。从表面上看，这应该会给我们的代码带来一些混乱。但是它们似乎提供了另一种解决我们问题的方法，尽管这种方法本身看起来有点奇怪。解释生成器的一种方式是，在当前的 JavaScript 中，它们让我们定义一个**状态机**——从一个状态到另一个状态的一系列流程，能够声明性地列出这些转换。我确信你们中的大多数人创建了相当多的状态机，并且你们可能甚至不知道它是这样命名的。以前，使用 JavaScript 中可用的工具实现状态机需要花费大量的精力和时间。我们经常使用一个**闭包**来维护一个函数的当前和先前状态，完成所有这些转换，但是代码变得越来越复杂，编写代码也很耗时。**生成器**正在添加语法糖，让你以一种更加简单明了的方式解决同样的问题。但是这对异步代码有什么帮助呢？为了达到这个目的，我们首先需要很好地掌握发电机的内部管道。

# 让步暂停

生成器引入了一个名为`yield`的新关键字，它的作用很像一个暂停按钮。因此，当生成器函数运行时，它会遇到一个`yield`关键字，这将展示一个有趣的行为。在哪里遇到这种屈服并不重要。甚至可能是在表达式中间，但是生成器会**暂停**。从那时起，发电机本身将不会发生任何事情，它将保持完全阻塞。它真的变得**冻结**。重要的部分是整体程序本身没有被阻塞，可以继续运行。由成品率引起的阻塞是完全局部化的。它可以无限期地保持这种“暂停”状态，直到有人来告诉它继续运行。您可以将**生成器**视为一个函数，它可以根据需要暂停和恢复多次，而不会丢失任何内部状态。

# 一个例子

我们现在必须看一个**生成器**的例子，看看所有这些概念是如何叠加在一起的。这是我们的第一台发电机:

```
function* helloWorldGenerator() {
  console.log('Hello world');
  yield; // pausing
  console.log('Hello again!')
}
```

在第 1 行，星号告诉 JavaScript 我们正在定义的函数确实是一个生成器。你会注意到在第 3 行我们有我们的 yield 关键字，这是我们的**暂停**按钮。通过使用 yield，生成器本身声明它希望暂停的时间、地点和方式。这也叫做**协同多任务**。外界没有人能进来打断它的执行。这就是多线程语言中经常导致灾难的原因。幸好我们没有那些。

# 呼叫发电机

当调用生成器时，它的行为与其他函数稍有不同。继续上面的例子，让我们来说明如何使用这个生成器:

```
const iterator = helloWorldGenerator();
​
iterator.next() // Hello world
iterator.next() // Hello again!
```

当我们调用生成器函数时，没有代码在生成器内部执行。执行生成器实际上不运行任何代码。真正发生的是我们得到了一个**迭代器**。你可能知道什么是迭代器，但是为了以防万一，让我们回忆一下它们的定义。**迭代器**是一种一次一个结果地遍历数据集的方法。在这种情况下，迭代器的目的不是遍历一个项目集合，而是通过遍历这些 yield 语句从外部控制我们的生成器。可以把它想象成一个方便的 API，帮助我们控制生成器的流程。我们**不能暂停**一个生成器，但是使用迭代器我们可以让它运行直到它想要**暂停自己**。所以在第 1 行没有代码运行，但是在第 2 行，通过调用迭代器对象上的`.next`,我们开始了生成器的执行。然后，它将执行`console.log('Hello world')`语句，在 yield 上暂停，并将控制权返回给客户端代码。每当下一次调用`.next`时，它将恢复生成器，执行最后一条`console.log('Hello again!')`语句，此时，我们的生成器就完成了。

# 产生价值

似乎除了**向我们的代码提供控制**之外，生成器也能够**提供值**。在前面的例子中，我们什么也没有得到。让我们用一个虚拟的例子来说明这一点:

```
function* authorDossierGenerator () {
  const author = {
    name: "Roman",
    surname: "Sarder",
    age: 23,
  }

  yield author.name;
  yield author.surname;
  yield author.age;
}
​
const iterator = authorDossierGenerator();
iterator.next() // { value: "Roman", done: false }
iterator.next() // { value: "Sarder", done: false }
iterator.next() // { value 23, done: false }
iterator.next() // { value: undefined, done: true }
```

在上一个例子中，我们假设 generator 产生了一个`undefined`，但是现在我们返回的是实际值。您会注意到每个`.next`调用都给了我们一个带有值和 done 属性的对象。该值对应于我们从生成器**得到的**，在本例中，它是一组对象属性值。完成标志表示生成器是否完成。这在开始时可能有些棘手。我们的第三个`iterator.next`调用在视觉上可能看起来像是一个已经完成的生成器，但它不是。虽然它是生成器中的最后一行，但实际发生的是生成器暂停在最后一个表达式`yield author.age`上。如果它被暂停，它可以被恢复，这就是为什么只有在第四个`.nex` t 之后，我们才能得到`done: false`。但是最后一个值没有定义怎么办？与简单函数一样，如果生成器末尾没有 return 语句，JavaScript 假定它返回 undefined。在任何时候，你都可以从一个生成器返回，它会立即**完成**本身，并返回一个值(如果有的话)。把 return 想象成一个**【退出】**按钮。

# 传递值

我们设法说明了确实有一种方法可以让生成器将消息传递给客户端的代码。但是我们不仅可以**输出**消息，而且当调用`.next`方法时，我们还可以**传递**中的消息，该消息将直接进入生成器。

```
function* sumIncrementedNumbers () {
  const x = 1 + (yield);
  const y = 1 + (yield);
  yield x + y
}
​
const iterator = sumIncrementedNumbers();
​
iterator.next() // { value: undefined, done: false } 
iterator.next(5) // { value: undefined, done: false }
iterator.next(2) // { value: 9, done: false }
iterator.next() // { value: undefined, done: true }
```

请注意，我们将 yield 关键字放在了两个表达式的中间。从内部角度来看，把这些收益率想象成问号。当生成器处理第一个表达式时，它基本上会问一个问题:这里应该放哪个值？没有答案，它就不能完成一个表达式。在这一点上，它将暂停自己，等待有人提供这个值。我们通过调用`.next`并传递一个值`5`来实现。现在可以进行下一个`yield`了。这些 yield 就像占位符**一样，代表将在某个时间点传递给生成器的值，并取代 yield 来完成一个表达式。**

# 转换为异步

现在，你应该准备好看下面的例子，而不是让你的头完全爆炸。我们将尝试使用**生成器**来处理**异步**代码，并转换我们之前的一个例子。由于吊装的原因，这看起来可能有点可怕，但请将其视为概念验证。我们肯定会重构出看起来更好的东西。

```
function getData (number) {
  setTimeout(() => {
    iterator.next(number);
  }, 1000)
}
​
function* sumIncrementedNumbersAsync() {
  const x = 1 + (yield getData(10));
  const y = 1 + (yield getData(20))
​
  console.log(x + y) // 32
}
​
const iterator = sumIncrementedNumbersAsync();
iterator.next();
```

唷，你还在吗？让我们浏览每一行代码，了解一下发生了什么。首先，我们调用生成器生成一个迭代器，并通过调用`.next`开始执行。到目前为止，没有火箭科学发展。我们的生成器开始计算一个值`x`，并遇到第一个`yield`。现在生成器**暂停**并提出一个问题:这里应该输入什么值？答案在于`getData(10)`函数调用的一个结果。有趣的部分来了:我们自制的 getData 函数，这是一个假的异步函数，**一旦计算完值**就恢复一个生成器。这里它只是一个`setTimeout`，但它可能是任何东西。所以在 1000 毫秒后，我们的假`getData`给我们一个响应，并且**用响应值**恢复一个生成器。下一个`yield getData(20)`以类似的方式处理。这里我们得到的是**同步查看异步代码**。我们的生成器现在能够在计算异步值时自行暂停和恢复，就像计算同步值一样。这是一件大事。

# 神奇的钥匙

因为生成器使用了这个**暂停/恢复**的东西，所以它能够阻塞自己，等待某个后台进程完成，然后用我们等待的值恢复。把你自己从实现细节中抽象出来，因为它大部分时间会隐藏在一个库中。重要的是生成器本身内部的代码。与我们在使用承诺的代码中看到的相比。Promises 的流控制将回调垂直组织成一个链。想想回调和 Thunks——它们嵌套了相同的回调。发电机也有自己的流量控制。但是这个流控制的非常特殊的特性是它看起来完全同步。异步代码和同步代码是平等的。我们**看不出有什么不同**，我们**也不必再考虑以不同的方式组织我们的异步代码**。异步本身现在是一个我们不关心的实现细节。这是可能的，因为**生成器**引入了一种语法方法来隐藏状态机的复杂性，在我们的例子中，是异步状态机。您还将获得同步代码的所有好处，如错误处理。您可以使用 try-catch 块以同样的方式处理异步代码中的错误。那不是很美吗？

# 清除国际奥委会

当您更仔细地观察这个例子时，您可能会注意到这种方法有一个问题。我们的 getData 函数是**控制执行我们的生成器**，这导致我们**控制反转**。这个函数以一种意想不到的方式调用我们的生成器上的`.next`方法，把一切都搞砸了，而当前的代码库对此没有解决方案。你猜怎么着？我们不再害怕这个以前可怕的问题。我们只需要回忆一下哪个模式已经为我们解决了这个问题。我们要把承诺和发电机混在一起！为了让这种结合发生，我们必须**产生提示**，而不是**产生未定义的**。

# 终极二人组

让我们想象一下我们如何能做到这一点。我们已经说过，在我们的发电机里面，我们需要产生一个承诺。但是谁来负责兑现这个承诺呢？嗯，这将由调用`.next`的代码**驱动发电机**来完成。一旦它得到承诺，它应该做些什么，它将不得不**等待承诺来解决** **并恢复发电机**。我们需要一个额外的抽象来为我们做这件事，这很可能是由框架、库或 JavaScript 本身提供的。这不太可能是一件实际的事情——每次你想使用有前途的发电机时都要重新发明轮子。但出于教育目的，我们会自己想出一个来研究。

# 建设我们的承诺发电机转子

我将为您提供这样的**发电机转子**的实现。显然，它缺少一些在生产中使用时绝对需要的功能，例如正确的处理，但它满足了我们的需求，完美地展示了这个概念，同时保持事情相当简单。

```
function runner (generatorFunction) {
  const iterator = generatorFunction();

  function nextStep(resolvedValue) {
    const { value: nextIteratorValue, done } = iterator.next(resolvedValue);
​
    if (done) return nextIteratorValue;
​
    return nextIteratorValue.then(nextStep)
  }
​
  return Promise.resolve().then(nextStep)
}
```

我们的 runner 像往常一样接受一个生成器函数并生成一个迭代器。然后它返回一个解析的承诺，在`.then`方法中，我们传递我们的工人函数`nextStep`。它完成了获取下一个迭代器值并检查生成器是否完成的全部工作。如果没有，我们假设`.next`呼叫的结果是一个承诺。因此，我们通过**等待迭代器值 Promise 解析并将值传递给我们的工作函数**来返回一个新的 Promise。如果需要的话，worker 会将结果值传递给迭代器，并重复其工作，直到生成器完成。没什么复杂的。

# 与我们的发电机转子一起工作

我们将进一步修改我们的`sumIncrementedNumbers`示例，以包含我们新的 runner，并看看我们如何消耗一个承诺的生成器。

```
function getData (data) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(data);
    }, 1000)
 })
}
​
function* sumIncrementedNumbersAsync () {
  const x = 1 + (yield getData(10));
  const y = 1 + (yield getData(20));
  return x + y;
}
​
runner(sumIncrementedNumbersAsync).then(value => {
  console.log(value) // After ~2000ms prints 32
});
```

这里的一切你应该已经很熟悉了。由于我们的跑步者最终会得到一个承诺，从外界的角度来看，我们的包装发电机只不过是另一个承诺。我们已经成功解决了**非局部、非顺序推理**问题，使用我们的生成器使异步代码看起来像同步代码。我们带来了解决**控制反转**问题的承诺，并创建了我们简单的**承诺生成器 runner** 。最后，我们最终得到了一个干净的承诺接口，所有承诺的好处都适用于我们的包装生成器。这就是发电机如此强大的原因。它们完全改变了你编写异步代码的方式。它们最终让你有能力编写一个对我们的大脑来说直观的代码，并且不违背我们的思维方式。

# 异步/等待？

事实上，这种模式证明了自己非常有用，以至于 ECMAScript 在 2017 年通过引入 **async/await** 关键字推出了自己的异步生成器实现。不要让它欺骗了你，因为这个特性是完全基于生成器的，概念是完全一样的。不同的是，现在它是我们语言中的一等公民，有适当的语法支持，我们不再需要使用任何助手库来完成这项工作。但是对于 **async/await** 现在是如何工作的，还有一些需要注意的地方。

# 纯生成器与异步/等待

如何取消一个异步函数并阻止它进一步执行？问题是没有办法这样做。目前 **async/await** 只是返回一个承诺。这很酷，但是取消功能太重要了，不容忽视。当前的实现并没有给你足够的工具来更好的控制执行。我不是评判他们设计决策的人，但我的观点是 API 可以进一步改进，例如，返回一个承诺和一个**取消**功能。最终，我们将使用实现了**拉**接口的生成器。我们控制着如何**使用迭代器**。你可以很容易地想象，如果我们收到一个取消信号，我们将如何停止在我们的跑步者中消耗它。为了证明这一点，我们可以引入一个简单的变化来实现一个非常原始的取消机制。你可以想象有人用回滚策略制造了一个更加复杂和防错的变种。

```
function runner (generatorFunction) {
  let isCancelled = false;
  const iterator = generatorFunction();
​
  function nextStep(resolvedValue) {
    const { value: nextIteratorValue, done } = iterator.next(resolvedValue);
​
    if (done) return nextIteratorValue;
​
    if (isCancelled) {
      return Promise.resolve();
    }

    return nextIteratorValue.then(nextStep)
 }
​
return {
  cancel: () => isCancelled = true,
  promise: Promise.resolve().then(nextStep)
}
```

这说明了我上面的观点。我们用**承诺**和**取消**方法返回一个对象。cancel 方法只是切换一个通过闭包包含的标志变量。非常简洁，并为进一步增强提供了很多可能性。

# 结尾部分

这次要学习和讨论的东西太多了。但是这个话题本身并不简单，不会让你花仅仅 5 分钟的时间去理解它。我不指望你们中的任何人仅仅通过完成这篇文章就成为发电机专家，但是我非常确定我已经给了你们一个良好的开端，这将推动你们自己进一步探索这个主题。看起来我们已经回答了所有关于异步编程的问题。我们已经解决了控制反转，我们现在能够编写看起来同步的异步代码，看起来我们已经结合了所有以前模式的最佳特性。但是，正如软件工程中经常发生的那样，同一个问题通常有不止一个可能的答案。从这一点来看，我们看到的下一个模式将为您提供解决问题的其他方式，其中的每一个都可能或多或少地适合您的情况。由作为工程师的你来做最后的决定。如果您在本系列的这一点上退出完全没问题，因为对于我们大多数人来说，这已经足够了解 JavaScript 中的异步编程了。但是如果你决定继续关注我，我们将会看看一些高级模式，比如 **CSP** 和**observable**。下次我们一定会谈到其中的一个。感谢您的长期阅读！

# 信用

非常感谢**凯尔·辛普森**和他的材料。他的[异步 JavaScript](https://frontendmasters.com/courses/rethinking-async-js/) 课程给了我特别的启发，它促使我比平时更努力地深入这些主题。

*更多内容请看*[***plain English . io***](http://plainenglish.io/)