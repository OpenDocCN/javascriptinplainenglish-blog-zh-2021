<html>
<head>
<title>Callback vs Promises vs Async/Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的回调vs承诺vs异步/等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-javascript-callback-promises-and-async-await-7970b5292985?source=collection_archive---------5-----------------------#2021-09-21">https://javascript.plainenglish.io/how-to-use-javascript-callback-promises-and-async-await-7970b5292985?source=collection_archive---------5-----------------------#2021-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="44ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何编写带有回调、承诺和异步/等待的异步JavaScript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/37033bff6e318ebfc07c75ad88996664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02xhEjsD_VcrN-4UYKWd8Q.jpeg"/></div></div></figure><p id="8ff2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/understanding-asynchronous-javascript-f43c4cd6a1d9">的上一篇文章</a>中，我们了解了JavaScript如何异步实现<strong class="kt ir"/>。web浏览器提供Web APIs环境来运行回调函数并承诺；因此，它不会阻塞用户界面。</p><p id="adaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用JavaScript编写异步代码有三种方式。</p><p id="b071" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">a.回收</p><p id="698d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">b.承诺</p><p id="bcb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">c.异步/等待</p><p id="ac71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看下面的场景。假设我们有一个登录功能来验证用户访问我们的网页。这个函数将调用一个嵌套函数来检查用户是否存在于数据库中。如果是，它将继续比较密码。如果密码有效，它将向前端返回成功。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="4c36" class="lt lu iq lp b gy lv lw l lx ly">function findUser(username, password) {<br/>    console.log(`Finding user.....`)<br/>    comparePassword(password, "password")<br/>}</span><span id="7c47" class="lt lu iq lp b gy lz lw l lx ly">function comparePassword(username, password, hashPassword) {<br/>    console.log(`Comparing password.....`)<br/>    generatingToken(username, password)<br/>}</span><span id="b912" class="lt lu iq lp b gy lz lw l lx ly">function generatingToken(username, password) {<br/>    console.log(`Generating signin token.....`)<br/>}</span><span id="cc9a" class="lt lu iq lp b gy lz lw l lx ly">function login(username, password) {<br/>    console.log(`Login user.....`)<br/>    findUser(username, password)<br/>    console.log(`Logged In.....`)<br/>}</span><span id="8eca" class="lt lu iq lp b gy lz lw l lx ly">login("user", "password")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ma"><img src="../Images/7ecac7bb7a22d0bf814e5f2e6d637545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKr05ooUpYaViDzD6nMfIg.png"/></div></div></figure><p id="c55d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前看起来不错。但是，findUser方法可能不会立即响应，因为获取API需要一些时间来处理。所以，在本教程中，我们使用setTimeout来模拟处理时间和回调。</p><h1 id="d23e" class="mb lu iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">复试</h1><p id="8af0" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">当一个函数作为参数传递给另一个函数时，它被称为回调函数。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3dd0" class="lt lu iq lp b gy lv lw l lx ly">function findUser(username, password, <strong class="lp ir">callback</strong>) {<br/>    setTimeout(() =&gt; {<br/>        console.log(`Finding user.....`)<br/>        <strong class="lp ir">callback</strong>(password, <strong class="lp ir">generatingToken</strong>)<br/>    }, 1000);<br/>}</span><span id="3488" class="lt lu iq lp b gy lz lw l lx ly">function comparePassword(password, <strong class="lp ir">callback</strong>) {<br/>    setTimeout(() =&gt; {<br/>        console.log(`Comparing password.....`)<br/>        <strong class="lp ir">callback</strong>(password)<br/>    }, 1000);<br/>}</span><span id="6cd1" class="lt lu iq lp b gy lz lw l lx ly">function generatingToken(password) {<br/>    setTimeout(() =&gt; {<br/>        console.log(`Generating signin token.....`)<br/>        console.log(`Logged In.....`)<br/>    }, 1000);<br/>}</span><span id="2473" class="lt lu iq lp b gy lz lw l lx ly">function login(username, password, <strong class="lp ir">callback</strong>) {<br/>    console.log(`Login user.....`)<br/>    <strong class="lp ir">callback</strong>(username, password, <strong class="lp ir">comparePassword</strong>)<br/>}</span><span id="e84e" class="lt lu iq lp b gy lz lw l lx ly">login("user", "password", <strong class="lp ir">findUser</strong>)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/dcf9f89f7460d41f0aa79c7cd4be5f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uc_eNLGW7KLq5W3n4fltIA.png"/></div></div></figure><p id="1eba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里看到了一个问题。当嵌套的回调函数越来越大时，就很难跟踪和阅读代码。我们把这个<strong class="kt ir"> <em class="my">叫做回调地狱。</em>T11】看起来是这样的。</strong></p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="27dd" class="lt lu iq lp b gy lv lw l lx ly">function login(username, password) {<br/>    console.log(`Login user.....`)<br/>    <strong class="lp ir">setTimeout</strong>(() =&gt; {<br/>        console.log(`Finding user.....`)<br/>        <strong class="lp ir">setTimeout</strong>(() =&gt; {<br/>            console.log(`Comparing password.....`)<br/>            <strong class="lp ir">setTimeout</strong>(() =&gt; {<br/>                console.log(`Generating signin token.....`)<br/>                <strong class="lp ir">setTimeout</strong>(() =&gt; {<br/>                    console.log(`Another callback.....`)<br/>                    <strong class="lp ir">setTimeout</strong>(() =&gt; {<br/>                        console.log(`Again Another callback.....`)<br/><br/>                    }, 1000);<br/>                }, 1000);<br/>            }, 1000);<br/>        }, 1000);<br/>    }, 1000);<br/>}</span></pre><h1 id="2ac3" class="mb lu iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">承诺</h1><p id="6792" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">承诺是为了简化操作。承诺有三种主要状态。</p><p id="2731" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">a.<strong class="kt ir">待定</strong> —这是初始状态。这里还没有发生任何事情。</p><p id="caaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">b.<strong class="kt ir">已解决</strong> —这是操作已成功完成的状态。</p><p id="6fea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">c.<strong class="kt ir">拒绝</strong> —这是操作失败的状态。</p><p id="0b96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们先来看看Promise语法。首先，我们创建一个Promise对象，并传递一个带有resolve和reject的回调函数。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="f9b0" class="lt lu iq lp b gy lv lw l lx ly">const findUser = new <strong class="lp ir">Promise</strong>(function<strong class="lp ir">(resolve, reject)</strong> {<br/>    const userExist = true;<br/>    if (userExist) {<br/>        resolve("User is valid");<br/>    } else {<br/>        <!-- -->reject<!-- -->("User doesn't exist");<br/>    }<br/>});</span><span id="f141" class="lt lu iq lp b gy lz lw l lx ly">console.log(findUser);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/8fcf9174f91c75100c156a1aa4dcb53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7VJaif2v4AsLsjQY11zRg.png"/></div></div></figure><p id="8991" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从控制台上，我们看到<strong class="kt ir"> <em class="my">承诺状态</em> </strong>返回为<strong class="kt ir"> <em class="my">“履行完毕”</em> </strong>另外，注意它返回一个<strong class="kt ir"> Promise对象</strong>而不是一个字符串中的结果。</p><p id="7e01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们深入探讨一下<strong class="kt ir"> <em class="my">承诺链</em> </strong>。所以我们不会传递回调函数，而是用<code class="fe na nb nc lp b">.then</code>来代替</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="9886" class="lt lu iq lp b gy lv lw l lx ly">promise<br/>    .then(function(done) {</span><span id="139e" class="lt lu iq lp b gy lz lw l lx ly">    })<br/>    .then(function(done) {</span><span id="587c" class="lt lu iq lp b gy lz lw l lx ly">    })</span></pre><h2 id="f0e5" class="lt lu iq bd mc nd ne dn mg nf ng dp mk la nh ni mm le nj nk mo li nl nm mq nn bi translated">例子</h2><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="bda9" class="lt lu iq lp b gy lv lw l lx ly">const findUser = function(username, password) {<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(() =&gt; {<br/>            console.log(`Finding user.....`)<br/>            const userExist = true;<br/>            if (userExist) {<br/>                resolve("User is valid");<br/>            } else {<br/>                reject("User doesn't exist");<br/>            }<br/>        }, 1000);<br/>    });<br/>}<br/>const comparePassword = function(password) {<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(() =&gt; {<br/>            console.log(`Comparing password.....`)<br/>            const isMatch = true;<br/>            if (isMatch) {<br/>                resolve("Password correct");<br/>            } else {<br/>                reject("Incorrect Password");<br/>            }<br/>        }, 1000);<br/>    });<br/>}<br/>const generatingToken = function(password) {<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(() =&gt; {<br/>            console.log(`Generating signin token.....`)<br/>            console.log(`Logged In.....`)<br/>            resolve();<br/>        }, 1000);<br/>    });<br/>}<br/>function login(username, password) {<br/>    console.log(`Login user.....`)<br/>    findUser(username, password)<br/>        .then(function(done)  {<br/>            console.log(done)<br/>            return comparePassword()     <br/>        })<br/>        .then(function(done)  {<br/>            console.log(done)<br/>            return generatingToken()  <br/>        })<br/>        .catch(function(error)  {<br/>            console.log(error)    <br/>        })<br/>}<br/>login("user", "password")</span></pre><p id="4aab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们试着把<code class="fe na nb nc lp b">userExist</code>改成<code class="fe na nb nc lp b">false</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/0001aedaf065c360beb6eacbc6b071d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYJpStm6o5mc855XKXVJ_A.png"/></div></div></figure><p id="690d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于在<em class="my"> findUser promise </em>中调用了reject，链在第一个<code class="fe na nb nc lp b">.then</code>处停止处理。</p><p id="e00c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们看到，承诺链允许我们以更合适的方式轻松地处理错误。</p><h1 id="e981" class="mb lu iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">异步/等待</h1><p id="5b17" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">同样，使用async/await有一种更好的方法。<strong class="kt ir"> Async/Await </strong>允许你同步编写异步代码。</p><p id="aab4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们先来看看语法。需要两个关键字<strong class="kt ir"> <em class="my"> async </em> </strong>来告诉引擎这个方法是一个异步代码。<strong class="kt ir"> <em class="my"> await </em> </strong>告诉引擎在进入下一个代码之前等待响应。<strong class="kt ir"> await </strong>必须在<strong class="kt ir"> async </strong>函数中使用，所以不能在全局中使用await。</p><p id="d951" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以将<strong class="kt ir">承诺链</strong>重写为下面的代码片段。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="65eb" class="lt lu iq lp b gy lv lw l lx ly"><strong class="lp ir">async</strong> function login(username, password) {<br/>    console.log(`Login user.....`)<br/>    const user = <strong class="lp ir">await</strong> findUser(username, password)<br/>    console.log(user)<br/>    const isMatch = <strong class="lp ir">await</strong> comparePassword(password, "password")<br/>    console.log(isMatch)<br/>    const token = <strong class="lp ir">await</strong> generatingToken(password)<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/0d01152ca3c1501c1035d11cbabdab3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVFlcw3sKMflpOHLvGm2xg.png"/></div></div></figure><p id="624f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了处理错误，我们需要手动创建一个try-catch块。我们试着把<code class="fe na nb nc lp b">userExist</code>改成<code class="fe na nb nc lp b">false</code>。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="dadd" class="lt lu iq lp b gy lv lw l lx ly"><strong class="lp ir">async</strong> function login(username, password) {<br/>    try {<br/>        console.log(`Login user.....`)<br/>        const user = <strong class="lp ir">await</strong> findUser(username, password)<br/>        console.log(user)<br/>        const isMatch = <strong class="lp ir">await</strong> comparePassword(password, "password")<br/>        console.log(isMatch)<br/>        const token = <strong class="lp ir">await</strong> generatingToken(password)<br/>    } catch (err) {<br/>        console.log(err)<br/>    }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/f5435601fd0d1e7147b4c4b237ca791e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o729-ue59uyIzyxGhG8-1g.png"/></div></div></figure><p id="3628" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面的例子中，我们看到代码很容易理解为同步的。代码似乎是按顺序一个接一个运行的。</p><p id="4215" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从我们之前学习的例子中，一个API调用依赖于另一个API调用。然而，在某些场景中，我们可能希望并行调用多个异步API，并且仅当所有异步API调用都有结果返回时才返回。</p><h1 id="ce2a" class="mb lu iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">承诺。所有</h1><p id="b9cd" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">所有的承诺都有助于达到预期的结果。在下面的代码中，封装在<strong class="kt ir"> Promise.all </strong>中的异步函数可以运行，而无需等待彼此返回结果。但是，console.log("已登录…. ")将仅在所有异步已经完成时被触发。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="aaa5" class="lt lu iq lp b gy lv lw l lx ly"><strong class="lp ir">async</strong> function login(username, password) {<br/>    console.log(`Login user.....`)<br/>    const [user, isMatch, token] = await <strong class="lp ir">Promise.all</strong>([<br/>        findUser(),<br/>        comparePassword(),<br/>        generatingToken()<br/>    ]);</span><span id="dc4e" class="lt lu iq lp b gy lz lw l lx ly">    console.log(`End Logged In.....`)<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/2191615eba47f8397db15d2005242e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wsbSAhTXjX-xRyX47hAm_w.png"/></div></div></figure><p id="fcef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">挑战自己，将<em class="my">更改密码</em>功能的计时器更新为2秒，然后观察日志。</p><p id="8b0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你会注意到<em class="my">“生成登录令牌…..</em>“是之前打印的”<em class="my">对比密码…..</em>"这是因为<strong class="kt ir">承诺。所有</strong>将并行启动异步函数，而不等待函数完成。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="c2db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们学习了如何使用回调、承诺和async/await编写异步函数。此外，我们学会了使用<strong class="kt ir"> Promise.all </strong>来运行多个并行异步调用。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="4c98" class="mb lu iq bd mc md nz mf mg mh oa mj mk jw ob jx mm jz oc ka mo kc od kd mq mr bi translated">了解更多信息</h1><ul class=""><li id="e49b" class="oe of iq kt b ku ms kx mt la og le oh li oi lm oj ok ol om bi translated"><a class="ae ln" href="https://enlear.academy/what-is-asynchronous-javascript-310426783ef1" rel="noopener ugc nofollow" target="_blank">什么是异步JavaScript </a></li><li id="d4a7" class="oe of iq kt b ku on kx oo la op le oq li or lm oj ok ol om bi translated"><a class="ae ln" href="https://enlear.academy/the-saga-of-async-javascript-callbacks-6f56b3490f4d" rel="noopener ugc nofollow" target="_blank">异步JavaScript的传奇:回调</a></li><li id="16e5" class="oe of iq kt b ku on kx oo la op le oq li or lm oj ok ol om bi translated"><a class="ae ln" href="https://enlear.academy/asynchronous-request-handling-with-aws-sqs-c4df33ae9717" rel="noopener ugc nofollow" target="_blank">AWS SQS如何工作</a></li></ul><p id="c13c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="my">更多内容请看</em><a class="ae ln" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae ln" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="my">免费周报</em> </strong> </a> <em class="my">。关注我们关于</em><a class="ae ln" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="my">Twitter</em></strong></a><a class="ae ln" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="my">LinkedIn</em></strong></a><em class="my"/><a class="ae ln" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="my">YouTube</em></strong></a><em class="my"/><a class="ae ln" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="my">不和</em> </strong> </a> <em class="my">。对增长黑客感兴趣？检查</em> <a class="ae ln" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="my">电路</em> </strong> </a> <em class="my">。</em></p></div></div>    
</body>
</html>