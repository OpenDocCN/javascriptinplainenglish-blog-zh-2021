<html>
<head>
<title>Playing with Promises, Then and Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中玩弄承诺，然后等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/playing-with-promises-then-and-await-in-javascript-75f4b5372f4d?source=collection_archive---------15-----------------------#2021-07-10">https://javascript.plainenglish.io/playing-with-promises-then-and-await-in-javascript-75f4b5372f4d?source=collection_archive---------15-----------------------#2021-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="07e0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">承诺能为我做什么？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/155c8e6a67a8de41f6a179a2c1c9fc31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X4qIP-A-fNP56Xjn"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6502" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我们不喜欢等待！</h1><p id="4862" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">人类不喜欢等待。如果有可能，我们在等待的时候也在做其他的事情。</p><p id="ea55" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">JavaScript中的<strong class="ln io">承诺</strong>也可以用同样的方式来思考。承诺是一项工作加上一个结果，当工作完成时就会被激发。</p><p id="a774" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">承诺的核心是定义工作。</strong>当这个<strong class="ln io">工作完成后，</strong>承诺返回一个<strong class="ln io">“已解决”。同时，你可以做或让别人做事情。…嘣！… </strong>这是<strong class="ln io"> Async(异步)！</strong></p><h1 id="bd1d" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">但是为什么要承诺呢？</h1><p id="59f7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在我们更仔细地研究承诺之前，让我们简单地讨论一下<strong class="ln io">原因:</strong>等待任务完成是从<strong class="ln io">很早就在</strong>的JavaScript中引入的。为此，使用了机制<strong class="ln io">“回调”</strong>。</p><p id="8720" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">回调是一个简单的普通函数，它将被完成的作业调用<strong class="ln io">。每个JavaScript初学者都知道这一点:</strong></p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="6343" class="mr ku in mn b gy ms mt l mu mv">setTimeout(callback, 1000);</span></pre><p id="469e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">“回调”是一个在1000毫秒后调用的函数。是的… <strong class="ln io">它是异步的。好吧，没有工作。让我们把1000毫秒当作一项工作来做。</strong></p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="121a" class="mr ku in mn b gy ms mt l mu mv">function callback() {<br/>   console.log("Auf Wiedersehen!");<br/>}<br/>setTimeout(callback, 1000);<br/>console.log("Guten Tag!");</span><span id="d467" class="mr ku in mn b gy mw mt l mu mv">// Guten Tag!<br/>////.. is waiting 1000 milliseconds<br/>// Auf Wiedersehen!</span></pre><p id="5a59" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">简单！…和异步！</strong></p><h1 id="ca14" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">问题是</h1><p id="a3d4" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">但是如果<strong class="ln io">是一个有特定时间的任务</strong>并且<strong class="ln io">之后有另一个有特定时间的任务</strong>并且<strong class="ln io">之后有另一个有特定时间的任务</strong> …并且…并且…然后我们需要注意<strong class="ln io">全部完成</strong>:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="7739" class="mr ku in mn b gy ms mt l mu mv">setTimeout(() =&gt; {<br/>  setTimeout(() =&gt; {<br/>    setTimeout(() =&gt; {<br/>      setTimeout(() =&gt; {<br/>        setTimeout(() =&gt; {<br/>          setTimeout(() =&gt; {<br/>            console.log("Fertig!");<br/>          }, 1000);<br/>        }, 1000);<br/>      }, 1000);<br/>    }, 1000);<br/>  }, 1000);<br/>}, 1000);<br/>console.log("Und los:");<br/>// Und los:<br/>//// waiting for 6 seconds<br/>// Fertig!</span></pre><p id="8de8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">《回调地狱》还是《末日金字塔》！</strong>形象更大的工作岗位！机器可以读取。对人类来说不是最好的。为了避免这个死亡金字塔，我们可以使用承诺。</p><h1 id="d09f" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">让我们去寻找承诺</h1><p id="1488" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">让我们和<strong class="ln io"> setTimeout </strong>呆一会儿。好了，这里没有<strong class="ln io">的本机代码</strong>对<strong class="ln io">的setTimeout </strong>作为承诺。但是我们可以对它做一点修改:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="89ba" class="mr ku in mn b gy ms mt l mu mv">const job = resolve =&gt; setTimeout(resolve, 1000);<br/>const myPromise = () =&gt; new Promise(job);</span></pre><p id="49b1" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">有一个<strong class="ln io">工作</strong>和一个<strong class="ln io">承诺</strong>。工作是承诺的核心。该作业是一个带有参数“<strong class="ln io"> resolve </strong>”的函数。工作是<strong class="ln io">在工作完成后</strong>调用参数“解决”<strong class="ln io">。该参数是回调。</strong></p><p id="c509" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">好的，这里真的有一些函数并且我也使用了现代的<a class="ae ks" href="https://javascript.info/arrow-functions-basics" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">箭头函数符号</strong> </a> …我以旧的JavaScript风格形成它。那可能会有一点帮助。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="82b4" class="mr ku in mn b gy ms mt l mu mv">function myPromise(){<br/>    function job(resolve){<br/>        setTimeout(resolve, 1000);<br/>    }<br/>    return new Promise(job)<br/>}</span></pre><h1 id="ad47" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">让我们玩诺言吧</h1><p id="3ebb" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">现在我们可以<strong class="ln io">稍微玩一下</strong>。示例:JavaScript在调用myPromise时<strong class="ln io">不会等待。</strong></p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="a94a" class="mr ku in mn b gy ms mt l mu mv">console.log("Und los:");<br/>myPromise();<br/>myPromise();<br/>myPromise();<br/>myPromise();<br/>myPromise();<br/>myPromise();<br/>console.log("Fertig!");<br/>// Und los:<br/>//// not waiting for<br/>// Fertig!</span></pre><p id="207e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">这是真正的异步。</strong>承诺产生了。并且代码<strong class="ln io">立即准备好</strong>。承诺范围内的工作得到了很好的履行。</p><p id="b24d" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">如果JavaScript 也不等待，我们为什么还需要<strong class="ln io">那些承诺？我们是否也可以使用<strong class="ln io">回调</strong>？默认情况下，JavaScript不会等待<strong class="ln io"/>。这很好，因为承诺起了作用。如果我们希望JavaScript等待每一个，那么我们<strong class="ln io">需要明确地告诉JavaScript:</strong></strong></p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="44b6" class="mr ku in mn b gy ms mt l mu mv">console.log("Und los");<br/>await myPromise();<br/>await myPromise();<br/>await myPromise();<br/>await myPromise();<br/>await myPromise();<br/>await myPromise();<br/>console.log("Fertig")<br/>// Und los:<br/>//// is waiting for 6 seconds<br/>// Fertig!</span></pre><p id="c41e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">单词<strong class="ln io">“await”</strong>让<strong class="ln io">停止JavaScript代码，等待解析</strong>承诺。这也更容易阅读。</p><h1 id="2dee" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">Await不是异步的？！</h1><p id="ec27" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">最后，确实如此。<strong class="ln io">但是</strong>承诺能做的<strong class="ln io">更多。</strong>当作业在承诺中执行时，承诺的值为<strong class="ln io">“待定”</strong>。一个<strong class="ln io">“Await”</strong>等待，直到<strong class="ln io">未决被解决</strong>。“await”的反义词是每个承诺都有<strong class="ln io">属性“then”</strong>。然而，只有当我们将上述过程变得更加复杂和更加异步时，这才变得令人兴奋。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="8bd0" class="mr ku in mn b gy ms mt l mu mv">const randomTimer = () =&gt; {<br/>  const ms = Math.round(Math.random() * 5000);<br/>  const job = resolve =&gt; setTimeout(() =&gt; resolve(ms), ms);<br/>  return new Promise(job);<br/>};</span></pre><p id="9ecc" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">函数<strong class="ln io"> "randomTimer" </strong>返回一个<strong class="ln io">作业</strong>内的<strong class="ln io">承诺</strong>，该<strong class="ln io">在一个<strong class="ln io">随机时间内以毫秒</strong>(毫秒)为单位解决</strong>。对于初学者:在第一行，你有一个<strong class="ln io">随机数“ms”</strong>的定义。在第二行，将“<strong class="ln io">作业”</strong>包装成一个函数，其参数是“<strong class="ln io"> resolve </strong>”(这是另一个函数..一个<strong class="ln io">回调</strong>)。setTimeout现在有一个函数作为第一个参数，它调用回调函数<strong class="ln io">“resolve”</strong>，并以“<strong class="ln io">ms”</strong>作为参数。好吧，这对于初学者来说并不容易。但是检查一下，然后继续。</p><h1 id="3c03" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">这个“然后”真的是异步的！</h1><p id="36a3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">接下来，我们需要一个消费者。<strong class="ln io">假设这是一个女孩，正在等待随机定时器:</strong></p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="9df5" class="mr ku in mn b gy ms mt l mu mv">const girl = promise =&gt; {<br/>  promise.then(result =&gt;<br/>    console.log(`I'm the girl and I waited for ${result / 1000} seconds`)<br/>  );<br/>};</span></pre><p id="f193" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">…还有一个男孩也是:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="fa83" class="mr ku in mn b gy ms mt l mu mv">const boy = promise =&gt; {<br/>  promise.then(result =&gt;<br/>    console.log(`I'm the boy and I waited for ${result / 1000} seconds`)<br/>  );<br/>};</span></pre><p id="d059" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">现在我们可以做这样的事情:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="1de8" class="mr ku in mn b gy ms mt l mu mv">girl(randomTimer());<br/>// I'm the girl and I waited for 3.065 seconds</span></pre><p id="1f0e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">每一个承诺</strong>都有一个<strong class="ln io">然后</strong>。如果承诺的<strong class="ln io">未决</strong>已经<strong class="ln io">结束</strong>，那么“将<strong class="ln io">被解雇</strong>。“then”的自变量是一个带有自变量“<strong class="ln io">结果</strong>的函数。这是来自“<strong class="ln io">random timer</strong>”—“<strong class="ln io">ms</strong>”的参数值。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="10e8" class="mr ku in mn b gy ms mt l mu mv">const girlTime = randomTimer();<br/>girl(girlTime);<br/>const boyTime = randomTimer();<br/>boy(boyTime);<br/>const timeForBoth = randomTimer();<br/>girl(timeForBoth);<br/>boy(timeForBoth);</span><span id="c02e" class="mr ku in mn b gy mw mt l mu mv">// I'm the girl and I waited for 0.74 seconds<br/>// I'm the boy and I waited for 0.74 seconds<br/>// I'm the boy and I waited for 0.934 seconds<br/>// I'm the girl and I waited for 3.42 seconds</span></pre><p id="e84e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">好的，<strong class="ln io">“time for both”。这是什么？</strong>另一个<strong class="ln io">优点</strong>的承诺。我们可以多次传递生成的承诺。一旦<strong class="ln io">待处理状态被解决</strong>，即工作完成，解决将在各处被触发<strong class="ln io">。这意味着<strong class="ln io">“then”</strong>将在<strong class="ln io">相同的应许所在的任何地方被调用。</strong> <br/>理论上，我们可以这样做:</strong></p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="39db" class="mr ku in mn b gy ms mt l mu mv">const girlTime = randomTimer();<br/>girl(girlTime);<br/>girlTime.then(() =&gt; console.log("girl time is over"));<br/>const boyTime = randomTimer();<br/>boyTime.then(() =&gt; console.log("boy time is over"));<br/>boy(boyTime);<br/>const timeForBoth = randomTimer();<br/>girl(timeForBoth);<br/>timeForBoth.then(() =&gt; console.log("both time is over"));<br/>boy(timeForBoth);</span><span id="91e5" class="mr ku in mn b gy mw mt l mu mv">//I'm the girl and I waited for 0.864 seconds<br/>//girl time is over<br/>//I'm the girl and I waited for 1.763 seconds<br/>//both time is over<br/>//I'm the boy and I waited for 1.763 seconds<br/>//boy time is over<br/>//I'm the boy and I waited for 4.038 seconds</span></pre><h1 id="ca1b" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">代码</h1><p id="8025" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们来看看<strong class="ln io">全代码:</strong></p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="c558" class="mr ku in mn b gy ms mt l mu mv">const init = async () =&gt; {<br/>  console.log("Start");<br/>  const girlTime = randomTimer();<br/>  girl(girlTime);<br/>  girlTime.then(() =&gt; console.log("girl time is over"));<br/>  const boyTime = randomTimer();<br/>  boyTime.then(() =&gt; console.log("boy time is over"));<br/>  boy(boyTime);<br/>  const timeForBoth = randomTimer();<br/>  girl(timeForBoth);<br/>  timeForBoth.then(() =&gt; console.log("both time is over"));<br/>  boy(timeForBoth);<br/>  await Promise.all([boyTime, girlTime, timeForBoth]);<br/>  console.log("All Promises done");<br/>};</span><span id="ff51" class="mr ku in mn b gy mw mt l mu mv">const randomTimer = () =&gt; {<br/>  const ms = Math.round(Math.random() * 5000);<br/>  const job = resolve =&gt; setTimeout(() =&gt; resolve(ms), ms);<br/>  return new Promise(job);<br/>};</span><span id="32ca" class="mr ku in mn b gy mw mt l mu mv">const girl = promise =&gt; {<br/>  promise.then(result =&gt;<br/>    console.log(`I'm the girl and I waited for ${result / 1000} seconds`)<br/>  );<br/>};</span><span id="de24" class="mr ku in mn b gy mw mt l mu mv">const boy = promise =&gt; {<br/>  promise.then(result =&gt;<br/>    console.log(`I'm the boy and I waited for ${result / 1000} seconds`)<br/>  );<br/>};</span><span id="f362" class="mr ku in mn b gy mw mt l mu mv">await init();</span></pre><h1 id="06e0" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">什么是承诺？</h1><p id="d297" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">promise不仅仅是一个你可以<strong class="ln io">生成Promise对象(用new Promise()) </strong>的类。它还具有静态属性。这里，就是<strong class="ln io"> Promise.all(Array) </strong>。这很简单:Promise.all <strong class="ln io">接受一组承诺</strong>，它本身就是一个承诺。正如我们在上面学到的，我们也可以用“await”等待<strong class="ln io">一个承诺。显式地，用Promise.all(Array)我们等待所有其他的承诺。</strong></p><h1 id="8e62" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">最重要的结论</h1><p id="d598" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><strong class="ln io"> JavaScript是异步的，句号。</strong>如果你想<strong class="ln io">保持JavaScript同步，</strong>你<strong class="ln io">不会用这种计算机语言走远</strong>。<br/> <strong class="ln io">回调是一种经过验证的处理异步的方式</strong>，但是它们已经<strong class="ln io">过时了。</strong></p><p id="1935" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">回调和承诺的最大区别在于回调必须总是在实际异步作业之前<strong class="ln io">创建。之后，您<strong class="ln io">不能再次更改回调</strong>。</strong></p><p id="fc98" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">承诺要灵活得多。一旦创建了承诺，它就可以<strong class="ln io">传递到任何其他位置。</strong>一旦“未决”完成，异步作业中的“解决”被触发，<strong class="ln io">每个有承诺的人都会被通知。嘣！砰！</strong></p><p id="18e2" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">所以要学会承诺！</strong></p><p id="a930" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">…但是，如果工作无法完成或工作陷入困境，会发生什么呢？当我有更多的关注者时，我会在其他地方了解更多。:)</p><p id="fad8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="mx">多内容于</em> <a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io"> <em class="mx">浅显易懂</em> </strong> </a></p></div></div>    
</body>
</html>