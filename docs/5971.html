<html>
<head>
<title>How to Handle Stream Data Requests in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中处理流数据请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handling-stream-data-requests-in-nodejs-91746427c103?source=collection_archive---------0-----------------------#2021-12-22">https://javascript.plainenglish.io/handling-stream-data-requests-in-nodejs-91746427c103?source=collection_archive---------0-----------------------#2021-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f0c4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">完整的代码实现和用例。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1b9239a3cfba9450679be45f5e1ff349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Ow91aReqsvgi93T"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aa6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express Node.js模块</a>使Node.js web开发人员能够以最少的麻烦设置web应用和REST APIs。然而，在浏览网页时，我注意到不仅有许多关于数据流/缓冲区(例如音频、图像&amp;视频二进制数据)的查询，而且许多提议的解决方案也倾向于包括额外的实用程序，例如<a class="ae kv" href="https://www.npmjs.com/package/got" rel="noopener ugc nofollow" target="_blank"> got </a>和<a class="ae kv" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>。</p><blockquote class="ls"><p id="d466" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">虽然这些额外的节点模块可以在大规模项目中实现更易维护的代码，但是在开发人员试图创建小规模应用程序的场景中，具有最少插件的轻量级解决方案可能更合适、更理想。</p></blockquote><p id="b5ac" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">因此，我决定发布这篇文章，希望它能对其他NodeJS开发人员有用，他们正在寻找一个在实现中只需要最少安装的解决方案。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="48b0" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">先决条件—使用<a class="ae kv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express模块</a>设置一个最小的Node.js服务器</h2><p id="9f2a" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated"><strong class="ky ir">第一步。</strong>初始化工作区文件夹(根文件夹)。在该文件夹中，打开一个终端并继续运行以下命令:</p><pre class="kg kh ki kj gt nm nn no bn np nq bi"><span id="532e" class="nr mp iq nn b be ns nt l nu nv">npm init -y<br/>npm i express --save</span></pre><p id="6c3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面创建了一个<strong class="ky ir"> package.json </strong>文件，并将<a class="ae kv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express NodeJS模块</a>分别安装到应用中。</p><p id="3d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二步。创建一个名为<strong class="ky ir"> server.js </strong>的文件，并添加以下几行:</strong></p><pre class="kg kh ki kj gt nm nn no bn np nq bi"><span id="73b2" class="nr mp iq nn b be ns nt l nu nv">const express = require('express');<br/>const app = express();<br/>const port = 9000;<br/>app.get('/', (req, res) =&gt; {<br/> res.send('Hello World!');<br/>});<br/>app.listen(port, () =&gt; {<br/> console.log(`App is listening at http://localhost:${port}`);<br/>});</span></pre><p id="72a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第三步。</strong>在同一终端中，运行<code class="fe nw nx ny nn b">node server.js</code>并继续导航至<a class="ae kv" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9000/ </a></p><p id="aef3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">输出:</strong>单词“Hello World！”应呈现如下所示</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/fba8ff45e9e2cc5acb8e69636f5a2d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOHnAgCnoR_zN-kTURKcXg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screenshot by Author</figcaption></figure><blockquote class="oa ob oc"><p id="613d" class="kw kx od ky b kz la jr lb lc ld ju le oe lg lh li of lk ll lm og lo lp lq lr ij bi translated">至此，我们已经使用Node.js的 <a class="ae kv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Express模块</em> </a> <em class="iq">建立了一个运行在端口</em><strong class="ky ir"><em class="iq">9000</em></strong><em class="iq">上的极简web服务器。</em></p></blockquote><h1 id="b36a" class="oh mp iq bd mq oi oj ok mt ol om on mw jw oo jx mz jz op ka nc kc oq kd nf or bi translated">用例:返回一个图像文件流响应</h1><h2 id="98ca" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated"><strong class="ak">注意:</strong>完整源代码可从我的<a class="ae kv" href="https://github.com/incubated-geek-cc/node-api-stream-demo" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>获得</h2><p id="8bb6" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated"><strong class="ky ir">参考消息:</strong>在<strong class="ky ir"> server.js </strong>文件中，向客户端返回响应并呈现页面内容的代码块，即“Hello World！”如下所示:</p><pre class="kg kh ki kj gt nm nn no bn np nq bi"><span id="8278" class="nr mp iq nn b be ns nt l nu nv">app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World!');<br/>});</span></pre><blockquote class="ls"><p id="909a" class="lt lu iq bd lv lw os ot ou ov ow lr dk translated">在假设的场景中，商业用户坚持展示一幅图像，而不是呈现单词“Hello World！”相反，在web页面上，需要考虑ExpressJS服务器应该向客户机浏览器返回什么类型的响应数据，因为所需的内容不再是普通的HTML文本。</p></blockquote><p id="70c4" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">首先，重要的是首先要确定这个用例的目标是返回一个嵌入了图像的二进制文件数据的<strong class="ky ir">响应对象</strong>。因此，在下一节中，我将继续演示如何渲染一个图像，例如地址为<a class="ae kv" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9000/ </a>的<a class="ae kv" href="https://github.com/incubated-geek-cc/node-api-stream-demo/raw/main/leaf.png" rel="noopener ugc nofollow" target="_blank">leaf.png</a>。</p><p id="e691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，只需参考前面提到的代码行，并在下面的<strong class="ky ir"> server.js </strong>中进行以下更改:</p><pre class="kg kh ki kj gt nm nn no bn np nq bi"><span id="9e77" class="nr mp iq nn b be ns nt l nu nv">const express = require('express');<br/>const app = express();<br/>const port = 9000;<br/>const fs = require('fs');<br/>const path = require('path');<br/>app.get('/', (req, res) =&gt; {<br/>   var filepathToStream=path.join(__dirname, 'leaf.png');<br/>   var readStream = fs.createReadStream(filepathToStream);<br/>   readStream<br/>   .on('open', () =&gt; {<br/>       readStream.pipe(res);<br/>   })<br/>   .on('error', (err_msg) =&gt; {<br/>       console.log(err_msg);<br/>       res.end(err_msg);<br/>   });<br/>});<br/>app.listen(port, () =&gt; {<br/> console.log(`App is listening at http://localhost:${port}`)<br/>});</span></pre><p id="81c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续重新运行应用程序。预期输出应为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/cfc2e5ec787fd399bc62189a2a147466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjZFcafghNru6IrtJvRR-Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screenshot by Author | The leaf image has been rendered onto the same local address on port 9000 after changes were made to server.js</figcaption></figure><p id="1458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">附注:</strong>在检查元素时，值得注意的是Transfer-Encoding属性被声明为“chunked”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/beb390e634d695077d01655c717c1f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHkKtKXJ6iagS3RsMI1Dbg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screenshot by Author | Transfer-Encoding is chunked in this case as outlined by the red box.</figcaption></figure><h2 id="b899" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated"><strong class="ak">解释传输编码=分块的基本原理</strong></h2><p id="846a" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">在服务器无法确定响应实体的总大小<em class="od">(字节数)</em>的情况下，响应数据的缓冲区数组将因此被成批返回，以防止服务器在传输完成时或之前过载。</p><p id="7554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="od"> — </em> </strong>这在服务器应用程序需要从外部分页API连续传输数据的用例中尤其常见。</p><p id="c4ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于在这个特定的演示中，我们很清楚作为响应实体返回到客户端的本地文件映像没有超出服务器的处理能力，因此本能的选择是实现<strong class="ky ir">管道</strong>以减少所需的代码行。</p><pre class="kg kh ki kj gt nm nn no bn np nq bi"><span id="0f52" class="nr mp iq nn b be ns nt l nu nv">readStream<br/>   .on('open', () =&gt; {<br/>       readStream.pipe(res);<br/>   })<br/>   .on('error', (err_msg) =&gt; {<br/>       console.log(err_msg);<br/>       res.end(err_msg);<br/>   });</span></pre><blockquote class="oa ob oc"><p id="273e" class="kw kx od ky b kz la jr lb lc ld ju le oe lg lh li of lk ll lm og lo lp lq lr ij bi translated"><em class="iq">或者，如果我们坚持按块传输数据的传统方式，那么检索缓冲区数组的方法将不同于上面的方法，如下面的</em><strong class="ky ir"><em class="iq">server . js</em></strong><em class="iq">文件中的替代解决方案所示(其中所需的输出可以通过地址链接</em><a class="ae kv" href="http://localhost:9000/leaf" rel="noopener ugc nofollow" target="_blank"><em class="iq">http://localhost:9000/leaf</em></a><em class="iq">访问)</em></p></blockquote><pre class="kg kh ki kj gt nm nn no bn np nq bi"><span id="5b3f" class="nr mp iq nn b be ns nt l nu nv">const express = require('express');<br/>const app = express();<br/>const port = 9000;<br/>const fs = require('fs');<br/>const path = require('path');<br/>app.get('/', (req, res) =&gt; {<br/>   var filepathToStream=path.join(__dirname, 'leaf.png');<br/>   var readStream = fs.createReadStream(filepathToStream);<br/>   readStream<br/>   .on('open', () =&gt; {<br/>       readStream.pipe(res);<br/>   })<br/>   .on('error', (err_msg) =&gt; {<br/>       console.log(err_msg);<br/>       res.end(err_msg);<br/>   });<br/>});<br/>app.get('/leaf', (req, res) =&gt; {<br/>  var filepathToStream=path.join(__dirname, 'leaf.png');<br/>  var readStream = fs.createReadStream(filepathToStream);<br/>  readStream<br/>  .on('data',(chunk) =&gt; {<br/>    res.write(chunk);<br/>  })<br/>  .on('error', (err_msg) =&gt; {<br/>    console.log(err_msg);<br/>    res.end(err_msg);<br/>  })<br/>  .on('end', () =&gt; {<br/>      res.end();<br/>  });<br/>});<br/>app.listen(port, () =&gt; {<br/> console.log(`App is listening at http://localhost:${port}`)<br/>});</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/3ed60f0c3965fb4d9a951f87d1efa2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpxSBMyNdn_S6UFZuHGwlQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screenshot by Author | The leaf image has been rendered onto the same local address on port 9000 with the suffix ‘leaf’ after changes made to server.js</figcaption></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="15ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我已经完成了以上关于如何使用<strong class="ky ir">管道</strong>功能和/或通过<strong class="ky ir">块</strong>读取来处理流和缓冲区的演示，但还有一点我想分享，因为它通常与相关用例密切相关。</p><h2 id="05c9" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">额外材料:为图片提供一个下载链接</h2><p id="3267" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">对<strong class="ky ir"> server.js </strong>文件进行修改后，可在<a class="ae kv" href="http://localhost:9000/download_leaf" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/download _ leaf</a>访问下载链接；</p><pre class="kg kh ki kj gt nm nn no bn np nq bi"><span id="8f42" class="nr mp iq nn b be ns nt l nu nv">const express = require('express');<br/>const app = express();<br/>const port = 9000;<br/>const fs = require('fs');<br/>const path = require('path');<br/>app.get('/', (req, res) =&gt; {<br/>   var filepathToStream=path.join(__dirname, 'leaf.png');<br/>   var readStream = fs.createReadStream(filepathToStream);<br/>   readStream<br/>   .on('open', () =&gt; {<br/>       readStream.pipe(res);<br/>   })<br/>   .on('error', (err_msg) =&gt; {<br/>       console.log(err_msg);<br/>       res.end(err_msg);<br/>   });<br/>});<br/>app.get('/leaf', (req, res) =&gt; {<br/>  var filepathToStream = path.join(__dirname, 'leaf.png');<br/>  var readStream = fs.createReadStream(filepathToStream);<br/>  readStream<br/>  .on('data',(chunk) =&gt; {<br/>    res.write(chunk);<br/>  })<br/>  .on('error', (err_msg) =&gt; {<br/>    console.log(err_msg);<br/>    res.end(err_msg);<br/>  })<br/>  .on('end', () =&gt; {<br/>      res.end();<br/>  });<br/>});<br/>app.get('/download_leaf', (req, res) =&gt; {<br/>  var allChunks=[];<br/>  var filepathToStream=path.join(__dirname, 'leaf.png');<br/>  var readStream = fs.createReadStream(filepathToStream);<br/>  readStream<br/>  .on('data', (chunk) =&gt; {<br/>    allChunks=allChunks.concat(chunk);<br/>  })<br/>  .on('error', (err_msg) =&gt; {<br/>    console.log(err_msg);<br/>    res.end(err_msg);<br/>  })<br/>  .on('end', () =&gt; {<br/>      var b64URI = 'data:image/png;base64,' + Buffer.from(allChunks[0]).toString('base64');<br/>      var downloadLink="&lt;a href='"+b64URI+"' download='leaf.png' target='_blank'&gt;Download leaf.png&lt;/a&gt;";<br/>      res.send(downloadLink);<br/>  });<br/>});<br/>app.listen(port, () =&gt; {<br/>  console.log(`App is listening at http://localhost:${port}`)<br/>});</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/b6e8f1a8f51aaa4a9ebd210e64c5c733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*kz2DhprkHQCe8srOLjiV2A.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screen Capture by Author | Upon navigating to <a class="ae kv" href="http://localhost:9000/download_leaf" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/download_leaf</a> the download link is generated. Image is then saved successfully.</figcaption></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="3c28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="od">我关于如何在ExpressJS中处理缓冲区数组和流数据的文章到此结束！非常感谢你坚持到这篇文章的结尾！❤希望本指南对您有用，如果您想了解更多GIS、数据分析&amp; Web应用相关的内容，请随时</em> <a class="ae kv" href="https://medium.com/@geek-cc" rel="noopener"> <em class="od">关注我的Medium </em> </a> <em class="od">。</em>非常感谢😀</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="ff99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你忘记了，完整的源代码在这里<a class="ae kv" href="https://github.com/incubated-geek-cc/node-api-stream-demo" rel="noopener ugc nofollow" target="_blank">可以找到</a>如果有人想检索它作为参考。</p><div class="pa pb gp gr pc pd"><a href="https://geek-cc.medium.com/membership" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd ir gy z fp pi fr fs pj fu fw ip bi translated">通过我的推荐链接加入灵媒——李思欣·崔</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">获得李思欣·崔和其他作家在媒体上的所有帖子！😃您的会员费直接…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">geek-cc.medium.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr kp pd"/></div></div></a></div><p id="0fc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="od">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="od">plain English . io</em></a><em class="od">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="od">免费周报在这里</em> </a> <em class="od">。</em></p></div></div>    
</body>
</html>