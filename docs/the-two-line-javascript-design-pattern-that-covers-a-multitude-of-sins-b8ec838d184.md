# 两行 JavaScript 设计模式涵盖了许多原罪

> 原文：<https://javascript.plainenglish.io/the-two-line-javascript-design-pattern-that-covers-a-multitude-of-sins-b8ec838d184?source=collection_archive---------1----------------------->

## 因为对于一个有才华的傻瓜来说，没有什么是不可救药的。

![](img/11df28e316f685c8edfdaae5eb0a1c76.png)

## 有什么问题？😩

总有一个不是吗？写类似于`if (x === undefined)`的东西的初级开发者，或者用大量你不需要的垃圾污染全局范围的包。或者这可能是一种自我破坏——你花了很长时间调试某个模糊的问题，诅咒造成这个问题的人，却发现实际上是你搞砸了😅

尽管 JavaScript 生态系统在过去十年中取得了令人难以置信的进步，但一些粗心的代码仍然有一百万种方式可以毁掉你的一天。

如果你是一个前端开发人员，你会确切地知道我在说什么，特别是如果你曾经不得不在框架之外工作。编码标准指南能做的就这么多了——它不能弥补粗心大意或对语言工作原理缺乏理解。

还是可以…

## 有什么解决办法？💡

以下编程模式保护您的代码免受应用程序中其他地方(包括导入的库)出现的几乎每一个粗心错误的影响，它只用两行代码就做到了这一点——足够短，任何人都可以记住:

看起来不怎么样，是吧？虽然它的简单性是骗人的，但实际上有相当多的东西需要解开。让我们开始吧。

第一行以分号开始，它将您的代码与其之前执行的代码分隔开来。这确保了任何不够聪明的人没有机会破坏你的代码。接下来，我们有一个匿名函数。这确保了您声明的任何变量都在闭包内，这意味着它们不会受到任何全局变量的影响。因为，你知道，人们就是喜欢污染全球范围。

您还会注意到，我们在函数参数中重新声明了`window`对象，它是由文件底部的函数执行中传递的`this`关键字声明的。在箭头函数之外，`this`关键字总是引用其当前执行上下文的父上下文，在全局设置中是`window`对象。以这种方式传递它可以确保您的函数接收实际的`window`(或父)对象，而不是某人出于某种原因以相同的名称声明的其他变量。

`undefined`也是如此。通过在函数中声明它，但不在执行中传递它，我们确保它保留了`undefined`的值，不管它是否在全局范围内被污染。因为，是的，`undefined`是可变的。

如果你正在处理实际上需要这两者之一的代码，我的心*真的*与你同在，但是尽管如此，有一个修复程序也是好的。

我们可以使用同样的方法来防止我们实际需要的全局范围内变量的名称冲突。你只需要在执行中引用它们作为`this`的子节点，并在函数声明中把它们添加到`undefined`参数之前:

## 在纯粹主义者来找我之前…

我知道，我知道。现在是 2021 年，我们不应该再写窗口级别的代码了。包装生态系统消除了很多这样的问题。开发人员应该了解他们正在犯的错误，而不是被编程模式屏蔽掉。

我知道这个。你知道的。但这不是重点。

现实情况是，许多项目仍然运行窗口级代码，许多团队没有足够的带宽来适当地指导初级人员，许多开发人员在时间紧迫的准系统团队中，处理着许多可以通过这种模式解决的压力。

那些事情*是否应该*是真实的是另一个讨论，我只是说它们*是真实的*，并试图帮助那些不得不处理后果的可怜的灵魂。不要@我🤷🏻‍♂️

**感谢您的阅读！**

你有什么编程模式可以帮助你的日常工作吗？请在评论中告诉我！👇👇👇