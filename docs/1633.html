<html>
<head>
<title>Create a Collaborative Canvas with Fabric.js and Socket.IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Fabric.js和Socket创建协作画布。超正析象管(Image Orthicon)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-collaborative-canvas-with-fabric-js-and-socket-io-c60668e4099b?source=collection_archive---------0-----------------------#2021-04-08">https://javascript.plainenglish.io/creating-a-collaborative-canvas-with-fabric-js-and-socket-io-c60668e4099b?source=collection_archive---------0-----------------------#2021-04-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="5014" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="ce1c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Fabric.js是目前最强大的JavaScript库之一，它为经典的HTML5画布添加了一个交互层，允许从绘图工具到动画的一切简化实现。</p><p id="eac9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">最近想把Fabric.js的强大和Socket的强大结合起来。IO，一个用于实时通信的JavaScript框架，创建一个多个用户可以一起交互的画布。</p><p id="4c2c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我没有找到关于这种组合的太多信息，所以我决定记录我创建一个简单协作画布的过程。</p><p id="8ec2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我将在前端使用React，在服务器端使用Express，但是这段代码可以适用于其他框架。</p><h1 id="7dec" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">第1部分:Fabric.js</h1><p id="568a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们将从设置我们的Fabric canvas开始—您需要安装Fabric.js。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="366e" class="lu jl in lq b gy lv lw l lx ly">npm install fabric</span></pre><p id="db65" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">一旦安装了结构模块，就将其导入到您的应用程序组件中。另外，从React导入useState和useEffect挂钩——这将使我们更容易设置画布，以及稍后在画布之间同步。</p><p id="5101" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">准备好画布需要几个步骤。</p><ol class=""><li id="539e" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">声明一个名为“canvas”的状态变量:</li></ol><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="2873" class="lu jl in lq b gy lv lw l lx ly">const [canvas, setCanvas] = useState('');</span></pre><p id="250a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">2.我们还需要一个HTML画布元素来包裹我们的织物画布:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="730e" class="lu jl in lq b gy lv lw l lx ly">&lt;canvas id='canv' /&gt;</span></pre><p id="5048" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">3.现在，我们可以编写一个函数来初始化我们的Fabric canvas，通过其id来标识要使用的canvas元素:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="11dc" class="lu jl in lq b gy lv lw l lx ly">const initCanvas = () =&gt; {   <br/>   // Fabric will create a wrapper around the html canvas element with the id 'canv'<br/>   new fabric.Canvas('canv', {      <br/>     height: 500,      <br/>     width: 500,      <br/>     backgroundColor: 'white',    <br/>   });</span></pre><p id="8751" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">4.在App组件最初呈现canvas元素之后，我们可以使用<a class="ae mi" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> useEffect钩子</a>调用initCanvas函数，并将Fabric canvas存储在我们的状态变量中。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="02f9" class="lu jl in lq b gy lv lw l lx ly">useEffect(() =&gt; {<br/>    setCanvas(initCanvas());<br/>  }, []);</span></pre><p id="a633" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">画布本身并不令人兴奋——我们想添加一些功能！</p><p id="85f2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Fabric有大量有趣的方式与画布互动——你可以查看他们的<a class="ae mi" href="http://fabricjs.com/demos/" rel="noopener ugc nofollow" target="_blank">演示</a>以获得一些很酷的想法——但我们很高兴进入协作部分，所以我们现在将保持简单。</p><h2 id="3a7c" class="lu jl in bd jm mj mk dn jq ml mm dp ju kt mn mo jy kx mp mq kc lb mr ms kg mt bi translated">让我们添加一些形状！</h2><p id="1ec9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在我们的canvas元素之上，添加三个按钮。我们将使用onClick事件来触发一个名为“addShape”的函数</p><p id="b7ce" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">根据点击的按钮，addShape将在画布上呈现圆形、三角形或矩形。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="79a0" class="lu jl in lq b gy lv lw l lx ly">&lt;button type='button' name='rectangle' onClick={addShape}&gt;    <br/>   Add a Rectangle  <br/>&lt;/button&gt;</span></pre><p id="d177" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在useEffect下面，我们将编写addShape函数。我们检查被单击的按钮的name属性，以确定要添加哪种类型的形状，然后使用内置的Fabric方法创建它，将其添加到画布，并呈现更新后的画布。</p><p id="3763" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们还在创建对象时添加了一个id属性。这不是Fabric对象的内置属性，但是我们以后开始修改对象时会用到它。我正在使用<a class="ae mi" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a>来轻松创建唯一的id。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9f5d" class="lu jl in lq b gy lv lw l lx ly">const addShape = (e) =&gt; {<br/>   let type = e.target.name;<br/>   let object<br/>   <br/>   // determine the type of the object to create based on the name attribute from the button that was clicked<br/>   if (type === 'rectangle') {<br/>      object = new fabric.Rect({<br/>      height: 75,<br/>      width: 150,<br/>   });</span><span id="5d73" class="lu jl in lq b gy mu lw l lx ly">   // set an id property on the object<br/>   object.set({id: uuid()})<br/>   // add the object to the canvas<br/>   canvas.add(object);<br/>   // re-render the canvas<br/>   canvas.renderAll();<br/>}</span></pre><p id="68f0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这是我们目前为止的应用组件:</p><figure class="ll lm ln lo gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="25ce" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">经过一点点的造型，这就是我们最终得到的结果:</p><figure class="ll lm ln lo gt mv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/4f8c5381c94e07cb3dc8a0a2a3b005b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/1*YpJotDQOiz_uW_RWszHLgg.gif"/></div></figure><p id="1282" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">更多关于Fabric.js特性的信息，请查看他们的<a class="ae mi" href="http://fabricjs.com/articles/" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><h1 id="afa8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">第二部分:插座。IO(服务器)</h1><p id="982a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在我们已经准备好集成Socket.IO了。我将Express用于我的服务器，所以我将继续在其上连接我的Socket服务器。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="82db" class="lu jl in lq b gy lv lw l lx ly">// be sure to require socket.io<br/>const express = require('express')<br/>const app = express()<br/>const socketio = require('socket.io')   </span><span id="e85f" class="lu jl in lq b gy mu lw l lx ly">const server = app.listen(8080)  </span><span id="72d5" class="lu jl in lq b gy mu lw l lx ly">// after we start listening to our server, we can set up and attach our socket.io server<br/>const io = socketio(server)</span><span id="6d7f" class="lu jl in lq b gy mu lw l lx ly">// in a separate file we'll get more specific about the events we want our socket server to listen for and broadcast<br/>require('./socket')(io)</span></pre><p id="6506" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在每个套接字连接中，我们希望监听两个事件——“对象添加”或“对象修改”当我们与画布交互时，我们将从客户端发出这些事件。</p><p id="edef" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">当服务器听到这些事件之一时，我们将让它广播数据和相应的事件。通过广播，我们将事件发送给除原始发送者之外的所有套接字连接。</p><p id="bdf8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这将让所有其他套接字连接知道添加或修改对象，但不会导致原始套接字复制事件。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="021f" class="lu jl in lq b gy lv lw l lx ly">module.exports = (io) =&gt; {  <br/>   io.on('connection', socket =&gt; {     </span><span id="57b2" class="lu jl in lq b gy mu lw l lx ly">   socket.on('object-added', data =&gt; {         <br/>      socket.broadcast.emit('new-add', data);    <br/>   })     <br/>   <br/>   socket.on('object-modified', data =&gt; {    <br/>      socket.broadcast.emit('new-modification', data);    <br/>   })      <br/>})}</span></pre><p id="ac2f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">你可以找到更多关于Socket的信息。IO服务器初始化这里:【https://socket.io/docs/v3/server-initialization/ T2】</p><h1 id="e69e" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">第三部分:插座。IO(客户端)</h1><p id="c938" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">最后，我们准备在客户端完成套接字的设置。</p><p id="bd13" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">首先，建立一个新的。js文件，它将包含我们所有的套接字侦听器和发射器。你可以阅读更多关于Socket的内容。IO客户端初始化这里:【https://socket.io/docs/v3/client-initialization/ T4】</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="249b" class="lu jl in lq b gy lv lw l lx ly">import io from 'socket.io-client'<br/>import {fabric} from 'fabric' </span><span id="9269" class="lu jl in lq b gy mu lw l lx ly">const socket = io(window.location.origin) </span></pre><p id="0025" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们需要两个发射器，一个在添加对象时使用，一个在修改对象时使用——确保导出它们，因为我们稍后将在应用程序组件中使用它们:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="73c1" class="lu jl in lq b gy lv lw l lx ly">export const emitAdd = obj =&gt; {<br/>  // we include the name of the event we're emitting, and a data object<br/>  socket.emit('object-added', data)<br/>}</span><span id="b14b" class="lu jl in lq b gy mu lw l lx ly">export const emitModify = (obj) =&gt; {<br/>  socket.emit('object-modified', obj)<br/>}</span></pre><p id="bab7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们还需要两个侦听器，一个用于当服务器广播另一个套接字已经添加了一个对象时:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="ec27" class="lu jl in lq b gy lv lw l lx ly">export const addObj = canvas =&gt; {<br/>   // we call socket.off first in case the socket connection has been restarted - this will remove any previous assignments of this method and prevent duplicate add events<br/>  socket.off('new-add')</span><span id="2fa9" class="lu jl in lq b gy mu lw l lx ly">    // listens for the socket server to broadcast a 'new-add' event<br/>  socket.on('new-add', data =&gt; {</span><span id="a40c" class="lu jl in lq b gy mu lw l lx ly">     // we'll pull out the object and id from the data object the socket emitted<br/>    const { obj, id } = data<br/>    let object</span><span id="97c5" class="lu jl in lq b gy mu lw l lx ly">    // check the type of the obj we received and create an object of that type<br/>    if (obj.type === 'rect') {<br/>      object = new fabric.Rect({<br/>        height: obj.height,<br/>        width: obj.width,<br/>      })<br/>    } else if (obj.type === 'circle') {<br/>      object = new fabric.Circle({<br/>        radius: obj.radius,<br/>      })<br/>    } else if (obj.type === 'triangle') {<br/>      object = new fabric.Triangle({<br/>        width: obj.width,<br/>        height: obj.height,<br/>      })<br/>    }</span><span id="7716" class="lu jl in lq b gy mu lw l lx ly">    // set the new object's id to the id we received<br/>    object.set({id: id})<br/>    // add the object to the canvas<br/>    canvas.add(object)<br/>    canvas.renderAll()<br/>  })<br/>}</span></pre><p id="0adc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">一个用于当套接字服务器广播另一个套接字已经修改了对象时:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9f15" class="lu jl in lq b gy lv lw l lx ly">export const modifyObj = canvas =&gt; {</span><span id="be91" class="lu jl in lq b gy mu lw l lx ly">   // listens for the socket server to broadcast a 'new-modification' event<br/>   socket.on('new-modification', data =&gt; {<br/>   const { obj, id } = data</span><span id="1d31" class="lu jl in lq b gy mu lw l lx ly">    // check the objects on our canvas for one with a matching id<br/>    canvas.getObjects().forEach(object =&gt; {<br/>      if (object.id === id) {</span><span id="bf92" class="lu jl in lq b gy mu lw l lx ly">        // set the object on the canvas to the object we received from the socket server<br/>        object.set(obj)</span><span id="5030" class="lu jl in lq b gy mu lw l lx ly">        // calling setCoords ensures that the canvas recognizes the object in its new position<br/>        object.setCoords()<br/>        canvas.renderAll()<br/>      }<br/>    })<br/>  })<br/>}</span></pre><p id="7fde" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">以下是完整的代码:</p><figure class="ll lm ln lo gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9960" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，我们需要向我们的应用程序组件添加一些东西。我们需要刚刚定义的发射器和监听器，所以一定要导入它们:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="2ea5" class="lu jl in lq b gy lv lw l lx ly">import { emitModify, emitAdd, modifyObj, addObj } from './socket'</span></pre><p id="a9eb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们将创建第二个<a class="ae mi" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> useEffect钩子</a>，并将包含状态变量‘canvas’的数组作为第二个参数传递。在钩子中，我们将检查这个变量中是否有值:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="98d6" class="lu jl in lq b gy lv lw l lx ly">useEffect(<br/>    () =&gt; {<br/>      if (canvas) {<br/>        // listeners will go here<br/>      },<br/>    [canvas]<br/>  )</span></pre><p id="15e5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果这样做，我们将添加两个画布监听器——它们将监听画布修改或对象移动。如果我们听到其中一个事件，我们将把它发送到套接字服务器:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="dc6f" class="lu jl in lq b gy lv lw l lx ly">canvas.on('object:modified', function (options) {<br/>          if (options.target) {<br/>            const modifiedObj = {<br/>              obj: options.target,<br/>              id: options.target.id,<br/>            }<br/>            emitModify(modifiedObj)<br/>          }<br/>        })</span><span id="b51a" class="lu jl in lq b gy mu lw l lx ly">canvas.on('object:moving', function (options) {<br/>          if (options.target) {<br/>            const modifiedObj = {<br/>              obj: options.target,<br/>              id: options.target.id,<br/>            }<br/>            emitModify(modifiedObj)<br/>          }<br/>        })</span></pre><p id="4d5e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可能已经注意到，我们正在创建一个新的对象，将Fabric对象及其id作为单独的属性。这是由于Fabric的序列化方法—序列化对象时只包括Fabric对象的标准属性。</p><p id="73e4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">为了抵消这一点，我们可以在发出事件时单独传递id。</p><p id="e50f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在我们的if语句中，我们还可以调用我们的套接字侦听器，来捕获套接字服务器广播的任何事件:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="bd7e" class="lu jl in lq b gy lv lw l lx ly">modifyObj(canvas)<br/>addObj(canvas)</span></pre><p id="5f65" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们还想在addShape函数中添加一个发射器。在这里，我们还将创建一个新对象来分隔id:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="d0d5" class="lu jl in lq b gy lv lw l lx ly">emitAdd({obj: object, id: object.id})</span></pre><p id="5c66" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这是我们协作画布的点睛之笔，这是我们最终的应用组件:</p><figure class="ll lm ln lo gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c45d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这是我们正在使用的画布:</p><figure class="ll lm ln lo gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/97b1d2d1707852b3e9835a36e4bf404a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SDbgrjzVyAXJ24Z7K-Pfhw.gif"/></div></div></figure><h1 id="8582" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="301d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">既然你已经建立了一个简单的协作画布，我建议你探索一下<a class="ae mi" href="http://fabricjs.com/" rel="noopener ugc nofollow" target="_blank"> Fabric.js </a>的许多特性——你可以添加更多的工具，从绘图到滤镜再到上传图像。</p><p id="947a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要获得更多灵感，请查看<a class="ae mi" href="https://collaballage.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">Collaballage</a>——这是一个团队最近创建的协作画布网络应用。</p><p id="18b7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">感谢您的阅读——如有任何问题、建议或更正，请随时联系我们！</p></div></div>    
</body>
</html>