<html>
<head>
<title>Tackling some react-lazyload edge cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理一些反应迟钝的边缘案例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tackling-the-react-lazyload-issue-of-in-some-edge-cases-not-loading-its-wrapped-component-and-how-daeeddadcabe?source=collection_archive---------19-----------------------#2021-04-20">https://javascript.plainenglish.io/tackling-the-react-lazyload-issue-of-in-some-edge-cases-not-loading-its-wrapped-component-and-how-daeeddadcabe?source=collection_archive---------19-----------------------#2021-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="60f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解决在某些边缘情况下不加载其包装组件的react-lazyload问题，以及如何在屏幕之间平滑过渡</h2></div><p id="5b3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之前我写了3篇文章，关于如何在<a class="ae lb" href="https://metacules.com" rel="noopener ugc nofollow" target="_blank">metacules.com</a>网站上完成图像加载、优化和性能，以及当试图解决一些挑战时，什么样的思维过程发挥了作用。</p><p id="1769" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你也想看看，你可以在链接下面找到这3篇文章:</p><ul class=""><li id="1fab" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/image-loading-in-react-js-preloading-lazy-loading-intersectionobserver-fade-in-transitions-722c24f4d5fb">第1部分:预加载、延迟加载、交叉观察器、淡入过渡、窗口、错误处理、占位符等等</a></li><li id="7bd5" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/react-image-loading-optimization-techniques-b885427bde44">第二部分:预加载，交叉观察，淡入过渡，用指针事件阻止图像下载等等… </a></li><li id="313c" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/scroll-rendering-performance-react-image-loading-optimization-techniques-17350d8f04a8">第3部分:react-lazyload的性能优化&amp; react-window、内存化以及如何处理两个包都存在的问题</a></li></ul><p id="81eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我想深入探讨一下我在使用react-lazyload时遇到的一个问题，即在某些边缘情况下，当它进入视图时，它不会加载它的组件。</p><p id="9ff0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给你一些必要的背景知识。请看下图中Android设备上的移动web应用程序的UI。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/94899717362b8a320e364e15c4bb0b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vWkcDXr_Ze4EXzyDJSuX7w.jpeg"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">‘White’ version of the Mobile UI</figcaption></figure><p id="cd02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在页面底部，您会看到4个选项卡，用于在应用程序的主“屏幕”之间导航。<br/>页面之间的导航不是通过像从<strong class="kh ir"> /home </strong>到<strong class="kh ir"> /videos </strong>这样的路径来完成的(目前在桌面版本中仍然是这样)。相反，我们有一个主要组件，包含4个div，分别用于主页、视频、播客和书籍屏幕，根据选择的导航选项卡，其他选项卡的div将设置为<strong class="kh ir">隐藏</strong>。</p><p id="9283" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我喜欢这种方法，例如，与使用react-router-dom相比，react-router-DOM根据当前活动的路由来装载和卸载组件，因为选项卡之间的转换现在可以更快、更平滑地执行，并且一些内容已经预先呈现和预加载。</p><p id="25ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我遇到了一个问题，当从一个选项卡切换到另一个选项卡时，直到用户第一次滚动屏幕时，这些行才会呈现… <br/>如果您阅读了以前的文章，您可能记得每个屏幕上的行都包装在LazyLoad组件中，例如在Books屏幕上，这些行看起来像这样:</p><pre class="lr ls lt lu gt mc md me mf aw mg bi"><span id="7e7e" class="mh mi iq md b gy mj mk l ml mm">{<strong class="md ir">Object</strong>.entries(bookRows).map(([title, items]) =&gt; (<br/>    &lt;LazyLoad offset={200} key={title}&gt;<br/>        &lt;div key={title}<br/>             className={classes.cardRow}&gt;<br/>            &lt;BookRowMobile<br/>                title={title}<br/>                onBookClicked={onBookClicked}<br/>                items={items}/&gt;<br/>        &lt;/div&gt;<br/>    &lt;/LazyLoad&gt;<br/>))}</span></pre><p id="5862" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">lazyload组件只负责在它位于视口内或在视口的指定偏移量内时触发其子组件的渲染。我遇到的问题是，当切换tab和它的div状态从隐藏变为可见时，渲染没有被触发，只有当滚动一点点时，LazyLoad组件才会重新评估渲染是否是它的子组件。</p><p id="2000" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我环顾四周，但找不到如何处理这种特定用例的解决方案。因此，最终我想到了实现一个“创造性”的解决方案，每当新屏幕变得可见时，就在视窗中显示行。我是这样做的，当另一个“屏幕”变得可见时，通过编程向下滚动一个像素，再向上滚动一个像素。以相同的位置结束，但以这种方式触发渲染。</p><p id="1fca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我这样做的方式是通过创建一个自定义挂钩，我将传递每个屏幕组件的主div的<strong class="kh ir"> ref </strong>，然后该自定义挂钩将通过IntersectionObserver API评估该div是否可见，如果可见，则再次上下滚动1个像素。</p><p id="767c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自定义挂钩看起来像这样:</p><pre class="lr ls lt lu gt mc md me mf aw mg bi"><span id="dde4" class="mh mi iq md b gy mj mk l ml mm">export default function useLazyLoadFirstVisibilityFix(ref) {<br/><br/>    const [isVisible, setIsVisible] = useState(false);<br/><br/>    const observer = new <strong class="md ir">IntersectionObserver</strong>(<br/>        ([entry]) =&gt; {<br/>            if (entry.isIntersecting) {<br/>                setIsVisible(true);<br/>                <strong class="md ir">window</strong>.scrollTo({top: <strong class="md ir">window</strong>.pageYOffset + 1});<br/>                <strong class="md ir">window</strong>.scrollTo({top: <strong class="md ir">window</strong>.pageYOffset - 1});<br/>            } else {<br/>                setIsVisible(false);<br/>            }<br/>        }<br/>    );<br/><br/>    useEffect(() =&gt; {<br/>        observer.observe(ref.current)<br/>        // Remove the observer as soon as the component is unmounted<br/>        return () =&gt; {<br/>            observer.disconnect()<br/>        }<br/>    }, []);<br/><br/>    return isVisible<br/>}</span></pre><p id="9cc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，无论引用的组件是否可见，它都会返回一个布尔值。我们不一定需要这个“黑客”来修复这个行可见性问题，但它被用于其他事情…我们将在后面得到那个…</p><p id="f3ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在“屏幕”组件的代码应该是这样的</p><pre class="lr ls lt lu gt mc md me mf aw mg bi"><span id="ddfe" class="mh mi iq md b gy mj mk l ml mm">function BooksMobile() {</span><span id="a0db" class="mh mi iq md b gy mn mk l ml mm">const classes = useStyles<em class="mo">()</em>;<br/>const ref = useRef();<br/>const isVisible = useLazyLoadFirstVisibilityFix(ref);</span><span id="9579" class="mh mi iq md b gy mn mk l ml mm">[... bunch of other code ...]</span><span id="b1a2" class="mh mi iq md b gy mn mk l ml mm">return (<br/>    &lt;div <strong class="md ir">ref={ref}</strong> className=<em class="mo">{</em>`$<em class="mo">{</em>classes.root<em class="mo">} </em>$<em class="mo">{</em>isVisible ? classes.isVisible : classes.isNotVisible<em class="mo">}</em>`<em class="mo">}</em>&gt;</span><span id="6966" class="mh mi iq md b gy mn mk l ml mm">        [... other components ...]</span><span id="3701" class="mh mi iq md b gy mn mk l ml mm">        {<strong class="md ir">Object</strong>.entries(bookRows).map(([title, items]) =&gt; (<br/>            &lt;LazyLoad offset={200} key={title}&gt;<br/>                &lt;div key={title}<br/>                     className={classes.cardRow}&gt;<br/>                    &lt;BookRowMobile<br/>                        onShareBookClicked={onShareBookClicked}<br/>                        title={title}<br/>                        onBookClicked={onBookClicked}<br/>                        shuffleItems={true}<br/>                        items={items}/&gt;<br/>                &lt;/div&gt;<br/>            &lt;/LazyLoad&gt;<br/>        ))}</span><span id="7a25" class="mh mi iq md b gy mn mk l ml mm">    &lt;/div&gt;<br/>);<br/>}</span></pre><p id="b8c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">useRef用于存储对main <div>的引用，该引用随后被传递给自定义<strong class="kh ir">useLazyLoadFirstVisibilityFix</strong>钩子，该钩子确保LazyLoad组件上的呈现在组件变得可见时被触发。</div></p><p id="5087" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，使用<em class="mo">值的部分是可见的。<br/> </em>我使用了Material-UI useStyles钩子，这个组件的样式看起来像这样:</p><pre class="lr ls lt lu gt mc md me mf aw mg bi"><span id="5cd3" class="mh mi iq md b gy mj mk l ml mm">const useStyles = makeStyles((theme) =&gt; createStyles({<br/>    root: theme.screenRoot,<br/>    isVisible: {<br/>        opacity: 1,<br/>        transition: "opacity 0.3s",<br/>    },<br/>    isNotVisible: {<br/>        opacity: 0,<br/>    },<br/> }));</span></pre><p id="7de9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当从一个屏幕导航到另一个屏幕时，它会创建一个0.3秒的不透明度过渡动画，而不是在屏幕之间导航时有一个硬过渡。就像谷歌新闻应用程序使用的例子一样。</p><p id="8cd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这就是这篇文章。如果你想看看我正在开发的手机应用原型的现状，你可以在https://metacules.com<a class="ae lb" href="https://metacules.com" rel="noopener ugc nofollow" target="_blank">查看</a></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="dd6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想知道更多，或者想帮助Metacules.com的创作，请联系我，通过任何一个渠道关注我，了解未来的最新消息。</p><p id="0d41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有任何额外的东西要添加、改进，或者如果你想给我们的项目送去一些爱或支持，你可以给我买咖啡或帮助筹集我们创建元规则(一种审查的解毒剂)平台的资金</p><ul class=""><li id="c8e7" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://www.buymeacoffee.com/l5LnQfk" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/l5LnQfk</a></li><li id="3b27" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">https://fundrazr.com/f1ldl3<a class="ae lb" href="https://fundrazr.com/f1ldl3" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="cc78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">里克·范·韦尔森是metacules的创始人，高级(Android)移动开发者，目前是使用React/NodeJs的metacules平台的开发者。<br/>您可以在社交媒体上关注我们:</em></p><p id="bffc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo"> -推特:</em><a class="ae lb" href="https://twitter.com/VelzenRik" rel="noopener ugc nofollow" target="_blank">https://twitter.com/VelzenRik</a><br/>-<em class="mo">推特</em>:<a class="ae lb" href="https://twitter.com/metacules" rel="noopener ugc nofollow" target="_blank">https://twitter.com/metacules</a><br/>-<em class="mo">脸书</em>:<a class="ae lb" href="https://www.facebook.com/Metaculescom-100856938688500" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/Metaculescom-100856938688500</a></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/c08ac77f23d3f41940524419906a4ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IslAlwYOeT0f4BaSZrQRgA.jpeg"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Part of the landing page of metacules.com</figcaption></figure></div></div>    
</body>
</html>