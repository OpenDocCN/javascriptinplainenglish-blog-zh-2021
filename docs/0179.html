<html>
<head>
<title>Intro to React Server Side Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React服务器端渲染简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-react-server-side-rendering-3c2af3782d08?source=collection_archive---------0-----------------------#2021-01-11">https://javascript.plainenglish.io/intro-to-react-server-side-rendering-3c2af3782d08?source=collection_archive---------0-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ee0a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在没有任何工具或框架的情况下构建一个React SSR应用程序</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/794d9bb20d4c3d6a277d87beeb6d858b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXvYmj3eEqaRigoFGcJZTA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Source: <a class="ae ks" href="https://www.reddit.com/r/ProgrammerHumor/comments/5lnsko/programming_environment_dilbert_comic_strip_on/" rel="noopener ugc nofollow" target="_blank">Reddit</a> and Dilbert by Scott Adams</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="2dbd" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这是(希望是)记录我在构建和维护SSR应用程序中所学到的经验的系列文章中的第一篇。</p><p id="bb28" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">本文不涉及SSR的优缺点，也不涉及不使用工具或框架的优缺点(例如，创建React App、Next.js等)。</p><p id="aaf6" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我完全承认手动设置构建配置是痛苦的。有很多很棒的工具可以抽象出这些配置，所以你可能甚至不需要接触这些东西就可以构建很棒的应用。</p><p id="0e3f" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">但是对于那些准备好接受痛苦的人来说…</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="0577" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">概观</h1><p id="1cd6" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">让我们从基础开始。我们将使用<strong class="lc io"> React </strong>、<strong class="lc io"> webpack </strong>和<strong class="lc io"> Express </strong>构建一个SSR应用程序，其工作方式如下:</p><ol class=""><li id="5617" class="mt mu in lc b ld le lg lh lj mv ln mw lr mx lv my mz na nb bi translated">浏览器向服务器发送HTTP请求以加载页面。</li><li id="9290" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv my mz na nb bi translated">服务器接收HTTP请求，并将React JSX转换为HTML标记。</li><li id="bb1b" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv my mz na nb bi translated">服务器将标记插入HTML模板，并将HTML响应发送回浏览器。</li><li id="1f0d" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv my mz na nb bi translated">浏览器呈现HTML，下载客户端JavaScript包，并“水合”HTML。</li></ol><p id="69b1" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">此外，为了使本文简短，我将重点讨论开发模式。我正在为未来保存生产模式(大概😅)文章。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="1cc1" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">项目结构</h1><p id="5097" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">在深入研究代码之前，让我们先了解一下项目结构。</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="2e41" class="nm lx in ni b gy nn no l np nq">.<br/>+-- client<br/>|   +-- components<br/>|   |   +-- App<br/>|   |   |   +-- index.js<br/>|   |   |   +-- style.less<br/>|   +-- index.js<br/>+-- server<br/>|   +-- index.js<br/>+-- babel.config.js<br/>+-- package.json<br/>+-- webpack.client.config.js<br/>+-- webpack.server.config.js<br/>+-- webpack.shared.config.js</span></pre><p id="2504" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">此项目中文件的快速概要:</p><ul class=""><li id="2500" class="mt mu in lc b ld le lg lh lj mv ln mw lr mx lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">./client/components</code>包含React和CSS代码。</li><li id="17b4" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">./client/index.js</code>是webpack的客户端<a class="ae ks" href="https://webpack.js.org/concepts/entry-points/" rel="noopener ugc nofollow" target="_blank">入口点</a>，在这里我们“水合”了服务器端呈现的HTML。</li><li id="81a0" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">./server/index.js</code>是webpack的服务器端<a class="ae ks" href="https://webpack.js.org/concepts/entry-points/" rel="noopener ugc nofollow" target="_blank">入口点</a>，我们在这里定义服务HTML页面的路径。</li><li id="261d" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">./babel.config.js</code>是<a class="ae ks" href="https://babeljs.io/docs/en/config-files#configuration-file-types" rel="noopener ugc nofollow" target="_blank">的东西</a>让你可以在浏览器和Node.js中使用React JSX和ES6+的特性，你可能见过这个文件的替代版本(<code class="fe ns nt nu ni b">.babelrc</code>、<code class="fe ns nt nu ni b">babel.config.json</code>等)。</li><li id="d089" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">./webpack.shared.config.js</code>是webpack用于客户端和服务器端代码的配置。</li><li id="2357" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">./webpack.client.config.js</code>是特定于客户端代码的配置。</li><li id="fa75" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">./webpack.server.config.js</code>是特定于服务器端代码的配置。</li></ul></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="dafa" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">属国</h1><p id="bb71" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">下面是撰写本文时使用的依赖项(和版本)。我还将在下面的每一节中提到要安装哪些相关的依赖项。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ae8e" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在让我们更详细地看看项目中的每个文件。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="14b0" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">网络包</h1><p id="c6d4" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">如果您习惯于构建spa(单页应用程序)，您可能不需要webpack来处理您的服务器端代码。但是要启用SSR，服务器必须能够读取React代码，或者更确切地说是JSX。这意味着，我们现在需要webpack在我们的服务器端代码上发挥它的魔力。另外，您还可以使用Node.js中可能不支持的ES6+语法，例如<code class="fe ns nt nu ni b">import</code>和<code class="fe ns nt nu ni b">export</code>。(旁注:如果你选择<a class="ae ks" href="https://reactjs.org/docs/react-without-jsx.html" rel="noopener ugc nofollow" target="_blank">根本不写JSX </a>就不需要webpack。😬)</p><p id="dc66" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我不会详细介绍每个webpack选项，但是如果你感兴趣的话，这里有一个很好的解释器。</p><h2 id="8849" class="nm lx in bd ly nx ny dn mc nz oa dp mg lj ob oc mi ln od oe mk lr of og mm oh bi translated"><em class="oi">客户端和服务器端的通用webpack配置</em></h2><p id="7966" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">安装相关的依赖项:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="931a" class="nm lx in ni b gy nn no l np nq">npm i webpack webpack-cli babel-loader</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">webpack.shared.config.js</figcaption></figure><p id="e5ab" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">上面代码注释的注释:</p><p id="3521" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[A]</strong></code>出于我们的目的，我们想要显式地将<code class="fe ns nt nu ni b">mode</code>设置为<strong class="lc io">开发</strong>。如果我们使用<strong class="lc io"> production </strong>的默认值，我们可能会丢失React等库中有用的控制台警告/错误，并且由于代码缩减，错误堆栈跟踪非常难以阅读。点击阅读更多关于<strong class="lc io">生产</strong>和<strong class="lc io">开发</strong>模式<a class="ae ks" href="https://webpack.js.org/configuration/mode/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="cc63" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[B]</strong></code>这告诉webpack用<code class="fe ns nt nu ni b">babel-loader</code>预处理<code class="fe ns nt nu ni b">.js</code>文件，后者<a class="ae ks" href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them#:~:text=Transpilers%2C%20or%20source%2Dto%2D,are%20said%20to%20target%20JavaScript." rel="noopener ugc nofollow" target="_blank">将</a> ES6+和JSX代码转换成浏览器和Node.js服务器可读的JavaScript代码。该加载程序使用我们在<code class="fe ns nt nu ni b">babel.config.js</code>中指定的选项。</p><p id="9125" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[C]</strong></code>这意味着在导入带有这些扩展名的文件时，我不必再键入<code class="fe ns nt nu ni b">.js</code>或<code class="fe ns nt nu ni b">.less</code>。比如<code class="fe ns nt nu ni b">import App from ‘./components/App’</code>。</p><h2 id="c565" class="nm lx in bd ly nx ny dn mc nz oa dp mg lj ob oc mi ln od oe mk lr of og mm oh bi translated">巴贝尔配置</h2><p id="9d8d" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">安装相关的依赖项:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="293b" class="nm lx in ni b gy nn no l np nq">npm i babel-loader @babel/core @babel/preset-env @babel/preset-react</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">babel.config.js</figcaption></figure><p id="c4e0" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">上面代码注释的注释:</p><p id="c553" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这告诉webpack将ES6+特性转换成JS代码，这在Node.js和(最现代的)浏览器中是本地支持的。阅读<a class="ae ks" href="https://babeljs.io/docs/en/babel-preset-env" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多详情。</p><p id="79aa" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[B]</strong></code>这告诉webpack将React JSX转换成JavaScript代码。阅读<a class="ae ks" href="https://babeljs.io/docs/en/babel-preset-react" rel="noopener ugc nofollow" target="_blank">文件</a>了解更多详情。</p><h2 id="94eb" class="nm lx in bd ly nx ny dn mc nz oa dp mg lj ob oc mi ln od oe mk lr of og mm oh bi translated">客户端webpack配置</h2><p id="4a25" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">安装相关的依赖项:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="240f" class="nm lx in ni b gy nn no l np nq">npm i webpack webpack-cli webpack-merge webpack-dev-server mini-css-extract-plugin css-loader less-loader less</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">webpack.client.config.js</figcaption></figure><p id="7c20" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">上面代码注释的注释:</p><p id="cdfc" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[A]</strong></code>这是客户端代码的入口点，我们在这里将React应用程序渲染到DOM中。</p><p id="a9df" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[B]</strong></code>这告诉webpack将传输的客户端JS包输出保存为<code class="fe ns nt nu ni b">./build/client/scripts/bundle.js</code>。这对于开发模式来说并不重要，因为我们使用<code class="fe ns nt nu ni b">webpack-dev-server</code>在内存中传输客户端包。根据<a class="ae ks" href="https://webpack.js.org/guides/development/#using-webpack-dev-server" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="oj ok ol"><p id="2e79" class="la lb om lc b ld le jo lf lg lh jr li on lk ll lm oo lo lp lq op ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><em class="in">webpack-dev-server</em></code>编译后不写任何输出文件。相反，它将包文件保存在内存中，并像它们是挂载在服务器根路径上的真实文件一样提供服务。</p></blockquote><p id="89b1" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[C]</strong></code><code class="fe ns nt nu ni b">publicPath</code>选项告诉webpack我们将在哪里提供客户端捆绑包。注意，我们对<code class="fe ns nt nu ni b">devServer</code>使用了相同的<code class="fe ns nt nu ni b">clientPort</code>，它告诉<code class="fe ns nt nu ni b">webpack-dev-server</code>服务来自<code class="fe ns nt nu ni b"><a class="ae ks" href="http://localhost:8080/." rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a></code>的客户端包。由于<code class="fe ns nt nu ni b">filename</code>选项告诉webpack将<code class="fe ns nt nu ni b">bundle.js</code>嵌套在一个<code class="fe ns nt nu ni b">scripts</code>文件夹中，客户端包将由<code class="fe ns nt nu ni b"><a class="ae ks" href="http://localhost:8080/scripts/bundle.js" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/scripts/bundle.js</a></code>提供服务。</p><p id="84c3" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[D]</strong></code> <a class="ae ks" href="https://css-tricks.com/css-modules-part-1-need/" rel="noopener ugc nofollow" target="_blank"> CSS模块</a>和CSS预处理器(如Less，Sass)值得一文。但是简单地说，这段配置告诉webpack:</p><ul class=""><li id="697e" class="mt mu in lc b ld le lg lh lj mv ln mw lr mx lv nr mz na nb bi translated">将文件转换成浏览器理解的CSS代码，</li><li id="92ac" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated">允许我们对导入它的组件进行本地范围<strong class="lc io"/>的<code class="fe ns nt nu ni b">import style from ‘./style.less’</code>(也就是说，随着应用程序的增长，我们不必担心CSS类命名冲突或特殊性问题)，</li><li id="2205" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated">生成一个独立于JS包的CSS包。在这种情况下，<code class="fe ns nt nu ni b">MiniCssExtractPlugin</code>告诉webpack在开发模式下提供来自<code class="fe ns nt nu ni b">http://localhost:8080/styles/bundle.css</code>的CSS包。</li></ul><p id="f4ba" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[E]</strong></code>还记得<code class="fe ns nt nu ni b">webpack.shared.config.js</code>吗？这条线将<code class="fe ns nt nu ni b">webpack.shared.config.js</code>与<code class="fe ns nt nu ni b">webpack.client.config.js</code>合并。</p><h2 id="dd31" class="nm lx in bd ly nx ny dn mc nz oa dp mg lj ob oc mi ln od oe mk lr of og mm oh bi translated">服务器端webpack配置</h2><p id="e7a9" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">坚持住，这是我们将讨论的最后一个webpack配置。</p><p id="5200" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">安装相关的依赖项(并获取一个☕️):</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="2cb5" class="nm lx in ni b gy nn no l np nq">npm i webpack webpack-cli webpack-node-externals css-loader</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">webpack.server.config.js</figcaption></figure><p id="78bd" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">上面代码注释的注释:</p><p id="d615" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[A]</strong></code>默认值是<strong class="lc io"> web </strong>，所以我们需要显式地将它设置为<strong class="lc io">节点</strong>，这样webpack才能在服务器端代码上发挥它的魔力。</p><p id="8892" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[B]</strong></code>这是服务器端代码的入口点。</p><p id="e863" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[C]</strong></code>这告诉webpack将传输的服务器端JS包输出保存为<code class="fe ns nt nu ni b">./build/server/bundle.js</code>。</p><p id="0690" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[D]</strong></code>这告诉webpack不要将来自<code class="fe ns nt nu ni b">node_modules</code>的代码包含在服务器端包中。</p><p id="d083" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[E]</strong></code>这告诉webpack不要在服务器端的CSS代码上做任何工作，而只是确保每个HTML元素的<code class="fe ns nt nu ni b">className</code>都与客户端的CSS代码相匹配。</p><p id="9a6e" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[F]</strong></code>还记得<code class="fe ns nt nu ni b">webpack.shared.config.js</code>吗？这条线将<code class="fe ns nt nu ni b">webpack.shared.config.js</code>与<code class="fe ns nt nu ni b">webpack.server.config.js</code>合并。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="7d30" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">反应组分</h1><p id="a3da" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">安装相关的依赖项:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="3ca0" class="nm lx in ni b gy nn no l np nq">npm i react</span></pre><p id="b1e0" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们创建一个简单的React组件<code class="fe ns nt nu ni b">App</code>，它用一些基本样式呈现我们最喜欢的问候语，以及一个单击时显示警告对话框的按钮。我们将在服务器端呈现这个组件，并在客户端合成它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">client/components/App/index.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">client/components/App/style.less</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="eabe" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">服务器端代码</h1><p id="efe9" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">安装相关的依赖项:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="64d0" class="nm lx in ni b gy nn no l np nq">npm i express react react-dom</span></pre><p id="8bdf" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们创建一个Express服务器，并定义一个当用户访问<code class="fe ns nt nu ni b"><a class="ae ks" href="http://localhost:3000/." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a></code>时为HTML页面提供服务的路由</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">server/index.js</figcaption></figure><p id="f4ac" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">上面代码注释的注释:</p><p id="8297" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[A]</strong></code>这将React组件<code class="fe ns nt nu ni b">App</code>转换成HTML字符串，然后我们将它插入到ID为<strong class="lc io">“SSR-app”的<code class="fe ns nt nu ni b">div</code>之间。</strong></p><p id="0118" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><code class="fe ns nt nu ni b"><strong class="lc io">[B]</strong></code>还记得<code class="fe ns nt nu ni b">webpack.client.config.js</code>中的<code class="fe ns nt nu ni b">devServer</code>选项在dev模式下启动<code class="fe ns nt nu ni b">webpack-dev-server</code>吗？这些脚本和链接标签告诉浏览器分别从运行在<code class="fe ns nt nu ni b"><a class="ae ks" href="http://localhost:8080." rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></code>上的<code class="fe ns nt nu ni b">webpack-dev-server</code>获取客户端JS和CSS包。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="951a" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">客户端代码</h1><p id="7979" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">安装相关的依赖项:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="48fd" class="nm lx in ni b gy nn no l np nq">npm i react react-dom</span></pre><p id="4364" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在客户端入口点，我们将把经过SSR处理的React组件"<a class="ae ks" href="https://reactjs.org/docs/react-dom.html#hydrate" rel="noopener ugc nofollow" target="_blank"/>"合并到ID为<strong class="lc io"> "ssr-app" </strong>的根DOM容器中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">client/index.js</figcaption></figure><p id="06cf" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">根据<a class="ae ks" href="https://reactjs.org/docs/react-dom-server.html#rendertostring" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="oj ok ol"><p id="bb3a" class="la lb om lc b ld le jo lf lg lh jr li on lk ll lm oo lo lp lq op ls lt lu lv ig bi translated">如果您在已经有这个服务器呈现的标记的节点上调用<code class="fe ns nt nu ni b"><a class="ae ks" href="https://reactjs.org/docs/react-dom.html#hydrate" rel="noopener ugc nofollow" target="_blank"><em class="in">ReactDOM.hydrate()</em></a></code>，React将保留它，并且只附加事件处理程序，让您有一个非常好的首次加载体验。</p></blockquote><p id="3f5d" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">所以在这个例子中，客户端代码只需附加按钮的click处理程序，而不必在<code class="fe ns nt nu ni b">App</code>组件中重新呈现任何标记。</p><h1 id="aa69" class="lw lx in bd ly lz oq mb mc md or mf mg jt os ju mi jw ot jx mk jz ou ka mm mn bi translated">把所有的放在一起</h1><p id="55c1" class="pw-post-body-paragraph la lb in lc b ld mo jo lf lg mp jr li lj mq ll lm ln mr lp lq lr ms lt lu lv ig bi translated">安装相关的依赖项:</p><pre class="kd ke kf kg gt nh ni nj nk aw nl bi"><span id="0de0" class="nm lx in ni b gy nn no l np nq">npm i rimraf webpack webpack-cli webpack-dev-server npm-run-all nodemon</span></pre><p id="cf20" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这是<code class="fe ns nt nu ni b">package.json</code>文件中的<code class="fe ns nt nu ni b">scripts</code>键，在这里我们定义了几个<code class="fe ns nt nu ni b">npm</code>脚本来构建并在开发模式下启动应用程序。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">package.json</figcaption></figure><p id="d3e9" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们来看看每一个:</p><ul class=""><li id="c4fb" class="mt mu in lc b ld le lg lh lj mv ln mw lr mx lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">clear</code> —使用<a class="ae ks" href="https://github.com/isaacs/rimraf" rel="noopener ugc nofollow" target="_blank"> rimraf </a>删除<code class="fe ns nt nu ni b">./build</code>文件夹。</li><li id="46e6" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">build:server</code> —这告诉webpack构建服务器端代码并将包输出保存到<code class="fe ns nt nu ni b">./build/server/bundle.js</code>(根据<code class="fe ns nt nu ni b">./webpack.server.config.js</code>)。</li><li id="2c4a" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">start:server</code> —这将在<code class="fe ns nt nu ni b">http://localhost:3000</code>启动快速服务器。</li><li id="b1df" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">dev:server</code> —这使用<a class="ae ks" href="https://github.com/remy/nodemon" rel="noopener ugc nofollow" target="_blank"> nodemon </a>来监控工作目录中的任何文件更改(减去<code class="fe ns nt nu ni b">./build</code>)，并使用<a class="ae ks" href="https://github.com/mysticatea/npm-run-all" rel="noopener ugc nofollow" target="_blank"> npm-run-all </a>来在有文件更改时重新运行<code class="fe ns nt nu ni b">clear</code>、<code class="fe ns nt nu ni b">build:server</code>和<code class="fe ns nt nu ni b">start:server</code>。</li><li id="ced3" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">dev:client</code> —这告诉webpack“构建”客户端代码，将包输出保存在“内存”中，并从<code class="fe ns nt nu ni b">http://localhost:8080</code>提供服务(根据<code class="fe ns nt nu ni b">./webpack.client.config.js</code>)。</li><li id="8682" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><code class="fe ns nt nu ni b">dev</code> —这用一个命令运行上述所有操作。</li></ul><p id="4152" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在终端中运行<code class="fe ns nt nu ni b">npm run dev</code>启动SSR应用程序。在浏览器中打开<code class="fe ns nt nu ni b">http://localhost:3000</code>。🎉🥳</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/bcc83ab30122af62d4e5e6cdbb8a4910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ht6aRr0glttBE5TlouMJJQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Server-side rendering and client-side hydration</figcaption></figure><p id="0eb2" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">并点击按钮<code class="fe ns nt nu ni b">Say Hello Back!</code>🙌🎊</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/4d421118f5e3caca0d1a5eb3d4b46a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcnDOG4whmExaBhNoyG8Vg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Clicking the button triggers the alert dialog</figcaption></figure><p id="c68b" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在，让我们禁用客户端JavaScript…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/cac2b442267457271e9bca8fb963e6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43qx5zcj8QnwSjXQT-Nhsw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Disable client-side JavaScript</figcaption></figure><p id="48b0" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">…并刷新页面。这不是一张白纸！🤯</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/9f805e771a7670ee9d97b60ca984744b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFgBAnbm-9c3gN6J_yA1eg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Server-side rendered page</figcaption></figure><p id="f788" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">旁注:如果你点击按钮，什么也不会发生。这是因为事件处理程序是由客户端代码附加的(也称为“水合”)。召回<a class="ae ks" href="https://reactjs.org/docs/react-dom-server.html#rendertostring" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="oj ok ol"><p id="2c2d" class="la lb om lc b ld le jo lf lg lh jr li on lk ll lm oo lo lp lq op ls lt lu lv ig bi translated">如果您在已经有这个服务器呈现的标记的节点上调用<code class="fe ns nt nu ni b"><a class="ae ks" href="https://reactjs.org/docs/react-dom.html#hydrate" rel="noopener ugc nofollow" target="_blank"><em class="in">ReactDOM.hydrate()</em></a></code>，React将保留它，并且只附加事件处理程序，让您有一个非常好的首次加载体验。</p></blockquote><p id="4316" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">因为我们禁用了客户端JavaScript，所以你看到的只是普通的HTML。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/e846e8aaf068047842beaafe5a3f437a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGp1Ds4XtlabyFoGwI2G1A.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Source: <a class="ae ks" href="https://www.thecoderpedia.com/blog/programming-memes/" rel="noopener ugc nofollow" target="_blank">CoderPedia</a></figcaption></figure><p id="29e4" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">将来(差不多)😅🤞🏻)的文章，我计划涵盖更多高级特性，如路由、数据获取、缓存、代码分割、延迟加载和部署生产应用程序。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="a043" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">资源</h1><ul class=""><li id="46bc" class="mt mu in lc b ld mo lg mp lj oy ln oz lr pa lv nr mz na nb bi translated">由<a class="ae ks" href="https://twitter.com/gagliardi_vale" rel="noopener ugc nofollow" target="_blank">瓦伦蒂诺·加利亚迪</a>撰写的网络包5 的基本完整指南</li><li id="991f" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><a class="ae ks" href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them#:~:text=Transpilers,%20or%20source-to-,are%20said%20to%20target%20JavaScript." rel="noopener ugc nofollow" target="_blank">JavaScript trans pilers:What&amp;Why</a>by<a class="pb pc ep" href="https://medium.com/u/1baf735d9bdc?source=post_page-----3c2af3782d08--------------------------------" rel="noopener" target="_blank">Peleke seng stack</a></li><li id="2a1b" class="mt mu in lc b ld nc lg nd lj ne ln nf lr ng lv nr mz na nb bi translated"><a class="ae ks" href="https://css-tricks.com/css-modules-part-1-need/" rel="noopener ugc nofollow" target="_blank">什么是CSS模块，我们为什么需要它们？</a>作者<a class="pb pc ep" href="https://medium.com/u/aae529a3f8b0?source=post_page-----3c2af3782d08--------------------------------" rel="noopener" target="_blank">罗宾·伦德尔</a></li></ul></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="b9ba" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">阅读更多</h1><div class="pd pe gp gr pf pg"><a href="https://medium.com/javascript-in-plain-english/decouple-data-from-ui-with-react-hooks-6f7fe968c3e3" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd io gy z fp pl fr fs pm fu fw im bi translated">用React钩子将数据从UI解耦</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">以及我如何用JavaScript函数“编程到一个接口”</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu km pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a href="https://medium.com/javascript-in-plain-english/how-to-decouple-data-from-ui-in-react-d6b1516f4f0b" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd io gy z fp pl fr fs pm fu fw im bi translated">在React第2部分中将数据与UI解耦</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">对钩子、渲染道具和特设模式的进一步探索</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="pv l pr ps pt pp pu km pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a href="https://tech.boxed.com/accessible-ui-stop-making-clickable-divs-264115938716" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd io gy z fp pl fr fs pm fu fw im bi translated">可访问的UI:停止制作可点击的div</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">一次访问一个(少一个)分区。</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">tech.boxed.com</p></div></div><div class="pp l"><div class="pw l pr ps pt pp pu km pg"/></div></div></a></div></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="40f2" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">📫<em class="om">我们连线上</em><a class="ae ks" href="https://www.linkedin.com/in/suhanwijaya/" rel="noopener ugc nofollow" target="_blank"><em class="om">LinkedIn</em></a><em class="om">或者</em><a class="ae ks" href="https://twitter.com/suhanw" rel="noopener ugc nofollow" target="_blank"><em class="om">Twitter</em></a><em class="om">！</em></p></div></div>    
</body>
</html>