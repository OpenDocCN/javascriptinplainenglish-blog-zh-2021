<html>
<head>
<title>Is “Don’t Pollute the Global Namespace” Still Good Advice in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“不要污染全局命名空间”在JavaScript中还是好建议吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/revisiting-javascripts-global-namespace-4e21ed6fd049?source=collection_archive---------6-----------------------#2021-07-22">https://javascript.plainenglish.io/revisiting-javascripts-global-namespace-4e21ed6fd049?source=collection_archive---------6-----------------------#2021-07-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1d39b37d5c2ad8673353d2bd37d67bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGvvpySeDDb93JBK0DbMuQ.jpeg"/></div></div></figure><p id="f659" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你是一名JavaScript开发人员，你可能听说过这样一句话，“不要污染全局名称空间。”这条经验法则已经为开发人员节省了很多时间，并且仍然有一些优点。然而，JavaScript的进步已经让位于以更安全的方式使用“全局”空间的新机会。</p><h2 id="8097" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">原创思维</h2><p id="1a4b" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">JavaScript开发人员最初接受“脚本”思维。这与今天更常见的“应用程序开发”的心态非常不同。在那个时期，脚本库开始出现，比如jQuery。jQuery库使用一个<code class="fe lr ls lt lu b">$</code>符号作为全局名称空间(名称空间只是一个全局对象)。通过使用对象，可以将属性创建为方法，比如<code class="fe lr ls lt lu b">$.ajax()</code>，它被定义为:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="e9c6" class="kt ku in lu b gy md me l mf mg">window.$ = {<br/>  ajax: function () {...},<br/>  ...<br/>}</span></pre><p id="f32b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这种方法容易出现域名冲突</strong>。换句话说，如果在应用程序中使用jQuery，<code class="fe lr ls lt lu b">$</code>将不可用。随着越来越多的库开始出现，可用的名字越来越少。一些图书馆开始共享名称。这使得在不修改其中一个库的情况下不可能使用两个不同的库，因为它们都试图使用相同的全局变量名。</p><p id="83d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了防止命名冲突，专家们将这种做法称为“全球命名空间的污染”。</p><p id="25e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mh">全局名称空间污染示例:</em></p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="712b" class="kt ku in lu b gy md me l mf mg">var x = 10<br/>var y = 2</span><span id="0e32" class="kt ku in lu b gy mi me l mf mg">function add() {<br/>  return x + y<br/>}</span></pre><p id="3833" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有未限定作用域的变量(x、y和add)“污染”了全局名称空间。</p><p id="d486" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">替代方案</strong>是创建一个单独的全局名称空间来隔离应用程序代码。例如:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="c4ca" class="kt ku in lu b gy md me l mf mg">var MyNamespace = {<br/>  x: 10,<br/>  y: 2,<br/>  add: function () {<br/>    return x + y<br/>  }<br/>}</span><span id="8b31" class="kt ku in lu b gy mi me l mf mg">MyNamespace.add(1, 1)</span></pre><p id="0c02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码更好，因为只有“MyNamespace”存在于全局范围内。尽管这仍然不是一个完美的解决方案。确实没有办法使用基于字符串的变量名在全局级别上唯一地标识某些东西。</p><h2 id="6ad0" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">JavaScript进化</h2><p id="a7ef" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">ECMAScript(JavaScript的规范)从jQuery的巅峰时期开始经历了巨大的转变。这种语言继续快速发展，比其他任何被广泛采用的编程语言都要快。</p><p id="9387" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现代JavaScript中有两个更新的功能改变了我们在全局范围内可以做的事情:<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">模块</strong> </a>和<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">符号</strong> </a>。</p><h2 id="d7b9" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">模块很重要</h2><p id="f742" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">如果您熟悉模块，您可能已经知道全局名称空间惟一性已经成为可能。例如，可以为模块动态分配新名称，如下所示:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="4bb5" class="kt ku in lu b gy md me l mf mg">import MyNamespace as Different from 'https://domain.com/code.js'<br/>import { something as Renamed } from 'https://domain.com/code.js'</span></pre><p id="c038" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这部分解决了全局名称空间污染问题，但不是完整的解决方案。</p><p id="6d68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mh">有依赖关系问题需要考虑</em>。</p><p id="dd14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模块是隔离的，这意味着很难与其他模块集成。</p><p id="22f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">现实世界中的依赖性挑战:</strong></p><p id="6258" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多年来，我一直默默致力于一个名为<a class="ae mj" href="https://github.com/ngnjs/ngn" rel="noopener ugc nofollow" target="_blank"> NGN </a>的JS库。它在浏览器、Node.js和Deno中工作。我用它来构建框架、系统、API、桌面软件、ETL过程，甚至还被用来创建UI框架(JET)。</p><p id="0b54" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">核心库是围绕一个强大的事件发射器构建的，它被许多其他组件使用。还有一个非常强大的网络通信库、数据管理库、lexer/tokenizer(用于创建您自己的标记/查询语言)和许多其他功能，这些功能都包含在一个非常小的空间中。但是；大多数应用程序只需要可用功能的一个子集。将<em class="mh">所有的东西</em>捆绑在一起是没有意义的。将库拆分成单独的模块允许开发人员只使用他们需要的东西，但是这会产生内部依赖性。一些模块将依赖于其他模块，这是一个难题。</p><p id="1762" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果您只想使用网络组件和核心事件发射器，您可能需要如下代码:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="8fb8" class="kt ku in lu b gy md me l mf mg">1. import {EventEmitter} from '<a class="ae mj" href="https://cdn.jsdelivr.net/npm/ngn@2.0.0-alpha.8/index.min.js" rel="noopener ugc nofollow" target="_blank">http://jsdelivr.net/npm/ngn/index.js</a>'<br/>2. import NET from '<a class="ae mj" href="https://cdn.jsdelivr.net/npm/ngn@2.0.0-alpha.8/index.min.js" rel="noopener ugc nofollow" target="_blank">http://jsdelivr.net/npm/@ngnjs/net/index.js</a>'<br/>3. <br/>4. class MyThing extends EventEmitter {...}<br/>5. const API = new NET.Resource(...)</span></pre><p id="8ab5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题出在第5行。NET库有扩展核心的内部类<code class="fe lr ls lt lu b">EventEmitter</code>。ES模块在导入时检测到<code class="fe lr ls lt lu b">EventEmitter</code>库<em class="mh">，使得网络库无法访问。要将每一个作为<em class="mh">独立的</em>模块打包/发布，需要将核心<code class="fe lr ls lt lu b">EventEmitter</code>捆绑到每个组件中。使用上面的代码，这意味着<code class="fe lr ls lt lu b">EventEmitter</code>代码将被下载两次<em class="mh"/>(一次在NGN导入，再次在. NET导入)。</em></p><p id="0fcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当增加更多依赖核心的库时，T21的问题就更复杂了。<code class="fe lr ls lt lu b">EventEmitter</code>会被第三次下载吗？第四个？在Node中同样具有挑战性，因为您需要<code class="fe lr ls lt lu b">npm install</code>额外的软件包。节点应用程序可能并不总是像浏览器应用程序那样拥有运行时互联网访问。</p><p id="f5b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一大捆<em class="mh"> </em>增加的<em class="mh">优势是简单。如果您只需要/关心其中一个库，很容易导入:</em></p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="3f5f" class="kt ku in lu b gy md me l mf mg">import NET from '<a class="ae mj" href="https://cdn.jsdelivr.net/npm/ngn@2.0.0-alpha.8/index.min.js" rel="noopener ugc nofollow" target="_blank">http://jsdelivr.net/npm/@ngnjs/net/index.js</a>'</span></pre><p id="d405" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自2013年以来，我一直在使用不同形式的“图书馆收藏”，很少会出现只使用一个功能的情况。捆绑过程很有效，并不会阻止我使用我需要的东西，但是这种方法的带宽滥用<strong class="jx io"> <em class="mh">真的</em> </strong>让我恼火。</p><h2 id="1938" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">全球变量出手相救？</strong></h2><p id="29d7" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">假设JavaScript社区不会因为使用全局变量而大吵大闹名称空间谋杀。每个非核心模块(如network lib)都可以检查全局名称空间中核心库的存在，如果不存在就抛出一个错误/警告。这就避免了在每个模块中捆绑冗余代码的需要，而开发人员需要导入核心库。还有其他好处，比如确切地知道你的应用程序里有什么。</p><p id="6ea1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对每个系统库的全局引用肯定会使互操作性更容易，最小化带宽/内存需求，并简化绑定过程。这看起来像是一个胜利，除了讨厌的“不要污染全球命名空间”咒语。认识到这一点后，我渴望有一个全球注册中心来简化这一切。输入符号。</p><h2 id="be8d" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">作为符号的全局引用</h2><p id="fbe6" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" rel="noopener ugc nofollow" target="_blank">符号</a>是一种<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank"> JavaScript原语</a>，就像数字、字符串、布尔等一样。它们是独一无二的，应该从字面上理解。它们绝对是独一无二的。</p><p id="c85e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您不熟悉符号，请尝试运行以下代码:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="430d" class="kt ku in lu b gy md me l mf mg">console.log(Symbol() === Symbol()) // This will always be "false"</span></pre><p id="70ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在考虑一下这个:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="df02" class="kt ku in lu b gy md me l mf mg">globalThis[Symbol()]</span></pre><p id="c2f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码保证是唯一的“全局名称空间”。您可以向全局名称空间添加任意数量的符号，它们永远不会发生冲突。这是因为符号在<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Glossary/symbol#Global_symbol_registry" rel="noopener ugc nofollow" target="_blank">全局符号注册表</a>中保证是唯一的。</p><blockquote class="mk ml mm"><p id="5c39" class="jv jw mh jx b jy jz ka kb kc kd ke kf mn kh ki kj mo kl km kn mp kp kq kr ks ig bi translated">注意:Symbol.for()将总是返回对符号的相同引用。因此，它<strong class="jx io">可能</strong>污染全局名称空间。几率还是比较低的，因为<code class="fe lr ls lt lu b">globalThis[Symbol.for('mylib')</code>和<code class="fe lr ls lt lu b">globalThis['mylib']</code>不一样。它实际上只是一个隐藏的全局名称空间。这仍然是一把双刃剑，如果没有适当的治理，最初的“不要污染全球名称空间”的咒语仍然适用。换句话说，这种方法可能在像公司网络这样的可信/封闭环境中工作，但是对于向公众发布的代码可能不太好。</p></blockquote><h2 id="1318" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">在实践中使用全局符号</h2><p id="906c" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">这种方法有一个问题。为了访问全局引用，您需要对符号的引用。为了突出这一挑战，请考虑以下情况:</p><p id="02a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模块1:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="454b" class="kt ku in lu b gy md me l mf mg">globalThis[Symbol('mylib')] = {<br/>  EventEmitter: MyEventEmitter<br/>}</span></pre><p id="c8af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模块2:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="301e" class="kt ku in lu b gy md me l mf mg">let EventEmitter = globalThis[Symbol('mylib')].EventEmitter</span><span id="93ee" class="kt ku in lu b gy mi me l mf mg">export default class Network extends EventEmitter {<br/>  ...<br/>}</span></pre><p id="e9a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">模块2将出现故障。</strong>请记住，<code class="fe lr ls lt lu b">Symbol('mylib')</code>每次调用都会创建一个新的独特符号。</p><p id="ffb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，使用变量传递符号引用，如下所示:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="14b2" class="kt ku in lu b gy md me l mf mg">const REF = Symbol('mylib')<br/>globalThis[REF] = ...</span></pre><p id="09ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而；<code class="fe lr ls lt lu b">REF</code>变量不能“传递”给另一个模块。它也不能作为模块导出，因为这样做的目的是确定另一个模块是否存在。</p><h2 id="87db" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">这听起来不可能。全局符号实际上能起作用吗？</strong></h2><p id="6269" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">虽然解决方案并不像我个人喜欢的那样干净/直接，但还是有办法可以做到的。就我而言，这种权衡是可以接受的。下面的实验详细描述了这些方法、权衡以及我是如何评估它们的。</p><p id="d8ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">实验1:全局符号查找</strong></p><p id="924b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用查找，库可以扫描符号的全局范围，遍历它们来搜索重要的符号。例如:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="da88" class="kt ku in lu b gy md me l mf mg">const references = Object.<strong class="lu io">getOwnPropertySymbols</strong>(globalThis).filter(id =&gt; {<br/>  return globalThis[id].hasOwnProperty('mylib')<br/>})</span></pre><p id="d55b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码遍历全局范围内的所有唯一符号，并检查它们是否有一个名为<code class="fe lr ls lt lu b">mylib</code>的属性。这将返回一个数组，起初这让我很困扰，因为我想要一个对我的库的引用。经过思考，我意识到支持对一个库的多个版本的引用是可能的。这对于迁移、测试和其他目的非常有用。</p><p id="4a42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法的主要挑战是确保您的库有一种一致且唯一的方式来标识自己。任何依赖项都需要能够执行相同的查找并获得相同的结果。作为一个库作者，这意味着保持纪律。根据我自己的经验，这是这个过程中相当琐碎的一部分。然而；并没有真正解决原来的问题。另一个库仍然有可能使用这种技术，同时给它们的库取与另一个库相同的名字。这只是比与典型的全局定义变量发生冲突的可能性小一点<em class="mh"/><em class="mh">。</em></p><p id="4124" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">实验2:半安全查找</strong></p><p id="ea83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我仍然为需要遍历每个全局符号而烦恼。只是<em class="mh">觉得</em>没有必要。我决定使用<code class="fe lr ls lt lu b">Symbol.for</code>创建一个符号引用。这允许更直接的查找，这<em class="mh">不太可能</em>与全局范围中的某些东西冲突。例如:</p><p id="9877" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mh"> NGN核心文件:</em></p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="9289" class="kt ku in lu b gy md me l mf mg">const NGN = ...<br/>export { NGN as default, NGN, EventEmitter, .... }</span><span id="4e30" class="kt ku in lu b gy mi me l mf mg">const ID = Symbol.for('NGN')<br/>globalThis[ID] = globalThis[ID] || new Map()<br/>globalThis[ID].set(NGN.version, NGN)</span></pre><p id="9248" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">网络库文件:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="6d80" class="kt ku in lu b gy md me l mf mg">const ID = Symbol.for('NGN')<br/>const core = globalThis[ID]</span><span id="bbc0" class="kt ku in lu b gy mi me l mf mg">if (core.size === 0) {<br/>  throw new Error('The network library is dependent on NGN core.')<br/>}</span><span id="08a4" class="kt ku in lu b gy mi me l mf mg">if (!core.has('2.0.0')) {<br/>  throw new Error('The network library requires NGN 2.0.0')<br/>}</span><span id="4c98" class="kt ku in lu b gy mi me l mf mg">const NGN = core.get('2.0.0')</span><span id="113a" class="kt ku in lu b gy mi me l mf mg">export default class Network extends NGN.EventEmitter {<br/>  ...<br/>}</span></pre><p id="2d72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这也是可行的，但是仍然有可能出现命名冲突，因为<code class="fe lr ls lt lu b">Symbol.for('NGN')</code>可能会被另一个库使用或者被用户创建。这个问题有点像唯一ID问题(UUID/GUID)，在某种程度上，冲突的可能性非常小，以至于我们可能不会活到看到它真正发生的时候。</p><p id="ca15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实验三:混血儿</p><p id="16b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我决定尝试最后一种方法，使用半安全的全局符号作为查找索引。</p><p id="89ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mh"> NGN核心文件:</em></p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="a097" class="kt ku in lu b gy md me l mf mg">const Reference = Symbol() // Guaranteed to be unique<br/>const NGN = ...<br/>export { NGN as default, NGN, EventEmitter, Reference, .... }</span><span id="682a" class="kt ku in lu b gy mi me l mf mg">globalThis[Reference] = NGN</span><span id="5dc1" class="kt ku in lu b gy mi me l mf mg">try {<br/>  const ID = Symbol.for('NGN')<br/>  globalThis[ID] = globalThis[ID] || new Set()<br/>  globalThis[ID].add(Reference)<br/>} catch (e) {}</span></pre><p id="d3ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码有一个专门为NGN库定义的唯一符号，它使用实验1的概念被添加到全局范围。这保证了使用查找过程可以从全局范围访问该库。</p><p id="d34a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我并不热衷于使用try/catch语句，但它确实有效。它为NGN寻找半安全的全局符号，如果它不存在就创建它(这就是<code class="fe lr ls lt lu b">Symbol.for()</code>的工作方式)。然后，它试图找到/创建一个JavaScript <a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">集</a>，用来保存对核心库实例的引用。有人可能会覆盖<code class="fe lr ls lt lu b">globalThis[ID]</code>的值，但可能性不大。问题的可能性在于为什么它被包装在一个try/catch中。</p><p id="bafd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，非核心库从如下代码开始:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="687a" class="kt ku in lu b gy md me l mf mg">const instances = globalThis[Symbol.for('NGN')]<br/>let NGN</span><span id="2a51" class="kt ku in lu b gy mi me l mf mg">if (instances &amp;&amp; instances.size &gt; 0) {<br/>  for (const instance of instances) {<br/>    if (globalThis[instance].version === '2.0.0') {<br/>      NGN = globalThis[instance]<br/>      break<br/>    }<br/>  }<br/>}</span><span id="ff4a" class="kt ku in lu b gy mi me l mf mg">// fallback to scanning the global namespace<br/>if (!NGN) {<br/>  const references =<br/>    Object.<strong class="lu io">getOwnPropertySymbols</strong>(globalThis).filter(id =&gt; {<br/>      return globalThis[id].hasOwnProperty('mylib')<br/>    })<br/>  ... loop through references to find the right version<br/>}</span><span id="c5f4" class="kt ku in lu b gy mi me l mf mg">if (!NGN) {<br/>  throw new Error('NGN is required.')<br/>}</span><span id="d256" class="kt ku in lu b gy mi me l mf mg">export default class Network extends NGN.EventEmitter {<br/>  ...<br/>}</span></pre><p id="9214" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码首先尝试直接查找NGN库引用，这是最有效的方法。如果找到了，它就会继续前进。如果没有，它退回到扫描全局符号。最后，如果根本找不到引用，它就会崩溃。</p><h2 id="31fb" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">反思这些实验</h2><p id="725a" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">当我回想这些实验时，我觉得它们“精神上很庞大”。符号的使用有许多细微差别，这可能具有挑战性。符号的命名法，即<code class="fe lr ls lt lu b">Symbol()</code>和<code class="fe lr ls lt lu b">Symbol.for()</code>一开始可能很难理解，因为它们看起来非常相似，但行为却非常不同。然而；我越来越欣赏这些功能，因为它们非常强大。</p><p id="8cf4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我创建了一个小的“插件”模块来完成这些查找。这让我回到了最初的问题，即需要在库的每个部分都包含相同的重复代码。不同之处在于，与包含整个核心库相比，重复要少得多。这是一个我可以忍受的权衡。当缩小和压缩时，差别只是几个字节的开销。它使每个附加模块不必捆绑核心库(6kB)。</p><p id="dd51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我主要编写库和工具，所以这些东西对我很重要。对于那些不知道的人来说，这里仍然有几个要点。</p><ol class=""><li id="a348" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">通过符号在全局命名空间中具有唯一性是可能的。</li><li id="a592" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">不正确地使用全局符号仍然会造成全局命名空间冲突。</li></ol><p id="d52a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不会说旧的经验法则(“不要污染全局名称空间”)是过时的建议，但它感觉更像是一个“小心”标志，而不是“请勿进入”。JavaScript的进步使得解决经验法则起源的根本问题成为可能。仍然没有一个完美的答案，但肯定有进步。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="30d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您尝试了这些实验中的任何一个，或者对解决这些概念有其他想法，请分享评论或在推特上联系我，网址为<a class="ae mj" href="https://twitter.com/goldglovecb" rel="noopener ugc nofollow" target="_blank">@ gold glovercb</a>。这是我第一次写关于深入实验的文章。所以，如果你喜欢，记得为这篇文章鼓掌(并保持更多的喜欢他们的到来)！</p><p id="9bdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mh">更内容于</em> <a class="ae mj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mh">通俗地说就是</em> </strong> </a></p></div></div>    
</body>
</html>