<html>
<head>
<title>Learn JavaScript’s Most Feared Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解JavaScript最令人恐惧的特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-do-developers-fear-this-fb7497f95570?source=collection_archive---------7-----------------------#2021-03-24">https://javascript.plainenglish.io/why-do-developers-fear-this-fb7497f95570?source=collection_archive---------7-----------------------#2021-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c4fa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不要害怕“这个”关键字</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f894b9aaf4a101a89b182251c2d93bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cb_l5sx7YhGZcHoQ9NhkSQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Illustrations by <a class="ae kv" href="https://www.twitter.com/tweetsbysoma" rel="noopener ugc nofollow" target="_blank">Somnath</a></figcaption></figure><p id="f40d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有人说“<strong class="ky ir"> <em class="ls">这种“</em> </strong>是他们遇到的最令人困惑的概念。对某些人来说，<strong class="ky ir"> <em class="ls">这个</em> </strong>是最难把握的概念。有些人甚至非常讨厌它，以至于他们不惜一切代价试图在代码中避免它，因为它造成了太多的混乱。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/ee23ba5a86e63230a3f1b19ea6b452cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRg_m168BSNZQq8csnIGYA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Hoisting is covered beautifully <a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/90-of-developers-get-this-wrong-fdbdb2e4bf66?source=friends_link&amp;sk=16af24e78c923fc24c57b0172710ea62">here</a></figcaption></figure><p id="d170" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“<code class="fe lu lv lw lx b">this</code>”机制如此令人困惑，甚至对于经验丰富的JavaScript开发人员来说，人们可能会奇怪它为什么会在那里！</p><p id="a116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是不是麻烦大于值得？让我们试着解开这个谜，弄清楚<code class="fe lu lv lw lx b">this</code>到底是怎么回事。</p><p id="fd26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，确保你对JavaScript如何工作有一些基本的了解。 </p><p id="c04d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">利用它来温习您的JavaScript基础知识。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/21661b1f9ae2743d03abd16c506c3ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiH1A3Fk3UBGdxREa-RNRw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/3b9d763f1d425263468d86798335a9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OcBzxaxFxTzKKu_9uKanVg.gif"/></div></div></figure><div class="kg kh ki kj gt ab cb"><figure class="ma kk mb mc md me mf paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/0361ddcdb08c37b0e4765f8cf56d3ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*NTGuU4uhxovk3ZepEmsuFw.png"/></div></figure><figure class="ma kk mg mc md me mf paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/c310f420e306963246bda81cc00f7c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*vkml2hZnS5xlO5vZDsWCsg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk mh di mi mj">Execution Context of foo() is created and put inside the global Execution Context</figcaption></figure></div><h2 id="923c" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">打开你的开发控制台，是时候把手弄脏了！</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/f3f8da4c669d98389a63dfc3114bdba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMIfJ29QZcFu6gq03zCH8w.png"/></div></div></figure><p id="567a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键字<code class="fe lu lv lw lx b">this</code>指向代码中这一层的全局对象。在浏览器内部，全局对象就是我们所知道的<code class="fe lu lv lw lx b">Window</code>对象。</p><p id="7ce1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看另一个例子。假设我有一个函数，我称它为<code class="fe lu lv lw lx b">foo</code>，我将记录<code class="fe lu lv lw lx b">this</code>。然后我会调用<code class="fe lu lv lw lx b">foo</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/bdeb9fb61a4076f79d11874134b2bd92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUwEnbkDxnACoWw4jLuYTQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">foo is just a random name here, you can use anything!</figcaption></figure><p id="c0af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住，调用<code class="fe lu lv lw lx b">foo</code>意味着运行代码属性，它包含了函数中的所有代码行。它做的第一件事就是创建执行上下文。其中一个难题是关键字<code class="fe lu lv lw lx b">this</code>的创建。</p><p id="f115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，在通过调用<code class="fe lu lv lw lx b">foo</code>执行上下文来运行<code class="fe lu lv lw lx b">foo</code>函数而创建的执行上下文中，关键字<code class="fe lu lv lw lx b">this</code>会是什么呢？</p><p id="e34b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/8b0cec13c9727dcc5053242e2e7e40c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MqJf9Xst1WN3PDwkchbW3w.png"/></div></div></figure><p id="f58c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它也是<strong class="ky ir">窗口的</strong>对象</p><p id="7c85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，当你创建一个函数，并决定使用<code class="fe lu lv lw lx b">this</code>时，它仍然指向全局对象。</p><p id="9209" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，如果我使用一个函数表达式来设置对象，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/3ec96d926d866939fa591597973ec2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQ7D_ua66Y31vsEZ_mEGWw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">bar is just a random name here, you can use anything you wish!</figcaption></figure><p id="e20b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上案例中的<code class="fe lu lv lw lx b">this</code>会是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/13bb947941bdf2f7c877572b8381ce86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsLTtTKTLeKq1gzyEiZRUA.png"/></div></div></figure><p id="2b68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且还是<code class="fe lu lv lw lx b">Window</code>对象！</p><p id="0a11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，每当我创建一个函数或函数表达式或函数语句时，<code class="fe lu lv lw lx b">this</code>就会指向全局对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/0ae90b04a1aa778f802913d19cab08dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UriHuaAmdzfKFm0wmWNN_A.png"/></div></div></figure><p id="1880" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我们在这里实际上看到了三个执行上下文，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/10711fc3b23cd335f592dc4e1b5ce9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4BaRmHzQZU7yccc7jNJog.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The global one, the one that’s created when <code class="fe lu lv lw lx b">foo</code> is invoked, and another execution context that’s created when <code class="fe lu lv lw lx b">bar</code> is invoked.</figcaption></figure><p id="f978" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在每一种情况下，他们都有自己的<code class="fe lu lv lw lx b">this</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/d1ea464a76aa139be60bc4293df11914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jtfakvdNii8qwSzTFgUZoA.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Creation of Execution Context in action</figcaption></figure><div class="kg kh ki kj gt ab cb"><figure class="ma kk nl mc md me mf paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/29561116f238e515c4ddf7d5d50b5712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*bFyqmFUbSr566YXiu7vqQg.png"/></div></figure><figure class="ma kk nm mc md me mf paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/5da51289f8b9b9c2cb8ce61cb97556a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*ik4jj-zgblCcFvaoX5PV0A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk nn di no mj">Execution Context of foo() and bar()</figcaption></figure></div><p id="6855" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在所有这些情况下，<code class="fe lu lv lw lx b">this</code>关键字都指向你计算机内存中的同一个位置，都指向全局对象！</p><p id="6aa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有道理吗？</p><p id="8d4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着你甚至可以做一些奇怪的事情，比如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/b7f057be35ec466b1fbc2a3bce9d6fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NlTl8fBqwyBTMf6vcSDCNg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">After I call <code class="fe lu lv lw lx b">foo</code>, I can <code class="fe lu lv lw lx b">console.log(newVariable)</code>, because that has been created. Using the dot operator, I’ve attached the<code class="fe lu lv lw lx b"> newVariable</code> to the<strong class="bd nq"> global object</strong>.</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/61147c9b7a30cb7895341950dfdba3e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*thw3XEIal1qvoiA8cG3OkQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Remember, any variables attached to the global object, I can just reference like that, I don’t need to use the dot operator, it just assumes I’m asking for a variable on the global object.</figcaption></figure><p id="60b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有点奇怪，对吧？</p><p id="c2ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不明白<code class="fe lu lv lw lx b">this</code>关键字指向什么，并且你认为你在某种程度上把<code class="fe lu lv lw lx b">this</code>附加到函数上，你不是！实际上，您正在进入全局名称空间，这可能会给自己带来很多问题。</p><p id="3d96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，当你只是调用函数时，<code class="fe lu lv lw lx b">this</code>总是指向一个全局变量。</p><h2 id="c479" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">对象方法呢？</h2><p id="30cd" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">让我们从一个方法创建一个新的对象和<code class="fe lu lv lw lx b">console.log(this)</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/f2a50707041bfaf4250fd965086ea927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BirjwbQVg3VocJL2EUj9qw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">functions inside an object is called method</figcaption></figure><p id="2d79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lu lv lw lx b">this</code>会是什么？</p><p id="ed3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住，每次调用一个函数，都会创建一个新的执行上下文。JavaScript引擎决定<code class="fe lu lv lw lx b">this</code>应该指向哪里。早先是<code class="fe lu lv lw lx b"> Window </code>对象，但这里是对象上的方法。在这种情况下，函数实际上是一个附加到对象上的方法，<code class="fe lu lv lw lx b">this</code>关键字就变成了方法所在的对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/47f82581af9e0dd8abb41b6583da7d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*hiufe-jWl9DAWIPwuO8wUw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">See that?</figcaption></figure><p id="32ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里JavaScript引擎说，啊，你被附加到一个对象上。所以当你使用<code class="fe lu lv lw lx b">this</code>关键字时，我将指向包含你的那个对象。</p><p id="a793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以做一些事情，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/01354b6741d2779a1e07ccad3e10b689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilsr-g-NIjRRjQ10nskkYw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/740576939232aa2fa66a8aac4be8fcde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHqvUwSJgialxBpTI3QJ1Q.png"/></div></div></figure><p id="43d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看到了吗？我可以改变包含我的对象，如果我是那个对象的方法，通过使用<code class="fe lu lv lw lx b">this</code>关键字！</p><p id="f402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">能够访问特定方法所在的同一对象上的其他属性和方法非常有用。</p><p id="1574" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，还有一样东西要给你看！</p><p id="7221" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多人认为这是JavaScript中的一个错误。你可能会说，JavaScript中的bug是什么意思？JavaScript是一种编程语言，引擎和语言是由人设计的。决定是关于事情应该如何运作的，在这种情况下，这个决定，很多人觉得是错误的。让我展示给你看。</p><p id="c5d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我在一个方法中创建了一个函数，我们能做到吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/a3c9f8c23e4cc718c0bae2f96dc46f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUky70bF9ylHUAm_9az6jw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">setName() inside the method log()</figcaption></figure><p id="c65c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将传递一个变量给我的函数，比如说newName。</p><p id="1345" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我要说<code class="fe lu lv lw lx b">this.name = newName</code>。我正试图用<code class="fe lu lv lw lx b">newName.</code>改变我的对象</p><p id="1c70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看输出</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/ef049ee899dffb120e348a20c08e82b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7zB-rdxtcQFttlFXKRXPg.png"/></div></div></figure><p id="71e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。等等…，这不是我们所期望的！我们有吗？</p><p id="98ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们期望<code class="fe lu lv lw lx b">this</code>关键字仍然指向包含它的对象！因为它是对象内部函数内部的函数。因为<code class="fe lu lv lw lx b">this</code>关键字指向对象，你期望，再向下一个函数，它仍然指向对象，你可以改变它。</p><p id="8949" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这是个问题！我们得到了“<code class="fe lu lv lw lx b">Object Name Updated</code>”和“<code class="fe lu lv lw lx b">Object Name Updated</code>”，这意味着第二次<code class="fe lu lv lw lx b">this</code>跑，但似乎没有做任何事情！</p><p id="cf32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还是做到了？让我们来看看<code class="fe lu lv lw lx b">Window</code>物体</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/904999d05fe538652492d7e418483ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*J87WT01azd6Es2zdT5-Q4g.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Did you see that? That name property was instead created and added by the equals operator on the global object</figcaption></figure><p id="35f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着第二个内部函数当它的执行上下文被创建时，<code class="fe lu lv lw lx b">this</code>关键字指向全局对象，即使它位于我创建的对象内部。</p><p id="e767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为那是错误的。而且很多人都这样！</p><p id="f831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这就是JavaScript在这种情况下的工作方式。在这一点上我们也无能为力。</p><p id="0b06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，当我遇到这种情况时，我们能做些什么来确保我使用了正确的对象，即<code class="fe lu lv lw lx b">this</code>关键字不会导致我犯一个意外的错误。在这种情况下，我们可以使用一种非常常见的模式。</p><p id="77f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我要设置一个变量，我叫它<code class="fe lu lv lw lx b">self</code>，有人叫它<code class="fe lu lv lw lx b">that</code>，我喜欢<code class="fe lu lv lw lx b">self</code>，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/a6df89bf7785cbf259dc5b5ca94063d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8FvKqRPRL2DNTZUmyjzVQ.png"/></div></div></figure><p id="6e83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我要设置<code class="fe lu lv lw lx b">self</code> = <code class="fe lu lv lw lx b">this</code>。</p><p id="834c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生了什么？好了，现在我们有了一个新变量，<code class="fe lu lv lw lx b">self</code>。</p><p id="9410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这些都是对象，所以要通过引用设置为。</p><p id="c1ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以<code class="fe lu lv lw lx b">self</code>将指向内存中与<code class="fe lu lv lw lx b">this</code>关键字相同的位置。第4行代码中的<code class="fe lu lv lw lx b">this</code>关键字指向我的整个对象。然后为了健康起见，我们简单地到处使用<code class="fe lu lv lw lx b">self</code>，在我们通常会使用<code class="fe lu lv lw lx b">this</code>的地方，甚至在这些子函数内部。</p><p id="8941" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我就不用考虑我是否指向了正确的对象。变量<code class="fe lu lv lw lx b">self</code>仍然指向与<code class="fe lu lv lw lx b">this</code>相同的位置和内存。当我改变它时，它会更新适当的东西，在这个例子中，是我的整个对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/79cdd08fb50e5da2ad99a7d96fde23af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxoDewfGcugEKPFmNoLRnA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/0722139c5f8f15ef38ab922403578af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-iM7SGEz_9yfxIg7aFCWA.png"/></div></div></figure><p id="7e4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看那个。这是我们所期望的！不是吗？</p><h2 id="06f9" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">那么，我们学到了什么？</h2><p id="a204" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">我们了解到没有一种编程语言是完美的。它们都有自己的怪癖，JavaScript当然也不例外。但是我们可以使用一些模式来解决编程语言可能存在的任何问题。现在，我还想提一下，如果你在任何真实的JavaScript场景中工作，那么你会经常看到上面的模式。</p><p id="0db0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在ES6出现后，作为<code class="fe lu lv lw lx b">var</code>关键字和<code class="fe lu lv lw lx b">arrow</code>函数的替代物的<code class="fe lu lv lw lx b">let</code>关键字旨在解决这些问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/1e8732c1e44332c09963a92df08bed49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoG0bgS93hzA1gsSZHuvSw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">our code in es6</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/6ab6c489eafb6a19130bcc09f76a045d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYtXh_qfyTrMGVdS0Wj8aA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We achieved the same output without meddling with “this” keyword</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/ce259c9d214fd131024a75368e93ef98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5adITBkwvBJFY0v3U6WxjA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A word of advice from JavaScript Creator himself.</figcaption></figure><h1 id="75c4" class="ok ml iq bd mm ol om on mp oo op oq ms jw or jx mv jz os ka my kc ot kd nb ou bi translated">摘要</h1><ul class=""><li id="1308" class="ov ow iq ky b kz ns lc nt lf ox lj oy ln oz lr pa pb pc pd bi translated">每次调用一个函数，都会创建一个<strong class="ky ir">执行上下文</strong>。</li><li id="9f38" class="ov ow iq ky b kz pe lc pf lf pg lj ph ln pi lr pa pb pc pd bi translated"><strong class="ky ir">在每个</strong> <em class="ls">执行上下文</em>中，我们得到一个名为“<code class="fe lu lv lw lx b">this</code>”的对象</li><li id="1dce" class="ov ow iq ky b kz pe lc pf lf pg lj ph ln pi lr pa pb pc pd bi translated">当仅仅调用一个<strong class="ky ir">函数</strong>时，<code class="fe lu lv lw lx b">this</code>关键字指向<strong class="ky ir">全局对象</strong>。</li><li id="5d60" class="ov ow iq ky b kz pe lc pf lf pg lj ph ln pi lr pa pb pc pd bi translated">当函数是对象的<strong class="ky ir">方法</strong>时，<code class="fe lu lv lw lx b">this</code>关键字指向该对象。</li><li id="0108" class="ov ow iq ky b kz pe lc pf lf pg lj ph ln pi lr pa pb pc pd bi translated">然而，任何内部子函数都有问题，所以我们可以<strong class="ky ir">设置一个变量</strong>等于<code class="fe lu lv lw lx b">this</code>，然后在剩下的过程中只携带那个<strong class="ky ir">变量</strong>，以确保我们不会遇到任何无意的错误。</li><li id="255e" class="ov ow iq ky b kz pe lc pf lf pg lj ph ln pi lr pa pb pc pd bi translated">新的<strong class="ky ir"> ES6 arrow function </strong>特性的主要动机是解决基于<code class="fe lu lv lw lx b">this</code>的普通函数代码带来的困扰。</li></ul><p id="f8fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你发现这篇文章在某些方面有帮助，那么考虑与他人分享。让我知道你对此的看法，因为对我来说这很重要！</p><p id="9b11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保重！我的另一篇帖子见！</p></div></div>    
</body>
</html>