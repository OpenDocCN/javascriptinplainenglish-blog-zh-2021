<html>
<head>
<title>Best Practices for Passing Props in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中传递道具的最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-practices-passing-props-in-react-9f6706bc05a?source=collection_archive---------0-----------------------#2021-05-21">https://javascript.plainenglish.io/best-practices-passing-props-in-react-9f6706bc05a?source=collection_archive---------0-----------------------#2021-05-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/827275115324ba13f44e3d07581c38d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1hOlYReJiKG0lxH1E4JeQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Source: <a class="ae jz" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank">https://vuejs.org/</a></figcaption></figure><h1 id="e1c8" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="a872" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">React的组件编码风格最棒的一点是父元素和子元素之间定义的清晰关系。您经常会遇到这样一种情况，即父组件负责根据用户的某些操作来呈现具有不同特征或显示属性的子组件。在这种情况下，您可以传递给子组件不同的“道具”,然后在子组件内部以某种方式显示数据。</p><p id="3338" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这很有用，因为它让您可以完全独立地考虑每个组件。这被称为“关注点分离”。该组件将定义或者已经向其传递了将数据呈现到屏幕所需的所有信息。</p><h1 id="d59c" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">小道具</h1><p id="8e25" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">Props是properties的缩写，它们是通常由父组件传递给子组件的参数(如果使用Redux，情况并非总是如此)。</p><p id="005e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">将道具传递给子组件的正确方式如下:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7de2" class="mk kb in mg b gy ml mm l mn mo">function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Welcome name="Sara" /&gt;<br/>      &lt;Welcome name="Cahal" /&gt;<br/>      &lt;Welcome name="Edite" /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="215d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这个例子中，App是父节点，Welcome是子节点。属性“name”被传递到每个欢迎组件中。</p><p id="2908" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，在Welcome中，您将可以通过传入每个组件的prop对象来访问名称prop。无论是否传入道具，这个道具对象总是存在的。</p><h2 id="3a24" class="mk kb in bd kc mp mq dn kg mr ms dp kk lj mt mu ko ln mv mw ks lr mx my kw mz bi translated">类组件中的道具</h2><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6923" class="mk kb in mg b gy ml mm l mn mo">class Welcome extends React.Component {<br/>  render() {<br/>    return &lt;h1&gt;Hello, {<strong class="mg io">this.props.name</strong>}&lt;/h1&gt;;<br/>  }<br/>}</span></pre><p id="01ed" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在类组件中，使用语法“this.props”访问属性。</p><p id="b3ae" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在上面的示例中，向Welcome传递了名称prop，因此您可以通过访问this.props .上的name属性并将其放在花括号内，以编程方式显示该信息。</p><h2 id="05f3" class="mk kb in bd kc mp mq dn kg mr ms dp kk lj mt mu ko ln mv mw ks lr mx my kw mz bi translated">功能组件中的道具</h2><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e549" class="mk kb in mg b gy ml mm l mn mo">function Welcome(<strong class="mg io">props</strong>) {<br/>  return &lt;h1&gt;Hello, {<strong class="mg io">props.name</strong>}&lt;/h1&gt;;<br/>}</span></pre><p id="0e29" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在功能组件中，逻辑非常相似，只是语法略有变化。您需要将一个名为props的参数传递到组件的函数定义中，然后就可以在不使用这个选择器的情况下访问组件的属性。直接调用' props.propertyname '就可以了。</p><h2 id="9366" class="mk kb in bd kc mp mq dn kg mr ms dp kk lj mt mu ko ln mv mw ks lr mx my kw mz bi translated">动态传递道具</h2><p id="85f7" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">回到我们从应用程序传递到欢迎程序的例子，第一种方法是每次手动输入欢迎和名称，这对于拥有超过100个欢迎名称的大型应用程序来说不是非常干净的代码。相反，您希望映射一个包含所有名称的数组，并将一个表示名称的变量作为属性传递给每个Welcome组件。这是这样做的:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="eed3" class="mk kb in mg b gy ml mm l mn mo">names = ['<!-- -->Sara', 'Cahal', 'Edite']</span><span id="8fc1" class="mk kb in mg b gy na mm l mn mo">function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      names.map(name =&gt; &lt;Welcome name ={name}/&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="5780" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这是更简洁的代码，您可以将动态名称属性放在花括号中传递给Welcome组件。</p><h1 id="bd9e" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">破坏道具</h1><p id="6ddc" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">假设您有一个庞大的用户API，其中不仅仅附加了一个名称属性。每个用户都有与之相关的姓名、用户名、年龄、性别和出生日期。而不是像这样逐个传递这些道具:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="970b" class="mk kb in mg b gy ml mm l mn mo">function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Welcome<br/>        name="Sara"<br/>        username ="sara12"<br/>        age=23<br/>        gender=female<br/>        dob="7/12/1997"<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="d8b5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">相反，您可以将props作为对象传递，并使用ES6提供的新语法来析构它们。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9ee1" class="mk kb in mg b gy ml mm l mn mo">function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Welcome userObj = {userObj} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="62cd" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">有两种方法可以做到这一点。</p><h2 id="2b6e" class="mk kb in bd kc mp mq dn kg mr ms dp kk lj mt mu ko ln mv mw ks lr mx my kw mz bi translated">组件内部的析构</h2><p id="8f75" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这通常在类组件中完成，但如果您愿意，也可以在功能组件中完成。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b9a0" class="mk kb in mg b gy ml mm l mn mo">class Welcome extends React.Component {<br/>  <strong class="mg io">{name, username, age, gender, dob}= this.props</strong></span><span id="f58b" class="mk kb in mg b gy na mm l mn mo">  render() {<br/>    return (<br/>      &lt;h1&gt;Hello, {name}&lt;/h1&gt;;<br/>      &lt;div&gt;<br/>        Age: {age}<br/>        Gender: {gender}<br/>        Date of Birth: {dob}<br/>      &lt;/div&gt;<br/>  }<br/>}</span></pre><p id="73aa" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这段代码所做的是有效的，比如对于花括号中的每个变量，在this.props上查找一个具有相应名称的属性，并将其值赋给变量。它与这样做是一样的，但要干净得多:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7078" class="mk kb in mg b gy ml mm l mn mo">class Welcome extends React.Component {<br/><strong class="mg io">  let name = this.props.name<br/>  let username = this.props.username<br/>  let age = this.props.age<br/>  let gender = this.props.gender<br/>  let dob = this.props.dob</strong></span><span id="546c" class="mk kb in mg b gy na mm l mn mo">  render() {<br/>    return (<br/>      &lt;h1&gt;Hello, {name}&lt;/h1&gt;;<br/>      &lt;div&gt;<br/>        Age: {age}<br/>        Gender: {gender}<br/>        Date of Birth: {dob}<br/>      &lt;/div&gt;<br/>  }<br/>}</span></pre><h2 id="5934" class="mk kb in bd kc mp mq dn kg mr ms dp kk lj mt mu ko ln mv mw ks lr mx my kw mz bi translated">组件函数定义内部的析构</h2><p id="1990" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这是您在功能组件中经常看到的方式。实际上，您可以通过传递一个包含变量名的对象，在通常传入props参数的地方直接析构它。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c84e" class="mk kb in mg b gy ml mm l mn mo">function Welcome(<strong class="mg io">{name, username, age, gender, dob}</strong>) {</span><span id="d0eb" class="mk kb in mg b gy na mm l mn mo">render() {<br/>    return (<br/>      &lt;h1&gt;Hello, {name}&lt;/h1&gt;;<br/>      &lt;div&gt;<br/>        Age: {age}<br/>        Gender: {gender}<br/>        Date of Birth: {dob}<br/>      &lt;/div&gt;<br/>  }<br/>}</span></pre><p id="18e3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在你可以在JSX代码中直接访问这些变量，甚至不需要额外的代码行来析构对象。在函数定义里就可以做对！</p><p id="ae2c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="nb">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nb">plain English . io</em></a></p></div></div>    
</body>
</html>