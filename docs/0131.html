<html>
<head>
<title>7 Simple MongoDB/Mongoose Tips Make Your Code Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7个简单的MongoDB/mongose技巧让你的代码更快</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-simple-mongodb-tips-make-your-code-faster-and-optimize-f696211f1431?source=collection_archive---------1-----------------------#2021-01-08">https://javascript.plainenglish.io/7-simple-mongodb-tips-make-your-code-faster-and-optimize-f696211f1431?source=collection_archive---------1-----------------------#2021-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2dae" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">学习如何用几个技巧给你的MongoDB或Mongoose加电。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cd4f1dd1e08a70e3901b62d2dc86a774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gmBxh_lRo6_Vkvf7"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@bensow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Benjamin Sow</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cc22" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">去年圣诞节前后，我作为MongoDB的NodeJS开发人员开始了我的旅程。我知道一开始。我犯了很多菜鸟的错误，花了大量的时间在StackOverflow和GitHub中寻找合适的解决方案。经历了几次精疲力尽之后。我在MongoDB或mongoose中发现了一些小但非常有用的技巧。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="0d59" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">1.精益()</h1><p id="1699" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">当您在mongose中在结果之前执行任何查询时，mongose会执行<code class="fe mt mu mv mw b">hydrate()</code>一个模型函数，该函数用于从预先保存在DB中的现有原始数据创建一个新文档。返回的文档是mongose<code class="fe mt mu mv mw b">Document</code>类的一个实例，这个实例很重，因为它们有很多内部状态用于变更跟踪。<code class="fe mt mu mv mw b"><strong class="kv io">lean()</strong></code> <strong class="kv io"> </strong>从<code class="fe mt mu mv mw b">hydrate()</code>函数中创建一个快捷方式，使查询速度更快，占用的内存更少，但是返回的文档是普通的旧JavaScript对象(POJOs)而不是mongoose文档。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="b523" class="nb lx in mw b gy nc nd l ne nf"><em class="ng">// Module that estimates the size of an object in memory</em><br/><strong class="mw io">const sizeof = require('object-sizeof');</strong><br/><br/><strong class="mw io">const normalDoc = await MyModel.findOne();</strong><br/><em class="ng">// To enable the `lean` option for a query, use the `lean()` function.</em><br/><strong class="mw io">const leanDoc = await MyModel.findOne().lean();</strong><br/><br/><strong class="mw io">sizeof(normalDoc);</strong> <em class="ng">// &gt;= 1000</em><br/><strong class="mw io">sizeof(leanDoc);</strong> <em class="ng">// 86, 10x smaller!</em></span></pre></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="a3d9" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">2.虚拟财产</h1><p id="fe30" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">我们中的一些人已经熟悉猫鼬虚拟财产。但是这里有些隐藏行为的虚拟。基本上，virtual只是不存储在MongoDB中的MongoDB文档的计算属性。</p><p id="ca47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设有两个字符串属性:firstName和lastName。您可以创建一个虚拟属性fullName，让您可以同时设置这两个属性。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="45b2" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">const</strong> <strong class="mw io">userSchema = mongoose.Schema({<br/>  firstName: String,<br/>  lastName: String<br/>});</strong></span><span id="a1e8" class="nb lx in mw b gy nh nd l ne nf"><em class="ng">// Create a virtual property `fullName`.</em><br/><strong class="mw io">userSchema.virtual('fullName').get(function() {<br/>  return `${this.firstName} $(this.lastName}`;<br/>});<br/>const User = mongoose.model('User', userSchema);<br/><br/>let doc = await User.create({ firstName: 'Tim', lastName: 'Burton' });</strong></span><span id="f22a" class="nb lx in mw b gy nh nd l ne nf"><em class="ng">// `fullName` is now a property on documents.</em><br/><strong class="mw io">doc.fullName; </strong><em class="ng">// 'Tim Burton'</em></span></pre><p id="0d17" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当您将文档转换为JSON或POJO时，Mongoose不包含virtuals。如果你使用<code class="fe mt mu mv mw b">.lean()</code>，那就意味着没有虚拟。例如，如果您将一个文档传递给<a class="ae ks" href="http://expressjs.com/en/4x/api.html#res.json" rel="noopener ugc nofollow" target="_blank">Express</a>T5】函数，默认情况下会包含<strong class="kv io">而不是</strong>。如果你想在<code class="fe mt mu mv mw b">res.json()</code>中获得虚拟，只需将<code class="fe mt mu mv mw b">toJSON</code>模式选项设置为<code class="fe mt mu mv mw b">{virtuals: true}</code>。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="8977" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">const</strong> <strong class="mw io">userSchema = mongoose.Schema({<br/>  firstName: String,<br/>  lastName: String<br/>}, { toJSON: {virtuals: true} });</strong></span></pre></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="3e0f" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">3.索引()</h1><p id="f8ce" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">当我读到MongoDB索引功能时，我感到很惊讶。您可以将MongoDB索引与SQL索引进行比较，两者几乎相同。我们可以在路径级别或模式级别的模式中定义这些索引。创建复合索引时，必须在模式级别定义索引。</p><blockquote class="ni nj nk"><p id="b63a" class="kt ku ng kv b kw kx jo ky kz la jr lb nl ld le lf nm lh li lj nn ll lm ln lo ig bi translated"><em class="in">索引支持在MongoDB中高效执行查询。如果没有索引，MongoDB必须执行集合扫描，即扫描集合中的每个文档，以选择那些匹配查询语句的文档。如果某个查询有合适的索引，MongoDB可以使用索引来限制它必须检查的文档数量。</em></p></blockquote><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="cf52" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">const userSchema= new Schema({<br/>    name: String,<br/>    email: { type: [String], index: true } </strong><em class="ng">// field level</em><strong class="mw io"><br/>  });<br/><br/>userSchema.index({ email: 1, name: -1 }); </strong><em class="ng">// schema level</em></span></pre><p id="0efa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="ng">注意:</em> </strong> <em class="ng">索引使用内存和磁盘上的临时文件的组合来完成索引构建，内存使用的默认限制是200兆字节(对于4.2.3和更高版本)和500兆字节(对于4.2.2和更低版本)。您可以通过设置</em> <code class="fe mt mu mv mw b"><a class="ae ks" href="https://docs.mongodb.com/manual/reference/parameters/#param.maxIndexBuildMemoryUsageMegabytes" rel="noopener ugc nofollow" target="_blank"><em class="ng">maxIndexBuildMemoryUsageMegabytes</em></a></code> <em class="ng">服务器参数来覆盖内存限制。</em></p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="aa79" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">4.排序()</h1><p id="5042" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">我知道sort()函数在MongoDB中很常见，但是这里我要说的是给sort()函数一些额外的功能。如果您知道默认的sort()通过区分大小写的排序来给出结果。我猜很少有读者知道MongoDB中的<code class="fe mt mu mv mw b"><strong class="kv io">collation</strong></code><strong class="kv io"/><strong class="kv io"/>选项。<code class="fe mt mu mv mw b">collation</code>允许用户指定特定语言的字符串比较规则，例如字母大小写和重音符号的规则。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="98a8" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">User.find().collation({locale:'en',strength: 1}).sort({username:1})<br/>    .then( (users) =&gt;{ <br/>        </strong>//do your stuff<br/><strong class="mw io">    }); </strong>// sort by username without case sensitivity.</span><span id="2442" class="nb lx in mw b gy nh nd l ne nf"><strong class="mw io">UserSchema.index(<br/>  {username:1}, <br/>  {collation: { locale: 'en', strength: 1}}<br/>); </strong>//<strong class="mw io"> </strong>index on <!-- -->username<!-- --> without case sensitivity.</span></pre><p id="5ca0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，<code class="fe mt mu mv mw b">locale: 'en'</code>显示集合是英文的，<code class="fe mt mu mv mw b">strength: 1</code>显示collation只对基本字符进行比较，忽略其他差异，比如音调符号和大小写。另外，<code class="fe mt mu mv mw b">collation</code>还有几个<a class="ae ks" href="https://docs.mongodb.com/manual/reference/collation/#collation-document-fields" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">选项</strong> </a> <strong class="kv io"> </strong>你可以探索一下。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="3566" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">5.实例方法</h1><p id="3a93" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">在MongoDB中，文档基本上是真实模型的小实例。MongoDB有丰富的内置实例方法。此外，MongoDB提供了定制的文档实例方法。这些方法可以访问模型对象，并且可以非常有创造性地使用它们。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="f484" class="nb lx in mw b gy nc nd l ne nf">// Define `getFullName` instance method.<br/><strong class="mw io">userSchema.methods.getFullName = function() {<br/>  return 'Mr.' + this.firstName+ ' ' + this.lastName<br/>}</strong></span><span id="5a53" class="nb lx in mw b gy nh nd l ne nf">// This method accessible via a model instance.<br/><strong class="mw io">let model = new UserModel({<br/>  firstName: 'Thomas',<br/>  lastName: 'Anderson'<br/>})</strong></span><span id="de82" class="nb lx in mw b gy nh nd l ne nf"><strong class="mw io">let initials = model.getFullName();<br/>console.log(initials)</strong> // This will output: Mr. Thomas Anderson</span></pre><p id="b207" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意:</strong> Do <strong class="kv io"> not </strong>使用ES6箭头函数(<code class="fe mt mu mv mw b">=&gt;</code>)声明方法。箭头函数<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this" rel="noopener ugc nofollow" target="_blank">显式地阻止绑定</a> <code class="fe mt mu mv mw b">this.</code>因此，你的方法<strong class="kv io">而不是</strong>可以访问文档，上面的例子将不起作用。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="91d0" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">6.静态方法</h1><p id="1d6c" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">静态方法类似于实例方法，但区别只是<code class="fe mt mu mv mw b">statics</code>是在模型上定义的方法，而<code class="fe mt mu mv mw b">methods</code>是在文档(实例)上定义的。<code class="fe mt mu mv mw b">statics</code>关键字定义了静态方法。让我们创建一个<code class="fe mt mu mv mw b">getAllUser</code>静态方法来从数据库中获取所有用户数据。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="8847" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">userSchema.statics.getAllUsers = function() {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    this.find((err, docs) =&gt; {<br/>      if(err) {<br/>        console.error(err)<br/>        return reject(err)<br/>      }<br/>      resolve(docs)<br/>    })<br/>  })<br/>}</strong></span></pre><p id="4bdb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<code class="fe mt mu mv mw b">getAllUsers</code>静态，模型类通过调用这些静态从数据库返回所有用户数据。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="a742" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">UserModel.getAllUsers()<br/>  .then(docs =&gt; {<br/>    console.log(docs)<br/>  })<br/>  .catch(err =&gt; {<br/>    console.error(err)<br/>  })</strong></span></pre><p id="bd8b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我的建议中，您应该使用<code class="fe mt mu mv mw b">statics</code>方法，而不是多次重复相同的查询。添加实例和静态方法是在集合和记录上实现数据库交互接口的好方法。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="2187" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">7.中间件</h1><p id="caca" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">中间件用于操作管道的特定阶段。Mongoose有4种类型的中间件:文档中间件、模型中间件、聚合中间件和查询中间件。</p><p id="8a36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，模型有带两个参数的<code class="fe mt mu mv mw b">pre</code>和<code class="fe mt mu mv mw b">post</code>函数:</p><ol class=""><li id="83a0" class="no np in kv b kw kx kz la lc nq lg nr lk ns lo nt nu nv nw bi translated">事件的类型(“初始化”、“验证”、“保存”、“删除”)</li><li id="42b9" class="no np in kv b kw nx kz ny lc nz lg oa lk ob lo nt nu nv nw bi translated">用引用模型实例的<strong class="kv io"> this，</strong> by <strong class="kv io"> </strong>执行的回调。</li></ol><p id="d7e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们用邮箱和密码创建<code class="fe mt mu mv mw b">userSchema</code>。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="b509" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">const userSchema= new Schema({<br/>    email: {<br/>      type: String,<br/>      unique: true </strong><em class="ng">// `email` must be unique</em><strong class="mw io"><br/>    },<br/>    password: String<br/>  });</strong></span></pre><h2 id="c1c2" class="nb lx in bd ly oc od dn mc oe of dp mg lc og oh mi lg oi oj mk lk ok ol mm om bi translated">预挂钩:</h2><p id="4ef4" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">如果你想保存密码总是加密格式。对于这一点，一个解决方案是你必须在保存之前手动加密密码，另一个解决方案是mongoose帮助你在存储到数据库之前加密你的密码字段。钩子将处理你的中间件逻辑。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="466e" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">userSchema.pre('save', function (next) {<br/>  this.password = </strong><strong class="mw io">hashPassword(this.password)</strong><strong class="mw io">; </strong>// Replace with encrypted password</span><span id="4f86" class="nb lx in mw b gy nh nd l ne nf">  // Call the next function in the pre-save chain<strong class="mw io"><br/>  next(); <br/>})</strong></span></pre><blockquote class="ni nj nk"><p id="943b" class="kt ku ng kv b kw kx jo ky kz la jr lb nl ld le lf nm lh li lj nn ll lm ln lo ig bi translated">如果任何预挂钩出错，mongoose将不会执行后续的中间件或被挂钩的功能。Mongoose将向回调传递一个错误和/或拒绝返回的承诺。</p></blockquote><h2 id="e892" class="nb lx in bd ly oc od dn mc oe of dp mg lc og oh mi lg oi oj mk lk ok ol mm om bi translated">柱钩</h2><p id="64e5" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">Post hook中间件运行在数据库和查询响应之间。这将有助于您在将查询结果发送到端点之前对其进行操作。我们再举一个例子。我们的<code class="fe mt mu mv mw b">userSchema</code>说电子邮件字段是唯一的。但是当您试图保存已经存储在数据库中的电子邮件时，MongoDB会发送一个错误，并且您的节点服务器会立即崩溃。您必须重新启动节点应用程序。</p><p id="48c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了避免节点服务器崩溃，post挂钩负责错误处理，并试图保持服务器运行。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="f5f1" class="nb lx in mw b gy nc nd l ne nf"><strong class="mw io">userSchema.post('save', function(error, doc, next) {<br/>  if (error.name === 'MongoError' &amp;&amp; error.code === 11000) {<br/>    next(new Error('There was a duplicate key error'));<br/>  } else {<br/>    next();<br/>  }<br/>});</strong></span></pre></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi on"><img src="../Images/ffed36b76af3261340e1fcaa12155924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bEQEI-F9oqzCGYGn"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Fewings</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="12d0" class="lw lx in bd ly lz oo mb mc md op mf mg jt oq ju mi jw or jx mk jz os ka mm mn bi translated">结论</h1><p id="4738" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">现在，我敢肯定，现在没有人能低估你在MongoDB中的原始技能，也永远不要试图称你为这一领域的菜鸟。我只是试着涵盖那些对你方便的功能，让你的代码更快更优化。我们仅仅触及了Mongoose的一些功能。这是一个丰富的库，充满了有用和强大的功能。祝你编码愉快。</p></div></div>    
</body>
</html>