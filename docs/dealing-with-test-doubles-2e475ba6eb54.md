# 不同类型测试双打的利与弊

> 原文：<https://javascript.plainenglish.io/dealing-with-test-doubles-2e475ba6eb54?source=collection_archive---------6----------------------->

## 比较不同类型的测试双打，并找到最适合测试您的实现。

![](img/e3ec4b1bff589a0d58497f20cbf7fbb4.png)

Photo by [**nicollazzi xiong**](https://www.pexels.com/@nicollazzi-xiong-208366?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) from [**Pexels**](https://www.pexels.com/photo/four-rock-formation-668353/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

毫无疑问，测试是软件开发中最重要的部分之一。已经开发了许多工具来简化测试过程。但是时间工程师通常不愿意写测试，因为两个原因，脆弱和缓慢的测试。

如果一个测试由于没有在产品代码中引入任何 bug 的无关变更而失败，那么这个测试就被认为是脆弱的。如果测试验证的是实现细节而不是公共 API，就会发生这种情况。

另一方面，缓慢的测试可能是由多种原因造成的。也许测试正在执行一个增加延迟的 HTTP 请求，也许测试必须模拟延迟以满足某些条件，等等。其中很少是好的，但是想象一下数百个测试用例，每个都增加了几秒钟的运行时间，测试可能需要几个小时才能完成。

在这种情况下，**测试替身**会很方便。

# 测试双打

如果术语 test double 对您来说感觉很奇怪，那是因为我们通常使用“mock”这个词来指代测试中使用的所有对象。

就像替身演员代替演员表演身体要求高的东西一样，替身演员被用来代替真实的表演。test double 是一个简单的替代对象或函数，其行为类似于真实实现的行为。当使用真正的生产服务不可行时，这是一个理想的选择。

> 你能想象每次我们运行一个测试案例时，必须实际处理信用卡支付服务的费用吗？

罗伯特·马丁(也被称为鲍勃叔叔)写了一篇名为[小嘲笑者](https://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html)的简短博文，有趣地解释了各种测试替身之间的关系。

简而言之，测试替身由假人、假货、树桩、间谍和模仿品组成。每一种都支持不同风格的测试。

在这些对象中，虚拟对象没有真正的行为，它们只是被传递来满足参数列表，而其余的工作方式略有不同。对于工程师来说，理解每种技术的工作原理及其缺点是非常有帮助的。

# 赝品

首先，我们有 fakes，一个 API、对象或函数的轻量级版本。假货的行为与真货类似，它们有商业行为，但通常采取一些捷径来简化。

这方面的一个例子是代表真实数据库的内存数据库。

假货可以在没有嘲讽框架的帮助下构建，如 [Jest](https://jestjs.io/) 或 [Sinon](https://sinonjs.org/) 。Typescript 中的伪对象示例:

有了假货，真正的实现可以换成假的。在上面的例子中，我们创建了一个假的身份验证类，它严格遵循身份验证 API 契约，只要接口匹配，这个类以后可以用来替代真正的身份验证。

围绕创建测试替身的一个相当重要的概念是*保真度*，这是一个假的行为与真实实现的行为有多接近。保真度越高越好，这意味着假货越接近生产代码，反过来，我们可以依靠它们在出现漏洞时捕捉漏洞。

然而，赝品的一个缺点是它们很难制作，维护起来也很麻烦。

# 存根和间谍

其他技术有存根和间谍。根据定义，存根化是一个将行为添加到一个原本不存在的函数中的过程。但是，也可以用来替换现有的行为，以避免处理依赖关系。

另一方面，间谍只是存根，但是它们跟踪调用，这样你就可以验证它们被调用了多少次。

开玩笑的说，树桩和间谍是一样的东西，它们可以用`jest.spyOn()`创建:

在上面的例子中，我们在`getCount`方法上添加了一个行为，这样无论如何它都会返回一个值`20`。

当需要模拟各种各样的返回值时，存根是合适的，如果我们使用真实的实现或假的，这可能是不可能的。

此外，由于 Jest 将 stub 和 spy 对象视为同一事物，这意味着我们可以验证该对象确实被调用了。

```
expect(mockCounter.getCount).toHaveBeenCalled(); // ✅
```

因为 stubbing 很容易应用，所以很容易把它当作一个简单的补丁来处理其他重要的行为。如果我们过度依赖存根来定制实现，那么与实际实现的偏差就是一个真正的问题。

# 嘲弄

您可能会注意到，到目前为止，我们所做的只是验证“状态”在给定条件下是否正确。换句话说，我们正在做一个状态验证，一个通过验证被测试系统的状态来验证被运用的方法是否正确工作的测试。

问题是，被测试的系统可能是有状态的，也可能不是，在这种情况下，我们需要使用行为验证测试，一种验证某个方法的调用的测试。这就是模仿发挥作用的地方。

模拟是预编程的对象，具有观察调用的能力。在测试过程中，用模拟的物体代替真实的物体，这是确保副作用不会发生的好方法。此外，我们还可以设置断言，如果一个函数根本没有被调用、用错误的参数调用或者调用次数过多，测试就会失败。

假设我们有一个名为`analytics`的对象，它包含几个如下所示的方法:

我们可能不想在测试期间向分析仪表板发送实际事件，但是我们确实需要确保它们被调用。

为了解决这个问题，我们可以模仿`analytics`模块:

`jest.mock('./analytics')`在这种情况下，相当于:

`jest.fn()`是一个方便的函数，它将删除一个方法的当前行为，并用一个模仿对象来替换它。这样，我们可以安全地调用`analytics.sendEvent()`进行测试，而不必担心副作用。

然后，我们可以像这样执行彻底的断言:

这种测试的一个缺点是它利用了被测系统的实现细节。我们已经接触到被测系统调用这个函数的测试。

[在本文](https://kentcdodds.com/blog/testing-implementation-details)中，Kent C. Dodds 说得很好，测试实现细节糟糕是因为两个原因:

1.  如果我们重构应用程序代码，测试可能会中断。**假阴性**
2.  如果我们破坏了应用程序代码，测试可能不会失败。**假阳性**

这两种情况都表明测试人员对被测系统的内部细节了解太多。

# 状态验证与行为验证

在测试过程中，我经常问自己的一个问题是，我应该使用模拟还是存根？

事实证明，这个问题的答案取决于执行状态验证是否比行为验证更合适。

在 Martin Fowler 的文章[中，这个决定几乎总是取决于上下文。我们谈论的是简单的合作还是相当尴尬的合作？](https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs)

如果协作很容易，例如在`Order`类和`Warehouse`类之间，我们更有可能能够使用真实的对象或存根并执行状态验证。如果是尴尬的协作，比如`Order`类和`MailService`类之间的协作，我们很可能会使用 mock 并执行行为验证。

另一个要考虑的因素是这两种测试方法与实际工作代码的相似程度。行为验证的主要问题是，我们不能确定被测系统是否正常工作，我们只能验证某个函数是否如预期的那样被调用。举个例子，如果调用了`database.save(payload)`函数，我们只能假设该项会被保存到数据库中。而使用状态验证，我们可以对数据库执行查询，以验证该项确实存在。

当然，最终，我们需要衡量两个决策之间的权衡。

# 结论

我从软件测试中学到的一件事是，不同的测试框架对测试副本的创建有不同的看法。在`jest`中，测试双创仅限于`jest.mock()`和`jest.spyOn()`，stub 和 spy 被视为同一事物，可以互换使用 mock 和 stub。而在`sinon`，则有`sinon.stub()`、`sinon.fake()`、`sinon.mock()`、`sinon.spy()`。

测试替身在帮助工程师编写运行快速的综合测试套件方面非常有价值。然而，误用它们会导致一场维护噩梦。这就是为什么工程师需要了解每一种测试 double 的起伏。工程师经常需要权衡使用哪种技术。

*原发布于*[*https://frendy Guo . me*](https://frendyguo.me/dealing-with-test-doubles/)*。*

*更多内容看* [*说白了就是*](http://plainenglish.io/) *。报名参加我们的* [*免费每周简讯*](http://newsletter.plainenglish.io/) *。在我们的* [*社区不和谐*](https://discord.gg/GtDtUAvyhW) *获得独家获得写作机会和建议。*