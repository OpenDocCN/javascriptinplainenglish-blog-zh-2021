<html>
<head>
<title>TypeScript: How to create Synchronized derived types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:如何创建同步的派生类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-how-to-create-synchronized-derived-types-4bf2371a9eab?source=collection_archive---------4-----------------------#2021-10-07">https://javascript.plainenglish.io/typescript-how-to-create-synchronized-derived-types-4bf2371a9eab?source=collection_archive---------4-----------------------#2021-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4886" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的应用程序的任何部分消耗的数据都不会与应用程序接收的源数据有太大的不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/30c066723e2a7e8fa03251daad065db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i_pTh29pnHtK1Q6I"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@martino_pietropoli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martino Pietropoli</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="4e80" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">数据无论在哪里都是相关的</h2><p id="5520" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">贯穿我们应用程序的数据不能如此互不相关。我们来看一个小例子。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3c66" class="kz la in ly b gy mc md l me mf">// types.ts</span><span id="83c7" class="kz la in ly b gy mg md l me mf">type User = {<br/>  name: string, // "John Doe"<br/>  age: number, // 22<br/>  score: number, // 6.3<br/>}</span></pre><p id="c991" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在我们的应用程序中有一个名为<strong class="jm io"> UserScore </strong>的组件，它获取以下属性。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="4360" class="kz la in ly b gy mc md l me mf">// UserScore.tsx</span><span id="0134" class="kz la in ly b gy mg md l me mf">type UserScore = {<br/>  name: string,<br/>  age: number,<br/>  score: number,<br/>  goals: number,<br/>}</span></pre><p id="0c83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目标数据从何而来？它可能来自另一个API响应。但是现在，我们只是选择使用<strong class="jm io"> <em class="mh">原始类型</em> </strong>来创建这个组件的道具类型。</p><p id="df3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事情进展得很顺利，直到有一天公司选择修改score属性。他们不想存储确切的数字，而是其中的一个。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="db3d" class="kz la in ly b gy mc md l me mf">score: 'S' | 'A+' | 'A' | 'B' | 'C' | 'D' | 'U'</span></pre><p id="652e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们修改用户类型如下。为什么是用户类型？因为这是数据进入我们应用程序的地方，自然也是我们首先更新的地方。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3e13" class="kz la in ly b gy mc md l me mf">type User = {<br/>  name: string, // "John Doe"<br/>  age: number, // 22<br/>  score: Grade, // B<br/>}</span><span id="238d" class="kz la in ly b gy mg md l me mf">type <strong class="ly io">Grade</strong> = 'S' | 'A+' | 'A' | 'B' | 'C' | 'D' | 'U'</span></pre><p id="934c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们引入了一个名为Grade的新类型，并将其与我们的用户类型挂钩。</p><p id="8f7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，由于我们已经在项目中使用了typescript，当我们试图将分数从User type传递到组件UserScore时，将会出现一个错误。</p><p id="a883" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们不小心，为了修复错误，我们可能最终会编写一个<strong class="jm io"> <em class="mh">适配器</em> </strong>来连接UserScore和用户类型，但是从那一点开始会变得更糟糕。</p><blockquote class="mi"><p id="4e39" class="mj mk in bd ml mm mn mo mp mq mr kh dk translated">UI/消费者可以插入到流中，并将类型转换成任何东西。但是流会在整个应用程序中保留这些类型。</p></blockquote><figure class="mt mu mv mw mx kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/5d0304d5fe82f6a4a85d1e56e9c6d742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIu6kjD6UfsLibIAnwV4ZQ.png"/></div></div></figure><h2 id="859c" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">拾取、延伸和组合</h2><p id="5680" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们可以如下更新用户分数。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="a718" class="kz la in ly b gy mc md l me mf">type <strong class="ly io">User</strong> = {<br/>  name: string, // "John Doe"<br/>  age: number, // 22<br/>  score: Grade, // B<br/>}</span><span id="f7cd" class="kz la in ly b gy mg md l me mf">type <strong class="ly io">Grade</strong> = 'S' | 'A+' | 'A' | 'B' | 'C' | 'D' | 'U'</span><span id="41cd" class="kz la in ly b gy mg md l me mf">type <strong class="ly io">Sport</strong> = {<br/>  name: string,<br/>  goals: number<br/>}</span><span id="8291" class="kz la in ly b gy mg md l me mf">type <strong class="ly io">UserScore</strong> = <br/>  <strong class="ly io">Pick</strong>&lt;User, 'name' | 'age' | 'score'&gt; <br/>  &amp; <br/>  <strong class="ly io">Pick</strong>&lt;Sport, 'goals'&gt;</span></pre><p id="9aae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Pick让我们从一个类型中挑选一组属性。因此用户分数保持其与用户和运动的关系。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="d575" class="kz la in ly b gy mc md l me mf">const userScore: <strong class="ly io">UserScore</strong> = {<br/>  name: 'Karthick',<br/>  age: 33,<br/>  score: 'A+',<br/>  goals: 32,<br/>}</span></pre><p id="a272" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这种类型的UI可以做任何它需要满足的事情。但是表示数据流中节点的类型将始终保持与根类型的关系。</p><p id="27d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种严格的类型操作将为开发人员提供良好的体验。在数据流中的任何一点，我们都知道分数是什么类型。</p><p id="ebf1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当发生变化时，这种设置足以改变源类型，并且每个与源类型挂钩的<strong class="jm io">派生类型都将得到更新。现在，适应就成了用户界面/消费者的工作。</strong></p><p id="d712" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们为史诗克隆项目设计我们的类型。</p><h2 id="ce50" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">来源类型</h2><p id="88fe" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们在数据库中存储了<strong class="jm io">游戏</strong>、<strong class="jm io">发行商</strong>和<strong class="jm io">用户游戏</strong>类型。我们从前端代码中那些资源的模式开始。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="21f8" class="kz la in ly b gy mc md l me mf">// Clone start branch:<br/>git clone <strong class="ly io">-b 03-create-types-start</strong> github.com/karthickthankyou/epic-clone</span><span id="77e2" class="kz la in ly b gy mg md l me mf">// Clone final branch:<br/>git clone <strong class="ly io">-b 03-create-types-final</strong> github.com/karthickthankyou/epic-clone</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="eb94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们知道标签、特性、注释、平台和状态有一组预定义的值可供选择。我们将它们保持为联合类型，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ae94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">工会类型像枚举一样工作，但是它有它的好处。当企业决定在上述联合类型中引入更新的<strong class="jm io">元素</strong>时，我们只需更新上述文件，这将相应地塑造依赖类型。</p><p id="3460" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们对源类型满意了，我们就必须专注于创建派生类型。</p><h2 id="8fe3" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">派生类型</h2><p id="ac1e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">请看游戏类型中的一个示例项目。它非常精致</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="32f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的主页上，我们列出了大约40-60款游戏。下面的卡片展示了一个常见的场景，我们只需要游戏中的一些属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/e01a7088ed91b7a64d42f4252b5a8aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WcXzoymGSsqBYPUINov3A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">a section showing games with limited data</figcaption></figure><h2 id="8398" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">挑选</h2><p id="b097" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">因此，我们创建了一个游戏灯类型。我们可以用<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">偏</a>。但是它太宽泛了，我们这样做就失去了所有的必要条件。<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">选择</strong> </a>允许我们将必需的和可选的特性保留为原始类型。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="412b" class="kz la in ly b gy mc md l me mf">Pick&lt;Type, Keys&gt;</span></pre><p id="9b80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们选择显示游戏所需的必要功能，而不是详细的产品页面。类型如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="a984" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">我们可以在联合类型的选项中进行选择吗？</h2><p id="6db2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在我们的项目中有一个场景，我们必须只使用GameGenre联合类型的一部分。它有很多可能的值，但在我们的主屏幕上，我们选择了只包含“动作' | '冒险' | '谜题' | '叙述”的部分。</p><p id="5d02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">列表会随着时间而改变，我们需要一种类型来保护它。首先，我使用泛型创建了一个适用于联合类型的实用程序类型。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="f610" class="kz la in ly b gy mc md l me mf">// Create a subset of union types<br/>export type PickUnion&lt;T, U extends T&gt; = U</span></pre><p id="89c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的实用程序类型获得了两个泛型类型，其中一个是父类型。第二个是父对象的子集。我们使用上面的实用程序类型如下。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="bb0a" class="kz la in ly b gy mc md l me mf">type selectedGenre = PickUnion&lt;GameGenre, 'Action' | 'Adventure' | 'Puzzle' | 'Narration'&gt;</span><span id="cb0c" class="kz la in ly b gy mg md l me mf">// Translates to <strong class="ly io">type selectedGenre = "Action" | "Adventure" | "Puzzle" | "Narration"</strong></span></pre><p id="b5a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript提供了一些<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">实用程序类型</a>,让我们可以自由地派生出我们想要的类型。</p><p id="fadc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将会有许多组件需要不同的属性，但是使用上述技术，我们可以精确地满足组件的需求！</p><p id="aac7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一节见。</p><p id="beff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mh">更多内容看</em> <a class="ae ky" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mh">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>