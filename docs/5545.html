<html>
<head>
<title>The Simple Way to Not Repeat Yourself with React Localization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不重复React本地化的简单方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-simple-way-to-not-repeat-yourself-with-react-localization-f9bba4453c2b?source=collection_archive---------13-----------------------#2021-11-17">https://javascript.plainenglish.io/the-simple-way-to-not-repeat-yourself-with-react-localization-f9bba4453c2b?source=collection_archive---------13-----------------------#2021-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="69f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">本地化经常会导致重复翻译——这里有一个处理它的好方法！</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f80728b0d5b2a47f972fd5857c90055d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z8JGDrAW1vLANJ7s"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Photo by <a class="ae lc" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sigmund</a> on <a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你正在读这篇文章，那么你可能不需要我向你推销<strong class="jp ir">网络应用本地化</strong>的好处。如果你正在构建任何可以在世界范围内访问的东西，那么本地化就不是“生活质量”的提高，而是一项必要的功能<strong class="jp ir">。尽管一个好的用户界面可以不用文字来直观地解释它自己，但是你不需要向你的用户显示文本。</strong></p><h1 id="5bac" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">本地化基础</h1><p id="a8e1" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在我正在做的一个项目中，我们在(恰当命名的)<a class="ae lc" href="https://www.npmjs.com/package/react-localization" rel="noopener ugc nofollow" target="_blank"> react-localization </a>库的帮助下解决了本地化问题。这是一个<strong class="jp ir">超级简单的</strong>库，让你的本地化自动化，不需要太多的思考能力。</p><p id="109a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用他们的例子；</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="8058" class="ml le iq mh b gy mm mn l mo mp">import LocalizedStrings from 'react-localization';<br/><br/>let strings = new LocalizedStrings({<br/> en:{<br/>   how:"How do you want your egg today?",<br/>   boiledEgg:"Boiled egg",<br/>   softBoiledEgg:"Soft-boiled egg",<br/>   choice:"How to choose the egg"<br/> },<br/> it: {<br/>   how:"Come vuoi il tuo uovo oggi?",<br/>   boiledEgg:"Uovo sodo",<br/>   softBoiledEgg:"Uovo alla coque",<br/>   choice:"Come scegliere l'uovo"<br/> }<br/>});</span></pre><p id="c530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建一个<code class="fe mq mr ms mh b">strings</code> LocalizedStrings对象，并在其中定义我们所有的UI字符串，并使用国家代码来提供翻译。现在，如果我们将这个对象导入一个组件并编写:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="40c3" class="ml le iq mh b gy mm mn l mo mp">&lt;p&gt;{strings.how}&lt;/p&gt;</span></pre><p id="a834" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">它会</em> <em class="kl">看起来不同，取决于我们的浏览器是英语还是意大利语。</em></p><p id="af49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恭喜您，您的web应用程序现已本地化。任务完成。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="3a2b" class="ld le iq bd lf lg na li lj lk nb lm ln lo nc lq lr ls nd lu lv lw ne ly lz ma bi translated">嗯，工作完成了一半。</h1><p id="2dc0" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">关于如何<strong class="jp ir">组织您的翻译文件</strong>，需要做出一个决定。这里有两个主要的选择:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4d16418d8a481c7b8ae575bf5f29f6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*JBxGdI-vH3humFPH.png"/></div></figure><ol class=""><li id="f7d3" class="ng nh iq jp b jq jr ju jv jy ni kc nj kg nk kk nl nm nn no bi translated"><strong class="jp ir">集中的字符串文件</strong> (1个文件)<br/>优点<br/> -总是知道在哪里寻找字符串<br/> -将所有文件放在一个文件中被认为是“更整洁”<br/>缺点<br/> -文件长度是一个巨大的问题-想象你有1k个翻译并且你支持8种语言<br/> -很容易在编辑一些语言时出错而忘记其他语言<br/> -我提到文件大小了吗？它真的不漂亮，而且破坏了任何智能IDE自动完成的建议。</li><li id="33fa" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><strong class="jp ir">每个组件/文件夹1个文件</strong> (n个文件)<br/>优点<br/> -只有组件相关的字符串与该文件相关联<br/> -人类实际上是可读的<br/> -可用的IDE自动完成建议<br/>缺点<br/> -你最终会得到很多额外的文件，有些在<br/>中很少-很容易在不同的文件中重复字符串(不是很枯燥)</li></ol><p id="f6aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的项目，我们采用选项2。这似乎进行得很顺利，但是我们构建的UI越多，翻译文件中出现的相同字符串就越多。有些词或短语会出现在用户界面的不同部分，比如“返回”、“提交”、“取消”等等。这些看起来并不是什么大问题，但是它们累积起来就是你在8个不同的地方翻译“电子邮件”这个词。为什么这样不好？<strong class="jp ir">D-R-Y——不要重复自己</strong>(我在之前提到的一个<em class="kl">)。那么答案是什么呢？这是我的方法。</em></p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="4745" class="ld le iq bd lf lg na li lj lk nb lm ln lo nc lq lr ls nd lu lv lw ne ly lz ma bi translated">把常用的单词放在…一个普通的文件里</h1><p id="09aa" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">据我所知，这并不是一个突破性的想法，但确实有效。我们可以识别经常使用的单词并把它们转移到一个单独的“公共”翻译文件中，而不是让单词的副本在不同的翻译文件中浮动。然后我们需要做的就是包装我们的翻译文件，使它们也包含common。这是一个如何做到这一点的示例代码片段；</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="427d" class="ml le iq mh b gy mm mn l mo mp">//commonStrings.ts</span><span id="46fe" class="ml le iq mh b gy nu mn l mo mp">let common = new LocalizedStrings({<br/> en:{<br/>   common: "This is a common string!"<br/> }<br/>});</span><span id="f24e" class="ml le iq mh b gy nu mn l mo mp"><br/>export function includeCommon&lt;Type&gt;(strings: Type): Type &amp; typeof <strong class="mh ir"><em class="kl">commonStrings </em></strong>{<br/>    return {<br/>        ...strings,<br/>        ...<strong class="mh ir"><em class="kl">common<br/>    </em></strong>}<br/>}</span><span id="1c51" class="ml le iq mh b gy nu mn l mo mp">//uniqueStrings.ts</span><span id="e119" class="ml le iq mh b gy nu mn l mo mp">let uniqueStrings = new LocalizedStrings({<br/> en:{ <br/>   unique: "This is a unique string!"<br/> }<br/>});</span><span id="3db5" class="ml le iq mh b gy nu mn l mo mp">export default includeCommon&lt;typeof uniqueStrings&gt;(uniqueStrings);</span><span id="5f0d" class="ml le iq mh b gy nu mn l mo mp">//TestComponent.tsx</span><span id="19bf" class="ml le iq mh b gy nu mn l mo mp">import strings from "./uniqueStrings"</span><span id="a592" class="ml le iq mh b gy nu mn l mo mp">console.log(strings.common) ---&gt; "This is a common string!"<br/>console.log(strings.unique) ---&gt; "This is a unique string!"</span></pre><p id="5035" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望您可以从底部的2个控制台日志中看到，包装我们的</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e570391a4e63507505b1623269683ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*XlH2XuYtdxzSYAd4.png"/></div></figure><p id="ee99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用common的特定翻译使我们能够访问我们的常用词库。这意味着不再有重复和浪费时间翻译相同的东西！这也意味着我们可以使用IDE auto completes来查看我们是否需要翻译一些东西。例如，如果我们正在创建一个具有字符串“Enter”的按钮，我们可以编写<code class="fe mq mr ms mh b">strings.e..</code>并查看IDE是否试图自动完成到<code class="fe mq mr ms mh b">strings.enter</code>的操作。如果是的话，我们就可以使用这个字符串了。如果没有，那么我们知道我们实际上需要花时间去翻译。不管怎样，我们都做出了正确的决定，这是一个生产力双赢的局面。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="5e18" class="ld le iq bd lf lg na li lj lk nb lm ln lo nc lq lr ls nd lu lv lw ne ly lz ma bi translated">包扎</h1><p id="da29" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">本地化对于web开发人员来说是一个重要的概念，谢天谢地，像react-localization这样的包使得实现起来很简单。然而，最简单的实现并不总是最好的，如果你在开始时投入一点额外的时间，并以一种明智的方式设置它，未来的你会感谢你自己。在配置上花一点时间，在重复上就会节省很多时间。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="614f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您喜欢这篇文章或觉得它有用，请随意操作。或者，你可以在Medium  <a class="ae lc" href="https://jamesmbrightman.medium.com/membership" rel="noopener"> <em class="kl">这里</em> </a> <em class="kl">支持我或者给我买一杯</em> <a class="ae lc" href="https://ko-fi.com/jamesbrightman" rel="noopener ugc nofollow" target="_blank"> <em class="kl">咖啡</em> </a> <em class="kl">！非常感谢所有的支持。</em></p><p id="9cfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">更多内容请看</em><a class="ae lc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">plain English . io</em></strong></a></p></div></div>    
</body>
</html>