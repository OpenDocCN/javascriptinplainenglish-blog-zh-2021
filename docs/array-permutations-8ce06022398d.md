# 软件开发人员面试问题:阵列排列

> 原文：<https://javascript.plainenglish.io/array-permutations-8ce06022398d?source=collection_archive---------15----------------------->

![](img/51fb3612ad1323a2845867161a798847.png)

你可能已经熟悉了一个处理输入排列的流行的技术面试问题。如果您不是，这个问题通常以下列方式出现:

***“给定一个由唯一字符组成的字符串，创建一个函数，查找并返回该字符串所有可能的排列作为一个数组。”***

在本文中，我将关注这个问题的一个稍微不同的版本(大约中等难度)，其中给定的输入是不同整数的**数组**，所需的输出是任意顺序的子数组的**单个数组(每个可能的排列一个)。你可以在这里找到这个特殊问题的例子。**

我发现这个问题很有趣，因为它的解决方案可以包括迭代和递归。让我们来看看解决这个问题的一种可能的方法，如下所示。

第一步是创建一个空数组( **result** )，它将存储排列和我们将在算法结束时返回的排列。接下来，我们必须通过搜索不同整数的给定数组(**num**)来找到我们的排列。如您所见，这个特殊的解决方案包括在我们的原始函数中编写另一个函数。我们通过选择 ES6 路线并使用 **const** 来实现这一点，以便将事情保持在局部范围内(不像我们最初的函数是用 **var** 声明的)。我们的内部函数接受输入数组和一个空数组。在我们开始迭代之前，我们考虑数组为空的潜在边缘情况，并将空数组推入我们在第一步中创建的第一个空数组。现在，为什么我们需要一个空数组里面的空数组呢？因为我们必须返回一个数组，该数组包含一个(或多个)具有每种可能排列的数组。

接下来，我们为循环实现一个**。从输入数组中的第一个数字开始，我们递增 1，直到遍历完所有的数字。我们初始化一个局部变量( **current** )，它的值是输入数组的一个**副本**，以便在我们稍后操作它时表示数组的一个当前版本。然后我们初始化另一个变量( **next** )，它的值是一个新数组，包含我们当前所在的数字(来自 O.G .输入数组)和下一个数字——即第一个和第二个数字。这两个数字已经从**当前**中取出(因为拼接是一个*到位*操作)并组成它们自己的小数组。**

下一步是递归调用。我们再次做整个过程，但是这一次我们不看输入数组，而是看当前**和**T3 的副本，而不是使用最初空的数组 **n、**，接下来我们用**连接 **n** 。一旦我们完成了，我们回到我们的外部函数，进入全局范围，在这里我们进行另一个递归调用(但是这次是在外部函数中！)并返回**结果**数组，该数组包含所有可能排列的数组。******

## 结论

我希望这个解决方案能加深你对这个有点棘手的问题的理解。记住运算的范围是很重要的，尤其是在处理递归的时候。

*更多内容请看*[***plain English . io***](https://plainenglish.io/)